import { r as ue, R as n } from "./storybook-index-45401197.es.js";
import { v as Tp, a as wg, i as Ap, b as Lp, g as Cg } from "./storybook-isSolr-cb863e7a.es.js";
import { _ as qr, p as Pp, F as Li, J as Kr, a as qt, K as Np, b as Nc, N as rr, t as Wu, O as nl, Q as Md, R as Rp, S as er, U as Dp, V as Tg, W as Ag, l as _p, X as vr, u as ll, P as Lg, d as Pg, e as tl, h as Op, g as Fp, j as Ng, y as Rg, B as Dg, Y as Jn, r as sl, Z as Zu, $ as Cs, H as _g, C as Mp, m as Og, M as wm, E as Fg, n as Mg, o as Cm, L as zg, G as Bg, D as Tm, x as Am, z as Lm, I as zp, A as $g } from "./storybook-InputToggle-37e3ece9.es.js";
import { L as mf, u as Ig, p as Hg, s as Vg, a as Wg, c as jg } from "./storybook-coveUpdateWorker-91c2d978.es.js";
import { B as Rc } from "./storybook-Button-d74e310e.es.js";
import { p as Ug, P as $e } from "./storybook-index-43433e35.es.js";
import { d as Kg } from "./storybook-debounce-cc216a80.es.js";
import { a as Yg } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { P as Bp } from "./storybook-papaparse.min-b07ddc33.es.js";
import { H as Mi, T as Gg } from "./storybook-index-e5bf02db.es.js";
import { _ as gn } from "./storybook-extends-70f3d2a3.es.js";
import { t as Xg, c as Rn, d as qf, e as ss, g as Pi, a as qg, f as zi, h as ya, L as $p, S as Ip, M as zd, D as Zg } from "./storybook-DataTable-c2cc0eaa.es.js";
import { _ as lt } from "./storybook-lodash-a4231e1c.es.js";
import { E as $r, L as Qg } from "./storybook-Loading-f180d060.es.js";
import { s as ms, t as Pm, a as Nm, b as Rm, d as Rs, B as Lr, c as jn, C as Jg } from "./storybook-Circle-f595886d.es.js";
import { q as Dc, t as ev, u as Dm, v as Hp, w as tv, x as nv, y as rv, z as Vp, A as av, G as at, g as Dn, B as iv } from "./storybook-Group-eff0b1b9.es.js";
import { R as ov } from "./storybook-index-633d712d.es.js";
import { T as vt } from "./storybook-Text-c19e6344.es.js";
import { t as _m, m as Bd, f as Om, d as Tu, a as Au, b as Lu, n as Wp, o as lv, p as jp, c as Fm, e as Mm } from "./storybook-year-24bd1dc7.es.js";
import { e as Wa, a as zn, b as Bn, c as $n, d as In, A as Bi, D as zm } from "./storybook-DataTransform-0947aeee.es.js";
import { a as Xe, S as Bm } from "./storybook-Icon-4f5978ba.es.js";
import { B as Up } from "./storybook-BlurStrokeText-adc27352.es.js";
import { T as se } from "./storybook-Tooltip-4102bd69.es.js";
import { T as je, S as yt, C as Je } from "./storybook-Inputs-b80d0cf3.es.js";
import { M as yf } from "./storybook-MultiSelect-d587cce3.es.js";
import { h as gf, i as vf, j as sv, f as Ni, F as Kp, k as uv } from "./storybook-Filters-103ea5c1.es.js";
import { I as ja } from "./storybook-InputSelect-20478396.es.js";
import { A as Pu } from "./storybook-Accordion-2501c7d9.es.js";
import { n as Yp } from "./storybook-numberFromString-24623c03.es.js";
import { c as Gp } from "./storybook-cacheBustingString-7a3dd9ba.es.js";
function $m(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Xp(e) {
  let t = e, r = e;
  e.length === 1 && (t = (d, c) => e(d) - c, r = cv(e));
  function a(d, c, s, p) {
    for (s == null && (s = 0), p == null && (p = d.length); s < p; ) {
      const m = s + p >>> 1;
      r(d[m], c) < 0 ? s = m + 1 : p = m;
    }
    return s;
  }
  function i(d, c, s, p) {
    for (s == null && (s = 0), p == null && (p = d.length); s < p; ) {
      const m = s + p >>> 1;
      r(d[m], c) > 0 ? p = m : s = m + 1;
    }
    return s;
  }
  function o(d, c, s, p) {
    s == null && (s = 0), p == null && (p = d.length);
    const m = a(d, c, s, p - 1);
    return m > s && t(d[m - 1], c) > -t(d[m], c) ? m - 1 : m;
  }
  return { left: a, center: o, right: i };
}
function cv(e) {
  return (t, r) => $m(e(t), r);
}
function* dv(e, t) {
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && (yield r);
  else {
    let r = -1;
    for (let a of e)
      (a = t(a, ++r, e)) != null && (a = +a) >= a && (yield a);
  }
}
function fv(e, t) {
  let r = 0, a, i = 0, o = 0;
  if (t === void 0)
    for (let d of e)
      d != null && (d = +d) >= d && (a = d - i, i += a / ++r, o += a * (d - i));
  else {
    let d = -1;
    for (let c of e)
      (c = t(c, ++d, e)) != null && (c = +c) >= c && (a = c - i, i += a / ++r, o += a * (c - i));
  }
  if (r > 1)
    return o / (r - 1);
}
function pv(e, t) {
  const r = fv(e, t);
  return r && Math.sqrt(r);
}
function Qu(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r < a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function xf(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r > a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function Im(e, t, r = 0, a = e.length - 1, i = $m) {
  for (; a > r; ) {
    if (a - r > 600) {
      const s = a - r + 1, p = t - r + 1, m = Math.log(s), y = 0.5 * Math.exp(2 * m / 3), x = 0.5 * Math.sqrt(m * y * (s - y) / s) * (p - s / 2 < 0 ? -1 : 1), T = Math.max(r, Math.floor(t - p * y / s + x)), S = Math.min(a, Math.floor(t + (s - p) * y / s + x));
      Im(e, t, T, S, i);
    }
    const o = e[t];
    let d = r, c = a;
    for (us(e, r, t), i(e[a], o) > 0 && us(e, r, a); d < c; ) {
      for (us(e, d, c), ++d, --c; i(e[d], o) < 0; )
        ++d;
      for (; i(e[c], o) > 0; )
        --c;
    }
    i(e[r], o) === 0 ? us(e, r, c) : (++c, us(e, c, a)), c <= t && (r = c + 1), t <= c && (a = c - 1);
  }
  return e;
}
function us(e, t, r) {
  const a = e[t];
  e[t] = e[r], e[r] = a;
}
function bf(e, t, r) {
  if (e = Float64Array.from(dv(e, r)), !!(a = e.length)) {
    if ((t = +t) <= 0 || a < 2)
      return xf(e);
    if (t >= 1)
      return Qu(e);
    var a, i = (a - 1) * t, o = Math.floor(i), d = Qu(Im(e, o).subarray(0, o + 1)), c = xf(e.subarray(o + 1));
    return d + (c - d) * (i - o);
  }
}
function hv(e, t) {
  let r = 0, a = 0;
  if (t === void 0)
    for (let i of e)
      i != null && (i = +i) >= i && (++r, a += i);
  else {
    let i = -1;
    for (let o of e)
      (o = t(o, ++i, e)) != null && (o = +o) >= o && (++r, a += o);
  }
  if (r)
    return a / r;
}
function Hm(e, t) {
  return bf(e, 0.5, t);
}
class qp extends Map {
  constructor(t, r = gv) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), t != null)
      for (const [a, i] of t)
        this.set(a, i);
  }
  get(t) {
    return super.get(Zp(this, t));
  }
  has(t) {
    return super.has(Zp(this, t));
  }
  set(t, r) {
    return super.set(mv(this, t), r);
  }
  delete(t) {
    return super.delete(yv(this, t));
  }
}
function Zp({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) ? e.get(a) : r;
}
function mv({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) ? e.get(a) : (e.set(a, r), r);
}
function yv({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) && (r = e.get(a), e.delete(a)), r;
}
function gv(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function vv(e, t, r) {
  e = +e, t = +t, r = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +r;
  for (var a = -1, i = Math.max(0, Math.ceil((t - e) / r)) | 0, o = new Array(i); ++a < i; )
    o[a] = e + a * r;
  return o;
}
const Qp = Symbol("implicit");
function Zf() {
  var e = new qp(), t = [], r = [], a = Qp;
  function i(o) {
    let d = e.get(o);
    if (d === void 0) {
      if (a !== Qp)
        return a;
      e.set(o, d = t.push(o) - 1);
    }
    return r[d % r.length];
  }
  return i.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new qp();
    for (const d of o)
      e.has(d) || e.set(d, t.push(d) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (r = Array.from(o), i) : r.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (a = o, i) : a;
  }, i.copy = function() {
    return Zf(t, r).unknown(a);
  }, Dc.apply(i, arguments), i;
}
function Qf() {
  var e = Zf().unknown(void 0), t = e.domain, r = e.range, a = 0, i = 1, o, d, c = !1, s = 0, p = 0, m = 0.5;
  delete e.unknown;
  function y() {
    var x = t().length, T = i < a, S = T ? i : a, A = T ? a : i;
    o = (A - S) / Math.max(1, x - s + p * 2), c && (o = Math.floor(o)), S += (A - S - o * (x - s)) * m, d = o * (1 - s), c && (S = Math.round(S), d = Math.round(d));
    var E = vv(x).map(function(b) {
      return S + o * b;
    });
    return r(T ? E.reverse() : E);
  }
  return e.domain = function(x) {
    return arguments.length ? (t(x), y()) : t();
  }, e.range = function(x) {
    return arguments.length ? ([a, i] = x, a = +a, i = +i, y()) : [a, i];
  }, e.rangeRound = function(x) {
    return [a, i] = x, a = +a, i = +i, c = !0, y();
  }, e.bandwidth = function() {
    return d;
  }, e.step = function() {
    return o;
  }, e.round = function(x) {
    return arguments.length ? (c = !!x, y()) : c;
  }, e.padding = function(x) {
    return arguments.length ? (s = Math.min(1, p = +x), y()) : s;
  }, e.paddingInner = function(x) {
    return arguments.length ? (s = Math.min(1, x), y()) : s;
  }, e.paddingOuter = function(x) {
    return arguments.length ? (p = +x, y()) : p;
  }, e.align = function(x) {
    return arguments.length ? (m = Math.max(0, Math.min(1, x)), y()) : m;
  }, e.copy = function() {
    return Qf(t(), [a, i]).round(c).paddingInner(s).paddingOuter(p).align(m);
  }, Dc.apply(y(), arguments);
}
function Vm(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return Vm(t());
  }, e;
}
function xv() {
  return Vm(Qf.apply(null, arguments).paddingInner(1));
}
function Wm(e, t) {
  e = e.slice();
  var r = 0, a = e.length - 1, i = e[r], o = e[a], d;
  return o < i && (d = r, r = a, a = d, d = i, i = o, o = d), e[r] = t.floor(i), e[a] = t.ceil(o), e;
}
function Jp(e) {
  return Math.log(e);
}
function eh(e) {
  return Math.exp(e);
}
function bv(e) {
  return -Math.log(-e);
}
function Ev(e) {
  return -Math.exp(-e);
}
function Sv(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function kv(e) {
  return e === 10 ? Sv : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function wv(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function th(e) {
  return (t, r) => -e(-t, r);
}
function Cv(e) {
  const t = e(Jp, eh), r = t.domain;
  let a = 10, i, o;
  function d() {
    return i = wv(a), o = kv(a), r()[0] < 0 ? (i = th(i), o = th(o), e(bv, Ev)) : e(Jp, eh), t;
  }
  return t.base = function(c) {
    return arguments.length ? (a = +c, d()) : a;
  }, t.domain = function(c) {
    return arguments.length ? (r(c), d()) : r();
  }, t.ticks = (c) => {
    const s = r();
    let p = s[0], m = s[s.length - 1];
    const y = m < p;
    y && ([p, m] = [m, p]);
    let x = i(p), T = i(m), S, A;
    const E = c == null ? 10 : +c;
    let b = [];
    if (!(a % 1) && T - x < E) {
      if (x = Math.floor(x), T = Math.ceil(T), p > 0) {
        for (; x <= T; ++x)
          for (S = 1; S < a; ++S)
            if (A = x < 0 ? S / o(-x) : S * o(x), !(A < p)) {
              if (A > m)
                break;
              b.push(A);
            }
      } else
        for (; x <= T; ++x)
          for (S = a - 1; S >= 1; --S)
            if (A = x > 0 ? S / o(-x) : S * o(x), !(A < p)) {
              if (A > m)
                break;
              b.push(A);
            }
      b.length * 2 < E && (b = Hp(p, m, E));
    } else
      b = Hp(x, T, Math.min(T - x, E)).map(o);
    return y ? b.reverse() : b;
  }, t.tickFormat = (c, s) => {
    if (c == null && (c = 10), s == null && (s = a === 10 ? "s" : ","), typeof s != "function" && (!(a % 1) && (s = tv(s)).precision == null && (s.trim = !0), s = nv(s)), c === 1 / 0)
      return s;
    const p = Math.max(1, a * c / t.ticks().length);
    return (m) => {
      let y = m / o(Math.round(i(m)));
      return y * a < a - 0.5 && (y *= a), y <= p ? s(m) : "";
    };
  }, t.nice = () => r(Wm(r(), {
    floor: (c) => o(Math.floor(i(c))),
    ceil: (c) => o(Math.ceil(i(c)))
  })), t;
}
function jm() {
  const e = Cv(ev()).domain([1, 10]);
  return e.copy = () => Dm(e, jm()).base(e.base()), Dc.apply(e, arguments), e;
}
const Ju = _m(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Ju.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? _m((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, r) => {
  t.setTime(+t + r * e);
}, (t, r) => (r - t) / e) : Ju);
Ju.range;
function Tv(e, t, r, a, i, o) {
  const d = [
    [ms, 1, Tu],
    [ms, 5, 5 * Tu],
    [ms, 15, 15 * Tu],
    [ms, 30, 30 * Tu],
    [o, 1, Au],
    [o, 5, 5 * Au],
    [o, 15, 15 * Au],
    [o, 30, 30 * Au],
    [i, 1, Lu],
    [i, 3, 3 * Lu],
    [i, 6, 6 * Lu],
    [i, 12, 12 * Lu],
    [a, 1, Wp],
    [a, 2, 2 * Wp],
    [r, 1, lv],
    [t, 1, jp],
    [t, 3, 3 * jp],
    [e, 1, Bd]
  ];
  function c(p, m, y) {
    const x = m < p;
    x && ([p, m] = [m, p]);
    const T = y && typeof y.range == "function" ? y : s(p, m, y), S = T ? T.range(p, +m + 1) : [];
    return x ? S.reverse() : S;
  }
  function s(p, m, y) {
    const x = Math.abs(m - p) / y, T = rv(([, , E]) => E).right(d, x);
    if (T === d.length)
      return e.every(Vp(p / Bd, m / Bd, y));
    if (T === 0)
      return Ju.every(Math.max(Vp(p, m, y), 1));
    const [S, A] = d[x / d[T - 1][2] < d[T][2] / x ? T - 1 : T];
    return S.every(A);
  }
  return [c, s];
}
const [Av, Lv] = Tv(Om, Rm, Mm, Fm, Nm, Pm);
function Pv(e) {
  return new Date(e);
}
function Nv(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Um(e, t, r, a, i, o, d, c, s, p) {
  var m = av(), y = m.invert, x = m.domain, T = p(".%L"), S = p(":%S"), A = p("%I:%M"), E = p("%I %p"), b = p("%a %d"), v = p("%b %d"), N = p("%B"), C = p("%Y");
  function R(_) {
    return (s(_) < _ ? T : c(_) < _ ? S : d(_) < _ ? A : o(_) < _ ? E : a(_) < _ ? i(_) < _ ? b : v : r(_) < _ ? N : C)(_);
  }
  return m.invert = function(_) {
    return new Date(y(_));
  }, m.domain = function(_) {
    return arguments.length ? x(Array.from(_, Nv)) : x().map(Pv);
  }, m.ticks = function(_) {
    var U = x();
    return e(U[0], U[U.length - 1], _ ?? 10);
  }, m.tickFormat = function(_, U) {
    return U == null ? R : p(U);
  }, m.nice = function(_) {
    var U = x();
    return (!_ || typeof _.range != "function") && (_ = t(U[0], U[U.length - 1], _ ?? 10)), _ ? x(Wm(U, _)) : m;
  }, m.copy = function() {
    return Dm(m, Um(e, t, r, a, i, o, d, c, s, p));
  }, m;
}
function Km() {
  return Dc.apply(Um(Av, Lv, Om, Rm, Mm, Fm, Nm, Pm, ms, Xg).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var Rv = Rs("domain", "range", "reverse", "align", "padding", "round");
function ec(e) {
  return Rv(Qf(), e);
}
var Dv = Rs("domain", "range", "reverse", "align", "padding", "round");
function rl(e) {
  return Dv(xv(), e);
}
var _v = Rs("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function Ov(e) {
  return _v(Km(), e);
}
var Fv = Rs("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function tc(e) {
  return Fv(jm(), e);
}
var Mv = Rs("domain", "range", "reverse", "unknown");
function Ii(e) {
  return Mv(Zf(), e);
}
function zv(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function Ym(e, t) {
  var r = e;
  return "ticks" in r ? r.ticks(t) : r.domain().filter(function(a, i, o) {
    return t == null || o.length <= t || i % Math.round((o.length - 1) / t) === 0;
  });
}
function Bv(e) {
  return e == null ? void 0 : e.toString();
}
var Hi = [], $v = function() {
  return Hi.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Iv = function() {
  return Hi.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, nh = "ResizeObserver loop completed with undelivered notifications.", Hv = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: nh
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = nh), window.dispatchEvent(e);
}, Ts;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Ts || (Ts = {}));
var Vi = function(e) {
  return Object.freeze(e);
}, Gm = function() {
  function e(t, r) {
    this.inlineSize = t, this.blockSize = r, Vi(this);
  }
  return e;
}(), Xm = function() {
  function e(t, r, a, i) {
    return this.x = t, this.y = r, this.width = a, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Vi(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, r = t.x, a = t.y, i = t.top, o = t.right, d = t.bottom, c = t.left, s = t.width, p = t.height;
    return { x: r, y: a, top: i, right: o, bottom: d, left: c, width: s, height: p };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Jf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, qm = function(e) {
  if (Jf(e)) {
    var t = e.getBBox(), r = t.width, a = t.height;
    return !r && !a;
  }
  var i = e, o = i.offsetWidth, d = i.offsetHeight;
  return !(o || d || e.getClientRects().length);
}, rh = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var r = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(r && e instanceof r.Element);
}, Vv = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ys = typeof window < "u" ? window : {}, Nu = /* @__PURE__ */ new WeakMap(), ah = /auto|scroll/, Wv = /^tb|vertical/, jv = /msie|trident/i.test(ys.navigator && ys.navigator.userAgent), Yr = function(e) {
  return parseFloat(e || "0");
}, il = function(e, t, r) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), r === void 0 && (r = !1), new Gm((r ? t : e) || 0, (r ? e : t) || 0);
}, ih = Vi({
  devicePixelContentBoxSize: il(),
  borderBoxSize: il(),
  contentBoxSize: il(),
  contentRect: new Xm(0, 0, 0, 0)
}), Zm = function(e, t) {
  if (t === void 0 && (t = !1), Nu.has(e) && !t)
    return Nu.get(e);
  if (qm(e))
    return Nu.set(e, ih), ih;
  var r = getComputedStyle(e), a = Jf(e) && e.ownerSVGElement && e.getBBox(), i = !jv && r.boxSizing === "border-box", o = Wv.test(r.writingMode || ""), d = !a && ah.test(r.overflowY || ""), c = !a && ah.test(r.overflowX || ""), s = a ? 0 : Yr(r.paddingTop), p = a ? 0 : Yr(r.paddingRight), m = a ? 0 : Yr(r.paddingBottom), y = a ? 0 : Yr(r.paddingLeft), x = a ? 0 : Yr(r.borderTopWidth), T = a ? 0 : Yr(r.borderRightWidth), S = a ? 0 : Yr(r.borderBottomWidth), A = a ? 0 : Yr(r.borderLeftWidth), E = y + p, b = s + m, v = A + T, N = x + S, C = c ? e.offsetHeight - N - e.clientHeight : 0, R = d ? e.offsetWidth - v - e.clientWidth : 0, _ = i ? E + v : 0, U = i ? b + N : 0, j = a ? a.width : Yr(r.width) - _ - R, te = a ? a.height : Yr(r.height) - U - C, Q = j + E + R + v, $ = te + b + C + N, J = Vi({
    devicePixelContentBoxSize: il(Math.round(j * devicePixelRatio), Math.round(te * devicePixelRatio), o),
    borderBoxSize: il(Q, $, o),
    contentBoxSize: il(j, te, o),
    contentRect: new Xm(y, s, j, te)
  });
  return Nu.set(e, J), J;
}, Qm = function(e, t, r) {
  var a = Zm(e, r), i = a.borderBoxSize, o = a.contentBoxSize, d = a.devicePixelContentBoxSize;
  switch (t) {
    case Ts.DEVICE_PIXEL_CONTENT_BOX:
      return d;
    case Ts.BORDER_BOX:
      return i;
    default:
      return o;
  }
}, Jm = function() {
  function e(t) {
    var r = Zm(t);
    this.target = t, this.contentRect = r.contentRect, this.borderBoxSize = Vi([r.borderBoxSize]), this.contentBoxSize = Vi([r.contentBoxSize]), this.devicePixelContentBoxSize = Vi([r.devicePixelContentBoxSize]);
  }
  return e;
}(), ey = function(e) {
  if (qm(e))
    return 1 / 0;
  for (var t = 0, r = e.parentNode; r; )
    t += 1, r = r.parentNode;
  return t;
}, Uv = function() {
  var e = 1 / 0, t = [];
  Hi.forEach(function(d) {
    if (d.activeTargets.length !== 0) {
      var c = [];
      d.activeTargets.forEach(function(p) {
        var m = new Jm(p.target), y = ey(p.target);
        c.push(m), p.lastReportedSize = Qm(p.target, p.observedBox), y < e && (e = y);
      }), t.push(function() {
        d.callback.call(d.observer, c, d.observer);
      }), d.activeTargets.splice(0, d.activeTargets.length);
    }
  });
  for (var r = 0, a = t; r < a.length; r++) {
    var i = a[r];
    i();
  }
  return e;
}, oh = function(e) {
  Hi.forEach(function(r) {
    r.activeTargets.splice(0, r.activeTargets.length), r.skippedTargets.splice(0, r.skippedTargets.length), r.observationTargets.forEach(function(i) {
      i.isActive() && (ey(i.target) > e ? r.activeTargets.push(i) : r.skippedTargets.push(i));
    });
  });
}, Kv = function() {
  var e = 0;
  for (oh(e); $v(); )
    e = Uv(), oh(e);
  return Iv() && Hv(), e > 0;
}, $d, ty = [], Yv = function() {
  return ty.splice(0).forEach(function(e) {
    return e();
  });
}, Gv = function(e) {
  if (!$d) {
    var t = 0, r = document.createTextNode(""), a = { characterData: !0 };
    new MutationObserver(function() {
      return Yv();
    }).observe(r, a), $d = function() {
      r.textContent = "".concat(t ? t-- : t++);
    };
  }
  ty.push(e), $d();
}, Xv = function(e) {
  Gv(function() {
    requestAnimationFrame(e);
  });
}, ju = 0, qv = function() {
  return !!ju;
}, Zv = 250, Qv = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, lh = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], sh = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Id = !1, Jv = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var r = this;
    if (t === void 0 && (t = Zv), !Id) {
      Id = !0;
      var a = sh(t);
      Xv(function() {
        var i = !1;
        try {
          i = Kv();
        } finally {
          if (Id = !1, t = a - sh(), !qv())
            return;
          i ? r.run(1e3) : t > 0 ? r.run(t) : r.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, r = function() {
      return t.observer && t.observer.observe(document.body, Qv);
    };
    document.body ? r() : ys.addEventListener("DOMContentLoaded", r);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), lh.forEach(function(r) {
      return ys.addEventListener(r, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), lh.forEach(function(r) {
      return ys.removeEventListener(r, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), Ef = new Jv(), uh = function(e) {
  !ju && e > 0 && Ef.start(), ju += e, !ju && Ef.stop();
}, ex = function(e) {
  return !Jf(e) && !Vv(e) && getComputedStyle(e).display === "inline";
}, tx = function() {
  function e(t, r) {
    this.target = t, this.observedBox = r || Ts.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Qm(this.target, this.observedBox, !0);
    return ex(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), nx = function() {
  function e(t, r) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = r;
  }
  return e;
}(), Ru = /* @__PURE__ */ new WeakMap(), ch = function(e, t) {
  for (var r = 0; r < e.length; r += 1)
    if (e[r].target === t)
      return r;
  return -1;
}, Du = function() {
  function e() {
  }
  return e.connect = function(t, r) {
    var a = new nx(t, r);
    Ru.set(t, a);
  }, e.observe = function(t, r, a) {
    var i = Ru.get(t), o = i.observationTargets.length === 0;
    ch(i.observationTargets, r) < 0 && (o && Hi.push(i), i.observationTargets.push(new tx(r, a && a.box)), uh(1), Ef.schedule());
  }, e.unobserve = function(t, r) {
    var a = Ru.get(t), i = ch(a.observationTargets, r), o = a.observationTargets.length === 1;
    i >= 0 && (o && Hi.splice(Hi.indexOf(a), 1), a.observationTargets.splice(i, 1), uh(-1));
  }, e.disconnect = function(t) {
    var r = this, a = Ru.get(t);
    a.observationTargets.slice().forEach(function(i) {
      return r.unobserve(t, i.target);
    }), a.activeTargets.splice(0, a.activeTargets.length);
  }, e;
}(), rx = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Du.connect(this, t);
  }
  return e.prototype.observe = function(t, r) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!rh(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Du.observe(this, t, r);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!rh(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Du.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Du.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const ax = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: rx,
  ResizeObserverEntry: Jm,
  ResizeObserverSize: Gm
}, Symbol.toStringTag, { value: "Module" })), ix = /* @__PURE__ */ Yg(ax);
var Xo = ay, Ba = ry(Ug), ox = ry(Kg), qo = ux(ue), lx = ix, sx = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function ny(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (ny = function(i) {
    return i ? r : t;
  })(e);
}
function ux(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var r = ny(t);
  if (r && r.has(e))
    return r.get(e);
  var a = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var d = i ? Object.getOwnPropertyDescriptor(e, o) : null;
      d && (d.get || d.set) ? Object.defineProperty(a, o, d) : a[o] = e[o];
    }
  return a.default = e, r && r.set(e, a), a;
}
function ry(e) {
  return e && e.__esModule ? e : { default: e };
}
function nc() {
  return nc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, nc.apply(this, arguments);
}
function cx(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var dx = [];
function ay(e) {
  var t = e.className, r = e.children, a = e.debounceTime, i = a === void 0 ? 300 : a, o = e.ignoreDimensions, d = o === void 0 ? dx : o, c = e.parentSizeStyles, s = c === void 0 ? {
    width: "100%",
    height: "100%"
  } : c, p = e.enableDebounceLeadingCall, m = p === void 0 ? !0 : p, y = cx(e, sx), x = (0, qo.useRef)(null), T = (0, qo.useRef)(0), S = (0, qo.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), A = S[0], E = S[1], b = (0, qo.useMemo)(function() {
    var v = Array.isArray(d) ? d : [d];
    return (0, ox.default)(function(N) {
      E(function(C) {
        var R = Object.keys(C), _ = R.filter(function(j) {
          return C[j] !== N[j];
        }), U = _.every(function(j) {
          return v.includes(j);
        });
        return U ? C : N;
      });
    }, i, {
      leading: m
    });
  }, [i, m, d]);
  return (0, qo.useEffect)(function() {
    var v = new lx.ResizeObserver(function(N) {
      N === void 0 && (N = []), N.forEach(function(C) {
        var R = C.contentRect, _ = R.left, U = R.top, j = R.width, te = R.height;
        T.current = window.requestAnimationFrame(function() {
          b({
            width: j,
            height: te,
            top: U,
            left: _
          });
        });
      });
    });
    return x.current && v.observe(x.current), function() {
      window.cancelAnimationFrame(T.current), v.disconnect(), b != null && b.cancel && b.cancel();
    };
  }, [b]), /* @__PURE__ */ qo.default.createElement("div", nc({
    style: s,
    ref: x,
    className: t
  }, y), r(nc({}, A, {
    ref: x.current,
    resize: b
  })));
}
ay.propTypes = {
  className: Ba.default.string,
  debounceTime: Ba.default.number,
  enableDebounceLeadingCall: Ba.default.bool,
  ignoreDimensions: Ba.default.oneOfType([Ba.default.any, Ba.default.arrayOf(Ba.default.any)]),
  children: Ba.default.func.isRequired
};
var Hd = /* @__PURE__ */ new Date(), Vd = /* @__PURE__ */ new Date();
function ga(e, t, r, a) {
  function i(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return i.floor = function(o) {
    return e(o = /* @__PURE__ */ new Date(+o)), o;
  }, i.ceil = function(o) {
    return e(o = new Date(o - 1)), t(o, 1), e(o), o;
  }, i.round = function(o) {
    var d = i(o), c = i.ceil(o);
    return o - d < c - o ? d : c;
  }, i.offset = function(o, d) {
    return t(o = /* @__PURE__ */ new Date(+o), d == null ? 1 : Math.floor(d)), o;
  }, i.range = function(o, d, c) {
    var s = [], p;
    if (o = i.ceil(o), c = c == null ? 1 : Math.floor(c), !(o < d) || !(c > 0))
      return s;
    do
      s.push(p = /* @__PURE__ */ new Date(+o)), t(o, c), e(o);
    while (p < o && o < d);
    return s;
  }, i.filter = function(o) {
    return ga(function(d) {
      if (d >= d)
        for (; e(d), !o(d); )
          d.setTime(d - 1);
    }, function(d, c) {
      if (d >= d)
        if (c < 0)
          for (; ++c <= 0; )
            for (; t(d, -1), !o(d); )
              ;
        else
          for (; --c >= 0; )
            for (; t(d, 1), !o(d); )
              ;
    });
  }, r && (i.count = function(o, d) {
    return Hd.setTime(+o), Vd.setTime(+d), e(Hd), e(Vd), Math.floor(r(Hd, Vd));
  }, i.every = function(o) {
    return o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(a ? function(d) {
      return a(d) % o === 0;
    } : function(d) {
      return i.count(0, d) % o === 0;
    }) : i;
  }), i;
}
const fx = 1e3, ep = fx * 60, px = ep * 60, tp = px * 24, iy = tp * 7;
var oy = ga(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * ep) / tp,
  (e) => e.getDate() - 1
);
const ly = oy;
oy.range;
function Gi(e) {
  return ga(function(t) {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setDate(t.getDate() + r * 7);
  }, function(t, r) {
    return (r - t - (r.getTimezoneOffset() - t.getTimezoneOffset()) * ep) / iy;
  });
}
var sy = Gi(0), rc = Gi(1), hx = Gi(2), mx = Gi(3), ul = Gi(4), yx = Gi(5), gx = Gi(6);
sy.range;
rc.range;
hx.range;
mx.range;
ul.range;
yx.range;
gx.range;
var np = ga(function(e) {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setFullYear(e.getFullYear() + t);
}, function(e, t) {
  return t.getFullYear() - e.getFullYear();
}, function(e) {
  return e.getFullYear();
});
np.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ga(function(t) {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setFullYear(t.getFullYear() + r * e);
  });
};
const As = np;
np.range;
var uy = ga(function(e) {
  e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCDate(e.getUTCDate() + t);
}, function(e, t) {
  return (t - e) / tp;
}, function(e) {
  return e.getUTCDate() - 1;
});
const cy = uy;
uy.range;
function Xi(e) {
  return ga(function(t) {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setUTCDate(t.getUTCDate() + r * 7);
  }, function(t, r) {
    return (r - t) / iy;
  });
}
var dy = Xi(0), ac = Xi(1), vx = Xi(2), xx = Xi(3), cl = Xi(4), bx = Xi(5), Ex = Xi(6);
dy.range;
ac.range;
vx.range;
xx.range;
cl.range;
bx.range;
Ex.range;
var rp = ga(function(e) {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, function(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}, function(e) {
  return e.getUTCFullYear();
});
rp.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ga(function(t) {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setUTCFullYear(t.getUTCFullYear() + r * e);
  });
};
const Ls = rp;
rp.range;
function Wd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function jd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function cs(e, t, r) {
  return { y: e, m: t, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function Sx(e) {
  var t = e.dateTime, r = e.date, a = e.time, i = e.periods, o = e.days, d = e.shortDays, c = e.months, s = e.shortMonths, p = ds(i), m = fs(i), y = ds(o), x = fs(o), T = ds(d), S = fs(d), A = ds(c), E = fs(c), b = ds(s), v = fs(s), N = {
    a: ae,
    A: oe,
    b: K,
    B: Y,
    c: null,
    d: yh,
    e: yh,
    f: Ux,
    g: tb,
    G: rb,
    H: Vx,
    I: Wx,
    j: jx,
    L: fy,
    m: Kx,
    M: Yx,
    p: X,
    q,
    Q: xh,
    s: bh,
    S: Gx,
    u: Xx,
    U: qx,
    V: Zx,
    w: Qx,
    W: Jx,
    x: null,
    X: null,
    y: eb,
    Y: nb,
    Z: ab,
    "%": vh
  }, C = {
    a: ce,
    A: ge,
    b: De,
    B: me,
    c: null,
    d: gh,
    e: gh,
    f: sb,
    g: vb,
    G: bb,
    H: ib,
    I: ob,
    j: lb,
    L: hy,
    m: ub,
    M: cb,
    p: Fe,
    q: Ue,
    Q: xh,
    s: bh,
    S: db,
    u: fb,
    U: pb,
    V: hb,
    w: mb,
    W: yb,
    x: null,
    X: null,
    y: gb,
    Y: xb,
    Z: Eb,
    "%": vh
  }, R = {
    a: Q,
    A: $,
    b: J,
    B: ne,
    c: z,
    d: hh,
    e: hh,
    f: Bx,
    g: ph,
    G: fh,
    H: mh,
    I: mh,
    j: Ox,
    L: zx,
    m: _x,
    M: Fx,
    p: te,
    q: Dx,
    Q: Ix,
    s: Hx,
    S: Mx,
    u: Ax,
    U: Lx,
    V: Px,
    w: Tx,
    W: Nx,
    x: W,
    X: ie,
    y: ph,
    Y: fh,
    Z: Rx,
    "%": $x
  };
  N.x = _(r, N), N.X = _(a, N), N.c = _(t, N), C.x = _(r, C), C.X = _(a, C), C.c = _(t, C);
  function _(Te, ve) {
    return function(Ae) {
      var fe = [], ze = -1, Oe = 0, Ve = Te.length, Ze, Ie, qe;
      for (Ae instanceof Date || (Ae = /* @__PURE__ */ new Date(+Ae)); ++ze < Ve; )
        Te.charCodeAt(ze) === 37 && (fe.push(Te.slice(Oe, ze)), (Ie = dh[Ze = Te.charAt(++ze)]) != null ? Ze = Te.charAt(++ze) : Ie = Ze === "e" ? " " : "0", (qe = ve[Ze]) && (Ze = qe(Ae, Ie)), fe.push(Ze), Oe = ze + 1);
      return fe.push(Te.slice(Oe, ze)), fe.join("");
    };
  }
  function U(Te, ve) {
    return function(Ae) {
      var fe = cs(1900, void 0, 1), ze = j(fe, Te, Ae += "", 0), Oe, Ve;
      if (ze != Ae.length)
        return null;
      if ("Q" in fe)
        return new Date(fe.Q);
      if ("s" in fe)
        return new Date(fe.s * 1e3 + ("L" in fe ? fe.L : 0));
      if (ve && !("Z" in fe) && (fe.Z = 0), "p" in fe && (fe.H = fe.H % 12 + fe.p * 12), fe.m === void 0 && (fe.m = "q" in fe ? fe.q : 0), "V" in fe) {
        if (fe.V < 1 || fe.V > 53)
          return null;
        "w" in fe || (fe.w = 1), "Z" in fe ? (Oe = jd(cs(fe.y, 0, 1)), Ve = Oe.getUTCDay(), Oe = Ve > 4 || Ve === 0 ? ac.ceil(Oe) : ac(Oe), Oe = cy.offset(Oe, (fe.V - 1) * 7), fe.y = Oe.getUTCFullYear(), fe.m = Oe.getUTCMonth(), fe.d = Oe.getUTCDate() + (fe.w + 6) % 7) : (Oe = Wd(cs(fe.y, 0, 1)), Ve = Oe.getDay(), Oe = Ve > 4 || Ve === 0 ? rc.ceil(Oe) : rc(Oe), Oe = ly.offset(Oe, (fe.V - 1) * 7), fe.y = Oe.getFullYear(), fe.m = Oe.getMonth(), fe.d = Oe.getDate() + (fe.w + 6) % 7);
      } else
        ("W" in fe || "U" in fe) && ("w" in fe || (fe.w = "u" in fe ? fe.u % 7 : "W" in fe ? 1 : 0), Ve = "Z" in fe ? jd(cs(fe.y, 0, 1)).getUTCDay() : Wd(cs(fe.y, 0, 1)).getDay(), fe.m = 0, fe.d = "W" in fe ? (fe.w + 6) % 7 + fe.W * 7 - (Ve + 5) % 7 : fe.w + fe.U * 7 - (Ve + 6) % 7);
      return "Z" in fe ? (fe.H += fe.Z / 100 | 0, fe.M += fe.Z % 100, jd(fe)) : Wd(fe);
    };
  }
  function j(Te, ve, Ae, fe) {
    for (var ze = 0, Oe = ve.length, Ve = Ae.length, Ze, Ie; ze < Oe; ) {
      if (fe >= Ve)
        return -1;
      if (Ze = ve.charCodeAt(ze++), Ze === 37) {
        if (Ze = ve.charAt(ze++), Ie = R[Ze in dh ? ve.charAt(ze++) : Ze], !Ie || (fe = Ie(Te, Ae, fe)) < 0)
          return -1;
      } else if (Ze != Ae.charCodeAt(fe++))
        return -1;
    }
    return fe;
  }
  function te(Te, ve, Ae) {
    var fe = p.exec(ve.slice(Ae));
    return fe ? (Te.p = m.get(fe[0].toLowerCase()), Ae + fe[0].length) : -1;
  }
  function Q(Te, ve, Ae) {
    var fe = T.exec(ve.slice(Ae));
    return fe ? (Te.w = S.get(fe[0].toLowerCase()), Ae + fe[0].length) : -1;
  }
  function $(Te, ve, Ae) {
    var fe = y.exec(ve.slice(Ae));
    return fe ? (Te.w = x.get(fe[0].toLowerCase()), Ae + fe[0].length) : -1;
  }
  function J(Te, ve, Ae) {
    var fe = b.exec(ve.slice(Ae));
    return fe ? (Te.m = v.get(fe[0].toLowerCase()), Ae + fe[0].length) : -1;
  }
  function ne(Te, ve, Ae) {
    var fe = A.exec(ve.slice(Ae));
    return fe ? (Te.m = E.get(fe[0].toLowerCase()), Ae + fe[0].length) : -1;
  }
  function z(Te, ve, Ae) {
    return j(Te, t, ve, Ae);
  }
  function W(Te, ve, Ae) {
    return j(Te, r, ve, Ae);
  }
  function ie(Te, ve, Ae) {
    return j(Te, a, ve, Ae);
  }
  function ae(Te) {
    return d[Te.getDay()];
  }
  function oe(Te) {
    return o[Te.getDay()];
  }
  function K(Te) {
    return s[Te.getMonth()];
  }
  function Y(Te) {
    return c[Te.getMonth()];
  }
  function X(Te) {
    return i[+(Te.getHours() >= 12)];
  }
  function q(Te) {
    return 1 + ~~(Te.getMonth() / 3);
  }
  function ce(Te) {
    return d[Te.getUTCDay()];
  }
  function ge(Te) {
    return o[Te.getUTCDay()];
  }
  function De(Te) {
    return s[Te.getUTCMonth()];
  }
  function me(Te) {
    return c[Te.getUTCMonth()];
  }
  function Fe(Te) {
    return i[+(Te.getUTCHours() >= 12)];
  }
  function Ue(Te) {
    return 1 + ~~(Te.getUTCMonth() / 3);
  }
  return {
    format: function(Te) {
      var ve = _(Te += "", N);
      return ve.toString = function() {
        return Te;
      }, ve;
    },
    parse: function(Te) {
      var ve = U(Te += "", !1);
      return ve.toString = function() {
        return Te;
      }, ve;
    },
    utcFormat: function(Te) {
      var ve = _(Te += "", C);
      return ve.toString = function() {
        return Te;
      }, ve;
    },
    utcParse: function(Te) {
      var ve = U(Te += "", !0);
      return ve.toString = function() {
        return Te;
      }, ve;
    }
  };
}
var dh = { "-": "", _: " ", 0: "0" }, Yn = /^\s*\d+/, kx = /^%/, wx = /[\\^$*+?|[\]().{}]/g;
function Qt(e, t, r) {
  var a = e < 0 ? "-" : "", i = (a ? -e : e) + "", o = i.length;
  return a + (o < r ? new Array(r - o + 1).join(t) + i : i);
}
function Cx(e) {
  return e.replace(wx, "\\$&");
}
function ds(e) {
  return new RegExp("^(?:" + e.map(Cx).join("|") + ")", "i");
}
function fs(e) {
  return new Map(e.map((t, r) => [t.toLowerCase(), r]));
}
function Tx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 1));
  return a ? (e.w = +a[0], r + a[0].length) : -1;
}
function Ax(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 1));
  return a ? (e.u = +a[0], r + a[0].length) : -1;
}
function Lx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.U = +a[0], r + a[0].length) : -1;
}
function Px(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.V = +a[0], r + a[0].length) : -1;
}
function Nx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.W = +a[0], r + a[0].length) : -1;
}
function fh(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 4));
  return a ? (e.y = +a[0], r + a[0].length) : -1;
}
function ph(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), r + a[0].length) : -1;
}
function Rx(e, t, r) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(r, r + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), r + a[0].length) : -1;
}
function Dx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 1));
  return a ? (e.q = a[0] * 3 - 3, r + a[0].length) : -1;
}
function _x(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.m = a[0] - 1, r + a[0].length) : -1;
}
function hh(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.d = +a[0], r + a[0].length) : -1;
}
function Ox(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 3));
  return a ? (e.m = 0, e.d = +a[0], r + a[0].length) : -1;
}
function mh(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.H = +a[0], r + a[0].length) : -1;
}
function Fx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.M = +a[0], r + a[0].length) : -1;
}
function Mx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.S = +a[0], r + a[0].length) : -1;
}
function zx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 3));
  return a ? (e.L = +a[0], r + a[0].length) : -1;
}
function Bx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), r + a[0].length) : -1;
}
function $x(e, t, r) {
  var a = kx.exec(t.slice(r, r + 1));
  return a ? r + a[0].length : -1;
}
function Ix(e, t, r) {
  var a = Yn.exec(t.slice(r));
  return a ? (e.Q = +a[0], r + a[0].length) : -1;
}
function Hx(e, t, r) {
  var a = Yn.exec(t.slice(r));
  return a ? (e.s = +a[0], r + a[0].length) : -1;
}
function yh(e, t) {
  return Qt(e.getDate(), t, 2);
}
function Vx(e, t) {
  return Qt(e.getHours(), t, 2);
}
function Wx(e, t) {
  return Qt(e.getHours() % 12 || 12, t, 2);
}
function jx(e, t) {
  return Qt(1 + ly.count(As(e), e), t, 3);
}
function fy(e, t) {
  return Qt(e.getMilliseconds(), t, 3);
}
function Ux(e, t) {
  return fy(e, t) + "000";
}
function Kx(e, t) {
  return Qt(e.getMonth() + 1, t, 2);
}
function Yx(e, t) {
  return Qt(e.getMinutes(), t, 2);
}
function Gx(e, t) {
  return Qt(e.getSeconds(), t, 2);
}
function Xx(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function qx(e, t) {
  return Qt(sy.count(As(e) - 1, e), t, 2);
}
function py(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? ul(e) : ul.ceil(e);
}
function Zx(e, t) {
  return e = py(e), Qt(ul.count(As(e), e) + (As(e).getDay() === 4), t, 2);
}
function Qx(e) {
  return e.getDay();
}
function Jx(e, t) {
  return Qt(rc.count(As(e) - 1, e), t, 2);
}
function eb(e, t) {
  return Qt(e.getFullYear() % 100, t, 2);
}
function tb(e, t) {
  return e = py(e), Qt(e.getFullYear() % 100, t, 2);
}
function nb(e, t) {
  return Qt(e.getFullYear() % 1e4, t, 4);
}
function rb(e, t) {
  var r = e.getDay();
  return e = r >= 4 || r === 0 ? ul(e) : ul.ceil(e), Qt(e.getFullYear() % 1e4, t, 4);
}
function ab(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Qt(t / 60 | 0, "0", 2) + Qt(t % 60, "0", 2);
}
function gh(e, t) {
  return Qt(e.getUTCDate(), t, 2);
}
function ib(e, t) {
  return Qt(e.getUTCHours(), t, 2);
}
function ob(e, t) {
  return Qt(e.getUTCHours() % 12 || 12, t, 2);
}
function lb(e, t) {
  return Qt(1 + cy.count(Ls(e), e), t, 3);
}
function hy(e, t) {
  return Qt(e.getUTCMilliseconds(), t, 3);
}
function sb(e, t) {
  return hy(e, t) + "000";
}
function ub(e, t) {
  return Qt(e.getUTCMonth() + 1, t, 2);
}
function cb(e, t) {
  return Qt(e.getUTCMinutes(), t, 2);
}
function db(e, t) {
  return Qt(e.getUTCSeconds(), t, 2);
}
function fb(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function pb(e, t) {
  return Qt(dy.count(Ls(e) - 1, e), t, 2);
}
function my(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? cl(e) : cl.ceil(e);
}
function hb(e, t) {
  return e = my(e), Qt(cl.count(Ls(e), e) + (Ls(e).getUTCDay() === 4), t, 2);
}
function mb(e) {
  return e.getUTCDay();
}
function yb(e, t) {
  return Qt(ac.count(Ls(e) - 1, e), t, 2);
}
function gb(e, t) {
  return Qt(e.getUTCFullYear() % 100, t, 2);
}
function vb(e, t) {
  return e = my(e), Qt(e.getUTCFullYear() % 100, t, 2);
}
function xb(e, t) {
  return Qt(e.getUTCFullYear() % 1e4, t, 4);
}
function bb(e, t) {
  var r = e.getUTCDay();
  return e = r >= 4 || r === 0 ? cl(e) : cl.ceil(e), Qt(e.getUTCFullYear() % 1e4, t, 4);
}
function Eb() {
  return "+0000";
}
function vh() {
  return "%";
}
function xh(e) {
  return +e;
}
function bh(e) {
  return Math.floor(+e / 1e3);
}
var Zo, Uu, yy;
Sb({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function Sb(e) {
  return Zo = Sx(e), Uu = Zo.format, yy = Zo.parse, Zo.utcFormat, Zo.utcParse, Zo;
}
const gt = ue.createContext({}), Wt = {
  arr: Array.isArray,
  obj: (e) => Object.prototype.toString.call(e) === "[object Object]",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0,
  nul: (e) => e === null,
  set: (e) => e instanceof Set,
  map: (e) => e instanceof Map,
  equ(e, t) {
    if (typeof e != typeof t)
      return !1;
    if (Wt.str(e) || Wt.num(e))
      return e === t;
    if (Wt.obj(e) && Wt.obj(t) && Object.keys(e).length + Object.keys(t).length === 0)
      return !0;
    let r;
    for (r in e)
      if (!(r in t))
        return !1;
    for (r in t)
      if (e[r] !== t[r])
        return !1;
    return Wt.und(r) ? e === t : !0;
  }
};
function kb(e, t) {
  return t === void 0 && (t = !0), (r) => (Wt.arr(r) ? r : Object.keys(r)).reduce((a, i) => {
    const o = t ? i[0].toLowerCase() + i.substring(1) : i;
    return a[o] = e(o), a;
  }, e);
}
function gy() {
  const e = ue.useState(!1), t = e[1];
  return ue.useCallback(() => t((a) => !a), []);
}
function Ri(e, t) {
  return Wt.und(e) || Wt.nul(e) ? t : e;
}
function al(e) {
  return Wt.und(e) ? [] : Wt.arr(e) ? e : [e];
}
function Fr(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    r[a - 1] = arguments[a];
  return Wt.fun(e) ? e(...r) : e;
}
function wb(e) {
  return e.to, e.from, e.config, e.onStart, e.onRest, e.onFrame, e.children, e.reset, e.reverse, e.force, e.immediate, e.delay, e.attach, e.destroyed, e.interpolateTo, e.ref, e.lazy, qr(e, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
}
function Ud(e) {
  const t = wb(e);
  if (Wt.und(t))
    return gn({
      to: t
    }, e);
  const r = Object.keys(e).reduce((a, i) => Wt.und(t[i]) ? gn({}, a, {
    [i]: e[i]
  }) : a, {});
  return gn({
    to: t
  }, r);
}
function Cb(e, t) {
  return t && (Wt.fun(t) ? t(e) : Wt.obj(t) && (t.current = e)), e;
}
class Mr {
  constructor() {
    this.payload = void 0, this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(t) {
    this.children.length === 0 && this.attach(), this.children.push(t);
  }
  removeChild(t) {
    const r = this.children.indexOf(t);
    this.children.splice(r, 1), this.children.length === 0 && this.detach();
  }
}
class Sf extends Mr {
  constructor() {
    super(...arguments), this.payload = [], this.attach = () => this.payload.forEach((t) => t instanceof Mr && t.addChild(this)), this.detach = () => this.payload.forEach((t) => t instanceof Mr && t.removeChild(this));
  }
}
class vy extends Mr {
  constructor() {
    super(...arguments), this.payload = {}, this.attach = () => Object.values(this.payload).forEach((t) => t instanceof Mr && t.addChild(this)), this.detach = () => Object.values(this.payload).forEach((t) => t instanceof Mr && t.removeChild(this));
  }
  getValue(t) {
    t === void 0 && (t = !1);
    const r = {};
    for (const a in this.payload) {
      const i = this.payload[a];
      t && !(i instanceof Mr) || (r[a] = i instanceof Mr ? i[t ? "getAnimatedValue" : "getValue"]() : i);
    }
    return r;
  }
  getAnimatedValue() {
    return this.getValue(!0);
  }
}
let ap;
function Tb(e, t) {
  ap = {
    fn: e,
    transform: t
  };
}
let xy;
function Ab(e) {
  xy = e;
}
let by = (e) => typeof window < "u" ? window.requestAnimationFrame(e) : -1, ic;
function Lb(e) {
  ic = e;
}
let Ey = () => Date.now(), Pb = (e) => e.current, Sy;
function Nb(e) {
  Sy = e;
}
class Rb extends vy {
  constructor(t, r) {
    super(), this.update = void 0, this.payload = t.style ? gn({}, t, {
      style: Sy(t.style)
    }) : t, this.update = r, this.attach();
  }
}
const Db = (e) => Wt.fun(e) && !(e.prototype instanceof n.Component), _b = (e) => ue.forwardRef((r, a) => {
  const i = gy(), o = ue.useRef(!0), d = ue.useRef(null), c = ue.useRef(null), s = ue.useCallback((x) => {
    const T = d.current, S = () => {
      let A = !1;
      c.current && (A = ap.fn(c.current, d.current.getAnimatedValue())), (!c.current || A === !1) && i();
    };
    d.current = new Rb(x, S), T && T.detach();
  }, []);
  ue.useEffect(() => () => {
    o.current = !1, d.current && d.current.detach();
  }, []), ue.useImperativeHandle(a, () => Pb(c)), s(r);
  const p = d.current.getValue();
  p.scrollTop, p.scrollLeft;
  const m = qr(p, ["scrollTop", "scrollLeft"]), y = Db(e) ? void 0 : (x) => c.current = Cb(x, a);
  return n.createElement(e, gn({}, m, {
    ref: y
  }));
});
let gs = !1;
const Wi = /* @__PURE__ */ new Set(), ky = () => {
  if (!gs)
    return !1;
  let e = Ey();
  for (let t of Wi) {
    let r = !1;
    for (let a = 0; a < t.configs.length; a++) {
      let i = t.configs[a], o, d;
      for (let c = 0; c < i.animatedValues.length; c++) {
        let s = i.animatedValues[c];
        if (s.done)
          continue;
        let p = i.fromValues[c], m = i.toValues[c], y = s.lastPosition, x = m instanceof Mr, T = Array.isArray(i.initialVelocity) ? i.initialVelocity[c] : i.initialVelocity;
        if (x && (m = m.getValue()), i.immediate) {
          s.setValue(m), s.done = !0;
          continue;
        }
        if (typeof p == "string" || typeof m == "string") {
          s.setValue(m), s.done = !0;
          continue;
        }
        if (i.duration !== void 0)
          y = p + i.easing((e - s.startTime) / i.duration) * (m - p), o = e >= s.startTime + i.duration;
        else if (i.decay)
          y = p + T / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (e - s.startTime))), o = Math.abs(s.lastPosition - y) < 0.1, o && (m = y);
        else {
          d = s.lastTime !== void 0 ? s.lastTime : e, T = s.lastVelocity !== void 0 ? s.lastVelocity : i.initialVelocity, e > d + 64 && (d = e);
          let S = Math.floor(e - d);
          for (let v = 0; v < S; ++v) {
            let N = -i.tension * (y - m), C = -i.friction * T, R = (N + C) / i.mass;
            T = T + R * 1 / 1e3, y = y + T * 1 / 1e3;
          }
          let A = i.clamp && i.tension !== 0 ? p < m ? y > m : y < m : !1, E = Math.abs(T) <= i.precision, b = i.tension !== 0 ? Math.abs(m - y) <= i.precision : !0;
          o = A || E && b, s.lastVelocity = T, s.lastTime = e;
        }
        x && !i.toValues[c].done && (o = !1), o ? (s.value !== m && (y = m), s.done = !0) : r = !0, s.setValue(y), s.lastPosition = y;
      }
      t.props.onFrame && (t.values[i.name] = i.interpolation.getValue());
    }
    t.props.onFrame && t.props.onFrame(t.values), r || (Wi.delete(t), t.stop(!0));
  }
  return Wi.size ? by(ky) : gs = !1, gs;
}, Ob = (e) => {
  Wi.has(e) || Wi.add(e), gs || (gs = !0, by(ky));
}, Fb = (e) => {
  Wi.has(e) && Wi.delete(e);
};
function oc(e, t, r) {
  if (typeof e == "function")
    return e;
  if (Array.isArray(e))
    return oc({
      range: e,
      output: t,
      extrapolate: r
    });
  if (ic && typeof e.output[0] == "string")
    return ic(e);
  const a = e, i = a.output, o = a.range || [0, 1], d = a.extrapolateLeft || a.extrapolate || "extend", c = a.extrapolateRight || a.extrapolate || "extend", s = a.easing || ((p) => p);
  return (p) => {
    const m = zb(p, o);
    return Mb(p, o[m], o[m + 1], i[m], i[m + 1], s, d, c, a.map);
  };
}
function Mb(e, t, r, a, i, o, d, c, s) {
  let p = s ? s(e) : e;
  if (p < t) {
    if (d === "identity")
      return p;
    d === "clamp" && (p = t);
  }
  if (p > r) {
    if (c === "identity")
      return p;
    c === "clamp" && (p = r);
  }
  return a === i ? a : t === r ? e <= t ? a : i : (t === -1 / 0 ? p = -p : r === 1 / 0 ? p = p - t : p = (p - t) / (r - t), p = o(p), a === -1 / 0 ? p = -p : i === 1 / 0 ? p = p + a : p = p * (i - a) + a, p);
}
function zb(e, t) {
  for (var r = 1; r < t.length - 1 && !(t[r] >= e); ++r)
    ;
  return r - 1;
}
class dl extends Sf {
  constructor(t, r, a, i) {
    super(), this.calc = void 0, this.payload = t instanceof Sf && !(t instanceof dl) ? t.getPayload() : Array.isArray(t) ? t : [t], this.calc = oc(r, a, i);
  }
  getValue() {
    return this.calc(...this.payload.map((t) => t.getValue()));
  }
  updateConfig(t, r, a) {
    this.calc = oc(t, r, a);
  }
  interpolate(t, r, a) {
    return new dl(this, t, r, a);
  }
}
const Bb = (e, t, r) => e && new dl(e, t, r);
function wy(e, t) {
  "update" in e ? t.add(e) : e.getChildren().forEach((r) => wy(r, t));
}
class kf extends Mr {
  constructor(t) {
    var r;
    super(), r = this, this.animatedStyles = /* @__PURE__ */ new Set(), this.value = void 0, this.startPosition = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.startTime = void 0, this.lastTime = void 0, this.done = !1, this.setValue = function(a, i) {
      i === void 0 && (i = !0), r.value = a, i && r.flush();
    }, this.value = t, this.startPosition = t, this.lastPosition = t;
  }
  flush() {
    this.animatedStyles.size === 0 && wy(this, this.animatedStyles), this.animatedStyles.forEach((t) => t.update());
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  getValue() {
    return this.value;
  }
  interpolate(t, r, a) {
    return new dl(this, t, r, a);
  }
}
class $b extends Sf {
  constructor(t) {
    super(), this.payload = t.map((r) => new kf(r));
  }
  setValue(t, r) {
    r === void 0 && (r = !0), Array.isArray(t) ? t.length === this.payload.length && t.forEach((a, i) => this.payload[i].setValue(a, r)) : this.payload.forEach((a) => a.setValue(t, r));
  }
  getValue() {
    return this.payload.map((t) => t.getValue());
  }
  interpolate(t, r) {
    return new dl(this, t, r);
  }
}
let Ib = 0;
class Hb {
  constructor() {
    this.id = void 0, this.idle = !0, this.hasChanged = !1, this.guid = 0, this.local = 0, this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.listeners = [], this.queue = [], this.localQueue = void 0, this.getValues = () => this.interpolations, this.id = Ib++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */
  update(t) {
    if (!t)
      return this;
    const r = Ud(t), a = r.delay, i = a === void 0 ? 0 : a, o = r.to, d = qr(r, ["delay", "to"]);
    if (Wt.arr(o) || Wt.fun(o))
      this.queue.push(gn({}, d, {
        delay: i,
        to: o
      }));
    else if (o) {
      let c = {};
      Object.entries(o).forEach((s) => {
        let p = s[0], m = s[1];
        const y = gn({
          to: {
            [p]: m
          },
          delay: Fr(i, p)
        }, d), x = c[y.delay] && c[y.delay].to;
        c[y.delay] = gn({}, c[y.delay], y, {
          to: gn({}, x, y.to)
        });
      }), this.queue = Object.values(c);
    }
    return this.queue = this.queue.sort((c, s) => c.delay - s.delay), this.diff(d), this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  start(t) {
    if (this.queue.length) {
      this.idle = !1, this.localQueue && this.localQueue.forEach((i) => {
        let o = i.from, d = o === void 0 ? {} : o, c = i.to, s = c === void 0 ? {} : c;
        Wt.obj(d) && (this.merged = gn({}, d, this.merged)), Wt.obj(s) && (this.merged = gn({}, this.merged, s));
      });
      const r = this.local = ++this.guid, a = this.localQueue = this.queue;
      this.queue = [], a.forEach((i, o) => {
        let d = i.delay, c = qr(i, ["delay"]);
        const s = (m) => {
          o === a.length - 1 && r === this.guid && m && (this.idle = !0, this.props.onRest && this.props.onRest(this.merged)), t && t();
        };
        let p = Wt.arr(c.to) || Wt.fun(c.to);
        d ? setTimeout(() => {
          r === this.guid && (p ? this.runAsync(c, s) : this.diff(c).start(s));
        }, d) : p ? this.runAsync(c, s) : this.diff(c).start(s);
      });
    } else
      Wt.fun(t) && this.listeners.push(t), this.props.onStart && this.props.onStart(), Ob(this);
    return this;
  }
  stop(t) {
    return this.listeners.forEach((r) => r(t)), this.listeners = [], this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  pause(t) {
    return this.stop(!0), t && Fb(this), this;
  }
  runAsync(t, r) {
    var a = this;
    t.delay;
    let i = qr(t, ["delay"]);
    const o = this.local;
    let d = Promise.resolve(void 0);
    if (Wt.arr(i.to))
      for (let c = 0; c < i.to.length; c++) {
        const s = c, p = gn({}, i, Ud(i.to[s]));
        Wt.arr(p.config) && (p.config = p.config[s]), d = d.then(() => {
          if (o === this.guid)
            return new Promise((m) => this.diff(p).start(m));
        });
      }
    else if (Wt.fun(i.to)) {
      let c = 0, s;
      d = d.then(() => i.to(
        // next(props)
        (p) => {
          const m = gn({}, i, Ud(p));
          if (Wt.arr(m.config) && (m.config = m.config[c]), c++, o === this.guid)
            return s = new Promise((y) => this.diff(m).start(y));
        },
        // cancel()
        function(p) {
          return p === void 0 && (p = !0), a.stop(p);
        }
      ).then(() => s));
    }
    d.then(r);
  }
  diff(t) {
    this.props = gn({}, this.props, t);
    let r = this.props, a = r.from, i = a === void 0 ? {} : a, o = r.to, d = o === void 0 ? {} : o, c = r.config, s = c === void 0 ? {} : c, p = r.reverse, m = r.attach, y = r.reset, x = r.immediate;
    if (p) {
      var T = [d, i];
      i = T[0], d = T[1];
    }
    this.merged = gn({}, i, this.merged, d), this.hasChanged = !1;
    let S = m && m(this);
    if (this.animations = Object.entries(this.merged).reduce((A, E) => {
      let b = E[0], v = E[1], N = A[b] || {};
      const C = Wt.num(v), R = Wt.str(v) && !v.startsWith("#") && !/\d/.test(v) && !xy[v], _ = Wt.arr(v), U = !C && !_ && !R;
      let j = Wt.und(i[b]) ? v : i[b], te = C || _ || R ? v : 1, Q = Fr(s, b);
      S && (te = S.animations[b].parent);
      let $ = N.parent, J = N.interpolation, ne = al(S ? te.getPayload() : te), z, W = v;
      U && (W = ic({
        range: [0, 1],
        output: [v, v]
      })(1));
      let ie = J && J.getValue();
      const oe = !Wt.und($) && N.animatedValues.some((q) => !q.done), K = !Wt.equ(W, ie), Y = !Wt.equ(W, N.previous), X = !Wt.equ(Q, N.config);
      if (y || Y && K || X) {
        if (C || R)
          $ = J = N.parent || new kf(j);
        else if (_)
          $ = J = N.parent || new $b(j);
        else if (U) {
          let q = N.interpolation && N.interpolation.calc(N.parent.value);
          q = q !== void 0 && !y ? q : j, N.parent ? ($ = N.parent, $.setValue(0, !1)) : $ = new kf(0);
          const ce = {
            output: [q, v]
          };
          N.interpolation ? (J = N.interpolation, N.interpolation.updateConfig(ce)) : J = $.interpolate(ce);
        }
        return ne = al(S ? te.getPayload() : te), z = al($.getPayload()), y && !U && $.setValue(j, !1), this.hasChanged = !0, z.forEach((q) => {
          q.startPosition = q.value, q.lastPosition = q.value, q.lastVelocity = oe ? q.lastVelocity : void 0, q.lastTime = oe ? q.lastTime : void 0, q.startTime = Ey(), q.done = !1, q.animatedStyles.clear();
        }), Fr(x, b) && $.setValue(U ? te : v, !1), gn({}, A, {
          [b]: gn({}, N, {
            name: b,
            parent: $,
            interpolation: J,
            animatedValues: z,
            toValues: ne,
            previous: W,
            config: Q,
            fromValues: al($.getValue()),
            immediate: Fr(x, b),
            initialVelocity: Ri(Q.velocity, 0),
            clamp: Ri(Q.clamp, !1),
            precision: Ri(Q.precision, 0.01),
            tension: Ri(Q.tension, 170),
            friction: Ri(Q.friction, 26),
            mass: Ri(Q.mass, 1),
            duration: Q.duration,
            easing: Ri(Q.easing, (q) => q),
            decay: Q.decay
          })
        });
      } else
        return K ? A : (U && ($.setValue(1, !1), J.updateConfig({
          output: [W, W]
        })), $.done = !0, this.hasChanged = !0, gn({}, A, {
          [b]: gn({}, A[b], {
            previous: W
          })
        }));
    }, this.animations), this.hasChanged) {
      this.configs = Object.values(this.animations), this.values = {}, this.interpolations = {};
      for (let A in this.animations)
        this.interpolations[A] = this.animations[A].interpolation, this.values[A] = this.animations[A].interpolation.getValue();
    }
    return this;
  }
  destroy() {
    this.stop(), this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.local = 0;
  }
}
let Vb = 0;
const Ku = "enter", Kd = "leave", Yd = "update", Wb = (e, t) => (typeof t == "function" ? e.map(t) : al(t)).map(String), wf = (e) => {
  let t = e.items, r = e.keys, a = r === void 0 ? (o) => o : r, i = qr(e, ["items", "keys"]);
  return t = al(t !== void 0 ? t : null), gn({
    items: t,
    keys: Wb(t, a)
  }, i);
};
function jb(e, t, r) {
  const a = gn({
    items: e,
    keys: t || ((v) => v)
  }, r), i = wf(a), o = i.lazy, d = o === void 0 ? !1 : o;
  i.unique;
  const c = i.reset, s = c === void 0 ? !1 : c;
  i.enter, i.leave, i.update;
  const p = i.onDestroyed;
  i.keys, i.items;
  const m = i.onFrame, y = i.onRest, x = i.onStart, T = i.ref, S = qr(i, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]), A = gy(), E = ue.useRef(!1), b = ue.useRef({
    mounted: !1,
    first: !0,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!a.ref,
    instances: !E.current && /* @__PURE__ */ new Map(),
    forceUpdate: A
  });
  return ue.useImperativeHandle(a.ref, () => ({
    start: () => Promise.all(Array.from(b.current.instances).map((v) => {
      let N = v[1];
      return new Promise((C) => N.start(C));
    })),
    stop: (v) => Array.from(b.current.instances).forEach((N) => N[1].stop(v)),
    get controllers() {
      return Array.from(b.current.instances).map((v) => v[1]);
    }
  })), b.current = Ub(b.current, a), b.current.changed && b.current.transitions.forEach((v) => {
    const N = v.slot, C = v.from, R = v.to, _ = v.config, U = v.trail, j = v.key, te = v.item;
    b.current.instances.has(j) || b.current.instances.set(j, new Hb());
    const Q = b.current.instances.get(j), $ = gn({}, S, {
      to: R,
      from: C,
      config: _,
      ref: T,
      onRest: (J) => {
        b.current.mounted && (v.destroyed && (!T && !d && Eh(b, j), p && p(te)), !Array.from(b.current.instances).some((W) => !W[1].idle) && (T || d) && b.current.deleted.length > 0 && Eh(b), y && y(te, N, J));
      },
      onStart: x && (() => x(te, N)),
      onFrame: m && ((J) => m(te, N, J)),
      delay: U,
      reset: s && N === Ku
      // Update controller
    });
    Q.update($), b.current.paused || Q.start();
  }), ue.useEffect(() => (b.current.mounted = E.current = !0, () => {
    b.current.mounted = E.current = !1, Array.from(b.current.instances).map((v) => v[1].destroy()), b.current.instances.clear();
  }), []), b.current.transitions.map((v) => {
    let N = v.item, C = v.slot, R = v.key;
    return {
      item: N,
      key: R,
      state: C,
      props: b.current.instances.get(R).getValues()
    };
  });
}
function Eh(e, t) {
  const r = e.current.deleted;
  for (let a of r) {
    let i = a.key;
    const o = (d) => d.key !== i;
    (Wt.und(t) || t === i) && (e.current.instances.delete(i), e.current.transitions = e.current.transitions.filter(o), e.current.deleted = e.current.deleted.filter(o));
  }
  e.current.forceUpdate();
}
function Ub(e, t) {
  let r = e.first, a = e.prevProps, i = qr(e, ["first", "prevProps"]), o = wf(t), d = o.items, c = o.keys, s = o.initial, p = o.from, m = o.enter, y = o.leave, x = o.update, T = o.trail, S = T === void 0 ? 0 : T, A = o.unique, E = o.config, b = o.order, v = b === void 0 ? [Ku, Kd, Yd] : b, N = wf(a), C = N.keys, R = N.items, _ = gn({}, i.current), U = [...i.deleted], j = Object.keys(_), te = new Set(j), Q = new Set(c), $ = c.filter((ie) => !te.has(ie)), J = i.transitions.filter((ie) => !ie.destroyed && !Q.has(ie.originalKey)).map((ie) => ie.originalKey), ne = c.filter((ie) => te.has(ie)), z = -S;
  for (; v.length; )
    switch (v.shift()) {
      case Ku: {
        $.forEach((ae, oe) => {
          A && U.find((q) => q.originalKey === ae) && (U = U.filter((q) => q.originalKey !== ae));
          const K = c.indexOf(ae), Y = d[K], X = r && s !== void 0 ? "initial" : Ku;
          _[ae] = {
            slot: X,
            originalKey: ae,
            key: A ? String(ae) : Vb++,
            item: Y,
            trail: z = z + S,
            config: Fr(E, Y, X),
            from: Fr(r && s !== void 0 ? s || {} : p, Y),
            to: Fr(m, Y)
          };
        });
        break;
      }
      case Kd: {
        J.forEach((ae) => {
          const oe = C.indexOf(ae), K = R[oe], Y = Kd;
          U.unshift(gn({}, _[ae], {
            slot: Y,
            destroyed: !0,
            left: C[Math.max(0, oe - 1)],
            right: C[Math.min(C.length, oe + 1)],
            trail: z = z + S,
            config: Fr(E, K, Y),
            to: Fr(y, K)
          })), delete _[ae];
        });
        break;
      }
      case Yd: {
        ne.forEach((ae) => {
          const oe = c.indexOf(ae), K = d[oe], Y = Yd;
          _[ae] = gn({}, _[ae], {
            item: K,
            slot: Y,
            trail: z = z + S,
            config: Fr(E, K, Y),
            to: Fr(x, K)
          });
        });
        break;
      }
    }
  let W = c.map((ie) => _[ie]);
  return U.forEach((ie) => {
    let ae = ie.left;
    ie.right;
    let oe = qr(ie, ["left", "right"]), K;
    (K = W.findIndex((Y) => Y.originalKey === ae)) !== -1 && (K += 1), K = Math.max(0, K), W = [...W.slice(0, K), oe, ...W.slice(K)];
  }), gn({}, i, {
    changed: $.length || J.length || ne.length,
    first: r && $.length === 0,
    transitions: W,
    current: _,
    deleted: U,
    prevProps: t
  });
}
class Kb extends vy {
  constructor(t) {
    t === void 0 && (t = {}), super(), t.transform && !(t.transform instanceof Mr) && (t = ap.transform(t)), this.payload = t;
  }
}
const lc = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, zr = "[-+]?\\d*\\.?\\d+", sc = zr + "%";
function _c() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const Yb = new RegExp("rgb" + _c(zr, zr, zr)), Gb = new RegExp("rgba" + _c(zr, zr, zr, zr)), Xb = new RegExp("hsl" + _c(zr, sc, sc)), qb = new RegExp("hsla" + _c(zr, sc, sc, zr)), Zb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Qb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Jb = /^#([0-9a-fA-F]{6})$/, e0 = /^#([0-9a-fA-F]{8})$/;
function t0(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = Jb.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : lc.hasOwnProperty(e) ? lc[e] : (t = Yb.exec(e)) ? (Qo(t[1]) << 24 | // r
  Qo(t[2]) << 16 | // g
  Qo(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = Gb.exec(e)) ? (Qo(t[1]) << 24 | // r
  Qo(t[2]) << 16 | // g
  Qo(t[3]) << 8 | // b
  wh(t[4])) >>> // a
  0 : (t = Zb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = e0.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = Qb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = Xb.exec(e)) ? (Sh(
    kh(t[1]),
    // h
    _u(t[2]),
    // s
    _u(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = qb.exec(e)) ? (Sh(
    kh(t[1]),
    // h
    _u(t[2]),
    // s
    _u(t[3])
    // l
  ) | wh(t[4])) >>> // a
  0 : null;
}
function Gd(e, t, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function Sh(e, t, r) {
  const a = r < 0.5 ? r * (1 + t) : r + t - r * t, i = 2 * r - a, o = Gd(i, a, e + 1 / 3), d = Gd(i, a, e), c = Gd(i, a, e - 1 / 3);
  return Math.round(o * 255) << 24 | Math.round(d * 255) << 16 | Math.round(c * 255) << 8;
}
function Qo(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function kh(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function wh(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function _u(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function Ch(e) {
  let t = t0(e);
  if (t === null)
    return e;
  t = t || 0;
  let r = (t & 4278190080) >>> 24, a = (t & 16711680) >>> 16, i = (t & 65280) >>> 8, o = (t & 255) / 255;
  return `rgba(${r}, ${a}, ${i}, ${o})`;
}
const Ou = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, n0 = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, r0 = new RegExp(`(${Object.keys(lc).join("|")})`, "g"), a0 = (e) => {
  const t = e.output.map((i) => i.replace(n0, Ch)).map((i) => i.replace(r0, Ch)), r = t[0].match(Ou).map(() => []);
  t.forEach((i) => {
    i.match(Ou).forEach((o, d) => r[d].push(+o));
  });
  const a = t[0].match(Ou).map((i, o) => oc(gn({}, e, {
    output: r[o]
  })));
  return (i) => {
    let o = 0;
    return t[0].replace(Ou, () => a[o++](i)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (d, c, s, p, m) => `rgba(${Math.round(c)}, ${Math.round(s)}, ${Math.round(p)}, ${m})`);
  };
};
let vs = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const i0 = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), o0 = ["Webkit", "Ms", "Moz", "O"];
vs = Object.keys(vs).reduce((e, t) => (o0.forEach((r) => e[i0(r, t)] = e[t]), e), vs);
function l0(e, t, r) {
  return t == null || typeof t == "boolean" || t === "" ? "" : !r && typeof t == "number" && t !== 0 && !(vs.hasOwnProperty(e) && vs[e]) ? t + "px" : ("" + t).trim();
}
const Th = {};
Nb((e) => new Kb(e));
Lb(a0);
Ab(lc);
Tb((e, t) => {
  if (e.nodeType && e.setAttribute !== void 0) {
    const i = t.style, o = t.children, d = t.scrollTop, c = t.scrollLeft, s = qr(t, ["style", "children", "scrollTop", "scrollLeft"]), p = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter";
    d !== void 0 && (e.scrollTop = d), c !== void 0 && (e.scrollLeft = c), o !== void 0 && (e.textContent = o);
    for (let m in i)
      if (i.hasOwnProperty(m)) {
        var r = m.indexOf("--") === 0, a = l0(m, i[m], r);
        m === "float" && (m = "cssFloat"), r ? e.style.setProperty(m, a) : e.style[m] = a;
      }
    for (let m in s) {
      const y = p ? m : Th[m] || (Th[m] = m.replace(/([A-Z])/g, (x) => "-" + x.toLowerCase()));
      typeof e.getAttribute(y) < "u" && e.setAttribute(y, s[m]);
    }
    return;
  } else
    return !1;
}, (e) => e);
const s0 = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], u0 = kb(_b, !1), Ah = u0(s0);
function c0(e) {
  return e.innerRadius;
}
function d0(e) {
  return e.outerRadius;
}
function f0(e) {
  return e.startAngle;
}
function p0(e) {
  return e.endAngle;
}
function h0(e) {
  return e && e.padAngle;
}
function m0(e, t, r, a, i, o, d, c) {
  var s = r - e, p = a - t, m = d - i, y = c - o, x = y * s - m * p;
  if (!(x * x < rr))
    return x = (m * (t - o) - y * (e - i)) / x, [e + x * s, t + x * p];
}
function Fu(e, t, r, a, i, o, d) {
  var c = e - r, s = t - a, p = (d ? o : -o) / nl(c * c + s * s), m = p * s, y = -p * c, x = e + m, T = t + y, S = r + m, A = a + y, E = (x + S) / 2, b = (T + A) / 2, v = S - x, N = A - T, C = v * v + N * N, R = i - o, _ = x * A - S * T, U = (N < 0 ? -1 : 1) * nl(Ag(0, R * R * C - _ * _)), j = (_ * N - v * U) / C, te = (-_ * v - N * U) / C, Q = (_ * N + v * U) / C, $ = (-_ * v + N * U) / C, J = j - E, ne = te - b, z = Q - E, W = $ - b;
  return J * J + ne * ne > z * z + W * W && (j = Q, te = $), {
    cx: j,
    cy: te,
    x01: -m,
    y01: -y,
    x11: j * (i / R - 1),
    y11: te * (i / R - 1)
  };
}
function y0() {
  var e = c0, t = d0, r = qt(0), a = null, i = f0, o = p0, d = h0, c = null;
  function s() {
    var p, m, y = +e.apply(this, arguments), x = +t.apply(this, arguments), T = i.apply(this, arguments) - Np, S = o.apply(this, arguments) - Np, A = Rp(S - T), E = S > T;
    if (c || (c = p = Nc()), x < y && (m = x, x = y, y = m), !(x > rr))
      c.moveTo(0, 0);
    else if (A > Wu - rr)
      c.moveTo(x * Li(T), x * Kr(T)), c.arc(0, 0, x, T, S, !E), y > rr && (c.moveTo(y * Li(S), y * Kr(S)), c.arc(0, 0, y, S, T, E));
    else {
      var b = T, v = S, N = T, C = S, R = A, _ = A, U = d.apply(this, arguments) / 2, j = U > rr && (a ? +a.apply(this, arguments) : nl(y * y + x * x)), te = Md(Rp(x - y) / 2, +r.apply(this, arguments)), Q = te, $ = te, J, ne;
      if (j > rr) {
        var z = Dp(j / y * Kr(U)), W = Dp(j / x * Kr(U));
        (R -= z * 2) > rr ? (z *= E ? 1 : -1, N += z, C -= z) : (R = 0, N = C = (T + S) / 2), (_ -= W * 2) > rr ? (W *= E ? 1 : -1, b += W, v -= W) : (_ = 0, b = v = (T + S) / 2);
      }
      var ie = x * Li(b), ae = x * Kr(b), oe = y * Li(C), K = y * Kr(C);
      if (te > rr) {
        var Y = x * Li(v), X = x * Kr(v), q = y * Li(N), ce = y * Kr(N), ge;
        if (A < Pp && (ge = m0(ie, ae, q, ce, Y, X, oe, K))) {
          var De = ie - ge[0], me = ae - ge[1], Fe = Y - ge[0], Ue = X - ge[1], Te = 1 / Kr(Tg((De * Fe + me * Ue) / (nl(De * De + me * me) * nl(Fe * Fe + Ue * Ue))) / 2), ve = nl(ge[0] * ge[0] + ge[1] * ge[1]);
          Q = Md(te, (y - ve) / (Te - 1)), $ = Md(te, (x - ve) / (Te + 1));
        }
      }
      _ > rr ? $ > rr ? (J = Fu(q, ce, ie, ae, x, $, E), ne = Fu(Y, X, oe, K, x, $, E), c.moveTo(J.cx + J.x01, J.cy + J.y01), $ < te ? c.arc(J.cx, J.cy, $, er(J.y01, J.x01), er(ne.y01, ne.x01), !E) : (c.arc(J.cx, J.cy, $, er(J.y01, J.x01), er(J.y11, J.x11), !E), c.arc(0, 0, x, er(J.cy + J.y11, J.cx + J.x11), er(ne.cy + ne.y11, ne.cx + ne.x11), !E), c.arc(ne.cx, ne.cy, $, er(ne.y11, ne.x11), er(ne.y01, ne.x01), !E))) : (c.moveTo(ie, ae), c.arc(0, 0, x, b, v, !E)) : c.moveTo(ie, ae), !(y > rr) || !(R > rr) ? c.lineTo(oe, K) : Q > rr ? (J = Fu(oe, K, Y, X, y, -Q, E), ne = Fu(ie, ae, q, ce, y, -Q, E), c.lineTo(J.cx + J.x01, J.cy + J.y01), Q < te ? c.arc(J.cx, J.cy, Q, er(J.y01, J.x01), er(ne.y01, ne.x01), !E) : (c.arc(J.cx, J.cy, Q, er(J.y01, J.x01), er(J.y11, J.x11), !E), c.arc(0, 0, y, er(J.cy + J.y11, J.cx + J.x11), er(ne.cy + ne.y11, ne.cx + ne.x11), E), c.arc(ne.cx, ne.cy, Q, er(ne.y11, ne.x11), er(ne.y01, ne.x01), !E))) : c.arc(0, 0, y, C, N, E);
    }
    if (c.closePath(), p)
      return c = null, p + "" || null;
  }
  return s.centroid = function() {
    var p = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, m = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Pp / 2;
    return [Li(m) * p, Kr(m) * p];
  }, s.innerRadius = function(p) {
    return arguments.length ? (e = typeof p == "function" ? p : qt(+p), s) : e;
  }, s.outerRadius = function(p) {
    return arguments.length ? (t = typeof p == "function" ? p : qt(+p), s) : t;
  }, s.cornerRadius = function(p) {
    return arguments.length ? (r = typeof p == "function" ? p : qt(+p), s) : r;
  }, s.padRadius = function(p) {
    return arguments.length ? (a = p == null ? null : typeof p == "function" ? p : qt(+p), s) : a;
  }, s.startAngle = function(p) {
    return arguments.length ? (i = typeof p == "function" ? p : qt(+p), s) : i;
  }, s.endAngle = function(p) {
    return arguments.length ? (o = typeof p == "function" ? p : qt(+p), s) : o;
  }, s.padAngle = function(p) {
    return arguments.length ? (d = typeof p == "function" ? p : qt(+p), s) : d;
  }, s.context = function(p) {
    return arguments.length ? (c = p ?? null, s) : c;
  }, s;
}
function Cy(e) {
  this._context = e;
}
Cy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Oc(e) {
  return new Cy(e);
}
function ip(e) {
  return e[0];
}
function op(e) {
  return e[1];
}
function Ty() {
  var e = ip, t = op, r = qt(!0), a = null, i = Oc, o = null;
  function d(c) {
    var s, p = c.length, m, y = !1, x;
    for (a == null && (o = i(x = Nc())), s = 0; s <= p; ++s)
      !(s < p && r(m = c[s], s, c)) === y && ((y = !y) ? o.lineStart() : o.lineEnd()), y && o.point(+e(m, s, c), +t(m, s, c));
    if (x)
      return o = null, x + "" || null;
  }
  return d.x = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : qt(+c), d) : e;
  }, d.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : qt(+c), d) : t;
  }, d.defined = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : qt(!!c), d) : r;
  }, d.curve = function(c) {
    return arguments.length ? (i = c, a != null && (o = i(a)), d) : i;
  }, d.context = function(c) {
    return arguments.length ? (c == null ? a = o = null : o = i(a = c), d) : a;
  }, d;
}
function g0() {
  var e = ip, t = null, r = qt(0), a = op, i = qt(!0), o = null, d = Oc, c = null;
  function s(m) {
    var y, x, T, S = m.length, A, E = !1, b, v = new Array(S), N = new Array(S);
    for (o == null && (c = d(b = Nc())), y = 0; y <= S; ++y) {
      if (!(y < S && i(A = m[y], y, m)) === E)
        if (E = !E)
          x = y, c.areaStart(), c.lineStart();
        else {
          for (c.lineEnd(), c.lineStart(), T = y - 1; T >= x; --T)
            c.point(v[T], N[T]);
          c.lineEnd(), c.areaEnd();
        }
      E && (v[y] = +e(A, y, m), N[y] = +r(A, y, m), c.point(t ? +t(A, y, m) : v[y], a ? +a(A, y, m) : N[y]));
    }
    if (b)
      return c = null, b + "" || null;
  }
  function p() {
    return Ty().defined(i).curve(d).context(o);
  }
  return s.x = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : qt(+m), t = null, s) : e;
  }, s.x0 = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : qt(+m), s) : e;
  }, s.x1 = function(m) {
    return arguments.length ? (t = m == null ? null : typeof m == "function" ? m : qt(+m), s) : t;
  }, s.y = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : qt(+m), a = null, s) : r;
  }, s.y0 = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : qt(+m), s) : r;
  }, s.y1 = function(m) {
    return arguments.length ? (a = m == null ? null : typeof m == "function" ? m : qt(+m), s) : a;
  }, s.lineX0 = s.lineY0 = function() {
    return p().x(e).y(r);
  }, s.lineY1 = function() {
    return p().x(e).y(a);
  }, s.lineX1 = function() {
    return p().x(t).y(r);
  }, s.defined = function(m) {
    return arguments.length ? (i = typeof m == "function" ? m : qt(!!m), s) : i;
  }, s.curve = function(m) {
    return arguments.length ? (d = m, o != null && (c = d(o)), s) : d;
  }, s.context = function(m) {
    return arguments.length ? (m == null ? o = c = null : c = d(o = m), s) : o;
  }, s;
}
function v0(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function x0(e) {
  return e;
}
function b0() {
  var e = x0, t = v0, r = null, a = qt(0), i = qt(Wu), o = qt(0);
  function d(c) {
    var s, p = c.length, m, y, x = 0, T = new Array(p), S = new Array(p), A = +a.apply(this, arguments), E = Math.min(Wu, Math.max(-Wu, i.apply(this, arguments) - A)), b, v = Math.min(Math.abs(E) / p, o.apply(this, arguments)), N = v * (E < 0 ? -1 : 1), C;
    for (s = 0; s < p; ++s)
      (C = S[T[s] = s] = +e(c[s], s, c)) > 0 && (x += C);
    for (t != null ? T.sort(function(R, _) {
      return t(S[R], S[_]);
    }) : r != null && T.sort(function(R, _) {
      return r(c[R], c[_]);
    }), s = 0, y = x ? (E - p * N) / x : 0; s < p; ++s, A = b)
      m = T[s], C = S[m], b = A + (C > 0 ? C * y : 0) + N, S[m] = {
        data: c[m],
        index: s,
        value: C,
        startAngle: A,
        endAngle: b,
        padAngle: v
      };
    return S;
  }
  return d.value = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : qt(+c), d) : e;
  }, d.sortValues = function(c) {
    return arguments.length ? (t = c, r = null, d) : t;
  }, d.sort = function(c) {
    return arguments.length ? (r = c, t = null, d) : r;
  }, d.startAngle = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : qt(+c), d) : a;
  }, d.endAngle = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : qt(+c), d) : i;
  }, d.padAngle = function(c) {
    return arguments.length ? (o = typeof c == "function" ? c : qt(+c), d) : o;
  }, d;
}
var Cf = Array.prototype.slice;
function E0(e) {
  return e.source;
}
function S0(e) {
  return e.target;
}
function k0(e) {
  var t = E0, r = S0, a = ip, i = op, o = null;
  function d() {
    var c, s = Cf.call(arguments), p = t.apply(this, s), m = r.apply(this, s);
    if (o || (o = c = Nc()), e(o, +a.apply(this, (s[0] = p, s)), +i.apply(this, s), +a.apply(this, (s[0] = m, s)), +i.apply(this, s)), c)
      return o = null, c + "" || null;
  }
  return d.source = function(c) {
    return arguments.length ? (t = c, d) : t;
  }, d.target = function(c) {
    return arguments.length ? (r = c, d) : r;
  }, d.x = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : qt(+c), d) : a;
  }, d.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : qt(+c), d) : i;
  }, d.context = function(c) {
    return arguments.length ? (o = c ?? null, d) : o;
  }, d;
}
function w0(e, t, r, a, i) {
  e.moveTo(t, r), e.bezierCurveTo(t = (t + a) / 2, r, t, i, a, i);
}
function C0() {
  return k0(w0);
}
function Ua() {
}
function uc(e, t, r) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + r) / 6
  );
}
function Fc(e) {
  this._context = e;
}
Fc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        uc(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        uc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function T0(e) {
  return new Fc(e);
}
function Ay(e) {
  this._context = e;
}
Ay.prototype = {
  areaStart: Ua,
  areaEnd: Ua,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        uc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function A0(e) {
  return new Ay(e);
}
function Ly(e) {
  this._context = e;
}
Ly.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + e) / 6, a = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(r, a) : this._context.moveTo(r, a);
        break;
      case 3:
        this._point = 4;
      default:
        uc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function L0(e) {
  return new Ly(e);
}
function Py(e, t) {
  this._basis = new Fc(e), this._beta = t;
}
Py.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length - 1;
    if (r > 0)
      for (var a = e[0], i = t[0], o = e[r] - a, d = t[r] - i, c = -1, s; ++c <= r; )
        s = c / r, this._basis.point(
          this._beta * e[c] + (1 - this._beta) * (a + s * o),
          this._beta * t[c] + (1 - this._beta) * (i + s * d)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const P0 = function e(t) {
  function r(a) {
    return t === 1 ? new Fc(a) : new Py(a, t);
  }
  return r.beta = function(a) {
    return e(+a);
  }, r;
}(0.85);
function cc(e, t, r) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - r),
    e._x2,
    e._y2
  );
}
function lp(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
lp.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        cc(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        cc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const N0 = function e(t) {
  function r(a) {
    return new lp(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function sp(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
sp.prototype = {
  areaStart: Ua,
  areaEnd: Ua,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        cc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const R0 = function e(t) {
  function r(a) {
    return new sp(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function up(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
up.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        cc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const D0 = function e(t) {
  function r(a) {
    return new up(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function cp(e, t, r) {
  var a = e._x1, i = e._y1, o = e._x2, d = e._y2;
  if (e._l01_a > rr) {
    var c = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, s = 3 * e._l01_a * (e._l01_a + e._l12_a);
    a = (a * c - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / s, i = (i * c - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / s;
  }
  if (e._l23_a > rr) {
    var p = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, m = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * p + e._x1 * e._l23_2a - t * e._l12_2a) / m, d = (d * p + e._y1 * e._l23_2a - r * e._l12_2a) / m;
  }
  e._context.bezierCurveTo(a, i, o, d, e._x2, e._y2);
}
function Ny(e, t) {
  this._context = e, this._alpha = t;
}
Ny.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        cp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const _0 = function e(t) {
  function r(a) {
    return t ? new Ny(a, t) : new lp(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function Ry(e, t) {
  this._context = e, this._alpha = t;
}
Ry.prototype = {
  areaStart: Ua,
  areaEnd: Ua,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        cp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const O0 = function e(t) {
  function r(a) {
    return t ? new Ry(a, t) : new sp(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function Dy(e, t) {
  this._context = e, this._alpha = t;
}
Dy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        cp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const F0 = function e(t) {
  function r(a) {
    return t ? new Dy(a, t) : new up(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function _y(e) {
  this._context = e;
}
_y.prototype = {
  areaStart: Ua,
  areaEnd: Ua,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function Tf(e) {
  return new _y(e);
}
function Lh(e) {
  return e < 0 ? -1 : 1;
}
function Ph(e, t, r) {
  var a = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (a || i < 0 && -0), d = (r - e._y1) / (i || a < 0 && -0), c = (o * i + d * a) / (a + i);
  return (Lh(o) + Lh(d)) * Math.min(Math.abs(o), Math.abs(d), 0.5 * Math.abs(c)) || 0;
}
function Nh(e, t) {
  var r = e._x1 - e._x0;
  return r ? (3 * (e._y1 - e._y0) / r - t) / 2 : t;
}
function Xd(e, t, r) {
  var a = e._x0, i = e._y0, o = e._x1, d = e._y1, c = (o - a) / 3;
  e._context.bezierCurveTo(a + c, i + c * t, o - c, d - c * r, o, d);
}
function dc(e) {
  this._context = e;
}
dc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Xd(this, this._t0, Nh(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var r = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Xd(this, Nh(this, r = Ph(this, e, t)), r);
          break;
        default:
          Xd(this, this._t0, r = Ph(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = r;
    }
  }
};
function Oy(e) {
  this._context = new Fy(e);
}
(Oy.prototype = Object.create(dc.prototype)).point = function(e, t) {
  dc.prototype.point.call(this, t, e);
};
function Fy(e) {
  this._context = e;
}
Fy.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, r, a, i, o) {
    this._context.bezierCurveTo(t, e, a, r, o, i);
  }
};
function Yu(e) {
  return new dc(e);
}
function M0(e) {
  return new Oy(e);
}
function My(e) {
  this._context = e;
}
My.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length;
    if (r)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), r === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var a = Rh(e), i = Rh(t), o = 0, d = 1; d < r; ++o, ++d)
          this._context.bezierCurveTo(a[0][o], i[0][o], a[1][o], i[1][o], e[d], t[d]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Rh(e) {
  var t, r = e.length - 1, a, i = new Array(r), o = new Array(r), d = new Array(r);
  for (i[0] = 0, o[0] = 2, d[0] = e[0] + 2 * e[1], t = 1; t < r - 1; ++t)
    i[t] = 1, o[t] = 4, d[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[r - 1] = 2, o[r - 1] = 7, d[r - 1] = 8 * e[r - 1] + e[r], t = 1; t < r; ++t)
    a = i[t] / o[t - 1], o[t] -= a, d[t] -= a * d[t - 1];
  for (i[r - 1] = d[r - 1] / o[r - 1], t = r - 2; t >= 0; --t)
    i[t] = (d[t] - i[t + 1]) / o[t];
  for (o[r - 1] = (e[r] + i[r - 1]) / 2, t = 0; t < r - 1; ++t)
    o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function z0(e) {
  return new My(e);
}
function Mc(e, t) {
  this._context = e, this._t = t;
}
Mc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var r = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function B0(e) {
  return new Mc(e, 0.5);
}
function $0(e) {
  return new Mc(e, 0);
}
function I0(e) {
  return new Mc(e, 1);
}
function fl(e, t) {
  if ((d = e.length) > 1)
    for (var r = 1, a, i, o = e[t[0]], d, c = o.length; r < d; ++r)
      for (i = o, o = e[t[r]], a = 0; a < c; ++a)
        o[a][1] += o[a][0] = isNaN(i[a][1]) ? i[a][0] : i[a][1];
}
function pl(e) {
  for (var t = e.length, r = new Array(t); --t >= 0; )
    r[t] = t;
  return r;
}
function H0(e, t) {
  return e[t];
}
function dp() {
  var e = qt([]), t = pl, r = fl, a = H0;
  function i(o) {
    var d = e.apply(this, arguments), c, s = o.length, p = d.length, m = new Array(p), y;
    for (c = 0; c < p; ++c) {
      for (var x = d[c], T = m[c] = new Array(s), S = 0, A; S < s; ++S)
        T[S] = A = [0, +a(o[S], x, S, o)], A.data = o[S];
      T.key = x;
    }
    for (c = 0, y = t(m); c < p; ++c)
      m[y[c]].index = c;
    return r(m, y), m;
  }
  return i.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : qt(Cf.call(o)), i) : e;
  }, i.value = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : qt(+o), i) : a;
  }, i.order = function(o) {
    return arguments.length ? (t = o == null ? pl : typeof o == "function" ? o : qt(Cf.call(o)), i) : t;
  }, i.offset = function(o) {
    return arguments.length ? (r = o ?? fl, i) : r;
  }, i;
}
function V0(e, t) {
  if ((a = e.length) > 0) {
    for (var r, a, i = 0, o = e[0].length, d; i < o; ++i) {
      for (d = r = 0; r < a; ++r)
        d += e[r][i][1] || 0;
      if (d)
        for (r = 0; r < a; ++r)
          e[r][i][1] /= d;
    }
    fl(e, t);
  }
}
function W0(e, t) {
  if ((s = e.length) > 0)
    for (var r, a = 0, i, o, d, c, s, p = e[t[0]].length; a < p; ++a)
      for (d = c = 0, r = 0; r < s; ++r)
        (o = (i = e[t[r]][a])[1] - i[0]) > 0 ? (i[0] = d, i[1] = d += o) : o < 0 ? (i[1] = c, i[0] = c += o) : (i[0] = 0, i[1] = o);
}
function j0(e, t) {
  if ((i = e.length) > 0) {
    for (var r = 0, a = e[t[0]], i, o = a.length; r < o; ++r) {
      for (var d = 0, c = 0; d < i; ++d)
        c += e[d][r][1] || 0;
      a[r][1] += a[r][0] = -c / 2;
    }
    fl(e, t);
  }
}
function U0(e, t) {
  if (!(!((d = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var r = 0, a = 1, i, o, d; a < o; ++a) {
      for (var c = 0, s = 0, p = 0; c < d; ++c) {
        for (var m = e[t[c]], y = m[a][1] || 0, x = m[a - 1][1] || 0, T = (y - x) / 2, S = 0; S < c; ++S) {
          var A = e[t[S]], E = A[a][1] || 0, b = A[a - 1][1] || 0;
          T += E - b;
        }
        s += y, p += T * y;
      }
      i[a - 1][1] += i[a - 1][0] = r, s && (r -= p / s);
    }
    i[a - 1][1] += i[a - 1][0] = r, fl(e, t);
  }
}
function K0(e) {
  var t = e.map(Y0);
  return pl(e).sort(function(r, a) {
    return t[r] - t[a];
  });
}
function Y0(e) {
  for (var t = -1, r = 0, a = e.length, i, o = -1 / 0; ++t < a; )
    (i = +e[t][1]) > o && (o = i, r = t);
  return r;
}
function zy(e) {
  var t = e.map(By);
  return pl(e).sort(function(r, a) {
    return t[r] - t[a];
  });
}
function By(e) {
  for (var t = 0, r = -1, a = e.length, i; ++r < a; )
    (i = +e[r][1]) && (t += i);
  return t;
}
function G0(e) {
  return zy(e).reverse();
}
function X0(e) {
  var t = e.length, r, a, i = e.map(By), o = K0(e), d = 0, c = 0, s = [], p = [];
  for (r = 0; r < t; ++r)
    a = o[r], d < c ? (d += i[a], s.push(a)) : (c += i[a], p.push(a));
  return p.reverse().concat(s);
}
function q0(e) {
  return pl(e).reverse();
}
function Tn(e, t) {
  e(t);
}
var Dh = {
  ascending: zy,
  descending: G0,
  insideout: X0,
  none: pl,
  reverse: q0
};
function fp(e) {
  return e && Dh[e] || Dh.none;
}
var _h = {
  expand: V0,
  diverging: W0,
  none: fl,
  silhouette: j0,
  wiggle: U0
};
function pp(e) {
  return e && _h[e] || _h.none;
}
function Z0(e) {
  var t = e === void 0 ? {} : e, r = t.innerRadius, a = t.outerRadius, i = t.cornerRadius, o = t.startAngle, d = t.endAngle, c = t.padAngle, s = t.padRadius, p = y0();
  return r != null && Tn(p.innerRadius, r), a != null && Tn(p.outerRadius, a), i != null && Tn(p.cornerRadius, i), o != null && Tn(p.startAngle, o), d != null && Tn(p.endAngle, d), c != null && Tn(p.padAngle, c), s != null && Tn(p.padRadius, s), p;
}
function hp(e) {
  var t = e === void 0 ? {} : e, r = t.x, a = t.x0, i = t.x1, o = t.y, d = t.y0, c = t.y1, s = t.defined, p = t.curve, m = g0();
  return r && Tn(m.x, r), a && Tn(m.x0, a), i && Tn(m.x1, i), o && Tn(m.y, o), d && Tn(m.y0, d), c && Tn(m.y1, c), s && m.defined(s), p && m.curve(p), m;
}
function $y(e) {
  var t = e === void 0 ? {} : e, r = t.x, a = t.y, i = t.defined, o = t.curve, d = Ty();
  return r && Tn(d.x, r), a && Tn(d.y, a), i && d.defined(i), o && d.curve(o), d;
}
function Q0(e) {
  var t = e === void 0 ? {} : e, r = t.startAngle, a = t.endAngle, i = t.padAngle, o = t.value, d = t.sort, c = t.sortValues, s = b0();
  return (d === null || d != null) && s.sort(d), (c === null || c != null) && s.sortValues(c), o != null && s.value(o), i != null && Tn(s.padAngle, i), r != null && Tn(s.startAngle, r), a != null && Tn(s.endAngle, a), s;
}
function J0(e) {
  var t = e.keys, r = e.value, a = e.order, i = e.offset, o = dp();
  return t && o.keys(t), r && Tn(o.value, r), a && o.order(fp(a)), i && o.offset(pp(i)), o;
}
var eE = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function Af() {
  return Af = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Af.apply(this, arguments);
}
function tE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function nE(e) {
  var t = e.className, r = e.top, a = e.left, i = e.data, o = i === void 0 ? [] : i, d = e.centroid, c = e.innerRadius, s = c === void 0 ? 0 : c, p = e.outerRadius, m = e.cornerRadius, y = e.startAngle, x = e.endAngle, T = e.padAngle, S = e.padRadius, A = e.pieSort, E = e.pieSortValues, b = e.pieValue, v = e.children, N = e.fill, C = N === void 0 ? "" : N, R = tE(e, eE), _ = Z0({
    innerRadius: s,
    outerRadius: p,
    cornerRadius: m,
    padRadius: S
  }), U = Q0({
    startAngle: y,
    endAngle: x,
    padAngle: T,
    value: b,
    sort: A,
    sortValues: E
  }), j = U(o);
  return v ? /* @__PURE__ */ n.createElement(n.Fragment, null, v({
    arcs: j,
    path: _,
    pie: U
  })) : /* @__PURE__ */ n.createElement(at, {
    className: "visx-pie-arcs-group",
    top: r,
    left: a
  }, j.map(function(te, Q) {
    return /* @__PURE__ */ n.createElement("g", {
      key: "pie-arc-" + Q
    }, /* @__PURE__ */ n.createElement("path", Af({
      className: Dn("visx-pie-arc", t),
      d: _(te) || "",
      fill: C == null || typeof C == "string" ? C : C(te)
    }, R)), d == null ? void 0 : d(_.centroid(te), te));
  }));
}
var rE = ["from", "to", "fill", "className", "innerRef"];
function Lf() {
  return Lf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Lf.apply(this, arguments);
}
function aE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function cn(e) {
  var t = e.from, r = t === void 0 ? {
    x: 0,
    y: 0
  } : t, a = e.to, i = a === void 0 ? {
    x: 1,
    y: 1
  } : a, o = e.fill, d = o === void 0 ? "transparent" : o, c = e.className, s = e.innerRef, p = aE(e, rE), m = r.x === i.x || r.y === i.y;
  return /* @__PURE__ */ n.createElement("line", Lf({
    ref: s,
    className: Dn("visx-line", c),
    x1: r.x,
    y1: r.y,
    x2: i.x,
    y2: i.y,
    fill: d,
    shapeRendering: m ? "crispEdges" : "auto"
  }, p));
}
var iE = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function Pf() {
  return Pf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Pf.apply(this, arguments);
}
function oE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Br(e) {
  var t = e.children, r = e.data, a = r === void 0 ? [] : r, i = e.x, o = e.y, d = e.fill, c = d === void 0 ? "transparent" : d, s = e.className, p = e.curve, m = e.innerRef, y = e.defined, x = y === void 0 ? function() {
    return !0;
  } : y, T = oE(e, iE), S = $y({
    x: i,
    y: o,
    defined: x,
    curve: p
  });
  return t ? /* @__PURE__ */ n.createElement(n.Fragment, null, t({
    path: S
  })) : /* @__PURE__ */ n.createElement("path", Pf({
    ref: m,
    className: Dn("visx-linepath", s),
    d: S(a) || "",
    fill: c,
    strokeLinecap: "round"
  }, T));
}
var lE = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function Nf() {
  return Nf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Nf.apply(this, arguments);
}
function sE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function uE(e) {
  var t = e.children, r = e.x, a = e.x0, i = e.x1, o = e.y, d = e.y0, c = e.y1, s = e.data, p = s === void 0 ? [] : s, m = e.defined, y = m === void 0 ? function() {
    return !0;
  } : m, x = e.className, T = e.curve, S = e.innerRef, A = sE(e, lE), E = hp({
    x: r,
    x0: a,
    x1: i,
    y: o,
    y0: d,
    y1: c,
    defined: y,
    curve: T
  });
  return t ? /* @__PURE__ */ n.createElement(n.Fragment, null, t({
    path: E
  })) : /* @__PURE__ */ n.createElement("path", Nf({
    ref: S,
    className: Dn("visx-area", x),
    d: E(p) || ""
  }, A));
}
var cE = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function Rf() {
  return Rf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Rf.apply(this, arguments);
}
function dE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Df(e) {
  var t = e.x, r = e.x0, a = e.x1, i = e.y, o = e.y1, d = e.y0, c = e.yScale, s = e.data, p = s === void 0 ? [] : s, m = e.defined, y = m === void 0 ? function() {
    return !0;
  } : m, x = e.className, T = e.curve, S = e.innerRef, A = e.children, E = dE(e, cE), b = hp({
    x: t,
    x0: r,
    x1: a,
    defined: y,
    curve: T
  });
  return d == null ? b.y0(c.range()[0]) : Tn(b.y0, d), i && !o && Tn(b.y1, i), o && !i && Tn(b.y1, o), A ? /* @__PURE__ */ n.createElement(n.Fragment, null, A({
    path: b
  })) : /* @__PURE__ */ n.createElement("path", Rf({
    ref: S,
    className: Dn("visx-area-closed", x),
    d: b(p) || ""
  }, E));
}
var fE = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function _f() {
  return _f = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, _f.apply(this, arguments);
}
function pE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function hE(e) {
  var t = e.className, r = e.top, a = e.left, i = e.keys, o = e.data, d = e.curve, c = e.defined, s = e.x, p = e.x0, m = e.x1, y = e.y0, x = e.y1, T = e.value, S = e.order, A = e.offset, E = e.color, b = e.children, v = pE(e, fE), N = J0({
    keys: i,
    value: T,
    order: S,
    offset: A
  }), C = hp({
    x: s,
    x0: p,
    x1: m,
    y0: y,
    y1: x,
    curve: d,
    defined: c
  }), R = N(o);
  return b ? /* @__PURE__ */ n.createElement(n.Fragment, null, b({
    stacks: R,
    path: C,
    stack: N
  })) : /* @__PURE__ */ n.createElement(at, {
    top: r,
    left: a
  }, R.map(function(_, U) {
    return /* @__PURE__ */ n.createElement("path", _f({
      className: Dn("visx-stack", t),
      key: "stack-" + U + "-" + (_.key || ""),
      d: C(_) || "",
      fill: E == null ? void 0 : E(_.key, U)
    }, v));
  }));
}
var mE = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function fc() {
  return fc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, fc.apply(this, arguments);
}
function yE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function gE(e) {
  var t = e.className, r = e.top, a = e.left, i = e.keys, o = e.data, d = e.curve, c = e.defined, s = e.x, p = e.x0, m = e.x1, y = e.y0, x = e.y1, T = e.value, S = e.order, A = e.offset, E = e.color, b = e.children, v = yE(e, mE);
  return /* @__PURE__ */ n.createElement(hE, fc({
    className: t,
    top: r,
    left: a,
    keys: i,
    data: o,
    curve: d,
    defined: c,
    x: s,
    x0: p,
    x1: m,
    y0: y,
    y1: x,
    value: T,
    order: S,
    offset: A,
    color: E
  }, v), b || function(N) {
    var C = N.stacks, R = N.path;
    return C.map(function(_, U) {
      return /* @__PURE__ */ n.createElement("path", fc({
        className: Dn("visx-area-stack", t),
        key: "area-stack-" + U + "-" + (_.key || ""),
        d: R(_) || "",
        fill: E == null ? void 0 : E(_.key, U)
      }, v));
    });
  });
}
function mp(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), r = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / r.length;
}
var vE = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function Of() {
  return Of = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Of.apply(this, arguments);
}
function xE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Iy(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.x0, d = e.x0Scale, c = e.x1Scale, s = e.yScale, p = e.color, m = e.keys, y = e.height, x = e.children, T = xE(e, vE), S = mp(c), A = t.map(function(E, b) {
    return {
      index: b,
      x0: d(o(E)),
      bars: m.map(function(v, N) {
        var C = E[v];
        return {
          index: N,
          key: v,
          value: C,
          width: S,
          x: c(v) || 0,
          y: s(C) || 0,
          color: p(v, N),
          height: y - (s(C) || 0)
        };
      })
    };
  });
  return x ? /* @__PURE__ */ n.createElement(n.Fragment, null, x(A)) : /* @__PURE__ */ n.createElement(at, {
    className: Dn("visx-bar-group", r),
    top: a,
    left: i
  }, A.map(function(E) {
    return /* @__PURE__ */ n.createElement(at, {
      key: "bar-group-" + E.index + "-" + E.x0,
      left: E.x0
    }, E.bars.map(function(b) {
      return /* @__PURE__ */ n.createElement(Lr, Of({
        key: "bar-group-bar-" + E.index + "-" + b.index + "-" + b.value + "-" + b.key,
        x: b.x,
        y: b.y,
        width: b.width,
        height: b.height,
        fill: b.color
      }, T));
    }));
  }));
}
function Hy(e) {
  return e == null ? void 0 : e[0];
}
function Vy(e) {
  return e == null ? void 0 : e[1];
}
var bE = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function Ff() {
  return Ff = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ff.apply(this, arguments);
}
function EE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Wy(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.x, d = e.y0, c = d === void 0 ? Hy : d, s = e.y1, p = s === void 0 ? Vy : s, m = e.xScale, y = e.yScale, x = e.color, T = e.keys, S = e.value, A = e.order, E = e.offset, b = e.children, v = EE(e, bE), N = dp();
  T && N.keys(T), S && Tn(N.value, S), A && N.order(fp(A)), E && N.offset(pp(E));
  var C = N(t), R = mp(m), _ = C.map(function(U, j) {
    var te = U.key;
    return {
      index: j,
      key: te,
      bars: U.map(function(Q, $) {
        var J = (y(c(Q)) || 0) - (y(p(Q)) || 0), ne = y(p(Q)), z = "bandwidth" in m ? m(o(Q.data)) : Math.max((m(o(Q.data)) || 0) - R / 2);
        return {
          bar: Q,
          key: te,
          index: $,
          height: J,
          width: R,
          x: z || 0,
          y: ne || 0,
          color: x(U.key, $)
        };
      })
    };
  });
  return b ? /* @__PURE__ */ n.createElement(n.Fragment, null, b(_)) : /* @__PURE__ */ n.createElement(at, {
    className: Dn("visx-bar-stack", r),
    top: a,
    left: i
  }, _.map(function(U) {
    return U.bars.map(function(j) {
      return /* @__PURE__ */ n.createElement(Lr, Ff({
        key: "bar-stack-" + U.index + "-" + j.index,
        x: j.x,
        y: j.y,
        height: j.height,
        width: j.width,
        fill: j.color
      }, v));
    });
  }));
}
var SE = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function Mf() {
  return Mf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Mf.apply(this, arguments);
}
function kE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function wE(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.y, d = e.x0, c = d === void 0 ? Hy : d, s = e.x1, p = s === void 0 ? Vy : s, m = e.xScale, y = e.yScale, x = e.color, T = e.keys, S = e.value, A = e.order, E = e.offset, b = e.children, v = kE(e, SE), N = dp();
  T && N.keys(T), S && Tn(N.value, S), A && N.order(fp(A)), E && N.offset(pp(E));
  var C = N(t), R = mp(y), _ = C.map(function(U, j) {
    var te = U.key;
    return {
      index: j,
      key: te,
      bars: U.map(function(Q, $) {
        var J = (m(p(Q)) || 0) - (m(c(Q)) || 0), ne = m(c(Q)), z = "bandwidth" in y ? y(o(Q.data)) : Math.max((y(o(Q.data)) || 0) - J / 2);
        return {
          bar: Q,
          key: te,
          index: $,
          height: R,
          width: J,
          x: ne || 0,
          y: z || 0,
          color: x(U.key, $)
        };
      })
    };
  });
  return b ? /* @__PURE__ */ n.createElement(n.Fragment, null, b(_)) : /* @__PURE__ */ n.createElement(at, {
    className: Dn("visx-bar-stack-horizontal", r),
    top: a,
    left: i
  }, _.map(function(U) {
    return U.bars.map(function(j) {
      return /* @__PURE__ */ n.createElement(Lr, Mf({
        key: "bar-stack-" + U.index + "-" + j.index,
        x: j.x,
        y: j.y,
        height: j.height,
        width: j.width,
        fill: j.color
      }, v));
    });
  }));
}
var Oh = "http://www.w3.org/2000/svg";
function CE(e) {
  var t = document.getElementById(e);
  if (!t) {
    var r = document.createElementNS(Oh, "svg");
    r.setAttribute("aria-hidden", "true"), r.style.opacity = "0", r.style.width = "0", r.style.height = "0", r.style.position = "absolute", r.style.top = "-100%", r.style.left = "-100%", r.style.pointerEvents = "none", t = document.createElementNS(Oh, "path"), t.setAttribute("id", e), r.appendChild(t), document.body.appendChild(r);
  }
  return t;
}
var TE = "__visx_splitpath_svg_path_measurement_id", Fh = function() {
  return !0;
};
function AE(e) {
  var t = e.path, r = e.pointsInSegments, a = e.segmentation, i = a === void 0 ? "x" : a, o = e.sampleRate, d = o === void 0 ? 1 : o;
  try {
    var c = CE(TE);
    c.setAttribute("d", t);
    var s = c.getTotalLength(), p = r.length, m = r.map(function() {
      return [];
    });
    if (i === "x" || i === "y")
      for (var y = r.map(function(ne) {
        var z;
        return (z = ne.find(function(W) {
          return typeof W[i] == "number";
        })) == null ? void 0 : z[i];
      }), x = c.getPointAtLength(0), T = c.getPointAtLength(s), S = T[i] > x[i], A = S ? y.map(function(ne) {
        return typeof ne > "u" ? Fh : function(z) {
          return z >= ne;
        };
      }) : y.map(function(ne) {
        return typeof ne > "u" ? Fh : function(z) {
          return z <= ne;
        };
      }), E = 0, b = 0; b <= s; b += d) {
        for (var v = c.getPointAtLength(b), N = v[i]; E < p - 1 && A[E + 1](N); )
          E += 1;
        m[E].push(v);
      }
    else {
      var C = r.map(function(ne) {
        return ne.length;
      }), R = C.reduce(function(ne, z) {
        return ne + z;
      }, 0), _ = s / Math.max(1, R - 1), U = C.slice(0, p - 1);
      U.unshift(0);
      for (var j = 2; j < p; j += 1)
        U[j] += U[j - 1];
      for (var te = 0; te < p; te += 1)
        U[te] *= _;
      for (var Q = 0, $ = 0; $ <= s; $ += d) {
        for (var J = c.getPointAtLength($); Q < p - 1 && $ >= U[Q + 1]; )
          Q += 1;
        m[Q].push(J);
      }
    }
    return m;
  } catch {
    return [];
  }
}
function zf() {
  return zf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, zf.apply(this, arguments);
}
var LE = function(t) {
  return t.x || 0;
}, PE = function(t) {
  return t.y || 0;
};
function jy(e) {
  var t = e.children, r = e.className, a = e.curve, i = e.defined, o = e.segmentation, d = e.sampleRate, c = e.segments, s = e.x, p = e.y, m = e.styles, y = ue.useMemo(function() {
    var S = typeof s == "number" || typeof s > "u" ? function() {
      return s;
    } : s, A = typeof p == "number" || typeof p > "u" ? function() {
      return p;
    } : p;
    return c.map(function(E) {
      return E.map(function(b, v) {
        return {
          x: S(b, v, E),
          y: A(b, v, E)
        };
      });
    });
  }, [s, p, c]), x = ue.useMemo(function() {
    var S = $y({
      x: s,
      y: p,
      defined: i,
      curve: a
    });
    return S(c.flat()) || "";
  }, [s, p, i, a, c]), T = ue.useMemo(function() {
    return AE({
      path: x,
      segmentation: o,
      pointsInSegments: y,
      sampleRate: d
    });
  }, [x, o, y, d]);
  return /* @__PURE__ */ n.createElement("g", null, T.map(function(S, A) {
    return t ? /* @__PURE__ */ n.createElement(n.Fragment, {
      key: A
    }, t({
      index: A,
      segment: S,
      styles: m[A] || m[A % m.length]
    })) : /* @__PURE__ */ n.createElement(Br, zf({
      key: A,
      className: r,
      data: S,
      x: LE,
      y: PE
    }, m[A] || m[A % m.length]));
  }));
}
jy.propTypes = {
  segments: $e.arrayOf($e.array).isRequired,
  styles: $e.array.isRequired,
  children: $e.func,
  className: $e.string
};
var NE = ["tooltipOpen"];
function RE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function pc() {
  return pc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, pc.apply(this, arguments);
}
function Uy(e) {
  var t = ue.useState(pc({
    tooltipOpen: !1
  }, e)), r = t[0], a = t[1], i = ue.useCallback(function(d) {
    return a(typeof d == "function" ? function(c) {
      c.tooltipOpen;
      var s = RE(c, NE);
      return pc({}, d(s), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: d.tooltipLeft,
      tooltipTop: d.tooltipTop,
      tooltipData: d.tooltipData
    });
  }, [a]), o = ue.useCallback(function() {
    return a({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [a]);
  return {
    tooltipOpen: r.tooltipOpen,
    tooltipLeft: r.tooltipLeft,
    tooltipTop: r.tooltipTop,
    tooltipData: r.tooltipData,
    updateTooltip: a,
    showTooltip: i,
    hideTooltip: o
  };
}
var DE = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function hc() {
  return hc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, hc.apply(this, arguments);
}
function _E(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var Ky = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, yp = /* @__PURE__ */ n.forwardRef(function(e, t) {
  var r = e.className, a = e.top, i = e.left, o = e.offsetLeft, d = o === void 0 ? 10 : o, c = e.offsetTop, s = c === void 0 ? 10 : c, p = e.style, m = p === void 0 ? Ky : p, y = e.children, x = e.unstyled, T = x === void 0 ? !1 : x, S = e.applyPositionStyle, A = S === void 0 ? !1 : S, E = _E(e, DE);
  return /* @__PURE__ */ n.createElement("div", hc({
    ref: t,
    className: Dn("visx-tooltip", r),
    style: hc({
      top: a == null || s == null ? a : a + s,
      left: i == null || d == null ? i : i + d
    }, A && {
      position: "absolute"
    }, !T && m)
  }, E), y);
});
yp.propTypes = {
  children: $e.node,
  className: $e.string,
  left: $e.number,
  offsetLeft: $e.number,
  offsetTop: $e.number,
  top: $e.number,
  applyPositionStyle: $e.bool,
  unstyled: $e.bool
};
yp.displayName = "Tooltip";
const OE = yp;
function Bf() {
  return Bf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Bf.apply(this, arguments);
}
function FE(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function ME(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, $f(e, t);
}
function $f(e, t) {
  return $f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, i) {
    return a.__proto__ = i, a;
  }, $f(e, t);
}
var Mh = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function zE(e) {
  var t;
  return t = /* @__PURE__ */ function(r) {
    ME(a, r);
    function a(o) {
      var d;
      return d = r.call(this, o) || this, d.state = {
        rect: void 0,
        parentRect: void 0
      }, d.nodeRef = /* @__PURE__ */ n.createRef(), d.getRects = d.getRects.bind(FE(d)), d;
    }
    var i = a.prototype;
    return i.componentDidMount = function() {
      var d, c = this;
      this.node = (d = this.nodeRef) != null && d.current ? this.nodeRef.current : ov.findDOMNode(this), this.setState(function() {
        return c.getRects();
      });
    }, i.getRects = function() {
      if (!this.node)
        return this.state;
      var d = this.node, c = d.parentNode, s = d.getBoundingClientRect ? d.getBoundingClientRect() : Mh, p = c != null && c.getBoundingClientRect ? c.getBoundingClientRect() : Mh;
      return {
        rect: s,
        parentRect: p
      };
    }, i.render = function() {
      return /* @__PURE__ */ n.createElement(e, Bf({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, a;
  }(n.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var Yy = /* @__PURE__ */ ue.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), BE = Yy.Provider;
Yy.Consumer;
var $E = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function mc() {
  return mc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, mc.apply(this, arguments);
}
function IE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Gy(e) {
  var t = e.children;
  e.getRects;
  var r = e.left, a = r === void 0 ? 0 : r, i = e.offsetLeft, o = i === void 0 ? 10 : i, d = e.offsetTop, c = d === void 0 ? 10 : d, s = e.parentRect, p = e.rect, m = e.style, y = m === void 0 ? Ky : m, x = e.top, T = x === void 0 ? 0 : x, S = e.unstyled, A = S === void 0 ? !1 : S, E = e.nodeRef, b = IE(e, $E), v, N = !1, C = !1;
  if (p && s) {
    var R = a, _ = T;
    if (s.width) {
      var U = R + o + p.width - s.width, j = p.width - R - o;
      N = U > 0 && U > j;
    } else {
      var te = R + o + p.width - window.innerWidth, Q = p.width - R - o;
      N = te > 0 && te > Q;
    }
    if (s.height) {
      var $ = _ + c + p.height - s.height, J = p.height - _ - c;
      C = $ > 0 && $ > J;
    } else
      C = _ + c + p.height > window.innerHeight;
    R = N ? R - p.width - o : R + o, _ = C ? _ - p.height - c : _ + c, R = Math.round(R), _ = Math.round(_), v = "translate(" + R + "px, " + _ + "px)";
  }
  return /* @__PURE__ */ n.createElement(OE, mc({
    ref: E,
    style: mc({
      left: 0,
      top: 0,
      transform: v
    }, !A && y)
  }, b), /* @__PURE__ */ n.createElement(BE, {
    value: {
      isFlippedVertically: !C,
      isFlippedHorizontally: !N
    }
  }, t));
}
Gy.propTypes = {
  nodeRef: $e.oneOfType([$e.string, $e.func, $e.object])
};
const Xy = zE(Gy), qy = (e) => {
  const {
    tableData: t,
    config: r,
    formatNumber: a,
    capitalize: i,
    formatDate: o,
    formatTooltipsDate: d,
    parseDate: c,
    setSharedFilter: s,
    isDraggingAnnotation: p
  } = ue.useContext(gt), { xScale: m, yScale: y, showTooltip: x, hideTooltip: T } = e, { xAxis: S, visualizationType: A, orientation: E, yAxis: b, runtime: v } = r, N = (ae, oe) => {
    var ce;
    let K = 0, Y = Number(y.invert(ae)), X = null, q = null;
    for (let ge of (ce = r.runtime) == null ? void 0 : ce.seriesKeys)
      if (oe.hasOwnProperty(ge) && (K += Number(oe[ge]), K >= Y)) {
        q = oe[ge], X = ge;
        break;
      }
    return [X, q];
  }, C = (ae, oe, K, Y) => {
    const X = K.general.showMissingDataLabel && (!oe || oe === "null"), q = ae === K.xAxis.dataKey ? oe : a(oe, Y(ae));
    return X ? "N/A" : q;
  }, R = (ae, oe) => {
    const { x: K, y: Y } = oe, q = {
      data: ae || {},
      dataXPosition: K + 10,
      dataYPosition: Y
    };
    return {
      tooltipLeft: q.dataXPosition,
      tooltipTop: q.dataYPosition,
      tooltipData: q
    };
  }, _ = (ae, oe) => {
    if (A === "Bump Chart" || (ae.stopPropagation(), p))
      return;
    const K = _p(ae), { x: Y, y: X } = K, { data: q, arc: ce } = oe ?? {}, ge = te(Y - Number(r.yAxis.size || 0)), De = t.filter((Ae) => Ae[S.dataKey] === Q(X)), me = E === "vertical" ? J(ge) : De, Fe = (Ae) => {
      const fe = r.runtime.series.filter((Oe) => Oe.dataKey === Ae)[0];
      return fe != null && fe.axis ? String(fe.axis).toLowerCase() : "left";
    }, Te = (() => {
      var Ve, Ze, Ie, qe;
      const Ae = r.columns, fe = [], ze = [];
      for (const [et, He] of Object.entries(Ae)) {
        const Ge = {
          addColPrefix: r.columns[et].prefix,
          addColSuffix: r.columns[et].suffix,
          addColRoundTo: r.columns[et].roundToPlace ? r.columns[et].roundToPlace : "",
          addColCommas: r.columns[et].commas
        };
        let Le = null;
        r.visualizationType === "Pie" ? Le = ce == null ? void 0 : ce.data[He.name] : Le = (Ve = me[0]) == null ? void 0 : Ve[He.name];
        const _e = qf(Le, "left", !0, r, Ge);
        He.tooltips && fe.push([He.label, _e]);
      }
      const Oe = [];
      if (fe.forEach((et) => {
        Oe.push([et[0], et[1]]);
      }), A === "Pie" && ze.push(
        // ignore
        [r.xAxis.dataKey, q],
        [r.runtime.yAxis.dataKey, a(ce == null ? void 0 : ce.data[r.runtime.yAxis.dataKey])],
        ["Percent", `${Math.round(((ce == null ? void 0 : ce.endAngle) - (ce == null ? void 0 : ce.startAngle)) * 180 / Math.PI / 360 * 100) + "%"}`]
      ), A === "Forest Plot" && ze.push([r.xAxis.dataKey, Q(X)]), A !== "Pie" && A !== "Forest Plot" && !r.tooltips.singleSeries && (ze.push(
        ...(Ie = (Ze = ne()) == null ? void 0 : Ze.filter((et) => {
          var Ge, Le;
          return ((Ge = r.runtime.series) == null ? void 0 : Ge.find(
            (_e) => _e.dataKey === et && (_e == null ? void 0 : _e.tooltip) && !_e.dynamicCategory
          )) || ((Le = r.xAxis) == null ? void 0 : Le.dataKey) == et || A === "Forecasting";
        })) == null ? void 0 : Ie.flatMap((et) => {
          var Le;
          const He = (Le = me[0]) == null ? void 0 : Le[et], Ge = C(et, He, r, Fe);
          return (He == null || He === "" || Ge === "N/A") && r.general.hideNullValue ? [] : [[et, Ge, Fe(et)]];
        })
      ), (qe = r.runtime.series) == null || qe.forEach((et) => {
        if (et != null && et.dynamicCategory) {
          const He = et.dataKey, Ge = me.find((st) => st[et.dynamicCategory] === He);
          if (!Ge)
            return;
          const Le = Ge[et.originalDataKey], _e = C(He, Le, r, Fe);
          ze.push([He, _e, Fe(He)]);
        }
      })), A !== "Pie" && A !== "Forest Plot" && r.tooltips.singleSeries) {
        const [et, He] = N(X, me[0]);
        if (et && He) {
          ze.push([r.xAxis.dataKey, ge]);
          const Ge = C(et, He, r, Fe);
          ze.push([et, Ge]);
        }
      }
      return [...ze, ...Oe];
    })();
    if (!Te)
      return;
    const ve = R(Te, K);
    x(ve);
  }, U = () => {
    r.visualizationType === "Area Chart" ? setTimeout(() => {
      T();
    }, 3e3) : T();
  }, j = (ae) => {
    if (r.xAxis.type === "categorical" || r.visualizationType === "Combo") {
      let oe = m.step();
      const Y = Math.floor(Number(ae) / oe);
      return m.domain()[Y - 1];
    }
    if (Rn(r.xAxis) && r.visualizationType !== "Combo") {
      const oe = Xp((q) => c(q[r.xAxis.dataKey])).left, K = m.invert(m(ae)), Y = oe(r.data, K, 1);
      return c(r.data[Y - 1][r.xAxis.dataKey]);
    }
  }, te = (ae, oe = !1) => {
    if (A !== "Pie" && E !== "horizontal") {
      if (m.type === "point" || S.type === "continuous" || Rn(S)) {
        let K = null, Y = Number.MAX_VALUE, X = ae;
        return t.forEach((q) => {
          const ce = Rn(S) ? m(c(q[S.dataKey])) : m(q[S.dataKey]);
          let ge = r.barHeight;
          const De = Math.abs(Number(ce - X + (oe ? ge * 2 : 0)));
          De <= Y && (Y = De, K = (Rn(S), q[S.dataKey]));
        }), K;
      }
      if (r.xAxis.type === "categorical" || A === "Combo" && E !== "horizontal" && A !== "Forest Plot") {
        let Y = (m.range()[1] - m.range()[0]) / (m.domain().length + 1);
        const q = Math.floor((Number(ae) - Y / 2) / Y);
        return m.domain()[q];
      }
      if (Rn(S) && A !== "Combo" && E !== "horizontal") {
        const K = Xp((ce) => c(ce[r.xAxis.dataKey])).left, Y = m.invert(ae), X = K(r.data, Y, 1);
        return c(r.data[X - 1][r.xAxis.dataKey]);
      }
    }
  }, Q = (ae, oe) => {
    if (A === "Pie")
      return;
    let K = Number.MAX_VALUE, Y = null;
    return t.forEach((X, q) => {
      const ce = y(A !== "Forest Plot" ? X[r.xAxis.dataKey] : q), ge = Math.abs(ce - ae);
      ge < K && (K = ge, Y = oe ? X[oe] : X[r.xAxis.dataKey]);
    }), Y;
  }, $ = (ae) => {
    var oe, K;
    try {
      if (r.visualizationType === "Bump Chart")
        return;
      const Y = _p(ae), { x: X } = Y;
      if (!X)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let q = te(X, !0), ce = (oe = r.data) == null ? void 0 : oe.filter((ge) => ge[r.xAxis.dataKey] === q);
      if (!q)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (Rn(S) && q && (q = new Date(q), q = o(q), ce = (K = r.data) == null ? void 0 : K.filter((ge) => o(new Date(ge[r.xAxis.dataKey])) === q)), !ce[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${q}`);
      s && (r != null && r.uid) && (ce != null && ce[0]) && s(r.uid, ce[0]);
    } catch (Y) {
      console.error(Y.message);
    }
  }, J = (ae) => {
    const K = r.runtime.series.filter(
      (q) => A === "Pie" || q.tooltip === !0 && !q.dynamicCategory
    ).map((q) => q.dataKey);
    K.push(r.xAxis.dataKey);
    const Y = lt.uniq(
      r.runtime.series.flatMap((q) => {
        if (q.dynamicCategory)
          return [q.dynamicCategory, q.originalDataKey];
      })
    );
    K.push(...Y), r.visualizationType === "Forecasting" && r.runtime.series.map((q) => {
      q.confidenceIntervals.map((ce) => {
        ce.showInTooltip && (K.push(ce.high), K.push(ce.low));
      });
    });
    const X = Object.values(r.columns).map((q) => q.name);
    K.push(...X, ...X);
    try {
      const q = t.filter((ge) => ge[S.dataKey] === ae);
      return !q || q.length === 0 ? [] : q.map((ge) => lt.pick(ge, K));
    } catch (q) {
      console.error("COVE", q);
    }
  }, ne = () => {
    var ae;
    try {
      let oe, K = [], Y = [];
      if ((ae = r.runtime.series) == null || ae.forEach((X) => {
        X.type === "Forecasting" && (K.push(X.stageColumn), X == null || X.confidenceIntervals.forEach((q) => {
          q.showInTooltip === !0 && (Y.push(q.low), Y.push(q.high));
        }));
      }), !r.dashboard)
        switch (A) {
          case "Combo":
            oe = [v.xAxis.dataKey, ...v == null ? void 0 : v.seriesKeys, ...Y];
            break;
          case "Forecasting":
            oe = [v.xAxis.dataKey, ...K, ...Y];
            break;
          case "Line":
            oe = [v.xAxis.dataKey, ...v == null ? void 0 : v.seriesKeys];
            break;
          case "Area Chart":
            oe = [v.xAxis.dataKey, ...v == null ? void 0 : v.seriesKeys];
            break;
          case "Bar":
            oe = E === "vertical" ? [v.xAxis.dataKey, ...v == null ? void 0 : v.seriesKeys] : [v.yAxis.dataKey, ...v == null ? void 0 : v.seriesKeys];
            break;
          case "Pie":
            oe = [v.xAxis.dataKey, ...v == null ? void 0 : v.seriesKeys];
          default:
            throw new Error("No visualization type found in handleTooltipMouseOver");
        }
      return r.dashboard && (oe = [
        v.xAxis.dataKey,
        ...v == null ? void 0 : v.barSeriesKeys,
        ...v == null ? void 0 : v.lineSeriesKeys,
        ...K,
        ...Y
      ]), oe;
    } catch (oe) {
      console.error("COVE", oe);
    }
  }, z = (ae) => {
    const { dataXPosition: oe, dataYPosition: K } = ae;
    return {
      opacity: r.tooltips.opacity ? r.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${oe}px, ${Number(K)}px)`
    };
  }, W = (ae) => {
    var K, Y;
    let oe = r.runtime.series.filter((X) => X.dataKey === ae);
    return (K = oe[0]) != null && K.name ? (Y = oe[0]) == null ? void 0 : Y.name : ae;
  };
  return {
    getIncludedTooltipSeries: ne,
    getXValueFromCoordinate: te,
    getXValueFromCoordinateDate: j,
    getYScaleValues: J,
    handleTooltipClick: $,
    handleTooltipMouseOff: U,
    handleTooltipMouseOver: _,
    TooltipListItem: ({ item: ae }) => {
      var Ue;
      const [oe, K] = ae, [Y, X, q] = K;
      if (A === "Forest Plot")
        return Y === r.xAxis.dataKey ? /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(r.xAxis.dataKey ? `${r.xAxis.dataKey}: ` : "")} ${Rn(b) ? o(c(Y, !1)) : X}`) : /* @__PURE__ */ n.createElement("li", { className: "tooltip-body" }, `${W(Y)}: ${a(X, "left")}`);
      const ce = r.tooltips.dateDisplayFormat ? d(c(X, !1)) : o(c(X, !1));
      if (A === "Bar" && E === "horizontal" && Y === r.xAxis.dataKey)
        return /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(
          r.runtime.yAxis.label ? `${r.runtime.yAxis.label}: ` : ""
        )} ${r.xAxis.type === "date" ? ce : X}`);
      if (Y === r.xAxis.dataKey)
        return /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(
          r.runtime.xAxis.label ? `${r.runtime.xAxis.label}: ` : ""
        )} ${Rn(S) ? ce : X}`);
      const { label: ge, displayGray: De } = r.visualizationSubType !== "stacked" && r.general.showSuppressedSymbol && ((Ue = r.preliminaryData) == null ? void 0 : Ue.find(
        (Te) => Te.label && Te.type === "suppression" && Te.displayTooltip && X === Te.value && (!Te.column || Y === Te.column)
      )) || {};
      let me = ge || X;
      const Fe = De ? { color: "#8b8b8a" } : {};
      return oe == 1 && r.dataFormat.onlyShowTopPrefixSuffix && (me = `${r.dataFormat.prefix}${me}${r.dataFormat.suffix}`), /* @__PURE__ */ n.createElement("li", { style: Fe, className: "tooltip-body" }, `${W(Y)}: ${me}`);
    },
    tooltipStyles: z
  };
};
function gp(e, { threshold: t = 0, root: r = null, rootMargin: a = "0%", freezeOnceVisible: i = !1 }) {
  const [o, d] = ue.useState(), c = (o == null ? void 0 : o.isIntersecting) && i, s = ([p]) => {
    d(p);
  };
  return ue.useEffect(() => {
    setTimeout(() => {
      const p = e == null ? void 0 : e.current;
      if (!!!window.IntersectionObserver || c || !p)
        return;
      const y = { threshold: t, root: r, rootMargin: a }, x = new IntersectionObserver(s, y);
      return x.observe(p), () => x.disconnect();
    }, 500);
  }, [e, t, r, a, c]), o;
}
const If = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let r = "";
    return e.visualizationType && (r += `${e.visualizationType} chart`), e.title && e.visualizationType && (r += ` with the title: ${e.title}`), r;
  } catch (r) {
    console.error("COVE: ", r.message);
  }
}, Mu = ({ startAngle: e, endAngle: t }) => ({
  startAngle: e,
  endAngle: t
}), HE = (e) => {
  const {
    transformedData: t,
    config: r,
    colorScale: a,
    currentViewport: i,
    seriesHighlight: o,
    isDraggingAnnotation: d
  } = ue.useContext(gt), { tooltipData: c, showTooltip: s, hideTooltip: p, tooltipOpen: m, tooltipLeft: y, tooltipTop: x } = Uy(), { handleTooltipMouseOver: T, handleTooltipMouseOff: S, TooltipListItem: A } = qy({
    xScale: !1,
    yScale: !1,
    showTooltip: s,
    hideTooltip: p
  }), [E, b] = ue.useState(void 0), [v, N] = ue.useState(!1), C = Object.values(r.columns).filter((Y) => Y.showInViz), R = C.length > 0, _ = R ? "pivotColumn" : void 0, U = ue.useMemo(() => {
    if (R) {
      let Y = [];
      const X = r.yAxis.dataKey, q = C.map((De) => De.name), ce = [X, ...q], ge = r.xAxis.dataKey;
      return t.forEach((De) => {
        ce.forEach((me) => {
          const Fe = De[me];
          Fe && Y.push({
            [_]: Fe,
            [ge]: `${De[ge]} - ${me}`
          });
        });
      }), Y;
    }
    return t;
  }, [t, R]), j = ue.useMemo(() => {
    if (R) {
      const Y = {};
      U.forEach((ce) => {
        Y[ce[r.xAxis.dataKey]] || (Y[ce[r.xAxis.dataKey]] = !0);
      });
      const X = Object.entries(Y).length;
      let q = r.customColors || vr[r.palette];
      return q = q.slice(0, X), Ii({
        domain: Object.keys(Y),
        range: q,
        unknown: null
      });
    }
    return a;
  }, [a, R]), te = ue.useRef(), Q = gp(te, {
    freezeOnceVisible: !1
  });
  ue.useEffect(() => {
    document.querySelector(".isEditor") && N((X) => !0);
  }), ue.useEffect(() => {
    Q != null && Q.isIntersecting && r.animate && !v && setTimeout(() => {
      N(!0);
    }, 500);
  }, [Q == null ? void 0 : Q.isIntersecting, r.animate]);
  const $ = ({ arcs: Y, path: X, getKey: q }) => {
    const ce = jb(Y, q, {
      from: Mu,
      enter: Mu,
      update: Mu,
      leave: Mu
    });
    return ue.useEffect(() => {
      const ge = setTimeout(() => {
        p();
      }, 500);
      return () => {
        clearTimeout(ge);
      };
    }, [c]), /* @__PURE__ */ n.createElement(n.Fragment, null, ce.map(({ item: ge, props: De, key: me }, Fe) => /* @__PURE__ */ n.createElement(
      at,
      {
        className: ge.data[r.xAxis.dataKey],
        key: `${me}-${Fe}`,
        style: {
          opacity: r.legend.behavior === "highlight" && o.length > 0 && o.indexOf(ge.data[r.runtime.xAxis.dataKey]) === -1 ? 0.5 : 1
        }
      },
      /* @__PURE__ */ n.createElement(
        Ah.path,
        {
          d: Bb(
            [De.startAngle, De.endAngle],
            (Ue, Te) => X({
              ...ge,
              startAngle: Ue,
              endAngle: Te
            })
          ),
          fill: j(ge.data[r.runtime.xAxis.dataKey]),
          onMouseEnter: (Ue) => T(Ue, { data: ge.data[r.runtime.xAxis.dataKey], arc: ge }),
          onMouseLeave: (Ue) => S()
        }
      )
    )), ce.map(({ item: ge, key: De }, me) => {
      const Fe = Number(r.dataFormat.roundTo) || 0, [Ue, Te] = X.centroid(ge), ve = ge.endAngle - ge.startAngle >= 0.1;
      let Ae = "#FFF";
      j(ge.data[r.runtime.xAxis.dataKey]) && (Ae = ll(Ae, j(ge.data[r.runtime.xAxis.dataKey])));
      const Oe = ((ge.endAngle - ge.startAngle) * 180 / Math.PI / 360 * 100).toFixed(Fe);
      return /* @__PURE__ */ n.createElement(Ah.g, { key: `${De}${me}` }, ve && /* @__PURE__ */ n.createElement(
        vt,
        {
          style: { fill: Ae },
          x: Ue,
          y: Te,
          dy: ".33em",
          textAnchor: "middle",
          pointerEvents: "none"
        },
        Oe + "%"
      ));
    }));
  };
  let J = e.parentWidth, ne = e.parentWidth;
  r && r.legend && !r.legend.hide && i === "lg" && (ne = Number(J) * 0.73);
  const z = r.heights.vertical, W = Math.min(ne, z) / 2, ie = z / 2, ae = e.parentWidth / 2, oe = r.pieType === "Donut" ? 75 : W;
  ue.useEffect(() => {
    if (o.length > 0 && r.legend.behavior !== "highlight") {
      let Y = [];
      U.forEach((X) => {
        o.indexOf(X[r.runtime.xAxis.dataKey]) !== -1 && Y.push(X);
      }), b(Y);
    } else
      b(void 0);
  }, [o]);
  const K = () => {
    let Y = ["animated-pie", "group"];
    return (r.animate === !1 || v) && Y.push("animated"), Y.join(" ");
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement($r, { component: "PieChart" }, /* @__PURE__ */ n.createElement(
    "svg",
    {
      width: W * 2,
      height: z,
      className: K(),
      role: "img",
      "aria-label": If(r)
    },
    /* @__PURE__ */ n.createElement(at, { top: ie, left: W }, /* @__PURE__ */ n.createElement(
      nE,
      {
        data: E || U,
        pieValue: (Y) => Y[_ || r.runtime.yAxis.dataKey],
        pieSortValues: () => -1,
        innerRadius: W - oe,
        outerRadius: W
      },
      (Y) => /* @__PURE__ */ n.createElement($, { ...Y, getKey: (X) => X.data[r.runtime.xAxis.dataKey] })
    ))
  ), /* @__PURE__ */ n.createElement("div", { ref: te }), !d && c && Object.entries(c.data).length > 0 && m && s && c.dataYPosition && c.dataXPosition && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${r.tooltips.opacity / 100}) !important`), /* @__PURE__ */ n.createElement(
    Xy,
    {
      key: Math.random(),
      className: "tooltip cdc-open-viz-module",
      left: y + ae - W,
      top: x
    },
    /* @__PURE__ */ n.createElement("ul", null, typeof c == "object" && Object.entries(c.data).map((Y, X) => /* @__PURE__ */ n.createElement(A, { item: Y, key: X })))
  ))));
};
function Ds(e) {
  return e.split("-")[1];
}
function vp(e) {
  return e === "y" ? "height" : "width";
}
function ji(e) {
  return e.split("-")[0];
}
function _s(e) {
  return ["top", "bottom"].includes(ji(e)) ? "x" : "y";
}
function zh(e, t, r) {
  let { reference: a, floating: i } = e;
  const o = a.x + a.width / 2 - i.width / 2, d = a.y + a.height / 2 - i.height / 2, c = _s(t), s = vp(c), p = a[s] / 2 - i[s] / 2, m = c === "x";
  let y;
  switch (ji(t)) {
    case "top":
      y = { x: o, y: a.y - i.height };
      break;
    case "bottom":
      y = { x: o, y: a.y + a.height };
      break;
    case "right":
      y = { x: a.x + a.width, y: d };
      break;
    case "left":
      y = { x: a.x - i.width, y: d };
      break;
    default:
      y = { x: a.x, y: a.y };
  }
  switch (Ds(t)) {
    case "start":
      y[c] -= p * (r && m ? -1 : 1);
      break;
    case "end":
      y[c] += p * (r && m ? -1 : 1);
  }
  return y;
}
function Zy(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function xs(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Qy(e, t) {
  var r;
  t === void 0 && (t = {});
  const { x: a, y: i, platform: o, rects: d, elements: c, strategy: s } = e, { boundary: p = "clippingAncestors", rootBoundary: m = "viewport", elementContext: y = "floating", altBoundary: x = !1, padding: T = 0 } = t, S = Zy(T), A = c[x ? y === "floating" ? "reference" : "floating" : y], E = xs(await o.getClippingRect({ element: (r = await (o.isElement == null ? void 0 : o.isElement(A))) == null || r ? A : A.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(c.floating)), boundary: p, rootBoundary: m, strategy: s })), b = y === "floating" ? { ...d.floating, x: a, y: i } : d.reference, v = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c.floating)), N = await (o.isElement == null ? void 0 : o.isElement(v)) && await (o.getScale == null ? void 0 : o.getScale(v)) || { x: 1, y: 1 }, C = xs(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: b, offsetParent: v, strategy: s }) : b);
  return { top: (E.top - C.top + S.top) / N.y, bottom: (C.bottom - E.bottom + S.bottom) / N.y, left: (E.left - C.left + S.left) / N.x, right: (C.right - E.right + S.right) / N.x };
}
const VE = Math.min, WE = Math.max;
function Hf(e, t, r) {
  return WE(e, VE(t, r));
}
["top", "right", "bottom", "left"].reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const jE = { left: "right", right: "left", bottom: "top", top: "bottom" };
function yc(e) {
  return e.replace(/left|right|bottom|top/g, (t) => jE[t]);
}
function UE(e, t, r) {
  r === void 0 && (r = !1);
  const a = Ds(e), i = _s(e), o = vp(i);
  let d = i === "x" ? a === (r ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (d = yc(d)), { main: d, cross: yc(d) };
}
const KE = { start: "end", end: "start" };
function qd(e) {
  return e.replace(/start|end/g, (t) => KE[t]);
}
const YE = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var r;
    const { placement: a, middlewareData: i, rects: o, initialPlacement: d, platform: c, elements: s } = t, { mainAxis: p = !0, crossAxis: m = !0, fallbackPlacements: y, fallbackStrategy: x = "bestFit", fallbackAxisSideDirection: T = "none", flipAlignment: S = !0, ...A } = e, E = ji(a), b = ji(d) === d, v = await (c.isRTL == null ? void 0 : c.isRTL(s.floating)), N = y || (b || !S ? [yc(d)] : function($) {
      const J = yc($);
      return [qd($), J, qd(J)];
    }(d));
    y || T === "none" || N.push(...function($, J, ne, z) {
      const W = Ds($);
      let ie = function(ae, oe, K) {
        const Y = ["left", "right"], X = ["right", "left"], q = ["top", "bottom"], ce = ["bottom", "top"];
        switch (ae) {
          case "top":
          case "bottom":
            return K ? oe ? X : Y : oe ? Y : X;
          case "left":
          case "right":
            return oe ? q : ce;
          default:
            return [];
        }
      }(ji($), ne === "start", z);
      return W && (ie = ie.map((ae) => ae + "-" + W), J && (ie = ie.concat(ie.map(qd)))), ie;
    }(d, S, T, v));
    const C = [d, ...N], R = await Qy(t, A), _ = [];
    let U = ((r = i.flip) == null ? void 0 : r.overflows) || [];
    if (p && _.push(R[E]), m) {
      const { main: $, cross: J } = UE(a, o, v);
      _.push(R[$], R[J]);
    }
    if (U = [...U, { placement: a, overflows: _ }], !_.every(($) => $ <= 0)) {
      var j, te;
      const $ = (((j = i.flip) == null ? void 0 : j.index) || 0) + 1, J = C[$];
      if (J)
        return { data: { index: $, overflows: U }, reset: { placement: J } };
      let ne = (te = U.find((z) => z.overflows[0] <= 0)) == null ? void 0 : te.placement;
      if (!ne)
        switch (x) {
          case "bestFit": {
            var Q;
            const z = (Q = U.map((W) => [W.placement, W.overflows.filter((ie) => ie > 0).reduce((ie, ae) => ie + ae, 0)]).sort((W, ie) => W[1] - ie[1])[0]) == null ? void 0 : Q[0];
            z && (ne = z);
            break;
          }
          case "initialPlacement":
            ne = d;
        }
      if (a !== ne)
        return { reset: { placement: ne } };
    }
    return {};
  } };
}, GE = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: r, y: a } = t, i = await async function(o, d) {
      const { placement: c, platform: s, elements: p } = o, m = await (s.isRTL == null ? void 0 : s.isRTL(p.floating)), y = ji(c), x = Ds(c), T = _s(c) === "x", S = ["left", "top"].includes(y) ? -1 : 1, A = m && T ? -1 : 1, E = typeof d == "function" ? d(o) : d;
      let { mainAxis: b, crossAxis: v, alignmentAxis: N } = typeof E == "number" ? { mainAxis: E, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...E };
      return x && typeof N == "number" && (v = x === "end" ? -1 * N : N), T ? { x: v * A, y: b * S } : { x: b * S, y: v * A };
    }(t, e);
    return { x: r + i.x, y: a + i.y, data: i };
  } };
}, XE = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: r, y: a, placement: i } = t, { mainAxis: o = !0, crossAxis: d = !1, limiter: c = { fn: (E) => {
      let { x: b, y: v } = E;
      return { x: b, y: v };
    } }, ...s } = e, p = { x: r, y: a }, m = await Qy(t, s), y = _s(ji(i)), x = y === "x" ? "y" : "x";
    let T = p[y], S = p[x];
    if (o) {
      const E = y === "y" ? "bottom" : "right";
      T = Hf(T + m[y === "y" ? "top" : "left"], T, T - m[E]);
    }
    if (d) {
      const E = x === "y" ? "bottom" : "right";
      S = Hf(S + m[x === "y" ? "top" : "left"], S, S - m[E]);
    }
    const A = c.fn({ ...t, [y]: T, [x]: S });
    return { ...A, data: { x: A.x - r, y: A.y - a } };
  } };
};
function Ar(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Zr(e) {
  return Ar(e).getComputedStyle(e);
}
const Bh = Math.min, bs = Math.max, gc = Math.round;
function Jy(e) {
  const t = Zr(e);
  let r = parseFloat(t.width), a = parseFloat(t.height);
  const i = e.offsetWidth, o = e.offsetHeight, d = gc(r) !== i || gc(a) !== o;
  return d && (r = i, a = o), { width: r, height: a, fallback: d };
}
function Ka(e) {
  return tg(e) ? (e.nodeName || "").toLowerCase() : "";
}
let zu;
function eg() {
  if (zu)
    return zu;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (zu = e.brands.map((t) => t.brand + "/" + t.version).join(" "), zu) : navigator.userAgent;
}
function Qr(e) {
  return e instanceof Ar(e).HTMLElement;
}
function Ha(e) {
  return e instanceof Ar(e).Element;
}
function tg(e) {
  return e instanceof Ar(e).Node;
}
function $h(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Ar(e).ShadowRoot || e instanceof ShadowRoot;
}
function zc(e) {
  const { overflow: t, overflowX: r, overflowY: a, display: i } = Zr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + r) && !["inline", "contents"].includes(i);
}
function qE(e) {
  return ["table", "td", "th"].includes(Ka(e));
}
function Vf(e) {
  const t = /firefox/i.test(eg()), r = Zr(e), a = r.backdropFilter || r.WebkitBackdropFilter;
  return r.transform !== "none" || r.perspective !== "none" || !!a && a !== "none" || t && r.willChange === "filter" || t && !!r.filter && r.filter !== "none" || ["transform", "perspective"].some((i) => r.willChange.includes(i)) || ["paint", "layout", "strict", "content"].some((i) => {
    const o = r.contain;
    return o != null && o.includes(i);
  });
}
function ng() {
  return !/^((?!chrome|android).)*safari/i.test(eg());
}
function xp(e) {
  return ["html", "body", "#document"].includes(Ka(e));
}
function rg(e) {
  return Ha(e) ? e : e.contextElement;
}
const ag = { x: 1, y: 1 };
function ol(e) {
  const t = rg(e);
  if (!Qr(t))
    return ag;
  const r = t.getBoundingClientRect(), { width: a, height: i, fallback: o } = Jy(t);
  let d = (o ? gc(r.width) : r.width) / a, c = (o ? gc(r.height) : r.height) / i;
  return d && Number.isFinite(d) || (d = 1), c && Number.isFinite(c) || (c = 1), { x: d, y: c };
}
function Ps(e, t, r, a) {
  var i, o;
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  const d = e.getBoundingClientRect(), c = rg(e);
  let s = ag;
  t && (a ? Ha(a) && (s = ol(a)) : s = ol(e));
  const p = c ? Ar(c) : window, m = !ng() && r;
  let y = (d.left + (m && ((i = p.visualViewport) == null ? void 0 : i.offsetLeft) || 0)) / s.x, x = (d.top + (m && ((o = p.visualViewport) == null ? void 0 : o.offsetTop) || 0)) / s.y, T = d.width / s.x, S = d.height / s.y;
  if (c) {
    const A = Ar(c), E = a && Ha(a) ? Ar(a) : a;
    let b = A.frameElement;
    for (; b && a && E !== A; ) {
      const v = ol(b), N = b.getBoundingClientRect(), C = getComputedStyle(b);
      N.x += (b.clientLeft + parseFloat(C.paddingLeft)) * v.x, N.y += (b.clientTop + parseFloat(C.paddingTop)) * v.y, y *= v.x, x *= v.y, T *= v.x, S *= v.y, y += N.x, x += N.y, b = Ar(b).frameElement;
    }
  }
  return { width: T, height: S, top: x, right: y + T, bottom: x + S, left: y, x: y, y: x };
}
function Va(e) {
  return ((tg(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function Bc(e) {
  return Ha(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function ig(e) {
  return Ps(Va(e)).left + Bc(e).scrollLeft;
}
function Ns(e) {
  if (Ka(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || $h(e) && e.host || Va(e);
  return $h(t) ? t.host : t;
}
function og(e) {
  const t = Ns(e);
  return xp(t) ? t.ownerDocument.body : Qr(t) && zc(t) ? t : og(t);
}
function lg(e, t) {
  var r;
  t === void 0 && (t = []);
  const a = og(e), i = a === ((r = e.ownerDocument) == null ? void 0 : r.body), o = Ar(a);
  return i ? t.concat(o, o.visualViewport || [], zc(a) ? a : []) : t.concat(a, lg(a));
}
function Ih(e, t, r) {
  return t === "viewport" ? xs(function(a, i) {
    const o = Ar(a), d = Va(a), c = o.visualViewport;
    let s = d.clientWidth, p = d.clientHeight, m = 0, y = 0;
    if (c) {
      s = c.width, p = c.height;
      const x = ng();
      (x || !x && i === "fixed") && (m = c.offsetLeft, y = c.offsetTop);
    }
    return { width: s, height: p, x: m, y };
  }(e, r)) : Ha(t) ? xs(function(a, i) {
    const o = Ps(a, !0, i === "fixed"), d = o.top + a.clientTop, c = o.left + a.clientLeft, s = Qr(a) ? ol(a) : { x: 1, y: 1 };
    return { width: a.clientWidth * s.x, height: a.clientHeight * s.y, x: c * s.x, y: d * s.y };
  }(t, r)) : xs(function(a) {
    const i = Va(a), o = Bc(a), d = a.ownerDocument.body, c = bs(i.scrollWidth, i.clientWidth, d.scrollWidth, d.clientWidth), s = bs(i.scrollHeight, i.clientHeight, d.scrollHeight, d.clientHeight);
    let p = -o.scrollLeft + ig(a);
    const m = -o.scrollTop;
    return Zr(d).direction === "rtl" && (p += bs(i.clientWidth, d.clientWidth) - c), { width: c, height: s, x: p, y: m };
  }(Va(e)));
}
function Hh(e) {
  return Qr(e) && Zr(e).position !== "fixed" ? e.offsetParent : null;
}
function Vh(e) {
  const t = Ar(e);
  let r = Hh(e);
  for (; r && qE(r) && Zr(r).position === "static"; )
    r = Hh(r);
  return r && (Ka(r) === "html" || Ka(r) === "body" && Zr(r).position === "static" && !Vf(r)) ? t : r || function(a) {
    let i = Ns(a);
    for (; Qr(i) && !xp(i); ) {
      if (Vf(i))
        return i;
      i = Ns(i);
    }
    return null;
  }(e) || t;
}
function ZE(e, t, r) {
  const a = Qr(t), i = Va(t), o = Ps(e, !0, r === "fixed", t);
  let d = { scrollLeft: 0, scrollTop: 0 };
  const c = { x: 0, y: 0 };
  if (a || !a && r !== "fixed")
    if ((Ka(t) !== "body" || zc(i)) && (d = Bc(t)), Qr(t)) {
      const s = Ps(t, !0);
      c.x = s.x + t.clientLeft, c.y = s.y + t.clientTop;
    } else
      i && (c.x = ig(i));
  return { x: o.left + d.scrollLeft - c.x, y: o.top + d.scrollTop - c.y, width: o.width, height: o.height };
}
const QE = { getClippingRect: function(e) {
  let { element: t, boundary: r, rootBoundary: a, strategy: i } = e;
  const o = r === "clippingAncestors" ? function(p, m) {
    const y = m.get(p);
    if (y)
      return y;
    let x = lg(p).filter((E) => Ha(E) && Ka(E) !== "body"), T = null;
    const S = Zr(p).position === "fixed";
    let A = S ? Ns(p) : p;
    for (; Ha(A) && !xp(A); ) {
      const E = Zr(A), b = Vf(A);
      (S ? b || T : b || E.position !== "static" || !T || !["absolute", "fixed"].includes(T.position)) ? T = E : x = x.filter((v) => v !== A), A = Ns(A);
    }
    return m.set(p, x), x;
  }(t, this._c) : [].concat(r), d = [...o, a], c = d[0], s = d.reduce((p, m) => {
    const y = Ih(t, m, i);
    return p.top = bs(y.top, p.top), p.right = Bh(y.right, p.right), p.bottom = Bh(y.bottom, p.bottom), p.left = bs(y.left, p.left), p;
  }, Ih(t, c, i));
  return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: r, strategy: a } = e;
  const i = Qr(r), o = Va(r);
  if (r === o)
    return t;
  let d = { scrollLeft: 0, scrollTop: 0 }, c = { x: 1, y: 1 };
  const s = { x: 0, y: 0 };
  if ((i || !i && a !== "fixed") && ((Ka(r) !== "body" || zc(o)) && (d = Bc(r)), Qr(r))) {
    const p = Ps(r);
    c = ol(r), s.x = p.x + r.clientLeft, s.y = p.y + r.clientTop;
  }
  return { width: t.width * c.x, height: t.height * c.y, x: t.x * c.x - d.scrollLeft * c.x + s.x, y: t.y * c.y - d.scrollTop * c.y + s.y };
}, isElement: Ha, getDimensions: function(e) {
  return Qr(e) ? Jy(e) : e.getBoundingClientRect();
}, getOffsetParent: Vh, getDocumentElement: Va, getScale: ol, async getElementRects(e) {
  let { reference: t, floating: r, strategy: a } = e;
  const i = this.getOffsetParent || Vh, o = this.getDimensions;
  return { reference: ZE(t, await i(r), a), floating: { x: 0, y: 0, ...await o(r) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => Zr(e).direction === "rtl" }, Wh = (e, t, r) => {
  const a = /* @__PURE__ */ new Map(), i = { platform: QE, ...r }, o = { ...i.platform, _c: a };
  return (async (d, c, s) => {
    const { placement: p = "bottom", strategy: m = "absolute", middleware: y = [], platform: x } = s, T = y.filter(Boolean), S = await (x.isRTL == null ? void 0 : x.isRTL(c));
    if (x == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), T.filter((R) => {
      let { name: _ } = R;
      return _ === "autoPlacement" || _ === "flip";
    }).length > 1)
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    d && c || console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    let A = await x.getElementRects({ reference: d, floating: c, strategy: m }), { x: E, y: b } = zh(A, p, S), v = p, N = {}, C = 0;
    for (let R = 0; R < T.length; R++) {
      const { name: _, fn: U } = T[R], { x: j, y: te, data: Q, reset: $ } = await U({ x: E, y: b, initialPlacement: p, placement: v, strategy: m, middlewareData: N, rects: A, platform: x, elements: { reference: d, floating: c } });
      E = j ?? E, b = te ?? b, N = { ...N, [_]: { ...N[_], ...Q } }, C > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), $ && C <= 50 && (C++, typeof $ == "object" && ($.placement && (v = $.placement), $.rects && (A = $.rects === !0 ? await x.getElementRects({ reference: d, floating: c, strategy: m }) : $.rects), { x: E, y: b } = zh(A, v, S)), R = -1);
    }
    return { x: E, y: b, placement: v, strategy: m, middlewareData: N };
  })(e, t, { ...i, platform: o });
};
var $a, Ui = { exports: {} }, jh = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
$a = jh, function() {
  var e = n, t = 60103, r = 60106;
  $a.Fragment = 60107;
  var a = 60108, i = 60114, o = 60109, d = 60110, c = 60112, s = 60113, p = 60120, m = 60115, y = 60116, x = 60121, T = 60122, S = 60117, A = 60129, E = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var b = Symbol.for;
    t = b("react.element"), r = b("react.portal"), $a.Fragment = b("react.fragment"), a = b("react.strict_mode"), i = b("react.profiler"), o = b("react.provider"), d = b("react.context"), c = b("react.forward_ref"), s = b("react.suspense"), p = b("react.suspense_list"), m = b("react.memo"), y = b("react.lazy"), x = b("react.block"), T = b("react.server.block"), S = b("react.fundamental"), b("react.scope"), b("react.opaque.id"), A = b("react.debug_trace_mode"), b("react.offscreen"), E = b("react.legacy_hidden");
  }
  var v = typeof Symbol == "function" && Symbol.iterator, N = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function C(ve) {
    for (var Ae = arguments.length, fe = new Array(Ae > 1 ? Ae - 1 : 0), ze = 1; ze < Ae; ze++)
      fe[ze - 1] = arguments[ze];
    R("error", ve, fe);
  }
  function R(ve, Ae, fe) {
    var ze = N.ReactDebugCurrentFrame, Oe = "";
    if (te) {
      var Ve = U(te.type), Ze = te._owner;
      Oe += function(qe, et, He) {
        var Ge = "";
        if (et) {
          var Le = et.fileName, _e = Le.replace(_, "");
          if (/^index\./.test(_e)) {
            var st = Le.match(_);
            if (st) {
              var Ee = st[1];
              Ee && (_e = Ee.replace(_, "") + "/" + _e);
            }
          }
          Ge = " (at " + _e + ":" + et.lineNumber + ")";
        } else
          He && (Ge = " (created by " + He + ")");
        return `
    in ` + (qe || "Unknown") + Ge;
      }(Ve, te._source, Ze && U(Ze.type));
    }
    (Oe += ze.getStackAddendum()) !== "" && (Ae += "%s", fe = fe.concat([Oe]));
    var Ie = fe.map(function(qe) {
      return "" + qe;
    });
    Ie.unshift("Warning: " + Ae), Function.prototype.apply.call(console[ve], console, Ie);
  }
  var _ = /^(.*)[\\\/]/;
  function U(ve) {
    if (ve == null)
      return null;
    if (typeof ve.tag == "number" && C("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof ve == "function")
      return ve.displayName || ve.name || null;
    if (typeof ve == "string")
      return ve;
    switch (ve) {
      case $a.Fragment:
        return "Fragment";
      case r:
        return "Portal";
      case i:
        return "Profiler";
      case a:
        return "StrictMode";
      case s:
        return "Suspense";
      case p:
        return "SuspenseList";
    }
    if (typeof ve == "object")
      switch (ve.$$typeof) {
        case d:
          return "Context.Consumer";
        case o:
          return "Context.Provider";
        case c:
          return ze = ve, Oe = ve.render, Ve = "ForwardRef", Ze = Oe.displayName || Oe.name || "", ze.displayName || (Ze !== "" ? Ve + "(" + Ze + ")" : Ve);
        case m:
          return U(ve.type);
        case x:
          return U(ve.render);
        case y:
          var Ae = (fe = ve)._status === 1 ? fe._result : null;
          if (Ae)
            return U(Ae);
      }
    var fe, ze, Oe, Ve, Ze;
    return null;
  }
  var j = {};
  N.ReactDebugCurrentFrame;
  var te = null;
  function Q(ve) {
    te = ve;
  }
  var $, J, ne, z = N.ReactCurrentOwner, W = Object.prototype.hasOwnProperty, ie = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ae(ve, Ae, fe, ze, Oe) {
    var Ve, Ze = {}, Ie = null, qe = null;
    for (Ve in fe !== void 0 && (Ie = "" + fe), function(Ge) {
      if (W.call(Ge, "key")) {
        var Le = Object.getOwnPropertyDescriptor(Ge, "key").get;
        if (Le && Le.isReactWarning)
          return !1;
      }
      return Ge.key !== void 0;
    }(Ae) && (Ie = "" + Ae.key), function(Ge) {
      if (W.call(Ge, "ref")) {
        var Le = Object.getOwnPropertyDescriptor(Ge, "ref").get;
        if (Le && Le.isReactWarning)
          return !1;
      }
      return Ge.ref !== void 0;
    }(Ae) && (qe = Ae.ref, function(Ge, Le) {
      if (typeof Ge.ref == "string" && z.current && Le && z.current.stateNode !== Le) {
        var _e = U(z.current.type);
        ne[_e] || (C('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', U(z.current.type), Ge.ref), ne[_e] = !0);
      }
    }(Ae, Oe)), Ae)
      W.call(Ae, Ve) && !ie.hasOwnProperty(Ve) && (Ze[Ve] = Ae[Ve]);
    if (ve && ve.defaultProps) {
      var et = ve.defaultProps;
      for (Ve in et)
        Ze[Ve] === void 0 && (Ze[Ve] = et[Ve]);
    }
    if (Ie || qe) {
      var He = typeof ve == "function" ? ve.displayName || ve.name || "Unknown" : ve;
      Ie && function(Ge, Le) {
        var _e = function() {
          $ || ($ = !0, C("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Le));
        };
        _e.isReactWarning = !0, Object.defineProperty(Ge, "key", { get: _e, configurable: !0 });
      }(Ze, He), qe && function(Ge, Le) {
        var _e = function() {
          J || (J = !0, C("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Le));
        };
        _e.isReactWarning = !0, Object.defineProperty(Ge, "ref", { get: _e, configurable: !0 });
      }(Ze, He);
    }
    return function(Ge, Le, _e, st, Ee, rt, pt) {
      var ft = { $$typeof: t, type: Ge, key: Le, ref: _e, props: pt, _owner: rt, _store: {} };
      return Object.defineProperty(ft._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(ft, "_self", { configurable: !1, enumerable: !1, writable: !1, value: st }), Object.defineProperty(ft, "_source", { configurable: !1, enumerable: !1, writable: !1, value: Ee }), Object.freeze && (Object.freeze(ft.props), Object.freeze(ft)), ft;
    }(ve, Ie, qe, Oe, ze, z.current, Ze);
  }
  ne = {};
  var oe, K = N.ReactCurrentOwner;
  function Y(ve) {
    te = ve;
  }
  function X(ve) {
    return typeof ve == "object" && ve !== null && ve.$$typeof === t;
  }
  function q() {
    if (K.current) {
      var ve = U(K.current.type);
      if (ve)
        return `

Check the render method of \`` + ve + "`.";
    }
    return "";
  }
  N.ReactDebugCurrentFrame, oe = !1;
  var ce = {};
  function ge(ve, Ae) {
    if (ve._store && !ve._store.validated && ve.key == null) {
      ve._store.validated = !0;
      var fe = function(Oe) {
        var Ve = q();
        if (!Ve) {
          var Ze = typeof Oe == "string" ? Oe : Oe.displayName || Oe.name;
          Ze && (Ve = `

Check the top-level render call using <` + Ze + ">.");
        }
        return Ve;
      }(Ae);
      if (!ce[fe]) {
        ce[fe] = !0;
        var ze = "";
        ve && ve._owner && ve._owner !== K.current && (ze = " It was passed a child from " + U(ve._owner.type) + "."), Y(ve), C('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', fe, ze), Y(null);
      }
    }
  }
  function De(ve, Ae) {
    if (typeof ve == "object") {
      if (Array.isArray(ve))
        for (var fe = 0; fe < ve.length; fe++) {
          var ze = ve[fe];
          X(ze) && ge(ze, Ae);
        }
      else if (X(ve))
        ve._store && (ve._store.validated = !0);
      else if (ve) {
        var Oe = function(Ie) {
          if (Ie === null || typeof Ie != "object")
            return null;
          var qe = v && Ie[v] || Ie["@@iterator"];
          return typeof qe == "function" ? qe : null;
        }(ve);
        if (typeof Oe == "function" && Oe !== ve.entries)
          for (var Ve, Ze = Oe.call(ve); !(Ve = Ze.next()).done; )
            X(Ve.value) && ge(Ve.value, Ae);
      }
    }
  }
  function me(ve) {
    var Ae, fe = ve.type;
    if (fe != null && typeof fe != "string") {
      if (typeof fe == "function")
        Ae = fe.propTypes;
      else {
        if (typeof fe != "object" || fe.$$typeof !== c && fe.$$typeof !== m)
          return;
        Ae = fe.propTypes;
      }
      if (Ae) {
        var ze = U(fe);
        (function(Oe, Ve, Ze, Ie, qe) {
          var et = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var He in Oe)
            if (et(Oe, He)) {
              var Ge = void 0;
              try {
                if (typeof Oe[He] != "function") {
                  var Le = Error((Ie || "React class") + ": " + Ze + " type `" + He + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Oe[He] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Le.name = "Invariant Violation", Le;
                }
                Ge = Oe[He](Ve, He, Ie, Ze, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (_e) {
                Ge = _e;
              }
              !Ge || Ge instanceof Error || (Q(qe), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ie || "React class", Ze, He, typeof Ge), Q(null)), Ge instanceof Error && !(Ge.message in j) && (j[Ge.message] = !0, Q(qe), C("Failed %s type: %s", Ze, Ge.message), Q(null));
            }
        })(Ae, ve.props, "prop", ze, ve);
      } else
        fe.PropTypes === void 0 || oe || (oe = !0, C("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", U(fe) || "Unknown"));
      typeof fe.getDefaultProps != "function" || fe.getDefaultProps.isReactClassApproved || C("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function Fe(ve, Ae, fe, ze, Oe, Ve) {
    var Ze = function(_e) {
      return typeof _e == "string" || typeof _e == "function" || _e === $a.Fragment || _e === i || _e === A || _e === a || _e === s || _e === p || _e === E || typeof _e == "object" && _e !== null && (_e.$$typeof === y || _e.$$typeof === m || _e.$$typeof === o || _e.$$typeof === d || _e.$$typeof === c || _e.$$typeof === S || _e.$$typeof === x || _e[0] === T);
    }(ve);
    if (!Ze) {
      var Ie = "";
      (ve === void 0 || typeof ve == "object" && ve !== null && Object.keys(ve).length === 0) && (Ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
      var qe, et = function(_e) {
        return _e !== void 0 ? `

Check your code at ` + _e.fileName.replace(/^.*[\\\/]/, "") + ":" + _e.lineNumber + "." : "";
      }(Oe);
      Ie += et || q(), ve === null ? qe = "null" : Array.isArray(ve) ? qe = "array" : ve !== void 0 && ve.$$typeof === t ? (qe = "<" + (U(ve.type) || "Unknown") + " />", Ie = " Did you accidentally export a JSX literal instead of a component?") : qe = typeof ve, C("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", qe, Ie);
    }
    var He = ae(ve, Ae, fe, Oe, Ve);
    if (He == null)
      return He;
    if (Ze) {
      var Ge = Ae.children;
      if (Ge !== void 0)
        if (ze)
          if (Array.isArray(Ge)) {
            for (var Le = 0; Le < Ge.length; Le++)
              De(Ge[Le], ve);
            Object.freeze && Object.freeze(Ge);
          } else
            C("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          De(Ge, ve);
    }
    return ve === $a.Fragment ? function(_e) {
      for (var st = Object.keys(_e.props), Ee = 0; Ee < st.length; Ee++) {
        var rt = st[Ee];
        if (rt !== "children" && rt !== "key") {
          Y(_e), C("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", rt), Y(null);
          break;
        }
      }
      _e.ref !== null && (Y(_e), C("Invalid attribute `ref` supplied to `React.Fragment`."), Y(null));
    }(He) : me(He), He;
  }
  var Ue = function(ve, Ae, fe) {
    return Fe(ve, Ae, fe, !1);
  }, Te = function(ve, Ae, fe) {
    return Fe(ve, Ae, fe, !0);
  };
  $a.jsx = Ue, $a.jsxs = Te;
}(), Ui.exports = jh;
var Zd, sg = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
Zd = sg, function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var r = [], a = 0; a < arguments.length; a++) {
      var i = arguments[a];
      if (i) {
        var o = typeof i;
        if (o === "string" || o === "number")
          r.push(i);
        else if (Array.isArray(i)) {
          if (i.length) {
            var d = t.apply(null, i);
            d && r.push(d);
          }
        } else if (o === "object") {
          if (i.toString !== Object.prototype.toString && !i.toString.toString().includes("[native code]")) {
            r.push(i.toString());
            continue;
          }
          for (var c in i)
            e.call(i, c) && i[c] && r.push(c);
        }
      }
    }
    return r.join(" ");
  }
  Zd.exports ? (t.default = t, Zd.exports = t) : window.classNames = t;
}();
var Uh = sg.exports;
const Kh = (e, t, r) => {
  let a = null;
  return function(...i) {
    a && clearTimeout(a), a = setTimeout(() => {
      a = null, r || e.apply(this, i);
    }, t);
  };
}, JE = ({ content: e }) => Ui.exports.jsx("span", { dangerouslySetInnerHTML: { __html: e } }), eS = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} }, tS = ue.createContext({ getTooltipData: () => eS });
function ug(e = "DEFAULT_TOOLTIP_ID") {
  return ue.useContext(tS).getTooltipData(e);
}
const Yh = async ({ elementReference: e = null, tooltipReference: t = null, tooltipArrowReference: r = null, place: a = "top", offset: i = 10, strategy: o = "absolute", middlewares: d = [GE(Number(i)), YE(), XE({ padding: 5 })] }) => {
  if (!e)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  if (t === null)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  const c = d;
  return r ? (c.push({ name: "arrow", options: s = { element: r, padding: 5 }, async fn(p) {
    const { element: m, padding: y = 0 } = s || {}, { x, y: T, placement: S, rects: A, platform: E } = p;
    if (m == null)
      return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."), {};
    const b = Zy(y), v = { x, y: T }, N = _s(S), C = vp(N), R = await E.getDimensions(m), _ = N === "y" ? "top" : "left", U = N === "y" ? "bottom" : "right", j = A.reference[C] + A.reference[N] - v[N] - A.floating[C], te = v[N] - A.reference[N], Q = await (E.getOffsetParent == null ? void 0 : E.getOffsetParent(m));
    let $ = Q ? N === "y" ? Q.clientHeight || 0 : Q.clientWidth || 0 : 0;
    $ === 0 && ($ = A.floating[C]);
    const J = j / 2 - te / 2, ne = b[_], z = $ - R[C] - b[U], W = $ / 2 - R[C] / 2 + J, ie = Hf(ne, W, z), ae = Ds(S) != null && W != ie && A.reference[C] / 2 - (W < ne ? b[_] : b[U]) - R[C] / 2 < 0;
    return { [N]: v[N] - (ae ? W < ne ? ne - W : z - W : 0), data: { [N]: ie, centerOffset: W - ie } };
  } }), Wh(e, t, { placement: a, strategy: o, middleware: c }).then(({ x: p, y: m, placement: y, middlewareData: x }) => {
    var T, S;
    const A = { left: `${p}px`, top: `${m}px` }, { x: E, y: b } = (T = x.arrow) !== null && T !== void 0 ? T : { x: 0, y: 0 };
    return { tooltipStyles: A, tooltipArrowStyles: { left: E != null ? `${E}px` : "", top: b != null ? `${b}px` : "", right: "", bottom: "", [(S = { top: "bottom", right: "left", bottom: "top", left: "right" }[y.split("-")[0]]) !== null && S !== void 0 ? S : "bottom"]: "-4px" } };
  })) : Wh(e, t, { placement: "bottom", strategy: o, middleware: c }).then(({ x: p, y: m }) => ({ tooltipStyles: { left: `${p}px`, top: `${m}px` }, tooltipArrowStyles: {} }));
  var s;
};
var Di = { tooltip: "styles-module_tooltip__mnnfp", fixed: "styles-module_fixed__7ciUi", arrow: "styles-module_arrow__K0L3T", "no-arrow": "styles-module_no-arrow__KcFZN", clickable: "styles-module_clickable__Bv9o7", show: "styles-module_show__2NboJ", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
const Gh = ({ id: e, className: t, classNameArrow: r, variant: a = "dark", anchorId: i, anchorSelect: o, place: d = "top", offset: c = 10, events: s = ["hover"], positionStrategy: p = "absolute", middlewares: m, wrapper: y, children: x = null, delayShow: T = 0, delayHide: S = 0, float: A = !1, noArrow: E = !1, clickable: b = !1, closeOnEsc: v = !1, style: N, position: C, afterShow: R, afterHide: _, content: U, html: j, isOpen: te, setIsOpen: Q, activeAnchor: $, setActiveAnchor: J }) => {
  const ne = ue.useRef(null), z = ue.useRef(null), W = ue.useRef(null), ie = ue.useRef(null), [ae, oe] = ue.useState({}), [K, Y] = ue.useState({}), [X, q] = ue.useState(!1), [ce, ge] = ue.useState(!1), De = ue.useRef(!1), me = ue.useRef(null), { anchorRefs: Fe, setActiveAnchor: Ue } = ug(e), Te = ue.useRef(!1), [ve, Ae] = ue.useState([]), fe = ue.useRef(!1);
  ue.useLayoutEffect(() => (fe.current = !0, () => {
    fe.current = !1;
  }), []), ue.useEffect(() => {
    if (!X) {
      const Ee = setTimeout(() => {
        ge(!1);
      }, 150);
      return () => {
        clearTimeout(Ee);
      };
    }
    return () => null;
  }, [X]);
  const ze = (Ee) => {
    fe.current && (Ee && ge(!0), setTimeout(() => {
      fe.current && (Q == null || Q(Ee), te === void 0 && q(Ee));
    }, 10));
  };
  ue.useEffect(() => {
    if (te === void 0)
      return () => null;
    te && ge(!0);
    const Ee = setTimeout(() => {
      q(te);
    }, 10);
    return () => {
      clearTimeout(Ee);
    };
  }, [te]), ue.useEffect(() => {
    X !== De.current && (De.current = X, X ? R == null || R() : _ == null || _());
  }, [X]);
  const Oe = (Ee = S) => {
    ie.current && clearTimeout(ie.current), ie.current = setTimeout(() => {
      Te.current || ze(!1);
    }, Ee);
  }, Ve = (Ee) => {
    var rt;
    if (!Ee)
      return;
    T ? (W.current && clearTimeout(W.current), W.current = setTimeout(() => {
      ze(!0);
    }, T)) : ze(!0);
    const pt = (rt = Ee.currentTarget) !== null && rt !== void 0 ? rt : Ee.target;
    J(pt), Ue({ current: pt }), ie.current && clearTimeout(ie.current);
  }, Ze = () => {
    b ? Oe(S || 100) : S ? Oe() : ze(!1), W.current && clearTimeout(W.current);
  }, Ie = ({ x: Ee, y: rt }) => {
    Yh({ place: d, offset: c, elementReference: { getBoundingClientRect: () => ({ x: Ee, y: rt, width: 0, height: 0, top: rt, left: Ee, right: Ee, bottom: rt }) }, tooltipReference: ne.current, tooltipArrowReference: z.current, strategy: p, middlewares: m }).then((pt) => {
      Object.keys(pt.tooltipStyles).length && oe(pt.tooltipStyles), Object.keys(pt.tooltipArrowStyles).length && Y(pt.tooltipArrowStyles);
    });
  }, qe = (Ee) => {
    if (!Ee)
      return;
    const rt = Ee, pt = { x: rt.clientX, y: rt.clientY };
    Ie(pt), me.current = pt;
  }, et = (Ee) => {
    Ve(Ee), S && Oe();
  }, He = (Ee) => {
    const rt = document.querySelector(`[id='${i}']`);
    rt != null && rt.contains(Ee.target) || ve.some((pt) => pt.contains(Ee.target)) || ze(!1);
  }, Ge = (Ee) => {
    Ee.key === "Escape" && ze(!1);
  }, Le = Kh(Ve, 50), _e = Kh(Ze, 50);
  ue.useEffect(() => {
    var Ee, rt;
    const pt = new Set(Fe);
    ve.forEach((jt) => {
      pt.add({ current: jt });
    });
    const ft = document.querySelector(`[id='${i}']`);
    ft && pt.add({ current: ft }), v && window.addEventListener("keydown", Ge);
    const wt = [];
    s.find((jt) => jt === "click") && (window.addEventListener("click", He), wt.push({ event: "click", listener: et })), s.find((jt) => jt === "hover") && (wt.push({ event: "mouseenter", listener: Le }, { event: "mouseleave", listener: _e }, { event: "focus", listener: Le }, { event: "blur", listener: _e }), A && wt.push({ event: "mousemove", listener: qe }));
    const zt = () => {
      Te.current = !0;
    }, Jt = () => {
      Te.current = !1, Ze();
    };
    return b && ((Ee = ne.current) === null || Ee === void 0 || Ee.addEventListener("mouseenter", zt), (rt = ne.current) === null || rt === void 0 || rt.addEventListener("mouseleave", Jt)), wt.forEach(({ event: jt, listener: on }) => {
      pt.forEach((_t) => {
        var tn;
        (tn = _t.current) === null || tn === void 0 || tn.addEventListener(jt, on);
      });
    }), () => {
      var jt, on;
      s.find((_t) => _t === "click") && window.removeEventListener("click", He), v && window.removeEventListener("keydown", Ge), b && ((jt = ne.current) === null || jt === void 0 || jt.removeEventListener("mouseenter", zt), (on = ne.current) === null || on === void 0 || on.removeEventListener("mouseleave", Jt)), wt.forEach(({ event: _t, listener: tn }) => {
        pt.forEach(($t) => {
          var Ut;
          (Ut = $t.current) === null || Ut === void 0 || Ut.removeEventListener(_t, tn);
        });
      });
    };
  }, [ce, Fe, ve, v, s]), ue.useEffect(() => {
    let Ee = o ?? "";
    !Ee && e && (Ee = `[data-tooltip-id='${e}']`);
    const rt = new MutationObserver((pt) => {
      const ft = [];
      pt.forEach((wt) => {
        if (wt.type === "attributes" && wt.attributeName === "data-tooltip-id" && wt.target.getAttribute("data-tooltip-id") === e && ft.push(wt.target), wt.type === "childList" && ($ && [...wt.removedNodes].some((zt) => !!zt.contains($) && (ge(!1), ze(!1), J(null), !0)), Ee))
          try {
            const zt = [...wt.addedNodes].filter((Jt) => Jt.nodeType === 1);
            ft.push(...zt.filter((Jt) => Jt.matches(Ee))), ft.push(...zt.flatMap((Jt) => [...Jt.querySelectorAll(Ee)]));
          } catch {
          }
      }), ft.length && Ae((wt) => [...wt, ...ft]);
    });
    return rt.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"] }), () => {
      rt.disconnect();
    };
  }, [e, o, $]), ue.useEffect(() => {
    C ? Ie(C) : A ? me.current && Ie(me.current) : Yh({ place: d, offset: c, elementReference: $, tooltipReference: ne.current, tooltipArrowReference: z.current, strategy: p, middlewares: m }).then((Ee) => {
      fe.current && (Object.keys(Ee.tooltipStyles).length && oe(Ee.tooltipStyles), Object.keys(Ee.tooltipArrowStyles).length && Y(Ee.tooltipArrowStyles));
    });
  }, [X, $, U, j, d, c, p, C]), ue.useEffect(() => {
    var Ee;
    const rt = document.querySelector(`[id='${i}']`), pt = [...ve, rt];
    $ && pt.includes($) || J((Ee = ve[0]) !== null && Ee !== void 0 ? Ee : rt);
  }, [i, ve, $]), ue.useEffect(() => () => {
    W.current && clearTimeout(W.current), ie.current && clearTimeout(ie.current);
  }, []), ue.useEffect(() => {
    let Ee = o;
    if (!Ee && e && (Ee = `[data-tooltip-id='${e}']`), Ee)
      try {
        const rt = Array.from(document.querySelectorAll(Ee));
        Ae(rt);
      } catch {
        Ae([]);
      }
  }, [e, o]);
  const st = !!(j || U || x) && X && Object.keys(ae).length > 0;
  return ce ? Ui.exports.jsxs(y, { id: e, role: "tooltip", className: Uh("react-tooltip", Di.tooltip, Di[a], t, { [Di.show]: st, [Di.fixed]: p === "fixed", [Di.clickable]: b }), style: { ...N, ...ae }, ref: ne, children: [j && Ui.exports.jsx(JE, { content: j }) || U || x, Ui.exports.jsx(y, { className: Uh("react-tooltip-arrow", Di.arrow, r, { [Di["no-arrow"]]: E }), style: K, ref: z })] }) : null;
}, vc = ({ id: e, anchorId: t, anchorSelect: r, content: a, html: i, className: o, classNameArrow: d, variant: c = "dark", place: s = "top", offset: p = 10, wrapper: m = "div", children: y = null, events: x = ["hover"], positionStrategy: T = "absolute", middlewares: S, delayShow: A = 0, delayHide: E = 0, float: b = !1, noArrow: v = !1, clickable: N = !1, closeOnEsc: C = !1, style: R, position: _, isOpen: U, setIsOpen: j, afterShow: te, afterHide: Q }) => {
  const [$, J] = ue.useState(a), [ne, z] = ue.useState(i), [W, ie] = ue.useState(s), [ae, oe] = ue.useState(c), [K, Y] = ue.useState(p), [X, q] = ue.useState(A), [ce, ge] = ue.useState(E), [De, me] = ue.useState(b), [Fe, Ue] = ue.useState(m), [Te, ve] = ue.useState(x), [Ae, fe] = ue.useState(T), [ze, Oe] = ue.useState(null), { anchorRefs: Ve, activeAnchor: Ze } = ug(e), Ie = (He) => He == null ? void 0 : He.getAttributeNames().reduce((Ge, Le) => {
    var _e;
    return Le.startsWith("data-tooltip-") && (Ge[Le.replace(/^data-tooltip-/, "")] = (_e = He == null ? void 0 : He.getAttribute(Le)) !== null && _e !== void 0 ? _e : null), Ge;
  }, {}), qe = (He) => {
    const Ge = { place: (Le) => {
      var _e;
      ie((_e = Le) !== null && _e !== void 0 ? _e : s);
    }, content: (Le) => {
      J(Le ?? a);
    }, html: (Le) => {
      z(Le ?? i);
    }, variant: (Le) => {
      var _e;
      oe((_e = Le) !== null && _e !== void 0 ? _e : c);
    }, offset: (Le) => {
      Y(Le === null ? p : Number(Le));
    }, wrapper: (Le) => {
      var _e;
      Ue((_e = Le) !== null && _e !== void 0 ? _e : m);
    }, events: (Le) => {
      const _e = Le == null ? void 0 : Le.split(" ");
      ve(_e ?? x);
    }, "position-strategy": (Le) => {
      var _e;
      fe((_e = Le) !== null && _e !== void 0 ? _e : T);
    }, "delay-show": (Le) => {
      q(Le === null ? A : Number(Le));
    }, "delay-hide": (Le) => {
      ge(Le === null ? E : Number(Le));
    }, float: (Le) => {
      me(Le === null ? b : !!Le);
    } };
    Object.values(Ge).forEach((Le) => Le(null)), Object.entries(He).forEach(([Le, _e]) => {
      var st;
      (st = Ge[Le]) === null || st === void 0 || st.call(Ge, _e);
    });
  };
  ue.useEffect(() => {
    J(a);
  }, [a]), ue.useEffect(() => {
    z(i);
  }, [i]), ue.useEffect(() => {
    ie(s);
  }, [s]), ue.useEffect(() => {
    var He;
    const Ge = new Set(Ve);
    let Le = r;
    if (!Le && e && (Le = `[data-tooltip-id='${e}']`), Le)
      try {
        document.querySelectorAll(Le).forEach((pt) => {
          Ge.add({ current: pt });
        });
      } catch {
        console.warn(`[react-tooltip] "${r}" is not a valid CSS selector`);
      }
    const _e = document.querySelector(`[id='${t}']`);
    if (_e && Ge.add({ current: _e }), !Ge.size)
      return () => null;
    const st = (He = ze ?? _e) !== null && He !== void 0 ? He : Ze.current, Ee = new MutationObserver((pt) => {
      pt.forEach((ft) => {
        var wt;
        if (!st || ft.type !== "attributes" || !(!((wt = ft.attributeName) === null || wt === void 0) && wt.startsWith("data-tooltip-")))
          return;
        const zt = Ie(st);
        qe(zt);
      });
    }), rt = { attributes: !0, childList: !1, subtree: !1 };
    if (st) {
      const pt = Ie(st);
      qe(pt), Ee.observe(st, rt);
    }
    return () => {
      Ee.disconnect();
    };
  }, [Ve, Ze, ze, t, r]);
  const et = { id: e, anchorId: t, anchorSelect: r, className: o, classNameArrow: d, content: $, html: ne, place: W, variant: ae, offset: K, wrapper: Fe, events: Te, positionStrategy: Ae, middlewares: S, delayShow: X, delayHide: ce, float: De, noArrow: v, clickable: N, closeOnEsc: C, style: R, position: _, isOpen: U, setIsOpen: j, afterShow: te, afterHide: Q, activeAnchor: ze, setActiveAnchor: (He) => Oe(He) };
  return y ? Ui.exports.jsx(Gh, { ...et, children: y }) : Ui.exports.jsx(Gh, { ...et });
};
function Xh(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r < a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function nS(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r > a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function Qd(e, t) {
  let r = 0;
  if (t === void 0)
    for (let a of e)
      (a = +a) && (r += a);
  else {
    let a = -1;
    for (let i of e)
      (i = +t(i, ++a, e)) && (r += i);
  }
  return r;
}
function rS(e) {
  return e.depth;
}
function aS(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function Bu(e) {
  return function() {
    return e;
  };
}
function qh(e, t) {
  return xc(e.source, t.source) || e.index - t.index;
}
function Zh(e, t) {
  return xc(e.target, t.target) || e.index - t.index;
}
function xc(e, t) {
  return e.y0 - t.y0;
}
function Jd(e) {
  return e.value;
}
function iS(e) {
  return e.index;
}
function oS(e) {
  return e.nodes;
}
function lS(e) {
  return e.links;
}
function Qh(e, t) {
  const r = e.get(t);
  if (!r)
    throw new Error("missing: " + t);
  return r;
}
function Jh({ nodes: e }) {
  for (const t of e) {
    let r = t.y0, a = r;
    for (const i of t.sourceLinks)
      i.y0 = r + i.width / 2, r += i.width;
    for (const i of t.targetLinks)
      i.y1 = a + i.width / 2, a += i.width;
  }
}
function sS() {
  let e = 0, t = 0, r = 1, a = 1, i = 24, o = 8, d, c = iS, s = aS, p, m, y = oS, x = lS, T = 6;
  function S() {
    const W = { nodes: y.apply(null, arguments), links: x.apply(null, arguments) };
    return A(W), E(W), b(W), v(W), R(W), Jh(W), W;
  }
  S.update = function(W) {
    return Jh(W), W;
  }, S.nodeId = function(W) {
    return arguments.length ? (c = typeof W == "function" ? W : Bu(W), S) : c;
  }, S.nodeAlign = function(W) {
    return arguments.length ? (s = typeof W == "function" ? W : Bu(W), S) : s;
  }, S.nodeSort = function(W) {
    return arguments.length ? (p = W, S) : p;
  }, S.nodeWidth = function(W) {
    return arguments.length ? (i = +W, S) : i;
  }, S.nodePadding = function(W) {
    return arguments.length ? (o = d = +W, S) : o;
  }, S.nodes = function(W) {
    return arguments.length ? (y = typeof W == "function" ? W : Bu(W), S) : y;
  }, S.links = function(W) {
    return arguments.length ? (x = typeof W == "function" ? W : Bu(W), S) : x;
  }, S.linkSort = function(W) {
    return arguments.length ? (m = W, S) : m;
  }, S.size = function(W) {
    return arguments.length ? (e = t = 0, r = +W[0], a = +W[1], S) : [r - e, a - t];
  }, S.extent = function(W) {
    return arguments.length ? (e = +W[0][0], r = +W[1][0], t = +W[0][1], a = +W[1][1], S) : [[e, t], [r, a]];
  }, S.iterations = function(W) {
    return arguments.length ? (T = +W, S) : T;
  };
  function A({ nodes: W, links: ie }) {
    for (const [oe, K] of W.entries())
      K.index = oe, K.sourceLinks = [], K.targetLinks = [];
    const ae = new Map(W.map((oe, K) => [c(oe, K, W), oe]));
    for (const [oe, K] of ie.entries()) {
      K.index = oe;
      let { source: Y, target: X } = K;
      typeof Y != "object" && (Y = K.source = Qh(ae, Y)), typeof X != "object" && (X = K.target = Qh(ae, X)), Y.sourceLinks.push(K), X.targetLinks.push(K);
    }
    if (m != null)
      for (const { sourceLinks: oe, targetLinks: K } of W)
        oe.sort(m), K.sort(m);
  }
  function E({ nodes: W }) {
    for (const ie of W)
      ie.value = ie.fixedValue === void 0 ? Math.max(Qd(ie.sourceLinks, Jd), Qd(ie.targetLinks, Jd)) : ie.fixedValue;
  }
  function b({ nodes: W }) {
    const ie = W.length;
    let ae = new Set(W), oe = /* @__PURE__ */ new Set(), K = 0;
    for (; ae.size; ) {
      for (const Y of ae) {
        Y.depth = K;
        for (const { target: X } of Y.sourceLinks)
          oe.add(X);
      }
      if (++K > ie)
        throw new Error("circular link");
      ae = oe, oe = /* @__PURE__ */ new Set();
    }
  }
  function v({ nodes: W }) {
    const ie = W.length;
    let ae = new Set(W), oe = /* @__PURE__ */ new Set(), K = 0;
    for (; ae.size; ) {
      for (const Y of ae) {
        Y.height = K;
        for (const { source: X } of Y.targetLinks)
          oe.add(X);
      }
      if (++K > ie)
        throw new Error("circular link");
      ae = oe, oe = /* @__PURE__ */ new Set();
    }
  }
  function N({ nodes: W }) {
    const ie = Xh(W, (K) => K.depth) + 1, ae = (r - e - i) / (ie - 1), oe = new Array(ie);
    for (const K of W) {
      const Y = Math.max(0, Math.min(ie - 1, Math.floor(s.call(null, K, ie))));
      K.layer = Y, K.x0 = e + Y * ae, K.x1 = K.x0 + i, oe[Y] ? oe[Y].push(K) : oe[Y] = [K];
    }
    if (p)
      for (const K of oe)
        K.sort(p);
    return oe;
  }
  function C(W) {
    const ie = nS(W, (ae) => (a - t - (ae.length - 1) * d) / Qd(ae, Jd));
    for (const ae of W) {
      let oe = t;
      for (const K of ae) {
        K.y0 = oe, K.y1 = oe + K.value * ie, oe = K.y1 + d;
        for (const Y of K.sourceLinks)
          Y.width = Y.value * ie;
      }
      oe = (a - oe + d) / (ae.length + 1);
      for (let K = 0; K < ae.length; ++K) {
        const Y = ae[K];
        Y.y0 += oe * (K + 1), Y.y1 += oe * (K + 1);
      }
      J(ae);
    }
  }
  function R(W) {
    const ie = N(W);
    d = Math.min(o, (a - t) / (Xh(ie, (ae) => ae.length) - 1)), C(ie);
    for (let ae = 0; ae < T; ++ae) {
      const oe = Math.pow(0.99, ae), K = Math.max(1 - oe, (ae + 1) / T);
      U(ie, oe, K), _(ie, oe, K);
    }
  }
  function _(W, ie, ae) {
    for (let oe = 1, K = W.length; oe < K; ++oe) {
      const Y = W[oe];
      for (const X of Y) {
        let q = 0, ce = 0;
        for (const { source: De, value: me } of X.targetLinks) {
          let Fe = me * (X.layer - De.layer);
          q += ne(De, X) * Fe, ce += Fe;
        }
        if (!(ce > 0))
          continue;
        let ge = (q / ce - X.y0) * ie;
        X.y0 += ge, X.y1 += ge, $(X);
      }
      p === void 0 && Y.sort(xc), j(Y, ae);
    }
  }
  function U(W, ie, ae) {
    for (let oe = W.length, K = oe - 2; K >= 0; --K) {
      const Y = W[K];
      for (const X of Y) {
        let q = 0, ce = 0;
        for (const { target: De, value: me } of X.sourceLinks) {
          let Fe = me * (De.layer - X.layer);
          q += z(X, De) * Fe, ce += Fe;
        }
        if (!(ce > 0))
          continue;
        let ge = (q / ce - X.y0) * ie;
        X.y0 += ge, X.y1 += ge, $(X);
      }
      p === void 0 && Y.sort(xc), j(Y, ae);
    }
  }
  function j(W, ie) {
    const ae = W.length >> 1, oe = W[ae];
    Q(W, oe.y0 - d, ae - 1, ie), te(W, oe.y1 + d, ae + 1, ie), Q(W, a, W.length - 1, ie), te(W, t, 0, ie);
  }
  function te(W, ie, ae, oe) {
    for (; ae < W.length; ++ae) {
      const K = W[ae], Y = (ie - K.y0) * oe;
      Y > 1e-6 && (K.y0 += Y, K.y1 += Y), ie = K.y1 + d;
    }
  }
  function Q(W, ie, ae, oe) {
    for (; ae >= 0; --ae) {
      const K = W[ae], Y = (K.y1 - ie) * oe;
      Y > 1e-6 && (K.y0 -= Y, K.y1 -= Y), ie = K.y0 - d;
    }
  }
  function $({ sourceLinks: W, targetLinks: ie }) {
    if (m === void 0) {
      for (const { source: { sourceLinks: ae } } of ie)
        ae.sort(Zh);
      for (const { target: { targetLinks: ae } } of W)
        ae.sort(qh);
    }
  }
  function J(W) {
    if (m === void 0)
      for (const { sourceLinks: ie, targetLinks: ae } of W)
        ie.sort(Zh), ae.sort(qh);
  }
  function ne(W, ie) {
    let ae = W.y0 - (W.sourceLinks.length - 1) * d / 2;
    for (const { target: oe, width: K } of W.sourceLinks) {
      if (oe === ie)
        break;
      ae += K + d;
    }
    for (const { source: oe, width: K } of ie.targetLinks) {
      if (oe === W)
        break;
      ae -= K;
    }
    return ae;
  }
  function z(W, ie) {
    let ae = ie.y0 - (ie.targetLinks.length - 1) * d / 2;
    for (const { source: oe, width: K } of ie.targetLinks) {
      if (oe === W)
        break;
      ae += K + d;
    }
    for (const { target: oe, width: K } of W.sourceLinks) {
      if (oe === ie)
        break;
      ae -= K;
    }
    return ae;
  }
  return S;
}
function uS(e) {
  return [e.source.x1, e.y0];
}
function cS(e) {
  return [e.target.x0, e.y1];
}
function dS() {
  return C0().source(uS).target(cS);
}
const fS = () => {
  const { config: e, handleChartTabbing: t, legendId: r } = ue.useContext(gt), [a, i] = ue.useState(!1), o = /* @__PURE__ */ n.createElement(n.Fragment, null, "For best viewing we recommend portrait mode. If you are unable to put your device in portrait mode, please review the ", /* @__PURE__ */ n.createElement("a", { href: `#${t(e, r)}` }, "data table"), " below.", " ", /* @__PURE__ */ n.createElement("a", { onClick: () => i(!1), href: "#!" }, "Close this alert"), " ", "to continue viewing the chart."), d = () => {
    i(!1);
  }, c = a ? /* @__PURE__ */ n.createElement("div", { className: "alert alert-warning alert-dismissible", role: "alert" }, /* @__PURE__ */ n.createElement("p", { style: { padding: "35px" } }, o), /* @__PURE__ */ n.createElement("button", { type: "button", className: "close", "data-dismiss": "alert", "aria-label": "Close", onClick: d }, /* @__PURE__ */ n.createElement("span", { "aria-hidden": "true" }, "×"))) : null;
  return ue.useEffect(() => {
    const s = () => {
      window.innerWidth < 768 && window.innerHeight > window.innerWidth ? i(!0) : i(!1);
    };
    return window.addEventListener("resize", s), s(), () => {
      window.removeEventListener("resize", s);
    };
  }, []), {
    setShowAlert: i,
    showAlert: a,
    handleCloseModal: d,
    alertMessage: o,
    alert: c
  };
};
var Ya = {}, _i = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var em;
function pS() {
  if (em)
    return _i;
  em = 1;
  var e = ue;
  function t(g) {
    for (var P = "https://reactjs.org/docs/error-decoder.html?invariant=" + g, M = 1; M < arguments.length; M++)
      P += "&args[]=" + encodeURIComponent(arguments[M]);
    return "Minified React error #" + g + "; visit " + P + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = Object.prototype.hasOwnProperty, a = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, i = {}, o = {};
  function d(g) {
    return r.call(o, g) ? !0 : r.call(i, g) ? !1 : a.test(g) ? o[g] = !0 : (i[g] = !0, !1);
  }
  function c(g, P, M, Z, xe, B, I) {
    this.acceptsBooleans = P === 2 || P === 3 || P === 4, this.attributeName = Z, this.attributeNamespace = xe, this.mustUseProperty = M, this.propertyName = g, this.type = P, this.sanitizeURL = B, this.removeEmptyString = I;
  }
  var s = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(g) {
    s[g] = new c(g, 0, !1, g, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(g) {
    var P = g[0];
    s[P] = new c(P, 1, !1, g[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(g) {
    s[g] = new c(g, 2, !1, g.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(g) {
    s[g] = new c(g, 2, !1, g, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(g) {
    s[g] = new c(g, 3, !1, g.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(g) {
    s[g] = new c(g, 3, !0, g, null, !1, !1);
  }), ["capture", "download"].forEach(function(g) {
    s[g] = new c(g, 4, !1, g, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(g) {
    s[g] = new c(g, 6, !1, g, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(g) {
    s[g] = new c(g, 5, !1, g.toLowerCase(), null, !1, !1);
  });
  var p = /[\-:]([a-z])/g;
  function m(g) {
    return g[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(g) {
    var P = g.replace(
      p,
      m
    );
    s[P] = new c(P, 1, !1, g, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(g) {
    var P = g.replace(p, m);
    s[P] = new c(P, 1, !1, g, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(g) {
    var P = g.replace(p, m);
    s[P] = new c(P, 1, !1, g, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(g) {
    s[g] = new c(g, 1, !1, g.toLowerCase(), null, !1, !1);
  }), s.xlinkHref = new c("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(g) {
    s[g] = new c(g, 1, !1, g.toLowerCase(), null, !0, !0);
  });
  var y = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, x = ["Webkit", "ms", "Moz", "O"];
  Object.keys(y).forEach(function(g) {
    x.forEach(function(P) {
      P = P + g.charAt(0).toUpperCase() + g.substring(1), y[P] = y[g];
    });
  });
  var T = /["'&<>]/;
  function S(g) {
    if (typeof g == "boolean" || typeof g == "number")
      return "" + g;
    g = "" + g;
    var P = T.exec(g);
    if (P) {
      var M = "", Z, xe = 0;
      for (Z = P.index; Z < g.length; Z++) {
        switch (g.charCodeAt(Z)) {
          case 34:
            P = "&quot;";
            break;
          case 38:
            P = "&amp;";
            break;
          case 39:
            P = "&#x27;";
            break;
          case 60:
            P = "&lt;";
            break;
          case 62:
            P = "&gt;";
            break;
          default:
            continue;
        }
        xe !== Z && (M += g.substring(xe, Z)), xe = Z + 1, M += P;
      }
      g = xe !== Z ? M + g.substring(xe, Z) : M;
    }
    return g;
  }
  var A = /([A-Z])/g, E = /^ms-/, b = Array.isArray;
  function v(g, P) {
    return { insertionMode: g, selectedValue: P };
  }
  function N(g, P, M) {
    switch (P) {
      case "select":
        return v(1, M.value != null ? M.value : M.defaultValue);
      case "svg":
        return v(2, null);
      case "math":
        return v(3, null);
      case "foreignObject":
        return v(1, null);
      case "table":
        return v(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return v(5, null);
      case "colgroup":
        return v(7, null);
      case "tr":
        return v(6, null);
    }
    return 4 <= g.insertionMode || g.insertionMode === 0 ? v(1, null) : g;
  }
  var C = /* @__PURE__ */ new Map();
  function R(g, P, M) {
    if (typeof M != "object")
      throw Error(t(62));
    P = !0;
    for (var Z in M)
      if (r.call(M, Z)) {
        var xe = M[Z];
        if (xe != null && typeof xe != "boolean" && xe !== "") {
          if (Z.indexOf("--") === 0) {
            var B = S(Z);
            xe = S(("" + xe).trim());
          } else {
            B = Z;
            var I = C.get(B);
            I !== void 0 || (I = S(B.replace(A, "-$1").toLowerCase().replace(E, "-ms-")), C.set(B, I)), B = I, xe = typeof xe == "number" ? xe === 0 || r.call(y, Z) ? "" + xe : xe + "px" : S(("" + xe).trim());
          }
          P ? (P = !1, g.push(' style="', B, ":", xe)) : g.push(";", B, ":", xe);
        }
      }
    P || g.push('"');
  }
  function _(g, P, M, Z) {
    switch (M) {
      case "style":
        R(g, P, Z);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < M.length) || M[0] !== "o" && M[0] !== "O" || M[1] !== "n" && M[1] !== "N") {
      if (P = s.hasOwnProperty(M) ? s[M] : null, P !== null) {
        switch (typeof Z) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!P.acceptsBooleans)
              return;
        }
        switch (M = P.attributeName, P.type) {
          case 3:
            Z && g.push(" ", M, '=""');
            break;
          case 4:
            Z === !0 ? g.push(" ", M, '=""') : Z !== !1 && g.push(" ", M, '="', S(Z), '"');
            break;
          case 5:
            isNaN(Z) || g.push(" ", M, '="', S(Z), '"');
            break;
          case 6:
            !isNaN(Z) && 1 <= Z && g.push(" ", M, '="', S(Z), '"');
            break;
          default:
            P.sanitizeURL && (Z = "" + Z), g.push(" ", M, '="', S(Z), '"');
        }
      } else if (d(M)) {
        switch (typeof Z) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (P = M.toLowerCase().slice(0, 5), P !== "data-" && P !== "aria-")
              return;
        }
        g.push(" ", M, '="', S(Z), '"');
      }
    }
  }
  function U(g, P, M) {
    if (P != null) {
      if (M != null)
        throw Error(t(60));
      if (typeof P != "object" || !("__html" in P))
        throw Error(t(61));
      P = P.__html, P != null && g.push("" + P);
    }
  }
  function j(g) {
    var P = "";
    return e.Children.forEach(g, function(M) {
      M != null && (P += M);
    }), P;
  }
  function te(g, P, M, Z) {
    g.push(J(M));
    var xe = M = null, B;
    for (B in P)
      if (r.call(P, B)) {
        var I = P[B];
        if (I != null)
          switch (B) {
            case "children":
              M = I;
              break;
            case "dangerouslySetInnerHTML":
              xe = I;
              break;
            default:
              _(g, Z, B, I);
          }
      }
    return g.push(">"), U(g, xe, M), typeof M == "string" ? (g.push(S(M)), null) : M;
  }
  var Q = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, $ = /* @__PURE__ */ new Map();
  function J(g) {
    var P = $.get(g);
    if (P === void 0) {
      if (!Q.test(g))
        throw Error(t(65, g));
      P = "<" + g, $.set(g, P);
    }
    return P;
  }
  function ne(g, P, M, Z, xe) {
    switch (P) {
      case "select":
        g.push(J("select"));
        var B = null, I = null;
        for (Qe in M)
          if (r.call(M, Qe)) {
            var ee = M[Qe];
            if (ee != null)
              switch (Qe) {
                case "children":
                  B = ee;
                  break;
                case "dangerouslySetInnerHTML":
                  I = ee;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  _(g, Z, Qe, ee);
              }
          }
        return g.push(">"), U(g, I, B), B;
      case "option":
        I = xe.selectedValue, g.push(J("option"));
        var be = ee = null, We = null, Qe = null;
        for (B in M)
          if (r.call(M, B)) {
            var St = M[B];
            if (St != null)
              switch (B) {
                case "children":
                  ee = St;
                  break;
                case "selected":
                  We = St;
                  break;
                case "dangerouslySetInnerHTML":
                  Qe = St;
                  break;
                case "value":
                  be = St;
                default:
                  _(g, Z, B, St);
              }
          }
        if (I != null)
          if (M = be !== null ? "" + be : j(ee), b(I)) {
            for (Z = 0; Z < I.length; Z++)
              if ("" + I[Z] === M) {
                g.push(' selected=""');
                break;
              }
          } else
            "" + I === M && g.push(' selected=""');
        else
          We && g.push(' selected=""');
        return g.push(">"), U(g, Qe, ee), ee;
      case "textarea":
        g.push(J("textarea")), Qe = I = B = null;
        for (ee in M)
          if (r.call(M, ee) && (be = M[ee], be != null))
            switch (ee) {
              case "children":
                Qe = be;
                break;
              case "value":
                B = be;
                break;
              case "defaultValue":
                I = be;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                _(
                  g,
                  Z,
                  ee,
                  be
                );
            }
        if (B === null && I !== null && (B = I), g.push(">"), Qe != null) {
          if (B != null)
            throw Error(t(92));
          if (b(Qe) && 1 < Qe.length)
            throw Error(t(93));
          B = "" + Qe;
        }
        return typeof B == "string" && B[0] === `
` && g.push(`
`), B !== null && g.push(S("" + B)), null;
      case "input":
        g.push(J("input")), be = Qe = ee = B = null;
        for (I in M)
          if (r.call(M, I) && (We = M[I], We != null))
            switch (I) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                be = We;
                break;
              case "defaultValue":
                ee = We;
                break;
              case "checked":
                Qe = We;
                break;
              case "value":
                B = We;
                break;
              default:
                _(g, Z, I, We);
            }
        return Qe !== null ? _(g, Z, "checked", Qe) : be !== null && _(g, Z, "checked", be), B !== null ? _(g, Z, "value", B) : ee !== null && _(g, Z, "value", ee), g.push("/>"), null;
      case "menuitem":
        g.push(J("menuitem"));
        for (var Dt in M)
          if (r.call(M, Dt) && (B = M[Dt], B != null))
            switch (Dt) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                _(g, Z, Dt, B);
            }
        return g.push(">"), null;
      case "title":
        g.push(J("title")), B = null;
        for (St in M)
          if (r.call(M, St) && (I = M[St], I != null))
            switch (St) {
              case "children":
                B = I;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                _(g, Z, St, I);
            }
        return g.push(">"), B;
      case "listing":
      case "pre":
        g.push(J(P)), I = B = null;
        for (be in M)
          if (r.call(M, be) && (ee = M[be], ee != null))
            switch (be) {
              case "children":
                B = ee;
                break;
              case "dangerouslySetInnerHTML":
                I = ee;
                break;
              default:
                _(g, Z, be, ee);
            }
        if (g.push(">"), I != null) {
          if (B != null)
            throw Error(t(60));
          if (typeof I != "object" || !("__html" in I))
            throw Error(t(61));
          M = I.__html, M != null && (typeof M == "string" && 0 < M.length && M[0] === `
` ? g.push(`
`, M) : g.push("" + M));
        }
        return typeof B == "string" && B[0] === `
` && g.push(`
`), B;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        g.push(J(P));
        for (var Bt in M)
          if (r.call(M, Bt) && (B = M[Bt], B != null))
            switch (Bt) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, P));
              default:
                _(g, Z, Bt, B);
            }
        return g.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return te(
          g,
          M,
          P,
          Z
        );
      case "html":
        return xe.insertionMode === 0 && g.push("<!DOCTYPE html>"), te(g, M, P, Z);
      default:
        if (P.indexOf("-") === -1 && typeof M.is != "string")
          return te(g, M, P, Z);
        g.push(J(P)), I = B = null;
        for (We in M)
          if (r.call(M, We) && (ee = M[We], ee != null))
            switch (We) {
              case "children":
                B = ee;
                break;
              case "dangerouslySetInnerHTML":
                I = ee;
                break;
              case "style":
                R(g, Z, ee);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                d(We) && typeof ee != "function" && typeof ee != "symbol" && g.push(" ", We, '="', S(ee), '"');
            }
        return g.push(">"), U(g, I, B), B;
    }
  }
  function z(g, P, M) {
    if (g.push('<!--$?--><template id="'), M === null)
      throw Error(t(395));
    return g.push(M), g.push('"></template>');
  }
  function W(g, P, M, Z) {
    switch (M.insertionMode) {
      case 0:
      case 1:
        return g.push('<div hidden id="'), g.push(P.segmentPrefix), P = Z.toString(16), g.push(P), g.push('">');
      case 2:
        return g.push('<svg aria-hidden="true" style="display:none" id="'), g.push(P.segmentPrefix), P = Z.toString(16), g.push(P), g.push('">');
      case 3:
        return g.push('<math aria-hidden="true" style="display:none" id="'), g.push(P.segmentPrefix), P = Z.toString(16), g.push(P), g.push('">');
      case 4:
        return g.push('<table hidden id="'), g.push(P.segmentPrefix), P = Z.toString(16), g.push(P), g.push('">');
      case 5:
        return g.push('<table hidden><tbody id="'), g.push(P.segmentPrefix), P = Z.toString(16), g.push(P), g.push('">');
      case 6:
        return g.push('<table hidden><tr id="'), g.push(P.segmentPrefix), P = Z.toString(16), g.push(P), g.push('">');
      case 7:
        return g.push('<table hidden><colgroup id="'), g.push(P.segmentPrefix), P = Z.toString(16), g.push(P), g.push('">');
      default:
        throw Error(t(397));
    }
  }
  function ie(g, P) {
    switch (P.insertionMode) {
      case 0:
      case 1:
        return g.push("</div>");
      case 2:
        return g.push("</svg>");
      case 3:
        return g.push("</math>");
      case 4:
        return g.push("</table>");
      case 5:
        return g.push("</tbody></table>");
      case 6:
        return g.push("</tr></table>");
      case 7:
        return g.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var ae = /[<\u2028\u2029]/g;
  function oe(g) {
    return JSON.stringify(g).replace(ae, function(P) {
      switch (P) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function K(g, P) {
    return P = P === void 0 ? "" : P, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: P + "P:", segmentPrefix: P + "S:", boundaryPrefix: P + "B:", idPrefix: P, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: g };
  }
  function Y(g, P, M, Z) {
    return M.generateStaticMarkup ? (g.push(S(P)), !1) : (P === "" ? g = Z : (Z && g.push("<!-- -->"), g.push(S(P)), g = !0), g);
  }
  var X = Object.assign, q = Symbol.for("react.element"), ce = Symbol.for("react.portal"), ge = Symbol.for("react.fragment"), De = Symbol.for("react.strict_mode"), me = Symbol.for("react.profiler"), Fe = Symbol.for("react.provider"), Ue = Symbol.for("react.context"), Te = Symbol.for("react.forward_ref"), ve = Symbol.for("react.suspense"), Ae = Symbol.for("react.suspense_list"), fe = Symbol.for("react.memo"), ze = Symbol.for("react.lazy"), Oe = Symbol.for("react.scope"), Ve = Symbol.for("react.debug_trace_mode"), Ze = Symbol.for("react.legacy_hidden"), Ie = Symbol.for("react.default_value"), qe = Symbol.iterator;
  function et(g) {
    if (g == null)
      return null;
    if (typeof g == "function")
      return g.displayName || g.name || null;
    if (typeof g == "string")
      return g;
    switch (g) {
      case ge:
        return "Fragment";
      case ce:
        return "Portal";
      case me:
        return "Profiler";
      case De:
        return "StrictMode";
      case ve:
        return "Suspense";
      case Ae:
        return "SuspenseList";
    }
    if (typeof g == "object")
      switch (g.$$typeof) {
        case Ue:
          return (g.displayName || "Context") + ".Consumer";
        case Fe:
          return (g._context.displayName || "Context") + ".Provider";
        case Te:
          var P = g.render;
          return g = g.displayName, g || (g = P.displayName || P.name || "", g = g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef"), g;
        case fe:
          return P = g.displayName || null, P !== null ? P : et(g.type) || "Memo";
        case ze:
          P = g._payload, g = g._init;
          try {
            return et(g(P));
          } catch {
          }
      }
    return null;
  }
  var He = {};
  function Ge(g, P) {
    if (g = g.contextTypes, !g)
      return He;
    var M = {}, Z;
    for (Z in g)
      M[Z] = P[Z];
    return M;
  }
  var Le = null;
  function _e(g, P) {
    if (g !== P) {
      g.context._currentValue2 = g.parentValue, g = g.parent;
      var M = P.parent;
      if (g === null) {
        if (M !== null)
          throw Error(t(401));
      } else {
        if (M === null)
          throw Error(t(401));
        _e(g, M);
      }
      P.context._currentValue2 = P.value;
    }
  }
  function st(g) {
    g.context._currentValue2 = g.parentValue, g = g.parent, g !== null && st(g);
  }
  function Ee(g) {
    var P = g.parent;
    P !== null && Ee(P), g.context._currentValue2 = g.value;
  }
  function rt(g, P) {
    if (g.context._currentValue2 = g.parentValue, g = g.parent, g === null)
      throw Error(t(402));
    g.depth === P.depth ? _e(g, P) : rt(g, P);
  }
  function pt(g, P) {
    var M = P.parent;
    if (M === null)
      throw Error(t(402));
    g.depth === M.depth ? _e(g, M) : pt(g, M), P.context._currentValue2 = P.value;
  }
  function ft(g) {
    var P = Le;
    P !== g && (P === null ? Ee(g) : g === null ? st(P) : P.depth === g.depth ? _e(P, g) : P.depth > g.depth ? rt(P, g) : pt(P, g), Le = g);
  }
  var wt = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(g, P) {
    g = g._reactInternals, g.queue !== null && g.queue.push(P);
  }, enqueueReplaceState: function(g, P) {
    g = g._reactInternals, g.replace = !0, g.queue = [P];
  }, enqueueForceUpdate: function() {
  } };
  function zt(g, P, M, Z) {
    var xe = g.state !== void 0 ? g.state : null;
    g.updater = wt, g.props = M, g.state = xe;
    var B = { queue: [], replace: !1 };
    g._reactInternals = B;
    var I = P.contextType;
    if (g.context = typeof I == "object" && I !== null ? I._currentValue2 : Z, I = P.getDerivedStateFromProps, typeof I == "function" && (I = I(M, xe), xe = I == null ? xe : X({}, xe, I), g.state = xe), typeof P.getDerivedStateFromProps != "function" && typeof g.getSnapshotBeforeUpdate != "function" && (typeof g.UNSAFE_componentWillMount == "function" || typeof g.componentWillMount == "function"))
      if (P = g.state, typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(), P !== g.state && wt.enqueueReplaceState(g, g.state, null), B.queue !== null && 0 < B.queue.length)
        if (P = B.queue, I = B.replace, B.queue = null, B.replace = !1, I && P.length === 1)
          g.state = P[0];
        else {
          for (B = I ? P[0] : g.state, xe = !0, I = I ? 1 : 0; I < P.length; I++) {
            var ee = P[I];
            ee = typeof ee == "function" ? ee.call(g, B, M, Z) : ee, ee != null && (xe ? (xe = !1, B = X({}, B, ee)) : X(B, ee));
          }
          g.state = B;
        }
      else
        B.queue = null;
  }
  var Jt = { id: 1, overflow: "" };
  function jt(g, P, M) {
    var Z = g.id;
    g = g.overflow;
    var xe = 32 - on(Z) - 1;
    Z &= ~(1 << xe), M += 1;
    var B = 32 - on(P) + xe;
    if (30 < B) {
      var I = xe - xe % 5;
      return B = (Z & (1 << I) - 1).toString(32), Z >>= I, xe -= I, { id: 1 << 32 - on(P) + xe | M << xe | Z, overflow: B + g };
    }
    return { id: 1 << B | M << xe | Z, overflow: g };
  }
  var on = Math.clz32 ? Math.clz32 : $t, _t = Math.log, tn = Math.LN2;
  function $t(g) {
    return g >>>= 0, g === 0 ? 32 : 31 - (_t(g) / tn | 0) | 0;
  }
  function Ut(g, P) {
    return g === P && (g !== 0 || 1 / g === 1 / P) || g !== g && P !== P;
  }
  var bt = typeof Object.is == "function" ? Object.is : Ut, mt = null, ln = null, Yt = null, xt = null, Gt = !1, Sn = !1, At = 0, nn = null, Xt = 0;
  function sn() {
    if (mt === null)
      throw Error(t(321));
    return mt;
  }
  function Nt() {
    if (0 < Xt)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function xn() {
    return xt === null ? Yt === null ? (Gt = !1, Yt = xt = Nt()) : (Gt = !0, xt = Yt) : xt.next === null ? (Gt = !1, xt = xt.next = Nt()) : (Gt = !0, xt = xt.next), xt;
  }
  function dn() {
    ln = mt = null, Sn = !1, Yt = null, Xt = 0, xt = nn = null;
  }
  function Lt(g, P) {
    return typeof P == "function" ? P(g) : P;
  }
  function nt(g, P, M) {
    if (mt = sn(), xt = xn(), Gt) {
      var Z = xt.queue;
      if (P = Z.dispatch, nn !== null && (M = nn.get(Z), M !== void 0)) {
        nn.delete(Z), Z = xt.memoizedState;
        do
          Z = g(Z, M.action), M = M.next;
        while (M !== null);
        return xt.memoizedState = Z, [Z, P];
      }
      return [xt.memoizedState, P];
    }
    return g = g === Lt ? typeof P == "function" ? P() : P : M !== void 0 ? M(P) : P, xt.memoizedState = g, g = xt.queue = { last: null, dispatch: null }, g = g.dispatch = Hn.bind(null, mt, g), [xt.memoizedState, g];
  }
  function bn(g, P) {
    if (mt = sn(), xt = xn(), P = P === void 0 ? null : P, xt !== null) {
      var M = xt.memoizedState;
      if (M !== null && P !== null) {
        var Z = M[1];
        e:
          if (Z === null)
            Z = !1;
          else {
            for (var xe = 0; xe < Z.length && xe < P.length; xe++)
              if (!bt(P[xe], Z[xe])) {
                Z = !1;
                break e;
              }
            Z = !0;
          }
        if (Z)
          return M[0];
      }
    }
    return g = g(), xt.memoizedState = [g, P], g;
  }
  function Hn(g, P, M) {
    if (25 <= Xt)
      throw Error(t(301));
    if (g === mt)
      if (Sn = !0, g = { action: M, next: null }, nn === null && (nn = /* @__PURE__ */ new Map()), M = nn.get(P), M === void 0)
        nn.set(P, g);
      else {
        for (P = M; P.next !== null; )
          P = P.next;
        P.next = g;
      }
  }
  function Gn() {
    throw Error(t(394));
  }
  function An() {
  }
  var Un = { readContext: function(g) {
    return g._currentValue2;
  }, useContext: function(g) {
    return sn(), g._currentValue2;
  }, useMemo: bn, useReducer: nt, useRef: function(g) {
    mt = sn(), xt = xn();
    var P = xt.memoizedState;
    return P === null ? (g = { current: g }, xt.memoizedState = g) : P;
  }, useState: function(g) {
    return nt(Lt, g);
  }, useInsertionEffect: An, useLayoutEffect: function() {
  }, useCallback: function(g, P) {
    return bn(function() {
      return g;
    }, P);
  }, useImperativeHandle: An, useEffect: An, useDebugValue: An, useDeferredValue: function(g) {
    return sn(), g;
  }, useTransition: function() {
    return sn(), [
      !1,
      Gn
    ];
  }, useId: function() {
    var g = ln.treeContext, P = g.overflow;
    g = g.id, g = (g & ~(1 << 32 - on(g) - 1)).toString(32) + P;
    var M = _n;
    if (M === null)
      throw Error(t(404));
    return P = At++, g = ":" + M.idPrefix + "R" + g, 0 < P && (g += "H" + P.toString(32)), g + ":";
  }, useMutableSource: function(g, P) {
    return sn(), P(g._source);
  }, useSyncExternalStore: function(g, P, M) {
    if (M === void 0)
      throw Error(t(407));
    return M();
  } }, _n = null, Pn = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function pn(g) {
    return console.error(g), null;
  }
  function Se() {
  }
  function Ne(g, P, M, Z, xe, B, I, ee, be) {
    var We = [], Qe = /* @__PURE__ */ new Set();
    return P = { destination: null, responseState: P, progressiveChunkSize: Z === void 0 ? 12800 : Z, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Qe, pingedTasks: We, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: xe === void 0 ? pn : xe, onAllReady: B === void 0 ? Se : B, onShellReady: I === void 0 ? Se : I, onShellError: ee === void 0 ? Se : ee, onFatalError: be === void 0 ? Se : be }, M = Ke(P, 0, null, M, !1, !1), M.parentFlushed = !0, g = pe(P, g, null, M, Qe, He, null, Jt), We.push(g), P;
  }
  function pe(g, P, M, Z, xe, B, I, ee) {
    g.allPendingTasks++, M === null ? g.pendingRootTasks++ : M.pendingTasks++;
    var be = { node: P, ping: function() {
      var We = g.pingedTasks;
      We.push(be), We.length === 1 && Mt(g);
    }, blockedBoundary: M, blockedSegment: Z, abortSet: xe, legacyContext: B, context: I, treeContext: ee };
    return xe.add(be), be;
  }
  function Ke(g, P, M, Z, xe, B) {
    return { status: 0, id: -1, index: P, parentFlushed: !1, chunks: [], children: [], formatContext: Z, boundary: M, lastPushedText: xe, textEmbedded: B };
  }
  function ht(g, P) {
    if (g = g.onError(P), g != null && typeof g != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof g + '" instead');
    return g;
  }
  function it(g, P) {
    var M = g.onShellError;
    M(P), M = g.onFatalError, M(P), g.destination !== null ? (g.status = 2, g.destination.destroy(P)) : (g.status = 1, g.fatalError = P);
  }
  function ct(g, P, M, Z, xe) {
    for (mt = {}, ln = P, At = 0, g = M(Z, xe); Sn; )
      Sn = !1, At = 0, Xt += 1, xt = null, g = M(Z, xe);
    return dn(), g;
  }
  function Kt(g, P, M, Z) {
    var xe = M.render(), B = Z.childContextTypes;
    if (B != null) {
      var I = P.legacyContext;
      if (typeof M.getChildContext != "function")
        Z = I;
      else {
        M = M.getChildContext();
        for (var ee in M)
          if (!(ee in B))
            throw Error(t(108, et(Z) || "Unknown", ee));
        Z = X({}, I, M);
      }
      P.legacyContext = Z, ut(g, P, xe), P.legacyContext = I;
    } else
      ut(g, P, xe);
  }
  function Ot(g, P) {
    if (g && g.defaultProps) {
      P = X({}, P), g = g.defaultProps;
      for (var M in g)
        P[M] === void 0 && (P[M] = g[M]);
      return P;
    }
    return P;
  }
  function tt(g, P, M, Z, xe) {
    if (typeof M == "function")
      if (M.prototype && M.prototype.isReactComponent) {
        xe = Ge(M, P.legacyContext);
        var B = M.contextType;
        B = new M(Z, typeof B == "object" && B !== null ? B._currentValue2 : xe), zt(B, M, Z, xe), Kt(g, P, B, M);
      } else {
        B = Ge(M, P.legacyContext), xe = ct(g, P, M, Z, B);
        var I = At !== 0;
        if (typeof xe == "object" && xe !== null && typeof xe.render == "function" && xe.$$typeof === void 0)
          zt(xe, M, Z, B), Kt(g, P, xe, M);
        else if (I) {
          Z = P.treeContext, P.treeContext = jt(Z, 1, 0);
          try {
            ut(g, P, xe);
          } finally {
            P.treeContext = Z;
          }
        } else
          ut(g, P, xe);
      }
    else if (typeof M == "string") {
      switch (xe = P.blockedSegment, B = ne(xe.chunks, M, Z, g.responseState, xe.formatContext), xe.lastPushedText = !1, I = xe.formatContext, xe.formatContext = N(I, M, Z), Rt(g, P, B), xe.formatContext = I, M) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          xe.chunks.push("</", M, ">");
      }
      xe.lastPushedText = !1;
    } else {
      switch (M) {
        case Ze:
        case Ve:
        case De:
        case me:
        case ge:
          ut(g, P, Z.children);
          return;
        case Ae:
          ut(g, P, Z.children);
          return;
        case Oe:
          throw Error(t(343));
        case ve:
          e: {
            M = P.blockedBoundary, xe = P.blockedSegment, B = Z.fallback, Z = Z.children, I = /* @__PURE__ */ new Set();
            var ee = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: I, errorDigest: null }, be = Ke(g, xe.chunks.length, ee, xe.formatContext, !1, !1);
            xe.children.push(be), xe.lastPushedText = !1;
            var We = Ke(g, 0, null, xe.formatContext, !1, !1);
            We.parentFlushed = !0, P.blockedBoundary = ee, P.blockedSegment = We;
            try {
              if (Rt(
                g,
                P,
                Z
              ), g.responseState.generateStaticMarkup || We.lastPushedText && We.textEmbedded && We.chunks.push("<!-- -->"), We.status = 1, hn(ee, We), ee.pendingTasks === 0)
                break e;
            } catch (Qe) {
              We.status = 4, ee.forceClientRender = !0, ee.errorDigest = ht(g, Qe);
            } finally {
              P.blockedBoundary = M, P.blockedSegment = xe;
            }
            P = pe(g, B, M, be, I, P.legacyContext, P.context, P.treeContext), g.pingedTasks.push(P);
          }
          return;
      }
      if (typeof M == "object" && M !== null)
        switch (M.$$typeof) {
          case Te:
            if (Z = ct(g, P, M.render, Z, xe), At !== 0) {
              M = P.treeContext, P.treeContext = jt(M, 1, 0);
              try {
                ut(g, P, Z);
              } finally {
                P.treeContext = M;
              }
            } else
              ut(g, P, Z);
            return;
          case fe:
            M = M.type, Z = Ot(M, Z), tt(g, P, M, Z, xe);
            return;
          case Fe:
            if (xe = Z.children, M = M._context, Z = Z.value, B = M._currentValue2, M._currentValue2 = Z, I = Le, Le = Z = { parent: I, depth: I === null ? 0 : I.depth + 1, context: M, parentValue: B, value: Z }, P.context = Z, ut(g, P, xe), g = Le, g === null)
              throw Error(t(403));
            Z = g.parentValue, g.context._currentValue2 = Z === Ie ? g.context._defaultValue : Z, g = Le = g.parent, P.context = g;
            return;
          case Ue:
            Z = Z.children, Z = Z(M._currentValue2), ut(g, P, Z);
            return;
          case ze:
            xe = M._init, M = xe(M._payload), Z = Ot(M, Z), tt(
              g,
              P,
              M,
              Z,
              void 0
            );
            return;
        }
      throw Error(t(130, M == null ? M : typeof M, ""));
    }
  }
  function ut(g, P, M) {
    if (P.node = M, typeof M == "object" && M !== null) {
      switch (M.$$typeof) {
        case q:
          tt(g, P, M.type, M.props, M.ref);
          return;
        case ce:
          throw Error(t(257));
        case ze:
          var Z = M._init;
          M = Z(M._payload), ut(g, P, M);
          return;
      }
      if (b(M)) {
        It(g, P, M);
        return;
      }
      if (M === null || typeof M != "object" ? Z = null : (Z = qe && M[qe] || M["@@iterator"], Z = typeof Z == "function" ? Z : null), Z && (Z = Z.call(M))) {
        if (M = Z.next(), !M.done) {
          var xe = [];
          do
            xe.push(M.value), M = Z.next();
          while (!M.done);
          It(g, P, xe);
        }
        return;
      }
      throw g = Object.prototype.toString.call(M), Error(t(31, g === "[object Object]" ? "object with keys {" + Object.keys(M).join(", ") + "}" : g));
    }
    typeof M == "string" ? (Z = P.blockedSegment, Z.lastPushedText = Y(P.blockedSegment.chunks, M, g.responseState, Z.lastPushedText)) : typeof M == "number" && (Z = P.blockedSegment, Z.lastPushedText = Y(P.blockedSegment.chunks, "" + M, g.responseState, Z.lastPushedText));
  }
  function It(g, P, M) {
    for (var Z = M.length, xe = 0; xe < Z; xe++) {
      var B = P.treeContext;
      P.treeContext = jt(B, Z, xe);
      try {
        Rt(g, P, M[xe]);
      } finally {
        P.treeContext = B;
      }
    }
  }
  function Rt(g, P, M) {
    var Z = P.blockedSegment.formatContext, xe = P.legacyContext, B = P.context;
    try {
      return ut(g, P, M);
    } catch (be) {
      if (dn(), typeof be == "object" && be !== null && typeof be.then == "function") {
        M = be;
        var I = P.blockedSegment, ee = Ke(g, I.chunks.length, null, I.formatContext, I.lastPushedText, !0);
        I.children.push(ee), I.lastPushedText = !1, g = pe(g, P.node, P.blockedBoundary, ee, P.abortSet, P.legacyContext, P.context, P.treeContext).ping, M.then(g, g), P.blockedSegment.formatContext = Z, P.legacyContext = xe, P.context = B, ft(B);
      } else
        throw P.blockedSegment.formatContext = Z, P.legacyContext = xe, P.context = B, ft(B), be;
    }
  }
  function Ht(g) {
    var P = g.blockedBoundary;
    g = g.blockedSegment, g.status = 3, mn(this, P, g);
  }
  function Ft(g, P, M) {
    var Z = g.blockedBoundary;
    g.blockedSegment.status = 3, Z === null ? (P.allPendingTasks--, P.status !== 2 && (P.status = 2, P.destination !== null && P.destination.push(null))) : (Z.pendingTasks--, Z.forceClientRender || (Z.forceClientRender = !0, g = M === void 0 ? Error(t(432)) : M, Z.errorDigest = P.onError(g), Z.parentFlushed && P.clientRenderedBoundaries.push(Z)), Z.fallbackAbortableTasks.forEach(function(xe) {
      return Ft(xe, P, M);
    }), Z.fallbackAbortableTasks.clear(), P.allPendingTasks--, P.allPendingTasks === 0 && (Z = P.onAllReady, Z()));
  }
  function hn(g, P) {
    if (P.chunks.length === 0 && P.children.length === 1 && P.children[0].boundary === null) {
      var M = P.children[0];
      M.id = P.id, M.parentFlushed = !0, M.status === 1 && hn(g, M);
    } else
      g.completedSegments.push(P);
  }
  function mn(g, P, M) {
    if (P === null) {
      if (M.parentFlushed) {
        if (g.completedRootSegment !== null)
          throw Error(t(389));
        g.completedRootSegment = M;
      }
      g.pendingRootTasks--, g.pendingRootTasks === 0 && (g.onShellError = Se, P = g.onShellReady, P());
    } else
      P.pendingTasks--, P.forceClientRender || (P.pendingTasks === 0 ? (M.parentFlushed && M.status === 1 && hn(P, M), P.parentFlushed && g.completedBoundaries.push(P), P.fallbackAbortableTasks.forEach(Ht, g), P.fallbackAbortableTasks.clear()) : M.parentFlushed && M.status === 1 && (hn(P, M), P.completedSegments.length === 1 && P.parentFlushed && g.partialBoundaries.push(P)));
    g.allPendingTasks--, g.allPendingTasks === 0 && (g = g.onAllReady, g());
  }
  function Mt(g) {
    if (g.status !== 2) {
      var P = Le, M = Pn.current;
      Pn.current = Un;
      var Z = _n;
      _n = g.responseState;
      try {
        var xe = g.pingedTasks, B;
        for (B = 0; B < xe.length; B++) {
          var I = xe[B], ee = g, be = I.blockedSegment;
          if (be.status === 0) {
            ft(I.context);
            try {
              ut(ee, I, I.node), ee.responseState.generateStaticMarkup || be.lastPushedText && be.textEmbedded && be.chunks.push("<!-- -->"), I.abortSet.delete(I), be.status = 1, mn(ee, I.blockedBoundary, be);
            } catch (Cn) {
              if (dn(), typeof Cn == "object" && Cn !== null && typeof Cn.then == "function") {
                var We = I.ping;
                Cn.then(We, We);
              } else {
                I.abortSet.delete(I), be.status = 4;
                var Qe = I.blockedBoundary, St = Cn, Dt = ht(ee, St);
                if (Qe === null ? it(ee, St) : (Qe.pendingTasks--, Qe.forceClientRender || (Qe.forceClientRender = !0, Qe.errorDigest = Dt, Qe.parentFlushed && ee.clientRenderedBoundaries.push(Qe))), ee.allPendingTasks--, ee.allPendingTasks === 0) {
                  var Bt = ee.onAllReady;
                  Bt();
                }
              }
            } finally {
            }
          }
        }
        xe.splice(0, B), g.destination !== null && fn(g, g.destination);
      } catch (Cn) {
        ht(g, Cn), it(g, Cn);
      } finally {
        _n = Z, Pn.current = M, M === Un && ft(P);
      }
    }
  }
  function kn(g, P, M) {
    switch (M.parentFlushed = !0, M.status) {
      case 0:
        var Z = M.id = g.nextSegmentId++;
        return M.lastPushedText = !1, M.textEmbedded = !1, g = g.responseState, P.push('<template id="'), P.push(g.placeholderPrefix), g = Z.toString(16), P.push(g), P.push('"></template>');
      case 1:
        M.status = 2;
        var xe = !0;
        Z = M.chunks;
        var B = 0;
        M = M.children;
        for (var I = 0; I < M.length; I++) {
          for (xe = M[I]; B < xe.index; B++)
            P.push(Z[B]);
          xe = wn(g, P, xe);
        }
        for (; B < Z.length - 1; B++)
          P.push(Z[B]);
        return B < Z.length && (xe = P.push(Z[B])), xe;
      default:
        throw Error(t(390));
    }
  }
  function wn(g, P, M) {
    var Z = M.boundary;
    if (Z === null)
      return kn(g, P, M);
    if (Z.parentFlushed = !0, Z.forceClientRender)
      return g.responseState.generateStaticMarkup || (Z = Z.errorDigest, P.push("<!--$!-->"), P.push("<template"), Z && (P.push(' data-dgst="'), Z = S(Z), P.push(Z), P.push('"')), P.push("></template>")), kn(g, P, M), g = g.responseState.generateStaticMarkup ? !0 : P.push("<!--/$-->"), g;
    if (0 < Z.pendingTasks) {
      Z.rootSegmentID = g.nextSegmentId++, 0 < Z.completedSegments.length && g.partialBoundaries.push(Z);
      var xe = g.responseState, B = xe.nextSuspenseID++;
      return xe = xe.boundaryPrefix + B.toString(16), Z = Z.id = xe, z(P, g.responseState, Z), kn(g, P, M), P.push("<!--/$-->");
    }
    if (Z.byteSize > g.progressiveChunkSize)
      return Z.rootSegmentID = g.nextSegmentId++, g.completedBoundaries.push(Z), z(P, g.responseState, Z.id), kn(g, P, M), P.push("<!--/$-->");
    if (g.responseState.generateStaticMarkup || P.push("<!--$-->"), M = Z.completedSegments, M.length !== 1)
      throw Error(t(391));
    return wn(g, P, M[0]), g = g.responseState.generateStaticMarkup ? !0 : P.push("<!--/$-->"), g;
  }
  function On(g, P, M) {
    return W(P, g.responseState, M.formatContext, M.id), wn(g, P, M), ie(P, M.formatContext);
  }
  function Nn(g, P, M) {
    for (var Z = M.completedSegments, xe = 0; xe < Z.length; xe++)
      Ln(g, P, M, Z[xe]);
    if (Z.length = 0, g = g.responseState, Z = M.id, M = M.rootSegmentID, P.push(g.startInlineScript), g.sentCompleteBoundaryFunction ? P.push('$RC("') : (g.sentCompleteBoundaryFunction = !0, P.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), Z === null)
      throw Error(t(395));
    return M = M.toString(16), P.push(Z), P.push('","'), P.push(g.segmentPrefix), P.push(M), P.push('")<\/script>');
  }
  function Ln(g, P, M, Z) {
    if (Z.status === 2)
      return !0;
    var xe = Z.id;
    if (xe === -1) {
      if ((Z.id = M.rootSegmentID) === -1)
        throw Error(t(392));
      return On(g, P, Z);
    }
    return On(g, P, Z), g = g.responseState, P.push(g.startInlineScript), g.sentCompleteSegmentFunction ? P.push('$RS("') : (g.sentCompleteSegmentFunction = !0, P.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), P.push(g.segmentPrefix), xe = xe.toString(16), P.push(xe), P.push('","'), P.push(g.placeholderPrefix), P.push(xe), P.push('")<\/script>');
  }
  function fn(g, P) {
    try {
      var M = g.completedRootSegment;
      if (M !== null && g.pendingRootTasks === 0) {
        wn(g, P, M), g.completedRootSegment = null;
        var Z = g.responseState.bootstrapChunks;
        for (M = 0; M < Z.length - 1; M++)
          P.push(Z[M]);
        M < Z.length && P.push(Z[M]);
      }
      var xe = g.clientRenderedBoundaries, B;
      for (B = 0; B < xe.length; B++) {
        var I = xe[B];
        Z = P;
        var ee = g.responseState, be = I.id, We = I.errorDigest, Qe = I.errorMessage, St = I.errorComponentStack;
        if (Z.push(ee.startInlineScript), ee.sentClientRenderFunction ? Z.push('$RX("') : (ee.sentClientRenderFunction = !0, Z.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), be === null)
          throw Error(t(395));
        if (Z.push(be), Z.push('"'), We || Qe || St) {
          Z.push(",");
          var Dt = oe(We || "");
          Z.push(Dt);
        }
        if (Qe || St) {
          Z.push(",");
          var Bt = oe(Qe || "");
          Z.push(Bt);
        }
        if (St) {
          Z.push(",");
          var Cn = oe(St);
          Z.push(Cn);
        }
        if (!Z.push(")<\/script>")) {
          g.destination = null, B++, xe.splice(0, B);
          return;
        }
      }
      xe.splice(0, B);
      var Kn = g.completedBoundaries;
      for (B = 0; B < Kn.length; B++)
        if (!Nn(g, P, Kn[B])) {
          g.destination = null, B++, Kn.splice(0, B);
          return;
        }
      Kn.splice(0, B);
      var Mn = g.partialBoundaries;
      for (B = 0; B < Mn.length; B++) {
        var fr = Mn[B];
        e: {
          xe = g, I = P;
          var Xn = fr.completedSegments;
          for (ee = 0; ee < Xn.length; ee++)
            if (!Ln(xe, I, fr, Xn[ee])) {
              ee++, Xn.splice(0, ee);
              var Ct = !1;
              break e;
            }
          Xn.splice(0, ee), Ct = !0;
        }
        if (!Ct) {
          g.destination = null, B++, Mn.splice(0, B);
          return;
        }
      }
      Mn.splice(0, B);
      var rn = g.completedBoundaries;
      for (B = 0; B < rn.length; B++)
        if (!Nn(g, P, rn[B])) {
          g.destination = null, B++, rn.splice(0, B);
          return;
        }
      rn.splice(0, B);
    } finally {
      g.allPendingTasks === 0 && g.pingedTasks.length === 0 && g.clientRenderedBoundaries.length === 0 && g.completedBoundaries.length === 0 && P.push(null);
    }
  }
  function Fn(g, P) {
    try {
      var M = g.abortableTasks;
      M.forEach(function(Z) {
        return Ft(Z, g, P);
      }), M.clear(), g.destination !== null && fn(g, g.destination);
    } catch (Z) {
      ht(g, Z), it(g, Z);
    }
  }
  function Zt() {
  }
  function we(g, P, M, Z) {
    var xe = !1, B = null, I = "", ee = { push: function(We) {
      return We !== null && (I += We), !0;
    }, destroy: function(We) {
      xe = !0, B = We;
    } }, be = !1;
    if (g = Ne(g, K(M, P ? P.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, Zt, void 0, function() {
      be = !0;
    }, void 0, void 0), Mt(g), Fn(g, Z), g.status === 1)
      g.status = 2, ee.destroy(g.fatalError);
    else if (g.status !== 2 && g.destination === null) {
      g.destination = ee;
      try {
        fn(g, ee);
      } catch (We) {
        ht(g, We), it(g, We);
      }
    }
    if (xe)
      throw B;
    if (!be)
      throw Error(t(426));
    return I;
  }
  return _i.renderToNodeStream = function() {
    throw Error(t(207));
  }, _i.renderToStaticMarkup = function(g, P) {
    return we(g, P, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, _i.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, _i.renderToString = function(g, P) {
    return we(g, P, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, _i.version = "18.2.0", _i;
}
var $u = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tm;
function hS() {
  if (tm)
    return $u;
  tm = 1;
  var e = ue;
  function t(k) {
    for (var O = "https://reactjs.org/docs/error-decoder.html?invariant=" + k, V = 1; V < arguments.length; V++)
      O += "&args[]=" + encodeURIComponent(arguments[V]);
    return "Minified React error #" + k + "; visit " + O + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = null, a = 0;
  function i(k, O) {
    if (O.length !== 0)
      if (512 < O.length)
        0 < a && (k.enqueue(new Uint8Array(r.buffer, 0, a)), r = new Uint8Array(512), a = 0), k.enqueue(O);
      else {
        var V = r.length - a;
        V < O.length && (V === 0 ? k.enqueue(r) : (r.set(O.subarray(0, V), a), k.enqueue(r), O = O.subarray(V)), r = new Uint8Array(512), a = 0), r.set(O, a), a += O.length;
      }
  }
  function o(k, O) {
    return i(k, O), !0;
  }
  function d(k) {
    r && 0 < a && (k.enqueue(new Uint8Array(r.buffer, 0, a)), r = null, a = 0);
  }
  var c = new TextEncoder();
  function s(k) {
    return c.encode(k);
  }
  function p(k) {
    return c.encode(k);
  }
  function m(k, O) {
    typeof k.error == "function" ? k.error(O) : k.close();
  }
  var y = Object.prototype.hasOwnProperty, x = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, T = {}, S = {};
  function A(k) {
    return y.call(S, k) ? !0 : y.call(T, k) ? !1 : x.test(k) ? S[k] = !0 : (T[k] = !0, !1);
  }
  function E(k, O, V, re, Ce, ke, Me) {
    this.acceptsBooleans = O === 2 || O === 3 || O === 4, this.attributeName = re, this.attributeNamespace = Ce, this.mustUseProperty = V, this.propertyName = k, this.type = O, this.sanitizeURL = ke, this.removeEmptyString = Me;
  }
  var b = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(k) {
    b[k] = new E(k, 0, !1, k, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(k) {
    var O = k[0];
    b[O] = new E(O, 1, !1, k[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(k) {
    b[k] = new E(k, 2, !1, k.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(k) {
    b[k] = new E(k, 2, !1, k, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(k) {
    b[k] = new E(k, 3, !1, k.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(k) {
    b[k] = new E(k, 3, !0, k, null, !1, !1);
  }), ["capture", "download"].forEach(function(k) {
    b[k] = new E(k, 4, !1, k, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(k) {
    b[k] = new E(k, 6, !1, k, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(k) {
    b[k] = new E(k, 5, !1, k.toLowerCase(), null, !1, !1);
  });
  var v = /[\-:]([a-z])/g;
  function N(k) {
    return k[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(k) {
    var O = k.replace(
      v,
      N
    );
    b[O] = new E(O, 1, !1, k, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(k) {
    var O = k.replace(v, N);
    b[O] = new E(O, 1, !1, k, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(k) {
    var O = k.replace(v, N);
    b[O] = new E(O, 1, !1, k, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(k) {
    b[k] = new E(k, 1, !1, k.toLowerCase(), null, !1, !1);
  }), b.xlinkHref = new E("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(k) {
    b[k] = new E(k, 1, !1, k.toLowerCase(), null, !0, !0);
  });
  var C = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, R = ["Webkit", "ms", "Moz", "O"];
  Object.keys(C).forEach(function(k) {
    R.forEach(function(O) {
      O = O + k.charAt(0).toUpperCase() + k.substring(1), C[O] = C[k];
    });
  });
  var _ = /["'&<>]/;
  function U(k) {
    if (typeof k == "boolean" || typeof k == "number")
      return "" + k;
    k = "" + k;
    var O = _.exec(k);
    if (O) {
      var V = "", re, Ce = 0;
      for (re = O.index; re < k.length; re++) {
        switch (k.charCodeAt(re)) {
          case 34:
            O = "&quot;";
            break;
          case 38:
            O = "&amp;";
            break;
          case 39:
            O = "&#x27;";
            break;
          case 60:
            O = "&lt;";
            break;
          case 62:
            O = "&gt;";
            break;
          default:
            continue;
        }
        Ce !== re && (V += k.substring(Ce, re)), Ce = re + 1, V += O;
      }
      k = Ce !== re ? V + k.substring(Ce, re) : V;
    }
    return k;
  }
  var j = /([A-Z])/g, te = /^ms-/, Q = Array.isArray, $ = p("<script>"), J = p("<\/script>"), ne = p('<script src="'), z = p('<script type="module" src="'), W = p('" async=""><\/script>'), ie = /(<\/|<)(s)(cript)/gi;
  function ae(k, O, V, re) {
    return "" + O + (V === "s" ? "\\u0073" : "\\u0053") + re;
  }
  function oe(k, O, V, re, Ce) {
    k = k === void 0 ? "" : k, O = O === void 0 ? $ : p('<script nonce="' + U(O) + '">');
    var ke = [];
    if (V !== void 0 && ke.push(O, s(("" + V).replace(ie, ae)), J), re !== void 0)
      for (V = 0; V < re.length; V++)
        ke.push(ne, s(U(re[V])), W);
    if (Ce !== void 0)
      for (re = 0; re < Ce.length; re++)
        ke.push(z, s(U(Ce[re])), W);
    return { bootstrapChunks: ke, startInlineScript: O, placeholderPrefix: p(k + "P:"), segmentPrefix: p(k + "S:"), boundaryPrefix: k + "B:", idPrefix: k, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function K(k, O) {
    return { insertionMode: k, selectedValue: O };
  }
  function Y(k) {
    return K(k === "http://www.w3.org/2000/svg" ? 2 : k === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function X(k, O, V) {
    switch (O) {
      case "select":
        return K(1, V.value != null ? V.value : V.defaultValue);
      case "svg":
        return K(2, null);
      case "math":
        return K(3, null);
      case "foreignObject":
        return K(1, null);
      case "table":
        return K(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return K(5, null);
      case "colgroup":
        return K(7, null);
      case "tr":
        return K(6, null);
    }
    return 4 <= k.insertionMode || k.insertionMode === 0 ? K(1, null) : k;
  }
  var q = p("<!-- -->");
  function ce(k, O, V, re) {
    return O === "" ? re : (re && k.push(q), k.push(s(U(O))), !0);
  }
  var ge = /* @__PURE__ */ new Map(), De = p(' style="'), me = p(":"), Fe = p(";");
  function Ue(k, O, V) {
    if (typeof V != "object")
      throw Error(t(62));
    O = !0;
    for (var re in V)
      if (y.call(V, re)) {
        var Ce = V[re];
        if (Ce != null && typeof Ce != "boolean" && Ce !== "") {
          if (re.indexOf("--") === 0) {
            var ke = s(U(re));
            Ce = s(U(("" + Ce).trim()));
          } else {
            ke = re;
            var Me = ge.get(ke);
            Me !== void 0 || (Me = p(U(ke.replace(j, "-$1").toLowerCase().replace(te, "-ms-"))), ge.set(ke, Me)), ke = Me, Ce = typeof Ce == "number" ? Ce === 0 || y.call(C, re) ? s("" + Ce) : s(Ce + "px") : s(U(("" + Ce).trim()));
          }
          O ? (O = !1, k.push(De, ke, me, Ce)) : k.push(Fe, ke, me, Ce);
        }
      }
    O || k.push(Ae);
  }
  var Te = p(" "), ve = p('="'), Ae = p('"'), fe = p('=""');
  function ze(k, O, V, re) {
    switch (V) {
      case "style":
        Ue(k, O, re);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < V.length) || V[0] !== "o" && V[0] !== "O" || V[1] !== "n" && V[1] !== "N") {
      if (O = b.hasOwnProperty(V) ? b[V] : null, O !== null) {
        switch (typeof re) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!O.acceptsBooleans)
              return;
        }
        switch (V = s(O.attributeName), O.type) {
          case 3:
            re && k.push(Te, V, fe);
            break;
          case 4:
            re === !0 ? k.push(Te, V, fe) : re !== !1 && k.push(Te, V, ve, s(U(re)), Ae);
            break;
          case 5:
            isNaN(re) || k.push(Te, V, ve, s(U(re)), Ae);
            break;
          case 6:
            !isNaN(re) && 1 <= re && k.push(Te, V, ve, s(U(re)), Ae);
            break;
          default:
            O.sanitizeURL && (re = "" + re), k.push(Te, V, ve, s(U(re)), Ae);
        }
      } else if (A(V)) {
        switch (typeof re) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (O = V.toLowerCase().slice(0, 5), O !== "data-" && O !== "aria-")
              return;
        }
        k.push(Te, s(V), ve, s(U(re)), Ae);
      }
    }
  }
  var Oe = p(">"), Ve = p("/>");
  function Ze(k, O, V) {
    if (O != null) {
      if (V != null)
        throw Error(t(60));
      if (typeof O != "object" || !("__html" in O))
        throw Error(t(61));
      O = O.__html, O != null && k.push(s("" + O));
    }
  }
  function Ie(k) {
    var O = "";
    return e.Children.forEach(k, function(V) {
      V != null && (O += V);
    }), O;
  }
  var qe = p(' selected=""');
  function et(k, O, V, re) {
    k.push(_e(V));
    var Ce = V = null, ke;
    for (ke in O)
      if (y.call(O, ke)) {
        var Me = O[ke];
        if (Me != null)
          switch (ke) {
            case "children":
              V = Me;
              break;
            case "dangerouslySetInnerHTML":
              Ce = Me;
              break;
            default:
              ze(k, re, ke, Me);
          }
      }
    return k.push(Oe), Ze(k, Ce, V), typeof V == "string" ? (k.push(s(U(V))), null) : V;
  }
  var He = p(`
`), Ge = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Le = /* @__PURE__ */ new Map();
  function _e(k) {
    var O = Le.get(k);
    if (O === void 0) {
      if (!Ge.test(k))
        throw Error(t(65, k));
      O = p("<" + k), Le.set(k, O);
    }
    return O;
  }
  var st = p("<!DOCTYPE html>");
  function Ee(k, O, V, re, Ce) {
    switch (O) {
      case "select":
        k.push(_e("select"));
        var ke = null, Me = null;
        for (Tt in V)
          if (y.call(V, Tt)) {
            var Ye = V[Tt];
            if (Ye != null)
              switch (Tt) {
                case "children":
                  ke = Ye;
                  break;
                case "dangerouslySetInnerHTML":
                  Me = Ye;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  ze(k, re, Tt, Ye);
              }
          }
        return k.push(Oe), Ze(k, Me, ke), ke;
      case "option":
        Me = Ce.selectedValue, k.push(_e("option"));
        var Et = Ye = null, Pt = null, Tt = null;
        for (ke in V)
          if (y.call(V, ke)) {
            var un = V[ke];
            if (un != null)
              switch (ke) {
                case "children":
                  Ye = un;
                  break;
                case "selected":
                  Pt = un;
                  break;
                case "dangerouslySetInnerHTML":
                  Tt = un;
                  break;
                case "value":
                  Et = un;
                default:
                  ze(k, re, ke, un);
              }
          }
        if (Me != null)
          if (V = Et !== null ? "" + Et : Ie(Ye), Q(Me)) {
            for (re = 0; re < Me.length; re++)
              if ("" + Me[re] === V) {
                k.push(qe);
                break;
              }
          } else
            "" + Me === V && k.push(qe);
        else
          Pt && k.push(qe);
        return k.push(Oe), Ze(k, Tt, Ye), Ye;
      case "textarea":
        k.push(_e("textarea")), Tt = Me = ke = null;
        for (Ye in V)
          if (y.call(V, Ye) && (Et = V[Ye], Et != null))
            switch (Ye) {
              case "children":
                Tt = Et;
                break;
              case "value":
                ke = Et;
                break;
              case "defaultValue":
                Me = Et;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                ze(k, re, Ye, Et);
            }
        if (ke === null && Me !== null && (ke = Me), k.push(Oe), Tt != null) {
          if (ke != null)
            throw Error(t(92));
          if (Q(Tt) && 1 < Tt.length)
            throw Error(t(93));
          ke = "" + Tt;
        }
        return typeof ke == "string" && ke[0] === `
` && k.push(He), ke !== null && k.push(s(U("" + ke))), null;
      case "input":
        k.push(_e("input")), Et = Tt = Ye = ke = null;
        for (Me in V)
          if (y.call(V, Me) && (Pt = V[Me], Pt != null))
            switch (Me) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                Et = Pt;
                break;
              case "defaultValue":
                Ye = Pt;
                break;
              case "checked":
                Tt = Pt;
                break;
              case "value":
                ke = Pt;
                break;
              default:
                ze(k, re, Me, Pt);
            }
        return Tt !== null ? ze(
          k,
          re,
          "checked",
          Tt
        ) : Et !== null && ze(k, re, "checked", Et), ke !== null ? ze(k, re, "value", ke) : Ye !== null && ze(k, re, "value", Ye), k.push(Ve), null;
      case "menuitem":
        k.push(_e("menuitem"));
        for (var Qn in V)
          if (y.call(V, Qn) && (ke = V[Qn], ke != null))
            switch (Qn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                ze(k, re, Qn, ke);
            }
        return k.push(Oe), null;
      case "title":
        k.push(_e("title")), ke = null;
        for (un in V)
          if (y.call(V, un) && (Me = V[un], Me != null))
            switch (un) {
              case "children":
                ke = Me;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                ze(k, re, un, Me);
            }
        return k.push(Oe), ke;
      case "listing":
      case "pre":
        k.push(_e(O)), Me = ke = null;
        for (Et in V)
          if (y.call(V, Et) && (Ye = V[Et], Ye != null))
            switch (Et) {
              case "children":
                ke = Ye;
                break;
              case "dangerouslySetInnerHTML":
                Me = Ye;
                break;
              default:
                ze(k, re, Et, Ye);
            }
        if (k.push(Oe), Me != null) {
          if (ke != null)
            throw Error(t(60));
          if (typeof Me != "object" || !("__html" in Me))
            throw Error(t(61));
          V = Me.__html, V != null && (typeof V == "string" && 0 < V.length && V[0] === `
` ? k.push(He, s(V)) : k.push(s("" + V)));
        }
        return typeof ke == "string" && ke[0] === `
` && k.push(He), ke;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        k.push(_e(O));
        for (var or in V)
          if (y.call(V, or) && (ke = V[or], ke != null))
            switch (or) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, O));
              default:
                ze(k, re, or, ke);
            }
        return k.push(Ve), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return et(k, V, O, re);
      case "html":
        return Ce.insertionMode === 0 && k.push(st), et(k, V, O, re);
      default:
        if (O.indexOf("-") === -1 && typeof V.is != "string")
          return et(k, V, O, re);
        k.push(_e(O)), Me = ke = null;
        for (Pt in V)
          if (y.call(V, Pt) && (Ye = V[Pt], Ye != null))
            switch (Pt) {
              case "children":
                ke = Ye;
                break;
              case "dangerouslySetInnerHTML":
                Me = Ye;
                break;
              case "style":
                Ue(k, re, Ye);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                A(Pt) && typeof Ye != "function" && typeof Ye != "symbol" && k.push(Te, s(Pt), ve, s(U(Ye)), Ae);
            }
        return k.push(Oe), Ze(k, Me, ke), ke;
    }
  }
  var rt = p("</"), pt = p(">"), ft = p('<template id="'), wt = p('"></template>'), zt = p("<!--$-->"), Jt = p('<!--$?--><template id="'), jt = p('"></template>'), on = p("<!--$!-->"), _t = p("<!--/$-->"), tn = p("<template"), $t = p('"'), Ut = p(' data-dgst="');
  p(' data-msg="'), p(' data-stck="');
  var bt = p("></template>");
  function mt(k, O, V) {
    if (i(k, Jt), V === null)
      throw Error(t(395));
    return i(k, V), o(k, jt);
  }
  var ln = p('<div hidden id="'), Yt = p('">'), xt = p("</div>"), Gt = p('<svg aria-hidden="true" style="display:none" id="'), Sn = p('">'), At = p("</svg>"), nn = p('<math aria-hidden="true" style="display:none" id="'), Xt = p('">'), sn = p("</math>"), Nt = p('<table hidden id="'), xn = p('">'), dn = p("</table>"), Lt = p('<table hidden><tbody id="'), nt = p('">'), bn = p("</tbody></table>"), Hn = p('<table hidden><tr id="'), Gn = p('">'), An = p("</tr></table>"), Un = p('<table hidden><colgroup id="'), _n = p('">'), Pn = p("</colgroup></table>");
  function pn(k, O, V, re) {
    switch (V.insertionMode) {
      case 0:
      case 1:
        return i(k, ln), i(k, O.segmentPrefix), i(k, s(re.toString(16))), o(k, Yt);
      case 2:
        return i(k, Gt), i(k, O.segmentPrefix), i(k, s(re.toString(16))), o(k, Sn);
      case 3:
        return i(k, nn), i(k, O.segmentPrefix), i(k, s(re.toString(16))), o(k, Xt);
      case 4:
        return i(k, Nt), i(k, O.segmentPrefix), i(k, s(re.toString(16))), o(k, xn);
      case 5:
        return i(k, Lt), i(k, O.segmentPrefix), i(k, s(re.toString(16))), o(k, nt);
      case 6:
        return i(k, Hn), i(k, O.segmentPrefix), i(k, s(re.toString(16))), o(k, Gn);
      case 7:
        return i(
          k,
          Un
        ), i(k, O.segmentPrefix), i(k, s(re.toString(16))), o(k, _n);
      default:
        throw Error(t(397));
    }
  }
  function Se(k, O) {
    switch (O.insertionMode) {
      case 0:
      case 1:
        return o(k, xt);
      case 2:
        return o(k, At);
      case 3:
        return o(k, sn);
      case 4:
        return o(k, dn);
      case 5:
        return o(k, bn);
      case 6:
        return o(k, An);
      case 7:
        return o(k, Pn);
      default:
        throw Error(t(397));
    }
  }
  var Ne = p('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), pe = p('$RS("'), Ke = p('","'), ht = p('")<\/script>'), it = p('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), ct = p('$RC("'), Kt = p('","'), Ot = p('")<\/script>'), tt = p('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), ut = p('$RX("'), It = p('"'), Rt = p(")<\/script>"), Ht = p(","), Ft = /[<\u2028\u2029]/g;
  function hn(k) {
    return JSON.stringify(k).replace(Ft, function(O) {
      switch (O) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var mn = Object.assign, Mt = Symbol.for("react.element"), kn = Symbol.for("react.portal"), wn = Symbol.for("react.fragment"), On = Symbol.for("react.strict_mode"), Nn = Symbol.for("react.profiler"), Ln = Symbol.for("react.provider"), fn = Symbol.for("react.context"), Fn = Symbol.for("react.forward_ref"), Zt = Symbol.for("react.suspense"), we = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), P = Symbol.for("react.lazy"), M = Symbol.for("react.scope"), Z = Symbol.for("react.debug_trace_mode"), xe = Symbol.for("react.legacy_hidden"), B = Symbol.for("react.default_value"), I = Symbol.iterator;
  function ee(k) {
    if (k == null)
      return null;
    if (typeof k == "function")
      return k.displayName || k.name || null;
    if (typeof k == "string")
      return k;
    switch (k) {
      case wn:
        return "Fragment";
      case kn:
        return "Portal";
      case Nn:
        return "Profiler";
      case On:
        return "StrictMode";
      case Zt:
        return "Suspense";
      case we:
        return "SuspenseList";
    }
    if (typeof k == "object")
      switch (k.$$typeof) {
        case fn:
          return (k.displayName || "Context") + ".Consumer";
        case Ln:
          return (k._context.displayName || "Context") + ".Provider";
        case Fn:
          var O = k.render;
          return k = k.displayName, k || (k = O.displayName || O.name || "", k = k !== "" ? "ForwardRef(" + k + ")" : "ForwardRef"), k;
        case g:
          return O = k.displayName || null, O !== null ? O : ee(k.type) || "Memo";
        case P:
          O = k._payload, k = k._init;
          try {
            return ee(k(O));
          } catch {
          }
      }
    return null;
  }
  var be = {};
  function We(k, O) {
    if (k = k.contextTypes, !k)
      return be;
    var V = {}, re;
    for (re in k)
      V[re] = O[re];
    return V;
  }
  var Qe = null;
  function St(k, O) {
    if (k !== O) {
      k.context._currentValue = k.parentValue, k = k.parent;
      var V = O.parent;
      if (k === null) {
        if (V !== null)
          throw Error(t(401));
      } else {
        if (V === null)
          throw Error(t(401));
        St(k, V);
      }
      O.context._currentValue = O.value;
    }
  }
  function Dt(k) {
    k.context._currentValue = k.parentValue, k = k.parent, k !== null && Dt(k);
  }
  function Bt(k) {
    var O = k.parent;
    O !== null && Bt(O), k.context._currentValue = k.value;
  }
  function Cn(k, O) {
    if (k.context._currentValue = k.parentValue, k = k.parent, k === null)
      throw Error(t(402));
    k.depth === O.depth ? St(k, O) : Cn(k, O);
  }
  function Kn(k, O) {
    var V = O.parent;
    if (V === null)
      throw Error(t(402));
    k.depth === V.depth ? St(k, V) : Kn(k, V), O.context._currentValue = O.value;
  }
  function Mn(k) {
    var O = Qe;
    O !== k && (O === null ? Bt(k) : k === null ? Dt(O) : O.depth === k.depth ? St(O, k) : O.depth > k.depth ? Cn(O, k) : Kn(O, k), Qe = k);
  }
  var fr = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(k, O) {
    k = k._reactInternals, k.queue !== null && k.queue.push(O);
  }, enqueueReplaceState: function(k, O) {
    k = k._reactInternals, k.replace = !0, k.queue = [O];
  }, enqueueForceUpdate: function() {
  } };
  function Xn(k, O, V, re) {
    var Ce = k.state !== void 0 ? k.state : null;
    k.updater = fr, k.props = V, k.state = Ce;
    var ke = { queue: [], replace: !1 };
    k._reactInternals = ke;
    var Me = O.contextType;
    if (k.context = typeof Me == "object" && Me !== null ? Me._currentValue : re, Me = O.getDerivedStateFromProps, typeof Me == "function" && (Me = Me(V, Ce), Ce = Me == null ? Ce : mn({}, Ce, Me), k.state = Ce), typeof O.getDerivedStateFromProps != "function" && typeof k.getSnapshotBeforeUpdate != "function" && (typeof k.UNSAFE_componentWillMount == "function" || typeof k.componentWillMount == "function"))
      if (O = k.state, typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount(), O !== k.state && fr.enqueueReplaceState(k, k.state, null), ke.queue !== null && 0 < ke.queue.length)
        if (O = ke.queue, Me = ke.replace, ke.queue = null, ke.replace = !1, Me && O.length === 1)
          k.state = O[0];
        else {
          for (ke = Me ? O[0] : k.state, Ce = !0, Me = Me ? 1 : 0; Me < O.length; Me++) {
            var Ye = O[Me];
            Ye = typeof Ye == "function" ? Ye.call(k, ke, V, re) : Ye, Ye != null && (Ce ? (Ce = !1, ke = mn({}, ke, Ye)) : mn(ke, Ye));
          }
          k.state = ke;
        }
      else
        ke.queue = null;
  }
  var Ct = { id: 1, overflow: "" };
  function rn(k, O, V) {
    var re = k.id;
    k = k.overflow;
    var Ce = 32 - xr(re) - 1;
    re &= ~(1 << Ce), V += 1;
    var ke = 32 - xr(O) + Ce;
    if (30 < ke) {
      var Me = Ce - Ce % 5;
      return ke = (re & (1 << Me) - 1).toString(32), re >>= Me, Ce -= Me, { id: 1 << 32 - xr(O) + Ce | V << Ce | re, overflow: ke + k };
    }
    return { id: 1 << ke | V << Ce | re, overflow: k };
  }
  var xr = Math.clz32 ? Math.clz32 : ea, Jr = Math.log, Ga = Math.LN2;
  function ea(k) {
    return k >>>= 0, k === 0 ? 32 : 31 - (Jr(k) / Ga | 0) | 0;
  }
  function Xa(k, O) {
    return k === O && (k !== 0 || 1 / k === 1 / O) || k !== k && O !== O;
  }
  var Pr = typeof Object.is == "function" ? Object.is : Xa, ar = null, ta = null, va = null, an = null, br = !1, qn = !1, Nr = 0, Er = null, xa = 0;
  function Sr() {
    if (ar === null)
      throw Error(t(321));
    return ar;
  }
  function ir() {
    if (0 < xa)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function qa() {
    return an === null ? va === null ? (br = !1, va = an = ir()) : (br = !0, an = va) : an.next === null ? (br = !1, an = an.next = ir()) : (br = !0, an = an.next), an;
  }
  function Za() {
    ta = ar = null, qn = !1, va = null, xa = 0, an = Er = null;
  }
  function Zi(k, O) {
    return typeof O == "function" ? O(k) : O;
  }
  function Qi(k, O, V) {
    if (ar = Sr(), an = qa(), br) {
      var re = an.queue;
      if (O = re.dispatch, Er !== null && (V = Er.get(re), V !== void 0)) {
        Er.delete(re), re = an.memoizedState;
        do
          re = k(re, V.action), V = V.next;
        while (V !== null);
        return an.memoizedState = re, [re, O];
      }
      return [an.memoizedState, O];
    }
    return k = k === Zi ? typeof O == "function" ? O() : O : V !== void 0 ? V(O) : O, an.memoizedState = k, k = an.queue = { last: null, dispatch: null }, k = k.dispatch = hl.bind(null, ar, k), [an.memoizedState, k];
  }
  function Ji(k, O) {
    if (ar = Sr(), an = qa(), O = O === void 0 ? null : O, an !== null) {
      var V = an.memoizedState;
      if (V !== null && O !== null) {
        var re = V[1];
        e:
          if (re === null)
            re = !1;
          else {
            for (var Ce = 0; Ce < re.length && Ce < O.length; Ce++)
              if (!Pr(O[Ce], re[Ce])) {
                re = !1;
                break e;
              }
            re = !0;
          }
        if (re)
          return V[0];
      }
    }
    return k = k(), an.memoizedState = [k, O], k;
  }
  function hl(k, O, V) {
    if (25 <= xa)
      throw Error(t(301));
    if (k === ar)
      if (qn = !0, k = { action: V, next: null }, Er === null && (Er = /* @__PURE__ */ new Map()), V = Er.get(O), V === void 0)
        Er.set(O, k);
      else {
        for (O = V; O.next !== null; )
          O = O.next;
        O.next = k;
      }
  }
  function ml() {
    throw Error(t(394));
  }
  function ba() {
  }
  var Ea = { readContext: function(k) {
    return k._currentValue;
  }, useContext: function(k) {
    return Sr(), k._currentValue;
  }, useMemo: Ji, useReducer: Qi, useRef: function(k) {
    ar = Sr(), an = qa();
    var O = an.memoizedState;
    return O === null ? (k = { current: k }, an.memoizedState = k) : O;
  }, useState: function(k) {
    return Qi(Zi, k);
  }, useInsertionEffect: ba, useLayoutEffect: function() {
  }, useCallback: function(k, O) {
    return Ji(function() {
      return k;
    }, O);
  }, useImperativeHandle: ba, useEffect: ba, useDebugValue: ba, useDeferredValue: function(k) {
    return Sr(), k;
  }, useTransition: function() {
    return Sr(), [!1, ml];
  }, useId: function() {
    var k = ta.treeContext, O = k.overflow;
    k = k.id, k = (k & ~(1 << 32 - xr(k) - 1)).toString(32) + O;
    var V = Sa;
    if (V === null)
      throw Error(t(404));
    return O = Nr++, k = ":" + V.idPrefix + "R" + k, 0 < O && (k += "H" + O.toString(32)), k + ":";
  }, useMutableSource: function(k, O) {
    return Sr(), O(k._source);
  }, useSyncExternalStore: function(k, O, V) {
    if (V === void 0)
      throw Error(t(407));
    return V();
  } }, Sa = null, na = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function yl(k) {
    return console.error(k), null;
  }
  function ra() {
  }
  function Qa(k, O, V, re, Ce, ke, Me, Ye, Et) {
    var Pt = [], Tt = /* @__PURE__ */ new Set();
    return O = { destination: null, responseState: O, progressiveChunkSize: re === void 0 ? 12800 : re, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Tt, pingedTasks: Pt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Ce === void 0 ? yl : Ce, onAllReady: ke === void 0 ? ra : ke, onShellReady: Me === void 0 ? ra : Me, onShellError: Ye === void 0 ? ra : Ye, onFatalError: Et === void 0 ? ra : Et }, V = Ir(O, 0, null, V, !1, !1), V.parentFlushed = !0, k = Ja(O, k, null, V, Tt, be, null, Ct), Pt.push(k), O;
  }
  function Ja(k, O, V, re, Ce, ke, Me, Ye) {
    k.allPendingTasks++, V === null ? k.pendingRootTasks++ : V.pendingTasks++;
    var Et = { node: O, ping: function() {
      var Pt = k.pingedTasks;
      Pt.push(Et), Pt.length === 1 && io(k);
    }, blockedBoundary: V, blockedSegment: re, abortSet: Ce, legacyContext: ke, context: Me, treeContext: Ye };
    return Ce.add(Et), Et;
  }
  function Ir(k, O, V, re, Ce, ke) {
    return { status: 0, id: -1, index: O, parentFlushed: !1, chunks: [], children: [], formatContext: re, boundary: V, lastPushedText: Ce, textEmbedded: ke };
  }
  function Hr(k, O) {
    if (k = k.onError(O), k != null && typeof k != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof k + '" instead');
    return k;
  }
  function ka(k, O) {
    var V = k.onShellError;
    V(O), V = k.onFatalError, V(O), k.destination !== null ? (k.status = 2, m(k.destination, O)) : (k.status = 1, k.fatalError = O);
  }
  function eo(k, O, V, re, Ce) {
    for (ar = {}, ta = O, Nr = 0, k = V(re, Ce); qn; )
      qn = !1, Nr = 0, xa += 1, an = null, k = V(re, Ce);
    return Za(), k;
  }
  function ei(k, O, V, re) {
    var Ce = V.render(), ke = re.childContextTypes;
    if (ke != null) {
      var Me = O.legacyContext;
      if (typeof V.getChildContext != "function")
        re = Me;
      else {
        V = V.getChildContext();
        for (var Ye in V)
          if (!(Ye in ke))
            throw Error(t(108, ee(re) || "Unknown", Ye));
        re = mn({}, Me, V);
      }
      O.legacyContext = re, Zn(k, O, Ce), O.legacyContext = Me;
    } else
      Zn(k, O, Ce);
  }
  function to(k, O) {
    if (k && k.defaultProps) {
      O = mn({}, O), k = k.defaultProps;
      for (var V in k)
        O[V] === void 0 && (O[V] = k[V]);
      return O;
    }
    return O;
  }
  function wa(k, O, V, re, Ce) {
    if (typeof V == "function")
      if (V.prototype && V.prototype.isReactComponent) {
        Ce = We(V, O.legacyContext);
        var ke = V.contextType;
        ke = new V(re, typeof ke == "object" && ke !== null ? ke._currentValue : Ce), Xn(ke, V, re, Ce), ei(k, O, ke, V);
      } else {
        ke = We(V, O.legacyContext), Ce = eo(k, O, V, re, ke);
        var Me = Nr !== 0;
        if (typeof Ce == "object" && Ce !== null && typeof Ce.render == "function" && Ce.$$typeof === void 0)
          Xn(Ce, V, re, ke), ei(k, O, Ce, V);
        else if (Me) {
          re = O.treeContext, O.treeContext = rn(re, 1, 0);
          try {
            Zn(k, O, Ce);
          } finally {
            O.treeContext = re;
          }
        } else
          Zn(k, O, Ce);
      }
    else if (typeof V == "string") {
      switch (Ce = O.blockedSegment, ke = Ee(Ce.chunks, V, re, k.responseState, Ce.formatContext), Ce.lastPushedText = !1, Me = Ce.formatContext, Ce.formatContext = X(Me, V, re), Ca(k, O, ke), Ce.formatContext = Me, V) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Ce.chunks.push(rt, s(V), pt);
      }
      Ce.lastPushedText = !1;
    } else {
      switch (V) {
        case xe:
        case Z:
        case On:
        case Nn:
        case wn:
          Zn(k, O, re.children);
          return;
        case we:
          Zn(k, O, re.children);
          return;
        case M:
          throw Error(t(343));
        case Zt:
          e: {
            V = O.blockedBoundary, Ce = O.blockedSegment, ke = re.fallback, re = re.children, Me = /* @__PURE__ */ new Set();
            var Ye = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Me, errorDigest: null }, Et = Ir(k, Ce.chunks.length, Ye, Ce.formatContext, !1, !1);
            Ce.children.push(Et), Ce.lastPushedText = !1;
            var Pt = Ir(k, 0, null, Ce.formatContext, !1, !1);
            Pt.parentFlushed = !0, O.blockedBoundary = Ye, O.blockedSegment = Pt;
            try {
              if (Ca(
                k,
                O,
                re
              ), Pt.lastPushedText && Pt.textEmbedded && Pt.chunks.push(q), Pt.status = 1, Ta(Ye, Pt), Ye.pendingTasks === 0)
                break e;
            } catch (Tt) {
              Pt.status = 4, Ye.forceClientRender = !0, Ye.errorDigest = Hr(k, Tt);
            } finally {
              O.blockedBoundary = V, O.blockedSegment = Ce;
            }
            O = Ja(k, ke, V, Et, Me, O.legacyContext, O.context, O.treeContext), k.pingedTasks.push(O);
          }
          return;
      }
      if (typeof V == "object" && V !== null)
        switch (V.$$typeof) {
          case Fn:
            if (re = eo(k, O, V.render, re, Ce), Nr !== 0) {
              V = O.treeContext, O.treeContext = rn(V, 1, 0);
              try {
                Zn(k, O, re);
              } finally {
                O.treeContext = V;
              }
            } else
              Zn(k, O, re);
            return;
          case g:
            V = V.type, re = to(V, re), wa(k, O, V, re, Ce);
            return;
          case Ln:
            if (Ce = re.children, V = V._context, re = re.value, ke = V._currentValue, V._currentValue = re, Me = Qe, Qe = re = { parent: Me, depth: Me === null ? 0 : Me.depth + 1, context: V, parentValue: ke, value: re }, O.context = re, Zn(k, O, Ce), k = Qe, k === null)
              throw Error(t(403));
            re = k.parentValue, k.context._currentValue = re === B ? k.context._defaultValue : re, k = Qe = k.parent, O.context = k;
            return;
          case fn:
            re = re.children, re = re(V._currentValue), Zn(k, O, re);
            return;
          case P:
            Ce = V._init, V = Ce(V._payload), re = to(V, re), wa(k, O, V, re, void 0);
            return;
        }
      throw Error(t(
        130,
        V == null ? V : typeof V,
        ""
      ));
    }
  }
  function Zn(k, O, V) {
    if (O.node = V, typeof V == "object" && V !== null) {
      switch (V.$$typeof) {
        case Mt:
          wa(k, O, V.type, V.props, V.ref);
          return;
        case kn:
          throw Error(t(257));
        case P:
          var re = V._init;
          V = re(V._payload), Zn(k, O, V);
          return;
      }
      if (Q(V)) {
        no(k, O, V);
        return;
      }
      if (V === null || typeof V != "object" ? re = null : (re = I && V[I] || V["@@iterator"], re = typeof re == "function" ? re : null), re && (re = re.call(V))) {
        if (V = re.next(), !V.done) {
          var Ce = [];
          do
            Ce.push(V.value), V = re.next();
          while (!V.done);
          no(k, O, Ce);
        }
        return;
      }
      throw k = Object.prototype.toString.call(V), Error(t(31, k === "[object Object]" ? "object with keys {" + Object.keys(V).join(", ") + "}" : k));
    }
    typeof V == "string" ? (re = O.blockedSegment, re.lastPushedText = ce(O.blockedSegment.chunks, V, k.responseState, re.lastPushedText)) : typeof V == "number" && (re = O.blockedSegment, re.lastPushedText = ce(O.blockedSegment.chunks, "" + V, k.responseState, re.lastPushedText));
  }
  function no(k, O, V) {
    for (var re = V.length, Ce = 0; Ce < re; Ce++) {
      var ke = O.treeContext;
      O.treeContext = rn(ke, re, Ce);
      try {
        Ca(k, O, V[Ce]);
      } finally {
        O.treeContext = ke;
      }
    }
  }
  function Ca(k, O, V) {
    var re = O.blockedSegment.formatContext, Ce = O.legacyContext, ke = O.context;
    try {
      return Zn(k, O, V);
    } catch (Et) {
      if (Za(), typeof Et == "object" && Et !== null && typeof Et.then == "function") {
        V = Et;
        var Me = O.blockedSegment, Ye = Ir(k, Me.chunks.length, null, Me.formatContext, Me.lastPushedText, !0);
        Me.children.push(Ye), Me.lastPushedText = !1, k = Ja(k, O.node, O.blockedBoundary, Ye, O.abortSet, O.legacyContext, O.context, O.treeContext).ping, V.then(k, k), O.blockedSegment.formatContext = re, O.legacyContext = Ce, O.context = ke, Mn(ke);
      } else
        throw O.blockedSegment.formatContext = re, O.legacyContext = Ce, O.context = ke, Mn(ke), Et;
    }
  }
  function gl(k) {
    var O = k.blockedBoundary;
    k = k.blockedSegment, k.status = 3, ao(this, O, k);
  }
  function ro(k, O, V) {
    var re = k.blockedBoundary;
    k.blockedSegment.status = 3, re === null ? (O.allPendingTasks--, O.status !== 2 && (O.status = 2, O.destination !== null && O.destination.close())) : (re.pendingTasks--, re.forceClientRender || (re.forceClientRender = !0, k = V === void 0 ? Error(t(432)) : V, re.errorDigest = O.onError(k), re.parentFlushed && O.clientRenderedBoundaries.push(re)), re.fallbackAbortableTasks.forEach(function(Ce) {
      return ro(Ce, O, V);
    }), re.fallbackAbortableTasks.clear(), O.allPendingTasks--, O.allPendingTasks === 0 && (re = O.onAllReady, re()));
  }
  function Ta(k, O) {
    if (O.chunks.length === 0 && O.children.length === 1 && O.children[0].boundary === null) {
      var V = O.children[0];
      V.id = O.id, V.parentFlushed = !0, V.status === 1 && Ta(k, V);
    } else
      k.completedSegments.push(O);
  }
  function ao(k, O, V) {
    if (O === null) {
      if (V.parentFlushed) {
        if (k.completedRootSegment !== null)
          throw Error(t(389));
        k.completedRootSegment = V;
      }
      k.pendingRootTasks--, k.pendingRootTasks === 0 && (k.onShellError = ra, O = k.onShellReady, O());
    } else
      O.pendingTasks--, O.forceClientRender || (O.pendingTasks === 0 ? (V.parentFlushed && V.status === 1 && Ta(O, V), O.parentFlushed && k.completedBoundaries.push(O), O.fallbackAbortableTasks.forEach(gl, k), O.fallbackAbortableTasks.clear()) : V.parentFlushed && V.status === 1 && (Ta(O, V), O.completedSegments.length === 1 && O.parentFlushed && k.partialBoundaries.push(O)));
    k.allPendingTasks--, k.allPendingTasks === 0 && (k = k.onAllReady, k());
  }
  function io(k) {
    if (k.status !== 2) {
      var O = Qe, V = na.current;
      na.current = Ea;
      var re = Sa;
      Sa = k.responseState;
      try {
        var Ce = k.pingedTasks, ke;
        for (ke = 0; ke < Ce.length; ke++) {
          var Me = Ce[ke], Ye = k, Et = Me.blockedSegment;
          if (Et.status === 0) {
            Mn(Me.context);
            try {
              Zn(Ye, Me, Me.node), Et.lastPushedText && Et.textEmbedded && Et.chunks.push(q), Me.abortSet.delete(Me), Et.status = 1, ao(Ye, Me.blockedBoundary, Et);
            } catch (lr) {
              if (Za(), typeof lr == "object" && lr !== null && typeof lr.then == "function") {
                var Pt = Me.ping;
                lr.then(Pt, Pt);
              } else {
                Me.abortSet.delete(Me), Et.status = 4;
                var Tt = Me.blockedBoundary, un = lr, Qn = Hr(Ye, un);
                if (Tt === null ? ka(Ye, un) : (Tt.pendingTasks--, Tt.forceClientRender || (Tt.forceClientRender = !0, Tt.errorDigest = Qn, Tt.parentFlushed && Ye.clientRenderedBoundaries.push(Tt))), Ye.allPendingTasks--, Ye.allPendingTasks === 0) {
                  var or = Ye.onAllReady;
                  or();
                }
              }
            } finally {
            }
          }
        }
        Ce.splice(0, ke), k.destination !== null && ti(k, k.destination);
      } catch (lr) {
        Hr(k, lr), ka(k, lr);
      } finally {
        Sa = re, na.current = V, V === Ea && Mn(O);
      }
    }
  }
  function Aa(k, O, V) {
    switch (V.parentFlushed = !0, V.status) {
      case 0:
        var re = V.id = k.nextSegmentId++;
        return V.lastPushedText = !1, V.textEmbedded = !1, k = k.responseState, i(O, ft), i(O, k.placeholderPrefix), k = s(re.toString(16)), i(O, k), o(O, wt);
      case 1:
        V.status = 2;
        var Ce = !0;
        re = V.chunks;
        var ke = 0;
        V = V.children;
        for (var Me = 0; Me < V.length; Me++) {
          for (Ce = V[Me]; ke < Ce.index; ke++)
            i(O, re[ke]);
          Ce = La(k, O, Ce);
        }
        for (; ke < re.length - 1; ke++)
          i(O, re[ke]);
        return ke < re.length && (Ce = o(O, re[ke])), Ce;
      default:
        throw Error(t(390));
    }
  }
  function La(k, O, V) {
    var re = V.boundary;
    if (re === null)
      return Aa(k, O, V);
    if (re.parentFlushed = !0, re.forceClientRender)
      re = re.errorDigest, o(O, on), i(O, tn), re && (i(O, Ut), i(O, s(U(re))), i(O, $t)), o(O, bt), Aa(k, O, V);
    else if (0 < re.pendingTasks) {
      re.rootSegmentID = k.nextSegmentId++, 0 < re.completedSegments.length && k.partialBoundaries.push(re);
      var Ce = k.responseState, ke = Ce.nextSuspenseID++;
      Ce = p(Ce.boundaryPrefix + ke.toString(16)), re = re.id = Ce, mt(O, k.responseState, re), Aa(k, O, V);
    } else if (re.byteSize > k.progressiveChunkSize)
      re.rootSegmentID = k.nextSegmentId++, k.completedBoundaries.push(re), mt(O, k.responseState, re.id), Aa(k, O, V);
    else {
      if (o(O, zt), V = re.completedSegments, V.length !== 1)
        throw Error(t(391));
      La(k, O, V[0]);
    }
    return o(O, _t);
  }
  function oo(k, O, V) {
    return pn(O, k.responseState, V.formatContext, V.id), La(k, O, V), Se(O, V.formatContext);
  }
  function lo(k, O, V) {
    for (var re = V.completedSegments, Ce = 0; Ce < re.length; Ce++)
      so(k, O, V, re[Ce]);
    if (re.length = 0, k = k.responseState, re = V.id, V = V.rootSegmentID, i(O, k.startInlineScript), k.sentCompleteBoundaryFunction ? i(O, ct) : (k.sentCompleteBoundaryFunction = !0, i(O, it)), re === null)
      throw Error(t(395));
    return V = s(V.toString(16)), i(O, re), i(O, Kt), i(O, k.segmentPrefix), i(O, V), o(O, Ot);
  }
  function so(k, O, V, re) {
    if (re.status === 2)
      return !0;
    var Ce = re.id;
    if (Ce === -1) {
      if ((re.id = V.rootSegmentID) === -1)
        throw Error(t(392));
      return oo(k, O, re);
    }
    return oo(k, O, re), k = k.responseState, i(O, k.startInlineScript), k.sentCompleteSegmentFunction ? i(O, pe) : (k.sentCompleteSegmentFunction = !0, i(O, Ne)), i(O, k.segmentPrefix), Ce = s(Ce.toString(16)), i(O, Ce), i(O, Ke), i(O, k.placeholderPrefix), i(O, Ce), o(O, ht);
  }
  function ti(k, O) {
    r = new Uint8Array(512), a = 0;
    try {
      var V = k.completedRootSegment;
      if (V !== null && k.pendingRootTasks === 0) {
        La(k, O, V), k.completedRootSegment = null;
        var re = k.responseState.bootstrapChunks;
        for (V = 0; V < re.length - 1; V++)
          i(O, re[V]);
        V < re.length && o(O, re[V]);
      }
      var Ce = k.clientRenderedBoundaries, ke;
      for (ke = 0; ke < Ce.length; ke++) {
        var Me = Ce[ke];
        re = O;
        var Ye = k.responseState, Et = Me.id, Pt = Me.errorDigest, Tt = Me.errorMessage, un = Me.errorComponentStack;
        if (i(re, Ye.startInlineScript), Ye.sentClientRenderFunction ? i(re, ut) : (Ye.sentClientRenderFunction = !0, i(
          re,
          tt
        )), Et === null)
          throw Error(t(395));
        i(re, Et), i(re, It), (Pt || Tt || un) && (i(re, Ht), i(re, s(hn(Pt || "")))), (Tt || un) && (i(re, Ht), i(re, s(hn(Tt || "")))), un && (i(re, Ht), i(re, s(hn(un)))), o(re, Rt);
      }
      Ce.splice(0, ke);
      var Qn = k.completedBoundaries;
      for (ke = 0; ke < Qn.length; ke++)
        lo(k, O, Qn[ke]);
      Qn.splice(0, ke), d(O), r = new Uint8Array(512), a = 0;
      var or = k.partialBoundaries;
      for (ke = 0; ke < or.length; ke++) {
        var lr = or[ke];
        e: {
          Ce = k, Me = O;
          var Pa = lr.completedSegments;
          for (Ye = 0; Ye < Pa.length; Ye++)
            if (!so(
              Ce,
              Me,
              lr,
              Pa[Ye]
            )) {
              Ye++, Pa.splice(0, Ye);
              var co = !1;
              break e;
            }
          Pa.splice(0, Ye), co = !0;
        }
        if (!co) {
          k.destination = null, ke++, or.splice(0, ke);
          return;
        }
      }
      or.splice(0, ke);
      var ni = k.completedBoundaries;
      for (ke = 0; ke < ni.length; ke++)
        lo(k, O, ni[ke]);
      ni.splice(0, ke);
    } finally {
      d(O), k.allPendingTasks === 0 && k.pingedTasks.length === 0 && k.clientRenderedBoundaries.length === 0 && k.completedBoundaries.length === 0 && O.close();
    }
  }
  function uo(k, O) {
    try {
      var V = k.abortableTasks;
      V.forEach(function(re) {
        return ro(re, k, O);
      }), V.clear(), k.destination !== null && ti(k, k.destination);
    } catch (re) {
      Hr(k, re), ka(k, re);
    }
  }
  return $u.renderToReadableStream = function(k, O) {
    return new Promise(function(V, re) {
      var Ce, ke, Me = new Promise(function(Tt, un) {
        ke = Tt, Ce = un;
      }), Ye = Qa(k, oe(O ? O.identifierPrefix : void 0, O ? O.nonce : void 0, O ? O.bootstrapScriptContent : void 0, O ? O.bootstrapScripts : void 0, O ? O.bootstrapModules : void 0), Y(O ? O.namespaceURI : void 0), O ? O.progressiveChunkSize : void 0, O ? O.onError : void 0, ke, function() {
        var Tt = new ReadableStream({ type: "bytes", pull: function(un) {
          if (Ye.status === 1)
            Ye.status = 2, m(un, Ye.fatalError);
          else if (Ye.status !== 2 && Ye.destination === null) {
            Ye.destination = un;
            try {
              ti(Ye, un);
            } catch (Qn) {
              Hr(Ye, Qn), ka(Ye, Qn);
            }
          }
        }, cancel: function() {
          uo(Ye);
        } }, { highWaterMark: 0 });
        Tt.allReady = Me, V(Tt);
      }, function(Tt) {
        Me.catch(function() {
        }), re(Tt);
      }, Ce);
      if (O && O.signal) {
        var Et = O.signal, Pt = function() {
          uo(Ye, Et.reason), Et.removeEventListener("abort", Pt);
        };
        Et.addEventListener("abort", Pt);
      }
      io(Ye);
    });
  }, $u.version = "18.2.0", $u;
}
var Oi = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nm;
function mS() {
  return nm || (nm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ue, t = "18.2.0", r = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(l) {
      {
        for (var f = arguments.length, w = new Array(f > 1 ? f - 1 : 0), D = 1; D < f; D++)
          w[D - 1] = arguments[D];
        o("warn", l, w);
      }
    }
    function i(l) {
      {
        for (var f = arguments.length, w = new Array(f > 1 ? f - 1 : 0), D = 1; D < f; D++)
          w[D - 1] = arguments[D];
        o("error", l, w);
      }
    }
    function o(l, f, w) {
      {
        var D = r.ReactDebugCurrentFrame, H = D.getStackAddendum();
        H !== "" && (f += "%s", w = w.concat([H]));
        var le = w.map(function(he) {
          return String(he);
        });
        le.unshift("Warning: " + f), Function.prototype.apply.call(console[l], console, le);
      }
    }
    function d(l) {
      l();
    }
    function c(l) {
    }
    function s(l, f) {
      p(l, f);
    }
    function p(l, f) {
      return l.push(f);
    }
    function m(l) {
    }
    function y(l) {
      l.push(null);
    }
    function x(l) {
      return l;
    }
    function T(l) {
      return l;
    }
    function S(l, f) {
      l.destroy(f);
    }
    function A(l) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, w = f && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return w;
      }
    }
    function E(l) {
      try {
        return b(l), !1;
      } catch {
        return !0;
      }
    }
    function b(l) {
      return "" + l;
    }
    function v(l, f) {
      if (E(l))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", f, A(l)), b(l);
    }
    function N(l, f) {
      if (E(l))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", f, A(l)), b(l);
    }
    function C(l) {
      if (E(l))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", A(l)), b(l);
    }
    var R = Object.prototype.hasOwnProperty, _ = 0, U = 1, j = 2, te = 3, Q = 4, $ = 5, J = 6, ne = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", z = ne + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", W = new RegExp("^[" + ne + "][" + z + "]*$"), ie = {}, ae = {};
    function oe(l) {
      return R.call(ae, l) ? !0 : R.call(ie, l) ? !1 : W.test(l) ? (ae[l] = !0, !0) : (ie[l] = !0, i("Invalid attribute name: `%s`", l), !1);
    }
    function K(l, f, w, D) {
      if (w !== null && w.type === _)
        return !1;
      switch (typeof f) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (D)
            return !1;
          if (w !== null)
            return !w.acceptsBooleans;
          var H = l.toLowerCase().slice(0, 5);
          return H !== "data-" && H !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Y(l) {
      return q.hasOwnProperty(l) ? q[l] : null;
    }
    function X(l, f, w, D, H, le, he) {
      this.acceptsBooleans = f === j || f === te || f === Q, this.attributeName = D, this.attributeNamespace = H, this.mustUseProperty = w, this.propertyName = l, this.type = f, this.sanitizeURL = le, this.removeEmptyString = he;
    }
    var q = {}, ce = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ce.forEach(function(l) {
      q[l] = new X(
        l,
        _,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
      var f = l[0], w = l[1];
      q[f] = new X(
        f,
        U,
        !1,
        // mustUseProperty
        w,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
      q[l] = new X(
        l,
        j,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
      q[l] = new X(
        l,
        j,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(l) {
      q[l] = new X(
        l,
        te,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      q[l] = new X(
        l,
        te,
        !0,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      q[l] = new X(
        l,
        Q,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      q[l] = new X(
        l,
        J,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(l) {
      q[l] = new X(
        l,
        $,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ge = /[\-\:]([a-z])/g, De = function(l) {
      return l[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ge, De);
      q[f] = new X(
        f,
        U,
        !1,
        // mustUseProperty
        l,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ge, De);
      q[f] = new X(
        f,
        U,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ge, De);
      q[f] = new X(
        f,
        U,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(l) {
      q[l] = new X(
        l,
        U,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var me = "xlinkHref";
    q[me] = new X(
      "xlinkHref",
      U,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(l) {
      q[l] = new X(
        l,
        U,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Fe = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ue(l, f) {
      return l + f.charAt(0).toUpperCase() + f.substring(1);
    }
    var Te = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Fe).forEach(function(l) {
      Te.forEach(function(f) {
        Fe[Ue(f, l)] = Fe[l];
      });
    });
    var ve = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Ae(l, f) {
      ve[f.type] || f.onChange || f.onInput || f.readOnly || f.disabled || f.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), f.onChange || f.readOnly || f.disabled || f.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function fe(l, f) {
      if (l.indexOf("-") === -1)
        return typeof f.is == "string";
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ze = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Oe = {}, Ve = new RegExp("^(aria)-[" + z + "]*$"), Ze = new RegExp("^(aria)[A-Z][" + z + "]*$");
    function Ie(l, f) {
      {
        if (R.call(Oe, f) && Oe[f])
          return !0;
        if (Ze.test(f)) {
          var w = "aria-" + f.slice(4).toLowerCase(), D = ze.hasOwnProperty(w) ? w : null;
          if (D == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", f), Oe[f] = !0, !0;
          if (f !== D)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", f, D), Oe[f] = !0, !0;
        }
        if (Ve.test(f)) {
          var H = f.toLowerCase(), le = ze.hasOwnProperty(H) ? H : null;
          if (le == null)
            return Oe[f] = !0, !1;
          if (f !== le)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", f, le), Oe[f] = !0, !0;
        }
      }
      return !0;
    }
    function qe(l, f) {
      {
        var w = [];
        for (var D in f) {
          var H = Ie(l, D);
          H || w.push(D);
        }
        var le = w.map(function(he) {
          return "`" + he + "`";
        }).join(", ");
        w.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", le, l) : w.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", le, l);
      }
    }
    function et(l, f) {
      fe(l, f) || qe(l, f);
    }
    var He = !1;
    function Ge(l, f) {
      {
        if (l !== "input" && l !== "textarea" && l !== "select")
          return;
        f != null && f.value === null && !He && (He = !0, l === "select" && f.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", l) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", l));
      }
    }
    var Le = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, _e = function() {
    };
    {
      var st = {}, Ee = /^on./, rt = /^on[^A-Z]/, pt = new RegExp("^(aria)-[" + z + "]*$"), ft = new RegExp("^(aria)[A-Z][" + z + "]*$");
      _e = function(l, f, w, D) {
        if (R.call(st, f) && st[f])
          return !0;
        var H = f.toLowerCase();
        if (H === "onfocusin" || H === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), st[f] = !0, !0;
        if (D != null) {
          var le = D.registrationNameDependencies, he = D.possibleRegistrationNames;
          if (le.hasOwnProperty(f))
            return !0;
          var Pe = he.hasOwnProperty(H) ? he[H] : null;
          if (Pe != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", f, Pe), st[f] = !0, !0;
          if (Ee.test(f))
            return i("Unknown event handler property `%s`. It will be ignored.", f), st[f] = !0, !0;
        } else if (Ee.test(f))
          return rt.test(f) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", f), st[f] = !0, !0;
        if (pt.test(f) || ft.test(f))
          return !0;
        if (H === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), st[f] = !0, !0;
        if (H === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), st[f] = !0, !0;
        if (H === "is" && w !== null && w !== void 0 && typeof w != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof w), st[f] = !0, !0;
        if (typeof w == "number" && isNaN(w))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", f), st[f] = !0, !0;
        var Be = Y(f), ot = Be !== null && Be.type === _;
        if (Le.hasOwnProperty(H)) {
          var dt = Le[H];
          if (dt !== f)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", f, dt), st[f] = !0, !0;
        } else if (!ot && f !== H)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", f, H), st[f] = !0, !0;
        return typeof w == "boolean" && K(f, w, Be, !1) ? (w ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', w, f, f, w, f) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', w, f, f, w, f, f, f), st[f] = !0, !0) : ot ? !0 : K(f, w, Be, !1) ? (st[f] = !0, !1) : ((w === "false" || w === "true") && Be !== null && Be.type === te && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", w, f, w === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', f, w), st[f] = !0), !0);
      };
    }
    var wt = function(l, f, w) {
      {
        var D = [];
        for (var H in f) {
          var le = _e(l, H, f[H], w);
          le || D.push(H);
        }
        var he = D.map(function(Pe) {
          return "`" + Pe + "`";
        }).join(", ");
        D.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, l) : D.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, l);
      }
    };
    function zt(l, f, w) {
      fe(l, f) || wt(l, f, w);
    }
    var Jt = function() {
    };
    {
      var jt = /^(?:webkit|moz|o)[A-Z]/, on = /^-ms-/, _t = /-(.)/g, tn = /;\s*$/, $t = {}, Ut = {}, bt = !1, mt = !1, ln = function(l) {
        return l.replace(_t, function(f, w) {
          return w.toUpperCase();
        });
      }, Yt = function(l) {
        $t.hasOwnProperty(l) && $t[l] || ($t[l] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          l,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          ln(l.replace(on, "ms-"))
        ));
      }, xt = function(l) {
        $t.hasOwnProperty(l) && $t[l] || ($t[l] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", l, l.charAt(0).toUpperCase() + l.slice(1)));
      }, Gt = function(l, f) {
        Ut.hasOwnProperty(f) && Ut[f] || (Ut[f] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, l, f.replace(tn, "")));
      }, Sn = function(l, f) {
        bt || (bt = !0, i("`NaN` is an invalid value for the `%s` css style property.", l));
      }, At = function(l, f) {
        mt || (mt = !0, i("`Infinity` is an invalid value for the `%s` css style property.", l));
      };
      Jt = function(l, f) {
        l.indexOf("-") > -1 ? Yt(l) : jt.test(l) ? xt(l) : tn.test(f) && Gt(l, f), typeof f == "number" && (isNaN(f) ? Sn(l, f) : isFinite(f) || At(l, f));
      };
    }
    var nn = Jt, Xt = /["'&<>]/;
    function sn(l) {
      C(l);
      var f = "" + l, w = Xt.exec(f);
      if (!w)
        return f;
      var D, H = "", le, he = 0;
      for (le = w.index; le < f.length; le++) {
        switch (f.charCodeAt(le)) {
          case 34:
            D = "&quot;";
            break;
          case 38:
            D = "&amp;";
            break;
          case 39:
            D = "&#x27;";
            break;
          case 60:
            D = "&lt;";
            break;
          case 62:
            D = "&gt;";
            break;
          default:
            continue;
        }
        he !== le && (H += f.substring(he, le)), he = le + 1, H += D;
      }
      return he !== le ? H + f.substring(he, le) : H;
    }
    function Nt(l) {
      return typeof l == "boolean" || typeof l == "number" ? "" + l : sn(l);
    }
    var xn = /([A-Z])/g, dn = /^ms-/;
    function Lt(l) {
      return l.replace(xn, "-$1").toLowerCase().replace(dn, "-ms-");
    }
    var nt = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, bn = !1;
    function Hn(l) {
      !bn && nt.test(l) && (bn = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(l)));
    }
    var Gn = Array.isArray;
    function An(l) {
      return Gn(l);
    }
    var Un = "<script>", _n = "<\/script>", Pn = '<script src="', pn = '<script type="module" src="', Se = '" async=""><\/script>';
    function Ne(l) {
      return C(l), ("" + l).replace(pe, Ke);
    }
    var pe = /(<\/|<)(s)(cript)/gi, Ke = function(l, f, w, D) {
      return "" + f + (w === "s" ? "\\u0073" : "\\u0053") + D;
    };
    function ht(l, f, w, D, H) {
      var le = l === void 0 ? "" : l, he = f === void 0 ? Un : '<script nonce="' + Nt(f) + '">', Pe = [];
      if (w !== void 0 && Pe.push(he, Ne(w), _n), D !== void 0)
        for (var Be = 0; Be < D.length; Be++)
          Pe.push(Pn, Nt(D[Be]), Se);
      if (H !== void 0)
        for (var ot = 0; ot < H.length; ot++)
          Pe.push(pn, Nt(H[ot]), Se);
      return {
        bootstrapChunks: Pe,
        startInlineScript: he,
        placeholderPrefix: le + "P:",
        segmentPrefix: le + "S:",
        boundaryPrefix: le + "B:",
        idPrefix: le,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var it = 0, ct = 1, Kt = 2, Ot = 3, tt = 4, ut = 5, It = 6, Rt = 7;
    function Ht(l, f) {
      return {
        insertionMode: l,
        selectedValue: f
      };
    }
    function Ft(l, f, w) {
      switch (f) {
        case "select":
          return Ht(ct, w.value != null ? w.value : w.defaultValue);
        case "svg":
          return Ht(Kt, null);
        case "math":
          return Ht(Ot, null);
        case "foreignObject":
          return Ht(ct, null);
        case "table":
          return Ht(tt, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return Ht(ut, null);
        case "colgroup":
          return Ht(Rt, null);
        case "tr":
          return Ht(It, null);
      }
      return l.insertionMode >= tt || l.insertionMode === it ? Ht(ct, null) : l;
    }
    var hn = null;
    function mn(l) {
      var f = l.nextSuspenseID++;
      return l.boundaryPrefix + f.toString(16);
    }
    function Mt(l, f, w) {
      var D = l.idPrefix, H = ":" + D + "R" + f;
      return w > 0 && (H += "H" + w.toString(32)), H + ":";
    }
    function kn(l) {
      return Nt(l);
    }
    var wn = "<!-- -->";
    function On(l, f, w, D) {
      return f === "" ? D : (D && l.push(wn), l.push(kn(f)), !0);
    }
    function Nn(l, f, w, D) {
      w && D && l.push(wn);
    }
    var Ln = /* @__PURE__ */ new Map();
    function fn(l) {
      var f = Ln.get(l);
      if (f !== void 0)
        return f;
      var w = Nt(Lt(l));
      return Ln.set(l, w), w;
    }
    var Fn = ' style="', Zt = ":", we = ";";
    function g(l, f, w) {
      if (typeof w != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var D = !0;
      for (var H in w)
        if (R.call(w, H)) {
          var le = w[H];
          if (!(le == null || typeof le == "boolean" || le === "")) {
            var he = void 0, Pe = void 0, Be = H.indexOf("--") === 0;
            Be ? (he = Nt(H), N(le, H), Pe = Nt(("" + le).trim())) : (nn(H, le), he = fn(H), typeof le == "number" ? le !== 0 && !R.call(Fe, H) ? Pe = le + "px" : Pe = "" + le : (N(le, H), Pe = Nt(("" + le).trim()))), D ? (D = !1, l.push(Fn, he, Zt, Pe)) : l.push(we, he, Zt, Pe);
          }
        }
      D || l.push(Z);
    }
    var P = " ", M = '="', Z = '"', xe = '=""';
    function B(l, f, w, D) {
      switch (w) {
        case "style": {
          g(l, f, D);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(w.length > 2 && (w[0] === "o" || w[0] === "O") && (w[1] === "n" || w[1] === "N"))
      ) {
        var H = Y(w);
        if (H !== null) {
          switch (typeof D) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!H.acceptsBooleans)
                return;
          }
          var le = H.attributeName, he = le;
          switch (H.type) {
            case te:
              D && l.push(P, he, xe);
              return;
            case Q:
              D === !0 ? l.push(P, he, xe) : D === !1 || l.push(P, he, M, Nt(D), Z);
              return;
            case $:
              isNaN(D) || l.push(P, he, M, Nt(D), Z);
              break;
            case J:
              !isNaN(D) && D >= 1 && l.push(P, he, M, Nt(D), Z);
              break;
            default:
              H.sanitizeURL && (v(D, le), D = "" + D, Hn(D)), l.push(P, he, M, Nt(D), Z);
          }
        } else if (oe(w)) {
          switch (typeof D) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Pe = w.toLowerCase().slice(0, 5);
              if (Pe !== "data-" && Pe !== "aria-")
                return;
            }
          }
          l.push(P, w, M, Nt(D), Z);
        }
      }
    }
    var I = ">", ee = "/>";
    function be(l, f, w) {
      if (f != null) {
        if (w != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof f != "object" || !("__html" in f))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var D = f.__html;
        D != null && (C(D), l.push("" + D));
      }
    }
    var We = !1, Qe = !1, St = !1, Dt = !1, Bt = !1, Cn = !1, Kn = !1;
    function Mn(l, f) {
      {
        var w = l[f];
        if (w != null) {
          var D = An(w);
          l.multiple && !D ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", f) : !l.multiple && D && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", f);
        }
      }
    }
    function fr(l, f, w) {
      Ae("select", f), Mn(f, "value"), Mn(f, "defaultValue"), f.value !== void 0 && f.defaultValue !== void 0 && !St && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), St = !0), l.push(qn("select"));
      var D = null, H = null;
      for (var le in f)
        if (R.call(f, le)) {
          var he = f[le];
          if (he == null)
            continue;
          switch (le) {
            case "children":
              D = he;
              break;
            case "dangerouslySetInnerHTML":
              H = he;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              B(l, w, le, he);
              break;
          }
        }
      return l.push(I), be(l, H, D), D;
    }
    function Xn(l) {
      var f = "";
      return e.Children.forEach(l, function(w) {
        w != null && (f += w, !Bt && typeof w != "string" && typeof w != "number" && (Bt = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), f;
    }
    var Ct = ' selected=""';
    function rn(l, f, w, D) {
      var H = D.selectedValue;
      l.push(qn("option"));
      var le = null, he = null, Pe = null, Be = null;
      for (var ot in f)
        if (R.call(f, ot)) {
          var dt = f[ot];
          if (dt == null)
            continue;
          switch (ot) {
            case "children":
              le = dt;
              break;
            case "selected":
              Pe = dt, Kn || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Kn = !0);
              break;
            case "dangerouslySetInnerHTML":
              Be = dt;
              break;
            case "value":
              he = dt;
            default:
              B(l, w, ot, dt);
              break;
          }
        }
      if (H != null) {
        var kt;
        if (he !== null ? (v(he, "value"), kt = "" + he) : (Be !== null && (Cn || (Cn = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), kt = Xn(le)), An(H))
          for (var yn = 0; yn < H.length; yn++) {
            v(H[yn], "value");
            var Wn = "" + H[yn];
            if (Wn === kt) {
              l.push(Ct);
              break;
            }
          }
        else
          v(H, "select.value"), "" + H === kt && l.push(Ct);
      } else
        Pe && l.push(Ct);
      return l.push(I), be(l, Be, le), le;
    }
    function xr(l, f, w) {
      Ae("input", f), f.checked !== void 0 && f.defaultChecked !== void 0 && !Qe && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), Qe = !0), f.value !== void 0 && f.defaultValue !== void 0 && !We && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), We = !0), l.push(qn("input"));
      var D = null, H = null, le = null, he = null;
      for (var Pe in f)
        if (R.call(f, Pe)) {
          var Be = f[Pe];
          if (Be == null)
            continue;
          switch (Pe) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              he = Be;
              break;
            case "defaultValue":
              H = Be;
              break;
            case "checked":
              le = Be;
              break;
            case "value":
              D = Be;
              break;
            default:
              B(l, w, Pe, Be);
              break;
          }
        }
      return le !== null ? B(l, w, "checked", le) : he !== null && B(l, w, "checked", he), D !== null ? B(l, w, "value", D) : H !== null && B(l, w, "value", H), l.push(ee), null;
    }
    function Jr(l, f, w) {
      Ae("textarea", f), f.value !== void 0 && f.defaultValue !== void 0 && !Dt && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Dt = !0), l.push(qn("textarea"));
      var D = null, H = null, le = null;
      for (var he in f)
        if (R.call(f, he)) {
          var Pe = f[he];
          if (Pe == null)
            continue;
          switch (he) {
            case "children":
              le = Pe;
              break;
            case "value":
              D = Pe;
              break;
            case "defaultValue":
              H = Pe;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              B(l, w, he, Pe);
              break;
          }
        }
      if (D === null && H !== null && (D = H), l.push(I), le != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), D != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (An(le)) {
          if (le.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          C(le[0]), D = "" + le[0];
        }
        C(le), D = "" + le;
      }
      return typeof D == "string" && D[0] === `
` && l.push(ta), D !== null && (v(D, "value"), l.push(kn("" + D))), null;
    }
    function Ga(l, f, w, D) {
      l.push(qn(w));
      for (var H in f)
        if (R.call(f, H)) {
          var le = f[H];
          if (le == null)
            continue;
          switch (H) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(w + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              B(l, D, H, le);
              break;
          }
        }
      return l.push(ee), null;
    }
    function ea(l, f, w) {
      l.push(qn("menuitem"));
      for (var D in f)
        if (R.call(f, D)) {
          var H = f[D];
          if (H == null)
            continue;
          switch (D) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              B(l, w, D, H);
              break;
          }
        }
      return l.push(I), null;
    }
    function Xa(l, f, w) {
      l.push(qn("title"));
      var D = null;
      for (var H in f)
        if (R.call(f, H)) {
          var le = f[H];
          if (le == null)
            continue;
          switch (H) {
            case "children":
              D = le;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              B(l, w, H, le);
              break;
          }
        }
      l.push(I);
      {
        var he = Array.isArray(D) && D.length < 2 ? D[0] || null : D;
        Array.isArray(D) && D.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && he.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && typeof he != "string" && typeof he != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return D;
    }
    function Pr(l, f, w, D) {
      l.push(qn(w));
      var H = null, le = null;
      for (var he in f)
        if (R.call(f, he)) {
          var Pe = f[he];
          if (Pe == null)
            continue;
          switch (he) {
            case "children":
              H = Pe;
              break;
            case "dangerouslySetInnerHTML":
              le = Pe;
              break;
            default:
              B(l, D, he, Pe);
              break;
          }
        }
      return l.push(I), be(l, le, H), typeof H == "string" ? (l.push(kn(H)), null) : H;
    }
    function ar(l, f, w, D) {
      l.push(qn(w));
      var H = null, le = null;
      for (var he in f)
        if (R.call(f, he)) {
          var Pe = f[he];
          if (Pe == null)
            continue;
          switch (he) {
            case "children":
              H = Pe;
              break;
            case "dangerouslySetInnerHTML":
              le = Pe;
              break;
            case "style":
              g(l, D, Pe);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              oe(he) && typeof Pe != "function" && typeof Pe != "symbol" && l.push(P, he, M, Nt(Pe), Z);
              break;
          }
        }
      return l.push(I), be(l, le, H), H;
    }
    var ta = `
`;
    function va(l, f, w, D) {
      l.push(qn(w));
      var H = null, le = null;
      for (var he in f)
        if (R.call(f, he)) {
          var Pe = f[he];
          if (Pe == null)
            continue;
          switch (he) {
            case "children":
              H = Pe;
              break;
            case "dangerouslySetInnerHTML":
              le = Pe;
              break;
            default:
              B(l, D, he, Pe);
              break;
          }
        }
      if (l.push(I), le != null) {
        if (H != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof le != "object" || !("__html" in le))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var Be = le.__html;
        Be != null && (typeof Be == "string" && Be.length > 0 && Be[0] === `
` ? l.push(ta, Be) : (C(Be), l.push("" + Be)));
      }
      return typeof H == "string" && H[0] === `
` && l.push(ta), H;
    }
    var an = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, br = /* @__PURE__ */ new Map();
    function qn(l) {
      var f = br.get(l);
      if (f === void 0) {
        if (!an.test(l))
          throw new Error("Invalid tag: " + l);
        f = "<" + l, br.set(l, f);
      }
      return f;
    }
    var Nr = "<!DOCTYPE html>";
    function Er(l, f, w, D, H) {
      switch (et(f, w), Ge(f, w), zt(f, w, null), !w.suppressContentEditableWarning && w.contentEditable && w.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), H.insertionMode !== Kt && H.insertionMode !== Ot && f.indexOf("-") === -1 && typeof w.is != "string" && f.toLowerCase() !== f && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", f), f) {
        case "select":
          return fr(l, w, D);
        case "option":
          return rn(l, w, D, H);
        case "textarea":
          return Jr(l, w, D);
        case "input":
          return xr(l, w, D);
        case "menuitem":
          return ea(l, w, D);
        case "title":
          return Xa(l, w, D);
        case "listing":
        case "pre":
          return va(l, w, f, D);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Ga(l, w, f, D);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Pr(l, w, f, D);
        case "html":
          return H.insertionMode === it && l.push(Nr), Pr(l, w, f, D);
        default:
          return f.indexOf("-") === -1 && typeof w.is != "string" ? Pr(l, w, f, D) : ar(l, w, f, D);
      }
    }
    var xa = "</", Sr = ">";
    function ir(l, f, w) {
      switch (f) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          l.push(xa, f, Sr);
      }
    }
    function qa(l, f) {
      for (var w = f.bootstrapChunks, D = 0; D < w.length - 1; D++)
        s(l, w[D]);
      return D < w.length ? p(l, w[D]) : !0;
    }
    var Za = '<template id="', Zi = '"></template>';
    function Qi(l, f, w) {
      s(l, Za), s(l, f.placeholderPrefix);
      var D = w.toString(16);
      return s(l, D), p(l, Zi);
    }
    var Ji = "<!--$-->", hl = '<!--$?--><template id="', ml = '"></template>', ba = "<!--$!-->", Ea = "<!--/$-->", Sa = "<template", na = '"', yl = ' data-dgst="', ra = ' data-msg="', Qa = ' data-stck="', Ja = "></template>";
    function Ir(l, f) {
      return p(l, Ji);
    }
    function Hr(l, f, w) {
      if (s(l, hl), w === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, w), p(l, ml);
    }
    function ka(l, f, w, D, H) {
      var le;
      return le = p(l, ba), s(l, Sa), w && (s(l, yl), s(l, Nt(w)), s(l, na)), D && (s(l, ra), s(l, Nt(D)), s(l, na)), H && (s(l, Qa), s(l, Nt(H)), s(l, na)), le = p(l, Ja), le;
    }
    function eo(l, f) {
      return p(l, Ea);
    }
    function ei(l, f) {
      return p(l, Ea);
    }
    function to(l, f) {
      return p(l, Ea);
    }
    var wa = '<div hidden id="', Zn = '">', no = "</div>", Ca = '<svg aria-hidden="true" style="display:none" id="', gl = '">', ro = "</svg>", Ta = '<math aria-hidden="true" style="display:none" id="', ao = '">', io = "</math>", Aa = '<table hidden id="', La = '">', oo = "</table>", lo = '<table hidden><tbody id="', so = '">', ti = "</tbody></table>", uo = '<table hidden><tr id="', k = '">', O = "</tr></table>", V = '<table hidden><colgroup id="', re = '">', Ce = "</colgroup></table>";
    function ke(l, f, w, D) {
      switch (w.insertionMode) {
        case it:
        case ct:
          return s(l, wa), s(l, f.segmentPrefix), s(l, D.toString(16)), p(l, Zn);
        case Kt:
          return s(l, Ca), s(l, f.segmentPrefix), s(l, D.toString(16)), p(l, gl);
        case Ot:
          return s(l, Ta), s(l, f.segmentPrefix), s(l, D.toString(16)), p(l, ao);
        case tt:
          return s(l, Aa), s(l, f.segmentPrefix), s(l, D.toString(16)), p(l, La);
        case ut:
          return s(l, lo), s(l, f.segmentPrefix), s(l, D.toString(16)), p(l, so);
        case It:
          return s(l, uo), s(l, f.segmentPrefix), s(l, D.toString(16)), p(l, k);
        case Rt:
          return s(l, V), s(l, f.segmentPrefix), s(l, D.toString(16)), p(l, re);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Me(l, f) {
      switch (f.insertionMode) {
        case it:
        case ct:
          return p(l, no);
        case Kt:
          return p(l, ro);
        case Ot:
          return p(l, io);
        case tt:
          return p(l, oo);
        case ut:
          return p(l, ti);
        case It:
          return p(l, O);
        case Rt:
          return p(l, Ce);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Ye = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", Et = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Pt = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Tt = Ye + ';$RS("', un = '$RS("', Qn = '","', or = '")<\/script>';
    function lr(l, f, w) {
      s(l, f.startInlineScript), f.sentCompleteSegmentFunction ? s(l, un) : (f.sentCompleteSegmentFunction = !0, s(l, Tt)), s(l, f.segmentPrefix);
      var D = w.toString(16);
      return s(l, D), s(l, Qn), s(l, f.placeholderPrefix), s(l, D), p(l, or);
    }
    var Pa = Et + ';$RC("', co = '$RC("', ni = '","', Wc = '")<\/script>';
    function jc(l, f, w, D) {
      if (s(l, f.startInlineScript), f.sentCompleteBoundaryFunction ? s(l, co) : (f.sentCompleteBoundaryFunction = !0, s(l, Pa)), w === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var H = D.toString(16);
      return s(l, w), s(l, ni), s(l, f.segmentPrefix), s(l, H), p(l, Wc);
    }
    var Uc = Pt + ';$RX("', Kc = '$RX("', Yc = '"', Gc = ")<\/script>", vl = ",";
    function Xc(l, f, w, D, H, le) {
      if (s(l, f.startInlineScript), f.sentClientRenderFunction ? s(l, Kc) : (f.sentClientRenderFunction = !0, s(l, Uc)), w === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, w), s(l, Yc), (D || H || le) && (s(l, vl), s(l, xl(D || ""))), (H || le) && (s(l, vl), s(l, xl(H || ""))), le && (s(l, vl), s(l, xl(le))), p(l, Gc);
    }
    var qc = /[<\u2028\u2029]/g;
    function xl(l) {
      var f = JSON.stringify(l);
      return f.replace(qc, function(w) {
        switch (w) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Zc(l, f) {
      var w = ht(f, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: w.bootstrapChunks,
        startInlineScript: w.startInlineScript,
        placeholderPrefix: w.placeholderPrefix,
        segmentPrefix: w.segmentPrefix,
        boundaryPrefix: w.boundaryPrefix,
        idPrefix: w.idPrefix,
        nextSuspenseID: w.nextSuspenseID,
        sentCompleteSegmentFunction: w.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: w.sentCompleteBoundaryFunction,
        sentClientRenderFunction: w.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: l
      };
    }
    function bl() {
      return {
        insertionMode: ct,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function Bs(l, f, w, D) {
      return w.generateStaticMarkup ? (l.push(Nt(f)), !1) : On(l, f, w, D);
    }
    function $s(l, f, w, D) {
      if (!f.generateStaticMarkup)
        return Nn(l, f, w, D);
    }
    function El(l, f) {
      return f.generateStaticMarkup ? !0 : Ir(l);
    }
    function pr(l, f, w, D, H) {
      return f.generateStaticMarkup ? !0 : ka(l, f, w, D, H);
    }
    function Qc(l, f) {
      return f.generateStaticMarkup ? !0 : eo(l);
    }
    function Is(l, f) {
      return f.generateStaticMarkup ? !0 : to(l);
    }
    var sr = Object.assign, Hs = Symbol.for("react.element"), Sl = Symbol.for("react.portal"), fo = Symbol.for("react.fragment"), po = Symbol.for("react.strict_mode"), ho = Symbol.for("react.profiler"), ri = Symbol.for("react.provider"), ai = Symbol.for("react.context"), ii = Symbol.for("react.forward_ref"), Na = Symbol.for("react.suspense"), kl = Symbol.for("react.suspense_list"), wl = Symbol.for("react.memo"), mo = Symbol.for("react.lazy"), Jc = Symbol.for("react.scope"), Vs = Symbol.for("react.debug_trace_mode"), ed = Symbol.for("react.legacy_hidden"), td = Symbol.for("react.default_value"), Ws = Symbol.iterator, js = "@@iterator";
    function En(l) {
      if (l === null || typeof l != "object")
        return null;
      var f = Ws && l[Ws] || l[js];
      return typeof f == "function" ? f : null;
    }
    function oi(l, f, w) {
      var D = l.displayName;
      if (D)
        return D;
      var H = f.displayName || f.name || "";
      return H !== "" ? w + "(" + H + ")" : w;
    }
    function Cl(l) {
      return l.displayName || "Context";
    }
    function vn(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case fo:
          return "Fragment";
        case Sl:
          return "Portal";
        case ho:
          return "Profiler";
        case po:
          return "StrictMode";
        case Na:
          return "Suspense";
        case kl:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ai:
            var f = l;
            return Cl(f) + ".Consumer";
          case ri:
            var w = l;
            return Cl(w._context) + ".Provider";
          case ii:
            return oi(l, l.render, "ForwardRef");
          case wl:
            var D = l.displayName || null;
            return D !== null ? D : vn(l.type) || "Memo";
          case mo: {
            var H = l, le = H._payload, he = H._init;
            try {
              return vn(he(le));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ra = 0, Tl, Al, Ll, Pl, Nl, Us, Ks;
    function yo() {
    }
    yo.__reactDisabledLog = !0;
    function Rl() {
      {
        if (Ra === 0) {
          Tl = console.log, Al = console.info, Ll = console.warn, Pl = console.error, Nl = console.group, Us = console.groupCollapsed, Ks = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: yo,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        Ra++;
      }
    }
    function li() {
      {
        if (Ra--, Ra === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: sr({}, l, {
              value: Tl
            }),
            info: sr({}, l, {
              value: Al
            }),
            warn: sr({}, l, {
              value: Ll
            }),
            error: sr({}, l, {
              value: Pl
            }),
            group: sr({}, l, {
              value: Nl
            }),
            groupCollapsed: sr({}, l, {
              value: Us
            }),
            groupEnd: sr({}, l, {
              value: Ks
            })
          });
        }
        Ra < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var si = r.ReactCurrentDispatcher, Da;
    function ui(l, f, w) {
      {
        if (Da === void 0)
          try {
            throw Error();
          } catch (H) {
            var D = H.stack.trim().match(/\n( *(at )?)/);
            Da = D && D[1] || "";
          }
        return `
` + Da + l;
      }
    }
    var ci = !1, go;
    {
      var Ys = typeof WeakMap == "function" ? WeakMap : Map;
      go = new Ys();
    }
    function Dl(l, f) {
      if (!l || ci)
        return "";
      {
        var w = go.get(l);
        if (w !== void 0)
          return w;
      }
      var D;
      ci = !0;
      var H = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var le;
      le = si.current, si.current = null, Rl();
      try {
        if (f) {
          var he = function() {
            throw Error();
          };
          if (Object.defineProperty(he.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(he, []);
            } catch (gr) {
              D = gr;
            }
            Reflect.construct(l, [], he);
          } else {
            try {
              he.call();
            } catch (gr) {
              D = gr;
            }
            l.call(he.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (gr) {
            D = gr;
          }
          l();
        }
      } catch (gr) {
        if (gr && D && typeof gr.stack == "string") {
          for (var Pe = gr.stack.split(`
`), Be = D.stack.split(`
`), ot = Pe.length - 1, dt = Be.length - 1; ot >= 1 && dt >= 0 && Pe[ot] !== Be[dt]; )
            dt--;
          for (; ot >= 1 && dt >= 0; ot--, dt--)
            if (Pe[ot] !== Be[dt]) {
              if (ot !== 1 || dt !== 1)
                do
                  if (ot--, dt--, dt < 0 || Pe[ot] !== Be[dt]) {
                    var kt = `
` + Pe[ot].replace(" at new ", " at ");
                    return l.displayName && kt.includes("<anonymous>") && (kt = kt.replace("<anonymous>", l.displayName)), typeof l == "function" && go.set(l, kt), kt;
                  }
                while (ot >= 1 && dt >= 0);
              break;
            }
        }
      } finally {
        ci = !1, si.current = le, li(), Error.prepareStackTrace = H;
      }
      var yn = l ? l.displayName || l.name : "", Wn = yn ? ui(yn) : "";
      return typeof l == "function" && go.set(l, Wn), Wn;
    }
    function _l(l, f, w) {
      return Dl(l, !0);
    }
    function Ol(l, f, w) {
      return Dl(l, !1);
    }
    function Gs(l) {
      var f = l.prototype;
      return !!(f && f.isReactComponent);
    }
    function _a(l, f, w) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return Dl(l, Gs(l));
      if (typeof l == "string")
        return ui(l);
      switch (l) {
        case Na:
          return ui("Suspense");
        case kl:
          return ui("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ii:
            return Ol(l.render);
          case wl:
            return _a(l.type, f, w);
          case mo: {
            var D = l, H = D._payload, le = D._init;
            try {
              return _a(le(H), f, w);
            } catch {
            }
          }
        }
      return "";
    }
    var Fl = {}, vo = r.ReactDebugCurrentFrame;
    function aa(l) {
      if (l) {
        var f = l._owner, w = _a(l.type, l._source, f ? f.type : null);
        vo.setExtraStackFrame(w);
      } else
        vo.setExtraStackFrame(null);
    }
    function Ml(l, f, w, D, H) {
      {
        var le = Function.call.bind(R);
        for (var he in l)
          if (le(l, he)) {
            var Pe = void 0;
            try {
              if (typeof l[he] != "function") {
                var Be = Error((D || "React class") + ": " + w + " type `" + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[he] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Be.name = "Invariant Violation", Be;
              }
              Pe = l[he](f, he, D, w, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ot) {
              Pe = ot;
            }
            Pe && !(Pe instanceof Error) && (aa(H), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", D || "React class", w, he, typeof Pe), aa(null)), Pe instanceof Error && !(Pe.message in Fl) && (Fl[Pe.message] = !0, aa(H), i("Failed %s type: %s", w, Pe.message), aa(null));
          }
      }
    }
    var zl;
    zl = {};
    var Vr = {};
    Object.freeze(Vr);
    function Xs(l, f) {
      {
        var w = l.contextTypes;
        if (!w)
          return Vr;
        var D = {};
        for (var H in w)
          D[H] = f[H];
        {
          var le = vn(l) || "Unknown";
          Ml(w, D, "context", le);
        }
        return D;
      }
    }
    function ia(l, f, w, D) {
      {
        if (typeof l.getChildContext != "function") {
          {
            var H = vn(f) || "Unknown";
            zl[H] || (zl[H] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", H, H));
          }
          return w;
        }
        var le = l.getChildContext();
        for (var he in le)
          if (!(he in D))
            throw new Error((vn(f) || "Unknown") + '.getChildContext(): key "' + he + '" is not defined in childContextTypes.');
        {
          var Pe = vn(f) || "Unknown";
          Ml(D, le, "child context", Pe);
        }
        return sr({}, w, le);
      }
    }
    var oa;
    oa = {};
    var Bl = null, kr = null;
    function xo(l) {
      l.context._currentValue2 = l.parentValue;
    }
    function bo(l) {
      l.context._currentValue2 = l.value;
    }
    function di(l, f) {
      if (l !== f) {
        xo(l);
        var w = l.parent, D = f.parent;
        if (w === null) {
          if (D !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (D === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          di(w, D);
        }
        bo(f);
      }
    }
    function $l(l) {
      xo(l);
      var f = l.parent;
      f !== null && $l(f);
    }
    function fi(l) {
      var f = l.parent;
      f !== null && fi(f), bo(l);
    }
    function qs(l, f) {
      xo(l);
      var w = l.parent;
      if (w === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      w.depth === f.depth ? di(w, f) : qs(w, f);
    }
    function Zs(l, f) {
      var w = f.parent;
      if (w === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      l.depth === w.depth ? di(l, w) : Zs(l, w), bo(f);
    }
    function Eo(l) {
      var f = kr, w = l;
      f !== w && (f === null ? fi(w) : w === null ? $l(f) : f.depth === w.depth ? di(f, w) : f.depth > w.depth ? qs(f, w) : Zs(f, w), kr = w);
    }
    function pi(l, f) {
      var w;
      w = l._currentValue2, l._currentValue2 = f, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== oa && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = oa;
      var D = kr, H = {
        parent: D,
        depth: D === null ? 0 : D.depth + 1,
        context: l,
        parentValue: w,
        value: f
      };
      return kr = H, H;
    }
    function Il(l) {
      var f = kr;
      if (f === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      f.context !== l && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var w = f.parentValue;
        w === td ? f.context._currentValue2 = f.context._defaultValue : f.context._currentValue2 = w, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== oa && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = oa;
      }
      return kr = f.parent;
    }
    function nd() {
      return kr;
    }
    function Oa(l) {
      var f = l._currentValue2;
      return f;
    }
    function So(l) {
      return l._reactInternals;
    }
    function Hl(l, f) {
      l._reactInternals = f;
    }
    var ko = {}, wo = {}, hi, Co, Fa, mi, To, Ma, Ao, Lo, Po;
    {
      hi = /* @__PURE__ */ new Set(), Co = /* @__PURE__ */ new Set(), Fa = /* @__PURE__ */ new Set(), Ao = /* @__PURE__ */ new Set(), mi = /* @__PURE__ */ new Set(), Lo = /* @__PURE__ */ new Set(), Po = /* @__PURE__ */ new Set();
      var Qs = /* @__PURE__ */ new Set();
      Ma = function(l, f) {
        if (!(l === null || typeof l == "function")) {
          var w = f + "_" + l;
          Qs.has(w) || (Qs.add(w), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, l));
        }
      }, To = function(l, f) {
        if (f === void 0) {
          var w = vn(l) || "Component";
          mi.has(w) || (mi.add(w), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", w));
        }
      };
    }
    function Js(l, f) {
      {
        var w = l.constructor, D = w && vn(w) || "ReactClass", H = D + "." + f;
        if (ko[H])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, f, f, D), ko[H] = !0;
      }
    }
    var eu = {
      isMounted: function(l) {
        return !1;
      },
      enqueueSetState: function(l, f, w) {
        var D = So(l);
        D.queue === null ? Js(l, "setState") : (D.queue.push(f), w != null && Ma(w, "setState"));
      },
      enqueueReplaceState: function(l, f, w) {
        var D = So(l);
        D.replace = !0, D.queue = [f], w != null && Ma(w, "setState");
      },
      enqueueForceUpdate: function(l, f) {
        var w = So(l);
        w.queue === null ? Js(l, "forceUpdate") : f != null && Ma(f, "setState");
      }
    };
    function rd(l, f, w, D, H) {
      var le = w(H, D);
      To(f, le);
      var he = le == null ? D : sr({}, D, le);
      return he;
    }
    function ad(l, f, w) {
      var D = Vr, H = l.contextType;
      if ("contextType" in l) {
        var le = (
          // Allow null for conditional declaration
          H === null || H !== void 0 && H.$$typeof === ai && H._context === void 0
        );
        if (!le && !Po.has(l)) {
          Po.add(l);
          var he = "";
          H === void 0 ? he = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof H != "object" ? he = " However, it is set to a " + typeof H + "." : H.$$typeof === ri ? he = " Did you accidentally pass the Context.Provider instead?" : H._context !== void 0 ? he = " Did you accidentally pass the Context.Consumer instead?" : he = " However, it is set to an object with keys {" + Object.keys(H).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", vn(l) || "Component", he);
        }
      }
      typeof H == "object" && H !== null ? D = Oa(H) : D = w;
      var Pe = new l(f, D);
      {
        if (typeof l.getDerivedStateFromProps == "function" && (Pe.state === null || Pe.state === void 0)) {
          var Be = vn(l) || "Component";
          hi.has(Be) || (hi.add(Be), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Be, Pe.state === null ? "null" : "undefined", Be));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof Pe.getSnapshotBeforeUpdate == "function") {
          var ot = null, dt = null, kt = null;
          if (typeof Pe.componentWillMount == "function" && Pe.componentWillMount.__suppressDeprecationWarning !== !0 ? ot = "componentWillMount" : typeof Pe.UNSAFE_componentWillMount == "function" && (ot = "UNSAFE_componentWillMount"), typeof Pe.componentWillReceiveProps == "function" && Pe.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? dt = "componentWillReceiveProps" : typeof Pe.UNSAFE_componentWillReceiveProps == "function" && (dt = "UNSAFE_componentWillReceiveProps"), typeof Pe.componentWillUpdate == "function" && Pe.componentWillUpdate.__suppressDeprecationWarning !== !0 ? kt = "componentWillUpdate" : typeof Pe.UNSAFE_componentWillUpdate == "function" && (kt = "UNSAFE_componentWillUpdate"), ot !== null || dt !== null || kt !== null) {
            var yn = vn(l) || "Component", Wn = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Fa.has(yn) || (Fa.add(yn), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, yn, Wn, ot !== null ? `
  ` + ot : "", dt !== null ? `
  ` + dt : "", kt !== null ? `
  ` + kt : ""));
          }
        }
      }
      return Pe;
    }
    function tu(l, f, w) {
      {
        var D = vn(f) || "Component", H = l.render;
        H || (f.prototype && typeof f.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", D) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", D)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", D), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", D), l.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", D), l.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", D), l.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", D), f.contextType && f.contextTypes && !Lo.has(f) && (Lo.add(f), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", D)), typeof l.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", D), f.prototype && f.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", vn(f) || "A pure component"), typeof l.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", D), typeof l.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", D), typeof l.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", D), typeof l.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", D);
        var le = l.props !== w;
        l.props !== void 0 && le && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", D, D), l.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", D, D), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !Co.has(f) && (Co.add(f), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", vn(f))), typeof l.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", D), typeof l.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", D), typeof f.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", D);
        var he = l.state;
        he && (typeof he != "object" || An(he)) && i("%s.state: must be set to an object or null", D), typeof l.getChildContext == "function" && typeof f.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", D);
      }
    }
    function id(l, f) {
      var w = f.state;
      if (typeof f.componentWillMount == "function") {
        if (f.componentWillMount.__suppressDeprecationWarning !== !0) {
          var D = vn(l) || "Unknown";
          wo[D] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            D
          ), wo[D] = !0);
        }
        f.componentWillMount();
      }
      typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), w !== f.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", vn(l) || "Component"), eu.enqueueReplaceState(f, f.state, null));
    }
    function od(l, f, w, D) {
      if (l.queue !== null && l.queue.length > 0) {
        var H = l.queue, le = l.replace;
        if (l.queue = null, l.replace = !1, le && H.length === 1)
          f.state = H[0];
        else {
          for (var he = le ? H[0] : f.state, Pe = !0, Be = le ? 1 : 0; Be < H.length; Be++) {
            var ot = H[Be], dt = typeof ot == "function" ? ot.call(f, he, w, D) : ot;
            dt != null && (Pe ? (Pe = !1, he = sr({}, he, dt)) : sr(he, dt));
          }
          f.state = he;
        }
      } else
        l.queue = null;
    }
    function No(l, f, w, D) {
      tu(l, f, w);
      var H = l.state !== void 0 ? l.state : null;
      l.updater = eu, l.props = w, l.state = H;
      var le = {
        queue: [],
        replace: !1
      };
      Hl(l, le);
      var he = f.contextType;
      if (typeof he == "object" && he !== null ? l.context = Oa(he) : l.context = D, l.state === w) {
        var Pe = vn(f) || "Component";
        Ao.has(Pe) || (Ao.add(Pe), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Pe));
      }
      var Be = f.getDerivedStateFromProps;
      typeof Be == "function" && (l.state = rd(l, f, Be, H, w)), typeof f.getDerivedStateFromProps != "function" && typeof l.getSnapshotBeforeUpdate != "function" && (typeof l.UNSAFE_componentWillMount == "function" || typeof l.componentWillMount == "function") && (id(f, l), od(le, l, w, D));
    }
    var Ro = {
      id: 1,
      overflow: ""
    };
    function ld(l) {
      var f = l.overflow, w = l.id, D = w & ~sd(w);
      return D.toString(32) + f;
    }
    function Vl(l, f, w) {
      var D = l.id, H = l.overflow, le = Do(D) - 1, he = D & ~(1 << le), Pe = w + 1, Be = Do(f) + le;
      if (Be > 30) {
        var ot = le - le % 5, dt = (1 << ot) - 1, kt = (he & dt).toString(32), yn = he >> ot, Wn = le - ot, gr = Do(f) + Wn, ku = Pe << Wn, wu = ku | yn, Cu = kt + H;
        return {
          id: 1 << gr | wu,
          overflow: Cu
        };
      } else {
        var Go = Pe << le, Sg = Go | he, kg = H;
        return {
          id: 1 << Be | Sg,
          overflow: kg
        };
      }
    }
    function Do(l) {
      return 32 - ud(l);
    }
    function sd(l) {
      return 1 << Do(l) - 1;
    }
    var ud = Math.clz32 ? Math.clz32 : Rr, cd = Math.log, dd = Math.LN2;
    function Rr(l) {
      var f = l >>> 0;
      return f === 0 ? 32 : 31 - (cd(f) / dd | 0) | 0;
    }
    function Wl(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var _o = typeof Object.is == "function" ? Object.is : Wl, Vt = null, la = null, sa = null, en = null, hr = !1, ua = !1, Oo = 0, Vn = null, Dr = 0, ca = 25, wr = !1, da;
    function _r() {
      if (Vt === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return wr && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Vt;
    }
    function fd(l, f) {
      if (f === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", da), !1;
      l.length !== f.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, da, "[" + l.join(", ") + "]", "[" + f.join(", ") + "]");
      for (var w = 0; w < f.length && w < l.length; w++)
        if (!_o(l[w], f[w]))
          return !1;
      return !0;
    }
    function nu() {
      if (Dr > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Fo() {
      return en === null ? sa === null ? (hr = !1, sa = en = nu()) : (hr = !0, en = sa) : en.next === null ? (hr = !1, en = en.next = nu()) : (hr = !0, en = en.next), en;
    }
    function jl(l, f) {
      Vt = f, la = l, wr = !1, Oo = 0;
    }
    function pd(l, f, w, D) {
      for (; ua; )
        ua = !1, Oo = 0, Dr += 1, en = null, w = l(f, D);
      return yi(), w;
    }
    function ru() {
      var l = Oo !== 0;
      return l;
    }
    function yi() {
      wr = !1, Vt = null, la = null, ua = !1, sa = null, Dr = 0, Vn = null, en = null;
    }
    function hd(l) {
      return wr && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Oa(l);
    }
    function au(l) {
      return da = "useContext", _r(), Oa(l);
    }
    function Mo(l, f) {
      return typeof f == "function" ? f(l) : f;
    }
    function md(l) {
      return da = "useState", iu(
        Mo,
        // useReducer has a special case to support lazy useState initializers
        l
      );
    }
    function iu(l, f, w) {
      if (l !== Mo && (da = "useReducer"), Vt = _r(), en = Fo(), hr) {
        var D = en.queue, H = D.dispatch;
        if (Vn !== null) {
          var le = Vn.get(D);
          if (le !== void 0) {
            Vn.delete(D);
            var he = en.memoizedState, Pe = le;
            do {
              var Be = Pe.action;
              wr = !0, he = l(he, Be), wr = !1, Pe = Pe.next;
            } while (Pe !== null);
            return en.memoizedState = he, [he, H];
          }
        }
        return [en.memoizedState, H];
      } else {
        wr = !0;
        var ot;
        l === Mo ? ot = typeof f == "function" ? f() : f : ot = w !== void 0 ? w(f) : f, wr = !1, en.memoizedState = ot;
        var dt = en.queue = {
          last: null,
          dispatch: null
        }, kt = dt.dispatch = vd.bind(null, Vt, dt);
        return [en.memoizedState, kt];
      }
    }
    function ou(l, f) {
      Vt = _r(), en = Fo();
      var w = f === void 0 ? null : f;
      if (en !== null) {
        var D = en.memoizedState;
        if (D !== null && w !== null) {
          var H = D[1];
          if (fd(w, H))
            return D[0];
        }
      }
      wr = !0;
      var le = l();
      return wr = !1, en.memoizedState = [le, w], le;
    }
    function yd(l) {
      Vt = _r(), en = Fo();
      var f = en.memoizedState;
      if (f === null) {
        var w = {
          current: l
        };
        return Object.seal(w), en.memoizedState = w, w;
      } else
        return f;
    }
    function gd(l, f) {
      da = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function vd(l, f, w) {
      if (Dr >= ca)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (l === Vt) {
        ua = !0;
        var D = {
          action: w,
          next: null
        };
        Vn === null && (Vn = /* @__PURE__ */ new Map());
        var H = Vn.get(f);
        if (H === void 0)
          Vn.set(f, D);
        else {
          for (var le = H; le.next !== null; )
            le = le.next;
          le.next = D;
        }
      }
    }
    function xd(l, f) {
      return ou(function() {
        return l;
      }, f);
    }
    function bd(l, f, w) {
      return _r(), f(l._source);
    }
    function Ed(l, f, w) {
      if (w === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return w();
    }
    function Sd(l) {
      return _r(), l;
    }
    function zo() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function lu() {
      return _r(), [!1, zo];
    }
    function Ul() {
      var l = la, f = ld(l.treeContext), w = vi;
      if (w === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var D = Oo++;
      return Mt(w, f, D);
    }
    function gi() {
    }
    var su = {
      readContext: hd,
      useContext: au,
      useMemo: ou,
      useReducer: iu,
      useRef: yd,
      useState: md,
      useInsertionEffect: gi,
      useLayoutEffect: gd,
      useCallback: xd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: gi,
      // Effects are not run in the server environment.
      useEffect: gi,
      // Debugging effect
      useDebugValue: gi,
      useDeferredValue: Sd,
      useTransition: lu,
      useId: Ul,
      // Subscriptions are not setup in a server environment.
      useMutableSource: bd,
      useSyncExternalStore: Ed
    }, vi = null;
    function Bo(l) {
      vi = l;
    }
    function Kl(l) {
      try {
        var f = "", w = l;
        do {
          switch (w.tag) {
            case 0:
              f += ui(w.type, null, null);
              break;
            case 1:
              f += Ol(w.type, null, null);
              break;
            case 2:
              f += _l(w.type, null, null);
              break;
          }
          w = w.parent;
        } while (w);
        return f;
      } catch (D) {
        return `
Error generating stack: ` + D.message + `
` + D.stack;
      }
    }
    var Wr = r.ReactCurrentDispatcher, $o = r.ReactDebugCurrentFrame, Io = 0, fa = 1, uu = 2, Yl = 3, pa = 4, kd = 0, cu = 1, Cr = 2, wd = 12800;
    function Cd(l) {
      return console.error(l), null;
    }
    function xi() {
    }
    function Gl(l, f, w, D, H, le, he, Pe, Be) {
      var ot = [], dt = /* @__PURE__ */ new Set(), kt = {
        destination: null,
        responseState: f,
        progressiveChunkSize: D === void 0 ? wd : D,
        status: kd,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: dt,
        pingedTasks: ot,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: H === void 0 ? Cd : H,
        onAllReady: le === void 0 ? xi : le,
        onShellReady: he === void 0 ? xi : he,
        onShellError: Pe === void 0 ? xi : Pe,
        onFatalError: Be === void 0 ? xi : Be
      }, yn = jr(
        kt,
        0,
        null,
        w,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      yn.parentFlushed = !0;
      var Wn = bi(kt, l, null, yn, dt, Vr, Bl, Ro);
      return ot.push(Wn), kt;
    }
    function Ho(l, f) {
      var w = l.pingedTasks;
      w.push(f), w.length === 1 && d(function() {
        return Eu(l);
      });
    }
    function Or(l, f) {
      return {
        id: hn,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: f,
        errorDigest: null
      };
    }
    function bi(l, f, w, D, H, le, he, Pe) {
      l.allPendingTasks++, w === null ? l.pendingRootTasks++ : w.pendingTasks++;
      var Be = {
        node: f,
        ping: function() {
          return Ho(l, Be);
        },
        blockedBoundary: w,
        blockedSegment: D,
        abortSet: H,
        legacyContext: le,
        context: he,
        treeContext: Pe
      };
      return Be.componentStack = null, H.add(Be), Be;
    }
    function jr(l, f, w, D, H, le) {
      return {
        status: Io,
        id: -1,
        // lazily assigned later
        index: f,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: D,
        boundary: w,
        lastPushedText: H,
        textEmbedded: le
      };
    }
    var Tr = null;
    function Xl() {
      return Tr === null || Tr.componentStack === null ? "" : Kl(Tr.componentStack);
    }
    function mr(l, f) {
      l.componentStack = {
        tag: 0,
        parent: l.componentStack,
        type: f
      };
    }
    function za(l, f) {
      l.componentStack = {
        tag: 1,
        parent: l.componentStack,
        type: f
      };
    }
    function ql(l, f) {
      l.componentStack = {
        tag: 2,
        parent: l.componentStack,
        type: f
      };
    }
    function yr(l) {
      l.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : l.componentStack = l.componentStack.parent;
    }
    var Ur = null;
    function Zl(l, f) {
      {
        var w;
        typeof f == "string" ? w = f : f && typeof f.message == "string" ? w = f.message : w = String(f);
        var D = Ur || Xl();
        Ur = null, l.errorMessage = w, l.errorComponentStack = D;
      }
    }
    function Ei(l, f) {
      var w = l.onError(f);
      if (w != null && typeof w != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof w + '" instead');
      return w;
    }
    function Vo(l, f) {
      var w = l.onShellError;
      w(f);
      var D = l.onFatalError;
      D(f), l.destination !== null ? (l.status = Cr, S(l.destination, f)) : (l.status = cu, l.fatalError = f);
    }
    function du(l, f, w) {
      mr(f, "Suspense");
      var D = f.blockedBoundary, H = f.blockedSegment, le = w.fallback, he = w.children, Pe = /* @__PURE__ */ new Set(), Be = Or(l, Pe), ot = H.chunks.length, dt = jr(
        l,
        ot,
        Be,
        H.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      H.children.push(dt), H.lastPushedText = !1;
      var kt = jr(
        l,
        0,
        null,
        H.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      kt.parentFlushed = !0, f.blockedBoundary = Be, f.blockedSegment = kt;
      try {
        if (Wo(l, f, he), $s(kt.chunks, l.responseState, kt.lastPushedText, kt.textEmbedded), kt.status = fa, wi(Be, kt), Be.pendingTasks === 0) {
          yr(f);
          return;
        }
      } catch (Wn) {
        kt.status = pa, Be.forceClientRender = !0, Be.errorDigest = Ei(l, Wn), Zl(Be, Wn);
      } finally {
        f.blockedBoundary = D, f.blockedSegment = H;
      }
      var yn = bi(l, le, D, dt, Pe, f.legacyContext, f.context, f.treeContext);
      yn.componentStack = f.componentStack, l.pingedTasks.push(yn), yr(f);
    }
    function fu(l, f, w, D) {
      mr(f, w);
      var H = f.blockedSegment, le = Er(H.chunks, w, D, l.responseState, H.formatContext);
      H.lastPushedText = !1;
      var he = H.formatContext;
      H.formatContext = Ft(he, w, D), Wo(l, f, le), H.formatContext = he, ir(H.chunks, w), H.lastPushedText = !1, yr(f);
    }
    function Td(l) {
      return l.prototype && l.prototype.isReactComponent;
    }
    function Ql(l, f, w, D, H) {
      var le = {};
      jl(f, le);
      var he = w(D, H);
      return pd(w, D, he, H);
    }
    function Si(l, f, w, D, H) {
      var le = w.render();
      w.props !== H && (ns || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", vn(D) || "a component"), ns = !0);
      {
        var he = D.childContextTypes;
        if (he != null) {
          var Pe = f.legacyContext, Be = ia(w, D, Pe, he);
          f.legacyContext = Be, cr(l, f, le), f.legacyContext = Pe;
          return;
        }
      }
      cr(l, f, le);
    }
    function pu(l, f, w, D) {
      ql(f, w);
      var H = Xs(w, f.legacyContext), le = ad(w, D, H);
      No(le, w, D, H), Si(l, f, le, w, D), yr(f);
    }
    var Jl = {}, ki = {}, es = {}, ts = {}, ns = !1, hu = !1, mu = !1, rs = !1;
    function Ad(l, f, w, D) {
      var H;
      if (H = Xs(w, f.legacyContext), za(f, w), w.prototype && typeof w.prototype.render == "function") {
        var le = vn(w) || "Unknown";
        Jl[le] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", le, le), Jl[le] = !0);
      }
      var he = Ql(l, f, w, D, H), Pe = ru();
      if (typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0) {
        var Be = vn(w) || "Unknown";
        ki[Be] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Be, Be, Be), ki[Be] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0
      ) {
        {
          var ot = vn(w) || "Unknown";
          ki[ot] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ot, ot, ot), ki[ot] = !0);
        }
        No(he, w, D, H), Si(l, f, he, w, D);
      } else if (Ld(w), Pe) {
        var dt = f.treeContext, kt = 1, yn = 0;
        f.treeContext = Vl(dt, kt, yn);
        try {
          cr(l, f, he);
        } finally {
          f.treeContext = dt;
        }
      } else
        cr(l, f, he);
      yr(f);
    }
    function Ld(l) {
      {
        if (l && l.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), typeof l.getDerivedStateFromProps == "function") {
          var f = vn(l) || "Unknown";
          ts[f] || (i("%s: Function components do not support getDerivedStateFromProps.", f), ts[f] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var w = vn(l) || "Unknown";
          es[w] || (i("%s: Function components do not support contextType.", w), es[w] = !0);
        }
      }
    }
    function yu(l, f) {
      if (l && l.defaultProps) {
        var w = sr({}, f), D = l.defaultProps;
        for (var H in D)
          w[H] === void 0 && (w[H] = D[H]);
        return w;
      }
      return f;
    }
    function Pd(l, f, w, D, H) {
      za(f, w.render);
      var le = Ql(l, f, w.render, D, H), he = ru();
      if (he) {
        var Pe = f.treeContext, Be = 1, ot = 0;
        f.treeContext = Vl(Pe, Be, ot);
        try {
          cr(l, f, le);
        } finally {
          f.treeContext = Pe;
        }
      } else
        cr(l, f, le);
      yr(f);
    }
    function Nd(l, f, w, D, H) {
      var le = w.type, he = yu(le, D);
      is(l, f, le, he, H);
    }
    function as(l, f, w, D) {
      w._context === void 0 ? w !== w.Consumer && (rs || (rs = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : w = w._context;
      var H = D.children;
      typeof H != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var le = Oa(w), he = H(le);
      cr(l, f, he);
    }
    function Rd(l, f, w, D) {
      var H = w._context, le = D.value, he = D.children, Pe;
      Pe = f.context, f.context = pi(H, le), cr(l, f, he), f.context = Il(H), Pe !== f.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function ur(l, f, w, D, H) {
      mr(f, "Lazy");
      var le = w._payload, he = w._init, Pe = he(le), Be = yu(Pe, D);
      is(l, f, Pe, Be, H), yr(f);
    }
    function is(l, f, w, D, H) {
      if (typeof w == "function")
        if (Td(w)) {
          pu(l, f, w, D);
          return;
        } else {
          Ad(l, f, w, D);
          return;
        }
      if (typeof w == "string") {
        fu(l, f, w, D);
        return;
      }
      switch (w) {
        case ed:
        case Vs:
        case po:
        case ho:
        case fo: {
          cr(l, f, D.children);
          return;
        }
        case kl: {
          mr(f, "SuspenseList"), cr(l, f, D.children), yr(f);
          return;
        }
        case Jc:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Na: {
          du(l, f, D);
          return;
        }
      }
      if (typeof w == "object" && w !== null)
        switch (w.$$typeof) {
          case ii: {
            Pd(l, f, w, D, H);
            return;
          }
          case wl: {
            Nd(l, f, w, D, H);
            return;
          }
          case ri: {
            Rd(l, f, w, D);
            return;
          }
          case ai: {
            as(l, f, w, D);
            return;
          }
          case mo: {
            ur(l, f, w, D);
            return;
          }
        }
      var le = "";
      throw (w === void 0 || typeof w == "object" && w !== null && Object.keys(w).length === 0) && (le += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (w == null ? w : typeof w) + "." + le));
    }
    function gu(l, f) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      l[Symbol.toStringTag] === "Generator" && (hu || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), hu = !0), l.entries === f && (mu || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), mu = !0);
    }
    function cr(l, f, w) {
      try {
        return os(l, f, w);
      } catch (D) {
        throw typeof D == "object" && D !== null && typeof D.then == "function" || (Ur = Ur !== null ? Ur : Xl()), D;
      }
    }
    function os(l, f, w) {
      if (f.node = w, typeof w == "object" && w !== null) {
        switch (w.$$typeof) {
          case Hs: {
            var D = w, H = D.type, le = D.props, he = D.ref;
            is(l, f, H, le, he);
            return;
          }
          case Sl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case mo: {
            var Pe = w, Be = Pe._payload, ot = Pe._init, dt;
            try {
              dt = ot(Be);
            } catch (Go) {
              throw typeof Go == "object" && Go !== null && typeof Go.then == "function" && mr(f, "Lazy"), Go;
            }
            cr(l, f, dt);
            return;
          }
        }
        if (An(w)) {
          vu(l, f, w);
          return;
        }
        var kt = En(w);
        if (kt) {
          gu(w, kt);
          var yn = kt.call(w);
          if (yn) {
            var Wn = yn.next();
            if (!Wn.done) {
              var gr = [];
              do
                gr.push(Wn.value), Wn = yn.next();
              while (!Wn.done);
              vu(l, f, gr);
              return;
            }
            return;
          }
        }
        var ku = Object.prototype.toString.call(w);
        throw new Error("Objects are not valid as a React child (found: " + (ku === "[object Object]" ? "object with keys {" + Object.keys(w).join(", ") + "}" : ku) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof w == "string") {
        var wu = f.blockedSegment;
        wu.lastPushedText = Bs(f.blockedSegment.chunks, w, l.responseState, wu.lastPushedText);
        return;
      }
      if (typeof w == "number") {
        var Cu = f.blockedSegment;
        Cu.lastPushedText = Bs(f.blockedSegment.chunks, "" + w, l.responseState, Cu.lastPushedText);
        return;
      }
      typeof w == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function vu(l, f, w) {
      for (var D = w.length, H = 0; H < D; H++) {
        var le = f.treeContext;
        f.treeContext = Vl(le, D, H);
        try {
          Wo(l, f, w[H]);
        } finally {
          f.treeContext = le;
        }
      }
    }
    function Dd(l, f, w) {
      var D = f.blockedSegment, H = D.chunks.length, le = jr(
        l,
        H,
        null,
        D.formatContext,
        // Adopt the parent segment's leading text embed
        D.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      D.children.push(le), D.lastPushedText = !1;
      var he = bi(l, f.node, f.blockedBoundary, le, f.abortSet, f.legacyContext, f.context, f.treeContext);
      f.componentStack !== null && (he.componentStack = f.componentStack.parent);
      var Pe = he.ping;
      w.then(Pe, Pe);
    }
    function Wo(l, f, w) {
      var D = f.blockedSegment.formatContext, H = f.legacyContext, le = f.context, he = null;
      he = f.componentStack;
      try {
        return cr(l, f, w);
      } catch (Pe) {
        if (yi(), typeof Pe == "object" && Pe !== null && typeof Pe.then == "function") {
          Dd(l, f, Pe), f.blockedSegment.formatContext = D, f.legacyContext = H, f.context = le, Eo(le), f.componentStack = he;
          return;
        } else
          throw f.blockedSegment.formatContext = D, f.legacyContext = H, f.context = le, Eo(le), f.componentStack = he, Pe;
      }
    }
    function jo(l, f, w, D) {
      var H = Ei(l, D);
      if (f === null ? Vo(l, D) : (f.pendingTasks--, f.forceClientRender || (f.forceClientRender = !0, f.errorDigest = H, Zl(f, D), f.parentFlushed && l.clientRenderedBoundaries.push(f))), l.allPendingTasks--, l.allPendingTasks === 0) {
        var le = l.onAllReady;
        le();
      }
    }
    function xu(l) {
      var f = this, w = l.blockedBoundary, D = l.blockedSegment;
      D.status = Yl, Ci(f, w, D);
    }
    function bu(l, f, w) {
      var D = l.blockedBoundary, H = l.blockedSegment;
      if (H.status = Yl, D === null)
        f.allPendingTasks--, f.status !== Cr && (f.status = Cr, f.destination !== null && y(f.destination));
      else {
        if (D.pendingTasks--, !D.forceClientRender) {
          D.forceClientRender = !0;
          var le = w === void 0 ? new Error("The render was aborted by the server without a reason.") : w;
          D.errorDigest = f.onError(le);
          {
            var he = "The server did not finish this Suspense boundary: ";
            le && typeof le.message == "string" ? le = he + le.message : le = he + String(le);
            var Pe = Tr;
            Tr = l;
            try {
              Zl(D, le);
            } finally {
              Tr = Pe;
            }
          }
          D.parentFlushed && f.clientRenderedBoundaries.push(D);
        }
        if (D.fallbackAbortableTasks.forEach(function(ot) {
          return bu(ot, f, w);
        }), D.fallbackAbortableTasks.clear(), f.allPendingTasks--, f.allPendingTasks === 0) {
          var Be = f.onAllReady;
          Be();
        }
      }
    }
    function wi(l, f) {
      if (f.chunks.length === 0 && f.children.length === 1 && f.children[0].boundary === null) {
        var w = f.children[0];
        w.id = f.id, w.parentFlushed = !0, w.status === fa && wi(l, w);
      } else {
        var D = l.completedSegments;
        D.push(f);
      }
    }
    function Ci(l, f, w) {
      if (f === null) {
        if (w.parentFlushed) {
          if (l.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          l.completedRootSegment = w;
        }
        if (l.pendingRootTasks--, l.pendingRootTasks === 0) {
          l.onShellError = xi;
          var D = l.onShellReady;
          D();
        }
      } else if (f.pendingTasks--, !f.forceClientRender) {
        if (f.pendingTasks === 0)
          w.parentFlushed && w.status === fa && wi(f, w), f.parentFlushed && l.completedBoundaries.push(f), f.fallbackAbortableTasks.forEach(xu, l), f.fallbackAbortableTasks.clear();
        else if (w.parentFlushed && w.status === fa) {
          wi(f, w);
          var H = f.completedSegments;
          H.length === 1 && f.parentFlushed && l.partialBoundaries.push(f);
        }
      }
      if (l.allPendingTasks--, l.allPendingTasks === 0) {
        var le = l.onAllReady;
        le();
      }
    }
    function Uo(l, f) {
      var w = f.blockedSegment;
      if (w.status === Io) {
        Eo(f.context);
        var D = null;
        D = Tr, Tr = f;
        try {
          cr(l, f, f.node), $s(w.chunks, l.responseState, w.lastPushedText, w.textEmbedded), f.abortSet.delete(f), w.status = fa, Ci(l, f.blockedBoundary, w);
        } catch (le) {
          if (yi(), typeof le == "object" && le !== null && typeof le.then == "function") {
            var H = f.ping;
            le.then(H, H);
          } else
            f.abortSet.delete(f), w.status = pa, jo(l, f.blockedBoundary, w, le);
        } finally {
          Tr = D;
        }
      }
    }
    function Eu(l) {
      if (l.status !== Cr) {
        var f = nd(), w = Wr.current;
        Wr.current = su;
        var D;
        D = $o.getCurrentStack, $o.getCurrentStack = Xl;
        var H = vi;
        Bo(l.responseState);
        try {
          var le = l.pingedTasks, he;
          for (he = 0; he < le.length; he++) {
            var Pe = le[he];
            Uo(l, Pe);
          }
          le.splice(0, he), l.destination !== null && Yo(l, l.destination);
        } catch (Be) {
          Ei(l, Be), Vo(l, Be);
        } finally {
          Bo(H), Wr.current = w, $o.getCurrentStack = D, w === su && Eo(f);
        }
      }
    }
    function Ti(l, f, w) {
      switch (w.parentFlushed = !0, w.status) {
        case Io: {
          var D = w.id = l.nextSegmentId++;
          return w.lastPushedText = !1, w.textEmbedded = !1, Qi(f, l.responseState, D);
        }
        case fa: {
          w.status = uu;
          for (var H = !0, le = w.chunks, he = 0, Pe = w.children, Be = 0; Be < Pe.length; Be++) {
            for (var ot = Pe[Be]; he < ot.index; he++)
              s(f, le[he]);
            H = Ai(l, f, ot);
          }
          for (; he < le.length - 1; he++)
            s(f, le[he]);
          return he < le.length && (H = p(f, le[he])), H;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ai(l, f, w) {
      var D = w.boundary;
      if (D === null)
        return Ti(l, f, w);
      if (D.parentFlushed = !0, D.forceClientRender)
        return pr(f, l.responseState, D.errorDigest, D.errorMessage, D.errorComponentStack), Ti(l, f, w), Is(f, l.responseState);
      if (D.pendingTasks > 0) {
        D.rootSegmentID = l.nextSegmentId++, D.completedSegments.length > 0 && l.partialBoundaries.push(D);
        var H = D.id = mn(l.responseState);
        return Hr(f, l.responseState, H), Ti(l, f, w), ei(f, l.responseState);
      } else {
        if (D.byteSize > l.progressiveChunkSize)
          return D.rootSegmentID = l.nextSegmentId++, l.completedBoundaries.push(D), Hr(f, l.responseState, D.id), Ti(l, f, w), ei(f, l.responseState);
        El(f, l.responseState);
        var le = D.completedSegments;
        if (le.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var he = le[0];
        return Ai(l, f, he), Qc(f, l.responseState);
      }
    }
    function _d(l, f, w) {
      return Xc(f, l.responseState, w.id, w.errorDigest, w.errorMessage, w.errorComponentStack);
    }
    function ls(l, f, w) {
      return ke(f, l.responseState, w.formatContext, w.id), Ai(l, f, w), Me(f, w.formatContext);
    }
    function Ko(l, f, w) {
      for (var D = w.completedSegments, H = 0; H < D.length; H++) {
        var le = D[H];
        Su(l, f, w, le);
      }
      return D.length = 0, jc(f, l.responseState, w.id, w.rootSegmentID);
    }
    function Od(l, f, w) {
      for (var D = w.completedSegments, H = 0; H < D.length; H++) {
        var le = D[H];
        if (!Su(l, f, w, le))
          return H++, D.splice(0, H), !1;
      }
      return D.splice(0, H), !0;
    }
    function Su(l, f, w, D) {
      if (D.status === uu)
        return !0;
      var H = D.id;
      if (H === -1) {
        var le = D.id = w.rootSegmentID;
        if (le === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return ls(l, f, D);
      } else
        return ls(l, f, D), lr(f, l.responseState, H);
    }
    function Yo(l, f) {
      try {
        var w = l.completedRootSegment;
        w !== null && l.pendingRootTasks === 0 && (Ai(l, f, w), l.completedRootSegment = null, qa(f, l.responseState));
        var D = l.clientRenderedBoundaries, H;
        for (H = 0; H < D.length; H++) {
          var le = D[H];
          if (!_d(l, f, le)) {
            l.destination = null, H++, D.splice(0, H);
            return;
          }
        }
        D.splice(0, H);
        var he = l.completedBoundaries;
        for (H = 0; H < he.length; H++) {
          var Pe = he[H];
          if (!Ko(l, f, Pe)) {
            l.destination = null, H++, he.splice(0, H);
            return;
          }
        }
        he.splice(0, H);
        var Be = l.partialBoundaries;
        for (H = 0; H < Be.length; H++) {
          var ot = Be[H];
          if (!Od(l, f, ot)) {
            l.destination = null, H++, Be.splice(0, H);
            return;
          }
        }
        Be.splice(0, H);
        var dt = l.completedBoundaries;
        for (H = 0; H < dt.length; H++) {
          var kt = dt[H];
          if (!Ko(l, f, kt)) {
            l.destination = null, H++, dt.splice(0, H);
            return;
          }
        }
        dt.splice(0, H);
      } finally {
        l.allPendingTasks === 0 && l.pingedTasks.length === 0 && l.clientRenderedBoundaries.length === 0 && l.completedBoundaries.length === 0 && (l.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), y(f));
      }
    }
    function Fd(l) {
      d(function() {
        return Eu(l);
      });
    }
    function u(l, f) {
      if (l.status === cu) {
        l.status = Cr, S(f, l.fatalError);
        return;
      }
      if (l.status !== Cr && l.destination === null) {
        l.destination = f;
        try {
          Yo(l, f);
        } catch (w) {
          Ei(l, w), Vo(l, w);
        }
      }
    }
    function h(l, f) {
      try {
        var w = l.abortableTasks;
        w.forEach(function(D) {
          return bu(D, l, f);
        }), w.clear(), l.destination !== null && Yo(l, l.destination);
      } catch (D) {
        Ei(l, D), Vo(l, D);
      }
    }
    function L() {
    }
    function F(l, f, w, D) {
      var H = !1, le = null, he = "", Pe = {
        push: function(kt) {
          return kt !== null && (he += kt), !0;
        },
        destroy: function(kt) {
          H = !0, le = kt;
        }
      }, Be = !1;
      function ot() {
        Be = !0;
      }
      var dt = Gl(l, Zc(w, f ? f.identifierPrefix : void 0), bl(), 1 / 0, L, void 0, ot, void 0, void 0);
      if (Fd(dt), h(dt, D), u(dt, Pe), H)
        throw le;
      if (!Be)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return he;
    }
    function G(l, f) {
      return F(l, f, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function de(l, f) {
      return F(l, f, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function ye() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Re() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Oi.renderToNodeStream = ye, Oi.renderToStaticMarkup = de, Oi.renderToStaticNodeStream = Re, Oi.renderToString = G, Oi.version = t;
  }()), Oi;
}
var Iu = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rm;
function yS() {
  return rm || (rm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ue, t = "18.2.0", r = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(u) {
      {
        for (var h = arguments.length, L = new Array(h > 1 ? h - 1 : 0), F = 1; F < h; F++)
          L[F - 1] = arguments[F];
        o("warn", u, L);
      }
    }
    function i(u) {
      {
        for (var h = arguments.length, L = new Array(h > 1 ? h - 1 : 0), F = 1; F < h; F++)
          L[F - 1] = arguments[F];
        o("error", u, L);
      }
    }
    function o(u, h, L) {
      {
        var F = r.ReactDebugCurrentFrame, G = F.getStackAddendum();
        G !== "" && (h += "%s", L = L.concat([G]));
        var de = L.map(function(ye) {
          return String(ye);
        });
        de.unshift("Warning: " + h), Function.prototype.apply.call(console[u], console, de);
      }
    }
    function d(u) {
      u();
    }
    var c = 512, s = null, p = 0;
    function m(u) {
      s = new Uint8Array(c), p = 0;
    }
    function y(u, h) {
      if (h.length !== 0) {
        if (h.length > c) {
          p > 0 && (u.enqueue(new Uint8Array(s.buffer, 0, p)), s = new Uint8Array(c), p = 0), u.enqueue(h);
          return;
        }
        var L = h, F = s.length - p;
        F < L.length && (F === 0 ? u.enqueue(s) : (s.set(L.subarray(0, F), p), u.enqueue(s), L = L.subarray(F)), s = new Uint8Array(c), p = 0), s.set(L, p), p += L.length;
      }
    }
    function x(u, h) {
      return y(u, h), !0;
    }
    function T(u) {
      s && p > 0 && (u.enqueue(new Uint8Array(s.buffer, 0, p)), s = null, p = 0);
    }
    function S(u) {
      u.close();
    }
    var A = new TextEncoder();
    function E(u) {
      return A.encode(u);
    }
    function b(u) {
      return A.encode(u);
    }
    function v(u, h) {
      typeof u.error == "function" ? u.error(h) : u.close();
    }
    function N(u) {
      {
        var h = typeof Symbol == "function" && Symbol.toStringTag, L = h && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return L;
      }
    }
    function C(u) {
      try {
        return R(u), !1;
      } catch {
        return !0;
      }
    }
    function R(u) {
      return "" + u;
    }
    function _(u, h) {
      if (C(u))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", h, N(u)), R(u);
    }
    function U(u, h) {
      if (C(u))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", h, N(u)), R(u);
    }
    function j(u) {
      if (C(u))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", N(u)), R(u);
    }
    var te = Object.prototype.hasOwnProperty, Q = 0, $ = 1, J = 2, ne = 3, z = 4, W = 5, ie = 6, ae = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", oe = ae + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", K = new RegExp("^[" + ae + "][" + oe + "]*$"), Y = {}, X = {};
    function q(u) {
      return te.call(X, u) ? !0 : te.call(Y, u) ? !1 : K.test(u) ? (X[u] = !0, !0) : (Y[u] = !0, i("Invalid attribute name: `%s`", u), !1);
    }
    function ce(u, h, L, F) {
      if (L !== null && L.type === Q)
        return !1;
      switch (typeof h) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (F)
            return !1;
          if (L !== null)
            return !L.acceptsBooleans;
          var G = u.toLowerCase().slice(0, 5);
          return G !== "data-" && G !== "aria-";
        }
        default:
          return !1;
      }
    }
    function ge(u) {
      return me.hasOwnProperty(u) ? me[u] : null;
    }
    function De(u, h, L, F, G, de, ye) {
      this.acceptsBooleans = h === J || h === ne || h === z, this.attributeName = F, this.attributeNamespace = G, this.mustUseProperty = L, this.propertyName = u, this.type = h, this.sanitizeURL = de, this.removeEmptyString = ye;
    }
    var me = {}, Fe = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Fe.forEach(function(u) {
      me[u] = new De(
        u,
        Q,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(u) {
      var h = u[0], L = u[1];
      me[h] = new De(
        h,
        $,
        !1,
        // mustUseProperty
        L,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(u) {
      me[u] = new De(
        u,
        J,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(u) {
      me[u] = new De(
        u,
        J,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(u) {
      me[u] = new De(
        u,
        ne,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      me[u] = new De(
        u,
        ne,
        !0,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      me[u] = new De(
        u,
        z,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      me[u] = new De(
        u,
        ie,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(u) {
      me[u] = new De(
        u,
        W,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Ue = /[\-\:]([a-z])/g, Te = function(u) {
      return u[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(Ue, Te);
      me[h] = new De(
        h,
        $,
        !1,
        // mustUseProperty
        u,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(Ue, Te);
      me[h] = new De(
        h,
        $,
        !1,
        // mustUseProperty
        u,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(Ue, Te);
      me[h] = new De(
        h,
        $,
        !1,
        // mustUseProperty
        u,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(u) {
      me[u] = new De(
        u,
        $,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ve = "xlinkHref";
    me[ve] = new De(
      "xlinkHref",
      $,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(u) {
      me[u] = new De(
        u,
        $,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ae = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function fe(u, h) {
      return u + h.charAt(0).toUpperCase() + h.substring(1);
    }
    var ze = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Ae).forEach(function(u) {
      ze.forEach(function(h) {
        Ae[fe(h, u)] = Ae[u];
      });
    });
    var Oe = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Ve(u, h) {
      Oe[h.type] || h.onChange || h.onInput || h.readOnly || h.disabled || h.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), h.onChange || h.readOnly || h.disabled || h.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ze(u, h) {
      if (u.indexOf("-") === -1)
        return typeof h.is == "string";
      switch (u) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Ie = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, qe = {}, et = new RegExp("^(aria)-[" + oe + "]*$"), He = new RegExp("^(aria)[A-Z][" + oe + "]*$");
    function Ge(u, h) {
      {
        if (te.call(qe, h) && qe[h])
          return !0;
        if (He.test(h)) {
          var L = "aria-" + h.slice(4).toLowerCase(), F = Ie.hasOwnProperty(L) ? L : null;
          if (F == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", h), qe[h] = !0, !0;
          if (h !== F)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", h, F), qe[h] = !0, !0;
        }
        if (et.test(h)) {
          var G = h.toLowerCase(), de = Ie.hasOwnProperty(G) ? G : null;
          if (de == null)
            return qe[h] = !0, !1;
          if (h !== de)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", h, de), qe[h] = !0, !0;
        }
      }
      return !0;
    }
    function Le(u, h) {
      {
        var L = [];
        for (var F in h) {
          var G = Ge(u, F);
          G || L.push(F);
        }
        var de = L.map(function(ye) {
          return "`" + ye + "`";
        }).join(", ");
        L.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", de, u) : L.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", de, u);
      }
    }
    function _e(u, h) {
      Ze(u, h) || Le(u, h);
    }
    var st = !1;
    function Ee(u, h) {
      {
        if (u !== "input" && u !== "textarea" && u !== "select")
          return;
        h != null && h.value === null && !st && (st = !0, u === "select" && h.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", u) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", u));
      }
    }
    var rt = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, pt = function() {
    };
    {
      var ft = {}, wt = /^on./, zt = /^on[^A-Z]/, Jt = new RegExp("^(aria)-[" + oe + "]*$"), jt = new RegExp("^(aria)[A-Z][" + oe + "]*$");
      pt = function(u, h, L, F) {
        if (te.call(ft, h) && ft[h])
          return !0;
        var G = h.toLowerCase();
        if (G === "onfocusin" || G === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), ft[h] = !0, !0;
        if (F != null) {
          var de = F.registrationNameDependencies, ye = F.possibleRegistrationNames;
          if (de.hasOwnProperty(h))
            return !0;
          var Re = ye.hasOwnProperty(G) ? ye[G] : null;
          if (Re != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", h, Re), ft[h] = !0, !0;
          if (wt.test(h))
            return i("Unknown event handler property `%s`. It will be ignored.", h), ft[h] = !0, !0;
        } else if (wt.test(h))
          return zt.test(h) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", h), ft[h] = !0, !0;
        if (Jt.test(h) || jt.test(h))
          return !0;
        if (G === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), ft[h] = !0, !0;
        if (G === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), ft[h] = !0, !0;
        if (G === "is" && L !== null && L !== void 0 && typeof L != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof L), ft[h] = !0, !0;
        if (typeof L == "number" && isNaN(L))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", h), ft[h] = !0, !0;
        var l = ge(h), f = l !== null && l.type === Q;
        if (rt.hasOwnProperty(G)) {
          var w = rt[G];
          if (w !== h)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", h, w), ft[h] = !0, !0;
        } else if (!f && h !== G)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", h, G), ft[h] = !0, !0;
        return typeof L == "boolean" && ce(h, L, l, !1) ? (L ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', L, h, h, L, h) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', L, h, h, L, h, h, h), ft[h] = !0, !0) : f ? !0 : ce(h, L, l, !1) ? (ft[h] = !0, !1) : ((L === "false" || L === "true") && l !== null && l.type === ne && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", L, h, L === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', h, L), ft[h] = !0), !0);
      };
    }
    var on = function(u, h, L) {
      {
        var F = [];
        for (var G in h) {
          var de = pt(u, G, h[G], L);
          de || F.push(G);
        }
        var ye = F.map(function(Re) {
          return "`" + Re + "`";
        }).join(", ");
        F.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", ye, u) : F.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", ye, u);
      }
    };
    function _t(u, h, L) {
      Ze(u, h) || on(u, h, L);
    }
    var tn = function() {
    };
    {
      var $t = /^(?:webkit|moz|o)[A-Z]/, Ut = /^-ms-/, bt = /-(.)/g, mt = /;\s*$/, ln = {}, Yt = {}, xt = !1, Gt = !1, Sn = function(u) {
        return u.replace(bt, function(h, L) {
          return L.toUpperCase();
        });
      }, At = function(u) {
        ln.hasOwnProperty(u) && ln[u] || (ln[u] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          u,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Sn(u.replace(Ut, "ms-"))
        ));
      }, nn = function(u) {
        ln.hasOwnProperty(u) && ln[u] || (ln[u] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", u, u.charAt(0).toUpperCase() + u.slice(1)));
      }, Xt = function(u, h) {
        Yt.hasOwnProperty(h) && Yt[h] || (Yt[h] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, u, h.replace(mt, "")));
      }, sn = function(u, h) {
        xt || (xt = !0, i("`NaN` is an invalid value for the `%s` css style property.", u));
      }, Nt = function(u, h) {
        Gt || (Gt = !0, i("`Infinity` is an invalid value for the `%s` css style property.", u));
      };
      tn = function(u, h) {
        u.indexOf("-") > -1 ? At(u) : $t.test(u) ? nn(u) : mt.test(h) && Xt(u, h), typeof h == "number" && (isNaN(h) ? sn(u, h) : isFinite(h) || Nt(u, h));
      };
    }
    var xn = tn, dn = /["'&<>]/;
    function Lt(u) {
      j(u);
      var h = "" + u, L = dn.exec(h);
      if (!L)
        return h;
      var F, G = "", de, ye = 0;
      for (de = L.index; de < h.length; de++) {
        switch (h.charCodeAt(de)) {
          case 34:
            F = "&quot;";
            break;
          case 38:
            F = "&amp;";
            break;
          case 39:
            F = "&#x27;";
            break;
          case 60:
            F = "&lt;";
            break;
          case 62:
            F = "&gt;";
            break;
          default:
            continue;
        }
        ye !== de && (G += h.substring(ye, de)), ye = de + 1, G += F;
      }
      return ye !== de ? G + h.substring(ye, de) : G;
    }
    function nt(u) {
      return typeof u == "boolean" || typeof u == "number" ? "" + u : Lt(u);
    }
    var bn = /([A-Z])/g, Hn = /^ms-/;
    function Gn(u) {
      return u.replace(bn, "-$1").toLowerCase().replace(Hn, "-ms-");
    }
    var An = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Un = !1;
    function _n(u) {
      !Un && An.test(u) && (Un = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(u)));
    }
    var Pn = Array.isArray;
    function pn(u) {
      return Pn(u);
    }
    var Se = b("<script>"), Ne = b("<\/script>"), pe = b('<script src="'), Ke = b('<script type="module" src="'), ht = b('" async=""><\/script>');
    function it(u) {
      return j(u), ("" + u).replace(ct, Kt);
    }
    var ct = /(<\/|<)(s)(cript)/gi, Kt = function(u, h, L, F) {
      return "" + h + (L === "s" ? "\\u0073" : "\\u0053") + F;
    };
    function Ot(u, h, L, F, G) {
      var de = u === void 0 ? "" : u, ye = h === void 0 ? Se : b('<script nonce="' + nt(h) + '">'), Re = [];
      if (L !== void 0 && Re.push(ye, E(it(L)), Ne), F !== void 0)
        for (var l = 0; l < F.length; l++)
          Re.push(pe, E(nt(F[l])), ht);
      if (G !== void 0)
        for (var f = 0; f < G.length; f++)
          Re.push(Ke, E(nt(G[f])), ht);
      return {
        bootstrapChunks: Re,
        startInlineScript: ye,
        placeholderPrefix: b(de + "P:"),
        segmentPrefix: b(de + "S:"),
        boundaryPrefix: de + "B:",
        idPrefix: de,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var tt = 0, ut = 1, It = 2, Rt = 3, Ht = 4, Ft = 5, hn = 6, mn = 7;
    function Mt(u, h) {
      return {
        insertionMode: u,
        selectedValue: h
      };
    }
    function kn(u) {
      var h = u === "http://www.w3.org/2000/svg" ? It : u === "http://www.w3.org/1998/Math/MathML" ? Rt : tt;
      return Mt(h, null);
    }
    function wn(u, h, L) {
      switch (h) {
        case "select":
          return Mt(ut, L.value != null ? L.value : L.defaultValue);
        case "svg":
          return Mt(It, null);
        case "math":
          return Mt(Rt, null);
        case "foreignObject":
          return Mt(ut, null);
        case "table":
          return Mt(Ht, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return Mt(Ft, null);
        case "colgroup":
          return Mt(mn, null);
        case "tr":
          return Mt(hn, null);
      }
      return u.insertionMode >= Ht || u.insertionMode === tt ? Mt(ut, null) : u;
    }
    var On = null;
    function Nn(u) {
      var h = u.nextSuspenseID++;
      return b(u.boundaryPrefix + h.toString(16));
    }
    function Ln(u, h, L) {
      var F = u.idPrefix, G = ":" + F + "R" + h;
      return L > 0 && (G += "H" + L.toString(32)), G + ":";
    }
    function fn(u) {
      return nt(u);
    }
    var Fn = b("<!-- -->");
    function Zt(u, h, L, F) {
      return h === "" ? F : (F && u.push(Fn), u.push(E(fn(h))), !0);
    }
    function we(u, h, L, F) {
      L && F && u.push(Fn);
    }
    var g = /* @__PURE__ */ new Map();
    function P(u) {
      var h = g.get(u);
      if (h !== void 0)
        return h;
      var L = b(nt(Gn(u)));
      return g.set(u, L), L;
    }
    var M = b(' style="'), Z = b(":"), xe = b(";");
    function B(u, h, L) {
      if (typeof L != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var F = !0;
      for (var G in L)
        if (te.call(L, G)) {
          var de = L[G];
          if (!(de == null || typeof de == "boolean" || de === "")) {
            var ye = void 0, Re = void 0, l = G.indexOf("--") === 0;
            l ? (ye = E(nt(G)), U(de, G), Re = E(nt(("" + de).trim()))) : (xn(G, de), ye = P(G), typeof de == "number" ? de !== 0 && !te.call(Ae, G) ? Re = E(de + "px") : Re = E("" + de) : (U(de, G), Re = E(nt(("" + de).trim())))), F ? (F = !1, u.push(M, ye, Z, Re)) : u.push(xe, ye, Z, Re);
          }
        }
      F || u.push(be);
    }
    var I = b(" "), ee = b('="'), be = b('"'), We = b('=""');
    function Qe(u, h, L, F) {
      switch (L) {
        case "style": {
          B(u, h, F);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(L.length > 2 && (L[0] === "o" || L[0] === "O") && (L[1] === "n" || L[1] === "N"))
      ) {
        var G = ge(L);
        if (G !== null) {
          switch (typeof F) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!G.acceptsBooleans)
                return;
          }
          var de = G.attributeName, ye = E(de);
          switch (G.type) {
            case ne:
              F && u.push(I, ye, We);
              return;
            case z:
              F === !0 ? u.push(I, ye, We) : F === !1 || u.push(I, ye, ee, E(nt(F)), be);
              return;
            case W:
              isNaN(F) || u.push(I, ye, ee, E(nt(F)), be);
              break;
            case ie:
              !isNaN(F) && F >= 1 && u.push(I, ye, ee, E(nt(F)), be);
              break;
            default:
              G.sanitizeURL && (_(F, de), F = "" + F, _n(F)), u.push(I, ye, ee, E(nt(F)), be);
          }
        } else if (q(L)) {
          switch (typeof F) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Re = L.toLowerCase().slice(0, 5);
              if (Re !== "data-" && Re !== "aria-")
                return;
            }
          }
          u.push(I, E(L), ee, E(nt(F)), be);
        }
      }
    }
    var St = b(">"), Dt = b("/>");
    function Bt(u, h, L) {
      if (h != null) {
        if (L != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof h != "object" || !("__html" in h))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var F = h.__html;
        F != null && (j(F), u.push(E("" + F)));
      }
    }
    var Cn = !1, Kn = !1, Mn = !1, fr = !1, Xn = !1, Ct = !1, rn = !1;
    function xr(u, h) {
      {
        var L = u[h];
        if (L != null) {
          var F = pn(L);
          u.multiple && !F ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", h) : !u.multiple && F && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", h);
        }
      }
    }
    function Jr(u, h, L) {
      Ve("select", h), xr(h, "value"), xr(h, "defaultValue"), h.value !== void 0 && h.defaultValue !== void 0 && !Mn && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Mn = !0), u.push(ir("select"));
      var F = null, G = null;
      for (var de in h)
        if (te.call(h, de)) {
          var ye = h[de];
          if (ye == null)
            continue;
          switch (de) {
            case "children":
              F = ye;
              break;
            case "dangerouslySetInnerHTML":
              G = ye;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              Qe(u, L, de, ye);
              break;
          }
        }
      return u.push(St), Bt(u, G, F), F;
    }
    function Ga(u) {
      var h = "";
      return e.Children.forEach(u, function(L) {
        L != null && (h += L, !Xn && typeof L != "string" && typeof L != "number" && (Xn = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), h;
    }
    var ea = b(' selected=""');
    function Xa(u, h, L, F) {
      var G = F.selectedValue;
      u.push(ir("option"));
      var de = null, ye = null, Re = null, l = null;
      for (var f in h)
        if (te.call(h, f)) {
          var w = h[f];
          if (w == null)
            continue;
          switch (f) {
            case "children":
              de = w;
              break;
            case "selected":
              Re = w, rn || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), rn = !0);
              break;
            case "dangerouslySetInnerHTML":
              l = w;
              break;
            case "value":
              ye = w;
            default:
              Qe(u, L, f, w);
              break;
          }
        }
      if (G != null) {
        var D;
        if (ye !== null ? (_(ye, "value"), D = "" + ye) : (l !== null && (Ct || (Ct = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), D = Ga(de)), pn(G))
          for (var H = 0; H < G.length; H++) {
            _(G[H], "value");
            var le = "" + G[H];
            if (le === D) {
              u.push(ea);
              break;
            }
          }
        else
          _(G, "select.value"), "" + G === D && u.push(ea);
      } else
        Re && u.push(ea);
      return u.push(St), Bt(u, l, de), de;
    }
    function Pr(u, h, L) {
      Ve("input", h), h.checked !== void 0 && h.defaultChecked !== void 0 && !Kn && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), Kn = !0), h.value !== void 0 && h.defaultValue !== void 0 && !Cn && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), Cn = !0), u.push(ir("input"));
      var F = null, G = null, de = null, ye = null;
      for (var Re in h)
        if (te.call(h, Re)) {
          var l = h[Re];
          if (l == null)
            continue;
          switch (Re) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              ye = l;
              break;
            case "defaultValue":
              G = l;
              break;
            case "checked":
              de = l;
              break;
            case "value":
              F = l;
              break;
            default:
              Qe(u, L, Re, l);
              break;
          }
        }
      return de !== null ? Qe(u, L, "checked", de) : ye !== null && Qe(u, L, "checked", ye), F !== null ? Qe(u, L, "value", F) : G !== null && Qe(u, L, "value", G), u.push(Dt), null;
    }
    function ar(u, h, L) {
      Ve("textarea", h), h.value !== void 0 && h.defaultValue !== void 0 && !fr && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), fr = !0), u.push(ir("textarea"));
      var F = null, G = null, de = null;
      for (var ye in h)
        if (te.call(h, ye)) {
          var Re = h[ye];
          if (Re == null)
            continue;
          switch (ye) {
            case "children":
              de = Re;
              break;
            case "value":
              F = Re;
              break;
            case "defaultValue":
              G = Re;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              Qe(u, L, ye, Re);
              break;
          }
        }
      if (F === null && G !== null && (F = G), u.push(St), de != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), F != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (pn(de)) {
          if (de.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          j(de[0]), F = "" + de[0];
        }
        j(de), F = "" + de;
      }
      return typeof F == "string" && F[0] === `
` && u.push(Nr), F !== null && (_(F, "value"), u.push(E(fn("" + F)))), null;
    }
    function ta(u, h, L, F) {
      u.push(ir(L));
      for (var G in h)
        if (te.call(h, G)) {
          var de = h[G];
          if (de == null)
            continue;
          switch (G) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(L + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              Qe(u, F, G, de);
              break;
          }
        }
      return u.push(Dt), null;
    }
    function va(u, h, L) {
      u.push(ir("menuitem"));
      for (var F in h)
        if (te.call(h, F)) {
          var G = h[F];
          if (G == null)
            continue;
          switch (F) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              Qe(u, L, F, G);
              break;
          }
        }
      return u.push(St), null;
    }
    function an(u, h, L) {
      u.push(ir("title"));
      var F = null;
      for (var G in h)
        if (te.call(h, G)) {
          var de = h[G];
          if (de == null)
            continue;
          switch (G) {
            case "children":
              F = de;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              Qe(u, L, G, de);
              break;
          }
        }
      u.push(St);
      {
        var ye = Array.isArray(F) && F.length < 2 ? F[0] || null : F;
        Array.isArray(F) && F.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : ye != null && ye.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : ye != null && typeof ye != "string" && typeof ye != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return F;
    }
    function br(u, h, L, F) {
      u.push(ir(L));
      var G = null, de = null;
      for (var ye in h)
        if (te.call(h, ye)) {
          var Re = h[ye];
          if (Re == null)
            continue;
          switch (ye) {
            case "children":
              G = Re;
              break;
            case "dangerouslySetInnerHTML":
              de = Re;
              break;
            default:
              Qe(u, F, ye, Re);
              break;
          }
        }
      return u.push(St), Bt(u, de, G), typeof G == "string" ? (u.push(E(fn(G))), null) : G;
    }
    function qn(u, h, L, F) {
      u.push(ir(L));
      var G = null, de = null;
      for (var ye in h)
        if (te.call(h, ye)) {
          var Re = h[ye];
          if (Re == null)
            continue;
          switch (ye) {
            case "children":
              G = Re;
              break;
            case "dangerouslySetInnerHTML":
              de = Re;
              break;
            case "style":
              B(u, F, Re);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              q(ye) && typeof Re != "function" && typeof Re != "symbol" && u.push(I, E(ye), ee, E(nt(Re)), be);
              break;
          }
        }
      return u.push(St), Bt(u, de, G), G;
    }
    var Nr = b(`
`);
    function Er(u, h, L, F) {
      u.push(ir(L));
      var G = null, de = null;
      for (var ye in h)
        if (te.call(h, ye)) {
          var Re = h[ye];
          if (Re == null)
            continue;
          switch (ye) {
            case "children":
              G = Re;
              break;
            case "dangerouslySetInnerHTML":
              de = Re;
              break;
            default:
              Qe(u, F, ye, Re);
              break;
          }
        }
      if (u.push(St), de != null) {
        if (G != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof de != "object" || !("__html" in de))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var l = de.__html;
        l != null && (typeof l == "string" && l.length > 0 && l[0] === `
` ? u.push(Nr, E(l)) : (j(l), u.push(E("" + l))));
      }
      return typeof G == "string" && G[0] === `
` && u.push(Nr), G;
    }
    var xa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Sr = /* @__PURE__ */ new Map();
    function ir(u) {
      var h = Sr.get(u);
      if (h === void 0) {
        if (!xa.test(u))
          throw new Error("Invalid tag: " + u);
        h = b("<" + u), Sr.set(u, h);
      }
      return h;
    }
    var qa = b("<!DOCTYPE html>");
    function Za(u, h, L, F, G) {
      switch (_e(h, L), Ee(h, L), _t(h, L, null), !L.suppressContentEditableWarning && L.contentEditable && L.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), G.insertionMode !== It && G.insertionMode !== Rt && h.indexOf("-") === -1 && typeof L.is != "string" && h.toLowerCase() !== h && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", h), h) {
        case "select":
          return Jr(u, L, F);
        case "option":
          return Xa(u, L, F, G);
        case "textarea":
          return ar(u, L, F);
        case "input":
          return Pr(u, L, F);
        case "menuitem":
          return va(u, L, F);
        case "title":
          return an(u, L, F);
        case "listing":
        case "pre":
          return Er(u, L, h, F);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return ta(u, L, h, F);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return br(u, L, h, F);
        case "html":
          return G.insertionMode === tt && u.push(qa), br(u, L, h, F);
        default:
          return h.indexOf("-") === -1 && typeof L.is != "string" ? br(u, L, h, F) : qn(u, L, h, F);
      }
    }
    var Zi = b("</"), Qi = b(">");
    function Ji(u, h, L) {
      switch (h) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          u.push(Zi, E(h), Qi);
      }
    }
    function hl(u, h) {
      for (var L = h.bootstrapChunks, F = 0; F < L.length - 1; F++)
        y(u, L[F]);
      return F < L.length ? x(u, L[F]) : !0;
    }
    var ml = b('<template id="'), ba = b('"></template>');
    function Ea(u, h, L) {
      y(u, ml), y(u, h.placeholderPrefix);
      var F = E(L.toString(16));
      return y(u, F), x(u, ba);
    }
    var Sa = b("<!--$-->"), na = b('<!--$?--><template id="'), yl = b('"></template>'), ra = b("<!--$!-->"), Qa = b("<!--/$-->"), Ja = b("<template"), Ir = b('"'), Hr = b(' data-dgst="'), ka = b(' data-msg="'), eo = b(' data-stck="'), ei = b("></template>");
    function to(u, h) {
      return x(u, Sa);
    }
    function wa(u, h, L) {
      if (y(u, na), L === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return y(u, L), x(u, yl);
    }
    function Zn(u, h, L, F, G) {
      var de;
      return de = x(u, ra), y(u, Ja), L && (y(u, Hr), y(u, E(nt(L))), y(u, Ir)), F && (y(u, ka), y(u, E(nt(F))), y(u, Ir)), G && (y(u, eo), y(u, E(nt(G))), y(u, Ir)), de = x(u, ei), de;
    }
    function no(u, h) {
      return x(u, Qa);
    }
    function Ca(u, h) {
      return x(u, Qa);
    }
    function gl(u, h) {
      return x(u, Qa);
    }
    var ro = b('<div hidden id="'), Ta = b('">'), ao = b("</div>"), io = b('<svg aria-hidden="true" style="display:none" id="'), Aa = b('">'), La = b("</svg>"), oo = b('<math aria-hidden="true" style="display:none" id="'), lo = b('">'), so = b("</math>"), ti = b('<table hidden id="'), uo = b('">'), k = b("</table>"), O = b('<table hidden><tbody id="'), V = b('">'), re = b("</tbody></table>"), Ce = b('<table hidden><tr id="'), ke = b('">'), Me = b("</tr></table>"), Ye = b('<table hidden><colgroup id="'), Et = b('">'), Pt = b("</colgroup></table>");
    function Tt(u, h, L, F) {
      switch (L.insertionMode) {
        case tt:
        case ut:
          return y(u, ro), y(u, h.segmentPrefix), y(u, E(F.toString(16))), x(u, Ta);
        case It:
          return y(u, io), y(u, h.segmentPrefix), y(u, E(F.toString(16))), x(u, Aa);
        case Rt:
          return y(u, oo), y(u, h.segmentPrefix), y(u, E(F.toString(16))), x(u, lo);
        case Ht:
          return y(u, ti), y(u, h.segmentPrefix), y(u, E(F.toString(16))), x(u, uo);
        case Ft:
          return y(u, O), y(u, h.segmentPrefix), y(u, E(F.toString(16))), x(u, V);
        case hn:
          return y(u, Ce), y(u, h.segmentPrefix), y(u, E(F.toString(16))), x(u, ke);
        case mn:
          return y(u, Ye), y(u, h.segmentPrefix), y(u, E(F.toString(16))), x(u, Et);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function un(u, h) {
      switch (h.insertionMode) {
        case tt:
        case ut:
          return x(u, ao);
        case It:
          return x(u, La);
        case Rt:
          return x(u, so);
        case Ht:
          return x(u, k);
        case Ft:
          return x(u, re);
        case hn:
          return x(u, Me);
        case mn:
          return x(u, Pt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Qn = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", or = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', lr = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Pa = b(Qn + ';$RS("'), co = b('$RS("'), ni = b('","'), Wc = b('")<\/script>');
    function jc(u, h, L) {
      y(u, h.startInlineScript), h.sentCompleteSegmentFunction ? y(u, co) : (h.sentCompleteSegmentFunction = !0, y(u, Pa)), y(u, h.segmentPrefix);
      var F = E(L.toString(16));
      return y(u, F), y(u, ni), y(u, h.placeholderPrefix), y(u, F), x(u, Wc);
    }
    var Uc = b(or + ';$RC("'), Kc = b('$RC("'), Yc = b('","'), Gc = b('")<\/script>');
    function vl(u, h, L, F) {
      if (y(u, h.startInlineScript), h.sentCompleteBoundaryFunction ? y(u, Kc) : (h.sentCompleteBoundaryFunction = !0, y(u, Uc)), L === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var G = E(F.toString(16));
      return y(u, L), y(u, Yc), y(u, h.segmentPrefix), y(u, G), x(u, Gc);
    }
    var Xc = b(lr + ';$RX("'), qc = b('$RX("'), xl = b('"'), Zc = b(")<\/script>"), bl = b(",");
    function Bs(u, h, L, F, G, de) {
      if (y(u, h.startInlineScript), h.sentClientRenderFunction ? y(u, qc) : (h.sentClientRenderFunction = !0, y(u, Xc)), L === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return y(u, L), y(u, xl), (F || G || de) && (y(u, bl), y(u, E(El(F || "")))), (G || de) && (y(u, bl), y(u, E(El(G || "")))), de && (y(u, bl), y(u, E(El(de)))), x(u, Zc);
    }
    var $s = /[<\u2028\u2029]/g;
    function El(u) {
      var h = JSON.stringify(u);
      return h.replace($s, function(L) {
        switch (L) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var pr = Object.assign, Qc = Symbol.for("react.element"), Is = Symbol.for("react.portal"), sr = Symbol.for("react.fragment"), Hs = Symbol.for("react.strict_mode"), Sl = Symbol.for("react.profiler"), fo = Symbol.for("react.provider"), po = Symbol.for("react.context"), ho = Symbol.for("react.forward_ref"), ri = Symbol.for("react.suspense"), ai = Symbol.for("react.suspense_list"), ii = Symbol.for("react.memo"), Na = Symbol.for("react.lazy"), kl = Symbol.for("react.scope"), wl = Symbol.for("react.debug_trace_mode"), mo = Symbol.for("react.legacy_hidden"), Jc = Symbol.for("react.default_value"), Vs = Symbol.iterator, ed = "@@iterator";
    function td(u) {
      if (u === null || typeof u != "object")
        return null;
      var h = Vs && u[Vs] || u[ed];
      return typeof h == "function" ? h : null;
    }
    function Ws(u, h, L) {
      var F = u.displayName;
      if (F)
        return F;
      var G = h.displayName || h.name || "";
      return G !== "" ? L + "(" + G + ")" : L;
    }
    function js(u) {
      return u.displayName || "Context";
    }
    function En(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case sr:
          return "Fragment";
        case Is:
          return "Portal";
        case Sl:
          return "Profiler";
        case Hs:
          return "StrictMode";
        case ri:
          return "Suspense";
        case ai:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case po:
            var h = u;
            return js(h) + ".Consumer";
          case fo:
            var L = u;
            return js(L._context) + ".Provider";
          case ho:
            return Ws(u, u.render, "ForwardRef");
          case ii:
            var F = u.displayName || null;
            return F !== null ? F : En(u.type) || "Memo";
          case Na: {
            var G = u, de = G._payload, ye = G._init;
            try {
              return En(ye(de));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var oi = 0, Cl, vn, Ra, Tl, Al, Ll, Pl;
    function Nl() {
    }
    Nl.__reactDisabledLog = !0;
    function Us() {
      {
        if (oi === 0) {
          Cl = console.log, vn = console.info, Ra = console.warn, Tl = console.error, Al = console.group, Ll = console.groupCollapsed, Pl = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: Nl,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        oi++;
      }
    }
    function Ks() {
      {
        if (oi--, oi === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: pr({}, u, {
              value: Cl
            }),
            info: pr({}, u, {
              value: vn
            }),
            warn: pr({}, u, {
              value: Ra
            }),
            error: pr({}, u, {
              value: Tl
            }),
            group: pr({}, u, {
              value: Al
            }),
            groupCollapsed: pr({}, u, {
              value: Ll
            }),
            groupEnd: pr({}, u, {
              value: Pl
            })
          });
        }
        oi < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var yo = r.ReactCurrentDispatcher, Rl;
    function li(u, h, L) {
      {
        if (Rl === void 0)
          try {
            throw Error();
          } catch (G) {
            var F = G.stack.trim().match(/\n( *(at )?)/);
            Rl = F && F[1] || "";
          }
        return `
` + Rl + u;
      }
    }
    var si = !1, Da;
    {
      var ui = typeof WeakMap == "function" ? WeakMap : Map;
      Da = new ui();
    }
    function ci(u, h) {
      if (!u || si)
        return "";
      {
        var L = Da.get(u);
        if (L !== void 0)
          return L;
      }
      var F;
      si = !0;
      var G = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var de;
      de = yo.current, yo.current = null, Us();
      try {
        if (h) {
          var ye = function() {
            throw Error();
          };
          if (Object.defineProperty(ye.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ye, []);
            } catch (he) {
              F = he;
            }
            Reflect.construct(u, [], ye);
          } else {
            try {
              ye.call();
            } catch (he) {
              F = he;
            }
            u.call(ye.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (he) {
            F = he;
          }
          u();
        }
      } catch (he) {
        if (he && F && typeof he.stack == "string") {
          for (var Re = he.stack.split(`
`), l = F.stack.split(`
`), f = Re.length - 1, w = l.length - 1; f >= 1 && w >= 0 && Re[f] !== l[w]; )
            w--;
          for (; f >= 1 && w >= 0; f--, w--)
            if (Re[f] !== l[w]) {
              if (f !== 1 || w !== 1)
                do
                  if (f--, w--, w < 0 || Re[f] !== l[w]) {
                    var D = `
` + Re[f].replace(" at new ", " at ");
                    return u.displayName && D.includes("<anonymous>") && (D = D.replace("<anonymous>", u.displayName)), typeof u == "function" && Da.set(u, D), D;
                  }
                while (f >= 1 && w >= 0);
              break;
            }
        }
      } finally {
        si = !1, yo.current = de, Ks(), Error.prepareStackTrace = G;
      }
      var H = u ? u.displayName || u.name : "", le = H ? li(H) : "";
      return typeof u == "function" && Da.set(u, le), le;
    }
    function go(u, h, L) {
      return ci(u, !0);
    }
    function Ys(u, h, L) {
      return ci(u, !1);
    }
    function Dl(u) {
      var h = u.prototype;
      return !!(h && h.isReactComponent);
    }
    function _l(u, h, L) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return ci(u, Dl(u));
      if (typeof u == "string")
        return li(u);
      switch (u) {
        case ri:
          return li("Suspense");
        case ai:
          return li("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case ho:
            return Ys(u.render);
          case ii:
            return _l(u.type, h, L);
          case Na: {
            var F = u, G = F._payload, de = F._init;
            try {
              return _l(de(G), h, L);
            } catch {
            }
          }
        }
      return "";
    }
    var Ol = {}, Gs = r.ReactDebugCurrentFrame;
    function _a(u) {
      if (u) {
        var h = u._owner, L = _l(u.type, u._source, h ? h.type : null);
        Gs.setExtraStackFrame(L);
      } else
        Gs.setExtraStackFrame(null);
    }
    function Fl(u, h, L, F, G) {
      {
        var de = Function.call.bind(te);
        for (var ye in u)
          if (de(u, ye)) {
            var Re = void 0;
            try {
              if (typeof u[ye] != "function") {
                var l = Error((F || "React class") + ": " + L + " type `" + ye + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[ye] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw l.name = "Invariant Violation", l;
              }
              Re = u[ye](h, ye, F, L, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (f) {
              Re = f;
            }
            Re && !(Re instanceof Error) && (_a(G), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", F || "React class", L, ye, typeof Re), _a(null)), Re instanceof Error && !(Re.message in Ol) && (Ol[Re.message] = !0, _a(G), i("Failed %s type: %s", L, Re.message), _a(null));
          }
      }
    }
    var vo;
    vo = {};
    var aa = {};
    Object.freeze(aa);
    function Ml(u, h) {
      {
        var L = u.contextTypes;
        if (!L)
          return aa;
        var F = {};
        for (var G in L)
          F[G] = h[G];
        {
          var de = En(u) || "Unknown";
          Fl(L, F, "context", de);
        }
        return F;
      }
    }
    function zl(u, h, L, F) {
      {
        if (typeof u.getChildContext != "function") {
          {
            var G = En(h) || "Unknown";
            vo[G] || (vo[G] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", G, G));
          }
          return L;
        }
        var de = u.getChildContext();
        for (var ye in de)
          if (!(ye in F))
            throw new Error((En(h) || "Unknown") + '.getChildContext(): key "' + ye + '" is not defined in childContextTypes.');
        {
          var Re = En(h) || "Unknown";
          Fl(F, de, "child context", Re);
        }
        return pr({}, L, de);
      }
    }
    var Vr;
    Vr = {};
    var Xs = null, ia = null;
    function oa(u) {
      u.context._currentValue = u.parentValue;
    }
    function Bl(u) {
      u.context._currentValue = u.value;
    }
    function kr(u, h) {
      if (u !== h) {
        oa(u);
        var L = u.parent, F = h.parent;
        if (L === null) {
          if (F !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (F === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          kr(L, F);
        }
        Bl(h);
      }
    }
    function xo(u) {
      oa(u);
      var h = u.parent;
      h !== null && xo(h);
    }
    function bo(u) {
      var h = u.parent;
      h !== null && bo(h), Bl(u);
    }
    function di(u, h) {
      oa(u);
      var L = u.parent;
      if (L === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      L.depth === h.depth ? kr(L, h) : di(L, h);
    }
    function $l(u, h) {
      var L = h.parent;
      if (L === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      u.depth === L.depth ? kr(u, L) : $l(u, L), Bl(h);
    }
    function fi(u) {
      var h = ia, L = u;
      h !== L && (h === null ? bo(L) : L === null ? xo(h) : h.depth === L.depth ? kr(h, L) : h.depth > L.depth ? di(h, L) : $l(h, L), ia = L);
    }
    function qs(u, h) {
      var L;
      L = u._currentValue, u._currentValue = h, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== Vr && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = Vr;
      var F = ia, G = {
        parent: F,
        depth: F === null ? 0 : F.depth + 1,
        context: u,
        parentValue: L,
        value: h
      };
      return ia = G, G;
    }
    function Zs(u) {
      var h = ia;
      if (h === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      h.context !== u && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var L = h.parentValue;
        L === Jc ? h.context._currentValue = h.context._defaultValue : h.context._currentValue = L, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== Vr && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = Vr;
      }
      return ia = h.parent;
    }
    function Eo() {
      return ia;
    }
    function pi(u) {
      var h = u._currentValue;
      return h;
    }
    function Il(u) {
      return u._reactInternals;
    }
    function nd(u, h) {
      u._reactInternals = h;
    }
    var Oa = {}, So = {}, Hl, ko, wo, hi, Co, Fa, mi, To, Ma;
    {
      Hl = /* @__PURE__ */ new Set(), ko = /* @__PURE__ */ new Set(), wo = /* @__PURE__ */ new Set(), mi = /* @__PURE__ */ new Set(), hi = /* @__PURE__ */ new Set(), To = /* @__PURE__ */ new Set(), Ma = /* @__PURE__ */ new Set();
      var Ao = /* @__PURE__ */ new Set();
      Fa = function(u, h) {
        if (!(u === null || typeof u == "function")) {
          var L = h + "_" + u;
          Ao.has(L) || (Ao.add(L), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", h, u));
        }
      }, Co = function(u, h) {
        if (h === void 0) {
          var L = En(u) || "Component";
          hi.has(L) || (hi.add(L), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", L));
        }
      };
    }
    function Lo(u, h) {
      {
        var L = u.constructor, F = L && En(L) || "ReactClass", G = F + "." + h;
        if (Oa[G])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, h, h, F), Oa[G] = !0;
      }
    }
    var Po = {
      isMounted: function(u) {
        return !1;
      },
      enqueueSetState: function(u, h, L) {
        var F = Il(u);
        F.queue === null ? Lo(u, "setState") : (F.queue.push(h), L != null && Fa(L, "setState"));
      },
      enqueueReplaceState: function(u, h, L) {
        var F = Il(u);
        F.replace = !0, F.queue = [h], L != null && Fa(L, "setState");
      },
      enqueueForceUpdate: function(u, h) {
        var L = Il(u);
        L.queue === null ? Lo(u, "forceUpdate") : h != null && Fa(h, "setState");
      }
    };
    function Qs(u, h, L, F, G) {
      var de = L(G, F);
      Co(h, de);
      var ye = de == null ? F : pr({}, F, de);
      return ye;
    }
    function Js(u, h, L) {
      var F = aa, G = u.contextType;
      if ("contextType" in u) {
        var de = (
          // Allow null for conditional declaration
          G === null || G !== void 0 && G.$$typeof === po && G._context === void 0
        );
        if (!de && !Ma.has(u)) {
          Ma.add(u);
          var ye = "";
          G === void 0 ? ye = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof G != "object" ? ye = " However, it is set to a " + typeof G + "." : G.$$typeof === fo ? ye = " Did you accidentally pass the Context.Provider instead?" : G._context !== void 0 ? ye = " Did you accidentally pass the Context.Consumer instead?" : ye = " However, it is set to an object with keys {" + Object.keys(G).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", En(u) || "Component", ye);
        }
      }
      typeof G == "object" && G !== null ? F = pi(G) : F = L;
      var Re = new u(h, F);
      {
        if (typeof u.getDerivedStateFromProps == "function" && (Re.state === null || Re.state === void 0)) {
          var l = En(u) || "Component";
          Hl.has(l) || (Hl.add(l), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", l, Re.state === null ? "null" : "undefined", l));
        }
        if (typeof u.getDerivedStateFromProps == "function" || typeof Re.getSnapshotBeforeUpdate == "function") {
          var f = null, w = null, D = null;
          if (typeof Re.componentWillMount == "function" && Re.componentWillMount.__suppressDeprecationWarning !== !0 ? f = "componentWillMount" : typeof Re.UNSAFE_componentWillMount == "function" && (f = "UNSAFE_componentWillMount"), typeof Re.componentWillReceiveProps == "function" && Re.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? w = "componentWillReceiveProps" : typeof Re.UNSAFE_componentWillReceiveProps == "function" && (w = "UNSAFE_componentWillReceiveProps"), typeof Re.componentWillUpdate == "function" && Re.componentWillUpdate.__suppressDeprecationWarning !== !0 ? D = "componentWillUpdate" : typeof Re.UNSAFE_componentWillUpdate == "function" && (D = "UNSAFE_componentWillUpdate"), f !== null || w !== null || D !== null) {
            var H = En(u) || "Component", le = typeof u.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            wo.has(H) || (wo.add(H), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, H, le, f !== null ? `
  ` + f : "", w !== null ? `
  ` + w : "", D !== null ? `
  ` + D : ""));
          }
        }
      }
      return Re;
    }
    function eu(u, h, L) {
      {
        var F = En(h) || "Component", G = u.render;
        G || (h.prototype && typeof h.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", F) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", F)), u.getInitialState && !u.getInitialState.isReactClassApproved && !u.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", F), u.getDefaultProps && !u.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", F), u.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", F), u.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", F), u.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", F), h.contextType && h.contextTypes && !To.has(h) && (To.add(h), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", F)), typeof u.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", F), h.prototype && h.prototype.isPureReactComponent && typeof u.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", En(h) || "A pure component"), typeof u.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", F), typeof u.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", F), typeof u.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", F), typeof u.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", F);
        var de = u.props !== L;
        u.props !== void 0 && de && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", F, F), u.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", F, F), typeof u.getSnapshotBeforeUpdate == "function" && typeof u.componentDidUpdate != "function" && !ko.has(h) && (ko.add(h), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", En(h))), typeof u.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", F), typeof u.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", F), typeof h.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", F);
        var ye = u.state;
        ye && (typeof ye != "object" || pn(ye)) && i("%s.state: must be set to an object or null", F), typeof u.getChildContext == "function" && typeof h.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", F);
      }
    }
    function rd(u, h) {
      var L = h.state;
      if (typeof h.componentWillMount == "function") {
        if (h.componentWillMount.__suppressDeprecationWarning !== !0) {
          var F = En(u) || "Unknown";
          So[F] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            F
          ), So[F] = !0);
        }
        h.componentWillMount();
      }
      typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(), L !== h.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", En(u) || "Component"), Po.enqueueReplaceState(h, h.state, null));
    }
    function ad(u, h, L, F) {
      if (u.queue !== null && u.queue.length > 0) {
        var G = u.queue, de = u.replace;
        if (u.queue = null, u.replace = !1, de && G.length === 1)
          h.state = G[0];
        else {
          for (var ye = de ? G[0] : h.state, Re = !0, l = de ? 1 : 0; l < G.length; l++) {
            var f = G[l], w = typeof f == "function" ? f.call(h, ye, L, F) : f;
            w != null && (Re ? (Re = !1, ye = pr({}, ye, w)) : pr(ye, w));
          }
          h.state = ye;
        }
      } else
        u.queue = null;
    }
    function tu(u, h, L, F) {
      eu(u, h, L);
      var G = u.state !== void 0 ? u.state : null;
      u.updater = Po, u.props = L, u.state = G;
      var de = {
        queue: [],
        replace: !1
      };
      nd(u, de);
      var ye = h.contextType;
      if (typeof ye == "object" && ye !== null ? u.context = pi(ye) : u.context = F, u.state === L) {
        var Re = En(h) || "Component";
        mi.has(Re) || (mi.add(Re), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Re));
      }
      var l = h.getDerivedStateFromProps;
      typeof l == "function" && (u.state = Qs(u, h, l, G, L)), typeof h.getDerivedStateFromProps != "function" && typeof u.getSnapshotBeforeUpdate != "function" && (typeof u.UNSAFE_componentWillMount == "function" || typeof u.componentWillMount == "function") && (rd(h, u), ad(de, u, L, F));
    }
    var id = {
      id: 1,
      overflow: ""
    };
    function od(u) {
      var h = u.overflow, L = u.id, F = L & ~ld(L);
      return F.toString(32) + h;
    }
    function No(u, h, L) {
      var F = u.id, G = u.overflow, de = Ro(F) - 1, ye = F & ~(1 << de), Re = L + 1, l = Ro(h) + de;
      if (l > 30) {
        var f = de - de % 5, w = (1 << f) - 1, D = (ye & w).toString(32), H = ye >> f, le = de - f, he = Ro(h) + le, Pe = Re << le, Be = Pe | H, ot = D + G;
        return {
          id: 1 << he | Be,
          overflow: ot
        };
      } else {
        var dt = Re << de, kt = dt | ye, yn = G;
        return {
          id: 1 << l | kt,
          overflow: yn
        };
      }
    }
    function Ro(u) {
      return 32 - Vl(u);
    }
    function ld(u) {
      return 1 << Ro(u) - 1;
    }
    var Vl = Math.clz32 ? Math.clz32 : ud, Do = Math.log, sd = Math.LN2;
    function ud(u) {
      var h = u >>> 0;
      return h === 0 ? 32 : 31 - (Do(h) / sd | 0) | 0;
    }
    function cd(u, h) {
      return u === h && (u !== 0 || 1 / u === 1 / h) || u !== u && h !== h;
    }
    var dd = typeof Object.is == "function" ? Object.is : cd, Rr = null, Wl = null, _o = null, Vt = null, la = !1, sa = !1, en = 0, hr = null, ua = 0, Oo = 25, Vn = !1, Dr;
    function ca() {
      if (Rr === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Vn && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Rr;
    }
    function wr(u, h) {
      if (h === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Dr), !1;
      u.length !== h.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Dr, "[" + u.join(", ") + "]", "[" + h.join(", ") + "]");
      for (var L = 0; L < h.length && L < u.length; L++)
        if (!dd(u[L], h[L]))
          return !1;
      return !0;
    }
    function da() {
      if (ua > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function _r() {
      return Vt === null ? _o === null ? (la = !1, _o = Vt = da()) : (la = !0, Vt = _o) : Vt.next === null ? (la = !1, Vt = Vt.next = da()) : (la = !0, Vt = Vt.next), Vt;
    }
    function fd(u, h) {
      Rr = h, Wl = u, Vn = !1, en = 0;
    }
    function nu(u, h, L, F) {
      for (; sa; )
        sa = !1, en = 0, ua += 1, Vt = null, L = u(h, F);
      return jl(), L;
    }
    function Fo() {
      var u = en !== 0;
      return u;
    }
    function jl() {
      Vn = !1, Rr = null, Wl = null, sa = !1, _o = null, ua = 0, hr = null, Vt = null;
    }
    function pd(u) {
      return Vn && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), pi(u);
    }
    function ru(u) {
      return Dr = "useContext", ca(), pi(u);
    }
    function yi(u, h) {
      return typeof h == "function" ? h(u) : h;
    }
    function hd(u) {
      return Dr = "useState", au(
        yi,
        // useReducer has a special case to support lazy useState initializers
        u
      );
    }
    function au(u, h, L) {
      if (u !== yi && (Dr = "useReducer"), Rr = ca(), Vt = _r(), la) {
        var F = Vt.queue, G = F.dispatch;
        if (hr !== null) {
          var de = hr.get(F);
          if (de !== void 0) {
            hr.delete(F);
            var ye = Vt.memoizedState, Re = de;
            do {
              var l = Re.action;
              Vn = !0, ye = u(ye, l), Vn = !1, Re = Re.next;
            } while (Re !== null);
            return Vt.memoizedState = ye, [ye, G];
          }
        }
        return [Vt.memoizedState, G];
      } else {
        Vn = !0;
        var f;
        u === yi ? f = typeof h == "function" ? h() : h : f = L !== void 0 ? L(h) : h, Vn = !1, Vt.memoizedState = f;
        var w = Vt.queue = {
          last: null,
          dispatch: null
        }, D = w.dispatch = ou.bind(null, Rr, w);
        return [Vt.memoizedState, D];
      }
    }
    function Mo(u, h) {
      Rr = ca(), Vt = _r();
      var L = h === void 0 ? null : h;
      if (Vt !== null) {
        var F = Vt.memoizedState;
        if (F !== null && L !== null) {
          var G = F[1];
          if (wr(L, G))
            return F[0];
        }
      }
      Vn = !0;
      var de = u();
      return Vn = !1, Vt.memoizedState = [de, L], de;
    }
    function md(u) {
      Rr = ca(), Vt = _r();
      var h = Vt.memoizedState;
      if (h === null) {
        var L = {
          current: u
        };
        return Object.seal(L), Vt.memoizedState = L, L;
      } else
        return h;
    }
    function iu(u, h) {
      Dr = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function ou(u, h, L) {
      if (ua >= Oo)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (u === Rr) {
        sa = !0;
        var F = {
          action: L,
          next: null
        };
        hr === null && (hr = /* @__PURE__ */ new Map());
        var G = hr.get(h);
        if (G === void 0)
          hr.set(h, F);
        else {
          for (var de = G; de.next !== null; )
            de = de.next;
          de.next = F;
        }
      }
    }
    function yd(u, h) {
      return Mo(function() {
        return u;
      }, h);
    }
    function gd(u, h, L) {
      return ca(), h(u._source);
    }
    function vd(u, h, L) {
      if (L === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return L();
    }
    function xd(u) {
      return ca(), u;
    }
    function bd() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function Ed() {
      return ca(), [!1, bd];
    }
    function Sd() {
      var u = Wl, h = od(u.treeContext), L = Ul;
      if (L === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var F = en++;
      return Ln(L, h, F);
    }
    function zo() {
    }
    var lu = {
      readContext: pd,
      useContext: ru,
      useMemo: Mo,
      useReducer: au,
      useRef: md,
      useState: hd,
      useInsertionEffect: zo,
      useLayoutEffect: iu,
      useCallback: yd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: zo,
      // Effects are not run in the server environment.
      useEffect: zo,
      // Debugging effect
      useDebugValue: zo,
      useDeferredValue: xd,
      useTransition: Ed,
      useId: Sd,
      // Subscriptions are not setup in a server environment.
      useMutableSource: gd,
      useSyncExternalStore: vd
    }, Ul = null;
    function gi(u) {
      Ul = u;
    }
    function su(u) {
      try {
        var h = "", L = u;
        do {
          switch (L.tag) {
            case 0:
              h += li(L.type, null, null);
              break;
            case 1:
              h += Ys(L.type, null, null);
              break;
            case 2:
              h += go(L.type, null, null);
              break;
          }
          L = L.parent;
        } while (L);
        return h;
      } catch (F) {
        return `
Error generating stack: ` + F.message + `
` + F.stack;
      }
    }
    var vi = r.ReactCurrentDispatcher, Bo = r.ReactDebugCurrentFrame, Kl = 0, Wr = 1, $o = 2, Io = 3, fa = 4, uu = 0, Yl = 1, pa = 2, kd = 12800;
    function cu(u) {
      return console.error(u), null;
    }
    function Cr() {
    }
    function wd(u, h, L, F, G, de, ye, Re, l) {
      var f = [], w = /* @__PURE__ */ new Set(), D = {
        destination: null,
        responseState: h,
        progressiveChunkSize: F === void 0 ? kd : F,
        status: uu,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: w,
        pingedTasks: f,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: G === void 0 ? cu : G,
        onAllReady: de === void 0 ? Cr : de,
        onShellReady: ye === void 0 ? Cr : ye,
        onShellError: Re === void 0 ? Cr : Re,
        onFatalError: l === void 0 ? Cr : l
      }, H = Ho(
        D,
        0,
        null,
        L,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      H.parentFlushed = !0;
      var le = Gl(D, u, null, H, w, aa, Xs, id);
      return f.push(le), D;
    }
    function Cd(u, h) {
      var L = u.pingedTasks;
      L.push(h), L.length === 1 && d(function() {
        return wi(u);
      });
    }
    function xi(u, h) {
      return {
        id: On,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: h,
        errorDigest: null
      };
    }
    function Gl(u, h, L, F, G, de, ye, Re) {
      u.allPendingTasks++, L === null ? u.pendingRootTasks++ : L.pendingTasks++;
      var l = {
        node: h,
        ping: function() {
          return Cd(u, l);
        },
        blockedBoundary: L,
        blockedSegment: F,
        abortSet: G,
        legacyContext: de,
        context: ye,
        treeContext: Re
      };
      return l.componentStack = null, G.add(l), l;
    }
    function Ho(u, h, L, F, G, de) {
      return {
        status: Kl,
        id: -1,
        // lazily assigned later
        index: h,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: F,
        boundary: L,
        lastPushedText: G,
        textEmbedded: de
      };
    }
    var Or = null;
    function bi() {
      return Or === null || Or.componentStack === null ? "" : su(Or.componentStack);
    }
    function jr(u, h) {
      u.componentStack = {
        tag: 0,
        parent: u.componentStack,
        type: h
      };
    }
    function Tr(u, h) {
      u.componentStack = {
        tag: 1,
        parent: u.componentStack,
        type: h
      };
    }
    function Xl(u, h) {
      u.componentStack = {
        tag: 2,
        parent: u.componentStack,
        type: h
      };
    }
    function mr(u) {
      u.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : u.componentStack = u.componentStack.parent;
    }
    var za = null;
    function ql(u, h) {
      {
        var L;
        typeof h == "string" ? L = h : h && typeof h.message == "string" ? L = h.message : L = String(h);
        var F = za || bi();
        za = null, u.errorMessage = L, u.errorComponentStack = F;
      }
    }
    function yr(u, h) {
      var L = u.onError(h);
      if (L != null && typeof L != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof L + '" instead');
      return L;
    }
    function Ur(u, h) {
      var L = u.onShellError;
      L(h);
      var F = u.onFatalError;
      F(h), u.destination !== null ? (u.status = pa, v(u.destination, h)) : (u.status = Yl, u.fatalError = h);
    }
    function Zl(u, h, L) {
      jr(h, "Suspense");
      var F = h.blockedBoundary, G = h.blockedSegment, de = L.fallback, ye = L.children, Re = /* @__PURE__ */ new Set(), l = xi(u, Re), f = G.chunks.length, w = Ho(
        u,
        f,
        l,
        G.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      G.children.push(w), G.lastPushedText = !1;
      var D = Ho(
        u,
        0,
        null,
        G.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      D.parentFlushed = !0, h.blockedBoundary = l, h.blockedSegment = D;
      try {
        if (os(u, h, ye), we(D.chunks, u.responseState, D.lastPushedText, D.textEmbedded), D.status = Wr, jo(l, D), l.pendingTasks === 0) {
          mr(h);
          return;
        }
      } catch (le) {
        D.status = fa, l.forceClientRender = !0, l.errorDigest = yr(u, le), ql(l, le);
      } finally {
        h.blockedBoundary = F, h.blockedSegment = G;
      }
      var H = Gl(u, de, F, w, Re, h.legacyContext, h.context, h.treeContext);
      H.componentStack = h.componentStack, u.pingedTasks.push(H), mr(h);
    }
    function Ei(u, h, L, F) {
      jr(h, L);
      var G = h.blockedSegment, de = Za(G.chunks, L, F, u.responseState, G.formatContext);
      G.lastPushedText = !1;
      var ye = G.formatContext;
      G.formatContext = wn(ye, L, F), os(u, h, de), G.formatContext = ye, Ji(G.chunks, L), G.lastPushedText = !1, mr(h);
    }
    function Vo(u) {
      return u.prototype && u.prototype.isReactComponent;
    }
    function du(u, h, L, F, G) {
      var de = {};
      fd(h, de);
      var ye = L(F, G);
      return nu(L, F, ye, G);
    }
    function fu(u, h, L, F, G) {
      var de = L.render();
      L.props !== G && (ki || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", En(F) || "a component"), ki = !0);
      {
        var ye = F.childContextTypes;
        if (ye != null) {
          var Re = h.legacyContext, l = zl(L, F, Re, ye);
          h.legacyContext = l, ur(u, h, de), h.legacyContext = Re;
          return;
        }
      }
      ur(u, h, de);
    }
    function Td(u, h, L, F) {
      Xl(h, L);
      var G = Ml(L, h.legacyContext), de = Js(L, F, G);
      tu(de, L, F, G), fu(u, h, de, L, F), mr(h);
    }
    var Ql = {}, Si = {}, pu = {}, Jl = {}, ki = !1, es = !1, ts = !1, ns = !1;
    function hu(u, h, L, F) {
      var G;
      if (G = Ml(L, h.legacyContext), Tr(h, L), L.prototype && typeof L.prototype.render == "function") {
        var de = En(L) || "Unknown";
        Ql[de] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", de, de), Ql[de] = !0);
      }
      var ye = du(u, h, L, F, G), Re = Fo();
      if (typeof ye == "object" && ye !== null && typeof ye.render == "function" && ye.$$typeof === void 0) {
        var l = En(L) || "Unknown";
        Si[l] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", l, l, l), Si[l] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof ye == "object" && ye !== null && typeof ye.render == "function" && ye.$$typeof === void 0
      ) {
        {
          var f = En(L) || "Unknown";
          Si[f] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", f, f, f), Si[f] = !0);
        }
        tu(ye, L, F, G), fu(u, h, ye, L, F);
      } else if (mu(L), Re) {
        var w = h.treeContext, D = 1, H = 0;
        h.treeContext = No(w, D, H);
        try {
          ur(u, h, ye);
        } finally {
          h.treeContext = w;
        }
      } else
        ur(u, h, ye);
      mr(h);
    }
    function mu(u) {
      {
        if (u && u.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", u.displayName || u.name || "Component"), typeof u.getDerivedStateFromProps == "function") {
          var h = En(u) || "Unknown";
          Jl[h] || (i("%s: Function components do not support getDerivedStateFromProps.", h), Jl[h] = !0);
        }
        if (typeof u.contextType == "object" && u.contextType !== null) {
          var L = En(u) || "Unknown";
          pu[L] || (i("%s: Function components do not support contextType.", L), pu[L] = !0);
        }
      }
    }
    function rs(u, h) {
      if (u && u.defaultProps) {
        var L = pr({}, h), F = u.defaultProps;
        for (var G in F)
          L[G] === void 0 && (L[G] = F[G]);
        return L;
      }
      return h;
    }
    function Ad(u, h, L, F, G) {
      Tr(h, L.render);
      var de = du(u, h, L.render, F, G), ye = Fo();
      if (ye) {
        var Re = h.treeContext, l = 1, f = 0;
        h.treeContext = No(Re, l, f);
        try {
          ur(u, h, de);
        } finally {
          h.treeContext = Re;
        }
      } else
        ur(u, h, de);
      mr(h);
    }
    function Ld(u, h, L, F, G) {
      var de = L.type, ye = rs(de, F);
      as(u, h, de, ye, G);
    }
    function yu(u, h, L, F) {
      L._context === void 0 ? L !== L.Consumer && (ns || (ns = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : L = L._context;
      var G = F.children;
      typeof G != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var de = pi(L), ye = G(de);
      ur(u, h, ye);
    }
    function Pd(u, h, L, F) {
      var G = L._context, de = F.value, ye = F.children, Re;
      Re = h.context, h.context = qs(G, de), ur(u, h, ye), h.context = Zs(G), Re !== h.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function Nd(u, h, L, F, G) {
      jr(h, "Lazy");
      var de = L._payload, ye = L._init, Re = ye(de), l = rs(Re, F);
      as(u, h, Re, l, G), mr(h);
    }
    function as(u, h, L, F, G) {
      if (typeof L == "function")
        if (Vo(L)) {
          Td(u, h, L, F);
          return;
        } else {
          hu(u, h, L, F);
          return;
        }
      if (typeof L == "string") {
        Ei(u, h, L, F);
        return;
      }
      switch (L) {
        case mo:
        case wl:
        case Hs:
        case Sl:
        case sr: {
          ur(u, h, F.children);
          return;
        }
        case ai: {
          jr(h, "SuspenseList"), ur(u, h, F.children), mr(h);
          return;
        }
        case kl:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case ri: {
          Zl(u, h, F);
          return;
        }
      }
      if (typeof L == "object" && L !== null)
        switch (L.$$typeof) {
          case ho: {
            Ad(u, h, L, F, G);
            return;
          }
          case ii: {
            Ld(u, h, L, F, G);
            return;
          }
          case fo: {
            Pd(u, h, L, F);
            return;
          }
          case po: {
            yu(u, h, L, F);
            return;
          }
          case Na: {
            Nd(u, h, L, F);
            return;
          }
        }
      var de = "";
      throw (L === void 0 || typeof L == "object" && L !== null && Object.keys(L).length === 0) && (de += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (L == null ? L : typeof L) + "." + de));
    }
    function Rd(u, h) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      u[Symbol.toStringTag] === "Generator" && (es || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), es = !0), u.entries === h && (ts || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), ts = !0);
    }
    function ur(u, h, L) {
      try {
        return is(u, h, L);
      } catch (F) {
        throw typeof F == "object" && F !== null && typeof F.then == "function" || (za = za !== null ? za : bi()), F;
      }
    }
    function is(u, h, L) {
      if (h.node = L, typeof L == "object" && L !== null) {
        switch (L.$$typeof) {
          case Qc: {
            var F = L, G = F.type, de = F.props, ye = F.ref;
            as(u, h, G, de, ye);
            return;
          }
          case Is:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Na: {
            var Re = L, l = Re._payload, f = Re._init, w;
            try {
              w = f(l);
            } catch (dt) {
              throw typeof dt == "object" && dt !== null && typeof dt.then == "function" && jr(h, "Lazy"), dt;
            }
            ur(u, h, w);
            return;
          }
        }
        if (pn(L)) {
          gu(u, h, L);
          return;
        }
        var D = td(L);
        if (D) {
          Rd(L, D);
          var H = D.call(L);
          if (H) {
            var le = H.next();
            if (!le.done) {
              var he = [];
              do
                he.push(le.value), le = H.next();
              while (!le.done);
              gu(u, h, he);
              return;
            }
            return;
          }
        }
        var Pe = Object.prototype.toString.call(L);
        throw new Error("Objects are not valid as a React child (found: " + (Pe === "[object Object]" ? "object with keys {" + Object.keys(L).join(", ") + "}" : Pe) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof L == "string") {
        var Be = h.blockedSegment;
        Be.lastPushedText = Zt(h.blockedSegment.chunks, L, u.responseState, Be.lastPushedText);
        return;
      }
      if (typeof L == "number") {
        var ot = h.blockedSegment;
        ot.lastPushedText = Zt(h.blockedSegment.chunks, "" + L, u.responseState, ot.lastPushedText);
        return;
      }
      typeof L == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function gu(u, h, L) {
      for (var F = L.length, G = 0; G < F; G++) {
        var de = h.treeContext;
        h.treeContext = No(de, F, G);
        try {
          os(u, h, L[G]);
        } finally {
          h.treeContext = de;
        }
      }
    }
    function cr(u, h, L) {
      var F = h.blockedSegment, G = F.chunks.length, de = Ho(
        u,
        G,
        null,
        F.formatContext,
        // Adopt the parent segment's leading text embed
        F.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      F.children.push(de), F.lastPushedText = !1;
      var ye = Gl(u, h.node, h.blockedBoundary, de, h.abortSet, h.legacyContext, h.context, h.treeContext);
      h.componentStack !== null && (ye.componentStack = h.componentStack.parent);
      var Re = ye.ping;
      L.then(Re, Re);
    }
    function os(u, h, L) {
      var F = h.blockedSegment.formatContext, G = h.legacyContext, de = h.context, ye = null;
      ye = h.componentStack;
      try {
        return ur(u, h, L);
      } catch (Re) {
        if (jl(), typeof Re == "object" && Re !== null && typeof Re.then == "function") {
          cr(u, h, Re), h.blockedSegment.formatContext = F, h.legacyContext = G, h.context = de, fi(de), h.componentStack = ye;
          return;
        } else
          throw h.blockedSegment.formatContext = F, h.legacyContext = G, h.context = de, fi(de), h.componentStack = ye, Re;
      }
    }
    function vu(u, h, L, F) {
      var G = yr(u, F);
      if (h === null ? Ur(u, F) : (h.pendingTasks--, h.forceClientRender || (h.forceClientRender = !0, h.errorDigest = G, ql(h, F), h.parentFlushed && u.clientRenderedBoundaries.push(h))), u.allPendingTasks--, u.allPendingTasks === 0) {
        var de = u.onAllReady;
        de();
      }
    }
    function Dd(u) {
      var h = this, L = u.blockedBoundary, F = u.blockedSegment;
      F.status = Io, xu(h, L, F);
    }
    function Wo(u, h, L) {
      var F = u.blockedBoundary, G = u.blockedSegment;
      if (G.status = Io, F === null)
        h.allPendingTasks--, h.status !== pa && (h.status = pa, h.destination !== null && S(h.destination));
      else {
        if (F.pendingTasks--, !F.forceClientRender) {
          F.forceClientRender = !0;
          var de = L === void 0 ? new Error("The render was aborted by the server without a reason.") : L;
          F.errorDigest = h.onError(de);
          {
            var ye = "The server did not finish this Suspense boundary: ";
            de && typeof de.message == "string" ? de = ye + de.message : de = ye + String(de);
            var Re = Or;
            Or = u;
            try {
              ql(F, de);
            } finally {
              Or = Re;
            }
          }
          F.parentFlushed && h.clientRenderedBoundaries.push(F);
        }
        if (F.fallbackAbortableTasks.forEach(function(f) {
          return Wo(f, h, L);
        }), F.fallbackAbortableTasks.clear(), h.allPendingTasks--, h.allPendingTasks === 0) {
          var l = h.onAllReady;
          l();
        }
      }
    }
    function jo(u, h) {
      if (h.chunks.length === 0 && h.children.length === 1 && h.children[0].boundary === null) {
        var L = h.children[0];
        L.id = h.id, L.parentFlushed = !0, L.status === Wr && jo(u, L);
      } else {
        var F = u.completedSegments;
        F.push(h);
      }
    }
    function xu(u, h, L) {
      if (h === null) {
        if (L.parentFlushed) {
          if (u.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          u.completedRootSegment = L;
        }
        if (u.pendingRootTasks--, u.pendingRootTasks === 0) {
          u.onShellError = Cr;
          var F = u.onShellReady;
          F();
        }
      } else if (h.pendingTasks--, !h.forceClientRender) {
        if (h.pendingTasks === 0)
          L.parentFlushed && L.status === Wr && jo(h, L), h.parentFlushed && u.completedBoundaries.push(h), h.fallbackAbortableTasks.forEach(Dd, u), h.fallbackAbortableTasks.clear();
        else if (L.parentFlushed && L.status === Wr) {
          jo(h, L);
          var G = h.completedSegments;
          G.length === 1 && h.parentFlushed && u.partialBoundaries.push(h);
        }
      }
      if (u.allPendingTasks--, u.allPendingTasks === 0) {
        var de = u.onAllReady;
        de();
      }
    }
    function bu(u, h) {
      var L = h.blockedSegment;
      if (L.status === Kl) {
        fi(h.context);
        var F = null;
        F = Or, Or = h;
        try {
          ur(u, h, h.node), we(L.chunks, u.responseState, L.lastPushedText, L.textEmbedded), h.abortSet.delete(h), L.status = Wr, xu(u, h.blockedBoundary, L);
        } catch (de) {
          if (jl(), typeof de == "object" && de !== null && typeof de.then == "function") {
            var G = h.ping;
            de.then(G, G);
          } else
            h.abortSet.delete(h), L.status = fa, vu(u, h.blockedBoundary, L, de);
        } finally {
          Or = F;
        }
      }
    }
    function wi(u) {
      if (u.status !== pa) {
        var h = Eo(), L = vi.current;
        vi.current = lu;
        var F;
        F = Bo.getCurrentStack, Bo.getCurrentStack = bi;
        var G = Ul;
        gi(u.responseState);
        try {
          var de = u.pingedTasks, ye;
          for (ye = 0; ye < de.length; ye++) {
            var Re = de[ye];
            bu(u, Re);
          }
          de.splice(0, ye), u.destination !== null && Ko(u, u.destination);
        } catch (l) {
          yr(u, l), Ur(u, l);
        } finally {
          gi(G), vi.current = L, Bo.getCurrentStack = F, L === lu && fi(h);
        }
      }
    }
    function Ci(u, h, L) {
      switch (L.parentFlushed = !0, L.status) {
        case Kl: {
          var F = L.id = u.nextSegmentId++;
          return L.lastPushedText = !1, L.textEmbedded = !1, Ea(h, u.responseState, F);
        }
        case Wr: {
          L.status = $o;
          for (var G = !0, de = L.chunks, ye = 0, Re = L.children, l = 0; l < Re.length; l++) {
            for (var f = Re[l]; ye < f.index; ye++)
              y(h, de[ye]);
            G = Uo(u, h, f);
          }
          for (; ye < de.length - 1; ye++)
            y(h, de[ye]);
          return ye < de.length && (G = x(h, de[ye])), G;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Uo(u, h, L) {
      var F = L.boundary;
      if (F === null)
        return Ci(u, h, L);
      if (F.parentFlushed = !0, F.forceClientRender)
        return Zn(h, u.responseState, F.errorDigest, F.errorMessage, F.errorComponentStack), Ci(u, h, L), gl(h, u.responseState);
      if (F.pendingTasks > 0) {
        F.rootSegmentID = u.nextSegmentId++, F.completedSegments.length > 0 && u.partialBoundaries.push(F);
        var G = F.id = Nn(u.responseState);
        return wa(h, u.responseState, G), Ci(u, h, L), Ca(h, u.responseState);
      } else {
        if (F.byteSize > u.progressiveChunkSize)
          return F.rootSegmentID = u.nextSegmentId++, u.completedBoundaries.push(F), wa(h, u.responseState, F.id), Ci(u, h, L), Ca(h, u.responseState);
        to(h, u.responseState);
        var de = F.completedSegments;
        if (de.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var ye = de[0];
        return Uo(u, h, ye), no(h, u.responseState);
      }
    }
    function Eu(u, h, L) {
      return Bs(h, u.responseState, L.id, L.errorDigest, L.errorMessage, L.errorComponentStack);
    }
    function Ti(u, h, L) {
      return Tt(h, u.responseState, L.formatContext, L.id), Uo(u, h, L), un(h, L.formatContext);
    }
    function Ai(u, h, L) {
      for (var F = L.completedSegments, G = 0; G < F.length; G++) {
        var de = F[G];
        ls(u, h, L, de);
      }
      return F.length = 0, vl(h, u.responseState, L.id, L.rootSegmentID);
    }
    function _d(u, h, L) {
      for (var F = L.completedSegments, G = 0; G < F.length; G++) {
        var de = F[G];
        if (!ls(u, h, L, de))
          return G++, F.splice(0, G), !1;
      }
      return F.splice(0, G), !0;
    }
    function ls(u, h, L, F) {
      if (F.status === $o)
        return !0;
      var G = F.id;
      if (G === -1) {
        var de = F.id = L.rootSegmentID;
        if (de === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Ti(u, h, F);
      } else
        return Ti(u, h, F), jc(h, u.responseState, G);
    }
    function Ko(u, h) {
      m();
      try {
        var L = u.completedRootSegment;
        L !== null && u.pendingRootTasks === 0 && (Uo(u, h, L), u.completedRootSegment = null, hl(h, u.responseState));
        var F = u.clientRenderedBoundaries, G;
        for (G = 0; G < F.length; G++) {
          var de = F[G];
          Eu(u, h, de);
        }
        F.splice(0, G);
        var ye = u.completedBoundaries;
        for (G = 0; G < ye.length; G++) {
          var Re = ye[G];
          Ai(u, h, Re);
        }
        ye.splice(0, G), T(h), m(h);
        var l = u.partialBoundaries;
        for (G = 0; G < l.length; G++) {
          var f = l[G];
          if (!_d(u, h, f)) {
            u.destination = null, G++, l.splice(0, G);
            return;
          }
        }
        l.splice(0, G);
        var w = u.completedBoundaries;
        for (G = 0; G < w.length; G++) {
          var D = w[G];
          Ai(u, h, D);
        }
        w.splice(0, G);
      } finally {
        T(h), u.allPendingTasks === 0 && u.pingedTasks.length === 0 && u.clientRenderedBoundaries.length === 0 && u.completedBoundaries.length === 0 && (u.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), S(h));
      }
    }
    function Od(u) {
      d(function() {
        return wi(u);
      });
    }
    function Su(u, h) {
      if (u.status === Yl) {
        u.status = pa, v(h, u.fatalError);
        return;
      }
      if (u.status !== pa && u.destination === null) {
        u.destination = h;
        try {
          Ko(u, h);
        } catch (L) {
          yr(u, L), Ur(u, L);
        }
      }
    }
    function Yo(u, h) {
      try {
        var L = u.abortableTasks;
        L.forEach(function(F) {
          return Wo(F, u, h);
        }), L.clear(), u.destination !== null && Ko(u, u.destination);
      } catch (F) {
        yr(u, F), Ur(u, F);
      }
    }
    function Fd(u, h) {
      return new Promise(function(L, F) {
        var G, de, ye = new Promise(function(H, le) {
          de = H, G = le;
        });
        function Re() {
          var H = new ReadableStream(
            {
              type: "bytes",
              pull: function(le) {
                Su(f, le);
              },
              cancel: function(le) {
                Yo(f);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          H.allReady = ye, L(H);
        }
        function l(H) {
          ye.catch(function() {
          }), F(H);
        }
        var f = wd(u, Ot(h ? h.identifierPrefix : void 0, h ? h.nonce : void 0, h ? h.bootstrapScriptContent : void 0, h ? h.bootstrapScripts : void 0, h ? h.bootstrapModules : void 0), kn(h ? h.namespaceURI : void 0), h ? h.progressiveChunkSize : void 0, h ? h.onError : void 0, de, Re, l, G);
        if (h && h.signal) {
          var w = h.signal, D = function() {
            Yo(f, w.reason), w.removeEventListener("abort", D);
          };
          w.addEventListener("abort", D);
        }
        Od(f);
      });
    }
    Iu.renderToReadableStream = Fd, Iu.version = t;
  }()), Iu;
}
var Yi, Wf;
process.env.NODE_ENV === "production" ? (Yi = pS(), Wf = hS()) : (Yi = mS(), Wf = yS());
Ya.version = Yi.version;
Ya.renderToString = Yi.renderToString;
Ya.renderToStaticMarkup = Yi.renderToStaticMarkup;
Ya.renderToNodeStream = Yi.renderToNodeStream;
Ya.renderToStaticNodeStream = Yi.renderToStaticNodeStream;
Ya.renderToReadableStream = Wf.renderToReadableStream;
const am = ({ columnData: e }) => /* @__PURE__ */ n.createElement("ul", null, e == null ? void 0 : e.map((t, r) => /* @__PURE__ */ n.createElement("li", { key: r }, t.label, ": ", t.value, " (", t.additional_info, "%)"))), gS = (e, t) => {
  var m, y, x, T, S, A;
  const r = `${(((m = e == null ? void 0 : e.tooltips) == null ? void 0 : m.find((E) => E.node === t)) || {}).value}`, a = `${(((y = e == null ? void 0 : e.tooltips) == null ? void 0 : y.find((E) => E.node === t)) || {}).summary}`, i = (((x = e == null ? void 0 : e.tooltips) == null ? void 0 : x.find((E) => E.node === t)) || {}).column1Label, o = (((T = e == null ? void 0 : e.tooltips) == null ? void 0 : T.find((E) => E.node === t)) || {}).column2Label, d = (((S = e == null ? void 0 : e.tooltips) == null ? void 0 : S.find((E) => E.node === t)) || {}).column1, c = (((A = e == null ? void 0 : e.tooltips) == null ? void 0 : A.find((E) => E.node === t)) || {}).column2, s = Ya.renderToString(/* @__PURE__ */ n.createElement(am, { columnData: d })), p = Ya.renderToString(/* @__PURE__ */ n.createElement(am, { columnData: c }));
  return `<div class="sankey-chart__tooltip">
    <span class="sankey-chart__tooltip--tooltip-header">${t}</span>
    <span class="sankey-chart__tooltip--tooltip-header">${r}</span>
    <div class="divider"></div>
    <span><strong>Summary: </strong>${a}</span>
    <div class="divider"></div>
    <div class="sankey-chart__tooltip--info-section">
      <div>
        <span><strong>${i}</strong></span>
        ${s}
      </div>
      <div>
        <span><strong>${o}</strong></span>
        ${p}
      </div>
    </div>
  </div>
`;
}, vS = ({ width: e, height: t, runtime: r }) => {
  var J, ne;
  const { config: a } = ue.useContext(gt), { sankey: i } = a, [o, d] = ue.useState(0), [c, s] = ue.useState(""), { showAlert: p, alert: m } = fS(), y = ue.useRef([]), x = (z) => {
    const W = c;
    W && s(""), W !== z && s(z);
  };
  if (ue.useEffect(() => {
    var W;
    let z = 0;
    (W = y == null ? void 0 : y.current) == null || W.map((ie) => {
      const ae = ie == null ? void 0 : ie.getBoundingClientRect().width;
      ae > z && (z = ae);
    }), d(z);
  }, [y, i, window.innerWidth]), a.visualizationType !== "Sankey")
    return;
  const T = a == null ? void 0 : a.data[0], S = Array.from(new Set((J = T == null ? void 0 : T.links) == null ? void 0 : J.flatMap((z) => [z.source, z.target]))), A = {
    nodes: S.map((z) => ({ id: z })),
    links: (ne = T == null ? void 0 : T.links) == null ? void 0 : ne.map((z) => ({
      source: S.findIndex((W) => W === z.source),
      target: S.findIndex((W) => W === z.target),
      value: z.value
    }))
  };
  let E = 5;
  const b = 50, v = sS().nodeWidth(i.nodeSize.nodeWidth).nodePadding(i.nodePadding).iterations(i.iterations).nodeAlign(rS).extent([
    [i.margin.margin_x, Number(i.margin.margin_y)],
    [e - E - o, a.heights.vertical - b]
  ]), { links: N } = v(A), C = (z) => {
    var K;
    let W = 30, ie = 0, ae = "node-value--storynode", oe = !0;
    return (K = T == null ? void 0 : T.storyNodeText) != null && K.every((Y) => Y.StoryNode !== z) && (oe = !1, ie = 10, W = 8, ae = "node-value"), { textPositionHorizontal: W, textPositionVertical: ie, classStyle: ae, storyNodes: oe };
  }, R = (z) => {
    if (!(A != null && A.nodes))
      return { sourceNodes: [], activeLinks: [] };
    const W = A.nodes.find((oe) => oe.id === z), ie = [], ae = [];
    return W && (N.forEach((oe) => {
      const K = oe.target, Y = oe.source;
      K.id === z && ie.push(Y.id);
    }), ie.forEach((oe) => {
      N.forEach((K) => {
        const Y = K.target, X = K.source;
        Y.id === c && X.id === oe && ae.push(K);
      });
    })), { sourceNodes: ie, activeLinks: ae };
  }, _ = gS(T, c), U = A.nodes.map((z, W) => {
    var De, me;
    let { textPositionHorizontal: ie, textPositionVertical: ae, classStyle: oe, storyNodes: K } = C(z.id), { sourceNodes: Y } = R(c), X = i.opacity.nodeOpacityDefault, q = i.nodeColor.default;
    c !== z.id && c !== "" && !Y.includes(z.id) && (q = i.nodeColor.inactive, X = i.opacity.nodeOpacityInactive);
    const ce = v.nodeWidth(), ge = () => Math.sqrt(
      Math.pow(N[0].target.x0 - N[0].source.x1, 2) + Math.pow(N[0].target.y0 - N[0].source.y1, 2)
    ) - o;
    return /* @__PURE__ */ n.createElement(at, { className: "", key: W }, /* @__PURE__ */ n.createElement(
      "rect",
      {
        height: z.y1 - z.y0 + 2,
        width: ce,
        x: z.x0,
        y: z.y0 - 1,
        fill: q,
        fillOpacity: X,
        rx: i.rxValue,
        "data-tooltip-html": T.tooltips && a.enableTooltips && c !== "" ? _ : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
        onClick: () => x(z.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), K ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      vt,
      {
        width: ge(),
        x: z.x0 + ie,
        textAnchor: A.nodes.length - 1 === W ? "end" : "start",
        verticalAnchor: "end",
        y: (z.y1 + z.y0) / 2 - 30,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        className: "node-text",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(z.id),
        "data-tooltip-html": T.tooltips && a.enableTooltips && c !== "" ? _ : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      (((De = T == null ? void 0 : T.storyNodeText) == null ? void 0 : De.find((Fe) => Fe.StoryNode === z.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ n.createElement(
      vt,
      {
        width: ge(),
        verticalAnchor: "middle",
        className: oe,
        x: z.x0 + ie,
        y: (z.y1 + z.y0 + 25) / 2,
        fill: i.storyNodeFontColor || i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(z.id),
        "data-tooltip-html": T.tooltips && a.enableTooltips && c !== "" ? _ : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      typeof z.value == "number" ? z.value.toLocaleString() : z.value
    ), /* @__PURE__ */ n.createElement(
      vt,
      {
        width: ge(),
        x: z.x0 + ie,
        y: (z.y1 + z.y0) / 2 + 50,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: A.nodes.length === W ? "end" : "start",
        className: "node-text",
        verticalAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(z.id),
        "data-tooltip-html": T.tooltips && a.enableTooltips && c !== "" ? _ : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      (((me = T == null ? void 0 : T.storyNodeText) == null ? void 0 : me.find((Fe) => Fe.StoryNode === z.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      vt,
      {
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(z.id),
        "data-tooltip-html": T.tooltips && a.enableTooltips && c !== "" ? _ : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
        x: z.x0 + ie,
        y: (z.y1 + z.y0) / 2 + ae,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start"
      },
      z.id
    ), /* @__PURE__ */ n.createElement(
      "text",
      {
        x: z.x0 + ie,
        y: (z.y1 + z.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(z.id),
        "data-tooltip-html": T.tooltips && a.enableTooltips && c !== "" ? _ : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      /* @__PURE__ */ n.createElement("tspan", { className: oe }, i.nodeValueStyle.textBefore + (typeof z.value == "number" ? z.value.toLocaleString() : z.value) + i.nodeValueStyle.textAfter)
    )));
  }), j = N.map((z, W) => {
    const ae = dS()(z);
    let oe = i.opacity.LinkOpacityDefault, K = i.linkColor.default, { activeLinks: Y } = R(c);
    return !Y.includes(z) && c !== "" && (K = i.linkColor.inactive, oe = i.opacity.LinkOpacityInactive), /* @__PURE__ */ n.createElement(
      "path",
      {
        key: W,
        d: ae,
        stroke: K,
        fill: "none",
        strokeOpacity: oe,
        strokeWidth: z.width + 2,
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(z.target.id || null),
        "data-tooltip-html": T.tooltips && a.enableTooltips && c !== "" ? _ : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      }
    );
  }), te = A.nodes.reduce((z, W) => Math.max(z, W.depth), -1), $ = A.nodes.filter((z) => z.depth === te).map((z, W) => {
    var ce, ge;
    let { textPositionHorizontal: ie, textPositionVertical: ae, classStyle: oe, storyNodes: K } = C(z.id), { sourceNodes: Y } = R(c), X = i.opacity.nodeOpacityDefault, q = i.nodeColor.default;
    return c !== z.id && c !== "" && !Y.includes(z.id) && (q = i.nodeColor.inactive, X = i.opacity.nodeOpacityInactive), /* @__PURE__ */ n.createElement(at, { className: "", key: W, innerRef: (De) => y.current[W] = De }, /* @__PURE__ */ n.createElement(
      "rect",
      {
        height: z.y1 - z.y0 + 2,
        width: v.nodeWidth(),
        x: z.x0,
        y: z.y0 - 1,
        fill: q,
        fillOpacity: X,
        rx: i.rxValue,
        "data-tooltip-html": T.tooltips && a.enableTooltips && c !== "" ? _ : null,
        "data-tooltip-id": "tooltip",
        onClick: () => x(z.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), K ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      vt,
      {
        x: z.x0 + ie,
        textAnchor: A.nodes.length - 1 === W ? "end" : "start",
        verticalAnchor: "end",
        y: (z.y1 + z.y0) / 2 - 30,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        style: { pointerEvents: "none" },
        className: "node-text"
      },
      (((ce = T == null ? void 0 : T.storyNodeText) == null ? void 0 : ce.find((De) => De.StoryNode === z.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ n.createElement(
      vt,
      {
        verticalAnchor: "end",
        className: oe,
        x: z.x0 + ie,
        y: (z.y1 + z.y0 + 25) / 2,
        fill: i.storyNodeFontColor || i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      typeof z.value == "number" ? z.value.toLocaleString() : z.value
    ), /* @__PURE__ */ n.createElement(
      vt,
      {
        x: z.x0 + ie,
        y: (z.y1 + z.y0) / 2 + 50,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: A.nodes.length === W ? "end" : "start",
        style: { pointerEvents: "none" },
        className: "node-text",
        verticalAnchor: "end"
      },
      (((ge = T == null ? void 0 : T.storyNodeText) == null ? void 0 : ge.find((De) => De.StoryNode === z.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      "text",
      {
        x: z.x0 + ie,
        y: (z.y1 + z.y0) / 2 + ae,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ n.createElement("tspan", { id: z.id, className: "node-id" }, z.id)
    ), /* @__PURE__ */ n.createElement(
      "text",
      {
        x: z.x0 + ie,
        y: (z.y1 + z.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ n.createElement("tspan", { onClick: () => x(z.id), className: oe }, i.nodeValueStyle.textBefore + (typeof z.value == "number" ? z.value.toLocaleString() : z.value) + i.nodeValueStyle.textAfter)
    )));
  });
  return p ? m : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: "sankey-chart" }, /* @__PURE__ */ n.createElement(
    "svg",
    {
      className: "sankey-chart__diagram",
      width: e,
      height: Number(a.heights.vertical),
      style: { overflow: "visible" }
    },
    /* @__PURE__ */ n.createElement(at, { className: "links" }, j),
    /* @__PURE__ */ n.createElement(at, { className: "nodes" }, U),
    /* @__PURE__ */ n.createElement(at, { className: "finalNodes", style: { display: "none" } }, $)
  ), /* @__PURE__ */ n.createElement(
    vc,
    {
      id: `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
      afterHide: () => s(""),
      events: ["click"],
      place: "bottom",
      style: {
        backgroundColor: "rgba(238, 238, 238, 1)",
        color: "black",
        boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)"
      }
    }
  )));
};
var xS = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const dr = xS;
function bS(e) {
  var t = e.labelOffset, r = e.labelProps, a = e.orientation, i = e.range, o = e.tickLabelFontSize, d = e.tickLength, c = a === dr.left || a === dr.top ? -1 : 1, s, p, m;
  if (a === dr.top || a === dr.bottom) {
    var y = a === dr.bottom && typeof r.fontSize == "number" ? r.fontSize : 0;
    s = (Number(i[0]) + Number(i[i.length - 1])) / 2, p = c * (d + t + o + y);
  } else
    s = c * ((Number(i[0]) + Number(i[i.length - 1])) / 2), p = -(d + t), m = "rotate(" + c * 90 + ")";
  return {
    x: s,
    y: p,
    transform: m
  };
}
function Es() {
  return Es = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Es.apply(this, arguments);
}
function ES(e) {
  var t = e.hideTicks, r = e.horizontal, a = e.orientation, i = e.tickClassName, o = e.tickComponent, d = e.tickLabelProps, c = e.tickStroke, s = c === void 0 ? "#222" : c, p = e.tickTransform, m = e.ticks, y = e.strokeWidth, x = e.tickLineProps;
  return m.map(function(T) {
    var S, A = T.value, E = T.index, b = T.from, v = T.to, N = T.formattedValue, C = (S = d[E]) != null ? S : {}, R = Math.max(10, typeof C.fontSize == "number" && C.fontSize || 0), _ = v.y + (r && a !== dr.top ? R : 0);
    return /* @__PURE__ */ n.createElement(at, {
      key: "visx-tick-" + A + "-" + E,
      className: Dn("visx-axis-tick", i),
      transform: p
    }, !t && /* @__PURE__ */ n.createElement(cn, Es({
      from: b,
      to: v,
      stroke: s,
      strokeWidth: y,
      strokeLinecap: "square"
    }, x)), o ? o(Es({}, C, {
      x: v.x,
      y: _,
      formattedValue: N
    })) : /* @__PURE__ */ n.createElement(vt, Es({
      x: v.x,
      y: _
    }, C), N));
  });
}
function bc() {
  return bc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, bc.apply(this, arguments);
}
var im = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function SS(e) {
  var t = e.axisFromPoint, r = e.axisLineClassName, a = e.axisToPoint, i = e.hideAxisLine, o = e.hideTicks, d = e.horizontal, c = e.label, s = c === void 0 ? "" : c, p = e.labelClassName, m = e.labelOffset, y = m === void 0 ? 14 : m, x = e.labelProps, T = x === void 0 ? im : x, S = e.orientation, A = S === void 0 ? dr.bottom : S, E = e.scale, b = e.stroke, v = b === void 0 ? "#222" : b, N = e.strokeDasharray, C = e.strokeWidth, R = C === void 0 ? 1 : C, _ = e.tickClassName, U = e.tickComponent, j = e.tickLineProps, te = e.tickLabelProps, Q = e.tickLength, $ = Q === void 0 ? 8 : Q, J = e.tickStroke, ne = J === void 0 ? "#222" : J, z = e.tickTransform, W = e.ticks, ie = e.ticksComponent, ae = ie === void 0 ? ES : ie, oe = bc({}, im, typeof te == "object" ? te : null), K = W.map(function(X) {
    var q = X.value, ce = X.index;
    return typeof te == "function" ? te(q, ce, W) : oe;
  }), Y = Math.max.apply(Math, [10].concat(K.map(function(X) {
    return typeof X.fontSize == "number" ? X.fontSize : 0;
  })));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, ae({
    hideTicks: o,
    horizontal: d,
    orientation: A,
    scale: E,
    tickClassName: _,
    tickComponent: U,
    tickLabelProps: K,
    tickStroke: ne,
    tickTransform: z,
    ticks: W,
    strokeWidth: R,
    tickLineProps: j
  }), !i && /* @__PURE__ */ n.createElement(cn, {
    className: Dn("visx-axis-line", r),
    from: t,
    to: a,
    stroke: v,
    strokeWidth: R,
    strokeDasharray: N
  }), s && /* @__PURE__ */ n.createElement(vt, bc({
    className: Dn("visx-axis-label", p)
  }, bS({
    labelOffset: y,
    labelProps: T,
    orientation: A,
    range: E.range(),
    tickLabelFontSize: Y,
    tickLength: $
  }), T), s));
}
function kS(e, t) {
  t === void 0 && (t = "center");
  var r = e;
  if (t !== "start" && "bandwidth" in r) {
    var a = r.bandwidth();
    return t === "center" && (a /= 2), r.round() && (a = Math.round(a)), function(i) {
      var o = r(i);
      return typeof o == "number" ? o + a : o;
    };
  }
  return e;
}
function wS(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : Bv;
}
function Hu(e, t) {
  var r = e.x, a = e.y;
  return new Lg(t ? {
    x: r,
    y: a
  } : {
    x: a,
    y: r
  });
}
function jf() {
  return jf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, jf.apply(this, arguments);
}
var ef = 0;
function CS(e) {
  return e === void 0 && (e = ef), typeof e == "number" ? {
    start: e,
    end: e
  } : jf({
    start: ef,
    end: ef
  }, e);
}
var TS = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Uf() {
  return Uf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Uf.apply(this, arguments);
}
function AS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function $c(e) {
  var t = e.children, r = t === void 0 ? SS : t, a = e.axisClassName, i = e.hideAxisLine, o = i === void 0 ? !1 : i, d = e.hideTicks, c = d === void 0 ? !1 : d, s = e.hideZero, p = s === void 0 ? !1 : s, m = e.innerRef, y = e.left, x = y === void 0 ? 0 : y, T = e.numTicks, S = T === void 0 ? 10 : T, A = e.orientation, E = A === void 0 ? dr.bottom : A, b = e.rangePadding, v = b === void 0 ? 0 : b, N = e.scale, C = e.tickFormat, R = e.tickLength, _ = R === void 0 ? 8 : R, U = e.tickValues, j = e.top, te = j === void 0 ? 0 : j, Q = AS(e, TS), $ = C ?? wS(N), J = E === dr.left, ne = E === dr.top, z = ne || E === dr.bottom, W = kS(N), ie = J || ne ? -1 : 1, ae = N.range(), oe = CS(v), K = Hu({
    x: Number(ae[0]) + 0.5 - oe.start,
    y: 0
  }, z), Y = Hu({
    x: Number(ae[ae.length - 1]) + 0.5 + oe.end,
    y: 0
  }, z), X = (U ?? Ym(N, S)).filter(function(ce) {
    return !p || ce !== 0 && ce !== "0";
  }).map(function(ce, ge) {
    return {
      value: ce,
      index: ge
    };
  }), q = X.map(function(ce) {
    var ge = ce.value, De = ce.index, me = zv(W(ge));
    return {
      value: ge,
      index: De,
      from: Hu({
        x: me,
        y: 0
      }, z),
      to: Hu({
        x: me,
        y: _ * ie
      }, z),
      formattedValue: $(ge, De, X)
    };
  });
  return /* @__PURE__ */ n.createElement(at, {
    className: Dn("visx-axis", a),
    innerRef: m,
    top: te,
    left: x
  }, r(Uf({}, Q, {
    axisFromPoint: K,
    axisToPoint: Y,
    hideAxisLine: o,
    hideTicks: c,
    hideZero: p,
    horizontal: z,
    numTicks: S,
    orientation: E,
    rangePadding: v,
    scale: N,
    tickFormat: $,
    tickLength: _,
    tickPosition: W,
    tickSign: ie,
    ticks: q
  })));
}
var LS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Ec() {
  return Ec = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ec.apply(this, arguments);
}
function PS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var NS = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function om(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 36 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = PS(e, LS), s = typeof d == "function" ? d : Ec({}, NS, d);
  return /* @__PURE__ */ n.createElement($c, Ec({
    axisClassName: Dn("visx-axis-left", t),
    labelOffset: a,
    orientation: dr.left,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var RS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Sc() {
  return Sc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Sc.apply(this, arguments);
}
function DS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var _S = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function OS(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 36 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = DS(e, RS), s = typeof d == "function" ? d : Sc({}, _S, d);
  return /* @__PURE__ */ n.createElement($c, Sc({
    axisClassName: Dn("visx-axis-right", t),
    labelOffset: a,
    orientation: dr.right,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var FS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function kc() {
  return kc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, kc.apply(this, arguments);
}
function MS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var zS = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function BS(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 8 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = MS(e, FS), s = typeof d == "function" ? d : kc({}, zS, d);
  return /* @__PURE__ */ n.createElement($c, kc({
    axisClassName: Dn("visx-axis-top", t),
    labelOffset: a,
    orientation: dr.top,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var $S = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function wc() {
  return wc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, wc.apply(this, arguments);
}
function IS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var HS = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function Gu(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 8 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = IS(e, $S), s = typeof d == "function" ? d : wc({}, HS, d);
  return /* @__PURE__ */ n.createElement($c, wc({
    axisClassName: Dn("visx-axis-bottom", t),
    labelOffset: a,
    orientation: dr.bottom,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
const tf = (e) => () => e;
function VS(e, {
  sourceEvent: t,
  target: r,
  selection: a,
  mode: i,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    selection: { value: a, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function WS(e) {
  e.stopImmediatePropagation();
}
function nf(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var lm = { name: "drag" }, rf = { name: "space" }, Jo = { name: "handle" }, el = { name: "center" };
const { abs: sm, max: tr, min: nr } = Math;
function um(e) {
  return [+e[0], +e[1]];
}
function cm(e) {
  return [um(e[0]), um(e[1])];
}
var Xu = {
  name: "x",
  handles: ["w", "e"].map(Cc),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, af = {
  name: "y",
  handles: ["n", "s"].map(Cc),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, ha = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, dm = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, fm = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, jS = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, US = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Cc(e) {
  return { type: e };
}
function KS(e) {
  return !e.ctrlKey && !e.button;
}
function YS() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function GS() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function of(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function XS(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function qS() {
  return ZS(Xu);
}
function ZS(e) {
  var t = YS, r = KS, a = GS, i = !0, o = Pg("start", "brush", "end"), d = 6, c;
  function s(E) {
    var b = E.property("__brush", A).selectAll(".overlay").data([Cc("overlay")]);
    b.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", ha.overlay).merge(b).each(function() {
      var N = of(this).extent;
      tl(this).attr("x", N[0][0]).attr("y", N[0][1]).attr("width", N[1][0] - N[0][0]).attr("height", N[1][1] - N[0][1]);
    }), E.selectAll(".selection").data([Cc("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", ha.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var v = E.selectAll(".handle").data(e.handles, function(N) {
      return N.type;
    });
    v.exit().remove(), v.enter().append("rect").attr("class", function(N) {
      return "handle handle--" + N.type;
    }).attr("cursor", function(N) {
      return ha[N.type];
    }), E.each(p).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", x).filter(a).on("touchstart.brush", x).on("touchmove.brush", T).on("touchend.brush touchcancel.brush", S).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  s.move = function(E, b, v) {
    E.tween ? E.on("start.brush", function(N) {
      m(this, arguments).beforestart().start(N);
    }).on("interrupt.brush end.brush", function(N) {
      m(this, arguments).end(N);
    }).tween("brush", function() {
      var N = this, C = N.__brush, R = m(N, arguments), _ = C.selection, U = e.input(typeof b == "function" ? b.apply(this, arguments) : b, C.extent), j = iv(_, U);
      function te(Q) {
        C.selection = Q === 1 && U === null ? null : j(Q), p.call(N), R.brush();
      }
      return _ !== null && U !== null ? te : te(1);
    }) : E.each(function() {
      var N = this, C = arguments, R = N.__brush, _ = e.input(typeof b == "function" ? b.apply(N, C) : b, R.extent), U = m(N, C).beforestart();
      Op(N), R.selection = _ === null ? null : _, p.call(N), U.start(v).brush(v).end(v);
    });
  }, s.clear = function(E, b) {
    s.move(E, null, b);
  };
  function p() {
    var E = tl(this), b = of(this).selection;
    b ? (E.selectAll(".selection").style("display", null).attr("x", b[0][0]).attr("y", b[0][1]).attr("width", b[1][0] - b[0][0]).attr("height", b[1][1] - b[0][1]), E.selectAll(".handle").style("display", null).attr("x", function(v) {
      return v.type[v.type.length - 1] === "e" ? b[1][0] - d / 2 : b[0][0] - d / 2;
    }).attr("y", function(v) {
      return v.type[0] === "s" ? b[1][1] - d / 2 : b[0][1] - d / 2;
    }).attr("width", function(v) {
      return v.type === "n" || v.type === "s" ? b[1][0] - b[0][0] + d : d;
    }).attr("height", function(v) {
      return v.type === "e" || v.type === "w" ? b[1][1] - b[0][1] + d : d;
    })) : E.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function m(E, b, v) {
    var N = E.__brush.emitter;
    return N && (!v || !N.clean) ? N : new y(E, b, v);
  }
  function y(E, b, v) {
    this.that = E, this.args = b, this.state = E.__brush, this.active = 0, this.clean = v;
  }
  y.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(E, b) {
      return this.starting ? (this.starting = !1, this.emit("start", E, b)) : this.emit("brush", E), this;
    },
    brush: function(E, b) {
      return this.emit("brush", E, b), this;
    },
    end: function(E, b) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", E, b)), this;
    },
    emit: function(E, b, v) {
      var N = tl(this.that).datum();
      o.call(
        E,
        this.that,
        new VS(E, {
          sourceEvent: b,
          target: s,
          selection: e.output(this.state.selection),
          mode: v,
          dispatch: o
        }),
        N
      );
    }
  };
  function x(E) {
    if (c && !E.touches || !r.apply(this, arguments))
      return;
    var b = this, v = E.target.__data__.type, N = (i && E.metaKey ? v = "overlay" : v) === "selection" ? lm : i && E.altKey ? el : Jo, C = e === af ? null : jS[v], R = e === Xu ? null : US[v], _ = of(b), U = _.extent, j = _.selection, te = U[0][0], Q, $, J = U[0][1], ne, z, W = U[1][0], ie, ae, oe = U[1][1], K, Y, X = 0, q = 0, ce, ge = C && R && i && E.shiftKey, De, me, Fe = Array.from(E.touches || [E], (Ie) => {
      const qe = Ie.identifier;
      return Ie = Fp(Ie, b), Ie.point0 = Ie.slice(), Ie.identifier = qe, Ie;
    });
    Op(b);
    var Ue = m(b, arguments, !0).beforestart();
    if (v === "overlay") {
      j && (ce = !0);
      const Ie = [Fe[0], Fe[1] || Fe[0]];
      _.selection = j = [[
        Q = e === af ? te : nr(Ie[0][0], Ie[1][0]),
        ne = e === Xu ? J : nr(Ie[0][1], Ie[1][1])
      ], [
        ie = e === af ? W : tr(Ie[0][0], Ie[1][0]),
        K = e === Xu ? oe : tr(Ie[0][1], Ie[1][1])
      ]], Fe.length > 1 && ze(E);
    } else
      Q = j[0][0], ne = j[0][1], ie = j[1][0], K = j[1][1];
    $ = Q, z = ne, ae = ie, Y = K;
    var Te = tl(b).attr("pointer-events", "none"), ve = Te.selectAll(".overlay").attr("cursor", ha[v]);
    if (E.touches)
      Ue.moved = fe, Ue.ended = Oe;
    else {
      var Ae = tl(E.view).on("mousemove.brush", fe, !0).on("mouseup.brush", Oe, !0);
      i && Ae.on("keydown.brush", Ve, !0).on("keyup.brush", Ze, !0), Ng(E.view);
    }
    p.call(b), Ue.start(E, N.name);
    function fe(Ie) {
      for (const qe of Ie.changedTouches || [Ie])
        for (const et of Fe)
          et.identifier === qe.identifier && (et.cur = Fp(qe, b));
      if (ge && !De && !me && Fe.length === 1) {
        const qe = Fe[0];
        sm(qe.cur[0] - qe[0]) > sm(qe.cur[1] - qe[1]) ? me = !0 : De = !0;
      }
      for (const qe of Fe)
        qe.cur && (qe[0] = qe.cur[0], qe[1] = qe.cur[1]);
      ce = !0, nf(Ie), ze(Ie);
    }
    function ze(Ie) {
      const qe = Fe[0], et = qe.point0;
      var He;
      switch (X = qe[0] - et[0], q = qe[1] - et[1], N) {
        case rf:
        case lm: {
          C && (X = tr(te - Q, nr(W - ie, X)), $ = Q + X, ae = ie + X), R && (q = tr(J - ne, nr(oe - K, q)), z = ne + q, Y = K + q);
          break;
        }
        case Jo: {
          Fe[1] ? (C && ($ = tr(te, nr(W, Fe[0][0])), ae = tr(te, nr(W, Fe[1][0])), C = 1), R && (z = tr(J, nr(oe, Fe[0][1])), Y = tr(J, nr(oe, Fe[1][1])), R = 1)) : (C < 0 ? (X = tr(te - Q, nr(W - Q, X)), $ = Q + X, ae = ie) : C > 0 && (X = tr(te - ie, nr(W - ie, X)), $ = Q, ae = ie + X), R < 0 ? (q = tr(J - ne, nr(oe - ne, q)), z = ne + q, Y = K) : R > 0 && (q = tr(J - K, nr(oe - K, q)), z = ne, Y = K + q));
          break;
        }
        case el: {
          C && ($ = tr(te, nr(W, Q - X * C)), ae = tr(te, nr(W, ie + X * C))), R && (z = tr(J, nr(oe, ne - q * R)), Y = tr(J, nr(oe, K + q * R)));
          break;
        }
      }
      ae < $ && (C *= -1, He = Q, Q = ie, ie = He, He = $, $ = ae, ae = He, v in dm && ve.attr("cursor", ha[v = dm[v]])), Y < z && (R *= -1, He = ne, ne = K, K = He, He = z, z = Y, Y = He, v in fm && ve.attr("cursor", ha[v = fm[v]])), _.selection && (j = _.selection), De && ($ = j[0][0], ae = j[1][0]), me && (z = j[0][1], Y = j[1][1]), (j[0][0] !== $ || j[0][1] !== z || j[1][0] !== ae || j[1][1] !== Y) && (_.selection = [[$, z], [ae, Y]], p.call(b), Ue.brush(Ie, N.name));
    }
    function Oe(Ie) {
      if (WS(Ie), Ie.touches) {
        if (Ie.touches.length)
          return;
        c && clearTimeout(c), c = setTimeout(function() {
          c = null;
        }, 500);
      } else
        Rg(Ie.view, ce), Ae.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      Te.attr("pointer-events", "all"), ve.attr("cursor", ha.overlay), _.selection && (j = _.selection), XS(j) && (_.selection = null, p.call(b)), Ue.end(Ie, N.name);
    }
    function Ve(Ie) {
      switch (Ie.keyCode) {
        case 16: {
          ge = C && R;
          break;
        }
        case 18: {
          N === Jo && (C && (ie = ae - X * C, Q = $ + X * C), R && (K = Y - q * R, ne = z + q * R), N = el, ze(Ie));
          break;
        }
        case 32: {
          (N === Jo || N === el) && (C < 0 ? ie = ae - X : C > 0 && (Q = $ - X), R < 0 ? K = Y - q : R > 0 && (ne = z - q), N = rf, ve.attr("cursor", ha.selection), ze(Ie));
          break;
        }
        default:
          return;
      }
      nf(Ie);
    }
    function Ze(Ie) {
      switch (Ie.keyCode) {
        case 16: {
          ge && (De = me = ge = !1, ze(Ie));
          break;
        }
        case 18: {
          N === el && (C < 0 ? ie = ae : C > 0 && (Q = $), R < 0 ? K = Y : R > 0 && (ne = z), N = Jo, ze(Ie));
          break;
        }
        case 32: {
          N === rf && (Ie.altKey ? (C && (ie = ae - X * C, Q = $ + X * C), R && (K = Y - q * R, ne = z + q * R), N = el) : (C < 0 ? ie = ae : C > 0 && (Q = $), R < 0 ? K = Y : R > 0 && (ne = z), N = Jo), ve.attr("cursor", ha[v]), ze(Ie));
          break;
        }
        default:
          return;
      }
      nf(Ie);
    }
  }
  function T(E) {
    m(this, arguments).moved(E);
  }
  function S(E) {
    m(this, arguments).ended(E);
  }
  function A() {
    var E = this.__brush || { selection: null };
    return E.extent = cm(t.apply(this, arguments)), E.dim = e, E;
  }
  return s.extent = function(E) {
    return arguments.length ? (t = typeof E == "function" ? E : tf(cm(E)), s) : t;
  }, s.filter = function(E) {
    return arguments.length ? (r = typeof E == "function" ? E : tf(!!E), s) : r;
  }, s.touchable = function(E) {
    return arguments.length ? (a = typeof E == "function" ? E : tf(!!E), s) : a;
  }, s.handleSize = function(E) {
    return arguments.length ? (d = +E, s) : d;
  }, s.keyModifiers = function(E) {
    return arguments.length ? (i = !!E, s) : i;
  }, s.on = function() {
    var E = o.on.apply(o, arguments);
    return E === o ? s : E;
  }, s;
}
const QS = ({ xMax: e, yMax: t }) => {
  var ne, z;
  const { tableData: r, config: a, setBrushConfig: i, dashboardConfig: o, formatDate: d } = ue.useContext(gt), [c, s] = ue.useState({ isBrushing: !1, selection: [] }), [p, m] = ue.useState(0), y = ((ne = o == null ? void 0 : o.dashboard) == null ? void 0 : ne.sharedFilters) ?? [], x = (y == null ? void 0 : y.length) > 0, [T, S] = ue.useState(!1), A = ue.useRef(), E = 25, b = 15, v = Dg(r, (W) => new Date(W[a.runtime.originalXAxis.dataKey])), N = Km().domain(v).range([0, e]), R = Jn("Drag edges to focus on a specific segment ", `normal ${16 / 1.1}px sans-serif`), _ = 50, U = 1.5, j = () => (o == null ? void 0 : o.type) === "dashboard" ? Number(t) + a.xAxis.axisBBox + E * U + _ : Number(t) + a.xAxis.axisBBox + E * U, te = () => {
    c.selection[0] === 0 && e === c.selection[1] && S(!0);
  }, Q = () => {
    (c.selection[0] !== 0 || c.selection[1] !== e) && S(!1), S(!1);
  }, $ = (W, ie, ae, oe) => {
    const K = Jn(ae, `normal ${14.545454545454545}px sans-serif`);
    return W.selectAll(".handle--custom").data([{ side: "left" }, { side: "right" }]).join((Y) => {
      const X = Y.append("g").attr("class", "handle--custom");
      return X.append("text").attr("x", (q) => q.side === "left" ? 0 : -K).attr("y", 30).text((q) => q.side === "left" ? ae : oe).attr("font-size", "13px"), X;
    }).attr("display", "block").attr("transform", ie === null ? null : (Y, X) => `translate(${ie[X]},10)`);
  }, J = () => {
    const W = tl(A.current).attr("overflow", "visible");
    W.append("rect").attr("fill", "#949494").attr("stroke", "#c5c5c5").attr("stroke-width", 2).attr("ry", b).attr("rx", b).attr("height", E).attr("width", e);
    const ie = (Y) => {
      var Ue, Te, ve, Ae;
      const X = Y == null ? void 0 : Y.selection;
      let q = Y.type === "brush" && X && X.length > 0;
      const [ce, ge] = X.map((fe) => N.invert(fe)), De = r.filter((fe) => {
        const ze = fe[a.runtime.originalXAxis.dataKey];
        if (!ze)
          return !1;
        const Oe = new Date(ze);
        if (isNaN(Oe.getTime()))
          return !1;
        if (Oe >= ce && Oe <= ge)
          return !0;
      }), me = (De.length && De[0][(Te = (Ue = a == null ? void 0 : a.runtime) == null ? void 0 : Ue.originalXAxis) == null ? void 0 : Te.dataKey]) ?? "", Fe = (De.length && De[De.length - 1][(Ae = (ve = a == null ? void 0 : a.runtime) == null ? void 0 : ve.originalXAxis) == null ? void 0 : Ae.dataKey]) ?? "";
      W.selectAll(".handle--custom").remove(), W.call($, X, me, Fe), i({
        active: a.brush.active,
        isBrushing: q,
        data: De
      }), s({
        isBrushing: !0,
        selection: X
      });
    }, ae = qS().extent([
      [0, 0],
      [e, 25]
    ]).on("start brush end", ie), oe = [0, e];
    let K = W.append("g").call(ae).call(ae.move, oe);
    K.select(".overlay").style("pointer-events", "none"), K.selectAll(".selection").attr("fill", "#474747").attr("fill-opacity", 1).attr("rx", b).attr("ry", b);
  };
  return ue.useEffect(() => {
    var ae, oe, K;
    const W = (ae = a.filters) == null ? void 0 : ae.some((Y) => Y.active), ie = (oe = a.exclusions) == null ? void 0 : oe.active;
    return (W || ie || x) && ((K = a.brush) != null && K.active) && (m((Y) => Y + 1), i((Y) => ({
      ...Y,
      data: r
    }))), () => i((Y) => ({
      ...Y,
      data: []
    }));
  }, [a.filters, a.exclusions, (z = a.brush) == null ? void 0 : z.active, x]), ue.useEffect(() => {
    p && J();
  }, [p]), c.isBrushing || J(), /* @__PURE__ */ n.createElement(
    at,
    {
      onMouseLeave: Q,
      onMouseOver: te,
      className: "brush-container",
      left: Number(a.runtime.yAxis.size),
      top: j()
    },
    /* @__PURE__ */ n.createElement(
      vt,
      {
        pointerEvents: "visiblePainted",
        display: T ? "block" : "none",
        fontSize: 16,
        x: (Number(e) - Number(R)) / 2,
        y: -10
      },
      "Drag edges to focus on a specific segment"
    ),
    /* @__PURE__ */ n.createElement("svg", { width: "100%", height: E * 3, ref: A })
  );
}, $i = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: T0,
  curveBasisClosed: A0,
  curveBasisOpen: L0,
  curveBundle: P0,
  curveCardinal: N0,
  curveCardinalClosed: R0,
  curveCardinalOpen: D0,
  curveCatmullRom: _0,
  curveCatmullRomClosed: O0,
  curveCatmullRomOpen: F0,
  curveLinear: Oc,
  curveLinearClosed: Tf,
  curveMonotoneX: Yu,
  curveMonotoneY: M0,
  curveNatural: z0,
  curveStep: B0,
  curveStepAfter: I0,
  curveStepBefore: $0
}, Symbol.toStringTag, { value: "Module" })), JS = (e) => {
  var _, U;
  const { xScale: t, yScale: r, yMax: a, xMax: i, handleTooltipMouseOver: o, handleTooltipMouseOff: d, isDebug: c, children: s } = e;
  let { transformedData: p, config: m, handleLineType: y, parseDate: x, formatDate: T, formatNumber: S, seriesHighlight: A, colorScale: E, rawData: b, brushConfig: v } = ue.useContext(gt);
  const N = (_ = m.brush) != null && _.active && ((U = v.data) != null && U.length) ? v.data : p;
  if (!N)
    return;
  const C = (j) => (Rn(m.xAxis) ? t(x(j[m.xAxis.dataKey], !1)) : t(j[m.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), R = (j, te, Q = void 0) => r(j[Q.dataKey]);
  return N && /* @__PURE__ */ n.createElement("svg", null, /* @__PURE__ */ n.createElement($r, { component: "AreaChart" }, /* @__PURE__ */ n.createElement(at, { className: "area-chart", key: "area-wrapper", left: Number(m.yAxis.size) }, (m.runtime.areaSeriesKeys || m.series).map((j, te) => {
    let Q = N.map((z) => ({
      [m.xAxis.dataKey]: z[m.xAxis.dataKey],
      [j.dataKey]: z[j.dataKey]
    })), $ = $i[j.lineType], J = m.legend.behavior === "highlight" && A.length > 0 && A.indexOf(j.dataKey) === -1, ne = m.legend.behavior === "highlight" || A.length === 0 || A.indexOf(j.dataKey) !== -1;
    return /* @__PURE__ */ n.createElement(n.Fragment, { key: te }, /* @__PURE__ */ n.createElement(
      Br,
      {
        data: Q,
        x: (z) => C(z),
        y: (z) => R(z, te, j),
        stroke: ne ? E ? E(m.runtime.seriesLabels ? m.runtime.seriesLabels[j.dataKey] : j.dataKey) : "#000" : "transparent",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        curve: $,
        strokeDasharray: j.type ? y(j.type) : 0
      }
    ), /* @__PURE__ */ n.createElement(
      Df,
      {
        key: "area-chart",
        fill: ne ? E ? E(m.runtime.seriesLabels ? m.runtime.seriesLabels[j.dataKey] : j.dataKey) : "#000" : "transparent",
        fillOpacity: J ? 0.25 : 0.5,
        data: Q,
        x: (z) => C(z),
        y: (z) => R(z, te, j),
        yScale: r,
        curve: $,
        strokeDasharray: j.type ? y(j.type) : 0
      }
    ));
  }), /* @__PURE__ */ n.createElement(Lr, { width: Number(i), height: Number(a), fill: "transparent", fillOpacity: 0.05, onMouseMove: (j) => o(j, b), onMouseLeave: d }))));
}, ek = ue.memo(JS), tk = ({ xScale: e, yScale: t, yMax: r, xMax: a, handleTooltipMouseOver: i, handleTooltipMouseOff: o, isDebug: d }) => {
  var A, E;
  let { transformedData: c, config: s, seriesHighlight: p, colorScale: m, rawData: y } = ue.useContext(gt);
  const x = (A = s.brush) != null && A.active && ((E = s.brush.data) != null && E.length) ? s.brush.data : c;
  if (!x)
    return;
  const T = (b) => {
    if (s.xAxis.type === "categorical")
      return e(b);
    if (Rn(s.xAxis)) {
      let v = new Date(b);
      return e(v);
    }
  }, S = 2;
  return x && /* @__PURE__ */ n.createElement("svg", { height: Number(r) }, /* @__PURE__ */ n.createElement($r, { component: "AreaChartStacked" }, /* @__PURE__ */ n.createElement(
    at,
    {
      className: "area-chart",
      key: "area-wrapper",
      left: Number(s.yAxis.size) + S / 2,
      height: Number(r),
      style: { overflow: "hidden" }
    },
    /* @__PURE__ */ n.createElement(
      gE,
      {
        data: x,
        keys: s.runtime.areaSeriesKeys.map((b) => b.dataKey) || s.series.map((b) => b.dataKey),
        x0: (b) => T(b.data[s.xAxis.dataKey]),
        y0: (b) => Number(t(b[0])),
        y1: (b) => Number(t(b[1])),
        curve: $i[sl[s.stackedAreaChartLineType]]
      },
      ({ stacks: b, path: v }) => b.map((N, C) => {
        let R = s.legend.behavior === "highlight" && p.length > 0 && p.indexOf(N.key) === -1, _ = s.legend.behavior === "highlight" || p.length === 0 || p.indexOf(N.key) !== -1;
        return (
          // prettier-ignore
          /* @__PURE__ */ n.createElement(
            "path",
            {
              key: N.key,
              d: v(N) || "",
              strokeWidth: 2,
              stroke: _ ? m ? m(s.runtime.seriesLabels ? s.runtime.seriesLabels[N.key] : N.key) : "#000" : "transparent",
              fillOpacity: R ? 0.2 : 1,
              fill: _ ? m ? m(s.runtime.seriesLabels ? s.runtime.seriesLabels[N.key] : N.key) : "#000" : "transparent"
            }
          )
        );
      })
    ),
    /* @__PURE__ */ n.createElement(Lr, { width: Number(a), height: Number(r), fill: "transparent", onMouseMove: (b) => i(b, y), onMouseLeave: o })
  )));
}, nk = ue.memo(tk), Os = () => {
  const { config: e, colorPalettes: t, tableData: r, updateConfig: a, parseDate: i, formatDate: o, setSeriesHighlight: d, seriesHighlight: c } = ue.useContext(gt), { orientation: s } = e, [p, m] = ue.useState(null), y = s === "horizontal", x = 1, T = e.lollipopSize === "large" ? 7 : e.lollipopSize === "medium" ? 6 : 5, S = e.lollipopSize === "large" ? 14 : e.lollipopSize === "medium" ? 12 : 10, A = e.yAxis.labelPlacement === "Below Bar", E = e.yAxis.displayNumbersOnBar, b = e.orientation === "horizontal" ? "yAxis" : "xAxis", v = e.barStyle === "rounded", N = e.visualizationSubType === "stacked", C = e.tipRounding, R = e.roundingStyle === "standard" ? "8px" : e.roundingStyle === "shallow" ? "5px" : e.roundingStyle === "finger" ? "15px" : "0px", _ = e.runtime.seriesKeys.length, U = { small: 16, medium: 18, large: 20 }, j = Object.keys(e.runtime.seriesLabels).length > 1, Q = e.visualizationType === "Bar" && e.legend.behavior === "isolate" && e.legend.axisAlign && (c != null && c.length) ? c : e.runtime.barSeriesKeys || e.runtime.seriesKeys;
  return ue.useEffect(() => {
    s === "horizontal" && !e.yAxis.labelPlacement && a({
      ...e,
      yAxis: {
        ...e.yAxis,
        labelPlacement: "Below Bar"
      }
    });
  }, [e, a]), ue.useEffect(() => {
    e.isLollipopChart === !1 && e.barHeight < 25 && a({ ...e, barHeight: 25 });
  }, [e.isLollipopChart]), ue.useEffect(() => {
    e.visualizationSubType === "horizontal" && a({
      ...e,
      orientation: "horizontal"
    });
  }, []), ue.useEffect(() => {
    e.barStyle === "lollipop" && !e.isLollipopChart && a({ ...e, isLollipopChart: !0 }), (v || e.barStyle === "flat") && a({ ...e, isLollipopChart: !1 });
  }, [e.barStyle]), {
    isHorizontal: y,
    barBorderWidth: x,
    lollipopBarWidth: T,
    lollipopShapeSize: S,
    isLabelBelowBar: A,
    displayNumbersOnBar: E,
    shouldSuppress: (Y) => {
      var X;
      return (X = e.preliminaryData) == null ? void 0 : X.some((q) => {
        const ce = q.column ? q.column === Y.key : !0, ge = String(Y.value) === String(q.value) && q.value !== "";
        return ce && ge && q.symbol && q.type === "suppression";
      });
    },
    section: b,
    isRounded: v,
    isStacked: N,
    tipRounding: C,
    radius: R,
    stackCount: _,
    barStackedSeriesKeys: Q,
    fontSize: U,
    hasMultipleSeries: j,
    applyRadius: (Y) => {
      if (Y == null || !v)
        return {};
      let X = {};
      return (N && Y + 1 === _ || !N) && (X = y ? { borderRadius: `0 ${R}  ${R}  0` } : { borderRadius: `${R} ${R} 0 0` }), !N && Y === -1 && (X = y ? { borderRadius: `${R} 0  0 ${R} ` } : { borderRadius: ` 0  0 ${R} ${R}` }), C === "full" && N && Y === 0 && _ > 1 && (X = y ? { borderRadius: `${R} 0 0 ${R}` } : { borderRadius: `0 0 ${R} ${R}` }), C === "full" && (N && Y === 0 && _ === 1 || !N) && (X = { borderRadius: R }), X;
    },
    updateBars: (Y) => {
      if (e.visualizationType !== "Bar" && !y)
        return Y;
      const X = [...Y];
      let q;
      const ce = {
        stacked: e.barHeight,
        lollipop: T
      };
      N ? q = ce.stacked : q = ce[e.isLollipopChart ? "lollipop" : "stacked"] * _;
      const ge = A ? U[e.fontSize] * 1.2 : 0;
      let De = Number(e.barSpace), me = X.length * (q + ge + De);
      return y && (e.heights.horizontal = me), X.map((Fe, Ue) => {
        let Te = 0;
        return Fe.index !== 0 && (Te = (q + De + ge) * Ue), { ...Fe, y: Te, height: q };
      });
    },
    assignColorsToValues: (Y, X, q) => {
      if (!e.legend.colorCode && e.series.length > 1)
        return q;
      const ce = e.customColors ?? t[e.palette], ge = r.map((Ue) => Ue[e.legend.colorCode]);
      let De = /* @__PURE__ */ new Map(), me = [];
      for (let Ue = 0; Ue < ge.length; Ue++)
        De.has(ge[Ue]) || De.set(ge[Ue], ce[De.size % ce.length]), me.push(De.get(ge[Ue]));
      for (; me.length < Y; )
        me = me.concat(me);
      return me[X];
    },
    getHighlightedBarColorByValue: (Y) => {
      const X = e == null ? void 0 : e.highlightedBarValues.find((q) => {
        if (q.value)
          return e.xAxis.type === "date" ? o(i(q.value)) === Y : q.value === Y;
      });
      return X != null && X.color ? X.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (Y) => {
      const X = e == null ? void 0 : e.highlightedBarValues.filter((q) => {
        if (q.value)
          return e.xAxis.type === "date" ? o(i(q.value)) === Y : q.value === Y;
      })[0];
      return X != null && X.color ? X : !1;
    },
    getAdditionalColumn: (Y, X) => {
      if (!X)
        return "";
      const q = e.columns, ce = [];
      let ge = "";
      const De = r.find((me) => me[e.xAxis.dataKey] === X) || {};
      return Object.keys(q).forEach((me) => {
        if (Y && e.columns[me].series && e.columns[me].series !== Y)
          return;
        const Fe = {
          addColPrefix: e.columns[me].prefix,
          addColSuffix: e.columns[me].suffix,
          addColRoundTo: e.columns[me].roundToPlace ? e.columns[me].roundToPlace : "",
          addColCommas: e.columns[me].commas
        }, Ue = qf(De[e.columns[me].name], "left", !0, e, Fe);
        e.columns[me].tooltips && ce.push([e.columns[me].label, Ue]);
      }), ce.forEach((me) => {
        ge += `${me[0]} : ${me[1]} <br/>`;
      }), ge;
    },
    hoveredBar: p,
    setHoveredBar: m,
    onMouseOverBar: (Y, X) => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && X && d([X]), m(Y);
    },
    onMouseLeaveBar: () => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && d([]);
    }
  };
}, Fs = ue.createContext(null), bp = ({
  xScale: e,
  barWidth: t = 0,
  totalBarsInGroup: r = 1,
  yMax: a,
  handleTooltipMouseOff: i,
  handleTooltipMouseOver: o,
  handleTooltipClick: d,
  tooltipData: c,
  showTooltip: s,
  hideTooltip: p
}) => {
  const { parseDate: m, config: y } = ue.useContext(gt), { runtime: x, regions: T, visualizationType: S, orientation: A, xAxis: E } = y, b = e.domain(), v = (R) => {
    let _;
    if (!(R != null && R.fromType) || R.fromType === "Fixed") {
      const U = new Date(R.from), j = m(ss(y.xAxis.dateParseFormat, U)).getTime();
      _ = e(j), S === "Bar" && E.type === "date-time" && (_ = _ - t * r / 2);
    }
    if (R.fromType === "Previous Days") {
      const U = Number(R.from) || 0;
      b.map(($) => ss(y.xAxis.dateParseFormat, new Date($)));
      const j = R.toType === "Last Date" ? new Date(b[b.length - 1]).getTime() : new Date(R.to), te = y.xAxis.type === "categorical" ? ss(y.xAxis.dateParseFormat, j) : ss(y.xAxis.dateParseFormat, j), Q = new Date(te);
      if (_ = new Date(Q.setDate(Q.getDate() - Number(U))), E.type === "date") {
        _ = new Date(ss(E.dateParseFormat, _)).getTime();
        let $ = b[0], J = Math.abs(_ - $);
        for (let ne = 1; ne < b.length; ne++) {
          const z = Math.abs(_ - b[ne]);
          z < J && (J = z, $ = b[ne]);
        }
        _ = $;
      }
      if (E.type === "categorical") {
        let $ = b[0], J = Math.abs(new Date(_).getTime() - new Date($).getTime());
        for (let ne = 1; ne < b.length; ne++) {
          const z = Math.abs(new Date(_).getTime() - new Date(b[ne]).getTime());
          z < J && (J = z, $ = b[ne]);
        }
        _ = $;
      }
      _ = e(_);
    }
    if (E.type === "categorical" && R.fromType !== "Previous Days" && (_ = e(R.from)), S === "Line" || S === "Area Chart") {
      let U = Number(y.yAxis.size);
      e.bandwidth && (U += e.bandwidth() / 2), _ = _ + U;
    }
    return S === "Bar" && y.xAxis.type === "date-time" && R.fromType === "Previous Days" && (_ = _ - t * r / 2), _;
  }, N = (R) => {
    let _;
    if (E.type === "categorical" && (_ = e(R.to)), Rn(E) && ((!(R != null && R.toType) || R.toType === "Fixed") && (_ = e(m(R.to).getTime())), (S === "Bar" || y.visualizationType === "Combo") && (_ = R.toType !== "Last Date" ? e(m(R.to).getTime()) + t * r : _)), R.toType === "Last Date") {
      const U = b[b.length - 1];
      _ = Number(
        e(U) + ((S === "Bar" || S === "Combo") && y.xAxis.type === "date" ? t * r : 0)
      );
    }
    if (S === "Line" || S === "Area Chart") {
      let U = Number(y.yAxis.size);
      e.bandwidth && (U += e.bandwidth() / 2), _ = _ + U;
    }
    return S === "Bar" && y.xAxis.type === "date-time" && R.toType !== "Last Date" && (_ = _ - t * r / 2), (S === "Bar" || S === "Combo") && E.type === "categorical" && (_ = _ + (S === "Bar" || S === "Combo" ? t * r : 0)), _;
  }, C = (R, _) => R - _;
  if (T && A === "vertical")
    return T.map((R) => {
      const _ = v(R), U = N(R), j = C(U, _);
      if (!_ || !U)
        return null;
      const te = () => /* @__PURE__ */ n.createElement("rect", { x: _, y: 0, width: j, height: a, fill: R.background, opacity: 0.3 });
      return /* @__PURE__ */ n.createElement(
        at,
        {
          height: 100,
          fill: "red",
          className: "regions regions-group--line zzz",
          key: R.label,
          onMouseMove: o,
          onMouseLeave: i,
          handleTooltipClick: d,
          tooltipData: JSON.stringify(c),
          showTooltip: s
        },
        /* @__PURE__ */ n.createElement(te, null),
        /* @__PURE__ */ n.createElement(vt, { x: _ + j / 2, y: 5, fill: R.color, verticalAnchor: "start", textAnchor: "middle" }, R.label)
      );
    });
};
function Ms(e) {
  var q, ce;
  const { config: t, index: r, id: a, className: i, background: o, borderColor: d, borderWidth: c, width: s, height: p, x: m, y, onMouseOver: x, onMouseLeave: T, onClick: S, tooltipHtml: A, tooltipId: E, styleOverrides: b, seriesHighlight: v, type: N } = e, C = Math.max(0, s), R = Math.max(0, p), _ = t.orientation === "horizontal", U = t.barStyle === "rounded", j = t.visualizationSubType === "stacked", te = t.tipRounding, Q = t.visualizationType === "Combo" && ((ce = (q = t.runtime) == null ? void 0 : q.barSeriesKeys) == null ? void 0 : ce.length), $ = t.runtime.seriesKeys.length, J = t.visualizationType === "Bar" && t.legend.axisAlign && (v != null && v.length) ? v == null ? void 0 : v.length : 0, ne = Q || J || $;
  let z = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  (z > C / 2 || z > R / 2) && (z = Math.min(C / 2, R / 2));
  const W = () => `M${m},${y + R}
      L${m},${y + z}
      Q${m},${y} ${m + z},${y}
      L${m + C - z},${y}
      Q${m + C},${y} ${m + C},${y + z}
      L${m + C},${y + R}
      L${m},${y + R}`, ie = () => `M${m},${y + R}
      L${m},${y}
      L${m + C - z},${y}
      Q${m + C},${y} ${m + C},${y + z}
      L${m + C},${y + R - z}
      Q${m + C},${y + R} ${m + C - z},${y + R}
      L${m},${y + R}`, ae = () => `M${m + z},${y + R}
      Q${m},${y + R} ${m},${y + R - z}
      L${m},${y}
      L${m + C},${y}
      L${m + C},${y + R - z}
      Q${m + C},${y + R} ${m + C - z},${y + R}
      L${m + z},${y + R}`, oe = () => `M${m + z},${y + R}
      Q${m},${y + R} ${m},${y + R - z}
      L${m},${y + z}
      Q${m},${y} ${m + z},${y}
      L${m + C},${y}
      L${m + C},${y + R}
      L${m + z},${y + R}`, K = () => `M${m + z},${y + R}
      Q${m},${y + R} ${m},${y + R - z}
      L${m},${y + z}
      Q${m},${y} ${m + z},${y}
      L${m + C - z},${y}
      Q${m + C},${y} ${m + C},${y + z}
      L${m + C},${y + R - z}
      Q${m + C},${y + R} ${m + C - z},${y + R}
      L${m + z},${y + R}`, Y = () => `M${m},${y}
      L${m + C},${y}
      L${m + C},${y + R}
      L${m},${y + R}
      L${m},${y}`;
  let X;
  return r == null || !U || N == "axisBar" ? X = Y() : (X = Y(), (j && r + 1 === ne || !j) && (X = _ ? ie() : W()), !j && r === -1 && (X = _ ? oe() : ae()), te === "full" && j && r === 0 && ne > 1 && (X = _ ? oe() : ae()), te === "full" && (j && r === 0 && ne === 1 || !j) && (X = K())), /* @__PURE__ */ n.createElement(
    "path",
    {
      id: a,
      className: i,
      d: X,
      fill: o,
      stroke: d,
      strokeWidth: c,
      onMouseOver: x,
      onMouseLeave: T,
      onClick: S,
      "data-tooltip-html": A,
      "data-tooltip-id": E,
      style: {
        transition: "all 0.2s linear",
        ...b
      }
    }
  );
}
const rk = () => {
  var $, J;
  const [e, t] = ue.useState(0), { xScale: r, yScale: a, seriesScale: i, xMax: o, yMax: d } = ue.useContext(Fs), { transformedData: c, colorScale: s, seriesHighlight: p, config: m, formatNumber: y, formatDate: x, parseDate: T, setSharedFilter: S } = ue.useContext(gt), {
    isHorizontal: A,
    barBorderWidth: E,
    applyRadius: b,
    hoveredBar: v,
    getAdditionalColumn: N,
    onMouseLeaveBar: C,
    onMouseOverBar: R,
    barStackedSeriesKeys: _
  } = Os(), { orientation: U } = m, j = ($ = m.brush) != null && $.active && ((J = m.brush.data) != null && J.length) ? m.brush.data : c, te = m.runtime.xAxis.type === "date-time" || m.runtime.xAxis.type === "date", Q = m.runtime.xAxis.type === "date-time";
  return m.visualizationSubType === "stacked" && !A && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Wy,
    {
      data: j,
      keys: _,
      x: (ne) => ne[m.runtime.xAxis.dataKey],
      xScale: r,
      yScale: a,
      color: s
    },
    (ne) => ne.reverse().map(
      (z) => z.bars.map((W) => {
        let ie = m.legend.behavior === "highlight" && p.length > 0 && p.indexOf(W.key) === -1, ae = m.legend.behavior === "highlight" || p.length === 0 || p.indexOf(W.key) !== -1, oe = te ? i.range()[1] - i.range()[0] : o / z.bars.length;
        m.runtime.xAxis.type !== "date" && (oe = m.barThickness * oe);
        const K = W.bar.data[m.runtime.xAxis.dataKey], Y = te ? x(T(K)) : K, X = y(W.bar ? W.bar.data[W.key] : 0, "left");
        if (!X)
          return;
        const q = r(te ? T(K) : K) - (Q ? oe / 2 : 0), ce = m.runtime.xAxis.label ? `${m.runtime.xAxis.label}: ${Y}` : Y, ge = N(v), De = `${m.runtime.seriesLabels[W.key]}: ${X}`, me = `<ul>
                  <li class="tooltip-heading"">${ce}</li>
                  <li class="tooltip-body ">${De}</li>
                  <li class="tooltip-body ">${ge}</li>
                    </li></ul>`;
        return t(oe), /* @__PURE__ */ n.createElement(at, { key: `${z.index}--${W.index}--${U}` }, /* @__PURE__ */ n.createElement(
          at,
          {
            key: `bar-stack-${z.index}-${W.index}`,
            id: `barStack${z.index}-${W.index}`,
            className: "stack vertical"
          },
          Ms({
            config: m,
            seriesHighlight: p,
            index: z.index,
            background: s(m.runtime.seriesLabels[W.key]),
            borderColor: "#333",
            borderStyle: "solid",
            borderWidth: `${m.barHasBorder === "true" ? E : 0}px`,
            width: oe,
            height: W.height,
            x: q,
            y: W.y,
            onMouseOver: () => R(Y, W.key),
            onMouseLeave: C,
            tooltipHtml: me,
            tooltipId: `cdc-open-viz-tooltip-${m.runtime.uniqueId}`,
            onClick: (Fe) => {
              Fe.preventDefault(), S && (W[m.xAxis.dataKey] = Y, S(m.uid, W));
            },
            styleOverrides: {
              animationDelay: `${z.index * 0.5}s`,
              transformOrigin: `${oe / 2}px ${W.y + W.height}px`,
              opacity: ie ? 0.2 : 1,
              display: ae ? "block" : "none"
            }
          })
        ));
      })
    )
  ), /* @__PURE__ */ n.createElement(bp, { xScale: r, yMax: d, barWidth: e, totalBarsInGroup: 1 }));
}, ak = () => {
  const { yMax: e, yScale: t, xScale: r } = ue.useContext(Fs), {
    animatedChart: a,
    colorScale: i,
    config: o,
    formatDate: d,
    formatNumber: c,
    parseDate: s,
    seriesHighlight: p,
    setSharedFilter: m,
    transformedData: y
  } = ue.useContext(gt), { barBorderWidth: x, displayNumbersOnBar: T, fontSize: S, getAdditionalColumn: A, hoveredBar: E, isHorizontal: b, isLabelBelowBar: v, onMouseLeaveBar: N, onMouseOverBar: C, updateBars: R, barStackedSeriesKeys: _ } = Os(), { orientation: U, visualizationSubType: j } = o;
  return o.visualizationSubType === "stacked" && b && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    wE,
    {
      data: y,
      keys: _,
      height: e,
      y: (te) => te[o.runtime.yAxis.dataKey],
      xScale: r,
      yScale: t,
      color: i,
      offset: "none"
    },
    (te) => te.map(
      (Q) => R(Q.bars).map(($, J) => {
        const ne = o.legend.behavior === "highlight" && p.length > 0 && p.indexOf($.key) === -1, z = o.legend.behavior === "highlight" || p.length === 0 || p.indexOf($.key) !== -1;
        o.barHeight = Number(o.barHeight);
        const W = ll("#000", i(o.runtime.seriesLabels[$.key])), ie = c(y[$.index][$.key], "left"), ae = o.runtime.yAxis.type === "date" ? d(s(y[$.index][o.runtime.originalXAxis.dataKey])) : y[$.index][o.runtime.originalXAxis.dataKey], oe = o.runtime.yAxis.label ? `${o.runtime.yAxis.label}: ${ae}` : ae, K = Jn(ie, `normal ${S[o.fontSize]}px sans-serif`), Y = A(E), X = `${o.runtime.seriesLabels[$.key]}: ${ie}`, q = `<ul>
                  <li class="tooltip-heading"">${oe}</li>
                  <li class="tooltip-body ">${X}</li>
                  <li class="tooltip-body ">${Y}</li>
                    </li></ul>`;
        return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(at, { key: J, id: `barStack${Q.index}-${$.index}`, className: "stack horizontal" }, Ms({
          config: o,
          seriesHighlight: p,
          index: Q.index,
          className: `animated-chart group ${a ? "animated" : ""}`,
          background: i(o.runtime.seriesLabels[$.key]),
          borderColor: "#333",
          borderStyle: "solid",
          borderWidth: `${o.barHasBorder === "true" ? x : 0}px`,
          width: $.width,
          height: $.height,
          x: $.x,
          y: $.y,
          onMouseOver: () => C(ae, $.key),
          onMouseLeave: N,
          tooltipHtml: q,
          tooltipId: `cdc-open-viz-tooltip-${o.runtime.uniqueId}`,
          onClick: (ce) => {
            ce.preventDefault(), m && ($[o.xAxis.dataKey] = ie, m(o.uid, $));
          },
          styleOverrides: {
            animationDelay: `${Q.index * 0.5}s`,
            transformOrigin: `${$.x}px 0`,
            opacity: ne ? 0.2 : 1,
            display: z ? "block" : "none"
          }
        }), U === "horizontal" && j === "stacked" && v && Q.index === 0 && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          vt,
          {
            x: `${$.x + (o.isLollipopChart ? 15 : 5)}`,
            y: $.y + $.height * 1.2,
            fill: "#000000",
            textAnchor: "start",
            verticalAnchor: "start"
          },
          ae
        ), T && K < $.width && /* @__PURE__ */ n.createElement(
          vt,
          {
            display: z ? "block" : "none",
            x: $.x + Q.bars[$.index].width / 2,
            y: $.y + $.height / 2,
            fill: W,
            textAnchor: "middle",
            verticalAnchor: "middle"
          },
          ie
        )));
      })
    )
  ));
}, Ic = (e, t) => {
  var A;
  const { formatDate: r, parseDate: a } = ue.useContext(gt);
  let i = [], o = "", d = [], c = [];
  ((A = e.series) == null ? void 0 : A.length) > 0 && e.data ? (i = e.series[0], o = e.series[0].dataKey, d = e.highlightedBarValues, c = e.data.map((E) => E[e.xAxis.dataKey])) : (i = [], o = "", d = [], c = []);
  const s = (E, b) => {
    const v = [...e.highlightedBarValues];
    v[b].borderWidth = E.target.value, t({
      ...e,
      highlightedBarValues: v
    });
  }, p = (E, b) => {
    E.preventDefault();
    const v = [...e.highlightedBarValues];
    v[b].value = E.target.value, v[b].dataKey = o, t({
      ...e,
      highlightedBarValues: v
    });
  }, m = (E, b) => {
    E.preventDefault();
    const v = [...e.highlightedBarValues];
    v.push({ dataKey: o }), t({
      ...e,
      highlightedBarValues: v
    });
  }, y = (E, b) => {
    E.preventDefault();
    const v = [...e.highlightedBarValues];
    v.splice(b, 1), t({
      ...e,
      highlightedBarValues: v
    });
  }, x = (E, b) => {
    const v = [...e.highlightedBarValues];
    v[b].color = E.target.value, t({
      ...e
    });
  }, T = (E, b) => {
    const v = [...e.highlightedBarValues];
    v[b].legendLabel = E.target.value, t({
      ...e,
      copyOfHighlightedBarValues: v
    });
  }, S = () => {
  };
  return S.checkFontColor = (E, b, v) => {
    if (e.xAxis.type === "date") {
      if (S.formatDates(b).includes(E))
        return "#000";
    } else if (b.includes(E))
      return "#000";
    return v;
  }, S.formatDates = (E) => E.map((b) => b ? r(a(b)) : !1), S.findDuplicates = (E) => {
    const b = {};
    return E == null ? void 0 : E.filter((N) => {
      const { legendLabel: C } = N;
      return b[C] ? !1 : (b[C] = !0, !0);
    });
  }, {
    HighLightedBarUtils: S,
    highlightedSeries: i,
    highlightedSeriesKey: o,
    highlightedBarValues: d,
    highlightedSeriesValues: c,
    handleUpdateHighlightedBar: p,
    handleAddNewHighlightedBar: m,
    handleRemoveHighlightedBar: y,
    handleUpdateHighlightedBarColor: x,
    handleHighlightedBarLegendLabel: T,
    handleUpdateHighlightedBorderWidth: s
  };
};
function Ki(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
const cg = ({
  bar: e,
  defaultBarHeight: t,
  defaultBarWidth: r,
  config: a,
  barWidth: i,
  isVertical: o
}) => {
  let c = t, s = r, p = "", m = !1, y = !1, x = !1;
  const T = a.general.showSuppressedSymbol;
  if (a.preliminaryData.forEach((E) => {
    (!E.column || E.column === e.key) && E.type === "suppression" && E.value && String(E.value) === String(e.value) && (!E.hideBarSymbol && T ? (c = i > 10 ? 3 : 0, s = 3, m = !0) : (c = 0, s = 0, m = !0));
  }), !m && !Ki(e.value) && a.general.showMissingDataLabel) {
    const E = Jn(p, `normal ${i / 2}px sans-serif`), b = Number(E) < i && i > 10;
    y = !0, c = b ? 3 : 0, s = 3;
  }
  if (!m && e.value === "0" && a.general.showZeroValueData) {
    const E = Jn("0", `normal ${i / 2}px sans-serif`), b = Number(E) < i && i > 10;
    x = !0, c = b ? 3 : 0, s = 3;
  }
  return { barWidthHorizontal: s, barHeight: c, isSuppressed: m, showMissingDataLabel: y, getBarY: (E, b) => m || y || x ? a.isLollipopChart ? b - 3 * 2 : b - 3 : E, getAbsentDataLabel: (E) => {
    let b = "";
    String(E) === "0" && (b = ""), m && (b = ""), y && (b = "N/A"), x && (b = "0");
    const v = Jn(p, `normal ${i / 2}px sans-serif`), N = Number(v) < i && i > 10;
    return a.isLollipopChart || N && o ? b : o ? "" : b;
  } };
}, Ss = (e) => e == null ? void 0 : /^0(\.0)?$/.test(e.toString()), Hc = (e, t, r) => !!(e === "Line" && (t == null ? void 0 : t.length) < 3 && r), dg = (e, t, r) => {
  const a = e.series.find((s) => s.dynamicCategory);
  if (!a)
    return t;
  const { dynamicCategory: i, dataKey: o } = a, d = e.runtime.originalXAxis.dataKey, c = lt.groupBy(t, d);
  return Object.values(c).map((s) => s.reduce((p, m) => {
    const y = m[o], x = m[i];
    if (r) {
      const { lower: T, upper: S } = e.confidenceKeys;
      p.CI || (p.CI = {});
      const A = m[T], E = m[S];
      p.CI[x] = { lower: A, upper: E };
    }
    return p[x] = y, p[d] = m[d], p.dynamicData = !0, p;
  }, {}));
}, ik = () => {
  const { xScale: e, yScale: t, xMax: r, yMax: a, seriesScale: i } = ue.useContext(Fs), [o, d] = ue.useState(0), [c, s] = ue.useState(0), {
    // prettier-ignore
    assignColorsToValues: p,
    barBorderWidth: m,
    getAdditionalColumn: y,
    getHighlightedBarByValue: x,
    getHighlightedBarColorByValue: T,
    lollipopBarWidth: S,
    lollipopShapeSize: A,
    onMouseLeaveBar: E,
    onMouseOverBar: b,
    section: v
  } = Os(), { colorScale: N, config: C, dashboardConfig: R, tableData: _, formatDate: U, formatNumber: j, parseDate: te, seriesHighlight: Q, setSharedFilter: $, transformedData: J, brushConfig: ne } = ue.useContext(gt), { HighLightedBarUtils: z } = Ic(C), W = document.documentElement, ie = getComputedStyle(W).getPropertyValue("--cool-gray-90");
  let ae = J;
  C.preliminaryData.some((X) => X.value && X.type === "suppression") && (ae = _), ne.data.length && (ae = ne.data);
  const K = Object.keys(C.confidenceKeys).length > 0, Y = dg(C, ae, K);
  return C.visualizationSubType !== "stacked" && (C.visualizationType === "Bar" || C.visualizationType === "Combo" || Hc(C.visualizationType, ae, C.allowLineToBarGraph)) && C.orientation === "vertical" && /* @__PURE__ */ n.createElement(at, null, /* @__PURE__ */ n.createElement(
    Iy,
    {
      data: Y,
      keys: C.runtime.barSeriesKeys || C.runtime.seriesKeys,
      height: a,
      x0: (X) => {
        const q = X[C.runtime.originalXAxis.dataKey];
        return Rn(C.runtime.xAxis) ? te(q) : q;
      },
      x0Scale: e,
      x1Scale: i,
      yScale: t,
      color: () => ""
    },
    (X) => X.map((q, ce) => /* @__PURE__ */ n.createElement(
      at,
      {
        className: `bar-group-${q.index}-${q.x0}--${ce} ${C.orientation}`,
        key: `bar-group-${q.index}-${q.x0}--${ce}`,
        id: `bar-group-${q.index}-${q.x0}--${ce}`,
        left: q.x0
      },
      q.bars.map((ge, De) => {
        const me = Y[q.index], Fe = me[C.runtime.originalXAxis.dataKey], Ue = C.yAxis.type === "logarithmic" ? 0.1 : 0;
        let Te = C.highlightedBarValues.map((At) => At.value).filter((At) => At !== void 0);
        Te = C.xAxis.type === "date" ? z.formatDates(Te) : Te;
        const ve = C.legend.behavior === "highlight" && Q.length > 0 && Q.indexOf(ge.key) === -1, Ae = C.legend.behavior === "highlight" || Q.length === 0 || Q.indexOf(ge.key) !== -1;
        let fe = i.range()[1] - i.range()[0];
        const ze = Math.abs(t(ge.value) - t(Ue)), Oe = ge.value >= 0 && Ki(ge.value) ? ge.y : t(0);
        let Ve = C.isLollipopChart ? S : i.bandwidth(), Ze = ge.x + (C.isLollipopChart ? (fe / q.bars.length - S) / 2 : 0) - (C.xAxis.type === "date-time" ? fe / 2 : 0);
        d(Ve), s(q.bars.length);
        const Ie = j(/[a-zA-Z]/.test(String(ge.value)) ? "" : ge.value, "left"), qe = C.runtime[v].type === "date" ? U(te(Fe)) : Fe, et = ge.value < 0 ? -1 : De, He = y(ge.key, Fe);
        let Ge = C.runtime.xAxis.label ? `${C.runtime.xAxis.label}: ${qe}` : qe;
        const Le = `${C.runtime.seriesLabels[ge.key]}: ${Ie}`, _e = `<ul>
                  <li class="tooltip-heading">${Ge}</li>
                  <li class="tooltip-body ">${Le}</li>
                  ${He ? '<li class="tooltip-body ">' + He + "</li>" : ""}
                    </li></ul>`;
        let st = "#000000";
        st = z.checkFontColor(Ie, Te, st);
        const Ee = C.isLollipopChart && C.lollipopColorStyle === "regular", rt = C.isLollipopChart && C.lollipopColorStyle === "two-tone", pt = Te == null ? void 0 : Te.includes(qe), ft = T(qe), wt = x(qe), zt = pt ? ft : C.barHasBorder === "true" ? "#000" : "transparent", Jt = pt ? wt.borderWidth : C.isLollipopChart ? 0 : C.barHasBorder === "true" ? m : 0, { barHeight: jt, isSuppressed: on, getBarY: _t, getAbsentDataLabel: tn } = cg({
          bar: ge,
          defaultBarHeight: ze,
          config: C,
          barWidth: Ve,
          isVertical: !0
        }), $t = tn(Ie), Ut = on || !C.labels ? "" : Ie, bt = _t(Oe, t(Ue)), mt = Ss(ge.value) ? "none" : "block", ln = (At, nn) => {
          var Nt;
          let Xt = At, sn = nn || "#f2f2f2";
          if (R && ((Nt = R.dashboard.sharedFilters) == null ? void 0 : Nt.length) !== 0) {
            const { sharedFilters: xn } = R.dashboard;
            return Xt = xn ? xn.map((dn) => dn.setBy === C.uid ? dn.resetLabel === dn.active || dn.active === J[q.index][C.xAxis.dataKey] ? N(C.runtime.seriesLabels[ge.key]) : sn : N(C.runtime.seriesLabels[ge.key]))[0] : N(C.runtime.seriesLabels[ge.key]), Ee && (Xt = At), pt && (Xt = "transparent"), C.legend.colorCode && (Xt = p(X.length, q.index, At)), rt && (Xt = Wa(At).brighten(1)), Xt;
          }
          return rt && (Xt = Wa(At).brighten(1)), C.legend.colorCode && (Xt = p(X.length, q.index, At)), pt && (Xt = "transparent"), Xt;
        }, Yt = 5, xt = Ze + (C.xAxis.type !== "date-time" ? Ve / 2 : 0), Gt = t(
          me.dynamicData && me.CI[ge.key] ? me.CI[ge.key].upper : me[C.confidenceKeys.upper]
        ), Sn = t(
          me.dynamicData && me.CI[ge.key] ? me.CI[ge.key].lower : me[C.confidenceKeys.lower]
        );
        return /* @__PURE__ */ n.createElement(at, { key: `${q.index}--${De}` }, /* @__PURE__ */ n.createElement(at, { key: `bar-sub-group-${q.index}-${q.x0}-${bt}--${De}` }, Ms({
          config: C,
          index: et,
          id: `barGroup${q.index}`,
          background: ln(N(C.runtime.seriesLabels[ge.key])),
          borderColor: zt,
          borderStyle: "solid",
          borderWidth: `${Jt}px`,
          width: Ve,
          height: jt,
          x: Ze,
          y: bt,
          onMouseOver: () => b(qe, ge.key),
          onMouseLeave: E,
          tooltipHtml: _e,
          tooltipId: `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
          onClick: (At) => {
            At.preventDefault(), $ && (ge[C.xAxis.dataKey] = qe, $(C.uid, ge));
          },
          styleOverrides: {
            transformOrigin: `0 ${bt + jt}px`,
            opacity: ve ? 0.2 : 1,
            display: Ae ? "block" : "none",
            cursor: R ? "pointer" : "default"
          }
        }), C.preliminaryData.map((At, nn) => {
          const Xt = !At.column || At.column === ge.key;
          if (!(String(At.value) === String(ge.value) && At.value !== "" && Xt) || Ve < 10 || !C.general.showSuppressedSymbol || At.hideBarSymbol)
            return;
          const xn = String(At.symbol).includes("Asterisk"), dn = xn ? -5 : -8, Lt = xn ? "middle" : "end", nt = At.symbol === "Asterisk" ? Ve * 1.2 : At.symbol === "Double Asterisk" ? Ve : Ve / 1.5, bn = At.displayGray ? "#8b8b8a" : "#000";
          return /* @__PURE__ */ n.createElement(
            vt,
            {
              key: nn,
              dy: dn,
              display: Ae ? "block" : "none",
              opacity: ve ? 0.5 : 1,
              x: Ze + Ve / 2,
              y: bt,
              verticalAnchor: Lt,
              fill: bn,
              textAnchor: "middle",
              fontSize: `${nt}px`
            },
            At.iconCode
          );
        }), /* @__PURE__ */ n.createElement(
          vt,
          {
            display: Ae ? "block" : "none",
            opacity: ve ? 0.5 : 1,
            x: Ze + Ve / 2,
            y: bt - 5,
            fill: st,
            textAnchor: "middle"
          },
          Ss(ge.value) ? "" : Ut
        ), /* @__PURE__ */ n.createElement(
          vt,
          {
            display: Ae ? "block" : "none",
            opacity: ve ? 0.5 : 1,
            x: Ze + Ve / 2,
            y: bt - 5,
            fill: st,
            textAnchor: "middle",
            fontSize: C.isLollipopChart ? null : Ve / 2
          },
          $t
        ), C.isLollipopChart && C.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: mt,
            cx: Ze + A / 3.5,
            cy: ge.y,
            r: A / 2,
            fill: ln(N(C.runtime.seriesLabels[ge.key])),
            key: `circle--${ge.index}`,
            "data-tooltip-html": _e,
            "data-tooltip-id": `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
            style: { filter: "unset", opacity: 1 }
          }
        ), C.isLollipopChart && C.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
          "rect",
          {
            display: mt,
            x: Ze - S / 2,
            y: ge.y,
            width: A,
            height: A,
            fill: ln(N(C.runtime.seriesLabels[ge.key])),
            key: `circle--${ge.index}`,
            "data-tooltip-html": _e,
            "data-tooltip-id": `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
            style: { opacity: 1, filter: "unset" }
          },
          /* @__PURE__ */ n.createElement("animate", { attributeName: "height", values: `0, ${A}`, dur: "2.5s" })
        ), K && ge.value !== void 0 && me && /* @__PURE__ */ n.createElement(
          "path",
          {
            key: `confidence-interval-v-${me[C.runtime.originalXAxis.dataKey]}`,
            stroke: ie,
            strokeWidth: "px",
            d: `M${xt - Yt} ${Gt}
                                L${xt + Yt} ${Gt}
                                M${xt} ${Gt}
                                L${xt} ${Sn}
                                M${xt - Yt} ${Sn}
                                L${xt + Yt} ${Sn}`
          }
        )));
      })
    ))
  ), /* @__PURE__ */ n.createElement(bp, { xScale: e, yMax: a, barWidth: o, totalBarsInGroup: c }));
}, ok = () => {
  var K;
  const { xScale: e, yScale: t, yMax: r, seriesScale: a } = ue.useContext(Fs), {
    transformedData: i,
    tableData: o,
    colorScale: d,
    seriesHighlight: c,
    config: s,
    formatNumber: p,
    formatDate: m,
    parseDate: y,
    setSharedFilter: x,
    isNumber: T
  } = ue.useContext(gt), {
    isHorizontal: S,
    barBorderWidth: A,
    updateBars: E,
    assignColorsToValues: b,
    section: v,
    fontSize: N,
    isLabelBelowBar: C,
    displayNumbersOnBar: R,
    lollipopBarWidth: _,
    lollipopShapeSize: U,
    getHighlightedBarColorByValue: j,
    getHighlightedBarByValue: te,
    getAdditionalColumn: Q,
    hoveredBar: $,
    onMouseLeaveBar: J,
    onMouseOverBar: ne
  } = Os(), { HighLightedBarUtils: z } = Ic(s), W = Object.keys(s.confidenceKeys).length > 0, ie = dg(s, i, W), ae = document.documentElement, oe = getComputedStyle(ae).getPropertyValue("--cool-gray-90");
  return s.visualizationSubType !== "stacked" && s.visualizationType === "Bar" && s.orientation === "horizontal" && /* @__PURE__ */ n.createElement(at, null, /* @__PURE__ */ n.createElement(
    Iy,
    {
      data: (K = s.preliminaryData) != null && K.some((Y) => Y.value && Y.type === "suppression") ? o : ie,
      keys: s.runtime.barSeriesKeys || s.runtime.seriesKeys,
      height: r,
      x0: (Y) => Y[s.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: a,
      yScale: e,
      color: () => ""
    },
    (Y) => E(Y).map((X, q) => /* @__PURE__ */ n.createElement(
      at,
      {
        className: `bar-group-${X.index}-${X.x0}--${q} ${s.orientation}`,
        key: `bar-group-${X.index}-${X.x0}--${q}`,
        id: `bar-group-${X.index}-${X.x0}--${q}`,
        top: X.y
      },
      X.bars.map((ce, ge) => {
        var Lt;
        const De = ie[X.index], me = De[s.runtime.originalXAxis.dataKey], Fe = s.yAxis.type === "logarithmic" ? 0.1 : 0;
        let Ue = s.highlightedBarValues.map((nt) => nt.value).filter((nt) => nt !== void 0);
        Ue = s.xAxis.type === "date" ? z.formatDates(Ue) : Ue;
        let Te = s.legend.behavior === "highlight" && c.length > 0 && c.indexOf(ce.key) === -1, ve = s.legend.behavior === "highlight" || c.length === 0 || c.indexOf(ce.key) !== -1, Ae = s.barHeight, fe = parseInt(s.isLollipopChart ? _ : Ae);
        isNaN(fe) && (fe = 25);
        let ze = ce.value >= 0 && T(ce.value) ? ce.y : t(Fe);
        const Oe = Math.abs(e(ce.value) - e(Fe)), Ve = ce.value >= 0 && T(ce.value), {
          barWidthHorizontal: Ze,
          isSuppressed: Ie,
          getAbsentDataLabel: qe
        } = cg({ bar: ce, defaultBarWidth: Oe, config: s, isNumber: T, isVertical: !1 }), et = ce.value < 0 ? Math.abs(e(ce.value)) : e(Fe), He = p(ce.value, "left"), Ge = s.runtime[v].type === "date" ? m(y(me)) : me, Le = Ve ? "above" : "below", _e = qe(He), st = s.yAxis.displayNumbersOnBar ? He : "", Ee = Jn(st, `normal ${N[s.fontSize]}px sans-serif`), rt = Number(Ee) < Oe - 5;
        let pt = rt ? "end" : "start", ft = "start", wt = rt ? -5 : 5, zt = 10;
        Le === "below" && (pt = rt ? "start" : "end", wt = rt ? 5 : -5, s.isLollipopChart && (ft = "end", zt = -10));
        const Jt = ce.value < 0 ? -1 : ge;
        let jt = s.runtime.yAxis.label ? `${s.runtime.yAxis.label}: ${Ge}` : Ge;
        const on = Q($), _t = `${s.runtime.seriesLabels[ce.key]}: ${He}`, tn = `<ul>
                  <li class="tooltip-heading"">${jt}</li>
                  <li class="tooltip-body ">${_t}</li>
                  <li class="tooltip-body ">${on}</li>
                    </li></ul>`;
        let $t = "#000000";
        $t = z.checkFontColor(He, Ue, $t);
        let Ut = s.runtime.seriesLabels && s.runtime.seriesLabels[ce.key] ? d(s.runtime.seriesLabels[ce.key]) : d(ce.key);
        s.series.find((nt) => nt.dynamicCategory) || (Ut = b(Y.length, X.index, Ut));
        const mt = s.isLollipopChart && s.lollipopColorStyle === "regular", ln = s.isLollipopChart && s.lollipopColorStyle === "two-tone", Yt = Ue == null ? void 0 : Ue.includes(Ge), xt = j(Ge), Gt = te(Ge), Sn = Yt ? xt : s.barHasBorder === "true" ? "#000" : "transparent", At = Yt ? Gt.borderWidth : s.isLollipopChart ? 0 : s.barHasBorder === "true" ? A : 0, nn = Ss(ce.value) ? "none" : "block";
        Ut && $t && rt && ($t = ll("#000", Ut));
        const Xt = () => mt ? Ut : ln ? Wa(Ut).brighten(1) : Yt ? "transparent" : Ut, sn = 5, Nt = Ae * ce.index + Ae / 2, [xn, dn] = ["upper", "lower"].map((nt) => {
          if (!W)
            return;
          const bn = De.dynamicData ? De.CI[ce.key][nt] : De[s.confidenceKeys[nt]];
          return e(bn);
        });
        return /* @__PURE__ */ n.createElement(at, { key: `${X.index}--${ge}` }, /* @__PURE__ */ n.createElement(at, { key: `bar-sub-group-${X.index}-${X.x0}-${ze}--${ge}` }, Ms({
          config: s,
          index: Jt,
          id: `barGroup${X.index}`,
          background: Xt(),
          borderColor: Sn,
          borderStyle: "solid",
          borderWidth: `${At}px`,
          width: Ze,
          height: fe,
          x: et,
          y: Ae * ce.index,
          onMouseOver: () => ne(Ge, ce.key),
          onMouseLeave: J,
          tooltipHtml: tn,
          tooltipId: `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
          onClick: (nt) => {
            nt.preventDefault(), x && (ce[s.xAxis.dataKey] = He, x(s.uid, ce));
          },
          styleOverrides: {
            transformOrigin: `0 ${ze + Ae}px`,
            opacity: Te ? 0.2 : 1,
            display: ve ? "block" : "none"
          }
        }), (Lt = s.preliminaryData) == null ? void 0 : Lt.map((nt, bn) => {
          const Hn = !nt.column || nt.column === ce.key;
          if (!(String(nt.value) === String(ce.value) && nt.value !== "" && Hn) || nt.hideBarSymbol || !s.general.showSuppressedSymbol)
            return;
          const _n = String(nt.symbol).includes("Asterisk") ? "middle" : "end", Pn = nt.symbol === "Asterisk" ? Ae * 1.2 : nt.symbol === "Double Asterisk" ? Ae : Ae / 1.5, pn = nt.displayGray ? "#8b8b8a" : "#000";
          return /* @__PURE__ */ n.createElement(
            vt,
            {
              key: bn,
              fontSize: Pn,
              display: ve ? "block" : "none",
              opacity: Te ? 0.5 : 1,
              x: et,
              y: s.barHeight / 2 + s.barHeight * ce.index,
              fill: pn,
              dy: s.barHeight / 5,
              dx: 10,
              textAnchor: "start",
              verticalAnchor: _n
            },
            nt.iconCode
          );
        }), !s.isLollipopChart && /* @__PURE__ */ n.createElement(
          vt,
          {
            display: ve ? "block" : "none",
            x: ce.y,
            opacity: Te ? 0.5 : 1,
            y: s.barHeight / 2 + s.barHeight * ce.index,
            fill: $t,
            dx: wt,
            verticalAnchor: "middle",
            textAnchor: pt
          },
          Ss(ce.value) ? "" : st
        ), /* @__PURE__ */ n.createElement(
          vt,
          {
            display: ve ? "block" : "none",
            x: ce.y,
            opacity: Te ? 0.5 : 1,
            y: s.barHeight / 2 + s.barHeight * ce.index,
            fill: $t,
            dx: _e === "N/A" ? 20 : wt,
            dy: s.isLollipopChart ? -10 : 0,
            verticalAnchor: "middle",
            textAnchor: _e === "N/A" ? "middle" : pt
          },
          _e
        ), s.isLollipopChart && /* @__PURE__ */ n.createElement(
          vt,
          {
            display: ve ? "block" : "none",
            x: ce.y,
            y: 0,
            fill: "#000000",
            dx: zt,
            textAnchor: ft,
            verticalAnchor: "middle",
            fontWeight: "normal"
          },
          Ss(ce.value) ? "" : st
        ), C && !s.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          vt,
          {
            x: s.yAxis.hideAxis ? 0 : 5,
            y: X.height,
            dy: 4,
            verticalAnchor: "start",
            textAnchor: "start"
          },
          s.runtime.yAxis.type === "date" ? m(y(me)) : S ? me : p(me)
        ), s.isLollipopChart && s.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: nn,
            cx: ce.y,
            cy: Ae * ce.index + _ / 2,
            r: U / 2,
            fill: Ut,
            key: `circle--${ce.index}`,
            "data-tooltip-html": tn,
            "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
            style: { filter: "unset", opacity: 1 }
          }
        ), s.isLollipopChart && s.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
          "rect",
          {
            display: nn,
            x: ce.y > 10 ? ce.y - U / 2 : 0,
            y: 0 - _ / 2,
            width: U,
            height: U,
            fill: Ut,
            key: `circle--${ce.index}`,
            "data-tooltip-html": tn,
            "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
            style: { opacity: 1, filter: "unset" }
          },
          /* @__PURE__ */ n.createElement("animate", { attributeName: "height", values: `0, ${U}`, dur: "2.5s" })
        ), W && /* @__PURE__ */ n.createElement(
          "path",
          {
            key: `confidence-interval-h-${Nt}-${De[s.runtime.originalXAxis.dataKey]}`,
            stroke: oe,
            strokeWidth: "px",
            d: `
                                M${dn} ${Nt - sn}
                                L${dn} ${Nt + sn}
                                M${dn} ${Nt}
                                L${xn} ${Nt}
                                M${xn} ${Nt - sn}
                                L${xn} ${Nt + sn} `
          }
        )));
      })
    ))
  ));
}, Vu = {
  Vertical: ik,
  Horizontal: ok,
  StackedVertical: rk,
  StackedHorizontal: ak
}, lk = ({ xScale: e, yScale: t, seriesScale: r, xMax: a, yMax: i, handleTooltipMouseOver: o, handleTooltipMouseOff: d, handleTooltipClick: c }) => {
  const { transformedData: s, config: p } = ue.useContext(gt), m = {
    xScale: e,
    yScale: t,
    xMax: a,
    yMax: i,
    seriesScale: r
  };
  return /* @__PURE__ */ n.createElement($r, { component: "BarChart" }, /* @__PURE__ */ n.createElement(Fs.Provider, { value: m }, /* @__PURE__ */ n.createElement(at, { left: parseFloat(p.runtime.yAxis.size) }, /* @__PURE__ */ n.createElement(Vu.StackedVertical, null), /* @__PURE__ */ n.createElement(Vu.StackedHorizontal, null), /* @__PURE__ */ n.createElement(Vu.Vertical, null), /* @__PURE__ */ n.createElement(Vu.Horizontal, null), /* @__PURE__ */ n.createElement(Lr, { key: "bars", display: p.tooltips.singleSeries ? "none" : "block", width: Number(a), height: Number(i), fill: "transparent", fillOpacity: 0.05, onMouseMove: (y) => o(y, s), onMouseOut: d, onClick: (y) => c(y, s) }))));
};
function Ia() {
  return Ia = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ia.apply(this, arguments);
}
function Fi(e) {
  var t = e.x1, r = e.x2, a = e.y1, i = e.y2;
  return {
    x1: a,
    x2: i,
    y1: t,
    y2: r
  };
}
function fg(e) {
  var t = e.left, r = t === void 0 ? 0 : t, a = e.top, i = a === void 0 ? 0 : a, o = e.className, d = e.max, c = e.min, s = e.firstQuartile, p = e.thirdQuartile, m = e.median, y = e.boxWidth, x = y === void 0 ? 10 : y, T = e.fill, S = e.fillOpacity, A = e.stroke, E = e.strokeWidth, b = e.rx, v = b === void 0 ? 2 : b, N = e.ry, C = N === void 0 ? 2 : N, R = e.valueScale, _ = e.outliers, U = _ === void 0 ? [] : _, j = e.horizontal, te = e.medianProps, Q = te === void 0 ? {} : te, $ = e.maxProps, J = $ === void 0 ? {} : $, ne = e.minProps, z = ne === void 0 ? {} : ne, W = e.boxProps, ie = W === void 0 ? {} : W, ae = e.outlierProps, oe = ae === void 0 ? {} : ae, K = e.container, Y = K === void 0 ? !1 : K, X = e.containerProps, q = X === void 0 ? {} : X, ce = e.children, ge = j ? i : r, De = ge + (x || 0) / 2, me = R.range(), Fe = R(c ?? 0), Ue = R(s ?? 0), Te = R(m ?? 0), ve = R(p ?? 0), Ae = R(d ?? 0), fe = {
    valueRange: me,
    center: De,
    offset: ge,
    boxWidth: x,
    max: {
      x1: De - (x || 0) / 4,
      x2: De + (x || 0) / 4,
      y1: Ae,
      y2: Ae
    },
    maxToThird: {
      x1: De,
      x2: De,
      y1: Ae,
      y2: ve
    },
    median: {
      x1: ge,
      x2: ge + (x || 0),
      y1: Te,
      y2: Te
    },
    minToFirst: {
      x1: De,
      x2: De,
      y1: Ue,
      y2: Fe
    },
    min: {
      x1: De - (x || 0) / 4,
      x2: De + (x || 0) / 4,
      y1: Fe,
      y2: Fe
    },
    box: {
      x1: ge,
      x2: x || 0,
      y1: ve,
      y2: Math.abs(ve - Ue)
    },
    container: {
      x1: ge,
      x2: x || 0,
      y1: Math.min.apply(Math, me),
      y2: Math.abs(me[0] - me[1])
    }
  };
  return j && (fe.max = Fi(fe.max), fe.maxToThird = Fi(fe.maxToThird), fe.box.y1 = Ue, fe.box = Fi(fe.box), fe.median = Fi(fe.median), fe.minToFirst = Fi(fe.minToFirst), fe.min = Fi(fe.min), fe.container = Fi(fe.container), fe.container.y1 = Math.min.apply(Math, me)), ce ? /* @__PURE__ */ n.createElement(n.Fragment, null, ce(fe)) : /* @__PURE__ */ n.createElement(at, {
    className: Dn("visx-boxplot", o)
  }, U.map(function(ze, Oe) {
    var Ve = j ? R(ze) : De, Ze = j ? De : R(ze);
    return /* @__PURE__ */ n.createElement("circle", Ia({
      key: "visx-boxplot-outlier-" + Oe,
      className: "visx-boxplot-outlier",
      cx: Ve,
      cy: Ze,
      r: 4,
      stroke: A,
      strokeWidth: E,
      fill: T,
      fillOpacity: S
    }, oe));
  }), /* @__PURE__ */ n.createElement("line", Ia({
    className: "visx-boxplot-max",
    x1: fe.max.x1,
    y1: fe.max.y1,
    x2: fe.max.x2,
    y2: fe.max.y2,
    stroke: A,
    strokeWidth: E
  }, J)), /* @__PURE__ */ n.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: fe.maxToThird.x1,
    y1: fe.maxToThird.y1,
    x2: fe.maxToThird.x2,
    y2: fe.maxToThird.y2,
    stroke: A,
    strokeWidth: E
  }), /* @__PURE__ */ n.createElement("rect", Ia({
    className: "visx-boxplot-box",
    x: fe.box.x1,
    y: fe.box.y1,
    width: fe.box.x2,
    height: fe.box.y2,
    stroke: A,
    strokeWidth: E,
    fill: T,
    fillOpacity: S,
    rx: v,
    ry: C
  }, ie)), /* @__PURE__ */ n.createElement("line", Ia({
    className: "visx-boxplot-median",
    x1: fe.median.x1,
    y1: fe.median.y1,
    x2: fe.median.x2,
    y2: fe.median.y2,
    stroke: A,
    strokeWidth: E
  }, Q)), /* @__PURE__ */ n.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: fe.minToFirst.x1,
    y1: fe.minToFirst.y1,
    x2: fe.minToFirst.x2,
    y2: fe.minToFirst.y2,
    stroke: A,
    strokeWidth: E
  }), /* @__PURE__ */ n.createElement("line", Ia({
    className: "visx-boxplot-min",
    x1: fe.min.x1,
    y1: fe.min.y1,
    x2: fe.min.x2,
    y2: fe.min.y2,
    stroke: A,
    strokeWidth: E
  }, z)), Y && /* @__PURE__ */ n.createElement("rect", Ia({
    x: fe.container.x1,
    y: fe.container.y1,
    width: fe.container.x2,
    height: fe.container.y2,
    fillOpacity: "0"
  }, q)));
}
fg.propTypes = {
  max: $e.number,
  min: $e.number,
  firstQuartile: $e.number,
  thirdQuartile: $e.number,
  median: $e.number,
  boxWidth: $e.number,
  fill: $e.string,
  fillOpacity: $e.oneOfType([$e.number, $e.string]),
  stroke: $e.string,
  strokeWidth: $e.oneOfType([$e.number, $e.string]),
  rx: $e.number,
  ry: $e.number,
  outliers: $e.arrayOf($e.number),
  container: $e.bool,
  children: $e.func
};
const sk = (e, t, r, a, i, o, d) => `
      <strong>${t.columnCategory}</strong></br>
       <strong>Key:${r}</strong></br>
      ${e.labels.q1}: ${a}<br/>
      ${e.labels.q3}: ${i}<br/>
      ${e.labels.iqr}: ${d}<br/>
      ${e.labels.median}: ${o}
    `, uk = (e) => {
  if (!e || !e.length)
    return {};
  const t = lt.sortBy(e);
  return {
    min: xf(e),
    max: Qu(e),
    median: Hm(e),
    firstQuartile: bf(t, 0.25),
    thirdQuartile: bf(t, 0.75)
  };
}, ck = (e, t, r) => {
  const a = t.series.map((d) => d == null ? void 0 : d.dataKey), i = {}, o = r.filter((d) => d[t.xAxis.dataKey] === e);
  return a.forEach((d) => {
    i[d] = o.map((c) => c[d]);
  }), i;
}, dk = (e, t) => {
  const r = e.map((o) => o[t.xAxis.dataKey]), a = [], i = lt.uniq(r);
  return i && i.length > 0 && i.forEach((o) => {
    a.push({
      columnCategory: o,
      keyValues: ck(o, t, e)
    });
  }), a;
}, fk = ({ xScale: e, yScale: t, seriesScale: r }) => {
  const { config: a, colorScale: i, seriesHighlight: o, transformedData: d } = ue.useContext(gt), { boxplot: c } = a, s = `cdc-open-viz-tooltip-${a.runtime.uniqueId}`, p = e.bandwidth(), m = Math.min(40, p), y = lt.get(vr, [a.palette, 0], "#000");
  return /* @__PURE__ */ n.createElement($r, { component: "BoxPlot" }, /* @__PURE__ */ n.createElement(at, { left: Number(a.yAxis.size), className: "boxplot", key: "boxplot-group" }, dk(d, a).map((x, T) => {
    const S = p - m, A = 4;
    return /* @__PURE__ */ n.createElement(
      at,
      {
        key: `boxplotplot-${x.columnCategory}`,
        left: e(x.columnCategory) + (e.bandwidth() - r.bandwidth()) / 2
      },
      a.series.map((E, b) => {
        const v = x.keyValues[E.dataKey], { min: N, max: C, median: R, firstQuartile: _, thirdQuartile: U } = uk(v);
        let j = Number(U - _).toFixed(a.dataFormat.roundTo);
        const te = a.legend.behavior === "highlight" && o.length > 0 && o.indexOf(E.dataKey) === -1, Q = a.legend.behavior === "highlight" || o.length === 0 || o.indexOf(E.dataKey) !== -1, $ = te ? 0.3 : 0.5;
        return /* @__PURE__ */ n.createElement(at, { key: `boxplotplot-${E.dataKey}-${b}` }, c.plotNonOutlierValues && v.map((J, ne) => /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: Q ? "block" : "none",
            cx: r(E.dataKey) + r.bandwidth() / 2,
            cy: t(J),
            r: A,
            fill: "#ccc",
            style: { opacity: $, fillOpacity: 1, stroke: "black" },
            key: `boxplot-${T}--circle-${ne}`
          }
        )), Q && /* @__PURE__ */ n.createElement(
          fg,
          {
            display: Q ? "block" : "none",
            "data-left": e(x.columnCategory) + a.yAxis.size + S / 2 + 0.5,
            key: `box-plot-${T}-${E}`,
            min: Number(N),
            max: Number(C),
            left: r(E.dataKey),
            firstQuartile: _,
            thirdQuartile: U,
            median: R,
            boxWidth: r.bandwidth(),
            fill: i(E.dataKey),
            fillOpacity: $,
            stroke: $ ? "rgba(0,0,0,0.2)" : "rgba(0,0,0,0.1)",
            valueScale: t,
            outliers: c.plotOutlierValues ? x.columnOutliers : [],
            outlierProps: {
              style: {
                fill: `${y}`,
                opacity: $
              }
            },
            medianProps: {
              style: {
                stroke: "black",
                opacity: $
              }
            },
            boxProps: {
              style: {
                stroke: "black",
                strokeWidth: c.borders === "true" ? 1 : 0,
                opacity: $
              }
            },
            maxProps: {
              style: {
                stroke: "black",
                opacity: $
              }
            },
            container: !0,
            containerProps: {
              "data-tooltip-html": sk(
                c,
                x,
                E.dataKey,
                _,
                U,
                R,
                j
              ),
              "data-tooltip-id": s,
              tabIndex: -1
            }
          }
        ));
      })
    );
  })));
}, pk = ({ xScale: e, yScale: t }) => {
  const {
    transformedData: r,
    config: a,
    tableData: i,
    formatNumber: o,
    seriesHighlight: d,
    colorPalettes: c
  } = ue.useContext(gt), s = 4.5, p = Object.keys(a.runtime.seriesLabels).length > 1, m = Object.entries(a.columns).filter(([x, T]) => T.tooltips).map(([x, T]) => [
    T.label || T.name,
    T.name,
    {
      addColPrefix: T.prefix,
      addColSuffix: T.suffix,
      addColRoundTo: T.roundToPlace,
      addColCommas: T.commas
    }
  ]), y = (x, T, S) => `<div>
    ${a.legend.showLegendValuesTooltip && a.runtime.seriesLabels && p ? `${a.runtime.seriesLabels[T] || ""}<br/>` : ""}
    ${a.xAxis.label}: ${o(x[a.xAxis.dataKey], "bottom")} <br/>
    ${a.yAxis.label}: ${o(x[T], "left")}<br/>
   ${m.map(
    ([A, E, b]) => `${A} : ${qf(i[S][E], "left", !1, a, b)}<br/>`
  ).join("")}
</div>`;
  return /* @__PURE__ */ n.createElement(at, { className: "scatter-plot", left: a.yAxis.size }, r.map((x, T) => a.runtime.seriesKeys.map((S, A) => {
    const E = a.legend.behavior === "highlight" && d.length > 0 && d.indexOf(S) === -1, b = a.legend.behavior === "highlight" || d.length === 0 || d.indexOf(S) !== -1, v = a != null && a.customColors ? a.customColors[A] : a.palette ? c[a.palette][A] : "#000";
    let N = {
      filter: "unset",
      opacity: 1,
      stroke: b ? "black" : ""
    };
    return /* @__PURE__ */ n.createElement(
      "circle",
      {
        key: `${T}-${A}`,
        r: s,
        cx: e(x[a.xAxis.dataKey]),
        cy: t(x[S]),
        fill: b ? v : "transparent",
        fillOpacity: E ? 0.25 : 1,
        style: N,
        "data-tooltip-html": y(x, S, T),
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      }
    );
  })));
};
function hk({ height: e, xScale: t }) {
  const {
    transformedData: r,
    config: a,
    formatNumber: i,
    twoColorPalette: o,
    updateConfig: d,
    parseDate: c,
    formatDate: s,
    currentViewport: p
  } = ue.useContext(gt), { barStyle: m, tipRounding: y, roundingStyle: x, twoColor: T } = a, S = ue.useRef([]), [A, E] = ue.useState(window.innerWidth), b = x === "standard" ? "8px" : x === "shallow" ? "5px" : x === "finger" ? "15px" : "0px", v = { small: 16, medium: 18, large: 20 };
  a.barStyle;
  const N = Number(a.xAxis.target), C = a.series[0].dataKey, R = Number(t.domain()[1]), U = r.some((oe) => oe[C] < 0) || N > 0 || t.domain()[0] < 0, j = a.barHasBorder === "true" ? 1 : 0, te = a.lollipopSize === "large" ? 7 : a.lollipopSize === "medium" ? 6 : 5, Q = a.lollipopSize === "large" ? 14 : a.lollipopSize === "medium" ? 12 : 10, $ = Math.max(t(0), Math.min(t(N), t(R))), J = (oe) => {
    if (oe == null || m !== "rounded")
      return;
    let K = {};
    return oe === "left" && (K = { borderRadius: `${b} 0 0 ${b}` }), oe === "right" && (K = { borderRadius: `0 ${b} ${b} 0` }), y === "full" && (K = { borderRadius: b }), K;
  }, ne = {
    calculate: function() {
      const K = r[0][C] < N ? "left" : "right", Y = `${a.xAxis.targetLabel} ${i(a.xAxis.target || 0, "left")}`, X = Jn(Y, `bold ${v[a.fontSize]}px sans-serif`);
      let q = a.isLollipopChart ? te / 2 : Number(a.barHeight) / 2, ce = 0, ge = 0, De = !1;
      K === "right" && (ce = -10, De = X - ce < $, ge = $ - X), K === "left" && (ce = 10, De = t(R) - $ > X + ce, ge = $), this.text = Y, this.y = q, this.x = ge, this.padding = ce, this.showLabel = a.xAxis.showTargetLabel ? De : !1;
    }
  };
  ne.calculate();
  const z = ue.useRef(null), W = gp(z, {});
  ue.useEffect(() => {
    const oe = () => {
      var K;
      E(window.innerWidth), (K = S.current) == null || K.forEach((Y) => {
        !Y || !Y.style || (Y.style.transition = "none", Y.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", oe), () => {
      window.removeEventListener("resize", oe);
    };
  }, []);
  const [ie, ae] = ue.useState(!1);
  return ue.useEffect(() => {
    W != null && W.isIntersecting && setTimeout(() => {
      ae(!0);
    }, 100);
  }, [W == null ? void 0 : W.isIntersecting, a.animate]), ue.useEffect(() => {
    var oe;
    (oe = S.current) == null || oe.forEach((K, Y) => {
      if (!(!K || !K.style)) {
        if (a.animate) {
          const X = N / R * 100;
          K.style.opacity = "0", K.style.transform = `translate(${X / 1.07}%) scale(0, 1)`, setTimeout(() => {
            K.style.opacity = "1", K.style.transform = "translate(0) scale(1)", K.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          K.style.transition = "none", K.style.opacity = "0";
        a.animate || (K.style.transition = "none", K.style.opacity = "1");
      }
    });
  }, [a.animate, a, ie]), /* @__PURE__ */ n.createElement($r, { component: "Deviation Bar" }, /* @__PURE__ */ n.createElement(at, { left: Number(a.xAxis.size) }, r.map((oe, K) => {
    const Y = Number(oe[C]), X = a.isLollipopChart ? te : Number(a.barHeight), q = Number(a.barSpace), ce = Math.abs(t(Y) - $), ge = t(Y), De = Y > N ? $ : ge, me = Y < N ? "left" : "right";
    let Fe = 0;
    Fe = K !== 0 ? (q + X + j) * K : Fe;
    const Ue = (q + X + j) * r.length;
    a.heights.horizontal = Ue;
    const ve = Jn(
      i(Y, "left"),
      `normal ${v[a.fontSize]}px sans-serif`
    ) < ce - 6, Ae = ge, fe = Fe + X / 2, ze = ge, Oe = Fe + X / 2, Ve = ge, Ze = Fe - X / 2, Ie = J(me), [qe, et] = o[T.palette], He = { left: qe, right: et }, Ge = ll("#000", He[me]);
    let Le = mk(a.isLollipopChart, ve, Q, Ge);
    const _e = i(Y, "left"), st = a.runtime.yAxis.type === "date" ? s(c(r[K][a.runtime.originalXAxis.dataKey])) : r[K][a.runtime.originalXAxis.dataKey];
    let Ee = a.runtime.yAxis.label ? `${a.runtime.yAxis.label}: ${st}` : st, rt = a.runtime.xAxis.label ? `${a.runtime.xAxis.label}: ${_e}` : _e;
    const pt = `<div>
          ${Ee}<br />
          ${rt}
            </div>`;
    return /* @__PURE__ */ n.createElement(at, { key: `deviation-bar-${a.orientation}-${C}-${K}` }, /* @__PURE__ */ n.createElement(
      "foreignObject",
      {
        ref: (ft) => {
          S.current[K] = ft;
        },
        x: De,
        y: Fe,
        width: ce,
        height: X,
        "data-tooltip-html": pt,
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      },
      /* @__PURE__ */ n.createElement(
        "div",
        {
          style: {
            width: ce,
            height: X,
            border: `${j}px solid #333`,
            backgroundColor: He[me],
            ...Ie
          }
        }
      )
    ), a.yAxis.displayNumbersOnBar && /* @__PURE__ */ n.createElement(vt, { verticalAnchor: "middle", x: Ae, y: fe, ...Le[me] }, i(oe[C], "left")), a.isLollipopChart && a.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
      "circle",
      {
        cx: ze,
        cy: Oe,
        r: Q / 2,
        fill: He[me],
        style: { filter: "unset", opacity: 1 }
      }
    ), a.isLollipopChart && a.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
      "rect",
      {
        x: Ve,
        y: Ze,
        width: Q,
        height: Q,
        fill: He[me],
        style: { opacity: 1, filter: "unset" }
      }
    ));
  }), ne.showLabel && /* @__PURE__ */ n.createElement(vt, { fontWeight: "bold", dx: ne.padding, verticalAnchor: "middle", x: ne.x, y: ne.y }, ne.text), U && /* @__PURE__ */ n.createElement(cn, { from: { x: $, y: 0 }, to: { x: $, y: e }, stroke: "#333", strokeWidth: 2 })), /* @__PURE__ */ n.createElement("foreignObject", { y: e / 2, ref: z }));
}
function mk(e, t, r, a) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: r + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -r,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? a : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? a : "#000000"
    }
  };
}
const yk = ({ xScale: e, yScale: t, height: r, width: a, handleTooltipMouseOver: i, handleTooltipMouseOff: o }) => {
  var S;
  const { transformedData: d, rawData: c, config: s, seriesHighlight: p } = ue.useContext(gt), { xAxis: m, yAxis: y, legend: x, runtime: T } = s;
  return d && /* @__PURE__ */ n.createElement($r, { component: "ForecastingChart" }, /* @__PURE__ */ n.createElement(at, { className: "forecasting-items", key: "forecasting-items-wrapper", left: Number(y.size) }, (S = T.forecastingSeriesKeys) == null ? void 0 : S.map((A, E) => !A || !A.stages ? !1 : A.stages.map((b, v) => {
    var U;
    const { behavior: N } = x, C = c.filter((j) => j[A.stageColumn] === b.key);
    let R = N === "highlight" && p.length > 0 && p.indexOf(b.key) === -1, _ = N === "highlight" || p.length === 0 || p.indexOf(b.key) !== -1;
    return /* @__PURE__ */ n.createElement(at, { className: `forecasting-areas-combo-${E}`, key: `forecasting-areas--stage-${b.key.replaceAll(" ", "-")}-${E}` }, (U = A.confidenceIntervals) == null ? void 0 : U.map((j, te) => {
      const Q = Zu[b.color] || vr[b.color] || !1, $ = () => _ && Q[2] ? Q[2] : "transparent", J = () => _ && Q[1] ? Q[1] : "transparent";
      if (!(j.high === "" || j.low === ""))
        return /* @__PURE__ */ n.createElement(at, { key: `forecasting-areas--stage-${b.key.replaceAll(" ", "-")}--group-${v}-${te}` }, /* @__PURE__ */ n.createElement(
          uE,
          {
            curve: Yu,
            data: C,
            fill: $(),
            opacity: R ? 0.1 : 0.5,
            x: (ne) => e(Date.parse(ne[m.dataKey])),
            y0: (ne) => t(ne[j.low]),
            y1: (ne) => t(ne[j.high])
          }
        ), te === 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Br, { data: C, x: (ne) => Number(e(Date.parse(ne[m.dataKey]))), y: (ne) => Number(t(ne[j.high])), curve: Yu, stroke: J(), strokeWidth: 1, strokeOpacity: 1 }), /* @__PURE__ */ n.createElement(Br, { data: C, x: (ne) => Number(e(Date.parse(ne[m.dataKey]))), y: (ne) => Number(t(ne[j.low])), curve: Yu, stroke: J(), strokeWidth: 1, strokeOpacity: 1 })));
    }));
  })), /* @__PURE__ */ n.createElement(at, { key: "tooltip-hover-section" }, /* @__PURE__ */ n.createElement(Lr, { key: "bars", width: Number(a), height: Number(r), fill: "transparent", fillOpacity: 0.05, onMouseMove: (A) => i(A, d), onMouseOut: o }))));
};
function Vc(e, t) {
  const r = e.series.every(({ type: T }) => T === "Bar"), a = e.series.every(({ type: T }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(T)), i = (T) => (S) => T.reduce((A, E) => isNaN(Number(S[E])) ? A : A + Number(S[E]), 0), o = (T) => {
    const S = e.runtime.series.find((A) => A.dataKey === T);
    return S != null && S.dynamicCategory ? S.originalDataKey : T;
  }, d = () => {
    let T = Math.max(
      ...t.map(
        (S) => Math.max(
          ...e.runtime.seriesKeys.map((A) => {
            const E = o(A);
            return Ki(S[E]) ? Number(p(S[E])) : 0;
          })
        )
      )
    );
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && r) && e.visualizationSubType === "stacked") {
      const S = t.map(i(e.runtime.seriesKeys)).filter((A) => !isNaN(A));
      T = Math.max(...S);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const S = t.map(i(e.runtime.seriesKeys));
      T = Math.max(...S);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (T = Math.max(
      ...t.map((S) => Ki(S[e.series.dataKey]) ? Number(p(S[e.series.dataKey])) : 0)
    )), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !r && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const S = t.map(i(e.runtime.barSeriesKeys)), A = Math.max(
        ...t.map((b) => Math.max(...e.runtime.lineSeriesKeys.map((v) => Number(p(b[v])))))
      ), E = Math.max(...S);
      T = Math.max(E, A);
    }
    return T;
  }, c = () => {
    const T = Math.min(
      ...t.map(
        (S) => Math.min(
          ...e.runtime.seriesKeys.map((A) => {
            const E = o(A);
            return Ki(S[E]) ? Number(p(S[E])) : 1 / 0;
          })
        )
      )
    );
    return String(T);
  }, s = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((T) => t.some((S) => S[o(T)] >= 0)) : !1, p = (T) => T === null || T === "" ? "" : typeof T == "string" ? T.replace(/[,$]/g, "") : T, m = Number(d()), y = Number(c()), x = s();
  return { minValue: y, maxValue: m, existPositiveValue: x, isAllLine: a };
}
function Ep({ config: e, yMax: t = 0, data: r = [], updateConfig: a }) {
  var x, T, S, A;
  const i = e.visualizationType === "Combo" && e.orientation === "vertical", o = e.series && e.series.filter((E) => E.axis === "Right").map((E) => E.dataKey);
  let { minValue: d } = Vc(e, r);
  const c = (E) => {
    if (!E)
      return [0];
    let b = [];
    return E.map((v, N) => b = [...b, ...r.map((C) => Number(C[v]))]), b;
  };
  let s = Math.max.apply(null, c(o));
  e.yAxis.rightMax > s && (s = e.yAxis.rightMax), e.yAxis.rightMin < d && (d = e.yAxis.rightMin);
  const p = ((T = (x = e.runtime) == null ? void 0 : x.barSeriesKeys) == null ? void 0 : T.length) > 0, m = ((A = (S = e.runtime) == null ? void 0 : S.lineSeriesKeys) == null ? void 0 : A.length) > 0;
  return (p || m) && d > 0 && (d = 0), { yScaleRight: jn({
    domain: [d, s],
    range: [t, 0]
  }), hasRightAxis: i };
}
const gk = (e) => {
  const { preliminaryData: t, data: r, stroke: a, strokeWidth: i, handleLineType: o, lineType: d, seriesKey: c } = e, s = t.filter(
    (x) => x.seriesKey && x.column && x.value && x.type && x.style && x.type === "effect"
  ), p = (x) => s.find(
    (T) => T.seriesKey === c && x[T.column] === T.value && T.type === "effect" && T.style !== "Open Circles"
  );
  let m = [];
  const y = (x) => ({
    stroke: a,
    strokeWidth: i,
    strokeDasharray: x
  });
  return r.forEach((x, T) => {
    let S = p(x), A = y(o(S ? S.style : d));
    m.push(A), S && T > 0 && (m[T - 1] = y(o(S.style)));
  }), m;
}, vk = (e, t, r) => {
  const a = e == null ? void 0 : e.filter((o) => o.style.includes("Circles") && o.type === "effect").map((o) => ({
    column: o.column,
    value: o.value,
    seriesKey: o.seriesKey,
    circleSize: o.circleSize,
    style: o.style
  })), i = [];
  return t.forEach((o) => {
    a.forEach((d) => {
      if (o[d.column] === d.value && d.seriesKey === r && o[r] && d.style === "Open Circles") {
        const c = {
          data: o,
          size: d.circleSize,
          isFilled: !1
        };
        i.push(c);
      }
      if ((!d.value || o[d.column] === d.value) && d.seriesKey === r && o[r] && d.style === "Filled Circles") {
        const c = {
          data: o,
          size: d.circleSize,
          isFilled: !0
        };
        i.push(c);
      }
    });
  }), i;
}, Tc = (e) => !isNaN(parseFloat(e)) && isFinite(e), xk = (e, t, r) => {
  let a = "0";
  const i = {
    data: { 0: [] },
    style: ""
  };
  if (!e.length)
    return i;
  const o = e[0], d = (s) => {
    if (!(s.type === "effect" || s.hideLineStyle))
      return s.type == "suppression" && s.value === o[t] && (!s.column || s.column === t);
  }, c = r.find(d);
  if (c && c.style) {
    const s = { ...o, [t]: 0 };
    i.data[a].push(s), i.style = c.style;
    let p = 1;
    for (; p < e.length && !Tc(e[p][t]); )
      p++;
    p < e.length && i.data[a].push(e[p]);
  } else
    i.data[a].push(o);
  return i;
}, bk = (e, t, r) => {
  let a = "0";
  const i = {
    data: { 0: [] },
    style: ""
  };
  let o = -1;
  return r == null || r.forEach((d) => {
    if (d.type !== "effect" && e[e.length - 1][t] === d.value && d.style && (!d.column || d.column === t) && d.type == "suppression" && !d.hideLineStyle) {
      const c = e.length - 1, s = { ...e[c], [t]: 0 };
      i.data[a].push(s);
      let p = c - 1;
      for (; p >= 0 && !Tc(e[p][t]); )
        p--;
      p >= 0 && o !== p && (i.data[a].push(e[p]), o = p), i.style = d.style;
    }
  }), i;
};
function Ek(e, t, r) {
  let a = {
    data: {},
    style: ""
  }, i = 1;
  return e.forEach((o, d) => {
    r.forEach((c) => {
      const s = c.value;
      if (o[t] === s) {
        let p = null, m = null;
        for (let y = d - 1; y >= 0; y--)
          if (Tc(e[y][t])) {
            p = e[y];
            break;
          }
        for (let y = d + 1; y < e.length; y++)
          if (Tc(e[y][t])) {
            m = e[y];
            break;
          }
        p && m && (a.style = c.style, a.data[i++] = [p, m]);
      }
    });
  }), a;
}
const Sk = (e, t, r, a) => {
  const i = xk(e, t, r), o = bk(e, t, r), d = Ek(e, t, r);
  return [i, d, o];
}, lf = (e) => {
  var C, R, _, U, j, te, Q, $, J;
  const {
    config: t,
    d: r,
    tableData: a,
    displayArea: i,
    seriesKey: o,
    tooltipData: d,
    xScale: c,
    yScale: s,
    colorScale: p,
    parseDate: m,
    yScaleRight: y,
    data: x,
    circleData: T,
    dataIndex: S,
    mode: A
  } = e, { lineDatapointStyle: E } = t, b = (R = (C = t == null ? void 0 : t.runtime) == null ? void 0 : C.series.filter((ne) => ne.dataKey === o)) == null ? void 0 : R[0], v = (ne, z, W, ie, ae) => {
    const oe = W.runtime.seriesLabels || [];
    let K;
    return ne ? K = z(oe[ie] || ae) : K = "transparent", W.lineDatapointColor === "Lighter than Line" && K !== "transparent" && K && (K = Wa(K).brighten(1)), K;
  }, N = (ne) => (t.xAxis.type === "categorical" ? c(ne) : c(m(ne))) + (c.bandwidth ? c.bandwidth() / 2 : 0);
  if (A === "ALWAYS_SHOW_POINTS") {
    if (E === "hidden")
      return /* @__PURE__ */ n.createElement(n.Fragment, null);
    if (E === "always show")
      return (T == null ? void 0 : T.some(
        (z) => z[t.xAxis.dataKey] === r[t.xAxis.dataKey] && z[o] === r[o]
      )) || !b ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(
        "circle",
        {
          cx: N(r[t.xAxis.dataKey]),
          cy: b.axis === "Right" ? y(r[b.dataKey]) : s(r[b.dataKey]),
          r: 4.5,
          opacity: r[o] ? 1 : 0,
          fillOpacity: 1,
          fill: v(i, p, t, o, o),
          style: { filter: "unset", opacity: 1 }
        }
      );
  }
  if (A === "HOVER_POINTS" && E === "hover") {
    if (!d || !o || !d.data)
      return;
    let ne = (U = (_ = d == null ? void 0 : d.data) == null ? void 0 : _[0]) == null ? void 0 : U[1];
    if (!ne)
      return;
    let z, W = d.data.filter((oe) => oe[0] === o), ie = (j = W == null ? void 0 : W[0]) == null ? void 0 : j[0], ae = (te = W == null ? void 0 : W[0]) == null ? void 0 : te[2];
    return ie ? (d == null || d.data.indexOf(ie), z = (Q = a == null ? void 0 : a.find((oe) => oe[t == null ? void 0 : t.xAxis.dataKey] === ne)) == null ? void 0 : Q[o], d == null ? void 0 : d.data.map((oe, K) => (t.runtime.seriesLabelsAll.indexOf(ne), isNaN(z) ? /* @__PURE__ */ n.createElement(n.Fragment, null) : (T == null ? void 0 : T.some((X) => X[t.xAxis.dataKey] === ne)) || !z ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(
      "circle",
      {
        cx: N(ne),
        cy: ae === "right" ? y(z) : s(z),
        r: 4.5,
        opacity: 1,
        fillOpacity: 1,
        fill: v(i, p, t, ie, o),
        style: { filter: "unset", opacity: 1 },
        key: `line-chart-circle--${JSON.stringify(oe)}--${K}`
      }
    )))) : void 0;
  }
  return A === "ISOLATED_POINTS" && A && ((z, W) => {
    let ie = !1;
    const ae = x[z], oe = z > 0 ? x[z - 1] : null, K = z < x.length - 1 ? x[z + 1] : null;
    let Y = !1;
    return T.forEach((X) => {
      (X == null ? void 0 : X.data[W]) === ae[W] && (ie = !0);
    }), z === 0 && K && !K[W] && (Y = !0), z === x.length - 1 && oe && !oe[W] && (Y = !0), z > 0 && z < x.length - 1 && ae && ae[W] && (!oe || !oe[W]) && (!K || !K[W]) && (Y = !0), ie && (Y = !1), Y;
  })(S, o) ? /* @__PURE__ */ n.createElement(
    "circle",
    {
      cx: N(r[($ = t.xAxis) == null ? void 0 : $.dataKey]),
      cy: (b == null ? void 0 : b.axis) === "Right" ? y(r[b == null ? void 0 : b.dataKey]) : s(r[b == null ? void 0 : b.dataKey]),
      r: 5.3,
      strokeWidth: 2,
      stroke: p(t.runtime.seriesLabels[o]),
      fill: p((J = t.runtime) == null ? void 0 : J.seriesLabels[o])
    }
  ) : null;
}, kk = (e) => {
  var m, y;
  const { config: t, xScale: r, yScale: a, parseDate: i } = e;
  if (!((m = t == null ? void 0 : t.runtime) != null && m.series))
    return;
  const o = (x) => {
    if (t.xAxis.type === "date")
      return i(x).getTime();
    if (t.xAxis.type === "date-time")
      return new Date(x);
    if (t.xAxis.type === "categorical")
      return x;
  }, d = (x) => r.bandwidth ? r.bandwidth() / 2 + Number(x) : Number(x), c = (x) => {
    var T;
    return (T = Object.values(t.columns)) == null ? void 0 : T.filter((S) => S.tooltips).map((S) => `
        <li className='tooltip-body'>
          <strong>${S.label || S.name}</strong>: ${x[S.name]}
        </li>`).join(" ");
  }, s = (x) => `<ul> ${c(x)} </ul>`, p = (y = t.runtime) == null ? void 0 : y.series.map((x) => t.data.map((T, S) => {
    let A = T[x.dataKey], E = T[t.xAxis.dataKey];
    return /* @__PURE__ */ n.createElement(n.Fragment, { key: `bump-circle-${A}-${S}` }, /* @__PURE__ */ n.createElement(at, { left: Number(t.runtime.yAxis.size) }, A && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      "circle",
      {
        key: `bump-circle-${A}-${S}`,
        "data-tooltip-html": s(T),
        "data-tooltip-id": "bump-chart",
        r: 10,
        cx: Number(d(r(o(E)))),
        cy: Number(a(A)),
        stroke: "#CACACA",
        strokeWidth: 1,
        fill: "#E5E4E2"
      }
    ), A.toString().length === 2 ? (
      // prettier-ignore
      /* @__PURE__ */ n.createElement(
        "text",
        {
          x: Number(d(r(o(E)))) - 7,
          y: Number(a(A)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        A
      )
    ) : (
      // prettier-ignore
      /* @__PURE__ */ n.createElement(
        "text",
        {
          x: Number(d(r(o(E)))) - 4,
          y: Number(a(A)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        A
      )
    ))));
  }));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, p);
}, pm = (e) => {
  var ne;
  const {
    getXAxisData: t,
    getYAxisData: r,
    handleTooltipClick: a,
    handleTooltipMouseOff: i,
    handleTooltipMouseOver: o,
    tooltipData: d,
    xMax: c,
    xScale: s,
    yMax: p,
    yScale: m
  } = e, { colorScale: y, config: x, formatNumber: T, handleLineType: S, parseDate: A, seriesHighlight: E, tableData: b, transformedData: v, updateConfig: N, brushConfig: C, clean: R } = ue.useContext(gt), { yScaleRight: _ } = Ep({ config: x, yMax: p, data: v, updateConfig: N });
  if (!o)
    return;
  const { lineDatapointStyle: U, showLineSeriesLabels: j, legend: te } = x;
  let Q = v, $ = b;
  C.data.length > 0 && ((ne = x.brush) != null && ne.active) && (Q = R(C.data), $ = R(C.data));
  const J = (z) => s(t(z)) + (s.bandwidth ? s.bandwidth() / 2 : 0);
  return /* @__PURE__ */ n.createElement($r, { component: "LineChart" }, /* @__PURE__ */ n.createElement(at, { left: Number(x.runtime.yAxis.size) }, " ", (x.runtime.lineSeriesKeys || x.runtime.seriesKeys).map((z, W) => {
    var De;
    const ie = x.runtime.series.find((me) => me.dataKey === z), ae = ie.type, oe = ie.axis || "left", K = te.behavior === "highlight" || E.length === 0 || E.indexOf(z) !== -1, Y = Sk(
      b,
      z,
      x.preliminaryData,
      x.xAxis.dataKey
    ), X = ((De = x == null ? void 0 : x.preliminaryData) == null ? void 0 : De.filter((me) => me.style && !me.style.includes("Circles")).length) > 0, q = ie.dynamicCategory ? Q.filter((me) => me[ie.dynamicCategory] === z) : Q, ce = ie.dynamicCategory ? ie.originalDataKey : z, ge = vk(x == null ? void 0 : x.preliminaryData, $, ce);
    return /* @__PURE__ */ n.createElement(
      at,
      {
        key: `series-${z}-${W}`,
        opacity: te.behavior === "highlight" && E.length > 0 && E.indexOf(ce) === -1 ? 0.5 : 1,
        display: te.behavior === "highlight" || E.length === 0 && !te.dynamicLegend || E.indexOf(ce) !== -1 ? "block" : "none"
      },
      /* @__PURE__ */ n.createElement(
        Lr,
        {
          key: "bars",
          width: Number(c),
          height: Number(p),
          fill: "transparent",
          fillOpacity: 0.05,
          onMouseMove: (me) => o(me, b),
          onMouseOut: i,
          onClick: (me) => a(me, Q)
        }
      ),
      q.map((me, Fe) => Ki(me[ce]) && /* @__PURE__ */ n.createElement(n.Fragment, { key: `series-${z}-point-${Fe}` }, x.labels && /* @__PURE__ */ n.createElement(
        vt,
        {
          x: J(me),
          y: oe === "Right" ? _(r(me, ce)) : m(r(me, ce)),
          fill: "#000",
          textAnchor: "middle"
        },
        T(me[ce], "left")
      ), U === "always show" && /* @__PURE__ */ n.createElement(
        lf,
        {
          mode: "ALWAYS_SHOW_POINTS",
          dataIndex: Fe,
          circleData: ge,
          tableData: b,
          data: q,
          d: me,
          config: x,
          seriesKey: ce,
          displayArea: K,
          tooltipData: d,
          xScale: s,
          yScale: m,
          colorScale: y,
          parseDate: A,
          yScaleRight: _,
          seriesAxis: oe,
          key: `line-circle--${Fe}`
        }
      ), /* @__PURE__ */ n.createElement(
        lf,
        {
          mode: "ISOLATED_POINTS",
          dataIndex: Fe,
          tableData: b,
          circleData: ge,
          data: q,
          d: me,
          config: x,
          seriesKey: ce,
          displayArea: K,
          tooltipData: d,
          xScale: s,
          yScale: m,
          colorScale: y,
          parseDate: A,
          yScaleRight: _,
          seriesAxis: oe,
          key: `isolated-circle-${Fe}`
        }
      ))),
      /* @__PURE__ */ n.createElement(n.Fragment, null, U === "hover" && /* @__PURE__ */ n.createElement(
        lf,
        {
          tableData: b,
          dataIndex: 0,
          mode: "HOVER_POINTS",
          circleData: ge,
          data: q,
          config: x,
          seriesKey: z,
          displayArea: K,
          tooltipData: d,
          xScale: s,
          yScale: m,
          colorScale: y,
          parseDate: A,
          yScaleRight: _,
          seriesAxis: oe
        }
      )),
      X ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        jy,
        {
          curve: $i[ie.lineType],
          segments: q.map((me) => [me]),
          segmentation: "x",
          x: (me) => J(me),
          y: (me) => oe === "Right" ? _(r(me, ce)) : m(Number(r(me, ce))),
          styles: gk({
            preliminaryData: x.preliminaryData,
            data: $,
            stroke: y(x.runtime.seriesLabels[z]),
            strokeWidth: ie.weight || 2,
            handleLineType: S,
            lineType: ae,
            seriesKey: z
          }),
          defined: (me, Fe) => me[z] !== "" && me[z] !== null && me[z] !== void 0
        }
      ), Y.map((me, Fe) => Object.entries(me.data).map(([Ue, Te]) => {
        var ve;
        return /* @__PURE__ */ n.createElement(
          Br,
          {
            key: Fe,
            data: Te,
            x: (Ae) => J(Ae),
            y: (Ae) => oe === "Right" ? _(r(Ae, z)) : m(Number(r(Ae, z))),
            stroke: y(x.runtime.seriesLabels[z]),
            strokeWidth: ((ve = ie[0]) == null ? void 0 : ve.weight) || 2,
            strokeOpacity: 1,
            shapeRendering: "geometricPrecision",
            strokeDasharray: S(me.style),
            defined: (Ae, fe) => Ae[z] !== "" && Ae[z] !== null && Ae[z] !== void 0
          }
        );
      }))) : /* @__PURE__ */ n.createElement(n.Fragment, null, x.confidenceKeys && x.series.map((me, Fe) => me.dynamicCategory ? [...new Set(Q.map((Te) => Te[me.dynamicCategory]))].map((Te, ve) => {
        const Ae = Q.filter((fe) => fe[me.dynamicCategory] === Te);
        return /* @__PURE__ */ n.createElement(
          Df,
          {
            key: `area-closed-${Fe}-${ve}`,
            data: Ae,
            x: (fe) => J(fe),
            y0: (fe) => m(fe[x.confidenceKeys.lower]),
            y1: (fe) => m(fe[x.confidenceKeys.upper]),
            opacity: 0.5,
            fill: y(Te),
            yScale: m,
            curve: $i[me.lineType]
          }
        );
      }) : /* @__PURE__ */ n.createElement(
        Df,
        {
          key: `area-closed-${Fe}`,
          data: Q,
          x: (Ue) => J(Ue),
          y0: (Ue) => m(Ue[x.confidenceKeys.lower]),
          y1: (Ue) => m(Ue[x.confidenceKeys.upper]),
          opacity: 0.5,
          fill: y(
            x.runtime.seriesLabels ? x.runtime.seriesLabels[me.dataKey] : me.dataKey
          ),
          yScale: m,
          curve: $i[me.lineType]
        }
      )), /* @__PURE__ */ n.createElement(
        Br,
        {
          curve: $i[ie.lineType],
          data: x.visualizationType == "Bump Chart" ? q : x.xAxis.type === "date-time" || x.xAxis.type === "date" ? q.sort((me, Fe) => {
            let Ue = t(me), Te = t(Fe);
            return Ue < Te ? -1 : Te < Ue ? 1 : 0;
          }) : q,
          x: (me) => J(me),
          y: (me) => oe === "Right" ? _(r(me, ce)) : m(Number(r(me, ce))),
          stroke: y(x.runtime.seriesLabels[z]),
          strokeWidth: ie.weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: ae ? S(ae) : 0,
          defined: (me, Fe) => me[ce] !== "" && me[ce] !== null && me[ce] !== void 0
        }
      )),
      ge.map((me, Fe) => /* @__PURE__ */ n.createElement(
        "circle",
        {
          key: Fe,
          cx: J(me.data),
          cy: oe === "Right" ? _(r(me.data, ce)) : m(Number(r(me.data, ce))),
          r: me.size,
          strokeWidth: ie.weight || 2,
          stroke: y ? y(x.runtime.seriesLabels[z]) : "#000",
          fill: me.isFilled ? y ? y(x.runtime.seriesLabels[z]) : "#000" : "#fff"
        }
      )),
      x.animate && /* @__PURE__ */ n.createElement(
        Br,
        {
          className: "animation",
          curve: $i[ie.lineType],
          data: q,
          x: (me) => J(me),
          y: (me) => oe === "Right" ? _(r(me, ce)) : m(Number(r(me, ce))),
          stroke: "#fff",
          strokeWidth: 3,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: ae ? S(ae) : 0,
          defined: (me, Fe) => me[z] !== "" && me[z] !== null && me[z] !== void 0
        }
      ),
      j && (x.runtime.lineSeriesKeys || x.runtime.seriesKeys).map((me) => {
        let Fe;
        for (let Ue = q.length - 1; Ue >= 0; Ue--)
          if (q[Ue][me]) {
            Fe = q[Ue];
            break;
          }
        return Fe ? /* @__PURE__ */ n.createElement(
          vt,
          {
            x: J(Fe) + 5,
            y: m(r(Fe, me)),
            alignmentBaseline: "middle",
            fill: x.colorMatchLineSeriesLabels && y ? y(x.runtime.seriesLabels[me] || me) : "black"
          },
          x.runtime.seriesLabels[me] || me
        ) : /* @__PURE__ */ n.createElement(n.Fragment, null);
      })
    );
  }), x.legend.dynamicLegend && E.length === 0 && /* @__PURE__ */ n.createElement(vt, { x: c / 2, y: p / 2, fill: "black", textAnchor: "middle", color: "black" }, x.legend.dynamicLegendChartMessage)), x.visualizationType === "Bump Chart" && /* @__PURE__ */ n.createElement(kk, { config: x, xScale: s, yScale: m }));
}, wk = ({ xScale: e, yScale: t, config: r, height: a, width: i, handleTooltipMouseOff: o, handleTooltipMouseOver: d, forestPlotRightLabelRef: c }) => {
  const { rawData: s, updateConfig: p } = ue.useContext(gt), { forestPlot: m } = r, y = r.xAxis.tickWidthMax + 10, [x, T] = ue.useState(!1);
  ue.useEffect(() => {
    try {
      const C = ["estimateField", "lower", "upper", "estimateRadius"], R = r, _ = 10;
      for (let U = 0; U < _; U++)
        C.forEach((j) => {
          var te;
          r.forestPlot[j] && r.forestPlot[j] !== ((te = R.columns[r.forestPlot[`additionalColumn${U}`]]) == null ? void 0 : te.name) && (delete R.columns[`additionalColumn${U}`], R.columns[r.forestPlot[j]] = {}, R.columns[r.forestPlot[j]].dataKey = R.forestPlot[j], R.columns[r.forestPlot[j]].name = R.forestPlot[j], R.columns[r.forestPlot[j]].dataTable = !0, R.columns[r.forestPlot[j]].tooltips = !0, R.columns[r.forestPlot[j]].label = R.forestPlot[j]);
        });
      r.forestPlot.radius.scalingColumn && (R.columns[r.forestPlot.radius.scalingColumn] = {}, R.columns[r.forestPlot.radius.scalingColumn].dataKey = R.forestPlot.radius.scalingColumn, R.columns[r.forestPlot.radius.scalingColumn].name = R.forestPlot.radius.scalingColumn, R.columns[r.forestPlot.radius.scalingColumn].label = R.forestPlot.radius.scalingColumn, R.columns[r.forestPlot.radius.scalingColumn].dataTable = !0, R.columns[r.forestPlot.radius.scalingColumn].tooltips = !0), R.table.showVertical && (R.table.indexLabel = r.xAxis.dataKey), p(R);
    } catch (C) {
      console.log(C.message);
    }
  }, []), ue.useEffect(() => {
    !x && r.forestPlot.type === "Logarithmic" && (p({
      ...r,
      dataFormat: {
        ...r.dataFormat,
        roundTo: 2
      }
    }), T(!0));
  }, [r.forestPlot.type]);
  const S = r.data.find((C) => C[r.xAxis.dataKey] === r.forestPlot.pooledResult.column), A = S ? [
    { x: e(S[r.forestPlot.lower]), y: a - Number(r.forestPlot.rowHeight) },
    { x: e(S[r.forestPlot.estimateField]), y: a - m.pooledResult.diamondHeight - Number(r.forestPlot.rowHeight) },
    { x: e(S[r.forestPlot.upper]), y: a - Number(r.forestPlot.rowHeight) },
    { x: e(S[r.forestPlot.estimateField]), y: a + m.pooledResult.diamondHeight - Number(r.forestPlot.rowHeight) },
    { x: e(S[r.forestPlot.lower]), y: a - Number(r.forestPlot.rowHeight) }
  ] : [], E = r.forestPlot.rowHeight, b = [
    { x: 0, y: E },
    { x: i, y: E }
  ], v = [
    { x: 0, y: a },
    { x: i, y: a }
  ], N = Object.entries(r.columns).map((C) => C[1]).filter((C) => C.forestPlot === !0);
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(at, { width: i }, m.title && /* @__PURE__ */ n.createElement(vt, { className: "forest-plot--title", x: m.type === "Linear" ? e(0) : e(1), y: 0, textAnchor: "middle", verticalAnchor: "start", fontSize: Pi(r.fontSize), fill: "black" }, m.title), m.lineOfNoEffect.show && m.type === "Linear" && /* @__PURE__ */ n.createElement(cn, { from: { x: e(0), y: 0 + E }, to: { x: e(0), y: a }, className: "forestplot__line-of-no-effect", stroke: m.regression.baseLineColor || "black" }), m.lineOfNoEffect.show && m.type === "Logarithmic" && /* @__PURE__ */ n.createElement(cn, { from: { x: e(1), y: 0 + E }, to: { x: e(1), y: a }, className: "forestplot__line-of-no-effect", stroke: m.regression.baseLineColor || "black" }), s.map((C, R) => {
    const _ = jn({
      domain: s.map((J) => J[m.radius.scalingColumn]),
      range: [m.radius.min, m.radius.max]
    }), U = m.radius.scalingColumn !== "" ? _(s[R][m.radius.scalingColumn]) : 4, j = m.colors.shape ? m.colors.shape : "black", te = m.colors.line ? m.colors.line : "black", Q = 4;
    return C[r.xAxis.dataKey] === m.pooledResult.column ? /* @__PURE__ */ n.createElement(Br, { data: A, x: (J) => J.x, y: (J) => J.y - Pi(r.fontSize) / 2, stroke: "black", strokeWidth: 2, fill: "black", curve: Tf }) : /* @__PURE__ */ n.createElement(at, null, /* @__PURE__ */ n.createElement(
      "path",
      {
        stroke: te,
        strokeWidth: 1,
        className: "lower-ci",
        d: `
                    M${e(C[m.lower])} ${t(R) - Number(Q)}
                    L${e(C[m.lower])} ${t(R) + Number(Q)}
                `
      }
    ), /* @__PURE__ */ n.createElement(
      "path",
      {
        stroke: te,
        strokeWidth: 1,
        className: "upper-ci",
        d: `
                    M${e(C[m.upper])} ${t(R) - Number(Q)}
                    L${e(C[m.upper])} ${t(R) + Number(Q)}
                `
      }
    ), /* @__PURE__ */ n.createElement("line", { stroke: te, className: `line-${C[r.yAxis.dataKey]}`, key: R, x1: e(C[m.lower]), x2: e(C[m.upper]), y1: t(R), y2: t(R) }), m.shape === "circle" && /* @__PURE__ */ n.createElement(Jg, { className: "forest-plot--circle", cx: e(Number(C[m.estimateField])), cy: t(R), r: m.radius.scalingColumn !== "" ? _(s[R][m.radius.scalingColumn]) : 4, fill: j, style: { opacity: 1, filter: "unset" } }), m.shape === "square" && /* @__PURE__ */ n.createElement("rect", { className: "forest-plot--square", x: e(Number(C[m.estimateField])), y: t(R) - U / 2, width: U, height: U, fill: j, style: { opacity: 1, filter: "unset" } }), m.shape === "text" && /* @__PURE__ */ n.createElement(vt, { className: "forest-plot--text", x: e(Number(C[m.estimateField])), y: t(R), textAnchor: "middle", verticalAnchor: "middle", fontSize: Pi(r.fontSize), fill: j }, C[m.estimateField]));
  }), A && m.regression.showDiamond && /* @__PURE__ */ n.createElement(Br, { data: A, x: (C) => C.x, y: (C) => C.y, stroke: "black", strokeWidth: 2, fill: m.regression.baseLineColor, curve: Tf }), m.regression.description && /* @__PURE__ */ n.createElement(vt, { x: 0 - Number(r.xAxis.size), width: i, y: a - r.forestPlot.rowHeight - Number(m.rowHeight) / 3, verticalAnchor: "start", textAnchor: "start", style: { fontWeight: "bold", fontSize: 12 } }, m.regression.description), /* @__PURE__ */ n.createElement(Lr, { key: "forest-plot-tooltip-area", className: "forest-plot-tooltip-area", width: i, height: a, fill: "transparent", fillOpacity: 0.5, onMouseMove: (C) => d(C, s), onMouseOut: o })), /* @__PURE__ */ n.createElement(cn, { from: b[0], to: b[1], style: { stroke: "black", strokeWidth: 2 }, className: "forestplot__top-line" }), /* @__PURE__ */ n.createElement(cn, { from: v[0], to: v[1], style: { stroke: "black", strokeWidth: 2 }, className: "forestplot__bottom-line" }), N.map((C) => s.map((R, _) => /* @__PURE__ */ n.createElement(vt, { className: `${R[C.name]}`, x: C.forestPlotAlignRight ? i : C.forestPlotStartingPoint, y: t(_), textAnchor: C.forestPlotAlignRight ? "end" : "start", verticalAnchor: "middle", fontSize: Pi(r.fontSize), fill: "black" }, R[C.name]))), !m.hideDateCategoryCol && s.map((C, R) => /* @__PURE__ */ n.createElement(vt, { className: `${C[r.xAxis.dataKey]}`, x: 0, y: t(R), textAnchor: "start", verticalAnchor: "middle", fontSize: Pi(r.fontSize), fill: "black" }, C[r.xAxis.dataKey])), !m.hideDateCategoryCol && r.xAxis.dataKey && /* @__PURE__ */ n.createElement(vt, { className: r.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fontSize: Pi(r.fontSize), fill: "black" }, r.xAxis.dataKey), N.map((C) => /* @__PURE__ */ n.createElement(vt, { className: `${C.label}`, x: C.forestPlotAlignRight ? i : C.forestPlotStartingPoint, y: 0, textAnchor: C.forestPlotAlignRight ? "end" : "start", verticalAnchor: "start", fontSize: Pi(r.fontSize), fill: "black" }, C.label)), m.leftLabel && /* @__PURE__ */ n.createElement(vt, { className: "forest-plot__left-label", x: m.type === "Linear" ? e(0) - 25 : e(1) - 25, y: a + y, textAnchor: "end", verticalAnchor: "start" }, m.leftLabel), m.rightLabel && /* @__PURE__ */ n.createElement(vt, { innerRef: c, className: "forest-plot__right-label", x: m.type === "Linear" ? e(0) + 25 : e(1) + 25, y: a + y, textAnchor: "start", verticalAnchor: "start" }, m.rightLabel));
}, Ck = ({ width: e, height: t, originalWidth: r }) => {
  var v, N, C;
  const { config: a, colorScale: i, transformedData: o, formatNumber: d, seriesHighlight: c } = ue.useContext(gt);
  if (!a || ((v = a == null ? void 0 : a.series) == null ? void 0 : v.length) < 2)
    return;
  const s = a.barHasBorder === "true" ? 1 : 0, p = e / 2, m = { small: 16, medium: 18, large: 20 }, y = 1.02, x = {
    parentKey: (N = a.dataDescription) == null ? void 0 : N.seriesKey,
    dataKey: a.series[0].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[0].dataKey] || a.series[0].dataKey,
    color: i(a.runtime.seriesLabels[a.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((R) => R[a.series[0].dataKey])
    ),
    labelColor: ""
  }, T = {
    parentKey: (C = a.dataDescription) == null ? void 0 : C.seriesKey,
    dataKey: a.series[1].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[1].dataKey] || a.series[1].dataKey,
    color: i(a.runtime.seriesLabels[a.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((R) => R[a.series[1].dataKey])
    ),
    labelColor: ""
  }, S = jn({
    domain: [0, Math.max(x.max * y, T.max * 1.1)],
    range: [0, p]
  });
  x.labelColor = x.color ? ll("#000", x.color) : "#000", T.labelColor = T.color ? ll("#000", T.color) : "#000";
  const A = a.yAxis.label ? `${a.yAxis.label}: ` : "", E = (R) => {
    var _;
    return `<p>
				${(_ = a.dataDescription) == null ? void 0 : _.seriesKey}: ${x.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${R[a.xAxis.dataKey]}<br/>
				${A}${d(R[x.dataKey], "left")}
			</p>`;
  }, b = (R) => {
    var _;
    return `<p>
				${(_ = a.dataDescription) == null ? void 0 : _.seriesKey}: ${T.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${R[a.xAxis.dataKey]}<br/>
				${A}${d(R[T.dataKey], "left")}
			</p>`;
  };
  return e > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				`), /* @__PURE__ */ n.createElement(
    "svg",
    {
      id: "cdc-visualization__paired-bar-chart",
      width: r,
      height: t,
      viewBox: `0 0 ${e + Number(a.runtime.yAxis.size)} ${t}`,
      role: "img",
      tabIndex: 0
    },
    /* @__PURE__ */ n.createElement("title", null, `Paired bar chart graphic with the title ${a.title ? a.title : "No Title Found"}`),
    /* @__PURE__ */ n.createElement(at, { top: 0, left: Number(a.xAxis.size) }, o.filter((R) => a.series[0].dataKey === x.dataKey).map((R, _) => {
      var W, ie;
      let U = a.legend.behavior === "highlight" && c.length > 0 && c.indexOf(a.series[0].dataKey) === -1, j = a.legend.behavior === "highlight" || c.length === 0 || c.indexOf(a.series[0].dataKey) !== -1, te = S(R[a.series[0].dataKey]), Q = Number(a.barHeight) ? Number(a.barHeight) : 25, $ = 0;
      $ = _ !== 0 ? (Number(a.barSpace) + Q + s) * _ : $;
      const J = (Number(a.barSpace) + Q + s) * o.length;
      a.heights.horizontal = J;
      const z = Jn(
        d(R[x.dataKey], "left"),
        `normal ${m[a.fontSize]}px sans-serif`
      ) < te - 5;
      return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(at, { key: `group-${x.dataKey}-${R[a.xAxis.dataKey]}`, className: "horizontal" }, /* @__PURE__ */ n.createElement(
        Lr,
        {
          id: `bar-${x.dataKey}-${R[(W = a.dataDescription) == null ? void 0 : W.xKey]}`,
          className: "bar group-1",
          key: `bar-${x.dataKey}-${R[(ie = a.dataDescription) == null ? void 0 : ie.xKey]}`,
          x: p - te,
          y: $,
          width: S(R[a.series[0].dataKey]),
          height: Q,
          fill: x.color,
          "data-tooltip-html": E(R),
          "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
          stroke: "#333",
          strokeWidth: s,
          opacity: U ? 0.5 : 1,
          display: j ? "block" : "none",
          tabIndex: -1
        }
      ), a.yAxis.displayNumbersOnBar && j && /* @__PURE__ */ n.createElement(
        vt,
        {
          textAnchor: z ? "start" : "end",
          dx: z ? 5 : -5,
          verticalAnchor: "middle",
          x: p - te,
          y: $ + a.barHeight / 2,
          fill: z ? x.labelColor : "#000"
        },
        d(R[x.dataKey], "left")
      )));
    }), o.filter((R) => a.series[1].dataKey === T.dataKey).map((R, _) => {
      var W, ie, ae;
      let U = S(R[a.series[1].dataKey]), j = a.legend.behavior === "highlight" && c.length > 0 && c.indexOf(a.series[1].dataKey) === -1, te = a.legend.behavior === "highlight" || c.length === 0 || c.indexOf(a.series[1].dataKey) !== -1, Q = a.barHeight ? Number(a.barHeight) : 25, $ = 0;
      $ = _ !== 0 ? (Number(a.barSpace) + Q + s) * _ : $;
      const J = (Number(a.barSpace) + Q + s) * o.length;
      a.heights.horizontal = J;
      const z = Jn(
        d(R[T.dataKey], "left"),
        `normal ${m[a.fontSize]}px sans-serif`
      ) < U - 5;
      return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `
                      .bar-${T.dataKey}-${R[a.xAxis.dataKey]} {
                          transform-origin: ${p}px ${$}px
                      }
							      `), /* @__PURE__ */ n.createElement(at, { key: `group-${T.dataKey}-${R[(W = a.dataDescription) == null ? void 0 : W.xKey]}`, className: "horizontal" }, /* @__PURE__ */ n.createElement(
        Lr,
        {
          id: `bar-${T.dataKey}-${R[(ie = a.dataDescription) == null ? void 0 : ie.xKey]}`,
          className: "bar group-2",
          key: `bar-${T.dataKey}-${R[(ae = a.dataDescription) == null ? void 0 : ae.xKey]}`,
          x: p,
          y: $,
          width: S(R[a.series[1].dataKey]),
          height: Q,
          fill: T.color,
          "data-tooltip-html": b(R),
          "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
          strokeWidth: s,
          stroke: "#333",
          opacity: j ? 0.5 : 1,
          display: te ? "block" : "none",
          tabIndex: -1
        }
      ), a.yAxis.displayNumbersOnBar && te && /* @__PURE__ */ n.createElement(
        vt,
        {
          textAnchor: z ? "end" : "start",
          dx: z ? -5 : 5,
          verticalAnchor: "middle",
          x: p + U,
          y: $ + a.barHeight / 2,
          fill: z ? T.labelColor : "#000"
        },
        d(R[T.dataKey], "left")
      )));
    }))
  ));
}, Tk = ({ yMax: e, leftSize: t, max: r, xMax: a }) => {
  var b;
  const { config: i } = ue.useContext(gt), { fontSize: o } = Os(), { orientation: d } = i, c = (v, N = "#f1f1f1") => {
    try {
      return Wa(v).hex();
    } catch {
      return N;
    }
  }, s = (b = i.yAxis) == null ? void 0 : b.categories, y = ((v) => {
    const N = Object.keys(v), C = N[N.length - 1];
    if (v[C] === "") {
      const R = N.slice(0, -1).reduce((U, j) => {
        const te = Number(v[j]);
        return U + (isNaN(te) ? 0 : te);
      }, 0), _ = r - R;
      v[C] = _;
    }
    return [v];
  })(((v) => [...v].reduce((C, R) => (C[R.label] = R.height, C), {}))(s)), x = 0, T = ec({
    domain: [x],
    padding: 0,
    range: [0, t]
  }), S = jn({
    domain: [0, r],
    range: [e, 0],
    clamp: !0
  }), A = Ii({
    domain: s.map((v) => v == null ? void 0 : v.label),
    range: s.map((v) => {
      var N;
      return c((N = v == null ? void 0 : v.color) == null ? void 0 : N.trim());
    })
  }), E = Object.keys(y[0]);
  return /* @__PURE__ */ n.createElement(at, { left: t - T.bandwidth(), top: 0 }, /* @__PURE__ */ n.createElement(
    Wy,
    {
      data: y,
      keys: E,
      x: () => T(x),
      xScale: T,
      yScale: S,
      color: A
    },
    (v) => v.map(
      (N) => N.bars.map((C) => {
        const R = i.yAxis.categories.length - 1 === N.index, _ = o[i.fontSize] / 1.3, U = Wa(C.color).luminance() < 0.4 ? "#fff" : "#000", j = Jn(C.key, `normal ${_}px sans-serif`), te = Number(j) < C.width && C.height > _, Q = `<ul>
              <li class="tooltip-heading""> Label : ${C.key}  </li>
                    </li></ul>`;
        return /* @__PURE__ */ n.createElement(at, { key: `${N.index}--${C.index}--${d}` }, /* @__PURE__ */ n.createElement(
          at,
          {
            key: `bar-stack-${N.index}-${C.index}`,
            id: `barStack${N.index}-${C.index}`,
            className: "stack vertical"
          },
          Ms({
            type: "axisBar",
            config: i,
            index: N.index,
            background: A(C.key),
            borderColor: "#333",
            borderStyle: "solid",
            borderWidth: 0,
            width: T.bandwidth(),
            height: C.height,
            x: C.x,
            y: C.y,
            tooltipHtml: Q,
            tooltipId: `cdc-open-viz-tooltip-${i.runtime.uniqueId}`
          }),
          /* @__PURE__ */ n.createElement(
            vt,
            {
              display: te ? "block" : "none",
              key: `text-${N.index}-${C.index}`,
              x: C.x + T.bandwidth() / 2,
              y: C.y + C.height / 2,
              fill: U,
              textAnchor: "middle",
              verticalAnchor: "middle",
              style: { fontSize: _ }
            },
            C.key
          ),
          i.runtime.yAxis.gridLines && /* @__PURE__ */ n.createElement(
            cn,
            {
              from: { x: C.x + T.bandwidth(), y: C.y },
              to: { x: a + T.bandwidth(), y: C.y },
              stroke: "#d6d6d6"
            }
          ),
          !R && /* @__PURE__ */ n.createElement("rect", { x: C.x, y: C.y, width: C.width, height: 1, fill: "#fff" }),
          /* @__PURE__ */ n.createElement("rect", { x: C.x + C.width, y: 0, width: 1, height: e, fill: "#000" })
        ));
      })
    )
  ));
};
function Ak({ orientation: e, heights: t, visualizationType: r }, a) {
  const o = e === "vertical" || r === "Forest Plot", c = (t == null ? void 0 : t.mobileVertical) && qg(a) ? "mobileVertical" : "vertical";
  return o ? c : "horizontal";
}
function Lk({ heights: e, orientation: t, visualizationType: r }, a) {
  if (!e)
    return 0;
  const i = Ak({ orientation: t, heights: e, visualizationType: r }, a), o = Number(e == null ? void 0 : e[i]);
  return isNaN(o) ? 0 : o;
}
const pg = ({ config: e, minValue: t, maxValue: r, existPositiveValue: a, data: i, isAllLine: o, tableData: d }) => {
  let c = 0, s = 0, p = 0, m = 0;
  if (!i)
    return { min: c, max: s };
  const y = () => Hc(e.visualizationType, i, e.allowLineToBarGraph), { visualizationType: x, series: T } = e, { max: S, min: A } = e.runtime.yAxis, E = e.yAxis.enablePadding ? 1 + e.yAxis.scalePadding / 100 : 1, b = e.yAxis.type === "logarithmic", v = a ? Number(S) >= r : Number(S) >= 0, N = b ? Number(A) >= 0 : Number(A) <= 0 && t >= 0 || Number(A) <= t && t < 0;
  c = A && N ? Number(A) : t, s = S && v ? Number(S) : Number.MIN_VALUE;
  const { lower: C, upper: R } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (C && R && e.visualizationType === "Bar") {
    const _ = c < 0 ? 1.1 : 0, U = Math.max(...i.flatMap((te) => [te[R], te[C]])) * E, j = Math.min(...i.flatMap((te) => [te[R], te[C]])) * E * _;
    s = s > U ? s : U, c = c < j ? c : j;
  }
  if (e.series.filter((_) => (_ == null ? void 0 : _.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: _ }
    } = e;
    if ((_ == null ? void 0 : _.length) > 0) {
      let U = [];
      _.forEach(($) => {
        var J;
        (J = $.confidenceIntervals) == null || J.map((ne) => {
          U.push(ne.high), U.push(ne.low);
        });
      });
      const j = i.map(($) => U.map((J) => $[J])), te = Math.max.apply(
        null,
        j.map(($) => $[0])
      ), Q = Math.min.apply(
        null,
        j.map(($) => $[1])
      );
      te > s && (s = te), Q < c && (c = Q);
    }
  }
  if (x === "Combo")
    try {
      if (!i)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let _ = T.filter((te) => te.axis === "Left"), U = T.filter((te) => te.axis === "Right");
      const j = (te, Q, $, J = "left") => {
        let ne = 0;
        return (Q.map((W) => W.dataKey) || []).forEach((W) => {
          let ie = Q.find((K) => K.dataKey === W), ae = te.map((K) => K[W]), oe = Math.max.apply(null, ae);
          e.visualizationSubType === "stacked" && J === "left" && ie.type === "Bar" && (ne += oe), oe > $ && ($ = oe), $ < ne && ($ = ne);
        }), $;
      };
      p = j(i, _, p, "left"), m = j(i, U, m, "right"), p < Number(S) && (p = Number(S));
    } catch (_) {
      console.error(_.message);
    }
  if ((x === "Bar" || y() || x === "Combo" && !o) && c > 0 && (c = 0), (e.visualizationType === "Bar" || y() || e.visualizationType === "Combo" && !o) && c < 0 && (c = c * 1.1), e.visualizationType === "Combo" && o && ((A == null || A === "") && c > 0 && (c = 0), A)) {
    const _ = b ? Number(A) >= 0 && Number(A) < t : Number(A) < t;
    c = Number(A) && _ ? Number(A) : t;
  }
  if (e.visualizationType === "Deviation Bar" && c > 0) {
    const _ = Number(A) < Math.min(t, Number(e.xAxis.target));
    c = Number(A) && _ ? Number(A) : 0;
  }
  if (e.visualizationType === "Line" && !y()) {
    const _ = b ? Number(A) >= 0 && Number(A) < t : Number(A) < t, U = d == null ? void 0 : d.some((te, Q) => {
      var $;
      return ($ = e.preliminaryData) == null ? void 0 : $.some((J) => {
        var ie;
        if (J.type !== "suppression" || !J.style)
          return !1;
        const ne = lt.pick(te, (ie = e.runtime) == null ? void 0 : ie.seriesKeys), z = lt.values(ne).includes(J.value);
        return (J.column ? te[J.column] === J.value : z) && (Q === 0 || Q === d.length - 1);
      });
    });
    let j = e.yAxis.type === "categorical";
    c = A !== "" && _ ? Number(A) : U || j ? 0 : t;
  }
  if (s === Number.MIN_VALUE && (s = a ? r : 0), e.runtime.yAxis.paddingPercent) {
    let _ = (s - c) * e.runtime.yAxis.paddingPercent;
    c -= _, s += _;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const _ = i.map((j) => j[e.series[0].dataKey]), U = Math.max(..._).toString().length;
    switch (!0) {
      case (U > 8 && U <= 12):
        s = s * 1.3;
        break;
      case (U > 4 && U <= 7):
        s = s * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (c < 0 ? (s *= 1 + e.yAxis.scalePadding * 2 / 100, c *= 1 + e.yAxis.scalePadding * 2 / 100) : s *= 1 + e.yAxis.scalePadding / 100), e.visualizationType === "Area Chart" && e.visualizationSubType === "stacked" && (c = 0), { min: c, max: s, leftMax: p, rightMax: m };
}, Gr = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, Pk = (e) => {
  let { xAxisDataMapped: t, xMax: r, yMax: a, min: i, max: o, config: d, data: c } = e;
  const { rawData: s, dimensions: p } = ue.useContext(gt), [m] = p, y = d.runtime.barSeriesKeys || d.runtime.seriesKeys, x = d.runtime.xAxis.type, T = d.orientation === "horizontal", { visualizationType: S, xAxis: A, forestPlot: E } = d;
  let b = null, v = null, N = null, C = null, R = null, _ = null, U = jn({
    domain: [0, 100],
    range: [0, r]
  });
  if (T && (b = Ok({ min: i * 1.03, ...e }), b.type = d.yAxis.type === "logarithmic" ? Gr.LOG : Gr.LINEAR, v = Mk(x, t), v.rangeRound([0, a]), R = zk(y, [0, a])), T || (b = ps(t, [0, r], 1 - d.barThickness), v = Fk(e), R = ps(y, [0, b.bandwidth()], 0)), d.xAxis.type === "date" && !T) {
    const j = hm(t, d.xAxis.sortByRecentDate);
    b = ps(j, [0, r], 1 - d.barThickness);
  }
  if (A.type === "date-time" || A.type === "continuous") {
    let j = Math.min(...t.map(Number)), te = Math.max(...t.map(Number));
    j -= (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (te - j), te += S === "Line" ? 0 : (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (te - j);
    const Q = d.xAxis.sortByRecentDate ? [r, 0] : [0, r];
    b = Ov({
      domain: [j, te],
      range: Q
    }), b.type = Gr.TIME;
    let $ = Number.MAX_VALUE, J = hm(t, d.xAxis.sortByRecentDate);
    for (let ne = 0; ne < J.length - 1; ne++) {
      let z = b(J[ne + 1]) - b(J[ne]);
      z < $ && ($ = z);
    }
    (t.length === 1 || $ > r / 4) && ($ = r / 4), R = ps(y, [0, (d.barThickness || 1) * $], 0);
  }
  if (d.visualizationType === "Deviation Bar") {
    const j = d.isLollipopChart ? 1.05 : 1.03;
    v = ec({
      domain: t,
      range: [0, a]
    }), b = jn({
      domain: [i * j, Math.max(Number(A.target), o)],
      range: [0, r],
      round: !0,
      nice: !0
    }), b.type = Gr.LINEAR;
  }
  if (d.visualizationType === "Scatter Plot" && A.type === "continuous") {
    let j = A.min ? A.min : Math.min.apply(null, b.domain()), te = A.max ? A.max : Math.max.apply(null, b.domain());
    b = jn({
      domain: [j, te],
      range: [0, r]
    }), b.type = Gr.LINEAR;
  }
  if (S === "Box Plot") {
    const j = [];
    if (d.boxplot.plots.map((W) => W.columnOutliers.map((ie) => j.push(ie))) && !d.boxplot.hideOutliers) {
      let W = Math.min(...j), ie = Math.max(...j);
      W < i && (i = W), ie > o && (o = ie);
    }
    let Q = Math.min(...d.boxplot.plots.map((W) => W.columnLowerBounds)), $ = Math.max(...d.boxplot.plots.map((W) => W.columnUpperBounds));
    Q < i && (i = Q), $ > o && (o = $);
    const J = lt.uniq(c.map((W) => W[d.xAxis.dataKey])), ne = [0, d.barThickness * 100 || 1], z = lt.map(d.series, "dataKey");
    v = jn({
      range: [a, 0],
      round: !0,
      domain: [i, o]
    }), b = ec({
      range: [0, r],
      domain: J
    }), b.type = Gr.BAND, R = ps(z, ne);
  }
  if (S === "Paired Bar") {
    let te = Math.max.apply(
      Math,
      c.map(($) => {
        var J;
        return $[(J = d.series[0]) == null ? void 0 : J.dataKey];
      })
    ), Q = Math.max.apply(
      Math,
      c.map(($) => {
        var J;
        return $[(J = d.series[1]) == null ? void 0 : J.dataKey];
      })
    );
    C = jn({
      domain: [0, Math.max(te, Q) * 1.02],
      range: [r / 2, 0]
    }), N = jn({
      domain: C.domain(),
      range: [r / 2, r],
      nice: !0
    });
  }
  if (S === "Forest Plot") {
    const j = () => E.regression.showDiamond || E.regression.description ? [0 + E.rowHeight * 2, a - E.rowHeight] : [0 + E.rowHeight * 2, a];
    v = jn({
      domain: [0, s.length],
      range: j()
    });
    const te = 5, Q = Number(E.leftWidthOffset) / 100 * r, $ = Number(E.rightWidthOffset) / 100 * r, J = Number(E.rightWidthOffsetMobile) / 100 * r, ne = Number(E.leftWidthOffsetMobile) / 100 * r;
    if (m > 480) {
      if (E.type === "Linear" && (b = jn({
        domain: [
          Math.min(...c.map((z) => parseFloat(z[E.lower]))) - te,
          Math.max(...c.map((z) => parseFloat(z[E.upper]))) + te
        ],
        range: [Q, Number(m) - $]
      }), b.type = Gr.LINEAR), E.type === "Logarithmic") {
        let z = Math.max(...c.map((ie) => parseFloat(ie[E.upper]))), W = Math.min(...c.map((ie) => parseFloat(ie[E.lower])));
        b = tc({
          domain: [W, z],
          range: [Q, r - $],
          nice: !0
        }), b.type = Gr.LOG;
      }
    } else if (E.type === "Linear" && (b = jn({
      domain: [
        Math.min(...c.map((z) => parseFloat(z[E.lower]))) - te,
        Math.max(...c.map((z) => parseFloat(z[E.upper]))) + te
      ],
      range: [ne, r - J],
      type: Gr.LINEAR
    })), E.type === "Logarithmic") {
      let z = Math.max(...c.map((ie) => parseFloat(ie[E.upper]))), W = Math.min(...c.map((ie) => parseFloat(ie[E.lower])));
      b = tc({
        domain: [W, z],
        range: [Q, r - $],
        nice: !0,
        base: z > 1 ? 10 : 2,
        round: !1,
        type: Gr.LOG
      });
    }
  }
  return { xScale: b, yScale: v, seriesScale: R, g1xScale: C, g2xScale: N, xScaleNoPadding: _, xScaleAnnotation: U };
}, Nk = (e) => {
  const t = new Date(e);
  return new Date(t.getFullYear(), t.getMonth(), 1).getTime();
}, Rk = (e) => (e.includes("%b") || e.includes("%B") || e.includes("%m") || e.includes("%-m") || e.includes("%_m")) && !e.includes("%d") && !e.includes("%-d") && !e.includes("%_d") && !e.includes("%e"), Dk = (e, t, r, a) => {
  const i = t.domain();
  if (t.type === "time") {
    const o = e[e.length - 1], d = e[0], c = (o - d) / (r - 1);
    let s = [];
    for (let p = o; p >= d; p -= c)
      s.push(p);
    return s[s.length - 1] !== d && s.push(d), s.reverse(), Rk(a.xAxis.dateDisplayFormat) && (s = s.map((p) => Nk(p))), s;
  }
  if (i.length > 2) {
    const o = r || 1, d = [];
    for (let c = i.length; c > 0; c -= o) {
      const s = Math.max(Math.round(c) - 1, 0);
      d.push(i[s]);
    }
    return d.reverse(), d;
  }
}, _k = (e, t, r, a) => {
  let i = t.ticks;
  const o = Ym(t.scale, t.numTicks);
  if (o.length < r.length) {
    let d = 0;
    const c = r.indexOf(o[o.length - 1]);
    c < r.length - 1 && (d = e.xAxis.sortByRecentDate ? r.indexOf(o[0]) * -1 : r.length - 1 - c), i = o.map((s) => t.ticks[t.ticks.findIndex((p) => p.value === s) + d]);
  }
  return i.forEach((d, c) => {
    d.formattedValue = a(d.value, c, i);
  }), i;
}, Ok = ({ min: e, max: t, xMax: r, config: a }) => {
  const i = a.yAxis.type === "logarithmic";
  return e = i && e >= 0 && e < 1 ? e + 0.1 : e, (i ? tc : jn)({
    domain: [e, t],
    range: [0, r],
    nice: i,
    zero: i
  });
}, Fk = ({ min: e, max: t, yMax: r, config: a, leftMax: i }) => {
  const o = a.yAxis.type === "logarithmic";
  e = o && e >= 0 && e < 1 ? e + 0.1 : e;
  const d = o ? tc : jn;
  a.visualizationType === "Combo" && (t = i);
  const c = a.visualizationType === "Bump Chart" ? [1, t] : [e, t], s = a.visualizationType === "Bump Chart" ? [30, r] : [r, 0];
  return d({
    domain: c,
    range: s,
    nice: o,
    zero: o
  });
}, Mk = (e, t) => e === "date" ? jn({
  domain: [Math.min(...t), Math.max(...t)]
}) : rl({ domain: t, padding: 0.5 }), zk = (e, t, r = 0) => rl({
  domain: e,
  range: t,
  padding: r
}), ps = (e, t, r = 0) => ec({
  domain: e,
  range: t,
  padding: r
}), hm = (e, t) => !e || e.length === 0 ? [] : e.length === 1 ? e : t ? e.sort((r, a) => Number(a) - Number(r)) : e.sort((r, a) => Number(r) - Number(a));
function Bk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const zs = () => {
  const { config: e } = ue.useContext(gt), { visualizationType: t, series: r, orientation: a, visualizationSubType: i } = e, o = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Bump Chart",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], d = [
    "theme-blue",
    "theme-purple",
    "theme-brown",
    "theme-teal",
    "theme-pink",
    "theme-orange",
    "theme-slate",
    "theme-indigo",
    "theme-cyan",
    "theme-green",
    "theme-amber"
  ], c = () => !["Forest Plot", "Sankey"].includes(t), s = () => !!["Scatter Plot"].includes(t), p = () => !!["Scatter Plot"].includes(t), m = () => !["Spark Line"].includes(t), y = () => !["Spark Line"].includes(t), x = () => ![
    "Area Chart",
    "Box Plot",
    "Pie",
    "Scatter Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), T = () => ![
    "Area Chart",
    "Scatter Plot",
    "Box Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), S = () => {
    switch (t) {
      case "Box Plot":
        return !0;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, A = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), E = () => !!["Bar", "Combo", "Line"].includes(e.visualizationType), b = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, v = () => {
    if ((t === "Bar" || "Combo") && i === "regular")
      return !0;
  }, N = () => e.xAxis.type === "categorical" ? !1 : ["Line", "Bar", "Area Chart", "Combo"].includes(t) && a === "vertical", C = () => ["Box Plot", "Scatter Plot", "Pie", "Line"].includes(t) ? !1 : r == null ? void 0 : r.some(
    (_e) => _e.type === "Bar" || _e.type === "Paired Bar" || _e.type === "Deviation Bar"
  ), R = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, _ = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: o,
    headerColors: d,
    visCanAnimate: T,
    visHasAnchors: b,
    visHasBarBorders: C,
    visHasDataCutoff: R,
    visHasLabelOnData: x,
    visHasDataSuppression: v,
    visHasLegend: S,
    visHasLegendAxisAlign: () => t === "Bar" && i === "stacked" && e.legend.behavior === "isolate",
    visHasLegendColorCategory: () => {
      var Le;
      return t === "Bar" && i === "regular" && ((Le = e.series) == null ? void 0 : Le.length) === 1;
    },
    visHasBrushChart: N,
    visHasNumbersOnBars: A,
    visHasaAdditionalLabelsOnBars: E,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : a === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsMobileChartHeight: () => !!["Bar", "Line", "Combo", "Area Chart"].includes(t),
    visSupportsDateCategoryAxis: c,
    visSupportsDateCategoryAxisMin: s,
    visSupportsDateCategoryAxisMax: p,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line", "Bump Chart"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !(["Spark Line", "Sankey", "Bump Chart"].includes(t) || e.orientation !== "horizontal"),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: y,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => !!["Line", "Bar", "Combo"].includes(t),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: m,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: _,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const Le = ["Forest Plot"];
      return !(a === "horizontal" || Le.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot", "Bump Chart"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (e.yAxis.type === "categorical" || ["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t) || t === "Bar" && e.tooltips.singleSeries)
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t),
    visSupportsDynamicSeries: () => t === "Line" || t === "Bar" || t === "Scatter Plot" || t === "Area Chart",
    visSupportsYPadding: () => {
      var Le;
      return !e.dataFormat.onlyShowTopPrefixSuffix || !((Le = e.dataFormat.suffix) != null && Le.includes(" "));
    },
    visHasSingleSeriesTooltip: () => t === "Bar" || t === "Line" || t === "Area Chart" && i === "stacked",
    visHasCategoricalAxis: () => {
      if ((t === "Line" || t === "Bar" || t === "Combo" || t === "Area Chart") && e.yAxis.type === "categorical" && a === "vertical")
        return !0;
    }
  };
}, $k = ({ data: e, xScale: t, yScale: r, config: a, xMax: i, annotationSeriesKey: o }, d) => {
  const { xAxis: c, visualizationType: s, orientation: p } = a, m = (E, b, v, N, C) => {
    let R = [];
    a.xAxis.type === "date-time" && (b = new Date(b), v = new Date(v), N = N.map((j) => new Date(j)), R = C.ticks().map((j) => new Date(j)));
    const _ = (E - b) / (v - b), U = Math.round(_ * (N.length - 1));
    return a.xAxis.type === "date-time" ? R[U] : N[U];
  }, x = ((E, b = !1) => {
    if (s !== "Pie" && p !== "horizontal") {
      if (a.xAxis.type === "date-time") {
        const v = new Date(t.invert(E)), N = a.data.map((_) => new Date(_[a.xAxis.dataKey]).getTime());
        let C = 1 / 0, R = null;
        return N.forEach((_) => {
          const U = Math.abs(v.getTime() - _);
          U < C && (C = U, R = _);
        }), new Date(R).getTime();
      }
      if (a.xAxis.type === "categorical" || s === "Combo" && p !== "horizontal" && s !== "Forest Plot") {
        const N = (t.range()[1] - t.range()[0]) / (t.domain().length + 1), R = Math.floor((Number(E) - N / 2) / N);
        return t.domain()[R];
      }
      if (a.xAxis.type === "date") {
        const v = m(E, 0, i, t.domain(), t);
        let N = null, C = Number.MAX_VALUE;
        return t.domain().forEach((R) => {
          const _ = Math.abs(v - R);
          _ < C && (C = _, N = R);
        }), N;
      }
      return E;
    }
  })(d - Number(a.yAxis.size || 0));
  let T = [];
  if (!x)
    return { x: 0, y: 0 };
  c.type === "categorical" && (T = a.data.filter((E) => E[a.xAxis.dataKey] === x)), (c.type === "date" || c.type === "date-time") && (T = a.data.filter((E) => new Date(E[a.xAxis.dataKey]).getTime() === x));
  const S = T[0][o];
  return { x, y: S };
}, Ik = (e, t, r) => {
  const { connectionLocation: a } = e;
  return a === "right" ? "end" : a === "left" ? "start" : a === "bottom" || a === "top" || t(e.xKey) + e.dx < r.yAxis.size ? "middle" : null;
}, Hk = (e, t, r) => {
  const { connectionLocation: a } = e;
  return a === "top" ? "start" : a === "bottom" ? "end" : a === "right" || a === "left" ? "middle" : t(e.xKey) + e.dx < r.yAxis.size ? "end" : null;
}, Vk = () => {
  var s;
  const { config: e, data: t } = ue.useContext(gt), { visualizationSubType: r, visualizationType: a, series: i, legend: o } = e, d = (p) => {
    if (!(i != null && i.length))
      return [];
    const y = ["Paired Bar", "Deviation Bar"].includes(a) ? e.twoColor.palette : e.palette, x = { ...vr, ...Cs };
    let T = e.customColors || x[y];
    for (; p > T.length; )
      T = T.concat(T);
    return T.slice(0, p);
  };
  let c = Ii({
    domain: (s = e == null ? void 0 : e.runtime) == null ? void 0 : s.seriesLabelsAll,
    range: d(i.length)
  });
  if (a === "Deviation Bar") {
    const { targetLabel: p } = e.xAxis;
    c = Ii({
      domain: [`Below ${p}`, `Above ${p}`],
      range: d(2)
    });
  }
  if (a === "Bar" && r === "regular" && (i == null ? void 0 : i.length) === 1 && (o != null && o.colorCode)) {
    const p = new Set(t == null ? void 0 : t.map((m) => m[o.colorCode]));
    c = Ii({
      domain: [...p],
      range: d([...p].length)
    });
  }
  if (e.series.some((p) => p.name)) {
    const p = new Set(i.map((m) => m.name || m.dataKey));
    c = c = Ii({
      domain: [...p],
      range: d(i.length)
    });
  }
  return { colorScale: c };
};
const Wk = ({ xScale: e, yScale: t, xScaleAnnotation: r, xMax: a, svgRef: i, onDragStateChange: o }) => {
  const {
    config: d,
    dimensions: c,
    isEditor: s,
    updateConfig: p
  } = ue.useContext(gt), { annotations: m } = d, [y] = c, { colorScale: x } = Vk(), T = s ? Fg : Mg;
  return m && m.map((S, A) => {
    var N;
    const E = S.text || "", b = r(S.x), v = () => ({
      __html: Cm.sanitize(E)
    });
    return /* @__PURE__ */ n.createElement(
      T,
      {
        width: 200,
        height: y,
        dx: S.dx,
        dy: S.dy,
        x: b,
        y: S.y,
        canEditLabel: S.edit.label || !1,
        canEditSubject: S.edit.subject && S.connectionType !== "none" || !1,
        onDragStart: () => o(!0),
        onDragEnd: (C) => {
          o(!1);
          let R = [...m];
          if (S.x === r.invert(C.x) && S.y === C.y)
            R[A] = { ...R[A], dx: C.dx, dy: C.dy };
          else if (S.snapToNearestPoint) {
            let _ = $k(
              {
                data: d.data,
                xScale: e,
                yScale: t,
                config: d,
                xMax: a - d.yAxis.size / 2,
                annotationSeriesKey: S.seriesKey
              },
              C.x
            );
            R[A] = {
              ...R[A],
              x: r.invert(e(_.x)),
              y: t(_.y)
            };
          } else
            R[A] = {
              ...R[A],
              x: r.invert(C.x),
              y: C.y
            };
          p({
            ...d,
            annotations: R
          });
        }
      },
      /* @__PURE__ */ n.createElement(
        _g,
        {
          className: "annotation__desktop-label",
          showAnchorLine: !1,
          horizontalAnchor: Ik(S, e, d),
          verticalAnchor: Hk(S, e, d)
        },
        /* @__PURE__ */ n.createElement(
          "div",
          {
            style: {
              borderRadius: 5,
              // Optional: set border radius
              backgroundColor: `rgba(255, 255, 255, ${S != null && S.opacity ? Number(S == null ? void 0 : S.opacity) / 100 : 1})`,
              padding: "10px",
              width: "auto",
              display: d.general.showAnnotationDropdown ? "inline-flex" : "flex",
              justifyContent: "start",
              flexDirection: "row"
            },
            tabIndex: 0,
            "aria-label": `Annotation text that reads: ${S.text}`
          },
          ((N = d == null ? void 0 : d.general) == null ? void 0 : N.showAnnotationDropdown) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("p", { className: "annotation__has-dropdown-number", style: { margin: "2px 6px" } }, A + 1)),
          /* @__PURE__ */ n.createElement("div", { style: { fontSize: zi[d.fontSize] }, dangerouslySetInnerHTML: v() })
        )
      ),
      S.connectionType === "line" && /* @__PURE__ */ n.createElement(Mp, { type: "line", pathProps: { markerStart: `url(#marker-start--${A})` } }),
      S.connectionType === "elbow" && /* @__PURE__ */ n.createElement(Mp, { type: "elbow", pathProps: { markerStart: `url(#marker-start--${A})` } }),
      S.connectionType === "curve" && /* @__PURE__ */ n.createElement(
        Br,
        {
          d: `M ${b},${S.y}
                      Q ${b + S.dx / 2}, ${S.y + S.dy / 2 + Number(S == null ? void 0 : S.bezier) || 0} ${b + S.dx},${S.y + S.dy}`,
          stroke: "black",
          strokeWidth: "2",
          fill: "none",
          "marker-start": `url(#marker-start--${A})`
        }
      ),
      S.marker === "circle" && /* @__PURE__ */ n.createElement(
        Og,
        {
          id: `marker-start--${A}`,
          className: "circle-subject",
          stroke: x(S.seriesKey),
          radius: 8
        }
      ),
      S.marker === "arrow" && /* @__PURE__ */ n.createElement(
        wm,
        {
          fill: "black",
          id: `marker-start--${A}`,
          x: b,
          y: S.y,
          stroke: "#333",
          markerWidth: 10,
          size: 10,
          strokeWidth: 1,
          orient: "auto-start-reverse",
          markerUnits: "userSpaceOnUse"
        }
      ),
      /* @__PURE__ */ n.createElement(
        "circle",
        {
          fill: "white",
          cx: b + S.dx,
          cy: S.y + S.dy,
          r: 16,
          className: "annotation__mobile-label annotation__mobile-label-circle",
          stroke: x(S.seriesKey)
        }
      ),
      /* @__PURE__ */ n.createElement(
        "text",
        {
          height: 16,
          x: b + S.dx,
          y: S.y + S.dy,
          className: "annotation__mobile-label",
          alignmentBaseline: "middle",
          textAnchor: "middle"
        },
        A + 1
      )
    );
  });
};
const jk = ({ useBootstrapVisibilityClasses: e = !0 }) => {
  const { config: t } = ue.useContext(gt), r = t.annotations || [], a = () => {
    const o = ["annotation-list"];
    return e && o.push("d-block", "d-md-none"), o.join(" ");
  }, i = r.map((o, d) => {
    const c = o.text || "", s = () => ({
      __html: Cm.sanitize(c)
    });
    return /* @__PURE__ */ n.createElement("li", { key: "annotation-li-item__annotationIndex" }, /* @__PURE__ */ n.createElement("div", { className: "annotation__title-wrapper" }, /* @__PURE__ */ n.createElement("div", { className: "annotation__title-circle" }, d + 1), /* @__PURE__ */ n.createElement("p", { className: "annotation__subtext", dangerouslySetInnerHTML: s() })));
  });
  return /* @__PURE__ */ n.createElement("ul", { className: a() }, i);
};
const Uk = () => {
  var s;
  const { currentViewport: e, config: t } = ue.useContext(gt), [r, a] = ue.useState(!1), i = ["sm", "xs", "xxs"].includes(e) ? "13px" : `${zi[t == null ? void 0 : t.fontSize]}px`;
  ue.useContext(gt);
  const o = {
    maxHeight: t.table.limitHeight && `${t.table.height}px`,
    OverflowY: "scroll"
  }, d = () => {
    const p = ["data-table-heading", "annotation__dropdown-list"];
    return r || p.push("collapsed"), p.join(" ");
  }, c = () => {
    const p = ["data-table-container", e, "d-block", "d-lg-none", "w-100"];
    return t.general.showAnnotationDropdown && (p.push("d-lg-block"), p.splice(p.indexOf("d-lg-none"), 1)), p.join(" ");
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("section", { className: c() }, /* @__PURE__ */ n.createElement(
    "div",
    {
      style: { fontSize: i },
      role: "button",
      className: d(),
      onClick: () => {
        a(!r);
      },
      tabIndex: 0,
      onKeyDown: (p) => {
        p.keyCode === 13 && a(!r);
      }
    },
    /* @__PURE__ */ n.createElement(Xe, { display: r ? "minus" : "plus", base: !0 }),
    t.general.annotationDropdownText === "" ? "Annotations" : (s = t == null ? void 0 : t.general) == null ? void 0 : s.annotationDropdownText
  ), r && /* @__PURE__ */ n.createElement("div", { className: "table-container annotation-dropdown__panel", style: o }, /* @__PURE__ */ n.createElement(Sp.List, { useBootstrapVisibilityClasses: !1 }))));
}, Sp = {
  Draggable: Wk,
  // Mobile auto display
  List: jk,
  // Desktop Accessible Option
  Dropdown: Uk
}, Kk = ({ axis: e, max: t, runtime: r, currentViewport: a, isHorizontal: i, data: o, config: d, min: c }) => {
  let { numTicks: s } = r[e];
  r[e].viewportNumTicks && r[e].viewportNumTicks[a] && (s = r[e].viewportNumTicks[a]);
  let p;
  return e === "yAxis" && (p = i && !s ? o.length : i && s ? s : !i && !s ? void 0 : !i && s && s, p === void 0 && !d.dataFormat.roundTo && (Number(t) <= 3 ? p = 2 : p = 4), Number(p) > Number(t) && !i && (p = Number(c) < 0 ? Math.round(t) * 2 : Math.round(t))), e === "xAxis" && (p = i && !s ? void 0 : i && s ? s : !i && !s ? void 0 : !i && s && s, i && p === void 0 && !d.dataFormat.roundTo && (t <= 3 ? p = 2 : p = 4), d.visualizationType === "Forest Plot" && (p = d.yAxis.numTicks !== "" ? d.yAxis.numTicks : 4)), p;
}, sf = 9, uf = 3, cf = 8, Yk = 1e3 * 60 * 60 * 24 * 30, df = ue.forwardRef(({ parentHeight: e, parentWidth: t }, r) => {
  var Nn, Ln, fn, Fn, Zt;
  const {
    brushConfig: a,
    colorScale: i,
    config: o,
    currentViewport: d,
    dimensions: c,
    formatDate: s,
    formatNumber: p,
    handleChartAriaLabels: m,
    handleLineType: y,
    handleDragStateChange: x,
    isDraggingAnnotation: T,
    legendRef: S,
    parseDate: A,
    parentRef: E,
    tableData: b,
    transformedData: v,
    updateConfig: N,
    seriesHighlight: C
  } = ue.useContext(gt), {
    heights: R,
    visualizationType: _,
    visualizationSubType: U,
    orientation: j,
    xAxis: te,
    yAxis: Q,
    runtime: $,
    legend: J,
    forestPlot: ne,
    brush: z,
    dataFormat: W,
    debugSvg: ie
  } = o, { suffix: ae, onlyShowTopPrefixSuffix: oe } = W, { labelsAboveGridlines: K, hideAxis: Y } = o.yAxis, { minValue: X, maxValue: q, existPositiveValue: ce, isAllLine: ge } = Vc(o, v), { visSupportsReactTooltip: De } = zs(), { hasTopAxis: me } = Bk(o), [Fe, Ue] = ue.useState(!1), [Te, ve] = ue.useState({ x: 0, y: 0 }), [Ae, fe] = ue.useState(0), [ze, Oe] = ue.useState(0), Ve = ue.useRef(null), Ze = ue.useRef(null), Ie = ue.useRef(null), qe = ue.useRef(null), et = ue.useRef(), He = ue.useRef([]), Ge = ue.useRef(null), Le = ue.useRef(q), _e = gp(et, {
    freezeOnceVisible: !1
  }), st = !0, Ee = j === "horizontal" || o.visualizationType === "Forest Plot", rt = o.yAxis.type === "logarithmic", pt = _ === "Forest Plot", ft = o.xAxis.type === "date-time", wt = !ae.includes(" "), zt = oe && !wt, Jt = Number(j === "horizontal" ? o.xAxis.size : o.yAxis.size), jt = isNaN(parseInt(`${$.yAxis.labelOffset}`)) ? 0 : parseInt(`${$.yAxis.labelOffset}`), on = pt ? o.data.length * o.forestPlot.rowHeight : 0, _t = ue.useMemo(
    () => Lk(o, d),
    [o, d, e, (Nn = o.heights) == null ? void 0 : Nn.vertical, (Ln = o.heights) == null ? void 0 : Ln.horizontal]
  ), tn = ue.useMemo(() => _t + on, [_t, on]), $t = ue.useMemo(() => {
    var xe;
    const we = c[0], g = J == null ? void 0 : J.hide, P = ["bottom", "top"].includes((xe = o.legend) == null ? void 0 : xe.position), M = ya(d);
    if (!(!pt && !g && !P && !M))
      return we;
    if (S.current) {
      const B = getComputedStyle(S.current);
      return we - S.current.getBoundingClientRect().width - parseInt(B.marginLeft) - parseInt(B.marginRight);
    }
    return we * 0.73;
  }, [c[0], o.legend, d, S.current]), Ut = ue.useMemo(() => {
    var g;
    return He.current = (g = He.current) == null ? void 0 : g.filter((P) => P), He.current.length ? Math.max(...He.current.map((P) => P.getBBox().height)) + uf + cf : void 0;
  }, [c[0], o.xAxis, He.current, o.xAxis.tickRotation]), bt = $t - $.yAxis.size - (_ === "Combo" ? o.yAxis.rightAxisSize : 0), mt = _t + on, ln = o.filters && o.filters.values.length === 0 && v.length === 0, Yt = (we) => Rn(o.runtime.xAxis) ? A(we[o.runtime.originalXAxis.dataKey]).getTime() : we[o.runtime.originalXAxis.dataKey], xt = (we, g) => we[g], Gt = o.brush.active && ((fn = a.data) != null && fn.length) ? a.data.map((we) => Yt(we)) : v.map((we) => Yt(we)), Sn = o.orientation === "horizontal" || o.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", At = {
    data: v,
    tableData: b,
    config: {
      ...o,
      yAxis: {
        ...o.yAxis,
        scalePadding: zt ? ze : o.yAxis.scalePadding,
        enablePadding: zt || o.yAxis.enablePadding
      }
    },
    minValue: X,
    maxValue: q,
    isAllLine: ge,
    existPositiveValue: ce,
    xAxisDataMapped: Gt,
    xMax: bt,
    yMax: mt
  }, { min: nn, max: Xt, leftMax: sn, rightMax: Nt } = pg(At), { yScaleRight: xn, hasRightAxis: dn } = Ep({ config: o, yMax: mt, data: v, updateConfig: N }), { xScale: Lt, yScale: nt, seriesScale: bn, g1xScale: Hn, g2xScale: Gn, xScaleNoPadding: An, xScaleAnnotation: Un } = Pk({
    ...At,
    min: nn,
    max: Xt,
    leftMax: sn,
    rightMax: Nt,
    dimensions: c,
    xMax: t - Number(o.orientation === "horizontal" ? o.xAxis.size : o.yAxis.size)
  }), [_n, Pn] = ["yAxis", "xAxis"].map(
    (we) => Kk({ axis: we, max: Xt, runtime: $, currentViewport: d, isHorizontal: Ee, data: v, config: o, min: nn })
  ), pn = pt ? o.data.length : _n, { tooltipData: Se, showTooltip: Ne, hideTooltip: pe, tooltipOpen: Ke, tooltipLeft: ht, tooltipTop: it } = Uy(), {
    handleTooltipMouseOver: ct,
    handleTooltipClick: Kt,
    handleTooltipMouseOff: Ot,
    TooltipListItem: tt,
    getXValueFromCoordinate: ut
  } = qy({
    xScale: Lt,
    yScale: nt,
    showTooltip: Ne,
    hideTooltip: pe
  }), { dataKey: It } = $.xAxis, Rt = v.length && ft ? [0, v.length - 1].map((we) => A(v[we][It])).reduce((we, g) => Math.abs(we - g)) / Yk : 0, Ht = ft && Rt > Pn, Ft = () => Hc(o.visualizationType, v, o.allowLineToBarGraph), hn = (we, g, P) => {
    if (rt && we === 0.1 && (we = 0), !(o.data && !o.data[g] && _ === "Forest Plot"))
      return o.visualizationType === "Forest Plot" ? o.data[g][o.xAxis.dataKey] : Rn($.yAxis) ? s(A(we)) : j === "vertical" && Xt - nn < 3 ? p(we, "left", st, !1, !1, "1", { index: g, length: P.length }) : j === "vertical" ? p(we, "left", st, !1, !1, void 0, { index: g, length: P.length }) : we;
  }, mn = (we, g, P) => (rt && we === 0.1 && (we = 0), Rn($.xAxis) && o.visualizationType !== "Forest Plot" ? s(we, g, P) : j === "horizontal" && o.visualizationType !== "Forest Plot" ? p(we, "left", st) : o.xAxis.type === "continuous" && o.visualizationType !== "Forest Plot" ? p(we, "bottom", st) : o.visualizationType === "Forest Plot" ? p(
    we,
    "left",
    o.dataFormat.abbreviated,
    o.runtime.xAxis.prefix,
    o.runtime.xAxis.suffix,
    Number(o.dataFormat.roundTo)
  ) : we), Mt = () => {
    const { visualizationType: we } = o;
    return we === "Combo" && $.forecastingSeriesKeys > 0 || we === "Area Chart" || we === "Line" || we === "Bar";
  }, kn = () => {
    let we = o.xAxis.manualStep;
    return o.xAxis.viewportStepCount && o.xAxis.viewportStepCount[d] && (we = o.xAxis.viewportStepCount[d]), we;
  }, wn = (we) => {
    const g = we.currentTarget.getBoundingClientRect(), P = we.clientX - g.left, M = we.clientY - g.top;
    ve({
      x: P,
      y: M
    });
  };
  ue.useEffect(() => {
    document.querySelector(".isEditor") && Ue((g) => !0);
  }), ue.useEffect(() => {
    (_e == null ? void 0 : _e.isIntersecting) === !0 && o.animate && setTimeout(() => {
      Ue((we) => !0);
    }, 500);
  }, [_e == null ? void 0 : _e.isIntersecting, o.animate]), ue.useEffect(() => {
    const we = Ie.current;
    if (!we && !Ae)
      return;
    if (!we)
      return fe(0);
    const g = we.getBBox().width;
    fe(g);
  }, [o.dataFormat.suffix, o.dataFormat.onlyShowTopPrefixSuffix]), ue.useEffect(() => {
    if (!pt || te.hideLabel)
      return;
    const we = Ze.current;
    if (!we)
      return;
    const g = mt + Number(o.xAxis.axisPadding), M = we.getBBox().y - g + we.getBBox().height + sf;
    Ge.current && Ge.current.setAttribute("y", M);
  }, [(Fn = o == null ? void 0 : o.data) == null ? void 0 : Fn.length, on]), ue.useEffect(() => {
    if (!Ve.current)
      return;
    const we = Ve.current.getBBox().height, g = _ === "Forest Plot", P = qe.current && Q.labelsAboveGridlines, M = z != null && z.active ? z == null ? void 0 : z.height : 0, Z = g ? o.data.length * ne.rowHeight : 0, xe = P ? qe.current.getBBox().height : 0, B = we + M + Z + xe, I = _t + B;
    if (!E.current || (E.current.style.height = `${I}px`, !xe))
      return;
    const ee = r.current;
    if (!ee)
      return;
    const be = E.current.getBoundingClientRect().width;
    if (ee.setAttribute("viewBox", `0 ${-xe} ${be} ${I}`), !S.current)
      return;
    const We = (J == null ? void 0 : J.position) !== "top" && (J == null ? void 0 : J.position) !== "bottom" && !ya(d);
    S.current.style.transform = We ? `translateY(${xe}px)` : "none";
  }, [Ve.current, o, Ut, z, d, qe.current, _t]), ue.useEffect(() => {
    Le.current !== q && (Le.current = q, ze && Oe(0));
  }, [q]), ue.useEffect(() => {
    if (j === "horizontal" || !(q > Math.max(...nt.ticks(pn))) || !zt)
      return;
    const g = nt.ticks(pn)[1] - nt.ticks(pn)[0], P = Math.max(...nt.ticks(pn)) + g, M = X < 0 ? (P - q) / q / 2 : (P - q) / q;
    Oe(M * 100);
  }, [q, zt, nt, pn]);
  const On = () => {
    const we = Ut + sf, g = (P, M) => {
      if (!P.length)
        return !1;
      const Z = P.filter((Dt) => Dt.index !== 0), xe = Z == null ? void 0 : Z.length, B = M.range()[0] || bt / 2, I = Z.map(
        (Dt) => Jn(p(Dt.value, "left"), `normal ${zi[o.fontSize]}px sans-serif`)
      ), ee = 100, be = I.reduce((Dt, Bt) => Dt + Bt, ee), We = (B - be) / xe;
      let Qe = [0];
      for (let Dt = 1; Dt < I.length; Dt++)
        Qe[Dt] = Qe[Dt - 1] + I[Dt - 1] + We;
      let St = !1;
      return I.forEach((Dt, Bt) => {
        if (Qe[Bt] + I[Bt] > Qe[Bt + 1]) {
          St = !0;
          return;
        }
      }), St;
    };
    return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Gu,
      {
        top: mt,
        left: Number($.yAxis.size),
        label: $.xAxis.label,
        tickFormat: Rn($.xAxis) ? s : p,
        scale: Hn,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: $.xAxis.numTicks || void 0
      },
      (P) => /* @__PURE__ */ n.createElement(at, { className: "bottom-axis" }, P.ticks.map((M, Z) => {
        Jn(
          p(M.value, "left"),
          `normal ${zi[o.fontSize]}px sans-serif`
        );
        const xe = g(P.ticks, Hn), B = Number(o.xAxis.maxTickRotation) || 90, I = o.isResponsiveTicks && xe, ee = M.index !== 0 && (I ? B : Number(o.yAxis.tickRotation)), be = ee && M.index !== 0 ? "end" : "middle";
        return /* @__PURE__ */ n.createElement(at, { key: `vx-tick-${M.value}-${Z}`, className: "vx-axis-tick" }, !$.yAxis.hideTicks && /* @__PURE__ */ n.createElement(cn, { from: M.from, to: M.to, stroke: "#333" }), !$.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          vt,
          {
            innerRef: (We) => He.current[Z] = We,
            x: M.to.x,
            y: M.to.y,
            angle: -ee,
            verticalAnchor: ee ? "middle" : "start",
            textAnchor: be
          },
          p(M.value, "left")
        ));
      }), !$.yAxis.hideAxis && /* @__PURE__ */ n.createElement(cn, { from: P.axisFromPoint, to: P.axisToPoint, stroke: "#333" }))
    ), /* @__PURE__ */ n.createElement(
      Gu,
      {
        innerRef: Ve,
        top: mt,
        left: Number($.yAxis.size),
        label: $.xAxis.label,
        tickFormat: Rn($.xAxis) ? s : $.xAxis.dataKey !== "Year" ? p : (P) => P,
        scale: Gn,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: $.xAxis.numTicks || void 0
      },
      (P) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(at, { className: "bottom-axis" }, P.ticks.map((M, Z) => {
        Jn(
          p(M.value, "left"),
          `normal ${zi[o.fontSize]}px sans-serif`
        );
        const xe = g(P.ticks, Gn), B = Number(o.xAxis.maxTickRotation) || 90, I = o.isResponsiveTicks && xe, ee = M.index !== 0 && (I ? B : Number(o.yAxis.tickRotation)), be = ee && M.index !== 0 ? "end" : "middle";
        return Z ? /* @__PURE__ */ n.createElement(at, { key: `vx-tick-${M.value}-${Z}`, className: "vx-axis-tick" }, !$.yAxis.hideTicks && /* @__PURE__ */ n.createElement(cn, { from: M.from, to: M.to, stroke: "#333" }), !$.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          vt,
          {
            x: M.to.x,
            y: M.to.y + uf,
            angle: -ee,
            verticalAnchor: ee ? "middle" : "start",
            textAnchor: be
          },
          p(M.value, "left")
        )) : /* @__PURE__ */ n.createElement(n.Fragment, null);
      }), !$.yAxis.hideAxis && /* @__PURE__ */ n.createElement(cn, { from: P.axisFromPoint, to: P.axisToPoint, stroke: "#333" })), /* @__PURE__ */ n.createElement(at, null, /* @__PURE__ */ n.createElement(
        vt,
        {
          className: "x-axis-title-label",
          x: bt / 2,
          y: we,
          stroke: "#333",
          textAnchor: "middle",
          verticalAnchor: "start"
        },
        $.xAxis.label
      )))
    ));
  };
  return isNaN($t) ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement($r, { component: "LinearChart" }, /* @__PURE__ */ n.createElement(
    "div",
    {
      style: { width: `${t}px`, overflow: "visible", position: "relative" },
      className: "tooltip-boundary"
    },
    /* @__PURE__ */ n.createElement(
      "svg",
      {
        ref: r,
        onMouseMove: wn,
        width: t,
        height: ln ? 1 : e,
        className: `linear ${o.animate ? "animated" : ""} ${Fe && o.animate ? "animate" : ""} ${ie && "debug"} ${T && "dragging-annotation"}`,
        role: "img",
        "aria-label": m(o),
        style: { overflow: "visible" }
      },
      !T && /* @__PURE__ */ n.createElement(Lr, { width: t, height: _t, fill: "transparent" }),
      " ",
      !["Spark Line", "Forest Plot"].includes(_) && o.yAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(
        om,
        {
          scale: nt,
          left: Number($.yAxis.size) - o.yAxis.axisPadding,
          numTicks: pn
        },
        (we) => {
          const g = o.orientation === "horizontal" ? (we.axisToPoint.y - we.axisFromPoint.y) / 2 : (we.axisFromPoint.y - we.axisToPoint.y) / 2;
          return /* @__PURE__ */ n.createElement(at, { className: "left-axis" }, we.ticks.map((P, M) => {
            const Z = String(P.value).startsWith("1") || P.value === 0.1 ? "block" : "none", xe = P.index === 0 && P.value === 0 && o.xAxis.hideAxis;
            return /* @__PURE__ */ n.createElement(at, { key: `vx-tick-${P.value}-${M}`, className: "vx-axis-tick" }, $.yAxis.gridLines && !xe ? /* @__PURE__ */ n.createElement(
              cn,
              {
                key: `${P.value}--hide-hideGridLines`,
                display: (rt && Z).toString(),
                from: { x: P.from.x + bt, y: P.from.y },
                to: P.from,
                stroke: "#d6d6d6"
              }
            ) : "");
          }), /* @__PURE__ */ n.createElement(
            vt,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${-1 * $.yAxis.size + jt}, ${g}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.labelColor
            },
            we.label
          ));
        }
      ),
      _ === "Paired Bar" && On(),
      _ === "Deviation Bar" && ((Zt = o.runtime.series) == null ? void 0 : Zt.length) === 1 && /* @__PURE__ */ n.createElement(hk, { animatedChart: Fe, xScale: Lt, yScale: nt, width: bt, height: mt }),
      _ === "Paired Bar" && /* @__PURE__ */ n.createElement(Ck, { originalWidth: $t, width: bt, height: mt }),
      _ === "Scatter Plot" && /* @__PURE__ */ n.createElement(
        pk,
        {
          xScale: Lt,
          yScale: nt,
          getXAxisData: Yt,
          getYAxisData: xt,
          xMax: bt,
          yMax: mt,
          handleTooltipMouseOver: ct,
          handleTooltipMouseOff: Ot,
          handleTooltipClick: Kt,
          tooltipData: Se,
          showTooltip: Ne
        }
      ),
      _ === "Box Plot" && /* @__PURE__ */ n.createElement(
        fk,
        {
          seriesScale: bn,
          xMax: bt,
          yMax: mt,
          min: nn,
          max: Xt,
          xScale: Lt,
          yScale: nt
        }
      ),
      (_ === "Area Chart" && o.visualizationSubType === "regular" || _ === "Combo") && /* @__PURE__ */ n.createElement(
        ek,
        {
          xScale: Lt,
          yScale: nt,
          yMax: mt,
          xMax: bt,
          chartRef: r,
          width: bt,
          height: mt,
          handleTooltipMouseOver: ct,
          handleTooltipMouseOff: Ot,
          tooltipData: Se,
          showTooltip: Ne
        }
      ),
      (_ === "Area Chart" && o.visualizationSubType === "stacked" || _ === "Combo") && /* @__PURE__ */ n.createElement(
        nk,
        {
          xScale: Lt,
          yScale: nt,
          yMax: mt,
          xMax: bt,
          chartRef: r,
          width: bt,
          height: mt,
          handleTooltipMouseOver: ct,
          handleTooltipMouseOff: Ot,
          tooltipData: Se,
          showTooltip: Ne
        }
      ),
      (_ === "Bar" || _ === "Combo" || Ft()) && /* @__PURE__ */ n.createElement(
        lk,
        {
          xScale: Lt,
          yScale: nt,
          seriesScale: bn,
          xMax: bt,
          yMax: mt,
          getXAxisData: Yt,
          getYAxisData: xt,
          animatedChart: Fe,
          visible: Fe,
          handleTooltipMouseOver: ct,
          handleTooltipMouseOff: Ot,
          handleTooltipClick: Kt,
          tooltipData: Se,
          showTooltip: Ne,
          chartRef: r
        }
      ),
      (_ === "Line" && !Ft() || _ === "Combo" || _ === "Bump Chart") && /* @__PURE__ */ n.createElement(
        pm,
        {
          xScale: Lt,
          yScale: nt,
          getXAxisData: Yt,
          getYAxisData: xt,
          xMax: bt,
          yMax: mt,
          seriesStyle: o.runtime.series,
          handleTooltipMouseOver: ct,
          handleTooltipMouseOff: Ot,
          handleTooltipClick: Kt,
          tooltipData: Se,
          showTooltip: Ne,
          chartRef: r
        }
      ),
      (_ === "Forecasting" || _ === "Combo") && /* @__PURE__ */ n.createElement(
        yk,
        {
          showTooltip: Ne,
          tooltipData: Se,
          xScale: Lt,
          yScale: nt,
          width: bt,
          le: !0,
          height: mt,
          xScaleNoPadding: An,
          chartRef: r,
          getXValueFromCoordinate: ut,
          handleTooltipMouseOver: ct,
          handleTooltipMouseOff: Ot,
          isBrush: !1
        }
      ),
      _ === "Forest Plot" && /* @__PURE__ */ n.createElement(
        wk,
        {
          xScale: Lt,
          yScale: nt,
          seriesScale: bn,
          width: $t,
          height: tn,
          getXAxisData: Yt,
          getYAxisData: xt,
          animatedChart: Fe,
          visible: Fe,
          handleTooltipMouseOver: ct,
          handleTooltipMouseOff: Ot,
          handleTooltipClick: Kt,
          tooltipData: Se,
          showTooltip: Ne,
          chartRef: r,
          config: o,
          forestPlotRightLabelRef: Ze
        }
      ),
      o.brush.active && o.xAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(QS, { xMax: bt, yMax: mt }),
      !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(
        _
      ) && !Ft() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        pm,
        {
          xScale: Lt,
          yScale: nt,
          getXAxisData: Yt,
          getYAxisData: xt,
          xMax: bt,
          yMax: mt,
          seriesStyle: o.runtime.series
        }
      )),
      o.yAxis.anchors && o.yAxis.anchors.map((we, g) => {
        let P = nt(we.value), M = 0;
        if (we.value && (o.yAxis.labelPlacement === "Below Bar" ? M = -6.5 + Number(o.series.length * o.barHeight) / o.series.length : M = 8, !!P))
          return (
            // prettier-ignore
            /* @__PURE__ */ n.createElement(
              cn,
              {
                key: `yAxis-${we.value}--${g}`,
                strokeDasharray: y(we.lineStyle),
                stroke: we.color ? we.color : "rgba(0,0,0,1)",
                className: "anchor-y",
                from: { x: 0 + Jt, y: P - M },
                to: { x: $t - o.yAxis.rightAxisSize, y: P - M }
              }
            )
          );
      }),
      o.xAxis.anchors && o.xAxis.anchors.map((we, g) => {
        let P = te;
        j === "horizontal" && (P = Q);
        let Z = (() => {
          let xe;
          return xe = Rn(P) ? Lt(A(we.value, !1)) : Lt(we.value), (o.xAxis.type === "categorical" || o.xAxis.type === "date") && (xe = xe ? xe + (P.type === "categorical" || P.type === "date" ? Lt.bandwidth() : 0) / 2 : 0), xe;
        })();
        if (Z)
          return (
            // prettier-ignore
            /* @__PURE__ */ n.createElement(
              cn,
              {
                key: `xAxis-${we.value}--${g}`,
                strokeDasharray: y(we.lineStyle),
                stroke: we.color ? we.color : "rgba(0,0,0,1)",
                fill: we.color ? we.color : "rgba(0,0,0,1)",
                className: "anchor-x",
                from: { x: Number(Z) + Number(Jt), y: 0 },
                to: { x: Number(Z) + Number(Jt), y: mt }
              }
            )
          );
      }),
      o.visualizationType !== "Bar" && o.visualizationType !== "Combo" && /* @__PURE__ */ n.createElement(
        bp,
        {
          xScale: Lt,
          handleTooltipClick: Kt,
          handleTooltipMouseOff: Ot,
          handleTooltipMouseOver: ct,
          showTooltip: Ne,
          hideTooltip: pe,
          tooltipData: Se,
          yMax: mt,
          width: $t
        }
      ),
      Mt && Ne && Se && o.visual.verticalHoverLine && /* @__PURE__ */ n.createElement(at, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ n.createElement(
        cn,
        {
          from: { x: Se.dataXPosition - 10, y: 0 },
          to: { x: Se.dataXPosition - 10, y: mt },
          stroke: "black",
          strokeWidth: 1,
          pointerEvents: "none",
          strokeDasharray: "5,5",
          className: "vertical-tooltip-line"
        }
      )),
      Mt && Ne && Se && o.visual.horizontalHoverLine && /* @__PURE__ */ n.createElement(
        at,
        {
          key: "tooltipLine-horizontal",
          className: "horizontal-tooltip-line",
          left: o.yAxis.size ? o.yAxis.size : 0
        },
        /* @__PURE__ */ n.createElement(
          cn,
          {
            from: { x: 0, y: Se.dataYPosition },
            to: { x: bt, y: Se.dataYPosition },
            stroke: "black",
            strokeWidth: 1,
            pointerEvents: "none",
            strokeDasharray: "5,5",
            className: "horizontal-tooltip-line"
          }
        )
      ),
      ln && /* @__PURE__ */ n.createElement(
        vt,
        {
          x: Number(o.yAxis.size) + Number(bt / 2),
          y: _t / 2 - (o.xAxis.padding || 0) / 2,
          textAnchor: "middle"
        },
        o.chartMessage.noData
      ),
      (o.visualizationType === "Bar" || Ft()) && o.tooltips.singleSeries && o.visual.horizontalHoverLine && /* @__PURE__ */ n.createElement(
        at,
        {
          key: "tooltipLine-horizontal",
          className: "horizontal-tooltip-line",
          left: o.yAxis.size ? o.yAxis.size : 0
        },
        /* @__PURE__ */ n.createElement(
          cn,
          {
            from: { x: 0, y: Te.y },
            to: { x: bt, y: Te.y },
            stroke: "black",
            strokeWidth: 1,
            pointerEvents: "none",
            strokeDasharray: "5,5",
            className: "horizontal-tooltip-line"
          }
        )
      ),
      (o.visualizationType === "Bar" || Ft()) && o.tooltips.singleSeries && o.visual.verticalHoverLine && /* @__PURE__ */ n.createElement(at, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ n.createElement(
        cn,
        {
          from: { x: Te.x, y: 0 },
          to: { x: Te.x, y: mt },
          stroke: "black",
          strokeWidth: 1,
          pointerEvents: "none",
          strokeDasharray: "5,5",
          className: "vertical-tooltip-line"
        }
      )),
      /* @__PURE__ */ n.createElement(at, { left: Number(o.runtime.yAxis.size) }, /* @__PURE__ */ n.createElement(
        Sp.Draggable,
        {
          xScale: Lt,
          yScale: nt,
          xScaleAnnotation: Un,
          xMax: bt,
          svgRef: r,
          onDragStateChange: x
        }
      )),
      !["Spark Line", "Forest Plot"].includes(_) && o.yAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(
        om,
        {
          scale: nt,
          tickLength: rt ? 6 : 8,
          left: Number($.yAxis.size) - o.yAxis.axisPadding,
          label: $.yAxis.label || $.yAxis.label,
          stroke: "#333",
          tickFormat: hn,
          numTicks: pn
        },
        (we) => {
          const g = o.orientation === "horizontal" ? (we.axisToPoint.y - we.axisFromPoint.y) / 2 : (we.axisFromPoint.y - we.axisToPoint.y) / 2, P = mt / we.ticks.length / 2 - mt / we.ticks.length * (1 - o.barThickness) + 5;
          return /* @__PURE__ */ n.createElement(at, { className: "left-axis" }, !o.yAxis.hideAxis && /* @__PURE__ */ n.createElement(
            cn,
            {
              from: we.axisFromPoint,
              to: $.horizontal ? {
                x: 0,
                y: o.visualizationType === "Forest Plot" ? e : Number(R.horizontal)
              } : we.axisToPoint,
              stroke: "#000"
            }
          ), nt.domain()[0] < 0 && /* @__PURE__ */ n.createElement(
            cn,
            {
              from: { x: we.axisFromPoint.x, y: nt(0) },
              to: { x: bt, y: nt(0) },
              stroke: "#333"
            }
          ), _ === "Bar" && j === "horizontal" && Lt.domain()[0] < 0 && /* @__PURE__ */ n.createElement(
            cn,
            {
              from: { x: Lt(0), y: 0 },
              to: { x: Lt(0), y: mt },
              stroke: "#333",
              strokeWidth: 2
            }
          ), we.ticks.map((M, Z) => {
            const xe = we.ticks[0].to.y, B = 15, I = String(M.value).startsWith("1") || M.value === 0.1 ? "block" : "none", ee = I === "block" ? 7 : 0, be = { x: M.to.x - ee, y: M.to.y }, We = we.ticks.length - 1 === Z, Qe = We && oe && ae && !wt, Dt = K ? Y ? -8 : -12 : 2, Bt = K ? 4 : 0, Cn = M.to.x - Dt, Kn = M.to.y - Bt, Mn = K ? "end" : "middle", fr = oe && K && ae && We;
            return /* @__PURE__ */ n.createElement(at, { key: `vx-tick-${M.value}-${Z}`, className: "vx-axis-tick" }, !$.yAxis.hideTicks && !K && !Qe && /* @__PURE__ */ n.createElement(
              cn,
              {
                key: `${M.value}--hide-hideTicks`,
                from: M.from,
                to: rt ? be : M.to,
                stroke: o.yAxis.tickColor,
                display: j === "horizontal" ? "none" : "block"
              }
            ), j === "horizontal" && U !== "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              vt,
              {
                transform: `translate(${M.to.x - 5}, ${o.isLollipopChart ? M.to.y - xe : M.to.y - xe + (Number(o.barHeight * o.runtime.series.length) - B) / 2}) rotate(-${o.runtime.horizontal && o.runtime.yAxis.tickRotation || 0})`,
                verticalAnchor: "start",
                textAnchor: "end"
              },
              M.formattedValue
            ), j === "horizontal" && U === "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              vt,
              {
                transform: `translate(${M.to.x - 5}, ${M.to.y - xe + (Number(o.barHeight) - B) / 2}) rotate(-${$.horizontal ? $.yAxis.tickRotation : 0})`,
                verticalAnchor: "start",
                textAnchor: "end"
              },
              M.formattedValue
            ), j === "horizontal" && _ === "Paired Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              vt,
              {
                transform: `translate(${M.to.x - 5}, ${M.to.y - xe + Number(o.barHeight) / 2}) rotate(-${$.horizontal ? $.yAxis.tickRotation : 0})`,
                textAnchor: "end",
                verticalAnchor: "middle"
              },
              M.formattedValue
            ), j === "horizontal" && _ === "Deviation Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              vt,
              {
                transform: `translate(${M.to.x - 5}, ${o.isLollipopChart ? M.to.y - xe + 2 : M.to.y - xe + Number(o.barHeight) / 2}) rotate(-${$.horizontal ? $.yAxis.tickRotation : 0})`,
                textAnchor: "end",
                verticalAnchor: "middle"
              },
              M.formattedValue
            ), j === "vertical" && _ === "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
              vt,
              {
                display: o.useLogScale ? I : "block",
                dx: o.useLogScale ? -6 : 0,
                x: o.runtime.horizontal ? M.from.x + 2 : M.to.x - 8.5,
                y: M.to.y - 13 + (o.runtime.horizontal ? P : 0),
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: o.runtime.horizontal ? "start" : "middle",
                textAnchor: o.runtime.horizontal ? "start" : "end",
                fill: o.yAxis.tickLabelColor
              },
              o.runtime.seriesLabelsAll[M.formattedValue - 1]
            ), (C.length === 0 || C.includes(
              o.runtime.seriesLabelsAll[M.formattedValue - 1]
            )) && /* @__PURE__ */ n.createElement(
              "rect",
              {
                x: 0 - Number(o.yAxis.size),
                y: M.to.y - 8 + (o.runtime.horizontal ? P : 7),
                width: Number(o.yAxis.size) + Lt(Lt.domain()[0]),
                height: "2",
                fill: i(o.runtime.seriesLabelsAll[M.formattedValue - 1])
              }
            )), j === "vertical" && _ !== "Paired Bar" && _ !== "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(n.Fragment, null, oe && We && !K && /* @__PURE__ */ n.createElement(
              Up,
              {
                innerRef: Ie,
                display: rt ? I : "block",
                dx: rt ? -6 : 0,
                x: Cn,
                y: Kn,
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: Mn,
                textAnchor: wt ? "end" : "start",
                fill: o.yAxis.tickLabelColor,
                stroke: "#fff",
                paintOrder: "stroke",
                strokeLinejoin: "round",
                style: { whiteSpace: "pre-wrap" }
              },
              ae
            ), /* @__PURE__ */ n.createElement(
              Up,
              {
                innerRef: (Xn) => We && (qe.current = Xn),
                display: rt ? I : "block",
                dx: rt ? -6 : 0,
                x: wt ? Cn - Ae : Cn,
                y: Kn + (o.runtime.horizontal ? P : 0),
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: o.runtime.horizontal ? "start" : Mn,
                textAnchor: o.runtime.horizontal || K ? "start" : "end",
                fill: o.yAxis.tickLabelColor,
                stroke: "#fff",
                disableStroke: !K,
                strokeLinejoin: "round",
                paintOrder: "stroke",
                style: { whiteSpace: "pre-wrap" }
              },
              `${M.formattedValue}${fr ? ae : ""}`
            )));
          }), /* @__PURE__ */ n.createElement(
            vt,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${-1 * $.yAxis.size + jt}, ${g}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.labelColor
            },
            we.label
          ));
        }
      ),
      o.yAxis.type === "categorical" && o.orientation === "vertical" && /* @__PURE__ */ n.createElement(
        Tk,
        {
          max: Xt,
          maxValue: q,
          height: _t,
          xMax: bt,
          yMax: mt,
          leftSize: Number($.yAxis.size) - o.yAxis.axisPadding
        }
      ),
      dn && /* @__PURE__ */ n.createElement(
        OS,
        {
          scale: xn,
          left: Number($t - o.yAxis.rightAxisSize),
          label: o.yAxis.rightLabel,
          tickFormat: (we) => p(we, "right"),
          numTicks: $.yAxis.rightNumTicks || void 0,
          labelOffset: 45
        },
        (we) => {
          const g = o.orientation === "horizontal" ? (we.axisToPoint.y - we.axisFromPoint.y) / 2 : (we.axisFromPoint.y - we.axisToPoint.y) / 2, P = mt / we.ticks.length / 2 - mt / we.ticks.length * (1 - o.barThickness) + 5;
          return /* @__PURE__ */ n.createElement(at, { className: "right-axis" }, we.ticks.map((M, Z) => /* @__PURE__ */ n.createElement(at, { key: `vx-tick-${M.value}-${Z}`, className: "vx-axis-tick" }, !$.yAxis.rightHideTicks && /* @__PURE__ */ n.createElement(
            cn,
            {
              from: M.from,
              to: M.to,
              display: $.horizontal ? "none" : "block",
              stroke: o.yAxis.rightAxisTickColor
            }
          ), $.yAxis.rightGridLines ? /* @__PURE__ */ n.createElement(cn, { from: { x: M.from.x + bt, y: M.from.y }, to: M.from, stroke: "#d6d6d6" }) : "", !o.yAxis.rightHideLabel && /* @__PURE__ */ n.createElement(
            vt,
            {
              x: M.to.x,
              y: M.to.y + ($.horizontal ? P : 0),
              verticalAnchor: $.horizontal ? "start" : "middle",
              textAnchor: "start",
              fill: o.yAxis.rightAxisTickLabelColor
            },
            M.formattedValue
          ))), !o.yAxis.rightHideAxis && /* @__PURE__ */ n.createElement(cn, { from: we.axisFromPoint, to: we.axisToPoint, stroke: "#333" }), /* @__PURE__ */ n.createElement(
            vt,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${o.yAxis.rightLabelOffsetSize ? o.yAxis.rightLabelOffsetSize : 0}, ${g}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.rightAxisLabelColor
            },
            we.label
          ));
        }
      ),
      me && o.topAxis.hasLine && /* @__PURE__ */ n.createElement(
        BS,
        {
          stroke: "#333",
          left: Number($.yAxis.size),
          scale: Lt,
          hideTicks: !0,
          hideZero: !0,
          tickLabelProps: () => ({
            fill: "transparent"
          })
        }
      ),
      _ !== "Paired Bar" && _ !== "Spark Line" && /* @__PURE__ */ n.createElement(
        Gu,
        {
          innerRef: Ve,
          top: $.horizontal && o.visualizationType !== "Forest Plot" ? Number(R.horizontal) + Number(o.xAxis.axisPadding) : o.visualizationType === "Forest Plot" ? mt + Number(o.xAxis.axisPadding) : mt,
          left: o.visualizationType !== "Forest Plot" ? Number($.yAxis.size) : 0,
          label: o[Sn].label,
          tickFormat: mn,
          scale: Lt,
          stroke: "#333",
          numTicks: Ht ? Rt : Pn,
          tickStroke: "#333",
          tickValues: o.xAxis.manual ? Dk(Gt, Lt, ft ? Pn : kn(), o) : o.xAxis.type === "date" ? Gt : void 0
        },
        (we) => {
          var Xn;
          o.xAxis.type === "date" && !o.xAxis.manual && (we.ticks = _k(o, we, Gt, s));
          const g = Ht && Lt.ticks(Pn).map((Ct) => we.ticks.findIndex((rn) => rn.value.getTime() === Ct.getTime())).slice(0, 2).reduce((Ct, rn) => rn - Ct), P = Ht ? [...we.ticks].reverse().filter((Ct, rn) => rn % g === 0).reverse().map((Ct, rn, xr) => ({
            ...Ct,
            // reformat in case showYearsOnce, since first month of year may have changed
            formattedValue: mn(Ct.value, rn, xr)
          })) : we.ticks, M = Ut + sf, Z = (Ct) => /\s/.test(Ct), xe = P.some((Ct) => Z(Ct.value)), B = Math.max(
            ...P.map(
              (Ct) => Jn(Ct.formattedValue, `normal ${zi[o.fontSize]}px sans-serif`)
            )
          ), I = xe ? 180 : 100, ee = P.map(
            (Ct) => Jn(Ct.formattedValue, `normal ${zi[o.fontSize]}px sans-serif`)
          ), be = ee.reduce((Ct, rn) => Ct + rn, I), We = (bt - be) / (P.length - 1);
          let Qe = [0];
          for (let Ct = 1; Ct < ee.length; Ct++)
            Qe[Ct] = Qe[Ct - 1] + ee[Ct - 1] + We;
          const St = (Xn = Ve == null ? void 0 : Ve.current) == null ? void 0 : Xn.getBBox().height;
          o.xAxis.axisBBox = St;
          let Dt = !1;
          ee.forEach((Ct, rn) => {
            if (Qe[rn] + ee[rn] > Qe[rn + 1]) {
              Dt = !0;
              return;
            }
          }), o.xAxis.showYearsOnce && (Dt = !0);
          const Bt = ee[ee.length - 1], Kn = Qe[Qe.length - 1] + Bt + Bt / 2, Mn = bt - Bt;
          Kn > Mn && (Dt = !0);
          const fr = Dt && o.isResponsiveTicks ? B + cf + 20 : 0;
          return o.dynamicMarginTop = fr, o.xAxis.tickWidthMax = B, /* @__PURE__ */ n.createElement(at, { className: "bottom-axis", width: c[0] }, P.map((Ct, rn, xr) => {
            const Jr = String(Ct.value).startsWith("1") || Ct.value === 0.1 ? "block" : "none", Ga = Jr === "block" ? 16 : cf, ea = { x: Ct.to.x, y: Ga }, Xa = 100 / xr.length;
            o.yAxis.tickRotation = o.isResponsiveTicks && o.orientation === "horizontal" ? 0 : o.yAxis.tickRotation, o.xAxis.tickRotation = o.isResponsiveTicks && o.orientation === "vertical" ? 0 : o.xAxis.tickRotation;
            const Pr = o.isResponsiveTicks && Dt ? -Number(o.xAxis.maxTickRotation) || -90 : -Number(o.runtime.xAxis.tickRotation);
            return /* @__PURE__ */ n.createElement(at, { key: `vx-tick-${Ct.value}-${rn}`, className: "vx-axis-tick" }, !o.xAxis.hideTicks && /* @__PURE__ */ n.createElement(
              cn,
              {
                from: Ct.from,
                to: j === "horizontal" && rt ? ea : Ct.to,
                stroke: o.xAxis.tickColor,
                strokeWidth: Jr === "block" && rt ? 1.3 : 1
              }
            ), !o.xAxis.hideLabel && /* @__PURE__ */ n.createElement(
              vt,
              {
                innerRef: (ar) => He.current[rn] = ar,
                dy: o.orientation === "horizontal" && rt ? 8 : 0,
                display: o.orientation === "horizontal" && rt ? Jr : "block",
                x: Ct.to.x,
                y: Ct.to.y + uf,
                angle: Pr,
                verticalAnchor: Pr < -50 ? "middle" : "start",
                textAnchor: Pr ? "end" : "middle",
                width: Dt && !o.isResponsiveTicks && !Number(o[Sn].tickRotation) ? Xa : void 0,
                fill: o.xAxis.tickLabelColor
              },
              Ct.formattedValue
            ));
          }), !o.xAxis.hideAxis && /* @__PURE__ */ n.createElement(cn, { from: we.axisFromPoint, to: we.axisToPoint, stroke: "#333" }), /* @__PURE__ */ n.createElement(
            vt,
            {
              innerRef: Ge,
              className: "x-axis-title-label",
              x: bt / 2,
              y: pt ? 0 : M,
              textAnchor: "middle",
              verticalAnchor: "start",
              fontWeight: "bold",
              fill: o.xAxis.labelColor
            },
            we.label
          ));
        }
      )
    ),
    !T && Se && Object.entries(Se.data).length > 0 && Ke && Ne && Se.dataYPosition && Se.dataXPosition && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${o.tooltips.opacity / 100}) !important;`), /* @__PURE__ */ n.createElement("style", null, ".tooltip {max-width:300px} !important; word-wrap: break-word; "), /* @__PURE__ */ n.createElement(
      Xy,
      {
        key: Math.random(),
        className: "tooltip cdc-open-viz-module",
        left: ht,
        top: it
      },
      /* @__PURE__ */ n.createElement("ul", null, typeof Se == "object" && Object.entries(Se.data).map((we, g) => /* @__PURE__ */ n.createElement(tt, { item: we, key: g })))
    )),
    o.visualizationType === "Bump Chart" && /* @__PURE__ */ n.createElement(
      vc,
      {
        id: "bump-chart",
        variant: "light",
        arrowColor: "rgba(0,0,0,0)",
        className: "tooltip",
        style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
      }
    ),
    De() && !T && /* @__PURE__ */ n.createElement(
      vc,
      {
        id: `cdc-open-viz-tooltip-${$.uniqueId}`,
        variant: "light",
        arrowColor: "rgba(0,0,0,0)",
        className: "tooltip",
        style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
      }
    ),
    /* @__PURE__ */ n.createElement("div", { className: "animation-trigger", ref: et })
  ));
});
const Gk = (e) => {
  var $;
  const { width: t, height: r } = e, { transformedData: a, config: i, parseDate: o, formatDate: d, seriesHighlight: c, formatNumber: s, colorScale: p, handleChartAriaLabels: m } = ue.useContext(gt);
  let y = Number(t);
  const { minValue: x, maxValue: T } = Vc(i, a), S = { top: 5, right: 10, bottom: 10, left: 10 }, A = Number(r), E = y - i.runtime.yAxis.size, b = A - S.top - 20, v = (J) => i.runtime.xAxis.type === "date" ? o(J[i.runtime.originalXAxis.dataKey]).getTime() : J[i.runtime.originalXAxis.dataKey], N = (J, ne) => J[ne];
  let C, R;
  const { max: _, min: U } = i.runtime.yAxis, j = Number(_) >= Number(T), te = Number(U) <= Number(x);
  if (a) {
    let J = Number(U && te ? U : x), ne = Number(_ && j ? _ : Number.MIN_VALUE);
    if (ne === Number.MIN_VALUE && (ne = T), i.runtime.yAxis.paddingPercent) {
      let W = (ne - J) * i.runtime.yAxis.paddingPercent;
      J -= W, ne += W;
    }
    let z = a.map((W) => v(W));
    i.runtime.horizontal ? (C = jn({
      domain: [J, ne],
      range: [0, E]
    }), R = i.runtime.xAxis.type === "date" ? jn({ domain: [Math.min(...z), Math.max(...z)] }) : rl({ domain: z, padding: 0.5 }), rl({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, b]
    }), R.rangeRound([0, b])) : (J = J < 0 ? J * 1.11 : J, R = jn({
      domain: [J, ne],
      range: [b - S.bottom, S.top]
    }), C = rl({
      domain: z,
      range: [S.left, y - S.right]
    }), rl({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, E]
    }));
  }
  const Q = [C.domain()[0], C.domain()[C.domain().length - 1]];
  return /* @__PURE__ */ n.createElement($r, { component: "SparkLine" }, /* @__PURE__ */ n.createElement("svg", { role: "img", "aria-label": m(i), width: t, height: 100, className: "sparkline", tabIndex: 0 }, /* @__PURE__ */ n.createElement("title", null, `Spark line graphic with the title ${i.title ? i.title : "No Title Found"}`), (($ = i.runtime.lineSeriesKeys) == null ? void 0 : $.length) > 0 ? i.runtime.lineSeriesKeys : i.runtime.seriesKeys.map((J, ne) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    at,
    {
      style: { width: y },
      className: "sparkline-group",
      key: `series-${J}`,
      opacity: i.legend.behavior === "highlight" && c.length > 0 && c.indexOf(J) === -1 ? 0.5 : 1,
      display: i.legend.behavior === "highlight" || c.length === 0 || c.indexOf(J) !== -1 ? "block" : "none"
    },
    i.labels && a.map((z, W) => /* @__PURE__ */ n.createElement(at, { key: `series-${J}-point-${W}` }, /* @__PURE__ */ n.createElement(vt, { x: C(v(z)), y: R(N(z, J)), fill: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[J] : J) : "#000", textAnchor: "middle" }, s(z[J])))),
    /* @__PURE__ */ n.createElement(
      Br,
      {
        curve: Oc,
        data: a,
        x: (z) => C(v(z)),
        y: (z) => R(N(z, J)),
        stroke: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[J] : J) : "#000",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        markerEnd: `url(#arrow--${ne})`
      }
    ),
    /* @__PURE__ */ n.createElement(wm, { id: `arrow--${ne}`, refX: 2, size: 6, markerEnd: `url(#arrow--${ne})`, strokeOpacity: 1, fillOpacity: 1, fill: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[J] : J) : "#000" })
  ), /* @__PURE__ */ n.createElement(
    Gu,
    {
      top: b + S.top,
      hideAxisLine: !0,
      hideTicks: !0,
      scale: C,
      tickValues: Q,
      tickFormat: (z) => i.xAxis.type === "date" ? d(z) : null,
      stroke: "black",
      tickStroke: "black",
      tickLabelProps: () => ({
        fill: "black",
        fontSize: 11,
        textAnchor: "middle"
      })
    }
  )))));
};
var Xk = ["flexDirection", "alignItems", "margin", "display", "children"];
function Kf() {
  return Kf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Kf.apply(this, arguments);
}
function qk(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Ac(e) {
  var t = e.flexDirection, r = t === void 0 ? "row" : t, a = e.alignItems, i = a === void 0 ? "center" : a, o = e.margin, d = o === void 0 ? "0" : o, c = e.display, s = c === void 0 ? "flex" : c, p = e.children, m = qk(e, Xk);
  return /* @__PURE__ */ n.createElement("div", Kf({
    className: "visx-legend-item",
    style: {
      display: s,
      alignItems: i,
      flexDirection: r,
      margin: d
    }
  }, m), p);
}
Ac.propTypes = {
  alignItems: $e.string,
  margin: $e.oneOfType([$e.string, $e.number]),
  children: $e.node,
  display: $e.string
};
var Zk = ["flex", "label", "margin", "align", "children"];
function Yf() {
  return Yf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Yf.apply(this, arguments);
}
function Qk(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Lc(e) {
  var t = e.flex, r = t === void 0 ? "1" : t, a = e.label, i = e.margin, o = i === void 0 ? "5px 0" : i, d = e.align, c = d === void 0 ? "left" : d, s = e.children, p = Qk(e, Zk);
  return /* @__PURE__ */ n.createElement("div", Yf({
    className: "visx-legend-label",
    style: {
      justifyContent: c,
      display: "flex",
      flex: r,
      margin: o
    }
  }, p), s || a);
}
Lc.propTypes = {
  align: $e.string,
  label: $e.node,
  flex: $e.oneOfType([$e.string, $e.number]),
  margin: $e.oneOfType([$e.string, $e.number]),
  children: $e.node
};
function Gf() {
  return Gf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Gf.apply(this, arguments);
}
function kp(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style;
  return /* @__PURE__ */ n.createElement("div", {
    style: Gf({
      width: r,
      height: a,
      background: t
    }, i)
  });
}
kp.propTypes = {
  fill: $e.string,
  width: $e.oneOfType([$e.string, $e.number]),
  height: $e.oneOfType([$e.string, $e.number])
};
function hg(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style, o = typeof r == "string" || typeof r > "u" ? 0 : r, d = typeof a == "string" || typeof a > "u" ? 0 : a, c = Math.max(o, d), s = c / 2;
  return /* @__PURE__ */ n.createElement("svg", {
    width: c,
    height: c
  }, /* @__PURE__ */ n.createElement(at, {
    top: s,
    left: s
  }, /* @__PURE__ */ n.createElement("circle", {
    r: s,
    fill: t,
    style: i
  })));
}
hg.propTypes = {
  fill: $e.string,
  width: $e.oneOfType([$e.string, $e.number]),
  height: $e.oneOfType([$e.string, $e.number])
};
function mg(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style, o = typeof a == "string" || typeof a > "u" ? 0 : a, d = typeof (i == null ? void 0 : i.strokeWidth) == "number" ? i == null ? void 0 : i.strokeWidth : 2;
  return /* @__PURE__ */ n.createElement("svg", {
    width: r,
    height: a
  }, /* @__PURE__ */ n.createElement(at, {
    top: o / 2 - d / 2
  }, /* @__PURE__ */ n.createElement("line", {
    x1: 0,
    x2: r,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: d,
    style: i
  })));
}
mg.propTypes = {
  fill: $e.string,
  width: $e.oneOfType([$e.string, $e.number]),
  height: $e.oneOfType([$e.string, $e.number])
};
function ks() {
  return ks = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, ks.apply(this, arguments);
}
var ff = function() {
};
function Jk(e) {
  var t = e.shape, r = t === void 0 ? "rect" : t, a = e.fill, i = a === void 0 ? ff : a, o = e.size, d = o === void 0 ? ff : o, c = e.width, s = e.height, p = e.label, m = e.item, y = e.itemIndex, x = e.shapeStyle, T = x === void 0 ? ff : x, S = {
    width: c,
    height: s,
    item: m,
    itemIndex: y,
    label: p,
    fill: i(ks({}, p)),
    size: d(ks({}, p)),
    style: T(ks({}, p))
  };
  return typeof r == "string" ? r === "circle" ? /* @__PURE__ */ n.createElement(hg, S) : r === "line" ? /* @__PURE__ */ n.createElement(mg, S) : /* @__PURE__ */ n.createElement(kp, S) : /* @__PURE__ */ n.isValidElement(r) ? /* @__PURE__ */ n.cloneElement(r, S) : r ? /* @__PURE__ */ n.createElement(r, S) : null;
}
function Pc() {
  return Pc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Pc.apply(this, arguments);
}
function yg(e) {
  var t = e.shape, r = t === void 0 ? kp : t, a = e.width, i = e.height, o = e.margin, d = e.label, c = e.item, s = e.itemIndex, p = e.fill, m = e.size, y = e.shapeStyle;
  return /* @__PURE__ */ n.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: m ? m(Pc({}, d)) : a,
      height: m ? m(Pc({}, d)) : i,
      margin: o
    }
  }, Jk({
    shape: r,
    item: c,
    itemIndex: s,
    label: d,
    width: a,
    height: i,
    fill: p,
    shapeStyle: y
  }));
}
yg.propTypes = {
  itemIndex: $e.number.isRequired,
  margin: $e.oneOfType([$e.string, $e.number]),
  width: $e.oneOfType([$e.string, $e.number]),
  height: $e.oneOfType([$e.string, $e.number])
};
function gg(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function mm(e) {
  return String(gg(e));
}
function ew(e) {
  var t = e.scale, r = e.labelFormat;
  return function(a, i) {
    return {
      datum: a,
      index: i,
      text: "" + r(a, i),
      value: t(a)
    };
  };
}
var tw = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function ws() {
  return ws = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, ws.apply(this, arguments);
}
function nw(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var rw = {
  display: "flex"
};
function vg(e) {
  var t = e.className, r = e.style, a = r === void 0 ? rw : r, i = e.scale, o = e.shape, d = e.domain, c = e.fill, s = c === void 0 ? mm : c, p = e.size, m = p === void 0 ? mm : p, y = e.labelFormat, x = y === void 0 ? gg : y, T = e.labelTransform, S = T === void 0 ? ew : T, A = e.shapeWidth, E = A === void 0 ? 15 : A, b = e.shapeHeight, v = b === void 0 ? 15 : b, N = e.shapeMargin, C = N === void 0 ? "2px 4px 2px 0" : N, R = e.shapeStyle, _ = e.labelAlign, U = _ === void 0 ? "left" : _, j = e.labelFlex, te = j === void 0 ? "1" : j, Q = e.labelMargin, $ = Q === void 0 ? "0 4px" : Q, J = e.itemMargin, ne = J === void 0 ? "0" : J, z = e.direction, W = z === void 0 ? "column" : z, ie = e.itemDirection, ae = ie === void 0 ? "row" : ie, oe = e.legendLabelProps, K = e.children, Y = nw(e, tw), X = d || ("domain" in i ? i.domain() : []), q = S({
    scale: i,
    labelFormat: x
  }), ce = X.map(q);
  return K ? /* @__PURE__ */ n.createElement(n.Fragment, null, K(ce)) : /* @__PURE__ */ n.createElement("div", {
    className: Dn("visx-legend", t),
    style: ws({}, a, {
      flexDirection: W
    })
  }, ce.map(function(ge, De) {
    return /* @__PURE__ */ n.createElement(Ac, ws({
      key: "legend-" + ge.text + "-" + De,
      margin: ne,
      flexDirection: ae
    }, Y), /* @__PURE__ */ n.createElement(yg, {
      shape: o,
      height: v,
      width: E,
      margin: C,
      item: X[De],
      itemIndex: De,
      label: ge,
      fill: s,
      size: m,
      shapeStyle: R
    }), /* @__PURE__ */ n.createElement(Lc, ws({
      label: ge.text,
      flex: te,
      margin: $,
      align: U
    }, oe)));
  }));
}
vg.propTypes = {
  children: $e.func,
  className: $e.string,
  domain: $e.array,
  shapeWidth: $e.oneOfType([$e.string, $e.number]),
  shapeHeight: $e.oneOfType([$e.string, $e.number]),
  shapeMargin: $e.oneOfType([$e.string, $e.number]),
  labelAlign: $e.string,
  labelFlex: $e.oneOfType([$e.string, $e.number]),
  labelMargin: $e.oneOfType([$e.string, $e.number]),
  itemMargin: $e.oneOfType([$e.string, $e.number]),
  fill: $e.func,
  size: $e.func,
  shapeStyle: $e.func
};
function aw(e) {
  return /* @__PURE__ */ n.createElement(vg, e);
}
const iw = (e) => {
  const { position: t, singleRow: r, reverseLabelOrder: a, verticalSorted: i, hideBorder: o } = e.legend, d = ["legend-container"], c = ["legend-container__inner"];
  switch (t) {
    case "left":
      d.push("left");
      break;
    case "right":
      d.push("right");
      break;
    case "bottom":
      d.push("bottom"), c.push("double-column", "bottom");
      break;
    case "top":
      d.push("top"), c.push("double-column", "top");
      break;
  }
  return ["bottom", "top"].includes(t) && r && c.push("single-row"), a && c.push("d-flex", "flex-column-reverse"), ["bottom", "top"].includes(t) && i && c.push("vertical-sorted"), o.side && (["right", "left"].includes(t) || !t) && d.push("border-0"), o.topBottom && ["top", "bottom"].includes(t) && d.push("border-0"), o.topBottom && ["top"].includes(t) && d.push("p-0"), {
    containerClasses: d,
    innerClasses: c
  };
}, xg = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, ow = (e, t, r) => {
  const i = t([{ datum: "", index: 0, text: "", value: "" }]), o = e.legend.colorCode ? i.map((c) => c == null ? void 0 : c.value) : (r == null ? void 0 : r.range()) ?? [], d = e.legend.colorCode ? i.map((c) => (c == null ? void 0 : c.text) || (c == null ? void 0 : c.datum)) : (r == null ? void 0 : r.domain()) ?? [];
  return { colors: o, labels: d };
}, lw = (e, t) => {
  var r;
  return e ? e && ((r = t.brush) != null && r.active) ? `${t.brush.height * 1.5}px` : "20px" : "0px";
}, sw = (e, t) => {
  var i;
  const r = ((i = e.legend) == null ? void 0 : i.position) === "top" && !e.legend.hide;
  let a = 0;
  return r && (a = e.legend.hideBorder.topBottom ? 15 : 25), t && (a += 40), `${a}px`;
}, uw = ({ config: e, isBottomOrSmallViewport: t, setHasSuppression: r }) => {
  const { preliminaryData: a, visualizationType: i, visualizationSubType: o, legend: d } = e, c = () => (a == null ? void 0 : a.some((S) => S.label && S.type === "effect" && S.style !== "Filled Circles")) && ["Line", "Combo"].includes(i), s = () => !d.hideSuppressedLabels && (a == null ? void 0 : a.some(
    (S) => S.label && S.displayLegend && S.type === "suppression" && S.value && ((S == null ? void 0 : S.style) || S.symbol)
  )) && (i === "Bar" && o === "regular" || i === "Line" || i === "Combo"), p = () => a == null ? void 0 : a.map(
    (S, A) => S.label && S.type === "effect" && S.style && /* @__PURE__ */ n.createElement("div", { key: A, className: "legend-preliminary" }, /* @__PURE__ */ n.createElement("span", { className: S.symbol }, S.lineCode), /* @__PURE__ */ n.createElement("p", null, S.label))
  ), m = (S) => {
    S.preventDefault();
  }, y = () => {
    const S = (A) => A ? {
      color: "#777772"
    } : null;
    return a == null ? void 0 : a.map((A, E) => {
      if (!A.displayLegend || A.type !== "suppression")
        return null;
      const b = "legend-preliminary", v = E + i;
      return i === "Bar" ? /* @__PURE__ */ n.createElement("div", { style: S(A.displayGray), key: v, className: `${b} ${A.symbol}` }, /* @__PURE__ */ n.createElement("span", { className: A.symbol }, A.iconCode), /* @__PURE__ */ n.createElement("p", { className: A.type }, A.label)) : i === "Line" ? /* @__PURE__ */ n.createElement("div", { style: S(A.displayGray), key: v, className: b }, /* @__PURE__ */ n.createElement("span", null, A.lineCode), /* @__PURE__ */ n.createElement("p", { className: A.type }, A.label)) : i === "Combo" ? /* @__PURE__ */ n.createElement(n.Fragment, null, A.symbol && A.iconCode && /* @__PURE__ */ n.createElement("div", { style: S(A.displayGray), key: v, className: `${b} ${A.symbol}` }, /* @__PURE__ */ n.createElement("span", { className: A.symbol }, A.iconCode), /* @__PURE__ */ n.createElement("p", { className: A.type }, A.label)), A.style && A.lineCode && /* @__PURE__ */ n.createElement("div", { style: S(A.displayGray), key: v, className: b }, /* @__PURE__ */ n.createElement("span", null, A.lineCode), /* @__PURE__ */ n.createElement("p", null, A.label))) : null;
    });
  }, x = () => d.singleRow && t ? "legend-container__inner bottom single-row" : "", T = () => !e.legend.hideSuppressionLink && e.visualizationSubType !== "stacked" && (a == null ? void 0 : a.some((S) => S.label && S.type === "suppression" && S.value && ((S == null ? void 0 : S.style) || S.symbol)));
  return r(T()), /* @__PURE__ */ n.createElement(n.Fragment, null, c() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("div", { className: x() }, p())), s() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("div", { className: x() }, y())), T() && /* @__PURE__ */ n.createElement("div", { className: "legend-container__outer definition-link" }, /* @__PURE__ */ n.createElement(Xe, { alt: "info-icon", display: "info" }), /* @__PURE__ */ n.createElement("p", null, "This chart contains", /* @__PURE__ */ n.createElement(
    "a",
    {
      onClick: m,
      "data-tooltip-content": "Data is suppressed to maintain statistical reliability. This occurs when the number of respondents or reported values does not meet the minimum reporting threshold.",
      "data-tooltip-id": "my-tooltip",
      href: "no-router-link"
    },
    "suppressed data"
  ))), /* @__PURE__ */ n.createElement(
    vc,
    {
      id: "my-tooltip",
      variant: "light",
      style: { background: `rgba(255,255,255, ${e.tooltips.opacity / 100})`, color: "black", maxWidth: "100%" }
    }
  ));
}, cw = 30, dw = ue.forwardRef(
  ({
    config: e,
    colorScale: t,
    seriesHighlight: r,
    highlight: a,
    highlightReset: i,
    currentViewport: o,
    formatLabels: d,
    skipId: c = "legend",
    dimensions: s
  }, p) => {
    const { innerClasses: m, containerClasses: y } = iw(e), { runtime: x, legend: T } = e, [S, A] = ue.useState(!1), E = (T == null ? void 0 : T.position) === "bottom" || ya(o) && !T.hide, b = {
      marginBottom: sw(e, S),
      marginTop: lw(E, e)
    }, { HighLightedBarUtils: v } = Ic(e);
    let N = v.findDuplicates(e.highlightedBarValues);
    return T ? /* @__PURE__ */ n.createElement(
      "aside",
      {
        ref: p,
        style: b,
        id: c || "legend",
        className: y.join(" "),
        role: "region",
        "aria-label": "legend",
        tabIndex: 0
      },
      T.label && /* @__PURE__ */ n.createElement("h3", null, Mi(T.label)),
      T.description && /* @__PURE__ */ n.createElement("p", null, Mi(T.description)),
      /* @__PURE__ */ n.createElement(
        zg,
        {
          config: e,
          ...ow(e, d, t),
          dimensions: s,
          parentPaddingToSubtract: T.hideBorder ? 0 : cw
        }
      ),
      /* @__PURE__ */ n.createElement(aw, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0" }, (C) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: m.join(" ") }, d(C).map((R, _) => {
        var te, Q, $, J;
        let U = ["legend-item", `legend-text--${R.text.replace(" ", "").toLowerCase()}`], j = R.datum;
        if (e.exclusions.active && ((te = e.exclusions.keys) != null && te.includes(j)))
          return null;
        if (x.seriesLabels) {
          let ne = e.runtime.seriesLabelsAll.indexOf(j);
          j = e.runtime.seriesKeys[ne], ((Q = x == null ? void 0 : x.forecastingSeriesKeys) == null ? void 0 : Q.length) > 0 && (j = R.text);
        }
        return r.length > 0 && r.includes(j) === !1 && U.push("inactive"), e.legend.style === "gradient" ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(
          Ac,
          {
            className: U.join(" "),
            tabIndex: 0,
            key: `legend-quantile-${_}`,
            onKeyDown: (ne) => {
              ne.key === "Enter" && (ne.preventDefault(), a(R));
            },
            onClick: (ne) => {
              ne.preventDefault(), a(R);
            },
            role: "button"
          },
          /* @__PURE__ */ n.createElement(n.Fragment, null, e.visualizationType === "Line" && e.legend.style === "lines" ? /* @__PURE__ */ n.createElement("svg", { width: 40, height: 25 }, /* @__PURE__ */ n.createElement(
            cn,
            {
              from: { x: 10, y: 10 },
              to: { x: 40, y: 10 },
              stroke: R.value,
              strokeWidth: 2,
              strokeDasharray: xg(($ = e.series[_]) != null && $.type ? (J = e.series[_]) == null ? void 0 : J.type : "")
            }
          )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
            $p,
            {
              shape: e.legend.style === "boxes" ? "square" : "circle",
              fill: R.value
            }
          ))),
          /* @__PURE__ */ n.createElement(Lc, { align: "left", margin: "0 0 0 4px" }, R.text)
        );
      }), N.map((R, _) => {
        let U = "legend-item", j = R.legendLabel;
        return j ? (r.length > 0 && r.includes(j) === !1 && (U += " inactive"), /* @__PURE__ */ n.createElement(
          Ac,
          {
            className: U,
            tabIndex: 0,
            key: `legend-quantile-${_}`,
            onKeyDown: (te) => {
              te.key === "Enter" && (te.preventDefault(), a(R.legendLabel));
            },
            onClick: (te) => {
              te.preventDefault(), a(R.legendLabel);
            }
          },
          /* @__PURE__ */ n.createElement(
            $p,
            {
              shape: e.legend.style === "boxes" ? "square" : "circle",
              style: { borderRadius: "0px" },
              fill: "transparent",
              borderColor: R.color ? R.color : "rgba(255, 102, 1)"
            }
          ),
          " ",
          /* @__PURE__ */ n.createElement(Lc, { align: "left", margin: "0 0 0 4px" }, R.legendLabel ? R.legendLabel : R.value)
        )) : !1;
      })), /* @__PURE__ */ n.createElement(
        uw,
        {
          config: e,
          isBottomOrSmallViewport: E,
          setHasSuppression: A
        }
      ))),
      r.length > 0 && /* @__PURE__ */ n.createElement(Rc, { onClick: (C) => i(C), style: { marginTop: "1rem" } }, "Reset")
    ) : null;
  }
);
function fw(e) {
  return Bg({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" } }] })(e);
}
const pw = (e, t, r, a) => (i) => {
  var x, T, S, A, E;
  const { visualizationType: o, visualizationSubType: d, series: c, runtime: s } = e, p = (b) => {
    var v;
    return e.legend.reverseLabelOrder && ((v = e.legend) == null ? void 0 : v.position) === "bottom" ? b.reverse() : b;
  }, m = (x = e.legend) == null ? void 0 : x.colorCode;
  if (o === "Deviation Bar") {
    const [b, v] = Cs[e.twoColor.palette], N = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: b
    }, C = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: v
    };
    return p([N, C]);
  }
  if (o === "Bar" && d === "regular" && m && (c == null ? void 0 : c.length) === 1) {
    let b = vr[e.palette];
    for (; t.length > b.length; )
      b = b.concat(b);
    b = b.slice(0, r.length);
    const v = /* @__PURE__ */ new Set();
    t.forEach((C) => v.add(C[m]));
    const N = Array.from(v).map((C, R) => ({
      datum: C,
      index: R,
      text: C,
      value: b[R]
    }));
    return p(N);
  }
  if (((T = s == null ? void 0 : s.forecastingSeriesKeys) == null ? void 0 : T.length) > 0) {
    let b = [];
    return (A = (S = e.runtime) == null ? void 0 : S.forecastingSeriesKeys) == null || A.map((v, N) => {
      var C;
      return (C = v == null ? void 0 : v.stages) == null ? void 0 : C.map((R, _) => {
        var te, Q, $, J;
        let U = (te = Zu[R.color]) != null && te[2] ? (Q = Zu[R.color]) == null ? void 0 : Q[2] : ($ = vr[R.color]) != null && $[2] ? (J = vr[R.color]) == null ? void 0 : J[2] : "#ccc";
        const j = {
          datum: R.key,
          index: _,
          text: R.key,
          value: U
        };
        b.push(j);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((v, N) => {
      let C = vr[e.palette][N] ? vr[e.palette][N] : "#ccc";
      const R = {
        datum: v,
        index: N,
        text: v,
        value: C
      };
      b.push(R);
    }), p(b);
  }
  if (e.series.filter((b) => !!b.name).length > 0) {
    const b = /* @__PURE__ */ new Set();
    e.series.forEach((N) => {
      b.add(N.name || N.dataKey);
    });
    const v = Array.from(b).map((N, C) => ({
      datum: N,
      index: C,
      text: N,
      value: a(N)
    }));
    return p(v);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const b = i.length - 1;
    let v = [];
    return (E = e.suppressedData) == null || E.forEach(({ label: N, icon: C }, R) => {
      if (N && C) {
        const _ = {
          datum: N,
          index: b + R,
          text: N,
          icon: /* @__PURE__ */ n.createElement(fw, { color: "#000", size: 15 })
        };
        v.push(_);
      }
    }), [...i, ...v];
  }
  return p(i);
}, hw = ue.forwardRef((e, t) => {
  const {
    // prettier-ignore
    config: r,
    colorScale: a,
    seriesHighlight: i,
    highlight: o,
    tableData: d,
    highlightReset: c,
    transformedData: s,
    currentViewport: p,
    dimensions: m,
    getTextWidth: y
  } = ue.useContext(gt);
  if (!r.legend)
    return null;
  const x = pw(r, d, s, a);
  return /* @__PURE__ */ n.createElement(ue.Fragment, null, /* @__PURE__ */ n.createElement(
    dw,
    {
      getTextWidth: y,
      dimensions: m,
      ref: t,
      skipId: e.skipId || "legend",
      config: r,
      colorScale: a,
      seriesHighlight: i,
      highlight: o,
      highlightReset: c,
      currentViewport: p,
      formatLabels: x
    }
  ));
}), pf = {
  annotations: [],
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  fontSize: "medium",
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "false",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    annotationDropdownText: "Annotations",
    showDownloadButton: !1,
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0,
    showZeroValueData: !0,
    hideNullValue: !0
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !1,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: [],
    shoMissingDataLabel: !0,
    showMissingDataLine: !0,
    categories: []
  },
  boxplot: {
    plots: [],
    borders: "true",
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      count: "Count",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 0,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0,
    padding: 5,
    showYearsOnce: !1,
    sortByRecentDate: !1
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    showDownloadLinkBelow: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: "",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    label: "",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    hideSuppressionLink: !1,
    seriesHighlight: [],
    style: "circles",
    subStyle: "linear blocks",
    tickRotation: "",
    hideBorder: {
      side: !1,
      topBottom: !0
    },
    position: "right"
  },
  brush: {
    height: 45,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, bg = ({ fieldName: e, fieldKey: t, fieldType: r, controls: a, deleteField: i, children: o }) => {
  const [d, c] = a, s = d[t], p = (m, y) => {
    c({ ...d, [m]: y });
  };
  return s ? /* @__PURE__ */ n.createElement("fieldset", { className: "edit-block mb-1", key: t }, /* @__PURE__ */ n.createElement("div", { className: "d-flex justify-content-between" }, /* @__PURE__ */ n.createElement("button", { className: "btn btn-light", onClick: () => p(t, !1) }, /* @__PURE__ */ n.createElement(Xe, { display: "caretUp" })), /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "btn btn-danger btn-sm",
      onClick: (m) => {
        m.preventDefault(), i();
      }
    },
    "Remove"
  )), o) : /* @__PURE__ */ n.createElement("div", { className: "mb-1" }, /* @__PURE__ */ n.createElement("button", { className: "btn btn-light", onClick: () => p(t, !0) }, /* @__PURE__ */ n.createElement(Xe, { display: "caretDown" })), /* @__PURE__ */ n.createElement("span", null, " ", e ? `${e}` : "New " + r));
}, mw = ({
  config: e,
  deleteColumn: t,
  updateField: r,
  colKey: a,
  controls: i
}) => {
  var y, x, T, S;
  const [o, d] = i, c = (A, E) => {
    if (A === "dataTable" && E === !0) {
      const b = lt.cloneDeep(e.columns);
      b[a] = { ...b[a], dataTable: E }, r(null, null, "columns", b);
    } else
      r("columns", a, A, E);
  }, s = (A) => {
    const E = lt.cloneDeep(e.columns), v = { ...e.columns[a], name: A, label: A };
    if (v.dataTable === void 0 && (v.dataTable = !0), A !== a) {
      E[A] = v, delete E[a];
      const N = { ...lt.cloneDeep(o), [A]: !0 };
      delete N[a], d(N);
    }
    r(null, null, "columns", E);
  }, p = () => {
    var v;
    const A = e.data.flatMap((N) => Object.keys(N).map((C) => C)), E = Object.values(e.columns).map((N) => N.name), b = lt.uniq(A).filter((N) => !(e.table.groupBy === N || E.includes(N)));
    return (v = e.columns[a]) != null && v.name && b.push(e.columns[a].name), b;
  }, m = (y = e.columns[a]) == null ? void 0 : y.name;
  return /* @__PURE__ */ n.createElement(
    bg,
    {
      fieldName: m,
      fieldKey: a,
      fieldType: "Column",
      controls: i,
      deleteField: () => t(a)
    },
    /* @__PURE__ */ n.createElement(
      yt,
      {
        label: "Column",
        value: (x = e.columns[a]) == null ? void 0 : x.name,
        fieldName: "name",
        section: "columns",
        initial: "-Select-",
        options: p(),
        updateField: (A, E, b, v) => s(v)
      }
    ),
    e.type !== "table" && /* @__PURE__ */ n.createElement(
      yt,
      {
        label: "Associate to Series",
        value: (T = e.columns[a]) == null ? void 0 : T.series,
        fieldName: "series",
        section: "columns",
        initial: "Select series",
        options: ((S = e.series) == null ? void 0 : S.map((A) => A.dataKey)) || [],
        updateField: (A, E, b, v) => c("series", v)
      }
    ),
    /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.columns[a].label,
        section: "columns",
        subsection: a,
        fieldName: "label",
        label: "Label",
        updateField: r
      }
    ),
    /* @__PURE__ */ n.createElement("ul", { className: "column-edit" }, /* @__PURE__ */ n.createElement("li", { className: "three-col" }, /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.columns[a].prefix,
        section: "columns",
        subsection: a,
        fieldName: "prefix",
        label: "Prefix",
        updateField: r
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.columns[a].suffix,
        section: "columns",
        subsection: a,
        fieldName: "suffix",
        label: "Suffix",
        updateField: r
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        type: "number",
        value: e.columns[a].roundToPlace,
        section: "columns",
        subsection: a,
        fieldName: "roundToPlace",
        label: "Round",
        updateField: r
      }
    )), /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].commas,
        onChange: (A) => {
          c("commas", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Add Commas to Numbers"))), /* @__PURE__ */ n.createElement("li", null, e.table.showVertical && /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].dataTable ?? !0,
        onChange: (A) => {
          c("dataTable", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Data Table"))), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].showInViz,
        onChange: (A) => {
          c("showInViz", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Visualization"))), e.type !== "table" && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].tooltips || !1,
        onChange: (A) => {
          r("columns", a, "tooltips", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in tooltip"))), e.visualizationType === "Forest Plot" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].forestPlot || !1,
        onChange: (A) => {
          c("forestPlot", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Forest Plot"))), /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].forestPlotAlignRight || !1,
        onChange: (A) => {
          c("forestPlotAlignRight", A.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Align Right"))), !e.columns[a].forestPlotAlignRight && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "text" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Forest Plot Starting Point"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "number",
        value: e.columns[a].forestPlotStartingPoint || 0,
        onChange: (A) => {
          c("forestPlotStartingPoint", A.target.value);
        }
      }
    ))))),
    /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Order"), /* @__PURE__ */ n.createElement(
      "input",
      {
        onWheel: (A) => A.currentTarget.blur(),
        type: "number",
        min: "1",
        value: e.columns[a].order,
        onChange: (A) => r("columns", a, "order", parseInt(A.target.value))
      }
    ))
  );
}, yw = ({ config: e, updateField: t, deleteColumn: r }) => {
  var d;
  const a = ue.useState({}), i = Object.keys(e.columns), o = (c) => {
    const s = `additionalColumn${c}`, p = {
      label: "New Column",
      dataTable: !0,
      tooltips: !1,
      prefix: "",
      suffix: "",
      forestPlot: !1,
      startingPoint: "0",
      forestPlotAlignRight: !1,
      roundToPlace: 0,
      commas: !1,
      showInViz: !1,
      forestPlotStartingPoint: 0
    }, [m, y] = a;
    y({ ...m, [s]: !0 }), t("columns", null, s, p);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.type !== "navigation" && /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Configurations", /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can specify additional columns to display in tooltips and / or the supporting data table."))))), i.map((c, s) => /* @__PURE__ */ n.createElement(
    mw,
    {
      key: c + s,
      controls: a,
      config: e,
      deleteColumn: r,
      updateField: t,
      colKey: c
    }
  )), /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "btn btn-primary",
      onClick: (c) => {
        c.preventDefault(), o(i.length + 1);
      }
    },
    "Add Configuration"
  )), ((d = e.legend) == null ? void 0 : d.type) === "category" && /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Additional Category", /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can provide additional categories to ensure they appear in the legend"))))), e.legend.additionalCategories && e.legend.additionalCategories.map((c, s) => /* @__PURE__ */ n.createElement("fieldset", { className: "edit-block", key: c }, /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "remove-column",
      onClick: (p) => {
        p.preventDefault();
        const m = [...e.legend.additionalCategories];
        m.splice(s, 1), t("legend", null, "additionalCategories", m);
      }
    },
    "Remove"
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      value: c,
      label: "Category",
      section: "legend",
      subsection: null,
      fieldName: "additionalCategories",
      updateField: (p, m, y, x) => {
        const T = [...e.legend.additionalCategories];
        T[s] = x, t(p, m, y, T);
      }
    }
  ))), /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "btn btn-primary full-width",
      onClick: (c) => {
        c.preventDefault();
        const s = [...e.legend.additionalCategories || []];
        s.push(""), t("legend", null, "additionalCategories", s);
      }
    },
    "Add Category"
  )));
}, ym = "-Select-", gw = ({ config: e, updateField: t, isDashboard: r, columns: a }) => {
  var p, m, y, x, T, S, A;
  const i = ((p = e.dataKey) == null ? void 0 : p.includes("http://")) || ((m = e == null ? void 0 : e.dataKey) == null ? void 0 : m.includes("https://")), o = ue.useMemo(() => Object.keys(e.columns).map((E) => [E, e.columns[E].dataTable]).filter(([E, b]) => !b).map(([E]) => E), [e.columns]), d = ue.useMemo(() => {
    const E = e.data.flatMap(Object.keys);
    return lt.uniq(E).filter((v) => !0);
  }, [e.data]), c = (E) => {
    E === ym && (E = void 0), t("table", null, "groupBy", E);
  }, s = (E, b, v, N) => {
    const C = lt.cloneDeep(e.columns), R = [];
    for (let _ in C) {
      const U = C[_];
      R.push(U.name), N.includes(U.name) ? C[_].dataTable = !1 : C[_].dataTable = !0;
    }
    N.forEach((_) => {
      R.includes(_) || (C[_] = { name: _, dataTable: !1 });
    }), t(null, null, "columns", C);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    je,
    {
      value: e.table.label,
      updateField: t,
      section: "table",
      fieldName: "label",
      id: "tableLabel",
      label: "Data Table Title",
      placeholder: "Data Table",
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Label is required for Data Table for 508 Compliance")))
    }
  ), e.type !== "table" ? /* @__PURE__ */ n.createElement(
    Je,
    {
      value: e.table.show,
      fieldName: "show",
      label: "Show Data Table",
      section: "table",
      updateField: t,
      className: "column-heading",
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
        Xe,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Hiding the data table may affect accessibility. An alternate form of accessing visualization data is a 508 requirement.")))
    }
  ) : /* @__PURE__ */ n.createElement(
    Je,
    {
      value: (y = e.general) == null ? void 0 : y.showDownloadButton,
      fieldName: "showDownloadButton",
      label: "Show Download CSV link",
      section: "general",
      updateField: t,
      className: "column-heading"
    }
  ), e.visualizationType !== "Box Plot" && e.type !== "table" && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: e.table.showVertical,
      fieldName: "showVertical",
      label: "Show Vertical Data",
      section: "table",
      updateField: t,
      className: "column-heading",
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
        Xe,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "This will draw the data table with vertical data instead of horizontal.")))
    }
  ), e.type !== "table" && /* @__PURE__ */ n.createElement(
    je,
    {
      value: e.table.indexLabel,
      section: "table",
      fieldName: "indexLabel",
      label: "Index Column Header",
      updateField: t,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "To comply with 508 standards, if the first column in the data table has no header, enter a brief one here.")))
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      value: e.table.caption,
      updateField: t,
      section: "table",
      type: "textarea",
      fieldName: "caption",
      label: "Screen Reader Description",
      placeholder: " Data table",
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter a description of the data table to be read by screen readers.")))
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      value: e.table.limitHeight,
      section: "table",
      fieldName: "limitHeight",
      label: " Limit Table Height",
      updateField: t
    }
  ), e.table.limitHeight && /* @__PURE__ */ n.createElement(
    je,
    {
      value: e.table.height,
      section: "table",
      fieldName: "height",
      label: "Data Table Height",
      type: "number",
      min: 0,
      max: 500,
      placeholder: "Height(px)",
      updateField: t
    }
  ), (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement(
    yf,
    {
      key: o.join("") + "excluded",
      options: a.map((E) => ({ label: E, value: E })),
      selected: o,
      fieldName: "dataTable",
      label: "Exclude Columns",
      section: "columns",
      updateField: s
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      value: e.table.collapsible,
      fieldName: "collapsible",
      label: " Collapsible",
      section: "table",
      updateField: t
    }
  ), e.table.collapsible !== !1 && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: e.table.expanded,
      fieldName: "expanded",
      label: " Expanded by Default",
      section: "table",
      updateField: t
    }
  ), r && e.type !== "table" && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: e.table.showDataTableLink,
      fieldName: "showDataTableLink",
      label: "Show Data Table Name & Link",
      section: "table",
      updateField: t
    }
  ), i && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: e.table.showDownloadUrl,
      fieldName: "showDownloadUrl",
      label: "Show URL to Automatically Updated Data",
      section: "table",
      updateField: t
    }
  ), e.type !== "table" && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: e.table.showDownloadImgButton,
      fieldName: "showDownloadImgButton",
      label: "Display Image Button",
      section: "table",
      updateField: t
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      value: e.table.showDownloadLinkBelow,
      fieldName: "showDownloadLinkBelow",
      label: "Show Download Link Below Table",
      section: "table",
      updateField: t
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Table Cell Min Width"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      value: e.table.cellMinWidth ? e.table.cellMinWidth : 0,
      onChange: (E) => t("table", null, "cellMinWidth", E.target.value)
    }
  )), (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement(
    yt,
    {
      value: e.table.groupBy,
      fieldName: "groupBy",
      section: "table",
      label: "Group By",
      updateField: (E, b, v, N) => c(N),
      initial: ym,
      options: d.filter(
        (E) => {
          var b, v;
          return E !== ((b = e.table.pivot) == null ? void 0 : b.columnName) && !(((v = e.table.pivot) == null ? void 0 : v.valueColumns) || []).includes(E);
        }
      ),
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Choose a column to use for grouping data rows. The selected column will not be shown in the data table. You will only be able to choose a column which does not have a column configuration.")))
    }
  ), /* @__PURE__ */ n.createElement(
    yt,
    {
      label: "Pivot Column",
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select a Column whos data values will be pivoted to Column Values."))),
      value: (x = e.table.pivot) == null ? void 0 : x.columnName,
      options: d.filter(
        (E) => {
          var b;
          return E !== e.table.groupBy && !(((b = e.table.pivot) == null ? void 0 : b.valueColumns) || []).includes(E);
        }
      ),
      initial: "-Select-",
      section: "table",
      subsection: "pivot",
      fieldName: "columnName",
      updateField: t
    }
  ), ((T = e.table.pivot) == null ? void 0 : T.columnName) && /* @__PURE__ */ n.createElement(
    yf,
    {
      key: (S = e.table.pivot) == null ? void 0 : S.columnName,
      options: d.filter((E) => {
        var b;
        return E !== ((b = e.table.pivot) == null ? void 0 : b.columnName) && E !== e.table.groupBy;
      }).map((E) => ({ label: E, value: E })),
      selected: (A = e.table.pivot) == null ? void 0 : A.valueColumns,
      label: "Pivot Value Column(s) ",
      section: "table",
      subsection: "pivot",
      fieldName: "valueColumns",
      updateField: t,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "The column(s) whos values will be pivoted under the column selected as the Filter.")))
    }
  ));
}, Xf = ({ orderedValues: e, handleFilterOrder: t }) => /* @__PURE__ */ n.createElement(Tm, { onDragEnd: ({ source: r, destination: a }) => t(r == null ? void 0 : r.index, a == null ? void 0 : a.index) }, /* @__PURE__ */ n.createElement(Am, { droppableId: "filter_order" }, (r) => /* @__PURE__ */ n.createElement("ul", { ...r.droppableProps, className: "sort-list", ref: r.innerRef, style: { marginTop: "1em" } }, e == null ? void 0 : e.map((a, i) => /* @__PURE__ */ n.createElement(Lm, { key: a, draggableId: `draggableFilter-${a}`, index: i }, (o, d) => /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement(
  "div",
  {
    className: d.isDragging ? "currently-dragging" : "",
    style: o.draggableProps.style,
    ref: o.innerRef,
    ...o.draggableProps,
    ...o.dragHandleProps
  },
  a
)))), r.placeholder))), vw = ({
  config: e,
  dataColumns: t,
  handleGroupingCustomOrder: r,
  handleNameChange: a,
  filterIndex: i,
  rawData: o,
  updateField: d
}) => {
  const c = e.filters[i], s = c == null ? void 0 : c.subGrouping, p = [];
  e.filters.forEach((N, C) => {
    i !== C && (p.push(N.columnName), s != null && s.columnName && p.push(s.columnName));
  });
  const m = (N, C) => {
    d("filters", i, N, C);
  }, y = (N) => {
    const C = {
      values: lt.cloneDeep(c.values),
      order: N
    }, R = vf(C).values, _ = lt.cloneDeep(e.filters);
    _[i] = { ...c, values: R, order: N }, N === "cust" ? _[i].orderedValues = R : delete _[i].orderedValues, d(null, null, "filters", _);
  }, x = (N) => {
    d("filters", i, "subGrouping", N);
  }, T = (N) => {
    var U;
    const R = ((U = c.orderedValues) != null && U.length ? c.orderedValues : c.values).reduce((j, te) => {
      const Q = lt.uniq(
        o.map(($) => $[c.columnName] === te ? $[N] : "").filter(($) => $ !== "")
      ).sort();
      return j[te] = {
        values: Q
        // add temp values when column changes
      }, j;
    }, {}), _ = {
      ...s,
      columnName: N,
      valuesLookup: R
    };
    x(_);
  }, S = (N) => {
    const C = Object.keys(s.valuesLookup).reduce((_, U) => {
      const j = s.valuesLookup[U], { values: te } = vf({ values: j.values, order: N });
      return _[U] = {
        values: te
      }, N === "cust" ? _[U].orderedValues = te : delete _[U].orderedValues, _;
    }, {}), R = { ...s, order: N, valuesLookup: C };
    x(R);
  }, A = (N, C, R, _) => {
    const U = lt.cloneDeep(R), [j] = U.splice(N, 1);
    U.splice(C, 0, j);
    const te = lt.cloneDeep(s);
    te.valuesLookup[_].values = U, te.valuesLookup[_].orderedValues = U, x({ ...te, order: "cust" });
  }, E = t.filter((N) => !p.includes(N)), b = ue.useMemo(() => {
    var C;
    const N = e.filters[i];
    return !!(N.setByQueryParameter && ((C = N.subGrouping) != null && C.setByQueryParameter));
  }, [e, i]), v = (N) => {
    const C = e.filters, { checked: R } = N.target, _ = R ? c.columnName : "", U = R ? s.columnName : "";
    C[i] = {
      ...e.filters[i],
      setByQueryParameter: _,
      subGrouping: { ...s, setByQueryParameter: U }
    }, d(null, null, "filters", C);
  };
  return /* @__PURE__ */ n.createElement("div", { className: "nesteddropdown-editor" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading mt-2" }, "Label"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: c.label,
      onChange: (N) => {
        m("label", N.target.value);
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("div", { className: "edit-label column-heading mt-2" }, "Filter Grouping", /* @__PURE__ */ n.createElement("span", null)), /* @__PURE__ */ n.createElement("select", { value: c.columnName, onChange: (N) => a(N.target.value) }, /* @__PURE__ */ n.createElement("option", { value: "" }, "- Select Option -"), E.map((N, C) => /* @__PURE__ */ n.createElement("option", { value: N, key: C }, N)))), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("div", { className: "edit-label column-heading mt-2" }, "Filter SubGrouping", /* @__PURE__ */ n.createElement("span", null)), /* @__PURE__ */ n.createElement(
    "select",
    {
      value: (s == null ? void 0 : s.columnName) ?? "",
      onChange: (N) => {
        T(N.target.value);
      }
    },
    /* @__PURE__ */ n.createElement("option", { value: "" }, "- Select Option -"),
    E.map((N, C) => {
      if (N !== c.columnName)
        return /* @__PURE__ */ n.createElement("option", { value: N, key: C }, N);
    })
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "checkbox",
      checked: b,
      "aria-label": "Create query parameters",
      disabled: !c.columnName || !(s != null && s.columnName),
      onChange: (N) => v(N)
    }
  ), /* @__PURE__ */ n.createElement("span", null, " Create query parameters"), b && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading mt-2" }, "Grouping: Default Value Set By Query String Parameter"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: c.setByQueryParameter,
      onChange: (N) => {
        m("setByQueryParameter", N.target.value);
      }
    }
  ), /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading mt-2" }, "SubGrouping: Default Value Set By Query String Parameter"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: s == null ? void 0 : s.setByQueryParameter,
      onChange: (N) => {
        const C = N.target.value;
        x({ ...s, setByQueryParameter: C });
      }
    }
  ))), /* @__PURE__ */ n.createElement("label", { className: "mt-2" }, /* @__PURE__ */ n.createElement("div", { className: "edit-label column-heading float-right" }, c.columnName, " "), /* @__PURE__ */ n.createElement("span", { className: "edit-filterOrder column-heading " }, "Group Order"), /* @__PURE__ */ n.createElement("select", { value: c.order, onChange: (N) => y(N.target.value) }, gf.map((N, C) => /* @__PURE__ */ n.createElement("option", { value: N.value, key: `filter-${N.label}-${C}` }, N.label))), c.order === "cust" && /* @__PURE__ */ n.createElement(Xf, { orderedValues: c.orderedValues, handleFilterOrder: r })), (s == null ? void 0 : s.columnName) && /* @__PURE__ */ n.createElement("label", { className: "mt-2" }, /* @__PURE__ */ n.createElement("span", { className: "edit-filterOrder column-heading" }, "SubGrouping Order"), /* @__PURE__ */ n.createElement("div", { className: "edit-label column-heading float-right" }, s.columnName, " "), /* @__PURE__ */ n.createElement(
    "select",
    {
      value: s.order ? s.order : "asc",
      onChange: (N) => S(N.target.value)
    },
    gf.map((N, C) => /* @__PURE__ */ n.createElement("option", { value: N.value, key: `filter-${C}` }, N.label))
  ), (s == null ? void 0 : s.order) === "cust" && c.values.map((N, C) => {
    const R = s.valuesLookup[N].orderedValues;
    return /* @__PURE__ */ n.createElement("div", { key: `group-subgroup-values-${N}-${C}` }, /* @__PURE__ */ n.createElement("span", { className: "font-weight-bold" }, N), /* @__PURE__ */ n.createElement(
      Xf,
      {
        key: `subgroup-values-${N}-${C}`,
        orderedValues: R,
        handleFilterOrder: (_, U) => {
          A(_, U, R, N);
        }
      }
    ));
  })));
}, xw = ({ config: e, updateField: t, rawData: r }) => {
  const a = ue.useState({}), i = ue.useMemo(() => lt.uniq(lt.flatten(r == null ? void 0 : r.map((x) => Object.keys(x)))), [r]), o = (x) => {
    let T = lt.cloneDeep(e.filters);
    T.splice(x, 1), t(null, null, "filters", T);
  }, d = (x, T, S) => {
    t("filters", T, x, S);
  }, c = (x, T) => {
    const S = lt.cloneDeep(e.filters), A = { ...S[x], orderedValues: S[x].values };
    A.filterStyle = T, T === "multi-select" ? A.active = Array.isArray(A.active) ? A.active : [A.active] : Array.isArray(A.active) && (A.active = A.active[0]), T === "nested-dropdown" && (A.showDropdown = !0), S[x] = A, t(null, null, "filters", S);
  }, s = (x, T) => {
    const S = lt.uniq(r.map((b) => b[T])), A = { ...lt.cloneDeep(e.filters[x]), columnName: T, values: S };
    vf(A), A.active = A.values[0];
    const E = e.filters.map((b, v) => v === x ? A : b);
    t(null, null, "filters", E);
  }, p = () => {
    const x = e.filters ? [...e.filters] : [], T = {
      values: [],
      filterStyle: "dropdown",
      id: Date.now(),
      showDropdown: !0
    };
    x.push(T), t(null, null, "filters", x);
  }, m = (x, T, S) => {
    const A = e.filters[S], E = [...A.orderedValues || A.values], [b] = E.splice(x, 1);
    E.splice(T, 0, b);
    const v = lt.cloneDeep(e.filters), N = { ...v[S] };
    N.values = E, N.orderedValues = E, N.active = E[0], N.order = "cust", v[S] = N, t(null, null, "filters", v);
  }, y = (x) => e.filters.filter((T, S) => S !== x).map(({ label: T, columnName: S, id: A }) => ({ label: T || S, value: A }));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.filters && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    yt,
    {
      value: e.filterBehavior,
      fieldName: "filterBehavior",
      label: "Filter Behavior",
      updateField: t,
      options: ["Apply Button", "Filter Change"],
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, 'The Apply Button option changes the visualization when the user clicks "apply". The Filter Change option immediately changes the visualization when the selection is changed.')))
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "textarea",
      label: "Filter intro text",
      value: e.filterIntro,
      updateField: t,
      fieldName: "filterIntro"
    }
  ), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("ul", { className: "filters-list" }, e.filters.map((x, T) => x.type === "url" ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(
    bg,
    {
      key: x.columnName,
      fieldName: x.columnName,
      fieldKey: T,
      fieldType: "Filter",
      controls: a,
      deleteField: () => o(T)
    },
    /* @__PURE__ */ n.createElement(
      yt,
      {
        value: x.filterStyle,
        fieldName: "filterStyle",
        label: "Filter Style",
        updateField: (S, A, E, b) => c(T, b),
        options: sv
      }
    ),
    x.filterStyle !== "nested-dropdown" ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      yt,
      {
        value: x.columnName,
        fieldName: "columnName",
        label: "Filter",
        updateField: (S, A, E, b) => s(T, b),
        options: i,
        initial: "- Select Option -"
      }
    ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-showDropdown column-heading" }, "Show Filter Input"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: x.showDropdown === void 0 ? !0 : x.showDropdown,
        onChange: (S) => {
          d("showDropdown", T, S.target.checked);
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Label"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: x.label,
        onChange: (S) => {
          d("label", T, S.target.value);
        }
      }
    )), x.filterStyle === "multi-select" && /* @__PURE__ */ n.createElement(
      je,
      {
        label: "Select Limit",
        value: x.selectLimit,
        updateField: t,
        section: "filters",
        subsection: T,
        fieldName: "selectLimit",
        type: "number",
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "The maximum number of items that can be selected.")))
      }
    ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Default Value Set By Query String Parameter"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: x.setByQueryParameter,
        onChange: (S) => {
          d("setByQueryParameter", T, S.target.value);
        }
      }
    )), /* @__PURE__ */ n.createElement(
      yt,
      {
        value: x.order || "asc",
        fieldName: "order",
        label: "Filter Order",
        updateField: (S, A, E, b) => d("order", T, b),
        options: gf
      }
    ), x.order === "cust" && /* @__PURE__ */ n.createElement(
      Xf,
      {
        orderedValues: x.orderedValues || x.values,
        handleFilterOrder: (S, A) => m(S, A, T)
      }
    )) : /* @__PURE__ */ n.createElement(
      vw,
      {
        config: e,
        dataColumns: i,
        filterIndex: T,
        rawData: r,
        handleGroupingCustomOrder: (S, A) => m(S, A, T),
        handleNameChange: (S) => s(T, S),
        updateField: t,
        updateFilterStyle: c
      }
    ),
    /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Filter Parents", " ", /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "A selected parent's value will be used to filter the available options of this child filter.")))), /* @__PURE__ */ n.createElement(
      yf,
      {
        fieldName: "parents",
        updateField: (S, A, E, b) => {
          d("parents", T, b);
        },
        options: y(T)
      }
    ))
  )))), !e.filters && /* @__PURE__ */ n.createElement("p", { style: { textAlign: "center" } }, "There are currently no filters."), /* @__PURE__ */ n.createElement("button", { type: "button", onClick: p, className: "btn btn-primary full-width" }, "Add Filter"));
}, qu = (e) => /* @__PURE__ */ ue.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ ue.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), bw = ({ name: e }) => {
  var c, s, p, m, y;
  const { config: t, rawData: r, updateConfig: a } = ue.useContext(gt);
  if (t.visualizationType !== "Forest Plot")
    return;
  const i = (x) => {
    x.orientation === "horizontal" && (x.labels = !1), x.table.show === void 0 && (x.table.show = !isDashboard), x.visualizationType === "Combo" && (x.orientation = "vertical");
  }, o = (x = !0) => {
    let T = {};
    return r.forEach((S) => {
      Object.keys(S).forEach((A) => T[A] = !0);
    }), x && Object.keys(T).forEach((S) => {
      (t.series && t.series.filter((A) => A.dataKey === S).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(S)) && delete T[S];
    }), Object.keys(T);
  }, d = (x, T, S, A) => {
    if (x === "boxplot" && T === "legend") {
      a({
        ...t,
        [x]: {
          ...t[x],
          [T]: {
            ...t.boxplot[T],
            [S]: A
          }
        }
      });
      return;
    }
    if (x === "boxplot" && T === "labels") {
      a({
        ...t,
        [x]: {
          ...t[x],
          [T]: {
            ...t.boxplot[T],
            [S]: A
          }
        }
      });
      return;
    }
    if (x === "forestPlot" && T) {
      let N = {
        ...t,
        [x]: {
          ...t[x],
          [T]: {
            ...t.forestPlot[T],
            [S]: A
          }
        }
      };
      a(N);
      return;
    }
    if (x === "columns" && T !== "" && S !== "") {
      a({
        ...t,
        [x]: {
          ...t[x],
          [T]: {
            ...t[x][T],
            [S]: A
          }
        }
      });
      return;
    }
    if (x === null && T === null) {
      let N = { ...t, [S]: A };
      i(N), a(N);
      return;
    }
    const E = Array.isArray(t[x]);
    let b = E ? [...t[x], A] : { ...t[x], [S]: A };
    T !== null && (E ? (b = [...t[x]], b[T] = { ...b[T], [S]: A }) : typeof A == "string" ? b[T] = A : b = { ...t[x], [T]: { ...t[x][T], [S]: A } });
    let v = { ...t, [x]: b };
    i(v), a(v);
  };
  return /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, e, (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ n.createElement(qu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Study Column",
      initial: "Select",
      required: !0,
      updateField: d,
      options: o(!1),
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  ), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.forestPlot.type,
      label: "Forest Plot Type",
      initial: "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            type: x.target.value
          }
        }), x.target.value = "";
      },
      options: ["Linear", "Logarithmic"],
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ", /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("br", null), " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1.")))
    }
  ), /* @__PURE__ */ n.createElement(je, { type: "text", value: ((c = t.forestPlot) == null ? void 0 : c.title) || "", updateField: d, section: "forestPlot", fieldName: "title", label: "Plot Title" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Column Settings"), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.forestPlot.estimateField,
      label: "Point Estimate Column",
      initial: t.forestPlot.estimateField || "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            estimateField: x.target.value
          }
        }), x.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.forestPlot.shape,
      label: "Point Estimate Shape",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            shape: x.target.value
          }
        }), x.target.value = "";
      },
      options: ["text", "circle", "square"]
    }
  ), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.forestPlot.lower,
      label: "Lower CI Column",
      required: !0,
      initial: t.forestPlot.lower || "Select",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            lower: x.target.value
          }
        }), x.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.forestPlot.upper,
      label: "Upper CI Column",
      initial: t.forestPlot.upper || "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            upper: x.target.value
          }
        }), x.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Pooled Result Column", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: t.forestPlot.pooledResult.column || "",
      label: "Pooled Result Row",
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            pooledResult: {
              ...t.forestPlot.pooledResult,
              column: x.target.value
            }
          }
        }), x.target.value = "";
      }
    }
  ))), /* @__PURE__ */ n.createElement(Je, { value: ((p = (s = t.forestPlot) == null ? void 0 : s.lineOfNoEffect) == null ? void 0 : p.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: d }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Width Settings"), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left (%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffset || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffset: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left Mobile(%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffsetMobile || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffsetMobile: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right (%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffset || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffset: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right Mobile(%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffsetMobile || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffsetMobile: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement(je, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: d, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Labels Settings"), /* @__PURE__ */ n.createElement(je, { type: "text", value: ((m = t.forestPlot) == null ? void 0 : m.leftLabel) || "", updateField: d, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }), /* @__PURE__ */ n.createElement(je, { type: "text", value: ((y = t.forestPlot) == null ? void 0 : y.rightLabel) || "", updateField: d, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.forestPlot.radius.scalingColumn,
      label: "Weight Column",
      initial: "Select",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              scalingColumn: x.target.value
            }
          }
        }), x.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Radius Minimum Size"), /* @__PURE__ */ n.createElement(
    "input",
    {
      min: 3,
      max: 6,
      value: t.forestPlot.radius.min || 3,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              min: Number(x.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Radius Maximum Size"), /* @__PURE__ */ n.createElement(
    "input",
    {
      min: 7,
      max: 10,
      value: t.forestPlot.radius.max,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              max: Number(x.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  ))));
}, qi = n.createContext({}), Ew = (e) => {
  const { updateConfig: t, config: r, rawData: a } = ue.useContext(gt), { getColumns: i, selectComponent: o } = e, d = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], c = (s, p, m) => {
    let y = [...r.series];
    if (y[s][m] = p, m === "type" && p === "Bar" && (y[s].axis = "Left"), y[s].type === "Forecasting") {
      let x = Array.from(new Set(a.map((S) => S[y[s].dataKey]))), T = [];
      x.forEach((S) => {
        T.push({ key: S });
      }), y[s].stages = T, y[s].stageColumn = y[s].dataKey;
    }
    t({ ...r, series: y });
  };
  return /* @__PURE__ */ n.createElement(qi.Provider, { value: { updateSeries: c, supportedRightAxisTypes: d, getColumns: i, selectComponent: o } }, e.children);
}, Sw = (e) => {
  const { config: t, updateConfig: r } = ue.useContext(gt), { series: a, index: i } = e;
  if (!(() => {
    let s = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart", "Bump Chart"].some((m) => m.includes(a.type)) && (s = !0), s;
  })())
    return;
  const d = (s, p) => {
    let m = [...t.series];
    m[s].lineType = p, r({ ...t, series: m });
  };
  let c = [];
  return Object.keys(sl).map((s) => c.push(sl[s])), /* @__PURE__ */ n.createElement(
    ja,
    {
      initial: "Select an option",
      value: a.lineType ? a.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (s) => {
        d(i, s.target.value);
      },
      options: c
    }
  );
}, kw = (e) => {
  const { config: t } = ue.useContext(gt), { updateSeries: r } = ue.useContext(qi), { index: a, series: i } = e, o = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line" || t.visualizationType === "Bump Chart")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo", "Bump Chart"].includes(t.visualizationType))
    return /* @__PURE__ */ n.createElement(
      ja,
      {
        initial: "Select an option",
        value: i.type,
        label: "Series Type",
        onChange: (d) => {
          r(a, d.target.value, "type");
        },
        options: o()
      }
    );
}, ww = (e) => {
  const { config: t, updateConfig: r, rawData: a } = ue.useContext(gt), { updateSeries: i, getColumns: o } = ue.useContext(qi), { index: d, series: c } = e;
  return /* @__PURE__ */ n.createElement(
    ja,
    {
      initial: "Select an option",
      value: c.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (s) => {
        let p = [], m = new Set(a == null ? void 0 : a.map((x) => x[s.target.value]));
        m = Array.from(m), m = m.filter((x) => x !== void 0), m.forEach((x) => p.push({ key: x }));
        const y = [...t.series];
        y[d] = { ...y[d], stages: p, stageColumn: s.target.value }, r({
          ...t,
          series: y
        });
      },
      options: o(!1)
    }
  );
}, Cw = (e) => {
  const { config: t, rawData: r } = ue.useContext(gt), { updateSeries: a } = ue.useContext(qi), { index: i, series: o } = e;
  if (o.type !== "Forecasting" || !r || !o.stageColumn)
    return;
  let d = new Set(r.map((c) => c[o.stageColumn]));
  return d = Array.from(d), d = d.filter((c) => c !== void 0), /* @__PURE__ */ n.createElement(
    ja,
    {
      initial: "Select an option",
      value: o.stageItem,
      label: "Forecasting Item Column",
      onChange: (c) => {
        a(i, c.target.value, "stageItem");
      },
      options: d
    }
  );
}, Tw = (e) => {
  const { config: t } = ue.useContext(gt), { updateSeries: r, supportedRightAxisTypes: a } = ue.useContext(qi), { index: i, series: o } = e;
  if (!(t.visualizationType !== "Combo" || !o) && a.includes(o.type))
    return /* @__PURE__ */ n.createElement(
      ja,
      {
        initial: "Select an option",
        value: o.axis ? o.axis : "Left",
        label: "Series Axis",
        onChange: (d) => {
          r(i, d.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, Aw = (e) => {
  var o;
  const { config: t, updateConfig: r } = ue.useContext(gt), { index: a, series: i } = e;
  if (i.type === "Forecasting" && i)
    return (o = i == null ? void 0 : i.stages) == null ? void 0 : o.map((d, c) => {
      var s, p, m, y;
      return /* @__PURE__ */ n.createElement(
        ja,
        {
          key: `${d}--${c}`,
          initial: "Select an option",
          value: (p = (s = t.series) == null ? void 0 : s[a].stages) != null && p[c].color ? (y = (m = t.series) == null ? void 0 : m[a].stages) == null ? void 0 : y[c].color : "Select",
          label: `${d.key} Series Color`,
          onChange: (x) => {
            const T = [...t.series], S = T[a].stages;
            S[c].color = x.target.value, T[a] = { ...T[a], stages: S }, r({
              ...t,
              series: T
            });
          },
          options: Object.keys(Zu)
        }
      );
    });
}, Lw = (e) => {
  var d;
  const { config: t, updateConfig: r } = ue.useContext(gt), { series: a, index: i } = e, { getColumns: o } = ue.useContext(qi);
  if (a.type === "Forecasting")
    return /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Confidence Interval Groups"), /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement(Bi, { allowZeroExpanded: !0 }, (d = a == null ? void 0 : a.confidenceIntervals) == null ? void 0 : d.map((c, s) => {
      const p = c.showInTooltip ? c.showInTooltip : !1, m = (y, x, T) => {
        y.preventDefault();
        let S = [...t.series];
        S[x].confidenceIntervals[T].showInTooltip = !p, r({
          ...t,
          series: S
        });
      };
      return /* @__PURE__ */ n.createElement(zn, { className: "series-item series-item--chart", key: `${s}` }, /* @__PURE__ */ n.createElement(Bn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement($n, { className: "accordion__button accordion__button" }, "Group ", s + 1, /* @__PURE__ */ n.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (y) => {
            y.preventDefault();
            const x = [...t.series[i].confidenceIntervals];
            x.splice(s, 1);
            const T = [...t.series];
            T[i] = { ...T[i], confidenceIntervals: [...x] }, r({
              ...t,
              series: T
            });
          }
        },
        "Remove"
      )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("div", { className: "input-group" }, /* @__PURE__ */ n.createElement("label", { htmlFor: "showInTooltip" }, "Show In Tooltip"), /* @__PURE__ */ n.createElement(
        "div",
        {
          className: "cove-input__checkbox--small",
          onClick: (y) => m(y, i, s)
        },
        /* @__PURE__ */ n.createElement(
          "div",
          {
            className: "cove-input__checkbox-box custom-color",
            style: { backgroundColor: "" }
          },
          p && /* @__PURE__ */ n.createElement(Bm, { className: "", style: { fill: "#025eaa" } })
        ),
        /* @__PURE__ */ n.createElement(
          "input",
          {
            className: "cove-input--hidden",
            type: "checkbox",
            name: "showInTooltip",
            checked: p || !1,
            readOnly: !0
          }
        )
      )), /* @__PURE__ */ n.createElement(
        ja,
        {
          initial: "Select an option",
          value: t.series[i].confidenceIntervals[s].low ? t.series[i].confidenceIntervals[s].low : "Select",
          label: "Low Confidence Interval",
          onChange: (y) => {
            const x = [...t.series[i].confidenceIntervals];
            x[s].low = y.target.value;
            const T = [...t.series];
            T[i] = { ...T[i], confidenceIntervals: x }, r({
              ...t,
              series: T
            });
          },
          options: o()
        }
      ), /* @__PURE__ */ n.createElement(
        ja,
        {
          initial: "Select an option",
          value: t.series[i].confidenceIntervals[s].high ? t.series[i].confidenceIntervals[s].high : "Select",
          label: "High Confidence Interval",
          onChange: (y) => {
            const x = [...t.series[i].confidenceIntervals];
            x[s].high = y.target.value;
            const T = [...t.series];
            T[i] = { ...T[i], confidenceIntervals: x }, r({
              ...t,
              series: T
            });
          },
          options: o()
        }
      )));
    })), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (c) => {
          c.preventDefault();
          let s = null;
          t.series[i].confidenceIntervals ? s = [...t.series[i].confidenceIntervals] : s = [];
          const p = [...t.series];
          p[i] = {
            ...p[i],
            confidenceIntervals: [...s, { high: "", low: "" }]
          }, r({
            ...t,
            series: p
          });
        }
      },
      "Add Confidence Interval Group"
    )));
}, Pw = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = ue.useContext(gt);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const d = (c, s, p, m) => {
    let y = [...a.series], x = { ...a.runtime.seriesLabels };
    y[c].weight = s && Math.max(Number(p), Math.min(Number(m), Number(s))), x[y[c].dataKey] = y[c].weight ? y[c].weight : y[c].dataKey;
    const T = {
      ...a,
      series: y,
      runtime: {
        ...a.runtime,
        seriesLabels: x
      }
    };
    i(T);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "series-weight" }, "Line Weight"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      key: `series-weight-${r}`,
      value: t.weight ? t.weight : "",
      min: "1",
      max: "9",
      onChange: (c) => {
        d(r, c.target.value, c.target.min, c.target.max);
      }
    }
  ));
}, Nw = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = ue.useContext(gt);
  if (![
    "Bump Chart",
    "Bar",
    "Line",
    "Area Chart",
    "Combo",
    "Deviation",
    "Paired",
    "Scatter",
    "dashed-sm",
    "dashed-md",
    "dashed-lg"
  ].includes(t.type))
    return;
  const d = (c, s) => {
    let p = [...a.series], m = { ...a.runtime.seriesLabels };
    p[c].name = s, m[p[c].dataKey] = p[c].name ? p[c].name : p[c].dataKey;
    let y = {
      ...a,
      series: p,
      runtime: {
        ...a.runtime,
        seriesLabels: m
      }
    };
    i(y);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "series-name" }, "Series Name"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      key: `series-name-${r}`,
      value: t.name ? t.name : "",
      onChange: (c) => {
        d(r, c.target.value);
      }
    }
  ));
}, Rw = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = ue.useContext(gt);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(a.visualizationType))
    return;
  const o = (d) => {
    let c = [...a.series];
    c[d].tooltip && c[d].tooltip, c[d].tooltip = !c[d].tooltip, i({
      ...a,
      series: c
    });
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: "input-group" }, /* @__PURE__ */ n.createElement("label", { htmlFor: `series-tooltip--${r}` }, "Show In Tooltip"), /* @__PURE__ */ n.createElement("div", { className: "cove-input__checkbox--small", onClick: (d) => o(r) }, /* @__PURE__ */ n.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, t.tooltip && /* @__PURE__ */ n.createElement(Bm, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ n.createElement(
    "input",
    {
      className: "cove-input--hidden",
      type: "checkbox",
      name: `series-tooltip--${r}`,
      checked: t.tooltip ? t.tooltip : !1,
      readOnly: !0
    }
  ))));
}, Dw = (e) => {
  const { config: t, updateConfig: r } = ue.useContext(gt), { series: a, index: i } = e, o = (c) => {
    let s = [...t.series], p = -1;
    for (let m = 0; m < s.length; m++)
      if (s[m].dataKey === c) {
        p = m;
        break;
      }
    if (p !== -1) {
      s.splice(p, 1);
      let m = { ...t, series: s };
      s.length === 0 && delete m.series, r(m);
    }
    t.visualizationType === "Paired Bar" && r({
      ...t,
      series: []
    });
  }, d = (c, s, p) => {
    c.preventDefault(), o(s.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ n.createElement("button", { className: "series-list__remove", onClick: (c) => d(c, a) }, "Remove");
}, Eg = (e) => {
  const { config: t } = ue.useContext(gt), { updateSeries: r, getColumns: a } = ue.useContext(qi), { series: i, getItemStyle: o, sortableItemStyles: d, chartsWithOptions: c, index: s } = e, p = ["Bar", "Line"].includes(t.visualizationType) && t.visualizationSubType !== "Stacked" && !t.series.find((m) => m.dynamicCategory && m.dataKey !== i.dataKey);
  return /* @__PURE__ */ n.createElement(Lm, { key: i.dataKey, draggableId: `draggableFilter-${i.dataKey}`, index: s }, (m, y) => /* @__PURE__ */ n.createElement(
    "div",
    {
      key: s,
      className: y.isDragging ? "currently-dragging" : "",
      style: o(y.isDragging, m.draggableProps.style, d),
      ref: m.innerRef,
      ...m.draggableProps,
      ...m.dragHandleProps
    },
    /* @__PURE__ */ n.createElement(Bi, { allowZeroExpanded: !0 }, /* @__PURE__ */ n.createElement(zn, { className: "series-item series-item--chart" }, /* @__PURE__ */ n.createElement(Bn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(
      $n,
      {
        className: c.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow"
      },
      /* @__PURE__ */ n.createElement(Xe, { display: "move", size: 15, style: { cursor: "default" } }),
      i.dataKey,
      /* @__PURE__ */ n.createElement(Xr.Button.Remove, { series: i, index: s })
    )), c.includes(t.visualizationType) && /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(Xr.Input.Name, { series: i, index: s }), p && /* @__PURE__ */ n.createElement(
      yt,
      {
        label: "Dynamic Category",
        value: i.dynamicCategory,
        options: ["- Select - ", ...a().filter((x) => i.dataKey !== x)],
        updateField: (x, T, S, A) => {
          A === "- Select -" && (A = ""), r(s, A, "dynamicCategory");
        },
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "This field is Optional. If you have a dynamic data series you can select the category field here. You can only add one dynamic category per visualization.")))
      }
    ), /* @__PURE__ */ n.createElement(Xr.Input.Weight, { series: i, index: s }), /* @__PURE__ */ n.createElement(Xr.Dropdown.SeriesType, { series: i, index: s }), /* @__PURE__ */ n.createElement(Xr.Dropdown.AxisPosition, { series: i, index: s }), /* @__PURE__ */ n.createElement(Xr.Dropdown.LineType, { series: i, index: s }), /* @__PURE__ */ n.createElement(Xr.Dropdown.ForecastingColor, { series: i, index: s }), /* @__PURE__ */ n.createElement(Xr.Dropdown.ConfidenceInterval, { series: i, index: s }), /* @__PURE__ */ n.createElement(Xr.Checkbox.DisplayInTooltip, { series: i, index: s }))))
  ));
}, _w = (e) => {
  const { series: t, getItemStyle: r, sortableItemStyles: a, chartsWithOptions: i } = e;
  return t.map((o, d) => /* @__PURE__ */ n.createElement(
    Eg,
    {
      getItemStyle: r,
      sortableItemStyles: a,
      chartsWithOptions: i,
      series: o,
      index: d,
      key: `series-list-${d}`
    }
  ));
}, Xr = {
  Wrapper: Ew,
  Dropdown: {
    SeriesType: kw,
    AxisPosition: Tw,
    ConfidenceInterval: Lw,
    LineType: Sw,
    ForecastingStage: ww,
    ForecastingColumn: Cw,
    ForecastingColor: Aw
  },
  Input: {
    Name: Nw,
    Weight: Pw
  },
  Checkbox: {
    DisplayInTooltip: Rw
  },
  Button: {
    Remove: Dw
  },
  Item: Eg,
  List: _w
}, Ow = ue.memo(({ config: e, updateConfig: t }) => {
  let r = (s, p, m) => {
    let y = [];
    e.regions && (y = [...e.regions]), y[m][s] = p, t({ ...e, regions: y });
  }, a = (s, p, m, y, x) => r(m, y, x), i = (s) => {
    let p = [];
    e.regions && (p = [...e.regions]), p.splice(s, 1), t({ ...e, regions: p });
  }, o = () => {
    let s = [];
    e.regions && (s = [...e.regions]), s.push({}), t({ ...e, regions: s });
  };
  const d = ["Fixed", "Previous Days"], c = ["Last Date", "Fixed"];
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.regions && e.regions.map(({ label: s, color: p, from: m, to: y, background: x, range: T = "Custom" }, S) => {
    var A;
    return /* @__PURE__ */ n.createElement("div", { className: "edit-block", key: `region-${S}` }, /* @__PURE__ */ n.createElement(
      "button",
      {
        type: "button",
        className: "btn btn-danger remove-column",
        onClick: (E) => {
          E.preventDefault(), i(S);
        }
      },
      "Remove"
    ), /* @__PURE__ */ n.createElement(je, { value: s, label: "Region Label", fieldName: "label", i: S, updateField: a }), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      je,
      {
        value: p,
        label: "Text Color",
        fieldName: "color",
        updateField: (E, b, v, N) => r(v, N, S)
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: x,
        label: "Background",
        fieldName: "background",
        updateField: (E, b, v, N) => r(v, N, S)
      }
    )), /* @__PURE__ */ n.createElement(
      yt,
      {
        value: e.regions[S].fromType ?? "Fixed",
        label: "Minimum Region Type",
        initial: "Select",
        required: !0,
        onChange: (E) => {
          if (E.target.value !== "" && E.target.value !== "Select") {
            const b = [...e.regions];
            b[S].fromType = E.target.value, t({
              ...e,
              regions: b
            });
          }
          E.target.value = "";
        },
        options: d
      }
    ), (e.regions[S].fromType === "Fixed" || e.regions[S].fromType === "Previous Days" || !e.regions[S].fromType) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      je,
      {
        value: m,
        label: e.regions[S].fromType === "Fixed" || !((A = e.regions[S]) != null && A.fromType) ? "From Value" : "Previous Number of Days",
        fieldName: "from",
        updateField: (E, b, v, N) => r(v, N, S),
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value.")))
      }
    )), /* @__PURE__ */ n.createElement(
      yt,
      {
        value: e.regions[S].toType ?? "Fixed",
        label: "Maximum Region Type",
        initial: "Select",
        required: !0,
        onChange: (E) => {
          if (E.target.value !== "" && E.target.value !== "Select") {
            const b = [...e.regions];
            b[S].toType = E.target.value, t({
              ...e,
              regions: b
            });
          }
          E.target.value = "";
        },
        options: c
      }
    ), (e.regions[S].toType === "Fixed" || !e.regions[S].toType) && /* @__PURE__ */ n.createElement(
      je,
      {
        value: y,
        label: "To Value",
        fieldName: "to",
        updateField: (E, b, v, N) => r(v, N, S)
      }
    ));
  }), !e.regions && /* @__PURE__ */ n.createElement("p", { style: { textAlign: "center" } }, "There are currently no regions."), /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-primary full-width",
      onClick: (s) => {
        s.preventDefault(), o();
      }
    },
    "Add Region"
  ));
}), Fw = ({ name: e }) => {
  const { visSupportsRegions: t } = zs(), { config: r, updateConfig: a } = ue.useContext(gt);
  return t() ? /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, e)), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(Ow, { config: r, updateConfig: a }))) : null;
}, wp = ue.createContext(null), Cp = () => {
  const e = ue.useContext(wp);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, Mw = (e) => {
  const { config: t } = ue.useContext(gt), { updateField: r } = Cp(), {
    enabledChartTypes: a,
    visHasNumbersOnBars: i,
    visHasaAdditionalLabelsOnBars: o,
    visHasLabelOnData: d,
    visSupportsChartHeight: c,
    visSupportsMobileChartHeight: s,
    visSupportsSuperTitle: p,
    visSupportsFootnotes: m
  } = zs(), { visualizationType: y, visualizationSubType: x, barStyle: T } = t, S = () => (y === "Bar" || y === "Deviation Bar") && x !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ n.createElement(zn, null, " ", /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, "General")), /* @__PURE__ */ n.createElement(In, null, (t == null ? void 0 : t.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement(
    yt,
    {
      value: y,
      fieldName: "visualizationType",
      label: "Chart Type",
      updateField: r,
      options: a
    }
  ), c() && t.orientation === "vertical" && /* @__PURE__ */ n.createElement("div", { className: s() ? "two-col-inputs" : "" }, /* @__PURE__ */ n.createElement(
    je,
    {
      type: "number",
      value: t.heights.vertical,
      section: "heights",
      fieldName: "vertical",
      label: "Chart Height",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, "˝", /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "For some visualization types, such as the Sankey diagram, it may be necessary to adjust the chart height for optimal display.")))
    }
  ), s() && t.orientation === "vertical" && /* @__PURE__ */ n.createElement(
    je,
    {
      type: "number",
      value: t.heights.mobileVertical,
      section: "heights",
      fieldName: "mobileVertical",
      label: "Mobile Height",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "If the chart height is not optimized for mobile, you can adjust the height for better display. Not setting a value will default to the chart height.")))
    }
  )), (y === "Bar" || y === "Combo" || y === "Area Chart") && /* @__PURE__ */ n.createElement(
    yt,
    {
      value: x || "Regular",
      fieldName: "visualizationSubType",
      label: "Chart Subtype",
      updateField: r,
      options: ["regular", "stacked"]
    }
  ), y === "Area Chart" && x === "stacked" && /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.stackedAreaChartLineType || "Linear",
      fieldName: "stackedAreaChartLineType",
      label: "Stacked Area Chart Line Type",
      updateField: r,
      options: Object.keys(sl)
    }
  ), y === "Bar" && /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.orientation || "vertical",
      fieldName: "orientation",
      label: "Orientation",
      updateField: r,
      options: ["vertical", "horizontal"]
    }
  ), y === "Deviation Bar" && /* @__PURE__ */ n.createElement(yt, { label: "Orientation", options: ["horizontal"] }), (y === "Bar" || y === "Deviation Bar") && /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.isLollipopChart ? "lollipop" : T || "flat",
      fieldName: "barStyle",
      label: "bar style",
      updateField: r,
      options: S(),
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Consider using the 'Flat' bar style when presenting data that includes '0' values.")))
    }
  ), (y === "Bar" || y === "Deviation Bar") && T === "rounded" && /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.tipRounding || "top",
      fieldName: "tipRounding",
      label: "tip rounding",
      updateField: r,
      options: ["top", "full"]
    }
  ), (y === "Bar" || y === "Deviation Bar") && T === "rounded" && /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.roundingStyle || "standard",
      fieldName: "roundingStyle",
      label: "rounding style",
      updateField: r,
      options: ["standard", "shallow", "finger"]
    }
  ), y === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.yAxis.labelPlacement || "Below Bar",
      section: "yAxis",
      fieldName: "labelPlacement",
      label: "Label Placement",
      updateField: r,
      options: ["Below Bar", "On Date/Category Axis"]
    }
  ), i() ? /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.yAxis.displayNumbersOnBar,
      section: "yAxis",
      fieldName: "displayNumbersOnBar",
      label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar",
      updateField: r
    }
  ) : d() && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.labels,
      fieldName: "labels",
      label: "Display label on data",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will ", /* @__PURE__ */ n.createElement("i", null, " not "), ' hide the display of "zero value", "suppressed data", or "missing data" indicators on the chart (if applicable).')))
    }
  ), o() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Selecting this option will display a thin line slightly above the Date/Category Axis to indicate "zero value" where zero values are indicated in the Data Series.'))),
      value: t.general.showZeroValueData,
      section: "general",
      fieldName: "showZeroValueData",
      label: 'Display "Zero Data" Label',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, t.visualizationSubType === "stacked" && /* @__PURE__ */ n.createElement("p", null, "We do not recommend using stacked vertical/horizontal bar charts for missing data. If you choose to proceed, selecting this option will display 'N/A' in the tooltip hover and data table (e.g. nothing will display in chart)."), t.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("p", null, "Selecting this option will display 'N/A' on the Date/Category Axis, in the tooltip hover, and in the data table to indicate missing or undefined data values."))),
      value: t.general.showMissingDataLabel,
      section: "general",
      fieldName: "showMissingDataLabel",
      label: 'Display "Missing Data" Label',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      display: t.visualizationType === "Bar" || t.visualizationType === "Combo",
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting 'Remove Null Values' will hide the 'N/A' (no data indicator) when you hover over the chart."))),
      value: t.general.hideNullValue,
      section: "general",
      fieldName: "hideNullValue",
      label: 'Remove "Null" Values From Hover',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, t.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("p", null, "Selecting this option will show the ", /* @__PURE__ */ n.createElement("i", null, "suppression indicator "), " on the Date/Category axis, within tooltips, and in the data table where suppressed data values appear in the Data Series."), t.visualizationSubType === "stacked" && /* @__PURE__ */ n.createElement("p", null, "We do not recommend using stacked vertical/horizontal bar charts for suppressed data. If you choose to proceed, selecting this option will display the 'suppressed data symbol' in the tooltip hover and data table (e.g., nothing will display in the chart)."))),
      value: t.general.showSuppressedSymbol,
      section: "general",
      fieldName: "showSuppressedSymbol",
      label: 'Display "suppressed data" label',
      updateField: r
    }
  )), y === "Pie" && /* @__PURE__ */ n.createElement(yt, { fieldName: "pieType", label: "Pie Chart Type", updateField: r, options: ["Regular", "Donut"] }), y === "Line" && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.allowLineToBarGraph,
      fieldName: "allowLineToBarGraph",
      label: "Convert to Bar Graph",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Switch to bar graph when less than 3 data points available.")))
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      value: t.title || "Chart Title",
      fieldName: "title",
      id: "title",
      label: "Title",
      placeholder: "Chart Title",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Title is required to set the name of the download file but can be hidden using the option below.")))
    }
  ), /* @__PURE__ */ n.createElement(Je, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: r }), p() && /* @__PURE__ */ n.createElement(
    je,
    {
      value: t.superTitle,
      updateField: r,
      fieldName: "superTitle",
      label: "Super Title",
      placeholder: "Super Title",
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Super Title")))
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "textarea",
      value: t.introText,
      updateField: r,
      fieldName: "introText",
      label: "Message",
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Intro Text")))
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "textarea",
      value: t.description,
      fieldName: "description",
      label: "Subtext/Citation",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub.")))
    }
  ), m() && /* @__PURE__ */ n.createElement(
    je,
    {
      type: "textarea",
      value: t.footnotes,
      updateField: r,
      fieldName: "footnotes",
      label: "Footnotes",
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data.")))
    }
  )));
}, zw = (e) => {
  const { config: t } = ue.useContext(gt), { boxplot: r } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: a } = Cp();
  return /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, e.name)), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("h4", { style: { fontSize: "18px" } }, "Labels for 5-Number Summary"), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "text",
      value: r.labels.maximum,
      fieldName: "maximum",
      section: "boxplot",
      subsection: "labels",
      label: "Maximum",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Highest value, excluding outliers")))
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "text",
      value: r.labels.q3,
      fieldName: "q3",
      section: "boxplot",
      subsection: "labels",
      label: "Upper Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Represented by top line of box. 25% of data are higher.")))
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "text",
      value: r.labels.median,
      fieldName: "median",
      section: "boxplot",
      subsection: "labels",
      label: "Median",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Middle data point. Half of data are higher value.")))
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "text",
      value: r.labels.q1,
      fieldName: "q1",
      section: "boxplot",
      subsection: "labels",
      label: "Lower Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Represented by bottom line of box. 25% of data are lower.")))
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "text",
      value: r.labels.minimum,
      fieldName: "minimum",
      section: "boxplot",
      subsection: "labels",
      label: "Minimum",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Lowest value, excluding outliers")))
    }
  ), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", { style: { fontSize: "18px" } }, "Labels for Additional Measures"), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "text",
      value: r.labels.iqr,
      fieldName: "iqr",
      section: "boxplot",
      subsection: "labels",
      label: "Interquartile Range",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "text",
      value: r.labels.count,
      fieldName: "count",
      section: "boxplot",
      subsection: "labels",
      label: "Count",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "text",
      value: r.labels.mean,
      fieldName: "mean",
      section: "boxplot",
      subsection: "labels",
      label: "Mean",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "text",
      value: r.labels.outliers,
      fieldName: "outliers",
      section: "boxplot",
      subsection: "labels",
      label: "Outliers",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      type: "text",
      value: r.labels.values,
      fieldName: "values",
      section: "boxplot",
      subsection: "labels",
      label: "Values",
      updateField: a
    }
  )));
}, Bw = (e, t) => {
  let r = [], a = [], i = [];
  const o = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const d = e.twoColor.isPaletteReversed;
    r = Object.keys(Cs).filter(
      (c) => d ? c.endsWith("reverse") : !c.endsWith("reverse")
    );
  } else {
    const d = [], c = [];
    for (const s in vr) {
      const p = s.startsWith("sequential"), m = s.startsWith("qualitative"), y = s.startsWith("colorblindsafe"), x = s.endsWith("reverse");
      p && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && d.push(s), m && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && c.push(s), y && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && o.push(s);
    }
    a = d, i = c;
  }
  return ue.useEffect(() => {
    let d = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (d = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (d = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: d } });
  }, [e.twoColor.isPaletteReversed]), ue.useEffect(() => {
    let d = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (d = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (d = e.palette.slice(0, -7)), t({ ...e, palette: d });
  }, [e.isPaletteReversed]), { twoColorPalettes: r, sequential: a, nonSequential: i, accessibleColors: o };
}, $w = (e) => {
  var te;
  const { config: t, updateConfig: r, colorPalettes: a, twoColorPalette: i } = ue.useContext(gt), { visual: o } = t, { setLollipopShape: d, updateField: c } = Cp(), {
    visHasBarBorders: s,
    visCanAnimate: p,
    visSupportsNonSequentialPallete: m,
    headerColors: y,
    visSupportsTooltipOpacity: x,
    visSupportsTooltipLines: T,
    visSupportsBarSpace: S,
    visSupportsBarThickness: A,
    visHasDataCutoff: E,
    visSupportsSequentialPallete: b,
    visSupportsReverseColorPalette: v,
    visHasSingleSeriesTooltip: N
  } = zs(), { twoColorPalettes: C, sequential: R, nonSequential: _, accessibleColors: U } = Bw(t, r), j = (Q, $) => {
    if (console.log("value", $), Q === "storyNodeFontColor") {
      r({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: $
        }
      });
      return;
    } else
      r({
        ...t,
        sankey: {
          ...t.sankey,
          [Q]: {
            ...t.sankey[Q],
            default: $
          }
        }
      });
  };
  return /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, "Visual")), /* @__PURE__ */ n.createElement(In, null, (t.barStyle === "lollipop" || t.isLollipopChart) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", { className: "header" }, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Lollipop Shape"), /* @__PURE__ */ n.createElement(
    "div",
    {
      onChange: (Q) => {
        d(Q.target.value);
      }
    },
    /* @__PURE__ */ n.createElement("label", { className: "radio-label" }, /* @__PURE__ */ n.createElement("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }), "Circle"),
    /* @__PURE__ */ n.createElement("label", { className: "radio-label" }, /* @__PURE__ */ n.createElement("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }), "Square")
  )), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone",
      fieldName: "lollipopColorStyle",
      label: "Lollipop Color Style",
      updateField: c,
      options: ["regular", "two-tone"]
    }
  ), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.lollipopSize ? t.lollipopSize : "small",
      fieldName: "lollipopSize",
      label: "Lollipop Size",
      updateField: c,
      options: ["small", "medium", "large"]
    }
  )), t.visualizationType === "Box Plot" && /* @__PURE__ */ n.createElement("fieldset", { className: "fieldset fieldset--boxplot" }, /* @__PURE__ */ n.createElement("legend", { className: "" }, "Box Plot Settings"), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.boxplot.borders,
      fieldName: "borders",
      section: "boxplot",
      label: "Box Plot Borders",
      updateField: c,
      options: ["true", "false"]
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.boxplot.plotOutlierValues,
      fieldName: "plotOutlierValues",
      section: "boxplot",
      label: "Plot Outliers",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.boxplot.plotNonOutlierValues,
      fieldName: "plotNonOutlierValues",
      section: "boxplot",
      label: "Plot non-outlier values",
      updateField: c
    }
  )), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.fontSize,
      fieldName: "fontSize",
      label: "Font Size",
      updateField: c,
      options: ["small", "medium", "large"]
    }
  ), s() && /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.barHasBorder,
      fieldName: "barHasBorder",
      label: "Bar Borders",
      updateField: c,
      options: ["true", "false"]
    }
  ), p() && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.animate,
      fieldName: "animate",
      label: "Animate Visualization",
      updateField: c
    }
  ), (((te = t.series) == null ? void 0 : te.some(
    (Q) => Q.type === "Line" || Q.type === "dashed-lg" || Q.type === "dashed-sm" || Q.type === "dashed-md"
  )) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.lineDatapointStyle,
      fieldName: "lineDatapointStyle",
      label: "Line Datapoint Style",
      updateField: c,
      options: ["hidden", "hover", "always show"]
    }
  ), /* @__PURE__ */ n.createElement(
    yt,
    {
      value: t.lineDatapointColor,
      fieldName: "lineDatapointColor",
      label: "Line Datapoint Color",
      updateField: c,
      options: ["Same as Line", "Lighter than Line"]
    }
  )), /* @__PURE__ */ n.createElement("label", { className: "header" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Header Theme"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, y.map((Q) => /* @__PURE__ */ n.createElement(
    "button",
    {
      title: Q,
      key: Q,
      onClick: ($) => {
        $.preventDefault(), r({ ...t, theme: Q });
      },
      className: t.theme === Q ? "selected " + Q : Q
    }
  )))), (m() || m()) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Chart Color Palette")), v() && /* @__PURE__ */ n.createElement(
    zp,
    {
      fieldName: "isPaletteReversed",
      size: "small",
      label: "Use selected palette in reverse order",
      updateField: c,
      value: t.isPaletteReversed
    }
  ), b() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", null, "Sequential"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, R.map((Q) => {
    const $ = {
      backgroundColor: a[Q][2]
    }, J = {
      backgroundColor: a[Q][3]
    }, ne = {
      backgroundColor: a[Q][5]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: Q,
        key: Q,
        onClick: (z) => {
          z.preventDefault(), r({ ...t, palette: Q });
        },
        className: t.palette === Q ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: $ }),
      /* @__PURE__ */ n.createElement("span", { style: J }),
      /* @__PURE__ */ n.createElement("span", { style: ne })
    );
  }))), m() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", null, "Non-Sequential"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, _.map((Q) => {
    const $ = {
      backgroundColor: a[Q][2]
    }, J = {
      backgroundColor: a[Q][4]
    }, ne = {
      backgroundColor: a[Q][6]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: Q,
        key: Q,
        onClick: (z) => {
          z.preventDefault(), r({ ...t, palette: Q });
        },
        className: t.palette === Q ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: $ }),
      /* @__PURE__ */ n.createElement("span", { style: J }),
      /* @__PURE__ */ n.createElement("span", { style: ne })
    );
  })), /* @__PURE__ */ n.createElement("span", null, "Colorblind Safe"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, U.map((Q) => {
    const $ = {
      backgroundColor: a[Q][2]
    }, J = {
      backgroundColor: a[Q][3]
    }, ne = {
      backgroundColor: a[Q][5]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: Q,
        key: Q,
        onClick: (z) => {
          z.preventDefault(), r({ ...t, palette: Q });
        },
        className: t.palette === Q ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: $ }),
      /* @__PURE__ */ n.createElement("span", { style: J }),
      /* @__PURE__ */ n.createElement("span", { style: ne })
    );
  })))), t.visualizationType === "Sankey" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.nodeColor.default,
      id: "storyNodeColor",
      name: "storyNodeColor",
      onChange: (Q) => j("nodeColor", Q.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "storyNodeColor" }, "Story Node Color")), /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.storyNodeFontColor || "red",
      id: "storyNodeFontColor",
      name: "storyNodeFontColor",
      onChange: (Q) => j("storyNodeFontColor", Q.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "storyNodeFontColor" }, "Story Node Font Color")), /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.linkColor.default,
      id: "linkColor",
      name: "linkColor",
      onChange: (Q) => j("linkColor", Q.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "linkColor" }, "Link Color"))), (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    zp,
    {
      section: "twoColor",
      fieldName: "isPaletteReversed",
      size: "small",
      label: "Use selected palette in reverse order",
      updateField: c,
      value: t.twoColor.isPaletteReversed
    }
  ), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, C.map((Q) => {
    const $ = {
      backgroundColor: i[Q][0]
    }, J = {
      backgroundColor: i[Q][1]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: Q,
        key: Q,
        onClick: (ne) => {
          ne.preventDefault(), r({ ...t, twoColor: { ...t.twoColor, palette: Q } });
        },
        className: t.twoColor.palette === Q ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { className: "two-color", style: $ }),
      /* @__PURE__ */ n.createElement("span", { className: "two-color", style: J })
    );
  }))), E() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    je,
    {
      value: t.dataCutoff,
      type: "number",
      fieldName: "dataCutoff",
      className: "number-narrow",
      label: "Data Cutoff",
      updateField: c,
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.')))
    }
  )), A() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ n.createElement(
    je,
    {
      type: "number",
      value: t.barHeight || "25",
      fieldName: "barHeight",
      label: " Bar Thickness",
      updateField: c,
      min: 15
    }
  ), (t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    je,
    {
      value: t.barThickness,
      type: "number",
      fieldName: "barThickness",
      label: "Bar Thickness",
      updateField: c
    }
  ), S() && /* @__PURE__ */ n.createElement(
    je,
    {
      type: "number",
      value: t.barSpace || "15",
      fieldName: "barSpace",
      label: "Bar Space",
      updateField: c,
      min: 0
    }
  ), (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.topAxis.hasLine,
      section: "topAxis",
      fieldName: "hasLine",
      label: "Add Top Axis Line",
      updateField: c
    }
  ), t.visualizationType === "Spark Line" && /* @__PURE__ */ n.createElement("div", { className: "cove-accordion__panel-section checkbox-group" }, /* @__PURE__ */ n.createElement(
    Je,
    {
      value: o == null ? void 0 : o.border,
      section: "visual",
      fieldName: "border",
      label: "Show Border",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      value: o == null ? void 0 : o.borderColorTheme,
      section: "visual",
      fieldName: "borderColorTheme",
      label: "Use Border Color Theme",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      value: o == null ? void 0 : o.accent,
      section: "visual",
      fieldName: "accent",
      label: "Use Accent Style",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      value: o == null ? void 0 : o.background,
      section: "visual",
      fieldName: "background",
      label: "Use Theme Background Color",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      value: o == null ? void 0 : o.hideBackgroundColor,
      section: "visual",
      fieldName: "hideBackgroundColor",
      label: "Hide Background Color",
      updateField: c
    }
  )), (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.showLineSeriesLabels,
      fieldName: "showLineSeriesLabels",
      label: "Append Series Name to End of Line Charts",
      updateField: c
    }
  ), (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.colorMatchLineSeriesLabels,
      fieldName: "colorMatchLineSeriesLabels",
      label: "Match Series Color to Name at End of Line Charts",
      updateField: c
    }
  ), T() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Je,
    {
      value: o.verticalHoverLine,
      fieldName: "verticalHoverLine",
      section: "visual",
      label: "Vertical Hover Line",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Je,
    {
      value: o.horizontalHoverLine,
      fieldName: "horizontalHoverLine",
      section: "visual",
      label: "Horizontal Hover Line",
      updateField: c
    }
  )), x() && /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Tooltip Opacity"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      value: t.tooltips.opacity ? t.tooltips.opacity : 100,
      onChange: (Q) => r({
        ...t,
        tooltips: {
          ...t.tooltips,
          opacity: Q.target.value
        }
      })
    }
  )), N() && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.tooltips.singleSeries,
      fieldName: "singleSeries",
      section: "tooltips",
      label: "SHOW HOVER FOR SINGLE DATA SERIES",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "No Data Message"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: t.chartMessage.noData ? t.chartMessage.noData : "",
      onChange: (Q) => r({
        ...t,
        chartMessage: {
          ...t.chartMessage,
          noData: Q.target.value
        }
      })
    }
  ))));
}, Iw = (e) => {
  var s, p, m, y, x;
  const { config: t, updateConfig: r } = ue.useContext(gt), a = (s = t.data) == null ? void 0 : s[0], { updateField: i } = ue.useContext(wp);
  if (t.visualizationType !== "Sankey")
    return;
  const o = (T, S, A) => {
    let E = [];
    a != null && a.storyNodeText && (E = [...a == null ? void 0 : a.storyNodeText]), E[A][T] = S, r({
      ...t,
      sankey: {
        ...t.sankey,
        data: {
          ...t.sankey.data,
          storyNodeText: E
        }
      }
    });
  }, d = () => {
    const T = a;
    T.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), r({
      ...t,
      sankey: {
        ...t.sankey,
        data: [{ ...T }]
      }
    });
  }, c = (T) => {
    const S = a;
    S.storyNodeText.splice(T, 1), r({ ...t, sankey: { ...t.sankey, data: { ...S } } });
  };
  return /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, "Sankey Settings")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("p", null, "Node stories can provide additional details to support public health messaging. COVE can display a maximum of 3 node stories."), (a == null ? void 0 : a.storyNodeText) && (a == null ? void 0 : a.storyNodeText.map(({ StoryNode: T, segmentTextBefore: S, segmentTextAfter: A }, E) => /* @__PURE__ */ n.createElement(
    "div",
    {
      key: E,
      style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" }
    },
    /* @__PURE__ */ n.createElement("label", null, "Story Node Text", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: T,
        fieldName: "StoryNode",
        label: "StoryNode",
        onChange: (b) => o("StoryNode", b.target.value, E)
      }
    )),
    /* @__PURE__ */ n.createElement("label", null, "Story Text Before", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: S,
        fieldName: "segmentTextBefore",
        label: "Segment Text Before",
        onChange: (b) => o("segmentTextBefore", b.target.value, E)
      }
    )),
    /* @__PURE__ */ n.createElement("label", null, "Story Text After", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: A,
        fieldName: "segmentTextAfter",
        label: "Segment Text After",
        onChange: (b) => o("segmentTextAfter", b.target.value, E)
      }
    )),
    /* @__PURE__ */ n.createElement(Rc, { onClick: (b) => c(E), className: "btn btn-danger full-width" }, "Remove Story Node")
  ))), ((p = a == null ? void 0 : a.storyNodeText) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-primary full-width",
      onClick: (T) => {
        T.preventDefault(), d();
      }
    },
    "Add StoryNode"
  ), ((x = (y = (m = t.data) == null ? void 0 : m[0]) == null ? void 0 : y.tooltips) == null ? void 0 : x.length) > 0 && /* @__PURE__ */ n.createElement(
    Je,
    {
      value: t.enableTooltips,
      fieldName: "enableTooltips",
      label: "Enable Tooltips",
      updateField: i
    }
  )));
};
const Hw = (e) => {
  var c, s, p;
  const { updateConfig: t, config: r, svgRef: a } = ue.useContext(gt), i = (m, y, x) => {
    var E;
    const T = (E = document.querySelector(".chart-container  > svg")) == null ? void 0 : E.getBoundingClientRect(), S = [T == null ? void 0 : T.width, T == null ? void 0 : T.height], A = [...r == null ? void 0 : r.annotations];
    A[x][y] = m, A[x].savedDimensions = S, t({
      ...r,
      annotations: A
    });
  }, o = () => {
    var T, S, A, E, b, v, N, C, R, _;
    const m = [
      ((A = (S = (T = a == null ? void 0 : a.current) == null ? void 0 : T.width) == null ? void 0 : S.baseVal) == null ? void 0 : A.value) || ((E = a == null ? void 0 : a.current) == null ? void 0 : E.width),
      ((N = (v = (b = a == null ? void 0 : a.current) == null ? void 0 : b.height) == null ? void 0 : v.baseVal) == null ? void 0 : N.value) || ((C = a == null ? void 0 : a.current) == null ? void 0 : C.height)
    ], y = {
      text: "New Annotation",
      snapToNearestPoint: !1,
      fontSize: 16,
      bezier: 10,
      show: {
        desktop: !0,
        tablet: !0,
        mobile: !0
      },
      connectorType: "line",
      colors: {
        label: "black",
        connector: "black",
        marker: "black"
      },
      selected: !0,
      anchor: {
        vertical: !1,
        horizontal: !1
      },
      marker: "arrow",
      edit: {
        subject: !0,
        label: !0
      },
      seriesKey: "",
      x: 50,
      y: Number((m == null ? void 0 : m[1]) / 2),
      xKey: r.xAxis.type === "date" ? new Date((_ = (R = r == null ? void 0 : r.data) == null ? void 0 : R[0]) == null ? void 0 : _[r.xAxis.dataKey]).getTime() : r.xAxis.type === "categorical" ? "1/15/2016" : "",
      yKey: "",
      dx: 20,
      dy: -20,
      opacity: "100",
      savedDimensions: m,
      connectionType: "line"
    }, x = Array.isArray(r.annotations) ? r.annotations : [];
    t({
      ...r,
      annotations: [...x, y]
    });
  }, d = (m) => {
    const y = r.annotations.filter((x, T) => T !== m);
    t({
      ...r,
      annotations: y
    });
  };
  return /* @__PURE__ */ n.createElement(Pu, { key: e.name }, /* @__PURE__ */ n.createElement(Pu.Section, { title: e.name, key: e.name }, /* @__PURE__ */ n.createElement("label", { key: "key-1" }, "Show Annotation Dropdown", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "checkbox",
      checked: ((c = r == null ? void 0 : r.general) == null ? void 0 : c.showAnnotationDropdown) || !1,
      onChange: (m) => {
        t({
          ...r,
          general: {
            ...r.general,
            showAnnotationDropdown: m.target.checked
          }
        });
      }
    }
  )), r.general.showAnnotationDropdown && /* @__PURE__ */ n.createElement("label", { key: "key-2" }, "Annotation Dropdown Title:", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      style: { marginBottom: "10px" },
      value: (s = r == null ? void 0 : r.general) == null ? void 0 : s.annotationDropdownText,
      onChange: (m) => {
        t({
          ...r,
          general: {
            ...r.general,
            annotationDropdownText: m.target.value
          }
        });
      }
    }
  )), (r == null ? void 0 : r.annotations) && (r == null ? void 0 : r.annotations.map((m, y) => {
    var x, T, S, A, E, b, v, N;
    return /* @__PURE__ */ n.createElement(Pu, { key: y }, /* @__PURE__ */ n.createElement(
      Pu.Section,
      {
        title: m.text ? m.text.substring(0, 15) + "..." : `Annotation ${y + 1}`
      },
      /* @__PURE__ */ n.createElement("div", { className: "annotation-group" }, /* @__PURE__ */ n.createElement("label", null, "Annotation Text:", /* @__PURE__ */ n.createElement(
        "textarea",
        {
          rows: 5,
          value: m.text,
          onChange: (C) => i(C.target.value, "text", y)
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Opacity", /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "range",
          onChange: (C) => {
            const R = lt.cloneDeep(r == null ? void 0 : r.annotations);
            R[y].opacity = C.target.value, t({
              ...r,
              annotations: R
            });
          },
          value: ((T = (x = r == null ? void 0 : r.annotations) == null ? void 0 : x[y]) == null ? void 0 : T.opacity) || "100"
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Edit Subject", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "checkbox",
          checked: ((A = (S = r == null ? void 0 : r.annotations[y]) == null ? void 0 : S.edit) == null ? void 0 : A.subject) || !1,
          onChange: (C) => {
            const R = lt.cloneDeep(r == null ? void 0 : r.annotations);
            R[y].edit.subject = C.target.checked, t({
              ...r,
              annotations: R
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Edit Label", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "checkbox",
          checked: ((b = (E = r == null ? void 0 : r.annotations[y]) == null ? void 0 : E.edit) == null ? void 0 : b.label) || !1,
          onChange: (C) => {
            const R = lt.cloneDeep(r == null ? void 0 : r.annotations);
            R[y].edit.label = C.target.checked, t({
              ...r,
              annotations: R
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Connection Type:", /* @__PURE__ */ n.createElement(
        "select",
        {
          key: "annotation-connection-type",
          onChange: (C) => {
            const R = lt.cloneDeep(r == null ? void 0 : r.annotations);
            R[y].connectionType = C.target.value, t({
              ...r,
              annotations: R
            });
          },
          value: (v = r == null ? void 0 : r.annotations[y]) == null ? void 0 : v.connectionType
        },
        /* @__PURE__ */ n.createElement("option", { key: "select", value: "select" }, "Select"),
        ["curve", "line", "elbow", "none"].map((C, R) => /* @__PURE__ */ n.createElement("option", { key: C, value: C }, C))
      )), m.connectionType === "curve" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, "Curve Control", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "range",
          min: "-20",
          max: "20",
          value: ((N = r == null ? void 0 : r.annotations[y]) == null ? void 0 : N.bezier) || 0,
          onChange: (C) => {
            const R = lt.cloneDeep(r == null ? void 0 : r.annotations);
            R[y].bezier = C.target.value, t({
              ...r,
              annotations: R
            });
          }
        }
      ))), /* @__PURE__ */ n.createElement("label", null, "Marker", /* @__PURE__ */ n.createElement(
        "select",
        {
          key: "annotation-marker",
          value: m.marker,
          onChange: (C) => {
            const R = lt.cloneDeep(r == null ? void 0 : r.annotations);
            R[y].marker = C.target.value, t({
              ...r,
              annotations: R
            });
          }
        },
        ["arrow", "circle"].map((C, R) => /* @__PURE__ */ n.createElement("option", { key: `col-${R}` }, C))
      )), /* @__PURE__ */ n.createElement(Rc, { className: "btn btn-danger full-width", onClick: () => d(y) }, "Delete Annotation"))
    ));
  })), ((p = r == null ? void 0 : r.annotations) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ n.createElement("button", { onClick: o, className: "btn btn-primary mt-2 full-width" }, "Add Annotation")));
}, ma = {
  ForestPlot: bw,
  Series: Xr,
  Regions: Fw,
  General: Mw,
  BoxPlot: zw,
  Visual: $w,
  Sankey: Iw,
  Annotate: Hw
};
const gm = [
  ["*", "Asterisk"],
  ["†", "Dagger"],
  ["§", "Section Symbol"],
  ["¶", "Paragraph Symbol"]
], Vw = gm.concat(gm.map(([e, t]) => [e + e, "Double " + t])), vm = lt.fromPairs(lt.map(Vw, ([e, t]) => [t, e])), Ww = new zm(), xm = (e, t) => {
  for (let r = 0; r < e.length; r++) {
    let a = Object.keys(e[r]), i = !0;
    for (let o = 0; o < a.length; o++)
      if (e[r][a[o]] !== t[a[o]]) {
        i = !1;
        break;
      }
    if (i)
      return r;
  }
  return -1;
}, jw = (e, t, r) => {
  var i;
  const a = lt.cloneDeep(e);
  if (a.rankByValue = t, e.rankByValue && !t) {
    const o = (i = e == null ? void 0 : e.xAxis) != null && i.dataKey ? Ww.cleanData(e.data, e.xAxis.dataKey) : e.data, d = r.sort((c, s) => {
      const p = xm(o, c), m = xm(o, s);
      return p - m;
    });
    return [a, d];
  }
  return [a];
}, Uw = ({ config: e, updateConfig: t, data: r }) => {
  var E, b, v;
  const a = e.visualizationType === "Combo", i = ((E = e.runtime.lineSeriesKeys) == null ? void 0 : E.length) > 0, o = ((b = e.runtime.barSeriesKeys) == null ? void 0 : b.length) > 0, d = a && i, c = a && o, s = () => lt.uniq(lt.flatMap(r, lt.keys)), p = () => e.visualizationType === "Line" || d ? ["effect", "suppression"] : ["suppression"], m = {
    "Dashed Small": "- - -",
    "Dashed Medium": "– –",
    "Dashed Large": "— –",
    "Open Circles": "◯",
    "Filled Circles": ""
  }, y = (N) => {
    const C = Object.keys(m);
    return N === "suppression" ? C.slice(0, -2) : C;
  }, x = () => {
    if (e.visualizationType === "Bar" || c)
      return Object.keys(vm);
  };
  let T = (N) => {
    let C = [];
    e.preliminaryData && (C = [...e.preliminaryData]), C.splice(N, 1), t({ ...e, preliminaryData: C });
  }, S = () => {
    const N = e.visualizationType === "Line" ? "effect" : "suppression";
    let C = e.preliminaryData ? [...e.preliminaryData] : [];
    const R = {
      type: N,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: "",
      hideBarSymbol: !1,
      hideLineStyle: !1,
      circleSize: 6,
      displayGray: !0
    };
    C.push(R), t({ ...e, preliminaryData: C });
  }, A = (N, C, R) => {
    let _ = [];
    e.preliminaryData && (_ = [...e.preliminaryData]), _[R][N] = C, N === "symbol" && (_[R].iconCode = vm[C]), N === "style" && (_[R].lineCode = m[C]), t({ ...e, preliminaryData: _ });
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.preliminaryData && ((v = e.preliminaryData) == null ? void 0 : v.map(
    ({
      displayGray: N,
      circleSize: C,
      column: R,
      displayLegend: _,
      displayTable: U,
      displayTooltip: j,
      label: te,
      seriesKey: Q,
      style: $,
      symbol: J,
      type: ne,
      value: z,
      hideBarSymbol: W,
      hideLineStyle: ie
    }, ae) => {
      var oe, K;
      return /* @__PURE__ */ n.createElement("div", { key: `preliminaryData-${ae}`, className: "edit-block" }, /* @__PURE__ */ n.createElement("p", null, " ", ne === "suppression" ? "Suppressed" : "Effect", " Data"), /* @__PURE__ */ n.createElement(
        "button",
        {
          type: "button",
          className: "btn btn-danger",
          onClick: (Y) => {
            Y.preventDefault(), T(ae);
          }
        },
        "Remove"
      ), /* @__PURE__ */ n.createElement(
        yt,
        {
          value: ne,
          initial: e.visualizationType == "Bar" ? "" : "Select",
          fieldName: "type",
          label: "Type",
          updateField: (Y, X, q, ce) => A(q, ce, ae),
          options: p()
        }
      ), ne === "suppression" ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        yt,
        {
          tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", 'Without a selected "Data Series", the suppression symbol will be applied for all series in the current dataset visualization. However, choosing a specific "data series" will isolate the suppression to that series.'))),
          value: R,
          initial: "Select",
          fieldName: "column",
          label: "Add Data Series",
          updateField: (Y, X, q, ce) => A(q, ce, ae),
          options: (oe = e.runtime) == null ? void 0 : oe.seriesKeys
        }
      ), /* @__PURE__ */ n.createElement(
        je,
        {
          value: z,
          fieldName: "value",
          label: "Suppressed Data  Value",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      ), (d || e.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        yt,
        {
          tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "The recommended approach for presenting data is to include a footnote indicating any data suppression."))),
          value: $,
          initial: "Select",
          fieldName: "style",
          label: "suppression line style",
          updateField: (Y, X, q, ce) => A(q, ce, ae),
          options: y(ne)
        }
      ), /* @__PURE__ */ n.createElement(
        Je,
        {
          value: ie,
          fieldName: "hideLineStyle",
          label: "Hide Suppressed line Style",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      )), (c || e.visualizationType === "Bar") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        yt,
        {
          tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "A symbol is ", /* @__PURE__ */ n.createElement("i", null, "required"), ' to indicate suppressed data. We suggest "double asterisks." If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'))),
          value: J,
          initial: "Select",
          fieldName: "symbol",
          label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
          updateField: (Y, X, q, ce) => A(q, ce, ae),
          options: x()
        }
      ), /* @__PURE__ */ n.createElement(
        Je,
        {
          value: W,
          fieldName: "hideBarSymbol",
          label: "Hide Suppressed Bar Symbol  ",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      )), /* @__PURE__ */ n.createElement(
        je,
        {
          tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "This label will display in the tooltip and legend."))),
          value: te || "Suppressed",
          fieldName: "label",
          label: "Suppressed Data Label",
          placeholder: "",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      ), /* @__PURE__ */ n.createElement(
        Je,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting the "Display In Tooltips" option prevents suppressed values from appearing in tooltips.'))),
          value: j,
          fieldName: "displayTooltip",
          label: "Display in tooltips",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      ), /* @__PURE__ */ n.createElement(
        Je,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.'))),
          value: _,
          fieldName: "displayLegend",
          label: "Display in legend",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      ), /* @__PURE__ */ n.createElement(
        Je,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.'))),
          value: U,
          fieldName: "displayTable",
          label: "Display in table",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      ), /* @__PURE__ */ n.createElement(
        Je,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will apply to chart, tooltip hover, legend, and data table."))),
          value: N,
          fieldName: "displayGray",
          label: "Highlight Suppressed Data In Gray",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        yt,
        {
          value: Q,
          initial: "Select",
          fieldName: "seriesKey",
          label: "ASSOCIATE TO SERIES",
          updateField: (Y, X, q, ce) => A(q, ce, ae),
          options: e.runtime.lineSeriesKeys ?? ((K = e.runtime) == null ? void 0 : K.seriesKeys)
        }
      ), /* @__PURE__ */ n.createElement(
        yt,
        {
          value: R,
          initial: "Select",
          fieldName: "column",
          label: "COLUMN WITH CONFIGURATION VALUE",
          updateField: (Y, X, q, ce) => A(q, ce, ae),
          options: s()
        }
      ), /* @__PURE__ */ n.createElement(
        je,
        {
          tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "If 'Filled Circles' is selected as the style, this field is optional, and the style 'Filled Circles' will apply to all points within the associated series data."))),
          value: z,
          fieldName: "value",
          label: "VALUE TO TRIGGER",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      ), /* @__PURE__ */ n.createElement(
        yt,
        {
          value: $,
          initial: "Select",
          fieldName: "style",
          label: "Style",
          updateField: (Y, X, q, ce) => A(q, ce, ae),
          options: y(ne)
        }
      ), $.includes("Circles") && /* @__PURE__ */ n.createElement(
        je,
        {
          className: "number-narrow",
          type: "number",
          value: C,
          fieldName: "circleSize",
          label: "circle size",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      ), $ !== "Filled Circles" && /* @__PURE__ */ n.createElement(
        je,
        {
          value: te,
          fieldName: "label",
          label: "Label",
          placeholder: "",
          updateField: (Y, X, q, ce) => A(q, ce, ae)
        }
      )));
    }
  )), /* @__PURE__ */ n.createElement("button", { type: "button", onClick: S, className: "btn btn-primary full-width" }, e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line"));
}, Kw = ({ config: e, updateConfig: t, display: r }) => {
  var p, m, y, x;
  const a = (p = e == null ? void 0 : e.yAxis) == null ? void 0 : p.maxValue, i = ((y = (m = e == null ? void 0 : e.yAxis) == null ? void 0 : m.categories) == null ? void 0 : y.reduce((T, S) => T + (parseFloat(S.height) || 0), 0)) || 0, o = (T) => {
    let S = [];
    e.yAxis.categories && (S = [...e.yAxis.categories]), S.splice(T, 1), t({ ...e, yAxis: { ...e.yAxis, categories: S } });
  }, d = () => {
    var E, b;
    const T = (b = (E = e.yAxis) == null ? void 0 : E.categories) == null ? void 0 : b.length, S = 0.4;
    return Wa("#ddd").darken(S * T).hex();
  }, c = () => {
    const T = e.yAxis.categories ? [...e.yAxis.categories] : [], S = {
      label: "Label " + Number(T.length + 1),
      height: "",
      color: d()
    };
    T.push(S), t({ ...e, yAxis: { ...e.yAxis, categories: T } });
  }, s = (T, S, A) => {
    let E = [];
    e.yAxis.categories && (E = [...e.yAxis.categories]), E[A][T] = S, t({ ...e, yAxis: { ...e.yAxis, categories: E } });
  };
  return r ? /* @__PURE__ */ n.createElement(n.Fragment, null, e.yAxis.type === "categorical" && ((x = e.yAxis.categories) == null ? void 0 : x.map(({ label: T, color: S, height: A }, E) => /* @__PURE__ */ n.createElement("div", { key: `preliminaryData-${E}`, className: "edit-block" }, /* @__PURE__ */ n.createElement("p", null, "Axis Category ", E + 1), /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-danger",
      onClick: (b) => {
        b.preventDefault(), o(E);
      }
    },
    "Remove"
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", "Category Height will be ignored for the last category. The last category will fill the rest of the axis height."))),
      type: "number",
      value: A,
      fieldName: "height",
      label: "Category Height",
      updateField: (b, v, N, C) => s(N, C, E)
    }
  ), Number(i) > Number(a) && e.yAxis.categories.length - 1 === E && /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block", fontSize: "15px" } }, "Update Max value to show all categories"), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
    je,
    {
      value: S,
      fieldName: "color",
      label: "Color",
      updateField: (b, v, N, C) => s(N, C, E)
    }
  ), /* @__PURE__ */ n.createElement(
    je,
    {
      value: T,
      fieldName: "label",
      label: "Label",
      updateField: (b, v, N, C) => s(N, C, E)
    }
  ))))), /* @__PURE__ */ n.createElement("button", { type: "button", onClick: c, className: "btn btn-primary full-width" }, "Add Axis Category")) : /* @__PURE__ */ n.createElement(n.Fragment, null);
}, Yw = () => {
  var Ot, tt, ut, It, Rt, Ht, Ft, hn, mn, Mt, kn, wn, On, Nn, Ln, fn, Fn, Zt, we, g, P, M, Z, xe;
  const {
    config: e,
    updateConfig: t,
    tableData: r,
    transformedData: a,
    loading: i,
    colorScale: o,
    colorPalettes: d,
    twoColorPalette: c,
    unfilteredData: s,
    excludedData: p,
    isDashboard: m,
    setParentConfig: y,
    missingRequiredSections: x,
    isDebug: T,
    setFilteredData: S,
    lineOptions: A,
    rawData: E,
    highlight: b,
    highlightReset: v,
    dimensions: N
  } = ue.useContext(gt), { minValue: C, maxValue: R, existPositiveValue: _, isAllLine: U } = Vc(e, s), j = { data: a, config: e }, { leftMax: te, rightMax: Q } = pg(j), {
    visHasAnchors: $,
    visHasBrushChart: J,
    visHasCategoricalAxis: ne,
    visHasLegend: z,
    visHasLegendAxisAlign: W,
    visHasLegendColorCategory: ie,
    visHasSelectableLegendValues: ae,
    visSupportsDateCategoryAxis: oe,
    visSupportsDateCategoryAxisLabel: K,
    visSupportsDateCategoryAxisLine: Y,
    visSupportsDateCategoryAxisMax: X,
    visSupportsDateCategoryAxisMin: q,
    visSupportsDateCategoryAxisPadding: ce,
    visSupportsDateCategoryAxisTicks: ge,
    visSupportsDateCategoryHeight: De,
    visSupportsDateCategoryNumTicks: me,
    visSupportsDateCategoryTickRotation: Fe,
    visSupportsDynamicSeries: Ue,
    visSupportsFilters: Te,
    visSupportsLeftValueAxis: ve,
    visSupportsPreliminaryData: Ae,
    visSupportsRankByValue: fe,
    visSupportsResponsiveTicks: ze,
    visSupportsValueAxisGridLines: Oe,
    visSupportsValueAxisLabels: Ve,
    visSupportsValueAxisLine: Ze,
    visSupportsValueAxisMax: Ie,
    visSupportsValueAxisMin: qe,
    visSupportsValueAxisTicks: et,
    visSupportsYPadding: He
  } = zs();
  ue.useEffect(() => {
    let B = [];
    e.series && (B = e.series.map((I) => ({
      ...I,
      type: e.visualizationType === "Combo" ? "Bar" : e.visualizationType ? e.visualizationType : "Bar",
      axis: "Left"
    }))), t({
      ...e,
      series: B
    });
  }, [e.visualizationType]), ue.useEffect(() => {
    e.visualizationType === "Scatter Plot" && t({
      ...e,
      xAxis: {
        ...e.xAxis,
        type: "continuous"
      }
    });
  }, []), ue.useEffect(() => {
    e.visualizationType !== "Bar" && t({ ...e, tooltips: { ...e.tooltips, singleSeries: !1 } });
  }, [e.visualizationType]);
  const { hasRightAxis: Ge } = Ep({ config: e, yMax: e.yAxis.size, data: e.data, updateConfig: t }), Le = (B, I) => ({
    ...I
  }), _e = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, st = (B) => {
    B.orientation === "horizontal" && (B.labels = !1), B.table.show === void 0 && (B.table.show = !m), B.visualizationType === "Combo" && (B.orientation = "vertical"), Rn(B.xAxis) && !B.xAxis.padding && (B.xAxis.padding = 0), B.visualizationType === "Line" && (B.visualizationSubType = "regular", B.barStyle = "flat", B.isLollipopChart = !1);
  }, Ee = (B, I, ee, be) => {
    if (T && console.log(
      "#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue",
      B,
      I,
      ee,
      be
    ), B === "boxplot" && (I === "legend" || I === "labels")) {
      t({
        ...e,
        [B]: {
          ...e[B],
          [I]: {
            ...e.boxplot[I],
            [ee]: be
          }
        }
      });
      return;
    }
    const We = (Bt) => Bt === 0 ? !0 : !!Bt;
    if (B === "columns" && We(I) && We(ee)) {
      t({
        ...e,
        columns: {
          ...e.columns,
          [I]: {
            ...e.columns[I],
            [ee]: be
          }
        }
      });
      return;
    }
    if (B === null && I === null) {
      We(ee) || console.error("fieldName is required");
      let Bt = { ...e, [ee]: be };
      st(Bt), t(Bt);
      return;
    }
    const Qe = Array.isArray(e[B]);
    let St = Qe ? [...e[B], be] : { ...e[B], [ee]: be };
    We(I) && (Qe ? (St = [...e[B]], St[I] = { ...St[I], [ee]: be }) : typeof be == "string" ? St[I] = be : We(ee) && (St = { ...e[B], [I]: { ...e[B][I], [ee]: be } }));
    let Dt = { ...e, [B]: St };
    st(Dt), t(Dt);
  }, [rt, pt] = ue.useState(!0), [ft, wt] = ue.useState(!1);
  if (i)
    return null;
  const zt = (B) => {
    t({
      ...e,
      lollipopShape: B
    });
  }, Jt = (B) => {
    let I = e.series ? [...e.series] : [], ee = Array.from(new Set(a.map((We) => We[B]))), be = [];
    ee.forEach((We) => {
      be.push({ key: We });
    }), e.visualizationType === "Forecasting" ? I.push({
      dataKey: B,
      type: e.visualizationType,
      stages: be,
      stageColumn: B,
      axis: "Left",
      tooltip: !0
    }) : I.push({ dataKey: B, type: e.visualizationType, axis: "Left", tooltip: !0 }), t({ ...e, series: I });
  }, jt = (B) => {
    let I = [...e.exclusions.keys];
    I.push(B);
    let ee = { ...e.exclusions, keys: I };
    t({ ...e, exclusions: ee });
  }, on = (B) => {
    let I = -1, ee = [...e.exclusions.keys];
    for (let be = 0; be < ee.length; be++)
      if (ee[be] === B) {
        I = be;
        break;
      }
    if (I !== -1) {
      ee.splice(I, 1);
      let be = { ...e.exclusions, keys: ee }, We = { ...e, exclusions: be };
      ee.length === 0 && delete We.exclusions.keys, t(We);
    }
  }, _t = (B = !0) => {
    let I = {};
    if (s.forEach((ee) => {
      Object.keys(ee).forEach((be) => I[be] = !0);
    }), B) {
      const { lower: ee, upper: be } = e.confidenceKeys || {};
      Object.keys(I).forEach((We) => {
        (e.series && e.series.filter((Qe) => Qe.dataKey === We).length > 0 || e.confidenceKeys && Object.keys(e.confidenceKeys).includes(We) && (ee && be || ee || be) && We !== ee && We !== be) && delete I[We];
      });
    }
    return Object.keys(I);
  }, tn = (B) => {
    const I = [];
    switch (B) {
      case "style":
        I.push("circles", "boxes"), e.visualizationType === "Bar" && (!["right", "left"].includes(e.legend.position) || !e.legend.position) && I.push("gradient"), e.visualizationType === "Line" && I.push("lines");
        break;
      case "subStyle":
        e.visualizationType === "Bar" ? I.push("linear blocks") : I.push("linear blocks", "smooth");
        break;
    }
    return I;
  }, $t = (B) => {
    if (!B)
      return [];
    const I = /* @__PURE__ */ new Set();
    for (let ee = 0; ee < B.length; ee++)
      for (const [be] of Object.entries(B[ee]))
        I.add(be);
    return Array.from(I);
  }, Ut = (B, I = !1) => {
    let ee = [];
    return p.forEach((be) => {
      ee.push(be[B]);
    }), I ? [...new Set(ee)] : ee;
  }, bt = () => {
    pt(!rt), t({
      ...e,
      showEditorPanel: !rt
    });
  }, mt = () => {
    let B = JSON.parse(JSON.stringify(e));
    return x() === !1 && delete B.newViz, delete B.runtime, B;
  };
  ue.useEffect(() => {
    if (y) {
      const B = mt();
      y(B);
    }
  }, [e]), ue.useEffect(() => {
    const B = e.xAxis.anchors.length > 0 ? e.xAxis.anchors : [], I = e.yAxis.anchors.length > 0 ? e.yAxis.anchors : [];
    t({
      ...e,
      xAxis: {
        ...e.xAxis,
        anchors: I
      },
      yAxis: {
        ...e.yAxis,
        anchors: B
      }
    });
  }, [e.orientation]), ue.useEffect(() => {
    e.visualizationType === "Paired Bar" && t({
      ...e,
      orientation: "horizontal"
    });
  }, []), ue.useEffect(() => {
    e.orientation === "horizontal" && t({
      ...e,
      lollipopShape: e.lollipopShape
    });
  }, [e.isLollipopChart, e.lollipopShape]), ue.useEffect(() => {
    e.visualizationType === "Deviation Bar" && t({ ...e, orientation: "horizontal" });
  }, [e.visualizationType]);
  const ln = ue.useCallback(() => {
    const B = [...e.exclusions.keys];
    return /* @__PURE__ */ n.createElement("ul", { className: "series-list" }, B.map((I, ee) => /* @__PURE__ */ n.createElement("li", { key: I }, /* @__PURE__ */ n.createElement("div", { className: "series-list__name", "data-title": I }, /* @__PURE__ */ n.createElement("div", { className: "series-list__name--text" }, I)), /* @__PURE__ */ n.createElement("button", { className: "series-list__remove", onClick: () => on(I) }, "×"))));
  }, [e]), Yt = (B, I) => {
    let ee = e.series, [be] = ee.splice(B, 1);
    ee.splice(I, 0, be), t({ ...e, series: ee });
  };
  e.isLollipopChart && ((Ot = e == null ? void 0 : e.series) == null ? void 0 : Ot.length) > 1 && (e.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), e.visualizationType === "Paired Bar" && ((tt = e == null ? void 0 : e.series) == null ? void 0 : tt.length) !== 2 && (e.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), e.visualizationType === "Deviation Bar" && ((ut = e == null ? void 0 : e.series) == null ? void 0 : ut.length) !== 1 && (e.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), e.isLollipopChart && ((It = e == null ? void 0 : e.series) == null ? void 0 : It.length) === 0 && (e.runtime.editorErrorMessage = "Add a data series");
  const xt = e.orientation === "horizontal" ? "xAxis" : "yAxis", [Gt, Sn] = ue.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), At = () => {
    const B = e[xt].max, I = e[xt].rightMax;
    let ee = "", be = "";
    if (e.visualizationType !== "Combo")
      switch (!0) {
        case (B && parseFloat(B) < parseFloat(R) && _):
          ee = "Max value must be more than " + R;
          break;
        case (B && parseFloat(B) < 0 && !_):
          ee = "Value must be more than or equal to 0";
          break;
        default:
          ee = "";
      }
    if (e.visualizationType === "Combo")
      switch (!0) {
        case (B && parseFloat(B) < te):
          ee = "Max value must be more than " + te;
          break;
        case (I && parseFloat(I) < Q):
          be = "Max value must be more than " + Q;
          break;
        case (B && parseFloat(B) < 0 && !_):
          ee = "Value must be more than or equal to 0";
          break;
        default:
          ee = "";
      }
    Sn((We) => ({ ...We, maxMsg: ee, rightMaxMessage: be }));
  }, nn = () => {
    const B = parseFloat(e[xt].min);
    let I = Number(C), ee = "";
    switch (!0) {
      case (e.useLogScale && ["Line", "Combo", "Bar"].includes(e.visualizationType) && B < 0):
        ee = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((e.visualizationType === "Line" || e.visualizationType === "Spark Line") && B > I):
        ee = "Value should not exceed " + C;
        break;
      case (e.visualizationType === "Combo" && U && B > I):
        ee = "Value should not exceed " + C;
        break;
      case ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && !U) && I > 0 && B > 0):
        ee = e.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (e.visualizationType === "Deviation Bar" && B >= Math.min(I, e.xAxis.target)):
        ee = "Value must be less than " + Math.min(I, e.xAxis.target);
        break;
      case (e.visualizationType !== "Deviation Bar" && B && I < 0 && B > I):
        ee = "Value should not exceed " + C;
        break;
      default:
        ee = "";
    }
    Sn((be) => ({ ...be, minMsg: ee }));
  };
  ue.useEffect(() => {
    nn(), At();
  }, [C, R, e]);
  const Xt = ((Rt = e == null ? void 0 : e.dataKey) == null ? void 0 : Rt.includes("http://")) || ((Ht = e == null ? void 0 : e.dataKey) == null ? void 0 : Ht.includes("https://")), sn = () => {
    var B, I;
    if (T !== void 0 && T && !((B = e == null ? void 0 : e.xAxis) != null && B.dataKey)) {
      let ee = _t(!1);
      if (ee.includes("Date"))
        return "Date";
      if (ee.includes("Race"))
        return "Race";
      if (ee.includes("Month"))
        return "Month";
    }
    return ((I = e == null ? void 0 : e.xAxis) == null ? void 0 : I.dataKey) || "";
  }, Nt = () => {
    if (T !== void 0 && T && _t(!1).length > 0) {
      let B = _t(!1).filter((I) => I !== sn());
      if (B.length > 0)
        return B[0];
    }
    return "";
  };
  if (T && !e.xAxis.dataKey && (e.xAxis.dataKey = sn()), T && ((Ft = e == null ? void 0 : e.series) == null ? void 0 : Ft.length) === 0) {
    let B = Nt();
    B !== "" && Jt(B), T && console.log("### COVE DEBUG: Chart: Setting default datacol=", B);
  }
  const xn = [
    "Bump Chart",
    "Area Chart",
    "Combo",
    "Line",
    "Bar",
    "Forecasting",
    "Scatter Plot",
    "Paired Bar",
    "Deviation Bar"
  ], dn = [
    /* @__PURE__ */ n.createElement("option", { value: "", key: "Select Option" }, "- Select Option -")
  ];
  if (e.data && e.series) {
    Object.keys(((hn = e.data) == null ? void 0 : hn[0]) || []).map((I) => {
      const ee = e == null ? void 0 : e.series.some((be) => be.dataKey === I);
      if (I !== e.xAxis.dataKey && !ee)
        return dn.push(
          /* @__PURE__ */ n.createElement("option", { value: I, key: I }, I)
        );
    });
    let B = {};
    e.data.forEach((I) => {
      Object.keys(I).forEach((ee) => {
        B[ee] = B[ee] || [];
        const be = typeof I[ee] == "number" ? I[ee].toString() : I[ee];
        B[ee].indexOf(be) === -1 && B[ee].push(be);
      });
    });
  }
  if (!e.data && a) {
    if (!a[0])
      return;
    Object.keys(a[0]).map((I) => {
      const ee = a.some((be) => be.dataKey === I);
      if (I !== e.xAxis.dataKey && !ee)
        return dn.push(
          /* @__PURE__ */ n.createElement("option", { value: I, key: I }, I)
        );
    });
    let B = {};
    a.forEach((I) => {
      Object.keys(I).forEach((ee) => {
        B[ee] = B[ee] || [];
        const be = typeof I[ee] == "number" ? I[ee].toString() : I[ee];
        B[ee].indexOf(be) === -1 && B[ee].push(be);
      });
    });
  }
  const Lt = (B) => {
    const I = lt.cloneDeep(e.columns);
    delete I[B], t({
      ...e,
      columns: I
    });
  }, nt = async (B, I, ee) => {
    switch (I) {
      case "name":
        t({
          ...e,
          columns: {
            ...e.columns,
            [B]: {
              ...e.columns[B],
              [I]: ee
            }
          }
        });
        break;
      default:
        t({
          ...e,
          columns: {
            ...e.columns,
            [B]: {
              ...e.columns[B],
              [I]: ee
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: bn,
    highlightedSeriesValues: Hn,
    handleUpdateHighlightedBar: Gn,
    handleAddNewHighlightedBar: An,
    handleRemoveHighlightedBar: Un,
    handleUpdateHighlightedBarColor: _n,
    handleHighlightedBarLegendLabel: Pn,
    handleUpdateHighlightedBorderWidth: pn
  } = Ic(e, t), Se = e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1, Ne = () => {
    const B = a.map((I) => I[e.legend.colorCode]);
    return Se ? B : _t(!1).filter((I) => I !== e.xAxis.dataKey);
  }, pe = (B) => {
    t({ ...e, legend: { ...e.legend, seriesHighlight: B } });
  }, Ke = (B, I, ee) => {
    var Qe;
    const be = { ...e[B], [I]: ee }, We = { ...e, [B]: be };
    ee === "highlight" && ((Qe = e.legend.seriesHighlight) != null && Qe.length) && (We.legend.seriesHighlight.length = 0), t(We);
  }, ht = (B, I, ee) => {
    const be = { ...e.xAxis[B] };
    be[I] = ee;
    const We = { ...e, xAxis: { ...e.xAxis, [B]: be } };
    t(We);
  }, it = ![void 0, "- Select - "].includes((Mt = (mn = e.series) == null ? void 0 : mn[0]) == null ? void 0 : Mt.dynamicCategory), ct = ((kn = e.series) == null ? void 0 : kn.length) > 1, Kt = {
    addNewExclusion: jt,
    data: a,
    editColumn: nt,
    getColumns: _t,
    getDataValueOptions: $t,
    getDataValues: Ut,
    getItemStyle: Le,
    handleSeriesChange: Yt,
    handleAddNewHighlightedBar: An,
    setCategoryAxis: sn,
    updateField: Ee,
    warningMsg: Gt,
    highlightedBarValues: bn,
    handleHighlightedBarLegendLabel: Pn,
    handleUpdateHighlightedBar: Gn,
    handleRemoveHighlightedBar: Un,
    isPaletteReversed: e.isPaletteReversed,
    highlightedSeriesValues: Hn,
    handleUpdateHighlightedBorderWidth: pn,
    handleUpdateHighlightedBarColor: _n,
    setLollipopShape: zt
  };
  return /* @__PURE__ */ n.createElement(wp.Provider, { value: Kt }, /* @__PURE__ */ n.createElement($r, { component: "EditorPanel" }, /* @__PURE__ */ n.createElement(
    mf.Sidebar,
    {
      displayPanel: rt,
      isDashboard: m,
      title: "Configure Chart",
      onBackClick: bt
    },
    /* @__PURE__ */ n.createElement(Bi, { allowZeroExpanded: !0 }, /* @__PURE__ */ n.createElement(ma.General, { name: "General" }), /* @__PURE__ */ n.createElement(ma.ForestPlot, { name: "Forest Plot Settings" }), /* @__PURE__ */ n.createElement(ma.Sankey, { name: "Sankey" }), e.visualizationType !== "Pie" && e.visualizationType !== "Forest Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, "Data Series", " ", (!e.series || e.series.length === 0 || e.visualizationType === "Paired Bar" && e.series.length < 2) && !e.dynamicSeries && /* @__PURE__ */ n.createElement(qu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, e.dynamicSeries && e.visualizationType === "Line" && /* @__PURE__ */ n.createElement(
      yt,
      {
        fieldName: "dynamicSeriesType",
        value: e.dynamicSeriesType,
        label: "Series Type",
        initial: "Select",
        updateField: Ee,
        options: ["Line", "dashed-sm", "dashed-md", "dashed-lg"]
      }
    ), e.dynamicSeries && e.visualizationType === "Line" && e.dynamicSeriesType === "Line" && /* @__PURE__ */ n.createElement(
      yt,
      {
        fieldName: "dynamicSeriesLineType",
        value: e.dynamicSeriesLineType ? e.dynamicSeriesLineType : "curveLinear",
        label: "Line Type",
        initial: "Select",
        updateField: Ee,
        options: Object.keys(sl).map((B) => sl[B])
      }
    ), (!Ue() || !e.dynamicSeries) && /* @__PURE__ */ n.createElement(n.Fragment, null, (!e.series || e.series.length === 0) && !e.dynamicSeries && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement("p", { className: "warning" }, "At least one series is required"), (!e.series || e.series.length === 0 || e.series.length < 2) && e.visualizationType === "Paired Bar" && /* @__PURE__ */ n.createElement("p", { className: "warning" }, "Select two data series for paired bar chart (e.g., Male and Female)."), /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      yt,
      {
        fieldName: "visualizationType",
        label: "Add Data Series",
        initial: "Select",
        onChange: (B) => {
          B.target.value !== "" && B.target.value !== "Select" && Jt(B.target.value), B.target.value = "";
        },
        options: _t()
      }
    ), e.series && e.series.length !== 0 && /* @__PURE__ */ n.createElement(ma.Series.Wrapper, { getColumns: _t }, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label float-left" }, "Displaying"), /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "A data series is a set of related data points plotted in a chart and typically represented in the chart legend.")))), /* @__PURE__ */ n.createElement(
      Tm,
      {
        onDragEnd: ({ source: B, destination: I }) => Yt(B.index, I.index)
      },
      /* @__PURE__ */ n.createElement(Am, { droppableId: "filter_order" }, (B) => /* @__PURE__ */ n.createElement("ul", { ...B.droppableProps, className: "series-list", ref: B.innerRef }, /* @__PURE__ */ n.createElement(
        ma.Series.List,
        {
          series: e.series,
          getItemStyle: Le,
          sortableItemStyles: _e,
          chartsWithOptions: xn
        }
      ), B.placeholder))
    ))), (e.series && e.series.length && e.visualizationType === "Bar" || e.series && e.series.length <= 1 && e.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Confidence Keys"), /* @__PURE__ */ n.createElement(
      yt,
      {
        value: e.confidenceKeys.upper || "",
        section: "confidenceKeys",
        fieldName: "upper",
        label: "Upper",
        updateField: Ee,
        initial: "Select",
        options: _t()
      }
    ), /* @__PURE__ */ n.createElement(
      yt,
      {
        value: e.confidenceKeys.lower || "",
        section: "confidenceKeys",
        fieldName: "lower",
        label: "Lower",
        updateField: Ee,
        initial: "Select",
        options: _t()
      }
    )), fe() && e.series && e.series.length === 1 && /* @__PURE__ */ n.createElement(
      yt,
      {
        value: e.rankByValue,
        fieldName: "rankByValue",
        label: "Rank by Value",
        initial: "Select",
        updateField: (B, I, ee, be) => {
          const [We, Qe] = jw(e, be, a);
          t(We, Qe);
        },
        options: ["asc", "desc"]
      }
    ), Ae() && /* @__PURE__ */ n.createElement(Uw, { config: e, updateConfig: t, data: a })))), /* @__PURE__ */ n.createElement(ma.BoxPlot, { name: "Measures" }), ve() && /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, e.visualizationType === "Pie" ? "Data Format" : e.orientation === "vertical" ? "Left Value Axis" : "Value Axis", e.visualizationType === "Pie" && !e.yAxis.dataKey && /* @__PURE__ */ n.createElement(qu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(
      yt,
      {
        value: e.yAxis.dataKey || "",
        section: "yAxis",
        fieldName: "dataKey",
        label: "Data Column",
        initial: "Select",
        required: !0,
        updateField: Ee,
        options: _t(!1),
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the source data to be visually represented.")))
      }
    ), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Axis Type", /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, "Select 'Numeric (Linear Scale)' for uniform scaling, 'Numeric (Logarithmic Scale)' for exponential data, or 'Categorical' for discrete categories."))), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.yAxis.type,
        onChange: (B) => t({
          ...e,
          yAxis: {
            ...e.yAxis,
            type: B.target.value
          }
        })
      },
      /* @__PURE__ */ n.createElement("option", { value: "linear" }, "Numeric (Linear Scale)"),
      e.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("option", { value: "logarithmic" }, "Numeric (Logarithmic Scale)"),
      e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("option", { value: "categorical" }, "Categorical")
    )), /* @__PURE__ */ n.createElement(
      Kw,
      {
        config: e,
        updateConfig: t,
        data: a,
        display: ne()
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        display: !ne(),
        value: e.yAxis.label,
        section: "yAxis",
        fieldName: "label",
        label: "Label ",
        updateField: Ee
      }
    ), e.runtime.seriesKeys && e.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(e.visualizationType) && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.isLegendValue,
        fieldName: "isLegendValue",
        label: "Use Legend Value in Hover",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        display: !ne(),
        value: e.yAxis.numTicks,
        placeholder: "Auto",
        type: "number",
        section: "yAxis",
        fieldName: "numTicks",
        label: "Number of ticks",
        className: "number-narrow",
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used."))),
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.yAxis.size,
        type: "number",
        section: "yAxis",
        fieldName: "size",
        label: e.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
        className: "number-narrow",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, `Increase the size if elements in the ${e.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.`)))
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        display: !ne(),
        value: e.yAxis.labelOffset,
        section: "yAxis",
        fieldName: "labelOffset",
        label: "Label offset",
        type: "number",
        className: "number-narrow",
        updateField: Ee
      }
    ), e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.isResponsiveTicks,
        fieldName: "isResponsiveTicks",
        label: "Use Responsive Ticks",
        updateField: Ee
      }
    ), (e.orientation === "vertical" || !e.isResponsiveTicks) && /* @__PURE__ */ n.createElement(
      je,
      {
        display: !ne(),
        value: e.yAxis.tickRotation || 0,
        type: "number",
        min: 0,
        section: "yAxis",
        fieldName: "tickRotation",
        label: "Tick rotation (Degrees)",
        className: "number-narrow",
        updateField: Ee
      }
    ), e.isResponsiveTicks && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.maxTickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "maxTickRotation",
        label: "Max Tick Rotation",
        className: "number-narrow",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
      }
    ), Oe() && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.yAxis.gridLines,
        section: "yAxis",
        fieldName: "gridLines",
        label: "Show Gridlines",
        updateField: Ee
      }
    ), Oe() && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.yAxis.labelsAboveGridlines,
        section: "yAxis",
        fieldName: "labelsAboveGridlines",
        label: "Tick labels above gridlines",
        updateField: Ee,
        disabled: !e.yAxis.gridLines,
        title: e.yAxis.gridLines ? "" : "Show gridlines to enable"
      }
    ), He() && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.yAxis.enablePadding,
        section: "yAxis",
        fieldName: "enablePadding",
        label: "Add Padding to Value Axis Scale",
        updateField: Ee
      }
    ), e.yAxis.enablePadding && He() && /* @__PURE__ */ n.createElement(
      je,
      {
        type: "number",
        section: "yAxis",
        fieldName: "scalePadding",
        label: "Padding Percentage",
        className: "number-narrow",
        updateField: Ee,
        value: e.yAxis.scalePadding
      }
    )), /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.dataFormat.commas,
        section: "dataFormat",
        fieldName: "commas",
        label: "Add commas",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will add commas to the left value axis, tooltip hover, and data table.")))
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: !ne(),
        value: e.dataFormat.abbreviated,
        section: "dataFormat",
        fieldName: "abbreviated",
        label: "Abbreviate Axis Values",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.dataFormat.roundTo ? e.dataFormat.roundTo : 0,
        type: "number",
        section: "dataFormat",
        fieldName: "roundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: Ee,
        min: 0
      }
    ), " ", /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.dataFormat.prefix,
        section: "dataFormat",
        fieldName: "prefix",
        label: "Prefix",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.dataFormat.suffix,
        section: "dataFormat",
        fieldName: "suffix",
        label: "Suffix",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    )), e.orientation === "horizontal" ? (
      // horizontal - x is vertical y is horizontal
      /* @__PURE__ */ n.createElement(n.Fragment, null, Ze() && /* @__PURE__ */ n.createElement(
        Je,
        {
          value: e.xAxis.hideAxis,
          section: "xAxis",
          fieldName: "hideAxis",
          label: "Hide Axis",
          updateField: Ee
        }
      ), Ve() && /* @__PURE__ */ n.createElement(
        Je,
        {
          value: e.xAxis.hideLabel,
          section: "xAxis",
          fieldName: "hideLabel",
          label: "Hide Tick Labels",
          updateField: Ee
        }
      ), et() && /* @__PURE__ */ n.createElement(
        Je,
        {
          value: e.xAxis.hideTicks,
          section: "xAxis",
          fieldName: "hideTicks",
          label: "Hide Ticks",
          updateField: Ee
        }
      ), Ie() && /* @__PURE__ */ n.createElement(
        je,
        {
          value: e.xAxis.max,
          section: "xAxis",
          fieldName: "max",
          label: "max value",
          type: "number",
          placeholder: "Auto",
          updateField: Ee
        }
      ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Gt.maxMsg), qe() && /* @__PURE__ */ n.createElement(
        je,
        {
          value: e.xAxis.min,
          section: "xAxis",
          fieldName: "min",
          type: "number",
          label: "min value",
          placeholder: "Auto",
          updateField: Ee
        }
      ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Gt.minMsg), e.visualizationType === "Deviation Bar" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        je,
        {
          value: e.xAxis.target,
          section: "xAxis",
          fieldName: "target",
          type: "number",
          label: "Deviation point",
          placeholder: "Auto",
          updateField: Ee
        }
      ), /* @__PURE__ */ n.createElement(
        je,
        {
          value: e.xAxis.targetLabel || "Target",
          section: "xAxis",
          fieldName: "targetLabel",
          type: "text",
          label: "Deviation point Label",
          updateField: Ee
        }
      ), /* @__PURE__ */ n.createElement(
        Je,
        {
          value: e.xAxis.showTargetLabel,
          section: "xAxis",
          fieldName: "showTargetLabel",
          label: "Show Deviation point label",
          updateField: Ee
        }
      )))
    ) : e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Je,
      {
        display: !ne(),
        value: e.dataFormat.onlyShowTopPrefixSuffix,
        section: "dataFormat",
        fieldName: "onlyShowTopPrefixSuffix",
        label: "Only Show Top Prefix/Suffix",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: !ne(),
        value: e.yAxis.hideAxis,
        section: "yAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: !ne(),
        value: e.yAxis.hideLabel,
        section: "yAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: !ne(),
        value: e.yAxis.hideTicks,
        section: "yAxis",
        fieldName: "hideTicks",
        label: "Hide Ticks",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.yAxis.max,
        section: "yAxis",
        fieldName: "max",
        type: "number",
        label: "left axis max value",
        placeholder: "Auto",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Gt.maxMsg), e.visualizationType !== "Area Chart" && e.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.yAxis.min,
        section: "yAxis",
        fieldName: "min",
        type: "number",
        label: "left axis min value",
        placeholder: "Auto",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Gt.minMsg))), $() && e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Bi, { allowZeroExpanded: !0 }, (On = (wn = e.yAxis) == null ? void 0 : wn.anchors) == null ? void 0 : On.map((B, I) => /* @__PURE__ */ n.createElement(zn, { className: "series-item series-item--chart", key: `yaxis-anchors-2-${I}` }, /* @__PURE__ */ n.createElement(Bn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement($n, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (ee) => {
          ee.preventDefault();
          const be = [...e.yAxis.anchors];
          be.splice(I, 1), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: be
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.yAxis.anchors[I].value ? e.yAxis.anchors[I].value : "",
        onChange: (ee) => {
          ee.preventDefault();
          const be = [...e.yAxis.anchors];
          be[I].value = ee.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: be
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.yAxis.anchors[I].color ? e.yAxis.anchors[I].color : "",
        onChange: (ee) => {
          ee.preventDefault();
          const be = [...e.yAxis.anchors];
          be[I].color = ee.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: be
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.yAxis.anchors[I].lineStyle || "",
        onChange: (ee) => {
          const be = [...e.yAxis.anchors];
          be[I].lineStyle = ee.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: be
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      A.map((ee) => /* @__PURE__ */ n.createElement("option", { key: ee.key }, ee.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (B) => {
          B.preventDefault();
          const I = [...e.yAxis.anchors];
          I.push({}), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )), $() && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Bi, { allowZeroExpanded: !0 }, (Ln = (Nn = e.xAxis) == null ? void 0 : Nn.anchors) == null ? void 0 : Ln.map((B, I) => /* @__PURE__ */ n.createElement(zn, { className: "series-item series-item--chart", key: `xaxis-anchors-${I}` }, /* @__PURE__ */ n.createElement(Bn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement($n, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (ee) => {
          ee.preventDefault();
          const be = [...e.xAxis.anchors];
          be.splice(I, 1), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: be
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].value ? e.xAxis.anchors[I].value : "",
        onChange: (ee) => {
          ee.preventDefault();
          const be = [...e.xAxis.anchors];
          be[I].value = ee.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: be
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].color ? e.xAxis.anchors[I].color : "",
        onChange: (ee) => {
          ee.preventDefault();
          const be = [...e.xAxis.anchors];
          be[I].color = ee.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: be
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.anchors[I].lineStyle || "",
        onChange: (ee) => {
          const be = [...e.xAxis.anchors];
          be[I].lineStyle = ee.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: be
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      A.map((ee) => /* @__PURE__ */ n.createElement("option", { key: ee.key }, ee.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (B) => {
          B.preventDefault();
          const I = [...e.xAxis.anchors];
          I.push({}), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )))), Ge && /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, "Right Value Axis")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.yAxis.rightLabel,
        section: "yAxis",
        fieldName: "rightLabel",
        label: "Label",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.yAxis.rightNumTicks,
        placeholder: "Auto",
        type: "number",
        section: "yAxis",
        fieldName: "rightNumTicks",
        label: "Number of ticks",
        className: "number-narrow",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.yAxis.rightAxisSize,
        type: "number",
        section: "yAxis",
        fieldName: "rightAxisSize",
        label: "Size (Width)",
        className: "number-narrow",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.yAxis.rightLabelOffsetSize,
        type: "number",
        section: "yAxis",
        fieldName: "rightLabelOffsetSize",
        label: "Label Offset",
        className: "number-narrow",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.dataFormat.rightCommas,
        section: "dataFormat",
        fieldName: "rightCommas",
        label: "Add commas",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.dataFormat.rightRoundTo,
        type: "number",
        section: "dataFormat",
        fieldName: "rightRoundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: Ee,
        min: 0
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.dataFormat.rightPrefix,
        section: "dataFormat",
        fieldName: "rightPrefix",
        label: "Prefix",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.dataFormat.rightSuffix,
        section: "dataFormat",
        fieldName: "rightSuffix",
        label: "Suffix",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    )), /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.yAxis.rightHideAxis,
        section: "yAxis",
        fieldName: "rightHideAxis",
        label: "Hide Axis",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.yAxis.rightHideLabel,
        section: "yAxis",
        fieldName: "rightHideLabel",
        label: "Hide Tick Labels",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.yAxis.rightHideTicks,
        section: "yAxis",
        fieldName: "rightHideTicks",
        label: "Hide Ticks",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.yAxis.max,
        section: "yAxis",
        fieldName: "rightMax",
        type: "number",
        label: "right axis max value",
        placeholder: "Auto",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Gt.rightMaxMessage), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.yAxis.min,
        section: "yAxis",
        fieldName: "rightMin",
        type: "number",
        label: "right axis min value",
        placeholder: "Auto",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Gt.minMsg))), oe() && /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, e.visualizationType === "Pie" ? "Segments" : "Date/Category Axis", !e.xAxis.dataKey && /* @__PURE__ */ n.createElement(qu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, e.visualizationType !== "Forest Plot" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Data Scaling Type", /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, "Linear scales are employed for quantitative data, while time scales are used for time-series data."))), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.type,
        onChange: (B) => t({
          ...e,
          xAxis: {
            ...e.xAxis,
            type: B.target.value
          }
        })
      },
      e.visualizationType !== "Bump Chart" && /* @__PURE__ */ n.createElement("option", { value: "categorical" }, "Categorical (Linear Scale)"),
      e.visualizationType !== "Bump Chart" && /* @__PURE__ */ n.createElement("option", { value: "date" }, "Date (Linear Scale)"),
      /* @__PURE__ */ n.createElement("option", { value: "date-time" }, "Date (Date Time Scale)"),
      e.visualizationType === "Scatter Plot" && /* @__PURE__ */ n.createElement("option", { value: "continuous" }, "Continuous")
    )), /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.xAxis.manual,
        section: "xAxis",
        fieldName: "manual",
        label: "Manual Ticks",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: e.xAxis.type !== "categorical",
        value: e.xAxis.sortByRecentDate,
        section: "xAxis",
        fieldName: "sortByRecentDate",
        label: "Show dates newest to oldest",
        updateField: Ee
      }
    ), ce() && /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.padding,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "padding",
        label: "Padding (Percent)",
        className: "number-narrow",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified.")))
      }
    )), /* @__PURE__ */ n.createElement(
      yt,
      {
        value: e.xAxis.dataKey || sn() || "",
        section: "xAxis",
        fieldName: "dataKey",
        label: "Data Key",
        initial: "Select",
        required: !0,
        updateField: Ee,
        options: _t(!1),
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
      }
    )), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(
      yt,
      {
        value: e.xAxis.dataKey || "",
        section: "xAxis",
        fieldName: "dataKey",
        label: "Segment Labels",
        initial: "Select",
        required: !0,
        updateField: Ee,
        options: _t(!1),
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."')))
      }
    ), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.label,
        section: "xAxis",
        fieldName: "label",
        label: "Label",
        updateField: Ee
      }
    ), e.xAxis.type === "continuous" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.dataFormat.bottomPrefix,
        section: "dataFormat",
        fieldName: "bottomPrefix",
        label: "Prefix",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.dataFormat.bottomSuffix,
        section: "dataFormat",
        fieldName: "bottomSuffix",
        label: "Suffix",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.dataFormat.bottomAbbreviated,
        section: "dataFormat",
        fieldName: "bottomAbbreviated",
        label: "Abbreviate Axis Values",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
      }
    )), Rn(e.xAxis) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" } }, "Format how charts should parse and display your dates using", " ", /* @__PURE__ */ n.createElement("a", { href: "https://d3js.org/d3-time-format#locale_format", target: "_blank", rel: "noreferrer" }, "these guidelines"), "."), /* @__PURE__ */ n.createElement(
      je,
      {
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed.", " "))),
        value: e.xAxis.dateParseFormat,
        section: "xAxis",
        fieldName: "dateParseFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "Date Parse Format",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", "Adjusts the date display format on the axis for clear, visual date representation."))),
        value: e.xAxis.dateDisplayFormat,
        section: "xAxis",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "AXIS DATE DISPLAY FORMAT",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format.", " "))),
        value: e.table.dateDisplayFormat,
        section: "table",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "DATA TABLE DATE DISPLAY FORMAT",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format.", " "))),
        value: e.tooltips.dateDisplayFormat,
        section: "tooltips",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "HOVER DATE DISPLAY FORMAT",
        updateField: Ee
      }
    )), /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.exclusions.active,
        section: "exclusions",
        fieldName: "active",
        label: e.xAxis.type === "date" || e.xAxis.type === "date-time" ? "Limit by start and/or end dates" : "Exclude one or more values",
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked, you can select source-file values for exclusion from the date/category axis.", " "))),
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.xAxis.showYearsOnce,
        section: "xAxis",
        fieldName: "showYearsOnce",
        label: "Show years once",
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked and the date format for the axis includes years, each year will only be shown once in the axis."))),
        updateField: Ee
      }
    ), J() && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: (fn = e.brush) == null ? void 0 : fn.active,
        section: "brush",
        fieldName: "active",
        label: "Brush Slider ",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Use the brush slider to narrow down your data view to specific values along the axis. This tool is useful for examining detailed data segments within the larger dataset.", " ")))
      }
    ), e.exclusions.active && /* @__PURE__ */ n.createElement(n.Fragment, null, e.xAxis.type === "categorical" && /* @__PURE__ */ n.createElement(n.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ n.createElement(ln, null)), /* @__PURE__ */ n.createElement(
      yt,
      {
        fieldName: "visualizationType",
        label: "Add Exclusion",
        initial: "Select",
        onChange: (B) => {
          B.target.value !== "" && B.target.value !== "Select" && jt(B.target.value), B.target.value = "";
        },
        options: Ut(e.xAxis.dataKey, !0)
      }
    )), e.xAxis.type === "date" || e.xAxis.type === "date-time" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      je,
      {
        type: "date",
        section: "exclusions",
        fieldName: "dateStart",
        label: "Start Date",
        updateField: Ee,
        value: e.exclusions.dateStart || ""
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        type: "date",
        section: "exclusions",
        fieldName: "dateEnd",
        label: "End Date",
        updateField: Ee,
        value: e.exclusions.dateEnd || ""
      }
    ))), me() && e.xAxis.type !== "date-time" && e.xAxis.manual && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.manualStep,
        placeholder: "Auto",
        type: "number",
        min: 1,
        section: "xAxis",
        fieldName: "manualStep",
        label: "Step count",
        className: "number-narrow",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc.")))
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement(
      "button",
      {
        onClick: () => wt(!ft),
        className: "edit-label"
      },
      "Step Count: viewport overrides",
      " ",
      /* @__PURE__ */ n.createElement("span", { style: { transform: `rotate(${ft ? "90deg" : "0deg"})` } }, ">")
    )), ft && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, Object.keys(Tp).map((B) => /* @__PURE__ */ n.createElement(
      je,
      {
        key: `viewport-step-count-input-${B}`,
        value: e.xAxis.viewportStepCount ? e.xAxis.viewportStepCount[B] : void 0,
        placeholder: "Auto",
        type: "number",
        label: B,
        className: "number-narrow",
        updateField: (I, ee, be, We) => ht("viewportStepCount", B, We)
      }
    ))))), me() && (e.xAxis.type === "date-time" || !e.xAxis.manual) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.numTicks,
        placeholder: "Auto",
        type: "number",
        min: 1,
        section: "xAxis",
        fieldName: "numTicks",
        label: "Number of ticks",
        className: "number-narrow",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.')))
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement(
      "button",
      {
        onClick: () => wt(!ft),
        className: "edit-label"
      },
      "Number of ticks: viewport overrides",
      " ",
      /* @__PURE__ */ n.createElement("span", { style: { transform: `rotate(${ft ? "90deg" : "0deg"})` } }, ">")
    )), ft && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, Object.keys(Tp).map((B) => /* @__PURE__ */ n.createElement(
      je,
      {
        key: `viewport-num-ticks-input-${B}`,
        value: e.xAxis.viewportNumTicks ? e.xAxis.viewportNumTicks[B] : void 0,
        placeholder: "Auto",
        type: "number",
        label: B,
        className: "number-narrow",
        updateField: (I, ee, be, We) => ht("viewportNumTicks", B, We)
      }
    ))))), De() && /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.size,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "size",
        label: e.orientation === "horizontal" ? "Size (Width)" : "Size (Height)",
        className: "number-narrow",
        updateField: Ee
      }
    ), e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.labelOffset,
        section: "xAxis",
        fieldName: "labelOffset",
        label: "Label offset",
        type: "number",
        className: "number-narrow",
        updateField: Ee
      }
    ), (e.xAxis.type === "continuous" || e.forestPlot.type === "Logarithmic") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.dataFormat.bottomCommas,
        section: "dataFormat",
        fieldName: "bottomCommas",
        label: "Add commas",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.dataFormat.bottomRoundTo,
        type: "number",
        section: "dataFormat",
        fieldName: "bottomRoundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: Ee,
        min: 0
      }
    )), ze() && e.orientation === "vertical" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.isResponsiveTicks,
        fieldName: "isResponsiveTicks",
        label: "Use Responsive Ticks",
        updateField: Ee
      }
    ), (e.orientation === "horizontal" || !e.isResponsiveTicks) && Fe() && /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.tickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "tickRotation",
        label: "Tick rotation (Degrees)",
        className: "number-narrow",
        updateField: Ee
      }
    ), e.orientation === "vertical" && e.isResponsiveTicks && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.maxTickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "maxTickRotation",
        label: "Max Tick Rotation",
        className: "number-narrow",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
      }
    ), e.orientation === "horizontal" ? /* @__PURE__ */ n.createElement(n.Fragment, null, Y() && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.yAxis.hideAxis,
        section: "yAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: Ee
      }
    ), K() && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.yAxis.hideLabel,
        section: "yAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: Ee
      }
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, Y() && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.xAxis.hideAxis,
        section: "xAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: Ee
      }
    ), K() && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.xAxis.hideLabel,
        section: "xAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: Ee
      }
    ), ge() && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.xAxis.hideTicks,
        section: "xAxis",
        fieldName: "hideTicks",
        label: "Hide Ticks",
        updateField: Ee
      }
    )), ((Fn = e.series) == null ? void 0 : Fn.length) === 1 && e.visualizationType === "Bar" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "barHighlight" }, "Bar Highlighting"), e.series.length === 1 && bn.map((B, I) => /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("div", { className: "edit-block", key: `highlighted-bar-${I}` }, /* @__PURE__ */ n.createElement("button", { className: "btn btn-danger", onClick: (ee) => Un(ee, I) }, "Remove"), /* @__PURE__ */ n.createElement("p", null, "Highlighted Bar ", I + 1), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Value"), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.highlightedBarValues[I].value,
        onChange: (ee) => Gn(ee, I)
      },
      /* @__PURE__ */ n.createElement("option", { value: "" }, "- Select Value -"),
      Hn && [...new Set(Hn)].sort().map((ee) => /* @__PURE__ */ n.createElement("option", { key: `special-class-value-option-${I}-${ee}` }, ee))
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.highlightedBarValues[I].color ? e.highlightedBarValues[I].color : "",
        onChange: (ee) => _n(ee, I)
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Border Width"), /* @__PURE__ */ n.createElement(
      "input",
      {
        max: "5",
        min: "0",
        type: "number",
        value: e.highlightedBarValues[I].borderWidth ? e.highlightedBarValues[I].borderWidth : "",
        onChange: (ee) => pn(ee, I)
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Legend Label"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.highlightedBarValues[I].legendLabel ? e.highlightedBarValues[I].legendLabel : "",
        onChange: (ee) => Pn(ee, I)
      }
    ))))), /* @__PURE__ */ n.createElement("button", { className: "btn btn-primary full-width", onClick: (B) => An(B) }, "Add Highlighted Bar"))), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.exclusions.active,
        section: "exclusions",
        fieldName: "active",
        label: "Exclude one or more values",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked, you can select values for exclusion from the pie segments.")))
      }
    ), e.exclusions.active && /* @__PURE__ */ n.createElement(n.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ n.createElement(ln, null)), /* @__PURE__ */ n.createElement(
      yt,
      {
        fieldName: "visualizationType",
        label: "Add Exclusion",
        initial: "Select",
        onChange: (B) => {
          B.target.value !== "" && B.target.value !== "Select" && jt(B.target.value), B.target.value = "";
        },
        options: Ut(e.xAxis.dataKey, !0)
      }
    ))), q() && /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.min,
        section: "xAxis",
        fieldName: "min",
        type: "number",
        label: "min value",
        placeholder: "Auto",
        updateField: Ee
      }
    ), X() && /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.xAxis.max,
        section: "xAxis",
        fieldName: "max",
        type: "number",
        label: "max value",
        placeholder: "Auto",
        updateField: Ee
      }
    ), $() && e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Bi, { allowZeroExpanded: !0 }, (we = (Zt = e.xAxis) == null ? void 0 : Zt.anchors) == null ? void 0 : we.map((B, I) => /* @__PURE__ */ n.createElement(zn, { className: "series-item series-item--chart", key: `xaxis-anchors-2-${I}` }, /* @__PURE__ */ n.createElement(Bn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement($n, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (ee) => {
          ee.preventDefault();
          const be = [...e.xAxis.anchors];
          be.splice(I, 1), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: be
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].value ? e.xAxis.anchors[I].value : "",
        onChange: (ee) => {
          ee.preventDefault();
          const be = [...e.xAxis.anchors];
          be[I].value = ee.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: be
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].color ? e.xAxis.anchors[I].color : "",
        onChange: (ee) => {
          ee.preventDefault();
          const be = [...e.xAxis.anchors];
          be[I].color = ee.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: be
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.anchors[I].lineStyle || "",
        onChange: (ee) => {
          const be = [...e.xAxis.anchors];
          be[I].lineStyle = ee.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: be
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      A.map((ee) => /* @__PURE__ */ n.createElement("option", { key: ee.key }, ee.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (B) => {
          B.preventDefault();
          const I = [...e.xAxis.anchors];
          I.push({}), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )), $() && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Bi, { allowZeroExpanded: !0 }, (P = (g = e.yAxis) == null ? void 0 : g.anchors) == null ? void 0 : P.map((B, I) => /* @__PURE__ */ n.createElement(
      zn,
      {
        className: "series-item series-item--chart",
        key: `accordion-yaxis-anchors-${I}`
      },
      /* @__PURE__ */ n.createElement(Bn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement($n, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (ee) => {
            ee.preventDefault();
            const be = [...e.yAxis.anchors];
            be.splice(I, 1), t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: be
              }
            });
          }
        },
        "Remove"
      )))),
      /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "text",
          value: e.yAxis.anchors[I].value ? e.yAxis.anchors[I].value : "",
          onChange: (ee) => {
            ee.preventDefault();
            const be = [...e.yAxis.anchors];
            be[I].value = ee.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: be
              }
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "text",
          value: e.yAxis.anchors[I].color ? e.yAxis.anchors[I].color : "",
          onChange: (ee) => {
            ee.preventDefault();
            const be = [...e.yAxis.anchors];
            be[I].color = ee.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: be
              }
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
        "select",
        {
          value: e.yAxis.anchors[I].lineStyle || "",
          onChange: (ee) => {
            const be = [...e.yAxis.anchors];
            be[I].lineStyle = ee.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: be
              }
            });
          }
        },
        /* @__PURE__ */ n.createElement("option", null, "Select"),
        A.map((ee) => /* @__PURE__ */ n.createElement("option", { key: ee.key }, ee.value))
      )))
    ))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (B) => {
          B.preventDefault();
          const I = [...e.yAxis.anchors];
          I.push({}), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )))), /* @__PURE__ */ n.createElement(ma.Regions, { name: "Regions" }), e.visualizationType !== "Box Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, "Columns")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(yw, { config: e, updateField: Ee, deleteColumn: Lt }), " ")), z() && /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, "Legend")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
      yt,
      {
        value: (M = e.legend) == null ? void 0 : M.position,
        section: "legend",
        fieldName: "position",
        label: "Position",
        updateField: Ee,
        options: ["right", "left", "bottom", "top"]
      }
    ), (e.legend.position === "left" || e.legend.position === "right" || !e.legend.position) && e.legend.style === "gradient" && /* @__PURE__ */ n.createElement("span", { style: { color: "red", fontSize: "14px" } }, "Position must be set to top or bottom to use gradient style."), /* @__PURE__ */ n.createElement(
      yt,
      {
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "If using gradient style, limit the legend to five items for better mobile visibility, and position the legend at the top or bottom."))),
        display: !e.legend.hide,
        value: e.legend.style,
        section: "legend",
        fieldName: "style",
        label: "Legend Style",
        updateField: Ee,
        options: tn("style")
      }
    ), /* @__PURE__ */ n.createElement(
      yt,
      {
        display: !e.legend.hide && e.legend.style === "gradient",
        value: e.legend.subStyle,
        section: "legend",
        fieldName: "subStyle",
        label: "Gradient Style",
        updateField: Ee,
        options: tn("subStyle")
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        display: e.legend.style === "gradient" && !e.legend.hide,
        className: "number-narrow",
        type: "number",
        value: e.legend.tickRotation,
        section: "legend",
        fieldName: "tickRotation",
        label: "Tick Rotation (Degrees)",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: (Z = e.preliminaryData) == null ? void 0 : Z.some((B) => B.label && B.type === "suppression" && B.value),
        value: e.legend.hideSuppressedLabels,
        section: "legend",
        fieldName: "hideSuppressedLabels",
        label: "Hide Suppressed Labels",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.`)))
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: (xe = e.preliminaryData) == null ? void 0 : xe.some((B) => B.label && B.type === "suppression" && B.value),
        value: e.legend.hideSuppressionLink,
        section: "legend",
        fieldName: "hideSuppressionLink",
        label: "Hide Suppression Definition Link",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will hide the suppression definition link from display.")))
      }
    ), /* @__PURE__ */ n.createElement(
      yt,
      {
        display: it || ct,
        value: e.legend.behavior,
        section: "legend",
        fieldName: "behavior",
        label: "Legend Behavior (When clicked)",
        updateField: (...[B, , I, ee]) => Ke(B, I, ee),
        options: ["highlight", "isolate"]
      }
    ), /* @__PURE__ */ n.createElement(
      yt,
      {
        display: ie(),
        value: e.legend.colorCode,
        section: "legend",
        fieldName: "colorCode",
        label: "Color code by category",
        initial: "Select",
        updateField: Ee,
        options: $t(a)
      }
    ), W() && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.legend.axisAlign,
        fieldName: "axisAlign",
        section: "legend",
        label: "Align to Axis on Isolate",
        updateField: Ee
      }
    ), e.legend.behavior === "highlight" && e.tooltips.singleSeries && /* @__PURE__ */ n.createElement(
      Je,
      {
        value: e.legend.highlightOnHover,
        section: "legend",
        fieldName: "highlightOnHover",
        label: "HIGHLIGHT DATA SERIES ON HOVER",
        updateField: Ee
      }
    ), ae && e.legend.behavior === "isolate" && !Se && /* @__PURE__ */ n.createElement("fieldset", { className: "primary-fieldset edit-block", key: "additional-highlight-values" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Isolate Data Series", /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(Xe, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend."))))), e.legend.seriesHighlight && e.legend.seriesHighlight.map((B, I) => /* @__PURE__ */ n.createElement("fieldset", { className: "edit-block", key: `${B}-${I}` }, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-danger",
        onClick: (ee) => {
          ee.preventDefault();
          const be = [...e.legend.seriesHighlight];
          be.splice(I, 1), Ee("legend", null, "seriesHighlight", be), be.length || v();
        }
      },
      "Remove"
    ), /* @__PURE__ */ n.createElement(
      yt,
      {
        value: e.legend.seriesHighlight[I],
        fieldName: "seriesHighlight",
        label: "Isolate Value",
        onChange: (ee) => {
          const be = [...e.legend.seriesHighlight];
          be.includes(ee.target.value) || (be[I] = ee.target.value, pe([...be]));
        },
        options: Ne()
      }
    ))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (B) => {
          B.preventDefault();
          const I = Ne(), ee = [...e.legend.seriesHighlight];
          if (ee.length < I.length) {
            const [We] = I.filter((Qe) => !ee.includes(Qe));
            ee.push(We), pe([...ee]);
          }
        }
      },
      "Add Isolate Value"
    )), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: !e.legend.hide && e.legend.style !== "gradient",
        value: e.legend.reverseLabelOrder,
        section: "legend",
        fieldName: "reverseLabelOrder",
        label: "Reverse Labels",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: !e.legend.hide,
        value: ["left", "right"].includes(e.legend.position) ? e.legend.hideBorder.side : e.legend.hideBorder.topBottom,
        section: "legend",
        subsection: "hideBorder",
        fieldName: ["left", "right"].includes(e.legend.position) ? "side" : "topBottom",
        label: "Hide Legend Box",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "Default option for top and bottom legends is ‘No Box.’.")))
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: !e.legend.hide && !["left", "right"].includes(e.legend.position) && e.legend.style !== "gradient",
        value: e.legend.singleRow,
        section: "legend",
        fieldName: "singleRow",
        label: "Single Row Legend",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        display: ["bottom", "top"].includes(e.legend.position) && !e.legend.hide && e.legend.style !== "gradient",
        value: e.legend.verticalSorted,
        section: "legend",
        fieldName: "verticalSorted",
        label: "Vertical sorted Legend",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      Je,
      {
        value: !!e.legend.hide,
        section: "legend",
        fieldName: "hide",
        label: "Hide Legend",
        updateField: Ee,
        tooltip: /* @__PURE__ */ n.createElement(se, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(se.Target, null, /* @__PURE__ */ n.createElement(
          Xe,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(se.Content, null, /* @__PURE__ */ n.createElement("p", null, "With a single-series chart, consider hiding the legend to reduce visual clutter.")))
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        value: e.legend.label,
        section: "legend",
        fieldName: "label",
        label: "Title",
        updateField: Ee
      }
    ), /* @__PURE__ */ n.createElement(
      je,
      {
        type: "textarea",
        value: e.legend.description,
        updateField: Ee,
        section: "legend",
        fieldName: "description",
        label: "Legend Description"
      }
    ))), Te() && /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, "Filters")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(xw, { config: e, updateField: Ee, rawData: E }))), /* @__PURE__ */ n.createElement(ma.Visual, { name: "Visual" }), e.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement($n, null, "Data Table")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
      gw,
      {
        config: e,
        columns: Object.keys(a[0] || {}),
        updateField: Ee,
        isDashboard: m,
        isLoadedFromUrl: Xt
      }
    ), " ")), /* @__PURE__ */ n.createElement(ma.Annotate, { name: "Text Annotations" })),
    e.type !== "Spark Line" && /* @__PURE__ */ n.createElement($g, { loadConfig: t, config: e, convertStateToConfig: mt })
  )));
}, bm = (e) => {
  let t = "", r = Math.abs(e);
  return r >= 1e9 ? (t = "B", e = e / 1e9) : r >= 1e6 ? (t = "M", e = e / 1e6) : r >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, hs = (e, t) => {
  var r;
  return e ? (r = e.legend) != null && r.hide ? e != null && e.title ? `dataTableSection__${e.title.replace(/\s/g, "")}` : "dataTableSection" : t : "dataTableSection";
}, Gw = (e) => {
  const t = lt.sortBy(e), r = (o, d) => {
    const c = (o.length - 1) * d, s = Math.floor(c), p = c - s;
    return o[s + 1] !== void 0 ? o[s] + p * (o[s + 1] - o[s]) : o[s];
  }, a = r(t, 0.25), i = r(t, 0.75);
  return { q1: a, q3: i };
}, Xw = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], Em = (e) => typeof e == "string" ? parseFloat(e.replace(/,/g, "")) : Number(e), hf = (e, t) => {
  if (t.rankByValue) {
    const r = t.series[0].dataKey, a = e.sort((i, o) => Em(i[r]) - Em(o[r]));
    return t.rankByValue === "asc" ? a : a.reverse();
  }
  return e;
}, Sm = (e = "#000000", t = !1) => {
  let r = Wa(e), a = t ? r.brighten(0.5).hex() : r.saturate(1.3).hex();
  return [e, a, r.darken(0.3).hex()];
};
const km = (e) => {
  const t = /(?:\.([^.]+))$/, r = /[?&]wt=(csv|json)(?:&|$)/, a = new URL(e, window.location.origin), i = a.pathname, o = a.search, d = t.exec(i);
  if (d && d[1])
    return d[1];
  const c = r.exec(o);
  return c && c[1] ? c[1] : "";
}, qw = (e) => {
  const { children: t } = e, { config: r, currentViewport: a } = ue.useContext(gt), i = () => {
    let o = ["legend-wrapper", "d-flex", "flex-nowrap", "w-100"];
    const { legend: d } = r;
    return (d.position === "bottom" || d.position === "top" || ya(a)) && (o = o.filter((c) => c !== "flex-nowrap"), o.push("flex-wrap")), o.join(" ");
  };
  return /* @__PURE__ */ n.createElement("div", { className: i() }, ...t);
}, Zw = ({
  configUrl: e,
  config: t,
  isEditor: r = !1,
  isDebug: a = !1,
  isDashboard: i = !1,
  setConfig: o,
  setEditing: d,
  hostname: c,
  link: s,
  setSharedFilter: p,
  setSharedFilterValue: m,
  dashboardConfig: y
}) => {
  var dn, Lt, nt, bn, Hn, Gn, An, Un, _n, Pn, pn;
  const x = new zm(), [T, S] = ue.useState(!0), A = ue.useRef(null), [E, b] = ue.useState(null), [v, N] = ue.useState({}), [C, R] = ue.useState(lt.cloneDeep(t == null ? void 0 : t.data) || []), [_, U] = ue.useState(void 0), [j, te] = ue.useState(void 0), [Q, $] = ue.useState(
    t && ((Lt = (dn = t == null ? void 0 : t.legend) == null ? void 0 : dn.seriesHighlight) != null && Lt.length) ? [...(nt = t == null ? void 0 : t.legend) == null ? void 0 : nt.seriesHighlight] : []
  ), [J, ne] = ue.useState("lg"), [z, W] = ue.useState([0, 0]), [ie, ae] = ue.useState(), [oe, K] = ue.useState(), [Y, X] = ue.useState(!1), [q, ce] = ue.useState(!1), [ge, De] = ue.useState([]), [me] = ue.useState(`cove-${Math.random().toString(16).slice(-4)}`), [Fe, Ue] = ue.useState({
    data: [],
    isActive: !1,
    isBrushing: !1
  }), { description: Te, visualizationType: ve } = v, Ae = ue.useRef(null), fe = ue.useRef(null), ze = (Se) => {
    ce(Se);
  };
  a && console.log("Chart config, isEditor", v, r);
  let { legend: Oe, title: Ve } = v;
  r && (!Ve || Ve === "") && (Ve = "Chart Title"), v.table && (!((bn = v.table) != null && bn.label) || ((Hn = v.table) == null ? void 0 : Hn.label) === "") && (v.table.label = "Data Table");
  const { lineDatapointClass: Ze, contentClasses: Ie, sparkLineStyles: qe } = Ig(v), et = ue.useId(), He = () => Hc(v.visualizationType, j, v.allowLineToBarGraph), Ge = async () => {
    var Se;
    if (v.dataUrl) {
      const Ne = new URL(v.runtimeDataUrl || v.dataUrl, window.location.origin);
      let pe = Object.fromEntries(new URLSearchParams(Ne.search)), Ke = !1;
      if ((Se = v.filters) == null || Se.forEach((ct) => {
        ct.type === "url" && pe[ct.queryParameter] !== decodeURIComponent(ct.active) && (pe[ct.queryParameter] = ct.active, Ke = !0);
      }), (!v.formattedData || v.formattedData.urlFiltered) && !Ke)
        return;
      let ht = `${Ne.origin}${Ne.pathname}${Object.keys(pe).map((ct, Kt) => {
        let Ot = Kt === 0 ? "?" : "&";
        return Ot += ct + "=", Ot += pe[ct], Ot;
      }).join("")}`, it = [];
      try {
        const ct = km(Ne.href);
        ct === "csv" || Ap(ht) ? it = await fetch(ht).then((Kt) => Kt.text()).then((Kt) => Bp.parse(Kt, {
          header: !0,
          dynamicTyping: !0,
          skipEmptyLines: !0
        }).data) : ct === "json" || Lp(ht) ? it = await fetch(ht).then((Kt) => Kt.json()) : it = [];
      } catch {
        console.error(`Cannot parse URL: ${ht}`), it = [];
      }
      v.dataDescription && (it = x.autoStandardize(it), it = x.developerStandardize(it, v.dataDescription)), Object.assign(it, { urlFiltered: !0 }), it = hf(it, v), _e({ ...v, runtimeDataUrl: ht, data: it, formattedData: it }), it && (R(it), U(it), te(Ni(v.filters, it)));
    }
  }, Le = async () => {
    const Se = lt.cloneDeep(t) || await (await fetch(e)).json();
    let Ne = Se.data || [];
    const pe = Se.filters ? Se.filters.filter((it) => it.type === "url").length > 0 : !1;
    if (Se.dataUrl && !pe)
      try {
        const it = km(Se.dataUrl);
        (it === "csv" || Ap(Se.dataUrl)) && (Ne = await fetch(Se.dataUrl + `?v=${Gp()}`).then((ct) => ct.text()).then((ct) => (ct = ct.replace(/(".*?")|,/g, (...Ot) => Ot[1] || "|"), ct = ct.replace(/["]+/g, ""), Bp.parse(ct, {
          //quotes: "true",  // dont need these
          //quoteChar: "'",  // has no effect that I can tell
          header: !0,
          dynamicTyping: !0,
          skipEmptyLines: !0,
          delimiter: "|"
          // we are using pipe symbol as delimiter so setting this explicitly for Papa.parse
        }).data))), (it === "json" || Lp(Se.dataUrl)) && (Ne = await fetch(Se.dataUrl + `?v=${Gp()}`).then((ct) => ct.json()));
      } catch {
        console.error(`COVE: Cannot parse URL: ${Se.dataUrl}`), Ne = [];
      }
    Se.dataDescription && (Ne = x.autoStandardize(Ne), Ne = x.developerStandardize(Ne, Se.dataDescription)), Ne = hf(Ne, Se), Ne && (R(Ne), U(Ne)), Se !== void 0 && Se.table !== void 0 && (!Se.table || !Se.table.showVertical) && (Se.table = Se.table || {}, Se.table.showVertical = !1);
    let Ke = { ...pf, ...Se };
    Ke.table.show === void 0 && (Ke.table.show = !i), Ke.series.forEach((it) => {
      (it.tooltip === void 0 || it.tooltip === null) && (it.tooltip = !0), it.axis || (it.axis = "Left");
    }), Ne && (Ke.data = Ne);
    const ht = { ...jg(Ke) };
    _e(ht, Ne);
  }, _e = (Se, Ne) => {
    var ct, Kt, Ot;
    const pe = lt.cloneDeep(Se);
    let Ke = Ne || C;
    Ke = hf(Ke, pe), Object.keys(pf).forEach((tt) => {
      pe[tt] && typeof pe[tt] == "object" && !Array.isArray(pe[tt]) && (pe[tt] = { ...pf[tt], ...pe[tt] });
    });
    let ht = [];
    if (pe.exclusions && pe.exclusions.active)
      if (pe.xAxis.type === "categorical" && ((ct = pe.exclusions.keys) == null ? void 0 : ct.length) > 0)
        ht = Ke.filter((tt) => !pe.exclusions.keys.includes(tt[pe.xAxis.dataKey]));
      else if (Rn(pe.xAxis) && (pe.exclusions.dateStart || pe.exclusions.dateEnd) && pe.xAxis.dateParseFormat) {
        const tt = (Ft) => new Date(Ft).getTime();
        let ut = tt(pe.exclusions.dateStart), It = tt(pe.exclusions.dateEnd) + 86399999, Rt = typeof ut !== void 0 && isNaN(ut) === !1, Ht = typeof It !== void 0 && isNaN(It) === !1;
        Rt && Ht ? ht = Ke.filter(
          (Ft) => tt(Ft[pe.xAxis.dataKey]) >= ut && tt(Ft[pe.xAxis.dataKey]) <= It
        ) : Rt ? ht = Ke.filter((Ft) => tt(Ft[pe.xAxis.dataKey]) >= ut) : Ht && (ht = Ke.filter((Ft) => tt(Ft[pe.xAxis.dataKey]) <= It));
      } else
        ht = Ne || C;
    else
      ht = Ne || C;
    U(ht);
    let it = [];
    if (pe.filters) {
      const tt = uv(pe.filters, ht);
      it = Ni(tt, ht), te(it);
    }
    if (pe.xAxis.type === "date-time" && v.orientation === "horizontal" && (pe.xAxis.type = "date"), pe.runtime = {}, pe.runtime.series = pe.dynamicSeries ? [] : lt.cloneDeep(pe.series), pe.runtime.seriesLabels = {}, pe.runtime.seriesLabelsAll = [], pe.runtime.originalXAxis = pe.xAxis, pe.dynamicSeries) {
      let tt = Ne || pe.formattedData || pe.data;
      tt != null && tt.length && Object.keys(tt[0]).forEach((ut) => {
        ut !== pe.xAxis.dataKey && (!pe.filters || pe.filters.filter((It) => It.columnName === ut).length === 0) && (!pe.columns || Object.keys(pe.columns).indexOf(ut) === -1) && pe.runtime.series.push({
          dataKey: ut,
          type: pe.dynamicSeriesType,
          lineType: pe.dynamicSeriesLineType,
          tooltip: !0
        });
      });
    }
    if (pe.visualizationType === "Pie")
      pe.runtime.seriesKeys = (Ne || Ke).map((tt) => tt[pe.xAxis.dataKey]), pe.runtime.seriesLabelsAll = pe.runtime.seriesKeys;
    else {
      const tt = Ne || pe.formattedData || pe.data;
      pe.runtime.seriesKeys = (pe.runtime.series || []).flatMap((ut) => {
        if (ut.dynamicCategory) {
          lt.remove(pe.runtime.seriesLabelsAll, (Rt) => Rt === ut.dataKey), lt.remove(pe.runtime.series, (Rt) => Rt.dataKey === ut.dataKey);
          const It = lt.uniq(tt.map((Rt) => Rt[ut.dynamicCategory]));
          return It.forEach((Rt) => {
            pe.runtime.seriesLabels[Rt] = Rt, pe.runtime.seriesLabelsAll.push(Rt), pe.runtime.series.push({
              dataKey: Rt,
              type: ut.type,
              lineType: ut.lineType,
              originalDataKey: ut.dataKey,
              dynamicCategory: ut.dynamicCategory,
              tooltip: !0
            });
          }), It;
        } else
          return pe.runtime.seriesLabels[ut.dataKey] = ut.name || ut.label || ut.dataKey, pe.runtime.seriesLabelsAll.push(ut.name || ut.dataKey), [ut.dataKey];
      });
    }
    if (pe.visualizationType === "Box Plot" && pe.series) {
      const tt = j || Ke, ut = lt.uniq(lt.map(tt, pe.xAxis.dataKey)), It = lt.map(pe.series, "dataKey"), Rt = [];
      ut.forEach((Ft) => {
        It.forEach((hn) => {
          try {
            if (!Ft)
              throw new bt("No groups resolved in box plots");
            const { count: mn, sortedData: Mt } = lt.chain(tt).filter((we) => we[pe.xAxis.dataKey] === Ft).thru((we) => ({
              count: we.length,
              sortedData: lt.map(we, (g) => Number(g[hn])).sort()
            })).value(), kn = Gw(Mt);
            if (!Mt)
              throw new bt("boxplots dont have data yet");
            if (!Rt)
              throw new bt("boxplots dont have plots yet");
            const wn = kn.q1, On = kn.q3, Nn = On - wn, Ln = wn - 1.5 * Nn, fn = On + 1.5 * Nn, Fn = Mt.filter((we) => we <= fn), Zt = Qu(Fn);
            Rt.push({
              columnCategory: Ft,
              columnMax: Zt,
              columnThirdQuartile: lt.round(On, pe.dataFormat.roundTo),
              columnMedian: Number(Hm(Mt)).toFixed(pe.dataFormat.roundTo),
              columnFirstQuartile: lt.round(wn, pe.dataFormat.roundTo),
              columnMin: lt.min(Mt),
              columnCount: mn,
              columnSd: Number(pv(Mt)).toFixed(pe.dataFormat.roundTo),
              columnMean: Number(hv(Mt)).toFixed(pe.dataFormat.roundTo),
              columnIqr: lt.round(Nn, pe.dataFormat.roundTo),
              values: Mt,
              columnLowerBounds: Ln,
              columnUpperBounds: fn,
              columnOutliers: lt.filter(Mt, (we) => we < Ln || we > fn),
              columnNonOutliers: lt.filter(Mt, (we) => we >= Ln && we <= fn)
            });
          } catch (mn) {
            console.error("COVE: ", mn.message);
          }
        });
      });
      const Ht = It.length > 1 ? lt.flatMap(ut, (Ft) => lt.map(It, (hn) => `${lt.capitalize(hn)} - ${lt.capitalize(Ft)}`)) : ut;
      pe.boxplot.categories = Ht, pe.boxplot.plots = Rt;
    }
    pe.visualizationType === "Combo" && pe.series && (pe.runtime.barSeriesKeys = [], pe.runtime.lineSeriesKeys = [], pe.runtime.areaSeriesKeys = [], pe.runtime.forecastingSeriesKeys = [], pe.series.forEach((tt) => {
      tt.type === "Area Chart" && pe.runtime.areaSeriesKeys.push(tt), tt.type === "Forecasting" && pe.runtime.forecastingSeriesKeys.push(tt), (tt.type === "Bar" || tt.type === "Combo") && pe.runtime.barSeriesKeys.push(tt.dataKey), (tt.type === "Line" || tt.type === "dashed-sm" || tt.type === "dashed-md" || tt.type === "dashed-lg") && pe.runtime.lineSeriesKeys.push(tt.dataKey), tt.type === "Combo" && (tt.type = "Bar");
    })), pe.visualizationType === "Forecasting" && pe.series && (pe.runtime.forecastingSeriesKeys = [], pe.series.forEach((tt) => {
      tt.type === "Forecasting" && pe.runtime.forecastingSeriesKeys.push(tt);
    })), pe.visualizationType === "Area Chart" && pe.series && (pe.runtime.areaSeriesKeys = [], pe.series.forEach((tt) => {
      pe.runtime.areaSeriesKeys.push({ ...tt, type: "Area Chart" });
    })), pe.visualizationType === "Bar" && pe.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(pe.visualizationType) ? (pe.runtime.xAxis = pe.yAxis.yAxis ? pe.yAxis.yAxis : pe.yAxis, pe.runtime.yAxis = pe.xAxis.xAxis ? pe.xAxis.xAxis : pe.xAxis, pe.runtime.yAxis.labelOffset *= -1, pe.runtime.horizontal = !1, pe.orientation = "horizontal", pe.yAxis.type = pe.yAxis.type === "categorical" ? "linear" : pe.yAxis.type) : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(pe.visualizationType) && !He() ? (pe.runtime.xAxis = pe.xAxis, pe.runtime.yAxis = pe.yAxis, pe.runtime.horizontal = !1, pe.orientation = "vertical") : (pe.runtime.xAxis = pe.xAxis, pe.runtime.yAxis = pe.yAxis, pe.runtime.horizontal = !1), pe.runtime.uniqueId = Date.now(), pe.runtime.editorErrorMessage = pe.visualizationType === "Pie" && !pe.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", pe.runtime.editorErrorMessage = "", (Kt = pe.legend.seriesHighlight) != null && Kt.length && $((Ot = pe.legend) == null ? void 0 : Ot.seriesHighlight), N(pe);
  }, st = (Se, Ne) => {
    let pe = v.visualizationType === "Bar" && v.visualizationSubType === "horizontal" ? v.xAxis.dataKey : v.yAxis.sortKey, Ke = parseFloat(Se[pe]), ht = parseFloat(Ne[pe]);
    return Ke < ht ? v.sortData === "ascending" ? 1 : -1 : Ke > ht ? v.sortData === "ascending" ? -1 : 1 : 0;
  }, Ee = new wg((Se) => {
    for (let Ne of Se) {
      let { width: pe, height: Ke } = Ne.contentRect;
      const ht = 15;
      pe = r ? pe - 350 : pe;
      const ct = Cg(pe);
      ne(ct), Ne.target.dataset.lollipop === "true" && (pe = pe - 2.5), pe = pe - ht, W([pe, Ke]);
    }
  }), rt = ue.useCallback((Se) => {
    Se !== null && Ee.observe(Se), K(Se);
  }, []), pt = (Se) => Object.keys(Se).length === 0;
  ue.useEffect(() => {
    Le();
  }, [(Gn = t == null ? void 0 : t.data) != null && Gn.length ? t.data : null]), ue.useEffect(() => {
    Ge();
  }, [JSON.stringify(v.filters)]), ue.useEffect(() => {
    oe && !pt(v) && !Y && (Hg("cove_loaded", { config: v }), X(!0));
  }, [oe, v]), ue.useEffect(() => {
    const Se = (Ne) => {
      let pe = [];
      pe.push(Ne.detail), ae(pe);
    };
    return Vg("cove_filterData", (Ne) => Se(Ne)), () => {
      Wg("cove_filterData", Se);
    };
  }, [v]), ue.useEffect(() => {
    if (ie && ie[0] && !ie[0].hasOwnProperty("active")) {
      let Ne = { ...v };
      delete Ne.filters, N(Ne), te(Ni(ie, _));
    }
    if (ie && ie.length > 0 && ie.length > 0 && ie[0].hasOwnProperty("active")) {
      let Se = { ...v, filters: ie };
      N(Se), te(Ni(ie, _));
    }
  }, [ie]), ue.useEffect(() => {
    ["Bump Chart"].includes(v.visualizationType) && N({
      ...v,
      xAxis: {
        ...v.xAxis,
        type: "date-time"
      }
    });
  }, [v.visualizationType]), ue.useEffect(() => {
    var Se;
    if (C && v.xAxis && ((Se = v.runtime) != null && Se.seriesKeys)) {
      const Ne = ["Paired Bar", "Deviation Bar"].includes(v.visualizationType) ? v.twoColor.palette : v.palette, pe = { ...vr, ...Cs };
      let Ke = v.customColors || pe[Ne], ht = v.runtime.seriesKeys.length, it;
      for (; ht > Ke.length; )
        Ke = Ke.concat(Ke);
      Ke = Ke.slice(0, ht), it = () => Ii({
        domain: v.runtime.seriesLabelsAll,
        range: Ke,
        unknown: null
      }), b(it), S(!1);
    }
    v && C && v.sortData && C.sort(st);
  }, [v, C]);
  const ft = (Se) => {
    if (Q.length + 1 === v.runtime.seriesKeys.length && v.visualizationType !== "Forecasting") {
      wt();
      return;
    }
    const Ne = [...Q];
    let pe = Se.datum;
    v.runtime.seriesLabels && v.runtime.seriesKeys.forEach((Ke) => {
      v.runtime.seriesLabels[Ke] === Se.datum && (pe = Ke);
    }), Ne.indexOf(pe) !== -1 ? Ne.splice(Ne.indexOf(pe), 1) : Ne.push(pe), $(Ne);
  }, wt = () => {
    try {
      const Se = Ae.current;
      if (!Se)
        throw new bt("No legend available to set previous focus on.");
      Se.focus();
    } catch (Se) {
      console.error("COVE:", Se.message);
    }
    $([]);
  }, zt = v.orientation === "horizontal" ? "yAxis" : "xAxis", Jt = (Se, Ne = !0) => {
    let pe = yy(v.runtime[zt].dateParseFormat)(Se);
    return pe || (Ne && (v.runtime.editorErrorMessage = `Error parsing date "${Se}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, jt = (Se, Ne, pe) => {
    var ht, it;
    let Ke = Uu(v.runtime[zt].dateDisplayFormat)(Se);
    if ((ht = v.runtime[zt].dateDisplayFormat) != null && ht.includes("%b.") && Ke.includes("May.") && (Ke = Ke.replace(/May\./g, "May")), v.xAxis.showYearsOnce && ((it = v.runtime[zt].dateDisplayFormat) != null && it.includes("%Y")) && pe) {
      const ct = pe[Ne - 1] ? pe[Ne - 1].value : null, Kt = Uu(v.runtime[zt].dateDisplayFormat)(ct), Ot = Ke.match(/\d{4}/), tt = Kt.match(/\d{4}/);
      Ot && tt && Ot[0] === tt[0] && (Ke = Ke.replace(Ot, ""));
    }
    return Ke;
  }, on = (Se) => Uu(v.tooltips.dateDisplayFormat)(Se), _t = (Se, Ne, pe = !1, Ke, ht, it, { index: ct, length: Kt } = { index: null, length: null }) => {
    if (isNaN(Se) || !Se)
      return Se;
    const Ot = Se < 0;
    (Ne === void 0 || !Ne) && (Ne = "left"), Ot && (Se = Math.abs(Se));
    let {
      dataFormat: {
        commas: tt,
        abbreviated: ut,
        roundTo: It,
        prefix: Rt,
        suffix: Ht,
        rightRoundTo: Ft,
        bottomRoundTo: hn,
        rightPrefix: mn,
        rightSuffix: Mt,
        bottomPrefix: kn,
        bottomSuffix: wn,
        bottomAbbreviated: On,
        onlyShowTopPrefixSuffix: Nn
      }
    } = v;
    String(Se).indexOf(",") !== -1 && (Se = Se.replaceAll(",", ""));
    let Ln = Se, fn = {
      useGrouping: !!tt
      // for old chart data table to work right cant just leave this to undefined
    };
    if (Ne === "left" || Ne === void 0) {
      let we;
      it !== void 0 ? we = it ? Number(it) : 0 : we = It ? Number(It) : 0, fn = {
        useGrouping: it ? !0 : !!v.dataFormat.commas,
        minimumFractionDigits: we,
        maximumFractionDigits: we
      };
    }
    Ne === "right" && (fn = {
      useGrouping: !!v.dataFormat.rightCommas,
      minimumFractionDigits: Ft ? Number(Ft) : 0,
      maximumFractionDigits: Ft ? Number(Ft) : 0
    });
    const Fn = () => v.forestPlot.type === "Logarithmic" && !hn ? 2 : Number(hn) ? Number(hn) : 0;
    if (Ne === "bottom" && (fn = {
      useGrouping: !!v.dataFormat.bottomCommas,
      minimumFractionDigits: Fn(),
      maximumFractionDigits: Fn()
    }), Se = Yp(Se), isNaN(Se))
      return v.runtime.editorErrorMessage = `Unable to parse number from data ${Ln}. Try reviewing your data and selections in the Data Series section.`, Ln;
    if (!v.dataFormat)
      return Se;
    if (v.dataCutoff) {
      let we = Yp(v.dataCutoff);
      Se < we && (Se = we);
    }
    Ne === "left" && tt && ut && pe || Ne === "bottom" && tt && ut && pe ? Se = Se : Se = Se.toLocaleString("en-US", fn);
    let Zt = "";
    if (ut && Ne === "left" && pe && (Se = bm(parseFloat(Se))), On && Ne === "bottom" && pe && (Se = bm(parseFloat(Se))), Ke && Ne === "left")
      Zt = Ke + Zt;
    else {
      const we = Nn && Kt - 1 !== ct;
      Rt && Ne === "left" && !we && (Zt += Rt);
    }
    return mn && Ne === "right" && (Zt += mn), kn && Ne === "bottom" && (Zt += kn), Zt += Se, ht && Ne === "left" ? Zt += ht : Ht && Ne === "left" && !Nn && (Zt += Ht), Mt && Ne === "right" && (Zt += Mt), wn && Ne === "bottom" && (Zt += wn), Ot && (Zt = "-" + Zt), String(Zt);
  }, tn = () => {
    if (v.visualizationType === "Sankey" || v.visualizationType === "Forecasting" || v.visualizationType === "Forest Plot")
      return !1;
    if (v.visualizationType === "Pie") {
      if ((v == null ? void 0 : v.yAxis.dataKey) === void 0)
        return !0;
    } else if (((v == null ? void 0 : v.series) === void 0 || !((v == null ? void 0 : v.series.length) > 0)) && !(v != null && v.dynamicSeries))
      return !0;
    return !v.xAxis.dataKey;
  }, $t = (Se, Ne) => {
    if (Se === null || Se === "" || Se === void 0)
      return "";
    if (typeof Se == "string" && Se.length > 0 && v.legend.type === "equalnumber")
      return Se;
    let pe = Se, Ke;
    if (Object.keys(v.columns).length > 0 && Object.keys(v.columns).forEach(function(ht) {
      var it = v.columns[ht];
      it.name === Ne && (Ke = it);
    }), Ke === void 0 && (Ke = v.type === "chart" ? v.dataFormat : v.primary, Ke.useCommas = Ke.commas, Ke.roundToPlace = Ke.roundTo ? Ke.roundTo : ""), Ke) {
      let ht = !1, it = 0;
      Number(Se) && (Ke.roundToPlace >= 0 && (ht = Ke.roundToPlace ? Ke.roundToPlace !== "" || Ke.roundToPlace !== null : !1, it = Ke.roundToPlace ? Number(Ke.roundToPlace) : 0, Ke.hasOwnProperty("roundToPlace") && ht && (pe = Number(Se).toFixed(it))), Ke.hasOwnProperty("useCommas") && Ke.useCommas === !0 && (pe = Number(Se).toLocaleString("en-US", {
        style: "decimal",
        minimumFractionDigits: ht ? it : 0,
        maximumFractionDigits: ht ? it : 5
      }))), pe = (Ke.prefix || "") + pe + (Ke.suffix || "");
    }
    return pe;
  }, Ut = () => {
    const Se = (pe) => {
      pe && pe.preventDefault();
      let Ke = { ...v };
      delete Ke.newViz, _e(Ke);
    }, Ne = {
      position: "relative",
      height: "100vh",
      width: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gridArea: "content"
    };
    return /* @__PURE__ */ n.createElement("section", { className: "waiting", style: Ne }, /* @__PURE__ */ n.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ n.createElement("h3", null, "Finish Configuring"), /* @__PURE__ */ n.createElement("p", null, "Set all required options to the left and confirm below to display a preview of the chart."), /* @__PURE__ */ n.createElement(
      Rc,
      {
        className: "btn btn-primary",
        style: { margin: "1em auto" },
        disabled: tn(),
        onClick: (pe) => Se(pe)
      },
      "I'm Done"
    )));
  }, bt = () => {
    const Se = {
      position: "absolute",
      background: "white",
      zIndex: "999",
      height: "100vh",
      width: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gridArea: "content"
    };
    return /* @__PURE__ */ n.createElement("section", { className: "waiting", style: Se }, /* @__PURE__ */ n.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ n.createElement("h3", null, "Error With Configuration"), /* @__PURE__ */ n.createElement("p", null, v.runtime.editorErrorMessage)));
  }, mt = (Se) => {
    try {
      if (!Se)
        throw new bt("COVE: No rowObj in applyLegendToRow");
      if (v.type === "navigation") {
        let Ne = vr[v.color] || vr.bluegreenreverse;
        return Sm(Ne[3]);
      }
      return Sm();
    } catch (Ne) {
      console.error("COVE: ", Ne);
    }
  }, ln = (Se) => {
    var Ne, pe;
    return Array.isArray(Se) ? v.visualizationType === "Forecasting" || (Ne = v.series) != null && Ne.some((Ke) => !!Ke.dynamicCategory) ? Se : (pe = v == null ? void 0 : v.xAxis) != null && pe.dataKey ? x.cleanData(Se, v.xAxis.dataKey) : Se : [];
  }, Yt = () => {
    var Ke, ht, it;
    if (ve === "Sankey")
      return (ht = (Ke = v == null ? void 0 : v.data) == null ? void 0 : Ke[0]) == null ? void 0 : ht.tableData;
    const Se = j || _, Ne = v.series.find((ct) => !!ct.dynamicCategory);
    if (!Ne)
      return Se;
    const pe = Object.values(v.columns).filter((ct) => ct.dataTable).map((ct) => ct.name).concat([Ne.dynamicCategory, Ne.dataKey]);
    return (it = v.xAxis) != null && it.dataKey && pe.push(v.xAxis.dataKey), Se.map((ct) => lt.pick(ct, pe));
  }, xt = (Se) => {
    const Ne = lt.cloneDeep(Se), pe = Ne.series.find((Ke) => !!Ke.dynamicCategory);
    if (pe) {
      const Ke = { columnName: pe.dynamicCategory, valueColumns: [pe.dataKey] };
      Ne.table.pivot = Ke;
    }
    return Ne;
  };
  let Gt = /* @__PURE__ */ n.createElement(Qg, null);
  const Sn = (Se) => {
    if (!(!Se || !Se.toLowerCase))
      return Se.toLowerCase().replaceAll(/ /g, "-");
  }, At = () => {
    var pe;
    const Se = (Oe == null ? void 0 : Oe.position) === "bottom" || ya(J), Ne = ["chart-container", "p-relative"];
    return Oe != null && Oe.position && (ya(J) && (Oe == null ? void 0 : Oe.position) !== "top" ? Ne.push("legend-bottom") : Ne.push(`legend-${Oe.position}`)), Oe != null && Oe.hide && Ne.push("legend-hidden"), Ze && Ne.push(Ze), v.barHasBorder || Ne.push("chart-bar--no-border"), (pe = v.brush) != null && pe.active && (y == null ? void 0 : y.type) === "dashboard" && (!Se || Oe.hide) && Ne.push("dashboard-brush"), Ne.push(...Ie), Ne;
  }, nn = () => {
    var pe, Ke;
    const Se = ["subtext "], Ne = (Oe == null ? void 0 : Oe.position) === "bottom" || ya(J);
    return v.isResponsiveTicks && Se.push("subtext--responsive-ticks "), (pe = v.brush) != null && pe.active && !Ne && Se.push("subtext--brush-active "), (Ke = v.brush) != null && Ke.active && v.legend.hide && Se.push("subtext--brush-active "), Se;
  };
  if (!T) {
    const Se = /* @__PURE__ */ n.createElement("a", { href: `#data-table-${v.dataKey}`, className: "margin-left-href" }, v.dataKey, " (Go to Table)");
    Gt = /* @__PURE__ */ n.createElement(n.Fragment, null, r && /* @__PURE__ */ n.createElement(Yw, null), /* @__PURE__ */ n.createElement(mf.Responsive, { isEditor: r }, v.newViz && /* @__PURE__ */ n.createElement(Ut, null), v.newViz === void 0 && r && v.runtime && ((An = v.runtime) == null ? void 0 : An.editorErrorMessage) && /* @__PURE__ */ n.createElement(bt, null), !tn() && !v.newViz && /* @__PURE__ */ n.createElement(
      "div",
      {
        className: `cdc-chart-inner-container cove-component__content type-${Sn(
          v.visualizationType
        )}`,
        "aria-label": If(v),
        tabIndex: 0
      },
      /* @__PURE__ */ n.createElement(
        Gg,
        {
          showTitle: v.showTitle,
          isDashboard: i,
          title: Ve,
          superTitle: v.superTitle,
          classes: ["chart-title", `${v.theme}`, "cove-component__header"],
          style: void 0
        }
      ),
      /* @__PURE__ */ n.createElement("div", { className: At().join(" ") }, (v == null ? void 0 : v.introText) && v.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement("section", { className: "introText " }, Mi(v.introText)), v.filters && !ie && v.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement(
        Kp,
        {
          config: v,
          setConfig: N,
          setFilteredData: te,
          filteredData: j,
          excludedData: _,
          filterData: Ni,
          dimensions: z
        }
      ), /* @__PURE__ */ n.createElement(Ip, { skipId: hs(v, et), skipMessage: "Skip Over Chart Container" }), ((Un = v.annotations) == null ? void 0 : Un.length) > 0 && /* @__PURE__ */ n.createElement(
        Ip,
        {
          skipId: hs(v, et),
          skipMessage: "Skip over annotations",
          key: "skip-annotations"
        }
      ), /* @__PURE__ */ n.createElement(qw, null, /* @__PURE__ */ n.createElement(
        "div",
        {
          className: Oe.hide || ya(J) || Oe.position === "bottom" || Oe.position === "top" || ve === "Sankey" ? "w-100" : "w-75"
        },
        !["Spark Line", "Line", "Sankey", "Pie", "Sankey"].includes(v.visualizationType) && /* @__PURE__ */ n.createElement("div", { ref: fe, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Xo, null, (Ne) => /* @__PURE__ */ n.createElement(df, { ref: A, parentWidth: Ne.width, parentHeight: Ne.height }))),
        v.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(Xo, { className: "justify-content-center d-flex", style: { width: "100%" } }, (Ne) => /* @__PURE__ */ n.createElement(HE, { ref: A, parentWidth: Ne.width, parentHeight: Ne.height })),
        v.visualizationType === "Line" && (He() ? /* @__PURE__ */ n.createElement("div", { ref: fe, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Xo, null, (Ne) => /* @__PURE__ */ n.createElement(df, { ref: A, parentWidth: Ne.width, parentHeight: Ne.height }))) : /* @__PURE__ */ n.createElement("div", { ref: fe, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Xo, null, (Ne) => /* @__PURE__ */ n.createElement(df, { ref: A, parentWidth: Ne.width, parentHeight: Ne.height })))),
        v.visualizationType === "Spark Line" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
          Kp,
          {
            config: v,
            setConfig: N,
            setFilteredData: te,
            filteredData: j,
            excludedData: _,
            filterData: Ni,
            dimensions: z
          }
        ), (v == null ? void 0 : v.introText) && /* @__PURE__ */ n.createElement("section", { className: "introText", style: { padding: "0px 0 35px" } }, Mi(v.introText)), /* @__PURE__ */ n.createElement("div", { style: { height: "100px", width: "100%", ...qe } }, /* @__PURE__ */ n.createElement(Xo, null, (Ne) => /* @__PURE__ */ n.createElement(Gk, { width: Ne.width, height: Ne.height }))), Te && /* @__PURE__ */ n.createElement("div", { className: "subtext", style: { padding: "35px 0 15px" } }, Mi(Te))),
        v.visualizationType === "Sankey" && /* @__PURE__ */ n.createElement(Xo, { "aria-hidden": "true" }, (Ne) => /* @__PURE__ */ n.createElement(vS, { runtime: v.runtime, width: Ne.width, height: Ne.height }))
      ), !v.legend.hide && v.visualizationType !== "Spark Line" && v.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(hw, { ref: Ae, skipId: hs(v, et) })), i && v.table && v.table.show && v.table.showDataTableLink ? Se : s && s, Te && v.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement("div", { className: nn().join("") }, Mi(Te)), /* @__PURE__ */ n.createElement(zd.Section, { classes: ["download-buttons"] }, v.table.showDownloadImgButton && /* @__PURE__ */ n.createElement(
        zd.Button,
        {
          text: "Download Image",
          title: "Download Chart as Image",
          type: "image",
          state: v,
          elementToCapture: me
        }
      ), v.table.showDownloadPdfButton && /* @__PURE__ */ n.createElement(
        zd.Button,
        {
          text: "Download PDF",
          title: "Download Chart as PDF",
          type: "pdf",
          state: v,
          elementToCapture: me
        }
      )), (v.xAxis.dataKey && v.table.show && v.visualizationType !== "Spark Line" && v.visualizationType !== "Sankey" || v.visualizationType === "Sankey" && v.table.show) && /* @__PURE__ */ n.createElement(
        Zg,
        {
          config: xt(v),
          rawData: v.visualizationType === "Sankey" ? (Pn = (_n = v == null ? void 0 : v.data) == null ? void 0 : _n[0]) == null ? void 0 : Pn.tableData : v.table.customTableConfig ? Ni(v.filters, v.data) : v.data,
          runtimeData: Yt(),
          expandDataTable: v.table.expanded,
          columns: v.columns,
          displayDataAsText: $t,
          displayGeoName: (Ne) => Ne,
          applyLegendToRow: mt,
          tableTitle: v.table.label,
          indexTitle: v.table.indexLabel,
          vizTitle: Ve,
          viewport: J,
          tabbingId: hs(v, et),
          colorScale: E
        }
      ), ((pn = v == null ? void 0 : v.annotations) == null ? void 0 : pn.length) > 0 && /* @__PURE__ */ n.createElement(Sp.Dropdown, null)),
      (v == null ? void 0 : v.footnotes) && /* @__PURE__ */ n.createElement("section", { className: "footnotes" }, Mi(v.footnotes))
    )));
  }
  const xn = {
    brushConfig: Fe,
    capitalize: (Se) => Se.charAt(0).toUpperCase() + Se.slice(1),
    clean: ln,
    colorPalettes: vr,
    colorScale: E,
    config: v,
    currentViewport: J,
    dashboardConfig: y,
    debugSvg: a,
    dimensions: z,
    dynamicLegendItems: ge,
    excludedData: _,
    formatDate: jt,
    formatNumber: _t,
    formatTooltipsDate: on,
    getXAxisData: (Se) => Rn(v.runtime.xAxis) ? Jt(Se[v.runtime.originalXAxis.dataKey]).getTime() : Se[v.runtime.originalXAxis.dataKey],
    getYAxisData: (Se, Ne) => Se[Ne],
    handleChartAriaLabels: If,
    handleLineType: xg,
    handleChartTabbing: hs,
    highlight: ft,
    highlightReset: wt,
    imageId: me,
    isDashboard: i,
    isLegendBottom: (Oe == null ? void 0 : Oe.position) === "bottom" || ya(J),
    isDebug: a,
    isDraggingAnnotation: q,
    handleDragStateChange: ze,
    isEditor: r,
    isNumber: Ki,
    legend: Oe,
    legendId: et,
    legendRef: Ae,
    lineOptions: Xw,
    loading: T,
    missingRequiredSections: tn,
    outerContainerRef: rt,
    parentRef: fe,
    parseDate: Jt,
    rawData: lt.cloneDeep(C) ?? {},
    seriesHighlight: Q,
    setBrushConfig: Ue,
    setConfig: N,
    setDynamicLegendItems: De,
    setEditing: d,
    setFilteredData: te,
    setParentConfig: o,
    setSeriesHighlight: $,
    setSharedFilter: p,
    setSharedFilterValue: m,
    svgRef: A,
    tableData: j || _,
    // do not clean table data
    transformedData: ln(j || _),
    // do this right before passing to components
    twoColorPalette: Cs,
    unfilteredData: lt.cloneDeep(C),
    updateConfig: _e
  };
  return /* @__PURE__ */ n.createElement(gt.Provider, { value: xn }, /* @__PURE__ */ n.createElement(
    mf.VisualizationWrapper,
    {
      config: v,
      isEditor: r,
      currentViewport: J,
      ref: rt,
      imageId: me,
      showEditorPanel: v == null ? void 0 : v.showEditorPanel
    },
    Gt
  ));
}, LC = Zw;
export {
  LC as C,
  gw as D,
  bg as F,
  xw as V,
  yw as a,
  Vw as f
};
