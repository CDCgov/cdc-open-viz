import { R as n, r as se } from "./storybook-index-45401197.es.js";
import { v as Ap, i as Sg, g as kg } from "./storybook-getViewport-513ec896.es.js";
import { _ as ea, p as Lp, S as Li, U as qr, W as jt, X as Pp, Y as Ac, Z as ar, t as Iu, $ as Jo, a0 as Md, a1 as Rp, a2 as tr, a3 as Np, a4 as wg, a5 as Tg, l as Dp, a6 as Sr, v as al, P as Cg, d as Ag, b as Qo, g as _p, e as Op, h as Lg, y as Pg, R as Rg, a7 as hr, u as il, a as Lc, x as Sm, a8 as Yu, s as Ng, j as Gf, J as km, K as wm, O as Gu, N as Tm, H as Dg, C as Fp, o as _g, M as Cm, E as Og, q as Fg, r as Am, L as Mg, G as zg, a9 as Pc, F as Bg, B as Ig, I as Mp, D as $g, z as Hg, V as Vg, A as Wg } from "./storybook-InputToggle-1e77d9ab.es.js";
import { L as mf, u as jg, p as Ug, s as Kg, a as Yg, c as Gg } from "./storybook-coveUpdateWorker-4c7dbbf1.es.js";
import { B as Rc } from "./storybook-Button-63da743c.es.js";
import { a as Rn, f as Xf, t as Xg, b as is, L as zp, S as Bp, M as zd, D as qg } from "./storybook-DataTable-897188ef.es.js";
import { H as Oi, T as Zg } from "./storybook-index-3b47b3f7.es.js";
import { a as Va, E as Vr, b as yf, L as Qg } from "./storybook-viewports-5c5d7af1.es.js";
import { p as Jg, P as Me } from "./storybook-index-43433e35.es.js";
import { d as ev } from "./storybook-debounce-cc216a80.es.js";
import { a as tv } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { _ as et } from "./storybook-lodash-a4231e1c.es.js";
import { _ as yn } from "./storybook-extends-70f3d2a3.es.js";
import { s as fs, t as Lm, a as Pm, b as Rm, B as Rr, d as Ls, c as Vn, C as nv } from "./storybook-linear-bc5fb9aa.es.js";
import { t as rv, u as Ip, G as tt, c as Nn, q as Nc, v as av, w as Nm, x as $p, y as iv, z as ov, A as lv, B as sv } from "./storybook-linear-ef79b404.es.js";
import { R as uv } from "./storybook-index-633d712d.es.js";
import { T as ct } from "./storybook-Text-c19e6344.es.js";
import { t as Dm, m as Bd, f as _m, d as Su, a as ku, b as wu, n as Hp, o as cv, p as Vp, c as Om, e as Fm } from "./storybook-year-24bd1dc7.es.js";
import { e as Ua, a as Mn, b as zn, c as Bn, d as In, A as Fi, D as Mm } from "./storybook-DataTransform-6163e156.es.js";
import { a as Ue, S as zm } from "./storybook-Icon-4f5978ba.es.js";
import { B as Wp } from "./storybook-BlurStrokeText-adc27352.es.js";
import { T as ie } from "./storybook-Tooltip-4102bd69.es.js";
import { T as We, S as dt, C as Qe } from "./storybook-Inputs-b80d0cf3.es.js";
import { M as jp } from "./storybook-MultiSelect-d587cce3.es.js";
import { I as Ka } from "./storybook-InputSelect-20478396.es.js";
import { A as Tu } from "./storybook-Accordion-2501c7d9.es.js";
import { f as Uo, F as Up, a as dv } from "./storybook-Filters-ce4a04a7.es.js";
import { n as Kp } from "./storybook-numberFromString-24623c03.es.js";
const gf = (e) => {
  if (e.visualizationType === "Sankey" || e.visualizationType === "Forecasting" || e.visualizationType === "Forest Plot")
    return !1;
  if (e.visualizationType === "Pie") {
    if ((e == null ? void 0 : e.yAxis.dataKey) === void 0)
      return !0;
  } else if (((e == null ? void 0 : e.series) === void 0 || !((e == null ? void 0 : e.series.length) > 0)) && !(e != null && e.dynamicSeries))
    return !0;
  return !e.xAxis.dataKey;
}, fv = (e) => {
  const { updateConfig: t, config: r } = e, a = (o) => {
    o && o.preventDefault();
    let d = { ...r };
    delete d.newViz, t(d);
  }, i = {
    position: "relative",
    height: "100vh",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gridArea: "content"
  };
  return /* @__PURE__ */ n.createElement("section", { className: "waiting", style: i }, /* @__PURE__ */ n.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ n.createElement("h3", null, "Finish Configuring"), /* @__PURE__ */ n.createElement("p", null, "Set all required options to the left and confirm below to display a preview of the chart."), /* @__PURE__ */ n.createElement(
    Rc,
    {
      className: "btn btn-primary",
      style: { margin: "1em auto" },
      disabled: gf(r),
      onClick: (o) => a(o)
    },
    "I'm Done"
  )));
}, Id = ({ errorMessage: e }) => {
  const t = {
    position: "absolute",
    background: "white",
    zIndex: "999",
    height: "100vh",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gridArea: "content"
  };
  return /* @__PURE__ */ n.createElement("section", { className: "waiting", style: t }, /* @__PURE__ */ n.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ n.createElement("h3", null, "Error With Configuration"), /* @__PURE__ */ n.createElement("p", null, e)));
}, Xu = Dm(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Xu.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Dm((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, r) => {
  t.setTime(+t + r * e);
}, (t, r) => (r - t) / e) : Xu);
Xu.range;
class Yp extends Map {
  constructor(t, r = mv) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), t != null)
      for (const [a, i] of t)
        this.set(a, i);
  }
  get(t) {
    return super.get(Gp(this, t));
  }
  has(t) {
    return super.has(Gp(this, t));
  }
  set(t, r) {
    return super.set(pv(this, t), r);
  }
  delete(t) {
    return super.delete(hv(this, t));
  }
}
function Gp({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) ? e.get(a) : r;
}
function pv({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) ? e.get(a) : (e.set(a, r), r);
}
function hv({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) && (r = e.get(a), e.delete(a)), r;
}
function mv(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function yv(e, t, r) {
  e = +e, t = +t, r = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +r;
  for (var a = -1, i = Math.max(0, Math.ceil((t - e) / r)) | 0, o = new Array(i); ++a < i; )
    o[a] = e + a * r;
  return o;
}
function gv(e, t, r, a, i, o) {
  const d = [
    [fs, 1, Su],
    [fs, 5, 5 * Su],
    [fs, 15, 15 * Su],
    [fs, 30, 30 * Su],
    [o, 1, ku],
    [o, 5, 5 * ku],
    [o, 15, 15 * ku],
    [o, 30, 30 * ku],
    [i, 1, wu],
    [i, 3, 3 * wu],
    [i, 6, 6 * wu],
    [i, 12, 12 * wu],
    [a, 1, Hp],
    [a, 2, 2 * Hp],
    [r, 1, cv],
    [t, 1, Vp],
    [t, 3, 3 * Vp],
    [e, 1, Bd]
  ];
  function c(p, y, g) {
    const b = y < p;
    b && ([p, y] = [y, p]);
    const w = g && typeof g.range == "function" ? g : s(p, y, g), S = w ? w.range(p, +y + 1) : [];
    return b ? S.reverse() : S;
  }
  function s(p, y, g) {
    const b = Math.abs(y - p) / g, w = rv(([, , m]) => m).right(d, b);
    if (w === d.length)
      return e.every(Ip(p / Bd, y / Bd, g));
    if (w === 0)
      return Xu.every(Math.max(Ip(p, y, g), 1));
    const [S, L] = d[b / d[w - 1][2] < d[w][2] / b ? w - 1 : w];
    return S.every(L);
  }
  return [c, s];
}
const [vv, xv] = gv(_m, Rm, Fm, Om, Pm, Lm), ft = se.createContext({}), bv = (e) => {
  const { children: t } = e, { config: r, currentViewport: a } = se.useContext(ft), i = () => {
    let o = ["legend-wrapper", "d-flex", "flex-nowrap", "w-100"];
    const { legend: d } = r;
    return (d.position === "bottom" || d.position === "top" || Va(a)) && (o = o.filter((c) => c !== "flex-nowrap"), o.push("flex-wrap")), o.join(" ");
  };
  return /* @__PURE__ */ n.createElement("div", { className: i() }, ...t);
};
var zi = [], Ev = function() {
  return zi.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Sv = function() {
  return zi.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, Xp = "ResizeObserver loop completed with undelivered notifications.", kv = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: Xp
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = Xp), window.dispatchEvent(e);
}, Ss;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Ss || (Ss = {}));
var Bi = function(e) {
  return Object.freeze(e);
}, Bm = function() {
  function e(t, r) {
    this.inlineSize = t, this.blockSize = r, Bi(this);
  }
  return e;
}(), Im = function() {
  function e(t, r, a, i) {
    return this.x = t, this.y = r, this.width = a, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Bi(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, r = t.x, a = t.y, i = t.top, o = t.right, d = t.bottom, c = t.left, s = t.width, p = t.height;
    return { x: r, y: a, top: i, right: o, bottom: d, left: c, width: s, height: p };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), qf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, $m = function(e) {
  if (qf(e)) {
    var t = e.getBBox(), r = t.width, a = t.height;
    return !r && !a;
  }
  var i = e, o = i.offsetWidth, d = i.offsetHeight;
  return !(o || d || e.getClientRects().length);
}, qp = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var r = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(r && e instanceof r.Element);
}, wv = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ps = typeof window < "u" ? window : {}, Cu = /* @__PURE__ */ new WeakMap(), Zp = /auto|scroll/, Tv = /^tb|vertical/, Cv = /msie|trident/i.test(ps.navigator && ps.navigator.userAgent), Zr = function(e) {
  return parseFloat(e || "0");
}, nl = function(e, t, r) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), r === void 0 && (r = !1), new Bm((r ? t : e) || 0, (r ? e : t) || 0);
}, Qp = Bi({
  devicePixelContentBoxSize: nl(),
  borderBoxSize: nl(),
  contentBoxSize: nl(),
  contentRect: new Im(0, 0, 0, 0)
}), Hm = function(e, t) {
  if (t === void 0 && (t = !1), Cu.has(e) && !t)
    return Cu.get(e);
  if ($m(e))
    return Cu.set(e, Qp), Qp;
  var r = getComputedStyle(e), a = qf(e) && e.ownerSVGElement && e.getBBox(), i = !Cv && r.boxSizing === "border-box", o = Tv.test(r.writingMode || ""), d = !a && Zp.test(r.overflowY || ""), c = !a && Zp.test(r.overflowX || ""), s = a ? 0 : Zr(r.paddingTop), p = a ? 0 : Zr(r.paddingRight), y = a ? 0 : Zr(r.paddingBottom), g = a ? 0 : Zr(r.paddingLeft), b = a ? 0 : Zr(r.borderTopWidth), w = a ? 0 : Zr(r.borderRightWidth), S = a ? 0 : Zr(r.borderBottomWidth), L = a ? 0 : Zr(r.borderLeftWidth), m = g + p, v = s + y, A = L + w, P = b + S, T = c ? e.offsetHeight - P - e.clientHeight : 0, _ = d ? e.offsetWidth - A - e.clientWidth : 0, M = i ? m + A : 0, Z = i ? v + P : 0, Y = a ? a.width : Zr(r.width) - M - _, ae = a ? a.height : Zr(r.height) - Z - T, j = Y + m + _ + A, q = ae + v + T + P, te = Bi({
    devicePixelContentBoxSize: nl(Math.round(Y * devicePixelRatio), Math.round(ae * devicePixelRatio), o),
    borderBoxSize: nl(j, q, o),
    contentBoxSize: nl(Y, ae, o),
    contentRect: new Im(g, s, Y, ae)
  });
  return Cu.set(e, te), te;
}, Vm = function(e, t, r) {
  var a = Hm(e, r), i = a.borderBoxSize, o = a.contentBoxSize, d = a.devicePixelContentBoxSize;
  switch (t) {
    case Ss.DEVICE_PIXEL_CONTENT_BOX:
      return d;
    case Ss.BORDER_BOX:
      return i;
    default:
      return o;
  }
}, Wm = function() {
  function e(t) {
    var r = Hm(t);
    this.target = t, this.contentRect = r.contentRect, this.borderBoxSize = Bi([r.borderBoxSize]), this.contentBoxSize = Bi([r.contentBoxSize]), this.devicePixelContentBoxSize = Bi([r.devicePixelContentBoxSize]);
  }
  return e;
}(), jm = function(e) {
  if ($m(e))
    return 1 / 0;
  for (var t = 0, r = e.parentNode; r; )
    t += 1, r = r.parentNode;
  return t;
}, Av = function() {
  var e = 1 / 0, t = [];
  zi.forEach(function(d) {
    if (d.activeTargets.length !== 0) {
      var c = [];
      d.activeTargets.forEach(function(p) {
        var y = new Wm(p.target), g = jm(p.target);
        c.push(y), p.lastReportedSize = Vm(p.target, p.observedBox), g < e && (e = g);
      }), t.push(function() {
        d.callback.call(d.observer, c, d.observer);
      }), d.activeTargets.splice(0, d.activeTargets.length);
    }
  });
  for (var r = 0, a = t; r < a.length; r++) {
    var i = a[r];
    i();
  }
  return e;
}, Jp = function(e) {
  zi.forEach(function(r) {
    r.activeTargets.splice(0, r.activeTargets.length), r.skippedTargets.splice(0, r.skippedTargets.length), r.observationTargets.forEach(function(i) {
      i.isActive() && (jm(i.target) > e ? r.activeTargets.push(i) : r.skippedTargets.push(i));
    });
  });
}, Lv = function() {
  var e = 0;
  for (Jp(e); Ev(); )
    e = Av(), Jp(e);
  return Sv() && kv(), e > 0;
}, $d, Um = [], Pv = function() {
  return Um.splice(0).forEach(function(e) {
    return e();
  });
}, Rv = function(e) {
  if (!$d) {
    var t = 0, r = document.createTextNode(""), a = { characterData: !0 };
    new MutationObserver(function() {
      return Pv();
    }).observe(r, a), $d = function() {
      r.textContent = "".concat(t ? t-- : t++);
    };
  }
  Um.push(e), $d();
}, Nv = function(e) {
  Rv(function() {
    requestAnimationFrame(e);
  });
}, $u = 0, Dv = function() {
  return !!$u;
}, _v = 250, Ov = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, eh = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], th = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Hd = !1, Fv = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var r = this;
    if (t === void 0 && (t = _v), !Hd) {
      Hd = !0;
      var a = th(t);
      Nv(function() {
        var i = !1;
        try {
          i = Lv();
        } finally {
          if (Hd = !1, t = a - th(), !Dv())
            return;
          i ? r.run(1e3) : t > 0 ? r.run(t) : r.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, r = function() {
      return t.observer && t.observer.observe(document.body, Ov);
    };
    document.body ? r() : ps.addEventListener("DOMContentLoaded", r);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), eh.forEach(function(r) {
      return ps.addEventListener(r, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), eh.forEach(function(r) {
      return ps.removeEventListener(r, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), vf = new Fv(), nh = function(e) {
  !$u && e > 0 && vf.start(), $u += e, !$u && vf.stop();
}, Mv = function(e) {
  return !qf(e) && !wv(e) && getComputedStyle(e).display === "inline";
}, zv = function() {
  function e(t, r) {
    this.target = t, this.observedBox = r || Ss.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Vm(this.target, this.observedBox, !0);
    return Mv(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Bv = function() {
  function e(t, r) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = r;
  }
  return e;
}(), Au = /* @__PURE__ */ new WeakMap(), rh = function(e, t) {
  for (var r = 0; r < e.length; r += 1)
    if (e[r].target === t)
      return r;
  return -1;
}, Lu = function() {
  function e() {
  }
  return e.connect = function(t, r) {
    var a = new Bv(t, r);
    Au.set(t, a);
  }, e.observe = function(t, r, a) {
    var i = Au.get(t), o = i.observationTargets.length === 0;
    rh(i.observationTargets, r) < 0 && (o && zi.push(i), i.observationTargets.push(new zv(r, a && a.box)), nh(1), vf.schedule());
  }, e.unobserve = function(t, r) {
    var a = Au.get(t), i = rh(a.observationTargets, r), o = a.observationTargets.length === 1;
    i >= 0 && (o && zi.splice(zi.indexOf(a), 1), a.observationTargets.splice(i, 1), nh(-1));
  }, e.disconnect = function(t) {
    var r = this, a = Au.get(t);
    a.observationTargets.slice().forEach(function(i) {
      return r.unobserve(t, i.target);
    }), a.activeTargets.splice(0, a.activeTargets.length);
  }, e;
}(), Iv = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Lu.connect(this, t);
  }
  return e.prototype.observe = function(t, r) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!qp(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Lu.observe(this, t, r);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!qp(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Lu.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Lu.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const $v = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: Iv,
  ResizeObserverEntry: Wm,
  ResizeObserverSize: Bm
}, Symbol.toStringTag, { value: "Module" })), Hv = /* @__PURE__ */ tv($v);
var Ko = Gm, Ia = Ym(Jg), Vv = Ym(ev), Yo = Uv(se), Wv = Hv, jv = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function Km(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (Km = function(i) {
    return i ? r : t;
  })(e);
}
function Uv(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var r = Km(t);
  if (r && r.has(e))
    return r.get(e);
  var a = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var d = i ? Object.getOwnPropertyDescriptor(e, o) : null;
      d && (d.get || d.set) ? Object.defineProperty(a, o, d) : a[o] = e[o];
    }
  return a.default = e, r && r.set(e, a), a;
}
function Ym(e) {
  return e && e.__esModule ? e : { default: e };
}
function qu() {
  return qu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, qu.apply(this, arguments);
}
function Kv(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var Yv = [];
function Gm(e) {
  var t = e.className, r = e.children, a = e.debounceTime, i = a === void 0 ? 300 : a, o = e.ignoreDimensions, d = o === void 0 ? Yv : o, c = e.parentSizeStyles, s = c === void 0 ? {
    width: "100%",
    height: "100%"
  } : c, p = e.enableDebounceLeadingCall, y = p === void 0 ? !0 : p, g = Kv(e, jv), b = (0, Yo.useRef)(null), w = (0, Yo.useRef)(0), S = (0, Yo.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), L = S[0], m = S[1], v = (0, Yo.useMemo)(function() {
    var A = Array.isArray(d) ? d : [d];
    return (0, Vv.default)(function(P) {
      m(function(T) {
        var _ = Object.keys(T), M = _.filter(function(Y) {
          return T[Y] !== P[Y];
        }), Z = M.every(function(Y) {
          return A.includes(Y);
        });
        return Z ? T : P;
      });
    }, i, {
      leading: y
    });
  }, [i, y, d]);
  return (0, Yo.useEffect)(function() {
    var A = new Wv.ResizeObserver(function(P) {
      P === void 0 && (P = []), P.forEach(function(T) {
        var _ = T.contentRect, M = _.left, Z = _.top, Y = _.width, ae = _.height;
        w.current = window.requestAnimationFrame(function() {
          v({
            width: Y,
            height: ae,
            top: Z,
            left: M
          });
        });
      });
    });
    return b.current && A.observe(b.current), function() {
      window.cancelAnimationFrame(w.current), A.disconnect(), v != null && v.cancel && v.cancel();
    };
  }, [v]), /* @__PURE__ */ Yo.default.createElement("div", qu({
    style: s,
    ref: b,
    className: t
  }, g), r(qu({}, L, {
    ref: b.current,
    resize: v
  })));
}
Gm.propTypes = {
  className: Ia.default.string,
  debounceTime: Ia.default.number,
  enableDebounceLeadingCall: Ia.default.bool,
  ignoreDimensions: Ia.default.oneOfType([Ia.default.any, Ia.default.arrayOf(Ia.default.any)]),
  children: Ia.default.func.isRequired
};
var Vd = /* @__PURE__ */ new Date(), Wd = /* @__PURE__ */ new Date();
function va(e, t, r, a) {
  function i(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return i.floor = function(o) {
    return e(o = /* @__PURE__ */ new Date(+o)), o;
  }, i.ceil = function(o) {
    return e(o = new Date(o - 1)), t(o, 1), e(o), o;
  }, i.round = function(o) {
    var d = i(o), c = i.ceil(o);
    return o - d < c - o ? d : c;
  }, i.offset = function(o, d) {
    return t(o = /* @__PURE__ */ new Date(+o), d == null ? 1 : Math.floor(d)), o;
  }, i.range = function(o, d, c) {
    var s = [], p;
    if (o = i.ceil(o), c = c == null ? 1 : Math.floor(c), !(o < d) || !(c > 0))
      return s;
    do
      s.push(p = /* @__PURE__ */ new Date(+o)), t(o, c), e(o);
    while (p < o && o < d);
    return s;
  }, i.filter = function(o) {
    return va(function(d) {
      if (d >= d)
        for (; e(d), !o(d); )
          d.setTime(d - 1);
    }, function(d, c) {
      if (d >= d)
        if (c < 0)
          for (; ++c <= 0; )
            for (; t(d, -1), !o(d); )
              ;
        else
          for (; --c >= 0; )
            for (; t(d, 1), !o(d); )
              ;
    });
  }, r && (i.count = function(o, d) {
    return Vd.setTime(+o), Wd.setTime(+d), e(Vd), e(Wd), Math.floor(r(Vd, Wd));
  }, i.every = function(o) {
    return o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(a ? function(d) {
      return a(d) % o === 0;
    } : function(d) {
      return i.count(0, d) % o === 0;
    }) : i;
  }), i;
}
const Gv = 1e3, Zf = Gv * 60, Xv = Zf * 60, Qf = Xv * 24, Xm = Qf * 7;
var qm = va(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Zf) / Qf,
  (e) => e.getDate() - 1
);
const Zm = qm;
qm.range;
function ji(e) {
  return va(function(t) {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setDate(t.getDate() + r * 7);
  }, function(t, r) {
    return (r - t - (r.getTimezoneOffset() - t.getTimezoneOffset()) * Zf) / Xm;
  });
}
var Qm = ji(0), Zu = ji(1), qv = ji(2), Zv = ji(3), ol = ji(4), Qv = ji(5), Jv = ji(6);
Qm.range;
Zu.range;
qv.range;
Zv.range;
ol.range;
Qv.range;
Jv.range;
var Jf = va(function(e) {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setFullYear(e.getFullYear() + t);
}, function(e, t) {
  return t.getFullYear() - e.getFullYear();
}, function(e) {
  return e.getFullYear();
});
Jf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : va(function(t) {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setFullYear(t.getFullYear() + r * e);
  });
};
const ks = Jf;
Jf.range;
var Jm = va(function(e) {
  e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCDate(e.getUTCDate() + t);
}, function(e, t) {
  return (t - e) / Qf;
}, function(e) {
  return e.getUTCDate() - 1;
});
const ey = Jm;
Jm.range;
function Ui(e) {
  return va(function(t) {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setUTCDate(t.getUTCDate() + r * 7);
  }, function(t, r) {
    return (r - t) / Xm;
  });
}
var ty = Ui(0), Qu = Ui(1), ex = Ui(2), tx = Ui(3), ll = Ui(4), nx = Ui(5), rx = Ui(6);
ty.range;
Qu.range;
ex.range;
tx.range;
ll.range;
nx.range;
rx.range;
var ep = va(function(e) {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, function(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}, function(e) {
  return e.getUTCFullYear();
});
ep.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : va(function(t) {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setUTCFullYear(t.getUTCFullYear() + r * e);
  });
};
const ws = ep;
ep.range;
function ny(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function ah(e) {
  let t = e, r = e;
  e.length === 1 && (t = (d, c) => e(d) - c, r = ax(e));
  function a(d, c, s, p) {
    for (s == null && (s = 0), p == null && (p = d.length); s < p; ) {
      const y = s + p >>> 1;
      r(d[y], c) < 0 ? s = y + 1 : p = y;
    }
    return s;
  }
  function i(d, c, s, p) {
    for (s == null && (s = 0), p == null && (p = d.length); s < p; ) {
      const y = s + p >>> 1;
      r(d[y], c) > 0 ? p = y : s = y + 1;
    }
    return s;
  }
  function o(d, c, s, p) {
    s == null && (s = 0), p == null && (p = d.length);
    const y = a(d, c, s, p - 1);
    return y > s && t(d[y - 1], c) > -t(d[y], c) ? y - 1 : y;
  }
  return { left: a, center: o, right: i };
}
function ax(e) {
  return (t, r) => ny(e(t), r);
}
function* ix(e, t) {
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && (yield r);
  else {
    let r = -1;
    for (let a of e)
      (a = t(a, ++r, e)) != null && (a = +a) >= a && (yield a);
  }
}
function ox(e, t) {
  let r = 0, a, i = 0, o = 0;
  if (t === void 0)
    for (let d of e)
      d != null && (d = +d) >= d && (a = d - i, i += a / ++r, o += a * (d - i));
  else {
    let d = -1;
    for (let c of e)
      (c = t(c, ++d, e)) != null && (c = +c) >= c && (a = c - i, i += a / ++r, o += a * (c - i));
  }
  if (r > 1)
    return o / (r - 1);
}
function lx(e, t) {
  const r = ox(e, t);
  return r && Math.sqrt(r);
}
function Ju(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r < a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function xf(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r > a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function ry(e, t, r = 0, a = e.length - 1, i = ny) {
  for (; a > r; ) {
    if (a - r > 600) {
      const s = a - r + 1, p = t - r + 1, y = Math.log(s), g = 0.5 * Math.exp(2 * y / 3), b = 0.5 * Math.sqrt(y * g * (s - g) / s) * (p - s / 2 < 0 ? -1 : 1), w = Math.max(r, Math.floor(t - p * g / s + b)), S = Math.min(a, Math.floor(t + (s - p) * g / s + b));
      ry(e, t, w, S, i);
    }
    const o = e[t];
    let d = r, c = a;
    for (os(e, r, t), i(e[a], o) > 0 && os(e, r, a); d < c; ) {
      for (os(e, d, c), ++d, --c; i(e[d], o) < 0; )
        ++d;
      for (; i(e[c], o) > 0; )
        --c;
    }
    i(e[r], o) === 0 ? os(e, r, c) : (++c, os(e, c, a)), c <= t && (r = c + 1), t <= c && (a = c - 1);
  }
  return e;
}
function os(e, t, r) {
  const a = e[t];
  e[t] = e[r], e[r] = a;
}
function Ts(e, t, r) {
  if (e = Float64Array.from(ix(e, r)), !!(a = e.length)) {
    if ((t = +t) <= 0 || a < 2)
      return xf(e);
    if (t >= 1)
      return Ju(e);
    var a, i = (a - 1) * t, o = Math.floor(i), d = Ju(ry(e, o).subarray(0, o + 1)), c = xf(e.subarray(o + 1));
    return d + (c - d) * (i - o);
  }
}
function sx(e, t) {
  let r = 0, a = 0;
  if (t === void 0)
    for (let i of e)
      i != null && (i = +i) >= i && (++r, a += i);
  else {
    let i = -1;
    for (let o of e)
      (o = t(o, ++i, e)) != null && (o = +o) >= o && (++r, a += o);
  }
  if (r)
    return a / r;
}
function ay(e, t) {
  return Ts(e, 0.5, t);
}
function jd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Ud(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function ls(e, t, r) {
  return { y: e, m: t, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function ux(e) {
  var t = e.dateTime, r = e.date, a = e.time, i = e.periods, o = e.days, d = e.shortDays, c = e.months, s = e.shortMonths, p = ss(i), y = us(i), g = ss(o), b = us(o), w = ss(d), S = us(d), L = ss(c), m = us(c), v = ss(s), A = us(s), P = {
    a: ne,
    A: J,
    b: W,
    B: K,
    c: null,
    d: ch,
    e: ch,
    f: Dx,
    g: Vx,
    G: jx,
    H: Px,
    I: Rx,
    j: Nx,
    L: iy,
    m: _x,
    M: Ox,
    p: ee,
    q: $,
    Q: ph,
    s: hh,
    S: Fx,
    u: Mx,
    U: zx,
    V: Bx,
    w: Ix,
    W: $x,
    x: null,
    X: null,
    y: Hx,
    Y: Wx,
    Z: Ux,
    "%": fh
  }, T = {
    a: pe,
    A: ve,
    b: Te,
    B: ye,
    c: null,
    d: dh,
    e: dh,
    f: Xx,
    g: ib,
    G: lb,
    H: Kx,
    I: Yx,
    j: Gx,
    L: ly,
    m: qx,
    M: Zx,
    p: Re,
    q: Xe,
    Q: ph,
    s: hh,
    S: Qx,
    u: Jx,
    U: eb,
    V: tb,
    w: nb,
    W: rb,
    x: null,
    X: null,
    y: ab,
    Y: ob,
    Z: sb,
    "%": fh
  }, _ = {
    a: j,
    A: q,
    b: te,
    B: le,
    c: B,
    d: sh,
    e: sh,
    f: Tx,
    g: lh,
    G: oh,
    H: uh,
    I: uh,
    j: Ex,
    L: wx,
    m: bx,
    M: Sx,
    p: ae,
    q: xx,
    Q: Ax,
    s: Lx,
    S: kx,
    u: hx,
    U: mx,
    V: yx,
    w: px,
    W: gx,
    x: X,
    X: ue,
    y: lh,
    Y: oh,
    Z: vx,
    "%": Cx
  };
  P.x = M(r, P), P.X = M(a, P), P.c = M(t, P), T.x = M(r, T), T.X = M(a, T), T.c = M(t, T);
  function M(Ce, xe) {
    return function(Pe) {
      var de = [], Be = -1, Ne = 0, He = Ce.length, Ze, $e, Ye;
      for (Pe instanceof Date || (Pe = /* @__PURE__ */ new Date(+Pe)); ++Be < He; )
        Ce.charCodeAt(Be) === 37 && (de.push(Ce.slice(Ne, Be)), ($e = ih[Ze = Ce.charAt(++Be)]) != null ? Ze = Ce.charAt(++Be) : $e = Ze === "e" ? " " : "0", (Ye = xe[Ze]) && (Ze = Ye(Pe, $e)), de.push(Ze), Ne = Be + 1);
      return de.push(Ce.slice(Ne, Be)), de.join("");
    };
  }
  function Z(Ce, xe) {
    return function(Pe) {
      var de = ls(1900, void 0, 1), Be = Y(de, Ce, Pe += "", 0), Ne, He;
      if (Be != Pe.length)
        return null;
      if ("Q" in de)
        return new Date(de.Q);
      if ("s" in de)
        return new Date(de.s * 1e3 + ("L" in de ? de.L : 0));
      if (xe && !("Z" in de) && (de.Z = 0), "p" in de && (de.H = de.H % 12 + de.p * 12), de.m === void 0 && (de.m = "q" in de ? de.q : 0), "V" in de) {
        if (de.V < 1 || de.V > 53)
          return null;
        "w" in de || (de.w = 1), "Z" in de ? (Ne = Ud(ls(de.y, 0, 1)), He = Ne.getUTCDay(), Ne = He > 4 || He === 0 ? Qu.ceil(Ne) : Qu(Ne), Ne = ey.offset(Ne, (de.V - 1) * 7), de.y = Ne.getUTCFullYear(), de.m = Ne.getUTCMonth(), de.d = Ne.getUTCDate() + (de.w + 6) % 7) : (Ne = jd(ls(de.y, 0, 1)), He = Ne.getDay(), Ne = He > 4 || He === 0 ? Zu.ceil(Ne) : Zu(Ne), Ne = Zm.offset(Ne, (de.V - 1) * 7), de.y = Ne.getFullYear(), de.m = Ne.getMonth(), de.d = Ne.getDate() + (de.w + 6) % 7);
      } else
        ("W" in de || "U" in de) && ("w" in de || (de.w = "u" in de ? de.u % 7 : "W" in de ? 1 : 0), He = "Z" in de ? Ud(ls(de.y, 0, 1)).getUTCDay() : jd(ls(de.y, 0, 1)).getDay(), de.m = 0, de.d = "W" in de ? (de.w + 6) % 7 + de.W * 7 - (He + 5) % 7 : de.w + de.U * 7 - (He + 6) % 7);
      return "Z" in de ? (de.H += de.Z / 100 | 0, de.M += de.Z % 100, Ud(de)) : jd(de);
    };
  }
  function Y(Ce, xe, Pe, de) {
    for (var Be = 0, Ne = xe.length, He = Pe.length, Ze, $e; Be < Ne; ) {
      if (de >= He)
        return -1;
      if (Ze = xe.charCodeAt(Be++), Ze === 37) {
        if (Ze = xe.charAt(Be++), $e = _[Ze in ih ? xe.charAt(Be++) : Ze], !$e || (de = $e(Ce, Pe, de)) < 0)
          return -1;
      } else if (Ze != Pe.charCodeAt(de++))
        return -1;
    }
    return de;
  }
  function ae(Ce, xe, Pe) {
    var de = p.exec(xe.slice(Pe));
    return de ? (Ce.p = y.get(de[0].toLowerCase()), Pe + de[0].length) : -1;
  }
  function j(Ce, xe, Pe) {
    var de = w.exec(xe.slice(Pe));
    return de ? (Ce.w = S.get(de[0].toLowerCase()), Pe + de[0].length) : -1;
  }
  function q(Ce, xe, Pe) {
    var de = g.exec(xe.slice(Pe));
    return de ? (Ce.w = b.get(de[0].toLowerCase()), Pe + de[0].length) : -1;
  }
  function te(Ce, xe, Pe) {
    var de = v.exec(xe.slice(Pe));
    return de ? (Ce.m = A.get(de[0].toLowerCase()), Pe + de[0].length) : -1;
  }
  function le(Ce, xe, Pe) {
    var de = L.exec(xe.slice(Pe));
    return de ? (Ce.m = m.get(de[0].toLowerCase()), Pe + de[0].length) : -1;
  }
  function B(Ce, xe, Pe) {
    return Y(Ce, t, xe, Pe);
  }
  function X(Ce, xe, Pe) {
    return Y(Ce, r, xe, Pe);
  }
  function ue(Ce, xe, Pe) {
    return Y(Ce, a, xe, Pe);
  }
  function ne(Ce) {
    return d[Ce.getDay()];
  }
  function J(Ce) {
    return o[Ce.getDay()];
  }
  function W(Ce) {
    return s[Ce.getMonth()];
  }
  function K(Ce) {
    return c[Ce.getMonth()];
  }
  function ee(Ce) {
    return i[+(Ce.getHours() >= 12)];
  }
  function $(Ce) {
    return 1 + ~~(Ce.getMonth() / 3);
  }
  function pe(Ce) {
    return d[Ce.getUTCDay()];
  }
  function ve(Ce) {
    return o[Ce.getUTCDay()];
  }
  function Te(Ce) {
    return s[Ce.getUTCMonth()];
  }
  function ye(Ce) {
    return c[Ce.getUTCMonth()];
  }
  function Re(Ce) {
    return i[+(Ce.getUTCHours() >= 12)];
  }
  function Xe(Ce) {
    return 1 + ~~(Ce.getUTCMonth() / 3);
  }
  return {
    format: function(Ce) {
      var xe = M(Ce += "", P);
      return xe.toString = function() {
        return Ce;
      }, xe;
    },
    parse: function(Ce) {
      var xe = Z(Ce += "", !1);
      return xe.toString = function() {
        return Ce;
      }, xe;
    },
    utcFormat: function(Ce) {
      var xe = M(Ce += "", T);
      return xe.toString = function() {
        return Ce;
      }, xe;
    },
    utcParse: function(Ce) {
      var xe = Z(Ce += "", !0);
      return xe.toString = function() {
        return Ce;
      }, xe;
    }
  };
}
var ih = { "-": "", _: " ", 0: "0" }, Un = /^\s*\d+/, cx = /^%/, dx = /[\\^$*+?|[\]().{}]/g;
function qt(e, t, r) {
  var a = e < 0 ? "-" : "", i = (a ? -e : e) + "", o = i.length;
  return a + (o < r ? new Array(r - o + 1).join(t) + i : i);
}
function fx(e) {
  return e.replace(dx, "\\$&");
}
function ss(e) {
  return new RegExp("^(?:" + e.map(fx).join("|") + ")", "i");
}
function us(e) {
  return new Map(e.map((t, r) => [t.toLowerCase(), r]));
}
function px(e, t, r) {
  var a = Un.exec(t.slice(r, r + 1));
  return a ? (e.w = +a[0], r + a[0].length) : -1;
}
function hx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 1));
  return a ? (e.u = +a[0], r + a[0].length) : -1;
}
function mx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.U = +a[0], r + a[0].length) : -1;
}
function yx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.V = +a[0], r + a[0].length) : -1;
}
function gx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.W = +a[0], r + a[0].length) : -1;
}
function oh(e, t, r) {
  var a = Un.exec(t.slice(r, r + 4));
  return a ? (e.y = +a[0], r + a[0].length) : -1;
}
function lh(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), r + a[0].length) : -1;
}
function vx(e, t, r) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(r, r + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), r + a[0].length) : -1;
}
function xx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 1));
  return a ? (e.q = a[0] * 3 - 3, r + a[0].length) : -1;
}
function bx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.m = a[0] - 1, r + a[0].length) : -1;
}
function sh(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.d = +a[0], r + a[0].length) : -1;
}
function Ex(e, t, r) {
  var a = Un.exec(t.slice(r, r + 3));
  return a ? (e.m = 0, e.d = +a[0], r + a[0].length) : -1;
}
function uh(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.H = +a[0], r + a[0].length) : -1;
}
function Sx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.M = +a[0], r + a[0].length) : -1;
}
function kx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 2));
  return a ? (e.S = +a[0], r + a[0].length) : -1;
}
function wx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 3));
  return a ? (e.L = +a[0], r + a[0].length) : -1;
}
function Tx(e, t, r) {
  var a = Un.exec(t.slice(r, r + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), r + a[0].length) : -1;
}
function Cx(e, t, r) {
  var a = cx.exec(t.slice(r, r + 1));
  return a ? r + a[0].length : -1;
}
function Ax(e, t, r) {
  var a = Un.exec(t.slice(r));
  return a ? (e.Q = +a[0], r + a[0].length) : -1;
}
function Lx(e, t, r) {
  var a = Un.exec(t.slice(r));
  return a ? (e.s = +a[0], r + a[0].length) : -1;
}
function ch(e, t) {
  return qt(e.getDate(), t, 2);
}
function Px(e, t) {
  return qt(e.getHours(), t, 2);
}
function Rx(e, t) {
  return qt(e.getHours() % 12 || 12, t, 2);
}
function Nx(e, t) {
  return qt(1 + Zm.count(ks(e), e), t, 3);
}
function iy(e, t) {
  return qt(e.getMilliseconds(), t, 3);
}
function Dx(e, t) {
  return iy(e, t) + "000";
}
function _x(e, t) {
  return qt(e.getMonth() + 1, t, 2);
}
function Ox(e, t) {
  return qt(e.getMinutes(), t, 2);
}
function Fx(e, t) {
  return qt(e.getSeconds(), t, 2);
}
function Mx(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function zx(e, t) {
  return qt(Qm.count(ks(e) - 1, e), t, 2);
}
function oy(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? ol(e) : ol.ceil(e);
}
function Bx(e, t) {
  return e = oy(e), qt(ol.count(ks(e), e) + (ks(e).getDay() === 4), t, 2);
}
function Ix(e) {
  return e.getDay();
}
function $x(e, t) {
  return qt(Zu.count(ks(e) - 1, e), t, 2);
}
function Hx(e, t) {
  return qt(e.getFullYear() % 100, t, 2);
}
function Vx(e, t) {
  return e = oy(e), qt(e.getFullYear() % 100, t, 2);
}
function Wx(e, t) {
  return qt(e.getFullYear() % 1e4, t, 4);
}
function jx(e, t) {
  var r = e.getDay();
  return e = r >= 4 || r === 0 ? ol(e) : ol.ceil(e), qt(e.getFullYear() % 1e4, t, 4);
}
function Ux(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + qt(t / 60 | 0, "0", 2) + qt(t % 60, "0", 2);
}
function dh(e, t) {
  return qt(e.getUTCDate(), t, 2);
}
function Kx(e, t) {
  return qt(e.getUTCHours(), t, 2);
}
function Yx(e, t) {
  return qt(e.getUTCHours() % 12 || 12, t, 2);
}
function Gx(e, t) {
  return qt(1 + ey.count(ws(e), e), t, 3);
}
function ly(e, t) {
  return qt(e.getUTCMilliseconds(), t, 3);
}
function Xx(e, t) {
  return ly(e, t) + "000";
}
function qx(e, t) {
  return qt(e.getUTCMonth() + 1, t, 2);
}
function Zx(e, t) {
  return qt(e.getUTCMinutes(), t, 2);
}
function Qx(e, t) {
  return qt(e.getUTCSeconds(), t, 2);
}
function Jx(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function eb(e, t) {
  return qt(ty.count(ws(e) - 1, e), t, 2);
}
function sy(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? ll(e) : ll.ceil(e);
}
function tb(e, t) {
  return e = sy(e), qt(ll.count(ws(e), e) + (ws(e).getUTCDay() === 4), t, 2);
}
function nb(e) {
  return e.getUTCDay();
}
function rb(e, t) {
  return qt(Qu.count(ws(e) - 1, e), t, 2);
}
function ab(e, t) {
  return qt(e.getUTCFullYear() % 100, t, 2);
}
function ib(e, t) {
  return e = sy(e), qt(e.getUTCFullYear() % 100, t, 2);
}
function ob(e, t) {
  return qt(e.getUTCFullYear() % 1e4, t, 4);
}
function lb(e, t) {
  var r = e.getUTCDay();
  return e = r >= 4 || r === 0 ? ll(e) : ll.ceil(e), qt(e.getUTCFullYear() % 1e4, t, 4);
}
function sb() {
  return "+0000";
}
function fh() {
  return "%";
}
function ph(e) {
  return +e;
}
function hh(e) {
  return Math.floor(+e / 1e3);
}
var Go, Hu, uy;
ub({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function ub(e) {
  return Go = ux(e), Hu = Go.format, uy = Go.parse, Go.utcFormat, Go.utcParse, Go;
}
const zt = {
  arr: Array.isArray,
  obj: (e) => Object.prototype.toString.call(e) === "[object Object]",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0,
  nul: (e) => e === null,
  set: (e) => e instanceof Set,
  map: (e) => e instanceof Map,
  equ(e, t) {
    if (typeof e != typeof t)
      return !1;
    if (zt.str(e) || zt.num(e))
      return e === t;
    if (zt.obj(e) && zt.obj(t) && Object.keys(e).length + Object.keys(t).length === 0)
      return !0;
    let r;
    for (r in e)
      if (!(r in t))
        return !1;
    for (r in t)
      if (e[r] !== t[r])
        return !1;
    return zt.und(r) ? e === t : !0;
  }
};
function cb(e, t) {
  return t === void 0 && (t = !0), (r) => (zt.arr(r) ? r : Object.keys(r)).reduce((a, i) => {
    const o = t ? i[0].toLowerCase() + i.substring(1) : i;
    return a[o] = e(o), a;
  }, e);
}
function cy() {
  const e = se.useState(!1), t = e[1];
  return se.useCallback(() => t((a) => !a), []);
}
function Pi(e, t) {
  return zt.und(e) || zt.nul(e) ? t : e;
}
function el(e) {
  return zt.und(e) ? [] : zt.arr(e) ? e : [e];
}
function Br(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    r[a - 1] = arguments[a];
  return zt.fun(e) ? e(...r) : e;
}
function db(e) {
  return e.to, e.from, e.config, e.onStart, e.onRest, e.onFrame, e.children, e.reset, e.reverse, e.force, e.immediate, e.delay, e.attach, e.destroyed, e.interpolateTo, e.ref, e.lazy, ea(e, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
}
function Kd(e) {
  const t = db(e);
  if (zt.und(t))
    return yn({
      to: t
    }, e);
  const r = Object.keys(e).reduce((a, i) => zt.und(t[i]) ? yn({}, a, {
    [i]: e[i]
  }) : a, {});
  return yn({
    to: t
  }, r);
}
function fb(e, t) {
  return t && (zt.fun(t) ? t(e) : zt.obj(t) && (t.current = e)), e;
}
class Ir {
  constructor() {
    this.payload = void 0, this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(t) {
    this.children.length === 0 && this.attach(), this.children.push(t);
  }
  removeChild(t) {
    const r = this.children.indexOf(t);
    this.children.splice(r, 1), this.children.length === 0 && this.detach();
  }
}
class bf extends Ir {
  constructor() {
    super(...arguments), this.payload = [], this.attach = () => this.payload.forEach((t) => t instanceof Ir && t.addChild(this)), this.detach = () => this.payload.forEach((t) => t instanceof Ir && t.removeChild(this));
  }
}
class dy extends Ir {
  constructor() {
    super(...arguments), this.payload = {}, this.attach = () => Object.values(this.payload).forEach((t) => t instanceof Ir && t.addChild(this)), this.detach = () => Object.values(this.payload).forEach((t) => t instanceof Ir && t.removeChild(this));
  }
  getValue(t) {
    t === void 0 && (t = !1);
    const r = {};
    for (const a in this.payload) {
      const i = this.payload[a];
      t && !(i instanceof Ir) || (r[a] = i instanceof Ir ? i[t ? "getAnimatedValue" : "getValue"]() : i);
    }
    return r;
  }
  getAnimatedValue() {
    return this.getValue(!0);
  }
}
let tp;
function pb(e, t) {
  tp = {
    fn: e,
    transform: t
  };
}
let fy;
function hb(e) {
  fy = e;
}
let py = (e) => typeof window < "u" ? window.requestAnimationFrame(e) : -1, ec;
function mb(e) {
  ec = e;
}
let hy = () => Date.now(), yb = (e) => e.current, my;
function gb(e) {
  my = e;
}
class vb extends dy {
  constructor(t, r) {
    super(), this.update = void 0, this.payload = t.style ? yn({}, t, {
      style: my(t.style)
    }) : t, this.update = r, this.attach();
  }
}
const xb = (e) => zt.fun(e) && !(e.prototype instanceof n.Component), bb = (e) => se.forwardRef((r, a) => {
  const i = cy(), o = se.useRef(!0), d = se.useRef(null), c = se.useRef(null), s = se.useCallback((b) => {
    const w = d.current, S = () => {
      let L = !1;
      c.current && (L = tp.fn(c.current, d.current.getAnimatedValue())), (!c.current || L === !1) && i();
    };
    d.current = new vb(b, S), w && w.detach();
  }, []);
  se.useEffect(() => () => {
    o.current = !1, d.current && d.current.detach();
  }, []), se.useImperativeHandle(a, () => yb(c)), s(r);
  const p = d.current.getValue();
  p.scrollTop, p.scrollLeft;
  const y = ea(p, ["scrollTop", "scrollLeft"]), g = xb(e) ? void 0 : (b) => c.current = fb(b, a);
  return n.createElement(e, yn({}, y, {
    ref: g
  }));
});
let hs = !1;
const Ii = /* @__PURE__ */ new Set(), yy = () => {
  if (!hs)
    return !1;
  let e = hy();
  for (let t of Ii) {
    let r = !1;
    for (let a = 0; a < t.configs.length; a++) {
      let i = t.configs[a], o, d;
      for (let c = 0; c < i.animatedValues.length; c++) {
        let s = i.animatedValues[c];
        if (s.done)
          continue;
        let p = i.fromValues[c], y = i.toValues[c], g = s.lastPosition, b = y instanceof Ir, w = Array.isArray(i.initialVelocity) ? i.initialVelocity[c] : i.initialVelocity;
        if (b && (y = y.getValue()), i.immediate) {
          s.setValue(y), s.done = !0;
          continue;
        }
        if (typeof p == "string" || typeof y == "string") {
          s.setValue(y), s.done = !0;
          continue;
        }
        if (i.duration !== void 0)
          g = p + i.easing((e - s.startTime) / i.duration) * (y - p), o = e >= s.startTime + i.duration;
        else if (i.decay)
          g = p + w / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (e - s.startTime))), o = Math.abs(s.lastPosition - g) < 0.1, o && (y = g);
        else {
          d = s.lastTime !== void 0 ? s.lastTime : e, w = s.lastVelocity !== void 0 ? s.lastVelocity : i.initialVelocity, e > d + 64 && (d = e);
          let S = Math.floor(e - d);
          for (let A = 0; A < S; ++A) {
            let P = -i.tension * (g - y), T = -i.friction * w, _ = (P + T) / i.mass;
            w = w + _ * 1 / 1e3, g = g + w * 1 / 1e3;
          }
          let L = i.clamp && i.tension !== 0 ? p < y ? g > y : g < y : !1, m = Math.abs(w) <= i.precision, v = i.tension !== 0 ? Math.abs(y - g) <= i.precision : !0;
          o = L || m && v, s.lastVelocity = w, s.lastTime = e;
        }
        b && !i.toValues[c].done && (o = !1), o ? (s.value !== y && (g = y), s.done = !0) : r = !0, s.setValue(g), s.lastPosition = g;
      }
      t.props.onFrame && (t.values[i.name] = i.interpolation.getValue());
    }
    t.props.onFrame && t.props.onFrame(t.values), r || (Ii.delete(t), t.stop(!0));
  }
  return Ii.size ? py(yy) : hs = !1, hs;
}, Eb = (e) => {
  Ii.has(e) || Ii.add(e), hs || (hs = !0, py(yy));
}, Sb = (e) => {
  Ii.has(e) && Ii.delete(e);
};
function tc(e, t, r) {
  if (typeof e == "function")
    return e;
  if (Array.isArray(e))
    return tc({
      range: e,
      output: t,
      extrapolate: r
    });
  if (ec && typeof e.output[0] == "string")
    return ec(e);
  const a = e, i = a.output, o = a.range || [0, 1], d = a.extrapolateLeft || a.extrapolate || "extend", c = a.extrapolateRight || a.extrapolate || "extend", s = a.easing || ((p) => p);
  return (p) => {
    const y = wb(p, o);
    return kb(p, o[y], o[y + 1], i[y], i[y + 1], s, d, c, a.map);
  };
}
function kb(e, t, r, a, i, o, d, c, s) {
  let p = s ? s(e) : e;
  if (p < t) {
    if (d === "identity")
      return p;
    d === "clamp" && (p = t);
  }
  if (p > r) {
    if (c === "identity")
      return p;
    c === "clamp" && (p = r);
  }
  return a === i ? a : t === r ? e <= t ? a : i : (t === -1 / 0 ? p = -p : r === 1 / 0 ? p = p - t : p = (p - t) / (r - t), p = o(p), a === -1 / 0 ? p = -p : i === 1 / 0 ? p = p + a : p = p * (i - a) + a, p);
}
function wb(e, t) {
  for (var r = 1; r < t.length - 1 && !(t[r] >= e); ++r)
    ;
  return r - 1;
}
class sl extends bf {
  constructor(t, r, a, i) {
    super(), this.calc = void 0, this.payload = t instanceof bf && !(t instanceof sl) ? t.getPayload() : Array.isArray(t) ? t : [t], this.calc = tc(r, a, i);
  }
  getValue() {
    return this.calc(...this.payload.map((t) => t.getValue()));
  }
  updateConfig(t, r, a) {
    this.calc = tc(t, r, a);
  }
  interpolate(t, r, a) {
    return new sl(this, t, r, a);
  }
}
const Tb = (e, t, r) => e && new sl(e, t, r);
function gy(e, t) {
  "update" in e ? t.add(e) : e.getChildren().forEach((r) => gy(r, t));
}
class Ef extends Ir {
  constructor(t) {
    var r;
    super(), r = this, this.animatedStyles = /* @__PURE__ */ new Set(), this.value = void 0, this.startPosition = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.startTime = void 0, this.lastTime = void 0, this.done = !1, this.setValue = function(a, i) {
      i === void 0 && (i = !0), r.value = a, i && r.flush();
    }, this.value = t, this.startPosition = t, this.lastPosition = t;
  }
  flush() {
    this.animatedStyles.size === 0 && gy(this, this.animatedStyles), this.animatedStyles.forEach((t) => t.update());
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  getValue() {
    return this.value;
  }
  interpolate(t, r, a) {
    return new sl(this, t, r, a);
  }
}
class Cb extends bf {
  constructor(t) {
    super(), this.payload = t.map((r) => new Ef(r));
  }
  setValue(t, r) {
    r === void 0 && (r = !0), Array.isArray(t) ? t.length === this.payload.length && t.forEach((a, i) => this.payload[i].setValue(a, r)) : this.payload.forEach((a) => a.setValue(t, r));
  }
  getValue() {
    return this.payload.map((t) => t.getValue());
  }
  interpolate(t, r) {
    return new sl(this, t, r);
  }
}
let Ab = 0;
class Lb {
  constructor() {
    this.id = void 0, this.idle = !0, this.hasChanged = !1, this.guid = 0, this.local = 0, this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.listeners = [], this.queue = [], this.localQueue = void 0, this.getValues = () => this.interpolations, this.id = Ab++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */
  update(t) {
    if (!t)
      return this;
    const r = Kd(t), a = r.delay, i = a === void 0 ? 0 : a, o = r.to, d = ea(r, ["delay", "to"]);
    if (zt.arr(o) || zt.fun(o))
      this.queue.push(yn({}, d, {
        delay: i,
        to: o
      }));
    else if (o) {
      let c = {};
      Object.entries(o).forEach((s) => {
        let p = s[0], y = s[1];
        const g = yn({
          to: {
            [p]: y
          },
          delay: Br(i, p)
        }, d), b = c[g.delay] && c[g.delay].to;
        c[g.delay] = yn({}, c[g.delay], g, {
          to: yn({}, b, g.to)
        });
      }), this.queue = Object.values(c);
    }
    return this.queue = this.queue.sort((c, s) => c.delay - s.delay), this.diff(d), this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  start(t) {
    if (this.queue.length) {
      this.idle = !1, this.localQueue && this.localQueue.forEach((i) => {
        let o = i.from, d = o === void 0 ? {} : o, c = i.to, s = c === void 0 ? {} : c;
        zt.obj(d) && (this.merged = yn({}, d, this.merged)), zt.obj(s) && (this.merged = yn({}, this.merged, s));
      });
      const r = this.local = ++this.guid, a = this.localQueue = this.queue;
      this.queue = [], a.forEach((i, o) => {
        let d = i.delay, c = ea(i, ["delay"]);
        const s = (y) => {
          o === a.length - 1 && r === this.guid && y && (this.idle = !0, this.props.onRest && this.props.onRest(this.merged)), t && t();
        };
        let p = zt.arr(c.to) || zt.fun(c.to);
        d ? setTimeout(() => {
          r === this.guid && (p ? this.runAsync(c, s) : this.diff(c).start(s));
        }, d) : p ? this.runAsync(c, s) : this.diff(c).start(s);
      });
    } else
      zt.fun(t) && this.listeners.push(t), this.props.onStart && this.props.onStart(), Eb(this);
    return this;
  }
  stop(t) {
    return this.listeners.forEach((r) => r(t)), this.listeners = [], this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  pause(t) {
    return this.stop(!0), t && Sb(this), this;
  }
  runAsync(t, r) {
    var a = this;
    t.delay;
    let i = ea(t, ["delay"]);
    const o = this.local;
    let d = Promise.resolve(void 0);
    if (zt.arr(i.to))
      for (let c = 0; c < i.to.length; c++) {
        const s = c, p = yn({}, i, Kd(i.to[s]));
        zt.arr(p.config) && (p.config = p.config[s]), d = d.then(() => {
          if (o === this.guid)
            return new Promise((y) => this.diff(p).start(y));
        });
      }
    else if (zt.fun(i.to)) {
      let c = 0, s;
      d = d.then(() => i.to(
        // next(props)
        (p) => {
          const y = yn({}, i, Kd(p));
          if (zt.arr(y.config) && (y.config = y.config[c]), c++, o === this.guid)
            return s = new Promise((g) => this.diff(y).start(g));
        },
        // cancel()
        function(p) {
          return p === void 0 && (p = !0), a.stop(p);
        }
      ).then(() => s));
    }
    d.then(r);
  }
  diff(t) {
    this.props = yn({}, this.props, t);
    let r = this.props, a = r.from, i = a === void 0 ? {} : a, o = r.to, d = o === void 0 ? {} : o, c = r.config, s = c === void 0 ? {} : c, p = r.reverse, y = r.attach, g = r.reset, b = r.immediate;
    if (p) {
      var w = [d, i];
      i = w[0], d = w[1];
    }
    this.merged = yn({}, i, this.merged, d), this.hasChanged = !1;
    let S = y && y(this);
    if (this.animations = Object.entries(this.merged).reduce((L, m) => {
      let v = m[0], A = m[1], P = L[v] || {};
      const T = zt.num(A), _ = zt.str(A) && !A.startsWith("#") && !/\d/.test(A) && !fy[A], M = zt.arr(A), Z = !T && !M && !_;
      let Y = zt.und(i[v]) ? A : i[v], ae = T || M || _ ? A : 1, j = Br(s, v);
      S && (ae = S.animations[v].parent);
      let q = P.parent, te = P.interpolation, le = el(S ? ae.getPayload() : ae), B, X = A;
      Z && (X = ec({
        range: [0, 1],
        output: [A, A]
      })(1));
      let ue = te && te.getValue();
      const J = !zt.und(q) && P.animatedValues.some(($) => !$.done), W = !zt.equ(X, ue), K = !zt.equ(X, P.previous), ee = !zt.equ(j, P.config);
      if (g || K && W || ee) {
        if (T || _)
          q = te = P.parent || new Ef(Y);
        else if (M)
          q = te = P.parent || new Cb(Y);
        else if (Z) {
          let $ = P.interpolation && P.interpolation.calc(P.parent.value);
          $ = $ !== void 0 && !g ? $ : Y, P.parent ? (q = P.parent, q.setValue(0, !1)) : q = new Ef(0);
          const pe = {
            output: [$, A]
          };
          P.interpolation ? (te = P.interpolation, P.interpolation.updateConfig(pe)) : te = q.interpolate(pe);
        }
        return le = el(S ? ae.getPayload() : ae), B = el(q.getPayload()), g && !Z && q.setValue(Y, !1), this.hasChanged = !0, B.forEach(($) => {
          $.startPosition = $.value, $.lastPosition = $.value, $.lastVelocity = J ? $.lastVelocity : void 0, $.lastTime = J ? $.lastTime : void 0, $.startTime = hy(), $.done = !1, $.animatedStyles.clear();
        }), Br(b, v) && q.setValue(Z ? ae : A, !1), yn({}, L, {
          [v]: yn({}, P, {
            name: v,
            parent: q,
            interpolation: te,
            animatedValues: B,
            toValues: le,
            previous: X,
            config: j,
            fromValues: el(q.getValue()),
            immediate: Br(b, v),
            initialVelocity: Pi(j.velocity, 0),
            clamp: Pi(j.clamp, !1),
            precision: Pi(j.precision, 0.01),
            tension: Pi(j.tension, 170),
            friction: Pi(j.friction, 26),
            mass: Pi(j.mass, 1),
            duration: j.duration,
            easing: Pi(j.easing, ($) => $),
            decay: j.decay
          })
        });
      } else
        return W ? L : (Z && (q.setValue(1, !1), te.updateConfig({
          output: [X, X]
        })), q.done = !0, this.hasChanged = !0, yn({}, L, {
          [v]: yn({}, L[v], {
            previous: X
          })
        }));
    }, this.animations), this.hasChanged) {
      this.configs = Object.values(this.animations), this.values = {}, this.interpolations = {};
      for (let L in this.animations)
        this.interpolations[L] = this.animations[L].interpolation, this.values[L] = this.animations[L].interpolation.getValue();
    }
    return this;
  }
  destroy() {
    this.stop(), this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.local = 0;
  }
}
let Pb = 0;
const Vu = "enter", Yd = "leave", Gd = "update", Rb = (e, t) => (typeof t == "function" ? e.map(t) : el(t)).map(String), Sf = (e) => {
  let t = e.items, r = e.keys, a = r === void 0 ? (o) => o : r, i = ea(e, ["items", "keys"]);
  return t = el(t !== void 0 ? t : null), yn({
    items: t,
    keys: Rb(t, a)
  }, i);
};
function Nb(e, t, r) {
  const a = yn({
    items: e,
    keys: t || ((A) => A)
  }, r), i = Sf(a), o = i.lazy, d = o === void 0 ? !1 : o;
  i.unique;
  const c = i.reset, s = c === void 0 ? !1 : c;
  i.enter, i.leave, i.update;
  const p = i.onDestroyed;
  i.keys, i.items;
  const y = i.onFrame, g = i.onRest, b = i.onStart, w = i.ref, S = ea(i, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]), L = cy(), m = se.useRef(!1), v = se.useRef({
    mounted: !1,
    first: !0,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!a.ref,
    instances: !m.current && /* @__PURE__ */ new Map(),
    forceUpdate: L
  });
  return se.useImperativeHandle(a.ref, () => ({
    start: () => Promise.all(Array.from(v.current.instances).map((A) => {
      let P = A[1];
      return new Promise((T) => P.start(T));
    })),
    stop: (A) => Array.from(v.current.instances).forEach((P) => P[1].stop(A)),
    get controllers() {
      return Array.from(v.current.instances).map((A) => A[1]);
    }
  })), v.current = Db(v.current, a), v.current.changed && v.current.transitions.forEach((A) => {
    const P = A.slot, T = A.from, _ = A.to, M = A.config, Z = A.trail, Y = A.key, ae = A.item;
    v.current.instances.has(Y) || v.current.instances.set(Y, new Lb());
    const j = v.current.instances.get(Y), q = yn({}, S, {
      to: _,
      from: T,
      config: M,
      ref: w,
      onRest: (te) => {
        v.current.mounted && (A.destroyed && (!w && !d && mh(v, Y), p && p(ae)), !Array.from(v.current.instances).some((X) => !X[1].idle) && (w || d) && v.current.deleted.length > 0 && mh(v), g && g(ae, P, te));
      },
      onStart: b && (() => b(ae, P)),
      onFrame: y && ((te) => y(ae, P, te)),
      delay: Z,
      reset: s && P === Vu
      // Update controller
    });
    j.update(q), v.current.paused || j.start();
  }), se.useEffect(() => (v.current.mounted = m.current = !0, () => {
    v.current.mounted = m.current = !1, Array.from(v.current.instances).map((A) => A[1].destroy()), v.current.instances.clear();
  }), []), v.current.transitions.map((A) => {
    let P = A.item, T = A.slot, _ = A.key;
    return {
      item: P,
      key: _,
      state: T,
      props: v.current.instances.get(_).getValues()
    };
  });
}
function mh(e, t) {
  const r = e.current.deleted;
  for (let a of r) {
    let i = a.key;
    const o = (d) => d.key !== i;
    (zt.und(t) || t === i) && (e.current.instances.delete(i), e.current.transitions = e.current.transitions.filter(o), e.current.deleted = e.current.deleted.filter(o));
  }
  e.current.forceUpdate();
}
function Db(e, t) {
  let r = e.first, a = e.prevProps, i = ea(e, ["first", "prevProps"]), o = Sf(t), d = o.items, c = o.keys, s = o.initial, p = o.from, y = o.enter, g = o.leave, b = o.update, w = o.trail, S = w === void 0 ? 0 : w, L = o.unique, m = o.config, v = o.order, A = v === void 0 ? [Vu, Yd, Gd] : v, P = Sf(a), T = P.keys, _ = P.items, M = yn({}, i.current), Z = [...i.deleted], Y = Object.keys(M), ae = new Set(Y), j = new Set(c), q = c.filter((ue) => !ae.has(ue)), te = i.transitions.filter((ue) => !ue.destroyed && !j.has(ue.originalKey)).map((ue) => ue.originalKey), le = c.filter((ue) => ae.has(ue)), B = -S;
  for (; A.length; )
    switch (A.shift()) {
      case Vu: {
        q.forEach((ne, J) => {
          L && Z.find(($) => $.originalKey === ne) && (Z = Z.filter(($) => $.originalKey !== ne));
          const W = c.indexOf(ne), K = d[W], ee = r && s !== void 0 ? "initial" : Vu;
          M[ne] = {
            slot: ee,
            originalKey: ne,
            key: L ? String(ne) : Pb++,
            item: K,
            trail: B = B + S,
            config: Br(m, K, ee),
            from: Br(r && s !== void 0 ? s || {} : p, K),
            to: Br(y, K)
          };
        });
        break;
      }
      case Yd: {
        te.forEach((ne) => {
          const J = T.indexOf(ne), W = _[J], K = Yd;
          Z.unshift(yn({}, M[ne], {
            slot: K,
            destroyed: !0,
            left: T[Math.max(0, J - 1)],
            right: T[Math.min(T.length, J + 1)],
            trail: B = B + S,
            config: Br(m, W, K),
            to: Br(g, W)
          })), delete M[ne];
        });
        break;
      }
      case Gd: {
        le.forEach((ne) => {
          const J = c.indexOf(ne), W = d[J], K = Gd;
          M[ne] = yn({}, M[ne], {
            item: W,
            slot: K,
            trail: B = B + S,
            config: Br(m, W, K),
            to: Br(b, W)
          });
        });
        break;
      }
    }
  let X = c.map((ue) => M[ue]);
  return Z.forEach((ue) => {
    let ne = ue.left;
    ue.right;
    let J = ea(ue, ["left", "right"]), W;
    (W = X.findIndex((K) => K.originalKey === ne)) !== -1 && (W += 1), W = Math.max(0, W), X = [...X.slice(0, W), J, ...X.slice(W)];
  }), yn({}, i, {
    changed: q.length || te.length || le.length,
    first: r && q.length === 0,
    transitions: X,
    current: M,
    deleted: Z,
    prevProps: t
  });
}
class _b extends dy {
  constructor(t) {
    t === void 0 && (t = {}), super(), t.transform && !(t.transform instanceof Ir) && (t = tp.transform(t)), this.payload = t;
  }
}
const nc = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, $r = "[-+]?\\d*\\.?\\d+", rc = $r + "%";
function Dc() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const Ob = new RegExp("rgb" + Dc($r, $r, $r)), Fb = new RegExp("rgba" + Dc($r, $r, $r, $r)), Mb = new RegExp("hsl" + Dc($r, rc, rc)), zb = new RegExp("hsla" + Dc($r, rc, rc, $r)), Bb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Ib = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, $b = /^#([0-9a-fA-F]{6})$/, Hb = /^#([0-9a-fA-F]{8})$/;
function Vb(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = $b.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : nc.hasOwnProperty(e) ? nc[e] : (t = Ob.exec(e)) ? (Xo(t[1]) << 24 | // r
  Xo(t[2]) << 16 | // g
  Xo(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = Fb.exec(e)) ? (Xo(t[1]) << 24 | // r
  Xo(t[2]) << 16 | // g
  Xo(t[3]) << 8 | // b
  vh(t[4])) >>> // a
  0 : (t = Bb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = Hb.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = Ib.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = Mb.exec(e)) ? (yh(
    gh(t[1]),
    // h
    Pu(t[2]),
    // s
    Pu(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = zb.exec(e)) ? (yh(
    gh(t[1]),
    // h
    Pu(t[2]),
    // s
    Pu(t[3])
    // l
  ) | vh(t[4])) >>> // a
  0 : null;
}
function Xd(e, t, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function yh(e, t, r) {
  const a = r < 0.5 ? r * (1 + t) : r + t - r * t, i = 2 * r - a, o = Xd(i, a, e + 1 / 3), d = Xd(i, a, e), c = Xd(i, a, e - 1 / 3);
  return Math.round(o * 255) << 24 | Math.round(d * 255) << 16 | Math.round(c * 255) << 8;
}
function Xo(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function gh(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function vh(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function Pu(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function xh(e) {
  let t = Vb(e);
  if (t === null)
    return e;
  t = t || 0;
  let r = (t & 4278190080) >>> 24, a = (t & 16711680) >>> 16, i = (t & 65280) >>> 8, o = (t & 255) / 255;
  return `rgba(${r}, ${a}, ${i}, ${o})`;
}
const Ru = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Wb = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, jb = new RegExp(`(${Object.keys(nc).join("|")})`, "g"), Ub = (e) => {
  const t = e.output.map((i) => i.replace(Wb, xh)).map((i) => i.replace(jb, xh)), r = t[0].match(Ru).map(() => []);
  t.forEach((i) => {
    i.match(Ru).forEach((o, d) => r[d].push(+o));
  });
  const a = t[0].match(Ru).map((i, o) => tc(yn({}, e, {
    output: r[o]
  })));
  return (i) => {
    let o = 0;
    return t[0].replace(Ru, () => a[o++](i)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (d, c, s, p, y) => `rgba(${Math.round(c)}, ${Math.round(s)}, ${Math.round(p)}, ${y})`);
  };
};
let ms = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const Kb = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), Yb = ["Webkit", "Ms", "Moz", "O"];
ms = Object.keys(ms).reduce((e, t) => (Yb.forEach((r) => e[Kb(r, t)] = e[t]), e), ms);
function Gb(e, t, r) {
  return t == null || typeof t == "boolean" || t === "" ? "" : !r && typeof t == "number" && t !== 0 && !(ms.hasOwnProperty(e) && ms[e]) ? t + "px" : ("" + t).trim();
}
const bh = {};
gb((e) => new _b(e));
mb(Ub);
hb(nc);
pb((e, t) => {
  if (e.nodeType && e.setAttribute !== void 0) {
    const i = t.style, o = t.children, d = t.scrollTop, c = t.scrollLeft, s = ea(t, ["style", "children", "scrollTop", "scrollLeft"]), p = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter";
    d !== void 0 && (e.scrollTop = d), c !== void 0 && (e.scrollLeft = c), o !== void 0 && (e.textContent = o);
    for (let y in i)
      if (i.hasOwnProperty(y)) {
        var r = y.indexOf("--") === 0, a = Gb(y, i[y], r);
        y === "float" && (y = "cssFloat"), r ? e.style.setProperty(y, a) : e.style[y] = a;
      }
    for (let y in s) {
      const g = p ? y : bh[y] || (bh[y] = y.replace(/([A-Z])/g, (b) => "-" + b.toLowerCase()));
      typeof e.getAttribute(g) < "u" && e.setAttribute(g, s[y]);
    }
    return;
  } else
    return !1;
}, (e) => e);
const Xb = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], qb = cb(bb, !1), Eh = qb(Xb);
function Zb(e) {
  return e.innerRadius;
}
function Qb(e) {
  return e.outerRadius;
}
function Jb(e) {
  return e.startAngle;
}
function e0(e) {
  return e.endAngle;
}
function t0(e) {
  return e && e.padAngle;
}
function n0(e, t, r, a, i, o, d, c) {
  var s = r - e, p = a - t, y = d - i, g = c - o, b = g * s - y * p;
  if (!(b * b < ar))
    return b = (y * (t - o) - g * (e - i)) / b, [e + b * s, t + b * p];
}
function Nu(e, t, r, a, i, o, d) {
  var c = e - r, s = t - a, p = (d ? o : -o) / Jo(c * c + s * s), y = p * s, g = -p * c, b = e + y, w = t + g, S = r + y, L = a + g, m = (b + S) / 2, v = (w + L) / 2, A = S - b, P = L - w, T = A * A + P * P, _ = i - o, M = b * L - S * w, Z = (P < 0 ? -1 : 1) * Jo(Tg(0, _ * _ * T - M * M)), Y = (M * P - A * Z) / T, ae = (-M * A - P * Z) / T, j = (M * P + A * Z) / T, q = (-M * A + P * Z) / T, te = Y - m, le = ae - v, B = j - m, X = q - v;
  return te * te + le * le > B * B + X * X && (Y = j, ae = q), {
    cx: Y,
    cy: ae,
    x01: -y,
    y01: -g,
    x11: Y * (i / _ - 1),
    y11: ae * (i / _ - 1)
  };
}
function r0() {
  var e = Zb, t = Qb, r = jt(0), a = null, i = Jb, o = e0, d = t0, c = null;
  function s() {
    var p, y, g = +e.apply(this, arguments), b = +t.apply(this, arguments), w = i.apply(this, arguments) - Pp, S = o.apply(this, arguments) - Pp, L = Rp(S - w), m = S > w;
    if (c || (c = p = Ac()), b < g && (y = b, b = g, g = y), !(b > ar))
      c.moveTo(0, 0);
    else if (L > Iu - ar)
      c.moveTo(b * Li(w), b * qr(w)), c.arc(0, 0, b, w, S, !m), g > ar && (c.moveTo(g * Li(S), g * qr(S)), c.arc(0, 0, g, S, w, m));
    else {
      var v = w, A = S, P = w, T = S, _ = L, M = L, Z = d.apply(this, arguments) / 2, Y = Z > ar && (a ? +a.apply(this, arguments) : Jo(g * g + b * b)), ae = Md(Rp(b - g) / 2, +r.apply(this, arguments)), j = ae, q = ae, te, le;
      if (Y > ar) {
        var B = Np(Y / g * qr(Z)), X = Np(Y / b * qr(Z));
        (_ -= B * 2) > ar ? (B *= m ? 1 : -1, P += B, T -= B) : (_ = 0, P = T = (w + S) / 2), (M -= X * 2) > ar ? (X *= m ? 1 : -1, v += X, A -= X) : (M = 0, v = A = (w + S) / 2);
      }
      var ue = b * Li(v), ne = b * qr(v), J = g * Li(T), W = g * qr(T);
      if (ae > ar) {
        var K = b * Li(A), ee = b * qr(A), $ = g * Li(P), pe = g * qr(P), ve;
        if (L < Lp && (ve = n0(ue, ne, $, pe, K, ee, J, W))) {
          var Te = ue - ve[0], ye = ne - ve[1], Re = K - ve[0], Xe = ee - ve[1], Ce = 1 / qr(wg((Te * Re + ye * Xe) / (Jo(Te * Te + ye * ye) * Jo(Re * Re + Xe * Xe))) / 2), xe = Jo(ve[0] * ve[0] + ve[1] * ve[1]);
          j = Md(ae, (g - xe) / (Ce - 1)), q = Md(ae, (b - xe) / (Ce + 1));
        }
      }
      M > ar ? q > ar ? (te = Nu($, pe, ue, ne, b, q, m), le = Nu(K, ee, J, W, b, q, m), c.moveTo(te.cx + te.x01, te.cy + te.y01), q < ae ? c.arc(te.cx, te.cy, q, tr(te.y01, te.x01), tr(le.y01, le.x01), !m) : (c.arc(te.cx, te.cy, q, tr(te.y01, te.x01), tr(te.y11, te.x11), !m), c.arc(0, 0, b, tr(te.cy + te.y11, te.cx + te.x11), tr(le.cy + le.y11, le.cx + le.x11), !m), c.arc(le.cx, le.cy, q, tr(le.y11, le.x11), tr(le.y01, le.x01), !m))) : (c.moveTo(ue, ne), c.arc(0, 0, b, v, A, !m)) : c.moveTo(ue, ne), !(g > ar) || !(_ > ar) ? c.lineTo(J, W) : j > ar ? (te = Nu(J, W, K, ee, g, -j, m), le = Nu(ue, ne, $, pe, g, -j, m), c.lineTo(te.cx + te.x01, te.cy + te.y01), j < ae ? c.arc(te.cx, te.cy, j, tr(te.y01, te.x01), tr(le.y01, le.x01), !m) : (c.arc(te.cx, te.cy, j, tr(te.y01, te.x01), tr(te.y11, te.x11), !m), c.arc(0, 0, g, tr(te.cy + te.y11, te.cx + te.x11), tr(le.cy + le.y11, le.cx + le.x11), m), c.arc(le.cx, le.cy, j, tr(le.y11, le.x11), tr(le.y01, le.x01), !m))) : c.arc(0, 0, g, T, P, m);
    }
    if (c.closePath(), p)
      return c = null, p + "" || null;
  }
  return s.centroid = function() {
    var p = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, y = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Lp / 2;
    return [Li(y) * p, qr(y) * p];
  }, s.innerRadius = function(p) {
    return arguments.length ? (e = typeof p == "function" ? p : jt(+p), s) : e;
  }, s.outerRadius = function(p) {
    return arguments.length ? (t = typeof p == "function" ? p : jt(+p), s) : t;
  }, s.cornerRadius = function(p) {
    return arguments.length ? (r = typeof p == "function" ? p : jt(+p), s) : r;
  }, s.padRadius = function(p) {
    return arguments.length ? (a = p == null ? null : typeof p == "function" ? p : jt(+p), s) : a;
  }, s.startAngle = function(p) {
    return arguments.length ? (i = typeof p == "function" ? p : jt(+p), s) : i;
  }, s.endAngle = function(p) {
    return arguments.length ? (o = typeof p == "function" ? p : jt(+p), s) : o;
  }, s.padAngle = function(p) {
    return arguments.length ? (d = typeof p == "function" ? p : jt(+p), s) : d;
  }, s.context = function(p) {
    return arguments.length ? (c = p ?? null, s) : c;
  }, s;
}
function vy(e) {
  this._context = e;
}
vy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function _c(e) {
  return new vy(e);
}
function np(e) {
  return e[0];
}
function rp(e) {
  return e[1];
}
function xy() {
  var e = np, t = rp, r = jt(!0), a = null, i = _c, o = null;
  function d(c) {
    var s, p = c.length, y, g = !1, b;
    for (a == null && (o = i(b = Ac())), s = 0; s <= p; ++s)
      !(s < p && r(y = c[s], s, c)) === g && ((g = !g) ? o.lineStart() : o.lineEnd()), g && o.point(+e(y, s, c), +t(y, s, c));
    if (b)
      return o = null, b + "" || null;
  }
  return d.x = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : jt(+c), d) : e;
  }, d.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : jt(+c), d) : t;
  }, d.defined = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : jt(!!c), d) : r;
  }, d.curve = function(c) {
    return arguments.length ? (i = c, a != null && (o = i(a)), d) : i;
  }, d.context = function(c) {
    return arguments.length ? (c == null ? a = o = null : o = i(a = c), d) : a;
  }, d;
}
function a0() {
  var e = np, t = null, r = jt(0), a = rp, i = jt(!0), o = null, d = _c, c = null;
  function s(y) {
    var g, b, w, S = y.length, L, m = !1, v, A = new Array(S), P = new Array(S);
    for (o == null && (c = d(v = Ac())), g = 0; g <= S; ++g) {
      if (!(g < S && i(L = y[g], g, y)) === m)
        if (m = !m)
          b = g, c.areaStart(), c.lineStart();
        else {
          for (c.lineEnd(), c.lineStart(), w = g - 1; w >= b; --w)
            c.point(A[w], P[w]);
          c.lineEnd(), c.areaEnd();
        }
      m && (A[g] = +e(L, g, y), P[g] = +r(L, g, y), c.point(t ? +t(L, g, y) : A[g], a ? +a(L, g, y) : P[g]));
    }
    if (v)
      return c = null, v + "" || null;
  }
  function p() {
    return xy().defined(i).curve(d).context(o);
  }
  return s.x = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : jt(+y), t = null, s) : e;
  }, s.x0 = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : jt(+y), s) : e;
  }, s.x1 = function(y) {
    return arguments.length ? (t = y == null ? null : typeof y == "function" ? y : jt(+y), s) : t;
  }, s.y = function(y) {
    return arguments.length ? (r = typeof y == "function" ? y : jt(+y), a = null, s) : r;
  }, s.y0 = function(y) {
    return arguments.length ? (r = typeof y == "function" ? y : jt(+y), s) : r;
  }, s.y1 = function(y) {
    return arguments.length ? (a = y == null ? null : typeof y == "function" ? y : jt(+y), s) : a;
  }, s.lineX0 = s.lineY0 = function() {
    return p().x(e).y(r);
  }, s.lineY1 = function() {
    return p().x(e).y(a);
  }, s.lineX1 = function() {
    return p().x(t).y(r);
  }, s.defined = function(y) {
    return arguments.length ? (i = typeof y == "function" ? y : jt(!!y), s) : i;
  }, s.curve = function(y) {
    return arguments.length ? (d = y, o != null && (c = d(o)), s) : d;
  }, s.context = function(y) {
    return arguments.length ? (y == null ? o = c = null : c = d(o = y), s) : o;
  }, s;
}
function i0(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function o0(e) {
  return e;
}
function l0() {
  var e = o0, t = i0, r = null, a = jt(0), i = jt(Iu), o = jt(0);
  function d(c) {
    var s, p = c.length, y, g, b = 0, w = new Array(p), S = new Array(p), L = +a.apply(this, arguments), m = Math.min(Iu, Math.max(-Iu, i.apply(this, arguments) - L)), v, A = Math.min(Math.abs(m) / p, o.apply(this, arguments)), P = A * (m < 0 ? -1 : 1), T;
    for (s = 0; s < p; ++s)
      (T = S[w[s] = s] = +e(c[s], s, c)) > 0 && (b += T);
    for (t != null ? w.sort(function(_, M) {
      return t(S[_], S[M]);
    }) : r != null && w.sort(function(_, M) {
      return r(c[_], c[M]);
    }), s = 0, g = b ? (m - p * P) / b : 0; s < p; ++s, L = v)
      y = w[s], T = S[y], v = L + (T > 0 ? T * g : 0) + P, S[y] = {
        data: c[y],
        index: s,
        value: T,
        startAngle: L,
        endAngle: v,
        padAngle: A
      };
    return S;
  }
  return d.value = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : jt(+c), d) : e;
  }, d.sortValues = function(c) {
    return arguments.length ? (t = c, r = null, d) : t;
  }, d.sort = function(c) {
    return arguments.length ? (r = c, t = null, d) : r;
  }, d.startAngle = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : jt(+c), d) : a;
  }, d.endAngle = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : jt(+c), d) : i;
  }, d.padAngle = function(c) {
    return arguments.length ? (o = typeof c == "function" ? c : jt(+c), d) : o;
  }, d;
}
var kf = Array.prototype.slice;
function s0(e) {
  return e.source;
}
function u0(e) {
  return e.target;
}
function c0(e) {
  var t = s0, r = u0, a = np, i = rp, o = null;
  function d() {
    var c, s = kf.call(arguments), p = t.apply(this, s), y = r.apply(this, s);
    if (o || (o = c = Ac()), e(o, +a.apply(this, (s[0] = p, s)), +i.apply(this, s), +a.apply(this, (s[0] = y, s)), +i.apply(this, s)), c)
      return o = null, c + "" || null;
  }
  return d.source = function(c) {
    return arguments.length ? (t = c, d) : t;
  }, d.target = function(c) {
    return arguments.length ? (r = c, d) : r;
  }, d.x = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : jt(+c), d) : a;
  }, d.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : jt(+c), d) : i;
  }, d.context = function(c) {
    return arguments.length ? (o = c ?? null, d) : o;
  }, d;
}
function d0(e, t, r, a, i) {
  e.moveTo(t, r), e.bezierCurveTo(t = (t + a) / 2, r, t, i, a, i);
}
function f0() {
  return c0(d0);
}
const p0 = {
  draw: function(e, t) {
    var r = Math.sqrt(t / 5) / 2;
    e.moveTo(-3 * r, -r), e.lineTo(-r, -r), e.lineTo(-r, -3 * r), e.lineTo(r, -3 * r), e.lineTo(r, -r), e.lineTo(3 * r, -r), e.lineTo(3 * r, r), e.lineTo(r, r), e.lineTo(r, 3 * r), e.lineTo(-r, 3 * r), e.lineTo(-r, r), e.lineTo(-3 * r, r), e.closePath();
  }
};
function Ya() {
}
function ac(e, t, r) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + r) / 6
  );
}
function Oc(e) {
  this._context = e;
}
Oc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        ac(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        ac(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function h0(e) {
  return new Oc(e);
}
function by(e) {
  this._context = e;
}
by.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        ac(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function m0(e) {
  return new by(e);
}
function Ey(e) {
  this._context = e;
}
Ey.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + e) / 6, a = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(r, a) : this._context.moveTo(r, a);
        break;
      case 3:
        this._point = 4;
      default:
        ac(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function y0(e) {
  return new Ey(e);
}
function Sy(e, t) {
  this._basis = new Oc(e), this._beta = t;
}
Sy.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length - 1;
    if (r > 0)
      for (var a = e[0], i = t[0], o = e[r] - a, d = t[r] - i, c = -1, s; ++c <= r; )
        s = c / r, this._basis.point(
          this._beta * e[c] + (1 - this._beta) * (a + s * o),
          this._beta * t[c] + (1 - this._beta) * (i + s * d)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const g0 = function e(t) {
  function r(a) {
    return t === 1 ? new Oc(a) : new Sy(a, t);
  }
  return r.beta = function(a) {
    return e(+a);
  }, r;
}(0.85);
function ic(e, t, r) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - r),
    e._x2,
    e._y2
  );
}
function ap(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
ap.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        ic(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        ic(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const v0 = function e(t) {
  function r(a) {
    return new ap(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function ip(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
ip.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        ic(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const x0 = function e(t) {
  function r(a) {
    return new ip(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function op(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
op.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        ic(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const b0 = function e(t) {
  function r(a) {
    return new op(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function lp(e, t, r) {
  var a = e._x1, i = e._y1, o = e._x2, d = e._y2;
  if (e._l01_a > ar) {
    var c = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, s = 3 * e._l01_a * (e._l01_a + e._l12_a);
    a = (a * c - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / s, i = (i * c - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / s;
  }
  if (e._l23_a > ar) {
    var p = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, y = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * p + e._x1 * e._l23_2a - t * e._l12_2a) / y, d = (d * p + e._y1 * e._l23_2a - r * e._l12_2a) / y;
  }
  e._context.bezierCurveTo(a, i, o, d, e._x2, e._y2);
}
function ky(e, t) {
  this._context = e, this._alpha = t;
}
ky.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        lp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const E0 = function e(t) {
  function r(a) {
    return t ? new ky(a, t) : new ap(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function wy(e, t) {
  this._context = e, this._alpha = t;
}
wy.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        lp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const S0 = function e(t) {
  function r(a) {
    return t ? new wy(a, t) : new ip(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function Ty(e, t) {
  this._context = e, this._alpha = t;
}
Ty.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        lp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const k0 = function e(t) {
  function r(a) {
    return t ? new Ty(a, t) : new op(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function Cy(e) {
  this._context = e;
}
Cy.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function wf(e) {
  return new Cy(e);
}
function Sh(e) {
  return e < 0 ? -1 : 1;
}
function kh(e, t, r) {
  var a = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (a || i < 0 && -0), d = (r - e._y1) / (i || a < 0 && -0), c = (o * i + d * a) / (a + i);
  return (Sh(o) + Sh(d)) * Math.min(Math.abs(o), Math.abs(d), 0.5 * Math.abs(c)) || 0;
}
function wh(e, t) {
  var r = e._x1 - e._x0;
  return r ? (3 * (e._y1 - e._y0) / r - t) / 2 : t;
}
function qd(e, t, r) {
  var a = e._x0, i = e._y0, o = e._x1, d = e._y1, c = (o - a) / 3;
  e._context.bezierCurveTo(a + c, i + c * t, o - c, d - c * r, o, d);
}
function oc(e) {
  this._context = e;
}
oc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        qd(this, this._t0, wh(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var r = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, qd(this, wh(this, r = kh(this, e, t)), r);
          break;
        default:
          qd(this, this._t0, r = kh(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = r;
    }
  }
};
function Ay(e) {
  this._context = new Ly(e);
}
(Ay.prototype = Object.create(oc.prototype)).point = function(e, t) {
  oc.prototype.point.call(this, t, e);
};
function Ly(e) {
  this._context = e;
}
Ly.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, r, a, i, o) {
    this._context.bezierCurveTo(t, e, a, r, o, i);
  }
};
function Wu(e) {
  return new oc(e);
}
function w0(e) {
  return new Ay(e);
}
function Py(e) {
  this._context = e;
}
Py.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length;
    if (r)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), r === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var a = Th(e), i = Th(t), o = 0, d = 1; d < r; ++o, ++d)
          this._context.bezierCurveTo(a[0][o], i[0][o], a[1][o], i[1][o], e[d], t[d]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Th(e) {
  var t, r = e.length - 1, a, i = new Array(r), o = new Array(r), d = new Array(r);
  for (i[0] = 0, o[0] = 2, d[0] = e[0] + 2 * e[1], t = 1; t < r - 1; ++t)
    i[t] = 1, o[t] = 4, d[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[r - 1] = 2, o[r - 1] = 7, d[r - 1] = 8 * e[r - 1] + e[r], t = 1; t < r; ++t)
    a = i[t] / o[t - 1], o[t] -= a, d[t] -= a * d[t - 1];
  for (i[r - 1] = d[r - 1] / o[r - 1], t = r - 2; t >= 0; --t)
    i[t] = (d[t] - i[t + 1]) / o[t];
  for (o[r - 1] = (e[r] + i[r - 1]) / 2, t = 0; t < r - 1; ++t)
    o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function T0(e) {
  return new Py(e);
}
function Fc(e, t) {
  this._context = e, this._t = t;
}
Fc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var r = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function C0(e) {
  return new Fc(e, 0.5);
}
function A0(e) {
  return new Fc(e, 0);
}
function L0(e) {
  return new Fc(e, 1);
}
function ul(e, t) {
  if ((d = e.length) > 1)
    for (var r = 1, a, i, o = e[t[0]], d, c = o.length; r < d; ++r)
      for (i = o, o = e[t[r]], a = 0; a < c; ++a)
        o[a][1] += o[a][0] = isNaN(i[a][1]) ? i[a][0] : i[a][1];
}
function cl(e) {
  for (var t = e.length, r = new Array(t); --t >= 0; )
    r[t] = t;
  return r;
}
function P0(e, t) {
  return e[t];
}
function sp() {
  var e = jt([]), t = cl, r = ul, a = P0;
  function i(o) {
    var d = e.apply(this, arguments), c, s = o.length, p = d.length, y = new Array(p), g;
    for (c = 0; c < p; ++c) {
      for (var b = d[c], w = y[c] = new Array(s), S = 0, L; S < s; ++S)
        w[S] = L = [0, +a(o[S], b, S, o)], L.data = o[S];
      w.key = b;
    }
    for (c = 0, g = t(y); c < p; ++c)
      y[g[c]].index = c;
    return r(y, g), y;
  }
  return i.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : jt(kf.call(o)), i) : e;
  }, i.value = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : jt(+o), i) : a;
  }, i.order = function(o) {
    return arguments.length ? (t = o == null ? cl : typeof o == "function" ? o : jt(kf.call(o)), i) : t;
  }, i.offset = function(o) {
    return arguments.length ? (r = o ?? ul, i) : r;
  }, i;
}
function R0(e, t) {
  if ((a = e.length) > 0) {
    for (var r, a, i = 0, o = e[0].length, d; i < o; ++i) {
      for (d = r = 0; r < a; ++r)
        d += e[r][i][1] || 0;
      if (d)
        for (r = 0; r < a; ++r)
          e[r][i][1] /= d;
    }
    ul(e, t);
  }
}
function N0(e, t) {
  if ((s = e.length) > 0)
    for (var r, a = 0, i, o, d, c, s, p = e[t[0]].length; a < p; ++a)
      for (d = c = 0, r = 0; r < s; ++r)
        (o = (i = e[t[r]][a])[1] - i[0]) > 0 ? (i[0] = d, i[1] = d += o) : o < 0 ? (i[1] = c, i[0] = c += o) : (i[0] = 0, i[1] = o);
}
function D0(e, t) {
  if ((i = e.length) > 0) {
    for (var r = 0, a = e[t[0]], i, o = a.length; r < o; ++r) {
      for (var d = 0, c = 0; d < i; ++d)
        c += e[d][r][1] || 0;
      a[r][1] += a[r][0] = -c / 2;
    }
    ul(e, t);
  }
}
function _0(e, t) {
  if (!(!((d = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var r = 0, a = 1, i, o, d; a < o; ++a) {
      for (var c = 0, s = 0, p = 0; c < d; ++c) {
        for (var y = e[t[c]], g = y[a][1] || 0, b = y[a - 1][1] || 0, w = (g - b) / 2, S = 0; S < c; ++S) {
          var L = e[t[S]], m = L[a][1] || 0, v = L[a - 1][1] || 0;
          w += m - v;
        }
        s += g, p += w * g;
      }
      i[a - 1][1] += i[a - 1][0] = r, s && (r -= p / s);
    }
    i[a - 1][1] += i[a - 1][0] = r, ul(e, t);
  }
}
function O0(e) {
  var t = e.map(F0);
  return cl(e).sort(function(r, a) {
    return t[r] - t[a];
  });
}
function F0(e) {
  for (var t = -1, r = 0, a = e.length, i, o = -1 / 0; ++t < a; )
    (i = +e[t][1]) > o && (o = i, r = t);
  return r;
}
function Ry(e) {
  var t = e.map(Ny);
  return cl(e).sort(function(r, a) {
    return t[r] - t[a];
  });
}
function Ny(e) {
  for (var t = 0, r = -1, a = e.length, i; ++r < a; )
    (i = +e[r][1]) && (t += i);
  return t;
}
function M0(e) {
  return Ry(e).reverse();
}
function z0(e) {
  var t = e.length, r, a, i = e.map(Ny), o = O0(e), d = 0, c = 0, s = [], p = [];
  for (r = 0; r < t; ++r)
    a = o[r], d < c ? (d += i[a], s.push(a)) : (c += i[a], p.push(a));
  return p.reverse().concat(s);
}
function B0(e) {
  return cl(e).reverse();
}
function Cn(e, t) {
  e(t);
}
var Ch = {
  ascending: Ry,
  descending: M0,
  insideout: z0,
  none: cl,
  reverse: B0
};
function up(e) {
  return e && Ch[e] || Ch.none;
}
var Ah = {
  expand: R0,
  diverging: N0,
  none: ul,
  silhouette: D0,
  wiggle: _0
};
function cp(e) {
  return e && Ah[e] || Ah.none;
}
function I0(e) {
  var t = e === void 0 ? {} : e, r = t.innerRadius, a = t.outerRadius, i = t.cornerRadius, o = t.startAngle, d = t.endAngle, c = t.padAngle, s = t.padRadius, p = r0();
  return r != null && Cn(p.innerRadius, r), a != null && Cn(p.outerRadius, a), i != null && Cn(p.cornerRadius, i), o != null && Cn(p.startAngle, o), d != null && Cn(p.endAngle, d), c != null && Cn(p.padAngle, c), s != null && Cn(p.padRadius, s), p;
}
function dp(e) {
  var t = e === void 0 ? {} : e, r = t.x, a = t.x0, i = t.x1, o = t.y, d = t.y0, c = t.y1, s = t.defined, p = t.curve, y = a0();
  return r && Cn(y.x, r), a && Cn(y.x0, a), i && Cn(y.x1, i), o && Cn(y.y, o), d && Cn(y.y0, d), c && Cn(y.y1, c), s && y.defined(s), p && y.curve(p), y;
}
function Dy(e) {
  var t = e === void 0 ? {} : e, r = t.x, a = t.y, i = t.defined, o = t.curve, d = xy();
  return r && Cn(d.x, r), a && Cn(d.y, a), i && d.defined(i), o && d.curve(o), d;
}
function $0(e) {
  var t = e === void 0 ? {} : e, r = t.startAngle, a = t.endAngle, i = t.padAngle, o = t.value, d = t.sort, c = t.sortValues, s = l0();
  return (d === null || d != null) && s.sort(d), (c === null || c != null) && s.sortValues(c), o != null && s.value(o), i != null && Cn(s.padAngle, i), r != null && Cn(s.startAngle, r), a != null && Cn(s.endAngle, a), s;
}
function H0(e) {
  var t = e.keys, r = e.value, a = e.order, i = e.offset, o = sp();
  return t && o.keys(t), r && Cn(o.value, r), a && o.order(up(a)), i && o.offset(cp(i)), o;
}
var V0 = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function Tf() {
  return Tf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Tf.apply(this, arguments);
}
function W0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function j0(e) {
  var t = e.className, r = e.top, a = e.left, i = e.data, o = i === void 0 ? [] : i, d = e.centroid, c = e.innerRadius, s = c === void 0 ? 0 : c, p = e.outerRadius, y = e.cornerRadius, g = e.startAngle, b = e.endAngle, w = e.padAngle, S = e.padRadius, L = e.pieSort, m = e.pieSortValues, v = e.pieValue, A = e.children, P = e.fill, T = P === void 0 ? "" : P, _ = W0(e, V0), M = I0({
    innerRadius: s,
    outerRadius: p,
    cornerRadius: y,
    padRadius: S
  }), Z = $0({
    startAngle: g,
    endAngle: b,
    padAngle: w,
    value: v,
    sort: L,
    sortValues: m
  }), Y = Z(o);
  return A ? /* @__PURE__ */ n.createElement(n.Fragment, null, A({
    arcs: Y,
    path: M,
    pie: Z
  })) : /* @__PURE__ */ n.createElement(tt, {
    className: "visx-pie-arcs-group",
    top: r,
    left: a
  }, Y.map(function(ae, j) {
    return /* @__PURE__ */ n.createElement("g", {
      key: "pie-arc-" + j
    }, /* @__PURE__ */ n.createElement("path", Tf({
      className: Nn("visx-pie-arc", t),
      d: M(ae) || "",
      fill: T == null || typeof T == "string" ? T : T(ae)
    }, _)), d == null ? void 0 : d(M.centroid(ae), ae));
  }));
}
var U0 = ["from", "to", "fill", "className", "innerRef"];
function Cf() {
  return Cf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Cf.apply(this, arguments);
}
function K0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function cn(e) {
  var t = e.from, r = t === void 0 ? {
    x: 0,
    y: 0
  } : t, a = e.to, i = a === void 0 ? {
    x: 1,
    y: 1
  } : a, o = e.fill, d = o === void 0 ? "transparent" : o, c = e.className, s = e.innerRef, p = K0(e, U0), y = r.x === i.x || r.y === i.y;
  return /* @__PURE__ */ n.createElement("line", Cf({
    ref: s,
    className: Nn("visx-line", c),
    x1: r.x,
    y1: r.y,
    x2: i.x,
    y2: i.y,
    fill: d,
    shapeRendering: y ? "crispEdges" : "auto"
  }, p));
}
var Y0 = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function Af() {
  return Af = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Af.apply(this, arguments);
}
function G0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Hr(e) {
  var t = e.children, r = e.data, a = r === void 0 ? [] : r, i = e.x, o = e.y, d = e.fill, c = d === void 0 ? "transparent" : d, s = e.className, p = e.curve, y = e.innerRef, g = e.defined, b = g === void 0 ? function() {
    return !0;
  } : g, w = G0(e, Y0), S = Dy({
    x: i,
    y: o,
    defined: b,
    curve: p
  });
  return t ? /* @__PURE__ */ n.createElement(n.Fragment, null, t({
    path: S
  })) : /* @__PURE__ */ n.createElement("path", Af({
    ref: y,
    className: Nn("visx-linepath", s),
    d: S(a) || "",
    fill: c,
    strokeLinecap: "round"
  }, w));
}
var X0 = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function Lf() {
  return Lf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Lf.apply(this, arguments);
}
function q0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Z0(e) {
  var t = e.children, r = e.x, a = e.x0, i = e.x1, o = e.y, d = e.y0, c = e.y1, s = e.data, p = s === void 0 ? [] : s, y = e.defined, g = y === void 0 ? function() {
    return !0;
  } : y, b = e.className, w = e.curve, S = e.innerRef, L = q0(e, X0), m = dp({
    x: r,
    x0: a,
    x1: i,
    y: o,
    y0: d,
    y1: c,
    defined: g,
    curve: w
  });
  return t ? /* @__PURE__ */ n.createElement(n.Fragment, null, t({
    path: m
  })) : /* @__PURE__ */ n.createElement("path", Lf({
    ref: S,
    className: Nn("visx-area", b),
    d: m(p) || ""
  }, L));
}
var Q0 = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function Pf() {
  return Pf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Pf.apply(this, arguments);
}
function J0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Rf(e) {
  var t = e.x, r = e.x0, a = e.x1, i = e.y, o = e.y1, d = e.y0, c = e.yScale, s = e.data, p = s === void 0 ? [] : s, y = e.defined, g = y === void 0 ? function() {
    return !0;
  } : y, b = e.className, w = e.curve, S = e.innerRef, L = e.children, m = J0(e, Q0), v = dp({
    x: t,
    x0: r,
    x1: a,
    defined: g,
    curve: w
  });
  return d == null ? v.y0(c.range()[0]) : Cn(v.y0, d), i && !o && Cn(v.y1, i), o && !i && Cn(v.y1, o), L ? /* @__PURE__ */ n.createElement(n.Fragment, null, L({
    path: v
  })) : /* @__PURE__ */ n.createElement("path", Pf({
    ref: S,
    className: Nn("visx-area-closed", b),
    d: v(p) || ""
  }, m));
}
var eE = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function Nf() {
  return Nf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Nf.apply(this, arguments);
}
function tE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function nE(e) {
  var t = e.className, r = e.top, a = e.left, i = e.keys, o = e.data, d = e.curve, c = e.defined, s = e.x, p = e.x0, y = e.x1, g = e.y0, b = e.y1, w = e.value, S = e.order, L = e.offset, m = e.color, v = e.children, A = tE(e, eE), P = H0({
    keys: i,
    value: w,
    order: S,
    offset: L
  }), T = dp({
    x: s,
    x0: p,
    x1: y,
    y0: g,
    y1: b,
    curve: d,
    defined: c
  }), _ = P(o);
  return v ? /* @__PURE__ */ n.createElement(n.Fragment, null, v({
    stacks: _,
    path: T,
    stack: P
  })) : /* @__PURE__ */ n.createElement(tt, {
    top: r,
    left: a
  }, _.map(function(M, Z) {
    return /* @__PURE__ */ n.createElement("path", Nf({
      className: Nn("visx-stack", t),
      key: "stack-" + Z + "-" + (M.key || ""),
      d: T(M) || "",
      fill: m == null ? void 0 : m(M.key, Z)
    }, A));
  }));
}
var rE = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function lc() {
  return lc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, lc.apply(this, arguments);
}
function aE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function iE(e) {
  var t = e.className, r = e.top, a = e.left, i = e.keys, o = e.data, d = e.curve, c = e.defined, s = e.x, p = e.x0, y = e.x1, g = e.y0, b = e.y1, w = e.value, S = e.order, L = e.offset, m = e.color, v = e.children, A = aE(e, rE);
  return /* @__PURE__ */ n.createElement(nE, lc({
    className: t,
    top: r,
    left: a,
    keys: i,
    data: o,
    curve: d,
    defined: c,
    x: s,
    x0: p,
    x1: y,
    y0: g,
    y1: b,
    value: w,
    order: S,
    offset: L,
    color: m
  }, A), v || function(P) {
    var T = P.stacks, _ = P.path;
    return T.map(function(M, Z) {
      return /* @__PURE__ */ n.createElement("path", lc({
        className: Nn("visx-area-stack", t),
        key: "area-stack-" + Z + "-" + (M.key || ""),
        d: _(M) || "",
        fill: m == null ? void 0 : m(M.key, Z)
      }, A));
    });
  });
}
function fp(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), r = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / r.length;
}
var oE = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function Df() {
  return Df = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Df.apply(this, arguments);
}
function lE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function _y(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.x0, d = e.x0Scale, c = e.x1Scale, s = e.yScale, p = e.color, y = e.keys, g = e.height, b = e.children, w = lE(e, oE), S = fp(c), L = t.map(function(m, v) {
    return {
      index: v,
      x0: d(o(m)),
      bars: y.map(function(A, P) {
        var T = m[A];
        return {
          index: P,
          key: A,
          value: T,
          width: S,
          x: c(A) || 0,
          y: s(T) || 0,
          color: p(A, P),
          height: g - (s(T) || 0)
        };
      })
    };
  });
  return b ? /* @__PURE__ */ n.createElement(n.Fragment, null, b(L)) : /* @__PURE__ */ n.createElement(tt, {
    className: Nn("visx-bar-group", r),
    top: a,
    left: i
  }, L.map(function(m) {
    return /* @__PURE__ */ n.createElement(tt, {
      key: "bar-group-" + m.index + "-" + m.x0,
      left: m.x0
    }, m.bars.map(function(v) {
      return /* @__PURE__ */ n.createElement(Rr, Df({
        key: "bar-group-bar-" + m.index + "-" + v.index + "-" + v.value + "-" + v.key,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height,
        fill: v.color
      }, w));
    }));
  }));
}
function Oy(e) {
  return e == null ? void 0 : e[0];
}
function Fy(e) {
  return e == null ? void 0 : e[1];
}
var sE = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function _f() {
  return _f = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, _f.apply(this, arguments);
}
function uE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function My(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.x, d = e.y0, c = d === void 0 ? Oy : d, s = e.y1, p = s === void 0 ? Fy : s, y = e.xScale, g = e.yScale, b = e.color, w = e.keys, S = e.value, L = e.order, m = e.offset, v = e.children, A = uE(e, sE), P = sp();
  w && P.keys(w), S && Cn(P.value, S), L && P.order(up(L)), m && P.offset(cp(m));
  var T = P(t), _ = fp(y), M = T.map(function(Z, Y) {
    var ae = Z.key;
    return {
      index: Y,
      key: ae,
      bars: Z.map(function(j, q) {
        var te = (g(c(j)) || 0) - (g(p(j)) || 0), le = g(p(j)), B = "bandwidth" in y ? y(o(j.data)) : Math.max((y(o(j.data)) || 0) - _ / 2);
        return {
          bar: j,
          key: ae,
          index: q,
          height: te,
          width: _,
          x: B || 0,
          y: le || 0,
          color: b(Z.key, q)
        };
      })
    };
  });
  return v ? /* @__PURE__ */ n.createElement(n.Fragment, null, v(M)) : /* @__PURE__ */ n.createElement(tt, {
    className: Nn("visx-bar-stack", r),
    top: a,
    left: i
  }, M.map(function(Z) {
    return Z.bars.map(function(Y) {
      return /* @__PURE__ */ n.createElement(Rr, _f({
        key: "bar-stack-" + Z.index + "-" + Y.index,
        x: Y.x,
        y: Y.y,
        height: Y.height,
        width: Y.width,
        fill: Y.color
      }, A));
    });
  }));
}
var cE = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function Of() {
  return Of = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Of.apply(this, arguments);
}
function dE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function fE(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.y, d = e.x0, c = d === void 0 ? Oy : d, s = e.x1, p = s === void 0 ? Fy : s, y = e.xScale, g = e.yScale, b = e.color, w = e.keys, S = e.value, L = e.order, m = e.offset, v = e.children, A = dE(e, cE), P = sp();
  w && P.keys(w), S && Cn(P.value, S), L && P.order(up(L)), m && P.offset(cp(m));
  var T = P(t), _ = fp(g), M = T.map(function(Z, Y) {
    var ae = Z.key;
    return {
      index: Y,
      key: ae,
      bars: Z.map(function(j, q) {
        var te = (y(p(j)) || 0) - (y(c(j)) || 0), le = y(c(j)), B = "bandwidth" in g ? g(o(j.data)) : Math.max((g(o(j.data)) || 0) - te / 2);
        return {
          bar: j,
          key: ae,
          index: q,
          height: _,
          width: te,
          x: le || 0,
          y: B || 0,
          color: b(Z.key, q)
        };
      })
    };
  });
  return v ? /* @__PURE__ */ n.createElement(n.Fragment, null, v(M)) : /* @__PURE__ */ n.createElement(tt, {
    className: Nn("visx-bar-stack-horizontal", r),
    top: a,
    left: i
  }, M.map(function(Z) {
    return Z.bars.map(function(Y) {
      return /* @__PURE__ */ n.createElement(Rr, Of({
        key: "bar-stack-" + Z.index + "-" + Y.index,
        x: Y.x,
        y: Y.y,
        height: Y.height,
        width: Y.width,
        fill: Y.color
      }, A));
    });
  }));
}
var Lh = "http://www.w3.org/2000/svg";
function pE(e) {
  var t = document.getElementById(e);
  if (!t) {
    var r = document.createElementNS(Lh, "svg");
    r.setAttribute("aria-hidden", "true"), r.style.opacity = "0", r.style.width = "0", r.style.height = "0", r.style.position = "absolute", r.style.top = "-100%", r.style.left = "-100%", r.style.pointerEvents = "none", t = document.createElementNS(Lh, "path"), t.setAttribute("id", e), r.appendChild(t), document.body.appendChild(r);
  }
  return t;
}
var hE = "__visx_splitpath_svg_path_measurement_id", Ph = function() {
  return !0;
};
function mE(e) {
  var t = e.path, r = e.pointsInSegments, a = e.segmentation, i = a === void 0 ? "x" : a, o = e.sampleRate, d = o === void 0 ? 1 : o;
  try {
    var c = pE(hE);
    c.setAttribute("d", t);
    var s = c.getTotalLength(), p = r.length, y = r.map(function() {
      return [];
    });
    if (i === "x" || i === "y")
      for (var g = r.map(function(le) {
        var B;
        return (B = le.find(function(X) {
          return typeof X[i] == "number";
        })) == null ? void 0 : B[i];
      }), b = c.getPointAtLength(0), w = c.getPointAtLength(s), S = w[i] > b[i], L = S ? g.map(function(le) {
        return typeof le > "u" ? Ph : function(B) {
          return B >= le;
        };
      }) : g.map(function(le) {
        return typeof le > "u" ? Ph : function(B) {
          return B <= le;
        };
      }), m = 0, v = 0; v <= s; v += d) {
        for (var A = c.getPointAtLength(v), P = A[i]; m < p - 1 && L[m + 1](P); )
          m += 1;
        y[m].push(A);
      }
    else {
      var T = r.map(function(le) {
        return le.length;
      }), _ = T.reduce(function(le, B) {
        return le + B;
      }, 0), M = s / Math.max(1, _ - 1), Z = T.slice(0, p - 1);
      Z.unshift(0);
      for (var Y = 2; Y < p; Y += 1)
        Z[Y] += Z[Y - 1];
      for (var ae = 0; ae < p; ae += 1)
        Z[ae] *= M;
      for (var j = 0, q = 0; q <= s; q += d) {
        for (var te = c.getPointAtLength(q); j < p - 1 && q >= Z[j + 1]; )
          j += 1;
        y[j].push(te);
      }
    }
    return y;
  } catch {
    return [];
  }
}
function Ff() {
  return Ff = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ff.apply(this, arguments);
}
var yE = function(t) {
  return t.x || 0;
}, gE = function(t) {
  return t.y || 0;
};
function zy(e) {
  var t = e.children, r = e.className, a = e.curve, i = e.defined, o = e.segmentation, d = e.sampleRate, c = e.segments, s = e.x, p = e.y, y = e.styles, g = se.useMemo(function() {
    var S = typeof s == "number" || typeof s > "u" ? function() {
      return s;
    } : s, L = typeof p == "number" || typeof p > "u" ? function() {
      return p;
    } : p;
    return c.map(function(m) {
      return m.map(function(v, A) {
        return {
          x: S(v, A, m),
          y: L(v, A, m)
        };
      });
    });
  }, [s, p, c]), b = se.useMemo(function() {
    var S = Dy({
      x: s,
      y: p,
      defined: i,
      curve: a
    });
    return S(c.flat()) || "";
  }, [s, p, i, a, c]), w = se.useMemo(function() {
    return mE({
      path: b,
      segmentation: o,
      pointsInSegments: g,
      sampleRate: d
    });
  }, [b, o, g, d]);
  return /* @__PURE__ */ n.createElement("g", null, w.map(function(S, L) {
    return t ? /* @__PURE__ */ n.createElement(n.Fragment, {
      key: L
    }, t({
      index: L,
      segment: S,
      styles: y[L] || y[L % y.length]
    })) : /* @__PURE__ */ n.createElement(Hr, Ff({
      key: L,
      className: r,
      data: S,
      x: yE,
      y: gE
    }, y[L] || y[L % y.length]));
  }));
}
zy.propTypes = {
  segments: Me.arrayOf(Me.array).isRequired,
  styles: Me.array.isRequired,
  children: Me.func,
  className: Me.string
};
var vE = ["tooltipOpen"];
function xE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function sc() {
  return sc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, sc.apply(this, arguments);
}
function By(e) {
  var t = se.useState(sc({
    tooltipOpen: !1
  }, e)), r = t[0], a = t[1], i = se.useCallback(function(d) {
    return a(typeof d == "function" ? function(c) {
      c.tooltipOpen;
      var s = xE(c, vE);
      return sc({}, d(s), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: d.tooltipLeft,
      tooltipTop: d.tooltipTop,
      tooltipData: d.tooltipData
    });
  }, [a]), o = se.useCallback(function() {
    return a({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [a]);
  return {
    tooltipOpen: r.tooltipOpen,
    tooltipLeft: r.tooltipLeft,
    tooltipTop: r.tooltipTop,
    tooltipData: r.tooltipData,
    updateTooltip: a,
    showTooltip: i,
    hideTooltip: o
  };
}
var bE = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function uc() {
  return uc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, uc.apply(this, arguments);
}
function EE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var Iy = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, pp = /* @__PURE__ */ n.forwardRef(function(e, t) {
  var r = e.className, a = e.top, i = e.left, o = e.offsetLeft, d = o === void 0 ? 10 : o, c = e.offsetTop, s = c === void 0 ? 10 : c, p = e.style, y = p === void 0 ? Iy : p, g = e.children, b = e.unstyled, w = b === void 0 ? !1 : b, S = e.applyPositionStyle, L = S === void 0 ? !1 : S, m = EE(e, bE);
  return /* @__PURE__ */ n.createElement("div", uc({
    ref: t,
    className: Nn("visx-tooltip", r),
    style: uc({
      top: a == null || s == null ? a : a + s,
      left: i == null || d == null ? i : i + d
    }, L && {
      position: "absolute"
    }, !w && y)
  }, m), g);
});
pp.propTypes = {
  children: Me.node,
  className: Me.string,
  left: Me.number,
  offsetLeft: Me.number,
  offsetTop: Me.number,
  top: Me.number,
  applyPositionStyle: Me.bool,
  unstyled: Me.bool
};
pp.displayName = "Tooltip";
const SE = pp;
function Mf() {
  return Mf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Mf.apply(this, arguments);
}
function kE(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function wE(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, zf(e, t);
}
function zf(e, t) {
  return zf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, i) {
    return a.__proto__ = i, a;
  }, zf(e, t);
}
var Rh = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function TE(e) {
  var t;
  return t = /* @__PURE__ */ function(r) {
    wE(a, r);
    function a(o) {
      var d;
      return d = r.call(this, o) || this, d.state = {
        rect: void 0,
        parentRect: void 0
      }, d.nodeRef = /* @__PURE__ */ n.createRef(), d.getRects = d.getRects.bind(kE(d)), d;
    }
    var i = a.prototype;
    return i.componentDidMount = function() {
      var d, c = this;
      this.node = (d = this.nodeRef) != null && d.current ? this.nodeRef.current : uv.findDOMNode(this), this.setState(function() {
        return c.getRects();
      });
    }, i.getRects = function() {
      if (!this.node)
        return this.state;
      var d = this.node, c = d.parentNode, s = d.getBoundingClientRect ? d.getBoundingClientRect() : Rh, p = c != null && c.getBoundingClientRect ? c.getBoundingClientRect() : Rh;
      return {
        rect: s,
        parentRect: p
      };
    }, i.render = function() {
      return /* @__PURE__ */ n.createElement(e, Mf({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, a;
  }(n.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var $y = /* @__PURE__ */ se.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), CE = $y.Provider;
$y.Consumer;
var AE = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function cc() {
  return cc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, cc.apply(this, arguments);
}
function LE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Hy(e) {
  var t = e.children;
  e.getRects;
  var r = e.left, a = r === void 0 ? 0 : r, i = e.offsetLeft, o = i === void 0 ? 10 : i, d = e.offsetTop, c = d === void 0 ? 10 : d, s = e.parentRect, p = e.rect, y = e.style, g = y === void 0 ? Iy : y, b = e.top, w = b === void 0 ? 0 : b, S = e.unstyled, L = S === void 0 ? !1 : S, m = e.nodeRef, v = LE(e, AE), A, P = !1, T = !1;
  if (p && s) {
    var _ = a, M = w;
    if (s.width) {
      var Z = _ + o + p.width - s.width, Y = p.width - _ - o;
      P = Z > 0 && Z > Y;
    } else {
      var ae = _ + o + p.width - window.innerWidth, j = p.width - _ - o;
      P = ae > 0 && ae > j;
    }
    if (s.height) {
      var q = M + c + p.height - s.height, te = p.height - M - c;
      T = q > 0 && q > te;
    } else
      T = M + c + p.height > window.innerHeight;
    _ = P ? _ - p.width - o : _ + o, M = T ? M - p.height - c : M + c, _ = Math.round(_), M = Math.round(M), A = "translate(" + _ + "px, " + M + "px)";
  }
  return /* @__PURE__ */ n.createElement(SE, cc({
    ref: m,
    style: cc({
      left: 0,
      top: 0,
      transform: A
    }, !L && g)
  }, v), /* @__PURE__ */ n.createElement(CE, {
    value: {
      isFlippedVertically: !T,
      isFlippedHorizontally: !P
    }
  }, t));
}
Hy.propTypes = {
  nodeRef: Me.oneOfType([Me.string, Me.func, Me.object])
};
const Vy = TE(Hy), Wy = (e) => {
  const {
    tableData: t,
    config: r,
    formatNumber: a,
    capitalize: i,
    formatDate: o,
    formatTooltipsDate: d,
    parseDate: c,
    setSharedFilter: s,
    isDraggingAnnotation: p
  } = se.useContext(ft), { xScale: y, yScale: g, showTooltip: b, hideTooltip: w } = e, { xAxis: S, visualizationType: L, orientation: m, yAxis: v, runtime: A } = r, P = (ne, J) => {
    var pe;
    let W = 0, K = Number(g.invert(ne)), ee = null, $ = null;
    for (let ve of (pe = r.runtime) == null ? void 0 : pe.seriesKeys)
      if (J.hasOwnProperty(ve) && (W += Number(J[ve]), W >= K)) {
        $ = J[ve], ee = ve;
        break;
      }
    return [ee, $];
  }, T = (ne, J, W, K) => {
    const ee = W.general.showMissingDataLabel && (!J || J === "null"), $ = ne === W.xAxis.dataKey ? J : a(J, K(ne));
    return ee ? "N/A" : $;
  }, _ = (ne, J) => {
    const { x: W, y: K } = J, $ = {
      data: ne || {},
      dataXPosition: W + 10,
      dataYPosition: K
    };
    return {
      tooltipLeft: $.dataXPosition,
      tooltipTop: $.dataYPosition,
      tooltipData: $
    };
  }, M = (ne, J) => {
    if (L === "Bump Chart" || (ne.stopPropagation(), p))
      return;
    const W = Dp(ne), { x: K, y: ee } = W, { data: $, arc: pe } = J ?? {}, ve = ae(K - Number(r.yAxis.size || 0)), Te = t.filter((Pe) => Pe[S.dataKey] === j(ee)), ye = m === "vertical" ? te(ve) : Te, Re = (Pe) => {
      const de = r.runtime.series.filter((Ne) => Ne.dataKey === Pe)[0];
      return de != null && de.axis ? String(de.axis).toLowerCase() : "left";
    }, Ce = (() => {
      var He, Ze, $e, Ye;
      const Pe = r.columns, de = [], Be = [];
      for (const [qe, Ve] of Object.entries(Pe)) {
        const Ge = {
          addColPrefix: r.columns[qe].prefix,
          addColSuffix: r.columns[qe].suffix,
          addColRoundTo: r.columns[qe].roundToPlace ? r.columns[qe].roundToPlace : "",
          addColCommas: r.columns[qe].commas
        };
        let ke = null;
        r.visualizationType === "Pie" ? ke = pe == null ? void 0 : pe.data[Ve.name] : ke = (He = ye[0]) == null ? void 0 : He[Ve.name];
        const De = Xf(ke, "left", !0, r, Ge);
        Ve.tooltips && de.push([Ve.label, De]);
      }
      const Ne = [];
      if (de.forEach((qe) => {
        Ne.push([qe[0], qe[1]]);
      }), L === "Pie") {
        const qe = Number(r.dataFormat.roundTo) || 0, ke = ((pe.endAngle - pe.startAngle) * 180 / Math.PI / 360 * 100).toFixed(qe);
        Be.push(
          // ignore
          [r.xAxis.dataKey, $],
          [r.runtime.yAxis.dataKey, a(pe == null ? void 0 : pe.data[r.runtime.yAxis.dataKey])],
          ["Percent", `${ke + "%"}`]
        );
      }
      if (L === "Forest Plot" && Be.push([r.xAxis.dataKey, j(ee)]), L !== "Pie" && L !== "Forest Plot" && !r.tooltips.singleSeries && (Be.push(
        ...($e = (Ze = le()) == null ? void 0 : Ze.filter((qe) => {
          var Ge, ke;
          return ((Ge = r.runtime.series) == null ? void 0 : Ge.find(
            (De) => De.dataKey === qe && (De == null ? void 0 : De.tooltip) && !De.dynamicCategory
          )) || ((ke = r.xAxis) == null ? void 0 : ke.dataKey) == qe || L === "Forecasting";
        })) == null ? void 0 : $e.flatMap((qe) => {
          var ke;
          const Ve = (ke = ye[0]) == null ? void 0 : ke[qe], Ge = T(qe, Ve, r, Re);
          return (Ve == null || Ve === "" || Ge === "N/A") && r.general.hideNullValue ? [] : [[qe, Ge, Re(qe)]];
        })
      ), (Ye = r.runtime.series) == null || Ye.forEach((qe) => {
        if (qe != null && qe.dynamicCategory) {
          const Ve = qe.dataKey, Ge = ye.find((at) => at[qe.dynamicCategory] === Ve);
          if (!Ge)
            return;
          const ke = Ge[qe.originalDataKey], De = T(Ve, ke, r, Re);
          Be.push([Ve, De, Re(Ve)]);
        }
      })), L !== "Pie" && L !== "Forest Plot" && r.tooltips.singleSeries) {
        const [qe, Ve] = P(ee, ye[0]);
        if (qe && Ve) {
          Be.push([r.xAxis.dataKey, ve]);
          const Ge = T(qe, Ve, r, Re);
          Be.push([qe, Ge]);
        }
      }
      return [...Be, ...Ne];
    })();
    if (!Ce)
      return;
    const xe = _(Ce, W);
    b(xe);
  }, Z = () => {
    r.visualizationType === "Area Chart" ? setTimeout(() => {
      w();
    }, 3e3) : w();
  }, Y = (ne) => {
    if (r.xAxis.type === "categorical" || r.visualizationType === "Combo") {
      let J = y.step();
      const K = Math.floor(Number(ne) / J);
      return y.domain()[K - 1];
    }
    if (Rn(r.xAxis) && r.visualizationType !== "Combo") {
      const J = ah(($) => c($[r.xAxis.dataKey])).left, W = y.invert(y(ne)), K = J(r.data, W, 1);
      return c(r.data[K - 1][r.xAxis.dataKey]);
    }
  }, ae = (ne, J = !1) => {
    if (L !== "Pie" && m !== "horizontal") {
      if (y.type === "point" || S.type === "continuous" || Rn(S)) {
        let W = null, K = Number.MAX_VALUE, ee = ne;
        return t.forEach(($) => {
          const pe = Rn(S) ? y(c($[S.dataKey])) : y($[S.dataKey]);
          let ve = r.barHeight;
          const Te = Math.abs(Number(pe - ee + (J ? ve * 2 : 0)));
          Te <= K && (K = Te, W = (Rn(S), $[S.dataKey]));
        }), W;
      }
      if (r.xAxis.type === "categorical" || L === "Combo" && m !== "horizontal" && L !== "Forest Plot") {
        let K = (y.range()[1] - y.range()[0]) / (y.domain().length + 1);
        const $ = Math.floor((Number(ne) - K / 2) / K);
        return y.domain()[$];
      }
      if (Rn(S) && L !== "Combo" && m !== "horizontal") {
        const W = ah((pe) => c(pe[r.xAxis.dataKey])).left, K = y.invert(ne), ee = W(r.data, K, 1);
        return c(r.data[ee - 1][r.xAxis.dataKey]);
      }
    }
  }, j = (ne, J) => {
    if (L === "Pie")
      return;
    let W = Number.MAX_VALUE, K = null;
    return t.forEach((ee, $) => {
      const pe = g(L !== "Forest Plot" ? ee[r.xAxis.dataKey] : $), ve = Math.abs(pe - ne);
      ve < W && (W = ve, K = J ? ee[J] : ee[r.xAxis.dataKey]);
    }), K;
  }, q = (ne) => {
    var J, W;
    try {
      if (r.visualizationType === "Bump Chart")
        return;
      const K = Dp(ne), { x: ee } = K;
      if (!ee)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let $ = ae(ee, !0), pe = (J = r.data) == null ? void 0 : J.filter((ve) => ve[r.xAxis.dataKey] === $);
      if (!$)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (Rn(S) && $ && ($ = new Date($), $ = o($), pe = (W = r.data) == null ? void 0 : W.filter((ve) => o(new Date(ve[r.xAxis.dataKey])) === $)), !pe[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${$}`);
      s && (r != null && r.uid) && (pe != null && pe[0]) && s(r.uid, pe[0]);
    } catch (K) {
      console.error(K.message);
    }
  }, te = (ne) => {
    const W = r.runtime.series.filter(
      ($) => L === "Pie" || $.tooltip === !0 && !$.dynamicCategory
    ).map(($) => $.dataKey);
    W.push(r.xAxis.dataKey);
    const K = et.uniq(
      r.runtime.series.flatMap(($) => {
        if ($.dynamicCategory)
          return [$.dynamicCategory, $.originalDataKey];
      })
    );
    W.push(...K), r.visualizationType === "Forecasting" && r.runtime.series.map(($) => {
      $.confidenceIntervals.map((pe) => {
        pe.showInTooltip && (W.push(pe.high), W.push(pe.low));
      });
    });
    const ee = Object.values(r.columns).map(($) => $.name);
    W.push(...ee, ...ee);
    try {
      const $ = t.filter((ve) => ve[S.dataKey] === ne);
      return !$ || $.length === 0 ? [] : $.map((ve) => et.pick(ve, W));
    } catch ($) {
      console.error("COVE", $);
    }
  }, le = () => {
    var ne;
    try {
      let J, W = [], K = [];
      if ((ne = r.runtime.series) == null || ne.forEach((ee) => {
        ee.type === "Forecasting" && (W.push(ee.stageColumn), ee == null || ee.confidenceIntervals.forEach(($) => {
          $.showInTooltip === !0 && (K.push($.low), K.push($.high));
        }));
      }), !r.dashboard)
        switch (L) {
          case "Combo":
            J = [A.xAxis.dataKey, ...A == null ? void 0 : A.seriesKeys, ...K];
            break;
          case "Forecasting":
            J = [A.xAxis.dataKey, ...W, ...K];
            break;
          case "Line":
            J = [A.xAxis.dataKey, ...A == null ? void 0 : A.seriesKeys];
            break;
          case "Area Chart":
            J = [A.xAxis.dataKey, ...A == null ? void 0 : A.seriesKeys];
            break;
          case "Bar":
            J = m === "vertical" ? [A.xAxis.dataKey, ...A == null ? void 0 : A.seriesKeys] : [A.yAxis.dataKey, ...A == null ? void 0 : A.seriesKeys];
            break;
          case "Pie":
            J = [A.xAxis.dataKey, ...A == null ? void 0 : A.seriesKeys];
          default:
            throw new Error("No visualization type found in handleTooltipMouseOver");
        }
      return r.dashboard && (J = [
        A.xAxis.dataKey,
        ...A == null ? void 0 : A.barSeriesKeys,
        ...A == null ? void 0 : A.lineSeriesKeys,
        ...W,
        ...K
      ]), J;
    } catch (J) {
      console.error("COVE", J);
    }
  }, B = (ne) => {
    const { dataXPosition: J, dataYPosition: W } = ne;
    return {
      opacity: r.tooltips.opacity ? r.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${J}px, ${Number(W)}px)`
    };
  }, X = (ne) => {
    var W, K;
    let J = r.runtime.series.filter((ee) => ee.dataKey === ne);
    return (W = J[0]) != null && W.name ? (K = J[0]) == null ? void 0 : K.name : ne;
  };
  return {
    getIncludedTooltipSeries: le,
    getXValueFromCoordinate: ae,
    getXValueFromCoordinateDate: Y,
    getYScaleValues: te,
    handleTooltipClick: q,
    handleTooltipMouseOff: Z,
    handleTooltipMouseOver: M,
    TooltipListItem: ({ item: ne }) => {
      var Xe;
      const [J, W] = ne, [K, ee, $] = W;
      if (L === "Forest Plot")
        return K === r.xAxis.dataKey ? /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(r.xAxis.dataKey ? `${r.xAxis.dataKey}: ` : "")} ${Rn(v) ? o(c(K, !1)) : ee}`) : /* @__PURE__ */ n.createElement("li", { className: "tooltip-body" }, `${X(K)}: ${a(ee, "left")}`);
      const pe = r.tooltips.dateDisplayFormat ? d(c(ee, !1)) : o(c(ee, !1));
      if (L === "Bar" && m === "horizontal" && K === r.xAxis.dataKey)
        return /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(
          r.runtime.yAxis.label ? `${r.runtime.yAxis.label}: ` : ""
        )} ${r.xAxis.type === "date" ? pe : ee}`);
      if (K === r.xAxis.dataKey)
        return /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(
          r.runtime.xAxis.label ? `${r.runtime.xAxis.label}: ` : ""
        )} ${Rn(S) ? pe : ee}`);
      const { label: ve, displayGray: Te } = r.visualizationSubType !== "stacked" && r.general.showSuppressedSymbol && ((Xe = r.preliminaryData) == null ? void 0 : Xe.find(
        (Ce) => Ce.label && Ce.type === "suppression" && Ce.displayTooltip && ee === Ce.value && (!Ce.column || K === Ce.column)
      )) || {};
      let ye = ve || ee;
      const Re = Te ? { color: "#8b8b8a" } : {};
      return J == 1 && r.dataFormat.onlyShowTopPrefixSuffix && (ye = `${r.dataFormat.prefix}${ye}${r.dataFormat.suffix}`), /* @__PURE__ */ n.createElement("li", { style: Re, className: "tooltip-body" }, `${X(K)}: ${ye}`);
    },
    tooltipStyles: B
  };
};
function hp(e, { threshold: t = 0, root: r = null, rootMargin: a = "0%", freezeOnceVisible: i = !1 }) {
  const [o, d] = se.useState(), c = (o == null ? void 0 : o.isIntersecting) && i, s = ([p]) => {
    d(p);
  };
  return se.useEffect(() => {
    const p = e == null ? void 0 : e.current;
    if (!!!window.IntersectionObserver || c || !p)
      return;
    const g = { threshold: t, root: r, rootMargin: a }, b = new IntersectionObserver(s, g);
    return b.observe(p), () => b.disconnect();
  }, [e, t, r, a, c]), o;
}
const Bf = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let r = "";
    return e.visualizationType && (r += `${e.visualizationType} chart`), e.title && e.visualizationType && (r += ` with the title: ${e.title}`), r;
  } catch (r) {
    console.error("COVE: ", r.message);
  }
}, Nh = Symbol("implicit");
function mp() {
  var e = new Yp(), t = [], r = [], a = Nh;
  function i(o) {
    let d = e.get(o);
    if (d === void 0) {
      if (a !== Nh)
        return a;
      e.set(o, d = t.push(o) - 1);
    }
    return r[d % r.length];
  }
  return i.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new Yp();
    for (const d of o)
      e.has(d) || e.set(d, t.push(d) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (r = Array.from(o), i) : r.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (a = o, i) : a;
  }, i.copy = function() {
    return mp(t, r).unknown(a);
  }, Nc.apply(i, arguments), i;
}
function yp() {
  var e = mp().unknown(void 0), t = e.domain, r = e.range, a = 0, i = 1, o, d, c = !1, s = 0, p = 0, y = 0.5;
  delete e.unknown;
  function g() {
    var b = t().length, w = i < a, S = w ? i : a, L = w ? a : i;
    o = (L - S) / Math.max(1, b - s + p * 2), c && (o = Math.floor(o)), S += (L - S - o * (b - s)) * y, d = o * (1 - s), c && (S = Math.round(S), d = Math.round(d));
    var m = yv(b).map(function(v) {
      return S + o * v;
    });
    return r(w ? m.reverse() : m);
  }
  return e.domain = function(b) {
    return arguments.length ? (t(b), g()) : t();
  }, e.range = function(b) {
    return arguments.length ? ([a, i] = b, a = +a, i = +i, g()) : [a, i];
  }, e.rangeRound = function(b) {
    return [a, i] = b, a = +a, i = +i, c = !0, g();
  }, e.bandwidth = function() {
    return d;
  }, e.step = function() {
    return o;
  }, e.round = function(b) {
    return arguments.length ? (c = !!b, g()) : c;
  }, e.padding = function(b) {
    return arguments.length ? (s = Math.min(1, p = +b), g()) : s;
  }, e.paddingInner = function(b) {
    return arguments.length ? (s = Math.min(1, b), g()) : s;
  }, e.paddingOuter = function(b) {
    return arguments.length ? (p = +b, g()) : p;
  }, e.align = function(b) {
    return arguments.length ? (y = Math.max(0, Math.min(1, b)), g()) : y;
  }, e.copy = function() {
    return yp(t(), [a, i]).round(c).paddingInner(s).paddingOuter(p).align(y);
  }, Nc.apply(g(), arguments);
}
function jy(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return jy(t());
  }, e;
}
function PE() {
  return jy(yp.apply(null, arguments).paddingInner(1));
}
function Uy(e, t) {
  e = e.slice();
  var r = 0, a = e.length - 1, i = e[r], o = e[a], d;
  return o < i && (d = r, r = a, a = d, d = i, i = o, o = d), e[r] = t.floor(i), e[a] = t.ceil(o), e;
}
function Dh(e) {
  return Math.log(e);
}
function _h(e) {
  return Math.exp(e);
}
function RE(e) {
  return -Math.log(-e);
}
function NE(e) {
  return -Math.exp(-e);
}
function DE(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function _E(e) {
  return e === 10 ? DE : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function OE(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function Oh(e) {
  return (t, r) => -e(-t, r);
}
function FE(e) {
  const t = e(Dh, _h), r = t.domain;
  let a = 10, i, o;
  function d() {
    return i = OE(a), o = _E(a), r()[0] < 0 ? (i = Oh(i), o = Oh(o), e(RE, NE)) : e(Dh, _h), t;
  }
  return t.base = function(c) {
    return arguments.length ? (a = +c, d()) : a;
  }, t.domain = function(c) {
    return arguments.length ? (r(c), d()) : r();
  }, t.ticks = (c) => {
    const s = r();
    let p = s[0], y = s[s.length - 1];
    const g = y < p;
    g && ([p, y] = [y, p]);
    let b = i(p), w = i(y), S, L;
    const m = c == null ? 10 : +c;
    let v = [];
    if (!(a % 1) && w - b < m) {
      if (b = Math.floor(b), w = Math.ceil(w), p > 0) {
        for (; b <= w; ++b)
          for (S = 1; S < a; ++S)
            if (L = b < 0 ? S / o(-b) : S * o(b), !(L < p)) {
              if (L > y)
                break;
              v.push(L);
            }
      } else
        for (; b <= w; ++b)
          for (S = a - 1; S >= 1; --S)
            if (L = b > 0 ? S / o(-b) : S * o(b), !(L < p)) {
              if (L > y)
                break;
              v.push(L);
            }
      v.length * 2 < m && (v = $p(p, y, m));
    } else
      v = $p(b, w, Math.min(w - b, m)).map(o);
    return g ? v.reverse() : v;
  }, t.tickFormat = (c, s) => {
    if (c == null && (c = 10), s == null && (s = a === 10 ? "s" : ","), typeof s != "function" && (!(a % 1) && (s = iv(s)).precision == null && (s.trim = !0), s = ov(s)), c === 1 / 0)
      return s;
    const p = Math.max(1, a * c / t.ticks().length);
    return (y) => {
      let g = y / o(Math.round(i(y)));
      return g * a < a - 0.5 && (g *= a), g <= p ? s(y) : "";
    };
  }, t.nice = () => r(Uy(r(), {
    floor: (c) => o(Math.floor(i(c))),
    ceil: (c) => o(Math.ceil(i(c)))
  })), t;
}
function Ky() {
  const e = FE(av()).domain([1, 10]);
  return e.copy = () => Nm(e, Ky()).base(e.base()), Nc.apply(e, arguments), e;
}
function ME(e) {
  return new Date(e);
}
function zE(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Yy(e, t, r, a, i, o, d, c, s, p) {
  var y = lv(), g = y.invert, b = y.domain, w = p(".%L"), S = p(":%S"), L = p("%I:%M"), m = p("%I %p"), v = p("%a %d"), A = p("%b %d"), P = p("%B"), T = p("%Y");
  function _(M) {
    return (s(M) < M ? w : c(M) < M ? S : d(M) < M ? L : o(M) < M ? m : a(M) < M ? i(M) < M ? v : A : r(M) < M ? P : T)(M);
  }
  return y.invert = function(M) {
    return new Date(g(M));
  }, y.domain = function(M) {
    return arguments.length ? b(Array.from(M, zE)) : b().map(ME);
  }, y.ticks = function(M) {
    var Z = b();
    return e(Z[0], Z[Z.length - 1], M ?? 10);
  }, y.tickFormat = function(M, Z) {
    return Z == null ? _ : p(Z);
  }, y.nice = function(M) {
    var Z = b();
    return (!M || typeof M.range != "function") && (M = t(Z[0], Z[Z.length - 1], M ?? 10)), M ? b(Uy(Z, M)) : y;
  }, y.copy = function() {
    return Nm(y, Yy(e, t, r, a, i, o, d, c, s, p));
  }, y;
}
function Gy() {
  return Nc.apply(Yy(vv, xv, _m, Rm, Fm, Om, Pm, Lm, fs, Xg).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var BE = Ls("domain", "range", "reverse", "align", "padding", "round");
function dc(e) {
  return BE(yp(), e);
}
var IE = Ls("domain", "range", "reverse", "align", "padding", "round");
function tl(e) {
  return IE(PE(), e);
}
var $E = Ls("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function HE(e) {
  return $E(Gy(), e);
}
var VE = Ls("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function fc(e) {
  return VE(Ky(), e);
}
var WE = Ls("domain", "range", "reverse", "unknown");
function gp(e) {
  return WE(mp(), e);
}
function jE(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function Xy(e, t) {
  var r = e;
  return "ticks" in r ? r.ticks(t) : r.domain().filter(function(a, i, o) {
    return t == null || o.length <= t || i % Math.round((o.length - 1) / t) === 0;
  });
}
function UE(e) {
  return e == null ? void 0 : e.toString();
}
const Du = ({ startAngle: e, endAngle: t }) => ({
  startAngle: e,
  endAngle: t
}), KE = (e) => {
  const {
    transformedData: t,
    config: r,
    colorScale: a,
    currentViewport: i,
    seriesHighlight: o,
    isDraggingAnnotation: d
  } = se.useContext(ft), { tooltipData: c, showTooltip: s, hideTooltip: p, tooltipOpen: y, tooltipLeft: g, tooltipTop: b } = By(), { handleTooltipMouseOver: w, handleTooltipMouseOff: S, TooltipListItem: L } = Wy({
    xScale: !1,
    yScale: !1,
    showTooltip: s,
    hideTooltip: p
  }), [m, v] = se.useState(void 0), [A, P] = se.useState(!1), T = Object.values(r.columns).filter((K) => K.showInViz), _ = T.length > 0, M = _ ? "pivotColumn" : void 0, Z = se.useMemo(() => {
    if (_) {
      let K = [];
      const ee = r.yAxis.dataKey, $ = T.map((Te) => Te.name), pe = [ee, ...$], ve = r.xAxis.dataKey;
      return t.forEach((Te) => {
        pe.forEach((ye) => {
          const Re = Te[ye];
          Re && K.push({
            [M]: Re,
            [ve]: `${Te[ve]} - ${ye}`
          });
        });
      }), K;
    }
    return t;
  }, [t, _]), Y = se.useMemo(() => {
    if (_) {
      const K = {};
      Z.forEach((pe) => {
        K[pe[r.xAxis.dataKey]] || (K[pe[r.xAxis.dataKey]] = !0);
      });
      const ee = Object.entries(K).length;
      let $ = r.customColors || Sr[r.palette];
      return $ = $.slice(0, ee), gp({
        domain: Object.keys(K),
        range: $,
        unknown: null
      });
    }
    return a;
  }, [a, _]), ae = se.useRef(), j = hp(ae, {
    freezeOnceVisible: !1
  });
  se.useEffect(() => {
    document.querySelector(".isEditor") && P((ee) => !0);
  }), se.useEffect(() => {
    j != null && j.isIntersecting && r.animate && !A && setTimeout(() => {
      P(!0);
    }, 500);
  }, [j == null ? void 0 : j.isIntersecting, r.animate]);
  const q = ({ arcs: K, path: ee, getKey: $ }) => {
    const pe = Nb(K, $, {
      from: Du,
      enter: Du,
      update: Du,
      leave: Du
    });
    return se.useEffect(() => {
      const ve = setTimeout(() => {
        p();
      }, 500);
      return () => {
        clearTimeout(ve);
      };
    }, [c]), /* @__PURE__ */ n.createElement(n.Fragment, null, pe.map(({ item: ve, props: Te, key: ye }, Re) => /* @__PURE__ */ n.createElement(
      tt,
      {
        className: ve.data[r.xAxis.dataKey],
        key: `${ye}-${Re}`,
        style: {
          opacity: r.legend.behavior === "highlight" && o.length > 0 && o.indexOf(ve.data[r.runtime.xAxis.dataKey]) === -1 ? 0.5 : 1
        }
      },
      /* @__PURE__ */ n.createElement(
        Eh.path,
        {
          d: Tb(
            [Te.startAngle, Te.endAngle],
            (Xe, Ce) => ee({
              ...ve,
              startAngle: Xe,
              endAngle: Ce
            })
          ),
          fill: Y(ve.data[r.runtime.xAxis.dataKey]),
          onMouseEnter: (Xe) => w(Xe, { data: ve.data[r.runtime.xAxis.dataKey], arc: ve }),
          onMouseLeave: (Xe) => S()
        }
      )
    )), pe.map(({ item: ve, key: Te }, ye) => {
      const Re = Number(r.dataFormat.roundTo) || 0, [Xe, Ce] = ee.centroid(ve), xe = ve.endAngle - ve.startAngle >= 0.1;
      let Pe = "#FFF";
      Y(ve.data[r.runtime.xAxis.dataKey]) && (Pe = al(Pe, Y(ve.data[r.runtime.xAxis.dataKey])));
      const Ne = ((ve.endAngle - ve.startAngle) * 180 / Math.PI / 360 * 100).toFixed(Re);
      return /* @__PURE__ */ n.createElement(Eh.g, { key: `${Te}${ye}` }, xe && /* @__PURE__ */ n.createElement(
        ct,
        {
          style: { fill: Pe },
          x: Xe,
          y: Ce,
          dy: ".33em",
          textAnchor: "middle",
          pointerEvents: "none"
        },
        Ne + "%"
      ));
    }));
  };
  let te = e.parentWidth, le = e.parentWidth;
  r && r.legend && !r.legend.hide && i === "lg" && (le = Number(te) * 0.73);
  const B = r.heights.vertical, X = Math.min(le, B) / 2, ue = B / 2, ne = e.parentWidth / 2, J = r.pieType === "Donut" ? 75 : X;
  se.useEffect(() => {
    if (o.length > 0 && r.legend.behavior !== "highlight") {
      let K = [];
      Z.forEach((ee) => {
        o.indexOf(ee[r.runtime.xAxis.dataKey]) !== -1 && K.push(ee);
      }), v(K);
    } else
      v(void 0);
  }, [o]);
  const W = () => {
    let K = ["animated-pie", "group"];
    return (r.animate === !1 || A) && K.push("animated"), K.join(" ");
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Vr, { component: "PieChart" }, /* @__PURE__ */ n.createElement(
    "svg",
    {
      width: X * 2,
      height: B,
      className: W(),
      role: "img",
      "aria-label": Bf(r)
    },
    /* @__PURE__ */ n.createElement(tt, { top: ue, left: X }, /* @__PURE__ */ n.createElement(
      j0,
      {
        data: m || Z,
        pieValue: (K) => K[M || r.runtime.yAxis.dataKey],
        pieSortValues: () => -1,
        innerRadius: X - J,
        outerRadius: X
      },
      (K) => /* @__PURE__ */ n.createElement(q, { ...K, getKey: (ee) => ee.data[r.runtime.xAxis.dataKey] })
    ))
  ), /* @__PURE__ */ n.createElement("div", { ref: ae }), !d && c && Object.entries(c.data).length > 0 && y && s && c.dataYPosition && c.dataXPosition && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${r.tooltips.opacity / 100}) !important`), /* @__PURE__ */ n.createElement(
    Vy,
    {
      key: Math.random(),
      className: "tooltip cdc-open-viz-module",
      left: g + ne - X,
      top: b
    },
    /* @__PURE__ */ n.createElement("ul", null, typeof c == "object" && Object.entries(c.data).map((K, ee) => /* @__PURE__ */ n.createElement(L, { item: K, key: ee })))
  ))));
};
function Ps(e) {
  return e.split("-")[1];
}
function vp(e) {
  return e === "y" ? "height" : "width";
}
function $i(e) {
  return e.split("-")[0];
}
function Rs(e) {
  return ["top", "bottom"].includes($i(e)) ? "x" : "y";
}
function Fh(e, t, r) {
  let { reference: a, floating: i } = e;
  const o = a.x + a.width / 2 - i.width / 2, d = a.y + a.height / 2 - i.height / 2, c = Rs(t), s = vp(c), p = a[s] / 2 - i[s] / 2, y = c === "x";
  let g;
  switch ($i(t)) {
    case "top":
      g = { x: o, y: a.y - i.height };
      break;
    case "bottom":
      g = { x: o, y: a.y + a.height };
      break;
    case "right":
      g = { x: a.x + a.width, y: d };
      break;
    case "left":
      g = { x: a.x - i.width, y: d };
      break;
    default:
      g = { x: a.x, y: a.y };
  }
  switch (Ps(t)) {
    case "start":
      g[c] -= p * (r && y ? -1 : 1);
      break;
    case "end":
      g[c] += p * (r && y ? -1 : 1);
  }
  return g;
}
function qy(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function ys(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Zy(e, t) {
  var r;
  t === void 0 && (t = {});
  const { x: a, y: i, platform: o, rects: d, elements: c, strategy: s } = e, { boundary: p = "clippingAncestors", rootBoundary: y = "viewport", elementContext: g = "floating", altBoundary: b = !1, padding: w = 0 } = t, S = qy(w), L = c[b ? g === "floating" ? "reference" : "floating" : g], m = ys(await o.getClippingRect({ element: (r = await (o.isElement == null ? void 0 : o.isElement(L))) == null || r ? L : L.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(c.floating)), boundary: p, rootBoundary: y, strategy: s })), v = g === "floating" ? { ...d.floating, x: a, y: i } : d.reference, A = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c.floating)), P = await (o.isElement == null ? void 0 : o.isElement(A)) && await (o.getScale == null ? void 0 : o.getScale(A)) || { x: 1, y: 1 }, T = ys(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: v, offsetParent: A, strategy: s }) : v);
  return { top: (m.top - T.top + S.top) / P.y, bottom: (T.bottom - m.bottom + S.bottom) / P.y, left: (m.left - T.left + S.left) / P.x, right: (T.right - m.right + S.right) / P.x };
}
const YE = Math.min, GE = Math.max;
function If(e, t, r) {
  return GE(e, YE(t, r));
}
["top", "right", "bottom", "left"].reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const XE = { left: "right", right: "left", bottom: "top", top: "bottom" };
function pc(e) {
  return e.replace(/left|right|bottom|top/g, (t) => XE[t]);
}
function qE(e, t, r) {
  r === void 0 && (r = !1);
  const a = Ps(e), i = Rs(e), o = vp(i);
  let d = i === "x" ? a === (r ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (d = pc(d)), { main: d, cross: pc(d) };
}
const ZE = { start: "end", end: "start" };
function Zd(e) {
  return e.replace(/start|end/g, (t) => ZE[t]);
}
const QE = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var r;
    const { placement: a, middlewareData: i, rects: o, initialPlacement: d, platform: c, elements: s } = t, { mainAxis: p = !0, crossAxis: y = !0, fallbackPlacements: g, fallbackStrategy: b = "bestFit", fallbackAxisSideDirection: w = "none", flipAlignment: S = !0, ...L } = e, m = $i(a), v = $i(d) === d, A = await (c.isRTL == null ? void 0 : c.isRTL(s.floating)), P = g || (v || !S ? [pc(d)] : function(q) {
      const te = pc(q);
      return [Zd(q), te, Zd(te)];
    }(d));
    g || w === "none" || P.push(...function(q, te, le, B) {
      const X = Ps(q);
      let ue = function(ne, J, W) {
        const K = ["left", "right"], ee = ["right", "left"], $ = ["top", "bottom"], pe = ["bottom", "top"];
        switch (ne) {
          case "top":
          case "bottom":
            return W ? J ? ee : K : J ? K : ee;
          case "left":
          case "right":
            return J ? $ : pe;
          default:
            return [];
        }
      }($i(q), le === "start", B);
      return X && (ue = ue.map((ne) => ne + "-" + X), te && (ue = ue.concat(ue.map(Zd)))), ue;
    }(d, S, w, A));
    const T = [d, ...P], _ = await Zy(t, L), M = [];
    let Z = ((r = i.flip) == null ? void 0 : r.overflows) || [];
    if (p && M.push(_[m]), y) {
      const { main: q, cross: te } = qE(a, o, A);
      M.push(_[q], _[te]);
    }
    if (Z = [...Z, { placement: a, overflows: M }], !M.every((q) => q <= 0)) {
      var Y, ae;
      const q = (((Y = i.flip) == null ? void 0 : Y.index) || 0) + 1, te = T[q];
      if (te)
        return { data: { index: q, overflows: Z }, reset: { placement: te } };
      let le = (ae = Z.find((B) => B.overflows[0] <= 0)) == null ? void 0 : ae.placement;
      if (!le)
        switch (b) {
          case "bestFit": {
            var j;
            const B = (j = Z.map((X) => [X.placement, X.overflows.filter((ue) => ue > 0).reduce((ue, ne) => ue + ne, 0)]).sort((X, ue) => X[1] - ue[1])[0]) == null ? void 0 : j[0];
            B && (le = B);
            break;
          }
          case "initialPlacement":
            le = d;
        }
      if (a !== le)
        return { reset: { placement: le } };
    }
    return {};
  } };
}, JE = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: r, y: a } = t, i = await async function(o, d) {
      const { placement: c, platform: s, elements: p } = o, y = await (s.isRTL == null ? void 0 : s.isRTL(p.floating)), g = $i(c), b = Ps(c), w = Rs(c) === "x", S = ["left", "top"].includes(g) ? -1 : 1, L = y && w ? -1 : 1, m = typeof d == "function" ? d(o) : d;
      let { mainAxis: v, crossAxis: A, alignmentAxis: P } = typeof m == "number" ? { mainAxis: m, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...m };
      return b && typeof P == "number" && (A = b === "end" ? -1 * P : P), w ? { x: A * L, y: v * S } : { x: v * S, y: A * L };
    }(t, e);
    return { x: r + i.x, y: a + i.y, data: i };
  } };
}, eS = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: r, y: a, placement: i } = t, { mainAxis: o = !0, crossAxis: d = !1, limiter: c = { fn: (m) => {
      let { x: v, y: A } = m;
      return { x: v, y: A };
    } }, ...s } = e, p = { x: r, y: a }, y = await Zy(t, s), g = Rs($i(i)), b = g === "x" ? "y" : "x";
    let w = p[g], S = p[b];
    if (o) {
      const m = g === "y" ? "bottom" : "right";
      w = If(w + y[g === "y" ? "top" : "left"], w, w - y[m]);
    }
    if (d) {
      const m = b === "y" ? "bottom" : "right";
      S = If(S + y[b === "y" ? "top" : "left"], S, S - y[m]);
    }
    const L = c.fn({ ...t, [g]: w, [b]: S });
    return { ...L, data: { x: L.x - r, y: L.y - a } };
  } };
};
function Pr(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function ta(e) {
  return Pr(e).getComputedStyle(e);
}
const Mh = Math.min, gs = Math.max, hc = Math.round;
function Qy(e) {
  const t = ta(e);
  let r = parseFloat(t.width), a = parseFloat(t.height);
  const i = e.offsetWidth, o = e.offsetHeight, d = hc(r) !== i || hc(a) !== o;
  return d && (r = i, a = o), { width: r, height: a, fallback: d };
}
function Ga(e) {
  return eg(e) ? (e.nodeName || "").toLowerCase() : "";
}
let _u;
function Jy() {
  if (_u)
    return _u;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (_u = e.brands.map((t) => t.brand + "/" + t.version).join(" "), _u) : navigator.userAgent;
}
function na(e) {
  return e instanceof Pr(e).HTMLElement;
}
function Wa(e) {
  return e instanceof Pr(e).Element;
}
function eg(e) {
  return e instanceof Pr(e).Node;
}
function zh(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Pr(e).ShadowRoot || e instanceof ShadowRoot;
}
function Mc(e) {
  const { overflow: t, overflowX: r, overflowY: a, display: i } = ta(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + r) && !["inline", "contents"].includes(i);
}
function tS(e) {
  return ["table", "td", "th"].includes(Ga(e));
}
function $f(e) {
  const t = /firefox/i.test(Jy()), r = ta(e), a = r.backdropFilter || r.WebkitBackdropFilter;
  return r.transform !== "none" || r.perspective !== "none" || !!a && a !== "none" || t && r.willChange === "filter" || t && !!r.filter && r.filter !== "none" || ["transform", "perspective"].some((i) => r.willChange.includes(i)) || ["paint", "layout", "strict", "content"].some((i) => {
    const o = r.contain;
    return o != null && o.includes(i);
  });
}
function tg() {
  return !/^((?!chrome|android).)*safari/i.test(Jy());
}
function xp(e) {
  return ["html", "body", "#document"].includes(Ga(e));
}
function ng(e) {
  return Wa(e) ? e : e.contextElement;
}
const rg = { x: 1, y: 1 };
function rl(e) {
  const t = ng(e);
  if (!na(t))
    return rg;
  const r = t.getBoundingClientRect(), { width: a, height: i, fallback: o } = Qy(t);
  let d = (o ? hc(r.width) : r.width) / a, c = (o ? hc(r.height) : r.height) / i;
  return d && Number.isFinite(d) || (d = 1), c && Number.isFinite(c) || (c = 1), { x: d, y: c };
}
function Cs(e, t, r, a) {
  var i, o;
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  const d = e.getBoundingClientRect(), c = ng(e);
  let s = rg;
  t && (a ? Wa(a) && (s = rl(a)) : s = rl(e));
  const p = c ? Pr(c) : window, y = !tg() && r;
  let g = (d.left + (y && ((i = p.visualViewport) == null ? void 0 : i.offsetLeft) || 0)) / s.x, b = (d.top + (y && ((o = p.visualViewport) == null ? void 0 : o.offsetTop) || 0)) / s.y, w = d.width / s.x, S = d.height / s.y;
  if (c) {
    const L = Pr(c), m = a && Wa(a) ? Pr(a) : a;
    let v = L.frameElement;
    for (; v && a && m !== L; ) {
      const A = rl(v), P = v.getBoundingClientRect(), T = getComputedStyle(v);
      P.x += (v.clientLeft + parseFloat(T.paddingLeft)) * A.x, P.y += (v.clientTop + parseFloat(T.paddingTop)) * A.y, g *= A.x, b *= A.y, w *= A.x, S *= A.y, g += P.x, b += P.y, v = Pr(v).frameElement;
    }
  }
  return { width: w, height: S, top: b, right: g + w, bottom: b + S, left: g, x: g, y: b };
}
function ja(e) {
  return ((eg(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function zc(e) {
  return Wa(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function ag(e) {
  return Cs(ja(e)).left + zc(e).scrollLeft;
}
function As(e) {
  if (Ga(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || zh(e) && e.host || ja(e);
  return zh(t) ? t.host : t;
}
function ig(e) {
  const t = As(e);
  return xp(t) ? t.ownerDocument.body : na(t) && Mc(t) ? t : ig(t);
}
function og(e, t) {
  var r;
  t === void 0 && (t = []);
  const a = ig(e), i = a === ((r = e.ownerDocument) == null ? void 0 : r.body), o = Pr(a);
  return i ? t.concat(o, o.visualViewport || [], Mc(a) ? a : []) : t.concat(a, og(a));
}
function Bh(e, t, r) {
  return t === "viewport" ? ys(function(a, i) {
    const o = Pr(a), d = ja(a), c = o.visualViewport;
    let s = d.clientWidth, p = d.clientHeight, y = 0, g = 0;
    if (c) {
      s = c.width, p = c.height;
      const b = tg();
      (b || !b && i === "fixed") && (y = c.offsetLeft, g = c.offsetTop);
    }
    return { width: s, height: p, x: y, y: g };
  }(e, r)) : Wa(t) ? ys(function(a, i) {
    const o = Cs(a, !0, i === "fixed"), d = o.top + a.clientTop, c = o.left + a.clientLeft, s = na(a) ? rl(a) : { x: 1, y: 1 };
    return { width: a.clientWidth * s.x, height: a.clientHeight * s.y, x: c * s.x, y: d * s.y };
  }(t, r)) : ys(function(a) {
    const i = ja(a), o = zc(a), d = a.ownerDocument.body, c = gs(i.scrollWidth, i.clientWidth, d.scrollWidth, d.clientWidth), s = gs(i.scrollHeight, i.clientHeight, d.scrollHeight, d.clientHeight);
    let p = -o.scrollLeft + ag(a);
    const y = -o.scrollTop;
    return ta(d).direction === "rtl" && (p += gs(i.clientWidth, d.clientWidth) - c), { width: c, height: s, x: p, y };
  }(ja(e)));
}
function Ih(e) {
  return na(e) && ta(e).position !== "fixed" ? e.offsetParent : null;
}
function $h(e) {
  const t = Pr(e);
  let r = Ih(e);
  for (; r && tS(r) && ta(r).position === "static"; )
    r = Ih(r);
  return r && (Ga(r) === "html" || Ga(r) === "body" && ta(r).position === "static" && !$f(r)) ? t : r || function(a) {
    let i = As(a);
    for (; na(i) && !xp(i); ) {
      if ($f(i))
        return i;
      i = As(i);
    }
    return null;
  }(e) || t;
}
function nS(e, t, r) {
  const a = na(t), i = ja(t), o = Cs(e, !0, r === "fixed", t);
  let d = { scrollLeft: 0, scrollTop: 0 };
  const c = { x: 0, y: 0 };
  if (a || !a && r !== "fixed")
    if ((Ga(t) !== "body" || Mc(i)) && (d = zc(t)), na(t)) {
      const s = Cs(t, !0);
      c.x = s.x + t.clientLeft, c.y = s.y + t.clientTop;
    } else
      i && (c.x = ag(i));
  return { x: o.left + d.scrollLeft - c.x, y: o.top + d.scrollTop - c.y, width: o.width, height: o.height };
}
const rS = { getClippingRect: function(e) {
  let { element: t, boundary: r, rootBoundary: a, strategy: i } = e;
  const o = r === "clippingAncestors" ? function(p, y) {
    const g = y.get(p);
    if (g)
      return g;
    let b = og(p).filter((m) => Wa(m) && Ga(m) !== "body"), w = null;
    const S = ta(p).position === "fixed";
    let L = S ? As(p) : p;
    for (; Wa(L) && !xp(L); ) {
      const m = ta(L), v = $f(L);
      (S ? v || w : v || m.position !== "static" || !w || !["absolute", "fixed"].includes(w.position)) ? w = m : b = b.filter((A) => A !== L), L = As(L);
    }
    return y.set(p, b), b;
  }(t, this._c) : [].concat(r), d = [...o, a], c = d[0], s = d.reduce((p, y) => {
    const g = Bh(t, y, i);
    return p.top = gs(g.top, p.top), p.right = Mh(g.right, p.right), p.bottom = Mh(g.bottom, p.bottom), p.left = gs(g.left, p.left), p;
  }, Bh(t, c, i));
  return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: r, strategy: a } = e;
  const i = na(r), o = ja(r);
  if (r === o)
    return t;
  let d = { scrollLeft: 0, scrollTop: 0 }, c = { x: 1, y: 1 };
  const s = { x: 0, y: 0 };
  if ((i || !i && a !== "fixed") && ((Ga(r) !== "body" || Mc(o)) && (d = zc(r)), na(r))) {
    const p = Cs(r);
    c = rl(r), s.x = p.x + r.clientLeft, s.y = p.y + r.clientTop;
  }
  return { width: t.width * c.x, height: t.height * c.y, x: t.x * c.x - d.scrollLeft * c.x + s.x, y: t.y * c.y - d.scrollTop * c.y + s.y };
}, isElement: Wa, getDimensions: function(e) {
  return na(e) ? Qy(e) : e.getBoundingClientRect();
}, getOffsetParent: $h, getDocumentElement: ja, getScale: rl, async getElementRects(e) {
  let { reference: t, floating: r, strategy: a } = e;
  const i = this.getOffsetParent || $h, o = this.getDimensions;
  return { reference: nS(t, await i(r), a), floating: { x: 0, y: 0, ...await o(r) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => ta(e).direction === "rtl" }, Hh = (e, t, r) => {
  const a = /* @__PURE__ */ new Map(), i = { platform: rS, ...r }, o = { ...i.platform, _c: a };
  return (async (d, c, s) => {
    const { placement: p = "bottom", strategy: y = "absolute", middleware: g = [], platform: b } = s, w = g.filter(Boolean), S = await (b.isRTL == null ? void 0 : b.isRTL(c));
    if (b == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), w.filter((_) => {
      let { name: M } = _;
      return M === "autoPlacement" || M === "flip";
    }).length > 1)
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    d && c || console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    let L = await b.getElementRects({ reference: d, floating: c, strategy: y }), { x: m, y: v } = Fh(L, p, S), A = p, P = {}, T = 0;
    for (let _ = 0; _ < w.length; _++) {
      const { name: M, fn: Z } = w[_], { x: Y, y: ae, data: j, reset: q } = await Z({ x: m, y: v, initialPlacement: p, placement: A, strategy: y, middlewareData: P, rects: L, platform: b, elements: { reference: d, floating: c } });
      m = Y ?? m, v = ae ?? v, P = { ...P, [M]: { ...P[M], ...j } }, T > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), q && T <= 50 && (T++, typeof q == "object" && (q.placement && (A = q.placement), q.rects && (L = q.rects === !0 ? await b.getElementRects({ reference: d, floating: c, strategy: y }) : q.rects), { x: m, y: v } = Fh(L, A, S)), _ = -1);
    }
    return { x: m, y: v, placement: A, strategy: y, middlewareData: P };
  })(e, t, { ...i, platform: o });
};
var $a, Hi = { exports: {} }, Vh = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
$a = Vh, function() {
  var e = n, t = 60103, r = 60106;
  $a.Fragment = 60107;
  var a = 60108, i = 60114, o = 60109, d = 60110, c = 60112, s = 60113, p = 60120, y = 60115, g = 60116, b = 60121, w = 60122, S = 60117, L = 60129, m = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var v = Symbol.for;
    t = v("react.element"), r = v("react.portal"), $a.Fragment = v("react.fragment"), a = v("react.strict_mode"), i = v("react.profiler"), o = v("react.provider"), d = v("react.context"), c = v("react.forward_ref"), s = v("react.suspense"), p = v("react.suspense_list"), y = v("react.memo"), g = v("react.lazy"), b = v("react.block"), w = v("react.server.block"), S = v("react.fundamental"), v("react.scope"), v("react.opaque.id"), L = v("react.debug_trace_mode"), v("react.offscreen"), m = v("react.legacy_hidden");
  }
  var A = typeof Symbol == "function" && Symbol.iterator, P = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function T(xe) {
    for (var Pe = arguments.length, de = new Array(Pe > 1 ? Pe - 1 : 0), Be = 1; Be < Pe; Be++)
      de[Be - 1] = arguments[Be];
    _("error", xe, de);
  }
  function _(xe, Pe, de) {
    var Be = P.ReactDebugCurrentFrame, Ne = "";
    if (ae) {
      var He = Z(ae.type), Ze = ae._owner;
      Ne += function(Ye, qe, Ve) {
        var Ge = "";
        if (qe) {
          var ke = qe.fileName, De = ke.replace(M, "");
          if (/^index\./.test(De)) {
            var at = ke.match(M);
            if (at) {
              var be = at[1];
              be && (De = be.replace(M, "") + "/" + De);
            }
          }
          Ge = " (at " + De + ":" + qe.lineNumber + ")";
        } else
          Ve && (Ge = " (created by " + Ve + ")");
        return `
    in ` + (Ye || "Unknown") + Ge;
      }(He, ae._source, Ze && Z(Ze.type));
    }
    (Ne += Be.getStackAddendum()) !== "" && (Pe += "%s", de = de.concat([Ne]));
    var $e = de.map(function(Ye) {
      return "" + Ye;
    });
    $e.unshift("Warning: " + Pe), Function.prototype.apply.call(console[xe], console, $e);
  }
  var M = /^(.*)[\\\/]/;
  function Z(xe) {
    if (xe == null)
      return null;
    if (typeof xe.tag == "number" && T("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof xe == "function")
      return xe.displayName || xe.name || null;
    if (typeof xe == "string")
      return xe;
    switch (xe) {
      case $a.Fragment:
        return "Fragment";
      case r:
        return "Portal";
      case i:
        return "Profiler";
      case a:
        return "StrictMode";
      case s:
        return "Suspense";
      case p:
        return "SuspenseList";
    }
    if (typeof xe == "object")
      switch (xe.$$typeof) {
        case d:
          return "Context.Consumer";
        case o:
          return "Context.Provider";
        case c:
          return Be = xe, Ne = xe.render, He = "ForwardRef", Ze = Ne.displayName || Ne.name || "", Be.displayName || (Ze !== "" ? He + "(" + Ze + ")" : He);
        case y:
          return Z(xe.type);
        case b:
          return Z(xe.render);
        case g:
          var Pe = (de = xe)._status === 1 ? de._result : null;
          if (Pe)
            return Z(Pe);
      }
    var de, Be, Ne, He, Ze;
    return null;
  }
  var Y = {};
  P.ReactDebugCurrentFrame;
  var ae = null;
  function j(xe) {
    ae = xe;
  }
  var q, te, le, B = P.ReactCurrentOwner, X = Object.prototype.hasOwnProperty, ue = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ne(xe, Pe, de, Be, Ne) {
    var He, Ze = {}, $e = null, Ye = null;
    for (He in de !== void 0 && ($e = "" + de), function(Ge) {
      if (X.call(Ge, "key")) {
        var ke = Object.getOwnPropertyDescriptor(Ge, "key").get;
        if (ke && ke.isReactWarning)
          return !1;
      }
      return Ge.key !== void 0;
    }(Pe) && ($e = "" + Pe.key), function(Ge) {
      if (X.call(Ge, "ref")) {
        var ke = Object.getOwnPropertyDescriptor(Ge, "ref").get;
        if (ke && ke.isReactWarning)
          return !1;
      }
      return Ge.ref !== void 0;
    }(Pe) && (Ye = Pe.ref, function(Ge, ke) {
      if (typeof Ge.ref == "string" && B.current && ke && B.current.stateNode !== ke) {
        var De = Z(B.current.type);
        le[De] || (T('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Z(B.current.type), Ge.ref), le[De] = !0);
      }
    }(Pe, Ne)), Pe)
      X.call(Pe, He) && !ue.hasOwnProperty(He) && (Ze[He] = Pe[He]);
    if (xe && xe.defaultProps) {
      var qe = xe.defaultProps;
      for (He in qe)
        Ze[He] === void 0 && (Ze[He] = qe[He]);
    }
    if ($e || Ye) {
      var Ve = typeof xe == "function" ? xe.displayName || xe.name || "Unknown" : xe;
      $e && function(Ge, ke) {
        var De = function() {
          q || (q = !0, T("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ke));
        };
        De.isReactWarning = !0, Object.defineProperty(Ge, "key", { get: De, configurable: !0 });
      }(Ze, Ve), Ye && function(Ge, ke) {
        var De = function() {
          te || (te = !0, T("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ke));
        };
        De.isReactWarning = !0, Object.defineProperty(Ge, "ref", { get: De, configurable: !0 });
      }(Ze, Ve);
    }
    return function(Ge, ke, De, at, be, nt, st) {
      var lt = { $$typeof: t, type: Ge, key: ke, ref: De, props: st, _owner: nt, _store: {} };
      return Object.defineProperty(lt._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(lt, "_self", { configurable: !1, enumerable: !1, writable: !1, value: at }), Object.defineProperty(lt, "_source", { configurable: !1, enumerable: !1, writable: !1, value: be }), Object.freeze && (Object.freeze(lt.props), Object.freeze(lt)), lt;
    }(xe, $e, Ye, Ne, Be, B.current, Ze);
  }
  le = {};
  var J, W = P.ReactCurrentOwner;
  function K(xe) {
    ae = xe;
  }
  function ee(xe) {
    return typeof xe == "object" && xe !== null && xe.$$typeof === t;
  }
  function $() {
    if (W.current) {
      var xe = Z(W.current.type);
      if (xe)
        return `

Check the render method of \`` + xe + "`.";
    }
    return "";
  }
  P.ReactDebugCurrentFrame, J = !1;
  var pe = {};
  function ve(xe, Pe) {
    if (xe._store && !xe._store.validated && xe.key == null) {
      xe._store.validated = !0;
      var de = function(Ne) {
        var He = $();
        if (!He) {
          var Ze = typeof Ne == "string" ? Ne : Ne.displayName || Ne.name;
          Ze && (He = `

Check the top-level render call using <` + Ze + ">.");
        }
        return He;
      }(Pe);
      if (!pe[de]) {
        pe[de] = !0;
        var Be = "";
        xe && xe._owner && xe._owner !== W.current && (Be = " It was passed a child from " + Z(xe._owner.type) + "."), K(xe), T('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', de, Be), K(null);
      }
    }
  }
  function Te(xe, Pe) {
    if (typeof xe == "object") {
      if (Array.isArray(xe))
        for (var de = 0; de < xe.length; de++) {
          var Be = xe[de];
          ee(Be) && ve(Be, Pe);
        }
      else if (ee(xe))
        xe._store && (xe._store.validated = !0);
      else if (xe) {
        var Ne = function($e) {
          if ($e === null || typeof $e != "object")
            return null;
          var Ye = A && $e[A] || $e["@@iterator"];
          return typeof Ye == "function" ? Ye : null;
        }(xe);
        if (typeof Ne == "function" && Ne !== xe.entries)
          for (var He, Ze = Ne.call(xe); !(He = Ze.next()).done; )
            ee(He.value) && ve(He.value, Pe);
      }
    }
  }
  function ye(xe) {
    var Pe, de = xe.type;
    if (de != null && typeof de != "string") {
      if (typeof de == "function")
        Pe = de.propTypes;
      else {
        if (typeof de != "object" || de.$$typeof !== c && de.$$typeof !== y)
          return;
        Pe = de.propTypes;
      }
      if (Pe) {
        var Be = Z(de);
        (function(Ne, He, Ze, $e, Ye) {
          var qe = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var Ve in Ne)
            if (qe(Ne, Ve)) {
              var Ge = void 0;
              try {
                if (typeof Ne[Ve] != "function") {
                  var ke = Error(($e || "React class") + ": " + Ze + " type `" + Ve + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ne[Ve] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw ke.name = "Invariant Violation", ke;
                }
                Ge = Ne[Ve](He, Ve, $e, Ze, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (De) {
                Ge = De;
              }
              !Ge || Ge instanceof Error || (j(Ye), T("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", $e || "React class", Ze, Ve, typeof Ge), j(null)), Ge instanceof Error && !(Ge.message in Y) && (Y[Ge.message] = !0, j(Ye), T("Failed %s type: %s", Ze, Ge.message), j(null));
            }
        })(Pe, xe.props, "prop", Be, xe);
      } else
        de.PropTypes === void 0 || J || (J = !0, T("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Z(de) || "Unknown"));
      typeof de.getDefaultProps != "function" || de.getDefaultProps.isReactClassApproved || T("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function Re(xe, Pe, de, Be, Ne, He) {
    var Ze = function(De) {
      return typeof De == "string" || typeof De == "function" || De === $a.Fragment || De === i || De === L || De === a || De === s || De === p || De === m || typeof De == "object" && De !== null && (De.$$typeof === g || De.$$typeof === y || De.$$typeof === o || De.$$typeof === d || De.$$typeof === c || De.$$typeof === S || De.$$typeof === b || De[0] === w);
    }(xe);
    if (!Ze) {
      var $e = "";
      (xe === void 0 || typeof xe == "object" && xe !== null && Object.keys(xe).length === 0) && ($e += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
      var Ye, qe = function(De) {
        return De !== void 0 ? `

Check your code at ` + De.fileName.replace(/^.*[\\\/]/, "") + ":" + De.lineNumber + "." : "";
      }(Ne);
      $e += qe || $(), xe === null ? Ye = "null" : Array.isArray(xe) ? Ye = "array" : xe !== void 0 && xe.$$typeof === t ? (Ye = "<" + (Z(xe.type) || "Unknown") + " />", $e = " Did you accidentally export a JSX literal instead of a component?") : Ye = typeof xe, T("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ye, $e);
    }
    var Ve = ne(xe, Pe, de, Ne, He);
    if (Ve == null)
      return Ve;
    if (Ze) {
      var Ge = Pe.children;
      if (Ge !== void 0)
        if (Be)
          if (Array.isArray(Ge)) {
            for (var ke = 0; ke < Ge.length; ke++)
              Te(Ge[ke], xe);
            Object.freeze && Object.freeze(Ge);
          } else
            T("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          Te(Ge, xe);
    }
    return xe === $a.Fragment ? function(De) {
      for (var at = Object.keys(De.props), be = 0; be < at.length; be++) {
        var nt = at[be];
        if (nt !== "children" && nt !== "key") {
          K(De), T("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", nt), K(null);
          break;
        }
      }
      De.ref !== null && (K(De), T("Invalid attribute `ref` supplied to `React.Fragment`."), K(null));
    }(Ve) : ye(Ve), Ve;
  }
  var Xe = function(xe, Pe, de) {
    return Re(xe, Pe, de, !1);
  }, Ce = function(xe, Pe, de) {
    return Re(xe, Pe, de, !0);
  };
  $a.jsx = Xe, $a.jsxs = Ce;
}(), Hi.exports = Vh;
var Qd, lg = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
Qd = lg, function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var r = [], a = 0; a < arguments.length; a++) {
      var i = arguments[a];
      if (i) {
        var o = typeof i;
        if (o === "string" || o === "number")
          r.push(i);
        else if (Array.isArray(i)) {
          if (i.length) {
            var d = t.apply(null, i);
            d && r.push(d);
          }
        } else if (o === "object") {
          if (i.toString !== Object.prototype.toString && !i.toString.toString().includes("[native code]")) {
            r.push(i.toString());
            continue;
          }
          for (var c in i)
            e.call(i, c) && i[c] && r.push(c);
        }
      }
    }
    return r.join(" ");
  }
  Qd.exports ? (t.default = t, Qd.exports = t) : window.classNames = t;
}();
var Wh = lg.exports;
const jh = (e, t, r) => {
  let a = null;
  return function(...i) {
    a && clearTimeout(a), a = setTimeout(() => {
      a = null, r || e.apply(this, i);
    }, t);
  };
}, aS = ({ content: e }) => Hi.exports.jsx("span", { dangerouslySetInnerHTML: { __html: e } }), iS = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} }, oS = se.createContext({ getTooltipData: () => iS });
function sg(e = "DEFAULT_TOOLTIP_ID") {
  return se.useContext(oS).getTooltipData(e);
}
const Uh = async ({ elementReference: e = null, tooltipReference: t = null, tooltipArrowReference: r = null, place: a = "top", offset: i = 10, strategy: o = "absolute", middlewares: d = [JE(Number(i)), QE(), eS({ padding: 5 })] }) => {
  if (!e)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  if (t === null)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  const c = d;
  return r ? (c.push({ name: "arrow", options: s = { element: r, padding: 5 }, async fn(p) {
    const { element: y, padding: g = 0 } = s || {}, { x: b, y: w, placement: S, rects: L, platform: m } = p;
    if (y == null)
      return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."), {};
    const v = qy(g), A = { x: b, y: w }, P = Rs(S), T = vp(P), _ = await m.getDimensions(y), M = P === "y" ? "top" : "left", Z = P === "y" ? "bottom" : "right", Y = L.reference[T] + L.reference[P] - A[P] - L.floating[T], ae = A[P] - L.reference[P], j = await (m.getOffsetParent == null ? void 0 : m.getOffsetParent(y));
    let q = j ? P === "y" ? j.clientHeight || 0 : j.clientWidth || 0 : 0;
    q === 0 && (q = L.floating[T]);
    const te = Y / 2 - ae / 2, le = v[M], B = q - _[T] - v[Z], X = q / 2 - _[T] / 2 + te, ue = If(le, X, B), ne = Ps(S) != null && X != ue && L.reference[T] / 2 - (X < le ? v[M] : v[Z]) - _[T] / 2 < 0;
    return { [P]: A[P] - (ne ? X < le ? le - X : B - X : 0), data: { [P]: ue, centerOffset: X - ue } };
  } }), Hh(e, t, { placement: a, strategy: o, middleware: c }).then(({ x: p, y, placement: g, middlewareData: b }) => {
    var w, S;
    const L = { left: `${p}px`, top: `${y}px` }, { x: m, y: v } = (w = b.arrow) !== null && w !== void 0 ? w : { x: 0, y: 0 };
    return { tooltipStyles: L, tooltipArrowStyles: { left: m != null ? `${m}px` : "", top: v != null ? `${v}px` : "", right: "", bottom: "", [(S = { top: "bottom", right: "left", bottom: "top", left: "right" }[g.split("-")[0]]) !== null && S !== void 0 ? S : "bottom"]: "-4px" } };
  })) : Hh(e, t, { placement: "bottom", strategy: o, middleware: c }).then(({ x: p, y }) => ({ tooltipStyles: { left: `${p}px`, top: `${y}px` }, tooltipArrowStyles: {} }));
  var s;
};
var Ri = { tooltip: "styles-module_tooltip__mnnfp", fixed: "styles-module_fixed__7ciUi", arrow: "styles-module_arrow__K0L3T", "no-arrow": "styles-module_no-arrow__KcFZN", clickable: "styles-module_clickable__Bv9o7", show: "styles-module_show__2NboJ", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
const Kh = ({ id: e, className: t, classNameArrow: r, variant: a = "dark", anchorId: i, anchorSelect: o, place: d = "top", offset: c = 10, events: s = ["hover"], positionStrategy: p = "absolute", middlewares: y, wrapper: g, children: b = null, delayShow: w = 0, delayHide: S = 0, float: L = !1, noArrow: m = !1, clickable: v = !1, closeOnEsc: A = !1, style: P, position: T, afterShow: _, afterHide: M, content: Z, html: Y, isOpen: ae, setIsOpen: j, activeAnchor: q, setActiveAnchor: te }) => {
  const le = se.useRef(null), B = se.useRef(null), X = se.useRef(null), ue = se.useRef(null), [ne, J] = se.useState({}), [W, K] = se.useState({}), [ee, $] = se.useState(!1), [pe, ve] = se.useState(!1), Te = se.useRef(!1), ye = se.useRef(null), { anchorRefs: Re, setActiveAnchor: Xe } = sg(e), Ce = se.useRef(!1), [xe, Pe] = se.useState([]), de = se.useRef(!1);
  se.useLayoutEffect(() => (de.current = !0, () => {
    de.current = !1;
  }), []), se.useEffect(() => {
    if (!ee) {
      const be = setTimeout(() => {
        ve(!1);
      }, 150);
      return () => {
        clearTimeout(be);
      };
    }
    return () => null;
  }, [ee]);
  const Be = (be) => {
    de.current && (be && ve(!0), setTimeout(() => {
      de.current && (j == null || j(be), ae === void 0 && $(be));
    }, 10));
  };
  se.useEffect(() => {
    if (ae === void 0)
      return () => null;
    ae && ve(!0);
    const be = setTimeout(() => {
      $(ae);
    }, 10);
    return () => {
      clearTimeout(be);
    };
  }, [ae]), se.useEffect(() => {
    ee !== Te.current && (Te.current = ee, ee ? _ == null || _() : M == null || M());
  }, [ee]);
  const Ne = (be = S) => {
    ue.current && clearTimeout(ue.current), ue.current = setTimeout(() => {
      Ce.current || Be(!1);
    }, be);
  }, He = (be) => {
    var nt;
    if (!be)
      return;
    w ? (X.current && clearTimeout(X.current), X.current = setTimeout(() => {
      Be(!0);
    }, w)) : Be(!0);
    const st = (nt = be.currentTarget) !== null && nt !== void 0 ? nt : be.target;
    te(st), Xe({ current: st }), ue.current && clearTimeout(ue.current);
  }, Ze = () => {
    v ? Ne(S || 100) : S ? Ne() : Be(!1), X.current && clearTimeout(X.current);
  }, $e = ({ x: be, y: nt }) => {
    Uh({ place: d, offset: c, elementReference: { getBoundingClientRect: () => ({ x: be, y: nt, width: 0, height: 0, top: nt, left: be, right: be, bottom: nt }) }, tooltipReference: le.current, tooltipArrowReference: B.current, strategy: p, middlewares: y }).then((st) => {
      Object.keys(st.tooltipStyles).length && J(st.tooltipStyles), Object.keys(st.tooltipArrowStyles).length && K(st.tooltipArrowStyles);
    });
  }, Ye = (be) => {
    if (!be)
      return;
    const nt = be, st = { x: nt.clientX, y: nt.clientY };
    $e(st), ye.current = st;
  }, qe = (be) => {
    He(be), S && Ne();
  }, Ve = (be) => {
    const nt = document.querySelector(`[id='${i}']`);
    nt != null && nt.contains(be.target) || xe.some((st) => st.contains(be.target)) || Be(!1);
  }, Ge = (be) => {
    be.key === "Escape" && Be(!1);
  }, ke = jh(He, 50), De = jh(Ze, 50);
  se.useEffect(() => {
    var be, nt;
    const st = new Set(Re);
    xe.forEach((_t) => {
      st.add({ current: _t });
    });
    const lt = document.querySelector(`[id='${i}']`);
    lt && st.add({ current: lt }), A && window.addEventListener("keydown", Ge);
    const St = [];
    s.find((_t) => _t === "click") && (window.addEventListener("click", Ve), St.push({ event: "click", listener: qe })), s.find((_t) => _t === "hover") && (St.push({ event: "mouseenter", listener: ke }, { event: "mouseleave", listener: De }, { event: "focus", listener: ke }, { event: "blur", listener: De }), L && St.push({ event: "mousemove", listener: Ye }));
    const Ut = () => {
      Ce.current = !0;
    }, It = () => {
      Ce.current = !1, Ze();
    };
    return v && ((be = le.current) === null || be === void 0 || be.addEventListener("mouseenter", Ut), (nt = le.current) === null || nt === void 0 || nt.addEventListener("mouseleave", It)), St.forEach(({ event: _t, listener: Rt }) => {
      st.forEach((Lt) => {
        var $t;
        ($t = Lt.current) === null || $t === void 0 || $t.addEventListener(_t, Rt);
      });
    }), () => {
      var _t, Rt;
      s.find((Lt) => Lt === "click") && window.removeEventListener("click", Ve), A && window.removeEventListener("keydown", Ge), v && ((_t = le.current) === null || _t === void 0 || _t.removeEventListener("mouseenter", Ut), (Rt = le.current) === null || Rt === void 0 || Rt.removeEventListener("mouseleave", It)), St.forEach(({ event: Lt, listener: $t }) => {
        st.forEach((Dt) => {
          var Gt;
          (Gt = Dt.current) === null || Gt === void 0 || Gt.removeEventListener(Lt, $t);
        });
      });
    };
  }, [pe, Re, xe, A, s]), se.useEffect(() => {
    let be = o ?? "";
    !be && e && (be = `[data-tooltip-id='${e}']`);
    const nt = new MutationObserver((st) => {
      const lt = [];
      st.forEach((St) => {
        if (St.type === "attributes" && St.attributeName === "data-tooltip-id" && St.target.getAttribute("data-tooltip-id") === e && lt.push(St.target), St.type === "childList" && (q && [...St.removedNodes].some((Ut) => !!Ut.contains(q) && (ve(!1), Be(!1), te(null), !0)), be))
          try {
            const Ut = [...St.addedNodes].filter((It) => It.nodeType === 1);
            lt.push(...Ut.filter((It) => It.matches(be))), lt.push(...Ut.flatMap((It) => [...It.querySelectorAll(be)]));
          } catch {
          }
      }), lt.length && Pe((St) => [...St, ...lt]);
    });
    return nt.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"] }), () => {
      nt.disconnect();
    };
  }, [e, o, q]), se.useEffect(() => {
    T ? $e(T) : L ? ye.current && $e(ye.current) : Uh({ place: d, offset: c, elementReference: q, tooltipReference: le.current, tooltipArrowReference: B.current, strategy: p, middlewares: y }).then((be) => {
      de.current && (Object.keys(be.tooltipStyles).length && J(be.tooltipStyles), Object.keys(be.tooltipArrowStyles).length && K(be.tooltipArrowStyles));
    });
  }, [ee, q, Z, Y, d, c, p, T]), se.useEffect(() => {
    var be;
    const nt = document.querySelector(`[id='${i}']`), st = [...xe, nt];
    q && st.includes(q) || te((be = xe[0]) !== null && be !== void 0 ? be : nt);
  }, [i, xe, q]), se.useEffect(() => () => {
    X.current && clearTimeout(X.current), ue.current && clearTimeout(ue.current);
  }, []), se.useEffect(() => {
    let be = o;
    if (!be && e && (be = `[data-tooltip-id='${e}']`), be)
      try {
        const nt = Array.from(document.querySelectorAll(be));
        Pe(nt);
      } catch {
        Pe([]);
      }
  }, [e, o]);
  const at = !!(Y || Z || b) && ee && Object.keys(ne).length > 0;
  return pe ? Hi.exports.jsxs(g, { id: e, role: "tooltip", className: Wh("react-tooltip", Ri.tooltip, Ri[a], t, { [Ri.show]: at, [Ri.fixed]: p === "fixed", [Ri.clickable]: v }), style: { ...P, ...ne }, ref: le, children: [Y && Hi.exports.jsx(aS, { content: Y }) || Z || b, Hi.exports.jsx(g, { className: Wh("react-tooltip-arrow", Ri.arrow, r, { [Ri["no-arrow"]]: m }), style: W, ref: B })] }) : null;
}, mc = ({ id: e, anchorId: t, anchorSelect: r, content: a, html: i, className: o, classNameArrow: d, variant: c = "dark", place: s = "top", offset: p = 10, wrapper: y = "div", children: g = null, events: b = ["hover"], positionStrategy: w = "absolute", middlewares: S, delayShow: L = 0, delayHide: m = 0, float: v = !1, noArrow: A = !1, clickable: P = !1, closeOnEsc: T = !1, style: _, position: M, isOpen: Z, setIsOpen: Y, afterShow: ae, afterHide: j }) => {
  const [q, te] = se.useState(a), [le, B] = se.useState(i), [X, ue] = se.useState(s), [ne, J] = se.useState(c), [W, K] = se.useState(p), [ee, $] = se.useState(L), [pe, ve] = se.useState(m), [Te, ye] = se.useState(v), [Re, Xe] = se.useState(y), [Ce, xe] = se.useState(b), [Pe, de] = se.useState(w), [Be, Ne] = se.useState(null), { anchorRefs: He, activeAnchor: Ze } = sg(e), $e = (Ve) => Ve == null ? void 0 : Ve.getAttributeNames().reduce((Ge, ke) => {
    var De;
    return ke.startsWith("data-tooltip-") && (Ge[ke.replace(/^data-tooltip-/, "")] = (De = Ve == null ? void 0 : Ve.getAttribute(ke)) !== null && De !== void 0 ? De : null), Ge;
  }, {}), Ye = (Ve) => {
    const Ge = { place: (ke) => {
      var De;
      ue((De = ke) !== null && De !== void 0 ? De : s);
    }, content: (ke) => {
      te(ke ?? a);
    }, html: (ke) => {
      B(ke ?? i);
    }, variant: (ke) => {
      var De;
      J((De = ke) !== null && De !== void 0 ? De : c);
    }, offset: (ke) => {
      K(ke === null ? p : Number(ke));
    }, wrapper: (ke) => {
      var De;
      Xe((De = ke) !== null && De !== void 0 ? De : y);
    }, events: (ke) => {
      const De = ke == null ? void 0 : ke.split(" ");
      xe(De ?? b);
    }, "position-strategy": (ke) => {
      var De;
      de((De = ke) !== null && De !== void 0 ? De : w);
    }, "delay-show": (ke) => {
      $(ke === null ? L : Number(ke));
    }, "delay-hide": (ke) => {
      ve(ke === null ? m : Number(ke));
    }, float: (ke) => {
      ye(ke === null ? v : !!ke);
    } };
    Object.values(Ge).forEach((ke) => ke(null)), Object.entries(Ve).forEach(([ke, De]) => {
      var at;
      (at = Ge[ke]) === null || at === void 0 || at.call(Ge, De);
    });
  };
  se.useEffect(() => {
    te(a);
  }, [a]), se.useEffect(() => {
    B(i);
  }, [i]), se.useEffect(() => {
    ue(s);
  }, [s]), se.useEffect(() => {
    var Ve;
    const Ge = new Set(He);
    let ke = r;
    if (!ke && e && (ke = `[data-tooltip-id='${e}']`), ke)
      try {
        document.querySelectorAll(ke).forEach((st) => {
          Ge.add({ current: st });
        });
      } catch {
        console.warn(`[react-tooltip] "${r}" is not a valid CSS selector`);
      }
    const De = document.querySelector(`[id='${t}']`);
    if (De && Ge.add({ current: De }), !Ge.size)
      return () => null;
    const at = (Ve = Be ?? De) !== null && Ve !== void 0 ? Ve : Ze.current, be = new MutationObserver((st) => {
      st.forEach((lt) => {
        var St;
        if (!at || lt.type !== "attributes" || !(!((St = lt.attributeName) === null || St === void 0) && St.startsWith("data-tooltip-")))
          return;
        const Ut = $e(at);
        Ye(Ut);
      });
    }), nt = { attributes: !0, childList: !1, subtree: !1 };
    if (at) {
      const st = $e(at);
      Ye(st), be.observe(at, nt);
    }
    return () => {
      be.disconnect();
    };
  }, [He, Ze, Be, t, r]);
  const qe = { id: e, anchorId: t, anchorSelect: r, className: o, classNameArrow: d, content: q, html: le, place: X, variant: ne, offset: W, wrapper: Re, events: Ce, positionStrategy: Pe, middlewares: S, delayShow: ee, delayHide: pe, float: Te, noArrow: A, clickable: P, closeOnEsc: T, style: _, position: M, isOpen: Z, setIsOpen: Y, afterShow: ae, afterHide: j, activeAnchor: Be, setActiveAnchor: (Ve) => Ne(Ve) };
  return g ? Hi.exports.jsx(Kh, { ...qe, children: g }) : Hi.exports.jsx(Kh, { ...qe });
};
function Yh(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r < a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function lS(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r > a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function Jd(e, t) {
  let r = 0;
  if (t === void 0)
    for (let a of e)
      (a = +a) && (r += a);
  else {
    let a = -1;
    for (let i of e)
      (i = +t(i, ++a, e)) && (r += i);
  }
  return r;
}
function sS(e) {
  return e.depth;
}
function uS(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function Ou(e) {
  return function() {
    return e;
  };
}
function Gh(e, t) {
  return yc(e.source, t.source) || e.index - t.index;
}
function Xh(e, t) {
  return yc(e.target, t.target) || e.index - t.index;
}
function yc(e, t) {
  return e.y0 - t.y0;
}
function ef(e) {
  return e.value;
}
function cS(e) {
  return e.index;
}
function dS(e) {
  return e.nodes;
}
function fS(e) {
  return e.links;
}
function qh(e, t) {
  const r = e.get(t);
  if (!r)
    throw new Error("missing: " + t);
  return r;
}
function Zh({ nodes: e }) {
  for (const t of e) {
    let r = t.y0, a = r;
    for (const i of t.sourceLinks)
      i.y0 = r + i.width / 2, r += i.width;
    for (const i of t.targetLinks)
      i.y1 = a + i.width / 2, a += i.width;
  }
}
function pS() {
  let e = 0, t = 0, r = 1, a = 1, i = 24, o = 8, d, c = cS, s = uS, p, y, g = dS, b = fS, w = 6;
  function S() {
    const X = { nodes: g.apply(null, arguments), links: b.apply(null, arguments) };
    return L(X), m(X), v(X), A(X), _(X), Zh(X), X;
  }
  S.update = function(X) {
    return Zh(X), X;
  }, S.nodeId = function(X) {
    return arguments.length ? (c = typeof X == "function" ? X : Ou(X), S) : c;
  }, S.nodeAlign = function(X) {
    return arguments.length ? (s = typeof X == "function" ? X : Ou(X), S) : s;
  }, S.nodeSort = function(X) {
    return arguments.length ? (p = X, S) : p;
  }, S.nodeWidth = function(X) {
    return arguments.length ? (i = +X, S) : i;
  }, S.nodePadding = function(X) {
    return arguments.length ? (o = d = +X, S) : o;
  }, S.nodes = function(X) {
    return arguments.length ? (g = typeof X == "function" ? X : Ou(X), S) : g;
  }, S.links = function(X) {
    return arguments.length ? (b = typeof X == "function" ? X : Ou(X), S) : b;
  }, S.linkSort = function(X) {
    return arguments.length ? (y = X, S) : y;
  }, S.size = function(X) {
    return arguments.length ? (e = t = 0, r = +X[0], a = +X[1], S) : [r - e, a - t];
  }, S.extent = function(X) {
    return arguments.length ? (e = +X[0][0], r = +X[1][0], t = +X[0][1], a = +X[1][1], S) : [[e, t], [r, a]];
  }, S.iterations = function(X) {
    return arguments.length ? (w = +X, S) : w;
  };
  function L({ nodes: X, links: ue }) {
    for (const [J, W] of X.entries())
      W.index = J, W.sourceLinks = [], W.targetLinks = [];
    const ne = new Map(X.map((J, W) => [c(J, W, X), J]));
    for (const [J, W] of ue.entries()) {
      W.index = J;
      let { source: K, target: ee } = W;
      typeof K != "object" && (K = W.source = qh(ne, K)), typeof ee != "object" && (ee = W.target = qh(ne, ee)), K.sourceLinks.push(W), ee.targetLinks.push(W);
    }
    if (y != null)
      for (const { sourceLinks: J, targetLinks: W } of X)
        J.sort(y), W.sort(y);
  }
  function m({ nodes: X }) {
    for (const ue of X)
      ue.value = ue.fixedValue === void 0 ? Math.max(Jd(ue.sourceLinks, ef), Jd(ue.targetLinks, ef)) : ue.fixedValue;
  }
  function v({ nodes: X }) {
    const ue = X.length;
    let ne = new Set(X), J = /* @__PURE__ */ new Set(), W = 0;
    for (; ne.size; ) {
      for (const K of ne) {
        K.depth = W;
        for (const { target: ee } of K.sourceLinks)
          J.add(ee);
      }
      if (++W > ue)
        throw new Error("circular link");
      ne = J, J = /* @__PURE__ */ new Set();
    }
  }
  function A({ nodes: X }) {
    const ue = X.length;
    let ne = new Set(X), J = /* @__PURE__ */ new Set(), W = 0;
    for (; ne.size; ) {
      for (const K of ne) {
        K.height = W;
        for (const { source: ee } of K.targetLinks)
          J.add(ee);
      }
      if (++W > ue)
        throw new Error("circular link");
      ne = J, J = /* @__PURE__ */ new Set();
    }
  }
  function P({ nodes: X }) {
    const ue = Yh(X, (W) => W.depth) + 1, ne = (r - e - i) / (ue - 1), J = new Array(ue);
    for (const W of X) {
      const K = Math.max(0, Math.min(ue - 1, Math.floor(s.call(null, W, ue))));
      W.layer = K, W.x0 = e + K * ne, W.x1 = W.x0 + i, J[K] ? J[K].push(W) : J[K] = [W];
    }
    if (p)
      for (const W of J)
        W.sort(p);
    return J;
  }
  function T(X) {
    const ue = lS(X, (ne) => (a - t - (ne.length - 1) * d) / Jd(ne, ef));
    for (const ne of X) {
      let J = t;
      for (const W of ne) {
        W.y0 = J, W.y1 = J + W.value * ue, J = W.y1 + d;
        for (const K of W.sourceLinks)
          K.width = K.value * ue;
      }
      J = (a - J + d) / (ne.length + 1);
      for (let W = 0; W < ne.length; ++W) {
        const K = ne[W];
        K.y0 += J * (W + 1), K.y1 += J * (W + 1);
      }
      te(ne);
    }
  }
  function _(X) {
    const ue = P(X);
    d = Math.min(o, (a - t) / (Yh(ue, (ne) => ne.length) - 1)), T(ue);
    for (let ne = 0; ne < w; ++ne) {
      const J = Math.pow(0.99, ne), W = Math.max(1 - J, (ne + 1) / w);
      Z(ue, J, W), M(ue, J, W);
    }
  }
  function M(X, ue, ne) {
    for (let J = 1, W = X.length; J < W; ++J) {
      const K = X[J];
      for (const ee of K) {
        let $ = 0, pe = 0;
        for (const { source: Te, value: ye } of ee.targetLinks) {
          let Re = ye * (ee.layer - Te.layer);
          $ += le(Te, ee) * Re, pe += Re;
        }
        if (!(pe > 0))
          continue;
        let ve = ($ / pe - ee.y0) * ue;
        ee.y0 += ve, ee.y1 += ve, q(ee);
      }
      p === void 0 && K.sort(yc), Y(K, ne);
    }
  }
  function Z(X, ue, ne) {
    for (let J = X.length, W = J - 2; W >= 0; --W) {
      const K = X[W];
      for (const ee of K) {
        let $ = 0, pe = 0;
        for (const { target: Te, value: ye } of ee.sourceLinks) {
          let Re = ye * (Te.layer - ee.layer);
          $ += B(ee, Te) * Re, pe += Re;
        }
        if (!(pe > 0))
          continue;
        let ve = ($ / pe - ee.y0) * ue;
        ee.y0 += ve, ee.y1 += ve, q(ee);
      }
      p === void 0 && K.sort(yc), Y(K, ne);
    }
  }
  function Y(X, ue) {
    const ne = X.length >> 1, J = X[ne];
    j(X, J.y0 - d, ne - 1, ue), ae(X, J.y1 + d, ne + 1, ue), j(X, a, X.length - 1, ue), ae(X, t, 0, ue);
  }
  function ae(X, ue, ne, J) {
    for (; ne < X.length; ++ne) {
      const W = X[ne], K = (ue - W.y0) * J;
      K > 1e-6 && (W.y0 += K, W.y1 += K), ue = W.y1 + d;
    }
  }
  function j(X, ue, ne, J) {
    for (; ne >= 0; --ne) {
      const W = X[ne], K = (W.y1 - ue) * J;
      K > 1e-6 && (W.y0 -= K, W.y1 -= K), ue = W.y0 - d;
    }
  }
  function q({ sourceLinks: X, targetLinks: ue }) {
    if (y === void 0) {
      for (const { source: { sourceLinks: ne } } of ue)
        ne.sort(Xh);
      for (const { target: { targetLinks: ne } } of X)
        ne.sort(Gh);
    }
  }
  function te(X) {
    if (y === void 0)
      for (const { sourceLinks: ue, targetLinks: ne } of X)
        ue.sort(Xh), ne.sort(Gh);
  }
  function le(X, ue) {
    let ne = X.y0 - (X.sourceLinks.length - 1) * d / 2;
    for (const { target: J, width: W } of X.sourceLinks) {
      if (J === ue)
        break;
      ne += W + d;
    }
    for (const { source: J, width: W } of ue.targetLinks) {
      if (J === X)
        break;
      ne -= W;
    }
    return ne;
  }
  function B(X, ue) {
    let ne = ue.y0 - (ue.targetLinks.length - 1) * d / 2;
    for (const { source: J, width: W } of ue.targetLinks) {
      if (J === X)
        break;
      ne += W + d;
    }
    for (const { target: J, width: W } of X.sourceLinks) {
      if (J === ue)
        break;
      ne -= W;
    }
    return ne;
  }
  return S;
}
function hS(e) {
  return [e.source.x1, e.y0];
}
function mS(e) {
  return [e.target.x0, e.y1];
}
function yS() {
  return f0().source(hS).target(mS);
}
const gS = () => {
  const { config: e, handleChartTabbing: t, legendId: r } = se.useContext(ft), [a, i] = se.useState(!1), o = /* @__PURE__ */ n.createElement(n.Fragment, null, "For best viewing we recommend portrait mode. If you are unable to put your device in portrait mode, please review the ", /* @__PURE__ */ n.createElement("a", { href: `#${t(e, r)}` }, "data table"), " below.", " ", /* @__PURE__ */ n.createElement("a", { onClick: () => i(!1), href: "#!" }, "Close this alert"), " ", "to continue viewing the chart."), d = () => {
    i(!1);
  }, c = a ? /* @__PURE__ */ n.createElement("div", { className: "alert alert-warning alert-dismissible", role: "alert" }, /* @__PURE__ */ n.createElement("p", { style: { padding: "35px" } }, o), /* @__PURE__ */ n.createElement("button", { type: "button", className: "close", "data-dismiss": "alert", "aria-label": "Close", onClick: d }, /* @__PURE__ */ n.createElement("span", { "aria-hidden": "true" }, "×"))) : null;
  return se.useEffect(() => {
    const s = () => {
      window.innerWidth < 768 && window.innerHeight > window.innerWidth ? i(!0) : i(!1);
    };
    return window.addEventListener("resize", s), s(), () => {
      window.removeEventListener("resize", s);
    };
  }, []), {
    setShowAlert: i,
    showAlert: a,
    handleCloseModal: d,
    alertMessage: o,
    alert: c
  };
};
var Xa = {}, Ni = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Qh;
function vS() {
  if (Qh)
    return Ni;
  Qh = 1;
  var e = se;
  function t(x) {
    for (var D = "https://reactjs.org/docs/error-decoder.html?invariant=" + x, N = 1; N < arguments.length; N++)
      D += "&args[]=" + encodeURIComponent(arguments[N]);
    return "Minified React error #" + x + "; visit " + D + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = Object.prototype.hasOwnProperty, a = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, i = {}, o = {};
  function d(x) {
    return r.call(o, x) ? !0 : r.call(i, x) ? !1 : a.test(x) ? o[x] = !0 : (i[x] = !0, !1);
  }
  function c(x, D, N, U, fe, O, I) {
    this.acceptsBooleans = D === 2 || D === 3 || D === 4, this.attributeName = U, this.attributeNamespace = fe, this.mustUseProperty = N, this.propertyName = x, this.type = D, this.sanitizeURL = O, this.removeEmptyString = I;
  }
  var s = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(x) {
    s[x] = new c(x, 0, !1, x, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(x) {
    var D = x[0];
    s[D] = new c(D, 1, !1, x[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(x) {
    s[x] = new c(x, 2, !1, x.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(x) {
    s[x] = new c(x, 2, !1, x, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(x) {
    s[x] = new c(x, 3, !1, x.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(x) {
    s[x] = new c(x, 3, !0, x, null, !1, !1);
  }), ["capture", "download"].forEach(function(x) {
    s[x] = new c(x, 4, !1, x, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(x) {
    s[x] = new c(x, 6, !1, x, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(x) {
    s[x] = new c(x, 5, !1, x.toLowerCase(), null, !1, !1);
  });
  var p = /[\-:]([a-z])/g;
  function y(x) {
    return x[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(x) {
    var D = x.replace(
      p,
      y
    );
    s[D] = new c(D, 1, !1, x, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(x) {
    var D = x.replace(p, y);
    s[D] = new c(D, 1, !1, x, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(x) {
    var D = x.replace(p, y);
    s[D] = new c(D, 1, !1, x, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(x) {
    s[x] = new c(x, 1, !1, x.toLowerCase(), null, !1, !1);
  }), s.xlinkHref = new c("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(x) {
    s[x] = new c(x, 1, !1, x.toLowerCase(), null, !0, !0);
  });
  var g = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, b = ["Webkit", "ms", "Moz", "O"];
  Object.keys(g).forEach(function(x) {
    b.forEach(function(D) {
      D = D + x.charAt(0).toUpperCase() + x.substring(1), g[D] = g[x];
    });
  });
  var w = /["'&<>]/;
  function S(x) {
    if (typeof x == "boolean" || typeof x == "number")
      return "" + x;
    x = "" + x;
    var D = w.exec(x);
    if (D) {
      var N = "", U, fe = 0;
      for (U = D.index; U < x.length; U++) {
        switch (x.charCodeAt(U)) {
          case 34:
            D = "&quot;";
            break;
          case 38:
            D = "&amp;";
            break;
          case 39:
            D = "&#x27;";
            break;
          case 60:
            D = "&lt;";
            break;
          case 62:
            D = "&gt;";
            break;
          default:
            continue;
        }
        fe !== U && (N += x.substring(fe, U)), fe = U + 1, N += D;
      }
      x = fe !== U ? N + x.substring(fe, U) : N;
    }
    return x;
  }
  var L = /([A-Z])/g, m = /^ms-/, v = Array.isArray;
  function A(x, D) {
    return { insertionMode: x, selectedValue: D };
  }
  function P(x, D, N) {
    switch (D) {
      case "select":
        return A(1, N.value != null ? N.value : N.defaultValue);
      case "svg":
        return A(2, null);
      case "math":
        return A(3, null);
      case "foreignObject":
        return A(1, null);
      case "table":
        return A(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return A(5, null);
      case "colgroup":
        return A(7, null);
      case "tr":
        return A(6, null);
    }
    return 4 <= x.insertionMode || x.insertionMode === 0 ? A(1, null) : x;
  }
  var T = /* @__PURE__ */ new Map();
  function _(x, D, N) {
    if (typeof N != "object")
      throw Error(t(62));
    D = !0;
    for (var U in N)
      if (r.call(N, U)) {
        var fe = N[U];
        if (fe != null && typeof fe != "boolean" && fe !== "") {
          if (U.indexOf("--") === 0) {
            var O = S(U);
            fe = S(("" + fe).trim());
          } else {
            O = U;
            var I = T.get(O);
            I !== void 0 || (I = S(O.replace(L, "-$1").toLowerCase().replace(m, "-ms-")), T.set(O, I)), O = I, fe = typeof fe == "number" ? fe === 0 || r.call(g, U) ? "" + fe : fe + "px" : S(("" + fe).trim());
          }
          D ? (D = !1, x.push(' style="', O, ":", fe)) : x.push(";", O, ":", fe);
        }
      }
    D || x.push('"');
  }
  function M(x, D, N, U) {
    switch (N) {
      case "style":
        _(x, D, U);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < N.length) || N[0] !== "o" && N[0] !== "O" || N[1] !== "n" && N[1] !== "N") {
      if (D = s.hasOwnProperty(N) ? s[N] : null, D !== null) {
        switch (typeof U) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!D.acceptsBooleans)
              return;
        }
        switch (N = D.attributeName, D.type) {
          case 3:
            U && x.push(" ", N, '=""');
            break;
          case 4:
            U === !0 ? x.push(" ", N, '=""') : U !== !1 && x.push(" ", N, '="', S(U), '"');
            break;
          case 5:
            isNaN(U) || x.push(" ", N, '="', S(U), '"');
            break;
          case 6:
            !isNaN(U) && 1 <= U && x.push(" ", N, '="', S(U), '"');
            break;
          default:
            D.sanitizeURL && (U = "" + U), x.push(" ", N, '="', S(U), '"');
        }
      } else if (d(N)) {
        switch (typeof U) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (D = N.toLowerCase().slice(0, 5), D !== "data-" && D !== "aria-")
              return;
        }
        x.push(" ", N, '="', S(U), '"');
      }
    }
  }
  function Z(x, D, N) {
    if (D != null) {
      if (N != null)
        throw Error(t(60));
      if (typeof D != "object" || !("__html" in D))
        throw Error(t(61));
      D = D.__html, D != null && x.push("" + D);
    }
  }
  function Y(x) {
    var D = "";
    return e.Children.forEach(x, function(N) {
      N != null && (D += N);
    }), D;
  }
  function ae(x, D, N, U) {
    x.push(te(N));
    var fe = N = null, O;
    for (O in D)
      if (r.call(D, O)) {
        var I = D[O];
        if (I != null)
          switch (O) {
            case "children":
              N = I;
              break;
            case "dangerouslySetInnerHTML":
              fe = I;
              break;
            default:
              M(x, U, O, I);
          }
      }
    return x.push(">"), Z(x, fe, N), typeof N == "string" ? (x.push(S(N)), null) : N;
  }
  var j = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, q = /* @__PURE__ */ new Map();
  function te(x) {
    var D = q.get(x);
    if (D === void 0) {
      if (!j.test(x))
        throw Error(t(65, x));
      D = "<" + x, q.set(x, D);
    }
    return D;
  }
  function le(x, D, N, U, fe) {
    switch (D) {
      case "select":
        x.push(te("select"));
        var O = null, I = null;
        for (Ke in N)
          if (r.call(N, Ke)) {
            var Q = N[Ke];
            if (Q != null)
              switch (Ke) {
                case "children":
                  O = Q;
                  break;
                case "dangerouslySetInnerHTML":
                  I = Q;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  M(x, U, Ke, Q);
              }
          }
        return x.push(">"), Z(x, I, O), O;
      case "option":
        I = fe.selectedValue, x.push(te("option"));
        var ge = Q = null, ze = null, Ke = null;
        for (O in N)
          if (r.call(N, O)) {
            var ot = N[O];
            if (ot != null)
              switch (O) {
                case "children":
                  Q = ot;
                  break;
                case "selected":
                  ze = ot;
                  break;
                case "dangerouslySetInnerHTML":
                  Ke = ot;
                  break;
                case "value":
                  ge = ot;
                default:
                  M(x, U, O, ot);
              }
          }
        if (I != null)
          if (N = ge !== null ? "" + ge : Y(Q), v(I)) {
            for (U = 0; U < I.length; U++)
              if ("" + I[U] === N) {
                x.push(' selected=""');
                break;
              }
          } else
            "" + I === N && x.push(' selected=""');
        else
          ze && x.push(' selected=""');
        return x.push(">"), Z(x, Ke, Q), Q;
      case "textarea":
        x.push(te("textarea")), Ke = I = O = null;
        for (Q in N)
          if (r.call(N, Q) && (ge = N[Q], ge != null))
            switch (Q) {
              case "children":
                Ke = ge;
                break;
              case "value":
                O = ge;
                break;
              case "defaultValue":
                I = ge;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                M(
                  x,
                  U,
                  Q,
                  ge
                );
            }
        if (O === null && I !== null && (O = I), x.push(">"), Ke != null) {
          if (O != null)
            throw Error(t(92));
          if (v(Ke) && 1 < Ke.length)
            throw Error(t(93));
          O = "" + Ke;
        }
        return typeof O == "string" && O[0] === `
` && x.push(`
`), O !== null && x.push(S("" + O)), null;
      case "input":
        x.push(te("input")), ge = Ke = Q = O = null;
        for (I in N)
          if (r.call(N, I) && (ze = N[I], ze != null))
            switch (I) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                ge = ze;
                break;
              case "defaultValue":
                Q = ze;
                break;
              case "checked":
                Ke = ze;
                break;
              case "value":
                O = ze;
                break;
              default:
                M(x, U, I, ze);
            }
        return Ke !== null ? M(x, U, "checked", Ke) : ge !== null && M(x, U, "checked", ge), O !== null ? M(x, U, "value", O) : Q !== null && M(x, U, "value", Q), x.push("/>"), null;
      case "menuitem":
        x.push(te("menuitem"));
        for (var Yt in N)
          if (r.call(N, Yt) && (O = N[Yt], O != null))
            switch (Yt) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                M(x, U, Yt, O);
            }
        return x.push(">"), null;
      case "title":
        x.push(te("title")), O = null;
        for (ot in N)
          if (r.call(N, ot) && (I = N[ot], I != null))
            switch (ot) {
              case "children":
                O = I;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                M(x, U, ot, I);
            }
        return x.push(">"), O;
      case "listing":
      case "pre":
        x.push(te(D)), I = O = null;
        for (ge in N)
          if (r.call(N, ge) && (Q = N[ge], Q != null))
            switch (ge) {
              case "children":
                O = Q;
                break;
              case "dangerouslySetInnerHTML":
                I = Q;
                break;
              default:
                M(x, U, ge, Q);
            }
        if (x.push(">"), I != null) {
          if (O != null)
            throw Error(t(60));
          if (typeof I != "object" || !("__html" in I))
            throw Error(t(61));
          N = I.__html, N != null && (typeof N == "string" && 0 < N.length && N[0] === `
` ? x.push(`
`, N) : x.push("" + N));
        }
        return typeof O == "string" && O[0] === `
` && x.push(`
`), O;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        x.push(te(D));
        for (var Vt in N)
          if (r.call(N, Vt) && (O = N[Vt], O != null))
            switch (Vt) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, D));
              default:
                M(x, U, Vt, O);
            }
        return x.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return ae(
          x,
          N,
          D,
          U
        );
      case "html":
        return fe.insertionMode === 0 && x.push("<!DOCTYPE html>"), ae(x, N, D, U);
      default:
        if (D.indexOf("-") === -1 && typeof N.is != "string")
          return ae(x, N, D, U);
        x.push(te(D)), I = O = null;
        for (ze in N)
          if (r.call(N, ze) && (Q = N[ze], Q != null))
            switch (ze) {
              case "children":
                O = Q;
                break;
              case "dangerouslySetInnerHTML":
                I = Q;
                break;
              case "style":
                _(x, U, Q);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                d(ze) && typeof Q != "function" && typeof Q != "symbol" && x.push(" ", ze, '="', S(Q), '"');
            }
        return x.push(">"), Z(x, I, O), O;
    }
  }
  function B(x, D, N) {
    if (x.push('<!--$?--><template id="'), N === null)
      throw Error(t(395));
    return x.push(N), x.push('"></template>');
  }
  function X(x, D, N, U) {
    switch (N.insertionMode) {
      case 0:
      case 1:
        return x.push('<div hidden id="'), x.push(D.segmentPrefix), D = U.toString(16), x.push(D), x.push('">');
      case 2:
        return x.push('<svg aria-hidden="true" style="display:none" id="'), x.push(D.segmentPrefix), D = U.toString(16), x.push(D), x.push('">');
      case 3:
        return x.push('<math aria-hidden="true" style="display:none" id="'), x.push(D.segmentPrefix), D = U.toString(16), x.push(D), x.push('">');
      case 4:
        return x.push('<table hidden id="'), x.push(D.segmentPrefix), D = U.toString(16), x.push(D), x.push('">');
      case 5:
        return x.push('<table hidden><tbody id="'), x.push(D.segmentPrefix), D = U.toString(16), x.push(D), x.push('">');
      case 6:
        return x.push('<table hidden><tr id="'), x.push(D.segmentPrefix), D = U.toString(16), x.push(D), x.push('">');
      case 7:
        return x.push('<table hidden><colgroup id="'), x.push(D.segmentPrefix), D = U.toString(16), x.push(D), x.push('">');
      default:
        throw Error(t(397));
    }
  }
  function ue(x, D) {
    switch (D.insertionMode) {
      case 0:
      case 1:
        return x.push("</div>");
      case 2:
        return x.push("</svg>");
      case 3:
        return x.push("</math>");
      case 4:
        return x.push("</table>");
      case 5:
        return x.push("</tbody></table>");
      case 6:
        return x.push("</tr></table>");
      case 7:
        return x.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var ne = /[<\u2028\u2029]/g;
  function J(x) {
    return JSON.stringify(x).replace(ne, function(D) {
      switch (D) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function W(x, D) {
    return D = D === void 0 ? "" : D, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: D + "P:", segmentPrefix: D + "S:", boundaryPrefix: D + "B:", idPrefix: D, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: x };
  }
  function K(x, D, N, U) {
    return N.generateStaticMarkup ? (x.push(S(D)), !1) : (D === "" ? x = U : (U && x.push("<!-- -->"), x.push(S(D)), x = !0), x);
  }
  var ee = Object.assign, $ = Symbol.for("react.element"), pe = Symbol.for("react.portal"), ve = Symbol.for("react.fragment"), Te = Symbol.for("react.strict_mode"), ye = Symbol.for("react.profiler"), Re = Symbol.for("react.provider"), Xe = Symbol.for("react.context"), Ce = Symbol.for("react.forward_ref"), xe = Symbol.for("react.suspense"), Pe = Symbol.for("react.suspense_list"), de = Symbol.for("react.memo"), Be = Symbol.for("react.lazy"), Ne = Symbol.for("react.scope"), He = Symbol.for("react.debug_trace_mode"), Ze = Symbol.for("react.legacy_hidden"), $e = Symbol.for("react.default_value"), Ye = Symbol.iterator;
  function qe(x) {
    if (x == null)
      return null;
    if (typeof x == "function")
      return x.displayName || x.name || null;
    if (typeof x == "string")
      return x;
    switch (x) {
      case ve:
        return "Fragment";
      case pe:
        return "Portal";
      case ye:
        return "Profiler";
      case Te:
        return "StrictMode";
      case xe:
        return "Suspense";
      case Pe:
        return "SuspenseList";
    }
    if (typeof x == "object")
      switch (x.$$typeof) {
        case Xe:
          return (x.displayName || "Context") + ".Consumer";
        case Re:
          return (x._context.displayName || "Context") + ".Provider";
        case Ce:
          var D = x.render;
          return x = x.displayName, x || (x = D.displayName || D.name || "", x = x !== "" ? "ForwardRef(" + x + ")" : "ForwardRef"), x;
        case de:
          return D = x.displayName || null, D !== null ? D : qe(x.type) || "Memo";
        case Be:
          D = x._payload, x = x._init;
          try {
            return qe(x(D));
          } catch {
          }
      }
    return null;
  }
  var Ve = {};
  function Ge(x, D) {
    if (x = x.contextTypes, !x)
      return Ve;
    var N = {}, U;
    for (U in x)
      N[U] = D[U];
    return N;
  }
  var ke = null;
  function De(x, D) {
    if (x !== D) {
      x.context._currentValue2 = x.parentValue, x = x.parent;
      var N = D.parent;
      if (x === null) {
        if (N !== null)
          throw Error(t(401));
      } else {
        if (N === null)
          throw Error(t(401));
        De(x, N);
      }
      D.context._currentValue2 = D.value;
    }
  }
  function at(x) {
    x.context._currentValue2 = x.parentValue, x = x.parent, x !== null && at(x);
  }
  function be(x) {
    var D = x.parent;
    D !== null && be(D), x.context._currentValue2 = x.value;
  }
  function nt(x, D) {
    if (x.context._currentValue2 = x.parentValue, x = x.parent, x === null)
      throw Error(t(402));
    x.depth === D.depth ? De(x, D) : nt(x, D);
  }
  function st(x, D) {
    var N = D.parent;
    if (N === null)
      throw Error(t(402));
    x.depth === N.depth ? De(x, N) : st(x, N), D.context._currentValue2 = D.value;
  }
  function lt(x) {
    var D = ke;
    D !== x && (D === null ? be(x) : x === null ? at(D) : D.depth === x.depth ? De(D, x) : D.depth > x.depth ? nt(D, x) : st(D, x), ke = x);
  }
  var St = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(x, D) {
    x = x._reactInternals, x.queue !== null && x.queue.push(D);
  }, enqueueReplaceState: function(x, D) {
    x = x._reactInternals, x.replace = !0, x.queue = [D];
  }, enqueueForceUpdate: function() {
  } };
  function Ut(x, D, N, U) {
    var fe = x.state !== void 0 ? x.state : null;
    x.updater = St, x.props = N, x.state = fe;
    var O = { queue: [], replace: !1 };
    x._reactInternals = O;
    var I = D.contextType;
    if (x.context = typeof I == "object" && I !== null ? I._currentValue2 : U, I = D.getDerivedStateFromProps, typeof I == "function" && (I = I(N, fe), fe = I == null ? fe : ee({}, fe, I), x.state = fe), typeof D.getDerivedStateFromProps != "function" && typeof x.getSnapshotBeforeUpdate != "function" && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function"))
      if (D = x.state, typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount(), D !== x.state && St.enqueueReplaceState(x, x.state, null), O.queue !== null && 0 < O.queue.length)
        if (D = O.queue, I = O.replace, O.queue = null, O.replace = !1, I && D.length === 1)
          x.state = D[0];
        else {
          for (O = I ? D[0] : x.state, fe = !0, I = I ? 1 : 0; I < D.length; I++) {
            var Q = D[I];
            Q = typeof Q == "function" ? Q.call(x, O, N, U) : Q, Q != null && (fe ? (fe = !1, O = ee({}, O, Q)) : ee(O, Q));
          }
          x.state = O;
        }
      else
        O.queue = null;
  }
  var It = { id: 1, overflow: "" };
  function _t(x, D, N) {
    var U = x.id;
    x = x.overflow;
    var fe = 32 - Rt(U) - 1;
    U &= ~(1 << fe), N += 1;
    var O = 32 - Rt(D) + fe;
    if (30 < O) {
      var I = fe - fe % 5;
      return O = (U & (1 << I) - 1).toString(32), U >>= I, fe -= I, { id: 1 << 32 - Rt(D) + fe | N << fe | U, overflow: O + x };
    }
    return { id: 1 << O | N << fe | U, overflow: x };
  }
  var Rt = Math.clz32 ? Math.clz32 : Dt, Lt = Math.log, $t = Math.LN2;
  function Dt(x) {
    return x >>>= 0, x === 0 ? 32 : 31 - (Lt(x) / $t | 0) | 0;
  }
  function Gt(x, D) {
    return x === D && (x !== 0 || 1 / x === 1 / D) || x !== x && D !== D;
  }
  var An = typeof Object.is == "function" ? Object.is : Gt, Ot = null, Xt = null, ht = null, Je = null, Zt = !1, dn = !1, gn = 0, fn = null, vt = 0;
  function Ft() {
    if (Ot === null)
      throw Error(t(321));
    return Ot;
  }
  function mt() {
    if (0 < vt)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function pn() {
    return Je === null ? ht === null ? (Zt = !1, ht = Je = mt()) : (Zt = !0, Je = ht) : Je.next === null ? (Zt = !1, Je = Je.next = mt()) : (Zt = !0, Je = Je.next), Je;
  }
  function Sn() {
    Xt = Ot = null, dn = !1, ht = null, vt = 0, Je = fn = null;
  }
  function kt(x, D) {
    return typeof D == "function" ? D(x) : D;
  }
  function wt(x, D, N) {
    if (Ot = Ft(), Je = pn(), Zt) {
      var U = Je.queue;
      if (D = U.dispatch, fn !== null && (N = fn.get(U), N !== void 0)) {
        fn.delete(U), U = Je.memoizedState;
        do
          U = x(U, N.action), N = N.next;
        while (N !== null);
        return Je.memoizedState = U, [U, D];
      }
      return [Je.memoizedState, D];
    }
    return x = x === kt ? typeof D == "function" ? D() : D : N !== void 0 ? N(D) : D, Je.memoizedState = x, x = Je.queue = { last: null, dispatch: null }, x = x.dispatch = xt.bind(null, Ot, x), [Je.memoizedState, x];
  }
  function kn(x, D) {
    if (Ot = Ft(), Je = pn(), D = D === void 0 ? null : D, Je !== null) {
      var N = Je.memoizedState;
      if (N !== null && D !== null) {
        var U = N[1];
        e:
          if (U === null)
            U = !1;
          else {
            for (var fe = 0; fe < U.length && fe < D.length; fe++)
              if (!An(D[fe], U[fe])) {
                U = !1;
                break e;
              }
            U = !0;
          }
        if (U)
          return N[0];
      }
    }
    return x = x(), Je.memoizedState = [x, D], x;
  }
  function xt(x, D, N) {
    if (25 <= vt)
      throw Error(t(301));
    if (x === Ot)
      if (dn = !0, x = { action: N, next: null }, fn === null && (fn = /* @__PURE__ */ new Map()), N = fn.get(D), N === void 0)
        fn.set(D, x);
      else {
        for (D = N; D.next !== null; )
          D = D.next;
        D.next = x;
      }
  }
  function Pt() {
    throw Error(t(394));
  }
  function bn() {
  }
  var On = { readContext: function(x) {
    return x._currentValue2;
  }, useContext: function(x) {
    return Ft(), x._currentValue2;
  }, useMemo: kn, useReducer: wt, useRef: function(x) {
    Ot = Ft(), Je = pn();
    var D = Je.memoizedState;
    return D === null ? (x = { current: x }, Je.memoizedState = x) : D;
  }, useState: function(x) {
    return wt(kt, x);
  }, useInsertionEffect: bn, useLayoutEffect: function() {
  }, useCallback: function(x, D) {
    return kn(function() {
      return x;
    }, D);
  }, useImperativeHandle: bn, useEffect: bn, useDebugValue: bn, useDeferredValue: function(x) {
    return Ft(), x;
  }, useTransition: function() {
    return Ft(), [
      !1,
      Pt
    ];
  }, useId: function() {
    var x = Xt.treeContext, D = x.overflow;
    x = x.id, x = (x & ~(1 << 32 - Rt(x) - 1)).toString(32) + D;
    var N = _e;
    if (N === null)
      throw Error(t(404));
    return D = gn++, x = ":" + N.idPrefix + "R" + x, 0 < D && (x += "H" + D.toString(32)), x + ":";
  }, useMutableSource: function(x, D) {
    return Ft(), D(x._source);
  }, useSyncExternalStore: function(x, D, N) {
    if (N === void 0)
      throw Error(t(407));
    return N();
  } }, _e = null, Oe = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function Se(x) {
    return console.error(x), null;
  }
  function ut() {
  }
  function Kt(x, D, N, U, fe, O, I, Q, ge) {
    var ze = [], Ke = /* @__PURE__ */ new Set();
    return D = { destination: null, responseState: D, progressiveChunkSize: U === void 0 ? 12800 : U, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Ke, pingedTasks: ze, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: fe === void 0 ? Se : fe, onAllReady: O === void 0 ? ut : O, onShellReady: I === void 0 ? ut : I, onShellError: Q === void 0 ? ut : Q, onFatalError: ge === void 0 ? ut : ge }, N = yt(D, 0, null, N, !1, !1), N.parentFlushed = !0, x = Ht(D, x, null, N, Ke, Ve, null, It), ze.push(x), D;
  }
  function Ht(x, D, N, U, fe, O, I, Q) {
    x.allPendingTasks++, N === null ? x.pendingRootTasks++ : N.pendingTasks++;
    var ge = { node: D, ping: function() {
      var ze = x.pingedTasks;
      ze.push(ge), ze.length === 1 && ln(x);
    }, blockedBoundary: N, blockedSegment: U, abortSet: fe, legacyContext: O, context: I, treeContext: Q };
    return fe.add(ge), ge;
  }
  function yt(x, D, N, U, fe, O) {
    return { status: 0, id: -1, index: D, parentFlushed: !1, chunks: [], children: [], formatContext: U, boundary: N, lastPushedText: fe, textEmbedded: O };
  }
  function Bt(x, D) {
    if (x = x.onError(D), x != null && typeof x != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof x + '" instead');
    return x;
  }
  function bt(x, D) {
    var N = x.onShellError;
    N(D), N = x.onFatalError, N(D), x.destination !== null ? (x.status = 2, x.destination.destroy(D)) : (x.status = 1, x.fatalError = D);
  }
  function Tt(x, D, N, U, fe) {
    for (Ot = {}, Xt = D, gn = 0, x = N(U, fe); dn; )
      dn = !1, gn = 0, vt += 1, Je = null, x = N(U, fe);
    return Sn(), x;
  }
  function Pn(x, D, N, U) {
    var fe = N.render(), O = U.childContextTypes;
    if (O != null) {
      var I = D.legacyContext;
      if (typeof N.getChildContext != "function")
        U = I;
      else {
        N = N.getChildContext();
        for (var Q in N)
          if (!(Q in O))
            throw Error(t(108, qe(U) || "Unknown", Q));
        U = ee({}, I, N);
      }
      D.legacyContext = U, Nt(x, D, fe), D.legacyContext = I;
    } else
      Nt(x, D, fe);
  }
  function tn(x, D) {
    if (x && x.defaultProps) {
      D = ee({}, D), x = x.defaultProps;
      for (var N in x)
        D[N] === void 0 && (D[N] = x[N]);
      return D;
    }
    return D;
  }
  function Qt(x, D, N, U, fe) {
    if (typeof N == "function")
      if (N.prototype && N.prototype.isReactComponent) {
        fe = Ge(N, D.legacyContext);
        var O = N.contextType;
        O = new N(U, typeof O == "object" && O !== null ? O._currentValue2 : fe), Ut(O, N, U, fe), Pn(x, D, O, N);
      } else {
        O = Ge(N, D.legacyContext), fe = Tt(x, D, N, U, O);
        var I = gn !== 0;
        if (typeof fe == "object" && fe !== null && typeof fe.render == "function" && fe.$$typeof === void 0)
          Ut(fe, N, U, O), Pn(x, D, fe, N);
        else if (I) {
          U = D.treeContext, D.treeContext = _t(U, 1, 0);
          try {
            Nt(x, D, fe);
          } finally {
            D.treeContext = U;
          }
        } else
          Nt(x, D, fe);
      }
    else if (typeof N == "string") {
      switch (fe = D.blockedSegment, O = le(fe.chunks, N, U, x.responseState, fe.formatContext), fe.lastPushedText = !1, I = fe.formatContext, fe.formatContext = P(I, N, U), wn(x, D, O), fe.formatContext = I, N) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          fe.chunks.push("</", N, ">");
      }
      fe.lastPushedText = !1;
    } else {
      switch (N) {
        case Ze:
        case He:
        case Te:
        case ye:
        case ve:
          Nt(x, D, U.children);
          return;
        case Pe:
          Nt(x, D, U.children);
          return;
        case Ne:
          throw Error(t(343));
        case xe:
          e: {
            N = D.blockedBoundary, fe = D.blockedSegment, O = U.fallback, U = U.children, I = /* @__PURE__ */ new Set();
            var Q = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: I, errorDigest: null }, ge = yt(x, fe.chunks.length, Q, fe.formatContext, !1, !1);
            fe.children.push(ge), fe.lastPushedText = !1;
            var ze = yt(x, 0, null, fe.formatContext, !1, !1);
            ze.parentFlushed = !0, D.blockedBoundary = Q, D.blockedSegment = ze;
            try {
              if (wn(
                x,
                D,
                U
              ), x.responseState.generateStaticMarkup || ze.lastPushedText && ze.textEmbedded && ze.chunks.push("<!-- -->"), ze.status = 1, Ln(Q, ze), Q.pendingTasks === 0)
                break e;
            } catch (Ke) {
              ze.status = 4, Q.forceClientRender = !0, Q.errorDigest = Bt(x, Ke);
            } finally {
              D.blockedBoundary = N, D.blockedSegment = fe;
            }
            D = Ht(x, O, N, ge, I, D.legacyContext, D.context, D.treeContext), x.pingedTasks.push(D);
          }
          return;
      }
      if (typeof N == "object" && N !== null)
        switch (N.$$typeof) {
          case Ce:
            if (U = Tt(x, D, N.render, U, fe), gn !== 0) {
              N = D.treeContext, D.treeContext = _t(N, 1, 0);
              try {
                Nt(x, D, U);
              } finally {
                D.treeContext = N;
              }
            } else
              Nt(x, D, U);
            return;
          case de:
            N = N.type, U = tn(N, U), Qt(x, D, N, U, fe);
            return;
          case Re:
            if (fe = U.children, N = N._context, U = U.value, O = N._currentValue2, N._currentValue2 = U, I = ke, ke = U = { parent: I, depth: I === null ? 0 : I.depth + 1, context: N, parentValue: O, value: U }, D.context = U, Nt(x, D, fe), x = ke, x === null)
              throw Error(t(403));
            U = x.parentValue, x.context._currentValue2 = U === $e ? x.context._defaultValue : U, x = ke = x.parent, D.context = x;
            return;
          case Xe:
            U = U.children, U = U(N._currentValue2), Nt(x, D, U);
            return;
          case Be:
            fe = N._init, N = fe(N._payload), U = tn(N, U), Qt(
              x,
              D,
              N,
              U,
              void 0
            );
            return;
        }
      throw Error(t(130, N == null ? N : typeof N, ""));
    }
  }
  function Nt(x, D, N) {
    if (D.node = N, typeof N == "object" && N !== null) {
      switch (N.$$typeof) {
        case $:
          Qt(x, D, N.type, N.props, N.ref);
          return;
        case pe:
          throw Error(t(257));
        case Be:
          var U = N._init;
          N = U(N._payload), Nt(x, D, N);
          return;
      }
      if (v(N)) {
        Jt(x, D, N);
        return;
      }
      if (N === null || typeof N != "object" ? U = null : (U = Ye && N[Ye] || N["@@iterator"], U = typeof U == "function" ? U : null), U && (U = U.call(N))) {
        if (N = U.next(), !N.done) {
          var fe = [];
          do
            fe.push(N.value), N = U.next();
          while (!N.done);
          Jt(x, D, fe);
        }
        return;
      }
      throw x = Object.prototype.toString.call(N), Error(t(31, x === "[object Object]" ? "object with keys {" + Object.keys(N).join(", ") + "}" : x));
    }
    typeof N == "string" ? (U = D.blockedSegment, U.lastPushedText = K(D.blockedSegment.chunks, N, x.responseState, U.lastPushedText)) : typeof N == "number" && (U = D.blockedSegment, U.lastPushedText = K(D.blockedSegment.chunks, "" + N, x.responseState, U.lastPushedText));
  }
  function Jt(x, D, N) {
    for (var U = N.length, fe = 0; fe < U; fe++) {
      var O = D.treeContext;
      D.treeContext = _t(O, U, fe);
      try {
        wn(x, D, N[fe]);
      } finally {
        D.treeContext = O;
      }
    }
  }
  function wn(x, D, N) {
    var U = D.blockedSegment.formatContext, fe = D.legacyContext, O = D.context;
    try {
      return Nt(x, D, N);
    } catch (ge) {
      if (Sn(), typeof ge == "object" && ge !== null && typeof ge.then == "function") {
        N = ge;
        var I = D.blockedSegment, Q = yt(x, I.chunks.length, null, I.formatContext, I.lastPushedText, !0);
        I.children.push(Q), I.lastPushedText = !1, x = Ht(x, D.node, D.blockedBoundary, Q, D.abortSet, D.legacyContext, D.context, D.treeContext).ping, N.then(x, x), D.blockedSegment.formatContext = U, D.legacyContext = fe, D.context = O, lt(O);
      } else
        throw D.blockedSegment.formatContext = U, D.legacyContext = fe, D.context = O, lt(O), ge;
    }
  }
  function on(x) {
    var D = x.blockedBoundary;
    x = x.blockedSegment, x.status = 3, Tn(this, D, x);
  }
  function Wn(x, D, N) {
    var U = x.blockedBoundary;
    x.blockedSegment.status = 3, U === null ? (D.allPendingTasks--, D.status !== 2 && (D.status = 2, D.destination !== null && D.destination.push(null))) : (U.pendingTasks--, U.forceClientRender || (U.forceClientRender = !0, x = N === void 0 ? Error(t(432)) : N, U.errorDigest = D.onError(x), U.parentFlushed && D.clientRenderedBoundaries.push(U)), U.fallbackAbortableTasks.forEach(function(fe) {
      return Wn(fe, D, N);
    }), U.fallbackAbortableTasks.clear(), D.allPendingTasks--, D.allPendingTasks === 0 && (U = D.onAllReady, U()));
  }
  function Ln(x, D) {
    if (D.chunks.length === 0 && D.children.length === 1 && D.children[0].boundary === null) {
      var N = D.children[0];
      N.id = D.id, N.parentFlushed = !0, N.status === 1 && Ln(x, N);
    } else
      x.completedSegments.push(D);
  }
  function Tn(x, D, N) {
    if (D === null) {
      if (N.parentFlushed) {
        if (x.completedRootSegment !== null)
          throw Error(t(389));
        x.completedRootSegment = N;
      }
      x.pendingRootTasks--, x.pendingRootTasks === 0 && (x.onShellError = ut, D = x.onShellReady, D());
    } else
      D.pendingTasks--, D.forceClientRender || (D.pendingTasks === 0 ? (N.parentFlushed && N.status === 1 && Ln(D, N), D.parentFlushed && x.completedBoundaries.push(D), D.fallbackAbortableTasks.forEach(on, x), D.fallbackAbortableTasks.clear()) : N.parentFlushed && N.status === 1 && (Ln(D, N), D.completedSegments.length === 1 && D.parentFlushed && x.partialBoundaries.push(D)));
    x.allPendingTasks--, x.allPendingTasks === 0 && (x = x.onAllReady, x());
  }
  function ln(x) {
    if (x.status !== 2) {
      var D = ke, N = Oe.current;
      Oe.current = On;
      var U = _e;
      _e = x.responseState;
      try {
        var fe = x.pingedTasks, O;
        for (O = 0; O < fe.length; O++) {
          var I = fe[O], Q = x, ge = I.blockedSegment;
          if (ge.status === 0) {
            lt(I.context);
            try {
              Nt(Q, I, I.node), Q.responseState.generateStaticMarkup || ge.lastPushedText && ge.textEmbedded && ge.chunks.push("<!-- -->"), I.abortSet.delete(I), ge.status = 1, Tn(Q, I.blockedBoundary, ge);
            } catch (nn) {
              if (Sn(), typeof nn == "object" && nn !== null && typeof nn.then == "function") {
                var ze = I.ping;
                nn.then(ze, ze);
              } else {
                I.abortSet.delete(I), ge.status = 4;
                var Ke = I.blockedBoundary, ot = nn, Yt = Bt(Q, ot);
                if (Ke === null ? bt(Q, ot) : (Ke.pendingTasks--, Ke.forceClientRender || (Ke.forceClientRender = !0, Ke.errorDigest = Yt, Ke.parentFlushed && Q.clientRenderedBoundaries.push(Ke))), Q.allPendingTasks--, Q.allPendingTasks === 0) {
                  var Vt = Q.onAllReady;
                  Vt();
                }
              }
            } finally {
            }
          }
        }
        fe.splice(0, O), x.destination !== null && hn(x, x.destination);
      } catch (nn) {
        Bt(x, nn), bt(x, nn);
      } finally {
        _e = U, Oe.current = N, N === On && lt(D);
      }
    }
  }
  function Dn(x, D, N) {
    switch (N.parentFlushed = !0, N.status) {
      case 0:
        var U = N.id = x.nextSegmentId++;
        return N.lastPushedText = !1, N.textEmbedded = !1, x = x.responseState, D.push('<template id="'), D.push(x.placeholderPrefix), x = U.toString(16), D.push(x), D.push('"></template>');
      case 1:
        N.status = 2;
        var fe = !0;
        U = N.chunks;
        var O = 0;
        N = N.children;
        for (var I = 0; I < N.length; I++) {
          for (fe = N[I]; O < fe.index; O++)
            D.push(U[O]);
          fe = _n(x, D, fe);
        }
        for (; O < U.length - 1; O++)
          D.push(U[O]);
        return O < U.length && (fe = D.push(U[O])), fe;
      default:
        throw Error(t(390));
    }
  }
  function _n(x, D, N) {
    var U = N.boundary;
    if (U === null)
      return Dn(x, D, N);
    if (U.parentFlushed = !0, U.forceClientRender)
      return x.responseState.generateStaticMarkup || (U = U.errorDigest, D.push("<!--$!-->"), D.push("<template"), U && (D.push(' data-dgst="'), U = S(U), D.push(U), D.push('"')), D.push("></template>")), Dn(x, D, N), x = x.responseState.generateStaticMarkup ? !0 : D.push("<!--/$-->"), x;
    if (0 < U.pendingTasks) {
      U.rootSegmentID = x.nextSegmentId++, 0 < U.completedSegments.length && x.partialBoundaries.push(U);
      var fe = x.responseState, O = fe.nextSuspenseID++;
      return fe = fe.boundaryPrefix + O.toString(16), U = U.id = fe, B(D, x.responseState, U), Dn(x, D, N), D.push("<!--/$-->");
    }
    if (U.byteSize > x.progressiveChunkSize)
      return U.rootSegmentID = x.nextSegmentId++, x.completedBoundaries.push(U), B(D, x.responseState, U.id), Dn(x, D, N), D.push("<!--/$-->");
    if (x.responseState.generateStaticMarkup || D.push("<!--$-->"), N = U.completedSegments, N.length !== 1)
      throw Error(t(391));
    return _n(x, D, N[0]), x = x.responseState.generateStaticMarkup ? !0 : D.push("<!--/$-->"), x;
  }
  function Fn(x, D, N) {
    return X(D, x.responseState, N.formatContext, N.id), _n(x, D, N), ue(D, N.formatContext);
  }
  function Kn(x, D, N) {
    for (var U = N.completedSegments, fe = 0; fe < U.length; fe++)
      sn(x, D, N, U[fe]);
    if (U.length = 0, x = x.responseState, U = N.id, N = N.rootSegmentID, D.push(x.startInlineScript), x.sentCompleteBoundaryFunction ? D.push('$RC("') : (x.sentCompleteBoundaryFunction = !0, D.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), U === null)
      throw Error(t(395));
    return N = N.toString(16), D.push(U), D.push('","'), D.push(x.segmentPrefix), D.push(N), D.push('")<\/script>');
  }
  function sn(x, D, N, U) {
    if (U.status === 2)
      return !0;
    var fe = U.id;
    if (fe === -1) {
      if ((U.id = N.rootSegmentID) === -1)
        throw Error(t(392));
      return Fn(x, D, U);
    }
    return Fn(x, D, U), x = x.responseState, D.push(x.startInlineScript), x.sentCompleteSegmentFunction ? D.push('$RS("') : (x.sentCompleteSegmentFunction = !0, D.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), D.push(x.segmentPrefix), fe = fe.toString(16), D.push(fe), D.push('","'), D.push(x.placeholderPrefix), D.push(fe), D.push('")<\/script>');
  }
  function hn(x, D) {
    try {
      var N = x.completedRootSegment;
      if (N !== null && x.pendingRootTasks === 0) {
        _n(x, D, N), x.completedRootSegment = null;
        var U = x.responseState.bootstrapChunks;
        for (N = 0; N < U.length - 1; N++)
          D.push(U[N]);
        N < U.length && D.push(U[N]);
      }
      var fe = x.clientRenderedBoundaries, O;
      for (O = 0; O < fe.length; O++) {
        var I = fe[O];
        U = D;
        var Q = x.responseState, ge = I.id, ze = I.errorDigest, Ke = I.errorMessage, ot = I.errorComponentStack;
        if (U.push(Q.startInlineScript), Q.sentClientRenderFunction ? U.push('$RX("') : (Q.sentClientRenderFunction = !0, U.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), ge === null)
          throw Error(t(395));
        if (U.push(ge), U.push('"'), ze || Ke || ot) {
          U.push(",");
          var Yt = J(ze || "");
          U.push(Yt);
        }
        if (Ke || ot) {
          U.push(",");
          var Vt = J(Ke || "");
          U.push(Vt);
        }
        if (ot) {
          U.push(",");
          var nn = J(ot);
          U.push(nn);
        }
        if (!U.push(")<\/script>")) {
          x.destination = null, O++, fe.splice(0, O);
          return;
        }
      }
      fe.splice(0, O);
      var rn = x.completedBoundaries;
      for (O = 0; O < rn.length; O++)
        if (!Kn(x, D, rn[O])) {
          x.destination = null, O++, rn.splice(0, O);
          return;
        }
      rn.splice(0, O);
      var an = x.partialBoundaries;
      for (O = 0; O < an.length; O++) {
        var jn = an[O];
        e: {
          fe = x, I = D;
          var Jn = jn.completedSegments;
          for (Q = 0; Q < Jn.length; Q++)
            if (!sn(fe, I, jn, Jn[Q])) {
              Q++, Jn.splice(0, Q);
              var er = !1;
              break e;
            }
          Jn.splice(0, Q), er = !0;
        }
        if (!er) {
          x.destination = null, O++, an.splice(0, O);
          return;
        }
      }
      an.splice(0, O);
      var Yn = x.completedBoundaries;
      for (O = 0; O < Yn.length; O++)
        if (!Kn(x, D, Yn[O])) {
          x.destination = null, O++, Yn.splice(0, O);
          return;
        }
      Yn.splice(0, O);
    } finally {
      x.allPendingTasks === 0 && x.pingedTasks.length === 0 && x.clientRenderedBoundaries.length === 0 && x.completedBoundaries.length === 0 && D.push(null);
    }
  }
  function ir(x, D) {
    try {
      var N = x.abortableTasks;
      N.forEach(function(U) {
        return Wn(U, x, D);
      }), N.clear(), x.destination !== null && hn(x, x.destination);
    } catch (U) {
      Bt(x, U), bt(x, U);
    }
  }
  function Zn() {
  }
  function Qn(x, D, N, U) {
    var fe = !1, O = null, I = "", Q = { push: function(ze) {
      return ze !== null && (I += ze), !0;
    }, destroy: function(ze) {
      fe = !0, O = ze;
    } }, ge = !1;
    if (x = Kt(x, W(N, D ? D.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, Zn, void 0, function() {
      ge = !0;
    }, void 0, void 0), ln(x), ir(x, U), x.status === 1)
      x.status = 2, Q.destroy(x.fatalError);
    else if (x.status !== 2 && x.destination === null) {
      x.destination = Q;
      try {
        hn(x, Q);
      } catch (ze) {
        Bt(x, ze), bt(x, ze);
      }
    }
    if (fe)
      throw O;
    if (!ge)
      throw Error(t(426));
    return I;
  }
  return Ni.renderToNodeStream = function() {
    throw Error(t(207));
  }, Ni.renderToStaticMarkup = function(x, D) {
    return Qn(x, D, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Ni.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, Ni.renderToString = function(x, D) {
    return Qn(x, D, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Ni.version = "18.2.0", Ni;
}
var Fu = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Jh;
function xS() {
  if (Jh)
    return Fu;
  Jh = 1;
  var e = se;
  function t(E) {
    for (var F = "https://reactjs.org/docs/error-decoder.html?invariant=" + E, V = 1; V < arguments.length; V++)
      F += "&args[]=" + encodeURIComponent(arguments[V]);
    return "Minified React error #" + E + "; visit " + F + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = null, a = 0;
  function i(E, F) {
    if (F.length !== 0)
      if (512 < F.length)
        0 < a && (E.enqueue(new Uint8Array(r.buffer, 0, a)), r = new Uint8Array(512), a = 0), E.enqueue(F);
      else {
        var V = r.length - a;
        V < F.length && (V === 0 ? E.enqueue(r) : (r.set(F.subarray(0, V), a), E.enqueue(r), F = F.subarray(V)), r = new Uint8Array(512), a = 0), r.set(F, a), a += F.length;
      }
  }
  function o(E, F) {
    return i(E, F), !0;
  }
  function d(E) {
    r && 0 < a && (E.enqueue(new Uint8Array(r.buffer, 0, a)), r = null, a = 0);
  }
  var c = new TextEncoder();
  function s(E) {
    return c.encode(E);
  }
  function p(E) {
    return c.encode(E);
  }
  function y(E, F) {
    typeof E.error == "function" ? E.error(F) : E.close();
  }
  var g = Object.prototype.hasOwnProperty, b = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, w = {}, S = {};
  function L(E) {
    return g.call(S, E) ? !0 : g.call(w, E) ? !1 : b.test(E) ? S[E] = !0 : (w[E] = !0, !1);
  }
  function m(E, F, V, re, we, Ee, Fe) {
    this.acceptsBooleans = F === 2 || F === 3 || F === 4, this.attributeName = re, this.attributeNamespace = we, this.mustUseProperty = V, this.propertyName = E, this.type = F, this.sanitizeURL = Ee, this.removeEmptyString = Fe;
  }
  var v = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(E) {
    v[E] = new m(E, 0, !1, E, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(E) {
    var F = E[0];
    v[F] = new m(F, 1, !1, E[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(E) {
    v[E] = new m(E, 2, !1, E.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(E) {
    v[E] = new m(E, 2, !1, E, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(E) {
    v[E] = new m(E, 3, !1, E.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(E) {
    v[E] = new m(E, 3, !0, E, null, !1, !1);
  }), ["capture", "download"].forEach(function(E) {
    v[E] = new m(E, 4, !1, E, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(E) {
    v[E] = new m(E, 6, !1, E, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(E) {
    v[E] = new m(E, 5, !1, E.toLowerCase(), null, !1, !1);
  });
  var A = /[\-:]([a-z])/g;
  function P(E) {
    return E[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(E) {
    var F = E.replace(
      A,
      P
    );
    v[F] = new m(F, 1, !1, E, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(E) {
    var F = E.replace(A, P);
    v[F] = new m(F, 1, !1, E, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(E) {
    var F = E.replace(A, P);
    v[F] = new m(F, 1, !1, E, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(E) {
    v[E] = new m(E, 1, !1, E.toLowerCase(), null, !1, !1);
  }), v.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(E) {
    v[E] = new m(E, 1, !1, E.toLowerCase(), null, !0, !0);
  });
  var T = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, _ = ["Webkit", "ms", "Moz", "O"];
  Object.keys(T).forEach(function(E) {
    _.forEach(function(F) {
      F = F + E.charAt(0).toUpperCase() + E.substring(1), T[F] = T[E];
    });
  });
  var M = /["'&<>]/;
  function Z(E) {
    if (typeof E == "boolean" || typeof E == "number")
      return "" + E;
    E = "" + E;
    var F = M.exec(E);
    if (F) {
      var V = "", re, we = 0;
      for (re = F.index; re < E.length; re++) {
        switch (E.charCodeAt(re)) {
          case 34:
            F = "&quot;";
            break;
          case 38:
            F = "&amp;";
            break;
          case 39:
            F = "&#x27;";
            break;
          case 60:
            F = "&lt;";
            break;
          case 62:
            F = "&gt;";
            break;
          default:
            continue;
        }
        we !== re && (V += E.substring(we, re)), we = re + 1, V += F;
      }
      E = we !== re ? V + E.substring(we, re) : V;
    }
    return E;
  }
  var Y = /([A-Z])/g, ae = /^ms-/, j = Array.isArray, q = p("<script>"), te = p("<\/script>"), le = p('<script src="'), B = p('<script type="module" src="'), X = p('" async=""><\/script>'), ue = /(<\/|<)(s)(cript)/gi;
  function ne(E, F, V, re) {
    return "" + F + (V === "s" ? "\\u0073" : "\\u0053") + re;
  }
  function J(E, F, V, re, we) {
    E = E === void 0 ? "" : E, F = F === void 0 ? q : p('<script nonce="' + Z(F) + '">');
    var Ee = [];
    if (V !== void 0 && Ee.push(F, s(("" + V).replace(ue, ne)), te), re !== void 0)
      for (V = 0; V < re.length; V++)
        Ee.push(le, s(Z(re[V])), X);
    if (we !== void 0)
      for (re = 0; re < we.length; re++)
        Ee.push(B, s(Z(we[re])), X);
    return { bootstrapChunks: Ee, startInlineScript: F, placeholderPrefix: p(E + "P:"), segmentPrefix: p(E + "S:"), boundaryPrefix: E + "B:", idPrefix: E, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function W(E, F) {
    return { insertionMode: E, selectedValue: F };
  }
  function K(E) {
    return W(E === "http://www.w3.org/2000/svg" ? 2 : E === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function ee(E, F, V) {
    switch (F) {
      case "select":
        return W(1, V.value != null ? V.value : V.defaultValue);
      case "svg":
        return W(2, null);
      case "math":
        return W(3, null);
      case "foreignObject":
        return W(1, null);
      case "table":
        return W(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return W(5, null);
      case "colgroup":
        return W(7, null);
      case "tr":
        return W(6, null);
    }
    return 4 <= E.insertionMode || E.insertionMode === 0 ? W(1, null) : E;
  }
  var $ = p("<!-- -->");
  function pe(E, F, V, re) {
    return F === "" ? re : (re && E.push($), E.push(s(Z(F))), !0);
  }
  var ve = /* @__PURE__ */ new Map(), Te = p(' style="'), ye = p(":"), Re = p(";");
  function Xe(E, F, V) {
    if (typeof V != "object")
      throw Error(t(62));
    F = !0;
    for (var re in V)
      if (g.call(V, re)) {
        var we = V[re];
        if (we != null && typeof we != "boolean" && we !== "") {
          if (re.indexOf("--") === 0) {
            var Ee = s(Z(re));
            we = s(Z(("" + we).trim()));
          } else {
            Ee = re;
            var Fe = ve.get(Ee);
            Fe !== void 0 || (Fe = p(Z(Ee.replace(Y, "-$1").toLowerCase().replace(ae, "-ms-"))), ve.set(Ee, Fe)), Ee = Fe, we = typeof we == "number" ? we === 0 || g.call(T, re) ? s("" + we) : s(we + "px") : s(Z(("" + we).trim()));
          }
          F ? (F = !1, E.push(Te, Ee, ye, we)) : E.push(Re, Ee, ye, we);
        }
      }
    F || E.push(Pe);
  }
  var Ce = p(" "), xe = p('="'), Pe = p('"'), de = p('=""');
  function Be(E, F, V, re) {
    switch (V) {
      case "style":
        Xe(E, F, re);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < V.length) || V[0] !== "o" && V[0] !== "O" || V[1] !== "n" && V[1] !== "N") {
      if (F = v.hasOwnProperty(V) ? v[V] : null, F !== null) {
        switch (typeof re) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!F.acceptsBooleans)
              return;
        }
        switch (V = s(F.attributeName), F.type) {
          case 3:
            re && E.push(Ce, V, de);
            break;
          case 4:
            re === !0 ? E.push(Ce, V, de) : re !== !1 && E.push(Ce, V, xe, s(Z(re)), Pe);
            break;
          case 5:
            isNaN(re) || E.push(Ce, V, xe, s(Z(re)), Pe);
            break;
          case 6:
            !isNaN(re) && 1 <= re && E.push(Ce, V, xe, s(Z(re)), Pe);
            break;
          default:
            F.sanitizeURL && (re = "" + re), E.push(Ce, V, xe, s(Z(re)), Pe);
        }
      } else if (L(V)) {
        switch (typeof re) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (F = V.toLowerCase().slice(0, 5), F !== "data-" && F !== "aria-")
              return;
        }
        E.push(Ce, s(V), xe, s(Z(re)), Pe);
      }
    }
  }
  var Ne = p(">"), He = p("/>");
  function Ze(E, F, V) {
    if (F != null) {
      if (V != null)
        throw Error(t(60));
      if (typeof F != "object" || !("__html" in F))
        throw Error(t(61));
      F = F.__html, F != null && E.push(s("" + F));
    }
  }
  function $e(E) {
    var F = "";
    return e.Children.forEach(E, function(V) {
      V != null && (F += V);
    }), F;
  }
  var Ye = p(' selected=""');
  function qe(E, F, V, re) {
    E.push(De(V));
    var we = V = null, Ee;
    for (Ee in F)
      if (g.call(F, Ee)) {
        var Fe = F[Ee];
        if (Fe != null)
          switch (Ee) {
            case "children":
              V = Fe;
              break;
            case "dangerouslySetInnerHTML":
              we = Fe;
              break;
            default:
              Be(E, re, Ee, Fe);
          }
      }
    return E.push(Ne), Ze(E, we, V), typeof V == "string" ? (E.push(s(Z(V))), null) : V;
  }
  var Ve = p(`
`), Ge = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, ke = /* @__PURE__ */ new Map();
  function De(E) {
    var F = ke.get(E);
    if (F === void 0) {
      if (!Ge.test(E))
        throw Error(t(65, E));
      F = p("<" + E), ke.set(E, F);
    }
    return F;
  }
  var at = p("<!DOCTYPE html>");
  function be(E, F, V, re, we) {
    switch (F) {
      case "select":
        E.push(De("select"));
        var Ee = null, Fe = null;
        for (Et in V)
          if (g.call(V, Et)) {
            var je = V[Et];
            if (je != null)
              switch (Et) {
                case "children":
                  Ee = je;
                  break;
                case "dangerouslySetInnerHTML":
                  Fe = je;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  Be(E, re, Et, je);
              }
          }
        return E.push(Ne), Ze(E, Fe, Ee), Ee;
      case "option":
        Fe = we.selectedValue, E.push(De("option"));
        var pt = je = null, Ct = null, Et = null;
        for (Ee in V)
          if (g.call(V, Ee)) {
            var un = V[Ee];
            if (un != null)
              switch (Ee) {
                case "children":
                  je = un;
                  break;
                case "selected":
                  Ct = un;
                  break;
                case "dangerouslySetInnerHTML":
                  Et = un;
                  break;
                case "value":
                  pt = un;
                default:
                  Be(E, re, Ee, un);
              }
          }
        if (Fe != null)
          if (V = pt !== null ? "" + pt : $e(je), j(Fe)) {
            for (re = 0; re < Fe.length; re++)
              if ("" + Fe[re] === V) {
                E.push(Ye);
                break;
              }
          } else
            "" + Fe === V && E.push(Ye);
        else
          Ct && E.push(Ye);
        return E.push(Ne), Ze(E, Et, je), je;
      case "textarea":
        E.push(De("textarea")), Et = Fe = Ee = null;
        for (je in V)
          if (g.call(V, je) && (pt = V[je], pt != null))
            switch (je) {
              case "children":
                Et = pt;
                break;
              case "value":
                Ee = pt;
                break;
              case "defaultValue":
                Fe = pt;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                Be(E, re, je, pt);
            }
        if (Ee === null && Fe !== null && (Ee = Fe), E.push(Ne), Et != null) {
          if (Ee != null)
            throw Error(t(92));
          if (j(Et) && 1 < Et.length)
            throw Error(t(93));
          Ee = "" + Et;
        }
        return typeof Ee == "string" && Ee[0] === `
` && E.push(Ve), Ee !== null && E.push(s(Z("" + Ee))), null;
      case "input":
        E.push(De("input")), pt = Et = je = Ee = null;
        for (Fe in V)
          if (g.call(V, Fe) && (Ct = V[Fe], Ct != null))
            switch (Fe) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                pt = Ct;
                break;
              case "defaultValue":
                je = Ct;
                break;
              case "checked":
                Et = Ct;
                break;
              case "value":
                Ee = Ct;
                break;
              default:
                Be(E, re, Fe, Ct);
            }
        return Et !== null ? Be(
          E,
          re,
          "checked",
          Et
        ) : pt !== null && Be(E, re, "checked", pt), Ee !== null ? Be(E, re, "value", Ee) : je !== null && Be(E, re, "value", je), E.push(He), null;
      case "menuitem":
        E.push(De("menuitem"));
        for (var qn in V)
          if (g.call(V, qn) && (Ee = V[qn], Ee != null))
            switch (qn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                Be(E, re, qn, Ee);
            }
        return E.push(Ne), null;
      case "title":
        E.push(De("title")), Ee = null;
        for (un in V)
          if (g.call(V, un) && (Fe = V[un], Fe != null))
            switch (un) {
              case "children":
                Ee = Fe;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                Be(E, re, un, Fe);
            }
        return E.push(Ne), Ee;
      case "listing":
      case "pre":
        E.push(De(F)), Fe = Ee = null;
        for (pt in V)
          if (g.call(V, pt) && (je = V[pt], je != null))
            switch (pt) {
              case "children":
                Ee = je;
                break;
              case "dangerouslySetInnerHTML":
                Fe = je;
                break;
              default:
                Be(E, re, pt, je);
            }
        if (E.push(Ne), Fe != null) {
          if (Ee != null)
            throw Error(t(60));
          if (typeof Fe != "object" || !("__html" in Fe))
            throw Error(t(61));
          V = Fe.__html, V != null && (typeof V == "string" && 0 < V.length && V[0] === `
` ? E.push(Ve, s(V)) : E.push(s("" + V)));
        }
        return typeof Ee == "string" && Ee[0] === `
` && E.push(Ve), Ee;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        E.push(De(F));
        for (var sr in V)
          if (g.call(V, sr) && (Ee = V[sr], Ee != null))
            switch (sr) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, F));
              default:
                Be(E, re, sr, Ee);
            }
        return E.push(He), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return qe(E, V, F, re);
      case "html":
        return we.insertionMode === 0 && E.push(at), qe(E, V, F, re);
      default:
        if (F.indexOf("-") === -1 && typeof V.is != "string")
          return qe(E, V, F, re);
        E.push(De(F)), Fe = Ee = null;
        for (Ct in V)
          if (g.call(V, Ct) && (je = V[Ct], je != null))
            switch (Ct) {
              case "children":
                Ee = je;
                break;
              case "dangerouslySetInnerHTML":
                Fe = je;
                break;
              case "style":
                Xe(E, re, je);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                L(Ct) && typeof je != "function" && typeof je != "symbol" && E.push(Ce, s(Ct), xe, s(Z(je)), Pe);
            }
        return E.push(Ne), Ze(E, Fe, Ee), Ee;
    }
  }
  var nt = p("</"), st = p(">"), lt = p('<template id="'), St = p('"></template>'), Ut = p("<!--$-->"), It = p('<!--$?--><template id="'), _t = p('"></template>'), Rt = p("<!--$!-->"), Lt = p("<!--/$-->"), $t = p("<template"), Dt = p('"'), Gt = p(' data-dgst="');
  p(' data-msg="'), p(' data-stck="');
  var An = p("></template>");
  function Ot(E, F, V) {
    if (i(E, It), V === null)
      throw Error(t(395));
    return i(E, V), o(E, _t);
  }
  var Xt = p('<div hidden id="'), ht = p('">'), Je = p("</div>"), Zt = p('<svg aria-hidden="true" style="display:none" id="'), dn = p('">'), gn = p("</svg>"), fn = p('<math aria-hidden="true" style="display:none" id="'), vt = p('">'), Ft = p("</math>"), mt = p('<table hidden id="'), pn = p('">'), Sn = p("</table>"), kt = p('<table hidden><tbody id="'), wt = p('">'), kn = p("</tbody></table>"), xt = p('<table hidden><tr id="'), Pt = p('">'), bn = p("</tr></table>"), On = p('<table hidden><colgroup id="'), _e = p('">'), Oe = p("</colgroup></table>");
  function Se(E, F, V, re) {
    switch (V.insertionMode) {
      case 0:
      case 1:
        return i(E, Xt), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, ht);
      case 2:
        return i(E, Zt), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, dn);
      case 3:
        return i(E, fn), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, vt);
      case 4:
        return i(E, mt), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, pn);
      case 5:
        return i(E, kt), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, wt);
      case 6:
        return i(E, xt), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, Pt);
      case 7:
        return i(
          E,
          On
        ), i(E, F.segmentPrefix), i(E, s(re.toString(16))), o(E, _e);
      default:
        throw Error(t(397));
    }
  }
  function ut(E, F) {
    switch (F.insertionMode) {
      case 0:
      case 1:
        return o(E, Je);
      case 2:
        return o(E, gn);
      case 3:
        return o(E, Ft);
      case 4:
        return o(E, Sn);
      case 5:
        return o(E, kn);
      case 6:
        return o(E, bn);
      case 7:
        return o(E, Oe);
      default:
        throw Error(t(397));
    }
  }
  var Kt = p('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Ht = p('$RS("'), yt = p('","'), Bt = p('")<\/script>'), bt = p('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Tt = p('$RC("'), Pn = p('","'), tn = p('")<\/script>'), Qt = p('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Nt = p('$RX("'), Jt = p('"'), wn = p(")<\/script>"), on = p(","), Wn = /[<\u2028\u2029]/g;
  function Ln(E) {
    return JSON.stringify(E).replace(Wn, function(F) {
      switch (F) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var Tn = Object.assign, ln = Symbol.for("react.element"), Dn = Symbol.for("react.portal"), _n = Symbol.for("react.fragment"), Fn = Symbol.for("react.strict_mode"), Kn = Symbol.for("react.profiler"), sn = Symbol.for("react.provider"), hn = Symbol.for("react.context"), ir = Symbol.for("react.forward_ref"), Zn = Symbol.for("react.suspense"), Qn = Symbol.for("react.suspense_list"), x = Symbol.for("react.memo"), D = Symbol.for("react.lazy"), N = Symbol.for("react.scope"), U = Symbol.for("react.debug_trace_mode"), fe = Symbol.for("react.legacy_hidden"), O = Symbol.for("react.default_value"), I = Symbol.iterator;
  function Q(E) {
    if (E == null)
      return null;
    if (typeof E == "function")
      return E.displayName || E.name || null;
    if (typeof E == "string")
      return E;
    switch (E) {
      case _n:
        return "Fragment";
      case Dn:
        return "Portal";
      case Kn:
        return "Profiler";
      case Fn:
        return "StrictMode";
      case Zn:
        return "Suspense";
      case Qn:
        return "SuspenseList";
    }
    if (typeof E == "object")
      switch (E.$$typeof) {
        case hn:
          return (E.displayName || "Context") + ".Consumer";
        case sn:
          return (E._context.displayName || "Context") + ".Provider";
        case ir:
          var F = E.render;
          return E = E.displayName, E || (E = F.displayName || F.name || "", E = E !== "" ? "ForwardRef(" + E + ")" : "ForwardRef"), E;
        case x:
          return F = E.displayName || null, F !== null ? F : Q(E.type) || "Memo";
        case D:
          F = E._payload, E = E._init;
          try {
            return Q(E(F));
          } catch {
          }
      }
    return null;
  }
  var ge = {};
  function ze(E, F) {
    if (E = E.contextTypes, !E)
      return ge;
    var V = {}, re;
    for (re in E)
      V[re] = F[re];
    return V;
  }
  var Ke = null;
  function ot(E, F) {
    if (E !== F) {
      E.context._currentValue = E.parentValue, E = E.parent;
      var V = F.parent;
      if (E === null) {
        if (V !== null)
          throw Error(t(401));
      } else {
        if (V === null)
          throw Error(t(401));
        ot(E, V);
      }
      F.context._currentValue = F.value;
    }
  }
  function Yt(E) {
    E.context._currentValue = E.parentValue, E = E.parent, E !== null && Yt(E);
  }
  function Vt(E) {
    var F = E.parent;
    F !== null && Vt(F), E.context._currentValue = E.value;
  }
  function nn(E, F) {
    if (E.context._currentValue = E.parentValue, E = E.parent, E === null)
      throw Error(t(402));
    E.depth === F.depth ? ot(E, F) : nn(E, F);
  }
  function rn(E, F) {
    var V = F.parent;
    if (V === null)
      throw Error(t(402));
    E.depth === V.depth ? ot(E, V) : rn(E, V), F.context._currentValue = F.value;
  }
  function an(E) {
    var F = Ke;
    F !== E && (F === null ? Vt(E) : E === null ? Yt(F) : F.depth === E.depth ? ot(F, E) : F.depth > E.depth ? nn(F, E) : rn(F, E), Ke = E);
  }
  var jn = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(E, F) {
    E = E._reactInternals, E.queue !== null && E.queue.push(F);
  }, enqueueReplaceState: function(E, F) {
    E = E._reactInternals, E.replace = !0, E.queue = [F];
  }, enqueueForceUpdate: function() {
  } };
  function Jn(E, F, V, re) {
    var we = E.state !== void 0 ? E.state : null;
    E.updater = jn, E.props = V, E.state = we;
    var Ee = { queue: [], replace: !1 };
    E._reactInternals = Ee;
    var Fe = F.contextType;
    if (E.context = typeof Fe == "object" && Fe !== null ? Fe._currentValue : re, Fe = F.getDerivedStateFromProps, typeof Fe == "function" && (Fe = Fe(V, we), we = Fe == null ? we : Tn({}, we, Fe), E.state = we), typeof F.getDerivedStateFromProps != "function" && typeof E.getSnapshotBeforeUpdate != "function" && (typeof E.UNSAFE_componentWillMount == "function" || typeof E.componentWillMount == "function"))
      if (F = E.state, typeof E.componentWillMount == "function" && E.componentWillMount(), typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount(), F !== E.state && jn.enqueueReplaceState(E, E.state, null), Ee.queue !== null && 0 < Ee.queue.length)
        if (F = Ee.queue, Fe = Ee.replace, Ee.queue = null, Ee.replace = !1, Fe && F.length === 1)
          E.state = F[0];
        else {
          for (Ee = Fe ? F[0] : E.state, we = !0, Fe = Fe ? 1 : 0; Fe < F.length; Fe++) {
            var je = F[Fe];
            je = typeof je == "function" ? je.call(E, Ee, V, re) : je, je != null && (we ? (we = !1, Ee = Tn({}, Ee, je)) : Tn(Ee, je));
          }
          E.state = Ee;
        }
      else
        Ee.queue = null;
  }
  var er = { id: 1, overflow: "" };
  function Yn(E, F, V) {
    var re = E.id;
    E = E.overflow;
    var we = 32 - Er(re) - 1;
    re &= ~(1 << we), V += 1;
    var Ee = 32 - Er(F) + we;
    if (30 < Ee) {
      var Fe = we - we % 5;
      return Ee = (re & (1 << Fe) - 1).toString(32), re >>= Fe, we -= Fe, { id: 1 << 32 - Er(F) + we | V << we | re, overflow: Ee + E };
    }
    return { id: 1 << Ee | V << we | re, overflow: E };
  }
  var Er = Math.clz32 ? Math.clz32 : vn, xa = Math.log, At = Math.LN2;
  function vn(E) {
    return E >>>= 0, E === 0 ? 32 : 31 - (xa(E) / At | 0) | 0;
  }
  function ra(E, F) {
    return E === F && (E !== 0 || 1 / E === 1 / F) || E !== E && F !== F;
  }
  var Nr = typeof Object.is == "function" ? Object.is : ra, or = null, Dr = null, Wr = null, Wt = null, mr = !1, Gn = !1, _r = 0, kr = null, ba = 0;
  function wr() {
    if (or === null)
      throw Error(t(321));
    return or;
  }
  function lr() {
    if (0 < ba)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function qa() {
    return Wt === null ? Wr === null ? (mr = !1, Wr = Wt = lr()) : (mr = !0, Wt = Wr) : Wt.next === null ? (mr = !1, Wt = Wt.next = lr()) : (mr = !0, Wt = Wt.next), Wt;
  }
  function Za() {
    Dr = or = null, Gn = !1, Wr = null, ba = 0, Wt = kr = null;
  }
  function Yi(E, F) {
    return typeof F == "function" ? F(E) : F;
  }
  function Gi(E, F, V) {
    if (or = wr(), Wt = qa(), mr) {
      var re = Wt.queue;
      if (F = re.dispatch, kr !== null && (V = kr.get(re), V !== void 0)) {
        kr.delete(re), re = Wt.memoizedState;
        do
          re = E(re, V.action), V = V.next;
        while (V !== null);
        return Wt.memoizedState = re, [re, F];
      }
      return [Wt.memoizedState, F];
    }
    return E = E === Yi ? typeof F == "function" ? F() : F : V !== void 0 ? V(F) : F, Wt.memoizedState = E, E = Wt.queue = { last: null, dispatch: null }, E = E.dispatch = dl.bind(null, or, E), [Wt.memoizedState, E];
  }
  function Xi(E, F) {
    if (or = wr(), Wt = qa(), F = F === void 0 ? null : F, Wt !== null) {
      var V = Wt.memoizedState;
      if (V !== null && F !== null) {
        var re = V[1];
        e:
          if (re === null)
            re = !1;
          else {
            for (var we = 0; we < re.length && we < F.length; we++)
              if (!Nr(F[we], re[we])) {
                re = !1;
                break e;
              }
            re = !0;
          }
        if (re)
          return V[0];
      }
    }
    return E = E(), Wt.memoizedState = [E, F], E;
  }
  function dl(E, F, V) {
    if (25 <= ba)
      throw Error(t(301));
    if (E === or)
      if (Gn = !0, E = { action: V, next: null }, kr === null && (kr = /* @__PURE__ */ new Map()), V = kr.get(F), V === void 0)
        kr.set(F, E);
      else {
        for (F = V; F.next !== null; )
          F = F.next;
        F.next = E;
      }
  }
  function fl() {
    throw Error(t(394));
  }
  function Ea() {
  }
  var Sa = { readContext: function(E) {
    return E._currentValue;
  }, useContext: function(E) {
    return wr(), E._currentValue;
  }, useMemo: Xi, useReducer: Gi, useRef: function(E) {
    or = wr(), Wt = qa();
    var F = Wt.memoizedState;
    return F === null ? (E = { current: E }, Wt.memoizedState = E) : F;
  }, useState: function(E) {
    return Gi(Yi, E);
  }, useInsertionEffect: Ea, useLayoutEffect: function() {
  }, useCallback: function(E, F) {
    return Xi(function() {
      return E;
    }, F);
  }, useImperativeHandle: Ea, useEffect: Ea, useDebugValue: Ea, useDeferredValue: function(E) {
    return wr(), E;
  }, useTransition: function() {
    return wr(), [!1, fl];
  }, useId: function() {
    var E = Dr.treeContext, F = E.overflow;
    E = E.id, E = (E & ~(1 << 32 - Er(E) - 1)).toString(32) + F;
    var V = ka;
    if (V === null)
      throw Error(t(404));
    return F = _r++, E = ":" + V.idPrefix + "R" + E, 0 < F && (E += "H" + F.toString(32)), E + ":";
  }, useMutableSource: function(E, F) {
    return wr(), F(E._source);
  }, useSyncExternalStore: function(E, F, V) {
    if (V === void 0)
      throw Error(t(407));
    return V();
  } }, ka = null, aa = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function pl(E) {
    return console.error(E), null;
  }
  function ia() {
  }
  function Qa(E, F, V, re, we, Ee, Fe, je, pt) {
    var Ct = [], Et = /* @__PURE__ */ new Set();
    return F = { destination: null, responseState: F, progressiveChunkSize: re === void 0 ? 12800 : re, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Et, pingedTasks: Ct, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: we === void 0 ? pl : we, onAllReady: Ee === void 0 ? ia : Ee, onShellReady: Fe === void 0 ? ia : Fe, onShellError: je === void 0 ? ia : je, onFatalError: pt === void 0 ? ia : pt }, V = jr(F, 0, null, V, !1, !1), V.parentFlushed = !0, E = Ja(F, E, null, V, Et, ge, null, er), Ct.push(E), F;
  }
  function Ja(E, F, V, re, we, Ee, Fe, je) {
    E.allPendingTasks++, V === null ? E.pendingRootTasks++ : V.pendingTasks++;
    var pt = { node: F, ping: function() {
      var Ct = E.pingedTasks;
      Ct.push(pt), Ct.length === 1 && to(E);
    }, blockedBoundary: V, blockedSegment: re, abortSet: we, legacyContext: Ee, context: Fe, treeContext: je };
    return we.add(pt), pt;
  }
  function jr(E, F, V, re, we, Ee) {
    return { status: 0, id: -1, index: F, parentFlushed: !1, chunks: [], children: [], formatContext: re, boundary: V, lastPushedText: we, textEmbedded: Ee };
  }
  function Ur(E, F) {
    if (E = E.onError(F), E != null && typeof E != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof E + '" instead');
    return E;
  }
  function wa(E, F) {
    var V = E.onShellError;
    V(F), V = E.onFatalError, V(F), E.destination !== null ? (E.status = 2, y(E.destination, F)) : (E.status = 1, E.fatalError = F);
  }
  function qi(E, F, V, re, we) {
    for (or = {}, Dr = F, _r = 0, E = V(re, we); Gn; )
      Gn = !1, _r = 0, ba += 1, Wt = null, E = V(re, we);
    return Za(), E;
  }
  function ei(E, F, V, re) {
    var we = V.render(), Ee = re.childContextTypes;
    if (Ee != null) {
      var Fe = F.legacyContext;
      if (typeof V.getChildContext != "function")
        re = Fe;
      else {
        V = V.getChildContext();
        for (var je in V)
          if (!(je in Ee))
            throw Error(t(108, Q(re) || "Unknown", je));
        re = Tn({}, Fe, V);
      }
      F.legacyContext = re, Xn(E, F, we), F.legacyContext = Fe;
    } else
      Xn(E, F, we);
  }
  function Zi(E, F) {
    if (E && E.defaultProps) {
      F = Tn({}, F), E = E.defaultProps;
      for (var V in E)
        F[V] === void 0 && (F[V] = E[V]);
      return F;
    }
    return F;
  }
  function Ta(E, F, V, re, we) {
    if (typeof V == "function")
      if (V.prototype && V.prototype.isReactComponent) {
        we = ze(V, F.legacyContext);
        var Ee = V.contextType;
        Ee = new V(re, typeof Ee == "object" && Ee !== null ? Ee._currentValue : we), Jn(Ee, V, re, we), ei(E, F, Ee, V);
      } else {
        Ee = ze(V, F.legacyContext), we = qi(E, F, V, re, Ee);
        var Fe = _r !== 0;
        if (typeof we == "object" && we !== null && typeof we.render == "function" && we.$$typeof === void 0)
          Jn(we, V, re, Ee), ei(E, F, we, V);
        else if (Fe) {
          re = F.treeContext, F.treeContext = Yn(re, 1, 0);
          try {
            Xn(E, F, we);
          } finally {
            F.treeContext = re;
          }
        } else
          Xn(E, F, we);
      }
    else if (typeof V == "string") {
      switch (we = F.blockedSegment, Ee = be(we.chunks, V, re, E.responseState, we.formatContext), we.lastPushedText = !1, Fe = we.formatContext, we.formatContext = ee(Fe, V, re), Ca(E, F, Ee), we.formatContext = Fe, V) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          we.chunks.push(nt, s(V), st);
      }
      we.lastPushedText = !1;
    } else {
      switch (V) {
        case fe:
        case U:
        case Fn:
        case Kn:
        case _n:
          Xn(E, F, re.children);
          return;
        case Qn:
          Xn(E, F, re.children);
          return;
        case N:
          throw Error(t(343));
        case Zn:
          e: {
            V = F.blockedBoundary, we = F.blockedSegment, Ee = re.fallback, re = re.children, Fe = /* @__PURE__ */ new Set();
            var je = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Fe, errorDigest: null }, pt = jr(E, we.chunks.length, je, we.formatContext, !1, !1);
            we.children.push(pt), we.lastPushedText = !1;
            var Ct = jr(E, 0, null, we.formatContext, !1, !1);
            Ct.parentFlushed = !0, F.blockedBoundary = je, F.blockedSegment = Ct;
            try {
              if (Ca(
                E,
                F,
                re
              ), Ct.lastPushedText && Ct.textEmbedded && Ct.chunks.push($), Ct.status = 1, Aa(je, Ct), je.pendingTasks === 0)
                break e;
            } catch (Et) {
              Ct.status = 4, je.forceClientRender = !0, je.errorDigest = Ur(E, Et);
            } finally {
              F.blockedBoundary = V, F.blockedSegment = we;
            }
            F = Ja(E, Ee, V, pt, Fe, F.legacyContext, F.context, F.treeContext), E.pingedTasks.push(F);
          }
          return;
      }
      if (typeof V == "object" && V !== null)
        switch (V.$$typeof) {
          case ir:
            if (re = qi(E, F, V.render, re, we), _r !== 0) {
              V = F.treeContext, F.treeContext = Yn(V, 1, 0);
              try {
                Xn(E, F, re);
              } finally {
                F.treeContext = V;
              }
            } else
              Xn(E, F, re);
            return;
          case x:
            V = V.type, re = Zi(V, re), Ta(E, F, V, re, we);
            return;
          case sn:
            if (we = re.children, V = V._context, re = re.value, Ee = V._currentValue, V._currentValue = re, Fe = Ke, Ke = re = { parent: Fe, depth: Fe === null ? 0 : Fe.depth + 1, context: V, parentValue: Ee, value: re }, F.context = re, Xn(E, F, we), E = Ke, E === null)
              throw Error(t(403));
            re = E.parentValue, E.context._currentValue = re === O ? E.context._defaultValue : re, E = Ke = E.parent, F.context = E;
            return;
          case hn:
            re = re.children, re = re(V._currentValue), Xn(E, F, re);
            return;
          case D:
            we = V._init, V = we(V._payload), re = Zi(V, re), Ta(E, F, V, re, void 0);
            return;
        }
      throw Error(t(
        130,
        V == null ? V : typeof V,
        ""
      ));
    }
  }
  function Xn(E, F, V) {
    if (F.node = V, typeof V == "object" && V !== null) {
      switch (V.$$typeof) {
        case ln:
          Ta(E, F, V.type, V.props, V.ref);
          return;
        case Dn:
          throw Error(t(257));
        case D:
          var re = V._init;
          V = re(V._payload), Xn(E, F, V);
          return;
      }
      if (j(V)) {
        Qi(E, F, V);
        return;
      }
      if (V === null || typeof V != "object" ? re = null : (re = I && V[I] || V["@@iterator"], re = typeof re == "function" ? re : null), re && (re = re.call(V))) {
        if (V = re.next(), !V.done) {
          var we = [];
          do
            we.push(V.value), V = re.next();
          while (!V.done);
          Qi(E, F, we);
        }
        return;
      }
      throw E = Object.prototype.toString.call(V), Error(t(31, E === "[object Object]" ? "object with keys {" + Object.keys(V).join(", ") + "}" : E));
    }
    typeof V == "string" ? (re = F.blockedSegment, re.lastPushedText = pe(F.blockedSegment.chunks, V, E.responseState, re.lastPushedText)) : typeof V == "number" && (re = F.blockedSegment, re.lastPushedText = pe(F.blockedSegment.chunks, "" + V, E.responseState, re.lastPushedText));
  }
  function Qi(E, F, V) {
    for (var re = V.length, we = 0; we < re; we++) {
      var Ee = F.treeContext;
      F.treeContext = Yn(Ee, re, we);
      try {
        Ca(E, F, V[we]);
      } finally {
        F.treeContext = Ee;
      }
    }
  }
  function Ca(E, F, V) {
    var re = F.blockedSegment.formatContext, we = F.legacyContext, Ee = F.context;
    try {
      return Xn(E, F, V);
    } catch (pt) {
      if (Za(), typeof pt == "object" && pt !== null && typeof pt.then == "function") {
        V = pt;
        var Fe = F.blockedSegment, je = jr(E, Fe.chunks.length, null, Fe.formatContext, Fe.lastPushedText, !0);
        Fe.children.push(je), Fe.lastPushedText = !1, E = Ja(E, F.node, F.blockedBoundary, je, F.abortSet, F.legacyContext, F.context, F.treeContext).ping, V.then(E, E), F.blockedSegment.formatContext = re, F.legacyContext = we, F.context = Ee, an(Ee);
      } else
        throw F.blockedSegment.formatContext = re, F.legacyContext = we, F.context = Ee, an(Ee), pt;
    }
  }
  function hl(E) {
    var F = E.blockedBoundary;
    E = E.blockedSegment, E.status = 3, eo(this, F, E);
  }
  function Ji(E, F, V) {
    var re = E.blockedBoundary;
    E.blockedSegment.status = 3, re === null ? (F.allPendingTasks--, F.status !== 2 && (F.status = 2, F.destination !== null && F.destination.close())) : (re.pendingTasks--, re.forceClientRender || (re.forceClientRender = !0, E = V === void 0 ? Error(t(432)) : V, re.errorDigest = F.onError(E), re.parentFlushed && F.clientRenderedBoundaries.push(re)), re.fallbackAbortableTasks.forEach(function(we) {
      return Ji(we, F, V);
    }), re.fallbackAbortableTasks.clear(), F.allPendingTasks--, F.allPendingTasks === 0 && (re = F.onAllReady, re()));
  }
  function Aa(E, F) {
    if (F.chunks.length === 0 && F.children.length === 1 && F.children[0].boundary === null) {
      var V = F.children[0];
      V.id = F.id, V.parentFlushed = !0, V.status === 1 && Aa(E, V);
    } else
      E.completedSegments.push(F);
  }
  function eo(E, F, V) {
    if (F === null) {
      if (V.parentFlushed) {
        if (E.completedRootSegment !== null)
          throw Error(t(389));
        E.completedRootSegment = V;
      }
      E.pendingRootTasks--, E.pendingRootTasks === 0 && (E.onShellError = ia, F = E.onShellReady, F());
    } else
      F.pendingTasks--, F.forceClientRender || (F.pendingTasks === 0 ? (V.parentFlushed && V.status === 1 && Aa(F, V), F.parentFlushed && E.completedBoundaries.push(F), F.fallbackAbortableTasks.forEach(hl, E), F.fallbackAbortableTasks.clear()) : V.parentFlushed && V.status === 1 && (Aa(F, V), F.completedSegments.length === 1 && F.parentFlushed && E.partialBoundaries.push(F)));
    E.allPendingTasks--, E.allPendingTasks === 0 && (E = E.onAllReady, E());
  }
  function to(E) {
    if (E.status !== 2) {
      var F = Ke, V = aa.current;
      aa.current = Sa;
      var re = ka;
      ka = E.responseState;
      try {
        var we = E.pingedTasks, Ee;
        for (Ee = 0; Ee < we.length; Ee++) {
          var Fe = we[Ee], je = E, pt = Fe.blockedSegment;
          if (pt.status === 0) {
            an(Fe.context);
            try {
              Xn(je, Fe, Fe.node), pt.lastPushedText && pt.textEmbedded && pt.chunks.push($), Fe.abortSet.delete(Fe), pt.status = 1, eo(je, Fe.blockedBoundary, pt);
            } catch (ur) {
              if (Za(), typeof ur == "object" && ur !== null && typeof ur.then == "function") {
                var Ct = Fe.ping;
                ur.then(Ct, Ct);
              } else {
                Fe.abortSet.delete(Fe), pt.status = 4;
                var Et = Fe.blockedBoundary, un = ur, qn = Ur(je, un);
                if (Et === null ? wa(je, un) : (Et.pendingTasks--, Et.forceClientRender || (Et.forceClientRender = !0, Et.errorDigest = qn, Et.parentFlushed && je.clientRenderedBoundaries.push(Et))), je.allPendingTasks--, je.allPendingTasks === 0) {
                  var sr = je.onAllReady;
                  sr();
                }
              }
            } finally {
            }
          }
        }
        we.splice(0, Ee), E.destination !== null && ti(E, E.destination);
      } catch (ur) {
        Ur(E, ur), wa(E, ur);
      } finally {
        ka = re, aa.current = V, V === Sa && an(F);
      }
    }
  }
  function La(E, F, V) {
    switch (V.parentFlushed = !0, V.status) {
      case 0:
        var re = V.id = E.nextSegmentId++;
        return V.lastPushedText = !1, V.textEmbedded = !1, E = E.responseState, i(F, lt), i(F, E.placeholderPrefix), E = s(re.toString(16)), i(F, E), o(F, St);
      case 1:
        V.status = 2;
        var we = !0;
        re = V.chunks;
        var Ee = 0;
        V = V.children;
        for (var Fe = 0; Fe < V.length; Fe++) {
          for (we = V[Fe]; Ee < we.index; Ee++)
            i(F, re[Ee]);
          we = Pa(E, F, we);
        }
        for (; Ee < re.length - 1; Ee++)
          i(F, re[Ee]);
        return Ee < re.length && (we = o(F, re[Ee])), we;
      default:
        throw Error(t(390));
    }
  }
  function Pa(E, F, V) {
    var re = V.boundary;
    if (re === null)
      return La(E, F, V);
    if (re.parentFlushed = !0, re.forceClientRender)
      re = re.errorDigest, o(F, Rt), i(F, $t), re && (i(F, Gt), i(F, s(Z(re))), i(F, Dt)), o(F, An), La(E, F, V);
    else if (0 < re.pendingTasks) {
      re.rootSegmentID = E.nextSegmentId++, 0 < re.completedSegments.length && E.partialBoundaries.push(re);
      var we = E.responseState, Ee = we.nextSuspenseID++;
      we = p(we.boundaryPrefix + Ee.toString(16)), re = re.id = we, Ot(F, E.responseState, re), La(E, F, V);
    } else if (re.byteSize > E.progressiveChunkSize)
      re.rootSegmentID = E.nextSegmentId++, E.completedBoundaries.push(re), Ot(F, E.responseState, re.id), La(E, F, V);
    else {
      if (o(F, Ut), V = re.completedSegments, V.length !== 1)
        throw Error(t(391));
      Pa(E, F, V[0]);
    }
    return o(F, Lt);
  }
  function no(E, F, V) {
    return Se(F, E.responseState, V.formatContext, V.id), Pa(E, F, V), ut(F, V.formatContext);
  }
  function ro(E, F, V) {
    for (var re = V.completedSegments, we = 0; we < re.length; we++)
      ao(E, F, V, re[we]);
    if (re.length = 0, E = E.responseState, re = V.id, V = V.rootSegmentID, i(F, E.startInlineScript), E.sentCompleteBoundaryFunction ? i(F, Tt) : (E.sentCompleteBoundaryFunction = !0, i(F, bt)), re === null)
      throw Error(t(395));
    return V = s(V.toString(16)), i(F, re), i(F, Pn), i(F, E.segmentPrefix), i(F, V), o(F, tn);
  }
  function ao(E, F, V, re) {
    if (re.status === 2)
      return !0;
    var we = re.id;
    if (we === -1) {
      if ((re.id = V.rootSegmentID) === -1)
        throw Error(t(392));
      return no(E, F, re);
    }
    return no(E, F, re), E = E.responseState, i(F, E.startInlineScript), E.sentCompleteSegmentFunction ? i(F, Ht) : (E.sentCompleteSegmentFunction = !0, i(F, Kt)), i(F, E.segmentPrefix), we = s(we.toString(16)), i(F, we), i(F, yt), i(F, E.placeholderPrefix), i(F, we), o(F, Bt);
  }
  function ti(E, F) {
    r = new Uint8Array(512), a = 0;
    try {
      var V = E.completedRootSegment;
      if (V !== null && E.pendingRootTasks === 0) {
        Pa(E, F, V), E.completedRootSegment = null;
        var re = E.responseState.bootstrapChunks;
        for (V = 0; V < re.length - 1; V++)
          i(F, re[V]);
        V < re.length && o(F, re[V]);
      }
      var we = E.clientRenderedBoundaries, Ee;
      for (Ee = 0; Ee < we.length; Ee++) {
        var Fe = we[Ee];
        re = F;
        var je = E.responseState, pt = Fe.id, Ct = Fe.errorDigest, Et = Fe.errorMessage, un = Fe.errorComponentStack;
        if (i(re, je.startInlineScript), je.sentClientRenderFunction ? i(re, Nt) : (je.sentClientRenderFunction = !0, i(
          re,
          Qt
        )), pt === null)
          throw Error(t(395));
        i(re, pt), i(re, Jt), (Ct || Et || un) && (i(re, on), i(re, s(Ln(Ct || "")))), (Et || un) && (i(re, on), i(re, s(Ln(Et || "")))), un && (i(re, on), i(re, s(Ln(un)))), o(re, wn);
      }
      we.splice(0, Ee);
      var qn = E.completedBoundaries;
      for (Ee = 0; Ee < qn.length; Ee++)
        ro(E, F, qn[Ee]);
      qn.splice(0, Ee), d(F), r = new Uint8Array(512), a = 0;
      var sr = E.partialBoundaries;
      for (Ee = 0; Ee < sr.length; Ee++) {
        var ur = sr[Ee];
        e: {
          we = E, Fe = F;
          var Ra = ur.completedSegments;
          for (je = 0; je < Ra.length; je++)
            if (!ao(
              we,
              Fe,
              ur,
              Ra[je]
            )) {
              je++, Ra.splice(0, je);
              var oo = !1;
              break e;
            }
          Ra.splice(0, je), oo = !0;
        }
        if (!oo) {
          E.destination = null, Ee++, sr.splice(0, Ee);
          return;
        }
      }
      sr.splice(0, Ee);
      var ni = E.completedBoundaries;
      for (Ee = 0; Ee < ni.length; Ee++)
        ro(E, F, ni[Ee]);
      ni.splice(0, Ee);
    } finally {
      d(F), E.allPendingTasks === 0 && E.pingedTasks.length === 0 && E.clientRenderedBoundaries.length === 0 && E.completedBoundaries.length === 0 && F.close();
    }
  }
  function io(E, F) {
    try {
      var V = E.abortableTasks;
      V.forEach(function(re) {
        return Ji(re, E, F);
      }), V.clear(), E.destination !== null && ti(E, E.destination);
    } catch (re) {
      Ur(E, re), wa(E, re);
    }
  }
  return Fu.renderToReadableStream = function(E, F) {
    return new Promise(function(V, re) {
      var we, Ee, Fe = new Promise(function(Et, un) {
        Ee = Et, we = un;
      }), je = Qa(E, J(F ? F.identifierPrefix : void 0, F ? F.nonce : void 0, F ? F.bootstrapScriptContent : void 0, F ? F.bootstrapScripts : void 0, F ? F.bootstrapModules : void 0), K(F ? F.namespaceURI : void 0), F ? F.progressiveChunkSize : void 0, F ? F.onError : void 0, Ee, function() {
        var Et = new ReadableStream({ type: "bytes", pull: function(un) {
          if (je.status === 1)
            je.status = 2, y(un, je.fatalError);
          else if (je.status !== 2 && je.destination === null) {
            je.destination = un;
            try {
              ti(je, un);
            } catch (qn) {
              Ur(je, qn), wa(je, qn);
            }
          }
        }, cancel: function() {
          io(je);
        } }, { highWaterMark: 0 });
        Et.allReady = Fe, V(Et);
      }, function(Et) {
        Fe.catch(function() {
        }), re(Et);
      }, we);
      if (F && F.signal) {
        var pt = F.signal, Ct = function() {
          io(je, pt.reason), pt.removeEventListener("abort", Ct);
        };
        pt.addEventListener("abort", Ct);
      }
      to(je);
    });
  }, Fu.version = "18.2.0", Fu;
}
var Di = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var em;
function bS() {
  return em || (em = 1, process.env.NODE_ENV !== "production" && function() {
    var e = se, t = "18.2.0", r = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(l) {
      {
        for (var f = arguments.length, k = new Array(f > 1 ? f - 1 : 0), R = 1; R < f; R++)
          k[R - 1] = arguments[R];
        o("warn", l, k);
      }
    }
    function i(l) {
      {
        for (var f = arguments.length, k = new Array(f > 1 ? f - 1 : 0), R = 1; R < f; R++)
          k[R - 1] = arguments[R];
        o("error", l, k);
      }
    }
    function o(l, f, k) {
      {
        var R = r.ReactDebugCurrentFrame, H = R.getStackAddendum();
        H !== "" && (f += "%s", k = k.concat([H]));
        var oe = k.map(function(he) {
          return String(he);
        });
        oe.unshift("Warning: " + f), Function.prototype.apply.call(console[l], console, oe);
      }
    }
    function d(l) {
      l();
    }
    function c(l) {
    }
    function s(l, f) {
      p(l, f);
    }
    function p(l, f) {
      return l.push(f);
    }
    function y(l) {
    }
    function g(l) {
      l.push(null);
    }
    function b(l) {
      return l;
    }
    function w(l) {
      return l;
    }
    function S(l, f) {
      l.destroy(f);
    }
    function L(l) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, k = f && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return k;
      }
    }
    function m(l) {
      try {
        return v(l), !1;
      } catch {
        return !0;
      }
    }
    function v(l) {
      return "" + l;
    }
    function A(l, f) {
      if (m(l))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", f, L(l)), v(l);
    }
    function P(l, f) {
      if (m(l))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", f, L(l)), v(l);
    }
    function T(l) {
      if (m(l))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", L(l)), v(l);
    }
    var _ = Object.prototype.hasOwnProperty, M = 0, Z = 1, Y = 2, ae = 3, j = 4, q = 5, te = 6, le = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", B = le + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", X = new RegExp("^[" + le + "][" + B + "]*$"), ue = {}, ne = {};
    function J(l) {
      return _.call(ne, l) ? !0 : _.call(ue, l) ? !1 : X.test(l) ? (ne[l] = !0, !0) : (ue[l] = !0, i("Invalid attribute name: `%s`", l), !1);
    }
    function W(l, f, k, R) {
      if (k !== null && k.type === M)
        return !1;
      switch (typeof f) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (R)
            return !1;
          if (k !== null)
            return !k.acceptsBooleans;
          var H = l.toLowerCase().slice(0, 5);
          return H !== "data-" && H !== "aria-";
        }
        default:
          return !1;
      }
    }
    function K(l) {
      return $.hasOwnProperty(l) ? $[l] : null;
    }
    function ee(l, f, k, R, H, oe, he) {
      this.acceptsBooleans = f === Y || f === ae || f === j, this.attributeName = R, this.attributeNamespace = H, this.mustUseProperty = k, this.propertyName = l, this.type = f, this.sanitizeURL = oe, this.removeEmptyString = he;
    }
    var $ = {}, pe = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    pe.forEach(function(l) {
      $[l] = new ee(
        l,
        M,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
      var f = l[0], k = l[1];
      $[f] = new ee(
        f,
        Z,
        !1,
        // mustUseProperty
        k,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
      $[l] = new ee(
        l,
        Y,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
      $[l] = new ee(
        l,
        Y,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(l) {
      $[l] = new ee(
        l,
        ae,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      $[l] = new ee(
        l,
        ae,
        !0,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      $[l] = new ee(
        l,
        j,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      $[l] = new ee(
        l,
        te,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(l) {
      $[l] = new ee(
        l,
        q,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ve = /[\-\:]([a-z])/g, Te = function(l) {
      return l[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ve, Te);
      $[f] = new ee(
        f,
        Z,
        !1,
        // mustUseProperty
        l,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ve, Te);
      $[f] = new ee(
        f,
        Z,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ve, Te);
      $[f] = new ee(
        f,
        Z,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(l) {
      $[l] = new ee(
        l,
        Z,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ye = "xlinkHref";
    $[ye] = new ee(
      "xlinkHref",
      Z,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(l) {
      $[l] = new ee(
        l,
        Z,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Re = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Xe(l, f) {
      return l + f.charAt(0).toUpperCase() + f.substring(1);
    }
    var Ce = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Re).forEach(function(l) {
      Ce.forEach(function(f) {
        Re[Xe(f, l)] = Re[l];
      });
    });
    var xe = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Pe(l, f) {
      xe[f.type] || f.onChange || f.onInput || f.readOnly || f.disabled || f.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), f.onChange || f.readOnly || f.disabled || f.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function de(l, f) {
      if (l.indexOf("-") === -1)
        return typeof f.is == "string";
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Be = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ne = {}, He = new RegExp("^(aria)-[" + B + "]*$"), Ze = new RegExp("^(aria)[A-Z][" + B + "]*$");
    function $e(l, f) {
      {
        if (_.call(Ne, f) && Ne[f])
          return !0;
        if (Ze.test(f)) {
          var k = "aria-" + f.slice(4).toLowerCase(), R = Be.hasOwnProperty(k) ? k : null;
          if (R == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", f), Ne[f] = !0, !0;
          if (f !== R)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", f, R), Ne[f] = !0, !0;
        }
        if (He.test(f)) {
          var H = f.toLowerCase(), oe = Be.hasOwnProperty(H) ? H : null;
          if (oe == null)
            return Ne[f] = !0, !1;
          if (f !== oe)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", f, oe), Ne[f] = !0, !0;
        }
      }
      return !0;
    }
    function Ye(l, f) {
      {
        var k = [];
        for (var R in f) {
          var H = $e(l, R);
          H || k.push(R);
        }
        var oe = k.map(function(he) {
          return "`" + he + "`";
        }).join(", ");
        k.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", oe, l) : k.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", oe, l);
      }
    }
    function qe(l, f) {
      de(l, f) || Ye(l, f);
    }
    var Ve = !1;
    function Ge(l, f) {
      {
        if (l !== "input" && l !== "textarea" && l !== "select")
          return;
        f != null && f.value === null && !Ve && (Ve = !0, l === "select" && f.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", l) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", l));
      }
    }
    var ke = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, De = function() {
    };
    {
      var at = {}, be = /^on./, nt = /^on[^A-Z]/, st = new RegExp("^(aria)-[" + B + "]*$"), lt = new RegExp("^(aria)[A-Z][" + B + "]*$");
      De = function(l, f, k, R) {
        if (_.call(at, f) && at[f])
          return !0;
        var H = f.toLowerCase();
        if (H === "onfocusin" || H === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), at[f] = !0, !0;
        if (R != null) {
          var oe = R.registrationNameDependencies, he = R.possibleRegistrationNames;
          if (oe.hasOwnProperty(f))
            return !0;
          var Ae = he.hasOwnProperty(H) ? he[H] : null;
          if (Ae != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", f, Ae), at[f] = !0, !0;
          if (be.test(f))
            return i("Unknown event handler property `%s`. It will be ignored.", f), at[f] = !0, !0;
        } else if (be.test(f))
          return nt.test(f) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", f), at[f] = !0, !0;
        if (st.test(f) || lt.test(f))
          return !0;
        if (H === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), at[f] = !0, !0;
        if (H === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), at[f] = !0, !0;
        if (H === "is" && k !== null && k !== void 0 && typeof k != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof k), at[f] = !0, !0;
        if (typeof k == "number" && isNaN(k))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", f), at[f] = !0, !0;
        var Ie = K(f), rt = Ie !== null && Ie.type === M;
        if (ke.hasOwnProperty(H)) {
          var it = ke[H];
          if (it !== f)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", f, it), at[f] = !0, !0;
        } else if (!rt && f !== H)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", f, H), at[f] = !0, !0;
        return typeof k == "boolean" && W(f, k, Ie, !1) ? (k ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', k, f, f, k, f) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', k, f, f, k, f, f, f), at[f] = !0, !0) : rt ? !0 : W(f, k, Ie, !1) ? (at[f] = !0, !1) : ((k === "false" || k === "true") && Ie !== null && Ie.type === ae && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", k, f, k === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', f, k), at[f] = !0), !0);
      };
    }
    var St = function(l, f, k) {
      {
        var R = [];
        for (var H in f) {
          var oe = De(l, H, f[H], k);
          oe || R.push(H);
        }
        var he = R.map(function(Ae) {
          return "`" + Ae + "`";
        }).join(", ");
        R.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, l) : R.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, l);
      }
    };
    function Ut(l, f, k) {
      de(l, f) || St(l, f, k);
    }
    var It = function() {
    };
    {
      var _t = /^(?:webkit|moz|o)[A-Z]/, Rt = /^-ms-/, Lt = /-(.)/g, $t = /;\s*$/, Dt = {}, Gt = {}, An = !1, Ot = !1, Xt = function(l) {
        return l.replace(Lt, function(f, k) {
          return k.toUpperCase();
        });
      }, ht = function(l) {
        Dt.hasOwnProperty(l) && Dt[l] || (Dt[l] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          l,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Xt(l.replace(Rt, "ms-"))
        ));
      }, Je = function(l) {
        Dt.hasOwnProperty(l) && Dt[l] || (Dt[l] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", l, l.charAt(0).toUpperCase() + l.slice(1)));
      }, Zt = function(l, f) {
        Gt.hasOwnProperty(f) && Gt[f] || (Gt[f] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, l, f.replace($t, "")));
      }, dn = function(l, f) {
        An || (An = !0, i("`NaN` is an invalid value for the `%s` css style property.", l));
      }, gn = function(l, f) {
        Ot || (Ot = !0, i("`Infinity` is an invalid value for the `%s` css style property.", l));
      };
      It = function(l, f) {
        l.indexOf("-") > -1 ? ht(l) : _t.test(l) ? Je(l) : $t.test(f) && Zt(l, f), typeof f == "number" && (isNaN(f) ? dn(l, f) : isFinite(f) || gn(l, f));
      };
    }
    var fn = It, vt = /["'&<>]/;
    function Ft(l) {
      T(l);
      var f = "" + l, k = vt.exec(f);
      if (!k)
        return f;
      var R, H = "", oe, he = 0;
      for (oe = k.index; oe < f.length; oe++) {
        switch (f.charCodeAt(oe)) {
          case 34:
            R = "&quot;";
            break;
          case 38:
            R = "&amp;";
            break;
          case 39:
            R = "&#x27;";
            break;
          case 60:
            R = "&lt;";
            break;
          case 62:
            R = "&gt;";
            break;
          default:
            continue;
        }
        he !== oe && (H += f.substring(he, oe)), he = oe + 1, H += R;
      }
      return he !== oe ? H + f.substring(he, oe) : H;
    }
    function mt(l) {
      return typeof l == "boolean" || typeof l == "number" ? "" + l : Ft(l);
    }
    var pn = /([A-Z])/g, Sn = /^ms-/;
    function kt(l) {
      return l.replace(pn, "-$1").toLowerCase().replace(Sn, "-ms-");
    }
    var wt = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, kn = !1;
    function xt(l) {
      !kn && wt.test(l) && (kn = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(l)));
    }
    var Pt = Array.isArray;
    function bn(l) {
      return Pt(l);
    }
    var On = "<script>", _e = "<\/script>", Oe = '<script src="', Se = '<script type="module" src="', ut = '" async=""><\/script>';
    function Kt(l) {
      return T(l), ("" + l).replace(Ht, yt);
    }
    var Ht = /(<\/|<)(s)(cript)/gi, yt = function(l, f, k, R) {
      return "" + f + (k === "s" ? "\\u0073" : "\\u0053") + R;
    };
    function Bt(l, f, k, R, H) {
      var oe = l === void 0 ? "" : l, he = f === void 0 ? On : '<script nonce="' + mt(f) + '">', Ae = [];
      if (k !== void 0 && Ae.push(he, Kt(k), _e), R !== void 0)
        for (var Ie = 0; Ie < R.length; Ie++)
          Ae.push(Oe, mt(R[Ie]), ut);
      if (H !== void 0)
        for (var rt = 0; rt < H.length; rt++)
          Ae.push(Se, mt(H[rt]), ut);
      return {
        bootstrapChunks: Ae,
        startInlineScript: he,
        placeholderPrefix: oe + "P:",
        segmentPrefix: oe + "S:",
        boundaryPrefix: oe + "B:",
        idPrefix: oe,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var bt = 0, Tt = 1, Pn = 2, tn = 3, Qt = 4, Nt = 5, Jt = 6, wn = 7;
    function on(l, f) {
      return {
        insertionMode: l,
        selectedValue: f
      };
    }
    function Wn(l, f, k) {
      switch (f) {
        case "select":
          return on(Tt, k.value != null ? k.value : k.defaultValue);
        case "svg":
          return on(Pn, null);
        case "math":
          return on(tn, null);
        case "foreignObject":
          return on(Tt, null);
        case "table":
          return on(Qt, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return on(Nt, null);
        case "colgroup":
          return on(wn, null);
        case "tr":
          return on(Jt, null);
      }
      return l.insertionMode >= Qt || l.insertionMode === bt ? on(Tt, null) : l;
    }
    var Ln = null;
    function Tn(l) {
      var f = l.nextSuspenseID++;
      return l.boundaryPrefix + f.toString(16);
    }
    function ln(l, f, k) {
      var R = l.idPrefix, H = ":" + R + "R" + f;
      return k > 0 && (H += "H" + k.toString(32)), H + ":";
    }
    function Dn(l) {
      return mt(l);
    }
    var _n = "<!-- -->";
    function Fn(l, f, k, R) {
      return f === "" ? R : (R && l.push(_n), l.push(Dn(f)), !0);
    }
    function Kn(l, f, k, R) {
      k && R && l.push(_n);
    }
    var sn = /* @__PURE__ */ new Map();
    function hn(l) {
      var f = sn.get(l);
      if (f !== void 0)
        return f;
      var k = mt(kt(l));
      return sn.set(l, k), k;
    }
    var ir = ' style="', Zn = ":", Qn = ";";
    function x(l, f, k) {
      if (typeof k != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var R = !0;
      for (var H in k)
        if (_.call(k, H)) {
          var oe = k[H];
          if (!(oe == null || typeof oe == "boolean" || oe === "")) {
            var he = void 0, Ae = void 0, Ie = H.indexOf("--") === 0;
            Ie ? (he = mt(H), P(oe, H), Ae = mt(("" + oe).trim())) : (fn(H, oe), he = hn(H), typeof oe == "number" ? oe !== 0 && !_.call(Re, H) ? Ae = oe + "px" : Ae = "" + oe : (P(oe, H), Ae = mt(("" + oe).trim()))), R ? (R = !1, l.push(ir, he, Zn, Ae)) : l.push(Qn, he, Zn, Ae);
          }
        }
      R || l.push(U);
    }
    var D = " ", N = '="', U = '"', fe = '=""';
    function O(l, f, k, R) {
      switch (k) {
        case "style": {
          x(l, f, R);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(k.length > 2 && (k[0] === "o" || k[0] === "O") && (k[1] === "n" || k[1] === "N"))
      ) {
        var H = K(k);
        if (H !== null) {
          switch (typeof R) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!H.acceptsBooleans)
                return;
          }
          var oe = H.attributeName, he = oe;
          switch (H.type) {
            case ae:
              R && l.push(D, he, fe);
              return;
            case j:
              R === !0 ? l.push(D, he, fe) : R === !1 || l.push(D, he, N, mt(R), U);
              return;
            case q:
              isNaN(R) || l.push(D, he, N, mt(R), U);
              break;
            case te:
              !isNaN(R) && R >= 1 && l.push(D, he, N, mt(R), U);
              break;
            default:
              H.sanitizeURL && (A(R, oe), R = "" + R, xt(R)), l.push(D, he, N, mt(R), U);
          }
        } else if (J(k)) {
          switch (typeof R) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Ae = k.toLowerCase().slice(0, 5);
              if (Ae !== "data-" && Ae !== "aria-")
                return;
            }
          }
          l.push(D, k, N, mt(R), U);
        }
      }
    }
    var I = ">", Q = "/>";
    function ge(l, f, k) {
      if (f != null) {
        if (k != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof f != "object" || !("__html" in f))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var R = f.__html;
        R != null && (T(R), l.push("" + R));
      }
    }
    var ze = !1, Ke = !1, ot = !1, Yt = !1, Vt = !1, nn = !1, rn = !1;
    function an(l, f) {
      {
        var k = l[f];
        if (k != null) {
          var R = bn(k);
          l.multiple && !R ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", f) : !l.multiple && R && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", f);
        }
      }
    }
    function jn(l, f, k) {
      Pe("select", f), an(f, "value"), an(f, "defaultValue"), f.value !== void 0 && f.defaultValue !== void 0 && !ot && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), ot = !0), l.push(Gn("select"));
      var R = null, H = null;
      for (var oe in f)
        if (_.call(f, oe)) {
          var he = f[oe];
          if (he == null)
            continue;
          switch (oe) {
            case "children":
              R = he;
              break;
            case "dangerouslySetInnerHTML":
              H = he;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              O(l, k, oe, he);
              break;
          }
        }
      return l.push(I), ge(l, H, R), R;
    }
    function Jn(l) {
      var f = "";
      return e.Children.forEach(l, function(k) {
        k != null && (f += k, !Vt && typeof k != "string" && typeof k != "number" && (Vt = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), f;
    }
    var er = ' selected=""';
    function Yn(l, f, k, R) {
      var H = R.selectedValue;
      l.push(Gn("option"));
      var oe = null, he = null, Ae = null, Ie = null;
      for (var rt in f)
        if (_.call(f, rt)) {
          var it = f[rt];
          if (it == null)
            continue;
          switch (rt) {
            case "children":
              oe = it;
              break;
            case "selected":
              Ae = it, rn || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), rn = !0);
              break;
            case "dangerouslySetInnerHTML":
              Ie = it;
              break;
            case "value":
              he = it;
            default:
              O(l, k, rt, it);
              break;
          }
        }
      if (H != null) {
        var gt;
        if (he !== null ? (A(he, "value"), gt = "" + he) : (Ie !== null && (nn || (nn = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), gt = Jn(oe)), bn(H))
          for (var mn = 0; mn < H.length; mn++) {
            A(H[mn], "value");
            var Hn = "" + H[mn];
            if (Hn === gt) {
              l.push(er);
              break;
            }
          }
        else
          A(H, "select.value"), "" + H === gt && l.push(er);
      } else
        Ae && l.push(er);
      return l.push(I), ge(l, Ie, oe), oe;
    }
    function Er(l, f, k) {
      Pe("input", f), f.checked !== void 0 && f.defaultChecked !== void 0 && !Ke && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), Ke = !0), f.value !== void 0 && f.defaultValue !== void 0 && !ze && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), ze = !0), l.push(Gn("input"));
      var R = null, H = null, oe = null, he = null;
      for (var Ae in f)
        if (_.call(f, Ae)) {
          var Ie = f[Ae];
          if (Ie == null)
            continue;
          switch (Ae) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              he = Ie;
              break;
            case "defaultValue":
              H = Ie;
              break;
            case "checked":
              oe = Ie;
              break;
            case "value":
              R = Ie;
              break;
            default:
              O(l, k, Ae, Ie);
              break;
          }
        }
      return oe !== null ? O(l, k, "checked", oe) : he !== null && O(l, k, "checked", he), R !== null ? O(l, k, "value", R) : H !== null && O(l, k, "value", H), l.push(Q), null;
    }
    function xa(l, f, k) {
      Pe("textarea", f), f.value !== void 0 && f.defaultValue !== void 0 && !Yt && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Yt = !0), l.push(Gn("textarea"));
      var R = null, H = null, oe = null;
      for (var he in f)
        if (_.call(f, he)) {
          var Ae = f[he];
          if (Ae == null)
            continue;
          switch (he) {
            case "children":
              oe = Ae;
              break;
            case "value":
              R = Ae;
              break;
            case "defaultValue":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              O(l, k, he, Ae);
              break;
          }
        }
      if (R === null && H !== null && (R = H), l.push(I), oe != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), R != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (bn(oe)) {
          if (oe.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          T(oe[0]), R = "" + oe[0];
        }
        T(oe), R = "" + oe;
      }
      return typeof R == "string" && R[0] === `
` && l.push(Dr), R !== null && (A(R, "value"), l.push(Dn("" + R))), null;
    }
    function At(l, f, k, R) {
      l.push(Gn(k));
      for (var H in f)
        if (_.call(f, H)) {
          var oe = f[H];
          if (oe == null)
            continue;
          switch (H) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(k + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              O(l, R, H, oe);
              break;
          }
        }
      return l.push(Q), null;
    }
    function vn(l, f, k) {
      l.push(Gn("menuitem"));
      for (var R in f)
        if (_.call(f, R)) {
          var H = f[R];
          if (H == null)
            continue;
          switch (R) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              O(l, k, R, H);
              break;
          }
        }
      return l.push(I), null;
    }
    function ra(l, f, k) {
      l.push(Gn("title"));
      var R = null;
      for (var H in f)
        if (_.call(f, H)) {
          var oe = f[H];
          if (oe == null)
            continue;
          switch (H) {
            case "children":
              R = oe;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              O(l, k, H, oe);
              break;
          }
        }
      l.push(I);
      {
        var he = Array.isArray(R) && R.length < 2 ? R[0] || null : R;
        Array.isArray(R) && R.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && he.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && typeof he != "string" && typeof he != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return R;
    }
    function Nr(l, f, k, R) {
      l.push(Gn(k));
      var H = null, oe = null;
      for (var he in f)
        if (_.call(f, he)) {
          var Ae = f[he];
          if (Ae == null)
            continue;
          switch (he) {
            case "children":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              oe = Ae;
              break;
            default:
              O(l, R, he, Ae);
              break;
          }
        }
      return l.push(I), ge(l, oe, H), typeof H == "string" ? (l.push(Dn(H)), null) : H;
    }
    function or(l, f, k, R) {
      l.push(Gn(k));
      var H = null, oe = null;
      for (var he in f)
        if (_.call(f, he)) {
          var Ae = f[he];
          if (Ae == null)
            continue;
          switch (he) {
            case "children":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              oe = Ae;
              break;
            case "style":
              x(l, R, Ae);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              J(he) && typeof Ae != "function" && typeof Ae != "symbol" && l.push(D, he, N, mt(Ae), U);
              break;
          }
        }
      return l.push(I), ge(l, oe, H), H;
    }
    var Dr = `
`;
    function Wr(l, f, k, R) {
      l.push(Gn(k));
      var H = null, oe = null;
      for (var he in f)
        if (_.call(f, he)) {
          var Ae = f[he];
          if (Ae == null)
            continue;
          switch (he) {
            case "children":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              oe = Ae;
              break;
            default:
              O(l, R, he, Ae);
              break;
          }
        }
      if (l.push(I), oe != null) {
        if (H != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof oe != "object" || !("__html" in oe))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var Ie = oe.__html;
        Ie != null && (typeof Ie == "string" && Ie.length > 0 && Ie[0] === `
` ? l.push(Dr, Ie) : (T(Ie), l.push("" + Ie)));
      }
      return typeof H == "string" && H[0] === `
` && l.push(Dr), H;
    }
    var Wt = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, mr = /* @__PURE__ */ new Map();
    function Gn(l) {
      var f = mr.get(l);
      if (f === void 0) {
        if (!Wt.test(l))
          throw new Error("Invalid tag: " + l);
        f = "<" + l, mr.set(l, f);
      }
      return f;
    }
    var _r = "<!DOCTYPE html>";
    function kr(l, f, k, R, H) {
      switch (qe(f, k), Ge(f, k), Ut(f, k, null), !k.suppressContentEditableWarning && k.contentEditable && k.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), H.insertionMode !== Pn && H.insertionMode !== tn && f.indexOf("-") === -1 && typeof k.is != "string" && f.toLowerCase() !== f && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", f), f) {
        case "select":
          return jn(l, k, R);
        case "option":
          return Yn(l, k, R, H);
        case "textarea":
          return xa(l, k, R);
        case "input":
          return Er(l, k, R);
        case "menuitem":
          return vn(l, k, R);
        case "title":
          return ra(l, k, R);
        case "listing":
        case "pre":
          return Wr(l, k, f, R);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return At(l, k, f, R);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Nr(l, k, f, R);
        case "html":
          return H.insertionMode === bt && l.push(_r), Nr(l, k, f, R);
        default:
          return f.indexOf("-") === -1 && typeof k.is != "string" ? Nr(l, k, f, R) : or(l, k, f, R);
      }
    }
    var ba = "</", wr = ">";
    function lr(l, f, k) {
      switch (f) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          l.push(ba, f, wr);
      }
    }
    function qa(l, f) {
      for (var k = f.bootstrapChunks, R = 0; R < k.length - 1; R++)
        s(l, k[R]);
      return R < k.length ? p(l, k[R]) : !0;
    }
    var Za = '<template id="', Yi = '"></template>';
    function Gi(l, f, k) {
      s(l, Za), s(l, f.placeholderPrefix);
      var R = k.toString(16);
      return s(l, R), p(l, Yi);
    }
    var Xi = "<!--$-->", dl = '<!--$?--><template id="', fl = '"></template>', Ea = "<!--$!-->", Sa = "<!--/$-->", ka = "<template", aa = '"', pl = ' data-dgst="', ia = ' data-msg="', Qa = ' data-stck="', Ja = "></template>";
    function jr(l, f) {
      return p(l, Xi);
    }
    function Ur(l, f, k) {
      if (s(l, dl), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, k), p(l, fl);
    }
    function wa(l, f, k, R, H) {
      var oe;
      return oe = p(l, Ea), s(l, ka), k && (s(l, pl), s(l, mt(k)), s(l, aa)), R && (s(l, ia), s(l, mt(R)), s(l, aa)), H && (s(l, Qa), s(l, mt(H)), s(l, aa)), oe = p(l, Ja), oe;
    }
    function qi(l, f) {
      return p(l, Sa);
    }
    function ei(l, f) {
      return p(l, Sa);
    }
    function Zi(l, f) {
      return p(l, Sa);
    }
    var Ta = '<div hidden id="', Xn = '">', Qi = "</div>", Ca = '<svg aria-hidden="true" style="display:none" id="', hl = '">', Ji = "</svg>", Aa = '<math aria-hidden="true" style="display:none" id="', eo = '">', to = "</math>", La = '<table hidden id="', Pa = '">', no = "</table>", ro = '<table hidden><tbody id="', ao = '">', ti = "</tbody></table>", io = '<table hidden><tr id="', E = '">', F = "</tr></table>", V = '<table hidden><colgroup id="', re = '">', we = "</colgroup></table>";
    function Ee(l, f, k, R) {
      switch (k.insertionMode) {
        case bt:
        case Tt:
          return s(l, Ta), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, Xn);
        case Pn:
          return s(l, Ca), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, hl);
        case tn:
          return s(l, Aa), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, eo);
        case Qt:
          return s(l, La), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, Pa);
        case Nt:
          return s(l, ro), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, ao);
        case Jt:
          return s(l, io), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, E);
        case wn:
          return s(l, V), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, re);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Fe(l, f) {
      switch (f.insertionMode) {
        case bt:
        case Tt:
          return p(l, Qi);
        case Pn:
          return p(l, Ji);
        case tn:
          return p(l, to);
        case Qt:
          return p(l, no);
        case Nt:
          return p(l, ti);
        case Jt:
          return p(l, F);
        case wn:
          return p(l, we);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var je = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", pt = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Ct = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Et = je + ';$RS("', un = '$RS("', qn = '","', sr = '")<\/script>';
    function ur(l, f, k) {
      s(l, f.startInlineScript), f.sentCompleteSegmentFunction ? s(l, un) : (f.sentCompleteSegmentFunction = !0, s(l, Et)), s(l, f.segmentPrefix);
      var R = k.toString(16);
      return s(l, R), s(l, qn), s(l, f.placeholderPrefix), s(l, R), p(l, sr);
    }
    var Ra = pt + ';$RC("', oo = '$RC("', ni = '","', Wc = '")<\/script>';
    function jc(l, f, k, R) {
      if (s(l, f.startInlineScript), f.sentCompleteBoundaryFunction ? s(l, oo) : (f.sentCompleteBoundaryFunction = !0, s(l, Ra)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var H = R.toString(16);
      return s(l, k), s(l, ni), s(l, f.segmentPrefix), s(l, H), p(l, Wc);
    }
    var Uc = Ct + ';$RX("', Kc = '$RX("', Yc = '"', Gc = ")<\/script>", ml = ",";
    function Xc(l, f, k, R, H, oe) {
      if (s(l, f.startInlineScript), f.sentClientRenderFunction ? s(l, Kc) : (f.sentClientRenderFunction = !0, s(l, Uc)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, k), s(l, Yc), (R || H || oe) && (s(l, ml), s(l, yl(R || ""))), (H || oe) && (s(l, ml), s(l, yl(H || ""))), oe && (s(l, ml), s(l, yl(oe))), p(l, Gc);
    }
    var qc = /[<\u2028\u2029]/g;
    function yl(l) {
      var f = JSON.stringify(l);
      return f.replace(qc, function(k) {
        switch (k) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Zc(l, f) {
      var k = Bt(f, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: k.bootstrapChunks,
        startInlineScript: k.startInlineScript,
        placeholderPrefix: k.placeholderPrefix,
        segmentPrefix: k.segmentPrefix,
        boundaryPrefix: k.boundaryPrefix,
        idPrefix: k.idPrefix,
        nextSuspenseID: k.nextSuspenseID,
        sentCompleteSegmentFunction: k.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: k.sentCompleteBoundaryFunction,
        sentClientRenderFunction: k.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: l
      };
    }
    function gl() {
      return {
        insertionMode: Tt,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function Os(l, f, k, R) {
      return k.generateStaticMarkup ? (l.push(mt(f)), !1) : Fn(l, f, k, R);
    }
    function Fs(l, f, k, R) {
      if (!f.generateStaticMarkup)
        return Kn(l, f, k, R);
    }
    function vl(l, f) {
      return f.generateStaticMarkup ? !0 : jr(l);
    }
    function yr(l, f, k, R, H) {
      return f.generateStaticMarkup ? !0 : wa(l, f, k, R, H);
    }
    function Qc(l, f) {
      return f.generateStaticMarkup ? !0 : qi(l);
    }
    function Ms(l, f) {
      return f.generateStaticMarkup ? !0 : Zi(l);
    }
    var cr = Object.assign, zs = Symbol.for("react.element"), xl = Symbol.for("react.portal"), lo = Symbol.for("react.fragment"), so = Symbol.for("react.strict_mode"), uo = Symbol.for("react.profiler"), ri = Symbol.for("react.provider"), ai = Symbol.for("react.context"), ii = Symbol.for("react.forward_ref"), Na = Symbol.for("react.suspense"), bl = Symbol.for("react.suspense_list"), El = Symbol.for("react.memo"), co = Symbol.for("react.lazy"), Jc = Symbol.for("react.scope"), Bs = Symbol.for("react.debug_trace_mode"), ed = Symbol.for("react.legacy_hidden"), td = Symbol.for("react.default_value"), Is = Symbol.iterator, $s = "@@iterator";
    function En(l) {
      if (l === null || typeof l != "object")
        return null;
      var f = Is && l[Is] || l[$s];
      return typeof f == "function" ? f : null;
    }
    function oi(l, f, k) {
      var R = l.displayName;
      if (R)
        return R;
      var H = f.displayName || f.name || "";
      return H !== "" ? k + "(" + H + ")" : k;
    }
    function Sl(l) {
      return l.displayName || "Context";
    }
    function xn(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case lo:
          return "Fragment";
        case xl:
          return "Portal";
        case uo:
          return "Profiler";
        case so:
          return "StrictMode";
        case Na:
          return "Suspense";
        case bl:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ai:
            var f = l;
            return Sl(f) + ".Consumer";
          case ri:
            var k = l;
            return Sl(k._context) + ".Provider";
          case ii:
            return oi(l, l.render, "ForwardRef");
          case El:
            var R = l.displayName || null;
            return R !== null ? R : xn(l.type) || "Memo";
          case co: {
            var H = l, oe = H._payload, he = H._init;
            try {
              return xn(he(oe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Da = 0, kl, wl, Tl, Cl, Al, Hs, Vs;
    function fo() {
    }
    fo.__reactDisabledLog = !0;
    function Ll() {
      {
        if (Da === 0) {
          kl = console.log, wl = console.info, Tl = console.warn, Cl = console.error, Al = console.group, Hs = console.groupCollapsed, Vs = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: fo,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        Da++;
      }
    }
    function li() {
      {
        if (Da--, Da === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: cr({}, l, {
              value: kl
            }),
            info: cr({}, l, {
              value: wl
            }),
            warn: cr({}, l, {
              value: Tl
            }),
            error: cr({}, l, {
              value: Cl
            }),
            group: cr({}, l, {
              value: Al
            }),
            groupCollapsed: cr({}, l, {
              value: Hs
            }),
            groupEnd: cr({}, l, {
              value: Vs
            })
          });
        }
        Da < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var si = r.ReactCurrentDispatcher, _a;
    function ui(l, f, k) {
      {
        if (_a === void 0)
          try {
            throw Error();
          } catch (H) {
            var R = H.stack.trim().match(/\n( *(at )?)/);
            _a = R && R[1] || "";
          }
        return `
` + _a + l;
      }
    }
    var ci = !1, po;
    {
      var Ws = typeof WeakMap == "function" ? WeakMap : Map;
      po = new Ws();
    }
    function Pl(l, f) {
      if (!l || ci)
        return "";
      {
        var k = po.get(l);
        if (k !== void 0)
          return k;
      }
      var R;
      ci = !0;
      var H = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var oe;
      oe = si.current, si.current = null, Ll();
      try {
        if (f) {
          var he = function() {
            throw Error();
          };
          if (Object.defineProperty(he.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(he, []);
            } catch (br) {
              R = br;
            }
            Reflect.construct(l, [], he);
          } else {
            try {
              he.call();
            } catch (br) {
              R = br;
            }
            l.call(he.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (br) {
            R = br;
          }
          l();
        }
      } catch (br) {
        if (br && R && typeof br.stack == "string") {
          for (var Ae = br.stack.split(`
`), Ie = R.stack.split(`
`), rt = Ae.length - 1, it = Ie.length - 1; rt >= 1 && it >= 0 && Ae[rt] !== Ie[it]; )
            it--;
          for (; rt >= 1 && it >= 0; rt--, it--)
            if (Ae[rt] !== Ie[it]) {
              if (rt !== 1 || it !== 1)
                do
                  if (rt--, it--, it < 0 || Ae[rt] !== Ie[it]) {
                    var gt = `
` + Ae[rt].replace(" at new ", " at ");
                    return l.displayName && gt.includes("<anonymous>") && (gt = gt.replace("<anonymous>", l.displayName)), typeof l == "function" && po.set(l, gt), gt;
                  }
                while (rt >= 1 && it >= 0);
              break;
            }
        }
      } finally {
        ci = !1, si.current = oe, li(), Error.prepareStackTrace = H;
      }
      var mn = l ? l.displayName || l.name : "", Hn = mn ? ui(mn) : "";
      return typeof l == "function" && po.set(l, Hn), Hn;
    }
    function Rl(l, f, k) {
      return Pl(l, !0);
    }
    function Nl(l, f, k) {
      return Pl(l, !1);
    }
    function js(l) {
      var f = l.prototype;
      return !!(f && f.isReactComponent);
    }
    function Oa(l, f, k) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return Pl(l, js(l));
      if (typeof l == "string")
        return ui(l);
      switch (l) {
        case Na:
          return ui("Suspense");
        case bl:
          return ui("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ii:
            return Nl(l.render);
          case El:
            return Oa(l.type, f, k);
          case co: {
            var R = l, H = R._payload, oe = R._init;
            try {
              return Oa(oe(H), f, k);
            } catch {
            }
          }
        }
      return "";
    }
    var Dl = {}, ho = r.ReactDebugCurrentFrame;
    function oa(l) {
      if (l) {
        var f = l._owner, k = Oa(l.type, l._source, f ? f.type : null);
        ho.setExtraStackFrame(k);
      } else
        ho.setExtraStackFrame(null);
    }
    function _l(l, f, k, R, H) {
      {
        var oe = Function.call.bind(_);
        for (var he in l)
          if (oe(l, he)) {
            var Ae = void 0;
            try {
              if (typeof l[he] != "function") {
                var Ie = Error((R || "React class") + ": " + k + " type `" + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[he] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ie.name = "Invariant Violation", Ie;
              }
              Ae = l[he](f, he, R, k, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (rt) {
              Ae = rt;
            }
            Ae && !(Ae instanceof Error) && (oa(H), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", R || "React class", k, he, typeof Ae), oa(null)), Ae instanceof Error && !(Ae.message in Dl) && (Dl[Ae.message] = !0, oa(H), i("Failed %s type: %s", k, Ae.message), oa(null));
          }
      }
    }
    var Ol;
    Ol = {};
    var Kr = {};
    Object.freeze(Kr);
    function Us(l, f) {
      {
        var k = l.contextTypes;
        if (!k)
          return Kr;
        var R = {};
        for (var H in k)
          R[H] = f[H];
        {
          var oe = xn(l) || "Unknown";
          _l(k, R, "context", oe);
        }
        return R;
      }
    }
    function la(l, f, k, R) {
      {
        if (typeof l.getChildContext != "function") {
          {
            var H = xn(f) || "Unknown";
            Ol[H] || (Ol[H] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", H, H));
          }
          return k;
        }
        var oe = l.getChildContext();
        for (var he in oe)
          if (!(he in R))
            throw new Error((xn(f) || "Unknown") + '.getChildContext(): key "' + he + '" is not defined in childContextTypes.');
        {
          var Ae = xn(f) || "Unknown";
          _l(R, oe, "child context", Ae);
        }
        return cr({}, k, oe);
      }
    }
    var sa;
    sa = {};
    var Fl = null, Tr = null;
    function mo(l) {
      l.context._currentValue2 = l.parentValue;
    }
    function yo(l) {
      l.context._currentValue2 = l.value;
    }
    function di(l, f) {
      if (l !== f) {
        mo(l);
        var k = l.parent, R = f.parent;
        if (k === null) {
          if (R !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (R === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          di(k, R);
        }
        yo(f);
      }
    }
    function Ml(l) {
      mo(l);
      var f = l.parent;
      f !== null && Ml(f);
    }
    function fi(l) {
      var f = l.parent;
      f !== null && fi(f), yo(l);
    }
    function Ks(l, f) {
      mo(l);
      var k = l.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      k.depth === f.depth ? di(k, f) : Ks(k, f);
    }
    function Ys(l, f) {
      var k = f.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      l.depth === k.depth ? di(l, k) : Ys(l, k), yo(f);
    }
    function go(l) {
      var f = Tr, k = l;
      f !== k && (f === null ? fi(k) : k === null ? Ml(f) : f.depth === k.depth ? di(f, k) : f.depth > k.depth ? Ks(f, k) : Ys(f, k), Tr = k);
    }
    function pi(l, f) {
      var k;
      k = l._currentValue2, l._currentValue2 = f, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== sa && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = sa;
      var R = Tr, H = {
        parent: R,
        depth: R === null ? 0 : R.depth + 1,
        context: l,
        parentValue: k,
        value: f
      };
      return Tr = H, H;
    }
    function zl(l) {
      var f = Tr;
      if (f === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      f.context !== l && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var k = f.parentValue;
        k === td ? f.context._currentValue2 = f.context._defaultValue : f.context._currentValue2 = k, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== sa && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = sa;
      }
      return Tr = f.parent;
    }
    function nd() {
      return Tr;
    }
    function Fa(l) {
      var f = l._currentValue2;
      return f;
    }
    function vo(l) {
      return l._reactInternals;
    }
    function Bl(l, f) {
      l._reactInternals = f;
    }
    var xo = {}, bo = {}, hi, Eo, Ma, mi, So, za, ko, wo, To;
    {
      hi = /* @__PURE__ */ new Set(), Eo = /* @__PURE__ */ new Set(), Ma = /* @__PURE__ */ new Set(), ko = /* @__PURE__ */ new Set(), mi = /* @__PURE__ */ new Set(), wo = /* @__PURE__ */ new Set(), To = /* @__PURE__ */ new Set();
      var Gs = /* @__PURE__ */ new Set();
      za = function(l, f) {
        if (!(l === null || typeof l == "function")) {
          var k = f + "_" + l;
          Gs.has(k) || (Gs.add(k), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, l));
        }
      }, So = function(l, f) {
        if (f === void 0) {
          var k = xn(l) || "Component";
          mi.has(k) || (mi.add(k), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", k));
        }
      };
    }
    function Xs(l, f) {
      {
        var k = l.constructor, R = k && xn(k) || "ReactClass", H = R + "." + f;
        if (xo[H])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, f, f, R), xo[H] = !0;
      }
    }
    var qs = {
      isMounted: function(l) {
        return !1;
      },
      enqueueSetState: function(l, f, k) {
        var R = vo(l);
        R.queue === null ? Xs(l, "setState") : (R.queue.push(f), k != null && za(k, "setState"));
      },
      enqueueReplaceState: function(l, f, k) {
        var R = vo(l);
        R.replace = !0, R.queue = [f], k != null && za(k, "setState");
      },
      enqueueForceUpdate: function(l, f) {
        var k = vo(l);
        k.queue === null ? Xs(l, "forceUpdate") : f != null && za(f, "setState");
      }
    };
    function rd(l, f, k, R, H) {
      var oe = k(H, R);
      So(f, oe);
      var he = oe == null ? R : cr({}, R, oe);
      return he;
    }
    function ad(l, f, k) {
      var R = Kr, H = l.contextType;
      if ("contextType" in l) {
        var oe = (
          // Allow null for conditional declaration
          H === null || H !== void 0 && H.$$typeof === ai && H._context === void 0
        );
        if (!oe && !To.has(l)) {
          To.add(l);
          var he = "";
          H === void 0 ? he = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof H != "object" ? he = " However, it is set to a " + typeof H + "." : H.$$typeof === ri ? he = " Did you accidentally pass the Context.Provider instead?" : H._context !== void 0 ? he = " Did you accidentally pass the Context.Consumer instead?" : he = " However, it is set to an object with keys {" + Object.keys(H).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", xn(l) || "Component", he);
        }
      }
      typeof H == "object" && H !== null ? R = Fa(H) : R = k;
      var Ae = new l(f, R);
      {
        if (typeof l.getDerivedStateFromProps == "function" && (Ae.state === null || Ae.state === void 0)) {
          var Ie = xn(l) || "Component";
          hi.has(Ie) || (hi.add(Ie), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Ie, Ae.state === null ? "null" : "undefined", Ie));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof Ae.getSnapshotBeforeUpdate == "function") {
          var rt = null, it = null, gt = null;
          if (typeof Ae.componentWillMount == "function" && Ae.componentWillMount.__suppressDeprecationWarning !== !0 ? rt = "componentWillMount" : typeof Ae.UNSAFE_componentWillMount == "function" && (rt = "UNSAFE_componentWillMount"), typeof Ae.componentWillReceiveProps == "function" && Ae.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? it = "componentWillReceiveProps" : typeof Ae.UNSAFE_componentWillReceiveProps == "function" && (it = "UNSAFE_componentWillReceiveProps"), typeof Ae.componentWillUpdate == "function" && Ae.componentWillUpdate.__suppressDeprecationWarning !== !0 ? gt = "componentWillUpdate" : typeof Ae.UNSAFE_componentWillUpdate == "function" && (gt = "UNSAFE_componentWillUpdate"), rt !== null || it !== null || gt !== null) {
            var mn = xn(l) || "Component", Hn = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Ma.has(mn) || (Ma.add(mn), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, mn, Hn, rt !== null ? `
  ` + rt : "", it !== null ? `
  ` + it : "", gt !== null ? `
  ` + gt : ""));
          }
        }
      }
      return Ae;
    }
    function Zs(l, f, k) {
      {
        var R = xn(f) || "Component", H = l.render;
        H || (f.prototype && typeof f.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", R) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", R)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", R), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", R), l.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", R), l.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", R), l.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", R), f.contextType && f.contextTypes && !wo.has(f) && (wo.add(f), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", R)), typeof l.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", R), f.prototype && f.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", xn(f) || "A pure component"), typeof l.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", R), typeof l.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", R), typeof l.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", R), typeof l.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", R);
        var oe = l.props !== k;
        l.props !== void 0 && oe && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", R, R), l.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", R, R), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !Eo.has(f) && (Eo.add(f), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", xn(f))), typeof l.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", R), typeof l.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", R), typeof f.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", R);
        var he = l.state;
        he && (typeof he != "object" || bn(he)) && i("%s.state: must be set to an object or null", R), typeof l.getChildContext == "function" && typeof f.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", R);
      }
    }
    function id(l, f) {
      var k = f.state;
      if (typeof f.componentWillMount == "function") {
        if (f.componentWillMount.__suppressDeprecationWarning !== !0) {
          var R = xn(l) || "Unknown";
          bo[R] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            R
          ), bo[R] = !0);
        }
        f.componentWillMount();
      }
      typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), k !== f.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", xn(l) || "Component"), qs.enqueueReplaceState(f, f.state, null));
    }
    function od(l, f, k, R) {
      if (l.queue !== null && l.queue.length > 0) {
        var H = l.queue, oe = l.replace;
        if (l.queue = null, l.replace = !1, oe && H.length === 1)
          f.state = H[0];
        else {
          for (var he = oe ? H[0] : f.state, Ae = !0, Ie = oe ? 1 : 0; Ie < H.length; Ie++) {
            var rt = H[Ie], it = typeof rt == "function" ? rt.call(f, he, k, R) : rt;
            it != null && (Ae ? (Ae = !1, he = cr({}, he, it)) : cr(he, it));
          }
          f.state = he;
        }
      } else
        l.queue = null;
    }
    function Co(l, f, k, R) {
      Zs(l, f, k);
      var H = l.state !== void 0 ? l.state : null;
      l.updater = qs, l.props = k, l.state = H;
      var oe = {
        queue: [],
        replace: !1
      };
      Bl(l, oe);
      var he = f.contextType;
      if (typeof he == "object" && he !== null ? l.context = Fa(he) : l.context = R, l.state === k) {
        var Ae = xn(f) || "Component";
        ko.has(Ae) || (ko.add(Ae), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Ae));
      }
      var Ie = f.getDerivedStateFromProps;
      typeof Ie == "function" && (l.state = rd(l, f, Ie, H, k)), typeof f.getDerivedStateFromProps != "function" && typeof l.getSnapshotBeforeUpdate != "function" && (typeof l.UNSAFE_componentWillMount == "function" || typeof l.componentWillMount == "function") && (id(f, l), od(oe, l, k, R));
    }
    var Ao = {
      id: 1,
      overflow: ""
    };
    function ld(l) {
      var f = l.overflow, k = l.id, R = k & ~sd(k);
      return R.toString(32) + f;
    }
    function Il(l, f, k) {
      var R = l.id, H = l.overflow, oe = Lo(R) - 1, he = R & ~(1 << oe), Ae = k + 1, Ie = Lo(f) + oe;
      if (Ie > 30) {
        var rt = oe - oe % 5, it = (1 << rt) - 1, gt = (he & it).toString(32), mn = he >> rt, Hn = oe - rt, br = Lo(f) + Hn, xu = Ae << Hn, bu = xu | mn, Eu = gt + H;
        return {
          id: 1 << br | bu,
          overflow: Eu
        };
      } else {
        var jo = Ae << oe, bg = jo | he, Eg = H;
        return {
          id: 1 << Ie | bg,
          overflow: Eg
        };
      }
    }
    function Lo(l) {
      return 32 - ud(l);
    }
    function sd(l) {
      return 1 << Lo(l) - 1;
    }
    var ud = Math.clz32 ? Math.clz32 : Or, cd = Math.log, dd = Math.LN2;
    function Or(l) {
      var f = l >>> 0;
      return f === 0 ? 32 : 31 - (cd(f) / dd | 0) | 0;
    }
    function $l(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var Po = typeof Object.is == "function" ? Object.is : $l, Mt = null, ua = null, ca = null, en = null, gr = !1, da = !1, Ro = 0, $n = null, Fr = 0, fa = 25, Cr = !1, pa;
    function Mr() {
      if (Mt === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Cr && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Mt;
    }
    function fd(l, f) {
      if (f === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", pa), !1;
      l.length !== f.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, pa, "[" + l.join(", ") + "]", "[" + f.join(", ") + "]");
      for (var k = 0; k < f.length && k < l.length; k++)
        if (!Po(l[k], f[k]))
          return !1;
      return !0;
    }
    function Qs() {
      if (Fr > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function No() {
      return en === null ? ca === null ? (gr = !1, ca = en = Qs()) : (gr = !0, en = ca) : en.next === null ? (gr = !1, en = en.next = Qs()) : (gr = !0, en = en.next), en;
    }
    function Hl(l, f) {
      Mt = f, ua = l, Cr = !1, Ro = 0;
    }
    function pd(l, f, k, R) {
      for (; da; )
        da = !1, Ro = 0, Fr += 1, en = null, k = l(f, R);
      return yi(), k;
    }
    function Js() {
      var l = Ro !== 0;
      return l;
    }
    function yi() {
      Cr = !1, Mt = null, ua = null, da = !1, ca = null, Fr = 0, $n = null, en = null;
    }
    function hd(l) {
      return Cr && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Fa(l);
    }
    function eu(l) {
      return pa = "useContext", Mr(), Fa(l);
    }
    function Do(l, f) {
      return typeof f == "function" ? f(l) : f;
    }
    function md(l) {
      return pa = "useState", tu(
        Do,
        // useReducer has a special case to support lazy useState initializers
        l
      );
    }
    function tu(l, f, k) {
      if (l !== Do && (pa = "useReducer"), Mt = Mr(), en = No(), gr) {
        var R = en.queue, H = R.dispatch;
        if ($n !== null) {
          var oe = $n.get(R);
          if (oe !== void 0) {
            $n.delete(R);
            var he = en.memoizedState, Ae = oe;
            do {
              var Ie = Ae.action;
              Cr = !0, he = l(he, Ie), Cr = !1, Ae = Ae.next;
            } while (Ae !== null);
            return en.memoizedState = he, [he, H];
          }
        }
        return [en.memoizedState, H];
      } else {
        Cr = !0;
        var rt;
        l === Do ? rt = typeof f == "function" ? f() : f : rt = k !== void 0 ? k(f) : f, Cr = !1, en.memoizedState = rt;
        var it = en.queue = {
          last: null,
          dispatch: null
        }, gt = it.dispatch = vd.bind(null, Mt, it);
        return [en.memoizedState, gt];
      }
    }
    function nu(l, f) {
      Mt = Mr(), en = No();
      var k = f === void 0 ? null : f;
      if (en !== null) {
        var R = en.memoizedState;
        if (R !== null && k !== null) {
          var H = R[1];
          if (fd(k, H))
            return R[0];
        }
      }
      Cr = !0;
      var oe = l();
      return Cr = !1, en.memoizedState = [oe, k], oe;
    }
    function yd(l) {
      Mt = Mr(), en = No();
      var f = en.memoizedState;
      if (f === null) {
        var k = {
          current: l
        };
        return Object.seal(k), en.memoizedState = k, k;
      } else
        return f;
    }
    function gd(l, f) {
      pa = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function vd(l, f, k) {
      if (Fr >= fa)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (l === Mt) {
        da = !0;
        var R = {
          action: k,
          next: null
        };
        $n === null && ($n = /* @__PURE__ */ new Map());
        var H = $n.get(f);
        if (H === void 0)
          $n.set(f, R);
        else {
          for (var oe = H; oe.next !== null; )
            oe = oe.next;
          oe.next = R;
        }
      }
    }
    function xd(l, f) {
      return nu(function() {
        return l;
      }, f);
    }
    function bd(l, f, k) {
      return Mr(), f(l._source);
    }
    function Ed(l, f, k) {
      if (k === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return k();
    }
    function Sd(l) {
      return Mr(), l;
    }
    function _o() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function ru() {
      return Mr(), [!1, _o];
    }
    function Vl() {
      var l = ua, f = ld(l.treeContext), k = vi;
      if (k === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var R = Ro++;
      return ln(k, f, R);
    }
    function gi() {
    }
    var au = {
      readContext: hd,
      useContext: eu,
      useMemo: nu,
      useReducer: tu,
      useRef: yd,
      useState: md,
      useInsertionEffect: gi,
      useLayoutEffect: gd,
      useCallback: xd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: gi,
      // Effects are not run in the server environment.
      useEffect: gi,
      // Debugging effect
      useDebugValue: gi,
      useDeferredValue: Sd,
      useTransition: ru,
      useId: Vl,
      // Subscriptions are not setup in a server environment.
      useMutableSource: bd,
      useSyncExternalStore: Ed
    }, vi = null;
    function Oo(l) {
      vi = l;
    }
    function Wl(l) {
      try {
        var f = "", k = l;
        do {
          switch (k.tag) {
            case 0:
              f += ui(k.type, null, null);
              break;
            case 1:
              f += Nl(k.type, null, null);
              break;
            case 2:
              f += Rl(k.type, null, null);
              break;
          }
          k = k.parent;
        } while (k);
        return f;
      } catch (R) {
        return `
Error generating stack: ` + R.message + `
` + R.stack;
      }
    }
    var Yr = r.ReactCurrentDispatcher, Fo = r.ReactDebugCurrentFrame, Mo = 0, ha = 1, iu = 2, jl = 3, ma = 4, kd = 0, ou = 1, Ar = 2, wd = 12800;
    function Td(l) {
      return console.error(l), null;
    }
    function xi() {
    }
    function Ul(l, f, k, R, H, oe, he, Ae, Ie) {
      var rt = [], it = /* @__PURE__ */ new Set(), gt = {
        destination: null,
        responseState: f,
        progressiveChunkSize: R === void 0 ? wd : R,
        status: kd,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: it,
        pingedTasks: rt,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: H === void 0 ? Td : H,
        onAllReady: oe === void 0 ? xi : oe,
        onShellReady: he === void 0 ? xi : he,
        onShellError: Ae === void 0 ? xi : Ae,
        onFatalError: Ie === void 0 ? xi : Ie
      }, mn = Gr(
        gt,
        0,
        null,
        k,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      mn.parentFlushed = !0;
      var Hn = bi(gt, l, null, mn, it, Kr, Fl, Ao);
      return rt.push(Hn), gt;
    }
    function zo(l, f) {
      var k = l.pingedTasks;
      k.push(f), k.length === 1 && d(function() {
        return gu(l);
      });
    }
    function zr(l, f) {
      return {
        id: Ln,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: f,
        errorDigest: null
      };
    }
    function bi(l, f, k, R, H, oe, he, Ae) {
      l.allPendingTasks++, k === null ? l.pendingRootTasks++ : k.pendingTasks++;
      var Ie = {
        node: f,
        ping: function() {
          return zo(l, Ie);
        },
        blockedBoundary: k,
        blockedSegment: R,
        abortSet: H,
        legacyContext: oe,
        context: he,
        treeContext: Ae
      };
      return Ie.componentStack = null, H.add(Ie), Ie;
    }
    function Gr(l, f, k, R, H, oe) {
      return {
        status: Mo,
        id: -1,
        // lazily assigned later
        index: f,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: R,
        boundary: k,
        lastPushedText: H,
        textEmbedded: oe
      };
    }
    var Lr = null;
    function Kl() {
      return Lr === null || Lr.componentStack === null ? "" : Wl(Lr.componentStack);
    }
    function vr(l, f) {
      l.componentStack = {
        tag: 0,
        parent: l.componentStack,
        type: f
      };
    }
    function Ba(l, f) {
      l.componentStack = {
        tag: 1,
        parent: l.componentStack,
        type: f
      };
    }
    function Yl(l, f) {
      l.componentStack = {
        tag: 2,
        parent: l.componentStack,
        type: f
      };
    }
    function xr(l) {
      l.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : l.componentStack = l.componentStack.parent;
    }
    var Xr = null;
    function Gl(l, f) {
      {
        var k;
        typeof f == "string" ? k = f : f && typeof f.message == "string" ? k = f.message : k = String(f);
        var R = Xr || Kl();
        Xr = null, l.errorMessage = k, l.errorComponentStack = R;
      }
    }
    function Ei(l, f) {
      var k = l.onError(f);
      if (k != null && typeof k != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof k + '" instead');
      return k;
    }
    function Bo(l, f) {
      var k = l.onShellError;
      k(f);
      var R = l.onFatalError;
      R(f), l.destination !== null ? (l.status = Ar, S(l.destination, f)) : (l.status = ou, l.fatalError = f);
    }
    function lu(l, f, k) {
      vr(f, "Suspense");
      var R = f.blockedBoundary, H = f.blockedSegment, oe = k.fallback, he = k.children, Ae = /* @__PURE__ */ new Set(), Ie = zr(l, Ae), rt = H.chunks.length, it = Gr(
        l,
        rt,
        Ie,
        H.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      H.children.push(it), H.lastPushedText = !1;
      var gt = Gr(
        l,
        0,
        null,
        H.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      gt.parentFlushed = !0, f.blockedBoundary = Ie, f.blockedSegment = gt;
      try {
        if (Io(l, f, he), Fs(gt.chunks, l.responseState, gt.lastPushedText, gt.textEmbedded), gt.status = ha, wi(Ie, gt), Ie.pendingTasks === 0) {
          xr(f);
          return;
        }
      } catch (Hn) {
        gt.status = ma, Ie.forceClientRender = !0, Ie.errorDigest = Ei(l, Hn), Gl(Ie, Hn);
      } finally {
        f.blockedBoundary = R, f.blockedSegment = H;
      }
      var mn = bi(l, oe, R, it, Ae, f.legacyContext, f.context, f.treeContext);
      mn.componentStack = f.componentStack, l.pingedTasks.push(mn), xr(f);
    }
    function su(l, f, k, R) {
      vr(f, k);
      var H = f.blockedSegment, oe = kr(H.chunks, k, R, l.responseState, H.formatContext);
      H.lastPushedText = !1;
      var he = H.formatContext;
      H.formatContext = Wn(he, k, R), Io(l, f, oe), H.formatContext = he, lr(H.chunks, k), H.lastPushedText = !1, xr(f);
    }
    function Cd(l) {
      return l.prototype && l.prototype.isReactComponent;
    }
    function Xl(l, f, k, R, H) {
      var oe = {};
      Hl(f, oe);
      var he = k(R, H);
      return pd(k, R, he, H);
    }
    function Si(l, f, k, R, H) {
      var oe = k.render();
      k.props !== H && (Jl || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", xn(R) || "a component"), Jl = !0);
      {
        var he = R.childContextTypes;
        if (he != null) {
          var Ae = f.legacyContext, Ie = la(k, R, Ae, he);
          f.legacyContext = Ie, fr(l, f, oe), f.legacyContext = Ae;
          return;
        }
      }
      fr(l, f, oe);
    }
    function uu(l, f, k, R) {
      Yl(f, k);
      var H = Us(k, f.legacyContext), oe = ad(k, R, H);
      Co(oe, k, R, H), Si(l, f, oe, k, R), xr(f);
    }
    var ql = {}, ki = {}, Zl = {}, Ql = {}, Jl = !1, cu = !1, du = !1, es = !1;
    function Ad(l, f, k, R) {
      var H;
      if (H = Us(k, f.legacyContext), Ba(f, k), k.prototype && typeof k.prototype.render == "function") {
        var oe = xn(k) || "Unknown";
        ql[oe] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", oe, oe), ql[oe] = !0);
      }
      var he = Xl(l, f, k, R, H), Ae = Js();
      if (typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0) {
        var Ie = xn(k) || "Unknown";
        ki[Ie] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ie, Ie, Ie), ki[Ie] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0
      ) {
        {
          var rt = xn(k) || "Unknown";
          ki[rt] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", rt, rt, rt), ki[rt] = !0);
        }
        Co(he, k, R, H), Si(l, f, he, k, R);
      } else if (Ld(k), Ae) {
        var it = f.treeContext, gt = 1, mn = 0;
        f.treeContext = Il(it, gt, mn);
        try {
          fr(l, f, he);
        } finally {
          f.treeContext = it;
        }
      } else
        fr(l, f, he);
      xr(f);
    }
    function Ld(l) {
      {
        if (l && l.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), typeof l.getDerivedStateFromProps == "function") {
          var f = xn(l) || "Unknown";
          Ql[f] || (i("%s: Function components do not support getDerivedStateFromProps.", f), Ql[f] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var k = xn(l) || "Unknown";
          Zl[k] || (i("%s: Function components do not support contextType.", k), Zl[k] = !0);
        }
      }
    }
    function fu(l, f) {
      if (l && l.defaultProps) {
        var k = cr({}, f), R = l.defaultProps;
        for (var H in R)
          k[H] === void 0 && (k[H] = R[H]);
        return k;
      }
      return f;
    }
    function Pd(l, f, k, R, H) {
      Ba(f, k.render);
      var oe = Xl(l, f, k.render, R, H), he = Js();
      if (he) {
        var Ae = f.treeContext, Ie = 1, rt = 0;
        f.treeContext = Il(Ae, Ie, rt);
        try {
          fr(l, f, oe);
        } finally {
          f.treeContext = Ae;
        }
      } else
        fr(l, f, oe);
      xr(f);
    }
    function Rd(l, f, k, R, H) {
      var oe = k.type, he = fu(oe, R);
      ns(l, f, oe, he, H);
    }
    function ts(l, f, k, R) {
      k._context === void 0 ? k !== k.Consumer && (es || (es = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : k = k._context;
      var H = R.children;
      typeof H != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var oe = Fa(k), he = H(oe);
      fr(l, f, he);
    }
    function Nd(l, f, k, R) {
      var H = k._context, oe = R.value, he = R.children, Ae;
      Ae = f.context, f.context = pi(H, oe), fr(l, f, he), f.context = zl(H), Ae !== f.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function dr(l, f, k, R, H) {
      vr(f, "Lazy");
      var oe = k._payload, he = k._init, Ae = he(oe), Ie = fu(Ae, R);
      ns(l, f, Ae, Ie, H), xr(f);
    }
    function ns(l, f, k, R, H) {
      if (typeof k == "function")
        if (Cd(k)) {
          uu(l, f, k, R);
          return;
        } else {
          Ad(l, f, k, R);
          return;
        }
      if (typeof k == "string") {
        su(l, f, k, R);
        return;
      }
      switch (k) {
        case ed:
        case Bs:
        case so:
        case uo:
        case lo: {
          fr(l, f, R.children);
          return;
        }
        case bl: {
          vr(f, "SuspenseList"), fr(l, f, R.children), xr(f);
          return;
        }
        case Jc:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Na: {
          lu(l, f, R);
          return;
        }
      }
      if (typeof k == "object" && k !== null)
        switch (k.$$typeof) {
          case ii: {
            Pd(l, f, k, R, H);
            return;
          }
          case El: {
            Rd(l, f, k, R, H);
            return;
          }
          case ri: {
            Nd(l, f, k, R);
            return;
          }
          case ai: {
            ts(l, f, k, R);
            return;
          }
          case co: {
            dr(l, f, k, R);
            return;
          }
        }
      var oe = "";
      throw (k === void 0 || typeof k == "object" && k !== null && Object.keys(k).length === 0) && (oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (k == null ? k : typeof k) + "." + oe));
    }
    function pu(l, f) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      l[Symbol.toStringTag] === "Generator" && (cu || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), cu = !0), l.entries === f && (du || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), du = !0);
    }
    function fr(l, f, k) {
      try {
        return rs(l, f, k);
      } catch (R) {
        throw typeof R == "object" && R !== null && typeof R.then == "function" || (Xr = Xr !== null ? Xr : Kl()), R;
      }
    }
    function rs(l, f, k) {
      if (f.node = k, typeof k == "object" && k !== null) {
        switch (k.$$typeof) {
          case zs: {
            var R = k, H = R.type, oe = R.props, he = R.ref;
            ns(l, f, H, oe, he);
            return;
          }
          case xl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case co: {
            var Ae = k, Ie = Ae._payload, rt = Ae._init, it;
            try {
              it = rt(Ie);
            } catch (jo) {
              throw typeof jo == "object" && jo !== null && typeof jo.then == "function" && vr(f, "Lazy"), jo;
            }
            fr(l, f, it);
            return;
          }
        }
        if (bn(k)) {
          hu(l, f, k);
          return;
        }
        var gt = En(k);
        if (gt) {
          pu(k, gt);
          var mn = gt.call(k);
          if (mn) {
            var Hn = mn.next();
            if (!Hn.done) {
              var br = [];
              do
                br.push(Hn.value), Hn = mn.next();
              while (!Hn.done);
              hu(l, f, br);
              return;
            }
            return;
          }
        }
        var xu = Object.prototype.toString.call(k);
        throw new Error("Objects are not valid as a React child (found: " + (xu === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : xu) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof k == "string") {
        var bu = f.blockedSegment;
        bu.lastPushedText = Os(f.blockedSegment.chunks, k, l.responseState, bu.lastPushedText);
        return;
      }
      if (typeof k == "number") {
        var Eu = f.blockedSegment;
        Eu.lastPushedText = Os(f.blockedSegment.chunks, "" + k, l.responseState, Eu.lastPushedText);
        return;
      }
      typeof k == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function hu(l, f, k) {
      for (var R = k.length, H = 0; H < R; H++) {
        var oe = f.treeContext;
        f.treeContext = Il(oe, R, H);
        try {
          Io(l, f, k[H]);
        } finally {
          f.treeContext = oe;
        }
      }
    }
    function Dd(l, f, k) {
      var R = f.blockedSegment, H = R.chunks.length, oe = Gr(
        l,
        H,
        null,
        R.formatContext,
        // Adopt the parent segment's leading text embed
        R.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      R.children.push(oe), R.lastPushedText = !1;
      var he = bi(l, f.node, f.blockedBoundary, oe, f.abortSet, f.legacyContext, f.context, f.treeContext);
      f.componentStack !== null && (he.componentStack = f.componentStack.parent);
      var Ae = he.ping;
      k.then(Ae, Ae);
    }
    function Io(l, f, k) {
      var R = f.blockedSegment.formatContext, H = f.legacyContext, oe = f.context, he = null;
      he = f.componentStack;
      try {
        return fr(l, f, k);
      } catch (Ae) {
        if (yi(), typeof Ae == "object" && Ae !== null && typeof Ae.then == "function") {
          Dd(l, f, Ae), f.blockedSegment.formatContext = R, f.legacyContext = H, f.context = oe, go(oe), f.componentStack = he;
          return;
        } else
          throw f.blockedSegment.formatContext = R, f.legacyContext = H, f.context = oe, go(oe), f.componentStack = he, Ae;
      }
    }
    function $o(l, f, k, R) {
      var H = Ei(l, R);
      if (f === null ? Bo(l, R) : (f.pendingTasks--, f.forceClientRender || (f.forceClientRender = !0, f.errorDigest = H, Gl(f, R), f.parentFlushed && l.clientRenderedBoundaries.push(f))), l.allPendingTasks--, l.allPendingTasks === 0) {
        var oe = l.onAllReady;
        oe();
      }
    }
    function mu(l) {
      var f = this, k = l.blockedBoundary, R = l.blockedSegment;
      R.status = jl, Ti(f, k, R);
    }
    function yu(l, f, k) {
      var R = l.blockedBoundary, H = l.blockedSegment;
      if (H.status = jl, R === null)
        f.allPendingTasks--, f.status !== Ar && (f.status = Ar, f.destination !== null && g(f.destination));
      else {
        if (R.pendingTasks--, !R.forceClientRender) {
          R.forceClientRender = !0;
          var oe = k === void 0 ? new Error("The render was aborted by the server without a reason.") : k;
          R.errorDigest = f.onError(oe);
          {
            var he = "The server did not finish this Suspense boundary: ";
            oe && typeof oe.message == "string" ? oe = he + oe.message : oe = he + String(oe);
            var Ae = Lr;
            Lr = l;
            try {
              Gl(R, oe);
            } finally {
              Lr = Ae;
            }
          }
          R.parentFlushed && f.clientRenderedBoundaries.push(R);
        }
        if (R.fallbackAbortableTasks.forEach(function(rt) {
          return yu(rt, f, k);
        }), R.fallbackAbortableTasks.clear(), f.allPendingTasks--, f.allPendingTasks === 0) {
          var Ie = f.onAllReady;
          Ie();
        }
      }
    }
    function wi(l, f) {
      if (f.chunks.length === 0 && f.children.length === 1 && f.children[0].boundary === null) {
        var k = f.children[0];
        k.id = f.id, k.parentFlushed = !0, k.status === ha && wi(l, k);
      } else {
        var R = l.completedSegments;
        R.push(f);
      }
    }
    function Ti(l, f, k) {
      if (f === null) {
        if (k.parentFlushed) {
          if (l.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          l.completedRootSegment = k;
        }
        if (l.pendingRootTasks--, l.pendingRootTasks === 0) {
          l.onShellError = xi;
          var R = l.onShellReady;
          R();
        }
      } else if (f.pendingTasks--, !f.forceClientRender) {
        if (f.pendingTasks === 0)
          k.parentFlushed && k.status === ha && wi(f, k), f.parentFlushed && l.completedBoundaries.push(f), f.fallbackAbortableTasks.forEach(mu, l), f.fallbackAbortableTasks.clear();
        else if (k.parentFlushed && k.status === ha) {
          wi(f, k);
          var H = f.completedSegments;
          H.length === 1 && f.parentFlushed && l.partialBoundaries.push(f);
        }
      }
      if (l.allPendingTasks--, l.allPendingTasks === 0) {
        var oe = l.onAllReady;
        oe();
      }
    }
    function Ho(l, f) {
      var k = f.blockedSegment;
      if (k.status === Mo) {
        go(f.context);
        var R = null;
        R = Lr, Lr = f;
        try {
          fr(l, f, f.node), Fs(k.chunks, l.responseState, k.lastPushedText, k.textEmbedded), f.abortSet.delete(f), k.status = ha, Ti(l, f.blockedBoundary, k);
        } catch (oe) {
          if (yi(), typeof oe == "object" && oe !== null && typeof oe.then == "function") {
            var H = f.ping;
            oe.then(H, H);
          } else
            f.abortSet.delete(f), k.status = ma, $o(l, f.blockedBoundary, k, oe);
        } finally {
          Lr = R;
        }
      }
    }
    function gu(l) {
      if (l.status !== Ar) {
        var f = nd(), k = Yr.current;
        Yr.current = au;
        var R;
        R = Fo.getCurrentStack, Fo.getCurrentStack = Kl;
        var H = vi;
        Oo(l.responseState);
        try {
          var oe = l.pingedTasks, he;
          for (he = 0; he < oe.length; he++) {
            var Ae = oe[he];
            Ho(l, Ae);
          }
          oe.splice(0, he), l.destination !== null && Wo(l, l.destination);
        } catch (Ie) {
          Ei(l, Ie), Bo(l, Ie);
        } finally {
          Oo(H), Yr.current = k, Fo.getCurrentStack = R, k === au && go(f);
        }
      }
    }
    function Ci(l, f, k) {
      switch (k.parentFlushed = !0, k.status) {
        case Mo: {
          var R = k.id = l.nextSegmentId++;
          return k.lastPushedText = !1, k.textEmbedded = !1, Gi(f, l.responseState, R);
        }
        case ha: {
          k.status = iu;
          for (var H = !0, oe = k.chunks, he = 0, Ae = k.children, Ie = 0; Ie < Ae.length; Ie++) {
            for (var rt = Ae[Ie]; he < rt.index; he++)
              s(f, oe[he]);
            H = Ai(l, f, rt);
          }
          for (; he < oe.length - 1; he++)
            s(f, oe[he]);
          return he < oe.length && (H = p(f, oe[he])), H;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ai(l, f, k) {
      var R = k.boundary;
      if (R === null)
        return Ci(l, f, k);
      if (R.parentFlushed = !0, R.forceClientRender)
        return yr(f, l.responseState, R.errorDigest, R.errorMessage, R.errorComponentStack), Ci(l, f, k), Ms(f, l.responseState);
      if (R.pendingTasks > 0) {
        R.rootSegmentID = l.nextSegmentId++, R.completedSegments.length > 0 && l.partialBoundaries.push(R);
        var H = R.id = Tn(l.responseState);
        return Ur(f, l.responseState, H), Ci(l, f, k), ei(f, l.responseState);
      } else {
        if (R.byteSize > l.progressiveChunkSize)
          return R.rootSegmentID = l.nextSegmentId++, l.completedBoundaries.push(R), Ur(f, l.responseState, R.id), Ci(l, f, k), ei(f, l.responseState);
        vl(f, l.responseState);
        var oe = R.completedSegments;
        if (oe.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var he = oe[0];
        return Ai(l, f, he), Qc(f, l.responseState);
      }
    }
    function _d(l, f, k) {
      return Xc(f, l.responseState, k.id, k.errorDigest, k.errorMessage, k.errorComponentStack);
    }
    function as(l, f, k) {
      return Ee(f, l.responseState, k.formatContext, k.id), Ai(l, f, k), Fe(f, k.formatContext);
    }
    function Vo(l, f, k) {
      for (var R = k.completedSegments, H = 0; H < R.length; H++) {
        var oe = R[H];
        vu(l, f, k, oe);
      }
      return R.length = 0, jc(f, l.responseState, k.id, k.rootSegmentID);
    }
    function Od(l, f, k) {
      for (var R = k.completedSegments, H = 0; H < R.length; H++) {
        var oe = R[H];
        if (!vu(l, f, k, oe))
          return H++, R.splice(0, H), !1;
      }
      return R.splice(0, H), !0;
    }
    function vu(l, f, k, R) {
      if (R.status === iu)
        return !0;
      var H = R.id;
      if (H === -1) {
        var oe = R.id = k.rootSegmentID;
        if (oe === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return as(l, f, R);
      } else
        return as(l, f, R), ur(f, l.responseState, H);
    }
    function Wo(l, f) {
      try {
        var k = l.completedRootSegment;
        k !== null && l.pendingRootTasks === 0 && (Ai(l, f, k), l.completedRootSegment = null, qa(f, l.responseState));
        var R = l.clientRenderedBoundaries, H;
        for (H = 0; H < R.length; H++) {
          var oe = R[H];
          if (!_d(l, f, oe)) {
            l.destination = null, H++, R.splice(0, H);
            return;
          }
        }
        R.splice(0, H);
        var he = l.completedBoundaries;
        for (H = 0; H < he.length; H++) {
          var Ae = he[H];
          if (!Vo(l, f, Ae)) {
            l.destination = null, H++, he.splice(0, H);
            return;
          }
        }
        he.splice(0, H);
        var Ie = l.partialBoundaries;
        for (H = 0; H < Ie.length; H++) {
          var rt = Ie[H];
          if (!Od(l, f, rt)) {
            l.destination = null, H++, Ie.splice(0, H);
            return;
          }
        }
        Ie.splice(0, H);
        var it = l.completedBoundaries;
        for (H = 0; H < it.length; H++) {
          var gt = it[H];
          if (!Vo(l, f, gt)) {
            l.destination = null, H++, it.splice(0, H);
            return;
          }
        }
        it.splice(0, H);
      } finally {
        l.allPendingTasks === 0 && l.pingedTasks.length === 0 && l.clientRenderedBoundaries.length === 0 && l.completedBoundaries.length === 0 && (l.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), g(f));
      }
    }
    function Fd(l) {
      d(function() {
        return gu(l);
      });
    }
    function u(l, f) {
      if (l.status === ou) {
        l.status = Ar, S(f, l.fatalError);
        return;
      }
      if (l.status !== Ar && l.destination === null) {
        l.destination = f;
        try {
          Wo(l, f);
        } catch (k) {
          Ei(l, k), Bo(l, k);
        }
      }
    }
    function h(l, f) {
      try {
        var k = l.abortableTasks;
        k.forEach(function(R) {
          return yu(R, l, f);
        }), k.clear(), l.destination !== null && Wo(l, l.destination);
      } catch (R) {
        Ei(l, R), Bo(l, R);
      }
    }
    function C() {
    }
    function z(l, f, k, R) {
      var H = !1, oe = null, he = "", Ae = {
        push: function(gt) {
          return gt !== null && (he += gt), !0;
        },
        destroy: function(gt) {
          H = !0, oe = gt;
        }
      }, Ie = !1;
      function rt() {
        Ie = !0;
      }
      var it = Ul(l, Zc(k, f ? f.identifierPrefix : void 0), gl(), 1 / 0, C, void 0, rt, void 0, void 0);
      if (Fd(it), h(it, R), u(it, Ae), H)
        throw oe;
      if (!Ie)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return he;
    }
    function G(l, f) {
      return z(l, f, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function ce(l, f) {
      return z(l, f, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function me() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Le() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Di.renderToNodeStream = me, Di.renderToStaticMarkup = ce, Di.renderToStaticNodeStream = Le, Di.renderToString = G, Di.version = t;
  }()), Di;
}
var Mu = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tm;
function ES() {
  return tm || (tm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = se, t = "18.2.0", r = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(u) {
      {
        for (var h = arguments.length, C = new Array(h > 1 ? h - 1 : 0), z = 1; z < h; z++)
          C[z - 1] = arguments[z];
        o("warn", u, C);
      }
    }
    function i(u) {
      {
        for (var h = arguments.length, C = new Array(h > 1 ? h - 1 : 0), z = 1; z < h; z++)
          C[z - 1] = arguments[z];
        o("error", u, C);
      }
    }
    function o(u, h, C) {
      {
        var z = r.ReactDebugCurrentFrame, G = z.getStackAddendum();
        G !== "" && (h += "%s", C = C.concat([G]));
        var ce = C.map(function(me) {
          return String(me);
        });
        ce.unshift("Warning: " + h), Function.prototype.apply.call(console[u], console, ce);
      }
    }
    function d(u) {
      u();
    }
    var c = 512, s = null, p = 0;
    function y(u) {
      s = new Uint8Array(c), p = 0;
    }
    function g(u, h) {
      if (h.length !== 0) {
        if (h.length > c) {
          p > 0 && (u.enqueue(new Uint8Array(s.buffer, 0, p)), s = new Uint8Array(c), p = 0), u.enqueue(h);
          return;
        }
        var C = h, z = s.length - p;
        z < C.length && (z === 0 ? u.enqueue(s) : (s.set(C.subarray(0, z), p), u.enqueue(s), C = C.subarray(z)), s = new Uint8Array(c), p = 0), s.set(C, p), p += C.length;
      }
    }
    function b(u, h) {
      return g(u, h), !0;
    }
    function w(u) {
      s && p > 0 && (u.enqueue(new Uint8Array(s.buffer, 0, p)), s = null, p = 0);
    }
    function S(u) {
      u.close();
    }
    var L = new TextEncoder();
    function m(u) {
      return L.encode(u);
    }
    function v(u) {
      return L.encode(u);
    }
    function A(u, h) {
      typeof u.error == "function" ? u.error(h) : u.close();
    }
    function P(u) {
      {
        var h = typeof Symbol == "function" && Symbol.toStringTag, C = h && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return C;
      }
    }
    function T(u) {
      try {
        return _(u), !1;
      } catch {
        return !0;
      }
    }
    function _(u) {
      return "" + u;
    }
    function M(u, h) {
      if (T(u))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", h, P(u)), _(u);
    }
    function Z(u, h) {
      if (T(u))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", h, P(u)), _(u);
    }
    function Y(u) {
      if (T(u))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", P(u)), _(u);
    }
    var ae = Object.prototype.hasOwnProperty, j = 0, q = 1, te = 2, le = 3, B = 4, X = 5, ue = 6, ne = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", J = ne + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", W = new RegExp("^[" + ne + "][" + J + "]*$"), K = {}, ee = {};
    function $(u) {
      return ae.call(ee, u) ? !0 : ae.call(K, u) ? !1 : W.test(u) ? (ee[u] = !0, !0) : (K[u] = !0, i("Invalid attribute name: `%s`", u), !1);
    }
    function pe(u, h, C, z) {
      if (C !== null && C.type === j)
        return !1;
      switch (typeof h) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (z)
            return !1;
          if (C !== null)
            return !C.acceptsBooleans;
          var G = u.toLowerCase().slice(0, 5);
          return G !== "data-" && G !== "aria-";
        }
        default:
          return !1;
      }
    }
    function ve(u) {
      return ye.hasOwnProperty(u) ? ye[u] : null;
    }
    function Te(u, h, C, z, G, ce, me) {
      this.acceptsBooleans = h === te || h === le || h === B, this.attributeName = z, this.attributeNamespace = G, this.mustUseProperty = C, this.propertyName = u, this.type = h, this.sanitizeURL = ce, this.removeEmptyString = me;
    }
    var ye = {}, Re = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Re.forEach(function(u) {
      ye[u] = new Te(
        u,
        j,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(u) {
      var h = u[0], C = u[1];
      ye[h] = new Te(
        h,
        q,
        !1,
        // mustUseProperty
        C,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(u) {
      ye[u] = new Te(
        u,
        te,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(u) {
      ye[u] = new Te(
        u,
        te,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(u) {
      ye[u] = new Te(
        u,
        le,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      ye[u] = new Te(
        u,
        le,
        !0,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      ye[u] = new Te(
        u,
        B,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      ye[u] = new Te(
        u,
        ue,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(u) {
      ye[u] = new Te(
        u,
        X,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Xe = /[\-\:]([a-z])/g, Ce = function(u) {
      return u[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(Xe, Ce);
      ye[h] = new Te(
        h,
        q,
        !1,
        // mustUseProperty
        u,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(Xe, Ce);
      ye[h] = new Te(
        h,
        q,
        !1,
        // mustUseProperty
        u,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(Xe, Ce);
      ye[h] = new Te(
        h,
        q,
        !1,
        // mustUseProperty
        u,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(u) {
      ye[u] = new Te(
        u,
        q,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var xe = "xlinkHref";
    ye[xe] = new Te(
      "xlinkHref",
      q,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(u) {
      ye[u] = new Te(
        u,
        q,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Pe = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function de(u, h) {
      return u + h.charAt(0).toUpperCase() + h.substring(1);
    }
    var Be = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Pe).forEach(function(u) {
      Be.forEach(function(h) {
        Pe[de(h, u)] = Pe[u];
      });
    });
    var Ne = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function He(u, h) {
      Ne[h.type] || h.onChange || h.onInput || h.readOnly || h.disabled || h.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), h.onChange || h.readOnly || h.disabled || h.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ze(u, h) {
      if (u.indexOf("-") === -1)
        return typeof h.is == "string";
      switch (u) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var $e = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ye = {}, qe = new RegExp("^(aria)-[" + J + "]*$"), Ve = new RegExp("^(aria)[A-Z][" + J + "]*$");
    function Ge(u, h) {
      {
        if (ae.call(Ye, h) && Ye[h])
          return !0;
        if (Ve.test(h)) {
          var C = "aria-" + h.slice(4).toLowerCase(), z = $e.hasOwnProperty(C) ? C : null;
          if (z == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", h), Ye[h] = !0, !0;
          if (h !== z)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", h, z), Ye[h] = !0, !0;
        }
        if (qe.test(h)) {
          var G = h.toLowerCase(), ce = $e.hasOwnProperty(G) ? G : null;
          if (ce == null)
            return Ye[h] = !0, !1;
          if (h !== ce)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", h, ce), Ye[h] = !0, !0;
        }
      }
      return !0;
    }
    function ke(u, h) {
      {
        var C = [];
        for (var z in h) {
          var G = Ge(u, z);
          G || C.push(z);
        }
        var ce = C.map(function(me) {
          return "`" + me + "`";
        }).join(", ");
        C.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ce, u) : C.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ce, u);
      }
    }
    function De(u, h) {
      Ze(u, h) || ke(u, h);
    }
    var at = !1;
    function be(u, h) {
      {
        if (u !== "input" && u !== "textarea" && u !== "select")
          return;
        h != null && h.value === null && !at && (at = !0, u === "select" && h.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", u) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", u));
      }
    }
    var nt = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, st = function() {
    };
    {
      var lt = {}, St = /^on./, Ut = /^on[^A-Z]/, It = new RegExp("^(aria)-[" + J + "]*$"), _t = new RegExp("^(aria)[A-Z][" + J + "]*$");
      st = function(u, h, C, z) {
        if (ae.call(lt, h) && lt[h])
          return !0;
        var G = h.toLowerCase();
        if (G === "onfocusin" || G === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), lt[h] = !0, !0;
        if (z != null) {
          var ce = z.registrationNameDependencies, me = z.possibleRegistrationNames;
          if (ce.hasOwnProperty(h))
            return !0;
          var Le = me.hasOwnProperty(G) ? me[G] : null;
          if (Le != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", h, Le), lt[h] = !0, !0;
          if (St.test(h))
            return i("Unknown event handler property `%s`. It will be ignored.", h), lt[h] = !0, !0;
        } else if (St.test(h))
          return Ut.test(h) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", h), lt[h] = !0, !0;
        if (It.test(h) || _t.test(h))
          return !0;
        if (G === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), lt[h] = !0, !0;
        if (G === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), lt[h] = !0, !0;
        if (G === "is" && C !== null && C !== void 0 && typeof C != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof C), lt[h] = !0, !0;
        if (typeof C == "number" && isNaN(C))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", h), lt[h] = !0, !0;
        var l = ve(h), f = l !== null && l.type === j;
        if (nt.hasOwnProperty(G)) {
          var k = nt[G];
          if (k !== h)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", h, k), lt[h] = !0, !0;
        } else if (!f && h !== G)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", h, G), lt[h] = !0, !0;
        return typeof C == "boolean" && pe(h, C, l, !1) ? (C ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', C, h, h, C, h) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', C, h, h, C, h, h, h), lt[h] = !0, !0) : f ? !0 : pe(h, C, l, !1) ? (lt[h] = !0, !1) : ((C === "false" || C === "true") && l !== null && l.type === le && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", C, h, C === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', h, C), lt[h] = !0), !0);
      };
    }
    var Rt = function(u, h, C) {
      {
        var z = [];
        for (var G in h) {
          var ce = st(u, G, h[G], C);
          ce || z.push(G);
        }
        var me = z.map(function(Le) {
          return "`" + Le + "`";
        }).join(", ");
        z.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", me, u) : z.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", me, u);
      }
    };
    function Lt(u, h, C) {
      Ze(u, h) || Rt(u, h, C);
    }
    var $t = function() {
    };
    {
      var Dt = /^(?:webkit|moz|o)[A-Z]/, Gt = /^-ms-/, An = /-(.)/g, Ot = /;\s*$/, Xt = {}, ht = {}, Je = !1, Zt = !1, dn = function(u) {
        return u.replace(An, function(h, C) {
          return C.toUpperCase();
        });
      }, gn = function(u) {
        Xt.hasOwnProperty(u) && Xt[u] || (Xt[u] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          u,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          dn(u.replace(Gt, "ms-"))
        ));
      }, fn = function(u) {
        Xt.hasOwnProperty(u) && Xt[u] || (Xt[u] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", u, u.charAt(0).toUpperCase() + u.slice(1)));
      }, vt = function(u, h) {
        ht.hasOwnProperty(h) && ht[h] || (ht[h] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, u, h.replace(Ot, "")));
      }, Ft = function(u, h) {
        Je || (Je = !0, i("`NaN` is an invalid value for the `%s` css style property.", u));
      }, mt = function(u, h) {
        Zt || (Zt = !0, i("`Infinity` is an invalid value for the `%s` css style property.", u));
      };
      $t = function(u, h) {
        u.indexOf("-") > -1 ? gn(u) : Dt.test(u) ? fn(u) : Ot.test(h) && vt(u, h), typeof h == "number" && (isNaN(h) ? Ft(u, h) : isFinite(h) || mt(u, h));
      };
    }
    var pn = $t, Sn = /["'&<>]/;
    function kt(u) {
      Y(u);
      var h = "" + u, C = Sn.exec(h);
      if (!C)
        return h;
      var z, G = "", ce, me = 0;
      for (ce = C.index; ce < h.length; ce++) {
        switch (h.charCodeAt(ce)) {
          case 34:
            z = "&quot;";
            break;
          case 38:
            z = "&amp;";
            break;
          case 39:
            z = "&#x27;";
            break;
          case 60:
            z = "&lt;";
            break;
          case 62:
            z = "&gt;";
            break;
          default:
            continue;
        }
        me !== ce && (G += h.substring(me, ce)), me = ce + 1, G += z;
      }
      return me !== ce ? G + h.substring(me, ce) : G;
    }
    function wt(u) {
      return typeof u == "boolean" || typeof u == "number" ? "" + u : kt(u);
    }
    var kn = /([A-Z])/g, xt = /^ms-/;
    function Pt(u) {
      return u.replace(kn, "-$1").toLowerCase().replace(xt, "-ms-");
    }
    var bn = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, On = !1;
    function _e(u) {
      !On && bn.test(u) && (On = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(u)));
    }
    var Oe = Array.isArray;
    function Se(u) {
      return Oe(u);
    }
    var ut = v("<script>"), Kt = v("<\/script>"), Ht = v('<script src="'), yt = v('<script type="module" src="'), Bt = v('" async=""><\/script>');
    function bt(u) {
      return Y(u), ("" + u).replace(Tt, Pn);
    }
    var Tt = /(<\/|<)(s)(cript)/gi, Pn = function(u, h, C, z) {
      return "" + h + (C === "s" ? "\\u0073" : "\\u0053") + z;
    };
    function tn(u, h, C, z, G) {
      var ce = u === void 0 ? "" : u, me = h === void 0 ? ut : v('<script nonce="' + wt(h) + '">'), Le = [];
      if (C !== void 0 && Le.push(me, m(bt(C)), Kt), z !== void 0)
        for (var l = 0; l < z.length; l++)
          Le.push(Ht, m(wt(z[l])), Bt);
      if (G !== void 0)
        for (var f = 0; f < G.length; f++)
          Le.push(yt, m(wt(G[f])), Bt);
      return {
        bootstrapChunks: Le,
        startInlineScript: me,
        placeholderPrefix: v(ce + "P:"),
        segmentPrefix: v(ce + "S:"),
        boundaryPrefix: ce + "B:",
        idPrefix: ce,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var Qt = 0, Nt = 1, Jt = 2, wn = 3, on = 4, Wn = 5, Ln = 6, Tn = 7;
    function ln(u, h) {
      return {
        insertionMode: u,
        selectedValue: h
      };
    }
    function Dn(u) {
      var h = u === "http://www.w3.org/2000/svg" ? Jt : u === "http://www.w3.org/1998/Math/MathML" ? wn : Qt;
      return ln(h, null);
    }
    function _n(u, h, C) {
      switch (h) {
        case "select":
          return ln(Nt, C.value != null ? C.value : C.defaultValue);
        case "svg":
          return ln(Jt, null);
        case "math":
          return ln(wn, null);
        case "foreignObject":
          return ln(Nt, null);
        case "table":
          return ln(on, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return ln(Wn, null);
        case "colgroup":
          return ln(Tn, null);
        case "tr":
          return ln(Ln, null);
      }
      return u.insertionMode >= on || u.insertionMode === Qt ? ln(Nt, null) : u;
    }
    var Fn = null;
    function Kn(u) {
      var h = u.nextSuspenseID++;
      return v(u.boundaryPrefix + h.toString(16));
    }
    function sn(u, h, C) {
      var z = u.idPrefix, G = ":" + z + "R" + h;
      return C > 0 && (G += "H" + C.toString(32)), G + ":";
    }
    function hn(u) {
      return wt(u);
    }
    var ir = v("<!-- -->");
    function Zn(u, h, C, z) {
      return h === "" ? z : (z && u.push(ir), u.push(m(hn(h))), !0);
    }
    function Qn(u, h, C, z) {
      C && z && u.push(ir);
    }
    var x = /* @__PURE__ */ new Map();
    function D(u) {
      var h = x.get(u);
      if (h !== void 0)
        return h;
      var C = v(wt(Pt(u)));
      return x.set(u, C), C;
    }
    var N = v(' style="'), U = v(":"), fe = v(";");
    function O(u, h, C) {
      if (typeof C != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var z = !0;
      for (var G in C)
        if (ae.call(C, G)) {
          var ce = C[G];
          if (!(ce == null || typeof ce == "boolean" || ce === "")) {
            var me = void 0, Le = void 0, l = G.indexOf("--") === 0;
            l ? (me = m(wt(G)), Z(ce, G), Le = m(wt(("" + ce).trim()))) : (pn(G, ce), me = D(G), typeof ce == "number" ? ce !== 0 && !ae.call(Pe, G) ? Le = m(ce + "px") : Le = m("" + ce) : (Z(ce, G), Le = m(wt(("" + ce).trim())))), z ? (z = !1, u.push(N, me, U, Le)) : u.push(fe, me, U, Le);
          }
        }
      z || u.push(ge);
    }
    var I = v(" "), Q = v('="'), ge = v('"'), ze = v('=""');
    function Ke(u, h, C, z) {
      switch (C) {
        case "style": {
          O(u, h, z);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(C.length > 2 && (C[0] === "o" || C[0] === "O") && (C[1] === "n" || C[1] === "N"))
      ) {
        var G = ve(C);
        if (G !== null) {
          switch (typeof z) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!G.acceptsBooleans)
                return;
          }
          var ce = G.attributeName, me = m(ce);
          switch (G.type) {
            case le:
              z && u.push(I, me, ze);
              return;
            case B:
              z === !0 ? u.push(I, me, ze) : z === !1 || u.push(I, me, Q, m(wt(z)), ge);
              return;
            case X:
              isNaN(z) || u.push(I, me, Q, m(wt(z)), ge);
              break;
            case ue:
              !isNaN(z) && z >= 1 && u.push(I, me, Q, m(wt(z)), ge);
              break;
            default:
              G.sanitizeURL && (M(z, ce), z = "" + z, _e(z)), u.push(I, me, Q, m(wt(z)), ge);
          }
        } else if ($(C)) {
          switch (typeof z) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Le = C.toLowerCase().slice(0, 5);
              if (Le !== "data-" && Le !== "aria-")
                return;
            }
          }
          u.push(I, m(C), Q, m(wt(z)), ge);
        }
      }
    }
    var ot = v(">"), Yt = v("/>");
    function Vt(u, h, C) {
      if (h != null) {
        if (C != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof h != "object" || !("__html" in h))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var z = h.__html;
        z != null && (Y(z), u.push(m("" + z)));
      }
    }
    var nn = !1, rn = !1, an = !1, jn = !1, Jn = !1, er = !1, Yn = !1;
    function Er(u, h) {
      {
        var C = u[h];
        if (C != null) {
          var z = Se(C);
          u.multiple && !z ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", h) : !u.multiple && z && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", h);
        }
      }
    }
    function xa(u, h, C) {
      He("select", h), Er(h, "value"), Er(h, "defaultValue"), h.value !== void 0 && h.defaultValue !== void 0 && !an && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), an = !0), u.push(lr("select"));
      var z = null, G = null;
      for (var ce in h)
        if (ae.call(h, ce)) {
          var me = h[ce];
          if (me == null)
            continue;
          switch (ce) {
            case "children":
              z = me;
              break;
            case "dangerouslySetInnerHTML":
              G = me;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              Ke(u, C, ce, me);
              break;
          }
        }
      return u.push(ot), Vt(u, G, z), z;
    }
    function At(u) {
      var h = "";
      return e.Children.forEach(u, function(C) {
        C != null && (h += C, !Jn && typeof C != "string" && typeof C != "number" && (Jn = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), h;
    }
    var vn = v(' selected=""');
    function ra(u, h, C, z) {
      var G = z.selectedValue;
      u.push(lr("option"));
      var ce = null, me = null, Le = null, l = null;
      for (var f in h)
        if (ae.call(h, f)) {
          var k = h[f];
          if (k == null)
            continue;
          switch (f) {
            case "children":
              ce = k;
              break;
            case "selected":
              Le = k, Yn || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Yn = !0);
              break;
            case "dangerouslySetInnerHTML":
              l = k;
              break;
            case "value":
              me = k;
            default:
              Ke(u, C, f, k);
              break;
          }
        }
      if (G != null) {
        var R;
        if (me !== null ? (M(me, "value"), R = "" + me) : (l !== null && (er || (er = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), R = At(ce)), Se(G))
          for (var H = 0; H < G.length; H++) {
            M(G[H], "value");
            var oe = "" + G[H];
            if (oe === R) {
              u.push(vn);
              break;
            }
          }
        else
          M(G, "select.value"), "" + G === R && u.push(vn);
      } else
        Le && u.push(vn);
      return u.push(ot), Vt(u, l, ce), ce;
    }
    function Nr(u, h, C) {
      He("input", h), h.checked !== void 0 && h.defaultChecked !== void 0 && !rn && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), rn = !0), h.value !== void 0 && h.defaultValue !== void 0 && !nn && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), nn = !0), u.push(lr("input"));
      var z = null, G = null, ce = null, me = null;
      for (var Le in h)
        if (ae.call(h, Le)) {
          var l = h[Le];
          if (l == null)
            continue;
          switch (Le) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              me = l;
              break;
            case "defaultValue":
              G = l;
              break;
            case "checked":
              ce = l;
              break;
            case "value":
              z = l;
              break;
            default:
              Ke(u, C, Le, l);
              break;
          }
        }
      return ce !== null ? Ke(u, C, "checked", ce) : me !== null && Ke(u, C, "checked", me), z !== null ? Ke(u, C, "value", z) : G !== null && Ke(u, C, "value", G), u.push(Yt), null;
    }
    function or(u, h, C) {
      He("textarea", h), h.value !== void 0 && h.defaultValue !== void 0 && !jn && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), jn = !0), u.push(lr("textarea"));
      var z = null, G = null, ce = null;
      for (var me in h)
        if (ae.call(h, me)) {
          var Le = h[me];
          if (Le == null)
            continue;
          switch (me) {
            case "children":
              ce = Le;
              break;
            case "value":
              z = Le;
              break;
            case "defaultValue":
              G = Le;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              Ke(u, C, me, Le);
              break;
          }
        }
      if (z === null && G !== null && (z = G), u.push(ot), ce != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), z != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (Se(ce)) {
          if (ce.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          Y(ce[0]), z = "" + ce[0];
        }
        Y(ce), z = "" + ce;
      }
      return typeof z == "string" && z[0] === `
` && u.push(_r), z !== null && (M(z, "value"), u.push(m(hn("" + z)))), null;
    }
    function Dr(u, h, C, z) {
      u.push(lr(C));
      for (var G in h)
        if (ae.call(h, G)) {
          var ce = h[G];
          if (ce == null)
            continue;
          switch (G) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(C + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              Ke(u, z, G, ce);
              break;
          }
        }
      return u.push(Yt), null;
    }
    function Wr(u, h, C) {
      u.push(lr("menuitem"));
      for (var z in h)
        if (ae.call(h, z)) {
          var G = h[z];
          if (G == null)
            continue;
          switch (z) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              Ke(u, C, z, G);
              break;
          }
        }
      return u.push(ot), null;
    }
    function Wt(u, h, C) {
      u.push(lr("title"));
      var z = null;
      for (var G in h)
        if (ae.call(h, G)) {
          var ce = h[G];
          if (ce == null)
            continue;
          switch (G) {
            case "children":
              z = ce;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              Ke(u, C, G, ce);
              break;
          }
        }
      u.push(ot);
      {
        var me = Array.isArray(z) && z.length < 2 ? z[0] || null : z;
        Array.isArray(z) && z.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : me != null && me.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : me != null && typeof me != "string" && typeof me != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return z;
    }
    function mr(u, h, C, z) {
      u.push(lr(C));
      var G = null, ce = null;
      for (var me in h)
        if (ae.call(h, me)) {
          var Le = h[me];
          if (Le == null)
            continue;
          switch (me) {
            case "children":
              G = Le;
              break;
            case "dangerouslySetInnerHTML":
              ce = Le;
              break;
            default:
              Ke(u, z, me, Le);
              break;
          }
        }
      return u.push(ot), Vt(u, ce, G), typeof G == "string" ? (u.push(m(hn(G))), null) : G;
    }
    function Gn(u, h, C, z) {
      u.push(lr(C));
      var G = null, ce = null;
      for (var me in h)
        if (ae.call(h, me)) {
          var Le = h[me];
          if (Le == null)
            continue;
          switch (me) {
            case "children":
              G = Le;
              break;
            case "dangerouslySetInnerHTML":
              ce = Le;
              break;
            case "style":
              O(u, z, Le);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              $(me) && typeof Le != "function" && typeof Le != "symbol" && u.push(I, m(me), Q, m(wt(Le)), ge);
              break;
          }
        }
      return u.push(ot), Vt(u, ce, G), G;
    }
    var _r = v(`
`);
    function kr(u, h, C, z) {
      u.push(lr(C));
      var G = null, ce = null;
      for (var me in h)
        if (ae.call(h, me)) {
          var Le = h[me];
          if (Le == null)
            continue;
          switch (me) {
            case "children":
              G = Le;
              break;
            case "dangerouslySetInnerHTML":
              ce = Le;
              break;
            default:
              Ke(u, z, me, Le);
              break;
          }
        }
      if (u.push(ot), ce != null) {
        if (G != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof ce != "object" || !("__html" in ce))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var l = ce.__html;
        l != null && (typeof l == "string" && l.length > 0 && l[0] === `
` ? u.push(_r, m(l)) : (Y(l), u.push(m("" + l))));
      }
      return typeof G == "string" && G[0] === `
` && u.push(_r), G;
    }
    var ba = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, wr = /* @__PURE__ */ new Map();
    function lr(u) {
      var h = wr.get(u);
      if (h === void 0) {
        if (!ba.test(u))
          throw new Error("Invalid tag: " + u);
        h = v("<" + u), wr.set(u, h);
      }
      return h;
    }
    var qa = v("<!DOCTYPE html>");
    function Za(u, h, C, z, G) {
      switch (De(h, C), be(h, C), Lt(h, C, null), !C.suppressContentEditableWarning && C.contentEditable && C.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), G.insertionMode !== Jt && G.insertionMode !== wn && h.indexOf("-") === -1 && typeof C.is != "string" && h.toLowerCase() !== h && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", h), h) {
        case "select":
          return xa(u, C, z);
        case "option":
          return ra(u, C, z, G);
        case "textarea":
          return or(u, C, z);
        case "input":
          return Nr(u, C, z);
        case "menuitem":
          return Wr(u, C, z);
        case "title":
          return Wt(u, C, z);
        case "listing":
        case "pre":
          return kr(u, C, h, z);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Dr(u, C, h, z);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return mr(u, C, h, z);
        case "html":
          return G.insertionMode === Qt && u.push(qa), mr(u, C, h, z);
        default:
          return h.indexOf("-") === -1 && typeof C.is != "string" ? mr(u, C, h, z) : Gn(u, C, h, z);
      }
    }
    var Yi = v("</"), Gi = v(">");
    function Xi(u, h, C) {
      switch (h) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          u.push(Yi, m(h), Gi);
      }
    }
    function dl(u, h) {
      for (var C = h.bootstrapChunks, z = 0; z < C.length - 1; z++)
        g(u, C[z]);
      return z < C.length ? b(u, C[z]) : !0;
    }
    var fl = v('<template id="'), Ea = v('"></template>');
    function Sa(u, h, C) {
      g(u, fl), g(u, h.placeholderPrefix);
      var z = m(C.toString(16));
      return g(u, z), b(u, Ea);
    }
    var ka = v("<!--$-->"), aa = v('<!--$?--><template id="'), pl = v('"></template>'), ia = v("<!--$!-->"), Qa = v("<!--/$-->"), Ja = v("<template"), jr = v('"'), Ur = v(' data-dgst="'), wa = v(' data-msg="'), qi = v(' data-stck="'), ei = v("></template>");
    function Zi(u, h) {
      return b(u, ka);
    }
    function Ta(u, h, C) {
      if (g(u, aa), C === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(u, C), b(u, pl);
    }
    function Xn(u, h, C, z, G) {
      var ce;
      return ce = b(u, ia), g(u, Ja), C && (g(u, Ur), g(u, m(wt(C))), g(u, jr)), z && (g(u, wa), g(u, m(wt(z))), g(u, jr)), G && (g(u, qi), g(u, m(wt(G))), g(u, jr)), ce = b(u, ei), ce;
    }
    function Qi(u, h) {
      return b(u, Qa);
    }
    function Ca(u, h) {
      return b(u, Qa);
    }
    function hl(u, h) {
      return b(u, Qa);
    }
    var Ji = v('<div hidden id="'), Aa = v('">'), eo = v("</div>"), to = v('<svg aria-hidden="true" style="display:none" id="'), La = v('">'), Pa = v("</svg>"), no = v('<math aria-hidden="true" style="display:none" id="'), ro = v('">'), ao = v("</math>"), ti = v('<table hidden id="'), io = v('">'), E = v("</table>"), F = v('<table hidden><tbody id="'), V = v('">'), re = v("</tbody></table>"), we = v('<table hidden><tr id="'), Ee = v('">'), Fe = v("</tr></table>"), je = v('<table hidden><colgroup id="'), pt = v('">'), Ct = v("</colgroup></table>");
    function Et(u, h, C, z) {
      switch (C.insertionMode) {
        case Qt:
        case Nt:
          return g(u, Ji), g(u, h.segmentPrefix), g(u, m(z.toString(16))), b(u, Aa);
        case Jt:
          return g(u, to), g(u, h.segmentPrefix), g(u, m(z.toString(16))), b(u, La);
        case wn:
          return g(u, no), g(u, h.segmentPrefix), g(u, m(z.toString(16))), b(u, ro);
        case on:
          return g(u, ti), g(u, h.segmentPrefix), g(u, m(z.toString(16))), b(u, io);
        case Wn:
          return g(u, F), g(u, h.segmentPrefix), g(u, m(z.toString(16))), b(u, V);
        case Ln:
          return g(u, we), g(u, h.segmentPrefix), g(u, m(z.toString(16))), b(u, Ee);
        case Tn:
          return g(u, je), g(u, h.segmentPrefix), g(u, m(z.toString(16))), b(u, pt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function un(u, h) {
      switch (h.insertionMode) {
        case Qt:
        case Nt:
          return b(u, eo);
        case Jt:
          return b(u, Pa);
        case wn:
          return b(u, ao);
        case on:
          return b(u, E);
        case Wn:
          return b(u, re);
        case Ln:
          return b(u, Fe);
        case Tn:
          return b(u, Ct);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var qn = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", sr = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', ur = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Ra = v(qn + ';$RS("'), oo = v('$RS("'), ni = v('","'), Wc = v('")<\/script>');
    function jc(u, h, C) {
      g(u, h.startInlineScript), h.sentCompleteSegmentFunction ? g(u, oo) : (h.sentCompleteSegmentFunction = !0, g(u, Ra)), g(u, h.segmentPrefix);
      var z = m(C.toString(16));
      return g(u, z), g(u, ni), g(u, h.placeholderPrefix), g(u, z), b(u, Wc);
    }
    var Uc = v(sr + ';$RC("'), Kc = v('$RC("'), Yc = v('","'), Gc = v('")<\/script>');
    function ml(u, h, C, z) {
      if (g(u, h.startInlineScript), h.sentCompleteBoundaryFunction ? g(u, Kc) : (h.sentCompleteBoundaryFunction = !0, g(u, Uc)), C === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var G = m(z.toString(16));
      return g(u, C), g(u, Yc), g(u, h.segmentPrefix), g(u, G), b(u, Gc);
    }
    var Xc = v(ur + ';$RX("'), qc = v('$RX("'), yl = v('"'), Zc = v(")<\/script>"), gl = v(",");
    function Os(u, h, C, z, G, ce) {
      if (g(u, h.startInlineScript), h.sentClientRenderFunction ? g(u, qc) : (h.sentClientRenderFunction = !0, g(u, Xc)), C === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(u, C), g(u, yl), (z || G || ce) && (g(u, gl), g(u, m(vl(z || "")))), (G || ce) && (g(u, gl), g(u, m(vl(G || "")))), ce && (g(u, gl), g(u, m(vl(ce)))), b(u, Zc);
    }
    var Fs = /[<\u2028\u2029]/g;
    function vl(u) {
      var h = JSON.stringify(u);
      return h.replace(Fs, function(C) {
        switch (C) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var yr = Object.assign, Qc = Symbol.for("react.element"), Ms = Symbol.for("react.portal"), cr = Symbol.for("react.fragment"), zs = Symbol.for("react.strict_mode"), xl = Symbol.for("react.profiler"), lo = Symbol.for("react.provider"), so = Symbol.for("react.context"), uo = Symbol.for("react.forward_ref"), ri = Symbol.for("react.suspense"), ai = Symbol.for("react.suspense_list"), ii = Symbol.for("react.memo"), Na = Symbol.for("react.lazy"), bl = Symbol.for("react.scope"), El = Symbol.for("react.debug_trace_mode"), co = Symbol.for("react.legacy_hidden"), Jc = Symbol.for("react.default_value"), Bs = Symbol.iterator, ed = "@@iterator";
    function td(u) {
      if (u === null || typeof u != "object")
        return null;
      var h = Bs && u[Bs] || u[ed];
      return typeof h == "function" ? h : null;
    }
    function Is(u, h, C) {
      var z = u.displayName;
      if (z)
        return z;
      var G = h.displayName || h.name || "";
      return G !== "" ? C + "(" + G + ")" : C;
    }
    function $s(u) {
      return u.displayName || "Context";
    }
    function En(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case cr:
          return "Fragment";
        case Ms:
          return "Portal";
        case xl:
          return "Profiler";
        case zs:
          return "StrictMode";
        case ri:
          return "Suspense";
        case ai:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case so:
            var h = u;
            return $s(h) + ".Consumer";
          case lo:
            var C = u;
            return $s(C._context) + ".Provider";
          case uo:
            return Is(u, u.render, "ForwardRef");
          case ii:
            var z = u.displayName || null;
            return z !== null ? z : En(u.type) || "Memo";
          case Na: {
            var G = u, ce = G._payload, me = G._init;
            try {
              return En(me(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var oi = 0, Sl, xn, Da, kl, wl, Tl, Cl;
    function Al() {
    }
    Al.__reactDisabledLog = !0;
    function Hs() {
      {
        if (oi === 0) {
          Sl = console.log, xn = console.info, Da = console.warn, kl = console.error, wl = console.group, Tl = console.groupCollapsed, Cl = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: Al,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        oi++;
      }
    }
    function Vs() {
      {
        if (oi--, oi === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: yr({}, u, {
              value: Sl
            }),
            info: yr({}, u, {
              value: xn
            }),
            warn: yr({}, u, {
              value: Da
            }),
            error: yr({}, u, {
              value: kl
            }),
            group: yr({}, u, {
              value: wl
            }),
            groupCollapsed: yr({}, u, {
              value: Tl
            }),
            groupEnd: yr({}, u, {
              value: Cl
            })
          });
        }
        oi < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var fo = r.ReactCurrentDispatcher, Ll;
    function li(u, h, C) {
      {
        if (Ll === void 0)
          try {
            throw Error();
          } catch (G) {
            var z = G.stack.trim().match(/\n( *(at )?)/);
            Ll = z && z[1] || "";
          }
        return `
` + Ll + u;
      }
    }
    var si = !1, _a;
    {
      var ui = typeof WeakMap == "function" ? WeakMap : Map;
      _a = new ui();
    }
    function ci(u, h) {
      if (!u || si)
        return "";
      {
        var C = _a.get(u);
        if (C !== void 0)
          return C;
      }
      var z;
      si = !0;
      var G = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = fo.current, fo.current = null, Hs();
      try {
        if (h) {
          var me = function() {
            throw Error();
          };
          if (Object.defineProperty(me.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(me, []);
            } catch (he) {
              z = he;
            }
            Reflect.construct(u, [], me);
          } else {
            try {
              me.call();
            } catch (he) {
              z = he;
            }
            u.call(me.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (he) {
            z = he;
          }
          u();
        }
      } catch (he) {
        if (he && z && typeof he.stack == "string") {
          for (var Le = he.stack.split(`
`), l = z.stack.split(`
`), f = Le.length - 1, k = l.length - 1; f >= 1 && k >= 0 && Le[f] !== l[k]; )
            k--;
          for (; f >= 1 && k >= 0; f--, k--)
            if (Le[f] !== l[k]) {
              if (f !== 1 || k !== 1)
                do
                  if (f--, k--, k < 0 || Le[f] !== l[k]) {
                    var R = `
` + Le[f].replace(" at new ", " at ");
                    return u.displayName && R.includes("<anonymous>") && (R = R.replace("<anonymous>", u.displayName)), typeof u == "function" && _a.set(u, R), R;
                  }
                while (f >= 1 && k >= 0);
              break;
            }
        }
      } finally {
        si = !1, fo.current = ce, Vs(), Error.prepareStackTrace = G;
      }
      var H = u ? u.displayName || u.name : "", oe = H ? li(H) : "";
      return typeof u == "function" && _a.set(u, oe), oe;
    }
    function po(u, h, C) {
      return ci(u, !0);
    }
    function Ws(u, h, C) {
      return ci(u, !1);
    }
    function Pl(u) {
      var h = u.prototype;
      return !!(h && h.isReactComponent);
    }
    function Rl(u, h, C) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return ci(u, Pl(u));
      if (typeof u == "string")
        return li(u);
      switch (u) {
        case ri:
          return li("Suspense");
        case ai:
          return li("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case uo:
            return Ws(u.render);
          case ii:
            return Rl(u.type, h, C);
          case Na: {
            var z = u, G = z._payload, ce = z._init;
            try {
              return Rl(ce(G), h, C);
            } catch {
            }
          }
        }
      return "";
    }
    var Nl = {}, js = r.ReactDebugCurrentFrame;
    function Oa(u) {
      if (u) {
        var h = u._owner, C = Rl(u.type, u._source, h ? h.type : null);
        js.setExtraStackFrame(C);
      } else
        js.setExtraStackFrame(null);
    }
    function Dl(u, h, C, z, G) {
      {
        var ce = Function.call.bind(ae);
        for (var me in u)
          if (ce(u, me)) {
            var Le = void 0;
            try {
              if (typeof u[me] != "function") {
                var l = Error((z || "React class") + ": " + C + " type `" + me + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[me] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw l.name = "Invariant Violation", l;
              }
              Le = u[me](h, me, z, C, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (f) {
              Le = f;
            }
            Le && !(Le instanceof Error) && (Oa(G), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", z || "React class", C, me, typeof Le), Oa(null)), Le instanceof Error && !(Le.message in Nl) && (Nl[Le.message] = !0, Oa(G), i("Failed %s type: %s", C, Le.message), Oa(null));
          }
      }
    }
    var ho;
    ho = {};
    var oa = {};
    Object.freeze(oa);
    function _l(u, h) {
      {
        var C = u.contextTypes;
        if (!C)
          return oa;
        var z = {};
        for (var G in C)
          z[G] = h[G];
        {
          var ce = En(u) || "Unknown";
          Dl(C, z, "context", ce);
        }
        return z;
      }
    }
    function Ol(u, h, C, z) {
      {
        if (typeof u.getChildContext != "function") {
          {
            var G = En(h) || "Unknown";
            ho[G] || (ho[G] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", G, G));
          }
          return C;
        }
        var ce = u.getChildContext();
        for (var me in ce)
          if (!(me in z))
            throw new Error((En(h) || "Unknown") + '.getChildContext(): key "' + me + '" is not defined in childContextTypes.');
        {
          var Le = En(h) || "Unknown";
          Dl(z, ce, "child context", Le);
        }
        return yr({}, C, ce);
      }
    }
    var Kr;
    Kr = {};
    var Us = null, la = null;
    function sa(u) {
      u.context._currentValue = u.parentValue;
    }
    function Fl(u) {
      u.context._currentValue = u.value;
    }
    function Tr(u, h) {
      if (u !== h) {
        sa(u);
        var C = u.parent, z = h.parent;
        if (C === null) {
          if (z !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (z === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          Tr(C, z);
        }
        Fl(h);
      }
    }
    function mo(u) {
      sa(u);
      var h = u.parent;
      h !== null && mo(h);
    }
    function yo(u) {
      var h = u.parent;
      h !== null && yo(h), Fl(u);
    }
    function di(u, h) {
      sa(u);
      var C = u.parent;
      if (C === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      C.depth === h.depth ? Tr(C, h) : di(C, h);
    }
    function Ml(u, h) {
      var C = h.parent;
      if (C === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      u.depth === C.depth ? Tr(u, C) : Ml(u, C), Fl(h);
    }
    function fi(u) {
      var h = la, C = u;
      h !== C && (h === null ? yo(C) : C === null ? mo(h) : h.depth === C.depth ? Tr(h, C) : h.depth > C.depth ? di(h, C) : Ml(h, C), la = C);
    }
    function Ks(u, h) {
      var C;
      C = u._currentValue, u._currentValue = h, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== Kr && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = Kr;
      var z = la, G = {
        parent: z,
        depth: z === null ? 0 : z.depth + 1,
        context: u,
        parentValue: C,
        value: h
      };
      return la = G, G;
    }
    function Ys(u) {
      var h = la;
      if (h === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      h.context !== u && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var C = h.parentValue;
        C === Jc ? h.context._currentValue = h.context._defaultValue : h.context._currentValue = C, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== Kr && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = Kr;
      }
      return la = h.parent;
    }
    function go() {
      return la;
    }
    function pi(u) {
      var h = u._currentValue;
      return h;
    }
    function zl(u) {
      return u._reactInternals;
    }
    function nd(u, h) {
      u._reactInternals = h;
    }
    var Fa = {}, vo = {}, Bl, xo, bo, hi, Eo, Ma, mi, So, za;
    {
      Bl = /* @__PURE__ */ new Set(), xo = /* @__PURE__ */ new Set(), bo = /* @__PURE__ */ new Set(), mi = /* @__PURE__ */ new Set(), hi = /* @__PURE__ */ new Set(), So = /* @__PURE__ */ new Set(), za = /* @__PURE__ */ new Set();
      var ko = /* @__PURE__ */ new Set();
      Ma = function(u, h) {
        if (!(u === null || typeof u == "function")) {
          var C = h + "_" + u;
          ko.has(C) || (ko.add(C), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", h, u));
        }
      }, Eo = function(u, h) {
        if (h === void 0) {
          var C = En(u) || "Component";
          hi.has(C) || (hi.add(C), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", C));
        }
      };
    }
    function wo(u, h) {
      {
        var C = u.constructor, z = C && En(C) || "ReactClass", G = z + "." + h;
        if (Fa[G])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, h, h, z), Fa[G] = !0;
      }
    }
    var To = {
      isMounted: function(u) {
        return !1;
      },
      enqueueSetState: function(u, h, C) {
        var z = zl(u);
        z.queue === null ? wo(u, "setState") : (z.queue.push(h), C != null && Ma(C, "setState"));
      },
      enqueueReplaceState: function(u, h, C) {
        var z = zl(u);
        z.replace = !0, z.queue = [h], C != null && Ma(C, "setState");
      },
      enqueueForceUpdate: function(u, h) {
        var C = zl(u);
        C.queue === null ? wo(u, "forceUpdate") : h != null && Ma(h, "setState");
      }
    };
    function Gs(u, h, C, z, G) {
      var ce = C(G, z);
      Eo(h, ce);
      var me = ce == null ? z : yr({}, z, ce);
      return me;
    }
    function Xs(u, h, C) {
      var z = oa, G = u.contextType;
      if ("contextType" in u) {
        var ce = (
          // Allow null for conditional declaration
          G === null || G !== void 0 && G.$$typeof === so && G._context === void 0
        );
        if (!ce && !za.has(u)) {
          za.add(u);
          var me = "";
          G === void 0 ? me = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof G != "object" ? me = " However, it is set to a " + typeof G + "." : G.$$typeof === lo ? me = " Did you accidentally pass the Context.Provider instead?" : G._context !== void 0 ? me = " Did you accidentally pass the Context.Consumer instead?" : me = " However, it is set to an object with keys {" + Object.keys(G).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", En(u) || "Component", me);
        }
      }
      typeof G == "object" && G !== null ? z = pi(G) : z = C;
      var Le = new u(h, z);
      {
        if (typeof u.getDerivedStateFromProps == "function" && (Le.state === null || Le.state === void 0)) {
          var l = En(u) || "Component";
          Bl.has(l) || (Bl.add(l), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", l, Le.state === null ? "null" : "undefined", l));
        }
        if (typeof u.getDerivedStateFromProps == "function" || typeof Le.getSnapshotBeforeUpdate == "function") {
          var f = null, k = null, R = null;
          if (typeof Le.componentWillMount == "function" && Le.componentWillMount.__suppressDeprecationWarning !== !0 ? f = "componentWillMount" : typeof Le.UNSAFE_componentWillMount == "function" && (f = "UNSAFE_componentWillMount"), typeof Le.componentWillReceiveProps == "function" && Le.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? k = "componentWillReceiveProps" : typeof Le.UNSAFE_componentWillReceiveProps == "function" && (k = "UNSAFE_componentWillReceiveProps"), typeof Le.componentWillUpdate == "function" && Le.componentWillUpdate.__suppressDeprecationWarning !== !0 ? R = "componentWillUpdate" : typeof Le.UNSAFE_componentWillUpdate == "function" && (R = "UNSAFE_componentWillUpdate"), f !== null || k !== null || R !== null) {
            var H = En(u) || "Component", oe = typeof u.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            bo.has(H) || (bo.add(H), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, H, oe, f !== null ? `
  ` + f : "", k !== null ? `
  ` + k : "", R !== null ? `
  ` + R : ""));
          }
        }
      }
      return Le;
    }
    function qs(u, h, C) {
      {
        var z = En(h) || "Component", G = u.render;
        G || (h.prototype && typeof h.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", z) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", z)), u.getInitialState && !u.getInitialState.isReactClassApproved && !u.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", z), u.getDefaultProps && !u.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", z), u.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", z), u.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", z), u.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", z), h.contextType && h.contextTypes && !So.has(h) && (So.add(h), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", z)), typeof u.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", z), h.prototype && h.prototype.isPureReactComponent && typeof u.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", En(h) || "A pure component"), typeof u.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", z), typeof u.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", z), typeof u.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", z), typeof u.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", z);
        var ce = u.props !== C;
        u.props !== void 0 && ce && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", z, z), u.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", z, z), typeof u.getSnapshotBeforeUpdate == "function" && typeof u.componentDidUpdate != "function" && !xo.has(h) && (xo.add(h), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", En(h))), typeof u.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", z), typeof u.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", z), typeof h.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", z);
        var me = u.state;
        me && (typeof me != "object" || Se(me)) && i("%s.state: must be set to an object or null", z), typeof u.getChildContext == "function" && typeof h.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", z);
      }
    }
    function rd(u, h) {
      var C = h.state;
      if (typeof h.componentWillMount == "function") {
        if (h.componentWillMount.__suppressDeprecationWarning !== !0) {
          var z = En(u) || "Unknown";
          vo[z] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            z
          ), vo[z] = !0);
        }
        h.componentWillMount();
      }
      typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(), C !== h.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", En(u) || "Component"), To.enqueueReplaceState(h, h.state, null));
    }
    function ad(u, h, C, z) {
      if (u.queue !== null && u.queue.length > 0) {
        var G = u.queue, ce = u.replace;
        if (u.queue = null, u.replace = !1, ce && G.length === 1)
          h.state = G[0];
        else {
          for (var me = ce ? G[0] : h.state, Le = !0, l = ce ? 1 : 0; l < G.length; l++) {
            var f = G[l], k = typeof f == "function" ? f.call(h, me, C, z) : f;
            k != null && (Le ? (Le = !1, me = yr({}, me, k)) : yr(me, k));
          }
          h.state = me;
        }
      } else
        u.queue = null;
    }
    function Zs(u, h, C, z) {
      qs(u, h, C);
      var G = u.state !== void 0 ? u.state : null;
      u.updater = To, u.props = C, u.state = G;
      var ce = {
        queue: [],
        replace: !1
      };
      nd(u, ce);
      var me = h.contextType;
      if (typeof me == "object" && me !== null ? u.context = pi(me) : u.context = z, u.state === C) {
        var Le = En(h) || "Component";
        mi.has(Le) || (mi.add(Le), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Le));
      }
      var l = h.getDerivedStateFromProps;
      typeof l == "function" && (u.state = Gs(u, h, l, G, C)), typeof h.getDerivedStateFromProps != "function" && typeof u.getSnapshotBeforeUpdate != "function" && (typeof u.UNSAFE_componentWillMount == "function" || typeof u.componentWillMount == "function") && (rd(h, u), ad(ce, u, C, z));
    }
    var id = {
      id: 1,
      overflow: ""
    };
    function od(u) {
      var h = u.overflow, C = u.id, z = C & ~ld(C);
      return z.toString(32) + h;
    }
    function Co(u, h, C) {
      var z = u.id, G = u.overflow, ce = Ao(z) - 1, me = z & ~(1 << ce), Le = C + 1, l = Ao(h) + ce;
      if (l > 30) {
        var f = ce - ce % 5, k = (1 << f) - 1, R = (me & k).toString(32), H = me >> f, oe = ce - f, he = Ao(h) + oe, Ae = Le << oe, Ie = Ae | H, rt = R + G;
        return {
          id: 1 << he | Ie,
          overflow: rt
        };
      } else {
        var it = Le << ce, gt = it | me, mn = G;
        return {
          id: 1 << l | gt,
          overflow: mn
        };
      }
    }
    function Ao(u) {
      return 32 - Il(u);
    }
    function ld(u) {
      return 1 << Ao(u) - 1;
    }
    var Il = Math.clz32 ? Math.clz32 : ud, Lo = Math.log, sd = Math.LN2;
    function ud(u) {
      var h = u >>> 0;
      return h === 0 ? 32 : 31 - (Lo(h) / sd | 0) | 0;
    }
    function cd(u, h) {
      return u === h && (u !== 0 || 1 / u === 1 / h) || u !== u && h !== h;
    }
    var dd = typeof Object.is == "function" ? Object.is : cd, Or = null, $l = null, Po = null, Mt = null, ua = !1, ca = !1, en = 0, gr = null, da = 0, Ro = 25, $n = !1, Fr;
    function fa() {
      if (Or === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return $n && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Or;
    }
    function Cr(u, h) {
      if (h === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Fr), !1;
      u.length !== h.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Fr, "[" + u.join(", ") + "]", "[" + h.join(", ") + "]");
      for (var C = 0; C < h.length && C < u.length; C++)
        if (!dd(u[C], h[C]))
          return !1;
      return !0;
    }
    function pa() {
      if (da > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Mr() {
      return Mt === null ? Po === null ? (ua = !1, Po = Mt = pa()) : (ua = !0, Mt = Po) : Mt.next === null ? (ua = !1, Mt = Mt.next = pa()) : (ua = !0, Mt = Mt.next), Mt;
    }
    function fd(u, h) {
      Or = h, $l = u, $n = !1, en = 0;
    }
    function Qs(u, h, C, z) {
      for (; ca; )
        ca = !1, en = 0, da += 1, Mt = null, C = u(h, z);
      return Hl(), C;
    }
    function No() {
      var u = en !== 0;
      return u;
    }
    function Hl() {
      $n = !1, Or = null, $l = null, ca = !1, Po = null, da = 0, gr = null, Mt = null;
    }
    function pd(u) {
      return $n && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), pi(u);
    }
    function Js(u) {
      return Fr = "useContext", fa(), pi(u);
    }
    function yi(u, h) {
      return typeof h == "function" ? h(u) : h;
    }
    function hd(u) {
      return Fr = "useState", eu(
        yi,
        // useReducer has a special case to support lazy useState initializers
        u
      );
    }
    function eu(u, h, C) {
      if (u !== yi && (Fr = "useReducer"), Or = fa(), Mt = Mr(), ua) {
        var z = Mt.queue, G = z.dispatch;
        if (gr !== null) {
          var ce = gr.get(z);
          if (ce !== void 0) {
            gr.delete(z);
            var me = Mt.memoizedState, Le = ce;
            do {
              var l = Le.action;
              $n = !0, me = u(me, l), $n = !1, Le = Le.next;
            } while (Le !== null);
            return Mt.memoizedState = me, [me, G];
          }
        }
        return [Mt.memoizedState, G];
      } else {
        $n = !0;
        var f;
        u === yi ? f = typeof h == "function" ? h() : h : f = C !== void 0 ? C(h) : h, $n = !1, Mt.memoizedState = f;
        var k = Mt.queue = {
          last: null,
          dispatch: null
        }, R = k.dispatch = nu.bind(null, Or, k);
        return [Mt.memoizedState, R];
      }
    }
    function Do(u, h) {
      Or = fa(), Mt = Mr();
      var C = h === void 0 ? null : h;
      if (Mt !== null) {
        var z = Mt.memoizedState;
        if (z !== null && C !== null) {
          var G = z[1];
          if (Cr(C, G))
            return z[0];
        }
      }
      $n = !0;
      var ce = u();
      return $n = !1, Mt.memoizedState = [ce, C], ce;
    }
    function md(u) {
      Or = fa(), Mt = Mr();
      var h = Mt.memoizedState;
      if (h === null) {
        var C = {
          current: u
        };
        return Object.seal(C), Mt.memoizedState = C, C;
      } else
        return h;
    }
    function tu(u, h) {
      Fr = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function nu(u, h, C) {
      if (da >= Ro)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (u === Or) {
        ca = !0;
        var z = {
          action: C,
          next: null
        };
        gr === null && (gr = /* @__PURE__ */ new Map());
        var G = gr.get(h);
        if (G === void 0)
          gr.set(h, z);
        else {
          for (var ce = G; ce.next !== null; )
            ce = ce.next;
          ce.next = z;
        }
      }
    }
    function yd(u, h) {
      return Do(function() {
        return u;
      }, h);
    }
    function gd(u, h, C) {
      return fa(), h(u._source);
    }
    function vd(u, h, C) {
      if (C === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return C();
    }
    function xd(u) {
      return fa(), u;
    }
    function bd() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function Ed() {
      return fa(), [!1, bd];
    }
    function Sd() {
      var u = $l, h = od(u.treeContext), C = Vl;
      if (C === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var z = en++;
      return sn(C, h, z);
    }
    function _o() {
    }
    var ru = {
      readContext: pd,
      useContext: Js,
      useMemo: Do,
      useReducer: eu,
      useRef: md,
      useState: hd,
      useInsertionEffect: _o,
      useLayoutEffect: tu,
      useCallback: yd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: _o,
      // Effects are not run in the server environment.
      useEffect: _o,
      // Debugging effect
      useDebugValue: _o,
      useDeferredValue: xd,
      useTransition: Ed,
      useId: Sd,
      // Subscriptions are not setup in a server environment.
      useMutableSource: gd,
      useSyncExternalStore: vd
    }, Vl = null;
    function gi(u) {
      Vl = u;
    }
    function au(u) {
      try {
        var h = "", C = u;
        do {
          switch (C.tag) {
            case 0:
              h += li(C.type, null, null);
              break;
            case 1:
              h += Ws(C.type, null, null);
              break;
            case 2:
              h += po(C.type, null, null);
              break;
          }
          C = C.parent;
        } while (C);
        return h;
      } catch (z) {
        return `
Error generating stack: ` + z.message + `
` + z.stack;
      }
    }
    var vi = r.ReactCurrentDispatcher, Oo = r.ReactDebugCurrentFrame, Wl = 0, Yr = 1, Fo = 2, Mo = 3, ha = 4, iu = 0, jl = 1, ma = 2, kd = 12800;
    function ou(u) {
      return console.error(u), null;
    }
    function Ar() {
    }
    function wd(u, h, C, z, G, ce, me, Le, l) {
      var f = [], k = /* @__PURE__ */ new Set(), R = {
        destination: null,
        responseState: h,
        progressiveChunkSize: z === void 0 ? kd : z,
        status: iu,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: k,
        pingedTasks: f,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: G === void 0 ? ou : G,
        onAllReady: ce === void 0 ? Ar : ce,
        onShellReady: me === void 0 ? Ar : me,
        onShellError: Le === void 0 ? Ar : Le,
        onFatalError: l === void 0 ? Ar : l
      }, H = zo(
        R,
        0,
        null,
        C,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      H.parentFlushed = !0;
      var oe = Ul(R, u, null, H, k, oa, Us, id);
      return f.push(oe), R;
    }
    function Td(u, h) {
      var C = u.pingedTasks;
      C.push(h), C.length === 1 && d(function() {
        return wi(u);
      });
    }
    function xi(u, h) {
      return {
        id: Fn,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: h,
        errorDigest: null
      };
    }
    function Ul(u, h, C, z, G, ce, me, Le) {
      u.allPendingTasks++, C === null ? u.pendingRootTasks++ : C.pendingTasks++;
      var l = {
        node: h,
        ping: function() {
          return Td(u, l);
        },
        blockedBoundary: C,
        blockedSegment: z,
        abortSet: G,
        legacyContext: ce,
        context: me,
        treeContext: Le
      };
      return l.componentStack = null, G.add(l), l;
    }
    function zo(u, h, C, z, G, ce) {
      return {
        status: Wl,
        id: -1,
        // lazily assigned later
        index: h,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: z,
        boundary: C,
        lastPushedText: G,
        textEmbedded: ce
      };
    }
    var zr = null;
    function bi() {
      return zr === null || zr.componentStack === null ? "" : au(zr.componentStack);
    }
    function Gr(u, h) {
      u.componentStack = {
        tag: 0,
        parent: u.componentStack,
        type: h
      };
    }
    function Lr(u, h) {
      u.componentStack = {
        tag: 1,
        parent: u.componentStack,
        type: h
      };
    }
    function Kl(u, h) {
      u.componentStack = {
        tag: 2,
        parent: u.componentStack,
        type: h
      };
    }
    function vr(u) {
      u.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : u.componentStack = u.componentStack.parent;
    }
    var Ba = null;
    function Yl(u, h) {
      {
        var C;
        typeof h == "string" ? C = h : h && typeof h.message == "string" ? C = h.message : C = String(h);
        var z = Ba || bi();
        Ba = null, u.errorMessage = C, u.errorComponentStack = z;
      }
    }
    function xr(u, h) {
      var C = u.onError(h);
      if (C != null && typeof C != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof C + '" instead');
      return C;
    }
    function Xr(u, h) {
      var C = u.onShellError;
      C(h);
      var z = u.onFatalError;
      z(h), u.destination !== null ? (u.status = ma, A(u.destination, h)) : (u.status = jl, u.fatalError = h);
    }
    function Gl(u, h, C) {
      Gr(h, "Suspense");
      var z = h.blockedBoundary, G = h.blockedSegment, ce = C.fallback, me = C.children, Le = /* @__PURE__ */ new Set(), l = xi(u, Le), f = G.chunks.length, k = zo(
        u,
        f,
        l,
        G.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      G.children.push(k), G.lastPushedText = !1;
      var R = zo(
        u,
        0,
        null,
        G.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      R.parentFlushed = !0, h.blockedBoundary = l, h.blockedSegment = R;
      try {
        if (rs(u, h, me), Qn(R.chunks, u.responseState, R.lastPushedText, R.textEmbedded), R.status = Yr, $o(l, R), l.pendingTasks === 0) {
          vr(h);
          return;
        }
      } catch (oe) {
        R.status = ha, l.forceClientRender = !0, l.errorDigest = xr(u, oe), Yl(l, oe);
      } finally {
        h.blockedBoundary = z, h.blockedSegment = G;
      }
      var H = Ul(u, ce, z, k, Le, h.legacyContext, h.context, h.treeContext);
      H.componentStack = h.componentStack, u.pingedTasks.push(H), vr(h);
    }
    function Ei(u, h, C, z) {
      Gr(h, C);
      var G = h.blockedSegment, ce = Za(G.chunks, C, z, u.responseState, G.formatContext);
      G.lastPushedText = !1;
      var me = G.formatContext;
      G.formatContext = _n(me, C, z), rs(u, h, ce), G.formatContext = me, Xi(G.chunks, C), G.lastPushedText = !1, vr(h);
    }
    function Bo(u) {
      return u.prototype && u.prototype.isReactComponent;
    }
    function lu(u, h, C, z, G) {
      var ce = {};
      fd(h, ce);
      var me = C(z, G);
      return Qs(C, z, me, G);
    }
    function su(u, h, C, z, G) {
      var ce = C.render();
      C.props !== G && (ki || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", En(z) || "a component"), ki = !0);
      {
        var me = z.childContextTypes;
        if (me != null) {
          var Le = h.legacyContext, l = Ol(C, z, Le, me);
          h.legacyContext = l, dr(u, h, ce), h.legacyContext = Le;
          return;
        }
      }
      dr(u, h, ce);
    }
    function Cd(u, h, C, z) {
      Kl(h, C);
      var G = _l(C, h.legacyContext), ce = Xs(C, z, G);
      Zs(ce, C, z, G), su(u, h, ce, C, z), vr(h);
    }
    var Xl = {}, Si = {}, uu = {}, ql = {}, ki = !1, Zl = !1, Ql = !1, Jl = !1;
    function cu(u, h, C, z) {
      var G;
      if (G = _l(C, h.legacyContext), Lr(h, C), C.prototype && typeof C.prototype.render == "function") {
        var ce = En(C) || "Unknown";
        Xl[ce] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", ce, ce), Xl[ce] = !0);
      }
      var me = lu(u, h, C, z, G), Le = No();
      if (typeof me == "object" && me !== null && typeof me.render == "function" && me.$$typeof === void 0) {
        var l = En(C) || "Unknown";
        Si[l] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", l, l, l), Si[l] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof me == "object" && me !== null && typeof me.render == "function" && me.$$typeof === void 0
      ) {
        {
          var f = En(C) || "Unknown";
          Si[f] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", f, f, f), Si[f] = !0);
        }
        Zs(me, C, z, G), su(u, h, me, C, z);
      } else if (du(C), Le) {
        var k = h.treeContext, R = 1, H = 0;
        h.treeContext = Co(k, R, H);
        try {
          dr(u, h, me);
        } finally {
          h.treeContext = k;
        }
      } else
        dr(u, h, me);
      vr(h);
    }
    function du(u) {
      {
        if (u && u.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", u.displayName || u.name || "Component"), typeof u.getDerivedStateFromProps == "function") {
          var h = En(u) || "Unknown";
          ql[h] || (i("%s: Function components do not support getDerivedStateFromProps.", h), ql[h] = !0);
        }
        if (typeof u.contextType == "object" && u.contextType !== null) {
          var C = En(u) || "Unknown";
          uu[C] || (i("%s: Function components do not support contextType.", C), uu[C] = !0);
        }
      }
    }
    function es(u, h) {
      if (u && u.defaultProps) {
        var C = yr({}, h), z = u.defaultProps;
        for (var G in z)
          C[G] === void 0 && (C[G] = z[G]);
        return C;
      }
      return h;
    }
    function Ad(u, h, C, z, G) {
      Lr(h, C.render);
      var ce = lu(u, h, C.render, z, G), me = No();
      if (me) {
        var Le = h.treeContext, l = 1, f = 0;
        h.treeContext = Co(Le, l, f);
        try {
          dr(u, h, ce);
        } finally {
          h.treeContext = Le;
        }
      } else
        dr(u, h, ce);
      vr(h);
    }
    function Ld(u, h, C, z, G) {
      var ce = C.type, me = es(ce, z);
      ts(u, h, ce, me, G);
    }
    function fu(u, h, C, z) {
      C._context === void 0 ? C !== C.Consumer && (Jl || (Jl = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : C = C._context;
      var G = z.children;
      typeof G != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var ce = pi(C), me = G(ce);
      dr(u, h, me);
    }
    function Pd(u, h, C, z) {
      var G = C._context, ce = z.value, me = z.children, Le;
      Le = h.context, h.context = Ks(G, ce), dr(u, h, me), h.context = Ys(G), Le !== h.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function Rd(u, h, C, z, G) {
      Gr(h, "Lazy");
      var ce = C._payload, me = C._init, Le = me(ce), l = es(Le, z);
      ts(u, h, Le, l, G), vr(h);
    }
    function ts(u, h, C, z, G) {
      if (typeof C == "function")
        if (Bo(C)) {
          Cd(u, h, C, z);
          return;
        } else {
          cu(u, h, C, z);
          return;
        }
      if (typeof C == "string") {
        Ei(u, h, C, z);
        return;
      }
      switch (C) {
        case co:
        case El:
        case zs:
        case xl:
        case cr: {
          dr(u, h, z.children);
          return;
        }
        case ai: {
          Gr(h, "SuspenseList"), dr(u, h, z.children), vr(h);
          return;
        }
        case bl:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case ri: {
          Gl(u, h, z);
          return;
        }
      }
      if (typeof C == "object" && C !== null)
        switch (C.$$typeof) {
          case uo: {
            Ad(u, h, C, z, G);
            return;
          }
          case ii: {
            Ld(u, h, C, z, G);
            return;
          }
          case lo: {
            Pd(u, h, C, z);
            return;
          }
          case so: {
            fu(u, h, C, z);
            return;
          }
          case Na: {
            Rd(u, h, C, z);
            return;
          }
        }
      var ce = "";
      throw (C === void 0 || typeof C == "object" && C !== null && Object.keys(C).length === 0) && (ce += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (C == null ? C : typeof C) + "." + ce));
    }
    function Nd(u, h) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      u[Symbol.toStringTag] === "Generator" && (Zl || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Zl = !0), u.entries === h && (Ql || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Ql = !0);
    }
    function dr(u, h, C) {
      try {
        return ns(u, h, C);
      } catch (z) {
        throw typeof z == "object" && z !== null && typeof z.then == "function" || (Ba = Ba !== null ? Ba : bi()), z;
      }
    }
    function ns(u, h, C) {
      if (h.node = C, typeof C == "object" && C !== null) {
        switch (C.$$typeof) {
          case Qc: {
            var z = C, G = z.type, ce = z.props, me = z.ref;
            ts(u, h, G, ce, me);
            return;
          }
          case Ms:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Na: {
            var Le = C, l = Le._payload, f = Le._init, k;
            try {
              k = f(l);
            } catch (it) {
              throw typeof it == "object" && it !== null && typeof it.then == "function" && Gr(h, "Lazy"), it;
            }
            dr(u, h, k);
            return;
          }
        }
        if (Se(C)) {
          pu(u, h, C);
          return;
        }
        var R = td(C);
        if (R) {
          Nd(C, R);
          var H = R.call(C);
          if (H) {
            var oe = H.next();
            if (!oe.done) {
              var he = [];
              do
                he.push(oe.value), oe = H.next();
              while (!oe.done);
              pu(u, h, he);
              return;
            }
            return;
          }
        }
        var Ae = Object.prototype.toString.call(C);
        throw new Error("Objects are not valid as a React child (found: " + (Ae === "[object Object]" ? "object with keys {" + Object.keys(C).join(", ") + "}" : Ae) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof C == "string") {
        var Ie = h.blockedSegment;
        Ie.lastPushedText = Zn(h.blockedSegment.chunks, C, u.responseState, Ie.lastPushedText);
        return;
      }
      if (typeof C == "number") {
        var rt = h.blockedSegment;
        rt.lastPushedText = Zn(h.blockedSegment.chunks, "" + C, u.responseState, rt.lastPushedText);
        return;
      }
      typeof C == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function pu(u, h, C) {
      for (var z = C.length, G = 0; G < z; G++) {
        var ce = h.treeContext;
        h.treeContext = Co(ce, z, G);
        try {
          rs(u, h, C[G]);
        } finally {
          h.treeContext = ce;
        }
      }
    }
    function fr(u, h, C) {
      var z = h.blockedSegment, G = z.chunks.length, ce = zo(
        u,
        G,
        null,
        z.formatContext,
        // Adopt the parent segment's leading text embed
        z.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      z.children.push(ce), z.lastPushedText = !1;
      var me = Ul(u, h.node, h.blockedBoundary, ce, h.abortSet, h.legacyContext, h.context, h.treeContext);
      h.componentStack !== null && (me.componentStack = h.componentStack.parent);
      var Le = me.ping;
      C.then(Le, Le);
    }
    function rs(u, h, C) {
      var z = h.blockedSegment.formatContext, G = h.legacyContext, ce = h.context, me = null;
      me = h.componentStack;
      try {
        return dr(u, h, C);
      } catch (Le) {
        if (Hl(), typeof Le == "object" && Le !== null && typeof Le.then == "function") {
          fr(u, h, Le), h.blockedSegment.formatContext = z, h.legacyContext = G, h.context = ce, fi(ce), h.componentStack = me;
          return;
        } else
          throw h.blockedSegment.formatContext = z, h.legacyContext = G, h.context = ce, fi(ce), h.componentStack = me, Le;
      }
    }
    function hu(u, h, C, z) {
      var G = xr(u, z);
      if (h === null ? Xr(u, z) : (h.pendingTasks--, h.forceClientRender || (h.forceClientRender = !0, h.errorDigest = G, Yl(h, z), h.parentFlushed && u.clientRenderedBoundaries.push(h))), u.allPendingTasks--, u.allPendingTasks === 0) {
        var ce = u.onAllReady;
        ce();
      }
    }
    function Dd(u) {
      var h = this, C = u.blockedBoundary, z = u.blockedSegment;
      z.status = Mo, mu(h, C, z);
    }
    function Io(u, h, C) {
      var z = u.blockedBoundary, G = u.blockedSegment;
      if (G.status = Mo, z === null)
        h.allPendingTasks--, h.status !== ma && (h.status = ma, h.destination !== null && S(h.destination));
      else {
        if (z.pendingTasks--, !z.forceClientRender) {
          z.forceClientRender = !0;
          var ce = C === void 0 ? new Error("The render was aborted by the server without a reason.") : C;
          z.errorDigest = h.onError(ce);
          {
            var me = "The server did not finish this Suspense boundary: ";
            ce && typeof ce.message == "string" ? ce = me + ce.message : ce = me + String(ce);
            var Le = zr;
            zr = u;
            try {
              Yl(z, ce);
            } finally {
              zr = Le;
            }
          }
          z.parentFlushed && h.clientRenderedBoundaries.push(z);
        }
        if (z.fallbackAbortableTasks.forEach(function(f) {
          return Io(f, h, C);
        }), z.fallbackAbortableTasks.clear(), h.allPendingTasks--, h.allPendingTasks === 0) {
          var l = h.onAllReady;
          l();
        }
      }
    }
    function $o(u, h) {
      if (h.chunks.length === 0 && h.children.length === 1 && h.children[0].boundary === null) {
        var C = h.children[0];
        C.id = h.id, C.parentFlushed = !0, C.status === Yr && $o(u, C);
      } else {
        var z = u.completedSegments;
        z.push(h);
      }
    }
    function mu(u, h, C) {
      if (h === null) {
        if (C.parentFlushed) {
          if (u.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          u.completedRootSegment = C;
        }
        if (u.pendingRootTasks--, u.pendingRootTasks === 0) {
          u.onShellError = Ar;
          var z = u.onShellReady;
          z();
        }
      } else if (h.pendingTasks--, !h.forceClientRender) {
        if (h.pendingTasks === 0)
          C.parentFlushed && C.status === Yr && $o(h, C), h.parentFlushed && u.completedBoundaries.push(h), h.fallbackAbortableTasks.forEach(Dd, u), h.fallbackAbortableTasks.clear();
        else if (C.parentFlushed && C.status === Yr) {
          $o(h, C);
          var G = h.completedSegments;
          G.length === 1 && h.parentFlushed && u.partialBoundaries.push(h);
        }
      }
      if (u.allPendingTasks--, u.allPendingTasks === 0) {
        var ce = u.onAllReady;
        ce();
      }
    }
    function yu(u, h) {
      var C = h.blockedSegment;
      if (C.status === Wl) {
        fi(h.context);
        var z = null;
        z = zr, zr = h;
        try {
          dr(u, h, h.node), Qn(C.chunks, u.responseState, C.lastPushedText, C.textEmbedded), h.abortSet.delete(h), C.status = Yr, mu(u, h.blockedBoundary, C);
        } catch (ce) {
          if (Hl(), typeof ce == "object" && ce !== null && typeof ce.then == "function") {
            var G = h.ping;
            ce.then(G, G);
          } else
            h.abortSet.delete(h), C.status = ha, hu(u, h.blockedBoundary, C, ce);
        } finally {
          zr = z;
        }
      }
    }
    function wi(u) {
      if (u.status !== ma) {
        var h = go(), C = vi.current;
        vi.current = ru;
        var z;
        z = Oo.getCurrentStack, Oo.getCurrentStack = bi;
        var G = Vl;
        gi(u.responseState);
        try {
          var ce = u.pingedTasks, me;
          for (me = 0; me < ce.length; me++) {
            var Le = ce[me];
            yu(u, Le);
          }
          ce.splice(0, me), u.destination !== null && Vo(u, u.destination);
        } catch (l) {
          xr(u, l), Xr(u, l);
        } finally {
          gi(G), vi.current = C, Oo.getCurrentStack = z, C === ru && fi(h);
        }
      }
    }
    function Ti(u, h, C) {
      switch (C.parentFlushed = !0, C.status) {
        case Wl: {
          var z = C.id = u.nextSegmentId++;
          return C.lastPushedText = !1, C.textEmbedded = !1, Sa(h, u.responseState, z);
        }
        case Yr: {
          C.status = Fo;
          for (var G = !0, ce = C.chunks, me = 0, Le = C.children, l = 0; l < Le.length; l++) {
            for (var f = Le[l]; me < f.index; me++)
              g(h, ce[me]);
            G = Ho(u, h, f);
          }
          for (; me < ce.length - 1; me++)
            g(h, ce[me]);
          return me < ce.length && (G = b(h, ce[me])), G;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ho(u, h, C) {
      var z = C.boundary;
      if (z === null)
        return Ti(u, h, C);
      if (z.parentFlushed = !0, z.forceClientRender)
        return Xn(h, u.responseState, z.errorDigest, z.errorMessage, z.errorComponentStack), Ti(u, h, C), hl(h, u.responseState);
      if (z.pendingTasks > 0) {
        z.rootSegmentID = u.nextSegmentId++, z.completedSegments.length > 0 && u.partialBoundaries.push(z);
        var G = z.id = Kn(u.responseState);
        return Ta(h, u.responseState, G), Ti(u, h, C), Ca(h, u.responseState);
      } else {
        if (z.byteSize > u.progressiveChunkSize)
          return z.rootSegmentID = u.nextSegmentId++, u.completedBoundaries.push(z), Ta(h, u.responseState, z.id), Ti(u, h, C), Ca(h, u.responseState);
        Zi(h, u.responseState);
        var ce = z.completedSegments;
        if (ce.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var me = ce[0];
        return Ho(u, h, me), Qi(h, u.responseState);
      }
    }
    function gu(u, h, C) {
      return Os(h, u.responseState, C.id, C.errorDigest, C.errorMessage, C.errorComponentStack);
    }
    function Ci(u, h, C) {
      return Et(h, u.responseState, C.formatContext, C.id), Ho(u, h, C), un(h, C.formatContext);
    }
    function Ai(u, h, C) {
      for (var z = C.completedSegments, G = 0; G < z.length; G++) {
        var ce = z[G];
        as(u, h, C, ce);
      }
      return z.length = 0, ml(h, u.responseState, C.id, C.rootSegmentID);
    }
    function _d(u, h, C) {
      for (var z = C.completedSegments, G = 0; G < z.length; G++) {
        var ce = z[G];
        if (!as(u, h, C, ce))
          return G++, z.splice(0, G), !1;
      }
      return z.splice(0, G), !0;
    }
    function as(u, h, C, z) {
      if (z.status === Fo)
        return !0;
      var G = z.id;
      if (G === -1) {
        var ce = z.id = C.rootSegmentID;
        if (ce === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Ci(u, h, z);
      } else
        return Ci(u, h, z), jc(h, u.responseState, G);
    }
    function Vo(u, h) {
      y();
      try {
        var C = u.completedRootSegment;
        C !== null && u.pendingRootTasks === 0 && (Ho(u, h, C), u.completedRootSegment = null, dl(h, u.responseState));
        var z = u.clientRenderedBoundaries, G;
        for (G = 0; G < z.length; G++) {
          var ce = z[G];
          gu(u, h, ce);
        }
        z.splice(0, G);
        var me = u.completedBoundaries;
        for (G = 0; G < me.length; G++) {
          var Le = me[G];
          Ai(u, h, Le);
        }
        me.splice(0, G), w(h), y(h);
        var l = u.partialBoundaries;
        for (G = 0; G < l.length; G++) {
          var f = l[G];
          if (!_d(u, h, f)) {
            u.destination = null, G++, l.splice(0, G);
            return;
          }
        }
        l.splice(0, G);
        var k = u.completedBoundaries;
        for (G = 0; G < k.length; G++) {
          var R = k[G];
          Ai(u, h, R);
        }
        k.splice(0, G);
      } finally {
        w(h), u.allPendingTasks === 0 && u.pingedTasks.length === 0 && u.clientRenderedBoundaries.length === 0 && u.completedBoundaries.length === 0 && (u.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), S(h));
      }
    }
    function Od(u) {
      d(function() {
        return wi(u);
      });
    }
    function vu(u, h) {
      if (u.status === jl) {
        u.status = ma, A(h, u.fatalError);
        return;
      }
      if (u.status !== ma && u.destination === null) {
        u.destination = h;
        try {
          Vo(u, h);
        } catch (C) {
          xr(u, C), Xr(u, C);
        }
      }
    }
    function Wo(u, h) {
      try {
        var C = u.abortableTasks;
        C.forEach(function(z) {
          return Io(z, u, h);
        }), C.clear(), u.destination !== null && Vo(u, u.destination);
      } catch (z) {
        xr(u, z), Xr(u, z);
      }
    }
    function Fd(u, h) {
      return new Promise(function(C, z) {
        var G, ce, me = new Promise(function(H, oe) {
          ce = H, G = oe;
        });
        function Le() {
          var H = new ReadableStream(
            {
              type: "bytes",
              pull: function(oe) {
                vu(f, oe);
              },
              cancel: function(oe) {
                Wo(f);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          H.allReady = me, C(H);
        }
        function l(H) {
          me.catch(function() {
          }), z(H);
        }
        var f = wd(u, tn(h ? h.identifierPrefix : void 0, h ? h.nonce : void 0, h ? h.bootstrapScriptContent : void 0, h ? h.bootstrapScripts : void 0, h ? h.bootstrapModules : void 0), Dn(h ? h.namespaceURI : void 0), h ? h.progressiveChunkSize : void 0, h ? h.onError : void 0, ce, Le, l, G);
        if (h && h.signal) {
          var k = h.signal, R = function() {
            Wo(f, k.reason), k.removeEventListener("abort", R);
          };
          k.addEventListener("abort", R);
        }
        Od(f);
      });
    }
    Mu.renderToReadableStream = Fd, Mu.version = t;
  }()), Mu;
}
var Wi, Hf;
process.env.NODE_ENV === "production" ? (Wi = vS(), Hf = xS()) : (Wi = bS(), Hf = ES());
Xa.version = Wi.version;
Xa.renderToString = Wi.renderToString;
Xa.renderToStaticMarkup = Wi.renderToStaticMarkup;
Xa.renderToNodeStream = Wi.renderToNodeStream;
Xa.renderToStaticNodeStream = Wi.renderToStaticNodeStream;
Xa.renderToReadableStream = Hf.renderToReadableStream;
const nm = ({ columnData: e }) => /* @__PURE__ */ n.createElement("ul", null, e == null ? void 0 : e.map((t, r) => /* @__PURE__ */ n.createElement("li", { key: r }, t.label, ": ", t.value, " (", t.additional_info, "%)"))), SS = (e, t) => {
  var y, g, b, w, S, L;
  const r = `${(((y = e == null ? void 0 : e.tooltips) == null ? void 0 : y.find((m) => m.node === t)) || {}).value}`, a = `${(((g = e == null ? void 0 : e.tooltips) == null ? void 0 : g.find((m) => m.node === t)) || {}).summary}`, i = (((b = e == null ? void 0 : e.tooltips) == null ? void 0 : b.find((m) => m.node === t)) || {}).column1Label, o = (((w = e == null ? void 0 : e.tooltips) == null ? void 0 : w.find((m) => m.node === t)) || {}).column2Label, d = (((S = e == null ? void 0 : e.tooltips) == null ? void 0 : S.find((m) => m.node === t)) || {}).column1, c = (((L = e == null ? void 0 : e.tooltips) == null ? void 0 : L.find((m) => m.node === t)) || {}).column2, s = Xa.renderToString(/* @__PURE__ */ n.createElement(nm, { columnData: d })), p = Xa.renderToString(/* @__PURE__ */ n.createElement(nm, { columnData: c }));
  return `<div class="sankey-chart__tooltip">
    <span class="sankey-chart__tooltip--tooltip-header">${t}</span>
    <span class="sankey-chart__tooltip--tooltip-header">${r}</span>
    <div class="divider"></div>
    <span><strong>Summary: </strong>${a}</span>
    <div class="divider"></div>
    <div class="sankey-chart__tooltip--info-section">
      <div>
        <span><strong>${i}</strong></span>
        ${s}
      </div>
      <div>
        <span><strong>${o}</strong></span>
        ${p}
      </div>
    </div>
  </div>
`;
}, kS = ({ width: e, height: t, runtime: r }) => {
  var te, le;
  const { config: a } = se.useContext(ft), { sankey: i } = a, [o, d] = se.useState(0), [c, s] = se.useState(""), { showAlert: p, alert: y } = gS(), g = se.useRef([]), b = (B) => {
    const X = c;
    X && s(""), X !== B && s(B);
  };
  if (se.useEffect(() => {
    var X;
    let B = 0;
    (X = g == null ? void 0 : g.current) == null || X.map((ue) => {
      const ne = ue == null ? void 0 : ue.getBoundingClientRect().width;
      ne > B && (B = ne);
    }), d(B);
  }, [g, i, window.innerWidth]), a.visualizationType !== "Sankey")
    return;
  const w = a == null ? void 0 : a.data[0], S = Array.from(new Set((te = w == null ? void 0 : w.links) == null ? void 0 : te.flatMap((B) => [B.source, B.target]))), L = {
    nodes: S.map((B) => ({ id: B })),
    links: (le = w == null ? void 0 : w.links) == null ? void 0 : le.map((B) => ({
      source: S.findIndex((X) => X === B.source),
      target: S.findIndex((X) => X === B.target),
      value: B.value
    }))
  };
  let m = 5;
  const v = 50, A = pS().nodeWidth(i.nodeSize.nodeWidth).nodePadding(i.nodePadding).iterations(i.iterations).nodeAlign(sS).extent([
    [i.margin.margin_x, Number(i.margin.margin_y)],
    [e - m - o, a.heights.vertical - v]
  ]), { links: P } = A(L), T = (B) => {
    var W;
    let X = 30, ue = 0, ne = "node-value--storynode", J = !0;
    return (W = w == null ? void 0 : w.storyNodeText) != null && W.every((K) => K.StoryNode !== B) && (J = !1, ue = 10, X = 8, ne = "node-value"), { textPositionHorizontal: X, textPositionVertical: ue, classStyle: ne, storyNodes: J };
  }, _ = (B) => {
    if (!(L != null && L.nodes))
      return { sourceNodes: [], activeLinks: [] };
    const X = L.nodes.find((J) => J.id === B), ue = [], ne = [];
    return X && (P.forEach((J) => {
      const W = J.target, K = J.source;
      W.id === B && ue.push(K.id);
    }), ue.forEach((J) => {
      P.forEach((W) => {
        const K = W.target, ee = W.source;
        K.id === c && ee.id === J && ne.push(W);
      });
    })), { sourceNodes: ue, activeLinks: ne };
  }, M = SS(w, c), Z = L.nodes.map((B, X) => {
    var Te, ye;
    let { textPositionHorizontal: ue, textPositionVertical: ne, classStyle: J, storyNodes: W } = T(B.id), { sourceNodes: K } = _(c), ee = i.opacity.nodeOpacityDefault, $ = i.nodeColor.default;
    c !== B.id && c !== "" && !K.includes(B.id) && ($ = i.nodeColor.inactive, ee = i.opacity.nodeOpacityInactive);
    const pe = A.nodeWidth(), ve = () => Math.sqrt(
      Math.pow(P[0].target.x0 - P[0].source.x1, 2) + Math.pow(P[0].target.y0 - P[0].source.y1, 2)
    ) - o;
    return /* @__PURE__ */ n.createElement(tt, { className: "", key: X }, /* @__PURE__ */ n.createElement(
      "rect",
      {
        height: B.y1 - B.y0 + 2,
        width: pe,
        x: B.x0,
        y: B.y0 - 1,
        fill: $,
        fillOpacity: ee,
        rx: i.rxValue,
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? M : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
        onClick: () => b(B.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), W ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      ct,
      {
        width: ve(),
        x: B.x0 + ue,
        textAnchor: L.nodes.length - 1 === X ? "end" : "start",
        verticalAnchor: "end",
        y: (B.y1 + B.y0) / 2 - 30,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        className: "node-text",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => b(B.id),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? M : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      (((Te = w == null ? void 0 : w.storyNodeText) == null ? void 0 : Te.find((Re) => Re.StoryNode === B.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ n.createElement(
      ct,
      {
        width: ve(),
        verticalAnchor: "middle",
        className: J,
        x: B.x0 + ue,
        y: (B.y1 + B.y0 + 25) / 2,
        fill: i.storyNodeFontColor || i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => b(B.id),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? M : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      typeof B.value == "number" ? B.value.toLocaleString() : B.value
    ), /* @__PURE__ */ n.createElement(
      ct,
      {
        width: ve(),
        x: B.x0 + ue,
        y: (B.y1 + B.y0) / 2 + 50,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: L.nodes.length === X ? "end" : "start",
        className: "node-text",
        verticalAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => b(B.id),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? M : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      (((ye = w == null ? void 0 : w.storyNodeText) == null ? void 0 : ye.find((Re) => Re.StoryNode === B.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      ct,
      {
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => b(B.id),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? M : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
        x: B.x0 + ue,
        y: (B.y1 + B.y0) / 2 + ne,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start"
      },
      B.id
    ), /* @__PURE__ */ n.createElement(
      "text",
      {
        x: B.x0 + ue,
        y: (B.y1 + B.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => b(B.id),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? M : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      /* @__PURE__ */ n.createElement("tspan", { className: J }, i.nodeValueStyle.textBefore + (typeof B.value == "number" ? B.value.toLocaleString() : B.value) + i.nodeValueStyle.textAfter)
    )));
  }), Y = P.map((B, X) => {
    const ne = yS()(B);
    let J = i.opacity.LinkOpacityDefault, W = i.linkColor.default, { activeLinks: K } = _(c);
    return !K.includes(B) && c !== "" && (W = i.linkColor.inactive, J = i.opacity.LinkOpacityInactive), /* @__PURE__ */ n.createElement(
      "path",
      {
        key: X,
        d: ne,
        stroke: W,
        fill: "none",
        strokeOpacity: J,
        strokeWidth: B.width + 2,
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => b(B.target.id || null),
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? M : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      }
    );
  }), ae = L.nodes.reduce((B, X) => Math.max(B, X.depth), -1), q = L.nodes.filter((B) => B.depth === ae).map((B, X) => {
    var pe, ve;
    let { textPositionHorizontal: ue, textPositionVertical: ne, classStyle: J, storyNodes: W } = T(B.id), { sourceNodes: K } = _(c), ee = i.opacity.nodeOpacityDefault, $ = i.nodeColor.default;
    return c !== B.id && c !== "" && !K.includes(B.id) && ($ = i.nodeColor.inactive, ee = i.opacity.nodeOpacityInactive), /* @__PURE__ */ n.createElement(tt, { className: "", key: X, innerRef: (Te) => g.current[X] = Te }, /* @__PURE__ */ n.createElement(
      "rect",
      {
        height: B.y1 - B.y0 + 2,
        width: A.nodeWidth(),
        x: B.x0,
        y: B.y0 - 1,
        fill: $,
        fillOpacity: ee,
        rx: i.rxValue,
        "data-tooltip-html": w.tooltips && a.enableTooltips && c !== "" ? M : null,
        "data-tooltip-id": "tooltip",
        onClick: () => b(B.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), W ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      ct,
      {
        x: B.x0 + ue,
        textAnchor: L.nodes.length - 1 === X ? "end" : "start",
        verticalAnchor: "end",
        y: (B.y1 + B.y0) / 2 - 30,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        style: { pointerEvents: "none" },
        className: "node-text"
      },
      (((pe = w == null ? void 0 : w.storyNodeText) == null ? void 0 : pe.find((Te) => Te.StoryNode === B.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ n.createElement(
      ct,
      {
        verticalAnchor: "end",
        className: J,
        x: B.x0 + ue,
        y: (B.y1 + B.y0 + 25) / 2,
        fill: i.storyNodeFontColor || i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      typeof B.value == "number" ? B.value.toLocaleString() : B.value
    ), /* @__PURE__ */ n.createElement(
      ct,
      {
        x: B.x0 + ue,
        y: (B.y1 + B.y0) / 2 + 50,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: L.nodes.length === X ? "end" : "start",
        style: { pointerEvents: "none" },
        className: "node-text",
        verticalAnchor: "end"
      },
      (((ve = w == null ? void 0 : w.storyNodeText) == null ? void 0 : ve.find((Te) => Te.StoryNode === B.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      "text",
      {
        x: B.x0 + ue,
        y: (B.y1 + B.y0) / 2 + ne,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ n.createElement("tspan", { id: B.id, className: "node-id" }, B.id)
    ), /* @__PURE__ */ n.createElement(
      "text",
      {
        x: B.x0 + ue,
        y: (B.y1 + B.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ n.createElement("tspan", { onClick: () => b(B.id), className: J }, i.nodeValueStyle.textBefore + (typeof B.value == "number" ? B.value.toLocaleString() : B.value) + i.nodeValueStyle.textAfter)
    )));
  });
  return p ? y : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: "sankey-chart" }, /* @__PURE__ */ n.createElement(
    "svg",
    {
      className: "sankey-chart__diagram",
      width: e,
      height: Number(a.heights.vertical),
      style: { overflow: "visible" }
    },
    /* @__PURE__ */ n.createElement(tt, { className: "links" }, Y),
    /* @__PURE__ */ n.createElement(tt, { className: "nodes" }, Z),
    /* @__PURE__ */ n.createElement(tt, { className: "finalNodes", style: { display: "none" } }, q)
  ), /* @__PURE__ */ n.createElement(
    mc,
    {
      id: `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
      afterHide: () => s(""),
      events: ["click"],
      place: "bottom",
      style: {
        backgroundColor: "rgba(238, 238, 238, 1)",
        color: "black",
        boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)"
      }
    }
  )));
};
var wS = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const pr = wS;
function TS(e) {
  var t = e.labelOffset, r = e.labelProps, a = e.orientation, i = e.range, o = e.tickLabelFontSize, d = e.tickLength, c = a === pr.left || a === pr.top ? -1 : 1, s, p, y;
  if (a === pr.top || a === pr.bottom) {
    var g = a === pr.bottom && typeof r.fontSize == "number" ? r.fontSize : 0;
    s = (Number(i[0]) + Number(i[i.length - 1])) / 2, p = c * (d + t + o + g);
  } else
    s = c * ((Number(i[0]) + Number(i[i.length - 1])) / 2), p = -(d + t), y = "rotate(" + c * 90 + ")";
  return {
    x: s,
    y: p,
    transform: y
  };
}
function vs() {
  return vs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, vs.apply(this, arguments);
}
function CS(e) {
  var t = e.hideTicks, r = e.horizontal, a = e.orientation, i = e.tickClassName, o = e.tickComponent, d = e.tickLabelProps, c = e.tickStroke, s = c === void 0 ? "#222" : c, p = e.tickTransform, y = e.ticks, g = e.strokeWidth, b = e.tickLineProps;
  return y.map(function(w) {
    var S, L = w.value, m = w.index, v = w.from, A = w.to, P = w.formattedValue, T = (S = d[m]) != null ? S : {}, _ = Math.max(10, typeof T.fontSize == "number" && T.fontSize || 0), M = A.y + (r && a !== pr.top ? _ : 0);
    return /* @__PURE__ */ n.createElement(tt, {
      key: "visx-tick-" + L + "-" + m,
      className: Nn("visx-axis-tick", i),
      transform: p
    }, !t && /* @__PURE__ */ n.createElement(cn, vs({
      from: v,
      to: A,
      stroke: s,
      strokeWidth: g,
      strokeLinecap: "square"
    }, b)), o ? o(vs({}, T, {
      x: A.x,
      y: M,
      formattedValue: P
    })) : /* @__PURE__ */ n.createElement(ct, vs({
      x: A.x,
      y: M
    }, T), P));
  });
}
function gc() {
  return gc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, gc.apply(this, arguments);
}
var rm = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function AS(e) {
  var t = e.axisFromPoint, r = e.axisLineClassName, a = e.axisToPoint, i = e.hideAxisLine, o = e.hideTicks, d = e.horizontal, c = e.label, s = c === void 0 ? "" : c, p = e.labelClassName, y = e.labelOffset, g = y === void 0 ? 14 : y, b = e.labelProps, w = b === void 0 ? rm : b, S = e.orientation, L = S === void 0 ? pr.bottom : S, m = e.scale, v = e.stroke, A = v === void 0 ? "#222" : v, P = e.strokeDasharray, T = e.strokeWidth, _ = T === void 0 ? 1 : T, M = e.tickClassName, Z = e.tickComponent, Y = e.tickLineProps, ae = e.tickLabelProps, j = e.tickLength, q = j === void 0 ? 8 : j, te = e.tickStroke, le = te === void 0 ? "#222" : te, B = e.tickTransform, X = e.ticks, ue = e.ticksComponent, ne = ue === void 0 ? CS : ue, J = gc({}, rm, typeof ae == "object" ? ae : null), W = X.map(function(ee) {
    var $ = ee.value, pe = ee.index;
    return typeof ae == "function" ? ae($, pe, X) : J;
  }), K = Math.max.apply(Math, [10].concat(W.map(function(ee) {
    return typeof ee.fontSize == "number" ? ee.fontSize : 0;
  })));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, ne({
    hideTicks: o,
    horizontal: d,
    orientation: L,
    scale: m,
    tickClassName: M,
    tickComponent: Z,
    tickLabelProps: W,
    tickStroke: le,
    tickTransform: B,
    ticks: X,
    strokeWidth: _,
    tickLineProps: Y
  }), !i && /* @__PURE__ */ n.createElement(cn, {
    className: Nn("visx-axis-line", r),
    from: t,
    to: a,
    stroke: A,
    strokeWidth: _,
    strokeDasharray: P
  }), s && /* @__PURE__ */ n.createElement(ct, gc({
    className: Nn("visx-axis-label", p)
  }, TS({
    labelOffset: g,
    labelProps: w,
    orientation: L,
    range: m.range(),
    tickLabelFontSize: K,
    tickLength: q
  }), w), s));
}
function LS(e, t) {
  t === void 0 && (t = "center");
  var r = e;
  if (t !== "start" && "bandwidth" in r) {
    var a = r.bandwidth();
    return t === "center" && (a /= 2), r.round() && (a = Math.round(a)), function(i) {
      var o = r(i);
      return typeof o == "number" ? o + a : o;
    };
  }
  return e;
}
function PS(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : UE;
}
function zu(e, t) {
  var r = e.x, a = e.y;
  return new Cg(t ? {
    x: r,
    y: a
  } : {
    x: a,
    y: r
  });
}
function Vf() {
  return Vf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Vf.apply(this, arguments);
}
var tf = 0;
function RS(e) {
  return e === void 0 && (e = tf), typeof e == "number" ? {
    start: e,
    end: e
  } : Vf({
    start: tf,
    end: tf
  }, e);
}
var NS = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Wf() {
  return Wf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Wf.apply(this, arguments);
}
function DS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Bc(e) {
  var t = e.children, r = t === void 0 ? AS : t, a = e.axisClassName, i = e.hideAxisLine, o = i === void 0 ? !1 : i, d = e.hideTicks, c = d === void 0 ? !1 : d, s = e.hideZero, p = s === void 0 ? !1 : s, y = e.innerRef, g = e.left, b = g === void 0 ? 0 : g, w = e.numTicks, S = w === void 0 ? 10 : w, L = e.orientation, m = L === void 0 ? pr.bottom : L, v = e.rangePadding, A = v === void 0 ? 0 : v, P = e.scale, T = e.tickFormat, _ = e.tickLength, M = _ === void 0 ? 8 : _, Z = e.tickValues, Y = e.top, ae = Y === void 0 ? 0 : Y, j = DS(e, NS), q = T ?? PS(P), te = m === pr.left, le = m === pr.top, B = le || m === pr.bottom, X = LS(P), ue = te || le ? -1 : 1, ne = P.range(), J = RS(A), W = zu({
    x: Number(ne[0]) + 0.5 - J.start,
    y: 0
  }, B), K = zu({
    x: Number(ne[ne.length - 1]) + 0.5 + J.end,
    y: 0
  }, B), ee = (Z ?? Xy(P, S)).filter(function(pe) {
    return !p || pe !== 0 && pe !== "0";
  }).map(function(pe, ve) {
    return {
      value: pe,
      index: ve
    };
  }), $ = ee.map(function(pe) {
    var ve = pe.value, Te = pe.index, ye = jE(X(ve));
    return {
      value: ve,
      index: Te,
      from: zu({
        x: ye,
        y: 0
      }, B),
      to: zu({
        x: ye,
        y: M * ue
      }, B),
      formattedValue: q(ve, Te, ee)
    };
  });
  return /* @__PURE__ */ n.createElement(tt, {
    className: Nn("visx-axis", a),
    innerRef: y,
    top: ae,
    left: b
  }, r(Wf({}, j, {
    axisFromPoint: W,
    axisToPoint: K,
    hideAxisLine: o,
    hideTicks: c,
    hideZero: p,
    horizontal: B,
    numTicks: S,
    orientation: m,
    rangePadding: A,
    scale: P,
    tickFormat: q,
    tickLength: M,
    tickPosition: X,
    tickSign: ue,
    ticks: $
  })));
}
var _S = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function vc() {
  return vc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, vc.apply(this, arguments);
}
function OS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var FS = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function am(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 36 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = OS(e, _S), s = typeof d == "function" ? d : vc({}, FS, d);
  return /* @__PURE__ */ n.createElement(Bc, vc({
    axisClassName: Nn("visx-axis-left", t),
    labelOffset: a,
    orientation: pr.left,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var MS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function xc() {
  return xc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, xc.apply(this, arguments);
}
function zS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var BS = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function IS(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 36 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = zS(e, MS), s = typeof d == "function" ? d : xc({}, BS, d);
  return /* @__PURE__ */ n.createElement(Bc, xc({
    axisClassName: Nn("visx-axis-right", t),
    labelOffset: a,
    orientation: pr.right,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var $S = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function bc() {
  return bc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, bc.apply(this, arguments);
}
function HS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var VS = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function WS(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 8 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = HS(e, $S), s = typeof d == "function" ? d : bc({}, VS, d);
  return /* @__PURE__ */ n.createElement(Bc, bc({
    axisClassName: Nn("visx-axis-top", t),
    labelOffset: a,
    orientation: pr.top,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var jS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Ec() {
  return Ec = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ec.apply(this, arguments);
}
function US(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var KS = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function ju(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 8 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = US(e, jS), s = typeof d == "function" ? d : Ec({}, KS, d);
  return /* @__PURE__ */ n.createElement(Bc, Ec({
    axisClassName: Nn("visx-axis-bottom", t),
    labelOffset: a,
    orientation: pr.bottom,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
const nf = (e) => () => e;
function YS(e, {
  sourceEvent: t,
  target: r,
  selection: a,
  mode: i,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    selection: { value: a, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function GS(e) {
  e.stopImmediatePropagation();
}
function rf(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var im = { name: "drag" }, af = { name: "space" }, qo = { name: "handle" }, Zo = { name: "center" };
const { abs: om, max: nr, min: rr } = Math;
function lm(e) {
  return [+e[0], +e[1]];
}
function sm(e) {
  return [lm(e[0]), lm(e[1])];
}
var Uu = {
  name: "x",
  handles: ["w", "e"].map(Sc),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, of = {
  name: "y",
  handles: ["n", "s"].map(Sc),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, ya = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, um = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, cm = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, XS = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, qS = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Sc(e) {
  return { type: e };
}
function ZS(e) {
  return !e.ctrlKey && !e.button;
}
function QS() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function JS() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function lf(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function ek(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function tk() {
  return nk(Uu);
}
function nk(e) {
  var t = QS, r = ZS, a = JS, i = !0, o = Ag("start", "brush", "end"), d = 6, c;
  function s(m) {
    var v = m.property("__brush", L).selectAll(".overlay").data([Sc("overlay")]);
    v.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", ya.overlay).merge(v).each(function() {
      var P = lf(this).extent;
      Qo(this).attr("x", P[0][0]).attr("y", P[0][1]).attr("width", P[1][0] - P[0][0]).attr("height", P[1][1] - P[0][1]);
    }), m.selectAll(".selection").data([Sc("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", ya.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var A = m.selectAll(".handle").data(e.handles, function(P) {
      return P.type;
    });
    A.exit().remove(), A.enter().append("rect").attr("class", function(P) {
      return "handle handle--" + P.type;
    }).attr("cursor", function(P) {
      return ya[P.type];
    }), m.each(p).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", b).filter(a).on("touchstart.brush", b).on("touchmove.brush", w).on("touchend.brush touchcancel.brush", S).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  s.move = function(m, v, A) {
    m.tween ? m.on("start.brush", function(P) {
      y(this, arguments).beforestart().start(P);
    }).on("interrupt.brush end.brush", function(P) {
      y(this, arguments).end(P);
    }).tween("brush", function() {
      var P = this, T = P.__brush, _ = y(P, arguments), M = T.selection, Z = e.input(typeof v == "function" ? v.apply(this, arguments) : v, T.extent), Y = sv(M, Z);
      function ae(j) {
        T.selection = j === 1 && Z === null ? null : Y(j), p.call(P), _.brush();
      }
      return M !== null && Z !== null ? ae : ae(1);
    }) : m.each(function() {
      var P = this, T = arguments, _ = P.__brush, M = e.input(typeof v == "function" ? v.apply(P, T) : v, _.extent), Z = y(P, T).beforestart();
      _p(P), _.selection = M === null ? null : M, p.call(P), Z.start(A).brush(A).end(A);
    });
  }, s.clear = function(m, v) {
    s.move(m, null, v);
  };
  function p() {
    var m = Qo(this), v = lf(this).selection;
    v ? (m.selectAll(".selection").style("display", null).attr("x", v[0][0]).attr("y", v[0][1]).attr("width", v[1][0] - v[0][0]).attr("height", v[1][1] - v[0][1]), m.selectAll(".handle").style("display", null).attr("x", function(A) {
      return A.type[A.type.length - 1] === "e" ? v[1][0] - d / 2 : v[0][0] - d / 2;
    }).attr("y", function(A) {
      return A.type[0] === "s" ? v[1][1] - d / 2 : v[0][1] - d / 2;
    }).attr("width", function(A) {
      return A.type === "n" || A.type === "s" ? v[1][0] - v[0][0] + d : d;
    }).attr("height", function(A) {
      return A.type === "e" || A.type === "w" ? v[1][1] - v[0][1] + d : d;
    })) : m.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function y(m, v, A) {
    var P = m.__brush.emitter;
    return P && (!A || !P.clean) ? P : new g(m, v, A);
  }
  function g(m, v, A) {
    this.that = m, this.args = v, this.state = m.__brush, this.active = 0, this.clean = A;
  }
  g.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(m, v) {
      return this.starting ? (this.starting = !1, this.emit("start", m, v)) : this.emit("brush", m), this;
    },
    brush: function(m, v) {
      return this.emit("brush", m, v), this;
    },
    end: function(m, v) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", m, v)), this;
    },
    emit: function(m, v, A) {
      var P = Qo(this.that).datum();
      o.call(
        m,
        this.that,
        new YS(m, {
          sourceEvent: v,
          target: s,
          selection: e.output(this.state.selection),
          mode: A,
          dispatch: o
        }),
        P
      );
    }
  };
  function b(m) {
    if (c && !m.touches || !r.apply(this, arguments))
      return;
    var v = this, A = m.target.__data__.type, P = (i && m.metaKey ? A = "overlay" : A) === "selection" ? im : i && m.altKey ? Zo : qo, T = e === of ? null : XS[A], _ = e === Uu ? null : qS[A], M = lf(v), Z = M.extent, Y = M.selection, ae = Z[0][0], j, q, te = Z[0][1], le, B, X = Z[1][0], ue, ne, J = Z[1][1], W, K, ee = 0, $ = 0, pe, ve = T && _ && i && m.shiftKey, Te, ye, Re = Array.from(m.touches || [m], ($e) => {
      const Ye = $e.identifier;
      return $e = Op($e, v), $e.point0 = $e.slice(), $e.identifier = Ye, $e;
    });
    _p(v);
    var Xe = y(v, arguments, !0).beforestart();
    if (A === "overlay") {
      Y && (pe = !0);
      const $e = [Re[0], Re[1] || Re[0]];
      M.selection = Y = [[
        j = e === of ? ae : rr($e[0][0], $e[1][0]),
        le = e === Uu ? te : rr($e[0][1], $e[1][1])
      ], [
        ue = e === of ? X : nr($e[0][0], $e[1][0]),
        W = e === Uu ? J : nr($e[0][1], $e[1][1])
      ]], Re.length > 1 && Be(m);
    } else
      j = Y[0][0], le = Y[0][1], ue = Y[1][0], W = Y[1][1];
    q = j, B = le, ne = ue, K = W;
    var Ce = Qo(v).attr("pointer-events", "none"), xe = Ce.selectAll(".overlay").attr("cursor", ya[A]);
    if (m.touches)
      Xe.moved = de, Xe.ended = Ne;
    else {
      var Pe = Qo(m.view).on("mousemove.brush", de, !0).on("mouseup.brush", Ne, !0);
      i && Pe.on("keydown.brush", He, !0).on("keyup.brush", Ze, !0), Lg(m.view);
    }
    p.call(v), Xe.start(m, P.name);
    function de($e) {
      for (const Ye of $e.changedTouches || [$e])
        for (const qe of Re)
          qe.identifier === Ye.identifier && (qe.cur = Op(Ye, v));
      if (ve && !Te && !ye && Re.length === 1) {
        const Ye = Re[0];
        om(Ye.cur[0] - Ye[0]) > om(Ye.cur[1] - Ye[1]) ? ye = !0 : Te = !0;
      }
      for (const Ye of Re)
        Ye.cur && (Ye[0] = Ye.cur[0], Ye[1] = Ye.cur[1]);
      pe = !0, rf($e), Be($e);
    }
    function Be($e) {
      const Ye = Re[0], qe = Ye.point0;
      var Ve;
      switch (ee = Ye[0] - qe[0], $ = Ye[1] - qe[1], P) {
        case af:
        case im: {
          T && (ee = nr(ae - j, rr(X - ue, ee)), q = j + ee, ne = ue + ee), _ && ($ = nr(te - le, rr(J - W, $)), B = le + $, K = W + $);
          break;
        }
        case qo: {
          Re[1] ? (T && (q = nr(ae, rr(X, Re[0][0])), ne = nr(ae, rr(X, Re[1][0])), T = 1), _ && (B = nr(te, rr(J, Re[0][1])), K = nr(te, rr(J, Re[1][1])), _ = 1)) : (T < 0 ? (ee = nr(ae - j, rr(X - j, ee)), q = j + ee, ne = ue) : T > 0 && (ee = nr(ae - ue, rr(X - ue, ee)), q = j, ne = ue + ee), _ < 0 ? ($ = nr(te - le, rr(J - le, $)), B = le + $, K = W) : _ > 0 && ($ = nr(te - W, rr(J - W, $)), B = le, K = W + $));
          break;
        }
        case Zo: {
          T && (q = nr(ae, rr(X, j - ee * T)), ne = nr(ae, rr(X, ue + ee * T))), _ && (B = nr(te, rr(J, le - $ * _)), K = nr(te, rr(J, W + $ * _)));
          break;
        }
      }
      ne < q && (T *= -1, Ve = j, j = ue, ue = Ve, Ve = q, q = ne, ne = Ve, A in um && xe.attr("cursor", ya[A = um[A]])), K < B && (_ *= -1, Ve = le, le = W, W = Ve, Ve = B, B = K, K = Ve, A in cm && xe.attr("cursor", ya[A = cm[A]])), M.selection && (Y = M.selection), Te && (q = Y[0][0], ne = Y[1][0]), ye && (B = Y[0][1], K = Y[1][1]), (Y[0][0] !== q || Y[0][1] !== B || Y[1][0] !== ne || Y[1][1] !== K) && (M.selection = [[q, B], [ne, K]], p.call(v), Xe.brush($e, P.name));
    }
    function Ne($e) {
      if (GS($e), $e.touches) {
        if ($e.touches.length)
          return;
        c && clearTimeout(c), c = setTimeout(function() {
          c = null;
        }, 500);
      } else
        Pg($e.view, pe), Pe.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      Ce.attr("pointer-events", "all"), xe.attr("cursor", ya.overlay), M.selection && (Y = M.selection), ek(Y) && (M.selection = null, p.call(v)), Xe.end($e, P.name);
    }
    function He($e) {
      switch ($e.keyCode) {
        case 16: {
          ve = T && _;
          break;
        }
        case 18: {
          P === qo && (T && (ue = ne - ee * T, j = q + ee * T), _ && (W = K - $ * _, le = B + $ * _), P = Zo, Be($e));
          break;
        }
        case 32: {
          (P === qo || P === Zo) && (T < 0 ? ue = ne - ee : T > 0 && (j = q - ee), _ < 0 ? W = K - $ : _ > 0 && (le = B - $), P = af, xe.attr("cursor", ya.selection), Be($e));
          break;
        }
        default:
          return;
      }
      rf($e);
    }
    function Ze($e) {
      switch ($e.keyCode) {
        case 16: {
          ve && (Te = ye = ve = !1, Be($e));
          break;
        }
        case 18: {
          P === Zo && (T < 0 ? ue = ne : T > 0 && (j = q), _ < 0 ? W = K : _ > 0 && (le = B), P = qo, Be($e));
          break;
        }
        case 32: {
          P === af && ($e.altKey ? (T && (ue = ne - ee * T, j = q + ee * T), _ && (W = K - $ * _, le = B + $ * _), P = Zo) : (T < 0 ? ue = ne : T > 0 && (j = q), _ < 0 ? W = K : _ > 0 && (le = B), P = qo), xe.attr("cursor", ya[A]), Be($e));
          break;
        }
        default:
          return;
      }
      rf($e);
    }
  }
  function w(m) {
    y(this, arguments).moved(m);
  }
  function S(m) {
    y(this, arguments).ended(m);
  }
  function L() {
    var m = this.__brush || { selection: null };
    return m.extent = sm(t.apply(this, arguments)), m.dim = e, m;
  }
  return s.extent = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : nf(sm(m)), s) : t;
  }, s.filter = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : nf(!!m), s) : r;
  }, s.touchable = function(m) {
    return arguments.length ? (a = typeof m == "function" ? m : nf(!!m), s) : a;
  }, s.handleSize = function(m) {
    return arguments.length ? (d = +m, s) : d;
  }, s.keyModifiers = function(m) {
    return arguments.length ? (i = !!m, s) : i;
  }, s.on = function() {
    var m = o.on.apply(o, arguments);
    return m === o ? s : m;
  }, s;
}
const rk = ({ xMax: e, yMax: t }) => {
  var B, X;
  const { tableData: r, config: a, setBrushConfig: i, dashboardConfig: o, formatDate: d, parseDate: c } = se.useContext(ft), [s, p] = se.useState({ isBrushing: !1, selection: [] }), [y, g] = se.useState(0), b = ((B = o == null ? void 0 : o.dashboard) == null ? void 0 : B.sharedFilters) ?? [], w = (b == null ? void 0 : b.length) > 0, [S, L] = se.useState(!1), m = se.useRef(), v = 25, A = 15, P = Rg(r, (ue) => new Date(ue[a.runtime.originalXAxis.dataKey])), T = Gy().domain(P).range([0, e]), M = hr("Drag edges to focus on a specific segment ", `normal ${16 / 1.1}px sans-serif`), Z = 50, Y = 1.5, ae = () => (o == null ? void 0 : o.type) === "dashboard" ? Number(t) + a.xAxis.axisBBox + v * Y + Z : Number(t) + a.xAxis.axisBBox + v * Y, j = () => {
    s.selection[0] === 0 && e === s.selection[1] && L(!0);
  }, q = () => {
    (s.selection[0] !== 0 || s.selection[1] !== e) && L(!1), L(!1);
  }, te = (ue, ne, J, W) => {
    const K = hr(J, `normal ${14.545454545454545}px sans-serif`);
    return ue.selectAll(".handle--custom").data([{ side: "left" }, { side: "right" }]).join((ee) => {
      const $ = ee.append("g").attr("class", "handle--custom");
      return $.append("text").attr("x", (pe) => pe.side === "left" ? 0 : -K).attr("y", 30).text((pe) => pe.side === "left" ? J : W).attr("font-size", "13px"), $;
    }).attr("display", "block").attr("transform", ne === null ? null : (ee, $) => `translate(${ne[$]},10)`);
  }, le = () => {
    const ue = Qo(m.current).attr("overflow", "visible");
    ue.append("rect").attr("fill", "#949494").attr("stroke", "#c5c5c5").attr("stroke-width", 2).attr("ry", A).attr("rx", A).attr("height", v).attr("width", e);
    const ne = (ee) => {
      const $ = ee == null ? void 0 : ee.selection;
      let pe = ee.type === "brush" && $ && $.length > 0;
      const [ve, Te] = $.map((Ne) => T.invert(Ne)), ye = et.filter(r, (Ne) => {
        const He = new Date(Ne[a.xAxis.dataKey]);
        return He && !isNaN(He.getTime()) && He >= ve && He <= Te;
      }), Re = a.xAxis.sortByRecentDate, Xe = et.sortBy(ye, (Ne) => new Date(Ne[a.xAxis.dataKey])), Ce = Re ? Xe.reverse() : Xe, xe = et.get(et.first(Ce), a.xAxis.dataKey, ""), Pe = et.get(et.last(Ce), a.xAxis.dataKey, "");
      ue.selectAll(".handle--custom").remove();
      const [de, Be] = [xe, Pe].map((Ne) => d(c(Ne)));
      ue.call(te, $, de, Be), i({
        active: a.brush.active,
        isBrushing: pe,
        data: Ce
      }), p({
        isBrushing: !0,
        selection: $
      });
    }, J = tk().extent([
      [0, 0],
      [e, 25]
    ]).on("start brush end", ne), W = [0, e];
    let K = ue.append("g").call(J).call(J.move, W);
    K.select(".overlay").style("pointer-events", "none"), K.selectAll(".selection").attr("fill", "#474747").attr("fill-opacity", 1).attr("rx", A).attr("ry", A);
  };
  return se.useEffect(() => {
    var J, W, K;
    const ue = (J = a.filters) == null ? void 0 : J.some((ee) => ee.active), ne = (W = a.exclusions) == null ? void 0 : W.active;
    return (ue || ne || w) && ((K = a.brush) != null && K.active) && (g((ee) => ee + 1), i((ee) => ({
      ...ee,
      data: r
    }))), () => i((ee) => ({
      ...ee,
      data: []
    }));
  }, [a.filters, a.exclusions, (X = a.brush) == null ? void 0 : X.active, w]), se.useEffect(() => {
    y && le();
  }, [y]), s.isBrushing || le(), /* @__PURE__ */ n.createElement(
    tt,
    {
      onMouseLeave: q,
      onMouseOver: j,
      className: "brush-container",
      left: Number(a.runtime.yAxis.size),
      top: ae()
    },
    /* @__PURE__ */ n.createElement(
      ct,
      {
        pointerEvents: "visiblePainted",
        display: S ? "block" : "none",
        fontSize: 16,
        x: (Number(e) - Number(M)) / 2,
        y: -10
      },
      "Drag edges to focus on a specific segment"
    ),
    /* @__PURE__ */ n.createElement("svg", { width: "100%", height: v * 3, ref: m })
  );
}, Mi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: h0,
  curveBasisClosed: m0,
  curveBasisOpen: y0,
  curveBundle: g0,
  curveCardinal: v0,
  curveCardinalClosed: x0,
  curveCardinalOpen: b0,
  curveCatmullRom: E0,
  curveCatmullRomClosed: S0,
  curveCatmullRomOpen: k0,
  curveLinear: _c,
  curveLinearClosed: wf,
  curveMonotoneX: Wu,
  curveMonotoneY: w0,
  curveNatural: T0,
  curveStep: C0,
  curveStepAfter: L0,
  curveStepBefore: A0
}, Symbol.toStringTag, { value: "Module" })), ak = (e) => {
  var M, Z;
  const { xScale: t, yScale: r, yMax: a, xMax: i, handleTooltipMouseOver: o, handleTooltipMouseOff: d, isDebug: c, children: s } = e;
  let { transformedData: p, config: y, handleLineType: g, parseDate: b, formatDate: w, formatNumber: S, seriesHighlight: L, colorScale: m, rawData: v, brushConfig: A } = se.useContext(ft);
  const P = (M = y.brush) != null && M.active && ((Z = A.data) != null && Z.length) ? A.data : p;
  if (!P)
    return;
  const T = (Y) => (Rn(y.xAxis) ? t(b(Y[y.xAxis.dataKey], !1)) : t(Y[y.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), _ = (Y, ae, j = void 0) => r(Y[j.dataKey]);
  return P && /* @__PURE__ */ n.createElement("svg", null, /* @__PURE__ */ n.createElement(Vr, { component: "AreaChart" }, /* @__PURE__ */ n.createElement(tt, { className: "area-chart", key: "area-wrapper", left: Number(y.yAxis.size) }, (y.runtime.areaSeriesKeys || y.series).map((Y, ae) => {
    let j = P.map((B) => ({
      [y.xAxis.dataKey]: B[y.xAxis.dataKey],
      [Y.dataKey]: B[Y.dataKey]
    })), q = Mi[Y.lineType], te = y.legend.behavior === "highlight" && L.length > 0 && L.indexOf(Y.dataKey) === -1, le = y.legend.behavior === "highlight" || L.length === 0 || L.indexOf(Y.dataKey) !== -1;
    return /* @__PURE__ */ n.createElement(n.Fragment, { key: ae }, /* @__PURE__ */ n.createElement(
      Hr,
      {
        data: j,
        x: (B) => T(B),
        y: (B) => _(B, ae, Y),
        stroke: le ? m ? m(y.runtime.seriesLabels ? y.runtime.seriesLabels[Y.dataKey] : Y.dataKey) : "#000" : "transparent",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        curve: q,
        strokeDasharray: Y.type ? g(Y.type) : 0
      }
    ), /* @__PURE__ */ n.createElement(
      Rf,
      {
        key: "area-chart",
        fill: le ? m ? m(y.runtime.seriesLabels ? y.runtime.seriesLabels[Y.dataKey] : Y.dataKey) : "#000" : "transparent",
        fillOpacity: te ? 0.25 : 0.5,
        data: j,
        x: (B) => T(B),
        y: (B) => _(B, ae, Y),
        yScale: r,
        curve: q,
        strokeDasharray: Y.type ? g(Y.type) : 0
      }
    ));
  }), /* @__PURE__ */ n.createElement(Rr, { width: Number(i), height: Number(a), fill: "transparent", fillOpacity: 0.05, onMouseMove: (Y) => o(Y, v), onMouseLeave: d }))));
}, ik = se.memo(ak), ok = ({ xScale: e, yScale: t, yMax: r, xMax: a, handleTooltipMouseOver: i, handleTooltipMouseOff: o, isDebug: d }) => {
  var L, m;
  let { transformedData: c, config: s, seriesHighlight: p, colorScale: y, rawData: g } = se.useContext(ft);
  const b = (L = s.brush) != null && L.active && ((m = s.brush.data) != null && m.length) ? s.brush.data : c;
  if (!b)
    return;
  const w = (v) => {
    if (s.xAxis.type === "categorical")
      return e(v);
    if (Rn(s.xAxis)) {
      let A = new Date(v);
      return e(A);
    }
  }, S = 2;
  return b && /* @__PURE__ */ n.createElement("svg", { height: Number(r) }, /* @__PURE__ */ n.createElement(Vr, { component: "AreaChartStacked" }, /* @__PURE__ */ n.createElement(
    tt,
    {
      className: "area-chart",
      key: "area-wrapper",
      left: Number(s.yAxis.size) + S / 2,
      height: Number(r),
      style: { overflow: "hidden" }
    },
    /* @__PURE__ */ n.createElement(
      iE,
      {
        data: b,
        keys: s.runtime.areaSeriesKeys.map((v) => v.dataKey) || s.series.map((v) => v.dataKey),
        x0: (v) => w(v.data[s.xAxis.dataKey]),
        y0: (v) => Number(t(v[0])),
        y1: (v) => Number(t(v[1])),
        curve: Mi[il[s.stackedAreaChartLineType]]
      },
      ({ stacks: v, path: A }) => v.map((P, T) => {
        let _ = s.legend.behavior === "highlight" && p.length > 0 && p.indexOf(P.key) === -1, M = s.legend.behavior === "highlight" || p.length === 0 || p.indexOf(P.key) !== -1;
        return (
          // prettier-ignore
          /* @__PURE__ */ n.createElement(
            "path",
            {
              key: P.key,
              d: A(P) || "",
              strokeWidth: 2,
              stroke: M ? y ? y(s.runtime.seriesLabels ? s.runtime.seriesLabels[P.key] : P.key) : "#000" : "transparent",
              fillOpacity: _ ? 0.2 : 1,
              fill: M ? y ? y(s.runtime.seriesLabels ? s.runtime.seriesLabels[P.key] : P.key) : "#000" : "transparent"
            }
          )
        );
      })
    ),
    /* @__PURE__ */ n.createElement(Rr, { width: Number(a), height: Number(r), fill: "transparent", onMouseMove: (v) => i(v, g), onMouseLeave: o })
  )));
}, lk = se.memo(ok), Ic = () => {
  const { config: e, colorPalettes: t, tableData: r, updateConfig: a, parseDate: i, formatDate: o, setSeriesHighlight: d, seriesHighlight: c } = se.useContext(ft), { orientation: s } = e, [p, y] = se.useState(null), g = s === "horizontal", b = 1, w = e.lollipopSize === "large" ? 7 : e.lollipopSize === "medium" ? 6 : 5, S = e.lollipopSize === "large" ? 14 : e.lollipopSize === "medium" ? 12 : 10, L = e.yAxis.labelPlacement === "Below Bar", m = e.yAxis.displayNumbersOnBar, v = e.orientation === "horizontal" ? "yAxis" : "xAxis", A = e.barStyle === "rounded", P = e.visualizationSubType === "stacked", T = e.tipRounding, _ = e.roundingStyle === "standard" ? "8px" : e.roundingStyle === "shallow" ? "5px" : e.roundingStyle === "finger" ? "15px" : "0px", M = e.runtime.seriesKeys.length, Z = Object.keys(e.runtime.seriesLabels).length > 1, ae = e.visualizationType === "Bar" && e.legend.behavior === "isolate" && e.legend.axisAlign && (c != null && c.length) ? c : e.runtime.barSeriesKeys || e.runtime.seriesKeys;
  return se.useEffect(() => {
    s === "horizontal" && !e.yAxis.labelPlacement && a({
      ...e,
      yAxis: {
        ...e.yAxis,
        labelPlacement: "Below Bar"
      }
    });
  }, [e, a]), se.useEffect(() => {
    e.isLollipopChart === !1 && e.barHeight < 25 && a({ ...e, barHeight: 25 });
  }, [e.isLollipopChart]), se.useEffect(() => {
    e.visualizationSubType === "horizontal" && a({
      ...e,
      orientation: "horizontal"
    });
  }, []), se.useEffect(() => {
    e.barStyle === "lollipop" && !e.isLollipopChart && a({ ...e, isLollipopChart: !0 }), (A || e.barStyle === "flat") && a({ ...e, isLollipopChart: !1 });
  }, [e.barStyle]), {
    isHorizontal: g,
    barBorderWidth: b,
    lollipopBarWidth: w,
    lollipopShapeSize: S,
    isLabelBelowBar: L,
    displayNumbersOnBar: m,
    shouldSuppress: (W) => {
      var K;
      return (K = e.preliminaryData) == null ? void 0 : K.some((ee) => {
        const $ = ee.column ? ee.column === W.key : !0, pe = String(W.value) === String(ee.value) && ee.value !== "";
        return $ && pe && ee.symbol && ee.type === "suppression";
      });
    },
    section: v,
    isRounded: A,
    isStacked: P,
    tipRounding: T,
    radius: _,
    stackCount: M,
    barStackedSeriesKeys: ae,
    hasMultipleSeries: Z,
    applyRadius: (W) => {
      if (W == null || !A)
        return {};
      let K = {};
      return (P && W + 1 === M || !P) && (K = g ? { borderRadius: `0 ${_}  ${_}  0` } : { borderRadius: `${_} ${_} 0 0` }), !P && W === -1 && (K = g ? { borderRadius: `${_} 0  0 ${_} ` } : { borderRadius: ` 0  0 ${_} ${_}` }), T === "full" && P && W === 0 && M > 1 && (K = g ? { borderRadius: `${_} 0 0 ${_}` } : { borderRadius: `0 0 ${_} ${_}` }), T === "full" && (P && W === 0 && M === 1 || !P) && (K = { borderRadius: _ }), K;
    },
    updateBars: (W) => {
      if (e.visualizationType !== "Bar" && !g)
        return W;
      const K = [...W];
      let ee;
      const $ = {
        stacked: e.barHeight,
        lollipop: w
      };
      P ? ee = $.stacked : ee = $[e.isLollipopChart ? "lollipop" : "stacked"] * M;
      const pe = L ? Lc * 1.2 : 0;
      let ve = Number(e.barSpace), Te = K.length * (ee + pe + ve);
      return g && (e.heights.horizontal = Te), K.map((ye, Re) => {
        let Xe = 0;
        return ye.index !== 0 && (Xe = (ee + ve + pe) * Re), { ...ye, y: Xe, height: ee };
      });
    },
    assignColorsToValues: (W, K, ee) => {
      if (!e.legend.colorCode && e.series.length > 1)
        return ee;
      const $ = e.customColors ?? t[e.palette], pe = r.map((Re) => Re[e.legend.colorCode]);
      let ve = /* @__PURE__ */ new Map(), Te = [];
      for (let Re = 0; Re < pe.length; Re++)
        ve.has(pe[Re]) || ve.set(pe[Re], $[ve.size % $.length]), Te.push(ve.get(pe[Re]));
      for (; Te.length < W; )
        Te = Te.concat(Te);
      return Te[K];
    },
    getHighlightedBarColorByValue: (W) => {
      const K = e == null ? void 0 : e.highlightedBarValues.find((ee) => {
        if (ee.value)
          return e.xAxis.type === "date" ? o(i(ee.value)) === W : ee.value === W;
      });
      return K != null && K.color ? K.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (W) => {
      const K = e == null ? void 0 : e.highlightedBarValues.filter((ee) => {
        if (ee.value)
          return e.xAxis.type === "date" ? o(i(ee.value)) === W : ee.value === W;
      })[0];
      return K != null && K.color ? K : !1;
    },
    getAdditionalColumn: (W, K) => {
      if (!K)
        return "";
      const ee = e.columns, $ = [];
      let pe = "";
      const ve = r.find((Te) => Te[e.xAxis.dataKey] === K) || {};
      return Object.keys(ee).forEach((Te) => {
        if (W && e.columns[Te].series && e.columns[Te].series !== W)
          return;
        const ye = {
          addColPrefix: e.columns[Te].prefix,
          addColSuffix: e.columns[Te].suffix,
          addColRoundTo: e.columns[Te].roundToPlace ? e.columns[Te].roundToPlace : "",
          addColCommas: e.columns[Te].commas
        }, Re = Xf(
          ve[e.columns[Te].name],
          "left",
          !0,
          e,
          ye
        );
        e.columns[Te].tooltips && $.push([e.columns[Te].label, Re]);
      }), $.forEach((Te) => {
        pe += `${Te[0]} : ${Te[1]} <br/>`;
      }), pe;
    },
    hoveredBar: p,
    setHoveredBar: y,
    onMouseOverBar: (W, K) => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && K && d([K]), y(W);
    },
    onMouseLeaveBar: () => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && d([]);
    }
  };
}, Ns = se.createContext(null), bp = ({
  xScale: e,
  barWidth: t = 0,
  totalBarsInGroup: r = 1,
  yMax: a,
  handleTooltipMouseOff: i,
  handleTooltipMouseOver: o,
  handleTooltipClick: d,
  tooltipData: c,
  showTooltip: s,
  hideTooltip: p
}) => {
  const { parseDate: y, config: g } = se.useContext(ft), { runtime: b, regions: w, visualizationType: S, orientation: L, xAxis: m } = g, v = e.domain(), A = (_) => {
    let M;
    if (!(_ != null && _.fromType) || _.fromType === "Fixed") {
      const Z = new Date(_.from), Y = y(is(g.xAxis.dateParseFormat, Z)).getTime();
      M = e(Y), S === "Bar" && m.type === "date-time" && (M = M - t * r / 2);
    }
    if (_.fromType === "Previous Days") {
      const Z = Number(_.from) || 0;
      v.map((q) => is(g.xAxis.dateParseFormat, new Date(q)));
      const Y = _.toType === "Last Date" ? new Date(v[v.length - 1]).getTime() : new Date(_.to), ae = g.xAxis.type === "categorical" ? is(g.xAxis.dateParseFormat, Y) : is(g.xAxis.dateParseFormat, Y), j = new Date(ae);
      if (M = new Date(j.setDate(j.getDate() - Number(Z))), m.type === "date") {
        M = new Date(is(m.dateParseFormat, M)).getTime();
        let q = v[0], te = Math.abs(M - q);
        for (let le = 1; le < v.length; le++) {
          const B = Math.abs(M - v[le]);
          B < te && (te = B, q = v[le]);
        }
        M = q;
      }
      if (m.type === "categorical") {
        let q = v[0], te = Math.abs(new Date(M).getTime() - new Date(q).getTime());
        for (let le = 1; le < v.length; le++) {
          const B = Math.abs(new Date(M).getTime() - new Date(v[le]).getTime());
          B < te && (te = B, q = v[le]);
        }
        M = q;
      }
      M = e(M);
    }
    if (m.type === "categorical" && _.fromType !== "Previous Days" && (M = e(_.from)), S === "Line" || S === "Area Chart") {
      let Z = Number(g.yAxis.size);
      e.bandwidth && (Z += e.bandwidth() / 2), M = M + Z;
    }
    return S === "Bar" && g.xAxis.type === "date-time" && _.fromType === "Previous Days" && (M = M - t * r / 2), M;
  }, P = (_) => {
    let M;
    if (m.type === "categorical" && (M = e(_.to)), Rn(m) && ((!(_ != null && _.toType) || _.toType === "Fixed") && (M = e(y(_.to).getTime())), (S === "Bar" || g.visualizationType === "Combo") && (M = _.toType !== "Last Date" ? e(y(_.to).getTime()) + t * r : M)), _.toType === "Last Date") {
      const Z = v[v.length - 1];
      M = Number(
        e(Z) + ((S === "Bar" || S === "Combo") && g.xAxis.type === "date" ? t * r : 0)
      );
    }
    if (S === "Line" || S === "Area Chart") {
      let Z = Number(g.yAxis.size);
      e.bandwidth && (Z += e.bandwidth() / 2), M = M + Z;
    }
    return S === "Bar" && g.xAxis.type === "date-time" && _.toType !== "Last Date" && (M = M - t * r / 2), (S === "Bar" || S === "Combo") && m.type === "categorical" && (M = M + (S === "Bar" || S === "Combo" ? t * r : 0)), M;
  }, T = (_, M) => _ - M;
  if (w && L === "vertical")
    return w.map((_) => {
      const M = A(_), Z = P(_), Y = T(Z, M);
      if (!M || !Z)
        return null;
      const ae = () => /* @__PURE__ */ n.createElement("rect", { x: M, y: 0, width: Y, height: a, fill: _.background, opacity: 0.3 });
      return /* @__PURE__ */ n.createElement(
        tt,
        {
          height: 100,
          fill: "red",
          className: "regions regions-group--line zzz",
          key: _.label,
          onMouseMove: o,
          onMouseLeave: i,
          handleTooltipClick: d,
          tooltipData: JSON.stringify(c),
          showTooltip: s
        },
        /* @__PURE__ */ n.createElement(ae, null),
        /* @__PURE__ */ n.createElement(ct, { x: M + Y / 2, y: 5, fill: _.color, verticalAnchor: "start", textAnchor: "middle" }, _.label)
      );
    });
};
function Ds(e) {
  var $, pe;
  const { config: t, index: r, id: a, className: i, background: o, borderColor: d, borderWidth: c, width: s, height: p, x: y, y: g, onMouseOver: b, onMouseLeave: w, onClick: S, tooltipHtml: L, tooltipId: m, styleOverrides: v, seriesHighlight: A, type: P } = e, T = Math.max(0, s), _ = Math.max(0, p), M = t.orientation === "horizontal", Z = t.barStyle === "rounded", Y = t.visualizationSubType === "stacked", ae = t.tipRounding, j = t.visualizationType === "Combo" && ((pe = ($ = t.runtime) == null ? void 0 : $.barSeriesKeys) == null ? void 0 : pe.length), q = t.runtime.seriesKeys.length, te = t.visualizationType === "Bar" && t.legend.axisAlign && (A != null && A.length) ? A == null ? void 0 : A.length : 0, le = j || te || q;
  let B = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  (B > T / 2 || B > _ / 2) && (B = Math.min(T / 2, _ / 2));
  const X = () => `M${y},${g + _}
      L${y},${g + B}
      Q${y},${g} ${y + B},${g}
      L${y + T - B},${g}
      Q${y + T},${g} ${y + T},${g + B}
      L${y + T},${g + _}
      L${y},${g + _}`, ue = () => `M${y},${g + _}
      L${y},${g}
      L${y + T - B},${g}
      Q${y + T},${g} ${y + T},${g + B}
      L${y + T},${g + _ - B}
      Q${y + T},${g + _} ${y + T - B},${g + _}
      L${y},${g + _}`, ne = () => `M${y + B},${g + _}
      Q${y},${g + _} ${y},${g + _ - B}
      L${y},${g}
      L${y + T},${g}
      L${y + T},${g + _ - B}
      Q${y + T},${g + _} ${y + T - B},${g + _}
      L${y + B},${g + _}`, J = () => `M${y + B},${g + _}
      Q${y},${g + _} ${y},${g + _ - B}
      L${y},${g + B}
      Q${y},${g} ${y + B},${g}
      L${y + T},${g}
      L${y + T},${g + _}
      L${y + B},${g + _}`, W = () => `M${y + B},${g + _}
      Q${y},${g + _} ${y},${g + _ - B}
      L${y},${g + B}
      Q${y},${g} ${y + B},${g}
      L${y + T - B},${g}
      Q${y + T},${g} ${y + T},${g + B}
      L${y + T},${g + _ - B}
      Q${y + T},${g + _} ${y + T - B},${g + _}
      L${y + B},${g + _}`, K = () => `M${y},${g}
      L${y + T},${g}
      L${y + T},${g + _}
      L${y},${g + _}
      L${y},${g}`;
  let ee;
  return r == null || !Z || P == "axisBar" ? ee = K() : (ee = K(), (Y && r + 1 === le || !Y) && (ee = M ? ue() : X()), !Y && r === -1 && (ee = M ? J() : ne()), ae === "full" && Y && r === 0 && le > 1 && (ee = M ? J() : ne()), ae === "full" && (Y && r === 0 && le === 1 || !Y) && (ee = W())), /* @__PURE__ */ n.createElement(
    "path",
    {
      id: a,
      className: i,
      d: ee,
      fill: o,
      stroke: d,
      strokeWidth: c,
      onMouseOver: b,
      onMouseLeave: w,
      onClick: S,
      "data-tooltip-html": L,
      "data-tooltip-id": m,
      style: {
        transition: "all 0.2s linear",
        ...v
      }
    }
  );
}
const sk = () => {
  var q, te;
  const [e, t] = se.useState(0), { xScale: r, yScale: a, seriesScale: i, xMax: o, yMax: d } = se.useContext(Ns), { transformedData: c, colorScale: s, seriesHighlight: p, config: y, formatNumber: g, formatDate: b, parseDate: w, setSharedFilter: S } = se.useContext(ft), {
    isHorizontal: L,
    barBorderWidth: m,
    applyRadius: v,
    hoveredBar: A,
    getAdditionalColumn: P,
    onMouseLeaveBar: T,
    onMouseOverBar: _,
    barStackedSeriesKeys: M
  } = Ic(), { orientation: Z } = y, Y = (q = y.brush) != null && q.active && ((te = y.brush.data) != null && te.length) ? y.brush.data : c, ae = y.runtime.xAxis.type === "date-time" || y.runtime.xAxis.type === "date", j = y.runtime.xAxis.type === "date-time";
  return y.visualizationSubType === "stacked" && !L && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    My,
    {
      data: Y,
      keys: M,
      x: (le) => le[y.runtime.xAxis.dataKey],
      xScale: r,
      yScale: a,
      color: s
    },
    (le) => le.reverse().map(
      (B) => B.bars.map((X) => {
        let ue = y.legend.behavior === "highlight" && p.length > 0 && p.indexOf(X.key) === -1, ne = y.legend.behavior === "highlight" || p.length === 0 || p.indexOf(X.key) !== -1, J = ae ? i.range()[1] - i.range()[0] : o / B.bars.length;
        y.runtime.xAxis.type !== "date" && (J = y.barThickness * J);
        const W = X.bar.data[y.runtime.xAxis.dataKey], K = ae ? b(w(W)) : W, ee = g(X.bar ? X.bar.data[X.key] : 0, "left");
        if (!ee)
          return;
        const $ = r(ae ? w(W) : W) - (j ? J / 2 : 0), pe = y.runtime.xAxis.label ? `${y.runtime.xAxis.label}: ${K}` : K, ve = P(A), Te = `${y.runtime.seriesLabels[X.key]}: ${ee}`, ye = `<ul>
                  <li class="tooltip-heading"">${pe}</li>
                  <li class="tooltip-body ">${Te}</li>
                  <li class="tooltip-body ">${ve}</li>
                    </li></ul>`;
        return t(J), /* @__PURE__ */ n.createElement(tt, { key: `${B.index}--${X.index}--${Z}` }, /* @__PURE__ */ n.createElement(
          tt,
          {
            key: `bar-stack-${B.index}-${X.index}`,
            id: `barStack${B.index}-${X.index}`,
            className: "stack vertical"
          },
          Ds({
            config: y,
            seriesHighlight: p,
            index: B.index,
            background: s(y.runtime.seriesLabels[X.key]),
            borderColor: "#333",
            borderStyle: "solid",
            borderWidth: `${y.barHasBorder === "true" ? m : 0}px`,
            width: J,
            height: X.height,
            x: $,
            y: X.y,
            onMouseOver: () => _(K, X.key),
            onMouseLeave: T,
            tooltipHtml: ye,
            tooltipId: `cdc-open-viz-tooltip-${y.runtime.uniqueId}`,
            onClick: (Re) => {
              Re.preventDefault(), S && (X[y.xAxis.dataKey] = K, S(y.uid, X));
            },
            styleOverrides: {
              animationDelay: `${B.index * 0.5}s`,
              transformOrigin: `${J / 2}px ${X.y + X.height}px`,
              opacity: ue ? 0.2 : 1,
              display: ne ? "block" : "none"
            }
          })
        ));
      })
    )
  ), /* @__PURE__ */ n.createElement(bp, { xScale: r, yMax: d, barWidth: e, totalBarsInGroup: 1 }));
}, uk = () => {
  const { yMax: e, yScale: t, xScale: r } = se.useContext(Ns), {
    animatedChart: a,
    colorScale: i,
    config: o,
    formatDate: d,
    formatNumber: c,
    parseDate: s,
    seriesHighlight: p,
    setSharedFilter: y,
    transformedData: g
  } = se.useContext(ft), { barBorderWidth: b, displayNumbersOnBar: w, getAdditionalColumn: S, hoveredBar: L, isHorizontal: m, isLabelBelowBar: v, onMouseLeaveBar: A, onMouseOverBar: P, updateBars: T, barStackedSeriesKeys: _ } = Ic(), { orientation: M, visualizationSubType: Z } = o;
  return o.visualizationSubType === "stacked" && m && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    fE,
    {
      data: g,
      keys: _,
      height: e,
      y: (Y) => Y[o.runtime.yAxis.dataKey],
      xScale: r,
      yScale: t,
      color: i,
      offset: "none"
    },
    (Y) => Y.map(
      (ae) => T(ae.bars).map((j, q) => {
        const te = o.legend.behavior === "highlight" && p.length > 0 && p.indexOf(j.key) === -1, le = o.legend.behavior === "highlight" || p.length === 0 || p.indexOf(j.key) !== -1;
        o.barHeight = Number(o.barHeight);
        let B = i(o.runtime.seriesLabels[j.key]), X = al("#000", B);
        Sm("#000", B) < 7 && (X = "#fff");
        const J = c(g[j.index][j.key], "left"), W = o.runtime.yAxis.type === "date" ? d(s(g[j.index][o.runtime.originalXAxis.dataKey])) : g[j.index][o.runtime.originalXAxis.dataKey], K = o.runtime.yAxis.label ? `${o.runtime.yAxis.label}: ${W}` : W, ee = hr(J), $ = S(L), pe = `${o.runtime.seriesLabels[j.key]}: ${J}`, ve = `<ul>
                  <li class="tooltip-heading"">${K}</li>
                  <li class="tooltip-body ">${pe}</li>
                  <li class="tooltip-body ">${$}</li>
                    </li></ul>`;
        return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(tt, { key: q, id: `barStack${ae.index}-${j.index}`, className: "stack horizontal" }, Ds({
          config: o,
          seriesHighlight: p,
          index: ae.index,
          className: `animated-chart group ${a ? "animated" : ""}`,
          background: i(o.runtime.seriesLabels[j.key]),
          borderColor: "#333",
          borderStyle: "solid",
          borderWidth: `${o.barHasBorder === "true" ? b : 0}px`,
          width: j.width,
          height: j.height,
          x: j.x,
          y: j.y,
          onMouseOver: () => P(W, j.key),
          onMouseLeave: A,
          tooltipHtml: ve,
          tooltipId: `cdc-open-viz-tooltip-${o.runtime.uniqueId}`,
          onClick: (Te) => {
            Te.preventDefault(), y && (j[o.xAxis.dataKey] = J, y(o.uid, j));
          },
          styleOverrides: {
            animationDelay: `${ae.index * 0.5}s`,
            transformOrigin: `${j.x}px 0`,
            opacity: te ? 0.2 : 1,
            display: le ? "block" : "none"
          }
        }), M === "horizontal" && Z === "stacked" && v && ae.index === 0 && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          ct,
          {
            x: `${j.x + (o.isLollipopChart ? 15 : 5)}`,
            y: j.y + j.height * 1.2,
            fill: "#000000",
            textAnchor: "start",
            verticalAnchor: "start"
          },
          W
        ), w && ee < j.width && /* @__PURE__ */ n.createElement(
          ct,
          {
            display: le ? "block" : "none",
            x: j.x + ae.bars[j.index].width / 2,
            y: j.y + j.height / 2,
            fill: X,
            textAnchor: "middle",
            verticalAnchor: "middle"
          },
          J
        )));
      })
    )
  ));
}, $c = (e, t) => {
  var L;
  const { formatDate: r, parseDate: a } = se.useContext(ft);
  let i = [], o = "", d = [], c = [];
  ((L = e.series) == null ? void 0 : L.length) > 0 && e.data ? (i = e.series[0], o = e.series[0].dataKey, d = e.highlightedBarValues, c = e.data.map((m) => m[e.xAxis.dataKey])) : (i = [], o = "", d = [], c = []);
  const s = (m, v) => {
    const A = [...e.highlightedBarValues];
    A[v].borderWidth = m.target.value, t({
      ...e,
      highlightedBarValues: A
    });
  }, p = (m, v) => {
    m.preventDefault();
    const A = [...e.highlightedBarValues];
    A[v].value = m.target.value, A[v].dataKey = o, t({
      ...e,
      highlightedBarValues: A
    });
  }, y = (m, v) => {
    m.preventDefault();
    const A = [...e.highlightedBarValues];
    A.push({ dataKey: o }), t({
      ...e,
      highlightedBarValues: A
    });
  }, g = (m, v) => {
    m.preventDefault();
    const A = [...e.highlightedBarValues];
    A.splice(v, 1), t({
      ...e,
      highlightedBarValues: A
    });
  }, b = (m, v) => {
    const A = [...e.highlightedBarValues];
    A[v].color = m.target.value, t({
      ...e
    });
  }, w = (m, v) => {
    const A = [...e.highlightedBarValues];
    A[v].legendLabel = m.target.value, t({
      ...e,
      copyOfHighlightedBarValues: A
    });
  }, S = () => {
  };
  return S.checkFontColor = (m, v, A) => {
    if (e.xAxis.type === "date") {
      if (S.formatDates(v).includes(m))
        return "#000";
    } else if (v.includes(m))
      return "#000";
    return A;
  }, S.formatDates = (m) => m.map((v) => v ? r(a(v)) : !1), S.findDuplicates = (m) => {
    const v = {};
    return m == null ? void 0 : m.filter((P) => {
      const { legendLabel: T } = P;
      return v[T] ? !1 : (v[T] = !0, !0);
    });
  }, {
    HighLightedBarUtils: S,
    highlightedSeries: i,
    highlightedSeriesKey: o,
    highlightedBarValues: d,
    highlightedSeriesValues: c,
    handleUpdateHighlightedBar: p,
    handleAddNewHighlightedBar: y,
    handleRemoveHighlightedBar: g,
    handleUpdateHighlightedBarColor: b,
    handleHighlightedBarLegendLabel: w,
    handleUpdateHighlightedBorderWidth: s
  };
};
function Vi(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
const ug = ({
  bar: e,
  defaultBarHeight: t,
  defaultBarWidth: r,
  config: a,
  barWidth: i,
  isVertical: o
}) => {
  let c = t, s = r, p = "", y = !1, g = !1, b = !1;
  const w = a.general.showSuppressedSymbol;
  if (a.preliminaryData.forEach((m) => {
    (!m.column || m.column === e.key) && m.type === "suppression" && m.value && String(m.value) === String(e.value) && (!m.hideBarSymbol && w ? (c = i > 10 ? 3 : 0, s = 3, y = !0) : (c = 0, s = 0, y = !0));
  }), !y && !Vi(e.value) && a.general.showMissingDataLabel) {
    const m = hr(p, `normal ${i / 2}px sans-serif`), v = Number(m) < i && i > 10;
    g = !0, c = v ? 3 : 0, s = 3;
  }
  if (!y && e.value === "0" && a.general.showZeroValueData) {
    const m = hr("0", `normal ${i / 2}px sans-serif`), v = Number(m) < i && i > 10;
    b = !0, c = v ? 3 : 0, s = 3;
  }
  return { barWidthHorizontal: s, barHeight: c, isSuppressed: y, showMissingDataLabel: g, getBarY: (m, v) => y || g || b ? a.isLollipopChart ? v - 3 * 2 : v - 3 : m, getAbsentDataLabel: (m) => {
    let v = "";
    String(m) === "0" && (v = ""), y && (v = ""), g && (v = "N/A"), b && (v = "0");
    const A = hr(p, `normal ${i / 2}px sans-serif`), P = Number(A) < i && i > 10;
    return a.isLollipopChart || P && o ? v : o ? "" : v;
  } };
}, xs = (e) => e == null ? void 0 : /^0(\.0)?$/.test(e.toString()), Hc = (e, t, r) => !!(e === "Line" && (t == null ? void 0 : t.length) < 3 && r), cg = (e, t, r) => {
  const a = e.series.find((s) => s.dynamicCategory);
  if (!a)
    return t;
  const { dynamicCategory: i, dataKey: o } = a, d = e.runtime.originalXAxis.dataKey, c = et.groupBy(t, d);
  return Object.values(c).map((s) => s.reduce((p, y) => {
    const g = y[o], b = y[i];
    if (r) {
      const { lower: w, upper: S } = e.confidenceKeys;
      p.CI || (p.CI = {});
      const L = y[w], m = y[S];
      p.CI[b] = { lower: L, upper: m };
    }
    return p[b] = g, p[d] = y[d], p.dynamicData = !0, p;
  }, {}));
}, ck = () => {
  const { xScale: e, yScale: t, xMax: r, yMax: a, seriesScale: i } = se.useContext(Ns), [o, d] = se.useState(0), [c, s] = se.useState(0), {
    // prettier-ignore
    assignColorsToValues: p,
    barBorderWidth: y,
    getAdditionalColumn: g,
    getHighlightedBarByValue: b,
    getHighlightedBarColorByValue: w,
    lollipopBarWidth: S,
    lollipopShapeSize: L,
    onMouseLeaveBar: m,
    onMouseOverBar: v,
    section: A
  } = Ic(), { colorScale: P, config: T, dashboardConfig: _, tableData: M, formatDate: Z, formatNumber: Y, parseDate: ae, seriesHighlight: j, setSharedFilter: q, transformedData: te, brushConfig: le } = se.useContext(ft), { HighLightedBarUtils: B } = $c(T), X = document.documentElement, ue = getComputedStyle(X).getPropertyValue("--cool-gray-90");
  let ne = te;
  T.preliminaryData.some((ee) => ee.value && ee.type === "suppression") && (ne = M), le.data.length && (ne = le.data);
  const W = Object.keys(T.confidenceKeys).length > 0, K = cg(T, ne, W);
  return T.visualizationSubType !== "stacked" && (T.visualizationType === "Bar" || T.visualizationType === "Combo" || Hc(T.visualizationType, ne, T.allowLineToBarGraph)) && T.orientation === "vertical" && /* @__PURE__ */ n.createElement(tt, null, /* @__PURE__ */ n.createElement(
    _y,
    {
      data: K,
      keys: T.runtime.barSeriesKeys || T.runtime.seriesKeys,
      height: a,
      x0: (ee) => {
        const $ = ee[T.runtime.originalXAxis.dataKey];
        return Rn(T.runtime.xAxis) ? ae($) : $;
      },
      x0Scale: e,
      x1Scale: i,
      yScale: t,
      color: () => ""
    },
    (ee) => ee.map(($, pe) => /* @__PURE__ */ n.createElement(
      tt,
      {
        className: `bar-group-${$.index}-${$.x0}--${pe} ${T.orientation}`,
        key: `bar-group-${$.index}-${$.x0}--${pe}`,
        id: `bar-group-${$.index}-${$.x0}--${pe}`,
        left: $.x0
      },
      $.bars.map((ve, Te) => {
        var gn, fn;
        const ye = K[$.index], Re = ye[T.runtime.originalXAxis.dataKey], Xe = T.yAxis.type === "logarithmic" ? 0.1 : 0;
        let Ce = T.highlightedBarValues.map((vt) => vt.value).filter((vt) => vt !== void 0);
        Ce = T.xAxis.type === "date" ? B.formatDates(Ce) : Ce;
        const xe = T.legend.behavior === "highlight" && j.length > 0 && j.indexOf(ve.key) === -1, Pe = T.legend.behavior === "highlight" || j.length === 0 || j.indexOf(ve.key) !== -1;
        let de = i.range()[1] - i.range()[0];
        const Be = Math.abs(t(ve.value) - t(Xe)), Ne = ve.value >= 0 && Vi(ve.value) ? ve.y : t(0);
        let He = T.isLollipopChart ? S : i.bandwidth(), Ze = ve.x + (T.isLollipopChart ? (de / $.bars.length - S) / 2 : 0) - (T.xAxis.type === "date-time" ? de / 2 : 0);
        d(He), s($.bars.length);
        const $e = Y(/[a-zA-Z]/.test(String(ve.value)) ? "" : ve.value, "left"), Ye = T.runtime[A].type === "date" ? Z(ae(Re)) : Re, qe = ve.value < 0 ? -1 : Te, Ve = g(ve.key, Re);
        let Ge = T.runtime.xAxis.label ? `${T.runtime.xAxis.label}: ${Ye}` : Ye;
        const ke = `${T.runtime.seriesLabels[ve.key]}: ${$e}`, De = `<ul>
                  <li class="tooltip-heading">${Ge}</li>
                  <li class="tooltip-body ">${ke}</li>
                  ${Ve ? '<li class="tooltip-body ">' + Ve + "</li>" : ""}
                    </li></ul>`;
        let at = "#000000";
        at = B.checkFontColor($e, Ce, at);
        const be = T.isLollipopChart && T.lollipopColorStyle === "regular", nt = T.isLollipopChart && T.lollipopColorStyle === "two-tone", st = Ce == null ? void 0 : Ce.includes(Ye), lt = w(Ye), St = b(Ye), Ut = st ? lt : T.barHasBorder === "true" ? "#000" : "transparent", It = st ? St.borderWidth : T.isLollipopChart ? 0 : T.barHasBorder === "true" ? y : 0, { barHeight: _t, isSuppressed: Rt, getBarY: Lt, getAbsentDataLabel: $t } = ug({
          bar: ve,
          defaultBarHeight: Be,
          config: T,
          barWidth: He,
          isVertical: !0
        }), Dt = $t($e), Gt = Rt || !T.labels ? "" : $e, An = Lt(Ne, t(Xe)), Ot = xs(ve.value) ? "none" : "block", Xt = (vt, Ft) => {
          var Sn;
          let mt = vt, pn = Ft || "#f2f2f2";
          if (_ && ((Sn = _.dashboard.sharedFilters) == null ? void 0 : Sn.length) !== 0) {
            const { sharedFilters: kt } = _.dashboard;
            return mt = kt ? kt.map((wt) => wt.setBy === T.uid ? wt.resetLabel === wt.active || wt.active === te[$.index][T.xAxis.dataKey] ? P(T.runtime.seriesLabels[ve.key]) : pn : P(T.runtime.seriesLabels[ve.key]))[0] : P(T.runtime.seriesLabels[ve.key]), be && (mt = vt), st && (mt = "transparent"), T.legend.colorCode && (mt = p(ee.length, $.index, vt)), nt && (mt = Ua(vt).brighten(1)), mt;
          }
          return nt && (mt = Ua(vt).brighten(1)), T.legend.colorCode && (mt = p(ee.length, $.index, vt)), st && (mt = "transparent"), mt;
        }, ht = 5, Je = Ze + (T.xAxis.type !== "date-time" ? He / 2 : 0), Zt = t(
          ye.dynamicData && ((gn = ye == null ? void 0 : ye.CI) != null && gn[ve.key]) ? ye.CI[ve.key].upper : ye[T.confidenceKeys.upper]
        ), dn = t(
          ye.dynamicData && ((fn = ye == null ? void 0 : ye.CI) != null && fn[ve.key]) ? ye.CI[ve.key].lower : ye[T.confidenceKeys.lower]
        );
        return /* @__PURE__ */ n.createElement(tt, { key: `${$.index}--${Te}` }, /* @__PURE__ */ n.createElement(tt, { key: `bar-sub-group-${$.index}-${$.x0}-${An}--${Te}` }, Ds({
          config: T,
          index: qe,
          id: `barGroup${$.index}`,
          background: Xt(P(T.runtime.seriesLabels[ve.key])),
          borderColor: Ut,
          borderStyle: "solid",
          borderWidth: `${It}px`,
          width: He,
          height: _t,
          x: Ze,
          y: An,
          onMouseOver: () => v(Ye, ve.key),
          onMouseLeave: m,
          tooltipHtml: De,
          tooltipId: `cdc-open-viz-tooltip-${T.runtime.uniqueId}`,
          onClick: (vt) => {
            vt.preventDefault(), q && (ve[T.xAxis.dataKey] = Ye, q(T.uid, ve));
          },
          styleOverrides: {
            transformOrigin: `0 ${An + _t}px`,
            opacity: xe ? 0.2 : 1,
            display: Pe ? "block" : "none",
            cursor: _ ? "pointer" : "default"
          }
        }), T.preliminaryData.map((vt, Ft) => {
          const mt = !vt.column || vt.column === ve.key;
          if (!(String(vt.value) === String(ve.value) && vt.value !== "" && mt) || He < 10 || !T.general.showSuppressedSymbol || vt.hideBarSymbol)
            return;
          const kt = String(vt.symbol).includes("Asterisk"), wt = kt ? -5 : -8, kn = kt ? "middle" : "end", xt = vt.symbol === "Asterisk" ? He * 1.2 : vt.symbol === "Double Asterisk" ? He : He / 1.5, Pt = vt.displayGray ? "#8b8b8a" : "#000";
          return /* @__PURE__ */ n.createElement(
            ct,
            {
              key: Ft,
              dy: wt,
              display: Pe ? "block" : "none",
              opacity: xe ? 0.5 : 1,
              x: Ze + He / 2,
              y: An,
              verticalAnchor: kn,
              fill: Pt,
              textAnchor: "middle",
              fontSize: `${xt}px`
            },
            vt.iconCode
          );
        }), /* @__PURE__ */ n.createElement(
          ct,
          {
            display: Pe ? "block" : "none",
            opacity: xe ? 0.5 : 1,
            x: Ze + He / 2,
            y: An - 5,
            fill: at,
            textAnchor: "middle"
          },
          xs(ve.value) ? "" : Gt
        ), /* @__PURE__ */ n.createElement(
          ct,
          {
            display: Pe ? "block" : "none",
            opacity: xe ? 0.5 : 1,
            x: Ze + He / 2,
            y: An - 5,
            fill: at,
            textAnchor: "middle",
            fontSize: T.isLollipopChart ? null : He / 2
          },
          Dt
        ), T.isLollipopChart && T.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: Ot,
            cx: Ze + L / 3.5,
            cy: ve.y,
            r: L / 2,
            fill: Xt(P(T.runtime.seriesLabels[ve.key])),
            key: `circle--${ve.index}`,
            "data-tooltip-html": De,
            "data-tooltip-id": `cdc-open-viz-tooltip-${T.runtime.uniqueId}`,
            style: { filter: "unset", opacity: 1 }
          }
        ), T.isLollipopChart && T.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
          "rect",
          {
            display: Ot,
            x: Ze - S / 2,
            y: ve.y,
            width: L,
            height: L,
            fill: Xt(P(T.runtime.seriesLabels[ve.key])),
            key: `circle--${ve.index}`,
            "data-tooltip-html": De,
            "data-tooltip-id": `cdc-open-viz-tooltip-${T.runtime.uniqueId}`,
            style: { opacity: 1, filter: "unset" }
          },
          /* @__PURE__ */ n.createElement("animate", { attributeName: "height", values: `0, ${L}`, dur: "2.5s" })
        ), W && ve.value !== void 0 && ye && /* @__PURE__ */ n.createElement(
          "path",
          {
            key: `confidence-interval-v-${ye[T.runtime.originalXAxis.dataKey]}`,
            stroke: ue,
            strokeWidth: "px",
            d: `M${Je - ht} ${Zt}
                                L${Je + ht} ${Zt}
                                M${Je} ${Zt}
                                L${Je} ${dn}
                                M${Je - ht} ${dn}
                                L${Je + ht} ${dn}`
          }
        )));
      })
    ))
  ), /* @__PURE__ */ n.createElement(bp, { xScale: e, yMax: a, barWidth: o, totalBarsInGroup: c }));
}, dk = () => {
  var J;
  const { xScale: e, yScale: t, yMax: r, seriesScale: a } = se.useContext(Ns), {
    transformedData: i,
    tableData: o,
    colorScale: d,
    seriesHighlight: c,
    config: s,
    formatNumber: p,
    formatDate: y,
    parseDate: g,
    setSharedFilter: b,
    isNumber: w
  } = se.useContext(ft), {
    isHorizontal: S,
    barBorderWidth: L,
    updateBars: m,
    assignColorsToValues: v,
    section: A,
    isLabelBelowBar: P,
    displayNumbersOnBar: T,
    lollipopBarWidth: _,
    lollipopShapeSize: M,
    getHighlightedBarColorByValue: Z,
    getHighlightedBarByValue: Y,
    getAdditionalColumn: ae,
    hoveredBar: j,
    onMouseLeaveBar: q,
    onMouseOverBar: te
  } = Ic(), { HighLightedBarUtils: le } = $c(s), B = Object.keys(s.confidenceKeys).length > 0, X = cg(s, i, B), ue = document.documentElement, ne = getComputedStyle(ue).getPropertyValue("--cool-gray-90");
  return s.visualizationSubType !== "stacked" && s.visualizationType === "Bar" && s.orientation === "horizontal" && /* @__PURE__ */ n.createElement(tt, null, /* @__PURE__ */ n.createElement(
    _y,
    {
      data: (J = s.preliminaryData) != null && J.some((W) => W.value && W.type === "suppression") ? o : X,
      keys: s.runtime.barSeriesKeys || s.runtime.seriesKeys,
      height: r,
      x0: (W) => W[s.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: a,
      yScale: e,
      color: () => ""
    },
    (W) => m(W).map((K, ee) => /* @__PURE__ */ n.createElement(
      tt,
      {
        className: `bar-group-${K.index}-${K.x0}--${ee} ${s.orientation}`,
        key: `bar-group-${K.index}-${K.x0}--${ee}`,
        id: `bar-group-${K.index}-${K.x0}--${ee}`,
        top: K.y
      },
      K.bars.map(($, pe) => {
        var Sn;
        const ve = X[K.index], Te = ve[s.runtime.originalXAxis.dataKey], ye = s.yAxis.type === "logarithmic" ? 0.1 : 0;
        let Re = s.highlightedBarValues.map((kt) => kt.value).filter((kt) => kt !== void 0);
        Re = s.xAxis.type === "date" ? le.formatDates(Re) : Re;
        let Xe = s.legend.behavior === "highlight" && c.length > 0 && c.indexOf($.key) === -1, Ce = s.legend.behavior === "highlight" || c.length === 0 || c.indexOf($.key) !== -1, xe = s.barHeight, Pe = parseInt(s.isLollipopChart ? _ : xe);
        isNaN(Pe) && (Pe = 25);
        let de = $.value >= 0 && w($.value) ? $.y : t(ye);
        const Be = Math.abs(e($.value) - e(ye)), Ne = $.value >= 0 && w($.value), {
          barWidthHorizontal: He,
          isSuppressed: Ze,
          getAbsentDataLabel: $e
        } = ug({ bar: $, defaultBarWidth: Be, config: s, isNumber: w, isVertical: !1 }), Ye = $.value < 0 ? Math.abs(e($.value)) : e(ye), qe = p($.value, "left"), Ve = s.runtime[A].type === "date" ? y(g(Te)) : Te, Ge = Ne ? "above" : "below", ke = $e(qe), De = s.yAxis.displayNumbersOnBar ? qe : "", at = hr(De), be = Number(at) < Be - 5;
        let nt = be ? "end" : "start", st = "start", lt = be ? -5 : 5, St = 10;
        Ge === "below" && (nt = be ? "start" : "end", lt = be ? 5 : -5, s.isLollipopChart && (st = "end", St = -10));
        const Ut = $.value < 0 ? -1 : pe;
        let It = s.runtime.yAxis.label ? `${s.runtime.yAxis.label}: ${Ve}` : Ve;
        const _t = ae(j), Rt = `${s.runtime.seriesLabels[$.key]}: ${qe}`, Lt = `<ul>
                  <li class="tooltip-heading"">${It}</li>
                  <li class="tooltip-body ">${Rt}</li>
                  <li class="tooltip-body ">${_t}</li>
                    </li></ul>`;
        let $t = "#000000";
        $t = le.checkFontColor(qe, Re, $t);
        let Dt = s.runtime.seriesLabels && s.runtime.seriesLabels[$.key] ? d(s.runtime.seriesLabels[$.key]) : d($.key);
        s.series.find((kt) => kt.dynamicCategory) || (Dt = v(W.length, K.index, Dt));
        const An = s.isLollipopChart && s.lollipopColorStyle === "regular", Ot = s.isLollipopChart && s.lollipopColorStyle === "two-tone", Xt = Re == null ? void 0 : Re.includes(Ve), ht = Z(Ve), Je = Y(Ve), Zt = Xt ? ht : s.barHasBorder === "true" ? "#000" : "transparent", dn = Xt ? Je.borderWidth : s.isLollipopChart ? 0 : s.barHasBorder === "true" ? L : 0, gn = xs($.value) ? "none" : "block";
        Dt && $t && be && ($t = al("#000", Dt), Sm("#000", Dt) < 7 && ($t = "#fff"));
        const fn = () => An ? Dt : Ot ? Ua(Dt).brighten(1) : Xt ? "transparent" : Dt, vt = 5, Ft = xe * $.index + xe / 2, [mt, pn] = ["upper", "lower"].map((kt) => {
          if (!B)
            return;
          if (ve.dynamicData) {
            const kn = ve.CI[$.key];
            if (!kn)
              return;
            const xt = kn[kt];
            return e(xt);
          }
          const wt = ve[s.confidenceKeys[kt]];
          return e(wt);
        });
        return /* @__PURE__ */ n.createElement(tt, { key: `${K.index}--${pe}` }, /* @__PURE__ */ n.createElement(tt, { key: `bar-sub-group-${K.index}-${K.x0}-${de}--${pe}` }, Ds({
          config: s,
          index: Ut,
          id: `barGroup${K.index}`,
          background: fn(),
          borderColor: Zt,
          borderStyle: "solid",
          borderWidth: `${dn}px`,
          width: He,
          height: Pe,
          x: Ye,
          y: xe * $.index,
          onMouseOver: () => te(Ve, $.key),
          onMouseLeave: q,
          tooltipHtml: Lt,
          tooltipId: `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
          onClick: (kt) => {
            kt.preventDefault(), b && ($[s.xAxis.dataKey] = qe, b(s.uid, $));
          },
          styleOverrides: {
            transformOrigin: `0 ${de + xe}px`,
            opacity: Xe ? 0.2 : 1,
            display: Ce ? "block" : "none"
          }
        }), (Sn = s.preliminaryData) == null ? void 0 : Sn.map((kt, wt) => {
          const kn = !kt.column || kt.column === $.key;
          if (!(String(kt.value) === String($.value) && kt.value !== "" && kn) || kt.hideBarSymbol || !s.general.showSuppressedSymbol)
            return;
          const On = String(kt.symbol).includes("Asterisk") ? "middle" : "end", _e = kt.symbol === "Asterisk" ? xe * 1.2 : kt.symbol === "Double Asterisk" ? xe : xe / 1.5, Oe = kt.displayGray ? "#8b8b8a" : "#000";
          return /* @__PURE__ */ n.createElement(
            ct,
            {
              key: wt,
              fontSize: _e,
              display: Ce ? "block" : "none",
              opacity: Xe ? 0.5 : 1,
              x: Ye,
              y: s.barHeight / 2 + s.barHeight * $.index,
              fill: Oe,
              dy: s.barHeight / 5,
              dx: 10,
              textAnchor: "start",
              verticalAnchor: On
            },
            kt.iconCode
          );
        }), !s.isLollipopChart && /* @__PURE__ */ n.createElement(
          ct,
          {
            display: Ce ? "block" : "none",
            x: $.y,
            opacity: Xe ? 0.5 : 1,
            y: s.barHeight / 2 + s.barHeight * $.index,
            fill: $t,
            dx: lt,
            verticalAnchor: "middle",
            textAnchor: nt
          },
          xs($.value) ? "" : De
        ), /* @__PURE__ */ n.createElement(
          ct,
          {
            display: Ce ? "block" : "none",
            x: $.y,
            opacity: Xe ? 0.5 : 1,
            y: s.barHeight / 2 + s.barHeight * $.index,
            fill: $t,
            dx: ke === "N/A" ? 20 : lt,
            dy: s.isLollipopChart ? -10 : 0,
            verticalAnchor: "middle",
            textAnchor: ke === "N/A" ? "middle" : nt
          },
          ke
        ), s.isLollipopChart && /* @__PURE__ */ n.createElement(
          ct,
          {
            display: Ce ? "block" : "none",
            x: $.y,
            y: 0,
            fill: "#000000",
            dx: St,
            textAnchor: st,
            verticalAnchor: "middle",
            fontWeight: "normal"
          },
          xs($.value) ? "" : De
        ), P && !s.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          ct,
          {
            x: s.yAxis.hideAxis ? 0 : 5,
            y: K.height,
            dy: 4,
            verticalAnchor: "start",
            textAnchor: "start"
          },
          s.runtime.yAxis.type === "date" ? y(g(Te)) : S ? Te : p(Te)
        ), s.isLollipopChart && s.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: gn,
            cx: $.y,
            cy: xe * $.index + _ / 2,
            r: M / 2,
            fill: Dt,
            key: `circle--${$.index}`,
            "data-tooltip-html": Lt,
            "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
            style: { filter: "unset", opacity: 1 }
          }
        ), s.isLollipopChart && s.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
          "rect",
          {
            display: gn,
            x: $.y > 10 ? $.y - M / 2 : 0,
            y: 0 - _ / 2,
            width: M,
            height: M,
            fill: Dt,
            key: `circle--${$.index}`,
            "data-tooltip-html": Lt,
            "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
            style: { opacity: 1, filter: "unset" }
          },
          /* @__PURE__ */ n.createElement("animate", { attributeName: "height", values: `0, ${M}`, dur: "2.5s" })
        ), B && /* @__PURE__ */ n.createElement(
          "path",
          {
            key: `confidence-interval-h-${Ft}-${ve[s.runtime.originalXAxis.dataKey]}`,
            stroke: ne,
            strokeWidth: "px",
            d: `
                                M${pn} ${Ft - vt}
                                L${pn} ${Ft + vt}
                                M${pn} ${Ft}
                                L${mt} ${Ft}
                                M${mt} ${Ft - vt}
                                L${mt} ${Ft + vt} `
          }
        )));
      })
    ))
  ));
}, Bu = {
  Vertical: ck,
  Horizontal: dk,
  StackedVertical: sk,
  StackedHorizontal: uk
}, fk = ({ xScale: e, yScale: t, seriesScale: r, xMax: a, yMax: i, handleTooltipMouseOver: o, handleTooltipMouseOff: d, handleTooltipClick: c }) => {
  const { transformedData: s, config: p } = se.useContext(ft), y = {
    xScale: e,
    yScale: t,
    xMax: a,
    yMax: i,
    seriesScale: r
  };
  return /* @__PURE__ */ n.createElement(Vr, { component: "BarChart" }, /* @__PURE__ */ n.createElement(Ns.Provider, { value: y }, /* @__PURE__ */ n.createElement(tt, { left: parseFloat(p.runtime.yAxis.size) }, /* @__PURE__ */ n.createElement(Bu.StackedVertical, null), /* @__PURE__ */ n.createElement(Bu.StackedHorizontal, null), /* @__PURE__ */ n.createElement(Bu.Vertical, null), /* @__PURE__ */ n.createElement(Bu.Horizontal, null), /* @__PURE__ */ n.createElement(Rr, { key: "bars", display: p.tooltips.singleSeries ? "none" : "block", width: Number(a), height: Number(i), fill: "transparent", fillOpacity: 0.05, onMouseMove: (g) => o(g, s), onMouseOut: d, onClick: (g) => c(g, s) }))));
};
function Ha() {
  return Ha = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ha.apply(this, arguments);
}
function _i(e) {
  var t = e.x1, r = e.x2, a = e.y1, i = e.y2;
  return {
    x1: a,
    x2: i,
    y1: t,
    y2: r
  };
}
function dg(e) {
  var t = e.left, r = t === void 0 ? 0 : t, a = e.top, i = a === void 0 ? 0 : a, o = e.className, d = e.max, c = e.min, s = e.firstQuartile, p = e.thirdQuartile, y = e.median, g = e.boxWidth, b = g === void 0 ? 10 : g, w = e.fill, S = e.fillOpacity, L = e.stroke, m = e.strokeWidth, v = e.rx, A = v === void 0 ? 2 : v, P = e.ry, T = P === void 0 ? 2 : P, _ = e.valueScale, M = e.outliers, Z = M === void 0 ? [] : M, Y = e.horizontal, ae = e.medianProps, j = ae === void 0 ? {} : ae, q = e.maxProps, te = q === void 0 ? {} : q, le = e.minProps, B = le === void 0 ? {} : le, X = e.boxProps, ue = X === void 0 ? {} : X, ne = e.outlierProps, J = ne === void 0 ? {} : ne, W = e.container, K = W === void 0 ? !1 : W, ee = e.containerProps, $ = ee === void 0 ? {} : ee, pe = e.children, ve = Y ? i : r, Te = ve + (b || 0) / 2, ye = _.range(), Re = _(c ?? 0), Xe = _(s ?? 0), Ce = _(y ?? 0), xe = _(p ?? 0), Pe = _(d ?? 0), de = {
    valueRange: ye,
    center: Te,
    offset: ve,
    boxWidth: b,
    max: {
      x1: Te - (b || 0) / 4,
      x2: Te + (b || 0) / 4,
      y1: Pe,
      y2: Pe
    },
    maxToThird: {
      x1: Te,
      x2: Te,
      y1: Pe,
      y2: xe
    },
    median: {
      x1: ve,
      x2: ve + (b || 0),
      y1: Ce,
      y2: Ce
    },
    minToFirst: {
      x1: Te,
      x2: Te,
      y1: Xe,
      y2: Re
    },
    min: {
      x1: Te - (b || 0) / 4,
      x2: Te + (b || 0) / 4,
      y1: Re,
      y2: Re
    },
    box: {
      x1: ve,
      x2: b || 0,
      y1: xe,
      y2: Math.abs(xe - Xe)
    },
    container: {
      x1: ve,
      x2: b || 0,
      y1: Math.min.apply(Math, ye),
      y2: Math.abs(ye[0] - ye[1])
    }
  };
  return Y && (de.max = _i(de.max), de.maxToThird = _i(de.maxToThird), de.box.y1 = Xe, de.box = _i(de.box), de.median = _i(de.median), de.minToFirst = _i(de.minToFirst), de.min = _i(de.min), de.container = _i(de.container), de.container.y1 = Math.min.apply(Math, ye)), pe ? /* @__PURE__ */ n.createElement(n.Fragment, null, pe(de)) : /* @__PURE__ */ n.createElement(tt, {
    className: Nn("visx-boxplot", o)
  }, Z.map(function(Be, Ne) {
    var He = Y ? _(Be) : Te, Ze = Y ? Te : _(Be);
    return /* @__PURE__ */ n.createElement("circle", Ha({
      key: "visx-boxplot-outlier-" + Ne,
      className: "visx-boxplot-outlier",
      cx: He,
      cy: Ze,
      r: 4,
      stroke: L,
      strokeWidth: m,
      fill: w,
      fillOpacity: S
    }, J));
  }), /* @__PURE__ */ n.createElement("line", Ha({
    className: "visx-boxplot-max",
    x1: de.max.x1,
    y1: de.max.y1,
    x2: de.max.x2,
    y2: de.max.y2,
    stroke: L,
    strokeWidth: m
  }, te)), /* @__PURE__ */ n.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: de.maxToThird.x1,
    y1: de.maxToThird.y1,
    x2: de.maxToThird.x2,
    y2: de.maxToThird.y2,
    stroke: L,
    strokeWidth: m
  }), /* @__PURE__ */ n.createElement("rect", Ha({
    className: "visx-boxplot-box",
    x: de.box.x1,
    y: de.box.y1,
    width: de.box.x2,
    height: de.box.y2,
    stroke: L,
    strokeWidth: m,
    fill: w,
    fillOpacity: S,
    rx: A,
    ry: T
  }, ue)), /* @__PURE__ */ n.createElement("line", Ha({
    className: "visx-boxplot-median",
    x1: de.median.x1,
    y1: de.median.y1,
    x2: de.median.x2,
    y2: de.median.y2,
    stroke: L,
    strokeWidth: m
  }, j)), /* @__PURE__ */ n.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: de.minToFirst.x1,
    y1: de.minToFirst.y1,
    x2: de.minToFirst.x2,
    y2: de.minToFirst.y2,
    stroke: L,
    strokeWidth: m
  }), /* @__PURE__ */ n.createElement("line", Ha({
    className: "visx-boxplot-min",
    x1: de.min.x1,
    y1: de.min.y1,
    x2: de.min.x2,
    y2: de.min.y2,
    stroke: L,
    strokeWidth: m
  }, B)), K && /* @__PURE__ */ n.createElement("rect", Ha({
    x: de.container.x1,
    y: de.container.y1,
    width: de.container.x2,
    height: de.container.y2,
    fillOpacity: "0"
  }, $)));
}
dg.propTypes = {
  max: Me.number,
  min: Me.number,
  firstQuartile: Me.number,
  thirdQuartile: Me.number,
  median: Me.number,
  boxWidth: Me.number,
  fill: Me.string,
  fillOpacity: Me.oneOfType([Me.number, Me.string]),
  stroke: Me.string,
  strokeWidth: Me.oneOfType([Me.number, Me.string]),
  rx: Me.number,
  ry: Me.number,
  outliers: Me.arrayOf(Me.number),
  container: Me.bool,
  children: Me.func
};
const pk = (e, t, r, a, i, o, d, c, s) => `
    <div class="p-2  text-red" style="max-width: 300px; word-wrap: break-word; opacity:0.7; background: rgba(255, 255, 255, 0.9)">
      <div class="fw-bold" style="color: ${s};">
        ${c ? `${c} : ${t}` : t}
      </div>
      <div class="" style="background: ${s}; height: 2px;"></div>
        <strong>Key:</strong> ${r}<br/>
        <strong>${e.labels.q1}:</strong> ${a}<br/>
        <strong>${e.labels.q3}:</strong> ${i}<br/>
        <strong>${e.labels.iqr}:</strong> ${d}<br/>
        <strong>${e.labels.median}:</strong> ${o}
    </div>
  `, hk = (e) => {
  if (!e || e.length === 0)
    return {};
  const t = et.sortBy(e), r = Ts(t, 0.25) ?? 0, a = Ts(t, 0.75) ?? 0, i = a - r, o = r - 1.5 * i, d = a + 1.5 * i, c = t.filter((s) => s >= o && s <= d);
  return {
    min: xf(c),
    // Smallest non-outlier value
    max: Ju(c),
    // Largest non-outlier value
    median: ay(t),
    // Median of all values
    firstQuartile: r,
    thirdQuartile: a,
    iqr: i
  };
}, mk = (e, t, r) => {
  const a = t.series.map((d) => d == null ? void 0 : d.dataKey), i = {}, o = r.filter((d) => d[t.xAxis.dataKey] === e);
  return a.forEach((d) => {
    i[d] = o.map((c) => c[d]);
  }), i;
}, yk = (e, t, r) => {
  const a = r - t, i = t - 1.5 * a, o = r + 1.5 * a;
  return e.filter((d) => d < i || d > o);
}, gk = (e, t, r) => {
  const a = r - t, i = t - 1.5 * a, o = r + 1.5 * a;
  return e.filter((d) => d >= i && d <= o);
}, vk = (e, t) => {
  const r = e.map((o) => o[t.xAxis.dataKey]), a = [], i = et.uniq(r);
  return i && i.length > 0 && i.forEach((o) => {
    const d = mk(o, t, e), c = {}, s = {}, p = {}, y = {}, g = {}, b = {}, w = {}, S = {};
    Object.keys(d).forEach((L) => {
      const m = d[L], { firstQuartile: v, thirdQuartile: A, min: P, max: T, median: _, iqr: M } = hk(m);
      c[L] = yk(m, v, A).map(Number), s[L] = gk(m, v, A).map(Number), p[L] = _, y[L] = P, g[L] = T, b[L] = v, w[L] = A, S[L] = M;
    }), a.push({
      columnCategory: o,
      keyValues: d,
      columnOutliers: c,
      columnNonOutliers: s,
      min: y,
      max: g,
      q1: b,
      q3: w,
      median: p,
      iqr: S
    });
  }), a;
}, xk = ({ xScale: e, yScale: t, seriesScale: r }) => {
  const { config: a, colorScale: i, seriesHighlight: o, transformedData: d } = se.useContext(ft), { boxplot: c } = a, s = `cdc-open-viz-tooltip-${a.runtime.uniqueId}`, p = e.bandwidth(), g = getComputedStyle(document.body).getPropertyValue("--cool-gray-90").trim(), b = Math.min(40, p);
  et.get(Sr, [a.palette, 0], "#000");
  const w = vk(d, a);
  return /* @__PURE__ */ n.createElement(Vr, { component: "BoxPlot" }, /* @__PURE__ */ n.createElement(tt, { left: Number(a.yAxis.size), className: "boxplot", key: "boxplot-group" }, w.map((S, L) => {
    const m = p - b, v = 4;
    return /* @__PURE__ */ n.createElement(
      tt,
      {
        key: `boxplotplot-${S.columnCategory}`,
        left: e(S.columnCategory) + (e.bandwidth() - r.bandwidth()) / 2
      },
      a.series.map((A, P) => {
        const T = a.legend.behavior === "highlight" && o.length > 0 && o.indexOf(A.dataKey) === -1, _ = a.legend.behavior === "highlight" || o.length === 0 || o.indexOf(A.dataKey) !== -1, M = T ? 0.3 : 0.5;
        return /* @__PURE__ */ n.createElement(tt, { key: `boxplotplot-${A.dataKey}-${P}` }, c.plotNonOutlierValues && S.columnNonOutliers[A.dataKey].map((Z, Y) => /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: _ ? "block" : "none",
            cx: r(A.dataKey) + r.bandwidth() / 2,
            cy: t(Z),
            r: v,
            opacity: M,
            fill: g,
            style: { stroke: g },
            key: `boxplot-${L}--circle-${Y}`
          }
        )), _ && /* @__PURE__ */ n.createElement(
          dg,
          {
            display: _ ? "block" : "none",
            "data-left": e(S.columnCategory) + a.yAxis.size + m / 2 + 0.5,
            key: `box-plot-${L}-${A}`,
            min: Number(S.min[A.dataKey]),
            max: Number(S.max[A.dataKey]),
            left: r(A.dataKey),
            firstQuartile: S.q1[A.dataKey],
            thirdQuartile: S.q3[A.dataKey],
            median: S.median[A.dataKey],
            boxWidth: r.bandwidth(),
            fill: i(A.dataKey),
            fillOpacity: 1,
            stroke: g,
            valueScale: t,
            outliers: c.plotOutlierValues ? et.map(S.columnOutliers[A.dataKey], (Z) => Z) : [],
            outlierProps: {
              style: {
                fill: g,
                opacity: M,
                stroke: g
              }
            },
            medianProps: {
              style: {
                opacity: M,
                stroke: g
              }
            },
            boxProps: {
              style: {
                stroke: g,
                strokeWidth: c.borders === "true" ? 1.5 : 0,
                opacity: M
              }
            },
            maxProps: {
              style: {
                opacity: M,
                stroke: g
              }
            },
            container: !0,
            containerProps: {
              "data-tooltip-html": pk(
                c,
                S.columnCategory,
                A.dataKey,
                et.round(S.q1[A.dataKey], a.dataFormat.roundTo),
                et.round(S.q3[A.dataKey], a.dataFormat.roundTo),
                et.round(S.median[A.dataKey], a.dataFormat.roundTo),
                et.round(S.iqr[A.dataKey], a.dataFormat.roundTo),
                a.xAxis.label,
                g
              ),
              "data-tooltip-id": s,
              tabIndex: -1
            }
          }
        ));
      })
    );
  })));
}, bk = ({ xScale: e, yScale: t }) => {
  const {
    transformedData: r,
    config: a,
    tableData: i,
    formatNumber: o,
    seriesHighlight: d,
    colorPalettes: c
  } = se.useContext(ft), s = 4.5, p = Object.keys(a.runtime.seriesLabels).length > 1, y = Object.entries(a.columns).filter(([b, w]) => w.tooltips).map(([b, w]) => [
    w.label || w.name,
    w.name,
    {
      addColPrefix: w.prefix,
      addColSuffix: w.suffix,
      addColRoundTo: w.roundToPlace,
      addColCommas: w.commas
    }
  ]), g = (b, w, S) => `<div>
    ${a.legend.showLegendValuesTooltip && a.runtime.seriesLabels && p ? `${a.runtime.seriesLabels[w] || ""}<br/>` : ""}
    ${a.xAxis.label}: ${o(b[a.xAxis.dataKey], "bottom")} <br/>
    ${a.yAxis.label}: ${o(b[w], "left")}<br/>
   ${y.map(
    ([L, m, v]) => `${L} : ${Xf(i[S][m], "left", !1, a, v)}<br/>`
  ).join("")}
</div>`;
  return /* @__PURE__ */ n.createElement(tt, { className: "scatter-plot", left: a.yAxis.size }, r.map((b, w) => a.runtime.seriesKeys.map((S, L) => {
    const m = a.legend.behavior === "highlight" && d.length > 0 && d.indexOf(S) === -1, v = a.legend.behavior === "highlight" || d.length === 0 || d.indexOf(S) !== -1, A = a != null && a.customColors ? a.customColors[L] : a.palette ? c[a.palette][L] : "#000";
    let P = {
      filter: "unset",
      opacity: 1,
      stroke: v ? "black" : ""
    };
    return /* @__PURE__ */ n.createElement(
      "circle",
      {
        key: `${w}-${L}`,
        r: s,
        cx: e(b[a.xAxis.dataKey]),
        cy: t(b[S]),
        fill: v ? A : "transparent",
        fillOpacity: m ? 0.25 : 1,
        style: P,
        "data-tooltip-html": g(b, S, w),
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      }
    );
  })));
};
function Ek({ height: e, xScale: t }) {
  const {
    transformedData: r,
    config: a,
    formatNumber: i,
    twoColorPalette: o,
    updateConfig: d,
    parseDate: c,
    formatDate: s,
    currentViewport: p
  } = se.useContext(ft), { barStyle: y, tipRounding: g, roundingStyle: b, twoColor: w } = a, S = se.useRef([]), [L, m] = se.useState(window.innerWidth), v = b === "standard" ? "8px" : b === "shallow" ? "5px" : b === "finger" ? "15px" : "0px";
  a.barStyle;
  const A = Number(a.xAxis.target), P = a.series[0].dataKey, T = Number(t.domain()[1]), M = r.some((ne) => ne[P] < 0) || A > 0 || t.domain()[0] < 0, Z = a.barHasBorder === "true" ? 1 : 0, Y = a.lollipopSize === "large" ? 7 : a.lollipopSize === "medium" ? 6 : 5, ae = a.lollipopSize === "large" ? 14 : a.lollipopSize === "medium" ? 12 : 10, j = Math.max(t(0), Math.min(t(A), t(T))), q = (ne) => {
    if (ne == null || y !== "rounded")
      return;
    let J = {};
    return ne === "left" && (J = { borderRadius: `${v} 0 0 ${v}` }), ne === "right" && (J = { borderRadius: `0 ${v} ${v} 0` }), g === "full" && (J = { borderRadius: v }), J;
  }, te = {
    calculate: function() {
      const J = r[0][P] < A ? "left" : "right", W = `${a.xAxis.targetLabel} ${i(a.xAxis.target || 0, "left")}`, K = hr(W);
      let ee = a.isLollipopChart ? Y / 2 : Number(a.barHeight) / 2, $ = 0, pe = 0, ve = !1;
      J === "right" && ($ = -10, ve = K - $ < j, pe = j - K), J === "left" && ($ = 10, ve = t(T) - j > K + $, pe = j), this.text = W, this.y = ee, this.x = pe, this.padding = $, this.showLabel = a.xAxis.showTargetLabel ? ve : !1;
    }
  };
  te.calculate();
  const le = se.useRef(null), B = hp(le, {});
  se.useEffect(() => {
    const ne = () => {
      var J;
      m(window.innerWidth), (J = S.current) == null || J.forEach((W) => {
        !W || !W.style || (W.style.transition = "none", W.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", ne), () => {
      window.removeEventListener("resize", ne);
    };
  }, []);
  const [X, ue] = se.useState(!1);
  return se.useEffect(() => {
    B != null && B.isIntersecting && setTimeout(() => {
      ue(!0);
    }, 100);
  }, [B == null ? void 0 : B.isIntersecting, a.animate]), se.useEffect(() => {
    var ne;
    (ne = S.current) == null || ne.forEach((J, W) => {
      if (!(!J || !J.style)) {
        if (a.animate) {
          const K = A / T * 100;
          J.style.opacity = "0", J.style.transform = `translate(${K / 1.07}%) scale(0, 1)`, setTimeout(() => {
            J.style.opacity = "1", J.style.transform = "translate(0) scale(1)", J.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          J.style.transition = "none", J.style.opacity = "0";
        a.animate || (J.style.transition = "none", J.style.opacity = "1");
      }
    });
  }, [a.animate, a, X]), /* @__PURE__ */ n.createElement(Vr, { component: "Deviation Bar" }, /* @__PURE__ */ n.createElement(tt, { left: Number(a.xAxis.size) }, r.map((ne, J) => {
    const W = Number(ne[P]), K = a.isLollipopChart ? Y : Number(a.barHeight), ee = Number(a.barSpace), $ = Math.abs(t(W) - j), pe = t(W), ve = W > A ? j : pe, Te = W < A ? "left" : "right";
    let ye = 0;
    ye = J !== 0 ? (ee + K + Z) * J : ye;
    const Re = (ee + K + Z) * r.length;
    a.heights.horizontal = Re;
    const Ce = hr(i(W, "left")) < $ - 6, xe = pe, Pe = ye + K / 2, de = pe, Be = ye + K / 2, Ne = pe, He = ye - K / 2, Ze = q(Te), [$e, Ye] = o[w.palette], qe = { left: $e, right: Ye }, Ve = al("#000", qe[Te]);
    let Ge = Sk(a.isLollipopChart, Ce, ae, Ve);
    const ke = i(W, "left"), De = a.runtime.yAxis.type === "date" ? s(c(r[J][a.runtime.originalXAxis.dataKey])) : r[J][a.runtime.originalXAxis.dataKey];
    let at = a.runtime.yAxis.label ? `${a.runtime.yAxis.label}: ${De}` : De, be = a.runtime.xAxis.label ? `${a.runtime.xAxis.label}: ${ke}` : ke;
    const nt = `<div>
          ${at}<br />
          ${be}
            </div>`;
    return /* @__PURE__ */ n.createElement(tt, { key: `deviation-bar-${a.orientation}-${P}-${J}` }, /* @__PURE__ */ n.createElement(
      "foreignObject",
      {
        ref: (st) => {
          S.current[J] = st;
        },
        x: ve,
        y: ye,
        width: $,
        height: K,
        "data-tooltip-html": nt,
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      },
      /* @__PURE__ */ n.createElement(
        "div",
        {
          style: {
            width: $,
            height: K,
            border: `${Z}px solid #333`,
            backgroundColor: qe[Te],
            ...Ze
          }
        }
      )
    ), a.yAxis.displayNumbersOnBar && /* @__PURE__ */ n.createElement(ct, { verticalAnchor: "middle", x: xe, y: Pe, ...Ge[Te] }, i(ne[P], "left")), a.isLollipopChart && a.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
      "circle",
      {
        cx: de,
        cy: Be,
        r: ae / 2,
        fill: qe[Te],
        style: { filter: "unset", opacity: 1 }
      }
    ), a.isLollipopChart && a.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
      "rect",
      {
        x: Ne,
        y: He,
        width: ae,
        height: ae,
        fill: qe[Te],
        style: { opacity: 1, filter: "unset" }
      }
    ));
  }), te.showLabel && /* @__PURE__ */ n.createElement(ct, { fontWeight: "bold", dx: te.padding, verticalAnchor: "middle", x: te.x, y: te.y }, te.text), M && /* @__PURE__ */ n.createElement(cn, { from: { x: j, y: 0 }, to: { x: j, y: e }, stroke: "#333", strokeWidth: 2 })), /* @__PURE__ */ n.createElement("foreignObject", { y: e / 2, ref: le }));
}
function Sk(e, t, r, a) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: r + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -r,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? a : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? a : "#000000"
    }
  };
}
const kk = ({ xScale: e, yScale: t, height: r, width: a, handleTooltipMouseOver: i, handleTooltipMouseOff: o }) => {
  var S;
  const { transformedData: d, rawData: c, config: s, seriesHighlight: p } = se.useContext(ft), { xAxis: y, yAxis: g, legend: b, runtime: w } = s;
  return d && /* @__PURE__ */ n.createElement(Vr, { component: "ForecastingChart" }, /* @__PURE__ */ n.createElement(tt, { className: "forecasting-items", key: "forecasting-items-wrapper", left: Number(g.size) }, (S = w.forecastingSeriesKeys) == null ? void 0 : S.map((L, m) => !L || !L.stages ? !1 : L.stages.map((v, A) => {
    var Z;
    const { behavior: P } = b, T = c.filter((Y) => Y[L.stageColumn] === v.key);
    let _ = P === "highlight" && p.length > 0 && p.indexOf(v.key) === -1, M = P === "highlight" || p.length === 0 || p.indexOf(v.key) !== -1;
    return /* @__PURE__ */ n.createElement(tt, { className: `forecasting-areas-combo-${m}`, key: `forecasting-areas--stage-${v.key.replaceAll(" ", "-")}-${m}` }, (Z = L.confidenceIntervals) == null ? void 0 : Z.map((Y, ae) => {
      const j = Yu[v.color] || Sr[v.color] || !1, q = () => M && j[2] ? j[2] : "transparent", te = () => M && j[1] ? j[1] : "transparent";
      if (!(Y.high === "" || Y.low === ""))
        return /* @__PURE__ */ n.createElement(tt, { key: `forecasting-areas--stage-${v.key.replaceAll(" ", "-")}--group-${A}-${ae}` }, /* @__PURE__ */ n.createElement(
          Z0,
          {
            curve: Wu,
            data: T,
            fill: q(),
            opacity: _ ? 0.1 : 0.5,
            x: (le) => e(Date.parse(le[y.dataKey])),
            y0: (le) => t(le[Y.low]),
            y1: (le) => t(le[Y.high])
          }
        ), ae === 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Hr, { data: T, x: (le) => Number(e(Date.parse(le[y.dataKey]))), y: (le) => Number(t(le[Y.high])), curve: Wu, stroke: te(), strokeWidth: 1, strokeOpacity: 1 }), /* @__PURE__ */ n.createElement(Hr, { data: T, x: (le) => Number(e(Date.parse(le[y.dataKey]))), y: (le) => Number(t(le[Y.low])), curve: Wu, stroke: te(), strokeWidth: 1, strokeOpacity: 1 })));
    }));
  })), /* @__PURE__ */ n.createElement(tt, { key: "tooltip-hover-section" }, /* @__PURE__ */ n.createElement(Rr, { key: "bars", width: Number(a), height: Number(r), fill: "transparent", fillOpacity: 0.05, onMouseMove: (L) => i(L, d), onMouseOut: o }))));
};
function Vc(e, t) {
  const r = e.series.every(({ type: w }) => w === "Bar"), a = e.series.every(({ type: w }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(w)), i = (w) => (S) => w.reduce((L, m) => isNaN(Number(S[m])) ? L : L + Number(S[m]), 0), o = (w) => {
    const S = e.runtime.series.find((L) => L.dataKey === w);
    return S != null && S.dynamicCategory ? S.originalDataKey : w;
  }, d = () => {
    let w = Math.max(
      ...t == null ? void 0 : t.map(
        (S) => Math.max(
          ...e.runtime.seriesKeys.map((L) => {
            const m = o(L);
            return Vi(S[m]) ? Number(p(S[m])) : 0;
          })
        )
      )
    );
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && r) && e.visualizationSubType === "stacked") {
      const S = t.map(i(e.runtime.seriesKeys)).filter((L) => !isNaN(L));
      w = Math.max(...S);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const S = t.map(i(e.runtime.seriesKeys));
      w = Math.max(...S);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (w = Math.max(
      ...t.map((S) => Vi(S[e.series.dataKey]) ? Number(p(S[e.series.dataKey])) : 0)
    )), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !r && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const S = t.map(i(e.runtime.barSeriesKeys)), L = Math.max(
        ...t.map((v) => Math.max(...e.runtime.lineSeriesKeys.map((A) => Number(p(v[A])))))
      ), m = Math.max(...S);
      w = Math.max(m, L);
    }
    return w;
  }, c = () => {
    const w = Math.min(
      ...t.map(
        (S) => Math.min(
          ...e.runtime.seriesKeys.map((L) => {
            const m = o(L);
            return Vi(S[m]) ? Number(p(S[m])) : 1 / 0;
          })
        )
      )
    );
    return String(w);
  }, s = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((w) => t.some((S) => S[o(w)] >= 0)) : !1, p = (w) => w === null || w === "" ? "" : typeof w == "string" ? w.replace(/[,$]/g, "") : w, y = Number(d()), g = Number(c()), b = s();
  return { minValue: g, maxValue: y, existPositiveValue: b, isAllLine: a };
}
function Ep({ config: e, yMax: t = 0, data: r = [], updateConfig: a }) {
  var b, w, S, L;
  const i = e.visualizationType === "Combo" && e.orientation === "vertical", o = e.series && e.series.filter((m) => m.axis === "Right").map((m) => m.dataKey);
  let { minValue: d } = Vc(e, r);
  const c = (m) => {
    if (!m)
      return [0];
    let v = [];
    return m.map((A, P) => v = [...v, ...r.map((T) => Number(T[A]))]), v;
  };
  let s = Math.max.apply(null, c(o));
  e.yAxis.rightMax > s && (s = e.yAxis.rightMax), e.yAxis.rightMin < d && (d = e.yAxis.rightMin);
  const p = ((w = (b = e.runtime) == null ? void 0 : b.barSeriesKeys) == null ? void 0 : w.length) > 0, y = ((L = (S = e.runtime) == null ? void 0 : S.lineSeriesKeys) == null ? void 0 : L.length) > 0;
  return (p || y) && d > 0 && (d = 0), { yScaleRight: Vn({
    domain: [d, s],
    range: [t, 0]
  }), hasRightAxis: i };
}
const wk = (e) => {
  const { preliminaryData: t, data: r, stroke: a, strokeWidth: i, handleLineType: o, lineType: d, seriesKey: c } = e, s = t.filter(
    (b) => b.seriesKey && b.column && b.value && b.type && b.style && b.type === "effect"
  ), p = (b) => s.find(
    (w) => w.seriesKey === c && b[w.column] === w.value && w.type === "effect" && w.style !== "Open Circles"
  );
  let y = [];
  const g = (b) => ({
    stroke: a,
    strokeWidth: i,
    strokeDasharray: b
  });
  return r.forEach((b, w) => {
    let S = p(b), L = g(o(S ? S.style : d));
    y.push(L), S && w > 0 && (y[w - 1] = g(o(S.style)));
  }), y;
}, Tk = (e, t, r) => {
  const a = e == null ? void 0 : e.filter((o) => o.style.includes("Circles") && o.type === "effect").map((o) => ({
    column: o.column,
    value: o.value,
    seriesKey: o.seriesKey,
    circleSize: o.circleSize,
    style: o.style
  })), i = [];
  return t.forEach((o) => {
    a.forEach((d) => {
      if (o[d.column] === d.value && d.seriesKey === r && o[r] && d.style === "Open Circles") {
        const c = {
          data: o,
          size: d.circleSize,
          isFilled: !1
        };
        i.push(c);
      }
      if ((!d.value || o[d.column] === d.value) && d.seriesKey === r && o[r] && d.style === "Filled Circles") {
        const c = {
          data: o,
          size: d.circleSize,
          isFilled: !0
        };
        i.push(c);
      }
    });
  }), i;
}, kc = (e) => !isNaN(parseFloat(e)) && isFinite(e), Ck = (e, t, r) => {
  let a = "0";
  const i = {
    data: { 0: [] },
    style: ""
  };
  if (!e.length)
    return i;
  const o = e[0], d = (s) => {
    if (!(s.type === "effect" || s.hideLineStyle))
      return s.type == "suppression" && s.value === o[t] && (!s.column || s.column === t);
  }, c = r.find(d);
  if (c && c.style) {
    const s = { ...o, [t]: 0 };
    i.data[a].push(s), i.style = c.style;
    let p = 1;
    for (; p < e.length && !kc(e[p][t]); )
      p++;
    p < e.length && i.data[a].push(e[p]);
  } else
    i.data[a].push(o);
  return i;
}, Ak = (e, t, r) => {
  let a = "0";
  const i = {
    data: { 0: [] },
    style: ""
  };
  let o = -1;
  return r == null || r.forEach((d) => {
    if (d.type !== "effect" && e[e.length - 1][t] === d.value && d.style && (!d.column || d.column === t) && d.type == "suppression" && !d.hideLineStyle) {
      const c = e.length - 1, s = { ...e[c], [t]: 0 };
      i.data[a].push(s);
      let p = c - 1;
      for (; p >= 0 && !kc(e[p][t]); )
        p--;
      p >= 0 && o !== p && (i.data[a].push(e[p]), o = p), i.style = d.style;
    }
  }), i;
};
function Lk(e, t, r) {
  let a = {
    data: {},
    style: ""
  }, i = 1;
  return e.forEach((o, d) => {
    r.forEach((c) => {
      const s = c.value;
      if (o[t] === s) {
        let p = null, y = null;
        for (let g = d - 1; g >= 0; g--)
          if (kc(e[g][t])) {
            p = e[g];
            break;
          }
        for (let g = d + 1; g < e.length; g++)
          if (kc(e[g][t])) {
            y = e[g];
            break;
          }
        p && y && (a.style = c.style, a.data[i++] = [p, y]);
      }
    });
  }), a;
}
const Pk = (e, t, r, a) => {
  const i = Ck(e, t, r), o = Ak(e, t, r), d = Lk(e, t, r);
  return [i, d, o];
};
var Rk = ["children", "className", "top", "left", "size"];
function jf() {
  return jf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, jf.apply(this, arguments);
}
function Nk(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Sp(e) {
  var t = e.children, r = e.className, a = e.top, i = e.left, o = e.size, d = Nk(e, Rk), c = Ng();
  return c.type(p0), (typeof o == "number" || o) && c.size(o), t ? /* @__PURE__ */ n.createElement(n.Fragment, null, t({
    path: c
  })) : /* @__PURE__ */ n.createElement(Gf, {
    top: a,
    left: i
  }, /* @__PURE__ */ n.createElement("path", jf({
    className: Nn("visx-glyph-cross", r),
    d: c() || ""
  }, d)));
}
Sp.propTypes = {
  children: Me.func,
  className: Me.string,
  top: Me.number,
  left: Me.number,
  size: Me.oneOfType([Me.number, Me.func])
};
const Dk = [
  km,
  wm,
  Gu,
  Tm,
  Gu,
  Sp,
  ({ fill: e }) => /* @__PURE__ */ n.createElement(Gf, null, /* @__PURE__ */ n.createElement(ct, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle" }, "⬟"))
], sf = (e) => {
  var ae, j, q, te, le, B, X, ue;
  const {
    config: t,
    d: r,
    tableData: a,
    displayArea: i,
    seriesKey: o,
    tooltipData: d,
    xScale: c,
    yScale: s,
    colorScale: p,
    parseDate: y,
    yScaleRight: g,
    data: b,
    circleData: w,
    dataIndex: S,
    mode: L,
    seriesIndex: m
  } = e, { lineDatapointStyle: v, visual: A } = t, P = (j = (ae = t == null ? void 0 : t.runtime) == null ? void 0 : ae.series.filter((ne) => ne.dataKey === o)) == null ? void 0 : j[0], T = Dk[t.visual.lineDatapointSymbol === "standard" && m < A.maximumShapeAmount ? m : 0], _ = m === 4, M = (ne, J) => `translate(${J}, ${ne})${_ ? " rotate(180)" : ""}`, Z = (ne, J, W, K, ee) => {
    const $ = W.runtime.seriesLabels || [];
    let pe = ne ? J($[K] || ee) : " transparent";
    return W.lineDatapointColor === "Lighter than Line" && pe !== "transparent" && pe && (pe = Ua(pe).brighten(1)), pe;
  }, Y = (ne) => (t.xAxis.type === "categorical" ? c(ne) : c(y(ne))) + (c.bandwidth ? c.bandwidth() / 2 : 0);
  if (L === "ALWAYS_SHOW_POINTS" && v !== "hidden" && v === "always show") {
    if ((w == null ? void 0 : w.some(
      (K) => K[t.xAxis.dataKey] === r[t.xAxis.dataKey] && K[o] === r[o]
    )) || !P || A.maximumShapeAmount === m && A.lineDatapointSymbol === "standard")
      return /* @__PURE__ */ n.createElement(n.Fragment, null);
    const J = Y(r[t.xAxis.dataKey]), W = P.axis === "Right" ? g(r[P.dataKey]) : s(r[P.dataKey]);
    return /* @__PURE__ */ n.createElement("g", { transform: M(W, J) }, /* @__PURE__ */ n.createElement(
      T,
      {
        opacity: r[o] ? 1 : 0,
        fillOpacity: 1,
        fill: Z(i, p, t, o, o),
        style: { filter: "unset", opacity: 1 }
      }
    ));
  }
  if (L === "HOVER_POINTS" && v === "hover") {
    if (!d || !o || !d.data)
      return;
    let ne = (te = (q = d == null ? void 0 : d.data) == null ? void 0 : q[0]) == null ? void 0 : te[1];
    if (!ne)
      return;
    let J, W = d.data.filter(($) => $[0] === o), K = (le = W == null ? void 0 : W[0]) == null ? void 0 : le[0], ee = (B = W == null ? void 0 : W[0]) == null ? void 0 : B[2];
    return K ? (d == null || d.data.indexOf(K), J = (X = a == null ? void 0 : a.find(($) => $[t == null ? void 0 : t.xAxis.dataKey] === ne)) == null ? void 0 : X[o], d == null ? void 0 : d.data.map(($, pe) => {
      if (isNaN(J))
        return /* @__PURE__ */ n.createElement(n.Fragment, null);
      if ((w == null ? void 0 : w.some((Re) => Re[t.xAxis.dataKey] === ne)) || !J || A.maximumShapeAmount === m && A.lineDatapointSymbol === "standard")
        return /* @__PURE__ */ n.createElement(n.Fragment, null);
      const Te = ee === "right" ? g(J) : s(J), ye = Y(ne);
      return /* @__PURE__ */ n.createElement("g", { transform: M(Te, ye) }, /* @__PURE__ */ n.createElement(
        T,
        {
          size: 55,
          opacity: 1,
          fillOpacity: 1,
          fill: Z(i, p, t, K, o),
          style: { filter: "unset", opacity: 1 }
        }
      ));
    })) : void 0;
  }
  if (L === "ISOLATED_POINTS" && ((J, W) => {
    const K = b[J], ee = b[J - 1] || {}, $ = b[J + 1] || {};
    if (w.some((Re) => (Re == null ? void 0 : Re.data[W]) === K[W]))
      return !1;
    const ve = J === 0 && !$[W], Te = J === b.length - 1 && !ee[W], ye = J > 0 && J < b.length - 1 && K[W] && !ee[W] && !$[W];
    return ve || Te || ye;
  })(S, o) && !t.series.some((J) => J.dynamicCategory)) {
    const J = (P == null ? void 0 : P.axis) === "Right" ? g(r[P == null ? void 0 : P.dataKey]) : s(r[P == null ? void 0 : P.dataKey]), W = Y(r[(ue = t.xAxis) == null ? void 0 : ue.dataKey]), K = p(t.runtime.seriesLabels[o]);
    return /* @__PURE__ */ n.createElement("g", { transform: M(J, W) }, /* @__PURE__ */ n.createElement(T, { size: 124, stroke: K, fill: K }));
  }
  return null;
}, _k = (e) => {
  var y, g;
  const { config: t, xScale: r, yScale: a, parseDate: i } = e;
  if (!((y = t == null ? void 0 : t.runtime) != null && y.series))
    return;
  const o = (b) => {
    if (t.xAxis.type === "date")
      return i(b).getTime();
    if (t.xAxis.type === "date-time")
      return new Date(b);
    if (t.xAxis.type === "categorical")
      return b;
  }, d = (b) => r.bandwidth ? r.bandwidth() / 2 + Number(b) : Number(b), c = (b) => {
    var w;
    return (w = Object.values(t.columns)) == null ? void 0 : w.filter((S) => S.tooltips).map((S) => `
        <li className='tooltip-body'>
          <strong>${S.label || S.name}</strong>: ${b[S.name]}
        </li>`).join(" ");
  }, s = (b) => `<ul> ${c(b)} </ul>`, p = (g = t.runtime) == null ? void 0 : g.series.map((b) => t.data.map((w, S) => {
    let L = w[b.dataKey], m = w[t.xAxis.dataKey];
    return /* @__PURE__ */ n.createElement(n.Fragment, { key: `bump-circle-${L}-${S}` }, /* @__PURE__ */ n.createElement(tt, { left: Number(t.runtime.yAxis.size) }, L && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      "circle",
      {
        key: `bump-circle-${L}-${S}`,
        "data-tooltip-html": s(w),
        "data-tooltip-id": "bump-chart",
        r: 10,
        cx: Number(d(r(o(m)))),
        cy: Number(a(L)),
        stroke: "#CACACA",
        strokeWidth: 1,
        fill: "#E5E4E2"
      }
    ), L.toString().length === 2 ? (
      // prettier-ignore
      /* @__PURE__ */ n.createElement(
        "text",
        {
          x: Number(d(r(o(m)))) - 7,
          y: Number(a(L)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        L
      )
    ) : (
      // prettier-ignore
      /* @__PURE__ */ n.createElement(
        "text",
        {
          x: Number(d(r(o(m)))) - 4,
          y: Number(a(L)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        L
      )
    ))));
  }));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, p);
}, dm = (e) => {
  var le;
  const {
    getXAxisData: t,
    getYAxisData: r,
    handleTooltipClick: a,
    handleTooltipMouseOff: i,
    handleTooltipMouseOver: o,
    tooltipData: d,
    xMax: c,
    xScale: s,
    yMax: p,
    yScale: y
  } = e, { colorScale: g, config: b, formatNumber: w, handleLineType: S, parseDate: L, seriesHighlight: m, tableData: v, transformedData: A, updateConfig: P, brushConfig: T, clean: _ } = se.useContext(ft), { yScaleRight: M } = Ep({ config: b, yMax: p, data: A, updateConfig: P });
  if (!o)
    return;
  const { lineDatapointStyle: Z, showLineSeriesLabels: Y, legend: ae } = b;
  let j = A, q = v;
  T.data.length > 0 && ((le = b.brush) != null && le.active) && (j = _(T.data), q = _(T.data));
  const te = (B) => s(t(B)) + (s.bandwidth ? s.bandwidth() / 2 : 0);
  return /* @__PURE__ */ n.createElement(Vr, { component: "LineChart" }, /* @__PURE__ */ n.createElement(tt, { left: Number(b.runtime.yAxis.size) }, " ", (b.runtime.lineSeriesKeys || b.runtime.seriesKeys).map((B, X) => {
    var Te;
    const ue = b.runtime.series.find((ye) => ye.dataKey === B), ne = ue.type, J = ue.axis || "left", W = ae.behavior === "highlight" || m.length === 0 || m.indexOf(B) !== -1, K = Pk(
      v,
      B,
      b.preliminaryData,
      b.xAxis.dataKey
    ), ee = ((Te = b == null ? void 0 : b.preliminaryData) == null ? void 0 : Te.filter((ye) => ye.style && !ye.style.includes("Circles")).length) > 0, $ = ue.dynamicCategory ? j.filter((ye) => ye[ue.dynamicCategory] === B) : j, pe = ue.dynamicCategory ? ue.originalDataKey : B, ve = Tk(b == null ? void 0 : b.preliminaryData, q, pe);
    return /* @__PURE__ */ n.createElement(
      tt,
      {
        key: `series-${B}-${X}`,
        opacity: ae.behavior === "highlight" && m.length > 0 && m.indexOf(pe) === -1 ? 0.5 : 1,
        display: ae.behavior === "highlight" || m.length === 0 && !ae.dynamicLegend || m.indexOf(pe) !== -1 ? "block" : "none"
      },
      /* @__PURE__ */ n.createElement(
        Rr,
        {
          key: "bars",
          width: Number(c),
          height: Number(p),
          fill: "transparent",
          fillOpacity: 0.05,
          onMouseMove: (ye) => o(ye, v),
          onMouseOut: i,
          onClick: (ye) => a(ye, j)
        }
      ),
      $.map((ye, Re) => Vi(ye[pe]) && /* @__PURE__ */ n.createElement(n.Fragment, { key: `series-${B}-point-${Re}` }, b.labels && /* @__PURE__ */ n.createElement(
        ct,
        {
          x: te(ye),
          y: J === "Right" ? M(r(ye, pe)) : y(r(ye, pe)),
          fill: "#000",
          textAnchor: "middle"
        },
        w(ye[pe], "left")
      ), Z === "always show" && /* @__PURE__ */ n.createElement(
        sf,
        {
          mode: "ALWAYS_SHOW_POINTS",
          dataIndex: Re,
          circleData: ve,
          tableData: v,
          data: $,
          d: ye,
          config: b,
          seriesKey: pe,
          displayArea: W,
          tooltipData: d,
          xScale: s,
          yScale: y,
          colorScale: g,
          parseDate: L,
          yScaleRight: M,
          seriesAxis: J,
          seriesIndex: X,
          key: `line-circle--${Re}`
        }
      ), /* @__PURE__ */ n.createElement(
        sf,
        {
          mode: "ISOLATED_POINTS",
          seriesIndex: X,
          dataIndex: Re,
          tableData: v,
          circleData: ve,
          data: $,
          d: ye,
          config: b,
          seriesKey: pe,
          displayArea: W,
          tooltipData: d,
          xScale: s,
          yScale: y,
          colorScale: g,
          parseDate: L,
          yScaleRight: M,
          seriesAxis: J,
          key: `isolated-circle-${Re}`
        }
      ))),
      /* @__PURE__ */ n.createElement(n.Fragment, null, Z === "hover" && /* @__PURE__ */ n.createElement(
        sf,
        {
          seriesIndex: X,
          tableData: v,
          dataIndex: 0,
          mode: "HOVER_POINTS",
          circleData: ve,
          data: $,
          config: b,
          seriesKey: B,
          displayArea: W,
          tooltipData: d,
          xScale: s,
          yScale: y,
          colorScale: g,
          parseDate: L,
          yScaleRight: M,
          seriesAxis: J
        }
      )),
      ee ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        zy,
        {
          curve: Mi[ue.lineType],
          segments: $.map((ye) => [ye]),
          segmentation: "x",
          x: (ye) => te(ye),
          y: (ye) => J === "Right" ? M(r(ye, pe)) : y(Number(r(ye, pe))),
          styles: wk({
            preliminaryData: b.preliminaryData,
            data: q,
            stroke: g(b.runtime.seriesLabels[B]),
            strokeWidth: ue.weight || 2,
            handleLineType: S,
            lineType: ne,
            seriesKey: B
          }),
          defined: (ye, Re) => ye[B] !== "" && ye[B] !== null && ye[B] !== void 0
        }
      ), K.map((ye, Re) => Object.entries(ye.data).map(([Xe, Ce]) => {
        var xe;
        return /* @__PURE__ */ n.createElement(
          Hr,
          {
            key: Re,
            data: Ce,
            x: (Pe) => te(Pe),
            y: (Pe) => J === "Right" ? M(r(Pe, B)) : y(Number(r(Pe, B))),
            stroke: g(b.runtime.seriesLabels[B]),
            strokeWidth: ((xe = ue[0]) == null ? void 0 : xe.weight) || 2,
            strokeOpacity: 1,
            shapeRendering: "geometricPrecision",
            strokeDasharray: S(ye.style),
            defined: (Pe, de) => Pe[B] !== "" && Pe[B] !== null && Pe[B] !== void 0
          }
        );
      }))) : /* @__PURE__ */ n.createElement(n.Fragment, null, b.confidenceKeys && b.series.map((ye, Re) => ye.dynamicCategory ? [...new Set(j.map((Ce) => Ce[ye.dynamicCategory]))].map((Ce, xe) => {
        const Pe = j.filter((de) => de[ye.dynamicCategory] === Ce);
        return /* @__PURE__ */ n.createElement(
          Rf,
          {
            key: `area-closed-${Re}-${xe}`,
            data: Pe,
            x: (de) => te(de),
            y0: (de) => y(de[b.confidenceKeys.lower]),
            y1: (de) => y(de[b.confidenceKeys.upper]),
            opacity: 0.5,
            fill: g(Ce),
            yScale: y,
            curve: Mi[ye.lineType]
          }
        );
      }) : /* @__PURE__ */ n.createElement(
        Rf,
        {
          key: `area-closed-${Re}`,
          data: j,
          x: (Xe) => te(Xe),
          y0: (Xe) => y(Xe[b.confidenceKeys.lower]),
          y1: (Xe) => y(Xe[b.confidenceKeys.upper]),
          opacity: 0.5,
          fill: g(
            b.runtime.seriesLabels ? b.runtime.seriesLabels[ye.dataKey] : ye.dataKey
          ),
          yScale: y,
          curve: Mi[ye.lineType]
        }
      )), /* @__PURE__ */ n.createElement(
        Hr,
        {
          curve: Mi[ue.lineType],
          data: b.visualizationType == "Bump Chart" ? $ : b.xAxis.type === "date-time" || b.xAxis.type === "date" ? $.sort((ye, Re) => {
            let Xe = t(ye), Ce = t(Re);
            return Xe < Ce ? -1 : Ce < Xe ? 1 : 0;
          }) : $,
          x: (ye) => te(ye),
          y: (ye) => J === "Right" ? M(r(ye, pe)) : y(Number(r(ye, pe))),
          stroke: g(b.runtime.seriesLabels[B]),
          strokeWidth: ue.weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: ne ? S(ne) : 0,
          defined: (ye, Re) => ye[pe] !== "" && ye[pe] !== null && ye[pe] !== void 0
        }
      )),
      ve.map((ye, Re) => /* @__PURE__ */ n.createElement(
        "circle",
        {
          key: Re,
          cx: te(ye.data),
          cy: J === "Right" ? M(r(ye.data, pe)) : y(Number(r(ye.data, pe))),
          r: ye.size,
          strokeWidth: ue.weight || 2,
          stroke: g ? g(b.runtime.seriesLabels[B]) : "#000",
          fill: ye.isFilled ? g ? g(b.runtime.seriesLabels[B]) : "#000" : "#fff"
        }
      )),
      b.animate && /* @__PURE__ */ n.createElement(
        Hr,
        {
          className: "animation",
          curve: Mi[ue.lineType],
          data: $,
          x: (ye) => te(ye),
          y: (ye) => J === "Right" ? M(r(ye, pe)) : y(Number(r(ye, pe))),
          stroke: "#fff",
          strokeWidth: 3,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: ne ? S(ne) : 0,
          defined: (ye, Re) => ye[B] !== "" && ye[B] !== null && ye[B] !== void 0
        }
      ),
      Y && (b.runtime.lineSeriesKeys || b.runtime.seriesKeys).map((ye) => {
        let Re;
        for (let Xe = $.length - 1; Xe >= 0; Xe--)
          if ($[Xe][ye]) {
            Re = $[Xe];
            break;
          }
        return Re ? /* @__PURE__ */ n.createElement(
          ct,
          {
            x: te(Re) + 5,
            y: y(r(Re, ye)),
            alignmentBaseline: "middle",
            fill: b.colorMatchLineSeriesLabels && g ? g(b.runtime.seriesLabels[ye] || ye) : "black"
          },
          b.runtime.seriesLabels[ye] || ye
        ) : /* @__PURE__ */ n.createElement(n.Fragment, null);
      })
    );
  }), b.legend.dynamicLegend && m.length === 0 && /* @__PURE__ */ n.createElement(ct, { x: c / 2, y: p / 2, fill: "black", textAnchor: "middle", color: "black" }, b.legend.dynamicLegendChartMessage)), b.visualizationType === "Bump Chart" && /* @__PURE__ */ n.createElement(_k, { config: b, xScale: s, yScale: y }));
}, Ok = ({
  xScale: e,
  yScale: t,
  config: r,
  height: a,
  width: i,
  handleTooltipMouseOff: o,
  handleTooltipMouseOver: d,
  forestPlotRightLabelRef: c
}) => {
  const { rawData: s, updateConfig: p } = se.useContext(ft), { forestPlot: y } = r, g = r.xAxis.tickWidthMax + 10, [b, w] = se.useState(!1);
  se.useEffect(() => {
    try {
      const T = ["estimateField", "lower", "upper", "estimateRadius"], _ = r, M = 10;
      for (let Z = 0; Z < M; Z++)
        T.forEach((Y) => {
          var ae;
          r.forestPlot[Y] && r.forestPlot[Y] !== ((ae = _.columns[r.forestPlot[`additionalColumn${Z}`]]) == null ? void 0 : ae.name) && (delete _.columns[`additionalColumn${Z}`], _.columns[r.forestPlot[Y]] = {}, _.columns[r.forestPlot[Y]].dataKey = _.forestPlot[Y], _.columns[r.forestPlot[Y]].name = _.forestPlot[Y], _.columns[r.forestPlot[Y]].dataTable = !0, _.columns[r.forestPlot[Y]].tooltips = !0, _.columns[r.forestPlot[Y]].label = _.forestPlot[Y]);
        });
      r.forestPlot.radius.scalingColumn && (_.columns[r.forestPlot.radius.scalingColumn] = {}, _.columns[r.forestPlot.radius.scalingColumn].dataKey = _.forestPlot.radius.scalingColumn, _.columns[r.forestPlot.radius.scalingColumn].name = _.forestPlot.radius.scalingColumn, _.columns[r.forestPlot.radius.scalingColumn].label = _.forestPlot.radius.scalingColumn, _.columns[r.forestPlot.radius.scalingColumn].dataTable = !0, _.columns[r.forestPlot.radius.scalingColumn].tooltips = !0), _.table.showVertical && (_.table.indexLabel = r.xAxis.dataKey), p(_);
    } catch (T) {
      console.log(T.message);
    }
  }, []), se.useEffect(() => {
    !b && r.forestPlot.type === "Logarithmic" && (p({
      ...r,
      dataFormat: {
        ...r.dataFormat,
        roundTo: 2
      }
    }), w(!0));
  }, [r.forestPlot.type]);
  const S = r.data.find((T) => T[r.xAxis.dataKey] === r.forestPlot.pooledResult.column), L = S ? [
    { x: e(S[r.forestPlot.lower]), y: a - Number(r.forestPlot.rowHeight) },
    {
      x: e(S[r.forestPlot.estimateField]),
      y: a - y.pooledResult.diamondHeight - Number(r.forestPlot.rowHeight)
    },
    { x: e(S[r.forestPlot.upper]), y: a - Number(r.forestPlot.rowHeight) },
    {
      x: e(S[r.forestPlot.estimateField]),
      y: a + y.pooledResult.diamondHeight - Number(r.forestPlot.rowHeight)
    },
    { x: e(S[r.forestPlot.lower]), y: a - Number(r.forestPlot.rowHeight) }
  ] : [], m = r.forestPlot.rowHeight, v = [
    { x: 0, y: m },
    { x: i, y: m }
  ], A = [
    { x: 0, y: a },
    { x: i, y: a }
  ], P = Object.entries(r.columns).map((T) => T[1]).filter((T) => T.forestPlot === !0);
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(tt, { width: i }, y.title && /* @__PURE__ */ n.createElement(
    ct,
    {
      className: "forest-plot--title",
      x: y.type === "Linear" ? e(0) : e(1),
      y: 0,
      textAnchor: "middle",
      verticalAnchor: "start",
      fill: "black"
    },
    y.title
  ), y.lineOfNoEffect.show && y.type === "Linear" && /* @__PURE__ */ n.createElement(
    cn,
    {
      from: { x: e(0), y: 0 + m },
      to: { x: e(0), y: a },
      className: "forestplot__line-of-no-effect",
      stroke: y.regression.baseLineColor || "black"
    }
  ), y.lineOfNoEffect.show && y.type === "Logarithmic" && /* @__PURE__ */ n.createElement(
    cn,
    {
      from: { x: e(1), y: 0 + m },
      to: { x: e(1), y: a },
      className: "forestplot__line-of-no-effect",
      stroke: y.regression.baseLineColor || "black"
    }
  ), s.map((T, _) => {
    const M = Vn({
      domain: s.map((te) => te[y.radius.scalingColumn]),
      range: [y.radius.min, y.radius.max]
    }), Z = y.radius.scalingColumn !== "" ? M(s[_][y.radius.scalingColumn]) : 4, Y = y.colors.shape ? y.colors.shape : "black", ae = y.colors.line ? y.colors.line : "black", j = 4;
    return T[r.xAxis.dataKey] === y.pooledResult.column ? /* @__PURE__ */ n.createElement(
      Hr,
      {
        data: L,
        x: (te) => te.x,
        y: (te) => te.y - Lc / 2,
        stroke: "black",
        strokeWidth: 2,
        fill: "black",
        curve: wf
      }
    ) : /* @__PURE__ */ n.createElement(tt, null, /* @__PURE__ */ n.createElement(
      "path",
      {
        stroke: ae,
        strokeWidth: 1,
        className: "lower-ci",
        d: `
                    M${e(T[y.lower])} ${t(_) - Number(j)}
                    L${e(T[y.lower])} ${t(_) + Number(j)}
                `
      }
    ), /* @__PURE__ */ n.createElement(
      "path",
      {
        stroke: ae,
        strokeWidth: 1,
        className: "upper-ci",
        d: `
                    M${e(T[y.upper])} ${t(_) - Number(j)}
                    L${e(T[y.upper])} ${t(_) + Number(j)}
                `
      }
    ), /* @__PURE__ */ n.createElement(
      "line",
      {
        stroke: ae,
        className: `line-${T[r.yAxis.dataKey]}`,
        key: _,
        x1: e(T[y.lower]),
        x2: e(T[y.upper]),
        y1: t(_),
        y2: t(_)
      }
    ), y.shape === "circle" && /* @__PURE__ */ n.createElement(
      nv,
      {
        className: "forest-plot--circle",
        cx: e(Number(T[y.estimateField])),
        cy: t(_),
        r: y.radius.scalingColumn !== "" ? M(s[_][y.radius.scalingColumn]) : 4,
        fill: Y,
        style: { opacity: 1, filter: "unset" }
      }
    ), y.shape === "square" && /* @__PURE__ */ n.createElement(
      "rect",
      {
        className: "forest-plot--square",
        x: e(Number(T[y.estimateField])),
        y: t(_) - Z / 2,
        width: Z,
        height: Z,
        fill: Y,
        style: { opacity: 1, filter: "unset" }
      }
    ), y.shape === "text" && /* @__PURE__ */ n.createElement(
      ct,
      {
        className: "forest-plot--text",
        x: e(Number(T[y.estimateField])),
        y: t(_),
        textAnchor: "middle",
        verticalAnchor: "middle",
        fill: Y
      },
      T[y.estimateField]
    ));
  }), L && y.regression.showDiamond && /* @__PURE__ */ n.createElement(
    Hr,
    {
      data: L,
      x: (T) => T.x,
      y: (T) => T.y,
      stroke: "black",
      strokeWidth: 2,
      fill: y.regression.baseLineColor,
      curve: wf
    }
  ), y.regression.description && /* @__PURE__ */ n.createElement(
    ct,
    {
      x: 0 - Number(r.xAxis.size),
      width: i,
      y: a - r.forestPlot.rowHeight - Number(y.rowHeight) / 3,
      verticalAnchor: "start",
      textAnchor: "start",
      style: { fontWeight: "bold", fontSize: 12 }
    },
    y.regression.description
  ), /* @__PURE__ */ n.createElement(
    Rr,
    {
      key: "forest-plot-tooltip-area",
      className: "forest-plot-tooltip-area",
      width: i,
      height: a,
      fill: "transparent",
      fillOpacity: 0.5,
      onMouseMove: (T) => d(T, s),
      onMouseOut: o
    }
  )), /* @__PURE__ */ n.createElement(
    cn,
    {
      from: v[0],
      to: v[1],
      style: { stroke: "black", strokeWidth: 2 },
      className: "forestplot__top-line"
    }
  ), /* @__PURE__ */ n.createElement(
    cn,
    {
      from: A[0],
      to: A[1],
      style: { stroke: "black", strokeWidth: 2 },
      className: "forestplot__bottom-line"
    }
  ), P.map((T) => s.map((_, M) => /* @__PURE__ */ n.createElement(
    ct,
    {
      className: `${_[T.name]}`,
      x: T.forestPlotAlignRight ? i : T.forestPlotStartingPoint,
      y: t(M),
      textAnchor: T.forestPlotAlignRight ? "end" : "start",
      verticalAnchor: "middle",
      fill: "black"
    },
    _[T.name]
  ))), !y.hideDateCategoryCol && s.map((T, _) => /* @__PURE__ */ n.createElement(
    ct,
    {
      className: `${T[r.xAxis.dataKey]}`,
      x: 0,
      y: t(_),
      textAnchor: "start",
      verticalAnchor: "middle",
      fill: "black"
    },
    T[r.xAxis.dataKey]
  )), !y.hideDateCategoryCol && r.xAxis.dataKey && /* @__PURE__ */ n.createElement(ct, { className: r.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fill: "black" }, r.xAxis.dataKey), P.map((T) => /* @__PURE__ */ n.createElement(
    ct,
    {
      className: `${T.label}`,
      x: T.forestPlotAlignRight ? i : T.forestPlotStartingPoint,
      y: 0,
      textAnchor: T.forestPlotAlignRight ? "end" : "start",
      verticalAnchor: "start",
      fill: "black"
    },
    T.label
  )), y.leftLabel && /* @__PURE__ */ n.createElement(
    ct,
    {
      className: "forest-plot__left-label",
      x: y.type === "Linear" ? e(0) - 25 : e(1) - 25,
      y: a + g,
      textAnchor: "end",
      verticalAnchor: "start"
    },
    y.leftLabel
  ), y.rightLabel && /* @__PURE__ */ n.createElement(
    ct,
    {
      innerRef: c,
      className: "forest-plot__right-label",
      x: y.type === "Linear" ? e(0) + 25 : e(1) + 25,
      y: a + g,
      textAnchor: "start",
      verticalAnchor: "start"
    },
    y.rightLabel
  ));
}, Fk = ({ width: e, height: t, originalWidth: r }) => {
  var v, A, P;
  const { config: a, colorScale: i, transformedData: o, formatNumber: d, seriesHighlight: c } = se.useContext(ft);
  if (!a || ((v = a == null ? void 0 : a.series) == null ? void 0 : v.length) < 2)
    return;
  const s = a.barHasBorder === "true" ? 1 : 0, p = e / 2, y = 1.02, g = {
    parentKey: (A = a.dataDescription) == null ? void 0 : A.seriesKey,
    dataKey: a.series[0].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[0].dataKey] || a.series[0].dataKey,
    color: i(a.runtime.seriesLabels[a.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((T) => T[a.series[0].dataKey])
    ),
    labelColor: ""
  }, b = {
    parentKey: (P = a.dataDescription) == null ? void 0 : P.seriesKey,
    dataKey: a.series[1].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[1].dataKey] || a.series[1].dataKey,
    color: i(a.runtime.seriesLabels[a.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((T) => T[a.series[1].dataKey])
    ),
    labelColor: ""
  }, w = Vn({
    domain: [0, Math.max(g.max * y, b.max * 1.1)],
    range: [0, p]
  });
  g.labelColor = g.color ? al("#000", g.color) : "#000", b.labelColor = b.color ? al("#000", b.color) : "#000";
  const S = a.yAxis.label ? `${a.yAxis.label}: ` : "", L = (T) => {
    var _;
    return `<p>
				${(_ = a.dataDescription) == null ? void 0 : _.seriesKey}: ${g.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${T[a.xAxis.dataKey]}<br/>
				${S}${d(T[g.dataKey], "left")}
			</p>`;
  }, m = (T) => {
    var _;
    return `<p>
				${(_ = a.dataDescription) == null ? void 0 : _.seriesKey}: ${b.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${T[a.xAxis.dataKey]}<br/>
				${S}${d(T[b.dataKey], "left")}
			</p>`;
  };
  return e > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				`), /* @__PURE__ */ n.createElement(
    "svg",
    {
      id: "cdc-visualization__paired-bar-chart",
      width: r,
      height: t,
      viewBox: `0 0 ${e + Number(a.runtime.yAxis.size)} ${t}`,
      role: "img",
      tabIndex: 0
    },
    /* @__PURE__ */ n.createElement("title", null, `Paired bar chart graphic with the title ${a.title ? a.title : "No Title Found"}`),
    /* @__PURE__ */ n.createElement(tt, { top: 0, left: Number(a.xAxis.size) }, o.filter((T) => a.series[0].dataKey === g.dataKey).map((T, _) => {
      var B, X;
      let M = a.legend.behavior === "highlight" && c.length > 0 && c.indexOf(a.series[0].dataKey) === -1, Z = a.legend.behavior === "highlight" || c.length === 0 || c.indexOf(a.series[0].dataKey) !== -1, Y = w(T[a.series[0].dataKey]), ae = Number(a.barHeight) ? Number(a.barHeight) : 25, j = 0;
      j = _ !== 0 ? (Number(a.barSpace) + ae + s) * _ : j;
      const q = (Number(a.barSpace) + ae + s) * o.length;
      a.heights.horizontal = q;
      const le = hr(d(T[g.dataKey], "left")) < Y - 5;
      return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(tt, { key: `group-${g.dataKey}-${T[a.xAxis.dataKey]}`, className: "horizontal" }, /* @__PURE__ */ n.createElement(
        Rr,
        {
          id: `bar-${g.dataKey}-${T[(B = a.dataDescription) == null ? void 0 : B.xKey]}`,
          className: "bar group-1",
          key: `bar-${g.dataKey}-${T[(X = a.dataDescription) == null ? void 0 : X.xKey]}`,
          x: p - Y,
          y: j,
          width: w(T[a.series[0].dataKey]),
          height: ae,
          fill: g.color,
          "data-tooltip-html": L(T),
          "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
          stroke: "#333",
          strokeWidth: s,
          opacity: M ? 0.5 : 1,
          display: Z ? "block" : "none",
          tabIndex: -1
        }
      ), a.yAxis.displayNumbersOnBar && Z && /* @__PURE__ */ n.createElement(
        ct,
        {
          textAnchor: le ? "start" : "end",
          dx: le ? 5 : -5,
          verticalAnchor: "middle",
          x: p - Y,
          y: j + a.barHeight / 2,
          fill: le ? g.labelColor : "#000"
        },
        d(T[g.dataKey], "left")
      )));
    }), o.filter((T) => a.series[1].dataKey === b.dataKey).map((T, _) => {
      var B, X, ue;
      let M = w(T[a.series[1].dataKey]), Z = a.legend.behavior === "highlight" && c.length > 0 && c.indexOf(a.series[1].dataKey) === -1, Y = a.legend.behavior === "highlight" || c.length === 0 || c.indexOf(a.series[1].dataKey) !== -1, ae = a.barHeight ? Number(a.barHeight) : 25, j = 0;
      j = _ !== 0 ? (Number(a.barSpace) + ae + s) * _ : j;
      const q = (Number(a.barSpace) + ae + s) * o.length;
      a.heights.horizontal = q;
      const le = hr(d(T[b.dataKey], "left")) < M - 5;
      return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `
                      .bar-${b.dataKey}-${T[a.xAxis.dataKey]} {
                          transform-origin: ${p}px ${j}px
                      }
							      `), /* @__PURE__ */ n.createElement(tt, { key: `group-${b.dataKey}-${T[(B = a.dataDescription) == null ? void 0 : B.xKey]}`, className: "horizontal" }, /* @__PURE__ */ n.createElement(
        Rr,
        {
          id: `bar-${b.dataKey}-${T[(X = a.dataDescription) == null ? void 0 : X.xKey]}`,
          className: "bar group-2",
          key: `bar-${b.dataKey}-${T[(ue = a.dataDescription) == null ? void 0 : ue.xKey]}`,
          x: p,
          y: j,
          width: w(T[a.series[1].dataKey]),
          height: ae,
          fill: b.color,
          "data-tooltip-html": m(T),
          "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
          strokeWidth: s,
          stroke: "#333",
          opacity: Z ? 0.5 : 1,
          display: Y ? "block" : "none",
          tabIndex: -1
        }
      ), a.yAxis.displayNumbersOnBar && Y && /* @__PURE__ */ n.createElement(
        ct,
        {
          textAnchor: le ? "end" : "start",
          dx: le ? -5 : 5,
          verticalAnchor: "middle",
          x: p + M,
          y: j + a.barHeight / 2,
          fill: le ? b.labelColor : "#000"
        },
        d(T[b.dataKey], "left")
      )));
    }))
  ));
}, Mk = ({ yMax: e, leftSize: t, max: r, xMax: a }) => {
  var m;
  const { config: i } = se.useContext(ft), { orientation: o } = i, d = (v, A = "#f1f1f1") => {
    try {
      return Ua(v).hex();
    } catch {
      return A;
    }
  }, c = (m = i.yAxis) == null ? void 0 : m.categories, y = ((v) => {
    const A = Object.keys(v), P = A[A.length - 1];
    if (v[P] === "") {
      const T = A.slice(0, -1).reduce((M, Z) => {
        const Y = Number(v[Z]);
        return M + (isNaN(Y) ? 0 : Y);
      }, 0), _ = r - T;
      v[P] = _;
    }
    return [v];
  })(((v) => [...v].reduce((P, T) => (P[T.label] = T.height, P), {}))(c)), g = 0, b = dc({
    domain: [g],
    padding: 0,
    range: [0, t]
  }), w = Vn({
    domain: [0, r],
    range: [e, 0],
    clamp: !0
  }), S = gp({
    domain: c.map((v) => v == null ? void 0 : v.label),
    range: c.map((v) => {
      var A;
      return d((A = v == null ? void 0 : v.color) == null ? void 0 : A.trim());
    })
  }), L = Object.keys(y[0]);
  return /* @__PURE__ */ n.createElement(tt, { left: t - b.bandwidth(), top: 0 }, /* @__PURE__ */ n.createElement(
    My,
    {
      data: y,
      keys: L,
      x: () => b(g),
      xScale: b,
      yScale: w,
      color: S
    },
    (v) => v.map(
      (A) => A.bars.map((P) => {
        const T = i.yAxis.categories.length - 1 === A.index, _ = Lc / 1.3, M = Ua(P.color).luminance() < 0.4 ? "#fff" : "#000", Z = hr(P.key), Y = Number(Z) < P.width && P.height > _, ae = `<ul>
              <li class="tooltip-heading""> Label : ${P.key}  </li>
                    </li></ul>`;
        return /* @__PURE__ */ n.createElement(tt, { key: `${A.index}--${P.index}--${o}` }, /* @__PURE__ */ n.createElement(
          tt,
          {
            key: `bar-stack-${A.index}-${P.index}`,
            id: `barStack${A.index}-${P.index}`,
            className: "stack vertical"
          },
          Ds({
            type: "axisBar",
            config: i,
            index: A.index,
            background: S(P.key),
            borderColor: "#333",
            borderStyle: "solid",
            borderWidth: 0,
            width: b.bandwidth(),
            height: P.height,
            x: P.x,
            y: P.y,
            tooltipHtml: ae,
            tooltipId: `cdc-open-viz-tooltip-${i.runtime.uniqueId}`
          }),
          /* @__PURE__ */ n.createElement(
            ct,
            {
              display: Y ? "block" : "none",
              key: `text-${A.index}-${P.index}`,
              x: P.x + b.bandwidth() / 2,
              y: P.y + P.height / 2,
              fill: M,
              textAnchor: "middle",
              verticalAnchor: "middle",
              style: { fontSize: _ }
            },
            P.key
          ),
          i.runtime.yAxis.gridLines && /* @__PURE__ */ n.createElement(
            cn,
            {
              from: { x: P.x + b.bandwidth(), y: P.y },
              to: { x: a + b.bandwidth(), y: P.y },
              stroke: "#d6d6d6"
            }
          ),
          !T && /* @__PURE__ */ n.createElement("rect", { x: P.x, y: P.y, width: P.width, height: 1, fill: "#fff" }),
          /* @__PURE__ */ n.createElement("rect", { x: P.x + P.width, y: 0, width: 1, height: e, fill: "#000" })
        ));
      })
    )
  ));
};
function zk({ orientation: e, heights: t, visualizationType: r }, a) {
  const o = e === "vertical" || r === "Forest Plot", c = (t == null ? void 0 : t.mobileVertical) && yf(a) ? "mobileVertical" : "vertical";
  return o ? c : "horizontal";
}
function Bk({ heights: e, orientation: t, visualizationType: r }, a) {
  if (!e)
    return 0;
  const i = zk({ orientation: t, heights: e, visualizationType: r }, a), o = Number(e == null ? void 0 : e[i]);
  return isNaN(o) ? 0 : o;
}
const fg = ({ config: e, minValue: t, maxValue: r, existPositiveValue: a, data: i, isAllLine: o, tableData: d }) => {
  let c = 0, s = 0, p = 0, y = 0;
  if (!i)
    return { min: c, max: s };
  const g = () => Hc(e.visualizationType, i, e.allowLineToBarGraph), { visualizationType: b, series: w } = e, { max: S, min: L } = e.runtime.yAxis, m = e.yAxis.enablePadding ? 1 + e.yAxis.scalePadding / 100 : 1, v = e.yAxis.type === "logarithmic", A = a ? Number(S) >= r : Number(S) >= 0, P = v ? Number(L) >= 0 : Number(L) <= 0 && t >= 0 || Number(L) <= t && t < 0;
  c = L && P ? Number(L) : t, s = S && A ? Number(S) : Number.MIN_VALUE;
  const { lower: T, upper: _ } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (T && _ && e.visualizationType === "Bar") {
    const M = c < 0 ? 1.1 : 0, Z = Math.max(...i.flatMap((ae) => [ae[_], ae[T]])) * m, Y = Math.min(...i.flatMap((ae) => [ae[_], ae[T]])) * m * M;
    s = s > Z ? s : Z, c = c < Y ? c : Y;
  }
  if (e.series.filter((M) => (M == null ? void 0 : M.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: M }
    } = e;
    if ((M == null ? void 0 : M.length) > 0) {
      let Z = [];
      M.forEach((q) => {
        var te;
        (te = q.confidenceIntervals) == null || te.map((le) => {
          Z.push(le.high), Z.push(le.low);
        });
      });
      const Y = i.map((q) => Z.map((te) => q[te])), ae = Math.max.apply(
        null,
        Y.map((q) => q[0])
      ), j = Math.min.apply(
        null,
        Y.map((q) => q[1])
      );
      ae > s && (s = ae), j < c && (c = j);
    }
  }
  if (b === "Combo")
    try {
      if (!i)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let M = w.filter((ae) => ae.axis === "Left"), Z = w.filter((ae) => ae.axis === "Right");
      const Y = (ae, j, q, te = "left") => {
        let le = 0;
        return (j.map((X) => X.dataKey) || []).forEach((X) => {
          let ue = j.find((W) => W.dataKey === X), ne = ae.map((W) => W[X]), J = Math.max.apply(null, ne);
          e.visualizationSubType === "stacked" && te === "left" && ue.type === "Bar" && (le += J), J > q && (q = J), q < le && (q = le);
        }), q;
      };
      p = Y(i, M, p, "left"), y = Y(i, Z, y, "right"), p < Number(S) && (p = Number(S));
    } catch (M) {
      console.error(M.message);
    }
  if ((b === "Bar" || g() || b === "Combo" && !o) && c > 0 && (c = 0), (e.visualizationType === "Bar" || g() || e.visualizationType === "Combo" && !o) && c < 0 && (c = c * 1.1), e.visualizationType === "Combo" && o && ((L == null || L === "") && c > 0 && (c = 0), L)) {
    const M = v ? Number(L) >= 0 && Number(L) < t : Number(L) < t;
    c = Number(L) && M ? Number(L) : t;
  }
  if (e.visualizationType === "Deviation Bar" && c > 0) {
    const M = Number(L) < Math.min(t, Number(e.xAxis.target));
    c = Number(L) && M ? Number(L) : 0;
  }
  if (e.visualizationType === "Line" && !g()) {
    const M = v ? Number(L) >= 0 && Number(L) < t : Number(L) < t, Z = d == null ? void 0 : d.some((ae, j) => {
      var q;
      return (q = e.preliminaryData) == null ? void 0 : q.some((te) => {
        var ue;
        if (te.type !== "suppression" || !te.style)
          return !1;
        const le = et.pick(ae, (ue = e.runtime) == null ? void 0 : ue.seriesKeys), B = et.values(le).includes(te.value);
        return (te.column ? ae[te.column] === te.value : B) && (j === 0 || j === d.length - 1);
      });
    });
    let Y = e.yAxis.type === "categorical";
    c = L !== "" && M ? Number(L) : Z || Y ? 0 : t;
  }
  if (s === Number.MIN_VALUE && (s = a ? r : 0), e.runtime.yAxis.paddingPercent) {
    let M = (s - c) * e.runtime.yAxis.paddingPercent;
    c -= M, s += M;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const M = i.map((Y) => Y[e.series[0].dataKey]), Z = Math.max(...M).toString().length;
    switch (!0) {
      case (Z > 8 && Z <= 12):
        s = s * 1.3;
        break;
      case (Z > 4 && Z <= 7):
        s = s * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (c < 0 ? (s *= 1 + e.yAxis.scalePadding * 2 / 100, c *= 1 + e.yAxis.scalePadding * 2 / 100) : s *= 1 + e.yAxis.scalePadding / 100), e.visualizationType === "Area Chart" && e.visualizationSubType === "stacked" && (c = 0), e.visualizationType === "Scatter Plot" && (s = s * 1.1), { min: c, max: s, leftMax: p, rightMax: y };
}, Qr = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, Ik = (e) => {
  let { xAxisDataMapped: t, xMax: r, yMax: a, min: i, max: o, config: d, data: c } = e;
  const { rawData: s, dimensions: p } = se.useContext(ft), [y] = p, g = d.runtime.barSeriesKeys || d.runtime.seriesKeys, b = d.runtime.xAxis.type, w = d.orientation === "horizontal", { visualizationType: S, xAxis: L, forestPlot: m } = d;
  let v = null, A = null, P = null, T = null, _ = null, M = null, Z = Vn({
    domain: [0, 100],
    range: [0, r]
  });
  if (w && (v = jk({ min: i * 1.03, ...e }), v.type = d.yAxis.type === "logarithmic" ? Qr.LOG : Qr.LINEAR, A = Kk(b, t), A.rangeRound([0, a]), _ = Yk(g, [0, a])), w || (v = cs(t, [0, r], 1 - d.barThickness), A = Uk(e), _ = cs(g, [0, v.bandwidth()], 0)), d.xAxis.type === "date" && !w) {
    const Y = fm(t, d.xAxis.sortByRecentDate);
    v = cs(Y, [0, r], 1 - d.barThickness);
  }
  if (L.type === "date-time" || L.type === "continuous") {
    let Y = Math.min(...t.map(Number)), ae = Math.max(...t.map(Number));
    Y -= (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (ae - Y), ae += S === "Line" ? 0 : (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (ae - Y);
    const j = d.xAxis.sortByRecentDate ? [r, 0] : [0, r];
    v = HE({
      domain: [Y, ae],
      range: j
    }), v.type = Qr.TIME;
    let q = Number.MAX_VALUE, te = fm(t, d.xAxis.sortByRecentDate);
    for (let le = 0; le < te.length - 1; le++) {
      let B = v(te[le + 1]) - v(te[le]);
      B < q && (q = B);
    }
    (t.length === 1 || q > r / 4) && (q = r / 4), _ = cs(g, [0, (d.barThickness || 1) * q], 0);
  }
  if (d.visualizationType === "Deviation Bar") {
    const Y = d.isLollipopChart ? 1.05 : 1.03;
    A = dc({
      domain: t,
      range: [0, a]
    }), v = Vn({
      domain: [i * Y, Math.max(Number(L.target), o)],
      range: [0, r],
      round: !0,
      nice: !0
    }), v.type = Qr.LINEAR;
  }
  if (d.visualizationType === "Scatter Plot" && L.type === "continuous") {
    let Y = L.min ? L.min : Math.min.apply(null, v.domain()), ae = L.max ? L.max : Math.max.apply(null, v.domain());
    v = Vn({
      domain: [Y, ae],
      range: [0, r]
    }), v.type = Qr.LINEAR;
  }
  if (S === "Box Plot") {
    const Y = [];
    if (d.boxplot.plots.map((X) => X.columnOutliers.map((ue) => Y.push(ue))) && !d.boxplot.hideOutliers) {
      let X = Math.min(...Y), ue = Math.max(...Y);
      X < i && (i = X), ue > o && (o = ue);
    }
    let j = Math.min(...d.boxplot.plots.map((X) => X.columnLowerBounds)), q = Math.max(...d.boxplot.plots.map((X) => X.columnUpperBounds));
    j < i && (i = j), q > o && (o = q);
    const te = et.uniq(c.map((X) => X[d.xAxis.dataKey])), le = [0, d.barThickness * 100 || 1], B = et.map(d.series, "dataKey");
    A = Vn({
      range: [a, 0],
      round: !0,
      domain: [i, o]
    }), v = dc({
      range: [0, r],
      domain: te
    }), v.type = Qr.BAND, _ = cs(B, le);
  }
  if (S === "Paired Bar") {
    let ae = Math.max.apply(
      Math,
      c.map((q) => {
        var te;
        return q[(te = d.series[0]) == null ? void 0 : te.dataKey];
      })
    ), j = Math.max.apply(
      Math,
      c.map((q) => {
        var te;
        return q[(te = d.series[1]) == null ? void 0 : te.dataKey];
      })
    );
    T = Vn({
      domain: [0, Math.max(ae, j) * 1.02],
      range: [r / 2, 0]
    }), P = Vn({
      domain: T.domain(),
      range: [r / 2, r],
      nice: !0
    });
  }
  if (S === "Forest Plot") {
    const Y = () => m.regression.showDiamond || m.regression.description ? [0 + m.rowHeight * 2, a - m.rowHeight] : [0 + m.rowHeight * 2, a];
    A = Vn({
      domain: [0, s.length],
      range: Y()
    });
    const ae = 5, j = Number(m.leftWidthOffset) / 100 * r, q = Number(m.rightWidthOffset) / 100 * r, te = Number(m.rightWidthOffsetMobile) / 100 * r, le = Number(m.leftWidthOffsetMobile) / 100 * r;
    if (y > 480) {
      if (m.type === "Linear" && (v = Vn({
        domain: [
          Math.min(...c.map((B) => parseFloat(B[m.lower]))) - ae,
          Math.max(...c.map((B) => parseFloat(B[m.upper]))) + ae
        ],
        range: [j, Number(y) - q]
      }), v.type = Qr.LINEAR), m.type === "Logarithmic") {
        let B = Math.max(...c.map((ue) => parseFloat(ue[m.upper]))), X = Math.min(...c.map((ue) => parseFloat(ue[m.lower])));
        v = fc({
          domain: [X, B],
          range: [j, r - q],
          nice: !0
        }), v.type = Qr.LOG;
      }
    } else if (m.type === "Linear" && (v = Vn({
      domain: [
        Math.min(...c.map((B) => parseFloat(B[m.lower]))) - ae,
        Math.max(...c.map((B) => parseFloat(B[m.upper]))) + ae
      ],
      range: [le, r - te],
      type: Qr.LINEAR
    })), m.type === "Logarithmic") {
      let B = Math.max(...c.map((ue) => parseFloat(ue[m.upper]))), X = Math.min(...c.map((ue) => parseFloat(ue[m.lower])));
      v = fc({
        domain: [X, B],
        range: [j, r - q],
        nice: !0,
        base: B > 1 ? 10 : 2,
        round: !1,
        type: Qr.LOG
      });
    }
  }
  return { xScale: v, yScale: A, seriesScale: _, g1xScale: T, g2xScale: P, xScaleNoPadding: M, xScaleAnnotation: Z };
}, $k = (e) => {
  const t = new Date(e);
  return new Date(t.getFullYear(), t.getMonth(), 1).getTime();
}, Hk = (e) => (e.includes("%b") || e.includes("%B") || e.includes("%m") || e.includes("%-m") || e.includes("%_m")) && !e.includes("%d") && !e.includes("%-d") && !e.includes("%_d") && !e.includes("%e"), Vk = (e, t, r, a) => {
  const i = t.domain();
  if (t.type === "time") {
    const o = e[e.length - 1], d = e[0], c = (o - d) / (r - 1);
    let s = [];
    for (let p = o; p >= d; p -= c)
      s.push(p);
    return s[s.length - 1] !== d && s.push(d), s.reverse(), Hk(a.xAxis.dateDisplayFormat) && (s = s.map((p) => $k(p))), s;
  }
  if (i.length > 2) {
    const o = r || 1, d = [];
    for (let c = i.length; c > 0; c -= o) {
      const s = Math.max(Math.round(c) - 1, 0);
      d.push(i[s]);
    }
    return d.reverse(), d;
  }
}, Wk = (e, t, r, a) => {
  let i = t.ticks;
  const o = Xy(t.scale, t.numTicks);
  if (o.length < r.length) {
    let d = 0;
    const c = r.indexOf(o[o.length - 1]);
    c < r.length - 1 && (d = e.xAxis.sortByRecentDate ? r.indexOf(o[0]) * -1 : r.length - 1 - c), i = o.map((s) => t.ticks[t.ticks.findIndex((p) => p.value === s) + d]);
  }
  return i.forEach((d, c) => {
    d.formattedValue = a(d.value, c, i);
  }), i;
}, jk = ({ min: e, max: t, xMax: r, config: a }) => {
  const i = a.yAxis.type === "logarithmic";
  return e = i && e >= 0 && e < 1 ? e + 0.1 : e, (i ? fc : Vn)({
    domain: [e, t],
    range: [0, r],
    nice: i,
    zero: i
  });
}, Uk = ({ min: e, max: t, yMax: r, config: a, leftMax: i }) => {
  const o = a.yAxis.type === "logarithmic";
  e = o && e >= 0 && e < 1 ? e + 0.1 : e;
  const d = o ? fc : Vn;
  a.visualizationType === "Combo" && (t = i);
  const c = a.visualizationType === "Bump Chart" ? [1, t] : [e, t], s = a.visualizationType === "Bump Chart" ? [30, r] : [r, 0];
  return d({
    domain: c,
    range: s,
    nice: o,
    zero: o
  });
}, Kk = (e, t) => e === "date" ? Vn({
  domain: [Math.min(...t), Math.max(...t)]
}) : tl({ domain: t, padding: 0.5 }), Yk = (e, t, r = 0) => tl({
  domain: e,
  range: t,
  padding: r
}), cs = (e, t, r = 0) => dc({
  domain: e,
  range: t,
  padding: r
}), fm = (e, t) => !e || e.length === 0 ? [] : e.length === 1 ? e : t ? e.sort((r, a) => Number(a) - Number(r)) : e.sort((r, a) => Number(r) - Number(a));
function Gk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const _s = () => {
  const { config: e } = se.useContext(ft), { visualizationType: t, series: r, orientation: a, visualizationSubType: i } = e, o = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Bump Chart",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], d = [
    "theme-blue",
    "theme-purple",
    "theme-brown",
    "theme-teal",
    "theme-pink",
    "theme-orange",
    "theme-slate",
    "theme-indigo",
    "theme-cyan",
    "theme-green",
    "theme-amber"
  ], c = () => !["Forest Plot", "Sankey"].includes(t), s = () => !!["Scatter Plot"].includes(t), p = () => !!["Scatter Plot"].includes(t), y = () => !["Spark Line"].includes(t), g = () => !["Spark Line"].includes(t), b = () => ![
    "Area Chart",
    "Box Plot",
    "Pie",
    "Scatter Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), w = () => ![
    "Area Chart",
    "Scatter Plot",
    "Box Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), S = () => {
    switch (t) {
      case "Box Plot":
        return !0;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, L = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), m = () => !!["Bar", "Combo", "Line"].includes(e.visualizationType), v = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, A = () => {
    if ((t === "Bar" || "Combo") && i === "regular")
      return !0;
  }, P = () => e.xAxis.type === "categorical" ? !1 : ["Line", "Bar", "Area Chart", "Combo"].includes(t) && a === "vertical", T = () => ["Box Plot", "Scatter Plot", "Pie", "Line"].includes(t) ? !1 : r == null ? void 0 : r.some(
    (De) => De.type === "Bar" || De.type === "Paired Bar" || De.type === "Deviation Bar"
  ), _ = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, M = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: o,
    headerColors: d,
    visCanAnimate: w,
    visHasAnchors: v,
    visHasBarBorders: T,
    visHasDataCutoff: _,
    visHasLabelOnData: b,
    visHasDataSuppression: A,
    visHasLegend: S,
    visHasLegendAxisAlign: () => t === "Bar" && i === "stacked" && e.legend.behavior === "isolate",
    visHasLegendColorCategory: () => {
      var ke;
      return t === "Bar" && i === "regular" && ((ke = e.series) == null ? void 0 : ke.length) === 1;
    },
    visHasBrushChart: P,
    visHasNumbersOnBars: L,
    visHasaAdditionalLabelsOnBars: m,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : a === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsMobileChartHeight: () => !!["Bar", "Line", "Combo", "Area Chart"].includes(t),
    visSupportsDateCategoryAxis: c,
    visSupportsDateCategoryAxisMin: s,
    visSupportsDateCategoryAxisMax: p,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line", "Bump Chart"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !(["Spark Line", "Sankey", "Bump Chart"].includes(t) || e.orientation !== "horizontal"),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: g,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => !!["Line", "Bar", "Combo"].includes(t),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: y,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: M,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const ke = ["Forest Plot"];
      return !(a === "horizontal" || ke.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot", "Bump Chart"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (e.yAxis.type === "categorical" || ["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t) || t === "Bar" && e.tooltips.singleSeries)
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t),
    visSupportsDynamicSeries: () => t === "Line" || t === "Bar" || t === "Scatter Plot" || t === "Area Chart",
    visSupportsYPadding: () => {
      var ke;
      return !e.dataFormat.onlyShowTopPrefixSuffix || !((ke = e.dataFormat.suffix) != null && ke.includes(" "));
    },
    visHasSingleSeriesTooltip: () => t === "Bar" || t === "Line" || t === "Area Chart" && i === "stacked",
    visHasCategoricalAxis: () => {
      if ((t === "Line" || t === "Bar" || t === "Combo" || t === "Area Chart") && e.yAxis.type === "categorical" && a === "vertical")
        return !0;
    }
  };
}, Xk = ({ data: e, xScale: t, yScale: r, config: a, xMax: i, annotationSeriesKey: o }, d) => {
  const { xAxis: c, visualizationType: s, orientation: p } = a, y = (m, v, A, P, T) => {
    let _ = [];
    a.xAxis.type === "date-time" && (v = new Date(v), A = new Date(A), P = P.map((Y) => new Date(Y)), _ = T.ticks().map((Y) => new Date(Y)));
    const M = (m - v) / (A - v), Z = Math.round(M * (P.length - 1));
    return a.xAxis.type === "date-time" ? _[Z] : P[Z];
  }, b = ((m, v = !1) => {
    if (s !== "Pie" && p !== "horizontal") {
      if (a.xAxis.type === "date-time") {
        const A = new Date(t.invert(m)), P = a.data.map((M) => new Date(M[a.xAxis.dataKey]).getTime());
        let T = 1 / 0, _ = null;
        return P.forEach((M) => {
          const Z = Math.abs(A.getTime() - M);
          Z < T && (T = Z, _ = M);
        }), new Date(_).getTime();
      }
      if (a.xAxis.type === "categorical" || s === "Combo" && p !== "horizontal" && s !== "Forest Plot") {
        const P = (t.range()[1] - t.range()[0]) / (t.domain().length + 1), _ = Math.floor((Number(m) - P / 2) / P);
        return t.domain()[_];
      }
      if (a.xAxis.type === "date") {
        const A = y(m, 0, i, t.domain(), t);
        let P = null, T = Number.MAX_VALUE;
        return t.domain().forEach((_) => {
          const M = Math.abs(A - _);
          M < T && (T = M, P = _);
        }), P;
      }
      return m;
    }
  })(d - Number(a.yAxis.size || 0));
  let w = [];
  if (!b)
    return { x: 0, y: 0 };
  c.type === "categorical" && (w = a.data.filter((m) => m[a.xAxis.dataKey] === b)), (c.type === "date" || c.type === "date-time") && (w = a.data.filter((m) => new Date(m[a.xAxis.dataKey]).getTime() === b));
  const S = w[0][o];
  return { x: b, y: S };
}, qk = (e, t, r) => {
  const { connectionLocation: a } = e;
  return a === "right" ? "end" : a === "left" ? "start" : a === "bottom" || a === "top" || t(e.xKey) + e.dx < r.yAxis.size ? "middle" : null;
}, Zk = (e, t, r) => {
  const { connectionLocation: a } = e;
  return a === "top" ? "start" : a === "bottom" ? "end" : a === "right" || a === "left" ? "middle" : t(e.xKey) + e.dx < r.yAxis.size ? "end" : null;
};
const Qk = ({ xScale: e, yScale: t, xScaleAnnotation: r, xMax: a, svgRef: i, onDragStateChange: o }) => {
  const { config: d, dimensions: c, isEditor: s, updateConfig: p, colorScale: y } = se.useContext(ft), { annotations: g } = d, [b] = c, w = s ? Og : Fg;
  return g && g.map((S, L) => {
    var P;
    const m = S.text || "", v = r(S.x), A = () => ({
      __html: Am.sanitize(m)
    });
    return /* @__PURE__ */ n.createElement(
      w,
      {
        width: 200,
        height: b,
        dx: S.dx,
        dy: S.dy,
        x: v,
        y: S.y,
        canEditLabel: S.edit.label || !1,
        canEditSubject: S.edit.subject && S.connectionType !== "none" || !1,
        onDragStart: () => o(!0),
        onDragEnd: (T) => {
          o(!1);
          let _ = [...g];
          if (S.x === r.invert(T.x) && S.y === T.y)
            _[L] = { ..._[L], dx: T.dx, dy: T.dy };
          else if (S.snapToNearestPoint) {
            let M = Xk(
              {
                data: d.data,
                xScale: e,
                yScale: t,
                config: d,
                xMax: a - d.yAxis.size / 2,
                annotationSeriesKey: S.seriesKey
              },
              T.x
            );
            _[L] = {
              ..._[L],
              x: r.invert(e(M.x)),
              y: t(M.y)
            };
          } else
            _[L] = {
              ..._[L],
              x: r.invert(T.x),
              y: T.y
            };
          p({
            ...d,
            annotations: _
          });
        }
      },
      /* @__PURE__ */ n.createElement(
        Dg,
        {
          className: "annotation__desktop-label",
          showAnchorLine: !1,
          horizontalAnchor: qk(S, e, d),
          verticalAnchor: Zk(S, e, d)
        },
        /* @__PURE__ */ n.createElement(
          "div",
          {
            style: {
              borderRadius: 5,
              // Optional: set border radius
              backgroundColor: `rgba(255, 255, 255, ${S != null && S.opacity ? Number(S == null ? void 0 : S.opacity) / 100 : 1})`,
              padding: "10px",
              width: "auto",
              display: d.general.showAnnotationDropdown ? "inline-flex" : "flex",
              justifyContent: "start",
              flexDirection: "row"
            },
            tabIndex: 0,
            "aria-label": `Annotation text that reads: ${S.text}`
          },
          ((P = d == null ? void 0 : d.general) == null ? void 0 : P.showAnnotationDropdown) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("p", { className: "annotation__has-dropdown-number", style: { margin: "2px 6px" } }, L + 1)),
          /* @__PURE__ */ n.createElement("div", { dangerouslySetInnerHTML: A() })
        )
      ),
      S.connectionType === "line" && /* @__PURE__ */ n.createElement(Fp, { type: "line", pathProps: { markerStart: `url(#marker-start--${L})` } }),
      S.connectionType === "elbow" && /* @__PURE__ */ n.createElement(Fp, { type: "elbow", pathProps: { markerStart: `url(#marker-start--${L})` } }),
      S.connectionType === "curve" && /* @__PURE__ */ n.createElement(
        Hr,
        {
          d: `M ${v},${S.y}
                      Q ${v + S.dx / 2}, ${S.y + S.dy / 2 + Number(S == null ? void 0 : S.bezier) || 0} ${v + S.dx},${S.y + S.dy}`,
          stroke: "black",
          strokeWidth: "2",
          fill: "none",
          "marker-start": `url(#marker-start--${L})`
        }
      ),
      S.marker === "circle" && /* @__PURE__ */ n.createElement(
        _g,
        {
          id: `marker-start--${L}`,
          className: "circle-subject",
          stroke: y(S.seriesKey),
          radius: 8
        }
      ),
      S.marker === "arrow" && /* @__PURE__ */ n.createElement(
        Cm,
        {
          fill: "black",
          id: `marker-start--${L}`,
          x: v,
          y: S.y,
          stroke: "#333",
          markerWidth: 10,
          size: 10,
          strokeWidth: 1,
          orient: "auto-start-reverse",
          markerUnits: "userSpaceOnUse"
        }
      ),
      /* @__PURE__ */ n.createElement(
        "circle",
        {
          fill: "white",
          cx: v + S.dx,
          cy: S.y + S.dy,
          r: 16,
          className: "annotation__mobile-label annotation__mobile-label-circle",
          stroke: y(S.seriesKey)
        }
      ),
      /* @__PURE__ */ n.createElement(
        "text",
        {
          height: 16,
          x: v + S.dx,
          y: S.y + S.dy,
          className: "annotation__mobile-label",
          alignmentBaseline: "middle",
          textAnchor: "middle"
        },
        L + 1
      )
    );
  });
};
const Jk = ({ useBootstrapVisibilityClasses: e = !0 }) => {
  const { config: t } = se.useContext(ft), r = t.annotations || [], a = () => {
    const o = ["annotation-list"];
    return e && o.push("d-block", "d-md-none"), o.join(" ");
  }, i = r.map((o, d) => {
    const c = o.text || "", s = () => ({
      __html: Am.sanitize(c)
    });
    return /* @__PURE__ */ n.createElement("li", { key: "annotation-li-item__annotationIndex" }, /* @__PURE__ */ n.createElement("div", { className: "annotation__title-wrapper" }, /* @__PURE__ */ n.createElement("div", { className: "annotation__title-circle" }, d + 1), /* @__PURE__ */ n.createElement("p", { className: "annotation__subtext", dangerouslySetInnerHTML: s() })));
  });
  return /* @__PURE__ */ n.createElement("ul", { className: a() }, i);
};
const ew = () => {
  var s;
  const { currentViewport: e, config: t } = se.useContext(ft), [r, a] = se.useState(!1), i = ["sm", "xs", "xxs"].includes(e) ? "13px" : `${Lc}px`;
  se.useContext(ft);
  const o = {
    maxHeight: t.table.limitHeight && `${t.table.height}px`,
    OverflowY: "scroll"
  }, d = () => {
    const p = ["data-table-heading", "annotation__dropdown-list", "p-3"];
    return r || p.push("collapsed"), p.join(" ");
  }, c = () => {
    const p = ["data-table-container", e, "d-block", "d-lg-none", "w-100"];
    return t.general.showAnnotationDropdown && (p.push("d-lg-block"), p.splice(p.indexOf("d-lg-none"), 1)), p.join(" ");
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("section", { className: c() }, /* @__PURE__ */ n.createElement(
    "div",
    {
      style: { fontSize: i },
      role: "button",
      className: d(),
      onClick: () => {
        a(!r);
      },
      tabIndex: 0,
      onKeyDown: (p) => {
        p.keyCode === 13 && a(!r);
      }
    },
    /* @__PURE__ */ n.createElement(Ue, { display: r ? "minus" : "plus", base: !0 }),
    t.general.annotationDropdownText === "" ? "Annotations" : (s = t == null ? void 0 : t.general) == null ? void 0 : s.annotationDropdownText
  ), r && /* @__PURE__ */ n.createElement("div", { className: "table-container annotation-dropdown__panel", style: o }, /* @__PURE__ */ n.createElement(kp.List, { useBootstrapVisibilityClasses: !1 }))));
}, kp = {
  Draggable: Qk,
  // Mobile auto display
  List: Jk,
  // Desktop Accessible Option
  Dropdown: ew
}, tw = ({ axis: e, max: t, runtime: r, currentViewport: a, isHorizontal: i, data: o, config: d, min: c }) => {
  let { numTicks: s } = r[e];
  r[e].viewportNumTicks && r[e].viewportNumTicks[a] && (s = r[e].viewportNumTicks[a]);
  let p;
  return e === "yAxis" && (p = i && !s ? o.length : i && s ? s : !i && !s ? void 0 : !i && s && s, p === void 0 && !d.dataFormat.roundTo && (Number(t) <= 3 ? p = 2 : p = 4), Number(p) > Number(t) && !i && (p = Number(c) < 0 ? Math.round(t) * 2 : Math.round(t))), e === "xAxis" && (p = i && !s ? void 0 : i && s ? s : !i && !s ? void 0 : !i && s && s, i && p === void 0 && !d.dataFormat.roundTo && (t <= 3 ? p = 2 : p = 4), d.visualizationType === "Forest Plot" && (p = d.yAxis.numTicks !== "" ? d.yAxis.numTicks : 4)), p;
}, uf = 9, cf = 4.5, df = 8, nw = 1e3 * 60 * 60 * 24 * 30, rw = 16, aw = 13, iw = 18, ow = 14, lw = 4.5, ff = se.forwardRef(({ parentHeight: e, parentWidth: t }, r) => {
  var ir, Zn, Qn, x, D;
  const {
    brushConfig: a,
    colorScale: i,
    config: o,
    currentViewport: d,
    dimensions: c,
    formatDate: s,
    formatNumber: p,
    handleChartAriaLabels: y,
    handleLineType: g,
    handleDragStateChange: b,
    isDraggingAnnotation: w,
    legendRef: S,
    parseDate: L,
    parentRef: m,
    tableData: v,
    transformedData: A,
    updateConfig: P,
    seriesHighlight: T
  } = se.useContext(ft), {
    heights: _,
    visualizationType: M,
    visualizationSubType: Z,
    orientation: Y,
    xAxis: ae,
    yAxis: j,
    runtime: q,
    legend: te,
    forestPlot: le,
    brush: B,
    dataFormat: X,
    debugSvg: ue
  } = o, { suffix: ne, onlyShowTopPrefixSuffix: J } = X, { labelsAboveGridlines: W, hideAxis: K } = o.yAxis, { minValue: ee, maxValue: $, existPositiveValue: pe, isAllLine: ve } = Vc(o, A), { visSupportsReactTooltip: Te } = _s(), { hasTopAxis: ye } = Gk(o), [Re, Xe] = se.useState(!1), [Ce, xe] = se.useState({ x: 0, y: 0 }), [Pe, de] = se.useState(0), [Be, Ne] = se.useState(0), He = se.useRef(null), Ze = se.useRef(null), $e = se.useRef(null), Ye = se.useRef(null), qe = se.useRef(), Ve = se.useRef([]), Ge = se.useRef(null), ke = se.useRef($), De = hp(qe, {
    freezeOnceVisible: !1
  }), at = !0, be = Y === "horizontal" || o.visualizationType === "Forest Plot", nt = o.yAxis.type === "logarithmic", st = M === "Forest Plot", lt = o.xAxis.type === "date-time", St = !ne.includes(" "), Ut = J && !St, It = Number(Y === "horizontal" ? o.xAxis.size : o.yAxis.size), _t = isNaN(parseInt(`${q.yAxis.labelOffset}`)) ? 0 : parseInt(`${q.yAxis.labelOffset}`), Rt = yf(d) ? aw : rw, Lt = yf(d) ? ow : iw, $t = `normal ${Rt}px Nunito, sans-serif`, Dt = st ? o.data.length * o.forestPlot.rowHeight : 0, Gt = se.useMemo(
    () => Bk(o, d),
    [o, d, e, (ir = o.heights) == null ? void 0 : ir.vertical, (Zn = o.heights) == null ? void 0 : Zn.horizontal]
  ), An = se.useMemo(() => Gt + Dt, [Gt, Dt]), Ot = se.useMemo(() => {
    var Q;
    const N = c[0], U = te == null ? void 0 : te.hide, fe = ["bottom", "top"].includes((Q = o.legend) == null ? void 0 : Q.position), O = Va(d);
    if (!(!st && !U && !fe && !O))
      return N;
    if (S.current) {
      const ge = getComputedStyle(S.current);
      return N - S.current.getBoundingClientRect().width - parseInt(ge.marginLeft) - parseInt(ge.marginRight);
    }
    return N * 0.73;
  }, [c[0], o.legend, d, S.current]), Xt = se.useMemo(() => {
    var U;
    return Ve.current = (U = Ve.current) == null ? void 0 : U.filter((fe) => fe), Ve.current.length ? Math.max(...Ve.current.map((fe) => fe.getBBox().height)) + cf + df : void 0;
  }, [c[0], o.xAxis, Ve.current, o.xAxis.tickRotation]), ht = Ot - q.yAxis.size - (M === "Combo" ? o.yAxis.rightAxisSize : 0), Je = Gt + Dt, Zt = o.filters && o.filters.values.length === 0 && A.length === 0, dn = (N) => Rn(o.runtime.xAxis) ? L(N[o.runtime.originalXAxis.dataKey]).getTime() : N[o.runtime.originalXAxis.dataKey], gn = (N, U) => N[U], fn = o.brush.active && ((Qn = a.data) != null && Qn.length) ? a.data.map((N) => dn(N)) : A.map((N) => dn(N)), vt = o.orientation === "horizontal" || o.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", Ft = {
    data: A,
    tableData: v,
    config: {
      ...o,
      yAxis: {
        ...o.yAxis,
        scalePadding: Ut ? Be : o.yAxis.scalePadding,
        enablePadding: Ut || o.yAxis.enablePadding
      }
    },
    minValue: ee,
    maxValue: $,
    isAllLine: ve,
    existPositiveValue: pe,
    xAxisDataMapped: fn,
    xMax: ht,
    yMax: Je
  }, { min: mt, max: pn, leftMax: Sn, rightMax: kt } = fg(Ft), { yScaleRight: wt, hasRightAxis: kn } = Ep({ config: o, yMax: Je, data: A, updateConfig: P }), { xScale: xt, yScale: Pt, seriesScale: bn, g1xScale: On, g2xScale: _e, xScaleNoPadding: Oe, xScaleAnnotation: Se } = Ik({
    ...Ft,
    min: mt,
    max: pn,
    leftMax: Sn,
    rightMax: kt,
    dimensions: c,
    xMax: t - Number(o.orientation === "horizontal" ? o.xAxis.size : o.yAxis.size)
  }), [ut, Kt] = ["yAxis", "xAxis"].map(
    (N) => tw({ axis: N, max: pn, runtime: q, currentViewport: d, isHorizontal: be, data: A, config: o, min: mt })
  ), Ht = st ? o.data.length : ut, { tooltipData: yt, showTooltip: Bt, hideTooltip: bt, tooltipOpen: Tt, tooltipLeft: Pn, tooltipTop: tn } = By(), {
    handleTooltipMouseOver: Qt,
    handleTooltipClick: Nt,
    handleTooltipMouseOff: Jt,
    TooltipListItem: wn,
    getXValueFromCoordinate: on
  } = Wy({
    xScale: xt,
    yScale: Pt,
    showTooltip: Bt,
    hideTooltip: bt
  }), { dataKey: Wn } = q.xAxis, Ln = A.length && lt ? [0, A.length - 1].map((N) => L(A[N][Wn])).reduce((N, U) => Math.abs(N - U)) / nw : 0, Tn = lt && Ln > Kt, ln = () => Hc(o.visualizationType, A, o.allowLineToBarGraph), Dn = (N, U, fe) => {
    if (nt && N === 0.1 && (N = 0), !(o.data && !o.data[U] && M === "Forest Plot"))
      return o.visualizationType === "Forest Plot" ? o.data[U][o.xAxis.dataKey] : Rn(q.yAxis) ? s(L(N)) : Y === "vertical" && pn - mt < 3 ? p(N, "left", at, !1, !1, "1", { index: U, length: fe.length }) : Y === "vertical" ? p(N, "left", at, !1, !1, void 0, { index: U, length: fe.length }) : N;
  }, _n = (N, U, fe) => (nt && N === 0.1 && (N = 0), Rn(q.xAxis) && o.visualizationType !== "Forest Plot" ? s(N, U, fe) : Y === "horizontal" && o.visualizationType !== "Forest Plot" ? p(N, "left", at) : o.xAxis.type === "continuous" && o.visualizationType !== "Forest Plot" ? p(N, "bottom", at) : o.visualizationType === "Forest Plot" ? p(
    N,
    "left",
    o.dataFormat.abbreviated,
    o.runtime.xAxis.prefix,
    o.runtime.xAxis.suffix,
    Number(o.dataFormat.roundTo)
  ) : N), Fn = () => {
    const { visualizationType: N } = o;
    return N === "Combo" && q.forecastingSeriesKeys > 0 || N === "Area Chart" || N === "Line" || N === "Bar";
  }, Kn = () => {
    let N = o.xAxis.manualStep;
    return o.xAxis.viewportStepCount && o.xAxis.viewportStepCount[d] && (N = o.xAxis.viewportStepCount[d]), N;
  }, sn = (N) => {
    const U = N.currentTarget.getBoundingClientRect(), fe = N.clientX - U.left, O = N.clientY - U.top;
    xe({
      x: fe,
      y: O
    });
  };
  se.useEffect(() => {
    document.querySelector(".isEditor") && Xe((U) => !0);
  }), se.useEffect(() => {
    (De == null ? void 0 : De.isIntersecting) === !0 && o.animate && setTimeout(() => {
      Xe((N) => !0);
    }, 500);
  }, [De == null ? void 0 : De.isIntersecting, o.animate]), se.useEffect(() => {
    const N = $e.current;
    if (!N && !Pe)
      return;
    if (!N)
      return de(0);
    const U = N.getBBox().width;
    de(U);
  }, [o.dataFormat.suffix, o.dataFormat.onlyShowTopPrefixSuffix]), se.useEffect(() => {
    if (!st || ae.hideLabel)
      return;
    const N = Ze.current;
    if (!N)
      return;
    const U = Je + Number(o.xAxis.axisPadding), O = N.getBBox().y - U + N.getBBox().height + uf;
    Ge.current && Ge.current.setAttribute("y", O);
  }, [(x = o == null ? void 0 : o.data) == null ? void 0 : x.length, Dt]), se.useEffect(() => {
    if (!He.current)
      return;
    const N = He.current.getBBox().height, U = M === "Forest Plot", fe = Ye.current && j.labelsAboveGridlines, O = B != null && B.active ? B == null ? void 0 : B.height : 0, I = U ? o.data.length * le.rowHeight : 0, Q = fe ? Ye.current.getBBox().height : 0, ge = N + O + I + Q, ze = Gt + ge;
    if (!m.current || (m.current.style.height = `${ze}px`, !Q))
      return;
    const Ke = r.current;
    if (!Ke)
      return;
    const ot = m.current.getBoundingClientRect().width;
    if (Ke.setAttribute("viewBox", `0 ${-Q} ${ot} ${ze}`), !S.current)
      return;
    const Yt = (te == null ? void 0 : te.position) !== "top" && (te == null ? void 0 : te.position) !== "bottom" && !Va(d);
    S.current.style.transform = Yt ? `translateY(${Q}px)` : "none";
  }, [He.current, o, Xt, B, d, Ye.current, Gt]), se.useEffect(() => {
    ke.current !== $ && (ke.current = $, Be && Ne(0));
  }, [$]), se.useEffect(() => {
    if (Y === "horizontal" || !Ut)
      return;
    const N = 0.025, fe = Math.max(...Pt.ticks(Ht)) - $ * N;
    if (!($ > fe))
      return;
    const I = Pt.ticks(Ht), Q = I.length === 1 ? I[0] : I[1] - I[0], ge = Math.max(...Pt.ticks(Ht)) + Q, ze = ee < 0 ? $ / 2 : $, Ke = (ge - $) / ze, ot = Ke > N ? Ke : Ke + Q / ze;
    Ne(ot * 100 + 0.1);
  }, [$, Ut, Pt, Ht]);
  const hn = () => {
    const N = Xt + uf, U = (fe, O) => {
      if (!fe.length)
        return !1;
      const I = fe.filter((rn) => rn.index !== 0), Q = I == null ? void 0 : I.length, ge = O.range()[0] || ht / 2, ze = I.map(
        (rn) => hr(p(rn.value, "left"), $t)
      ), Ke = 100, ot = ze.reduce((rn, an) => rn + an, Ke), Yt = (ge - ot) / Q;
      let Vt = [0];
      for (let rn = 1; rn < ze.length; rn++)
        Vt[rn] = Vt[rn - 1] + ze[rn - 1] + Yt;
      let nn = !1;
      return ze.forEach((rn, an) => {
        if (Vt[an] + ze[an] > Vt[an + 1]) {
          nn = !0;
          return;
        }
      }), nn;
    };
    return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      ju,
      {
        top: Je,
        left: Number(q.yAxis.size),
        label: q.xAxis.label,
        tickFormat: Rn(q.xAxis) ? s : p,
        scale: On,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: q.xAxis.numTicks || void 0
      },
      (fe) => /* @__PURE__ */ n.createElement(tt, { className: "bottom-axis" }, fe.ticks.map((O, I) => {
        const Q = U(fe.ticks, On), ge = Number(o.xAxis.maxTickRotation) || 90, ze = o.isResponsiveTicks && Q, Ke = O.index !== 0 && (ze ? ge : Number(o.yAxis.tickRotation)), ot = Ke && O.index !== 0 ? "end" : "middle";
        return /* @__PURE__ */ n.createElement(tt, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !q.yAxis.hideTicks && /* @__PURE__ */ n.createElement(cn, { from: O.from, to: O.to, stroke: "#333" }), !q.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          ct,
          {
            innerRef: (Yt) => Ve.current[I] = Yt,
            x: O.to.x,
            y: O.to.y,
            angle: -Ke,
            verticalAnchor: Ke ? "middle" : "start",
            textAnchor: ot,
            fontSize: Rt
          },
          p(O.value, "left")
        ));
      }), !q.yAxis.hideAxis && /* @__PURE__ */ n.createElement(cn, { from: fe.axisFromPoint, to: fe.axisToPoint, stroke: "#333" }))
    ), /* @__PURE__ */ n.createElement(
      ju,
      {
        innerRef: He,
        top: Je,
        left: Number(q.yAxis.size),
        label: q.xAxis.label,
        tickFormat: Rn(q.xAxis) ? s : q.xAxis.dataKey !== "Year" ? p : (fe) => fe,
        scale: _e,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: q.xAxis.numTicks || void 0
      },
      (fe) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(tt, { className: "bottom-axis" }, fe.ticks.map((O, I) => {
        const Q = U(fe.ticks, _e), ge = Number(o.xAxis.maxTickRotation) || 90, ze = o.isResponsiveTicks && Q, Ke = O.index !== 0 && (ze ? ge : Number(o.yAxis.tickRotation)), ot = Ke && O.index !== 0 ? "end" : "middle";
        return I ? /* @__PURE__ */ n.createElement(tt, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !q.yAxis.hideTicks && /* @__PURE__ */ n.createElement(cn, { from: O.from, to: O.to, stroke: "#333" }), !q.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          ct,
          {
            x: O.to.x,
            y: O.to.y + cf,
            angle: -Ke,
            verticalAnchor: Ke ? "middle" : "start",
            textAnchor: ot,
            fontSize: Rt
          },
          p(O.value, "left")
        )) : /* @__PURE__ */ n.createElement(n.Fragment, null);
      }), !q.yAxis.hideAxis && /* @__PURE__ */ n.createElement(cn, { from: fe.axisFromPoint, to: fe.axisToPoint, stroke: "#333" })), /* @__PURE__ */ n.createElement(tt, null, /* @__PURE__ */ n.createElement(
        ct,
        {
          className: "x-axis-title-label",
          x: ht / 2,
          y: N,
          stroke: "#333",
          textAnchor: "middle",
          verticalAnchor: "start",
          fontSize: Lt
        },
        q.xAxis.label
      )))
    ));
  };
  return isNaN(Ot) ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(Vr, { component: "LinearChart" }, /* @__PURE__ */ n.createElement(
    "div",
    {
      style: { width: `${t}px`, overflow: "visible", position: "relative" },
      className: "tooltip-boundary"
    },
    /* @__PURE__ */ n.createElement(
      "svg",
      {
        ref: r,
        onMouseMove: sn,
        width: t,
        height: Zt ? 1 : e,
        className: `linear ${o.animate ? "animated" : ""} ${Re && o.animate ? "animate" : ""} ${ue && "debug"} ${w && "dragging-annotation"}`,
        role: "img",
        "aria-label": y(o),
        style: { overflow: "visible" }
      },
      !w && /* @__PURE__ */ n.createElement(Rr, { width: t, height: Gt, fill: "transparent" }),
      " ",
      !["Spark Line", "Forest Plot"].includes(M) && o.yAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(
        am,
        {
          scale: Pt,
          left: Number(q.yAxis.size) - o.yAxis.axisPadding,
          numTicks: Ht
        },
        (N) => {
          const U = o.orientation === "horizontal" ? (N.axisToPoint.y - N.axisFromPoint.y) / 2 : (N.axisFromPoint.y - N.axisToPoint.y) / 2;
          return /* @__PURE__ */ n.createElement(tt, { className: "left-axis" }, N.ticks.map((fe, O) => {
            const I = String(fe.value).startsWith("1") || fe.value === 0.1 ? "block" : "none", Q = fe.index === 0 && fe.value === 0 && o.xAxis.hideAxis;
            return /* @__PURE__ */ n.createElement(tt, { key: `vx-tick-${fe.value}-${O}`, className: "vx-axis-tick" }, q.yAxis.gridLines && !Q ? /* @__PURE__ */ n.createElement(
              cn,
              {
                key: `${fe.value}--hide-hideGridLines`,
                display: (nt && I).toString(),
                from: { x: fe.from.x + ht, y: fe.from.y },
                to: fe.from,
                stroke: "#d6d6d6"
              }
            ) : "");
          }), /* @__PURE__ */ n.createElement(
            ct,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${-1 * q.yAxis.size + _t}, ${U}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.labelColor,
              fontSize: Lt
            },
            N.label
          ));
        }
      ),
      M === "Paired Bar" && hn(),
      M === "Deviation Bar" && ((D = o.runtime.series) == null ? void 0 : D.length) === 1 && /* @__PURE__ */ n.createElement(Ek, { animatedChart: Re, xScale: xt, yScale: Pt, width: ht, height: Je }),
      M === "Paired Bar" && /* @__PURE__ */ n.createElement(Fk, { originalWidth: Ot, width: ht, height: Je }),
      M === "Scatter Plot" && /* @__PURE__ */ n.createElement(
        bk,
        {
          xScale: xt,
          yScale: Pt,
          getXAxisData: dn,
          getYAxisData: gn,
          xMax: ht,
          yMax: Je,
          handleTooltipMouseOver: Qt,
          handleTooltipMouseOff: Jt,
          handleTooltipClick: Nt,
          tooltipData: yt,
          showTooltip: Bt
        }
      ),
      M === "Box Plot" && /* @__PURE__ */ n.createElement(
        xk,
        {
          seriesScale: bn,
          xMax: ht,
          yMax: Je,
          min: mt,
          max: pn,
          xScale: xt,
          yScale: Pt
        }
      ),
      (M === "Area Chart" && o.visualizationSubType === "regular" || M === "Combo") && /* @__PURE__ */ n.createElement(
        ik,
        {
          xScale: xt,
          yScale: Pt,
          yMax: Je,
          xMax: ht,
          chartRef: r,
          width: ht,
          height: Je,
          handleTooltipMouseOver: Qt,
          handleTooltipMouseOff: Jt,
          tooltipData: yt,
          showTooltip: Bt
        }
      ),
      (M === "Area Chart" && o.visualizationSubType === "stacked" || M === "Combo") && /* @__PURE__ */ n.createElement(
        lk,
        {
          xScale: xt,
          yScale: Pt,
          yMax: Je,
          xMax: ht,
          chartRef: r,
          width: ht,
          height: Je,
          handleTooltipMouseOver: Qt,
          handleTooltipMouseOff: Jt,
          tooltipData: yt,
          showTooltip: Bt
        }
      ),
      (M === "Bar" || M === "Combo" || ln()) && /* @__PURE__ */ n.createElement(
        fk,
        {
          xScale: xt,
          yScale: Pt,
          seriesScale: bn,
          xMax: ht,
          yMax: Je,
          getXAxisData: dn,
          getYAxisData: gn,
          animatedChart: Re,
          visible: Re,
          handleTooltipMouseOver: Qt,
          handleTooltipMouseOff: Jt,
          handleTooltipClick: Nt,
          tooltipData: yt,
          showTooltip: Bt,
          chartRef: r
        }
      ),
      (M === "Line" && !ln() || M === "Combo" || M === "Bump Chart") && /* @__PURE__ */ n.createElement(
        dm,
        {
          xScale: xt,
          yScale: Pt,
          getXAxisData: dn,
          getYAxisData: gn,
          xMax: ht,
          yMax: Je,
          seriesStyle: o.runtime.series,
          handleTooltipMouseOver: Qt,
          handleTooltipMouseOff: Jt,
          handleTooltipClick: Nt,
          tooltipData: yt,
          showTooltip: Bt,
          chartRef: r
        }
      ),
      (M === "Forecasting" || M === "Combo") && /* @__PURE__ */ n.createElement(
        kk,
        {
          showTooltip: Bt,
          tooltipData: yt,
          xScale: xt,
          yScale: Pt,
          width: ht,
          le: !0,
          height: Je,
          xScaleNoPadding: Oe,
          chartRef: r,
          getXValueFromCoordinate: on,
          handleTooltipMouseOver: Qt,
          handleTooltipMouseOff: Jt,
          isBrush: !1
        }
      ),
      M === "Forest Plot" && /* @__PURE__ */ n.createElement(
        Ok,
        {
          xScale: xt,
          yScale: Pt,
          seriesScale: bn,
          width: Ot,
          height: An,
          getXAxisData: dn,
          getYAxisData: gn,
          animatedChart: Re,
          visible: Re,
          handleTooltipMouseOver: Qt,
          handleTooltipMouseOff: Jt,
          handleTooltipClick: Nt,
          tooltipData: yt,
          showTooltip: Bt,
          chartRef: r,
          config: o,
          forestPlotRightLabelRef: Ze
        }
      ),
      o.brush.active && o.xAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(rk, { xMax: ht, yMax: Je }),
      !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(
        M
      ) && !ln() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        dm,
        {
          xScale: xt,
          yScale: Pt,
          getXAxisData: dn,
          getYAxisData: gn,
          xMax: ht,
          yMax: Je,
          seriesStyle: o.runtime.series
        }
      )),
      o.yAxis.anchors && o.yAxis.anchors.map((N, U) => {
        let fe = Pt(N.value), O = 0;
        if (N.value && (o.yAxis.labelPlacement === "Below Bar" ? O = -6.5 + Number(o.series.length * o.barHeight) / o.series.length : O = 8, !!fe))
          return (
            // prettier-ignore
            /* @__PURE__ */ n.createElement(
              cn,
              {
                key: `yAxis-${N.value}--${U}`,
                strokeDasharray: g(N.lineStyle),
                stroke: N.color ? N.color : "rgba(0,0,0,1)",
                className: "anchor-y",
                from: { x: 0 + It, y: fe - O },
                to: { x: Ot - o.yAxis.rightAxisSize, y: fe - O }
              }
            )
          );
      }),
      o.xAxis.anchors && o.xAxis.anchors.map((N, U) => {
        let fe = ae;
        Y === "horizontal" && (fe = j);
        let I = (() => {
          let Q;
          return Q = Rn(fe) ? xt(L(N.value, !1)) : xt(N.value), (o.xAxis.type === "categorical" || o.xAxis.type === "date") && (Q = Q ? Q + (fe.type === "categorical" || fe.type === "date" ? xt.bandwidth() : 0) / 2 : 0), Q;
        })();
        if (I)
          return (
            // prettier-ignore
            /* @__PURE__ */ n.createElement(
              cn,
              {
                key: `xAxis-${N.value}--${U}`,
                strokeDasharray: g(N.lineStyle),
                stroke: N.color ? N.color : "rgba(0,0,0,1)",
                fill: N.color ? N.color : "rgba(0,0,0,1)",
                className: "anchor-x",
                from: { x: Number(I) + Number(It), y: 0 },
                to: { x: Number(I) + Number(It), y: Je }
              }
            )
          );
      }),
      o.visualizationType !== "Bar" && o.visualizationType !== "Combo" && /* @__PURE__ */ n.createElement(
        bp,
        {
          xScale: xt,
          handleTooltipClick: Nt,
          handleTooltipMouseOff: Jt,
          handleTooltipMouseOver: Qt,
          showTooltip: Bt,
          hideTooltip: bt,
          tooltipData: yt,
          yMax: Je,
          width: Ot
        }
      ),
      Fn && Bt && yt && o.visual.verticalHoverLine && /* @__PURE__ */ n.createElement(tt, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ n.createElement(
        cn,
        {
          from: { x: yt.dataXPosition - 10, y: 0 },
          to: { x: yt.dataXPosition - 10, y: Je },
          stroke: "black",
          strokeWidth: 1,
          pointerEvents: "none",
          strokeDasharray: "5,5",
          className: "vertical-tooltip-line"
        }
      )),
      Fn && Bt && yt && o.visual.horizontalHoverLine && /* @__PURE__ */ n.createElement(
        tt,
        {
          key: "tooltipLine-horizontal",
          className: "horizontal-tooltip-line",
          left: o.yAxis.size ? o.yAxis.size : 0
        },
        /* @__PURE__ */ n.createElement(
          cn,
          {
            from: { x: 0, y: yt.dataYPosition },
            to: { x: ht, y: yt.dataYPosition },
            stroke: "black",
            strokeWidth: 1,
            pointerEvents: "none",
            strokeDasharray: "5,5",
            className: "horizontal-tooltip-line"
          }
        )
      ),
      Zt && /* @__PURE__ */ n.createElement(
        ct,
        {
          x: Number(o.yAxis.size) + Number(ht / 2),
          y: Gt / 2 - (o.xAxis.padding || 0) / 2,
          textAnchor: "middle"
        },
        o.chartMessage.noData
      ),
      (o.visualizationType === "Bar" || ln()) && o.tooltips.singleSeries && o.visual.horizontalHoverLine && /* @__PURE__ */ n.createElement(
        tt,
        {
          key: "tooltipLine-horizontal",
          className: "horizontal-tooltip-line",
          left: o.yAxis.size ? o.yAxis.size : 0
        },
        /* @__PURE__ */ n.createElement(
          cn,
          {
            from: { x: 0, y: Ce.y },
            to: { x: ht, y: Ce.y },
            stroke: "black",
            strokeWidth: 1,
            pointerEvents: "none",
            strokeDasharray: "5,5",
            className: "horizontal-tooltip-line"
          }
        )
      ),
      (o.visualizationType === "Bar" || ln()) && o.tooltips.singleSeries && o.visual.verticalHoverLine && /* @__PURE__ */ n.createElement(tt, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ n.createElement(
        cn,
        {
          from: { x: Ce.x, y: 0 },
          to: { x: Ce.x, y: Je },
          stroke: "black",
          strokeWidth: 1,
          pointerEvents: "none",
          strokeDasharray: "5,5",
          className: "vertical-tooltip-line"
        }
      )),
      /* @__PURE__ */ n.createElement(tt, { left: Number(o.runtime.yAxis.size) }, /* @__PURE__ */ n.createElement(
        kp.Draggable,
        {
          xScale: xt,
          yScale: Pt,
          xScaleAnnotation: Se,
          xMax: ht,
          svgRef: r,
          onDragStateChange: b
        }
      )),
      !["Spark Line", "Forest Plot"].includes(M) && o.yAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(
        am,
        {
          scale: Pt,
          tickLength: nt ? 6 : 8,
          left: Number(q.yAxis.size) - o.yAxis.axisPadding,
          label: q.yAxis.label || q.yAxis.label,
          stroke: "#333",
          tickFormat: Dn,
          numTicks: Ht
        },
        (N) => {
          const U = o.orientation === "horizontal" ? (N.axisToPoint.y - N.axisFromPoint.y) / 2 : (N.axisFromPoint.y - N.axisToPoint.y) / 2, fe = Je / N.ticks.length / 2 - Je / N.ticks.length * (1 - o.barThickness) + 5;
          return /* @__PURE__ */ n.createElement(tt, { className: "left-axis" }, !o.yAxis.hideAxis && /* @__PURE__ */ n.createElement(
            cn,
            {
              from: N.axisFromPoint,
              to: q.horizontal ? {
                x: 0,
                y: o.visualizationType === "Forest Plot" ? e : Number(_.horizontal)
              } : N.axisToPoint,
              stroke: "#000"
            }
          ), Pt.domain()[0] < 0 && /* @__PURE__ */ n.createElement(
            cn,
            {
              from: { x: N.axisFromPoint.x, y: Pt(0) },
              to: { x: ht, y: Pt(0) },
              stroke: "#333"
            }
          ), M === "Bar" && Y === "horizontal" && xt.domain()[0] < 0 && /* @__PURE__ */ n.createElement(
            cn,
            {
              from: { x: xt(0), y: 0 },
              to: { x: xt(0), y: Je },
              stroke: "#333",
              strokeWidth: 2
            }
          ), N.ticks.map((O, I) => {
            const Q = N.ticks[0].to.y, ge = 15, ze = String(O.value).startsWith("1") || O.value === 0.1 ? "block" : "none", Ke = ze === "block" ? 7 : 0, ot = { x: O.to.x - Ke, y: O.to.y }, Yt = N.ticks.length - 1 === I, Vt = Yt && J && ne && !St, rn = W ? K ? -8 : -12 : lw, an = W ? 4 : 0, jn = O.to.x - rn, Jn = O.to.y - an, er = W ? "end" : "middle", Yn = J && W && ne && Yt;
            return /* @__PURE__ */ n.createElement(tt, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !q.yAxis.hideTicks && !W && !Vt && /* @__PURE__ */ n.createElement(
              cn,
              {
                key: `${O.value}--hide-hideTicks`,
                from: O.from,
                to: nt ? ot : O.to,
                stroke: o.yAxis.tickColor,
                display: Y === "horizontal" ? "none" : "block",
                fontSize: Rt
              }
            ), Y === "horizontal" && Z !== "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              ct,
              {
                transform: `translate(${O.to.x - 5}, ${o.isLollipopChart ? O.to.y - Q : O.to.y - Q + (Number(o.barHeight * o.runtime.series.length) - ge) / 2}) rotate(-${o.runtime.horizontal && o.runtime.yAxis.tickRotation || 0})`,
                verticalAnchor: "start",
                textAnchor: "end",
                fontSize: Rt
              },
              O.formattedValue
            ), Y === "horizontal" && Z === "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              ct,
              {
                transform: `translate(${O.to.x - 5}, ${O.to.y - Q + (Number(o.barHeight) - ge) / 2}) rotate(-${q.horizontal ? q.yAxis.tickRotation : 0})`,
                verticalAnchor: "start",
                textAnchor: "end",
                fontSize: Rt
              },
              O.formattedValue
            ), Y === "horizontal" && M === "Paired Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              ct,
              {
                transform: `translate(${O.to.x - 5}, ${O.to.y - Q + Number(o.barHeight) / 2}) rotate(-${q.horizontal ? q.yAxis.tickRotation : 0})`,
                textAnchor: "end",
                verticalAnchor: "middle",
                fontSize: Rt
              },
              O.formattedValue
            ), Y === "horizontal" && M === "Deviation Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              ct,
              {
                transform: `translate(${O.to.x - 5}, ${o.isLollipopChart ? O.to.y - Q + 2 : O.to.y - Q + Number(o.barHeight) / 2}) rotate(-${q.horizontal ? q.yAxis.tickRotation : 0})`,
                textAnchor: "end",
                verticalAnchor: "middle",
                fontSize: Rt
              },
              O.formattedValue
            ), Y === "vertical" && M === "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
              ct,
              {
                display: o.useLogScale ? ze : "block",
                dx: o.useLogScale ? -6 : 0,
                x: o.runtime.horizontal ? O.from.x + 2 : O.to.x - 8.5,
                y: O.to.y - 13 + (o.runtime.horizontal ? fe : 0),
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: o.runtime.horizontal ? "start" : "middle",
                textAnchor: o.runtime.horizontal ? "start" : "end",
                fill: o.yAxis.tickLabelColor,
                fontSize: Rt
              },
              o.runtime.seriesLabelsAll[O.formattedValue - 1]
            ), (T.length === 0 || T.includes(
              o.runtime.seriesLabelsAll[O.formattedValue - 1]
            )) && /* @__PURE__ */ n.createElement(
              "rect",
              {
                x: 0 - Number(o.yAxis.size),
                y: O.to.y - 8 + (o.runtime.horizontal ? fe : 7),
                width: Number(o.yAxis.size) + xt(xt.domain()[0]),
                height: "2",
                fill: i(o.runtime.seriesLabelsAll[O.formattedValue - 1])
              }
            )), Y === "vertical" && M !== "Paired Bar" && M !== "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(n.Fragment, null, J && Yt && !W && /* @__PURE__ */ n.createElement(
              Wp,
              {
                innerRef: $e,
                display: nt ? ze : "block",
                dx: nt ? -6 : 0,
                x: jn,
                y: Jn,
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: er,
                textAnchor: St ? "end" : "start",
                fill: o.yAxis.tickLabelColor,
                stroke: "#fff",
                paintOrder: "stroke",
                strokeLinejoin: "round",
                style: { whiteSpace: "pre-wrap" },
                fontSize: Rt
              },
              ne
            ), /* @__PURE__ */ n.createElement(
              Wp,
              {
                innerRef: (Er) => Yt && (Ye.current = Er),
                display: nt ? ze : "block",
                dx: nt ? -6 : 0,
                x: St ? jn - Pe : jn,
                y: Jn + (o.runtime.horizontal ? fe : 0),
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: o.runtime.horizontal ? "start" : er,
                textAnchor: o.runtime.horizontal || W ? "start" : "end",
                fill: o.yAxis.tickLabelColor,
                stroke: "#fff",
                disableStroke: !W,
                strokeLinejoin: "round",
                paintOrder: "stroke",
                style: { whiteSpace: "pre-wrap" },
                fontSize: Rt
              },
              `${O.formattedValue}${Yn ? ne : ""}`
            )));
          }), /* @__PURE__ */ n.createElement(
            ct,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${-1 * q.yAxis.size + _t}, ${U}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.labelColor,
              fontSize: Lt
            },
            N.label
          ));
        }
      ),
      o.yAxis.type === "categorical" && o.orientation === "vertical" && /* @__PURE__ */ n.createElement(
        Mk,
        {
          max: pn,
          maxValue: $,
          height: Gt,
          xMax: ht,
          yMax: Je,
          leftSize: Number(q.yAxis.size) - o.yAxis.axisPadding
        }
      ),
      kn && /* @__PURE__ */ n.createElement(
        IS,
        {
          scale: wt,
          left: Number(Ot - o.yAxis.rightAxisSize),
          label: o.yAxis.rightLabel,
          tickFormat: (N) => p(N, "right"),
          numTicks: q.yAxis.rightNumTicks || void 0,
          labelOffset: 45
        },
        (N) => {
          const U = o.orientation === "horizontal" ? (N.axisToPoint.y - N.axisFromPoint.y) / 2 : (N.axisFromPoint.y - N.axisToPoint.y) / 2, fe = Je / N.ticks.length / 2 - Je / N.ticks.length * (1 - o.barThickness) + 5;
          return /* @__PURE__ */ n.createElement(tt, { className: "right-axis" }, N.ticks.map((O, I) => /* @__PURE__ */ n.createElement(tt, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !q.yAxis.rightHideTicks && /* @__PURE__ */ n.createElement(
            cn,
            {
              from: O.from,
              to: O.to,
              display: q.horizontal ? "none" : "block",
              stroke: o.yAxis.rightAxisTickColor
            }
          ), q.yAxis.rightGridLines ? /* @__PURE__ */ n.createElement(cn, { from: { x: O.from.x + ht, y: O.from.y }, to: O.from, stroke: "#d6d6d6" }) : "", !o.yAxis.rightHideLabel && /* @__PURE__ */ n.createElement(
            ct,
            {
              x: O.to.x,
              y: O.to.y + (q.horizontal ? fe : 0),
              verticalAnchor: q.horizontal ? "start" : "middle",
              textAnchor: "start",
              fill: o.yAxis.rightAxisTickLabelColor,
              fontSize: Rt
            },
            O.formattedValue
          ))), !o.yAxis.rightHideAxis && /* @__PURE__ */ n.createElement(cn, { from: N.axisFromPoint, to: N.axisToPoint, stroke: "#333" }), /* @__PURE__ */ n.createElement(
            ct,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${o.yAxis.rightLabelOffsetSize ? o.yAxis.rightLabelOffsetSize : 0}, ${U}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.rightAxisLabelColor,
              fontSize: Lt
            },
            N.label
          ));
        }
      ),
      ye && o.topAxis.hasLine && /* @__PURE__ */ n.createElement(
        WS,
        {
          stroke: "#333",
          left: Number(q.yAxis.size),
          scale: xt,
          hideTicks: !0,
          hideZero: !0,
          tickLabelProps: () => ({
            fill: "transparent"
          })
        }
      ),
      M !== "Paired Bar" && M !== "Spark Line" && /* @__PURE__ */ n.createElement(
        ju,
        {
          innerRef: He,
          top: q.horizontal && o.visualizationType !== "Forest Plot" ? Number(_.horizontal) + Number(o.xAxis.axisPadding) : o.visualizationType === "Forest Plot" ? Je + Number(o.xAxis.axisPadding) : Je,
          left: o.visualizationType !== "Forest Plot" ? Number(q.yAxis.size) : 0,
          label: o[vt].label,
          tickFormat: _n,
          scale: xt,
          stroke: "#333",
          numTicks: Tn ? Ln : Kt,
          tickStroke: "#333",
          tickValues: o.runtime.xAxis.manual ? Vk(fn, xt, lt ? Kt : Kn(), o) : o.runtime.xAxis.type === "date" ? fn : void 0
        },
        (N) => {
          var xa;
          const U = o.series.some((At) => At.dynamicCategory);
          o.runtime.xAxis.type === "date" && !o.runtime.xAxis.manual && !U && (N.ticks = Wk(o, N, fn, s));
          const fe = Tn && xt.ticks(Kt).map(
            (At) => N.ticks.findIndex(
              (vn) => (typeof vn.value == "number" ? vn.value : vn.value.getTime()) === At.getTime()
            )
          ).slice(0, 2).reduce((At, vn) => vn - At), O = Tn ? [...N.ticks].reverse().filter((At, vn) => vn % fe === 0).reverse().map((At, vn, ra) => ({
            ...At,
            // reformat in case showYearsOnce, since first month of year may have changed
            formattedValue: _n(At.value, vn, ra)
          })) : N.ticks, I = Xt + uf, Q = (At) => /\s/.test(At), ge = O.some((At) => Q(At.value)), ze = Math.max(
            ...O.map((At) => hr(At.formattedValue, $t))
          ), Ke = ge ? 180 : 100, ot = O.map((At) => hr(At.formattedValue, $t)), Yt = ot.reduce((At, vn) => At + vn, Ke), Vt = (ht - Yt) / (O.length - 1);
          let nn = [0];
          for (let At = 1; At < ot.length; At++)
            nn[At] = nn[At - 1] + ot[At - 1] + Vt;
          const rn = (xa = He == null ? void 0 : He.current) == null ? void 0 : xa.getBBox().height;
          o.xAxis.axisBBox = rn;
          let an = !1;
          ot.forEach((At, vn) => {
            if (nn[vn] + ot[vn] > nn[vn + 1]) {
              an = !0;
              return;
            }
          }), o.xAxis.showYearsOnce && (an = !0);
          const jn = ot[ot.length - 1], er = nn[nn.length - 1] + jn + jn / 2, Yn = ht - jn;
          er > Yn && (an = !0);
          const Er = an && o.isResponsiveTicks ? ze + df + 20 : 0;
          return o.dynamicMarginTop = Er, o.xAxis.tickWidthMax = ze, /* @__PURE__ */ n.createElement(tt, { className: "bottom-axis", width: c[0] }, O.map((At, vn, ra) => {
            const Nr = String(At.value).startsWith("1") || At.value === 0.1 ? "block" : "none", or = Nr === "block" ? 16 : df, Dr = { x: At.to.x, y: or }, Wr = 100 / ra.length;
            o.yAxis.tickRotation = o.isResponsiveTicks && o.orientation === "horizontal" ? 0 : o.yAxis.tickRotation, o.xAxis.tickRotation = o.isResponsiveTicks && o.orientation === "vertical" ? 0 : o.xAxis.tickRotation;
            const Wt = o.isResponsiveTicks && an ? -Number(o.xAxis.maxTickRotation) || -90 : -Number(o.runtime.xAxis.tickRotation);
            return /* @__PURE__ */ n.createElement(tt, { key: `vx-tick-${At.value}-${vn}`, className: "vx-axis-tick" }, !o.xAxis.hideTicks && /* @__PURE__ */ n.createElement(
              cn,
              {
                from: At.from,
                to: Y === "horizontal" && nt ? Dr : At.to,
                stroke: o.xAxis.tickColor,
                strokeWidth: Nr === "block" && nt ? 1.3 : 1
              }
            ), !o.xAxis.hideLabel && /* @__PURE__ */ n.createElement(
              ct,
              {
                innerRef: (mr) => Ve.current[vn] = mr,
                dy: o.orientation === "horizontal" && nt ? 8 : 0,
                display: o.orientation === "horizontal" && nt ? Nr : "block",
                x: At.to.x,
                y: At.to.y + cf,
                angle: Wt,
                verticalAnchor: Wt < -50 ? "middle" : "start",
                textAnchor: Wt ? "end" : "middle",
                width: an && !o.isResponsiveTicks && !Number(o[vt].tickRotation) ? Wr : void 0,
                fill: o.xAxis.tickLabelColor,
                fontSize: Rt
              },
              At.formattedValue
            ));
          }), !o.xAxis.hideAxis && /* @__PURE__ */ n.createElement(cn, { from: N.axisFromPoint, to: N.axisToPoint, stroke: "#333" }), /* @__PURE__ */ n.createElement(
            ct,
            {
              innerRef: Ge,
              className: "x-axis-title-label",
              x: ht / 2,
              y: st ? 0 : I,
              textAnchor: "middle",
              verticalAnchor: "start",
              fontWeight: "bold",
              fill: o.xAxis.labelColor,
              fontSize: Lt
            },
            N.label
          ));
        }
      )
    ),
    !w && yt && Object.entries(yt.data).length > 0 && Tt && Bt && yt.dataYPosition && yt.dataXPosition && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${o.tooltips.opacity / 100}) !important;`), /* @__PURE__ */ n.createElement("style", null, ".tooltip {max-width:300px} !important; word-wrap: break-word; "), /* @__PURE__ */ n.createElement(
      Vy,
      {
        key: Math.random(),
        className: "tooltip cdc-open-viz-module",
        left: Pn,
        top: tn
      },
      /* @__PURE__ */ n.createElement("ul", null, typeof yt == "object" && Object.entries(yt.data).map((N, U) => /* @__PURE__ */ n.createElement(wn, { item: N, key: U })))
    )),
    o.visualizationType === "Bump Chart" && /* @__PURE__ */ n.createElement(
      mc,
      {
        id: "bump-chart",
        variant: "light",
        arrowColor: "rgba(0,0,0,0)",
        className: "tooltip",
        style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
      }
    ),
    Te() && !w && /* @__PURE__ */ n.createElement(
      mc,
      {
        id: `cdc-open-viz-tooltip-${q.uniqueId}`,
        variant: "light",
        arrowColor: "rgba(0,0,0,0)",
        className: "tooltip",
        style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
      }
    ),
    /* @__PURE__ */ n.createElement("div", { className: "animation-trigger", ref: qe })
  ));
});
const sw = (e) => {
  var q;
  const { width: t, height: r } = e, { transformedData: a, config: i, parseDate: o, formatDate: d, seriesHighlight: c, formatNumber: s, colorScale: p, handleChartAriaLabels: y } = se.useContext(ft);
  let g = Number(t);
  const { minValue: b, maxValue: w } = Vc(i, a), S = { top: 5, right: 10, bottom: 10, left: 10 }, L = Number(r), m = g - i.runtime.yAxis.size, v = L - S.top - 20, A = (te) => i.runtime.xAxis.type === "date" ? o(te[i.runtime.originalXAxis.dataKey]).getTime() : te[i.runtime.originalXAxis.dataKey], P = (te, le) => te[le];
  let T, _;
  const { max: M, min: Z } = i.runtime.yAxis, Y = Number(M) >= Number(w), ae = Number(Z) <= Number(b);
  if (a) {
    let te = Number(Z && ae ? Z : b), le = Number(M && Y ? M : Number.MIN_VALUE);
    if (le === Number.MIN_VALUE && (le = w), i.runtime.yAxis.paddingPercent) {
      let X = (le - te) * i.runtime.yAxis.paddingPercent;
      te -= X, le += X;
    }
    let B = a.map((X) => A(X));
    i.runtime.horizontal ? (T = Vn({
      domain: [te, le],
      range: [0, m]
    }), _ = i.runtime.xAxis.type === "date" ? Vn({ domain: [Math.min(...B), Math.max(...B)] }) : tl({ domain: B, padding: 0.5 }), tl({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, v]
    }), _.rangeRound([0, v])) : (te = te < 0 ? te * 1.11 : te, _ = Vn({
      domain: [te, le],
      range: [v - S.bottom, S.top]
    }), T = tl({
      domain: B,
      range: [S.left, g - S.right]
    }), tl({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, m]
    }));
  }
  const j = [T.domain()[0], T.domain()[T.domain().length - 1]];
  return /* @__PURE__ */ n.createElement(Vr, { component: "SparkLine" }, /* @__PURE__ */ n.createElement("svg", { role: "img", "aria-label": y(i), width: t, height: 100, className: "sparkline", tabIndex: 0 }, /* @__PURE__ */ n.createElement("title", null, `Spark line graphic with the title ${i.title ? i.title : "No Title Found"}`), ((q = i.runtime.lineSeriesKeys) == null ? void 0 : q.length) > 0 ? i.runtime.lineSeriesKeys : i.runtime.seriesKeys.map((te, le) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    tt,
    {
      style: { width: g },
      className: "sparkline-group",
      key: `series-${te}`,
      opacity: i.legend.behavior === "highlight" && c.length > 0 && c.indexOf(te) === -1 ? 0.5 : 1,
      display: i.legend.behavior === "highlight" || c.length === 0 || c.indexOf(te) !== -1 ? "block" : "none"
    },
    i.labels && a.map((B, X) => /* @__PURE__ */ n.createElement(tt, { key: `series-${te}-point-${X}` }, /* @__PURE__ */ n.createElement(ct, { x: T(A(B)), y: _(P(B, te)), fill: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[te] : te) : "#000", textAnchor: "middle" }, s(B[te])))),
    /* @__PURE__ */ n.createElement(
      Hr,
      {
        curve: _c,
        data: a,
        x: (B) => T(A(B)),
        y: (B) => _(P(B, te)),
        stroke: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[te] : te) : "#000",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        markerEnd: `url(#arrow--${le})`
      }
    ),
    /* @__PURE__ */ n.createElement(Cm, { id: `arrow--${le}`, refX: 2, size: 6, markerEnd: `url(#arrow--${le})`, strokeOpacity: 1, fillOpacity: 1, fill: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[te] : te) : "#000" })
  ), /* @__PURE__ */ n.createElement(
    ju,
    {
      top: v + S.top,
      hideAxisLine: !0,
      hideTicks: !0,
      scale: T,
      tickValues: j,
      tickFormat: (B) => i.xAxis.type === "date" ? d(B) : null,
      stroke: "black",
      tickStroke: "black",
      tickLabelProps: () => ({
        fill: "black",
        fontSize: 11,
        textAnchor: "middle"
      })
    }
  )))));
};
var uw = ["flexDirection", "alignItems", "margin", "display", "children"];
function Uf() {
  return Uf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Uf.apply(this, arguments);
}
function cw(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function wc(e) {
  var t = e.flexDirection, r = t === void 0 ? "row" : t, a = e.alignItems, i = a === void 0 ? "center" : a, o = e.margin, d = o === void 0 ? "0" : o, c = e.display, s = c === void 0 ? "flex" : c, p = e.children, y = cw(e, uw);
  return /* @__PURE__ */ n.createElement("div", Uf({
    className: "visx-legend-item",
    style: {
      display: s,
      alignItems: i,
      flexDirection: r,
      margin: d
    }
  }, y), p);
}
wc.propTypes = {
  alignItems: Me.string,
  margin: Me.oneOfType([Me.string, Me.number]),
  children: Me.node,
  display: Me.string
};
var dw = ["flex", "label", "margin", "align", "children"];
function Kf() {
  return Kf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Kf.apply(this, arguments);
}
function fw(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Tc(e) {
  var t = e.flex, r = t === void 0 ? "1" : t, a = e.label, i = e.margin, o = i === void 0 ? "5px 0" : i, d = e.align, c = d === void 0 ? "left" : d, s = e.children, p = fw(e, dw);
  return /* @__PURE__ */ n.createElement("div", Kf({
    className: "visx-legend-label",
    style: {
      justifyContent: c,
      display: "flex",
      flex: r,
      margin: o
    }
  }, p), s || a);
}
Tc.propTypes = {
  align: Me.string,
  label: Me.node,
  flex: Me.oneOfType([Me.string, Me.number]),
  margin: Me.oneOfType([Me.string, Me.number]),
  children: Me.node
};
function Yf() {
  return Yf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Yf.apply(this, arguments);
}
function wp(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style;
  return /* @__PURE__ */ n.createElement("div", {
    style: Yf({
      width: r,
      height: a,
      background: t
    }, i)
  });
}
wp.propTypes = {
  fill: Me.string,
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function pg(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style, o = typeof r == "string" || typeof r > "u" ? 0 : r, d = typeof a == "string" || typeof a > "u" ? 0 : a, c = Math.max(o, d), s = c / 2;
  return /* @__PURE__ */ n.createElement("svg", {
    width: c,
    height: c
  }, /* @__PURE__ */ n.createElement(tt, {
    top: s,
    left: s
  }, /* @__PURE__ */ n.createElement("circle", {
    r: s,
    fill: t,
    style: i
  })));
}
pg.propTypes = {
  fill: Me.string,
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function hg(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style, o = typeof a == "string" || typeof a > "u" ? 0 : a, d = typeof (i == null ? void 0 : i.strokeWidth) == "number" ? i == null ? void 0 : i.strokeWidth : 2;
  return /* @__PURE__ */ n.createElement("svg", {
    width: r,
    height: a
  }, /* @__PURE__ */ n.createElement(tt, {
    top: o / 2 - d / 2
  }, /* @__PURE__ */ n.createElement("line", {
    x1: 0,
    x2: r,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: d,
    style: i
  })));
}
hg.propTypes = {
  fill: Me.string,
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function bs() {
  return bs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, bs.apply(this, arguments);
}
var pf = function() {
};
function pw(e) {
  var t = e.shape, r = t === void 0 ? "rect" : t, a = e.fill, i = a === void 0 ? pf : a, o = e.size, d = o === void 0 ? pf : o, c = e.width, s = e.height, p = e.label, y = e.item, g = e.itemIndex, b = e.shapeStyle, w = b === void 0 ? pf : b, S = {
    width: c,
    height: s,
    item: y,
    itemIndex: g,
    label: p,
    fill: i(bs({}, p)),
    size: d(bs({}, p)),
    style: w(bs({}, p))
  };
  return typeof r == "string" ? r === "circle" ? /* @__PURE__ */ n.createElement(pg, S) : r === "line" ? /* @__PURE__ */ n.createElement(hg, S) : /* @__PURE__ */ n.createElement(wp, S) : /* @__PURE__ */ n.isValidElement(r) ? /* @__PURE__ */ n.cloneElement(r, S) : r ? /* @__PURE__ */ n.createElement(r, S) : null;
}
function Cc() {
  return Cc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Cc.apply(this, arguments);
}
function mg(e) {
  var t = e.shape, r = t === void 0 ? wp : t, a = e.width, i = e.height, o = e.margin, d = e.label, c = e.item, s = e.itemIndex, p = e.fill, y = e.size, g = e.shapeStyle;
  return /* @__PURE__ */ n.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: y ? y(Cc({}, d)) : a,
      height: y ? y(Cc({}, d)) : i,
      margin: o
    }
  }, pw({
    shape: r,
    item: c,
    itemIndex: s,
    label: d,
    width: a,
    height: i,
    fill: p,
    shapeStyle: g
  }));
}
mg.propTypes = {
  itemIndex: Me.number.isRequired,
  margin: Me.oneOfType([Me.string, Me.number]),
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function yg(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function pm(e) {
  return String(yg(e));
}
function hw(e) {
  var t = e.scale, r = e.labelFormat;
  return function(a, i) {
    return {
      datum: a,
      index: i,
      text: "" + r(a, i),
      value: t(a)
    };
  };
}
var mw = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function Es() {
  return Es = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Es.apply(this, arguments);
}
function yw(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var gw = {
  display: "flex"
};
function gg(e) {
  var t = e.className, r = e.style, a = r === void 0 ? gw : r, i = e.scale, o = e.shape, d = e.domain, c = e.fill, s = c === void 0 ? pm : c, p = e.size, y = p === void 0 ? pm : p, g = e.labelFormat, b = g === void 0 ? yg : g, w = e.labelTransform, S = w === void 0 ? hw : w, L = e.shapeWidth, m = L === void 0 ? 15 : L, v = e.shapeHeight, A = v === void 0 ? 15 : v, P = e.shapeMargin, T = P === void 0 ? "2px 4px 2px 0" : P, _ = e.shapeStyle, M = e.labelAlign, Z = M === void 0 ? "left" : M, Y = e.labelFlex, ae = Y === void 0 ? "1" : Y, j = e.labelMargin, q = j === void 0 ? "0 4px" : j, te = e.itemMargin, le = te === void 0 ? "0" : te, B = e.direction, X = B === void 0 ? "column" : B, ue = e.itemDirection, ne = ue === void 0 ? "row" : ue, J = e.legendLabelProps, W = e.children, K = yw(e, mw), ee = d || ("domain" in i ? i.domain() : []), $ = S({
    scale: i,
    labelFormat: b
  }), pe = ee.map($);
  return W ? /* @__PURE__ */ n.createElement(n.Fragment, null, W(pe)) : /* @__PURE__ */ n.createElement("div", {
    className: Nn("visx-legend", t),
    style: Es({}, a, {
      flexDirection: X
    })
  }, pe.map(function(ve, Te) {
    return /* @__PURE__ */ n.createElement(wc, Es({
      key: "legend-" + ve.text + "-" + Te,
      margin: le,
      flexDirection: ne
    }, K), /* @__PURE__ */ n.createElement(mg, {
      shape: o,
      height: A,
      width: m,
      margin: T,
      item: ee[Te],
      itemIndex: Te,
      label: ve,
      fill: s,
      size: y,
      shapeStyle: _
    }), /* @__PURE__ */ n.createElement(Tc, Es({
      label: ve.text,
      flex: ae,
      margin: q,
      align: Z
    }, J)));
  }));
}
gg.propTypes = {
  children: Me.func,
  className: Me.string,
  domain: Me.array,
  shapeWidth: Me.oneOfType([Me.string, Me.number]),
  shapeHeight: Me.oneOfType([Me.string, Me.number]),
  shapeMargin: Me.oneOfType([Me.string, Me.number]),
  labelAlign: Me.string,
  labelFlex: Me.oneOfType([Me.string, Me.number]),
  labelMargin: Me.oneOfType([Me.string, Me.number]),
  itemMargin: Me.oneOfType([Me.string, Me.number]),
  fill: Me.func,
  size: Me.func,
  shapeStyle: Me.func
};
function vw(e) {
  return /* @__PURE__ */ n.createElement(gg, e);
}
const xw = (e) => {
  const { position: t, singleRow: r, verticalSorted: a, hideBorder: i } = e.legend, o = {
    left: "left",
    right: "right",
    bottom: "bottom",
    top: "top"
  }, d = {
    bottom: r ? ["single-row", "bottom"] : ["double-column", "bottom"],
    top: r ? ["single-row", "top"] : ["double-column", "top"]
  }, c = ["legend-container", o[t]].filter(Boolean), s = ["legend-container__inner", ...d[t] || []];
  ["bottom", "top"].includes(t) && a && s.push("vertical-sorted");
  const p = (["right", "left"].includes(t) || !t) && i.side, y = ["top", "bottom"].includes(t) && i.topBottom;
  return p || y ? c.push("border-0", "p-0") : c.push("p-3"), {
    containerClasses: c,
    innerClasses: s
  };
}, bw = (e, t, r) => {
  const i = t([{ datum: "", index: 0, text: "", value: "" }]), o = e.legend.colorCode ? i.map((c) => c == null ? void 0 : c.value) : (r == null ? void 0 : r.range()) ?? [], d = e.legend.colorCode ? i.map((c) => (c == null ? void 0 : c.text) || (c == null ? void 0 : c.datum)) : (r == null ? void 0 : r.domain()) ?? [];
  return { colors: o, labels: d };
}, Ew = (e, t) => {
  var r;
  return e ? e && ((r = t.brush) != null && r.active) ? `${t.brush.height * 1.5}px` : "27px" : "0px";
}, Sw = (e, t) => {
  var o, d, c;
  const r = ((o = t.legend) == null ? void 0 : o.position) === "top" && !t.legend.hide, a = !t.legend.hideSuppressionLink && t.visualizationSubType !== "stacked" && ((d = t.preliminaryData) == null ? void 0 : d.some((s) => s.label && s.type === "suppression" && s.value && ((s == null ? void 0 : s.style) || s.symbol)));
  let i = 0;
  return r && (i = 27), r && ((c = t.dataFormat) != null && c.onlyShowTopPrefixSuffix) && (i += 9), e && (i += 9), a && (i += 40), `${i}px`;
}, kw = ({ config: e, isLegendBottom: t }) => {
  const { preliminaryData: r, visualizationType: a, visualizationSubType: i, legend: o } = e, d = () => (r == null ? void 0 : r.some((w) => w.label && w.type === "effect" && w.style !== "Filled Circles")) && ["Line", "Combo"].includes(a), c = () => !o.hideSuppressedLabels && (r == null ? void 0 : r.some(
    (w) => w.label && w.displayLegend && w.type === "suppression" && w.value && ((w == null ? void 0 : w.style) || w.symbol)
  )) && (a === "Bar" && i === "regular" || a === "Line" || a === "Combo"), s = () => r == null ? void 0 : r.map(
    (w, S) => w.label && w.type === "effect" && w.style && /* @__PURE__ */ n.createElement("div", { key: S, className: "legend-preliminary" }, /* @__PURE__ */ n.createElement("span", { className: w.symbol }, w.lineCode), /* @__PURE__ */ n.createElement("p", null, w.label))
  ), p = (w) => {
    w.preventDefault();
  }, y = () => {
    const w = (S) => S ? {
      color: "#777772"
    } : null;
    return r == null ? void 0 : r.map((S, L) => {
      if (!S.displayLegend || S.type !== "suppression")
        return null;
      const m = "legend-preliminary", v = L + a;
      return a === "Bar" ? /* @__PURE__ */ n.createElement("div", { style: w(S.displayGray), key: v, className: `${m} ${S.symbol}` }, /* @__PURE__ */ n.createElement("span", { className: S.symbol }, S.iconCode), /* @__PURE__ */ n.createElement("p", { className: S.type }, S.label)) : a === "Line" ? /* @__PURE__ */ n.createElement("div", { style: w(S.displayGray), key: v, className: m }, /* @__PURE__ */ n.createElement("span", null, S.lineCode), /* @__PURE__ */ n.createElement("p", { className: S.type }, S.label)) : a === "Combo" ? /* @__PURE__ */ n.createElement(n.Fragment, null, S.symbol && S.iconCode && /* @__PURE__ */ n.createElement("div", { style: w(S.displayGray), key: v, className: `${m} ${S.symbol}` }, /* @__PURE__ */ n.createElement("span", { className: S.symbol }, S.iconCode), /* @__PURE__ */ n.createElement("p", { className: S.type }, S.label)), S.style && S.lineCode && /* @__PURE__ */ n.createElement("div", { style: w(S.displayGray), key: v, className: m }, /* @__PURE__ */ n.createElement("span", null, S.lineCode), /* @__PURE__ */ n.createElement("p", null, S.label))) : null;
    });
  }, g = () => o.singleRow && t ? "legend-container__inner bottom single-row" : "", b = () => !e.legend.hideSuppressionLink && e.visualizationSubType !== "stacked" && (r == null ? void 0 : r.some((w) => w.label && w.type === "suppression" && w.value && ((w == null ? void 0 : w.style) || w.symbol)));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, d() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("div", { className: g() }, s())), c() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("div", { className: g() }, y())), b() && /* @__PURE__ */ n.createElement("div", { className: "legend-container__outer definition-link" }, /* @__PURE__ */ n.createElement(Ue, { alt: "info-icon", display: "info" }), /* @__PURE__ */ n.createElement("p", null, "This chart contains", /* @__PURE__ */ n.createElement(
    "a",
    {
      onClick: p,
      "data-tooltip-content": "Data is suppressed to maintain statistical reliability. This occurs when the number of respondents or reported values does not meet the minimum reporting threshold.",
      "data-tooltip-id": "my-tooltip",
      href: "no-router-link"
    },
    "suppressed data"
  ))), /* @__PURE__ */ n.createElement(
    mc,
    {
      id: "my-tooltip",
      variant: "light",
      style: { background: `rgba(255,255,255, ${e.tooltips.opacity / 100})`, color: "black", maxWidth: "100%" }
    }
  ));
}, vg = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, ww = [
  km,
  wm,
  Gu,
  Tm,
  Gu,
  Sp,
  ({ fill: e }) => /* @__PURE__ */ n.createElement(Gf, null, /* @__PURE__ */ n.createElement(ct, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle" }, "⬟"))
], Tw = (e) => {
  var c;
  const { config: t, label: r, index: a } = e, i = a === 4, o = ww[t.visual.lineDatapointSymbol === "standard" && a < t.visual.maximumShapeAmount ? a : 0], d = `translate(15, 3) ${i ? "rotate(180)" : ""}`;
  return /* @__PURE__ */ n.createElement("svg", { width: 30, height: 10, style: { overflow: "visible" }, className: "me-2" }, /* @__PURE__ */ n.createElement(
    cn,
    {
      from: { x: 0, y: 3 },
      to: { x: 30, y: 3 },
      stroke: r.value,
      strokeWidth: 2,
      strokeDasharray: vg(((c = t.series[a]) == null ? void 0 : c.type) || "")
    }
  ), /* @__PURE__ */ n.createElement("g", { display: t.legend.hasShape ? "block" : "none", transform: d }, /* @__PURE__ */ n.createElement(o, { fillOpacity: 1, fill: r.value })));
}, Cw = 36, Aw = se.forwardRef(
  ({
    config: e,
    colorScale: t,
    seriesHighlight: r,
    highlight: a,
    handleShowAll: i,
    currentViewport: o,
    formatLabels: d,
    skipId: c = "legend",
    dimensions: s
  }, p) => {
    const { innerClasses: y, containerClasses: g } = xw(e), { runtime: b, legend: w } = e, S = (w == null ? void 0 : w.position) === "bottom" || Va(o) && !w.hide && (w == null ? void 0 : w.position) !== "top", L = {
      marginBottom: Sw(S, e),
      marginTop: Ew(S, e)
    }, { HighLightedBarUtils: m } = $c(e);
    let v = m.findDuplicates(e.highlightedBarValues);
    return w ? /* @__PURE__ */ n.createElement(
      "aside",
      {
        ref: p,
        style: L,
        id: c || "legend",
        className: g.join(" "),
        role: "region",
        "aria-label": "legend",
        tabIndex: 0
      },
      (w.label || w.description) && /* @__PURE__ */ n.createElement("div", { className: w.description ? "mb-3" : "mb-2" }, w.label && /* @__PURE__ */ n.createElement("h3", { className: "fw-bold" }, Oi(w.label)), w.description && /* @__PURE__ */ n.createElement("p", { className: "mt-2" }, Oi(w.description))),
      /* @__PURE__ */ n.createElement(
        Mg,
        {
          config: e,
          ...bw(e, d, t),
          dimensions: s,
          parentPaddingToSubtract: w.hideBorder ? 0 : Cw
        }
      ),
      /* @__PURE__ */ n.createElement(vw, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0" }, (A) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: y.join(" ") }, d(A).map((P, T) => {
        var Z, Y;
        let _ = ["legend-item", `legend-text--${P.text.replace(" ", "").toLowerCase()}`], M = P.datum;
        if (e.exclusions.active && ((Z = e.exclusions.keys) != null && Z.includes(M)))
          return null;
        if (b.seriesLabels) {
          let ae = e.runtime.seriesLabelsAll.indexOf(M);
          M = e.runtime.seriesKeys[ae], ((Y = b == null ? void 0 : b.forecastingSeriesKeys) == null ? void 0 : Y.length) > 0 && (M = P.text);
        }
        return r.length && (r.includes(M) ? _.push("highlighted") : _.push("inactive")), e.legend.style === "gradient" ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(
          wc,
          {
            className: _.join(" "),
            tabIndex: 0,
            key: `legend-quantile-${T}`,
            onKeyDown: (ae) => {
              ae.key === "Enter" && (ae.preventDefault(), a(P));
            },
            onClick: (ae) => {
              ae.preventDefault(), a(P);
            },
            role: "button"
          },
          /* @__PURE__ */ n.createElement(n.Fragment, null, e.visualizationType === "Line" && e.legend.style === "lines" ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Tw, { index: T, label: P, config: e })) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
            zp,
            {
              shape: e.legend.style === "boxes" ? "square" : "circle",
              fill: P.value
            }
          ))),
          /* @__PURE__ */ n.createElement(Tc, { align: "left", className: "m-0" }, P.text)
        );
      }), v.map((P, T) => {
        let _ = "legend-item", M = P.legendLabel;
        return M ? (r.length > 0 && r.includes(M) === !1 && (_ += " inactive"), /* @__PURE__ */ n.createElement(
          wc,
          {
            className: _,
            tabIndex: 0,
            key: `legend-quantile-${T}`,
            onKeyDown: (Z) => {
              Z.key === "Enter" && (Z.preventDefault(), a(P.legendLabel));
            },
            onClick: (Z) => {
              Z.preventDefault(), a(P.legendLabel);
            }
          },
          /* @__PURE__ */ n.createElement(
            zp,
            {
              shape: e.legend.style === "boxes" ? "square" : "circle",
              style: { borderRadius: "0px" },
              fill: "transparent",
              borderColor: P.color ? P.color : "rgba(255, 102, 1)"
            }
          ),
          " ",
          /* @__PURE__ */ n.createElement(Tc, { align: "left" }, P.legendLabel ? P.legendLabel : P.value)
        )) : !1;
      })), /* @__PURE__ */ n.createElement(kw, { config: e, isLegendBottom: S }))),
      r.length > 0 && /* @__PURE__ */ n.createElement(Rc, { onClick: (A) => i(A), style: { marginTop: "1rem" } }, "Show All")
    ) : null;
  }
);
function Lw(e) {
  return zg({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" } }] })(e);
}
const Pw = (e, t, r, a) => (i) => {
  var w, S, L, m, v;
  const { visualizationType: o, visualizationSubType: d, series: c, runtime: s, legend: p } = e, y = (A) => p.verticalSorted ? et.sortBy(et.cloneDeep(A), (P) => {
    var _;
    const T = (_ = P.datum) == null ? void 0 : _.match(/-?\d+(\.\d+)?/);
    return T ? parseFloat(T[0]) : Number.MAX_SAFE_INTEGER;
  }) : A, g = (A) => e.legend.reverseLabelOrder ? y(A).reverse() : y(A), b = (w = e.legend) == null ? void 0 : w.colorCode;
  if (o === "Deviation Bar") {
    const [A, P] = Pc[e.twoColor.palette], T = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: A
    }, _ = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: P
    };
    return g([T, _]);
  }
  if (o === "Bar" && d === "regular" && b && (c == null ? void 0 : c.length) === 1) {
    let A = Sr[e.palette];
    for (; t.length > A.length; )
      A = A.concat(A);
    A = A.slice(0, r.length);
    const P = /* @__PURE__ */ new Set();
    t.forEach((_) => P.add(_[b]));
    const T = Array.from(P).map((_, M) => ({
      datum: _,
      index: M,
      text: _,
      value: A[M]
    }));
    return g(T);
  }
  if (((S = s == null ? void 0 : s.forecastingSeriesKeys) == null ? void 0 : S.length) > 0) {
    let A = [];
    return (m = (L = e.runtime) == null ? void 0 : L.forecastingSeriesKeys) == null || m.map((P, T) => {
      var _;
      return (_ = P == null ? void 0 : P.stages) == null ? void 0 : _.map((M, Z) => {
        var j, q, te, le;
        let Y = (j = Yu[M.color]) != null && j[2] ? (q = Yu[M.color]) == null ? void 0 : q[2] : (te = Sr[M.color]) != null && te[2] ? (le = Sr[M.color]) == null ? void 0 : le[2] : "#ccc";
        const ae = {
          datum: M.key,
          index: Z,
          text: M.key,
          value: Y
        };
        A.push(ae);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((P, T) => {
      let _ = Sr[e.palette][T] ? Sr[e.palette][T] : "#ccc";
      const M = {
        datum: P,
        index: T,
        text: P,
        value: _
      };
      A.push(M);
    }), g(A);
  }
  if (e.series.some((A) => A.name)) {
    const A = Array.from(new Set(e.series.map((P) => P.name || P.dataKey))).map((P, T) => ({
      datum: P,
      index: T,
      text: P,
      value: a(P)
    }));
    return g(A);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const A = i.length - 1;
    let P = [];
    return (v = e.suppressedData) == null || v.forEach(({ label: T, icon: _ }, M) => {
      if (T && _) {
        const Z = {
          datum: T,
          index: A + M,
          text: T,
          icon: /* @__PURE__ */ n.createElement(Lw, { color: "#000", size: 15 })
        };
        P.push(Z);
      }
    }), [...i, ...P];
  }
  return g(i);
}, Rw = se.forwardRef((e, t) => {
  const {
    // prettier-ignore
    config: r,
    colorScale: a,
    seriesHighlight: i,
    highlight: o,
    tableData: d,
    handleShowAll: c,
    transformedData: s,
    currentViewport: p,
    dimensions: y,
    getTextWidth: g
  } = se.useContext(ft);
  if (!r.legend)
    return null;
  const b = Pw(r, d, s, a);
  return /* @__PURE__ */ n.createElement(se.Fragment, null, /* @__PURE__ */ n.createElement(
    Aw,
    {
      getTextWidth: g,
      dimensions: y,
      ref: t,
      skipId: e.skipId || "legend",
      config: r,
      colorScale: a,
      seriesHighlight: i,
      highlight: o,
      handleShowAll: c,
      currentViewport: p,
      formatLabels: b
    }
  ));
}), hf = {
  annotations: [],
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "true",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    annotationDropdownText: "Annotations",
    showDownloadButton: !1,
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0,
    showZeroValueData: !0,
    hideNullValue: !0
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !1,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: [],
    shoMissingDataLabel: !0,
    showMissingDataLine: !0,
    categories: []
  },
  boxplot: {
    plots: [],
    borders: "true",
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      count: "Count",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 0,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0,
    padding: 5,
    showYearsOnce: !1,
    sortByRecentDate: !1
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    showDownloadLinkBelow: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: "",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    label: "",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    hideSuppressionLink: !1,
    seriesHighlight: [],
    style: "circles",
    subStyle: "linear blocks",
    shape: "circle",
    tickRotation: "",
    hideBorder: {
      side: !1,
      topBottom: !0
    },
    position: "right"
  },
  brush: {
    height: 45,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  filters: [],
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1,
    lineDatapointSymbol: "none",
    maximumShapeAmount: 7
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, Nw = ({
  config: e,
  deleteColumn: t,
  updateField: r,
  colKey: a,
  controls: i
}) => {
  var g, b, w, S;
  const [o, d] = i, c = (L, m) => {
    if (L === "dataTable" && m === !0) {
      const v = et.cloneDeep(e.columns);
      v[a] = { ...v[a], dataTable: m }, r(null, null, "columns", v);
    } else
      r("columns", a, L, m);
  }, s = (L) => {
    const m = et.cloneDeep(e.columns), A = { ...e.columns[a], name: L, label: L };
    if (A.dataTable === void 0 && (A.dataTable = !0), L !== a) {
      m[L] = A, delete m[a];
      const P = { ...et.cloneDeep(o), [L]: !0 };
      delete P[a], d(P);
    }
    r(null, null, "columns", m);
  }, p = () => {
    var A;
    const L = e.data.flatMap((P) => Object.keys(P).map((T) => T)), m = Object.values(e.columns).map((P) => P.name), v = et.uniq(L).filter((P) => !(e.table.groupBy === P || m.includes(P)));
    return (A = e.columns[a]) != null && A.name && v.push(e.columns[a].name), v;
  }, y = (g = e.columns[a]) == null ? void 0 : g.name;
  return /* @__PURE__ */ n.createElement(
    Bg,
    {
      fieldName: y,
      fieldKey: a,
      fieldType: "Column",
      controls: i,
      deleteField: () => t(a)
    },
    /* @__PURE__ */ n.createElement(
      dt,
      {
        label: "Column",
        value: (b = e.columns[a]) == null ? void 0 : b.name,
        fieldName: "name",
        section: "columns",
        initial: "-Select-",
        options: p(),
        updateField: (L, m, v, A) => s(A)
      }
    ),
    e.type !== "table" && /* @__PURE__ */ n.createElement(
      dt,
      {
        label: "Associate to Series",
        value: (w = e.columns[a]) == null ? void 0 : w.series,
        fieldName: "series",
        section: "columns",
        initial: "Select series",
        options: ((S = e.series) == null ? void 0 : S.map((L) => L.dataKey)) || [],
        updateField: (L, m, v, A) => c("series", A)
      }
    ),
    /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.columns[a].label,
        section: "columns",
        subsection: a,
        fieldName: "label",
        label: "Label",
        updateField: r
      }
    ),
    /* @__PURE__ */ n.createElement("ul", { className: "column-edit" }, /* @__PURE__ */ n.createElement("li", { className: "three-col" }, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.columns[a].prefix,
        section: "columns",
        subsection: a,
        fieldName: "prefix",
        label: "Prefix",
        updateField: r
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.columns[a].suffix,
        section: "columns",
        subsection: a,
        fieldName: "suffix",
        label: "Suffix",
        updateField: r
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        type: "number",
        value: e.columns[a].roundToPlace,
        section: "columns",
        subsection: a,
        fieldName: "roundToPlace",
        label: "Round",
        updateField: r
      }
    )), /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].commas,
        onChange: (L) => {
          c("commas", L.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Add Commas to Numbers"))), /* @__PURE__ */ n.createElement("li", null, e.table.showVertical && /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].dataTable ?? !0,
        onChange: (L) => {
          c("dataTable", L.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Data Table"))), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].showInViz,
        onChange: (L) => {
          c("showInViz", L.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Visualization"))), e.type !== "table" && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].tooltips || !1,
        onChange: (L) => {
          r("columns", a, "tooltips", L.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in tooltip"))), e.visualizationType === "Forest Plot" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].forestPlot || !1,
        onChange: (L) => {
          c("forestPlot", L.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Forest Plot"))), /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].forestPlotAlignRight || !1,
        onChange: (L) => {
          c("forestPlotAlignRight", L.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Align Right"))), !e.columns[a].forestPlotAlignRight && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "text" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Forest Plot Starting Point"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "number",
        value: e.columns[a].forestPlotStartingPoint || 0,
        onChange: (L) => {
          c("forestPlotStartingPoint", L.target.value);
        }
      }
    ))))),
    /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Order"), /* @__PURE__ */ n.createElement(
      "input",
      {
        onWheel: (L) => L.currentTarget.blur(),
        type: "number",
        min: "1",
        value: e.columns[a].order,
        onChange: (L) => r("columns", a, "order", parseInt(L.target.value))
      }
    ))
  );
}, Dw = ({ config: e, updateField: t, deleteColumn: r }) => {
  var d;
  const a = se.useState({}), i = Object.keys(e.columns), o = (c) => {
    const s = `additionalColumn${c}`, p = {
      label: "New Column",
      dataTable: !0,
      tooltips: !1,
      prefix: "",
      suffix: "",
      forestPlot: !1,
      startingPoint: "0",
      forestPlotAlignRight: !1,
      roundToPlace: 0,
      commas: !1,
      showInViz: !1,
      forestPlotStartingPoint: 0
    }, [y, g] = a;
    g({ ...y, [s]: !0 }), t("columns", null, s, p);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.type !== "navigation" && /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Configurations", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can specify additional columns to display in tooltips and / or the supporting data table."))))), i.map((c, s) => /* @__PURE__ */ n.createElement(
    Nw,
    {
      key: c + s,
      controls: a,
      config: e,
      deleteColumn: r,
      updateField: t,
      colKey: c
    }
  )), /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "btn btn-primary",
      onClick: (c) => {
        c.preventDefault(), o(i.length + 1);
      }
    },
    "Add Configuration"
  )), ((d = e.legend) == null ? void 0 : d.type) === "category" && /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Additional Category", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can provide additional categories to ensure they appear in the legend"))))), e.legend.additionalCategories && e.legend.additionalCategories.map((c, s) => /* @__PURE__ */ n.createElement("fieldset", { className: "edit-block", key: c }, /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "remove-column",
      onClick: (p) => {
        p.preventDefault();
        const y = [...e.legend.additionalCategories];
        y.splice(s, 1), t("legend", null, "additionalCategories", y);
      }
    },
    "Remove"
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      value: c,
      label: "Category",
      section: "legend",
      subsection: null,
      fieldName: "additionalCategories",
      updateField: (p, y, g, b) => {
        const w = [...e.legend.additionalCategories];
        w[s] = b, t(p, y, g, w);
      }
    }
  ))), /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "btn btn-primary full-width",
      onClick: (c) => {
        c.preventDefault();
        const s = [...e.legend.additionalCategories || []];
        s.push(""), t("legend", null, "additionalCategories", s);
      }
    },
    "Add Category"
  )));
}, hm = "-Select-", _w = ({ config: e, updateField: t, isDashboard: r, columns: a }) => {
  var p, y, g, b, w, S, L;
  const i = ((p = e.dataKey) == null ? void 0 : p.includes("http://")) || ((y = e == null ? void 0 : e.dataKey) == null ? void 0 : y.includes("https://")), o = se.useMemo(() => Object.keys(e.columns).map((m) => [m, e.columns[m].dataTable]).filter(([m, v]) => !v).map(([m]) => m), [e.columns]), d = se.useMemo(() => {
    const m = e.data.flatMap(Object.keys);
    return et.uniq(m).filter((A) => !0);
  }, [e.data]), c = (m) => {
    m === hm && (m = void 0), t("table", null, "groupBy", m);
  }, s = (m, v, A, P) => {
    const T = et.cloneDeep(e.columns), _ = [];
    for (let M in T) {
      const Z = T[M];
      _.push(Z.name), P.includes(Z.name) ? T[M].dataTable = !1 : T[M].dataTable = !0;
    }
    P.forEach((M) => {
      _.includes(M) || (T[M] = { name: M, dataTable: !1 });
    }), t(null, null, "columns", T);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    We,
    {
      value: e.table.label,
      updateField: t,
      section: "table",
      fieldName: "label",
      id: "tableLabel",
      label: "Data Table Title",
      placeholder: "Data Table",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Label is required for Data Table for 508 Compliance")))
    }
  ), e.type !== "table" ? /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.show,
      fieldName: "show",
      label: "Show Data Table",
      section: "table",
      updateField: t,
      className: "column-heading",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
        Ue,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Hiding the data table may affect accessibility. An alternate form of accessing visualization data is a 508 requirement.")))
    }
  ) : /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: (g = e.general) == null ? void 0 : g.showDownloadButton,
      fieldName: "showDownloadButton",
      label: "Show Download CSV link",
      section: "general",
      updateField: t,
      className: "column-heading"
    }
  ), e.visualizationType !== "Box Plot" && e.type !== "table" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.showVertical,
      fieldName: "showVertical",
      label: "Show Vertical Data",
      section: "table",
      updateField: t,
      className: "column-heading",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
        Ue,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This will draw the data table with vertical data instead of horizontal.")))
    }
  ), e.type !== "table" && /* @__PURE__ */ n.createElement(
    We,
    {
      value: e.table.indexLabel,
      section: "table",
      fieldName: "indexLabel",
      label: "Index Column Header",
      updateField: t,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "To comply with 508 standards, if the first column in the data table has no header, enter a brief one here.")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      value: e.table.caption,
      updateField: t,
      section: "table",
      type: "textarea",
      fieldName: "caption",
      label: "Screen Reader Description",
      placeholder: " Data table",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter a description of the data table to be read by screen readers.")))
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.limitHeight,
      section: "table",
      fieldName: "limitHeight",
      label: " Limit Table Height",
      updateField: t
    }
  ), e.table.limitHeight && /* @__PURE__ */ n.createElement(
    We,
    {
      value: e.table.height,
      section: "table",
      fieldName: "height",
      label: "Data Table Height",
      type: "number",
      min: 0,
      max: 500,
      placeholder: "Height(px)",
      updateField: t
    }
  ), (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading mt-1" }, "Exclude Columns "), /* @__PURE__ */ n.createElement(
    jp,
    {
      key: o.join("") + "excluded",
      options: a.map((m) => ({ label: m, value: m })),
      selected: o,
      label: "Exclude Columns",
      fieldName: "dataTable",
      section: "columns",
      updateField: s
    }
  )), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.collapsible,
      fieldName: "collapsible",
      label: " Collapsible",
      section: "table",
      updateField: t
    }
  ), e.table.collapsible !== !1 && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.expanded,
      fieldName: "expanded",
      label: " Expanded by Default",
      section: "table",
      updateField: t
    }
  ), r && e.type !== "table" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.showDataTableLink,
      fieldName: "showDataTableLink",
      label: "Show Data Table Name & Link",
      section: "table",
      updateField: t
    }
  ), i && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.showDownloadUrl,
      fieldName: "showDownloadUrl",
      label: "Show URL to Automatically Updated Data",
      section: "table",
      updateField: t
    }
  ), e.type !== "table" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.showDownloadImgButton,
      fieldName: "showDownloadImgButton",
      label: "Display Image Button",
      section: "table",
      updateField: t
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.showDownloadLinkBelow,
      fieldName: "showDownloadLinkBelow",
      label: "Show Download Link Below Table",
      section: "table",
      updateField: t
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Table Cell Min Width"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      value: e.table.cellMinWidth ? e.table.cellMinWidth : 0,
      onChange: (m) => t("table", null, "cellMinWidth", m.target.value)
    }
  )), (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement(
    dt,
    {
      value: e.table.groupBy,
      fieldName: "groupBy",
      section: "table",
      label: "Group By",
      updateField: (m, v, A, P) => c(P),
      initial: hm,
      options: d.filter(
        (m) => {
          var v, A;
          return m !== ((v = e.table.pivot) == null ? void 0 : v.columnName) && !(((A = e.table.pivot) == null ? void 0 : A.valueColumns) || []).includes(m);
        }
      ),
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Choose a column to use for grouping data rows. The selected column will not be shown in the data table. You will only be able to choose a column which does not have a column configuration.")))
    }
  ), /* @__PURE__ */ n.createElement(
    dt,
    {
      label: "Pivot Column",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select a Column whos data values will be pivoted to Column Values."))),
      value: (b = e.table.pivot) == null ? void 0 : b.columnName,
      options: d.filter(
        (m) => {
          var v;
          return m !== e.table.groupBy && !(((v = e.table.pivot) == null ? void 0 : v.valueColumns) || []).includes(m);
        }
      ),
      initial: "-Select-",
      section: "table",
      subsection: "pivot",
      fieldName: "columnName",
      updateField: t
    }
  ), ((w = e.table.pivot) == null ? void 0 : w.columnName) && /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading mt-1" }, "Pivot Value Column(s)", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "The column(s) whos values will be pivoted under the column selected as the Filter.")))), /* @__PURE__ */ n.createElement(
    jp,
    {
      key: (S = e.table.pivot) == null ? void 0 : S.columnName,
      options: d.filter((m) => {
        var v;
        return m !== ((v = e.table.pivot) == null ? void 0 : v.columnName) && m !== e.table.groupBy;
      }).map((m) => ({ label: m, value: m })),
      selected: (L = e.table.pivot) == null ? void 0 : L.valueColumns,
      label: "Pivot Value Column(s) ",
      section: "table",
      subsection: "pivot",
      fieldName: "valueColumns",
      updateField: t
    }
  )));
}, Ku = (e) => /* @__PURE__ */ se.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ se.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), Ow = ({ name: e }) => {
  var c, s, p, y, g;
  const { config: t, rawData: r, updateConfig: a } = se.useContext(ft);
  if (t.visualizationType !== "Forest Plot")
    return;
  const i = (b) => {
    b.orientation === "horizontal" && (b.labels = !1), b.table.show === void 0 && (b.table.show = !isDashboard), b.visualizationType === "Combo" && (b.orientation = "vertical");
  }, o = (b = !0) => {
    let w = {};
    return r.forEach((S) => {
      Object.keys(S).forEach((L) => w[L] = !0);
    }), b && Object.keys(w).forEach((S) => {
      (t.series && t.series.filter((L) => L.dataKey === S).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(S)) && delete w[S];
    }), Object.keys(w);
  }, d = (b, w, S, L) => {
    if (b === "boxplot" && w === "legend") {
      a({
        ...t,
        [b]: {
          ...t[b],
          [w]: {
            ...t.boxplot[w],
            [S]: L
          }
        }
      });
      return;
    }
    if (b === "boxplot" && w === "labels") {
      a({
        ...t,
        [b]: {
          ...t[b],
          [w]: {
            ...t.boxplot[w],
            [S]: L
          }
        }
      });
      return;
    }
    if (b === "forestPlot" && w) {
      let P = {
        ...t,
        [b]: {
          ...t[b],
          [w]: {
            ...t.forestPlot[w],
            [S]: L
          }
        }
      };
      a(P);
      return;
    }
    if (b === "columns" && w !== "" && S !== "") {
      a({
        ...t,
        [b]: {
          ...t[b],
          [w]: {
            ...t[b][w],
            [S]: L
          }
        }
      });
      return;
    }
    if (b === null && w === null) {
      let P = { ...t, [S]: L };
      i(P), a(P);
      return;
    }
    const m = Array.isArray(t[b]);
    let v = m ? [...t[b], L] : { ...t[b], [S]: L };
    w !== null && (m ? (v = [...t[b]], v[w] = { ...v[w], [S]: L }) : typeof L == "string" ? v[w] = L : v = { ...t[b], [w]: { ...t[b][w], [S]: L } });
    let A = { ...t, [b]: v };
    i(A), a(A);
  };
  return /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, e, (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ n.createElement(Ku, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Study Column",
      initial: "Select",
      required: !0,
      updateField: d,
      options: o(!1),
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  ), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.forestPlot.type,
      label: "Forest Plot Type",
      initial: "Select",
      required: !0,
      onChange: (b) => {
        b.target.value !== "" && b.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            type: b.target.value
          }
        }), b.target.value = "";
      },
      options: ["Linear", "Logarithmic"],
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ", /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("br", null), " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1.")))
    }
  ), /* @__PURE__ */ n.createElement(We, { type: "text", value: ((c = t.forestPlot) == null ? void 0 : c.title) || "", updateField: d, section: "forestPlot", fieldName: "title", label: "Plot Title" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Column Settings"), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.forestPlot.estimateField,
      label: "Point Estimate Column",
      initial: t.forestPlot.estimateField || "Select",
      required: !0,
      onChange: (b) => {
        b.target.value !== "" && b.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            estimateField: b.target.value
          }
        }), b.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.forestPlot.shape,
      label: "Point Estimate Shape",
      onChange: (b) => {
        b.target.value !== "" && b.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            shape: b.target.value
          }
        }), b.target.value = "";
      },
      options: ["text", "circle", "square"]
    }
  ), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.forestPlot.lower,
      label: "Lower CI Column",
      required: !0,
      initial: t.forestPlot.lower || "Select",
      onChange: (b) => {
        b.target.value !== "" && b.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            lower: b.target.value
          }
        }), b.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.forestPlot.upper,
      label: "Upper CI Column",
      initial: t.forestPlot.upper || "Select",
      required: !0,
      onChange: (b) => {
        b.target.value !== "" && b.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            upper: b.target.value
          }
        }), b.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Pooled Result Column", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: t.forestPlot.pooledResult.column || "",
      label: "Pooled Result Row",
      onChange: (b) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            pooledResult: {
              ...t.forestPlot.pooledResult,
              column: b.target.value
            }
          }
        }), b.target.value = "";
      }
    }
  ))), /* @__PURE__ */ n.createElement(Qe, { value: ((p = (s = t.forestPlot) == null ? void 0 : s.lineOfNoEffect) == null ? void 0 : p.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: d }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Width Settings"), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left (%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffset || 0,
      onChange: (b) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffset: b.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left Mobile(%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffsetMobile || 0,
      onChange: (b) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffsetMobile: b.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right (%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffset || 0,
      onChange: (b) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffset: b.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right Mobile(%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffsetMobile || 0,
      onChange: (b) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffsetMobile: b.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement(We, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: d, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Labels Settings"), /* @__PURE__ */ n.createElement(We, { type: "text", value: ((y = t.forestPlot) == null ? void 0 : y.leftLabel) || "", updateField: d, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }), /* @__PURE__ */ n.createElement(We, { type: "text", value: ((g = t.forestPlot) == null ? void 0 : g.rightLabel) || "", updateField: d, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.forestPlot.radius.scalingColumn,
      label: "Weight Column",
      initial: "Select",
      onChange: (b) => {
        b.target.value !== "" && b.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              scalingColumn: b.target.value
            }
          }
        }), b.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Radius Minimum Size"), /* @__PURE__ */ n.createElement(
    "input",
    {
      min: 3,
      max: 6,
      value: t.forestPlot.radius.min || 3,
      onChange: (b) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              min: Number(b.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Radius Maximum Size"), /* @__PURE__ */ n.createElement(
    "input",
    {
      min: 7,
      max: 10,
      value: t.forestPlot.radius.max,
      onChange: (b) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              max: Number(b.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  ))));
}, Ki = n.createContext({}), Fw = (e) => {
  const { updateConfig: t, config: r, rawData: a } = se.useContext(ft), { getColumns: i, selectComponent: o } = e, d = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], c = (s, p, y) => {
    let g = [...r.series];
    if (g[s][y] = p, y === "type" && p === "Bar" && (g[s].axis = "Left"), g[s].type === "Forecasting") {
      let b = Array.from(new Set(a.map((S) => S[g[s].dataKey]))), w = [];
      b.forEach((S) => {
        w.push({ key: S });
      }), g[s].stages = w, g[s].stageColumn = g[s].dataKey;
    }
    t({ ...r, series: g });
  };
  return /* @__PURE__ */ n.createElement(Ki.Provider, { value: { updateSeries: c, supportedRightAxisTypes: d, getColumns: i, selectComponent: o } }, e.children);
}, Mw = (e) => {
  const { config: t, updateConfig: r } = se.useContext(ft), { series: a, index: i } = e;
  if (!(() => {
    let s = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart", "Bump Chart"].some((y) => y.includes(a.type)) && (s = !0), s;
  })())
    return;
  const d = (s, p) => {
    let y = [...t.series];
    y[s].lineType = p, r({ ...t, series: y });
  };
  let c = [];
  return Object.keys(il).map((s) => c.push(il[s])), /* @__PURE__ */ n.createElement(
    Ka,
    {
      initial: "Select an option",
      value: a.lineType ? a.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (s) => {
        d(i, s.target.value);
      },
      options: c
    }
  );
}, zw = (e) => {
  const { config: t } = se.useContext(ft), { updateSeries: r } = se.useContext(Ki), { index: a, series: i } = e, o = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line" || t.visualizationType === "Bump Chart")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo", "Bump Chart"].includes(t.visualizationType))
    return /* @__PURE__ */ n.createElement(
      Ka,
      {
        initial: "Select an option",
        value: i.type,
        label: "Series Type",
        onChange: (d) => {
          r(a, d.target.value, "type");
        },
        options: o()
      }
    );
}, Bw = (e) => {
  const { config: t, updateConfig: r, rawData: a } = se.useContext(ft), { updateSeries: i, getColumns: o } = se.useContext(Ki), { index: d, series: c } = e;
  return /* @__PURE__ */ n.createElement(
    Ka,
    {
      initial: "Select an option",
      value: c.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (s) => {
        let p = [], y = new Set(a == null ? void 0 : a.map((b) => b[s.target.value]));
        y = Array.from(y), y = y.filter((b) => b !== void 0), y.forEach((b) => p.push({ key: b }));
        const g = [...t.series];
        g[d] = { ...g[d], stages: p, stageColumn: s.target.value }, r({
          ...t,
          series: g
        });
      },
      options: o(!1)
    }
  );
}, Iw = (e) => {
  const { config: t, rawData: r } = se.useContext(ft), { updateSeries: a } = se.useContext(Ki), { index: i, series: o } = e;
  if (o.type !== "Forecasting" || !r || !o.stageColumn)
    return;
  let d = new Set(r.map((c) => c[o.stageColumn]));
  return d = Array.from(d), d = d.filter((c) => c !== void 0), /* @__PURE__ */ n.createElement(
    Ka,
    {
      initial: "Select an option",
      value: o.stageItem,
      label: "Forecasting Item Column",
      onChange: (c) => {
        a(i, c.target.value, "stageItem");
      },
      options: d
    }
  );
}, $w = (e) => {
  const { config: t } = se.useContext(ft), { updateSeries: r, supportedRightAxisTypes: a } = se.useContext(Ki), { index: i, series: o } = e;
  if (!(t.visualizationType !== "Combo" || !o) && a.includes(o.type))
    return /* @__PURE__ */ n.createElement(
      Ka,
      {
        initial: "Select an option",
        value: o.axis ? o.axis : "Left",
        label: "Series Axis",
        onChange: (d) => {
          r(i, d.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, Hw = (e) => {
  var o;
  const { config: t, updateConfig: r } = se.useContext(ft), { index: a, series: i } = e;
  if (i.type === "Forecasting" && i)
    return (o = i == null ? void 0 : i.stages) == null ? void 0 : o.map((d, c) => {
      var s, p, y, g;
      return /* @__PURE__ */ n.createElement(
        Ka,
        {
          key: `${d}--${c}`,
          initial: "Select an option",
          value: (p = (s = t.series) == null ? void 0 : s[a].stages) != null && p[c].color ? (g = (y = t.series) == null ? void 0 : y[a].stages) == null ? void 0 : g[c].color : "Select",
          label: `${d.key} Series Color`,
          onChange: (b) => {
            const w = [...t.series], S = w[a].stages;
            S[c].color = b.target.value, w[a] = { ...w[a], stages: S }, r({
              ...t,
              series: w
            });
          },
          options: Object.keys(Yu)
        }
      );
    });
}, Vw = (e) => {
  var d;
  const { config: t, updateConfig: r } = se.useContext(ft), { series: a, index: i } = e, { getColumns: o } = se.useContext(Ki);
  if (a.type === "Forecasting")
    return /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Confidence Interval Groups"), /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, (d = a == null ? void 0 : a.confidenceIntervals) == null ? void 0 : d.map((c, s) => {
      const p = c.showInTooltip ? c.showInTooltip : !1, y = (g, b, w) => {
        g.preventDefault();
        let S = [...t.series];
        S[b].confidenceIntervals[w].showInTooltip = !p, r({
          ...t,
          series: S
        });
      };
      return /* @__PURE__ */ n.createElement(Mn, { className: "series-item series-item--chart", key: `${s}` }, /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Bn, { className: "accordion__button accordion__button" }, "Group ", s + 1, /* @__PURE__ */ n.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (g) => {
            g.preventDefault();
            const b = [...t.series[i].confidenceIntervals];
            b.splice(s, 1);
            const w = [...t.series];
            w[i] = { ...w[i], confidenceIntervals: [...b] }, r({
              ...t,
              series: w
            });
          }
        },
        "Remove"
      )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("div", { className: "input-group" }, /* @__PURE__ */ n.createElement("label", { htmlFor: "showInTooltip" }, "Show In Tooltip"), /* @__PURE__ */ n.createElement(
        "div",
        {
          className: "cove-input__checkbox--small",
          onClick: (g) => y(g, i, s)
        },
        /* @__PURE__ */ n.createElement(
          "div",
          {
            className: "cove-input__checkbox-box custom-color",
            style: { backgroundColor: "" }
          },
          p && /* @__PURE__ */ n.createElement(zm, { className: "", style: { fill: "#025eaa" } })
        ),
        /* @__PURE__ */ n.createElement(
          "input",
          {
            className: "cove-input--hidden",
            type: "checkbox",
            name: "showInTooltip",
            checked: p || !1,
            readOnly: !0
          }
        )
      )), /* @__PURE__ */ n.createElement(
        Ka,
        {
          initial: "Select an option",
          value: t.series[i].confidenceIntervals[s].low ? t.series[i].confidenceIntervals[s].low : "Select",
          label: "Low Confidence Interval",
          onChange: (g) => {
            const b = [...t.series[i].confidenceIntervals];
            b[s].low = g.target.value;
            const w = [...t.series];
            w[i] = { ...w[i], confidenceIntervals: b }, r({
              ...t,
              series: w
            });
          },
          options: o()
        }
      ), /* @__PURE__ */ n.createElement(
        Ka,
        {
          initial: "Select an option",
          value: t.series[i].confidenceIntervals[s].high ? t.series[i].confidenceIntervals[s].high : "Select",
          label: "High Confidence Interval",
          onChange: (g) => {
            const b = [...t.series[i].confidenceIntervals];
            b[s].high = g.target.value;
            const w = [...t.series];
            w[i] = { ...w[i], confidenceIntervals: b }, r({
              ...t,
              series: w
            });
          },
          options: o()
        }
      )));
    })), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (c) => {
          c.preventDefault();
          let s = null;
          t.series[i].confidenceIntervals ? s = [...t.series[i].confidenceIntervals] : s = [];
          const p = [...t.series];
          p[i] = {
            ...p[i],
            confidenceIntervals: [...s, { high: "", low: "" }]
          }, r({
            ...t,
            series: p
          });
        }
      },
      "Add Confidence Interval Group"
    )));
}, Ww = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = se.useContext(ft);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const d = (c, s, p, y) => {
    let g = [...a.series], b = { ...a.runtime.seriesLabels };
    g[c].weight = s && Math.max(Number(p), Math.min(Number(y), Number(s))), b[g[c].dataKey] = g[c].weight ? g[c].weight : g[c].dataKey;
    const w = {
      ...a,
      series: g,
      runtime: {
        ...a.runtime,
        seriesLabels: b
      }
    };
    i(w);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "series-weight" }, "Line Weight"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      key: `series-weight-${r}`,
      value: t.weight ? t.weight : "",
      min: "1",
      max: "9",
      onChange: (c) => {
        d(r, c.target.value, c.target.min, c.target.max);
      }
    }
  ));
}, jw = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = se.useContext(ft);
  if (![
    "Bump Chart",
    "Bar",
    "Line",
    "Area Chart",
    "Combo",
    "Deviation",
    "Paired",
    "Scatter",
    "dashed-sm",
    "dashed-md",
    "dashed-lg"
  ].includes(t.type))
    return;
  const d = (c, s) => {
    let p = [...a.series], y = { ...a.runtime.seriesLabels };
    p[c].name = s, y[p[c].dataKey] = p[c].name ? p[c].name : p[c].dataKey;
    let g = {
      ...a,
      series: p,
      runtime: {
        ...a.runtime,
        seriesLabels: y
      }
    };
    i(g);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "series-name" }, "Series Name"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      key: `series-name-${r}`,
      value: t.name ? t.name : "",
      onChange: (c) => {
        d(r, c.target.value);
      }
    }
  ));
}, Uw = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = se.useContext(ft);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(a.visualizationType))
    return;
  const o = (d) => {
    let c = [...a.series];
    c[d].tooltip && c[d].tooltip, c[d].tooltip = !c[d].tooltip, i({
      ...a,
      series: c
    });
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: "input-group" }, /* @__PURE__ */ n.createElement("label", { htmlFor: `series-tooltip--${r}` }, "Show In Tooltip"), /* @__PURE__ */ n.createElement("div", { className: "cove-input__checkbox--small", onClick: (d) => o(r) }, /* @__PURE__ */ n.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, t.tooltip && /* @__PURE__ */ n.createElement(zm, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ n.createElement(
    "input",
    {
      className: "cove-input--hidden",
      type: "checkbox",
      name: `series-tooltip--${r}`,
      checked: t.tooltip ? t.tooltip : !1,
      readOnly: !0
    }
  ))));
}, Kw = (e) => {
  const { config: t, updateConfig: r } = se.useContext(ft), { series: a, index: i } = e, o = (c) => {
    let s = [...t.series], p = -1;
    for (let y = 0; y < s.length; y++)
      if (s[y].dataKey === c) {
        p = y;
        break;
      }
    if (p !== -1) {
      s.splice(p, 1);
      let y = { ...t, series: s };
      s.length === 0 && delete y.series, r(y);
    }
    t.visualizationType === "Paired Bar" && r({
      ...t,
      series: []
    });
  }, d = (c, s, p) => {
    c.preventDefault(), o(s.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ n.createElement("button", { className: "series-list__remove", onClick: (c) => d(c, a) }, "Remove");
}, xg = (e) => {
  const { config: t } = se.useContext(ft), { updateSeries: r, getColumns: a } = se.useContext(Ki), { series: i, getItemStyle: o, sortableItemStyles: d, chartsWithOptions: c, index: s } = e, p = ["Bar", "Line"].includes(t.visualizationType) && t.visualizationSubType !== "Stacked" && !t.series.find((y) => y.dynamicCategory && y.dataKey !== i.dataKey);
  return /* @__PURE__ */ n.createElement(Ig, { key: i.dataKey, draggableId: `draggableFilter-${i.dataKey}`, index: s }, (y, g) => /* @__PURE__ */ n.createElement(
    "div",
    {
      key: s,
      className: g.isDragging ? "currently-dragging" : "",
      style: o(g.isDragging, y.draggableProps.style, d),
      ref: y.innerRef,
      ...y.draggableProps,
      ...y.dragHandleProps
    },
    /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, /* @__PURE__ */ n.createElement(Mn, { className: "series-item series-item--chart" }, /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(
      Bn,
      {
        className: c.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow"
      },
      /* @__PURE__ */ n.createElement(Ue, { display: "move", size: 15, style: { cursor: "default" } }),
      i.dataKey,
      /* @__PURE__ */ n.createElement(Jr.Button.Remove, { series: i, index: s })
    )), c.includes(t.visualizationType) && /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(Jr.Input.Name, { series: i, index: s }), p && /* @__PURE__ */ n.createElement(
      dt,
      {
        label: "Dynamic Category",
        value: i.dynamicCategory,
        options: ["- Select - ", ...a().filter((b) => i.dataKey !== b)],
        updateField: (b, w, S, L) => {
          L === "- Select -" && (L = ""), r(s, L, "dynamicCategory");
        },
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This field is Optional. If you have a dynamic data series you can select the category field here. You can only add one dynamic category per visualization.")))
      }
    ), /* @__PURE__ */ n.createElement(Jr.Input.Weight, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Dropdown.SeriesType, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Dropdown.AxisPosition, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Dropdown.LineType, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Dropdown.ForecastingColor, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Dropdown.ConfidenceInterval, { series: i, index: s }), /* @__PURE__ */ n.createElement(Jr.Checkbox.DisplayInTooltip, { series: i, index: s }))))
  ));
}, Yw = (e) => {
  const { series: t, getItemStyle: r, sortableItemStyles: a, chartsWithOptions: i } = e;
  return t.map((o, d) => /* @__PURE__ */ n.createElement(
    xg,
    {
      getItemStyle: r,
      sortableItemStyles: a,
      chartsWithOptions: i,
      series: o,
      index: d,
      key: `series-list-${d}`
    }
  ));
}, Jr = {
  Wrapper: Fw,
  Dropdown: {
    SeriesType: zw,
    AxisPosition: $w,
    ConfidenceInterval: Vw,
    LineType: Mw,
    ForecastingStage: Bw,
    ForecastingColumn: Iw,
    ForecastingColor: Hw
  },
  Input: {
    Name: jw,
    Weight: Ww
  },
  Checkbox: {
    DisplayInTooltip: Uw
  },
  Button: {
    Remove: Kw
  },
  Item: xg,
  List: Yw
}, Gw = se.memo(({ config: e, updateConfig: t }) => {
  let r = (s, p, y) => {
    let g = [];
    e.regions && (g = [...e.regions]), g[y][s] = p, t({ ...e, regions: g });
  }, a = (s, p, y, g, b) => r(y, g, b), i = (s) => {
    let p = [];
    e.regions && (p = [...e.regions]), p.splice(s, 1), t({ ...e, regions: p });
  }, o = () => {
    let s = [];
    e.regions && (s = [...e.regions]), s.push({}), t({ ...e, regions: s });
  };
  const d = ["Fixed", "Previous Days"], c = ["Last Date", "Fixed"];
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.regions && e.regions.map(({ label: s, color: p, from: y, to: g, background: b, range: w = "Custom" }, S) => {
    var L;
    return /* @__PURE__ */ n.createElement("div", { className: "edit-block", key: `region-${S}` }, /* @__PURE__ */ n.createElement(
      "button",
      {
        type: "button",
        className: "btn btn-danger remove-column",
        onClick: (m) => {
          m.preventDefault(), i(S);
        }
      },
      "Remove"
    ), /* @__PURE__ */ n.createElement(We, { value: s, label: "Region Label", fieldName: "label", i: S, updateField: a }), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      We,
      {
        value: p,
        label: "Text Color",
        fieldName: "color",
        updateField: (m, v, A, P) => r(A, P, S)
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: b,
        label: "Background",
        fieldName: "background",
        updateField: (m, v, A, P) => r(A, P, S)
      }
    )), /* @__PURE__ */ n.createElement(
      dt,
      {
        value: e.regions[S].fromType ?? "Fixed",
        label: "Minimum Region Type",
        initial: "Select",
        required: !0,
        onChange: (m) => {
          if (m.target.value !== "" && m.target.value !== "Select") {
            const v = [...e.regions];
            v[S].fromType = m.target.value, t({
              ...e,
              regions: v
            });
          }
          m.target.value = "";
        },
        options: d
      }
    ), (e.regions[S].fromType === "Fixed" || e.regions[S].fromType === "Previous Days" || !e.regions[S].fromType) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: y,
        label: e.regions[S].fromType === "Fixed" || !((L = e.regions[S]) != null && L.fromType) ? "From Value" : "Previous Number of Days",
        fieldName: "from",
        updateField: (m, v, A, P) => r(A, P, S),
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value.")))
      }
    )), /* @__PURE__ */ n.createElement(
      dt,
      {
        value: e.regions[S].toType ?? "Fixed",
        label: "Maximum Region Type",
        initial: "Select",
        required: !0,
        onChange: (m) => {
          if (m.target.value !== "" && m.target.value !== "Select") {
            const v = [...e.regions];
            v[S].toType = m.target.value, t({
              ...e,
              regions: v
            });
          }
          m.target.value = "";
        },
        options: c
      }
    ), (e.regions[S].toType === "Fixed" || !e.regions[S].toType) && /* @__PURE__ */ n.createElement(
      We,
      {
        value: g,
        label: "To Value",
        fieldName: "to",
        updateField: (m, v, A, P) => r(A, P, S)
      }
    ));
  }), !e.regions && /* @__PURE__ */ n.createElement("p", { style: { textAlign: "center" } }, "There are currently no regions."), /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-primary full-width",
      onClick: (s) => {
        s.preventDefault(), o();
      }
    },
    "Add Region"
  ));
}), Xw = ({ name: e }) => {
  const { visSupportsRegions: t } = _s(), { config: r, updateConfig: a } = se.useContext(ft);
  return t() ? /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, e)), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(Gw, { config: r, updateConfig: a }))) : null;
}, Tp = se.createContext(null), Cp = () => {
  const e = se.useContext(Tp);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, qw = (e) => {
  const { config: t } = se.useContext(ft), { updateField: r } = Cp(), {
    enabledChartTypes: a,
    visHasNumbersOnBars: i,
    visHasaAdditionalLabelsOnBars: o,
    visHasLabelOnData: d,
    visSupportsChartHeight: c,
    visSupportsMobileChartHeight: s,
    visSupportsSuperTitle: p,
    visSupportsFootnotes: y
  } = _s(), { visualizationType: g, visualizationSubType: b, barStyle: w } = t, S = () => (g === "Bar" || g === "Deviation Bar") && b !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ n.createElement(Mn, null, " ", /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "General")), /* @__PURE__ */ n.createElement(In, null, (t == null ? void 0 : t.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement(
    dt,
    {
      value: g,
      fieldName: "visualizationType",
      label: "Chart Type",
      updateField: r,
      options: a
    }
  ), c() && t.orientation === "vertical" && /* @__PURE__ */ n.createElement("div", { className: s() ? "two-col-inputs" : "" }, /* @__PURE__ */ n.createElement(
    We,
    {
      type: "number",
      value: t.heights.vertical,
      section: "heights",
      fieldName: "vertical",
      label: "Chart Height",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, "˝", /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "For some visualization types, such as the Sankey diagram, it may be necessary to adjust the chart height for optimal display.")))
    }
  ), s() && t.orientation === "vertical" && /* @__PURE__ */ n.createElement(
    We,
    {
      type: "number",
      value: t.heights.mobileVertical,
      section: "heights",
      fieldName: "mobileVertical",
      label: "Mobile Height",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "If the chart height is not optimized for mobile, you can adjust the height for better display. Not setting a value will default to the chart height.")))
    }
  )), (g === "Bar" || g === "Combo" || g === "Area Chart") && /* @__PURE__ */ n.createElement(
    dt,
    {
      value: b || "Regular",
      fieldName: "visualizationSubType",
      label: "Chart Subtype",
      updateField: r,
      options: ["regular", "stacked"]
    }
  ), g === "Area Chart" && b === "stacked" && /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.stackedAreaChartLineType || "Linear",
      fieldName: "stackedAreaChartLineType",
      label: "Stacked Area Chart Line Type",
      updateField: r,
      options: Object.keys(il)
    }
  ), g === "Bar" && /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.orientation || "vertical",
      fieldName: "orientation",
      label: "Orientation",
      updateField: r,
      options: ["vertical", "horizontal"]
    }
  ), g === "Deviation Bar" && /* @__PURE__ */ n.createElement(dt, { label: "Orientation", options: ["horizontal"] }), (g === "Bar" || g === "Deviation Bar") && /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.isLollipopChart ? "lollipop" : w || "flat",
      fieldName: "barStyle",
      label: "bar style",
      updateField: r,
      options: S(),
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Consider using the 'Flat' bar style when presenting data that includes '0' values.")))
    }
  ), (g === "Bar" || g === "Deviation Bar") && w === "rounded" && /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.tipRounding || "top",
      fieldName: "tipRounding",
      label: "tip rounding",
      updateField: r,
      options: ["top", "full"]
    }
  ), (g === "Bar" || g === "Deviation Bar") && w === "rounded" && /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.roundingStyle || "standard",
      fieldName: "roundingStyle",
      label: "rounding style",
      updateField: r,
      options: ["standard", "shallow", "finger"]
    }
  ), g === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.yAxis.labelPlacement || "Below Bar",
      section: "yAxis",
      fieldName: "labelPlacement",
      label: "Label Placement",
      updateField: r,
      options: ["Below Bar", "On Date/Category Axis"]
    }
  ), i() ? /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.yAxis.displayNumbersOnBar,
      section: "yAxis",
      fieldName: "displayNumbersOnBar",
      label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar",
      updateField: r
    }
  ) : d() && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.labels,
      fieldName: "labels",
      label: "Display label on data",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Recommended set to display for Section 508 compliance."), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("p", null, "Selecting this option will ", /* @__PURE__ */ n.createElement("i", null, " not "), ' hide the display of "zero value", "suppressed data", or "missing data" indicators on the chart (if applicable).')))
    }
  ), o() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Qe,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Selecting this option will display a thin line slightly above the Date/Category Axis to indicate "zero value" where zero values are indicated in the Data Series.'))),
      value: t.general.showZeroValueData,
      section: "general",
      fieldName: "showZeroValueData",
      label: 'Display "Zero Data" Label',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, t.visualizationSubType === "stacked" && /* @__PURE__ */ n.createElement("p", null, "We do not recommend using stacked vertical/horizontal bar charts for missing data. If you choose to proceed, selecting this option will display 'N/A' in the tooltip hover and data table (e.g. nothing will display in chart)."), t.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("p", null, "Selecting this option will display 'N/A' on the Date/Category Axis, in the tooltip hover, and in the data table to indicate missing or undefined data values."))),
      value: t.general.showMissingDataLabel,
      section: "general",
      fieldName: "showMissingDataLabel",
      label: 'Display "Missing Data" Label',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      display: t.visualizationType === "Bar" || t.visualizationType === "Combo",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting 'Remove Null Values' will hide the 'N/A' (no data indicator) when you hover over the chart."))),
      value: t.general.hideNullValue,
      section: "general",
      fieldName: "hideNullValue",
      label: 'Remove "Null" Values From Hover',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, t.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("p", null, "Selecting this option will show the ", /* @__PURE__ */ n.createElement("i", null, "suppression indicator "), " on the Date/Category axis, within tooltips, and in the data table where suppressed data values appear in the Data Series."), t.visualizationSubType === "stacked" && /* @__PURE__ */ n.createElement("p", null, "We do not recommend using stacked vertical/horizontal bar charts for suppressed data. If you choose to proceed, selecting this option will display the 'suppressed data symbol' in the tooltip hover and data table (e.g., nothing will display in the chart)."))),
      value: t.general.showSuppressedSymbol,
      section: "general",
      fieldName: "showSuppressedSymbol",
      label: 'Display "suppressed data" label',
      updateField: r
    }
  )), g === "Pie" && /* @__PURE__ */ n.createElement(dt, { fieldName: "pieType", label: "Pie Chart Type", updateField: r, options: ["Regular", "Donut"] }), g === "Line" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.allowLineToBarGraph,
      fieldName: "allowLineToBarGraph",
      label: "Convert to Bar Graph",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Switch to bar graph when less than 3 data points available.")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      value: t.title || "Chart Title",
      fieldName: "title",
      id: "title",
      label: "Title",
      placeholder: "Chart Title",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Title is required to set the name of the download file but can be hidden using the option below.")))
    }
  ), /* @__PURE__ */ n.createElement(Qe, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: r }), p() && /* @__PURE__ */ n.createElement(
    We,
    {
      value: t.superTitle,
      updateField: r,
      fieldName: "superTitle",
      label: "Super Title",
      placeholder: "Super Title",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Super Title")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "textarea",
      value: t.introText,
      updateField: r,
      fieldName: "introText",
      label: "Message",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Intro Text")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "textarea",
      value: t.description,
      fieldName: "description",
      label: "Subtext/Citation",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub.")))
    }
  ), y() && /* @__PURE__ */ n.createElement(
    We,
    {
      type: "textarea",
      value: t.footnotes,
      updateField: r,
      fieldName: "footnotes",
      label: "Footnotes",
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data.")))
    }
  )));
}, Zw = (e) => {
  const { config: t } = se.useContext(ft), { boxplot: r } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: a } = Cp();
  return /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, e.name)), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("h4", { style: { fontSize: "18px" } }, "Labels for 5-Number Summary"), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.maximum,
      fieldName: "maximum",
      section: "boxplot",
      subsection: "labels",
      label: "Maximum",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Highest value, excluding outliers")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.q3,
      fieldName: "q3",
      section: "boxplot",
      subsection: "labels",
      label: "Upper Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Represented by top line of box. 25% of data are higher.")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.median,
      fieldName: "median",
      section: "boxplot",
      subsection: "labels",
      label: "Median",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Middle data point. Half of data are higher value.")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.q1,
      fieldName: "q1",
      section: "boxplot",
      subsection: "labels",
      label: "Lower Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Represented by bottom line of box. 25% of data are lower.")))
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.minimum,
      fieldName: "minimum",
      section: "boxplot",
      subsection: "labels",
      label: "Minimum",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Lowest value, excluding outliers")))
    }
  ), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", { style: { fontSize: "18px" } }, "Labels for Additional Measures"), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.iqr,
      fieldName: "iqr",
      section: "boxplot",
      subsection: "labels",
      label: "Interquartile Range",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.count,
      fieldName: "count",
      section: "boxplot",
      subsection: "labels",
      label: "Count",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.mean,
      fieldName: "mean",
      section: "boxplot",
      subsection: "labels",
      label: "Mean",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.outliers,
      fieldName: "outliers",
      section: "boxplot",
      subsection: "labels",
      label: "Outliers",
      updateField: a
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      type: "text",
      value: r.labels.values,
      fieldName: "values",
      section: "boxplot",
      subsection: "labels",
      label: "Values",
      updateField: a
    }
  )));
}, Qw = (e, t) => {
  let r = [], a = [], i = [];
  const o = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const d = e.twoColor.isPaletteReversed;
    r = Object.keys(Pc).filter(
      (c) => d ? c.endsWith("reverse") : !c.endsWith("reverse")
    );
  } else {
    const d = [], c = [];
    for (const s in Sr) {
      const p = s.startsWith("sequential"), y = s.startsWith("qualitative"), g = s.startsWith("colorblindsafe"), b = s.endsWith("reverse");
      p && (!e.isPaletteReversed && !b || e.isPaletteReversed && b) && d.push(s), y && (!e.isPaletteReversed && !b || e.isPaletteReversed && b) && c.push(s), g && (!e.isPaletteReversed && !b || e.isPaletteReversed && b) && o.push(s);
    }
    a = d, i = c;
  }
  return se.useEffect(() => {
    let d = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (d = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (d = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: d } });
  }, [e.twoColor.isPaletteReversed]), se.useEffect(() => {
    let d = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (d = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (d = e.palette.slice(0, -7)), t({ ...e, palette: d });
  }, [e.isPaletteReversed]), { twoColorPalettes: r, sequential: a, nonSequential: i, accessibleColors: o };
}, Jw = (e) => {
  var ae;
  const { config: t, updateConfig: r, colorPalettes: a, twoColorPalette: i } = se.useContext(ft), { visual: o } = t, { setLollipopShape: d, updateField: c } = Cp(), {
    visHasBarBorders: s,
    visCanAnimate: p,
    visSupportsNonSequentialPallete: y,
    headerColors: g,
    visSupportsTooltipOpacity: b,
    visSupportsTooltipLines: w,
    visSupportsBarSpace: S,
    visSupportsBarThickness: L,
    visHasDataCutoff: m,
    visSupportsSequentialPallete: v,
    visSupportsReverseColorPalette: A,
    visHasSingleSeriesTooltip: P
  } = _s(), { twoColorPalettes: T, sequential: _, nonSequential: M, accessibleColors: Z } = Qw(t, r), Y = (j, q) => {
    if (console.log("value", q), j === "storyNodeFontColor") {
      r({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: q
        }
      });
      return;
    } else
      r({
        ...t,
        sankey: {
          ...t.sankey,
          [j]: {
            ...t.sankey[j],
            default: q
          }
        }
      });
  };
  return /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Visual")), /* @__PURE__ */ n.createElement(In, null, (t.barStyle === "lollipop" || t.isLollipopChart) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", { className: "header" }, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Lollipop Shape"), /* @__PURE__ */ n.createElement(
    "div",
    {
      onChange: (j) => {
        d(j.target.value);
      }
    },
    /* @__PURE__ */ n.createElement("label", { className: "radio-label" }, /* @__PURE__ */ n.createElement("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }), "Circle"),
    /* @__PURE__ */ n.createElement("label", { className: "radio-label" }, /* @__PURE__ */ n.createElement("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }), "Square")
  )), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone",
      fieldName: "lollipopColorStyle",
      label: "Lollipop Color Style",
      updateField: c,
      options: ["regular", "two-tone"]
    }
  ), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.lollipopSize ? t.lollipopSize : "small",
      fieldName: "lollipopSize",
      label: "Lollipop Size",
      updateField: c,
      options: ["small", "medium", "large"]
    }
  )), t.visualizationType === "Box Plot" && /* @__PURE__ */ n.createElement("fieldset", { className: "fieldset fieldset--boxplot" }, /* @__PURE__ */ n.createElement("legend", { className: "" }, "Box Plot Settings"), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.boxplot.borders,
      fieldName: "borders",
      section: "boxplot",
      label: "Box Plot Borders",
      updateField: c,
      options: ["true", "false"]
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.boxplot.plotOutlierValues,
      fieldName: "plotOutlierValues",
      section: "boxplot",
      label: "Plot Outliers",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.boxplot.plotNonOutlierValues,
      fieldName: "plotNonOutlierValues",
      section: "boxplot",
      label: "Plot non-outlier values",
      updateField: c
    }
  )), s() && /* @__PURE__ */ n.createElement(
    dt,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
        Ue,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Recommended set to display for Section 508 compliance."))),
      value: t.barHasBorder,
      fieldName: "barHasBorder",
      label: "Bar Borders",
      updateField: c,
      options: ["true", "false"]
    }
  ), p() && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.animate,
      fieldName: "animate",
      label: "Animate Visualization",
      updateField: c
    }
  ), (((ae = t.series) == null ? void 0 : ae.some(
    (j) => j.type === "Line" || j.type === "dashed-lg" || j.type === "dashed-sm" || j.type === "dashed-md"
  )) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    dt,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
        Ue,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Shapes will appear in the following order: circle, square, triangle, diamond, and inverted triangle. Use with a maximum of 5 data points."))),
      value: t.visual.lineDatapointSymbol,
      section: "visual",
      fieldName: "lineDatapointSymbol",
      label: "Line Datapoint Symbols",
      updateField: c,
      options: ["none", "standard"]
    }
  ), t.series.length > t.visual.maximumShapeAmount && t.visual.lineDatapointSymbol === "standard" && /* @__PURE__ */ n.createElement("small", { className: "text-danger" }, "Standard only supports up to 7 data points"), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.lineDatapointStyle,
      fieldName: "lineDatapointStyle",
      label: "Line Datapoint Style",
      updateField: c,
      options: ["hidden", "hover", "always show"]
    }
  ), /* @__PURE__ */ n.createElement(
    dt,
    {
      value: t.lineDatapointColor,
      fieldName: "lineDatapointColor",
      label: "Line Datapoint Color",
      updateField: c,
      options: ["Same as Line", "Lighter than Line"]
    }
  )), /* @__PURE__ */ n.createElement("label", { className: "header" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Header Theme"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, g.map((j) => /* @__PURE__ */ n.createElement(
    "button",
    {
      title: j,
      key: j,
      onClick: (q) => {
        q.preventDefault(), r({ ...t, theme: j });
      },
      className: t.theme === j ? "selected " + j : j
    }
  )))), (y() || y()) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Chart Color Palette")), A() && /* @__PURE__ */ n.createElement(
    Mp,
    {
      fieldName: "isPaletteReversed",
      size: "small",
      label: "Use selected palette in reverse order",
      updateField: c,
      value: t.isPaletteReversed
    }
  ), v() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", null, "Sequential"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, _.map((j) => {
    const q = {
      backgroundColor: a[j][2]
    }, te = {
      backgroundColor: a[j][3]
    }, le = {
      backgroundColor: a[j][5]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: j,
        key: j,
        onClick: (B) => {
          B.preventDefault(), r({ ...t, palette: j });
        },
        className: t.palette === j ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: q }),
      /* @__PURE__ */ n.createElement("span", { style: te }),
      /* @__PURE__ */ n.createElement("span", { style: le })
    );
  }))), y() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", null, "Non-Sequential"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, M.map((j) => {
    const q = {
      backgroundColor: a[j][2]
    }, te = {
      backgroundColor: a[j][4]
    }, le = {
      backgroundColor: a[j][6]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: j,
        key: j,
        onClick: (B) => {
          B.preventDefault(), r({ ...t, palette: j });
        },
        className: t.palette === j ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: q }),
      /* @__PURE__ */ n.createElement("span", { style: te }),
      /* @__PURE__ */ n.createElement("span", { style: le })
    );
  })), /* @__PURE__ */ n.createElement("span", null, "Colorblind Safe"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, Z.map((j) => {
    const q = {
      backgroundColor: a[j][2]
    }, te = {
      backgroundColor: a[j][3]
    }, le = {
      backgroundColor: a[j][5]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: j,
        key: j,
        onClick: (B) => {
          B.preventDefault(), r({ ...t, palette: j });
        },
        className: t.palette === j ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: q }),
      /* @__PURE__ */ n.createElement("span", { style: te }),
      /* @__PURE__ */ n.createElement("span", { style: le })
    );
  })))), t.visualizationType === "Sankey" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.nodeColor.default,
      id: "storyNodeColor",
      name: "storyNodeColor",
      onChange: (j) => Y("nodeColor", j.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "storyNodeColor" }, "Story Node Color")), /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.storyNodeFontColor || "red",
      id: "storyNodeFontColor",
      name: "storyNodeFontColor",
      onChange: (j) => Y("storyNodeFontColor", j.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "storyNodeFontColor" }, "Story Node Font Color")), /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.linkColor.default,
      id: "linkColor",
      name: "linkColor",
      onChange: (j) => Y("linkColor", j.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "linkColor" }, "Link Color"))), (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Mp,
    {
      section: "twoColor",
      fieldName: "isPaletteReversed",
      size: "small",
      label: "Use selected palette in reverse order",
      updateField: c,
      value: t.twoColor.isPaletteReversed
    }
  ), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, T.map((j) => {
    const q = {
      backgroundColor: i[j][0]
    }, te = {
      backgroundColor: i[j][1]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: j,
        key: j,
        onClick: (le) => {
          le.preventDefault(), r({ ...t, twoColor: { ...t.twoColor, palette: j } });
        },
        className: t.twoColor.palette === j ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { className: "two-color", style: q }),
      /* @__PURE__ */ n.createElement("span", { className: "two-color", style: te })
    );
  }))), m() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    We,
    {
      value: t.dataCutoff,
      type: "number",
      fieldName: "dataCutoff",
      className: "number-narrow",
      label: "Data Cutoff",
      updateField: c,
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.')))
    }
  )), L() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ n.createElement(
    We,
    {
      type: "number",
      value: t.barHeight || "25",
      fieldName: "barHeight",
      label: " Bar Thickness",
      updateField: c,
      min: 15
    }
  ), (t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    We,
    {
      value: t.barThickness,
      type: "number",
      fieldName: "barThickness",
      label: "Bar Thickness",
      updateField: c
    }
  ), S() && /* @__PURE__ */ n.createElement(
    We,
    {
      type: "number",
      value: t.barSpace || "15",
      fieldName: "barSpace",
      label: "Bar Space",
      updateField: c,
      min: 0
    }
  ), (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.topAxis.hasLine,
      section: "topAxis",
      fieldName: "hasLine",
      label: "Add Top Axis Line",
      updateField: c
    }
  ), t.visualizationType === "Spark Line" && /* @__PURE__ */ n.createElement("div", { className: "cove-accordion__panel-section checkbox-group" }, /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o == null ? void 0 : o.border,
      section: "visual",
      fieldName: "border",
      label: "Show Border",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o == null ? void 0 : o.borderColorTheme,
      section: "visual",
      fieldName: "borderColorTheme",
      label: "Use Border Color Theme",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o == null ? void 0 : o.accent,
      section: "visual",
      fieldName: "accent",
      label: "Use Accent Style",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o == null ? void 0 : o.background,
      section: "visual",
      fieldName: "background",
      label: "Use Theme Background Color",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o == null ? void 0 : o.hideBackgroundColor,
      section: "visual",
      fieldName: "hideBackgroundColor",
      label: "Hide Background Color",
      updateField: c
    }
  )), (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.showLineSeriesLabels,
      fieldName: "showLineSeriesLabels",
      label: "Append Series Name to End of Line Charts",
      updateField: c
    }
  ), (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.colorMatchLineSeriesLabels,
      fieldName: "colorMatchLineSeriesLabels",
      label: "Match Series Color to Name at End of Line Charts",
      updateField: c
    }
  ), w() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o.verticalHoverLine,
      fieldName: "verticalHoverLine",
      section: "visual",
      label: "Vertical Hover Line",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: o.horizontalHoverLine,
      fieldName: "horizontalHoverLine",
      section: "visual",
      label: "Horizontal Hover Line",
      updateField: c
    }
  )), b() && /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Tooltip Opacity"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      value: t.tooltips.opacity ? t.tooltips.opacity : 100,
      onChange: (j) => r({
        ...t,
        tooltips: {
          ...t.tooltips,
          opacity: j.target.value
        }
      })
    }
  )), P() && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.tooltips.singleSeries,
      fieldName: "singleSeries",
      section: "tooltips",
      label: "SHOW HOVER FOR SINGLE DATA SERIES",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "No Data Message"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: t.chartMessage.noData ? t.chartMessage.noData : "",
      onChange: (j) => r({
        ...t,
        chartMessage: {
          ...t.chartMessage,
          noData: j.target.value
        }
      })
    }
  ))));
}, eT = (e) => {
  var s, p, y, g, b;
  const { config: t, updateConfig: r } = se.useContext(ft), a = (s = t.data) == null ? void 0 : s[0], { updateField: i } = se.useContext(Tp);
  if (t.visualizationType !== "Sankey")
    return;
  const o = (w, S, L) => {
    let m = [];
    a != null && a.storyNodeText && (m = [...a == null ? void 0 : a.storyNodeText]), m[L][w] = S, r({
      ...t,
      sankey: {
        ...t.sankey,
        data: {
          ...t.sankey.data,
          storyNodeText: m
        }
      }
    });
  }, d = () => {
    const w = a;
    w.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), r({
      ...t,
      sankey: {
        ...t.sankey,
        data: [{ ...w }]
      }
    });
  }, c = (w) => {
    const S = a;
    S.storyNodeText.splice(w, 1), r({ ...t, sankey: { ...t.sankey, data: { ...S } } });
  };
  return /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Sankey Settings")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("p", null, "Node stories can provide additional details to support public health messaging. COVE can display a maximum of 3 node stories."), (a == null ? void 0 : a.storyNodeText) && (a == null ? void 0 : a.storyNodeText.map(({ StoryNode: w, segmentTextBefore: S, segmentTextAfter: L }, m) => /* @__PURE__ */ n.createElement(
    "div",
    {
      key: m,
      style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" }
    },
    /* @__PURE__ */ n.createElement("label", null, "Story Node Text", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: w,
        fieldName: "StoryNode",
        label: "StoryNode",
        onChange: (v) => o("StoryNode", v.target.value, m)
      }
    )),
    /* @__PURE__ */ n.createElement("label", null, "Story Text Before", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: S,
        fieldName: "segmentTextBefore",
        label: "Segment Text Before",
        onChange: (v) => o("segmentTextBefore", v.target.value, m)
      }
    )),
    /* @__PURE__ */ n.createElement("label", null, "Story Text After", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: L,
        fieldName: "segmentTextAfter",
        label: "Segment Text After",
        onChange: (v) => o("segmentTextAfter", v.target.value, m)
      }
    )),
    /* @__PURE__ */ n.createElement(Rc, { onClick: (v) => c(m), className: "btn btn-danger full-width" }, "Remove Story Node")
  ))), ((p = a == null ? void 0 : a.storyNodeText) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-primary full-width",
      onClick: (w) => {
        w.preventDefault(), d();
      }
    },
    "Add StoryNode"
  ), ((b = (g = (y = t.data) == null ? void 0 : y[0]) == null ? void 0 : g.tooltips) == null ? void 0 : b.length) > 0 && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.enableTooltips,
      fieldName: "enableTooltips",
      label: "Enable Tooltips",
      updateField: i
    }
  )));
};
const tT = (e) => {
  var c, s, p;
  const { updateConfig: t, config: r, svgRef: a } = se.useContext(ft), i = (y, g, b) => {
    var m;
    const w = (m = document.querySelector(".chart-container  > svg")) == null ? void 0 : m.getBoundingClientRect(), S = [w == null ? void 0 : w.width, w == null ? void 0 : w.height], L = [...r == null ? void 0 : r.annotations];
    L[b][g] = y, L[b].savedDimensions = S, t({
      ...r,
      annotations: L
    });
  }, o = () => {
    var w, S, L, m, v, A, P, T, _, M;
    const y = [
      ((L = (S = (w = a == null ? void 0 : a.current) == null ? void 0 : w.width) == null ? void 0 : S.baseVal) == null ? void 0 : L.value) || ((m = a == null ? void 0 : a.current) == null ? void 0 : m.width),
      ((P = (A = (v = a == null ? void 0 : a.current) == null ? void 0 : v.height) == null ? void 0 : A.baseVal) == null ? void 0 : P.value) || ((T = a == null ? void 0 : a.current) == null ? void 0 : T.height)
    ], g = {
      text: "New Annotation",
      snapToNearestPoint: !1,
      fontSize: 16,
      bezier: 10,
      show: {
        desktop: !0,
        tablet: !0,
        mobile: !0
      },
      connectorType: "line",
      colors: {
        label: "black",
        connector: "black",
        marker: "black"
      },
      selected: !0,
      anchor: {
        vertical: !1,
        horizontal: !1
      },
      marker: "arrow",
      edit: {
        subject: !0,
        label: !0
      },
      seriesKey: "",
      x: 50,
      y: Number((y == null ? void 0 : y[1]) / 2),
      xKey: r.xAxis.type === "date" ? new Date((M = (_ = r == null ? void 0 : r.data) == null ? void 0 : _[0]) == null ? void 0 : M[r.xAxis.dataKey]).getTime() : r.xAxis.type === "categorical" ? "1/15/2016" : "",
      yKey: "",
      dx: 20,
      dy: -20,
      opacity: "100",
      savedDimensions: y,
      connectionType: "line"
    }, b = Array.isArray(r.annotations) ? r.annotations : [];
    t({
      ...r,
      annotations: [...b, g]
    });
  }, d = (y) => {
    const g = r.annotations.filter((b, w) => w !== y);
    t({
      ...r,
      annotations: g
    });
  };
  return /* @__PURE__ */ n.createElement(Tu, { key: e.name }, /* @__PURE__ */ n.createElement(Tu.Section, { title: e.name, key: e.name }, /* @__PURE__ */ n.createElement("label", { key: "key-1" }, "Show Annotation Dropdown", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "checkbox",
      checked: ((c = r == null ? void 0 : r.general) == null ? void 0 : c.showAnnotationDropdown) || !1,
      onChange: (y) => {
        t({
          ...r,
          general: {
            ...r.general,
            showAnnotationDropdown: y.target.checked
          }
        });
      }
    }
  )), r.general.showAnnotationDropdown && /* @__PURE__ */ n.createElement("label", { key: "key-2" }, "Annotation Dropdown Title:", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      style: { marginBottom: "10px" },
      value: (s = r == null ? void 0 : r.general) == null ? void 0 : s.annotationDropdownText,
      onChange: (y) => {
        t({
          ...r,
          general: {
            ...r.general,
            annotationDropdownText: y.target.value
          }
        });
      }
    }
  )), (r == null ? void 0 : r.annotations) && (r == null ? void 0 : r.annotations.map((y, g) => {
    var b, w, S, L, m, v, A, P;
    return /* @__PURE__ */ n.createElement(Tu, { key: g }, /* @__PURE__ */ n.createElement(
      Tu.Section,
      {
        title: y.text ? y.text.substring(0, 15) + "..." : `Annotation ${g + 1}`
      },
      /* @__PURE__ */ n.createElement("div", { className: "annotation-group" }, /* @__PURE__ */ n.createElement("label", null, "Annotation Text:", /* @__PURE__ */ n.createElement(
        "textarea",
        {
          rows: 5,
          value: y.text,
          onChange: (T) => i(T.target.value, "text", g)
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Opacity", /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "range",
          onChange: (T) => {
            const _ = et.cloneDeep(r == null ? void 0 : r.annotations);
            _[g].opacity = T.target.value, t({
              ...r,
              annotations: _
            });
          },
          value: ((w = (b = r == null ? void 0 : r.annotations) == null ? void 0 : b[g]) == null ? void 0 : w.opacity) || "100"
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Edit Subject", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "checkbox",
          checked: ((L = (S = r == null ? void 0 : r.annotations[g]) == null ? void 0 : S.edit) == null ? void 0 : L.subject) || !1,
          onChange: (T) => {
            const _ = et.cloneDeep(r == null ? void 0 : r.annotations);
            _[g].edit.subject = T.target.checked, t({
              ...r,
              annotations: _
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Edit Label", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "checkbox",
          checked: ((v = (m = r == null ? void 0 : r.annotations[g]) == null ? void 0 : m.edit) == null ? void 0 : v.label) || !1,
          onChange: (T) => {
            const _ = et.cloneDeep(r == null ? void 0 : r.annotations);
            _[g].edit.label = T.target.checked, t({
              ...r,
              annotations: _
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Connection Type:", /* @__PURE__ */ n.createElement(
        "select",
        {
          key: "annotation-connection-type",
          onChange: (T) => {
            const _ = et.cloneDeep(r == null ? void 0 : r.annotations);
            _[g].connectionType = T.target.value, t({
              ...r,
              annotations: _
            });
          },
          value: (A = r == null ? void 0 : r.annotations[g]) == null ? void 0 : A.connectionType
        },
        /* @__PURE__ */ n.createElement("option", { key: "select", value: "select" }, "Select"),
        ["curve", "line", "elbow", "none"].map((T, _) => /* @__PURE__ */ n.createElement("option", { key: T, value: T }, T))
      )), y.connectionType === "curve" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, "Curve Control", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "range",
          min: "-20",
          max: "20",
          value: ((P = r == null ? void 0 : r.annotations[g]) == null ? void 0 : P.bezier) || 0,
          onChange: (T) => {
            const _ = et.cloneDeep(r == null ? void 0 : r.annotations);
            _[g].bezier = T.target.value, t({
              ...r,
              annotations: _
            });
          }
        }
      ))), /* @__PURE__ */ n.createElement("label", null, "Marker", /* @__PURE__ */ n.createElement(
        "select",
        {
          key: "annotation-marker",
          value: y.marker,
          onChange: (T) => {
            const _ = et.cloneDeep(r == null ? void 0 : r.annotations);
            _[g].marker = T.target.value, t({
              ...r,
              annotations: _
            });
          }
        },
        ["arrow", "circle"].map((T, _) => /* @__PURE__ */ n.createElement("option", { key: `col-${_}` }, T))
      )), /* @__PURE__ */ n.createElement(Rc, { className: "btn btn-danger full-width", onClick: () => d(g) }, "Delete Annotation"))
    ));
  })), ((p = r == null ? void 0 : r.annotations) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ n.createElement("button", { onClick: o, className: "btn btn-primary mt-2 full-width" }, "Add Annotation")));
}, ga = {
  ForestPlot: Ow,
  Series: Jr,
  Regions: Xw,
  General: qw,
  BoxPlot: Zw,
  Visual: Jw,
  Sankey: eT,
  Annotate: tT
};
const mm = [
  ["*", "Asterisk"],
  ["†", "Dagger"],
  ["§", "Section Symbol"],
  ["¶", "Paragraph Symbol"]
], nT = mm.concat(mm.map(([e, t]) => [e + e, "Double " + t])), ym = et.fromPairs(et.map(nT, ([e, t]) => [t, e])), rT = new Mm(), gm = (e, t) => {
  for (let r = 0; r < e.length; r++) {
    let a = Object.keys(e[r]), i = !0;
    for (let o = 0; o < a.length; o++)
      if (e[r][a[o]] !== t[a[o]]) {
        i = !1;
        break;
      }
    if (i)
      return r;
  }
  return -1;
}, aT = (e, t, r) => {
  var i;
  const a = et.cloneDeep(e);
  if (a.rankByValue = t, e.rankByValue && !t) {
    const o = (i = e == null ? void 0 : e.xAxis) != null && i.dataKey ? rT.cleanData(e.data, e.xAxis.dataKey) : e.data, d = r.sort((c, s) => {
      const p = gm(o, c), y = gm(o, s);
      return p - y;
    });
    return [a, d];
  }
  return [a];
}, iT = ({ config: e, updateConfig: t, data: r }) => {
  var m, v, A;
  const a = e.visualizationType === "Combo", i = ((m = e.runtime.lineSeriesKeys) == null ? void 0 : m.length) > 0, o = ((v = e.runtime.barSeriesKeys) == null ? void 0 : v.length) > 0, d = a && i, c = a && o, s = () => et.uniq(et.flatMap(r, et.keys)), p = () => e.visualizationType === "Line" || d ? ["effect", "suppression"] : ["suppression"], y = {
    "Dashed Small": "- - -",
    "Dashed Medium": "– –",
    "Dashed Large": "— –",
    "Open Circles": "◯",
    "Filled Circles": ""
  }, g = (P) => {
    const T = Object.keys(y);
    return P === "suppression" ? T.slice(0, -2) : T;
  }, b = () => {
    if (e.visualizationType === "Bar" || c)
      return Object.keys(ym);
  };
  let w = (P) => {
    let T = [];
    e.preliminaryData && (T = [...e.preliminaryData]), T.splice(P, 1), t({ ...e, preliminaryData: T });
  }, S = () => {
    const P = e.visualizationType === "Line" ? "effect" : "suppression";
    let T = e.preliminaryData ? [...e.preliminaryData] : [];
    const _ = {
      type: P,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: "",
      hideBarSymbol: !1,
      hideLineStyle: !1,
      circleSize: 6,
      displayGray: !0
    };
    T.push(_), t({ ...e, preliminaryData: T });
  }, L = (P, T, _) => {
    let M = [];
    e.preliminaryData && (M = [...e.preliminaryData]), M[_][P] = T, P === "symbol" && (M[_].iconCode = ym[T]), P === "style" && (M[_].lineCode = y[T]), t({ ...e, preliminaryData: M });
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.preliminaryData && ((A = e.preliminaryData) == null ? void 0 : A.map(
    ({
      displayGray: P,
      circleSize: T,
      column: _,
      displayLegend: M,
      displayTable: Z,
      displayTooltip: Y,
      label: ae,
      seriesKey: j,
      style: q,
      symbol: te,
      type: le,
      value: B,
      hideBarSymbol: X,
      hideLineStyle: ue
    }, ne) => {
      var J, W;
      return /* @__PURE__ */ n.createElement("div", { key: `preliminaryData-${ne}`, className: "edit-block" }, /* @__PURE__ */ n.createElement("p", null, " ", le === "suppression" ? "Suppressed" : "Effect", " Data"), /* @__PURE__ */ n.createElement(
        "button",
        {
          type: "button",
          className: "btn btn-danger",
          onClick: (K) => {
            K.preventDefault(), w(ne);
          }
        },
        "Remove"
      ), /* @__PURE__ */ n.createElement(
        dt,
        {
          value: le,
          initial: e.visualizationType == "Bar" ? "" : "Select",
          fieldName: "type",
          label: "Type",
          updateField: (K, ee, $, pe) => L($, pe, ne),
          options: p()
        }
      ), le === "suppression" ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        dt,
        {
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", 'Without a selected "Data Series", the suppression symbol will be applied for all series in the current dataset visualization. However, choosing a specific "data series" will isolate the suppression to that series.'))),
          value: _,
          initial: "Select",
          fieldName: "column",
          label: "Add Data Series",
          updateField: (K, ee, $, pe) => L($, pe, ne),
          options: (J = e.runtime) == null ? void 0 : J.seriesKeys
        }
      ), /* @__PURE__ */ n.createElement(
        We,
        {
          value: B,
          fieldName: "value",
          label: "Suppressed Data  Value",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      ), (d || e.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        dt,
        {
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "The recommended approach for presenting data is to include a footnote indicating any data suppression."))),
          value: q,
          initial: "Select",
          fieldName: "style",
          label: "suppression line style",
          updateField: (K, ee, $, pe) => L($, pe, ne),
          options: g(le)
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: ue,
          fieldName: "hideLineStyle",
          label: "Hide Suppressed line Style",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      )), (c || e.visualizationType === "Bar") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        dt,
        {
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "A symbol is ", /* @__PURE__ */ n.createElement("i", null, "required"), ' to indicate suppressed data. We suggest "double asterisks." If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'))),
          value: te,
          initial: "Select",
          fieldName: "symbol",
          label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
          updateField: (K, ee, $, pe) => L($, pe, ne),
          options: b()
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: X,
          fieldName: "hideBarSymbol",
          label: "Hide Suppressed Bar Symbol  ",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      )), /* @__PURE__ */ n.createElement(
        We,
        {
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This label will display in the tooltip and legend."))),
          value: ae || "Suppressed",
          fieldName: "label",
          label: "Suppressed Data Label",
          placeholder: "",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting the "Display In Tooltips" option prevents suppressed values from appearing in tooltips.'))),
          value: Y,
          fieldName: "displayTooltip",
          label: "Display in tooltips",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.'))),
          value: M,
          fieldName: "displayLegend",
          label: "Display in legend",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.'))),
          value: Z,
          fieldName: "displayTable",
          label: "Display in table",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will apply to chart, tooltip hover, legend, and data table."))),
          value: P,
          fieldName: "displayGray",
          label: "Highlight Suppressed Data In Gray",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        dt,
        {
          value: j,
          initial: "Select",
          fieldName: "seriesKey",
          label: "ASSOCIATE TO SERIES",
          updateField: (K, ee, $, pe) => L($, pe, ne),
          options: e.runtime.lineSeriesKeys ?? ((W = e.runtime) == null ? void 0 : W.seriesKeys)
        }
      ), /* @__PURE__ */ n.createElement(
        dt,
        {
          value: _,
          initial: "Select",
          fieldName: "column",
          label: "COLUMN WITH CONFIGURATION VALUE",
          updateField: (K, ee, $, pe) => L($, pe, ne),
          options: s()
        }
      ), /* @__PURE__ */ n.createElement(
        We,
        {
          tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "If 'Filled Circles' is selected as the style, this field is optional, and the style 'Filled Circles' will apply to all points within the associated series data."))),
          value: B,
          fieldName: "value",
          label: "VALUE TO TRIGGER",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      ), /* @__PURE__ */ n.createElement(
        dt,
        {
          value: q,
          initial: "Select",
          fieldName: "style",
          label: "Style",
          updateField: (K, ee, $, pe) => L($, pe, ne),
          options: g(le)
        }
      ), q.includes("Circles") && /* @__PURE__ */ n.createElement(
        We,
        {
          className: "number-narrow",
          type: "number",
          value: T,
          fieldName: "circleSize",
          label: "circle size",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      ), q !== "Filled Circles" && /* @__PURE__ */ n.createElement(
        We,
        {
          value: ae,
          fieldName: "label",
          label: "Label",
          placeholder: "",
          updateField: (K, ee, $, pe) => L($, pe, ne)
        }
      )));
    }
  )), /* @__PURE__ */ n.createElement("button", { type: "button", onClick: S, className: "btn btn-primary full-width" }, e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line"));
}, oT = ({ config: e, updateConfig: t, display: r }) => {
  var p, y, g, b;
  const a = (p = e == null ? void 0 : e.yAxis) == null ? void 0 : p.maxValue, i = ((g = (y = e == null ? void 0 : e.yAxis) == null ? void 0 : y.categories) == null ? void 0 : g.reduce((w, S) => w + (parseFloat(S.height) || 0), 0)) || 0, o = (w) => {
    let S = [];
    e.yAxis.categories && (S = [...e.yAxis.categories]), S.splice(w, 1), t({ ...e, yAxis: { ...e.yAxis, categories: S } });
  }, d = () => {
    var m, v;
    const w = (v = (m = e.yAxis) == null ? void 0 : m.categories) == null ? void 0 : v.length, S = 0.4;
    return Ua("#ddd").darken(S * w).hex();
  }, c = () => {
    const w = e.yAxis.categories ? [...e.yAxis.categories] : [], S = {
      label: "Label " + Number(w.length + 1),
      height: "",
      color: d()
    };
    w.push(S), t({ ...e, yAxis: { ...e.yAxis, categories: w } });
  }, s = (w, S, L) => {
    let m = [];
    e.yAxis.categories && (m = [...e.yAxis.categories]), m[L][w] = S, t({ ...e, yAxis: { ...e.yAxis, categories: m } });
  };
  return r ? /* @__PURE__ */ n.createElement(n.Fragment, null, e.yAxis.type === "categorical" && ((b = e.yAxis.categories) == null ? void 0 : b.map(({ label: w, color: S, height: L }, m) => /* @__PURE__ */ n.createElement("div", { key: `preliminaryData-${m}`, className: "edit-block" }, /* @__PURE__ */ n.createElement("p", null, "Axis Category ", m + 1), /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-danger",
      onClick: (v) => {
        v.preventDefault(), o(m);
      }
    },
    "Remove"
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", "Category Height will be ignored for the last category. The last category will fill the rest of the axis height."))),
      type: "number",
      value: L,
      fieldName: "height",
      label: "Category Height",
      updateField: (v, A, P, T) => s(P, T, m)
    }
  ), Number(i) > Number(a) && e.yAxis.categories.length - 1 === m && /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block", fontSize: "15px" } }, "Update Max value to show all categories"), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
    We,
    {
      value: S,
      fieldName: "color",
      label: "Color",
      updateField: (v, A, P, T) => s(P, T, m)
    }
  ), /* @__PURE__ */ n.createElement(
    We,
    {
      value: w,
      fieldName: "label",
      label: "Label",
      updateField: (v, A, P, T) => s(P, T, m)
    }
  ))))), /* @__PURE__ */ n.createElement("button", { type: "button", onClick: c, className: "btn btn-primary full-width" }, "Add Axis Category")) : /* @__PURE__ */ n.createElement(n.Fragment, null);
}, lT = () => {
  var tn, Qt, Nt, Jt, wn, on, Wn, Ln, Tn, ln, Dn, _n, Fn, Kn, sn, hn, ir, Zn, Qn, x, D, N, U, fe;
  const {
    config: e,
    updateConfig: t,
    tableData: r,
    transformedData: a,
    loading: i,
    colorScale: o,
    colorPalettes: d,
    twoColorPalette: c,
    unfilteredData: s,
    excludedData: p,
    isDashboard: y,
    setParentConfig: g,
    missingRequiredSections: b,
    isDebug: w,
    setFilteredData: S,
    lineOptions: L,
    rawData: m,
    highlight: v,
    handleShowAll: A,
    dimensions: P
  } = se.useContext(ft), { minValue: T, maxValue: _, existPositiveValue: M, isAllLine: Z } = Vc(e, s), Y = { data: a, config: e }, { leftMax: ae, rightMax: j } = fg(Y), {
    visHasAnchors: q,
    visHasBrushChart: te,
    visHasCategoricalAxis: le,
    visHasLegend: B,
    visHasLegendAxisAlign: X,
    visHasLegendColorCategory: ue,
    visHasSelectableLegendValues: ne,
    visSupportsDateCategoryAxis: J,
    visSupportsDateCategoryAxisLabel: W,
    visSupportsDateCategoryAxisLine: K,
    visSupportsDateCategoryAxisMax: ee,
    visSupportsDateCategoryAxisMin: $,
    visSupportsDateCategoryAxisPadding: pe,
    visSupportsDateCategoryAxisTicks: ve,
    visSupportsDateCategoryHeight: Te,
    visSupportsDateCategoryNumTicks: ye,
    visSupportsDateCategoryTickRotation: Re,
    visSupportsDynamicSeries: Xe,
    visSupportsFilters: Ce,
    visSupportsLeftValueAxis: xe,
    visSupportsPreliminaryData: Pe,
    visSupportsRankByValue: de,
    visSupportsResponsiveTicks: Be,
    visSupportsValueAxisGridLines: Ne,
    visSupportsValueAxisLabels: He,
    visSupportsValueAxisLine: Ze,
    visSupportsValueAxisMax: $e,
    visSupportsValueAxisMin: Ye,
    visSupportsValueAxisTicks: qe,
    visSupportsYPadding: Ve
  } = _s();
  se.useEffect(() => {
    let O = [];
    e.series && (O = e.series.map((I) => ({
      ...I,
      type: e.visualizationType === "Combo" ? "Bar" : e.visualizationType ? e.visualizationType : "Bar",
      axis: "Left"
    }))), t({
      ...e,
      series: O
    });
  }, [e.visualizationType]), se.useEffect(() => {
    e.visualizationType === "Scatter Plot" && t({
      ...e,
      xAxis: {
        ...e.xAxis,
        type: "continuous"
      }
    });
  }, []), se.useEffect(() => {
    e.visualizationType !== "Bar" && t({ ...e, tooltips: { ...e.tooltips, singleSeries: !1 } });
  }, [e.visualizationType]);
  const { hasRightAxis: Ge } = Ep({ config: e, yMax: e.yAxis.size, data: e.data, updateConfig: t }), ke = (O, I) => ({
    ...I
  }), De = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, at = (O) => {
    O.orientation === "horizontal" && (O.labels = !1), O.table.show === void 0 && (O.table.show = !y), O.visualizationType === "Combo" && (O.orientation = "vertical"), Rn(O.xAxis) && !O.xAxis.padding && (O.xAxis.padding = 0), O.visualizationType === "Line" && (O.visualizationSubType = "regular", O.barStyle = "flat", O.isLollipopChart = !1);
  }, be = (O, I, Q, ge) => {
    if (w && console.log(
      "#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue",
      O,
      I,
      Q,
      ge
    ), O === "boxplot" && (I === "legend" || I === "labels")) {
      t({
        ...e,
        [O]: {
          ...e[O],
          [I]: {
            ...e.boxplot[I],
            [Q]: ge
          }
        }
      });
      return;
    }
    const ze = (Vt) => Vt === 0 ? !0 : !!Vt;
    if (O === "columns" && ze(I) && ze(Q)) {
      t({
        ...e,
        columns: {
          ...e.columns,
          [I]: {
            ...e.columns[I],
            [Q]: ge
          }
        }
      });
      return;
    }
    if (O === null && I === null) {
      ze(Q) || console.error("fieldName is required");
      let Vt = { ...e, [Q]: ge };
      at(Vt), t(Vt);
      return;
    }
    const Ke = Array.isArray(e[O]);
    let ot = Ke ? [...e[O], ge] : { ...e[O], [Q]: ge };
    ze(I) && (Ke ? (ot = [...e[O]], ot[I] = { ...ot[I], [Q]: ge }) : typeof ge == "string" ? ot[I] = ge : ze(Q) && (ot = { ...e[O], [I]: { ...e[O][I], [Q]: ge } }));
    let Yt = { ...e, [O]: ot };
    at(Yt), t(Yt);
  }, [nt, st] = se.useState(!0), [lt, St] = se.useState(!1);
  if (i)
    return null;
  const Ut = (O) => {
    t({
      ...e,
      lollipopShape: O
    });
  }, It = (O) => {
    let I = e.series ? [...e.series] : [], Q = Array.from(new Set(a.map((ze) => ze[O]))), ge = [];
    Q.forEach((ze) => {
      ge.push({ key: ze });
    }), e.visualizationType === "Forecasting" ? I.push({
      dataKey: O,
      type: e.visualizationType,
      stages: ge,
      stageColumn: O,
      axis: "Left",
      tooltip: !0
    }) : I.push({ dataKey: O, type: e.visualizationType, axis: "Left", tooltip: !0 }), t({ ...e, series: I });
  }, _t = (O) => {
    let I = [...e.exclusions.keys];
    I.push(O);
    let Q = { ...e.exclusions, keys: I };
    t({ ...e, exclusions: Q });
  }, Rt = (O) => {
    let I = -1, Q = [...e.exclusions.keys];
    for (let ge = 0; ge < Q.length; ge++)
      if (Q[ge] === O) {
        I = ge;
        break;
      }
    if (I !== -1) {
      Q.splice(I, 1);
      let ge = { ...e.exclusions, keys: Q }, ze = { ...e, exclusions: ge };
      Q.length === 0 && delete ze.exclusions.keys, t(ze);
    }
  }, Lt = (O = !0) => {
    let I = {};
    if (s.forEach((Q) => {
      Object.keys(Q).forEach((ge) => I[ge] = !0);
    }), O) {
      const { lower: Q, upper: ge } = e.confidenceKeys || {};
      Object.keys(I).forEach((ze) => {
        (e.series && e.series.filter((Ke) => Ke.dataKey === ze).length > 0 || e.confidenceKeys && Object.keys(e.confidenceKeys).includes(ze) && (Q && ge || Q || ge) && ze !== Q && ze !== ge) && delete I[ze];
      });
    }
    return Object.keys(I);
  }, $t = (O) => {
    const I = [];
    switch (O) {
      case "style":
        I.push("circles", "boxes"), e.visualizationType === "Bar" && (!["right", "left"].includes(e.legend.position) || !e.legend.position) && I.push("gradient"), e.visualizationType === "Line" && I.push("lines");
        break;
      case "subStyle":
        e.visualizationType === "Bar" ? I.push("linear blocks") : I.push("linear blocks", "smooth");
        break;
    }
    return I;
  }, Dt = (O) => {
    if (!O)
      return [];
    const I = /* @__PURE__ */ new Set();
    for (let Q = 0; Q < O.length; Q++)
      for (const [ge] of Object.entries(O[Q]))
        I.add(ge);
    return Array.from(I);
  }, Gt = (O, I = !1) => {
    let Q = [];
    return p.forEach((ge) => {
      Q.push(ge[O]);
    }), I ? [...new Set(Q)] : Q;
  }, An = () => {
    st(!nt), t({
      ...e,
      showEditorPanel: !nt
    });
  }, Ot = () => {
    let O = JSON.parse(JSON.stringify(e));
    return b(e) === !1 && delete O.newViz, delete O.runtime, O;
  };
  se.useEffect(() => {
    if (g) {
      const O = Ot();
      g(O);
    }
  }, [e]), se.useEffect(() => {
    const O = e.xAxis.anchors.length > 0 ? e.xAxis.anchors : [], I = e.yAxis.anchors.length > 0 ? e.yAxis.anchors : [];
    t({
      ...e,
      xAxis: {
        ...e.xAxis,
        anchors: I
      },
      yAxis: {
        ...e.yAxis,
        anchors: O
      }
    });
  }, [e.orientation]), se.useEffect(() => {
    e.visualizationType === "Paired Bar" && t({
      ...e,
      orientation: "horizontal"
    });
  }, []), se.useEffect(() => {
    e.orientation === "horizontal" && t({
      ...e,
      lollipopShape: e.lollipopShape
    });
  }, [e.isLollipopChart, e.lollipopShape]), se.useEffect(() => {
    e.visualizationType === "Deviation Bar" && t({ ...e, orientation: "horizontal" });
  }, [e.visualizationType]);
  const Xt = se.useCallback(() => {
    const O = [...e.exclusions.keys];
    return /* @__PURE__ */ n.createElement("ul", { className: "series-list" }, O.map((I, Q) => /* @__PURE__ */ n.createElement("li", { key: I }, /* @__PURE__ */ n.createElement("div", { className: "series-list__name", "data-title": I }, /* @__PURE__ */ n.createElement("div", { className: "series-list__name--text" }, I)), /* @__PURE__ */ n.createElement("button", { className: "series-list__remove", onClick: () => Rt(I) }, "×"))));
  }, [e]), ht = (O, I) => {
    let Q = e.series, [ge] = Q.splice(O, 1);
    Q.splice(I, 0, ge), t({ ...e, series: Q });
  };
  e.isLollipopChart && ((tn = e == null ? void 0 : e.series) == null ? void 0 : tn.length) > 1 && (e.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), e.visualizationType === "Paired Bar" && ((Qt = e == null ? void 0 : e.series) == null ? void 0 : Qt.length) !== 2 && (e.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), e.visualizationType === "Deviation Bar" && ((Nt = e == null ? void 0 : e.series) == null ? void 0 : Nt.length) !== 1 && (e.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), e.isLollipopChart && ((Jt = e == null ? void 0 : e.series) == null ? void 0 : Jt.length) === 0 && (e.runtime.editorErrorMessage = "Add a data series");
  const Je = e.orientation === "horizontal" ? "xAxis" : "yAxis", [Zt, dn] = se.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), gn = () => {
    const O = e[Je].max, I = e[Je].rightMax;
    let Q = "", ge = "";
    if (e.visualizationType !== "Combo")
      switch (!0) {
        case (O && parseFloat(O) < parseFloat(_) && M):
          Q = "Max value must be more than " + _;
          break;
        case (O && parseFloat(O) < 0 && !M):
          Q = "Value must be more than or equal to 0";
          break;
        default:
          Q = "";
      }
    if (e.visualizationType === "Combo")
      switch (!0) {
        case (O && parseFloat(O) < ae):
          Q = "Max value must be more than " + ae;
          break;
        case (I && parseFloat(I) < j):
          ge = "Max value must be more than " + j;
          break;
        case (O && parseFloat(O) < 0 && !M):
          Q = "Value must be more than or equal to 0";
          break;
        default:
          Q = "";
      }
    dn((ze) => ({ ...ze, maxMsg: Q, rightMaxMessage: ge }));
  }, fn = () => {
    const O = parseFloat(e[Je].min);
    let I = Number(T), Q = "";
    switch (!0) {
      case (e.useLogScale && ["Line", "Combo", "Bar"].includes(e.visualizationType) && O < 0):
        Q = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((e.visualizationType === "Line" || e.visualizationType === "Spark Line") && O > I):
        Q = "Value should not exceed " + T;
        break;
      case (e.visualizationType === "Combo" && Z && O > I):
        Q = "Value should not exceed " + T;
        break;
      case ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && !Z) && I > 0 && O > 0):
        Q = e.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (e.visualizationType === "Deviation Bar" && O >= Math.min(I, e.xAxis.target)):
        Q = "Value must be less than " + Math.min(I, e.xAxis.target);
        break;
      case (e.visualizationType !== "Deviation Bar" && O && I < 0 && O > I):
        Q = "Value should not exceed " + T;
        break;
      default:
        Q = "";
    }
    dn((ge) => ({ ...ge, minMsg: Q }));
  };
  se.useEffect(() => {
    fn(), gn();
  }, [T, _, e]);
  const vt = ((wn = e == null ? void 0 : e.dataKey) == null ? void 0 : wn.includes("http://")) || ((on = e == null ? void 0 : e.dataKey) == null ? void 0 : on.includes("https://")), Ft = () => {
    var O, I;
    if (w !== void 0 && w && !((O = e == null ? void 0 : e.xAxis) != null && O.dataKey)) {
      let Q = Lt(!1);
      if (Q.includes("Date"))
        return "Date";
      if (Q.includes("Race"))
        return "Race";
      if (Q.includes("Month"))
        return "Month";
    }
    return ((I = e == null ? void 0 : e.xAxis) == null ? void 0 : I.dataKey) || "";
  }, mt = () => {
    if (w !== void 0 && w && Lt(!1).length > 0) {
      let O = Lt(!1).filter((I) => I !== Ft());
      if (O.length > 0)
        return O[0];
    }
    return "";
  };
  if (w && !e.xAxis.dataKey && (e.xAxis.dataKey = Ft()), w && ((Wn = e == null ? void 0 : e.series) == null ? void 0 : Wn.length) === 0) {
    let O = mt();
    O !== "" && It(O), w && console.log("### COVE DEBUG: Chart: Setting default datacol=", O);
  }
  const pn = [
    "Bump Chart",
    "Area Chart",
    "Combo",
    "Line",
    "Bar",
    "Forecasting",
    "Scatter Plot",
    "Paired Bar",
    "Deviation Bar"
  ], Sn = [
    /* @__PURE__ */ n.createElement("option", { value: "", key: "Select Option" }, "- Select Option -")
  ];
  if (e.data && e.series) {
    Object.keys(((Ln = e.data) == null ? void 0 : Ln[0]) || []).map((I) => {
      const Q = e == null ? void 0 : e.series.some((ge) => ge.dataKey === I);
      if (I !== e.xAxis.dataKey && !Q)
        return Sn.push(
          /* @__PURE__ */ n.createElement("option", { value: I, key: I }, I)
        );
    });
    let O = {};
    e.data.forEach((I) => {
      Object.keys(I).forEach((Q) => {
        O[Q] = O[Q] || [];
        const ge = typeof I[Q] == "number" ? I[Q].toString() : I[Q];
        O[Q].indexOf(ge) === -1 && O[Q].push(ge);
      });
    });
  }
  if (!e.data && a) {
    if (!a[0])
      return;
    Object.keys(a[0]).map((I) => {
      const Q = a.some((ge) => ge.dataKey === I);
      if (I !== e.xAxis.dataKey && !Q)
        return Sn.push(
          /* @__PURE__ */ n.createElement("option", { value: I, key: I }, I)
        );
    });
    let O = {};
    a.forEach((I) => {
      Object.keys(I).forEach((Q) => {
        O[Q] = O[Q] || [];
        const ge = typeof I[Q] == "number" ? I[Q].toString() : I[Q];
        O[Q].indexOf(ge) === -1 && O[Q].push(ge);
      });
    });
  }
  const kt = (O) => {
    const I = et.cloneDeep(e.columns);
    delete I[O], t({
      ...e,
      columns: I
    });
  }, wt = async (O, I, Q) => {
    switch (I) {
      case "name":
        t({
          ...e,
          columns: {
            ...e.columns,
            [O]: {
              ...e.columns[O],
              [I]: Q
            }
          }
        });
        break;
      default:
        t({
          ...e,
          columns: {
            ...e.columns,
            [O]: {
              ...e.columns[O],
              [I]: Q
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: kn,
    highlightedSeriesValues: xt,
    handleUpdateHighlightedBar: Pt,
    handleAddNewHighlightedBar: bn,
    handleRemoveHighlightedBar: On,
    handleUpdateHighlightedBarColor: _e,
    handleHighlightedBarLegendLabel: Oe,
    handleUpdateHighlightedBorderWidth: Se
  } = $c(e, t), ut = e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1, Kt = () => {
    const O = a.map((I) => I[e.legend.colorCode]);
    return ut ? O : Lt(!1).filter((I) => I !== e.xAxis.dataKey);
  }, Ht = (O) => {
    t({ ...e, legend: { ...e.legend, seriesHighlight: O } });
  }, yt = (O, I, Q) => {
    var Ke;
    const ge = { ...e[O], [I]: Q }, ze = { ...e, [O]: ge };
    Q === "highlight" && ((Ke = e.legend.seriesHighlight) != null && Ke.length) && (ze.legend.seriesHighlight.length = 0), t(ze);
  }, Bt = (O, I, Q) => {
    const ge = { ...e.xAxis[O] };
    ge[I] = Q;
    const ze = { ...e, xAxis: { ...e.xAxis, [O]: ge } };
    t(ze);
  }, bt = ![void 0, "- Select - "].includes((ln = (Tn = e.series) == null ? void 0 : Tn[0]) == null ? void 0 : ln.dynamicCategory), Tt = ((Dn = e.series) == null ? void 0 : Dn.length) > 1, Pn = {
    addNewExclusion: _t,
    data: a,
    editColumn: wt,
    getColumns: Lt,
    getDataValueOptions: Dt,
    getDataValues: Gt,
    getItemStyle: ke,
    handleSeriesChange: ht,
    handleAddNewHighlightedBar: bn,
    setCategoryAxis: Ft,
    updateField: be,
    warningMsg: Zt,
    highlightedBarValues: kn,
    handleHighlightedBarLegendLabel: Oe,
    handleUpdateHighlightedBar: Pt,
    handleRemoveHighlightedBar: On,
    isPaletteReversed: e.isPaletteReversed,
    highlightedSeriesValues: xt,
    handleUpdateHighlightedBorderWidth: Se,
    handleUpdateHighlightedBarColor: _e,
    setLollipopShape: Ut
  };
  return /* @__PURE__ */ n.createElement(Tp.Provider, { value: Pn }, /* @__PURE__ */ n.createElement(Vr, { component: "EditorPanel" }, /* @__PURE__ */ n.createElement(
    mf.Sidebar,
    {
      displayPanel: nt,
      isDashboard: y,
      title: "Configure Chart",
      onBackClick: An
    },
    /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, /* @__PURE__ */ n.createElement(ga.General, { name: "General" }), /* @__PURE__ */ n.createElement(ga.ForestPlot, { name: "Forest Plot Settings" }), /* @__PURE__ */ n.createElement(ga.Sankey, { name: "Sankey" }), e.visualizationType !== "Pie" && e.visualizationType !== "Forest Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Data Series", " ", (!e.series || e.series.length === 0 || e.visualizationType === "Paired Bar" && e.series.length < 2) && !e.dynamicSeries && /* @__PURE__ */ n.createElement(Ku, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, e.dynamicSeries && e.visualizationType === "Line" && /* @__PURE__ */ n.createElement(
      dt,
      {
        fieldName: "dynamicSeriesType",
        value: e.dynamicSeriesType,
        label: "Series Type",
        initial: "Select",
        updateField: be,
        options: ["Line", "dashed-sm", "dashed-md", "dashed-lg"]
      }
    ), e.dynamicSeries && e.visualizationType === "Line" && e.dynamicSeriesType === "Line" && /* @__PURE__ */ n.createElement(
      dt,
      {
        fieldName: "dynamicSeriesLineType",
        value: e.dynamicSeriesLineType ? e.dynamicSeriesLineType : "curveLinear",
        label: "Line Type",
        initial: "Select",
        updateField: be,
        options: Object.keys(il).map((O) => il[O])
      }
    ), (!Xe() || !e.dynamicSeries) && /* @__PURE__ */ n.createElement(n.Fragment, null, (!e.series || e.series.length === 0) && !e.dynamicSeries && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement("p", { className: "warning" }, "At least one series is required"), (!e.series || e.series.length === 0 || e.series.length < 2) && e.visualizationType === "Paired Bar" && /* @__PURE__ */ n.createElement("p", { className: "warning" }, "Select two data series for paired bar chart (e.g., Male and Female)."), /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      dt,
      {
        fieldName: "visualizationType",
        label: "Add Data Series",
        initial: "Select",
        onChange: (O) => {
          O.target.value !== "" && O.target.value !== "Select" && It(O.target.value), O.target.value = "";
        },
        options: Lt()
      }
    ), e.series && e.series.length !== 0 && /* @__PURE__ */ n.createElement(ga.Series.Wrapper, { getColumns: Lt }, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label float-left" }, "Displaying"), /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "A data series is a set of related data points plotted in a chart and typically represented in the chart legend.")))), /* @__PURE__ */ n.createElement(
      $g,
      {
        onDragEnd: ({ source: O, destination: I }) => ht(O.index, I.index)
      },
      /* @__PURE__ */ n.createElement(Hg, { droppableId: "filter_order" }, (O) => /* @__PURE__ */ n.createElement("ul", { ...O.droppableProps, className: "series-list", ref: O.innerRef }, /* @__PURE__ */ n.createElement(
        ga.Series.List,
        {
          series: e.series,
          getItemStyle: ke,
          sortableItemStyles: De,
          chartsWithOptions: pn
        }
      ), O.placeholder))
    ))), (e.series && e.series.length && e.visualizationType === "Bar" || e.series && e.series.length <= 1 && e.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Confidence Keys"), /* @__PURE__ */ n.createElement(
      dt,
      {
        value: e.confidenceKeys.upper || "",
        section: "confidenceKeys",
        fieldName: "upper",
        label: "Upper",
        updateField: be,
        initial: "Select",
        options: Lt()
      }
    ), /* @__PURE__ */ n.createElement(
      dt,
      {
        value: e.confidenceKeys.lower || "",
        section: "confidenceKeys",
        fieldName: "lower",
        label: "Lower",
        updateField: be,
        initial: "Select",
        options: Lt()
      }
    )), de() && e.series && e.series.length === 1 && /* @__PURE__ */ n.createElement(
      dt,
      {
        value: e.rankByValue,
        fieldName: "rankByValue",
        label: "Rank by Value",
        initial: "Select",
        updateField: (O, I, Q, ge) => {
          const [ze, Ke] = aT(e, ge, a);
          t(ze, Ke);
        },
        options: ["asc", "desc"]
      }
    ), Pe() && /* @__PURE__ */ n.createElement(iT, { config: e, updateConfig: t, data: a })))), /* @__PURE__ */ n.createElement(ga.BoxPlot, { name: "Measures" }), xe() && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, e.visualizationType === "Pie" ? "Data Format" : e.orientation === "vertical" ? "Left Value Axis" : "Value Axis", e.visualizationType === "Pie" && !e.yAxis.dataKey && /* @__PURE__ */ n.createElement(Ku, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(
      dt,
      {
        value: e.yAxis.dataKey || "",
        section: "yAxis",
        fieldName: "dataKey",
        label: "Data Column",
        initial: "Select",
        required: !0,
        updateField: be,
        options: Lt(!1),
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the source data to be visually represented.")))
      }
    ), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Axis Type", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, "Select 'Numeric (Linear Scale)' for uniform scaling, 'Numeric (Logarithmic Scale)' for exponential data, or 'Categorical' for discrete categories."))), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.yAxis.type,
        onChange: (O) => t({
          ...e,
          yAxis: {
            ...e.yAxis,
            type: O.target.value
          }
        })
      },
      /* @__PURE__ */ n.createElement("option", { value: "linear" }, "Numeric (Linear Scale)"),
      e.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("option", { value: "logarithmic" }, "Numeric (Logarithmic Scale)"),
      e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("option", { value: "categorical" }, "Categorical")
    )), /* @__PURE__ */ n.createElement(
      oT,
      {
        config: e,
        updateConfig: t,
        data: a,
        display: le()
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        display: !le(),
        value: e.yAxis.label,
        section: "yAxis",
        fieldName: "label",
        label: "Label",
        updateField: be,
        maxLength: 35,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "35 character limit")))
      }
    ), e.runtime.seriesKeys && e.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(e.visualizationType) && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.isLegendValue,
        fieldName: "isLegendValue",
        label: "Use Legend Value in Hover",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        display: !le(),
        value: e.yAxis.numTicks,
        placeholder: "Auto",
        type: "number",
        section: "yAxis",
        fieldName: "numTicks",
        label: "Number of ticks",
        className: "number-narrow",
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used."))),
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.size,
        type: "number",
        section: "yAxis",
        fieldName: "size",
        label: e.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
        className: "number-narrow",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, `Increase the size if elements in the ${e.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.`)))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        display: !le(),
        value: e.yAxis.labelOffset,
        section: "yAxis",
        fieldName: "labelOffset",
        label: "Label offset",
        type: "number",
        className: "number-narrow",
        updateField: be
      }
    ), e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.isResponsiveTicks,
        fieldName: "isResponsiveTicks",
        label: "Use Responsive Ticks",
        updateField: be
      }
    ), (e.orientation === "vertical" || !e.isResponsiveTicks) && /* @__PURE__ */ n.createElement(
      We,
      {
        display: !le(),
        value: e.yAxis.tickRotation || 0,
        type: "number",
        min: 0,
        section: "yAxis",
        fieldName: "tickRotation",
        label: "Tick rotation (Degrees)",
        className: "number-narrow",
        updateField: be
      }
    ), e.isResponsiveTicks && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.maxTickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "maxTickRotation",
        label: "Max Tick Rotation",
        className: "number-narrow",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
      }
    ), Ne() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.gridLines,
        section: "yAxis",
        fieldName: "gridLines",
        label: "Show Gridlines",
        updateField: be
      }
    ), Ne() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.labelsAboveGridlines,
        section: "yAxis",
        fieldName: "labelsAboveGridlines",
        label: "Tick labels above gridlines",
        updateField: be,
        disabled: !e.yAxis.gridLines,
        title: e.yAxis.gridLines ? "" : "Show gridlines to enable"
      }
    ), Ve() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.enablePadding,
        section: "yAxis",
        fieldName: "enablePadding",
        label: "Add Padding to Value Axis Scale",
        updateField: be
      }
    ), e.yAxis.enablePadding && Ve() && /* @__PURE__ */ n.createElement(
      We,
      {
        type: "number",
        section: "yAxis",
        fieldName: "scalePadding",
        label: "Padding Percentage",
        className: "number-narrow",
        updateField: be,
        value: e.yAxis.scalePadding
      }
    )), /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.commas,
        section: "dataFormat",
        fieldName: "commas",
        label: "Add commas",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will add commas to the left value axis, tooltip hover, and data table.")))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !le(),
        value: e.dataFormat.abbreviated,
        section: "dataFormat",
        fieldName: "abbreviated",
        label: "Abbreviate Axis Values",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.roundTo ? e.dataFormat.roundTo : 0,
        type: "number",
        section: "dataFormat",
        fieldName: "roundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: be,
        min: 0
      }
    ), " ", /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.prefix,
        section: "dataFormat",
        fieldName: "prefix",
        label: "Prefix",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.suffix,
        section: "dataFormat",
        fieldName: "suffix",
        label: "Suffix",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    )), e.orientation === "horizontal" ? (
      // horizontal - x is vertical y is horizontal
      /* @__PURE__ */ n.createElement(n.Fragment, null, Ze() && /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.hideAxis,
          section: "xAxis",
          fieldName: "hideAxis",
          label: "Hide Axis",
          updateField: be
        }
      ), He() && /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.hideLabel,
          section: "xAxis",
          fieldName: "hideLabel",
          label: "Hide Tick Labels",
          updateField: be
        }
      ), qe() && /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.hideTicks,
          section: "xAxis",
          fieldName: "hideTicks",
          label: "Hide Ticks",
          updateField: be
        }
      ), $e() && /* @__PURE__ */ n.createElement(
        We,
        {
          value: e.xAxis.max,
          section: "xAxis",
          fieldName: "max",
          label: "max value",
          type: "number",
          placeholder: "Auto",
          updateField: be
        }
      ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Zt.maxMsg), Ye() && /* @__PURE__ */ n.createElement(
        We,
        {
          value: e.xAxis.min,
          section: "xAxis",
          fieldName: "min",
          type: "number",
          label: "min value",
          placeholder: "Auto",
          updateField: be
        }
      ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Zt.minMsg), e.visualizationType === "Deviation Bar" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        We,
        {
          value: e.xAxis.target,
          section: "xAxis",
          fieldName: "target",
          type: "number",
          label: "Deviation point",
          placeholder: "Auto",
          updateField: be
        }
      ), /* @__PURE__ */ n.createElement(
        We,
        {
          value: e.xAxis.targetLabel || "Target",
          section: "xAxis",
          fieldName: "targetLabel",
          type: "text",
          label: "Deviation point Label",
          updateField: be
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.showTargetLabel,
          section: "xAxis",
          fieldName: "showTargetLabel",
          label: "Show Deviation point label",
          updateField: be
        }
      )))
    ) : e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !le(),
        value: e.dataFormat.onlyShowTopPrefixSuffix,
        section: "dataFormat",
        fieldName: "onlyShowTopPrefixSuffix",
        label: "Only Show Top Prefix/Suffix",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !le(),
        value: e.yAxis.hideAxis,
        section: "yAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !le(),
        value: e.yAxis.hideLabel,
        section: "yAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !le(),
        value: e.yAxis.hideTicks,
        section: "yAxis",
        fieldName: "hideTicks",
        label: "Hide Ticks",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.max,
        section: "yAxis",
        fieldName: "max",
        type: "number",
        label: "left axis max value",
        placeholder: "Auto",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Zt.maxMsg), e.visualizationType !== "Area Chart" && e.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.min,
        section: "yAxis",
        fieldName: "min",
        type: "number",
        label: "left axis min value",
        placeholder: "Auto",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Zt.minMsg))), q() && e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, (Fn = (_n = e.yAxis) == null ? void 0 : _n.anchors) == null ? void 0 : Fn.map((O, I) => /* @__PURE__ */ n.createElement(Mn, { className: "series-item series-item--chart", key: `yaxis-anchors-2-${I}` }, /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Bn, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (Q) => {
          Q.preventDefault();
          const ge = [...e.yAxis.anchors];
          ge.splice(I, 1), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: ge
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.yAxis.anchors[I].value ? e.yAxis.anchors[I].value : "",
        onChange: (Q) => {
          Q.preventDefault();
          const ge = [...e.yAxis.anchors];
          ge[I].value = Q.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: ge
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.yAxis.anchors[I].color ? e.yAxis.anchors[I].color : "",
        onChange: (Q) => {
          Q.preventDefault();
          const ge = [...e.yAxis.anchors];
          ge[I].color = Q.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: ge
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.yAxis.anchors[I].lineStyle || "",
        onChange: (Q) => {
          const ge = [...e.yAxis.anchors];
          ge[I].lineStyle = Q.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: ge
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      L.map((Q) => /* @__PURE__ */ n.createElement("option", { key: Q.key }, Q.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.yAxis.anchors];
          I.push({}), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )), q() && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, (sn = (Kn = e.xAxis) == null ? void 0 : Kn.anchors) == null ? void 0 : sn.map((O, I) => /* @__PURE__ */ n.createElement(Mn, { className: "series-item series-item--chart", key: `xaxis-anchors-${I}` }, /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Bn, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (Q) => {
          Q.preventDefault();
          const ge = [...e.xAxis.anchors];
          ge.splice(I, 1), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ge
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].value ? e.xAxis.anchors[I].value : "",
        onChange: (Q) => {
          Q.preventDefault();
          const ge = [...e.xAxis.anchors];
          ge[I].value = Q.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ge
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].color ? e.xAxis.anchors[I].color : "",
        onChange: (Q) => {
          Q.preventDefault();
          const ge = [...e.xAxis.anchors];
          ge[I].color = Q.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ge
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.anchors[I].lineStyle || "",
        onChange: (Q) => {
          const ge = [...e.xAxis.anchors];
          ge[I].lineStyle = Q.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ge
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      L.map((Q) => /* @__PURE__ */ n.createElement("option", { key: Q.key }, Q.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.xAxis.anchors];
          I.push({}), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )))), Ge && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Right Value Axis")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.rightLabel,
        section: "yAxis",
        fieldName: "rightLabel",
        label: "Label",
        updateField: be,
        maxLength: 35,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "35 character limit")))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.rightNumTicks,
        placeholder: "Auto",
        type: "number",
        section: "yAxis",
        fieldName: "rightNumTicks",
        label: "Number of ticks",
        className: "number-narrow",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.rightAxisSize,
        type: "number",
        section: "yAxis",
        fieldName: "rightAxisSize",
        label: "Size (Width)",
        className: "number-narrow",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.rightLabelOffsetSize,
        type: "number",
        section: "yAxis",
        fieldName: "rightLabelOffsetSize",
        label: "Label Offset",
        className: "number-narrow",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.rightCommas,
        section: "dataFormat",
        fieldName: "rightCommas",
        label: "Add commas",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.rightRoundTo,
        type: "number",
        section: "dataFormat",
        fieldName: "rightRoundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: be,
        min: 0
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.rightPrefix,
        section: "dataFormat",
        fieldName: "rightPrefix",
        label: "Prefix",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.rightSuffix,
        section: "dataFormat",
        fieldName: "rightSuffix",
        label: "Suffix",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    )), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.rightHideAxis,
        section: "yAxis",
        fieldName: "rightHideAxis",
        label: "Hide Axis",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.rightHideLabel,
        section: "yAxis",
        fieldName: "rightHideLabel",
        label: "Hide Tick Labels",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.rightHideTicks,
        section: "yAxis",
        fieldName: "rightHideTicks",
        label: "Hide Ticks",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.max,
        section: "yAxis",
        fieldName: "rightMax",
        type: "number",
        label: "right axis max value",
        placeholder: "Auto",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Zt.rightMaxMessage), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.yAxis.min,
        section: "yAxis",
        fieldName: "rightMin",
        type: "number",
        label: "right axis min value",
        placeholder: "Auto",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Zt.minMsg))), J() && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, e.visualizationType === "Pie" ? "Segments" : "Date/Category Axis", !e.xAxis.dataKey && /* @__PURE__ */ n.createElement(Ku, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(In, null, e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, e.visualizationType !== "Forest Plot" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Data Scaling Type", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, "Linear scales are employed for quantitative data, while time scales are used for time-series data."))), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.type,
        onChange: (O) => t({
          ...e,
          xAxis: {
            ...e.xAxis,
            type: O.target.value
          }
        })
      },
      e.visualizationType !== "Bump Chart" && /* @__PURE__ */ n.createElement("option", { value: "categorical" }, "Categorical (Linear Scale)"),
      e.visualizationType !== "Bump Chart" && /* @__PURE__ */ n.createElement("option", { value: "date" }, "Date (Linear Scale)"),
      /* @__PURE__ */ n.createElement("option", { value: "date-time" }, "Date (Date Time Scale)"),
      e.visualizationType === "Scatter Plot" && /* @__PURE__ */ n.createElement("option", { value: "continuous" }, "Continuous")
    )), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.manual,
        section: "xAxis",
        fieldName: "manual",
        label: "Manual Ticks",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: e.xAxis.type !== "categorical",
        value: e.xAxis.sortByRecentDate,
        section: "xAxis",
        fieldName: "sortByRecentDate",
        label: "Show dates newest to oldest",
        updateField: be
      }
    ), pe() && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.padding,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "padding",
        label: "Padding (Percent)",
        className: "number-narrow",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified.")))
      }
    )), /* @__PURE__ */ n.createElement(
      dt,
      {
        value: e.xAxis.dataKey || Ft() || "",
        section: "xAxis",
        fieldName: "dataKey",
        label: "Data Key",
        initial: "Select",
        required: !0,
        updateField: be,
        options: Lt(!1),
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
      }
    )), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(
      dt,
      {
        value: e.xAxis.dataKey || "",
        section: "xAxis",
        fieldName: "dataKey",
        label: "Segment Labels",
        initial: "Select",
        required: !0,
        updateField: be,
        options: Lt(!1),
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."')))
      }
    ), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.label,
        section: "xAxis",
        fieldName: "label",
        label: "Label",
        updateField: be,
        maxLength: 35,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "35 character limit")))
      }
    ), e.xAxis.type === "continuous" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.bottomPrefix,
        section: "dataFormat",
        fieldName: "bottomPrefix",
        label: "Prefix",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.bottomSuffix,
        section: "dataFormat",
        fieldName: "bottomSuffix",
        label: "Suffix",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.bottomAbbreviated,
        section: "dataFormat",
        fieldName: "bottomAbbreviated",
        label: "Abbreviate Axis Values",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
      }
    )), Rn(e.xAxis) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" } }, "Format how charts should parse and display your dates using", " ", /* @__PURE__ */ n.createElement("a", { href: "https://d3js.org/d3-time-format#locale_format", target: "_blank", rel: "noreferrer" }, "these guidelines"), "."), /* @__PURE__ */ n.createElement(
      We,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed.", " "))),
        value: e.xAxis.dateParseFormat,
        section: "xAxis",
        fieldName: "dateParseFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "Date Parse Format",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", "Adjusts the date display format on the axis for clear, visual date representation."))),
        value: e.xAxis.dateDisplayFormat,
        section: "xAxis",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "AXIS DATE DISPLAY FORMAT",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format.", " "))),
        value: e.table.dateDisplayFormat,
        section: "table",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "DATA TABLE DATE DISPLAY FORMAT",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format.", " "))),
        value: e.tooltips.dateDisplayFormat,
        section: "tooltips",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "HOVER DATE DISPLAY FORMAT",
        updateField: be
      }
    )), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.exclusions.active,
        section: "exclusions",
        fieldName: "active",
        label: e.xAxis.type === "date" || e.xAxis.type === "date-time" ? "Limit by start and/or end dates" : "Exclude one or more values",
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked, you can select source-file values for exclusion from the date/category axis.", " "))),
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.showYearsOnce,
        section: "xAxis",
        fieldName: "showYearsOnce",
        label: "Show years once",
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked and the date format for the axis includes years, each year will only be shown once in the axis."))),
        updateField: be
      }
    ), te() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: (hn = e.brush) == null ? void 0 : hn.active,
        section: "brush",
        fieldName: "active",
        label: "Brush Slider ",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Use the brush slider to narrow down your data view to specific values along the axis. This tool is useful for examining detailed data segments within the larger dataset.", " ")))
      }
    ), e.exclusions.active && /* @__PURE__ */ n.createElement(n.Fragment, null, e.xAxis.type === "categorical" && /* @__PURE__ */ n.createElement(n.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ n.createElement(Xt, null)), /* @__PURE__ */ n.createElement(
      dt,
      {
        fieldName: "visualizationType",
        label: "Add Exclusion",
        initial: "Select",
        onChange: (O) => {
          O.target.value !== "" && O.target.value !== "Select" && _t(O.target.value), O.target.value = "";
        },
        options: Gt(e.xAxis.dataKey, !0)
      }
    )), e.xAxis.type === "date" || e.xAxis.type === "date-time" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        type: "date",
        section: "exclusions",
        fieldName: "dateStart",
        label: "Start Date",
        updateField: be,
        value: e.exclusions.dateStart || ""
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        type: "date",
        section: "exclusions",
        fieldName: "dateEnd",
        label: "End Date",
        updateField: be,
        value: e.exclusions.dateEnd || ""
      }
    ))), ye() && e.xAxis.type !== "date-time" && e.xAxis.manual && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.manualStep,
        placeholder: "Auto",
        type: "number",
        min: 1,
        section: "xAxis",
        fieldName: "manualStep",
        label: "Step count",
        className: "number-narrow",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc.")))
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement(
      "button",
      {
        onClick: () => St(!lt),
        className: "edit-label"
      },
      "Step Count: viewport overrides",
      " ",
      /* @__PURE__ */ n.createElement("span", { style: { transform: `rotate(${lt ? "90deg" : "0deg"})` } }, ">")
    )), lt && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, Object.keys(Ap).map((O) => /* @__PURE__ */ n.createElement(
      We,
      {
        key: `viewport-step-count-input-${O}`,
        value: e.xAxis.viewportStepCount ? e.xAxis.viewportStepCount[O] : void 0,
        placeholder: "Auto",
        type: "number",
        label: O,
        className: "number-narrow",
        updateField: (I, Q, ge, ze) => Bt("viewportStepCount", O, ze)
      }
    ))))), ye() && (e.xAxis.type === "date-time" || !e.xAxis.manual) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.numTicks,
        placeholder: "Auto",
        type: "number",
        min: 1,
        section: "xAxis",
        fieldName: "numTicks",
        label: "Number of ticks",
        className: "number-narrow",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.')))
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement(
      "button",
      {
        onClick: () => St(!lt),
        className: "edit-label"
      },
      "Number of ticks: viewport overrides",
      " ",
      /* @__PURE__ */ n.createElement("span", { style: { transform: `rotate(${lt ? "90deg" : "0deg"})` } }, ">")
    )), lt && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, Object.keys(Ap).map((O) => /* @__PURE__ */ n.createElement(
      We,
      {
        key: `viewport-num-ticks-input-${O}`,
        value: e.xAxis.viewportNumTicks ? e.xAxis.viewportNumTicks[O] : void 0,
        placeholder: "Auto",
        type: "number",
        label: O,
        className: "number-narrow",
        updateField: (I, Q, ge, ze) => Bt("viewportNumTicks", O, ze)
      }
    ))))), Te() && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.size,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "size",
        label: e.orientation === "horizontal" ? "Size (Width)" : "Size (Height)",
        className: "number-narrow",
        updateField: be
      }
    ), e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.labelOffset,
        section: "xAxis",
        fieldName: "labelOffset",
        label: "Label offset",
        type: "number",
        className: "number-narrow",
        updateField: be
      }
    ), (e.xAxis.type === "continuous" || e.forestPlot.type === "Logarithmic") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.bottomCommas,
        section: "dataFormat",
        fieldName: "bottomCommas",
        label: "Add commas",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.dataFormat.bottomRoundTo,
        type: "number",
        section: "dataFormat",
        fieldName: "bottomRoundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: be,
        min: 0
      }
    )), Be() && e.orientation === "vertical" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.isResponsiveTicks,
        fieldName: "isResponsiveTicks",
        label: "Use Responsive Ticks",
        updateField: be
      }
    ), (e.orientation === "horizontal" || !e.isResponsiveTicks) && Re() && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.tickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "tickRotation",
        label: "Tick rotation (Degrees)",
        className: "number-narrow",
        updateField: be
      }
    ), e.orientation === "vertical" && e.isResponsiveTicks && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.maxTickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "maxTickRotation",
        label: "Max Tick Rotation",
        className: "number-narrow",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
      }
    ), e.orientation === "horizontal" ? /* @__PURE__ */ n.createElement(n.Fragment, null, K() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.hideAxis,
        section: "yAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: be
      }
    ), W() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.hideLabel,
        section: "yAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: be
      }
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, K() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.hideAxis,
        section: "xAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: be
      }
    ), W() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.hideLabel,
        section: "xAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: be
      }
    ), ve() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.hideTicks,
        section: "xAxis",
        fieldName: "hideTicks",
        label: "Hide Ticks",
        updateField: be
      }
    )), ((ir = e.series) == null ? void 0 : ir.length) === 1 && e.visualizationType === "Bar" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "barHighlight" }, "Bar Highlighting"), e.series.length === 1 && kn.map((O, I) => /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("div", { className: "edit-block", key: `highlighted-bar-${I}` }, /* @__PURE__ */ n.createElement("button", { className: "btn btn-danger", onClick: (Q) => On(Q, I) }, "Remove"), /* @__PURE__ */ n.createElement("p", null, "Highlighted Bar ", I + 1), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Value"), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.highlightedBarValues[I].value,
        onChange: (Q) => Pt(Q, I)
      },
      /* @__PURE__ */ n.createElement("option", { value: "" }, "- Select Value -"),
      xt && [...new Set(xt)].sort().map((Q) => /* @__PURE__ */ n.createElement("option", { key: `special-class-value-option-${I}-${Q}` }, Q))
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.highlightedBarValues[I].color ? e.highlightedBarValues[I].color : "",
        onChange: (Q) => _e(Q, I)
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Border Width"), /* @__PURE__ */ n.createElement(
      "input",
      {
        max: "5",
        min: "0",
        type: "number",
        value: e.highlightedBarValues[I].borderWidth ? e.highlightedBarValues[I].borderWidth : "",
        onChange: (Q) => Se(Q, I)
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Legend Label"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.highlightedBarValues[I].legendLabel ? e.highlightedBarValues[I].legendLabel : "",
        onChange: (Q) => Oe(Q, I)
      }
    ))))), /* @__PURE__ */ n.createElement("button", { className: "btn btn-primary full-width", onClick: (O) => bn(O) }, "Add Highlighted Bar"))), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.exclusions.active,
        section: "exclusions",
        fieldName: "active",
        label: "Exclude one or more values",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked, you can select values for exclusion from the pie segments.")))
      }
    ), e.exclusions.active && /* @__PURE__ */ n.createElement(n.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ n.createElement(Xt, null)), /* @__PURE__ */ n.createElement(
      dt,
      {
        fieldName: "visualizationType",
        label: "Add Exclusion",
        initial: "Select",
        onChange: (O) => {
          O.target.value !== "" && O.target.value !== "Select" && _t(O.target.value), O.target.value = "";
        },
        options: Gt(e.xAxis.dataKey, !0)
      }
    ))), $() && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.min,
        section: "xAxis",
        fieldName: "min",
        type: "number",
        label: "min value",
        placeholder: "Auto",
        updateField: be
      }
    ), ee() && /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.xAxis.max,
        section: "xAxis",
        fieldName: "max",
        type: "number",
        label: "max value",
        placeholder: "Auto",
        updateField: be
      }
    ), q() && e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, (Qn = (Zn = e.xAxis) == null ? void 0 : Zn.anchors) == null ? void 0 : Qn.map((O, I) => /* @__PURE__ */ n.createElement(Mn, { className: "series-item series-item--chart", key: `xaxis-anchors-2-${I}` }, /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Bn, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (Q) => {
          Q.preventDefault();
          const ge = [...e.xAxis.anchors];
          ge.splice(I, 1), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ge
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].value ? e.xAxis.anchors[I].value : "",
        onChange: (Q) => {
          Q.preventDefault();
          const ge = [...e.xAxis.anchors];
          ge[I].value = Q.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ge
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].color ? e.xAxis.anchors[I].color : "",
        onChange: (Q) => {
          Q.preventDefault();
          const ge = [...e.xAxis.anchors];
          ge[I].color = Q.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ge
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.anchors[I].lineStyle || "",
        onChange: (Q) => {
          const ge = [...e.xAxis.anchors];
          ge[I].lineStyle = Q.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: ge
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      L.map((Q) => /* @__PURE__ */ n.createElement("option", { key: Q.key }, Q.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.xAxis.anchors];
          I.push({}), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )), q() && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(Fi, { allowZeroExpanded: !0 }, (D = (x = e.yAxis) == null ? void 0 : x.anchors) == null ? void 0 : D.map((O, I) => /* @__PURE__ */ n.createElement(
      Mn,
      {
        className: "series-item series-item--chart",
        key: `accordion-yaxis-anchors-${I}`
      },
      /* @__PURE__ */ n.createElement(zn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Bn, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ n.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (Q) => {
            Q.preventDefault();
            const ge = [...e.yAxis.anchors];
            ge.splice(I, 1), t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: ge
              }
            });
          }
        },
        "Remove"
      )))),
      /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "text",
          value: e.yAxis.anchors[I].value ? e.yAxis.anchors[I].value : "",
          onChange: (Q) => {
            Q.preventDefault();
            const ge = [...e.yAxis.anchors];
            ge[I].value = Q.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: ge
              }
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "text",
          value: e.yAxis.anchors[I].color ? e.yAxis.anchors[I].color : "",
          onChange: (Q) => {
            Q.preventDefault();
            const ge = [...e.yAxis.anchors];
            ge[I].color = Q.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: ge
              }
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
        "select",
        {
          value: e.yAxis.anchors[I].lineStyle || "",
          onChange: (Q) => {
            const ge = [...e.yAxis.anchors];
            ge[I].lineStyle = Q.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: ge
              }
            });
          }
        },
        /* @__PURE__ */ n.createElement("option", null, "Select"),
        L.map((Q) => /* @__PURE__ */ n.createElement("option", { key: Q.key }, Q.value))
      )))
    ))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.yAxis.anchors];
          I.push({}), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )))), /* @__PURE__ */ n.createElement(ga.Regions, { name: "Regions" }), e.visualizationType !== "Box Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Columns")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(Dw, { config: e, updateField: be, deleteColumn: kt }), " ")), B() && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Legend")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
      dt,
      {
        value: (N = e.legend) == null ? void 0 : N.position,
        section: "legend",
        fieldName: "position",
        label: "Position",
        updateField: be,
        options: ["right", "left", "bottom", "top"]
      }
    ), (e.legend.position === "left" || e.legend.position === "right" || !e.legend.position) && e.legend.style === "gradient" && /* @__PURE__ */ n.createElement("span", { style: { color: "red", fontSize: "14px" } }, "Position must be set to top or bottom to use gradient style."), /* @__PURE__ */ n.createElement(
      dt,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "If using gradient style, limit the legend to five items for better mobile visibility, and position the legend at the top or bottom."))),
        display: !e.legend.hide,
        value: e.legend.style,
        section: "legend",
        fieldName: "style",
        label: "Legend Style",
        updateField: be,
        options: $t("style")
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Choose option Shapes in Line Datapoint Symbols to display."))),
        display: !e.legend.hide && e.legend.style === "lines",
        value: e.legend.hasShape,
        section: "legend",
        fieldName: "hasShape",
        label: "Shapes",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      dt,
      {
        display: !e.legend.hide && e.legend.style === "gradient",
        value: e.legend.subStyle,
        section: "legend",
        fieldName: "subStyle",
        label: "Gradient Style",
        updateField: be,
        options: $t("subStyle")
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        display: e.legend.style === "gradient" && !e.legend.hide,
        className: "number-narrow",
        type: "number",
        value: e.legend.tickRotation,
        section: "legend",
        fieldName: "tickRotation",
        label: "Tick Rotation (Degrees)",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: (U = e.preliminaryData) == null ? void 0 : U.some((O) => O.label && O.type === "suppression" && O.value),
        value: e.legend.hideSuppressedLabels,
        section: "legend",
        fieldName: "hideSuppressedLabels",
        label: "Hide Suppressed Labels",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.`)))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: (fe = e.preliminaryData) == null ? void 0 : fe.some((O) => O.label && O.type === "suppression" && O.value),
        value: e.legend.hideSuppressionLink,
        section: "legend",
        fieldName: "hideSuppressionLink",
        label: "Hide Suppression Definition Link",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will hide the suppression definition link from display.")))
      }
    ), /* @__PURE__ */ n.createElement(
      dt,
      {
        display: bt || Tt,
        value: e.legend.behavior,
        section: "legend",
        fieldName: "behavior",
        label: "Legend Behavior (When clicked)",
        updateField: (...[O, , I, Q]) => yt(O, I, Q),
        options: ["highlight", "isolate"]
      }
    ), /* @__PURE__ */ n.createElement(
      dt,
      {
        display: ue(),
        value: e.legend.colorCode,
        section: "legend",
        fieldName: "colorCode",
        label: "Color code by category",
        initial: "Select",
        updateField: be,
        options: Dt(a)
      }
    ), X() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.legend.axisAlign,
        fieldName: "axisAlign",
        section: "legend",
        label: "Align to Axis on Isolate",
        updateField: be
      }
    ), e.legend.behavior === "highlight" && e.tooltips.singleSeries && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.legend.highlightOnHover,
        section: "legend",
        fieldName: "highlightOnHover",
        label: "HIGHLIGHT DATA SERIES ON HOVER",
        updateField: be
      }
    ), ne && e.legend.behavior === "isolate" && !ut && /* @__PURE__ */ n.createElement("fieldset", { className: "primary-fieldset edit-block", key: "additional-highlight-values" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Isolate Data Series", /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(Ue, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend."))))), e.legend.seriesHighlight && e.legend.seriesHighlight.map((O, I) => /* @__PURE__ */ n.createElement("fieldset", { className: "edit-block", key: `${O}-${I}` }, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-danger",
        onClick: (Q) => {
          Q.preventDefault();
          const ge = [...e.legend.seriesHighlight];
          ge.splice(I, 1), be("legend", null, "seriesHighlight", ge), ge.length || A();
        }
      },
      "Remove"
    ), /* @__PURE__ */ n.createElement(
      dt,
      {
        value: e.legend.seriesHighlight[I],
        fieldName: "seriesHighlight",
        label: "Isolate Value",
        onChange: (Q) => {
          const ge = [...e.legend.seriesHighlight];
          ge.includes(Q.target.value) || (ge[I] = Q.target.value, Ht([...ge]));
        },
        options: Kt()
      }
    ))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = Kt(), Q = [...e.legend.seriesHighlight];
          if (Q.length < I.length) {
            const [ze] = I.filter((Ke) => !Q.includes(Ke));
            Q.push(ze), Ht([...Q]);
          }
        }
      },
      "Add Isolate Value"
    )), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !e.legend.hide && e.legend.style !== "gradient",
        value: e.legend.reverseLabelOrder,
        section: "legend",
        fieldName: "reverseLabelOrder",
        label: "Reverse Labels",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !e.legend.hide,
        value: ["left", "right"].includes(e.legend.position) ? e.legend.hideBorder.side : e.legend.hideBorder.topBottom,
        section: "legend",
        subsection: "hideBorder",
        fieldName: ["left", "right"].includes(e.legend.position) ? "side" : "topBottom",
        label: "Hide Legend Box",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "Default option for top and bottom legends is ‘No Box.’.")))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !e.legend.hide && !["left", "right"].includes(e.legend.position) && e.legend.style !== "gradient",
        value: e.legend.singleRow,
        section: "legend",
        fieldName: "singleRow",
        label: "Single Row Legend",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: ["bottom", "top"].includes(e.legend.position) && !e.legend.hide && e.legend.style !== "gradient" && !e.legend.singleRow && !e.legend.singleRow,
        value: e.legend.verticalSorted,
        section: "legend",
        fieldName: "verticalSorted",
        label: "Vertical sorted Legend",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: !!e.legend.hide,
        section: "legend",
        fieldName: "hide",
        label: "Hide Legend",
        updateField: be,
        tooltip: /* @__PURE__ */ n.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ie.Target, null, /* @__PURE__ */ n.createElement(
          Ue,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ie.Content, null, /* @__PURE__ */ n.createElement("p", null, "With a single-series chart, consider hiding the legend to reduce visual clutter.")))
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        value: e.legend.label,
        section: "legend",
        fieldName: "label",
        label: "Title",
        updateField: be
      }
    ), /* @__PURE__ */ n.createElement(
      We,
      {
        type: "textarea",
        value: e.legend.description,
        updateField: be,
        section: "legend",
        fieldName: "description",
        label: "Legend Description"
      }
    ))), Ce() && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Filters")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(Vg, { config: e, updateField: be, rawData: m }))), /* @__PURE__ */ n.createElement(ga.Visual, { name: "Visual" }), e.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, /* @__PURE__ */ n.createElement(Bn, null, "Data Table")), /* @__PURE__ */ n.createElement(In, null, /* @__PURE__ */ n.createElement(
      _w,
      {
        config: e,
        columns: Object.keys(a[0] || {}),
        updateField: be,
        isDashboard: y,
        isLoadedFromUrl: vt
      }
    ), " ")), /* @__PURE__ */ n.createElement(ga.Annotate, { name: "Text Annotations" })),
    e.type !== "Spark Line" && /* @__PURE__ */ n.createElement(Wg, { loadConfig: t, config: e, convertStateToConfig: Ot })
  )));
}, vm = (e) => {
  let t = "", r = Math.abs(e);
  return r >= 1e9 ? (t = "B", e = e / 1e9) : r >= 1e6 ? (t = "M", e = e / 1e6) : r >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, ds = (e, t) => {
  var r;
  return e ? (r = e.legend) != null && r.hide ? e != null && e.title ? `dataTableSection__${e.title.replace(/\s/g, "")}` : "dataTableSection" : t : "dataTableSection";
}, sT = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], xm = (e) => typeof e == "string" ? parseFloat(e.replace(/,/g, "")) : Number(e), bm = (e, t) => {
  if (t.rankByValue) {
    const r = t.series[0].dataKey, a = e.sort((i, o) => xm(i[r]) - xm(o[r]));
    return t.rankByValue === "asc" ? a : a.reverse();
  }
  return e;
}, Em = (e = "#000000", t = !1) => {
  let r = Ua(e), a = t ? r.brighten(0.5).hex() : r.saturate(1.3).hex();
  return [e, a, r.darken(0.3).hex()];
}, uT = se.createContext({ displayName: "ConfigContext", setTempConfig: () => {
} }), WT = se.createContext(() => {
}), cT = (e, t) => {
  const r = t, a = et.uniq(et.map(r, e.xAxis.dataKey)), i = et.map(e.series, "dataKey"), o = [];
  a.forEach((c) => {
    i.forEach((s) => {
      try {
        if (!c)
          throw new Error("No groups resolved in box plots");
        const { count: p, sortedData: y } = et.chain(r).filter((v) => v[e.xAxis.dataKey] === c).thru((v) => ({
          count: v.length,
          sortedData: et.map(v, (A) => Number(A[s])).sort()
        })).value();
        if (!y)
          throw new Error("boxplots dont have data yet");
        if (!o)
          throw new Error("boxplots dont have plots yet");
        const g = Ts(y, 0.25), b = Ts(y, 0.75), w = b - g, S = g - 1.5 * w, L = b + 1.5 * w, m = y.filter((v) => v >= S && v <= L);
        o.push({
          columnCategory: c,
          columnMax: Ju(m),
          columnThirdQuartile: et.round(b, e.dataFormat.roundTo),
          columnMedian: Number(ay(y)).toFixed(e.dataFormat.roundTo),
          columnFirstQuartile: et.round(g, e.dataFormat.roundTo),
          columnMin: et.min(m),
          columnCount: p,
          columnSd: Number(lx(y)).toFixed(e.dataFormat.roundTo),
          columnMean: Number(sx(y)).toFixed(e.dataFormat.roundTo),
          columnIqr: et.round(w, e.dataFormat.roundTo),
          values: y,
          columnLowerBounds: S,
          columnUpperBounds: L,
          columnOutliers: et.filter(y, (v) => v < S || v > L),
          columnNonOutliers: et.filter(y, (v) => v >= S && v <= L)
        });
      } catch (p) {
        console.error("COVE: ", p.message);
      }
    });
  });
  const d = i.length > 1 ? et.flatMap(a, (c) => et.map(i, (s) => `${et.capitalize(s)} - ${et.capitalize(c)}`)) : a;
  return [o, d];
}, dT = (e) => {
  if (e.visualizationType !== "Combo" || !e.series)
    return;
  const t = {
    barSeriesKeys: [],
    lineSeriesKeys: [],
    areaSeriesKeys: [],
    forecastingSeriesKeys: []
  }, r = /* @__PURE__ */ new Map([
    ["Area Chart", "areaSeriesKeys"],
    ["Forecasting", "forecastingSeriesKeys"],
    ["Bar", "barSeriesKeys"],
    ["Combo", "barSeriesKeys"],
    ["Line", "lineSeriesKeys"],
    ["dashed-sm", "lineSeriesKeys"],
    ["dashed-md", "lineSeriesKeys"],
    ["dashed-lg", "lineSeriesKeys"]
  ]);
  return e.series.forEach((a) => {
    const i = r.get(a.type);
    if (i) {
      const o = i === "barSeriesKeys" || i === "lineSeriesKeys" ? a.dataKey : a;
      t[i].push(o);
    }
    a.type === "Combo" && (a.type = "Bar");
  }), { ...e.runtime, ...t };
}, fT = (e, t) => {
  var a;
  let r = t;
  if (e.exclusions && e.exclusions.active)
    if (e.xAxis.type === "categorical" && ((a = e.exclusions.keys) == null ? void 0 : a.length) > 0)
      r = t.filter((i) => !e.exclusions.keys.includes(i[e.xAxis.dataKey]));
    else if (Rn(e.xAxis) && (e.exclusions.dateStart || e.exclusions.dateEnd) && e.xAxis.dateParseFormat) {
      const i = (p) => new Date(p).getTime();
      let o = i(e.exclusions.dateStart), d = i(e.exclusions.dateEnd) + 86399999, c = typeof o !== void 0 && isNaN(o) === !1, s = typeof d !== void 0 && isNaN(d) === !1;
      c && s ? r = t.filter(
        (p) => i(p[e.xAxis.dataKey]) >= o && i(p[e.xAxis.dataKey]) <= d
      ) : c ? r = t.filter((p) => i(p[e.xAxis.dataKey]) >= o) : s && (r = t.filter((p) => i(p[e.xAxis.dataKey]) <= d));
    } else
      r = t;
  return r;
}, pT = (e) => {
  const t = ["Paired Bar", "Deviation Bar"].includes(e.visualizationType) ? e.twoColor.palette : e.palette, r = { ...Sr, ...Pc };
  let a = e.customColors || r[t], i = e.runtime.seriesKeys.length, o;
  for (; i > a.length; )
    a = a.concat(a);
  return a = a.slice(0, i), o = () => gp({
    domain: e.runtime.seriesLabelsAll,
    range: a,
    unknown: null
  }), o;
};
const hT = ({
  config: e,
  isEditor: t = !1,
  isDebug: r = !1,
  isDashboard: a = !1,
  setConfig: i,
  setEditing: o,
  link: d,
  setSharedFilter: c,
  setSharedFilterValue: s,
  dashboardConfig: p
}) => {
  var Ft, mt, pn, Sn, kt, wt, kn, xt, Pt, bn, On;
  const y = new Mm(), [g, b] = se.useState(!0), w = se.useRef(null), [S, L] = se.useState(null), [m, v] = se.useState({}), [A, P] = se.useState(et.cloneDeep(e == null ? void 0 : e.data) || []), [T, _] = se.useState(void 0), [M, Z] = se.useState(void 0), [Y, ae] = se.useState(
    e && ((mt = (Ft = e == null ? void 0 : e.legend) == null ? void 0 : Ft.seriesHighlight) != null && mt.length) ? [...(pn = e == null ? void 0 : e.legend) == null ? void 0 : pn.seriesHighlight] : []
  ), [j, q] = se.useState("lg"), [te, le] = se.useState([0, 0]), [B, X] = se.useState(), [ue, ne] = se.useState(), [J, W] = se.useState(!1), [K, ee] = se.useState(!1), [$, pe] = se.useState([]), [ve] = se.useState(`cove-${Math.random().toString(16).slice(-4)}`), [Te, ye] = se.useState({
    data: [],
    isActive: !1,
    isBrushing: !1
  }), Re = se.useContext(uT), Xe = (_e) => {
    v(_e), t && !a && Re.setTempConfig(_e);
  }, { description: Ce, visualizationType: xe } = m, Pe = se.useRef(null), de = se.useRef(null), Be = (_e) => {
    ee(_e);
  };
  r && console.log("Chart config, isEditor", m, t);
  let { legend: Ne, title: He } = m;
  t && (!He || He === "") && (He = "Chart Title"), m.table && (!((Sn = m.table) != null && Sn.label) || ((kt = m.table) == null ? void 0 : kt.label) === "") && (m.table.label = "Data Table");
  const { lineDatapointClass: Ze, contentClasses: $e, sparkLineStyles: Ye } = jg(m), qe = se.useId(), Ge = (m.xAxis || m.yAxis) && ["date-time", "date"].includes((m.xAxis || m.yAxis).type) && m.xAxis.dataKey, ke = () => Hc(m.visualizationType, M, m.allowLineToBarGraph), De = (_e, Oe) => {
    let Se = et.defaultsDeep(_e, hf);
    return et.defaultsDeep(Se, {
      table: { showVertical: !1 }
    }), et.set(Se, "table.show", et.get(Se, "table.show", !a)), et.forEach(Se.series, (ut) => {
      et.defaults(ut, {
        tooltip: !0,
        axis: "Left"
      });
    }), Se.visualizationType === "Bump Chart" && Se.xAxis.type, { ...Gg(Se) };
  }, at = (_e, Oe) => {
    var yt, Bt;
    const Se = et.cloneDeep(_e);
    let ut = Oe || A;
    ut = bm(ut, Se), Object.keys(hf).forEach((bt) => {
      Se[bt] && typeof Se[bt] == "object" && !Array.isArray(Se[bt]) && (Se[bt] = { ...hf[bt], ...Se[bt] });
    });
    const Kt = fT(Se, Oe || A);
    _(Kt);
    let Ht = [];
    if (Se.filters) {
      const bt = dv(Se.filters, Kt);
      Ht = Uo(bt, Kt), Z(Ht);
    }
    if (Se.xAxis.type === "date-time" && m.orientation === "horizontal" && (Se.xAxis.type = "date"), Se.runtime = {}, Se.runtime.series = et.cloneDeep(Se.series), Se.runtime.seriesLabels = {}, Se.runtime.seriesLabelsAll = [], Se.runtime.originalXAxis = Se.xAxis, Se.visualizationType === "Pie")
      Se.runtime.seriesKeys = (Oe || ut).map((bt) => bt[Se.xAxis.dataKey]), Se.runtime.seriesLabelsAll = Se.runtime.seriesKeys;
    else {
      const bt = Oe || Se.formattedData || Se.data;
      Se.runtime.seriesKeys = (Se.runtime.series || []).flatMap((Tt) => {
        if (Tt.dynamicCategory) {
          et.remove(Se.runtime.seriesLabelsAll, (tn) => tn === Tt.dataKey), et.remove(Se.runtime.series, (tn) => tn.dataKey === Tt.dataKey);
          const Pn = et.uniq(bt.map((tn) => tn[Tt.dynamicCategory]));
          return Pn.forEach((tn) => {
            Se.runtime.seriesLabels[tn] = tn, Se.runtime.seriesLabelsAll.push(tn), Se.runtime.series.push({
              dataKey: tn,
              type: Tt.type,
              lineType: Tt.lineType,
              originalDataKey: Tt.dataKey,
              dynamicCategory: Tt.dynamicCategory,
              tooltip: !0
            });
          }), Pn;
        } else
          return Se.runtime.seriesLabels[Tt.dataKey] = Tt.name || Tt.label || Tt.dataKey, Se.runtime.seriesLabelsAll.push(Tt.name || Tt.dataKey), [Tt.dataKey];
      });
    }
    if (Se.visualizationType === "Box Plot" && Se.series) {
      const [bt, Tt] = cT(Se, A);
      Se.boxplot.categories = Tt, Se.boxplot.plots = bt;
    }
    Se.visualizationType === "Combo" && Se.series && (Se.runtime = dT(Se)), Se.visualizationType === "Forecasting" && Se.series && (Se.runtime.forecastingSeriesKeys = [], Se.series.forEach((bt) => {
      bt.type === "Forecasting" && Se.runtime.forecastingSeriesKeys.push(bt);
    })), Se.visualizationType === "Area Chart" && Se.series && (Se.runtime.areaSeriesKeys = [], Se.series.forEach((bt) => {
      Se.runtime.areaSeriesKeys.push({ ...bt, type: "Area Chart" });
    })), Se.visualizationType === "Bar" && Se.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(Se.visualizationType) ? (Se.runtime.xAxis = Se.yAxis.yAxis ? Se.yAxis.yAxis : Se.yAxis, Se.runtime.yAxis = Se.xAxis.xAxis ? Se.xAxis.xAxis : Se.xAxis, Se.runtime.yAxis.labelOffset *= -1, Se.runtime.horizontal = !1, Se.orientation = "horizontal", Se.yAxis.type = Se.yAxis.type === "categorical" ? "linear" : Se.yAxis.type) : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(Se.visualizationType) && !ke() ? (Se.runtime.xAxis = Se.xAxis, Se.runtime.yAxis = Se.yAxis, Se.runtime.horizontal = !1, Se.orientation = "vertical") : (Se.runtime.xAxis = Se.xAxis, Se.runtime.yAxis = Se.yAxis, Se.runtime.horizontal = !1), Se.runtime.uniqueId = Date.now(), Se.runtime.editorErrorMessage = Se.visualizationType === "Pie" && !Se.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", Se.runtime.editorErrorMessage = "", (yt = Se.legend.seriesHighlight) != null && yt.length && ae((Bt = Se.legend) == null ? void 0 : Bt.seriesHighlight), Xe(Se);
  }, be = (_e, Oe) => {
    let Se = m.visualizationType === "Bar" && m.visualizationSubType === "horizontal" ? m.xAxis.dataKey : m.yAxis.sortKey, ut = parseFloat(_e[Se]), Kt = parseFloat(Oe[Se]);
    return ut < Kt ? m.sortData === "ascending" ? 1 : -1 : ut > Kt ? m.sortData === "ascending" ? -1 : 1 : 0;
  }, nt = new Sg((_e) => {
    for (let Oe of _e) {
      let { width: Se, height: ut } = Oe.contentRect;
      const Kt = 15;
      Se = t ? Se - 350 : Se;
      const yt = kg(Se);
      q(yt), Oe.target.dataset.lollipop === "true" && (Se = Se - 2.5), Se = Se - Kt, le([Se, ut]);
    }
  }), st = se.useCallback((_e) => {
    _e !== null && nt.observe(_e), ne(_e);
  }, []), lt = (_e, Oe) => (_e.dataDescription && (Oe = y.autoStandardize(Oe), Oe = y.developerStandardize(Oe, _e.dataDescription)), Oe = bm(Oe, _e), Oe);
  se.useEffect(() => {
    (async () => {
      try {
        const Oe = e.data;
        if (e.data && e) {
          const Se = await De(e, Oe), ut = lt(e, Oe);
          P(ut), _(ut), at(Se, ut);
        }
      } catch {
        console.error("Could not Load!");
      }
    })();
  }, [(wt = e == null ? void 0 : e.data) != null && wt.length ? e.data : null]), se.useEffect(() => {
    ue && !et.isEmpty(m) && !J && (Ug("cove_loaded", { config: m }), W(!0));
  }, [ue, m]), se.useEffect(() => {
    const _e = (Oe) => {
      let Se = [];
      Se.push(Oe.detail), X(Se);
    };
    return Kg("cove_filterData", (Oe) => _e(Oe)), () => {
      Yg("cove_filterData", _e);
    };
  }, [m]), se.useEffect(() => {
    if (B && B[0] && !B[0].hasOwnProperty("active")) {
      let Oe = { ...m };
      delete Oe.filters, Xe(Oe), Z(Uo(B, T));
    }
    if (B && B.length > 0 && B.length > 0 && B[0].hasOwnProperty("active")) {
      let _e = { ...m, filters: B };
      Xe(_e), Z(Uo(B, T));
    }
  }, [B]), se.useEffect(() => {
    var _e;
    if (A && m.xAxis && ((_e = m.runtime) != null && _e.seriesKeys)) {
      const Oe = pT(m);
      L(Oe), b(!1);
    }
    m && A && m.sortData && A.sort(be);
  }, [m, A]);
  const St = (_e) => {
    if (Y.length + 1 === m.runtime.seriesKeys.length && m.visualizationType !== "Forecasting")
      return Ut();
    const Oe = et.findKey(m.runtime.seriesLabels, (ut) => ut === _e.datum) || _e.datum, Se = et.xor(Y, [Oe]);
    ae(Se);
  }, Ut = () => {
    try {
      const _e = Pe.current;
      if (!_e)
        throw new Id("No legend available to set previous focus on.");
      _e.focus();
    } catch (_e) {
      console.error("COVE:", _e.message);
    }
    ae([]);
  }, It = m.orientation === "horizontal" ? "yAxis" : "xAxis", _t = (_e, Oe = !0) => {
    let Se = uy(m.runtime[It].dateParseFormat)(_e);
    return Se || (Oe && (m.runtime.editorErrorMessage = `Error parsing date "${_e}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, Rt = (_e, Oe, Se) => {
    var Kt, Ht;
    let ut = Hu(m.runtime[It].dateDisplayFormat)(_e);
    if ((Kt = m.runtime[It].dateDisplayFormat) != null && Kt.includes("%b.") && ut.includes("May.") && (ut = ut.replace(/May\./g, "May")), m.xAxis.showYearsOnce && ((Ht = m.runtime[It].dateDisplayFormat) != null && Ht.includes("%Y")) && Se) {
      const yt = Se[Oe - 1] ? Se[Oe - 1].value : null, Bt = Hu(m.runtime[It].dateDisplayFormat)(yt), bt = ut.match(/\d{4}/), Tt = Bt.match(/\d{4}/);
      bt && Tt && bt[0] === Tt[0] && (ut = ut.replace(bt, ""));
    }
    return ut;
  }, Lt = (_e) => Hu(m.tooltips.dateDisplayFormat)(_e), $t = (_e, Oe, Se = !1, ut, Kt, Ht, { index: yt, length: Bt } = { index: null, length: null }) => {
    if (isNaN(_e) || !_e)
      return _e;
    const bt = _e < 0;
    (Oe === void 0 || !Oe) && (Oe = "left"), bt && (_e = Math.abs(_e));
    let {
      dataFormat: {
        commas: Tt,
        abbreviated: Pn,
        roundTo: tn,
        prefix: Qt,
        suffix: Nt,
        rightRoundTo: Jt,
        bottomRoundTo: wn,
        rightPrefix: on,
        rightSuffix: Wn,
        bottomPrefix: Ln,
        bottomSuffix: Tn,
        bottomAbbreviated: ln,
        onlyShowTopPrefixSuffix: Dn
      }
    } = m;
    String(_e).indexOf(",") !== -1 && (_e = _e.replaceAll(",", ""));
    let _n = _e, Fn = {
      useGrouping: !!Tt
      // for old chart data table to work right cant just leave this to undefined
    };
    if (Oe === "left" || Oe === void 0) {
      let hn;
      Ht !== void 0 ? hn = Ht ? Number(Ht) : 0 : hn = tn ? Number(tn) : 0, Fn = {
        useGrouping: Ht ? !0 : !!m.dataFormat.commas,
        minimumFractionDigits: hn,
        maximumFractionDigits: hn
      };
    }
    Oe === "right" && (Fn = {
      useGrouping: !!m.dataFormat.rightCommas,
      minimumFractionDigits: Jt ? Number(Jt) : 0,
      maximumFractionDigits: Jt ? Number(Jt) : 0
    });
    const Kn = () => m.forestPlot.type === "Logarithmic" && !wn ? 2 : Number(wn) ? Number(wn) : 0;
    if (Oe === "bottom" && (Fn = {
      useGrouping: !!m.dataFormat.bottomCommas,
      minimumFractionDigits: Kn(),
      maximumFractionDigits: Kn()
    }), _e = Kp(_e), isNaN(_e))
      return m.runtime.editorErrorMessage = `Unable to parse number from data ${_n}. Try reviewing your data and selections in the Data Series section.`, _n;
    if (!m.dataFormat)
      return _e;
    if (m.dataCutoff) {
      let hn = Kp(m.dataCutoff);
      _e < hn && (_e = hn);
    }
    Oe === "left" && Tt && Pn && Se || Oe === "bottom" && Tt && Pn && Se ? _e = _e : _e = _e.toLocaleString("en-US", Fn);
    let sn = "";
    if (Pn && Oe === "left" && Se && (_e = vm(parseFloat(_e))), ln && Oe === "bottom" && Se && (_e = vm(parseFloat(_e))), ut && Oe === "left")
      sn = ut + sn;
    else {
      const hn = Dn && Bt - 1 !== yt;
      Qt && Oe === "left" && !hn && (sn += Qt);
    }
    return on && Oe === "right" && (sn += on), Ln && Oe === "bottom" && (sn += Ln), sn += _e, Kt && Oe === "left" ? sn += Kt : Nt && Oe === "left" && !Dn && (sn += Nt), Wn && Oe === "right" && (sn += Wn), Tn && Oe === "bottom" && (sn += Tn), bt && (sn = "-" + sn), String(sn);
  }, Dt = (_e) => {
    try {
      if (!_e)
        throw new Id("COVE: No rowObj in applyLegendToRow");
      if (m.type === "navigation") {
        let Oe = Sr[m.color] || Sr.bluegreenreverse;
        return Em(Oe[3]);
      }
      return Em();
    } catch (Oe) {
      console.error("COVE: ", Oe);
    }
  }, Gt = (_e) => {
    var Oe, Se;
    return Array.isArray(_e) ? m.visualizationType === "Forecasting" || (Oe = m.series) != null && Oe.some((ut) => !!ut.dynamicCategory) ? _e : (Se = m == null ? void 0 : m.xAxis) != null && Se.dataKey ? y.cleanData(_e, m.xAxis.dataKey) : _e : [];
  }, An = () => {
    var ut, Kt, Ht;
    if (xe === "Sankey")
      return (Kt = (ut = m == null ? void 0 : m.data) == null ? void 0 : ut[0]) == null ? void 0 : Kt.tableData;
    const _e = M || T, Oe = m.series.find((yt) => !!yt.dynamicCategory);
    if (!Oe)
      return _e;
    const Se = Object.values(m.columns).filter((yt) => yt.dataTable).map((yt) => yt.name).concat([Oe.dynamicCategory, Oe.dataKey]);
    return (Ht = m.xAxis) != null && Ht.dataKey && Se.push(m.xAxis.dataKey), _e.map((yt) => et.pick(yt, Se));
  }, Ot = (_e) => {
    const Oe = et.cloneDeep(_e), Se = Oe.series.find((ut) => !!ut.dynamicCategory);
    if (Se) {
      const ut = { columnName: Se.dynamicCategory, valueColumns: [Se.dataKey] };
      Oe.table.pivot = ut;
    }
    return Oe;
  };
  let Xt = /* @__PURE__ */ n.createElement(Qg, null);
  const ht = (_e) => {
    if (et.isString(_e))
      return et.kebabCase(_e);
  }, Je = () => {
    var Se;
    const _e = (Ne == null ? void 0 : Ne.position) === "bottom" || Va(j), Oe = ["chart-container", "p-relative"];
    return Ne != null && Ne.position && (Va(j) && (Ne == null ? void 0 : Ne.position) !== "top" ? Oe.push("legend-bottom") : Oe.push(`legend-${Ne.position}`)), Ne != null && Ne.hide && Oe.push("legend-hidden"), Ze && Oe.push(Ze), m.barHasBorder || Oe.push("chart-bar--no-border"), (Se = m.brush) != null && Se.active && (p == null ? void 0 : p.type) === "dashboard" && (!_e || Ne.hide) && Oe.push("dashboard-brush"), Oe.push(...$e), Oe;
  }, Zt = () => {
    var Se, ut;
    const _e = ["subtext mt-4"], Oe = (Ne == null ? void 0 : Ne.position) === "bottom" || Va(j);
    return m.isResponsiveTicks && _e.push("subtext--responsive-ticks "), (Se = m.brush) != null && Se.active && !Oe && _e.push("subtext--brush-active "), (ut = m.brush) != null && ut.active && m.legend.hide && _e.push("subtext--brush-active "), _e;
  };
  if (!g) {
    const _e = /* @__PURE__ */ n.createElement("a", { href: `#data-table-${m.dataKey}`, className: "margin-left-href" }, m.dataKey, " (Go to Table)");
    Xt = /* @__PURE__ */ n.createElement(n.Fragment, null, t && /* @__PURE__ */ n.createElement(lT, null), /* @__PURE__ */ n.createElement(mf.Responsive, { isEditor: t }, m.newViz && /* @__PURE__ */ n.createElement(fv, { updateConfig: at, config: m }), m.newViz === void 0 && t && m.runtime && ((kn = m.runtime) == null ? void 0 : kn.editorErrorMessage) && /* @__PURE__ */ n.createElement(Id, { errorMessage: m.runtime.editorErrorMessage }), !gf(m) && !m.newViz && /* @__PURE__ */ n.createElement(
      "div",
      {
        className: `cdc-chart-inner-container cove-component__content type-${ht(
          m.visualizationType
        )}`,
        "aria-label": Bf(m),
        tabIndex: 0
      },
      /* @__PURE__ */ n.createElement(
        Zg,
        {
          showTitle: m.showTitle,
          isDashboard: a,
          title: He,
          superTitle: m.superTitle,
          classes: ["chart-title", `${m.theme}`, "cove-component__header", "mb-3"],
          style: void 0
        }
      ),
      /* @__PURE__ */ n.createElement("div", { className: Je().join(" ") }, (m == null ? void 0 : m.introText) && m.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement("section", { className: "introText mb-4" }, Oi(m.introText)), m.filters && !B && m.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement(
        Up,
        {
          config: m,
          setConfig: Xe,
          setFilteredData: Z,
          filteredData: M,
          excludedData: T,
          filterData: Uo,
          dimensions: te
        }
      ), /* @__PURE__ */ n.createElement(Bp, { skipId: ds(m, qe), skipMessage: "Skip Over Chart Container" }), ((xt = m.annotations) == null ? void 0 : xt.length) > 0 && /* @__PURE__ */ n.createElement(
        Bp,
        {
          skipId: ds(m, qe),
          skipMessage: "Skip over annotations",
          key: "skip-annotations"
        }
      ), /* @__PURE__ */ n.createElement(bv, null, /* @__PURE__ */ n.createElement(
        "div",
        {
          className: Ne.hide || Va(j) || Ne.position === "bottom" || Ne.position === "top" || xe === "Sankey" ? "w-100" : "w-75"
        },
        !["Spark Line", "Line", "Sankey", "Pie", "Sankey"].includes(m.visualizationType) && /* @__PURE__ */ n.createElement("div", { ref: de, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Ko, null, (Oe) => /* @__PURE__ */ n.createElement(ff, { ref: w, parentWidth: Oe.width, parentHeight: Oe.height }))),
        m.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(Ko, { className: "justify-content-center d-flex", style: { width: "100%" } }, (Oe) => /* @__PURE__ */ n.createElement(KE, { ref: w, parentWidth: Oe.width, parentHeight: Oe.height })),
        m.visualizationType === "Line" && (ke() ? /* @__PURE__ */ n.createElement("div", { ref: de, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Ko, null, (Oe) => /* @__PURE__ */ n.createElement(ff, { ref: w, parentWidth: Oe.width, parentHeight: Oe.height }))) : /* @__PURE__ */ n.createElement("div", { ref: de, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Ko, null, (Oe) => /* @__PURE__ */ n.createElement(ff, { ref: w, parentWidth: Oe.width, parentHeight: Oe.height })))),
        m.visualizationType === "Spark Line" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
          Up,
          {
            config: m,
            setConfig: Xe,
            setFilteredData: Z,
            filteredData: M,
            excludedData: T,
            filterData: Uo,
            dimensions: te
          }
        ), (m == null ? void 0 : m.introText) && /* @__PURE__ */ n.createElement("section", { className: "introText mb-4", style: { padding: "0px 0 35px" } }, Oi(m.introText)), /* @__PURE__ */ n.createElement("div", { style: { height: "100px", width: "100%", ...Ye } }, /* @__PURE__ */ n.createElement(Ko, null, (Oe) => /* @__PURE__ */ n.createElement(sw, { width: Oe.width, height: Oe.height }))), Ce && /* @__PURE__ */ n.createElement("div", { className: "subtext", style: { padding: "35px 0 15px" } }, Oi(Ce))),
        m.visualizationType === "Sankey" && /* @__PURE__ */ n.createElement(Ko, { "aria-hidden": "true" }, (Oe) => /* @__PURE__ */ n.createElement(kS, { runtime: m.runtime, width: Oe.width, height: Oe.height }))
      ), !m.legend.hide && m.visualizationType !== "Spark Line" && m.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(Rw, { ref: Pe, skipId: ds(m, qe) })), a && m.table && m.table.show && m.table.showDataTableLink ? _e : d && d, m.description && m.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement("div", { className: Zt().join(" ") }, Oi(m.description)), /* @__PURE__ */ n.createElement(zd.Section, { classes: ["download-buttons"] }, m.table.showDownloadImgButton && /* @__PURE__ */ n.createElement(
        zd.Button,
        {
          text: "Download Image",
          title: "Download Chart as Image",
          type: "image",
          state: m,
          elementToCapture: ve
        }
      ), m.table.showDownloadPdfButton && /* @__PURE__ */ n.createElement(
        zd.Button,
        {
          text: "Download PDF",
          title: "Download Chart as PDF",
          type: "pdf",
          state: m,
          elementToCapture: ve
        }
      )), (m.xAxis.dataKey && m.table.show && m.visualizationType !== "Spark Line" && m.visualizationType !== "Sankey" || m.visualizationType === "Sankey" && m.table.show) && /* @__PURE__ */ n.createElement(
        qg,
        {
          key: Ge,
          config: Ot(m),
          rawData: m.visualizationType === "Sankey" ? (bn = (Pt = m == null ? void 0 : m.data) == null ? void 0 : Pt[0]) == null ? void 0 : bn.tableData : m.table.customTableConfig ? Uo(m.filters, m.data) : m.data,
          runtimeData: An(),
          expandDataTable: m.table.expanded,
          columns: m.columns,
          defaultSortBy: Ge,
          displayGeoName: (Oe) => Oe,
          applyLegendToRow: Dt,
          tableTitle: m.table.label,
          indexTitle: m.table.indexLabel,
          vizTitle: He,
          viewport: j,
          tabbingId: ds(m, qe),
          colorScale: S
        }
      ), ((On = m == null ? void 0 : m.annotations) == null ? void 0 : On.length) > 0 && /* @__PURE__ */ n.createElement(kp.Dropdown, null), (m == null ? void 0 : m.footnotes) && /* @__PURE__ */ n.createElement("section", { className: "footnotes pt-2 mt-4" }, Oi(m.footnotes)))
    )));
  }
  const vt = {
    brushConfig: Te,
    capitalize: (_e) => _e.charAt(0).toUpperCase() + _e.slice(1),
    clean: Gt,
    colorPalettes: Sr,
    colorScale: S,
    config: m,
    currentViewport: j,
    dashboardConfig: p,
    debugSvg: r,
    dimensions: te,
    dynamicLegendItems: $,
    excludedData: T,
    formatDate: Rt,
    formatNumber: $t,
    formatTooltipsDate: Lt,
    getXAxisData: (_e) => Rn(m.runtime.xAxis) ? _t(_e[m.runtime.originalXAxis.dataKey]).getTime() : _e[m.runtime.originalXAxis.dataKey],
    getYAxisData: (_e, Oe) => _e[Oe],
    handleChartAriaLabels: Bf,
    handleLineType: vg,
    handleChartTabbing: ds,
    highlight: St,
    handleShowAll: Ut,
    imageId: ve,
    isDashboard: a,
    isDebug: r,
    isDraggingAnnotation: K,
    handleDragStateChange: Be,
    isEditor: t,
    isNumber: Vi,
    legend: Ne,
    legendId: qe,
    legendRef: Pe,
    lineOptions: sT,
    loading: g,
    missingRequiredSections: gf,
    outerContainerRef: st,
    parentRef: de,
    parseDate: _t,
    rawData: et.cloneDeep(A) ?? {},
    seriesHighlight: Y,
    setBrushConfig: ye,
    setConfig: Xe,
    setDynamicLegendItems: pe,
    setEditing: o,
    setFilteredData: Z,
    setParentConfig: i,
    setSeriesHighlight: ae,
    setSharedFilter: c,
    setSharedFilterValue: s,
    svgRef: w,
    tableData: M || T,
    // do not clean table data
    transformedData: Gt(M || T),
    // do this right before passing to components
    twoColorPalette: Pc,
    unfilteredData: et.cloneDeep(A),
    updateConfig: at
  };
  return /* @__PURE__ */ n.createElement(ft.Provider, { value: vt }, /* @__PURE__ */ n.createElement(
    mf.VisualizationWrapper,
    {
      config: m,
      isEditor: t,
      currentViewport: j,
      ref: st,
      imageId: ve,
      showEditorPanel: m == null ? void 0 : m.showEditorPanel
    },
    Xt
  ));
}, jT = hT;
export {
  jT as C,
  _w as D,
  WT as E,
  uT as a,
  Dw as b,
  nT as f
};
