import { j as a, a as z, F as Ue } from "./storybook-jsx-runtime-36872362.es.js";
import { r as de, R as Ve } from "./storybook-index-45401197.es.js";
import { v as Nh, b as kg, g as Tg, f as Cg } from "./storybook-getViewport-7dc50c16.es.js";
import { _ as ri, p as Ph, U as Pa, W as Jr, X as Vt, Y as Dh, Z as Pc, $ as nr, t as Vu, a0 as rl, a1 as Id, a2 as _h, a3 as Jn, a4 as Oh, a5 as Ag, a6 as Lg, m as Mh, a7 as Cr, w as sl, P as Eg, d as Rg, e as nl, h as Fh, g as zh, j as Ng, y as Pg, S as Dg, a8 as yr, v as ul, b as Dc, z as km, a9 as Zu, s as _g, k as qf, K as Tm, N as Cm, Q as Qu, O as Am, H as Og, C as Bh, q as Mg, M as Lm, E as Fg, r as zg, u as Em, L as Bg, G as Ig, aa as _c, a as $g, J as Hg, I as Ih, D as Vg, B as Wg, V as jg, A as Ug } from "./storybook-InputToggle-26a8dec6.es.js";
import { L as gf, u as Kg, p as Yg, s as Gg, a as Xg, c as qg } from "./storybook-coveUpdateWorker-f0e4685a.es.js";
import { B as Oc } from "./storybook-Button-9d1b8d73.es.js";
import { a as Tn, b as Zf, t as Zg, c as us, L as $h, e as Hh, S as Vh, M as $d, D as Qg } from "./storybook-DataTable-58beb6cf.es.js";
import { H as za, T as Jg } from "./storybook-index-88ba5a71.es.js";
import { a as Ui, E as Ur, b as vf, L as ev } from "./storybook-viewports-678eca6e.es.js";
import { p as tv, P as ze } from "./storybook-index-43433e35.es.js";
import { d as nv } from "./storybook-debounce-cc216a80.es.js";
import { a as rv } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { _ as nt } from "./storybook-lodash-a4231e1c.es.js";
import { _ as cn } from "./storybook-extends-70f3d2a3.es.js";
import { s as ms, t as Rm, a as Nm, b as Pm, B as _r, d as Ps, c as In, C as iv } from "./storybook-linear-bc5fb9aa.es.js";
import { t as av, u as Wh, G as it, c as Cn, q as Mc, v as ov, w as Dm, x as jh, y as lv, z as sv, A as uv, B as cv } from "./storybook-linear-ef79b404.es.js";
import { R as dv } from "./storybook-index-633d712d.es.js";
import { T as gt } from "./storybook-Text-c19e6344.es.js";
import { t as _m, m as Hd, f as Om, d as Cu, a as Au, b as Lu, n as Uh, o as fv, p as Kh, c as Mm, e as Fm } from "./storybook-year-24bd1dc7.es.js";
import { e as Gi, a as Nn, b as Pn, c as Dn, d as _n, A as Ba, D as zm } from "./storybook-DataTransform-12e90958.es.js";
import { a as Ze, S as Bm } from "./storybook-Icon-5df8fab3.es.js";
import { B as Yh } from "./storybook-BlurStrokeText-7561b486.es.js";
import { T as oe } from "./storybook-Tooltip-b155742f.es.js";
import { T as Ge, S as xt, C as et } from "./storybook-Inputs-b140d38c.es.js";
import { M as Gh } from "./storybook-MultiSelect-09077870.es.js";
import { I as Xi } from "./storybook-InputSelect-f5896759.es.js";
import { A as Eu } from "./storybook-Accordion-e48d2b15.es.js";
import { f as Go, F as Xh, a as hv } from "./storybook-Filters-8098ad82.es.js";
import { n as qh } from "./storybook-numberFromString-24623c03.es.js";
const xf = (e) => {
  if (e.visualizationType === "Sankey" || e.visualizationType === "Forecasting" || e.visualizationType === "Forest Plot")
    return !1;
  if (e.visualizationType === "Pie") {
    if ((e == null ? void 0 : e.yAxis.dataKey) === void 0)
      return !0;
  } else if (((e == null ? void 0 : e.series) === void 0 || !((e == null ? void 0 : e.series.length) > 0)) && !(e != null && e.dynamicSeries))
    return !0;
  return !e.xAxis.dataKey;
}, pv = (e) => {
  const { updateConfig: t, config: n } = e, r = (o) => {
    o && o.preventDefault();
    let d = { ...n };
    delete d.newViz, t(d);
  };
  return /* @__PURE__ */ a("section", { className: "waiting", style: {
    position: "relative",
    height: "100vh",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gridArea: "content"
  }, children: /* @__PURE__ */ z("section", { className: "waiting-container", children: [
    /* @__PURE__ */ a("h3", { children: "Finish Configuring" }),
    /* @__PURE__ */ a("p", { children: "Set all required options to the left and confirm below to display a preview of the chart." }),
    /* @__PURE__ */ a(
      Oc,
      {
        className: "btn btn-primary",
        style: { margin: "1em auto" },
        disabled: xf(n),
        onClick: (o) => r(o),
        children: "I'm Done"
      }
    )
  ] }) });
}, Vd = ({ errorMessage: e }) => /* @__PURE__ */ a("section", { className: "waiting", style: {
  position: "absolute",
  background: "white",
  zIndex: "999",
  height: "100vh",
  width: "100%",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  gridArea: "content"
}, children: /* @__PURE__ */ z("section", { className: "waiting-container", children: [
  /* @__PURE__ */ a("h3", { children: "Error With Configuration" }),
  /* @__PURE__ */ a("p", { children: e })
] }) }), Ju = _m(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Ju.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? _m((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : Ju);
Ju.range;
class Zh extends Map {
  constructor(t, n = gv) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [r, i] of t)
        this.set(r, i);
  }
  get(t) {
    return super.get(Qh(this, t));
  }
  has(t) {
    return super.has(Qh(this, t));
  }
  set(t, n) {
    return super.set(mv(this, t), n);
  }
  delete(t) {
    return super.delete(yv(this, t));
  }
}
function Qh({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function mv({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function yv({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function gv(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function vv(e, t, n) {
  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(i); ++r < i; )
    o[r] = e + r * n;
  return o;
}
function xv(e, t, n, r, i, o) {
  const d = [
    [ms, 1, Cu],
    [ms, 5, 5 * Cu],
    [ms, 15, 15 * Cu],
    [ms, 30, 30 * Cu],
    [o, 1, Au],
    [o, 5, 5 * Au],
    [o, 15, 15 * Au],
    [o, 30, 30 * Au],
    [i, 1, Lu],
    [i, 3, 3 * Lu],
    [i, 6, 6 * Lu],
    [i, 12, 12 * Lu],
    [r, 1, Uh],
    [r, 2, 2 * Uh],
    [n, 1, fv],
    [t, 1, Kh],
    [t, 3, 3 * Kh],
    [e, 1, Hd]
  ];
  function c(p, m, g) {
    const x = m < p;
    x && ([p, m] = [m, p]);
    const T = g && typeof g.range == "function" ? g : s(p, m, g), y = T ? T.range(p, +m + 1) : [];
    return x ? y.reverse() : y;
  }
  function s(p, m, g) {
    const x = Math.abs(m - p) / g, T = av(([, , b]) => b).right(d, x);
    if (T === d.length)
      return e.every(Wh(p / Hd, m / Hd, g));
    if (T === 0)
      return Ju.every(Math.max(Wh(p, m, g), 1));
    const [y, A] = d[x / d[T - 1][2] < d[T][2] / x ? T - 1 : T];
    return y.every(A);
  }
  return [c, s];
}
const [bv, Sv] = xv(Om, Pm, Fm, Mm, Nm, Rm), Qf = de.createContext(() => {
}), vt = de.createContext({}), wv = (e) => {
  const { children: t } = e, { config: n, currentViewport: r } = de.useContext(vt);
  return /* @__PURE__ */ z("div", { className: (() => {
    let o = ["legend-wrapper", "d-flex", "flex-nowrap", "w-100"];
    const { legend: d } = n;
    return (d.position === "bottom" || d.position === "top" || Ui(r)) && (o = o.filter((c) => c !== "flex-nowrap"), o.push("flex-wrap")), o.join(" ");
  })(), children: [
    ...t
  ] });
};
var $a = [], kv = function() {
  return $a.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Tv = function() {
  return $a.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, Jh = "ResizeObserver loop completed with undelivered notifications.", Cv = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: Jh
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = Jh), window.dispatchEvent(e);
}, Cs;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Cs || (Cs = {}));
var Ha = function(e) {
  return Object.freeze(e);
}, Im = function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Ha(this);
  }
  return e;
}(), $m = function() {
  function e(t, n, r, i) {
    return this.x = t, this.y = n, this.width = r, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Ha(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, i = t.top, o = t.right, d = t.bottom, c = t.left, s = t.width, p = t.height;
    return { x: n, y: r, top: i, right: o, bottom: d, left: c, width: s, height: p };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Jf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Hm = function(e) {
  if (Jf(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var i = e, o = i.offsetWidth, d = i.offsetHeight;
  return !(o || d || e.getClientRects().length);
}, ep = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, Av = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ys = typeof window < "u" ? window : {}, Ru = /* @__PURE__ */ new WeakMap(), tp = /auto|scroll/, Lv = /^tb|vertical/, Ev = /msie|trident/i.test(ys.navigator && ys.navigator.userAgent), ei = function(e) {
  return parseFloat(e || "0");
}, ol = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Im((n ? t : e) || 0, (n ? e : t) || 0);
}, np = Ha({
  devicePixelContentBoxSize: ol(),
  borderBoxSize: ol(),
  contentBoxSize: ol(),
  contentRect: new $m(0, 0, 0, 0)
}), Vm = function(e, t) {
  if (t === void 0 && (t = !1), Ru.has(e) && !t)
    return Ru.get(e);
  if (Hm(e))
    return Ru.set(e, np), np;
  var n = getComputedStyle(e), r = Jf(e) && e.ownerSVGElement && e.getBBox(), i = !Ev && n.boxSizing === "border-box", o = Lv.test(n.writingMode || ""), d = !r && tp.test(n.overflowY || ""), c = !r && tp.test(n.overflowX || ""), s = r ? 0 : ei(n.paddingTop), p = r ? 0 : ei(n.paddingRight), m = r ? 0 : ei(n.paddingBottom), g = r ? 0 : ei(n.paddingLeft), x = r ? 0 : ei(n.borderTopWidth), T = r ? 0 : ei(n.borderRightWidth), y = r ? 0 : ei(n.borderBottomWidth), A = r ? 0 : ei(n.borderLeftWidth), b = g + p, v = s + m, E = A + T, N = x + y, R = c ? e.offsetHeight - N - e.clientHeight : 0, L = d ? e.offsetWidth - E - e.clientWidth : 0, B = i ? b + E : 0, j = i ? v + N : 0, Z = r ? r.width : ei(n.width) - B - L, re = r ? r.height : ei(n.height) - j - R, X = Z + b + L + E, se = re + v + R + N, Y = Ha({
    devicePixelContentBoxSize: ol(Math.round(Z * devicePixelRatio), Math.round(re * devicePixelRatio), o),
    borderBoxSize: ol(X, se, o),
    contentBoxSize: ol(Z, re, o),
    contentRect: new $m(g, s, Z, re)
  });
  return Ru.set(e, Y), Y;
}, Wm = function(e, t, n) {
  var r = Vm(e, n), i = r.borderBoxSize, o = r.contentBoxSize, d = r.devicePixelContentBoxSize;
  switch (t) {
    case Cs.DEVICE_PIXEL_CONTENT_BOX:
      return d;
    case Cs.BORDER_BOX:
      return i;
    default:
      return o;
  }
}, jm = function() {
  function e(t) {
    var n = Vm(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Ha([n.borderBoxSize]), this.contentBoxSize = Ha([n.contentBoxSize]), this.devicePixelContentBoxSize = Ha([n.devicePixelContentBoxSize]);
  }
  return e;
}(), Um = function(e) {
  if (Hm(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Rv = function() {
  var e = 1 / 0, t = [];
  $a.forEach(function(d) {
    if (d.activeTargets.length !== 0) {
      var c = [];
      d.activeTargets.forEach(function(p) {
        var m = new jm(p.target), g = Um(p.target);
        c.push(m), p.lastReportedSize = Wm(p.target, p.observedBox), g < e && (e = g);
      }), t.push(function() {
        d.callback.call(d.observer, c, d.observer);
      }), d.activeTargets.splice(0, d.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var i = r[n];
    i();
  }
  return e;
}, rp = function(e) {
  $a.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(i) {
      i.isActive() && (Um(i.target) > e ? n.activeTargets.push(i) : n.skippedTargets.push(i));
    });
  });
}, Nv = function() {
  var e = 0;
  for (rp(e); kv(); )
    e = Rv(), rp(e);
  return Tv() && Cv(), e > 0;
}, Wd, Km = [], Pv = function() {
  return Km.splice(0).forEach(function(e) {
    return e();
  });
}, Dv = function(e) {
  if (!Wd) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return Pv();
    }).observe(n, r), Wd = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  Km.push(e), Wd();
}, _v = function(e) {
  Dv(function() {
    requestAnimationFrame(e);
  });
}, Wu = 0, Ov = function() {
  return !!Wu;
}, Mv = 250, Fv = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, ip = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], ap = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, jd = !1, zv = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Mv), !jd) {
      jd = !0;
      var r = ap(t);
      _v(function() {
        var i = !1;
        try {
          i = Nv();
        } finally {
          if (jd = !1, t = r - ap(), !Ov())
            return;
          i ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, Fv);
    };
    document.body ? n() : ys.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), ip.forEach(function(n) {
      return ys.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), ip.forEach(function(n) {
      return ys.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), bf = new zv(), op = function(e) {
  !Wu && e > 0 && bf.start(), Wu += e, !Wu && bf.stop();
}, Bv = function(e) {
  return !Jf(e) && !Av(e) && getComputedStyle(e).display === "inline";
}, Iv = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Cs.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Wm(this.target, this.observedBox, !0);
    return Bv(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), $v = function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Nu = /* @__PURE__ */ new WeakMap(), lp = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Pu = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new $v(t, n);
    Nu.set(t, r);
  }, e.observe = function(t, n, r) {
    var i = Nu.get(t), o = i.observationTargets.length === 0;
    lp(i.observationTargets, n) < 0 && (o && $a.push(i), i.observationTargets.push(new Iv(n, r && r.box)), op(1), bf.schedule());
  }, e.unobserve = function(t, n) {
    var r = Nu.get(t), i = lp(r.observationTargets, n), o = r.observationTargets.length === 1;
    i >= 0 && (o && $a.splice($a.indexOf(r), 1), r.observationTargets.splice(i, 1), op(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Nu.get(t);
    r.observationTargets.slice().forEach(function(i) {
      return n.unobserve(t, i.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), Hv = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Pu.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!ep(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Pu.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!ep(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Pu.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Pu.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const Vv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: Hv,
  ResizeObserverEntry: jm,
  ResizeObserverSize: Im
}, Symbol.toStringTag, { value: "Module" })), Wv = /* @__PURE__ */ rv(Vv);
var Xo = Xm, Vi = Gm(tv), jv = Gm(nv), qo = Yv(de), Uv = Wv, Kv = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function Ym(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (Ym = function(i) {
    return i ? n : t;
  })(e);
}
function Yv(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = Ym(t);
  if (n && n.has(e))
    return n.get(e);
  var r = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var d = i ? Object.getOwnPropertyDescriptor(e, o) : null;
      d && (d.get || d.set) ? Object.defineProperty(r, o, d) : r[o] = e[o];
    }
  return r.default = e, n && n.set(e, r), r;
}
function Gm(e) {
  return e && e.__esModule ? e : { default: e };
}
function ec() {
  return ec = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ec.apply(this, arguments);
}
function Gv(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var Xv = [];
function Xm(e) {
  var t = e.className, n = e.children, r = e.debounceTime, i = r === void 0 ? 300 : r, o = e.ignoreDimensions, d = o === void 0 ? Xv : o, c = e.parentSizeStyles, s = c === void 0 ? {
    width: "100%",
    height: "100%"
  } : c, p = e.enableDebounceLeadingCall, m = p === void 0 ? !0 : p, g = Gv(e, Kv), x = (0, qo.useRef)(null), T = (0, qo.useRef)(0), y = (0, qo.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), A = y[0], b = y[1], v = (0, qo.useMemo)(function() {
    var E = Array.isArray(d) ? d : [d];
    return (0, jv.default)(function(N) {
      b(function(R) {
        var L = Object.keys(R), B = L.filter(function(Z) {
          return R[Z] !== N[Z];
        }), j = B.every(function(Z) {
          return E.includes(Z);
        });
        return j ? R : N;
      });
    }, i, {
      leading: m
    });
  }, [i, m, d]);
  return (0, qo.useEffect)(function() {
    var E = new Uv.ResizeObserver(function(N) {
      N === void 0 && (N = []), N.forEach(function(R) {
        var L = R.contentRect, B = L.left, j = L.top, Z = L.width, re = L.height;
        T.current = window.requestAnimationFrame(function() {
          v({
            width: Z,
            height: re,
            top: j,
            left: B
          });
        });
      });
    });
    return x.current && E.observe(x.current), function() {
      window.cancelAnimationFrame(T.current), E.disconnect(), v != null && v.cancel && v.cancel();
    };
  }, [v]), /* @__PURE__ */ qo.default.createElement("div", ec({
    style: s,
    ref: x,
    className: t
  }, g), n(ec({}, A, {
    ref: x.current,
    resize: v
  })));
}
Xm.propTypes = {
  className: Vi.default.string,
  debounceTime: Vi.default.number,
  enableDebounceLeadingCall: Vi.default.bool,
  ignoreDimensions: Vi.default.oneOfType([Vi.default.any, Vi.default.arrayOf(Vi.default.any)]),
  children: Vi.default.func.isRequired
};
var Ud = /* @__PURE__ */ new Date(), Kd = /* @__PURE__ */ new Date();
function Si(e, t, n, r) {
  function i(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return i.floor = function(o) {
    return e(o = /* @__PURE__ */ new Date(+o)), o;
  }, i.ceil = function(o) {
    return e(o = new Date(o - 1)), t(o, 1), e(o), o;
  }, i.round = function(o) {
    var d = i(o), c = i.ceil(o);
    return o - d < c - o ? d : c;
  }, i.offset = function(o, d) {
    return t(o = /* @__PURE__ */ new Date(+o), d == null ? 1 : Math.floor(d)), o;
  }, i.range = function(o, d, c) {
    var s = [], p;
    if (o = i.ceil(o), c = c == null ? 1 : Math.floor(c), !(o < d) || !(c > 0))
      return s;
    do
      s.push(p = /* @__PURE__ */ new Date(+o)), t(o, c), e(o);
    while (p < o && o < d);
    return s;
  }, i.filter = function(o) {
    return Si(function(d) {
      if (d >= d)
        for (; e(d), !o(d); )
          d.setTime(d - 1);
    }, function(d, c) {
      if (d >= d)
        if (c < 0)
          for (; ++c <= 0; )
            for (; t(d, -1), !o(d); )
              ;
        else
          for (; --c >= 0; )
            for (; t(d, 1), !o(d); )
              ;
    });
  }, n && (i.count = function(o, d) {
    return Ud.setTime(+o), Kd.setTime(+d), e(Ud), e(Kd), Math.floor(n(Ud, Kd));
  }, i.every = function(o) {
    return o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(r ? function(d) {
      return r(d) % o === 0;
    } : function(d) {
      return i.count(0, d) % o === 0;
    }) : i;
  }), i;
}
const qv = 1e3, eh = qv * 60, Zv = eh * 60, th = Zv * 24, qm = th * 7;
var Zm = Si(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * eh) / th,
  (e) => e.getDate() - 1
);
const Qm = Zm;
Zm.range;
function Ya(e) {
  return Si(function(t) {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setDate(t.getDate() + n * 7);
  }, function(t, n) {
    return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * eh) / qm;
  });
}
var Jm = Ya(0), tc = Ya(1), Qv = Ya(2), Jv = Ya(3), cl = Ya(4), ex = Ya(5), tx = Ya(6);
Jm.range;
tc.range;
Qv.range;
Jv.range;
cl.range;
ex.range;
tx.range;
var nh = Si(function(e) {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setFullYear(e.getFullYear() + t);
}, function(e, t) {
  return t.getFullYear() - e.getFullYear();
}, function(e) {
  return e.getFullYear();
});
nh.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Si(function(t) {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setFullYear(t.getFullYear() + n * e);
  });
};
const As = nh;
nh.range;
var ey = Si(function(e) {
  e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCDate(e.getUTCDate() + t);
}, function(e, t) {
  return (t - e) / th;
}, function(e) {
  return e.getUTCDate() - 1;
});
const ty = ey;
ey.range;
function Ga(e) {
  return Si(function(t) {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, function(t, n) {
    return (n - t) / qm;
  });
}
var ny = Ga(0), nc = Ga(1), nx = Ga(2), rx = Ga(3), dl = Ga(4), ix = Ga(5), ax = Ga(6);
ny.range;
nc.range;
nx.range;
rx.range;
dl.range;
ix.range;
ax.range;
var rh = Si(function(e) {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, function(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}, function(e) {
  return e.getUTCFullYear();
});
rh.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Si(function(t) {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setUTCFullYear(t.getUTCFullYear() + n * e);
  });
};
const Ls = rh;
rh.range;
function ry(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function sp(e) {
  let t = e, n = e;
  e.length === 1 && (t = (d, c) => e(d) - c, n = ox(e));
  function r(d, c, s, p) {
    for (s == null && (s = 0), p == null && (p = d.length); s < p; ) {
      const m = s + p >>> 1;
      n(d[m], c) < 0 ? s = m + 1 : p = m;
    }
    return s;
  }
  function i(d, c, s, p) {
    for (s == null && (s = 0), p == null && (p = d.length); s < p; ) {
      const m = s + p >>> 1;
      n(d[m], c) > 0 ? p = m : s = m + 1;
    }
    return s;
  }
  function o(d, c, s, p) {
    s == null && (s = 0), p == null && (p = d.length);
    const m = r(d, c, s, p - 1);
    return m > s && t(d[m - 1], c) > -t(d[m], c) ? m - 1 : m;
  }
  return { left: r, center: o, right: i };
}
function ox(e) {
  return (t, n) => ry(e(t), n);
}
function* lx(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let r of e)
      (r = t(r, ++n, e)) != null && (r = +r) >= r && (yield r);
  }
}
function sx(e, t) {
  let n = 0, r, i = 0, o = 0;
  if (t === void 0)
    for (let d of e)
      d != null && (d = +d) >= d && (r = d - i, i += r / ++n, o += r * (d - i));
  else {
    let d = -1;
    for (let c of e)
      (c = t(c, ++d, e)) != null && (c = +c) >= c && (r = c - i, i += r / ++n, o += r * (c - i));
  }
  if (n > 1)
    return o / (n - 1);
}
function ux(e, t) {
  const n = sx(e, t);
  return n && Math.sqrt(n);
}
function rc(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function Sf(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function iy(e, t, n = 0, r = e.length - 1, i = ry) {
  for (; r > n; ) {
    if (r - n > 600) {
      const s = r - n + 1, p = t - n + 1, m = Math.log(s), g = 0.5 * Math.exp(2 * m / 3), x = 0.5 * Math.sqrt(m * g * (s - g) / s) * (p - s / 2 < 0 ? -1 : 1), T = Math.max(n, Math.floor(t - p * g / s + x)), y = Math.min(r, Math.floor(t + (s - p) * g / s + x));
      iy(e, t, T, y, i);
    }
    const o = e[t];
    let d = n, c = r;
    for (cs(e, n, t), i(e[r], o) > 0 && cs(e, n, r); d < c; ) {
      for (cs(e, d, c), ++d, --c; i(e[d], o) < 0; )
        ++d;
      for (; i(e[c], o) > 0; )
        --c;
    }
    i(e[n], o) === 0 ? cs(e, n, c) : (++c, cs(e, c, r)), c <= t && (n = c + 1), t <= c && (r = c - 1);
  }
  return e;
}
function cs(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function Es(e, t, n) {
  if (e = Float64Array.from(lx(e, n)), !!(r = e.length)) {
    if ((t = +t) <= 0 || r < 2)
      return Sf(e);
    if (t >= 1)
      return rc(e);
    var r, i = (r - 1) * t, o = Math.floor(i), d = rc(iy(e, o).subarray(0, o + 1)), c = Sf(e.subarray(o + 1));
    return d + (c - d) * (i - o);
  }
}
function cx(e, t) {
  let n = 0, r = 0;
  if (t === void 0)
    for (let i of e)
      i != null && (i = +i) >= i && (++n, r += i);
  else {
    let i = -1;
    for (let o of e)
      (o = t(o, ++i, e)) != null && (o = +o) >= o && (++n, r += o);
  }
  if (n)
    return r / n;
}
function ay(e, t) {
  return Es(e, 0.5, t);
}
function Yd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Gd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function ds(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function dx(e) {
  var t = e.dateTime, n = e.date, r = e.time, i = e.periods, o = e.days, d = e.shortDays, c = e.months, s = e.shortMonths, p = fs(i), m = hs(i), g = fs(o), x = hs(o), T = fs(d), y = hs(d), A = fs(c), b = hs(c), v = fs(s), E = hs(s), N = {
    a: te,
    A: J,
    b: Q,
    B: G,
    c: null,
    d: pp,
    e: pp,
    f: Ox,
    g: jx,
    G: Kx,
    H: Px,
    I: Dx,
    j: _x,
    L: oy,
    m: Mx,
    M: Fx,
    p: ne,
    q: H,
    Q: gp,
    s: vp,
    S: zx,
    u: Bx,
    U: Ix,
    V: $x,
    w: Hx,
    W: Vx,
    x: null,
    X: null,
    y: Wx,
    Y: Ux,
    Z: Yx,
    "%": yp
  }, R = {
    a: ce,
    A: ke,
    b: Se,
    B: xe,
    c: null,
    d: mp,
    e: mp,
    f: Zx,
    g: lb,
    G: ub,
    H: Gx,
    I: Xx,
    j: qx,
    L: sy,
    m: Qx,
    M: Jx,
    p: De,
    q: je,
    Q: gp,
    s: vp,
    S: eb,
    u: tb,
    U: nb,
    V: rb,
    w: ib,
    W: ab,
    x: null,
    X: null,
    y: ob,
    Y: sb,
    Z: cb,
    "%": yp
  }, L = {
    a: X,
    A: se,
    b: Y,
    B: ie,
    c: I,
    d: fp,
    e: fp,
    f: Lx,
    g: dp,
    G: cp,
    H: hp,
    I: hp,
    j: kx,
    L: Ax,
    m: wx,
    M: Tx,
    p: re,
    q: Sx,
    Q: Rx,
    s: Nx,
    S: Cx,
    u: yx,
    U: gx,
    V: vx,
    w: mx,
    W: xx,
    x: U,
    X: ue,
    y: dp,
    Y: cp,
    Z: bx,
    "%": Ex
  };
  N.x = B(n, N), N.X = B(r, N), N.c = B(t, N), R.x = B(n, R), R.X = B(r, R), R.c = B(t, R);
  function B(Ce, ye) {
    return function(Ee) {
      var he = [], Be = -1, $e = 0, tt = Ce.length, We, Fe, Je;
      for (Ee instanceof Date || (Ee = /* @__PURE__ */ new Date(+Ee)); ++Be < tt; )
        Ce.charCodeAt(Be) === 37 && (he.push(Ce.slice($e, Be)), (Fe = up[We = Ce.charAt(++Be)]) != null ? We = Ce.charAt(++Be) : Fe = We === "e" ? " " : "0", (Je = ye[We]) && (We = Je(Ee, Fe)), he.push(We), $e = Be + 1);
      return he.push(Ce.slice($e, Be)), he.join("");
    };
  }
  function j(Ce, ye) {
    return function(Ee) {
      var he = ds(1900, void 0, 1), Be = Z(he, Ce, Ee += "", 0), $e, tt;
      if (Be != Ee.length)
        return null;
      if ("Q" in he)
        return new Date(he.Q);
      if ("s" in he)
        return new Date(he.s * 1e3 + ("L" in he ? he.L : 0));
      if (ye && !("Z" in he) && (he.Z = 0), "p" in he && (he.H = he.H % 12 + he.p * 12), he.m === void 0 && (he.m = "q" in he ? he.q : 0), "V" in he) {
        if (he.V < 1 || he.V > 53)
          return null;
        "w" in he || (he.w = 1), "Z" in he ? ($e = Gd(ds(he.y, 0, 1)), tt = $e.getUTCDay(), $e = tt > 4 || tt === 0 ? nc.ceil($e) : nc($e), $e = ty.offset($e, (he.V - 1) * 7), he.y = $e.getUTCFullYear(), he.m = $e.getUTCMonth(), he.d = $e.getUTCDate() + (he.w + 6) % 7) : ($e = Yd(ds(he.y, 0, 1)), tt = $e.getDay(), $e = tt > 4 || tt === 0 ? tc.ceil($e) : tc($e), $e = Qm.offset($e, (he.V - 1) * 7), he.y = $e.getFullYear(), he.m = $e.getMonth(), he.d = $e.getDate() + (he.w + 6) % 7);
      } else
        ("W" in he || "U" in he) && ("w" in he || (he.w = "u" in he ? he.u % 7 : "W" in he ? 1 : 0), tt = "Z" in he ? Gd(ds(he.y, 0, 1)).getUTCDay() : Yd(ds(he.y, 0, 1)).getDay(), he.m = 0, he.d = "W" in he ? (he.w + 6) % 7 + he.W * 7 - (tt + 5) % 7 : he.w + he.U * 7 - (tt + 6) % 7);
      return "Z" in he ? (he.H += he.Z / 100 | 0, he.M += he.Z % 100, Gd(he)) : Yd(he);
    };
  }
  function Z(Ce, ye, Ee, he) {
    for (var Be = 0, $e = ye.length, tt = Ee.length, We, Fe; Be < $e; ) {
      if (he >= tt)
        return -1;
      if (We = ye.charCodeAt(Be++), We === 37) {
        if (We = ye.charAt(Be++), Fe = L[We in up ? ye.charAt(Be++) : We], !Fe || (he = Fe(Ce, Ee, he)) < 0)
          return -1;
      } else if (We != Ee.charCodeAt(he++))
        return -1;
    }
    return he;
  }
  function re(Ce, ye, Ee) {
    var he = p.exec(ye.slice(Ee));
    return he ? (Ce.p = m.get(he[0].toLowerCase()), Ee + he[0].length) : -1;
  }
  function X(Ce, ye, Ee) {
    var he = T.exec(ye.slice(Ee));
    return he ? (Ce.w = y.get(he[0].toLowerCase()), Ee + he[0].length) : -1;
  }
  function se(Ce, ye, Ee) {
    var he = g.exec(ye.slice(Ee));
    return he ? (Ce.w = x.get(he[0].toLowerCase()), Ee + he[0].length) : -1;
  }
  function Y(Ce, ye, Ee) {
    var he = v.exec(ye.slice(Ee));
    return he ? (Ce.m = E.get(he[0].toLowerCase()), Ee + he[0].length) : -1;
  }
  function ie(Ce, ye, Ee) {
    var he = A.exec(ye.slice(Ee));
    return he ? (Ce.m = b.get(he[0].toLowerCase()), Ee + he[0].length) : -1;
  }
  function I(Ce, ye, Ee) {
    return Z(Ce, t, ye, Ee);
  }
  function U(Ce, ye, Ee) {
    return Z(Ce, n, ye, Ee);
  }
  function ue(Ce, ye, Ee) {
    return Z(Ce, r, ye, Ee);
  }
  function te(Ce) {
    return d[Ce.getDay()];
  }
  function J(Ce) {
    return o[Ce.getDay()];
  }
  function Q(Ce) {
    return s[Ce.getMonth()];
  }
  function G(Ce) {
    return c[Ce.getMonth()];
  }
  function ne(Ce) {
    return i[+(Ce.getHours() >= 12)];
  }
  function H(Ce) {
    return 1 + ~~(Ce.getMonth() / 3);
  }
  function ce(Ce) {
    return d[Ce.getUTCDay()];
  }
  function ke(Ce) {
    return o[Ce.getUTCDay()];
  }
  function Se(Ce) {
    return s[Ce.getUTCMonth()];
  }
  function xe(Ce) {
    return c[Ce.getUTCMonth()];
  }
  function De(Ce) {
    return i[+(Ce.getUTCHours() >= 12)];
  }
  function je(Ce) {
    return 1 + ~~(Ce.getUTCMonth() / 3);
  }
  return {
    format: function(Ce) {
      var ye = B(Ce += "", N);
      return ye.toString = function() {
        return Ce;
      }, ye;
    },
    parse: function(Ce) {
      var ye = j(Ce += "", !1);
      return ye.toString = function() {
        return Ce;
      }, ye;
    },
    utcFormat: function(Ce) {
      var ye = B(Ce += "", R);
      return ye.toString = function() {
        return Ce;
      }, ye;
    },
    utcParse: function(Ce) {
      var ye = j(Ce += "", !0);
      return ye.toString = function() {
        return Ce;
      }, ye;
    }
  };
}
var up = { "-": "", _: " ", 0: "0" }, Wn = /^\s*\d+/, fx = /^%/, hx = /[\\^$*+?|[\]().{}]/g;
function Gt(e, t, n) {
  var r = e < 0 ? "-" : "", i = (r ? -e : e) + "", o = i.length;
  return r + (o < n ? new Array(n - o + 1).join(t) + i : i);
}
function px(e) {
  return e.replace(hx, "\\$&");
}
function fs(e) {
  return new RegExp("^(?:" + e.map(px).join("|") + ")", "i");
}
function hs(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function mx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 1));
  return r ? (e.w = +r[0], n + r[0].length) : -1;
}
function yx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 1));
  return r ? (e.u = +r[0], n + r[0].length) : -1;
}
function gx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 2));
  return r ? (e.U = +r[0], n + r[0].length) : -1;
}
function vx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 2));
  return r ? (e.V = +r[0], n + r[0].length) : -1;
}
function xx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 2));
  return r ? (e.W = +r[0], n + r[0].length) : -1;
}
function cp(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 4));
  return r ? (e.y = +r[0], n + r[0].length) : -1;
}
function dp(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 2));
  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;
}
function bx(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;
}
function Sx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 1));
  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;
}
function wx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 2));
  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;
}
function fp(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 2));
  return r ? (e.d = +r[0], n + r[0].length) : -1;
}
function kx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 3));
  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;
}
function hp(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 2));
  return r ? (e.H = +r[0], n + r[0].length) : -1;
}
function Tx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 2));
  return r ? (e.M = +r[0], n + r[0].length) : -1;
}
function Cx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 2));
  return r ? (e.S = +r[0], n + r[0].length) : -1;
}
function Ax(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 3));
  return r ? (e.L = +r[0], n + r[0].length) : -1;
}
function Lx(e, t, n) {
  var r = Wn.exec(t.slice(n, n + 6));
  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;
}
function Ex(e, t, n) {
  var r = fx.exec(t.slice(n, n + 1));
  return r ? n + r[0].length : -1;
}
function Rx(e, t, n) {
  var r = Wn.exec(t.slice(n));
  return r ? (e.Q = +r[0], n + r[0].length) : -1;
}
function Nx(e, t, n) {
  var r = Wn.exec(t.slice(n));
  return r ? (e.s = +r[0], n + r[0].length) : -1;
}
function pp(e, t) {
  return Gt(e.getDate(), t, 2);
}
function Px(e, t) {
  return Gt(e.getHours(), t, 2);
}
function Dx(e, t) {
  return Gt(e.getHours() % 12 || 12, t, 2);
}
function _x(e, t) {
  return Gt(1 + Qm.count(As(e), e), t, 3);
}
function oy(e, t) {
  return Gt(e.getMilliseconds(), t, 3);
}
function Ox(e, t) {
  return oy(e, t) + "000";
}
function Mx(e, t) {
  return Gt(e.getMonth() + 1, t, 2);
}
function Fx(e, t) {
  return Gt(e.getMinutes(), t, 2);
}
function zx(e, t) {
  return Gt(e.getSeconds(), t, 2);
}
function Bx(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function Ix(e, t) {
  return Gt(Jm.count(As(e) - 1, e), t, 2);
}
function ly(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? cl(e) : cl.ceil(e);
}
function $x(e, t) {
  return e = ly(e), Gt(cl.count(As(e), e) + (As(e).getDay() === 4), t, 2);
}
function Hx(e) {
  return e.getDay();
}
function Vx(e, t) {
  return Gt(tc.count(As(e) - 1, e), t, 2);
}
function Wx(e, t) {
  return Gt(e.getFullYear() % 100, t, 2);
}
function jx(e, t) {
  return e = ly(e), Gt(e.getFullYear() % 100, t, 2);
}
function Ux(e, t) {
  return Gt(e.getFullYear() % 1e4, t, 4);
}
function Kx(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? cl(e) : cl.ceil(e), Gt(e.getFullYear() % 1e4, t, 4);
}
function Yx(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Gt(t / 60 | 0, "0", 2) + Gt(t % 60, "0", 2);
}
function mp(e, t) {
  return Gt(e.getUTCDate(), t, 2);
}
function Gx(e, t) {
  return Gt(e.getUTCHours(), t, 2);
}
function Xx(e, t) {
  return Gt(e.getUTCHours() % 12 || 12, t, 2);
}
function qx(e, t) {
  return Gt(1 + ty.count(Ls(e), e), t, 3);
}
function sy(e, t) {
  return Gt(e.getUTCMilliseconds(), t, 3);
}
function Zx(e, t) {
  return sy(e, t) + "000";
}
function Qx(e, t) {
  return Gt(e.getUTCMonth() + 1, t, 2);
}
function Jx(e, t) {
  return Gt(e.getUTCMinutes(), t, 2);
}
function eb(e, t) {
  return Gt(e.getUTCSeconds(), t, 2);
}
function tb(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function nb(e, t) {
  return Gt(ny.count(Ls(e) - 1, e), t, 2);
}
function uy(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? dl(e) : dl.ceil(e);
}
function rb(e, t) {
  return e = uy(e), Gt(dl.count(Ls(e), e) + (Ls(e).getUTCDay() === 4), t, 2);
}
function ib(e) {
  return e.getUTCDay();
}
function ab(e, t) {
  return Gt(nc.count(Ls(e) - 1, e), t, 2);
}
function ob(e, t) {
  return Gt(e.getUTCFullYear() % 100, t, 2);
}
function lb(e, t) {
  return e = uy(e), Gt(e.getUTCFullYear() % 100, t, 2);
}
function sb(e, t) {
  return Gt(e.getUTCFullYear() % 1e4, t, 4);
}
function ub(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? dl(e) : dl.ceil(e), Gt(e.getUTCFullYear() % 1e4, t, 4);
}
function cb() {
  return "+0000";
}
function yp() {
  return "%";
}
function gp(e) {
  return +e;
}
function vp(e) {
  return Math.floor(+e / 1e3);
}
var Zo, ju, cy;
db({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function db(e) {
  return Zo = dx(e), ju = Zo.format, cy = Zo.parse, Zo.utcFormat, Zo.utcParse, Zo;
}
const Ft = {
  arr: Array.isArray,
  obj: (e) => Object.prototype.toString.call(e) === "[object Object]",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0,
  nul: (e) => e === null,
  set: (e) => e instanceof Set,
  map: (e) => e instanceof Map,
  equ(e, t) {
    if (typeof e != typeof t)
      return !1;
    if (Ft.str(e) || Ft.num(e))
      return e === t;
    if (Ft.obj(e) && Ft.obj(t) && Object.keys(e).length + Object.keys(t).length === 0)
      return !0;
    let n;
    for (n in e)
      if (!(n in t))
        return !1;
    for (n in t)
      if (e[n] !== t[n])
        return !1;
    return Ft.und(n) ? e === t : !0;
  }
};
function fb(e, t) {
  return t === void 0 && (t = !0), (n) => (Ft.arr(n) ? n : Object.keys(n)).reduce((r, i) => {
    const o = t ? i[0].toLowerCase() + i.substring(1) : i;
    return r[o] = e(o), r;
  }, e);
}
function dy() {
  const e = de.useState(!1), t = e[1];
  return de.useCallback(() => t((r) => !r), []);
}
function Da(e, t) {
  return Ft.und(e) || Ft.nul(e) ? t : e;
}
function il(e) {
  return Ft.und(e) ? [] : Ft.arr(e) ? e : [e];
}
function Hr(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return Ft.fun(e) ? e(...n) : e;
}
function hb(e) {
  return e.to, e.from, e.config, e.onStart, e.onRest, e.onFrame, e.children, e.reset, e.reverse, e.force, e.immediate, e.delay, e.attach, e.destroyed, e.interpolateTo, e.ref, e.lazy, ri(e, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
}
function Xd(e) {
  const t = hb(e);
  if (Ft.und(t))
    return cn({
      to: t
    }, e);
  const n = Object.keys(e).reduce((r, i) => Ft.und(t[i]) ? cn({}, r, {
    [i]: e[i]
  }) : r, {});
  return cn({
    to: t
  }, n);
}
function pb(e, t) {
  return t && (Ft.fun(t) ? t(e) : Ft.obj(t) && (t.current = e)), e;
}
class Vr {
  constructor() {
    this.payload = void 0, this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(t) {
    this.children.length === 0 && this.attach(), this.children.push(t);
  }
  removeChild(t) {
    const n = this.children.indexOf(t);
    this.children.splice(n, 1), this.children.length === 0 && this.detach();
  }
}
class wf extends Vr {
  constructor() {
    super(...arguments), this.payload = [], this.attach = () => this.payload.forEach((t) => t instanceof Vr && t.addChild(this)), this.detach = () => this.payload.forEach((t) => t instanceof Vr && t.removeChild(this));
  }
}
class fy extends Vr {
  constructor() {
    super(...arguments), this.payload = {}, this.attach = () => Object.values(this.payload).forEach((t) => t instanceof Vr && t.addChild(this)), this.detach = () => Object.values(this.payload).forEach((t) => t instanceof Vr && t.removeChild(this));
  }
  getValue(t) {
    t === void 0 && (t = !1);
    const n = {};
    for (const r in this.payload) {
      const i = this.payload[r];
      t && !(i instanceof Vr) || (n[r] = i instanceof Vr ? i[t ? "getAnimatedValue" : "getValue"]() : i);
    }
    return n;
  }
  getAnimatedValue() {
    return this.getValue(!0);
  }
}
let ih;
function mb(e, t) {
  ih = {
    fn: e,
    transform: t
  };
}
let hy;
function yb(e) {
  hy = e;
}
let py = (e) => typeof window < "u" ? window.requestAnimationFrame(e) : -1, ic;
function gb(e) {
  ic = e;
}
let my = () => Date.now(), vb = (e) => e.current, yy;
function xb(e) {
  yy = e;
}
class bb extends fy {
  constructor(t, n) {
    super(), this.update = void 0, this.payload = t.style ? cn({}, t, {
      style: yy(t.style)
    }) : t, this.update = n, this.attach();
  }
}
const Sb = (e) => Ft.fun(e) && !(e.prototype instanceof Ve.Component), wb = (e) => de.forwardRef((n, r) => {
  const i = dy(), o = de.useRef(!0), d = de.useRef(null), c = de.useRef(null), s = de.useCallback((x) => {
    const T = d.current, y = () => {
      let A = !1;
      c.current && (A = ih.fn(c.current, d.current.getAnimatedValue())), (!c.current || A === !1) && i();
    };
    d.current = new bb(x, y), T && T.detach();
  }, []);
  de.useEffect(() => () => {
    o.current = !1, d.current && d.current.detach();
  }, []), de.useImperativeHandle(r, () => vb(c)), s(n);
  const p = d.current.getValue();
  p.scrollTop, p.scrollLeft;
  const m = ri(p, ["scrollTop", "scrollLeft"]), g = Sb(e) ? void 0 : (x) => c.current = pb(x, r);
  return Ve.createElement(e, cn({}, m, {
    ref: g
  }));
});
let gs = !1;
const Va = /* @__PURE__ */ new Set(), gy = () => {
  if (!gs)
    return !1;
  let e = my();
  for (let t of Va) {
    let n = !1;
    for (let r = 0; r < t.configs.length; r++) {
      let i = t.configs[r], o, d;
      for (let c = 0; c < i.animatedValues.length; c++) {
        let s = i.animatedValues[c];
        if (s.done)
          continue;
        let p = i.fromValues[c], m = i.toValues[c], g = s.lastPosition, x = m instanceof Vr, T = Array.isArray(i.initialVelocity) ? i.initialVelocity[c] : i.initialVelocity;
        if (x && (m = m.getValue()), i.immediate) {
          s.setValue(m), s.done = !0;
          continue;
        }
        if (typeof p == "string" || typeof m == "string") {
          s.setValue(m), s.done = !0;
          continue;
        }
        if (i.duration !== void 0)
          g = p + i.easing((e - s.startTime) / i.duration) * (m - p), o = e >= s.startTime + i.duration;
        else if (i.decay)
          g = p + T / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (e - s.startTime))), o = Math.abs(s.lastPosition - g) < 0.1, o && (m = g);
        else {
          d = s.lastTime !== void 0 ? s.lastTime : e, T = s.lastVelocity !== void 0 ? s.lastVelocity : i.initialVelocity, e > d + 64 && (d = e);
          let y = Math.floor(e - d);
          for (let E = 0; E < y; ++E) {
            let N = -i.tension * (g - m), R = -i.friction * T, L = (N + R) / i.mass;
            T = T + L * 1 / 1e3, g = g + T * 1 / 1e3;
          }
          let A = i.clamp && i.tension !== 0 ? p < m ? g > m : g < m : !1, b = Math.abs(T) <= i.precision, v = i.tension !== 0 ? Math.abs(m - g) <= i.precision : !0;
          o = A || b && v, s.lastVelocity = T, s.lastTime = e;
        }
        x && !i.toValues[c].done && (o = !1), o ? (s.value !== m && (g = m), s.done = !0) : n = !0, s.setValue(g), s.lastPosition = g;
      }
      t.props.onFrame && (t.values[i.name] = i.interpolation.getValue());
    }
    t.props.onFrame && t.props.onFrame(t.values), n || (Va.delete(t), t.stop(!0));
  }
  return Va.size ? py(gy) : gs = !1, gs;
}, kb = (e) => {
  Va.has(e) || Va.add(e), gs || (gs = !0, py(gy));
}, Tb = (e) => {
  Va.has(e) && Va.delete(e);
};
function ac(e, t, n) {
  if (typeof e == "function")
    return e;
  if (Array.isArray(e))
    return ac({
      range: e,
      output: t,
      extrapolate: n
    });
  if (ic && typeof e.output[0] == "string")
    return ic(e);
  const r = e, i = r.output, o = r.range || [0, 1], d = r.extrapolateLeft || r.extrapolate || "extend", c = r.extrapolateRight || r.extrapolate || "extend", s = r.easing || ((p) => p);
  return (p) => {
    const m = Ab(p, o);
    return Cb(p, o[m], o[m + 1], i[m], i[m + 1], s, d, c, r.map);
  };
}
function Cb(e, t, n, r, i, o, d, c, s) {
  let p = s ? s(e) : e;
  if (p < t) {
    if (d === "identity")
      return p;
    d === "clamp" && (p = t);
  }
  if (p > n) {
    if (c === "identity")
      return p;
    c === "clamp" && (p = n);
  }
  return r === i ? r : t === n ? e <= t ? r : i : (t === -1 / 0 ? p = -p : n === 1 / 0 ? p = p - t : p = (p - t) / (n - t), p = o(p), r === -1 / 0 ? p = -p : i === 1 / 0 ? p = p + r : p = p * (i - r) + r, p);
}
function Ab(e, t) {
  for (var n = 1; n < t.length - 1 && !(t[n] >= e); ++n)
    ;
  return n - 1;
}
class fl extends wf {
  constructor(t, n, r, i) {
    super(), this.calc = void 0, this.payload = t instanceof wf && !(t instanceof fl) ? t.getPayload() : Array.isArray(t) ? t : [t], this.calc = ac(n, r, i);
  }
  getValue() {
    return this.calc(...this.payload.map((t) => t.getValue()));
  }
  updateConfig(t, n, r) {
    this.calc = ac(t, n, r);
  }
  interpolate(t, n, r) {
    return new fl(this, t, n, r);
  }
}
const Lb = (e, t, n) => e && new fl(e, t, n);
function vy(e, t) {
  "update" in e ? t.add(e) : e.getChildren().forEach((n) => vy(n, t));
}
class kf extends Vr {
  constructor(t) {
    var n;
    super(), n = this, this.animatedStyles = /* @__PURE__ */ new Set(), this.value = void 0, this.startPosition = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.startTime = void 0, this.lastTime = void 0, this.done = !1, this.setValue = function(r, i) {
      i === void 0 && (i = !0), n.value = r, i && n.flush();
    }, this.value = t, this.startPosition = t, this.lastPosition = t;
  }
  flush() {
    this.animatedStyles.size === 0 && vy(this, this.animatedStyles), this.animatedStyles.forEach((t) => t.update());
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  getValue() {
    return this.value;
  }
  interpolate(t, n, r) {
    return new fl(this, t, n, r);
  }
}
class Eb extends wf {
  constructor(t) {
    super(), this.payload = t.map((n) => new kf(n));
  }
  setValue(t, n) {
    n === void 0 && (n = !0), Array.isArray(t) ? t.length === this.payload.length && t.forEach((r, i) => this.payload[i].setValue(r, n)) : this.payload.forEach((r) => r.setValue(t, n));
  }
  getValue() {
    return this.payload.map((t) => t.getValue());
  }
  interpolate(t, n) {
    return new fl(this, t, n);
  }
}
let Rb = 0;
class Nb {
  constructor() {
    this.id = void 0, this.idle = !0, this.hasChanged = !1, this.guid = 0, this.local = 0, this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.listeners = [], this.queue = [], this.localQueue = void 0, this.getValues = () => this.interpolations, this.id = Rb++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */
  update(t) {
    if (!t)
      return this;
    const n = Xd(t), r = n.delay, i = r === void 0 ? 0 : r, o = n.to, d = ri(n, ["delay", "to"]);
    if (Ft.arr(o) || Ft.fun(o))
      this.queue.push(cn({}, d, {
        delay: i,
        to: o
      }));
    else if (o) {
      let c = {};
      Object.entries(o).forEach((s) => {
        let p = s[0], m = s[1];
        const g = cn({
          to: {
            [p]: m
          },
          delay: Hr(i, p)
        }, d), x = c[g.delay] && c[g.delay].to;
        c[g.delay] = cn({}, c[g.delay], g, {
          to: cn({}, x, g.to)
        });
      }), this.queue = Object.values(c);
    }
    return this.queue = this.queue.sort((c, s) => c.delay - s.delay), this.diff(d), this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  start(t) {
    if (this.queue.length) {
      this.idle = !1, this.localQueue && this.localQueue.forEach((i) => {
        let o = i.from, d = o === void 0 ? {} : o, c = i.to, s = c === void 0 ? {} : c;
        Ft.obj(d) && (this.merged = cn({}, d, this.merged)), Ft.obj(s) && (this.merged = cn({}, this.merged, s));
      });
      const n = this.local = ++this.guid, r = this.localQueue = this.queue;
      this.queue = [], r.forEach((i, o) => {
        let d = i.delay, c = ri(i, ["delay"]);
        const s = (m) => {
          o === r.length - 1 && n === this.guid && m && (this.idle = !0, this.props.onRest && this.props.onRest(this.merged)), t && t();
        };
        let p = Ft.arr(c.to) || Ft.fun(c.to);
        d ? setTimeout(() => {
          n === this.guid && (p ? this.runAsync(c, s) : this.diff(c).start(s));
        }, d) : p ? this.runAsync(c, s) : this.diff(c).start(s);
      });
    } else
      Ft.fun(t) && this.listeners.push(t), this.props.onStart && this.props.onStart(), kb(this);
    return this;
  }
  stop(t) {
    return this.listeners.forEach((n) => n(t)), this.listeners = [], this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  pause(t) {
    return this.stop(!0), t && Tb(this), this;
  }
  runAsync(t, n) {
    var r = this;
    t.delay;
    let i = ri(t, ["delay"]);
    const o = this.local;
    let d = Promise.resolve(void 0);
    if (Ft.arr(i.to))
      for (let c = 0; c < i.to.length; c++) {
        const s = c, p = cn({}, i, Xd(i.to[s]));
        Ft.arr(p.config) && (p.config = p.config[s]), d = d.then(() => {
          if (o === this.guid)
            return new Promise((m) => this.diff(p).start(m));
        });
      }
    else if (Ft.fun(i.to)) {
      let c = 0, s;
      d = d.then(() => i.to(
        // next(props)
        (p) => {
          const m = cn({}, i, Xd(p));
          if (Ft.arr(m.config) && (m.config = m.config[c]), c++, o === this.guid)
            return s = new Promise((g) => this.diff(m).start(g));
        },
        // cancel()
        function(p) {
          return p === void 0 && (p = !0), r.stop(p);
        }
      ).then(() => s));
    }
    d.then(n);
  }
  diff(t) {
    this.props = cn({}, this.props, t);
    let n = this.props, r = n.from, i = r === void 0 ? {} : r, o = n.to, d = o === void 0 ? {} : o, c = n.config, s = c === void 0 ? {} : c, p = n.reverse, m = n.attach, g = n.reset, x = n.immediate;
    if (p) {
      var T = [d, i];
      i = T[0], d = T[1];
    }
    this.merged = cn({}, i, this.merged, d), this.hasChanged = !1;
    let y = m && m(this);
    if (this.animations = Object.entries(this.merged).reduce((A, b) => {
      let v = b[0], E = b[1], N = A[v] || {};
      const R = Ft.num(E), L = Ft.str(E) && !E.startsWith("#") && !/\d/.test(E) && !hy[E], B = Ft.arr(E), j = !R && !B && !L;
      let Z = Ft.und(i[v]) ? E : i[v], re = R || B || L ? E : 1, X = Hr(s, v);
      y && (re = y.animations[v].parent);
      let se = N.parent, Y = N.interpolation, ie = il(y ? re.getPayload() : re), I, U = E;
      j && (U = ic({
        range: [0, 1],
        output: [E, E]
      })(1));
      let ue = Y && Y.getValue();
      const J = !Ft.und(se) && N.animatedValues.some((H) => !H.done), Q = !Ft.equ(U, ue), G = !Ft.equ(U, N.previous), ne = !Ft.equ(X, N.config);
      if (g || G && Q || ne) {
        if (R || L)
          se = Y = N.parent || new kf(Z);
        else if (B)
          se = Y = N.parent || new Eb(Z);
        else if (j) {
          let H = N.interpolation && N.interpolation.calc(N.parent.value);
          H = H !== void 0 && !g ? H : Z, N.parent ? (se = N.parent, se.setValue(0, !1)) : se = new kf(0);
          const ce = {
            output: [H, E]
          };
          N.interpolation ? (Y = N.interpolation, N.interpolation.updateConfig(ce)) : Y = se.interpolate(ce);
        }
        return ie = il(y ? re.getPayload() : re), I = il(se.getPayload()), g && !j && se.setValue(Z, !1), this.hasChanged = !0, I.forEach((H) => {
          H.startPosition = H.value, H.lastPosition = H.value, H.lastVelocity = J ? H.lastVelocity : void 0, H.lastTime = J ? H.lastTime : void 0, H.startTime = my(), H.done = !1, H.animatedStyles.clear();
        }), Hr(x, v) && se.setValue(j ? re : E, !1), cn({}, A, {
          [v]: cn({}, N, {
            name: v,
            parent: se,
            interpolation: Y,
            animatedValues: I,
            toValues: ie,
            previous: U,
            config: X,
            fromValues: il(se.getValue()),
            immediate: Hr(x, v),
            initialVelocity: Da(X.velocity, 0),
            clamp: Da(X.clamp, !1),
            precision: Da(X.precision, 0.01),
            tension: Da(X.tension, 170),
            friction: Da(X.friction, 26),
            mass: Da(X.mass, 1),
            duration: X.duration,
            easing: Da(X.easing, (H) => H),
            decay: X.decay
          })
        });
      } else
        return Q ? A : (j && (se.setValue(1, !1), Y.updateConfig({
          output: [U, U]
        })), se.done = !0, this.hasChanged = !0, cn({}, A, {
          [v]: cn({}, A[v], {
            previous: U
          })
        }));
    }, this.animations), this.hasChanged) {
      this.configs = Object.values(this.animations), this.values = {}, this.interpolations = {};
      for (let A in this.animations)
        this.interpolations[A] = this.animations[A].interpolation, this.values[A] = this.animations[A].interpolation.getValue();
    }
    return this;
  }
  destroy() {
    this.stop(), this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.local = 0;
  }
}
let Pb = 0;
const Uu = "enter", qd = "leave", Zd = "update", Db = (e, t) => (typeof t == "function" ? e.map(t) : il(t)).map(String), Tf = (e) => {
  let t = e.items, n = e.keys, r = n === void 0 ? (o) => o : n, i = ri(e, ["items", "keys"]);
  return t = il(t !== void 0 ? t : null), cn({
    items: t,
    keys: Db(t, r)
  }, i);
};
function _b(e, t, n) {
  const r = cn({
    items: e,
    keys: t || ((E) => E)
  }, n), i = Tf(r), o = i.lazy, d = o === void 0 ? !1 : o;
  i.unique;
  const c = i.reset, s = c === void 0 ? !1 : c;
  i.enter, i.leave, i.update;
  const p = i.onDestroyed;
  i.keys, i.items;
  const m = i.onFrame, g = i.onRest, x = i.onStart, T = i.ref, y = ri(i, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]), A = dy(), b = de.useRef(!1), v = de.useRef({
    mounted: !1,
    first: !0,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!r.ref,
    instances: !b.current && /* @__PURE__ */ new Map(),
    forceUpdate: A
  });
  return de.useImperativeHandle(r.ref, () => ({
    start: () => Promise.all(Array.from(v.current.instances).map((E) => {
      let N = E[1];
      return new Promise((R) => N.start(R));
    })),
    stop: (E) => Array.from(v.current.instances).forEach((N) => N[1].stop(E)),
    get controllers() {
      return Array.from(v.current.instances).map((E) => E[1]);
    }
  })), v.current = Ob(v.current, r), v.current.changed && v.current.transitions.forEach((E) => {
    const N = E.slot, R = E.from, L = E.to, B = E.config, j = E.trail, Z = E.key, re = E.item;
    v.current.instances.has(Z) || v.current.instances.set(Z, new Nb());
    const X = v.current.instances.get(Z), se = cn({}, y, {
      to: L,
      from: R,
      config: B,
      ref: T,
      onRest: (Y) => {
        v.current.mounted && (E.destroyed && (!T && !d && xp(v, Z), p && p(re)), !Array.from(v.current.instances).some((U) => !U[1].idle) && (T || d) && v.current.deleted.length > 0 && xp(v), g && g(re, N, Y));
      },
      onStart: x && (() => x(re, N)),
      onFrame: m && ((Y) => m(re, N, Y)),
      delay: j,
      reset: s && N === Uu
      // Update controller
    });
    X.update(se), v.current.paused || X.start();
  }), de.useEffect(() => (v.current.mounted = b.current = !0, () => {
    v.current.mounted = b.current = !1, Array.from(v.current.instances).map((E) => E[1].destroy()), v.current.instances.clear();
  }), []), v.current.transitions.map((E) => {
    let N = E.item, R = E.slot, L = E.key;
    return {
      item: N,
      key: L,
      state: R,
      props: v.current.instances.get(L).getValues()
    };
  });
}
function xp(e, t) {
  const n = e.current.deleted;
  for (let r of n) {
    let i = r.key;
    const o = (d) => d.key !== i;
    (Ft.und(t) || t === i) && (e.current.instances.delete(i), e.current.transitions = e.current.transitions.filter(o), e.current.deleted = e.current.deleted.filter(o));
  }
  e.current.forceUpdate();
}
function Ob(e, t) {
  let n = e.first, r = e.prevProps, i = ri(e, ["first", "prevProps"]), o = Tf(t), d = o.items, c = o.keys, s = o.initial, p = o.from, m = o.enter, g = o.leave, x = o.update, T = o.trail, y = T === void 0 ? 0 : T, A = o.unique, b = o.config, v = o.order, E = v === void 0 ? [Uu, qd, Zd] : v, N = Tf(r), R = N.keys, L = N.items, B = cn({}, i.current), j = [...i.deleted], Z = Object.keys(B), re = new Set(Z), X = new Set(c), se = c.filter((ue) => !re.has(ue)), Y = i.transitions.filter((ue) => !ue.destroyed && !X.has(ue.originalKey)).map((ue) => ue.originalKey), ie = c.filter((ue) => re.has(ue)), I = -y;
  for (; E.length; )
    switch (E.shift()) {
      case Uu: {
        se.forEach((te, J) => {
          A && j.find((H) => H.originalKey === te) && (j = j.filter((H) => H.originalKey !== te));
          const Q = c.indexOf(te), G = d[Q], ne = n && s !== void 0 ? "initial" : Uu;
          B[te] = {
            slot: ne,
            originalKey: te,
            key: A ? String(te) : Pb++,
            item: G,
            trail: I = I + y,
            config: Hr(b, G, ne),
            from: Hr(n && s !== void 0 ? s || {} : p, G),
            to: Hr(m, G)
          };
        });
        break;
      }
      case qd: {
        Y.forEach((te) => {
          const J = R.indexOf(te), Q = L[J], G = qd;
          j.unshift(cn({}, B[te], {
            slot: G,
            destroyed: !0,
            left: R[Math.max(0, J - 1)],
            right: R[Math.min(R.length, J + 1)],
            trail: I = I + y,
            config: Hr(b, Q, G),
            to: Hr(g, Q)
          })), delete B[te];
        });
        break;
      }
      case Zd: {
        ie.forEach((te) => {
          const J = c.indexOf(te), Q = d[J], G = Zd;
          B[te] = cn({}, B[te], {
            item: Q,
            slot: G,
            trail: I = I + y,
            config: Hr(b, Q, G),
            to: Hr(x, Q)
          });
        });
        break;
      }
    }
  let U = c.map((ue) => B[ue]);
  return j.forEach((ue) => {
    let te = ue.left;
    ue.right;
    let J = ri(ue, ["left", "right"]), Q;
    (Q = U.findIndex((G) => G.originalKey === te)) !== -1 && (Q += 1), Q = Math.max(0, Q), U = [...U.slice(0, Q), J, ...U.slice(Q)];
  }), cn({}, i, {
    changed: se.length || Y.length || ie.length,
    first: n && se.length === 0,
    transitions: U,
    current: B,
    deleted: j,
    prevProps: t
  });
}
class Mb extends fy {
  constructor(t) {
    t === void 0 && (t = {}), super(), t.transform && !(t.transform instanceof Vr) && (t = ih.transform(t)), this.payload = t;
  }
}
const oc = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, Wr = "[-+]?\\d*\\.?\\d+", lc = Wr + "%";
function Fc() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const Fb = new RegExp("rgb" + Fc(Wr, Wr, Wr)), zb = new RegExp("rgba" + Fc(Wr, Wr, Wr, Wr)), Bb = new RegExp("hsl" + Fc(Wr, lc, lc)), Ib = new RegExp("hsla" + Fc(Wr, lc, lc, Wr)), $b = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Hb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Vb = /^#([0-9a-fA-F]{6})$/, Wb = /^#([0-9a-fA-F]{8})$/;
function jb(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = Vb.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : oc.hasOwnProperty(e) ? oc[e] : (t = Fb.exec(e)) ? (Qo(t[1]) << 24 | // r
  Qo(t[2]) << 16 | // g
  Qo(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = zb.exec(e)) ? (Qo(t[1]) << 24 | // r
  Qo(t[2]) << 16 | // g
  Qo(t[3]) << 8 | // b
  wp(t[4])) >>> // a
  0 : (t = $b.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = Wb.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = Hb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = Bb.exec(e)) ? (bp(
    Sp(t[1]),
    // h
    Du(t[2]),
    // s
    Du(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = Ib.exec(e)) ? (bp(
    Sp(t[1]),
    // h
    Du(t[2]),
    // s
    Du(t[3])
    // l
  ) | wp(t[4])) >>> // a
  0 : null;
}
function Qd(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function bp(e, t, n) {
  const r = n < 0.5 ? n * (1 + t) : n + t - n * t, i = 2 * n - r, o = Qd(i, r, e + 1 / 3), d = Qd(i, r, e), c = Qd(i, r, e - 1 / 3);
  return Math.round(o * 255) << 24 | Math.round(d * 255) << 16 | Math.round(c * 255) << 8;
}
function Qo(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function Sp(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function wp(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function Du(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function kp(e) {
  let t = jb(e);
  if (t === null)
    return e;
  t = t || 0;
  let n = (t & 4278190080) >>> 24, r = (t & 16711680) >>> 16, i = (t & 65280) >>> 8, o = (t & 255) / 255;
  return `rgba(${n}, ${r}, ${i}, ${o})`;
}
const _u = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Ub = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Kb = new RegExp(`(${Object.keys(oc).join("|")})`, "g"), Yb = (e) => {
  const t = e.output.map((i) => i.replace(Ub, kp)).map((i) => i.replace(Kb, kp)), n = t[0].match(_u).map(() => []);
  t.forEach((i) => {
    i.match(_u).forEach((o, d) => n[d].push(+o));
  });
  const r = t[0].match(_u).map((i, o) => ac(cn({}, e, {
    output: n[o]
  })));
  return (i) => {
    let o = 0;
    return t[0].replace(_u, () => r[o++](i)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (d, c, s, p, m) => `rgba(${Math.round(c)}, ${Math.round(s)}, ${Math.round(p)}, ${m})`);
  };
};
let vs = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const Gb = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), Xb = ["Webkit", "Ms", "Moz", "O"];
vs = Object.keys(vs).reduce((e, t) => (Xb.forEach((n) => e[Gb(n, t)] = e[t]), e), vs);
function qb(e, t, n) {
  return t == null || typeof t == "boolean" || t === "" ? "" : !n && typeof t == "number" && t !== 0 && !(vs.hasOwnProperty(e) && vs[e]) ? t + "px" : ("" + t).trim();
}
const Tp = {};
xb((e) => new Mb(e));
gb(Yb);
yb(oc);
mb((e, t) => {
  if (e.nodeType && e.setAttribute !== void 0) {
    const i = t.style, o = t.children, d = t.scrollTop, c = t.scrollLeft, s = ri(t, ["style", "children", "scrollTop", "scrollLeft"]), p = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter";
    d !== void 0 && (e.scrollTop = d), c !== void 0 && (e.scrollLeft = c), o !== void 0 && (e.textContent = o);
    for (let m in i)
      if (i.hasOwnProperty(m)) {
        var n = m.indexOf("--") === 0, r = qb(m, i[m], n);
        m === "float" && (m = "cssFloat"), n ? e.style.setProperty(m, r) : e.style[m] = r;
      }
    for (let m in s) {
      const g = p ? m : Tp[m] || (Tp[m] = m.replace(/([A-Z])/g, (x) => "-" + x.toLowerCase()));
      typeof e.getAttribute(g) < "u" && e.setAttribute(g, s[m]);
    }
    return;
  } else
    return !1;
}, (e) => e);
const Zb = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Qb = fb(wb, !1), Cp = Qb(Zb);
function Jb(e) {
  return e.innerRadius;
}
function e0(e) {
  return e.outerRadius;
}
function t0(e) {
  return e.startAngle;
}
function n0(e) {
  return e.endAngle;
}
function r0(e) {
  return e && e.padAngle;
}
function i0(e, t, n, r, i, o, d, c) {
  var s = n - e, p = r - t, m = d - i, g = c - o, x = g * s - m * p;
  if (!(x * x < nr))
    return x = (m * (t - o) - g * (e - i)) / x, [e + x * s, t + x * p];
}
function Ou(e, t, n, r, i, o, d) {
  var c = e - n, s = t - r, p = (d ? o : -o) / rl(c * c + s * s), m = p * s, g = -p * c, x = e + m, T = t + g, y = n + m, A = r + g, b = (x + y) / 2, v = (T + A) / 2, E = y - x, N = A - T, R = E * E + N * N, L = i - o, B = x * A - y * T, j = (N < 0 ? -1 : 1) * rl(Lg(0, L * L * R - B * B)), Z = (B * N - E * j) / R, re = (-B * E - N * j) / R, X = (B * N + E * j) / R, se = (-B * E + N * j) / R, Y = Z - b, ie = re - v, I = X - b, U = se - v;
  return Y * Y + ie * ie > I * I + U * U && (Z = X, re = se), {
    cx: Z,
    cy: re,
    x01: -m,
    y01: -g,
    x11: Z * (i / L - 1),
    y11: re * (i / L - 1)
  };
}
function a0() {
  var e = Jb, t = e0, n = Vt(0), r = null, i = t0, o = n0, d = r0, c = null;
  function s() {
    var p, m, g = +e.apply(this, arguments), x = +t.apply(this, arguments), T = i.apply(this, arguments) - Dh, y = o.apply(this, arguments) - Dh, A = _h(y - T), b = y > T;
    if (c || (c = p = Pc()), x < g && (m = x, x = g, g = m), !(x > nr))
      c.moveTo(0, 0);
    else if (A > Vu - nr)
      c.moveTo(x * Pa(T), x * Jr(T)), c.arc(0, 0, x, T, y, !b), g > nr && (c.moveTo(g * Pa(y), g * Jr(y)), c.arc(0, 0, g, y, T, b));
    else {
      var v = T, E = y, N = T, R = y, L = A, B = A, j = d.apply(this, arguments) / 2, Z = j > nr && (r ? +r.apply(this, arguments) : rl(g * g + x * x)), re = Id(_h(x - g) / 2, +n.apply(this, arguments)), X = re, se = re, Y, ie;
      if (Z > nr) {
        var I = Oh(Z / g * Jr(j)), U = Oh(Z / x * Jr(j));
        (L -= I * 2) > nr ? (I *= b ? 1 : -1, N += I, R -= I) : (L = 0, N = R = (T + y) / 2), (B -= U * 2) > nr ? (U *= b ? 1 : -1, v += U, E -= U) : (B = 0, v = E = (T + y) / 2);
      }
      var ue = x * Pa(v), te = x * Jr(v), J = g * Pa(R), Q = g * Jr(R);
      if (re > nr) {
        var G = x * Pa(E), ne = x * Jr(E), H = g * Pa(N), ce = g * Jr(N), ke;
        if (A < Ph && (ke = i0(ue, te, H, ce, G, ne, J, Q))) {
          var Se = ue - ke[0], xe = te - ke[1], De = G - ke[0], je = ne - ke[1], Ce = 1 / Jr(Ag((Se * De + xe * je) / (rl(Se * Se + xe * xe) * rl(De * De + je * je))) / 2), ye = rl(ke[0] * ke[0] + ke[1] * ke[1]);
          X = Id(re, (g - ye) / (Ce - 1)), se = Id(re, (x - ye) / (Ce + 1));
        }
      }
      B > nr ? se > nr ? (Y = Ou(H, ce, ue, te, x, se, b), ie = Ou(G, ne, J, Q, x, se, b), c.moveTo(Y.cx + Y.x01, Y.cy + Y.y01), se < re ? c.arc(Y.cx, Y.cy, se, Jn(Y.y01, Y.x01), Jn(ie.y01, ie.x01), !b) : (c.arc(Y.cx, Y.cy, se, Jn(Y.y01, Y.x01), Jn(Y.y11, Y.x11), !b), c.arc(0, 0, x, Jn(Y.cy + Y.y11, Y.cx + Y.x11), Jn(ie.cy + ie.y11, ie.cx + ie.x11), !b), c.arc(ie.cx, ie.cy, se, Jn(ie.y11, ie.x11), Jn(ie.y01, ie.x01), !b))) : (c.moveTo(ue, te), c.arc(0, 0, x, v, E, !b)) : c.moveTo(ue, te), !(g > nr) || !(L > nr) ? c.lineTo(J, Q) : X > nr ? (Y = Ou(J, Q, G, ne, g, -X, b), ie = Ou(ue, te, H, ce, g, -X, b), c.lineTo(Y.cx + Y.x01, Y.cy + Y.y01), X < re ? c.arc(Y.cx, Y.cy, X, Jn(Y.y01, Y.x01), Jn(ie.y01, ie.x01), !b) : (c.arc(Y.cx, Y.cy, X, Jn(Y.y01, Y.x01), Jn(Y.y11, Y.x11), !b), c.arc(0, 0, g, Jn(Y.cy + Y.y11, Y.cx + Y.x11), Jn(ie.cy + ie.y11, ie.cx + ie.x11), b), c.arc(ie.cx, ie.cy, X, Jn(ie.y11, ie.x11), Jn(ie.y01, ie.x01), !b))) : c.arc(0, 0, g, R, N, b);
    }
    if (c.closePath(), p)
      return c = null, p + "" || null;
  }
  return s.centroid = function() {
    var p = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, m = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Ph / 2;
    return [Pa(m) * p, Jr(m) * p];
  }, s.innerRadius = function(p) {
    return arguments.length ? (e = typeof p == "function" ? p : Vt(+p), s) : e;
  }, s.outerRadius = function(p) {
    return arguments.length ? (t = typeof p == "function" ? p : Vt(+p), s) : t;
  }, s.cornerRadius = function(p) {
    return arguments.length ? (n = typeof p == "function" ? p : Vt(+p), s) : n;
  }, s.padRadius = function(p) {
    return arguments.length ? (r = p == null ? null : typeof p == "function" ? p : Vt(+p), s) : r;
  }, s.startAngle = function(p) {
    return arguments.length ? (i = typeof p == "function" ? p : Vt(+p), s) : i;
  }, s.endAngle = function(p) {
    return arguments.length ? (o = typeof p == "function" ? p : Vt(+p), s) : o;
  }, s.padAngle = function(p) {
    return arguments.length ? (d = typeof p == "function" ? p : Vt(+p), s) : d;
  }, s.context = function(p) {
    return arguments.length ? (c = p ?? null, s) : c;
  }, s;
}
function xy(e) {
  this._context = e;
}
xy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function zc(e) {
  return new xy(e);
}
function ah(e) {
  return e[0];
}
function oh(e) {
  return e[1];
}
function by() {
  var e = ah, t = oh, n = Vt(!0), r = null, i = zc, o = null;
  function d(c) {
    var s, p = c.length, m, g = !1, x;
    for (r == null && (o = i(x = Pc())), s = 0; s <= p; ++s)
      !(s < p && n(m = c[s], s, c)) === g && ((g = !g) ? o.lineStart() : o.lineEnd()), g && o.point(+e(m, s, c), +t(m, s, c));
    if (x)
      return o = null, x + "" || null;
  }
  return d.x = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : Vt(+c), d) : e;
  }, d.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : Vt(+c), d) : t;
  }, d.defined = function(c) {
    return arguments.length ? (n = typeof c == "function" ? c : Vt(!!c), d) : n;
  }, d.curve = function(c) {
    return arguments.length ? (i = c, r != null && (o = i(r)), d) : i;
  }, d.context = function(c) {
    return arguments.length ? (c == null ? r = o = null : o = i(r = c), d) : r;
  }, d;
}
function o0() {
  var e = ah, t = null, n = Vt(0), r = oh, i = Vt(!0), o = null, d = zc, c = null;
  function s(m) {
    var g, x, T, y = m.length, A, b = !1, v, E = new Array(y), N = new Array(y);
    for (o == null && (c = d(v = Pc())), g = 0; g <= y; ++g) {
      if (!(g < y && i(A = m[g], g, m)) === b)
        if (b = !b)
          x = g, c.areaStart(), c.lineStart();
        else {
          for (c.lineEnd(), c.lineStart(), T = g - 1; T >= x; --T)
            c.point(E[T], N[T]);
          c.lineEnd(), c.areaEnd();
        }
      b && (E[g] = +e(A, g, m), N[g] = +n(A, g, m), c.point(t ? +t(A, g, m) : E[g], r ? +r(A, g, m) : N[g]));
    }
    if (v)
      return c = null, v + "" || null;
  }
  function p() {
    return by().defined(i).curve(d).context(o);
  }
  return s.x = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Vt(+m), t = null, s) : e;
  }, s.x0 = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Vt(+m), s) : e;
  }, s.x1 = function(m) {
    return arguments.length ? (t = m == null ? null : typeof m == "function" ? m : Vt(+m), s) : t;
  }, s.y = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Vt(+m), r = null, s) : n;
  }, s.y0 = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Vt(+m), s) : n;
  }, s.y1 = function(m) {
    return arguments.length ? (r = m == null ? null : typeof m == "function" ? m : Vt(+m), s) : r;
  }, s.lineX0 = s.lineY0 = function() {
    return p().x(e).y(n);
  }, s.lineY1 = function() {
    return p().x(e).y(r);
  }, s.lineX1 = function() {
    return p().x(t).y(n);
  }, s.defined = function(m) {
    return arguments.length ? (i = typeof m == "function" ? m : Vt(!!m), s) : i;
  }, s.curve = function(m) {
    return arguments.length ? (d = m, o != null && (c = d(o)), s) : d;
  }, s.context = function(m) {
    return arguments.length ? (m == null ? o = c = null : c = d(o = m), s) : o;
  }, s;
}
function l0(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function s0(e) {
  return e;
}
function u0() {
  var e = s0, t = l0, n = null, r = Vt(0), i = Vt(Vu), o = Vt(0);
  function d(c) {
    var s, p = c.length, m, g, x = 0, T = new Array(p), y = new Array(p), A = +r.apply(this, arguments), b = Math.min(Vu, Math.max(-Vu, i.apply(this, arguments) - A)), v, E = Math.min(Math.abs(b) / p, o.apply(this, arguments)), N = E * (b < 0 ? -1 : 1), R;
    for (s = 0; s < p; ++s)
      (R = y[T[s] = s] = +e(c[s], s, c)) > 0 && (x += R);
    for (t != null ? T.sort(function(L, B) {
      return t(y[L], y[B]);
    }) : n != null && T.sort(function(L, B) {
      return n(c[L], c[B]);
    }), s = 0, g = x ? (b - p * N) / x : 0; s < p; ++s, A = v)
      m = T[s], R = y[m], v = A + (R > 0 ? R * g : 0) + N, y[m] = {
        data: c[m],
        index: s,
        value: R,
        startAngle: A,
        endAngle: v,
        padAngle: E
      };
    return y;
  }
  return d.value = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : Vt(+c), d) : e;
  }, d.sortValues = function(c) {
    return arguments.length ? (t = c, n = null, d) : t;
  }, d.sort = function(c) {
    return arguments.length ? (n = c, t = null, d) : n;
  }, d.startAngle = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : Vt(+c), d) : r;
  }, d.endAngle = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : Vt(+c), d) : i;
  }, d.padAngle = function(c) {
    return arguments.length ? (o = typeof c == "function" ? c : Vt(+c), d) : o;
  }, d;
}
var Cf = Array.prototype.slice;
function c0(e) {
  return e.source;
}
function d0(e) {
  return e.target;
}
function f0(e) {
  var t = c0, n = d0, r = ah, i = oh, o = null;
  function d() {
    var c, s = Cf.call(arguments), p = t.apply(this, s), m = n.apply(this, s);
    if (o || (o = c = Pc()), e(o, +r.apply(this, (s[0] = p, s)), +i.apply(this, s), +r.apply(this, (s[0] = m, s)), +i.apply(this, s)), c)
      return o = null, c + "" || null;
  }
  return d.source = function(c) {
    return arguments.length ? (t = c, d) : t;
  }, d.target = function(c) {
    return arguments.length ? (n = c, d) : n;
  }, d.x = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : Vt(+c), d) : r;
  }, d.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : Vt(+c), d) : i;
  }, d.context = function(c) {
    return arguments.length ? (o = c ?? null, d) : o;
  }, d;
}
function h0(e, t, n, r, i) {
  e.moveTo(t, n), e.bezierCurveTo(t = (t + r) / 2, n, t, i, r, i);
}
function p0() {
  return f0(h0);
}
const m0 = {
  draw: function(e, t) {
    var n = Math.sqrt(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
};
function qi() {
}
function sc(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function Bc(e) {
  this._context = e;
}
Bc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        sc(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        sc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function y0(e) {
  return new Bc(e);
}
function Sy(e) {
  this._context = e;
}
Sy.prototype = {
  areaStart: qi,
  areaEnd: qi,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        sc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function g0(e) {
  return new Sy(e);
}
function wy(e) {
  this._context = e;
}
wy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      default:
        sc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function v0(e) {
  return new wy(e);
}
function ky(e, t) {
  this._basis = new Bc(e), this._beta = t;
}
ky.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var r = e[0], i = t[0], o = e[n] - r, d = t[n] - i, c = -1, s; ++c <= n; )
        s = c / n, this._basis.point(
          this._beta * e[c] + (1 - this._beta) * (r + s * o),
          this._beta * t[c] + (1 - this._beta) * (i + s * d)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const x0 = function e(t) {
  function n(r) {
    return t === 1 ? new Bc(r) : new ky(r, t);
  }
  return n.beta = function(r) {
    return e(+r);
  }, n;
}(0.85);
function uc(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function lh(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
lh.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        uc(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        uc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const b0 = function e(t) {
  function n(r) {
    return new lh(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function sh(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
sh.prototype = {
  areaStart: qi,
  areaEnd: qi,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        uc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const S0 = function e(t) {
  function n(r) {
    return new sh(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function uh(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
uh.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        uc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const w0 = function e(t) {
  function n(r) {
    return new uh(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function ch(e, t, n) {
  var r = e._x1, i = e._y1, o = e._x2, d = e._y2;
  if (e._l01_a > nr) {
    var c = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, s = 3 * e._l01_a * (e._l01_a + e._l12_a);
    r = (r * c - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / s, i = (i * c - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / s;
  }
  if (e._l23_a > nr) {
    var p = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, m = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * p + e._x1 * e._l23_2a - t * e._l12_2a) / m, d = (d * p + e._y1 * e._l23_2a - n * e._l12_2a) / m;
  }
  e._context.bezierCurveTo(r, i, o, d, e._x2, e._y2);
}
function Ty(e, t) {
  this._context = e, this._alpha = t;
}
Ty.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        ch(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const k0 = function e(t) {
  function n(r) {
    return t ? new Ty(r, t) : new lh(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Cy(e, t) {
  this._context = e, this._alpha = t;
}
Cy.prototype = {
  areaStart: qi,
  areaEnd: qi,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        ch(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const T0 = function e(t) {
  function n(r) {
    return t ? new Cy(r, t) : new sh(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Ay(e, t) {
  this._context = e, this._alpha = t;
}
Ay.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        ch(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const C0 = function e(t) {
  function n(r) {
    return t ? new Ay(r, t) : new uh(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Ly(e) {
  this._context = e;
}
Ly.prototype = {
  areaStart: qi,
  areaEnd: qi,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function Af(e) {
  return new Ly(e);
}
function Ap(e) {
  return e < 0 ? -1 : 1;
}
function Lp(e, t, n) {
  var r = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (r || i < 0 && -0), d = (n - e._y1) / (i || r < 0 && -0), c = (o * i + d * r) / (r + i);
  return (Ap(o) + Ap(d)) * Math.min(Math.abs(o), Math.abs(d), 0.5 * Math.abs(c)) || 0;
}
function Ep(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function Jd(e, t, n) {
  var r = e._x0, i = e._y0, o = e._x1, d = e._y1, c = (o - r) / 3;
  e._context.bezierCurveTo(r + c, i + c * t, o - c, d - c * n, o, d);
}
function cc(e) {
  this._context = e;
}
cc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Jd(this, this._t0, Ep(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Jd(this, Ep(this, n = Lp(this, e, t)), n);
          break;
        default:
          Jd(this, this._t0, n = Lp(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function Ey(e) {
  this._context = new Ry(e);
}
(Ey.prototype = Object.create(cc.prototype)).point = function(e, t) {
  cc.prototype.point.call(this, t, e);
};
function Ry(e) {
  this._context = e;
}
Ry.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, i, o) {
    this._context.bezierCurveTo(t, e, r, n, o, i);
  }
};
function Ku(e) {
  return new cc(e);
}
function A0(e) {
  return new Ey(e);
}
function Ny(e) {
  this._context = e;
}
Ny.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = Rp(e), i = Rp(t), o = 0, d = 1; d < n; ++o, ++d)
          this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], e[d], t[d]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Rp(e) {
  var t, n = e.length - 1, r, i = new Array(n), o = new Array(n), d = new Array(n);
  for (i[0] = 0, o[0] = 2, d[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    i[t] = 1, o[t] = 4, d[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, o[n - 1] = 7, d[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    r = i[t] / o[t - 1], o[t] -= r, d[t] -= r * d[t - 1];
  for (i[n - 1] = d[n - 1] / o[n - 1], t = n - 2; t >= 0; --t)
    i[t] = (d[t] - i[t + 1]) / o[t];
  for (o[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)
    o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function L0(e) {
  return new Ny(e);
}
function Ic(e, t) {
  this._context = e, this._t = t;
}
Ic.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function E0(e) {
  return new Ic(e, 0.5);
}
function R0(e) {
  return new Ic(e, 0);
}
function N0(e) {
  return new Ic(e, 1);
}
function hl(e, t) {
  if ((d = e.length) > 1)
    for (var n = 1, r, i, o = e[t[0]], d, c = o.length; n < d; ++n)
      for (i = o, o = e[t[n]], r = 0; r < c; ++r)
        o[r][1] += o[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1];
}
function pl(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; )
    n[t] = t;
  return n;
}
function P0(e, t) {
  return e[t];
}
function dh() {
  var e = Vt([]), t = pl, n = hl, r = P0;
  function i(o) {
    var d = e.apply(this, arguments), c, s = o.length, p = d.length, m = new Array(p), g;
    for (c = 0; c < p; ++c) {
      for (var x = d[c], T = m[c] = new Array(s), y = 0, A; y < s; ++y)
        T[y] = A = [0, +r(o[y], x, y, o)], A.data = o[y];
      T.key = x;
    }
    for (c = 0, g = t(m); c < p; ++c)
      m[g[c]].index = c;
    return n(m, g), m;
  }
  return i.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Vt(Cf.call(o)), i) : e;
  }, i.value = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : Vt(+o), i) : r;
  }, i.order = function(o) {
    return arguments.length ? (t = o == null ? pl : typeof o == "function" ? o : Vt(Cf.call(o)), i) : t;
  }, i.offset = function(o) {
    return arguments.length ? (n = o ?? hl, i) : n;
  }, i;
}
function D0(e, t) {
  if ((r = e.length) > 0) {
    for (var n, r, i = 0, o = e[0].length, d; i < o; ++i) {
      for (d = n = 0; n < r; ++n)
        d += e[n][i][1] || 0;
      if (d)
        for (n = 0; n < r; ++n)
          e[n][i][1] /= d;
    }
    hl(e, t);
  }
}
function _0(e, t) {
  if ((s = e.length) > 0)
    for (var n, r = 0, i, o, d, c, s, p = e[t[0]].length; r < p; ++r)
      for (d = c = 0, n = 0; n < s; ++n)
        (o = (i = e[t[n]][r])[1] - i[0]) > 0 ? (i[0] = d, i[1] = d += o) : o < 0 ? (i[1] = c, i[0] = c += o) : (i[0] = 0, i[1] = o);
}
function O0(e, t) {
  if ((i = e.length) > 0) {
    for (var n = 0, r = e[t[0]], i, o = r.length; n < o; ++n) {
      for (var d = 0, c = 0; d < i; ++d)
        c += e[d][n][1] || 0;
      r[n][1] += r[n][0] = -c / 2;
    }
    hl(e, t);
  }
}
function M0(e, t) {
  if (!(!((d = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var n = 0, r = 1, i, o, d; r < o; ++r) {
      for (var c = 0, s = 0, p = 0; c < d; ++c) {
        for (var m = e[t[c]], g = m[r][1] || 0, x = m[r - 1][1] || 0, T = (g - x) / 2, y = 0; y < c; ++y) {
          var A = e[t[y]], b = A[r][1] || 0, v = A[r - 1][1] || 0;
          T += b - v;
        }
        s += g, p += T * g;
      }
      i[r - 1][1] += i[r - 1][0] = n, s && (n -= p / s);
    }
    i[r - 1][1] += i[r - 1][0] = n, hl(e, t);
  }
}
function F0(e) {
  var t = e.map(z0);
  return pl(e).sort(function(n, r) {
    return t[n] - t[r];
  });
}
function z0(e) {
  for (var t = -1, n = 0, r = e.length, i, o = -1 / 0; ++t < r; )
    (i = +e[t][1]) > o && (o = i, n = t);
  return n;
}
function Py(e) {
  var t = e.map(Dy);
  return pl(e).sort(function(n, r) {
    return t[n] - t[r];
  });
}
function Dy(e) {
  for (var t = 0, n = -1, r = e.length, i; ++n < r; )
    (i = +e[n][1]) && (t += i);
  return t;
}
function B0(e) {
  return Py(e).reverse();
}
function I0(e) {
  var t = e.length, n, r, i = e.map(Dy), o = F0(e), d = 0, c = 0, s = [], p = [];
  for (n = 0; n < t; ++n)
    r = o[n], d < c ? (d += i[r], s.push(r)) : (c += i[r], p.push(r));
  return p.reverse().concat(s);
}
function $0(e) {
  return pl(e).reverse();
}
function vn(e, t) {
  e(t);
}
var Np = {
  ascending: Py,
  descending: B0,
  insideout: I0,
  none: pl,
  reverse: $0
};
function fh(e) {
  return e && Np[e] || Np.none;
}
var Pp = {
  expand: D0,
  diverging: _0,
  none: hl,
  silhouette: O0,
  wiggle: M0
};
function hh(e) {
  return e && Pp[e] || Pp.none;
}
function H0(e) {
  var t = e === void 0 ? {} : e, n = t.innerRadius, r = t.outerRadius, i = t.cornerRadius, o = t.startAngle, d = t.endAngle, c = t.padAngle, s = t.padRadius, p = a0();
  return n != null && vn(p.innerRadius, n), r != null && vn(p.outerRadius, r), i != null && vn(p.cornerRadius, i), o != null && vn(p.startAngle, o), d != null && vn(p.endAngle, d), c != null && vn(p.padAngle, c), s != null && vn(p.padRadius, s), p;
}
function ph(e) {
  var t = e === void 0 ? {} : e, n = t.x, r = t.x0, i = t.x1, o = t.y, d = t.y0, c = t.y1, s = t.defined, p = t.curve, m = o0();
  return n && vn(m.x, n), r && vn(m.x0, r), i && vn(m.x1, i), o && vn(m.y, o), d && vn(m.y0, d), c && vn(m.y1, c), s && m.defined(s), p && m.curve(p), m;
}
function _y(e) {
  var t = e === void 0 ? {} : e, n = t.x, r = t.y, i = t.defined, o = t.curve, d = by();
  return n && vn(d.x, n), r && vn(d.y, r), i && d.defined(i), o && d.curve(o), d;
}
function V0(e) {
  var t = e === void 0 ? {} : e, n = t.startAngle, r = t.endAngle, i = t.padAngle, o = t.value, d = t.sort, c = t.sortValues, s = u0();
  return (d === null || d != null) && s.sort(d), (c === null || c != null) && s.sortValues(c), o != null && s.value(o), i != null && vn(s.padAngle, i), n != null && vn(s.startAngle, n), r != null && vn(s.endAngle, r), s;
}
function W0(e) {
  var t = e.keys, n = e.value, r = e.order, i = e.offset, o = dh();
  return t && o.keys(t), n && vn(o.value, n), r && o.order(fh(r)), i && o.offset(hh(i)), o;
}
var j0 = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function Lf() {
  return Lf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Lf.apply(this, arguments);
}
function U0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function K0(e) {
  var t = e.className, n = e.top, r = e.left, i = e.data, o = i === void 0 ? [] : i, d = e.centroid, c = e.innerRadius, s = c === void 0 ? 0 : c, p = e.outerRadius, m = e.cornerRadius, g = e.startAngle, x = e.endAngle, T = e.padAngle, y = e.padRadius, A = e.pieSort, b = e.pieSortValues, v = e.pieValue, E = e.children, N = e.fill, R = N === void 0 ? "" : N, L = U0(e, j0), B = H0({
    innerRadius: s,
    outerRadius: p,
    cornerRadius: m,
    padRadius: y
  }), j = V0({
    startAngle: g,
    endAngle: x,
    padAngle: T,
    value: v,
    sort: A,
    sortValues: b
  }), Z = j(o);
  return E ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, E({
    arcs: Z,
    path: B,
    pie: j
  })) : /* @__PURE__ */ Ve.createElement(it, {
    className: "visx-pie-arcs-group",
    top: n,
    left: r
  }, Z.map(function(re, X) {
    return /* @__PURE__ */ Ve.createElement("g", {
      key: "pie-arc-" + X
    }, /* @__PURE__ */ Ve.createElement("path", Lf({
      className: Cn("visx-pie-arc", t),
      d: B(re) || "",
      fill: R == null || typeof R == "string" ? R : R(re)
    }, L)), d == null ? void 0 : d(B.centroid(re), re));
  }));
}
var Y0 = ["from", "to", "fill", "className", "innerRef"];
function Ef() {
  return Ef = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ef.apply(this, arguments);
}
function G0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function rn(e) {
  var t = e.from, n = t === void 0 ? {
    x: 0,
    y: 0
  } : t, r = e.to, i = r === void 0 ? {
    x: 1,
    y: 1
  } : r, o = e.fill, d = o === void 0 ? "transparent" : o, c = e.className, s = e.innerRef, p = G0(e, Y0), m = n.x === i.x || n.y === i.y;
  return /* @__PURE__ */ Ve.createElement("line", Ef({
    ref: s,
    className: Cn("visx-line", c),
    x1: n.x,
    y1: n.y,
    x2: i.x,
    y2: i.y,
    fill: d,
    shapeRendering: m ? "crispEdges" : "auto"
  }, p));
}
var X0 = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function Rf() {
  return Rf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Rf.apply(this, arguments);
}
function q0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function jr(e) {
  var t = e.children, n = e.data, r = n === void 0 ? [] : n, i = e.x, o = e.y, d = e.fill, c = d === void 0 ? "transparent" : d, s = e.className, p = e.curve, m = e.innerRef, g = e.defined, x = g === void 0 ? function() {
    return !0;
  } : g, T = q0(e, X0), y = _y({
    x: i,
    y: o,
    defined: x,
    curve: p
  });
  return t ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, t({
    path: y
  })) : /* @__PURE__ */ Ve.createElement("path", Rf({
    ref: m,
    className: Cn("visx-linepath", s),
    d: y(r) || "",
    fill: c,
    strokeLinecap: "round"
  }, T));
}
var Z0 = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function Nf() {
  return Nf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Nf.apply(this, arguments);
}
function Q0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function J0(e) {
  var t = e.children, n = e.x, r = e.x0, i = e.x1, o = e.y, d = e.y0, c = e.y1, s = e.data, p = s === void 0 ? [] : s, m = e.defined, g = m === void 0 ? function() {
    return !0;
  } : m, x = e.className, T = e.curve, y = e.innerRef, A = Q0(e, Z0), b = ph({
    x: n,
    x0: r,
    x1: i,
    y: o,
    y0: d,
    y1: c,
    defined: g,
    curve: T
  });
  return t ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, t({
    path: b
  })) : /* @__PURE__ */ Ve.createElement("path", Nf({
    ref: y,
    className: Cn("visx-area", x),
    d: b(p) || ""
  }, A));
}
var eS = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function Pf() {
  return Pf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Pf.apply(this, arguments);
}
function tS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Df(e) {
  var t = e.x, n = e.x0, r = e.x1, i = e.y, o = e.y1, d = e.y0, c = e.yScale, s = e.data, p = s === void 0 ? [] : s, m = e.defined, g = m === void 0 ? function() {
    return !0;
  } : m, x = e.className, T = e.curve, y = e.innerRef, A = e.children, b = tS(e, eS), v = ph({
    x: t,
    x0: n,
    x1: r,
    defined: g,
    curve: T
  });
  return d == null ? v.y0(c.range()[0]) : vn(v.y0, d), i && !o && vn(v.y1, i), o && !i && vn(v.y1, o), A ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, A({
    path: v
  })) : /* @__PURE__ */ Ve.createElement("path", Pf({
    ref: y,
    className: Cn("visx-area-closed", x),
    d: v(p) || ""
  }, b));
}
var nS = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function _f() {
  return _f = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, _f.apply(this, arguments);
}
function rS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function iS(e) {
  var t = e.className, n = e.top, r = e.left, i = e.keys, o = e.data, d = e.curve, c = e.defined, s = e.x, p = e.x0, m = e.x1, g = e.y0, x = e.y1, T = e.value, y = e.order, A = e.offset, b = e.color, v = e.children, E = rS(e, nS), N = W0({
    keys: i,
    value: T,
    order: y,
    offset: A
  }), R = ph({
    x: s,
    x0: p,
    x1: m,
    y0: g,
    y1: x,
    curve: d,
    defined: c
  }), L = N(o);
  return v ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, v({
    stacks: L,
    path: R,
    stack: N
  })) : /* @__PURE__ */ Ve.createElement(it, {
    top: n,
    left: r
  }, L.map(function(B, j) {
    return /* @__PURE__ */ Ve.createElement("path", _f({
      className: Cn("visx-stack", t),
      key: "stack-" + j + "-" + (B.key || ""),
      d: R(B) || "",
      fill: b == null ? void 0 : b(B.key, j)
    }, E));
  }));
}
var aS = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function dc() {
  return dc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, dc.apply(this, arguments);
}
function oS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function lS(e) {
  var t = e.className, n = e.top, r = e.left, i = e.keys, o = e.data, d = e.curve, c = e.defined, s = e.x, p = e.x0, m = e.x1, g = e.y0, x = e.y1, T = e.value, y = e.order, A = e.offset, b = e.color, v = e.children, E = oS(e, aS);
  return /* @__PURE__ */ Ve.createElement(iS, dc({
    className: t,
    top: n,
    left: r,
    keys: i,
    data: o,
    curve: d,
    defined: c,
    x: s,
    x0: p,
    x1: m,
    y0: g,
    y1: x,
    value: T,
    order: y,
    offset: A,
    color: b
  }, E), v || function(N) {
    var R = N.stacks, L = N.path;
    return R.map(function(B, j) {
      return /* @__PURE__ */ Ve.createElement("path", dc({
        className: Cn("visx-area-stack", t),
        key: "area-stack-" + j + "-" + (B.key || ""),
        d: L(B) || "",
        fill: b == null ? void 0 : b(B.key, j)
      }, E));
    });
  });
}
function mh(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), n = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / n.length;
}
var sS = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function Of() {
  return Of = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Of.apply(this, arguments);
}
function uS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Oy(e) {
  var t = e.data, n = e.className, r = e.top, i = e.left, o = e.x0, d = e.x0Scale, c = e.x1Scale, s = e.yScale, p = e.color, m = e.keys, g = e.height, x = e.children, T = uS(e, sS), y = mh(c), A = t.map(function(b, v) {
    return {
      index: v,
      x0: d(o(b)),
      bars: m.map(function(E, N) {
        var R = b[E];
        return {
          index: N,
          key: E,
          value: R,
          width: y,
          x: c(E) || 0,
          y: s(R) || 0,
          color: p(E, N),
          height: g - (s(R) || 0)
        };
      })
    };
  });
  return x ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, x(A)) : /* @__PURE__ */ Ve.createElement(it, {
    className: Cn("visx-bar-group", n),
    top: r,
    left: i
  }, A.map(function(b) {
    return /* @__PURE__ */ Ve.createElement(it, {
      key: "bar-group-" + b.index + "-" + b.x0,
      left: b.x0
    }, b.bars.map(function(v) {
      return /* @__PURE__ */ Ve.createElement(_r, Of({
        key: "bar-group-bar-" + b.index + "-" + v.index + "-" + v.value + "-" + v.key,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height,
        fill: v.color
      }, T));
    }));
  }));
}
function My(e) {
  return e == null ? void 0 : e[0];
}
function Fy(e) {
  return e == null ? void 0 : e[1];
}
var cS = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function Mf() {
  return Mf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Mf.apply(this, arguments);
}
function dS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function zy(e) {
  var t = e.data, n = e.className, r = e.top, i = e.left, o = e.x, d = e.y0, c = d === void 0 ? My : d, s = e.y1, p = s === void 0 ? Fy : s, m = e.xScale, g = e.yScale, x = e.color, T = e.keys, y = e.value, A = e.order, b = e.offset, v = e.children, E = dS(e, cS), N = dh();
  T && N.keys(T), y && vn(N.value, y), A && N.order(fh(A)), b && N.offset(hh(b));
  var R = N(t), L = mh(m), B = R.map(function(j, Z) {
    var re = j.key;
    return {
      index: Z,
      key: re,
      bars: j.map(function(X, se) {
        var Y = (g(c(X)) || 0) - (g(p(X)) || 0), ie = g(p(X)), I = "bandwidth" in m ? m(o(X.data)) : Math.max((m(o(X.data)) || 0) - L / 2);
        return {
          bar: X,
          key: re,
          index: se,
          height: Y,
          width: L,
          x: I || 0,
          y: ie || 0,
          color: x(j.key, se)
        };
      })
    };
  });
  return v ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, v(B)) : /* @__PURE__ */ Ve.createElement(it, {
    className: Cn("visx-bar-stack", n),
    top: r,
    left: i
  }, B.map(function(j) {
    return j.bars.map(function(Z) {
      return /* @__PURE__ */ Ve.createElement(_r, Mf({
        key: "bar-stack-" + j.index + "-" + Z.index,
        x: Z.x,
        y: Z.y,
        height: Z.height,
        width: Z.width,
        fill: Z.color
      }, E));
    });
  }));
}
var fS = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function Ff() {
  return Ff = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ff.apply(this, arguments);
}
function hS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function pS(e) {
  var t = e.data, n = e.className, r = e.top, i = e.left, o = e.y, d = e.x0, c = d === void 0 ? My : d, s = e.x1, p = s === void 0 ? Fy : s, m = e.xScale, g = e.yScale, x = e.color, T = e.keys, y = e.value, A = e.order, b = e.offset, v = e.children, E = hS(e, fS), N = dh();
  T && N.keys(T), y && vn(N.value, y), A && N.order(fh(A)), b && N.offset(hh(b));
  var R = N(t), L = mh(g), B = R.map(function(j, Z) {
    var re = j.key;
    return {
      index: Z,
      key: re,
      bars: j.map(function(X, se) {
        var Y = (m(p(X)) || 0) - (m(c(X)) || 0), ie = m(c(X)), I = "bandwidth" in g ? g(o(X.data)) : Math.max((g(o(X.data)) || 0) - Y / 2);
        return {
          bar: X,
          key: re,
          index: se,
          height: L,
          width: Y,
          x: ie || 0,
          y: I || 0,
          color: x(j.key, se)
        };
      })
    };
  });
  return v ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, v(B)) : /* @__PURE__ */ Ve.createElement(it, {
    className: Cn("visx-bar-stack-horizontal", n),
    top: r,
    left: i
  }, B.map(function(j) {
    return j.bars.map(function(Z) {
      return /* @__PURE__ */ Ve.createElement(_r, Ff({
        key: "bar-stack-" + j.index + "-" + Z.index,
        x: Z.x,
        y: Z.y,
        height: Z.height,
        width: Z.width,
        fill: Z.color
      }, E));
    });
  }));
}
var Dp = "http://www.w3.org/2000/svg";
function mS(e) {
  var t = document.getElementById(e);
  if (!t) {
    var n = document.createElementNS(Dp, "svg");
    n.setAttribute("aria-hidden", "true"), n.style.opacity = "0", n.style.width = "0", n.style.height = "0", n.style.position = "absolute", n.style.top = "-100%", n.style.left = "-100%", n.style.pointerEvents = "none", t = document.createElementNS(Dp, "path"), t.setAttribute("id", e), n.appendChild(t), document.body.appendChild(n);
  }
  return t;
}
var yS = "__visx_splitpath_svg_path_measurement_id", _p = function() {
  return !0;
};
function gS(e) {
  var t = e.path, n = e.pointsInSegments, r = e.segmentation, i = r === void 0 ? "x" : r, o = e.sampleRate, d = o === void 0 ? 1 : o;
  try {
    var c = mS(yS);
    c.setAttribute("d", t);
    var s = c.getTotalLength(), p = n.length, m = n.map(function() {
      return [];
    });
    if (i === "x" || i === "y")
      for (var g = n.map(function(ie) {
        var I;
        return (I = ie.find(function(U) {
          return typeof U[i] == "number";
        })) == null ? void 0 : I[i];
      }), x = c.getPointAtLength(0), T = c.getPointAtLength(s), y = T[i] > x[i], A = y ? g.map(function(ie) {
        return typeof ie > "u" ? _p : function(I) {
          return I >= ie;
        };
      }) : g.map(function(ie) {
        return typeof ie > "u" ? _p : function(I) {
          return I <= ie;
        };
      }), b = 0, v = 0; v <= s; v += d) {
        for (var E = c.getPointAtLength(v), N = E[i]; b < p - 1 && A[b + 1](N); )
          b += 1;
        m[b].push(E);
      }
    else {
      var R = n.map(function(ie) {
        return ie.length;
      }), L = R.reduce(function(ie, I) {
        return ie + I;
      }, 0), B = s / Math.max(1, L - 1), j = R.slice(0, p - 1);
      j.unshift(0);
      for (var Z = 2; Z < p; Z += 1)
        j[Z] += j[Z - 1];
      for (var re = 0; re < p; re += 1)
        j[re] *= B;
      for (var X = 0, se = 0; se <= s; se += d) {
        for (var Y = c.getPointAtLength(se); X < p - 1 && se >= j[X + 1]; )
          X += 1;
        m[X].push(Y);
      }
    }
    return m;
  } catch {
    return [];
  }
}
function zf() {
  return zf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, zf.apply(this, arguments);
}
var vS = function(t) {
  return t.x || 0;
}, xS = function(t) {
  return t.y || 0;
};
function By(e) {
  var t = e.children, n = e.className, r = e.curve, i = e.defined, o = e.segmentation, d = e.sampleRate, c = e.segments, s = e.x, p = e.y, m = e.styles, g = de.useMemo(function() {
    var y = typeof s == "number" || typeof s > "u" ? function() {
      return s;
    } : s, A = typeof p == "number" || typeof p > "u" ? function() {
      return p;
    } : p;
    return c.map(function(b) {
      return b.map(function(v, E) {
        return {
          x: y(v, E, b),
          y: A(v, E, b)
        };
      });
    });
  }, [s, p, c]), x = de.useMemo(function() {
    var y = _y({
      x: s,
      y: p,
      defined: i,
      curve: r
    });
    return y(c.flat()) || "";
  }, [s, p, i, r, c]), T = de.useMemo(function() {
    return gS({
      path: x,
      segmentation: o,
      pointsInSegments: g,
      sampleRate: d
    });
  }, [x, o, g, d]);
  return /* @__PURE__ */ Ve.createElement("g", null, T.map(function(y, A) {
    return t ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, {
      key: A
    }, t({
      index: A,
      segment: y,
      styles: m[A] || m[A % m.length]
    })) : /* @__PURE__ */ Ve.createElement(jr, zf({
      key: A,
      className: n,
      data: y,
      x: vS,
      y: xS
    }, m[A] || m[A % m.length]));
  }));
}
By.propTypes = {
  segments: ze.arrayOf(ze.array).isRequired,
  styles: ze.array.isRequired,
  children: ze.func,
  className: ze.string
};
var bS = ["tooltipOpen"];
function SS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function fc() {
  return fc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, fc.apply(this, arguments);
}
function Iy(e) {
  var t = de.useState(fc({
    tooltipOpen: !1
  }, e)), n = t[0], r = t[1], i = de.useCallback(function(d) {
    return r(typeof d == "function" ? function(c) {
      c.tooltipOpen;
      var s = SS(c, bS);
      return fc({}, d(s), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: d.tooltipLeft,
      tooltipTop: d.tooltipTop,
      tooltipData: d.tooltipData
    });
  }, [r]), o = de.useCallback(function() {
    return r({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [r]);
  return {
    tooltipOpen: n.tooltipOpen,
    tooltipLeft: n.tooltipLeft,
    tooltipTop: n.tooltipTop,
    tooltipData: n.tooltipData,
    updateTooltip: r,
    showTooltip: i,
    hideTooltip: o
  };
}
var wS = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function hc() {
  return hc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, hc.apply(this, arguments);
}
function kS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var $y = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, yh = /* @__PURE__ */ Ve.forwardRef(function(e, t) {
  var n = e.className, r = e.top, i = e.left, o = e.offsetLeft, d = o === void 0 ? 10 : o, c = e.offsetTop, s = c === void 0 ? 10 : c, p = e.style, m = p === void 0 ? $y : p, g = e.children, x = e.unstyled, T = x === void 0 ? !1 : x, y = e.applyPositionStyle, A = y === void 0 ? !1 : y, b = kS(e, wS);
  return /* @__PURE__ */ Ve.createElement("div", hc({
    ref: t,
    className: Cn("visx-tooltip", n),
    style: hc({
      top: r == null || s == null ? r : r + s,
      left: i == null || d == null ? i : i + d
    }, A && {
      position: "absolute"
    }, !T && m)
  }, b), g);
});
yh.propTypes = {
  children: ze.node,
  className: ze.string,
  left: ze.number,
  offsetLeft: ze.number,
  offsetTop: ze.number,
  top: ze.number,
  applyPositionStyle: ze.bool,
  unstyled: ze.bool
};
yh.displayName = "Tooltip";
const TS = yh;
function Bf() {
  return Bf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Bf.apply(this, arguments);
}
function CS(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function AS(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, If(e, t);
}
function If(e, t) {
  return If = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, If(e, t);
}
var Op = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function LS(e) {
  var t;
  return t = /* @__PURE__ */ function(n) {
    AS(r, n);
    function r(o) {
      var d;
      return d = n.call(this, o) || this, d.state = {
        rect: void 0,
        parentRect: void 0
      }, d.nodeRef = /* @__PURE__ */ Ve.createRef(), d.getRects = d.getRects.bind(CS(d)), d;
    }
    var i = r.prototype;
    return i.componentDidMount = function() {
      var d, c = this;
      this.node = (d = this.nodeRef) != null && d.current ? this.nodeRef.current : dv.findDOMNode(this), this.setState(function() {
        return c.getRects();
      });
    }, i.getRects = function() {
      if (!this.node)
        return this.state;
      var d = this.node, c = d.parentNode, s = d.getBoundingClientRect ? d.getBoundingClientRect() : Op, p = c != null && c.getBoundingClientRect ? c.getBoundingClientRect() : Op;
      return {
        rect: s,
        parentRect: p
      };
    }, i.render = function() {
      return /* @__PURE__ */ Ve.createElement(e, Bf({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, r;
  }(Ve.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var Hy = /* @__PURE__ */ de.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), ES = Hy.Provider;
Hy.Consumer;
var RS = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function pc() {
  return pc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, pc.apply(this, arguments);
}
function NS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Vy(e) {
  var t = e.children;
  e.getRects;
  var n = e.left, r = n === void 0 ? 0 : n, i = e.offsetLeft, o = i === void 0 ? 10 : i, d = e.offsetTop, c = d === void 0 ? 10 : d, s = e.parentRect, p = e.rect, m = e.style, g = m === void 0 ? $y : m, x = e.top, T = x === void 0 ? 0 : x, y = e.unstyled, A = y === void 0 ? !1 : y, b = e.nodeRef, v = NS(e, RS), E, N = !1, R = !1;
  if (p && s) {
    var L = r, B = T;
    if (s.width) {
      var j = L + o + p.width - s.width, Z = p.width - L - o;
      N = j > 0 && j > Z;
    } else {
      var re = L + o + p.width - window.innerWidth, X = p.width - L - o;
      N = re > 0 && re > X;
    }
    if (s.height) {
      var se = B + c + p.height - s.height, Y = p.height - B - c;
      R = se > 0 && se > Y;
    } else
      R = B + c + p.height > window.innerHeight;
    L = N ? L - p.width - o : L + o, B = R ? B - p.height - c : B + c, L = Math.round(L), B = Math.round(B), E = "translate(" + L + "px, " + B + "px)";
  }
  return /* @__PURE__ */ Ve.createElement(TS, pc({
    ref: b,
    style: pc({
      left: 0,
      top: 0,
      transform: E
    }, !A && g)
  }, v), /* @__PURE__ */ Ve.createElement(ES, {
    value: {
      isFlippedVertically: !R,
      isFlippedHorizontally: !N
    }
  }, t));
}
Vy.propTypes = {
  nodeRef: ze.oneOfType([ze.string, ze.func, ze.object])
};
const Wy = LS(Vy), jy = (e) => {
  const {
    tableData: t,
    config: n,
    formatNumber: r,
    capitalize: i,
    formatDate: o,
    formatTooltipsDate: d,
    parseDate: c,
    setSharedFilter: s,
    isDraggingAnnotation: p
  } = de.useContext(vt), { xScale: m, yScale: g, showTooltip: x, hideTooltip: T } = e, { xAxis: y, visualizationType: A, orientation: b, yAxis: v, runtime: E } = n, N = (te, J) => {
    var ce;
    let Q = 0, G = Number(g.invert(te)), ne = null, H = null;
    for (let ke of (ce = n.runtime) == null ? void 0 : ce.seriesKeys)
      if (J.hasOwnProperty(ke) && (Q += Number(J[ke]), Q >= G)) {
        H = J[ke], ne = ke;
        break;
      }
    return [ne, H];
  }, R = (te, J, Q, G) => {
    const ne = Q.general.showMissingDataLabel && (!J || J === "null"), H = te === Q.xAxis.dataKey ? J : r(J, G(te));
    return ne ? "N/A" : H;
  }, L = (te, J) => {
    const { x: Q, y: G } = J, H = {
      data: te || {},
      dataXPosition: Q + 10,
      dataYPosition: G
    };
    return {
      tooltipLeft: H.dataXPosition,
      tooltipTop: H.dataYPosition,
      tooltipData: H
    };
  }, B = (te, J) => {
    if (A === "Bump Chart" || (te.stopPropagation(), p))
      return;
    const Q = Mh(te), { x: G, y: ne } = Q, { data: H, arc: ce } = J ?? {}, ke = re(G - Number(n.yAxis.size || 0)), Se = t.filter((Ee) => Ee[y.dataKey] === X(ne)), xe = b === "vertical" ? Y(ke) : Se, De = (Ee) => {
      const he = n.runtime.series.filter(($e) => $e.dataKey === Ee)[0];
      return he != null && he.axis ? String(he.axis).toLowerCase() : "left";
    }, Ce = (() => {
      var tt, We, Fe, Je;
      const Ee = n.columns, he = [], Be = [];
      for (const [Ke, Ye] of Object.entries(Ee)) {
        const Xe = {
          addColPrefix: n.columns[Ke].prefix,
          addColSuffix: n.columns[Ke].suffix,
          addColRoundTo: n.columns[Ke].roundToPlace ? n.columns[Ke].roundToPlace : "",
          addColCommas: n.columns[Ke].commas
        };
        let Ae = null;
        n.visualizationType === "Pie" ? Ae = ce == null ? void 0 : ce.data[Ye.name] : Ae = (tt = xe[0]) == null ? void 0 : tt[Ye.name];
        const Oe = Zf(Ae, "left", !0, n, Xe);
        Ye.tooltips && he.push([Ye.label, Oe]);
      }
      const $e = [];
      if (he.forEach((Ke) => {
        $e.push([Ke[0], Ke[1]]);
      }), A === "Pie") {
        const Ke = Number(n.dataFormat.roundTo) || 0, Ae = ((ce.endAngle - ce.startAngle) * 180 / Math.PI / 360 * 100).toFixed(Ke);
        Be.push(
          // ignore
          [n.xAxis.dataKey, H],
          [n.runtime.yAxis.dataKey, r(ce == null ? void 0 : ce.data[n.runtime.yAxis.dataKey])],
          ["Percent", `${Ae + "%"}`]
        );
      }
      if (A === "Forest Plot" && Be.push([n.xAxis.dataKey, X(ne)]), A !== "Pie" && A !== "Forest Plot" && !n.tooltips.singleSeries && (Be.push(
        ...(Fe = (We = ie()) == null ? void 0 : We.filter((Ke) => {
          var Xe, Ae;
          return ((Xe = n.runtime.series) == null ? void 0 : Xe.find(
            (Oe) => Oe.dataKey === Ke && (Oe == null ? void 0 : Oe.tooltip) && !Oe.dynamicCategory
          )) || ((Ae = n.xAxis) == null ? void 0 : Ae.dataKey) == Ke || A === "Forecasting";
        })) == null ? void 0 : Fe.flatMap((Ke) => {
          var Oe;
          const Ye = (Oe = xe[0]) == null ? void 0 : Oe[Ke], Xe = R(Ke, Ye, n, De), Ae = n.runtime.series.find(
            (lt) => lt.dataKey === Ke && lt.name !== void 0
          );
          return (Ye == null || Ye === "" || Xe === "N/A") && n.general.hideNullValue ? [] : Ae && Ae.name === "" ? [["", Xe, De(Ke)]] : [[Ke, Xe, De(Ke)]];
        })
      ), (Je = n.runtime.series) == null || Je.forEach((Ke) => {
        if (Ke != null && Ke.dynamicCategory) {
          const Ye = Ke.dataKey, Xe = xe.find((lt) => lt[Ke.dynamicCategory] === Ye);
          if (!Xe)
            return;
          const Ae = Xe[Ke.originalDataKey], Oe = R(Ye, Ae, n, De);
          Be.push([Ye, Oe, De(Ye)]);
        }
      })), A !== "Pie" && A !== "Forest Plot" && n.tooltips.singleSeries) {
        const [Ke, Ye] = N(ne, xe[0]);
        if (Ke && Ye) {
          Be.push([n.xAxis.dataKey, ke]);
          const Xe = R(Ke, Ye, n, De);
          Be.push([Ke, Xe]);
        }
      }
      return [...Be, ...$e];
    })();
    if (!Ce)
      return;
    const ye = L(Ce, Q);
    x(ye);
  }, j = () => {
    n.visualizationType === "Area Chart" ? setTimeout(() => {
      T();
    }, 3e3) : T();
  }, Z = (te) => {
    if (n.xAxis.type === "categorical" || n.visualizationType === "Combo") {
      let J = m.step();
      const G = Math.floor(Number(te) / J);
      return m.domain()[G - 1];
    }
    if (Tn(n.xAxis) && n.visualizationType !== "Combo") {
      const J = sp((H) => c(H[n.xAxis.dataKey])).left, Q = m.invert(m(te)), G = J(n.data, Q, 1);
      return c(n.data[G - 1][n.xAxis.dataKey]);
    }
  }, re = (te, J = !1) => {
    if (A !== "Pie" && b !== "horizontal") {
      if (m.type === "point" || y.type === "continuous" || Tn(y)) {
        let Q = null, G = Number.MAX_VALUE, ne = te;
        return t.forEach((H) => {
          const ce = Tn(y) ? m(c(H[y.dataKey])) : m(H[y.dataKey]);
          let ke = n.barHeight;
          const Se = Math.abs(Number(ce - ne + (J ? ke * 2 : 0)));
          Se <= G && (G = Se, Q = (Tn(y), H[y.dataKey]));
        }), Q;
      }
      if (n.xAxis.type === "categorical" || A === "Combo" && b !== "horizontal" && A !== "Forest Plot") {
        let G = (m.range()[1] - m.range()[0]) / (m.domain().length + 1);
        const H = Math.floor((Number(te) - G / 2) / G);
        return m.domain()[H];
      }
      if (Tn(y) && A !== "Combo" && b !== "horizontal") {
        const Q = sp((ce) => c(ce[n.xAxis.dataKey])).left, G = m.invert(te), ne = Q(n.data, G, 1);
        return c(n.data[ne - 1][n.xAxis.dataKey]);
      }
    }
  }, X = (te, J) => {
    if (A === "Pie")
      return;
    let Q = Number.MAX_VALUE, G = null;
    return t.forEach((ne, H) => {
      const ce = g(A !== "Forest Plot" ? ne[n.xAxis.dataKey] : H), ke = Math.abs(ce - te);
      ke < Q && (Q = ke, G = J ? ne[J] : ne[n.xAxis.dataKey]);
    }), G;
  }, se = (te) => {
    var J, Q;
    try {
      if (n.visualizationType === "Bump Chart")
        return;
      const G = Mh(te), { x: ne } = G;
      if (!ne)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let H = re(ne, !0), ce = (J = n.data) == null ? void 0 : J.filter((ke) => ke[n.xAxis.dataKey] === H);
      if (!H)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (Tn(y) && H && (H = new Date(H), H = o(H), ce = (Q = n.data) == null ? void 0 : Q.filter((ke) => o(new Date(ke[n.xAxis.dataKey])) === H)), !ce[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${H}`);
      s && (n != null && n.uid) && (ce != null && ce[0]) && s(n.uid, ce[0]);
    } catch (G) {
      console.error(G.message);
    }
  }, Y = (te) => {
    const Q = n.runtime.series.filter(
      (H) => A === "Pie" || H.tooltip === !0 && !H.dynamicCategory
    ).map((H) => H.dataKey);
    Q.push(n.xAxis.dataKey);
    const G = nt.uniq(
      n.runtime.series.flatMap((H) => {
        if (H.dynamicCategory)
          return [H.dynamicCategory, H.originalDataKey];
      })
    );
    Q.push(...G), n.visualizationType === "Forecasting" && n.runtime.series.map((H) => {
      H.confidenceIntervals.map((ce) => {
        ce.showInTooltip && (Q.push(ce.high), Q.push(ce.low));
      });
    });
    const ne = Object.values(n.columns).map((H) => H.name);
    Q.push(...ne, ...ne);
    try {
      const H = t.filter((ke) => ke[y.dataKey] === te);
      return !H || H.length === 0 ? [] : H.map((ke) => nt.pick(ke, Q));
    } catch (H) {
      console.error("COVE", H);
    }
  }, ie = () => {
    var te;
    try {
      let J, Q = [], G = [];
      if ((te = n.runtime.series) == null || te.forEach((ne) => {
        ne.type === "Forecasting" && (Q.push(ne.stageColumn), ne == null || ne.confidenceIntervals.forEach((H) => {
          H.showInTooltip === !0 && (G.push(H.low), G.push(H.high));
        }));
      }), !n.dashboard)
        switch (A) {
          case "Combo":
            J = [E.xAxis.dataKey, ...E == null ? void 0 : E.seriesKeys, ...G];
            break;
          case "Forecasting":
            J = [E.xAxis.dataKey, ...Q, ...G];
            break;
          case "Line":
            J = [E.xAxis.dataKey, ...E == null ? void 0 : E.seriesKeys];
            break;
          case "Area Chart":
            J = [E.xAxis.dataKey, ...E == null ? void 0 : E.seriesKeys];
            break;
          case "Bar":
            J = b === "vertical" ? [E.xAxis.dataKey, ...E == null ? void 0 : E.seriesKeys] : [E.yAxis.dataKey, ...E == null ? void 0 : E.seriesKeys];
            break;
          case "Pie":
            J = [E.xAxis.dataKey, ...E == null ? void 0 : E.seriesKeys];
          default:
            throw new Error("No visualization type found in handleTooltipMouseOver");
        }
      return n.dashboard && (J = [
        E.xAxis.dataKey,
        ...E == null ? void 0 : E.barSeriesKeys,
        ...E == null ? void 0 : E.lineSeriesKeys,
        ...Q,
        ...G
      ]), J;
    } catch (J) {
      console.error("COVE", J);
    }
  }, I = (te) => {
    const { dataXPosition: J, dataYPosition: Q } = te;
    return {
      opacity: n.tooltips.opacity ? n.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${J}px, ${Number(Q)}px)`
    };
  }, U = (te) => {
    var Q, G;
    let J = n.runtime.series.filter((ne) => ne.dataKey === te);
    return (Q = J[0]) != null && Q.name ? (G = J[0]) == null ? void 0 : G.name : te;
  };
  return {
    getIncludedTooltipSeries: ie,
    getXValueFromCoordinate: re,
    getXValueFromCoordinateDate: Z,
    getYScaleValues: Y,
    handleTooltipClick: se,
    handleTooltipMouseOff: j,
    handleTooltipMouseOver: B,
    TooltipListItem: ({ item: te }) => {
      var ye;
      const [J, Q] = te, [G, ne, H] = Q;
      if (A === "Forest Plot")
        return G === n.xAxis.dataKey ? /* @__PURE__ */ a("li", { className: "tooltip-heading", children: `${i(n.xAxis.dataKey ? `${n.xAxis.dataKey}: ` : "")} ${Tn(v) ? o(c(G, !1)) : ne}` }) : /* @__PURE__ */ a("li", { className: "tooltip-body", children: `${U(G)}: ${r(ne, "left")}` });
      const ce = n.tooltips.dateDisplayFormat ? d(c(ne, !1)) : o(c(ne, !1));
      if (A === "Bar" && b === "horizontal" && G === n.xAxis.dataKey)
        return /* @__PURE__ */ a("li", { className: "tooltip-heading", children: `${i(
          n.runtime.yAxis.label ? `${n.runtime.yAxis.label}: ` : ""
        )} ${n.xAxis.type === "date" ? ce : ne}` });
      if (G === n.xAxis.dataKey)
        return /* @__PURE__ */ a("li", { className: "tooltip-heading", children: `${i(
          n.runtime.xAxis.label ? `${n.runtime.xAxis.label}: ` : ""
        )} ${Tn(y) ? ce : ne}` });
      const { label: ke, displayGray: Se } = n.visualizationSubType !== "stacked" && n.general.showSuppressedSymbol && ((ye = n.preliminaryData) == null ? void 0 : ye.find(
        (Ee) => Ee.label && Ee.type === "suppression" && Ee.displayTooltip && ne === Ee.value && (!Ee.column || G === Ee.column)
      )) || {};
      let xe = ke || ne;
      const De = Se ? { color: "#8b8b8a" } : {};
      J == 1 && n.dataFormat.onlyShowTopPrefixSuffix && (xe = `${n.dataFormat.prefix}${xe}${n.dataFormat.suffix}`);
      const je = U(G), Ce = je ? `${je}: ${xe}` : xe;
      return /* @__PURE__ */ a("li", { style: De, className: "tooltip-body", children: Ce });
    },
    tooltipStyles: I
  };
};
function gh(e, { threshold: t = 0, root: n = null, rootMargin: r = "0%", freezeOnceVisible: i = !1 }) {
  const [o, d] = de.useState(), c = (o == null ? void 0 : o.isIntersecting) && i, s = ([p]) => {
    d(p);
  };
  return de.useEffect(() => {
    const p = e == null ? void 0 : e.current;
    if (!!!window.IntersectionObserver || c || !p)
      return;
    const g = { threshold: t, root: n, rootMargin: r }, x = new IntersectionObserver(s, g);
    return x.observe(p), () => x.disconnect();
  }, [e, t, n, r, c]), o;
}
const $f = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let n = "";
    return e.visualizationType && (n += `${e.visualizationType} chart`), e.title && e.visualizationType && (n += ` with the title: ${e.title}`), n;
  } catch (n) {
    console.error("COVE: ", n.message);
  }
}, Mp = Symbol("implicit");
function vh() {
  var e = new Zh(), t = [], n = [], r = Mp;
  function i(o) {
    let d = e.get(o);
    if (d === void 0) {
      if (r !== Mp)
        return r;
      e.set(o, d = t.push(o) - 1);
    }
    return n[d % n.length];
  }
  return i.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new Zh();
    for (const d of o)
      e.has(d) || e.set(d, t.push(d) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (n = Array.from(o), i) : n.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (r = o, i) : r;
  }, i.copy = function() {
    return vh(t, n).unknown(r);
  }, Mc.apply(i, arguments), i;
}
function xh() {
  var e = vh().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, o, d, c = !1, s = 0, p = 0, m = 0.5;
  delete e.unknown;
  function g() {
    var x = t().length, T = i < r, y = T ? i : r, A = T ? r : i;
    o = (A - y) / Math.max(1, x - s + p * 2), c && (o = Math.floor(o)), y += (A - y - o * (x - s)) * m, d = o * (1 - s), c && (y = Math.round(y), d = Math.round(d));
    var b = vv(x).map(function(v) {
      return y + o * v;
    });
    return n(T ? b.reverse() : b);
  }
  return e.domain = function(x) {
    return arguments.length ? (t(x), g()) : t();
  }, e.range = function(x) {
    return arguments.length ? ([r, i] = x, r = +r, i = +i, g()) : [r, i];
  }, e.rangeRound = function(x) {
    return [r, i] = x, r = +r, i = +i, c = !0, g();
  }, e.bandwidth = function() {
    return d;
  }, e.step = function() {
    return o;
  }, e.round = function(x) {
    return arguments.length ? (c = !!x, g()) : c;
  }, e.padding = function(x) {
    return arguments.length ? (s = Math.min(1, p = +x), g()) : s;
  }, e.paddingInner = function(x) {
    return arguments.length ? (s = Math.min(1, x), g()) : s;
  }, e.paddingOuter = function(x) {
    return arguments.length ? (p = +x, g()) : p;
  }, e.align = function(x) {
    return arguments.length ? (m = Math.max(0, Math.min(1, x)), g()) : m;
  }, e.copy = function() {
    return xh(t(), [r, i]).round(c).paddingInner(s).paddingOuter(p).align(m);
  }, Mc.apply(g(), arguments);
}
function Uy(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return Uy(t());
  }, e;
}
function PS() {
  return Uy(xh.apply(null, arguments).paddingInner(1));
}
function Ky(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, i = e[n], o = e[r], d;
  return o < i && (d = n, n = r, r = d, d = i, i = o, o = d), e[n] = t.floor(i), e[r] = t.ceil(o), e;
}
function Fp(e) {
  return Math.log(e);
}
function zp(e) {
  return Math.exp(e);
}
function DS(e) {
  return -Math.log(-e);
}
function _S(e) {
  return -Math.exp(-e);
}
function OS(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function MS(e) {
  return e === 10 ? OS : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function FS(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function Bp(e) {
  return (t, n) => -e(-t, n);
}
function zS(e) {
  const t = e(Fp, zp), n = t.domain;
  let r = 10, i, o;
  function d() {
    return i = FS(r), o = MS(r), n()[0] < 0 ? (i = Bp(i), o = Bp(o), e(DS, _S)) : e(Fp, zp), t;
  }
  return t.base = function(c) {
    return arguments.length ? (r = +c, d()) : r;
  }, t.domain = function(c) {
    return arguments.length ? (n(c), d()) : n();
  }, t.ticks = (c) => {
    const s = n();
    let p = s[0], m = s[s.length - 1];
    const g = m < p;
    g && ([p, m] = [m, p]);
    let x = i(p), T = i(m), y, A;
    const b = c == null ? 10 : +c;
    let v = [];
    if (!(r % 1) && T - x < b) {
      if (x = Math.floor(x), T = Math.ceil(T), p > 0) {
        for (; x <= T; ++x)
          for (y = 1; y < r; ++y)
            if (A = x < 0 ? y / o(-x) : y * o(x), !(A < p)) {
              if (A > m)
                break;
              v.push(A);
            }
      } else
        for (; x <= T; ++x)
          for (y = r - 1; y >= 1; --y)
            if (A = x > 0 ? y / o(-x) : y * o(x), !(A < p)) {
              if (A > m)
                break;
              v.push(A);
            }
      v.length * 2 < b && (v = jh(p, m, b));
    } else
      v = jh(x, T, Math.min(T - x, b)).map(o);
    return g ? v.reverse() : v;
  }, t.tickFormat = (c, s) => {
    if (c == null && (c = 10), s == null && (s = r === 10 ? "s" : ","), typeof s != "function" && (!(r % 1) && (s = lv(s)).precision == null && (s.trim = !0), s = sv(s)), c === 1 / 0)
      return s;
    const p = Math.max(1, r * c / t.ticks().length);
    return (m) => {
      let g = m / o(Math.round(i(m)));
      return g * r < r - 0.5 && (g *= r), g <= p ? s(m) : "";
    };
  }, t.nice = () => n(Ky(n(), {
    floor: (c) => o(Math.floor(i(c))),
    ceil: (c) => o(Math.ceil(i(c)))
  })), t;
}
function Yy() {
  const e = zS(ov()).domain([1, 10]);
  return e.copy = () => Dm(e, Yy()).base(e.base()), Mc.apply(e, arguments), e;
}
function BS(e) {
  return new Date(e);
}
function IS(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Gy(e, t, n, r, i, o, d, c, s, p) {
  var m = uv(), g = m.invert, x = m.domain, T = p(".%L"), y = p(":%S"), A = p("%I:%M"), b = p("%I %p"), v = p("%a %d"), E = p("%b %d"), N = p("%B"), R = p("%Y");
  function L(B) {
    return (s(B) < B ? T : c(B) < B ? y : d(B) < B ? A : o(B) < B ? b : r(B) < B ? i(B) < B ? v : E : n(B) < B ? N : R)(B);
  }
  return m.invert = function(B) {
    return new Date(g(B));
  }, m.domain = function(B) {
    return arguments.length ? x(Array.from(B, IS)) : x().map(BS);
  }, m.ticks = function(B) {
    var j = x();
    return e(j[0], j[j.length - 1], B ?? 10);
  }, m.tickFormat = function(B, j) {
    return j == null ? L : p(j);
  }, m.nice = function(B) {
    var j = x();
    return (!B || typeof B.range != "function") && (B = t(j[0], j[j.length - 1], B ?? 10)), B ? x(Ky(j, B)) : m;
  }, m.copy = function() {
    return Dm(m, Gy(e, t, n, r, i, o, d, c, s, p));
  }, m;
}
function Xy() {
  return Mc.apply(Gy(bv, Sv, Om, Pm, Fm, Mm, Nm, Rm, ms, Zg).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var $S = Ps("domain", "range", "reverse", "align", "padding", "round");
function mc(e) {
  return $S(xh(), e);
}
var HS = Ps("domain", "range", "reverse", "align", "padding", "round");
function al(e) {
  return HS(PS(), e);
}
var VS = Ps("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function WS(e) {
  return VS(Xy(), e);
}
var jS = Ps("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function yc(e) {
  return jS(Yy(), e);
}
var US = Ps("domain", "range", "reverse", "unknown");
function bh(e) {
  return US(vh(), e);
}
function KS(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function qy(e, t) {
  var n = e;
  return "ticks" in n ? n.ticks(t) : n.domain().filter(function(r, i, o) {
    return t == null || o.length <= t || i % Math.round((o.length - 1) / t) === 0;
  });
}
function YS(e) {
  return e == null ? void 0 : e.toString();
}
const Mu = ({ startAngle: e, endAngle: t }) => ({
  startAngle: e,
  endAngle: t
}), GS = (e) => {
  const {
    transformedData: t,
    config: n,
    colorScale: r,
    currentViewport: i,
    seriesHighlight: o,
    isDraggingAnnotation: d
  } = de.useContext(vt), { tooltipData: c, showTooltip: s, hideTooltip: p, tooltipOpen: m, tooltipLeft: g, tooltipTop: x } = Iy(), { handleTooltipMouseOver: T, handleTooltipMouseOff: y, TooltipListItem: A } = jy({
    xScale: !1,
    yScale: !1,
    showTooltip: s,
    hideTooltip: p
  }), [b, v] = de.useState(void 0), [E, N] = de.useState(!1), R = Object.values(n.columns).filter((G) => G.showInViz), L = R.length > 0, B = L ? "pivotColumn" : void 0, j = de.useMemo(() => {
    if (L) {
      let G = [];
      const ne = n.yAxis.dataKey, H = R.map((Se) => Se.name), ce = [ne, ...H], ke = n.xAxis.dataKey;
      return t.forEach((Se) => {
        ce.forEach((xe) => {
          const De = Se[xe];
          De && G.push({
            [B]: De,
            [ke]: `${Se[ke]} - ${xe}`
          });
        });
      }), G;
    }
    return t;
  }, [t, L]), Z = de.useMemo(() => {
    if (L) {
      const G = {};
      j.forEach((ce) => {
        G[ce[n.xAxis.dataKey]] || (G[ce[n.xAxis.dataKey]] = !0);
      });
      const ne = Object.entries(G).length;
      let H = n.customColors || Cr[n.palette];
      return H = H.slice(0, ne), bh({
        domain: Object.keys(G),
        range: H,
        unknown: null
      });
    }
    return r;
  }, [r, L]), re = de.useRef(), X = gh(re, {
    freezeOnceVisible: !1
  });
  de.useEffect(() => {
    document.querySelector(".isEditor") && N((ne) => !0);
  }), de.useEffect(() => {
    X != null && X.isIntersecting && n.animate && !E && setTimeout(() => {
      N(!0);
    }, 500);
  }, [X == null ? void 0 : X.isIntersecting, n.animate]);
  const se = ({ arcs: G, path: ne, getKey: H }) => {
    const ce = _b(G, H, {
      from: Mu,
      enter: Mu,
      update: Mu,
      leave: Mu
    });
    return de.useEffect(() => {
      const ke = setTimeout(() => {
        p();
      }, 500);
      return () => {
        clearTimeout(ke);
      };
    }, [c]), /* @__PURE__ */ z(Ue, { children: [
      ce.map(({ item: ke, props: Se, key: xe }, De) => /* @__PURE__ */ a(
        it,
        {
          className: ke.data[n.xAxis.dataKey],
          style: {
            opacity: n.legend.behavior === "highlight" && o.length > 0 && o.indexOf(ke.data[n.runtime.xAxis.dataKey]) === -1 ? 0.5 : 1
          },
          children: /* @__PURE__ */ a(
            Cp.path,
            {
              d: Lb(
                [Se.startAngle, Se.endAngle],
                (je, Ce) => ne({
                  ...ke,
                  startAngle: je,
                  endAngle: Ce
                })
              ),
              fill: Z(ke.data[n.runtime.xAxis.dataKey]),
              onMouseEnter: (je) => T(je, { data: ke.data[n.runtime.xAxis.dataKey], arc: ke }),
              onMouseLeave: (je) => y()
            }
          )
        },
        `${xe}-${De}`
      )),
      ce.map(({ item: ke, key: Se }, xe) => {
        const De = Number(n.dataFormat.roundTo) || 0, [je, Ce] = ne.centroid(ke), ye = ke.endAngle - ke.startAngle >= 0.1;
        let Ee = "#FFF";
        Z(ke.data[n.runtime.xAxis.dataKey]) && (Ee = sl(Ee, Z(ke.data[n.runtime.xAxis.dataKey])));
        const $e = ((ke.endAngle - ke.startAngle) * 180 / Math.PI / 360 * 100).toFixed(De);
        return /* @__PURE__ */ a(Cp.g, { children: ye && /* @__PURE__ */ a(
          gt,
          {
            style: { fill: Ee },
            x: je,
            y: Ce,
            dy: ".33em",
            textAnchor: "middle",
            pointerEvents: "none",
            children: $e + "%"
          }
        ) }, `${Se}${xe}`);
      })
    ] });
  };
  let Y = e.parentWidth, ie = e.parentWidth;
  n && n.legend && !n.legend.hide && i === "lg" && (ie = Number(Y) * 0.73);
  const I = n.heights.vertical, U = Math.min(ie, I) / 2, ue = I / 2, te = e.parentWidth / 2, J = n.pieType === "Donut" ? 75 : U;
  de.useEffect(() => {
    if (o.length > 0 && n.legend.behavior !== "highlight") {
      let G = [];
      j.forEach((ne) => {
        o.indexOf(ne[n.runtime.xAxis.dataKey]) !== -1 && G.push(ne);
      }), v(G);
    } else
      v(void 0);
  }, [o]);
  const Q = () => {
    let G = ["animated-pie", "group"];
    return (n.animate === !1 || E) && G.push("animated"), G.join(" ");
  };
  return /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z(Ur, { component: "PieChart", children: [
    /* @__PURE__ */ a(
      "svg",
      {
        width: U * 2,
        height: I,
        className: Q(),
        role: "img",
        "aria-label": $f(n),
        children: /* @__PURE__ */ a(it, { top: ue, left: U, children: /* @__PURE__ */ a(
          K0,
          {
            data: b || j,
            pieValue: (G) => G[B || n.runtime.yAxis.dataKey],
            pieSortValues: () => -1,
            innerRadius: U - J,
            outerRadius: U,
            children: (G) => /* @__PURE__ */ a(se, { ...G, getKey: (ne) => ne.data[n.runtime.xAxis.dataKey] })
          }
        ) })
      }
    ),
    /* @__PURE__ */ a("div", { ref: re }),
    !d && c && Object.entries(c.data).length > 0 && m && s && c.dataYPosition && c.dataXPosition && /* @__PURE__ */ z(Ue, { children: [
      /* @__PURE__ */ a("style", { children: `.tooltip {background-color: rgba(255,255,255, ${n.tooltips.opacity / 100}) !important` }),
      /* @__PURE__ */ a(
        Wy,
        {
          className: "tooltip cdc-open-viz-module",
          left: g + te - U,
          top: x,
          children: /* @__PURE__ */ a("ul", { children: typeof c == "object" && Object.entries(c.data).map((G, ne) => /* @__PURE__ */ a(A, { item: G }, ne)) })
        },
        Math.random()
      )
    ] })
  ] }) });
};
function Ds(e) {
  return e.split("-")[1];
}
function Sh(e) {
  return e === "y" ? "height" : "width";
}
function Wa(e) {
  return e.split("-")[0];
}
function _s(e) {
  return ["top", "bottom"].includes(Wa(e)) ? "x" : "y";
}
function Ip(e, t, n) {
  let { reference: r, floating: i } = e;
  const o = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, c = _s(t), s = Sh(c), p = r[s] / 2 - i[s] / 2, m = c === "x";
  let g;
  switch (Wa(t)) {
    case "top":
      g = { x: o, y: r.y - i.height };
      break;
    case "bottom":
      g = { x: o, y: r.y + r.height };
      break;
    case "right":
      g = { x: r.x + r.width, y: d };
      break;
    case "left":
      g = { x: r.x - i.width, y: d };
      break;
    default:
      g = { x: r.x, y: r.y };
  }
  switch (Ds(t)) {
    case "start":
      g[c] -= p * (n && m ? -1 : 1);
      break;
    case "end":
      g[c] += p * (n && m ? -1 : 1);
  }
  return g;
}
function Zy(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function xs(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Qy(e, t) {
  var n;
  t === void 0 && (t = {});
  const { x: r, y: i, platform: o, rects: d, elements: c, strategy: s } = e, { boundary: p = "clippingAncestors", rootBoundary: m = "viewport", elementContext: g = "floating", altBoundary: x = !1, padding: T = 0 } = t, y = Zy(T), A = c[x ? g === "floating" ? "reference" : "floating" : g], b = xs(await o.getClippingRect({ element: (n = await (o.isElement == null ? void 0 : o.isElement(A))) == null || n ? A : A.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(c.floating)), boundary: p, rootBoundary: m, strategy: s })), v = g === "floating" ? { ...d.floating, x: r, y: i } : d.reference, E = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c.floating)), N = await (o.isElement == null ? void 0 : o.isElement(E)) && await (o.getScale == null ? void 0 : o.getScale(E)) || { x: 1, y: 1 }, R = xs(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: v, offsetParent: E, strategy: s }) : v);
  return { top: (b.top - R.top + y.top) / N.y, bottom: (R.bottom - b.bottom + y.bottom) / N.y, left: (b.left - R.left + y.left) / N.x, right: (R.right - b.right + y.right) / N.x };
}
const XS = Math.min, qS = Math.max;
function Hf(e, t, n) {
  return qS(e, XS(t, n));
}
["top", "right", "bottom", "left"].reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const ZS = { left: "right", right: "left", bottom: "top", top: "bottom" };
function gc(e) {
  return e.replace(/left|right|bottom|top/g, (t) => ZS[t]);
}
function QS(e, t, n) {
  n === void 0 && (n = !1);
  const r = Ds(e), i = _s(e), o = Sh(i);
  let d = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (d = gc(d)), { main: d, cross: gc(d) };
}
const JS = { start: "end", end: "start" };
function ef(e) {
  return e.replace(/start|end/g, (t) => JS[t]);
}
const ew = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var n;
    const { placement: r, middlewareData: i, rects: o, initialPlacement: d, platform: c, elements: s } = t, { mainAxis: p = !0, crossAxis: m = !0, fallbackPlacements: g, fallbackStrategy: x = "bestFit", fallbackAxisSideDirection: T = "none", flipAlignment: y = !0, ...A } = e, b = Wa(r), v = Wa(d) === d, E = await (c.isRTL == null ? void 0 : c.isRTL(s.floating)), N = g || (v || !y ? [gc(d)] : function(se) {
      const Y = gc(se);
      return [ef(se), Y, ef(Y)];
    }(d));
    g || T === "none" || N.push(...function(se, Y, ie, I) {
      const U = Ds(se);
      let ue = function(te, J, Q) {
        const G = ["left", "right"], ne = ["right", "left"], H = ["top", "bottom"], ce = ["bottom", "top"];
        switch (te) {
          case "top":
          case "bottom":
            return Q ? J ? ne : G : J ? G : ne;
          case "left":
          case "right":
            return J ? H : ce;
          default:
            return [];
        }
      }(Wa(se), ie === "start", I);
      return U && (ue = ue.map((te) => te + "-" + U), Y && (ue = ue.concat(ue.map(ef)))), ue;
    }(d, y, T, E));
    const R = [d, ...N], L = await Qy(t, A), B = [];
    let j = ((n = i.flip) == null ? void 0 : n.overflows) || [];
    if (p && B.push(L[b]), m) {
      const { main: se, cross: Y } = QS(r, o, E);
      B.push(L[se], L[Y]);
    }
    if (j = [...j, { placement: r, overflows: B }], !B.every((se) => se <= 0)) {
      var Z, re;
      const se = (((Z = i.flip) == null ? void 0 : Z.index) || 0) + 1, Y = R[se];
      if (Y)
        return { data: { index: se, overflows: j }, reset: { placement: Y } };
      let ie = (re = j.find((I) => I.overflows[0] <= 0)) == null ? void 0 : re.placement;
      if (!ie)
        switch (x) {
          case "bestFit": {
            var X;
            const I = (X = j.map((U) => [U.placement, U.overflows.filter((ue) => ue > 0).reduce((ue, te) => ue + te, 0)]).sort((U, ue) => U[1] - ue[1])[0]) == null ? void 0 : X[0];
            I && (ie = I);
            break;
          }
          case "initialPlacement":
            ie = d;
        }
      if (r !== ie)
        return { reset: { placement: ie } };
    }
    return {};
  } };
}, tw = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: n, y: r } = t, i = await async function(o, d) {
      const { placement: c, platform: s, elements: p } = o, m = await (s.isRTL == null ? void 0 : s.isRTL(p.floating)), g = Wa(c), x = Ds(c), T = _s(c) === "x", y = ["left", "top"].includes(g) ? -1 : 1, A = m && T ? -1 : 1, b = typeof d == "function" ? d(o) : d;
      let { mainAxis: v, crossAxis: E, alignmentAxis: N } = typeof b == "number" ? { mainAxis: b, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...b };
      return x && typeof N == "number" && (E = x === "end" ? -1 * N : N), T ? { x: E * A, y: v * y } : { x: v * y, y: E * A };
    }(t, e);
    return { x: n + i.x, y: r + i.y, data: i };
  } };
}, nw = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: n, y: r, placement: i } = t, { mainAxis: o = !0, crossAxis: d = !1, limiter: c = { fn: (b) => {
      let { x: v, y: E } = b;
      return { x: v, y: E };
    } }, ...s } = e, p = { x: n, y: r }, m = await Qy(t, s), g = _s(Wa(i)), x = g === "x" ? "y" : "x";
    let T = p[g], y = p[x];
    if (o) {
      const b = g === "y" ? "bottom" : "right";
      T = Hf(T + m[g === "y" ? "top" : "left"], T, T - m[b]);
    }
    if (d) {
      const b = x === "y" ? "bottom" : "right";
      y = Hf(y + m[x === "y" ? "top" : "left"], y, y - m[b]);
    }
    const A = c.fn({ ...t, [g]: T, [x]: y });
    return { ...A, data: { x: A.x - n, y: A.y - r } };
  } };
};
function Dr(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function ii(e) {
  return Dr(e).getComputedStyle(e);
}
const $p = Math.min, bs = Math.max, vc = Math.round;
function Jy(e) {
  const t = ii(e);
  let n = parseFloat(t.width), r = parseFloat(t.height);
  const i = e.offsetWidth, o = e.offsetHeight, d = vc(n) !== i || vc(r) !== o;
  return d && (n = i, r = o), { width: n, height: r, fallback: d };
}
function Zi(e) {
  return tg(e) ? (e.nodeName || "").toLowerCase() : "";
}
let Fu;
function eg() {
  if (Fu)
    return Fu;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (Fu = e.brands.map((t) => t.brand + "/" + t.version).join(" "), Fu) : navigator.userAgent;
}
function ai(e) {
  return e instanceof Dr(e).HTMLElement;
}
function Ki(e) {
  return e instanceof Dr(e).Element;
}
function tg(e) {
  return e instanceof Dr(e).Node;
}
function Hp(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Dr(e).ShadowRoot || e instanceof ShadowRoot;
}
function $c(e) {
  const { overflow: t, overflowX: n, overflowY: r, display: i } = ii(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function rw(e) {
  return ["table", "td", "th"].includes(Zi(e));
}
function Vf(e) {
  const t = /firefox/i.test(eg()), n = ii(e), r = n.backdropFilter || n.WebkitBackdropFilter;
  return n.transform !== "none" || n.perspective !== "none" || !!r && r !== "none" || t && n.willChange === "filter" || t && !!n.filter && n.filter !== "none" || ["transform", "perspective"].some((i) => n.willChange.includes(i)) || ["paint", "layout", "strict", "content"].some((i) => {
    const o = n.contain;
    return o != null && o.includes(i);
  });
}
function ng() {
  return !/^((?!chrome|android).)*safari/i.test(eg());
}
function wh(e) {
  return ["html", "body", "#document"].includes(Zi(e));
}
function rg(e) {
  return Ki(e) ? e : e.contextElement;
}
const ig = { x: 1, y: 1 };
function ll(e) {
  const t = rg(e);
  if (!ai(t))
    return ig;
  const n = t.getBoundingClientRect(), { width: r, height: i, fallback: o } = Jy(t);
  let d = (o ? vc(n.width) : n.width) / r, c = (o ? vc(n.height) : n.height) / i;
  return d && Number.isFinite(d) || (d = 1), c && Number.isFinite(c) || (c = 1), { x: d, y: c };
}
function Rs(e, t, n, r) {
  var i, o;
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const d = e.getBoundingClientRect(), c = rg(e);
  let s = ig;
  t && (r ? Ki(r) && (s = ll(r)) : s = ll(e));
  const p = c ? Dr(c) : window, m = !ng() && n;
  let g = (d.left + (m && ((i = p.visualViewport) == null ? void 0 : i.offsetLeft) || 0)) / s.x, x = (d.top + (m && ((o = p.visualViewport) == null ? void 0 : o.offsetTop) || 0)) / s.y, T = d.width / s.x, y = d.height / s.y;
  if (c) {
    const A = Dr(c), b = r && Ki(r) ? Dr(r) : r;
    let v = A.frameElement;
    for (; v && r && b !== A; ) {
      const E = ll(v), N = v.getBoundingClientRect(), R = getComputedStyle(v);
      N.x += (v.clientLeft + parseFloat(R.paddingLeft)) * E.x, N.y += (v.clientTop + parseFloat(R.paddingTop)) * E.y, g *= E.x, x *= E.y, T *= E.x, y *= E.y, g += N.x, x += N.y, v = Dr(v).frameElement;
    }
  }
  return { width: T, height: y, top: x, right: g + T, bottom: x + y, left: g, x: g, y: x };
}
function Yi(e) {
  return ((tg(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function Hc(e) {
  return Ki(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function ag(e) {
  return Rs(Yi(e)).left + Hc(e).scrollLeft;
}
function Ns(e) {
  if (Zi(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || Hp(e) && e.host || Yi(e);
  return Hp(t) ? t.host : t;
}
function og(e) {
  const t = Ns(e);
  return wh(t) ? t.ownerDocument.body : ai(t) && $c(t) ? t : og(t);
}
function lg(e, t) {
  var n;
  t === void 0 && (t = []);
  const r = og(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), o = Dr(r);
  return i ? t.concat(o, o.visualViewport || [], $c(r) ? r : []) : t.concat(r, lg(r));
}
function Vp(e, t, n) {
  return t === "viewport" ? xs(function(r, i) {
    const o = Dr(r), d = Yi(r), c = o.visualViewport;
    let s = d.clientWidth, p = d.clientHeight, m = 0, g = 0;
    if (c) {
      s = c.width, p = c.height;
      const x = ng();
      (x || !x && i === "fixed") && (m = c.offsetLeft, g = c.offsetTop);
    }
    return { width: s, height: p, x: m, y: g };
  }(e, n)) : Ki(t) ? xs(function(r, i) {
    const o = Rs(r, !0, i === "fixed"), d = o.top + r.clientTop, c = o.left + r.clientLeft, s = ai(r) ? ll(r) : { x: 1, y: 1 };
    return { width: r.clientWidth * s.x, height: r.clientHeight * s.y, x: c * s.x, y: d * s.y };
  }(t, n)) : xs(function(r) {
    const i = Yi(r), o = Hc(r), d = r.ownerDocument.body, c = bs(i.scrollWidth, i.clientWidth, d.scrollWidth, d.clientWidth), s = bs(i.scrollHeight, i.clientHeight, d.scrollHeight, d.clientHeight);
    let p = -o.scrollLeft + ag(r);
    const m = -o.scrollTop;
    return ii(d).direction === "rtl" && (p += bs(i.clientWidth, d.clientWidth) - c), { width: c, height: s, x: p, y: m };
  }(Yi(e)));
}
function Wp(e) {
  return ai(e) && ii(e).position !== "fixed" ? e.offsetParent : null;
}
function jp(e) {
  const t = Dr(e);
  let n = Wp(e);
  for (; n && rw(n) && ii(n).position === "static"; )
    n = Wp(n);
  return n && (Zi(n) === "html" || Zi(n) === "body" && ii(n).position === "static" && !Vf(n)) ? t : n || function(r) {
    let i = Ns(r);
    for (; ai(i) && !wh(i); ) {
      if (Vf(i))
        return i;
      i = Ns(i);
    }
    return null;
  }(e) || t;
}
function iw(e, t, n) {
  const r = ai(t), i = Yi(t), o = Rs(e, !0, n === "fixed", t);
  let d = { scrollLeft: 0, scrollTop: 0 };
  const c = { x: 0, y: 0 };
  if (r || !r && n !== "fixed")
    if ((Zi(t) !== "body" || $c(i)) && (d = Hc(t)), ai(t)) {
      const s = Rs(t, !0);
      c.x = s.x + t.clientLeft, c.y = s.y + t.clientTop;
    } else
      i && (c.x = ag(i));
  return { x: o.left + d.scrollLeft - c.x, y: o.top + d.scrollTop - c.y, width: o.width, height: o.height };
}
const aw = { getClippingRect: function(e) {
  let { element: t, boundary: n, rootBoundary: r, strategy: i } = e;
  const o = n === "clippingAncestors" ? function(p, m) {
    const g = m.get(p);
    if (g)
      return g;
    let x = lg(p).filter((b) => Ki(b) && Zi(b) !== "body"), T = null;
    const y = ii(p).position === "fixed";
    let A = y ? Ns(p) : p;
    for (; Ki(A) && !wh(A); ) {
      const b = ii(A), v = Vf(A);
      (y ? v || T : v || b.position !== "static" || !T || !["absolute", "fixed"].includes(T.position)) ? T = b : x = x.filter((E) => E !== A), A = Ns(A);
    }
    return m.set(p, x), x;
  }(t, this._c) : [].concat(n), d = [...o, r], c = d[0], s = d.reduce((p, m) => {
    const g = Vp(t, m, i);
    return p.top = bs(g.top, p.top), p.right = $p(g.right, p.right), p.bottom = $p(g.bottom, p.bottom), p.left = bs(g.left, p.left), p;
  }, Vp(t, c, i));
  return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: n, strategy: r } = e;
  const i = ai(n), o = Yi(n);
  if (n === o)
    return t;
  let d = { scrollLeft: 0, scrollTop: 0 }, c = { x: 1, y: 1 };
  const s = { x: 0, y: 0 };
  if ((i || !i && r !== "fixed") && ((Zi(n) !== "body" || $c(o)) && (d = Hc(n)), ai(n))) {
    const p = Rs(n);
    c = ll(n), s.x = p.x + n.clientLeft, s.y = p.y + n.clientTop;
  }
  return { width: t.width * c.x, height: t.height * c.y, x: t.x * c.x - d.scrollLeft * c.x + s.x, y: t.y * c.y - d.scrollTop * c.y + s.y };
}, isElement: Ki, getDimensions: function(e) {
  return ai(e) ? Jy(e) : e.getBoundingClientRect();
}, getOffsetParent: jp, getDocumentElement: Yi, getScale: ll, async getElementRects(e) {
  let { reference: t, floating: n, strategy: r } = e;
  const i = this.getOffsetParent || jp, o = this.getDimensions;
  return { reference: iw(t, await i(n), r), floating: { x: 0, y: 0, ...await o(n) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => ii(e).direction === "rtl" }, Up = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = { platform: aw, ...n }, o = { ...i.platform, _c: r };
  return (async (d, c, s) => {
    const { placement: p = "bottom", strategy: m = "absolute", middleware: g = [], platform: x } = s, T = g.filter(Boolean), y = await (x.isRTL == null ? void 0 : x.isRTL(c));
    if (x == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), T.filter((L) => {
      let { name: B } = L;
      return B === "autoPlacement" || B === "flip";
    }).length > 1)
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    d && c || console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    let A = await x.getElementRects({ reference: d, floating: c, strategy: m }), { x: b, y: v } = Ip(A, p, y), E = p, N = {}, R = 0;
    for (let L = 0; L < T.length; L++) {
      const { name: B, fn: j } = T[L], { x: Z, y: re, data: X, reset: se } = await j({ x: b, y: v, initialPlacement: p, placement: E, strategy: m, middlewareData: N, rects: A, platform: x, elements: { reference: d, floating: c } });
      b = Z ?? b, v = re ?? v, N = { ...N, [B]: { ...N[B], ...X } }, R > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), se && R <= 50 && (R++, typeof se == "object" && (se.placement && (E = se.placement), se.rects && (A = se.rects === !0 ? await x.getElementRects({ reference: d, floating: c, strategy: m }) : se.rects), { x: b, y: v } = Ip(A, E, y)), L = -1);
    }
    return { x: b, y: v, placement: E, strategy: m, middlewareData: N };
  })(e, t, { ...i, platform: o });
};
var Wi, ja = { exports: {} }, Kp = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Wi = Kp, function() {
  var e = Ve, t = 60103, n = 60106;
  Wi.Fragment = 60107;
  var r = 60108, i = 60114, o = 60109, d = 60110, c = 60112, s = 60113, p = 60120, m = 60115, g = 60116, x = 60121, T = 60122, y = 60117, A = 60129, b = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var v = Symbol.for;
    t = v("react.element"), n = v("react.portal"), Wi.Fragment = v("react.fragment"), r = v("react.strict_mode"), i = v("react.profiler"), o = v("react.provider"), d = v("react.context"), c = v("react.forward_ref"), s = v("react.suspense"), p = v("react.suspense_list"), m = v("react.memo"), g = v("react.lazy"), x = v("react.block"), T = v("react.server.block"), y = v("react.fundamental"), v("react.scope"), v("react.opaque.id"), A = v("react.debug_trace_mode"), v("react.offscreen"), b = v("react.legacy_hidden");
  }
  var E = typeof Symbol == "function" && Symbol.iterator, N = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function R(ye) {
    for (var Ee = arguments.length, he = new Array(Ee > 1 ? Ee - 1 : 0), Be = 1; Be < Ee; Be++)
      he[Be - 1] = arguments[Be];
    L("error", ye, he);
  }
  function L(ye, Ee, he) {
    var Be = N.ReactDebugCurrentFrame, $e = "";
    if (re) {
      var tt = j(re.type), We = re._owner;
      $e += function(Je, Ke, Ye) {
        var Xe = "";
        if (Ke) {
          var Ae = Ke.fileName, Oe = Ae.replace(B, "");
          if (/^index\./.test(Oe)) {
            var lt = Ae.match(B);
            if (lt) {
              var ve = lt[1];
              ve && (Oe = ve.replace(B, "") + "/" + Oe);
            }
          }
          Xe = " (at " + Oe + ":" + Ke.lineNumber + ")";
        } else
          Ye && (Xe = " (created by " + Ye + ")");
        return `
    in ` + (Je || "Unknown") + Xe;
      }(tt, re._source, We && j(We.type));
    }
    ($e += Be.getStackAddendum()) !== "" && (Ee += "%s", he = he.concat([$e]));
    var Fe = he.map(function(Je) {
      return "" + Je;
    });
    Fe.unshift("Warning: " + Ee), Function.prototype.apply.call(console[ye], console, Fe);
  }
  var B = /^(.*)[\\\/]/;
  function j(ye) {
    if (ye == null)
      return null;
    if (typeof ye.tag == "number" && R("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof ye == "function")
      return ye.displayName || ye.name || null;
    if (typeof ye == "string")
      return ye;
    switch (ye) {
      case Wi.Fragment:
        return "Fragment";
      case n:
        return "Portal";
      case i:
        return "Profiler";
      case r:
        return "StrictMode";
      case s:
        return "Suspense";
      case p:
        return "SuspenseList";
    }
    if (typeof ye == "object")
      switch (ye.$$typeof) {
        case d:
          return "Context.Consumer";
        case o:
          return "Context.Provider";
        case c:
          return Be = ye, $e = ye.render, tt = "ForwardRef", We = $e.displayName || $e.name || "", Be.displayName || (We !== "" ? tt + "(" + We + ")" : tt);
        case m:
          return j(ye.type);
        case x:
          return j(ye.render);
        case g:
          var Ee = (he = ye)._status === 1 ? he._result : null;
          if (Ee)
            return j(Ee);
      }
    var he, Be, $e, tt, We;
    return null;
  }
  var Z = {};
  N.ReactDebugCurrentFrame;
  var re = null;
  function X(ye) {
    re = ye;
  }
  var se, Y, ie, I = N.ReactCurrentOwner, U = Object.prototype.hasOwnProperty, ue = { key: !0, ref: !0, __self: !0, __source: !0 };
  function te(ye, Ee, he, Be, $e) {
    var tt, We = {}, Fe = null, Je = null;
    for (tt in he !== void 0 && (Fe = "" + he), function(Xe) {
      if (U.call(Xe, "key")) {
        var Ae = Object.getOwnPropertyDescriptor(Xe, "key").get;
        if (Ae && Ae.isReactWarning)
          return !1;
      }
      return Xe.key !== void 0;
    }(Ee) && (Fe = "" + Ee.key), function(Xe) {
      if (U.call(Xe, "ref")) {
        var Ae = Object.getOwnPropertyDescriptor(Xe, "ref").get;
        if (Ae && Ae.isReactWarning)
          return !1;
      }
      return Xe.ref !== void 0;
    }(Ee) && (Je = Ee.ref, function(Xe, Ae) {
      if (typeof Xe.ref == "string" && I.current && Ae && I.current.stateNode !== Ae) {
        var Oe = j(I.current.type);
        ie[Oe] || (R('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', j(I.current.type), Xe.ref), ie[Oe] = !0);
      }
    }(Ee, $e)), Ee)
      U.call(Ee, tt) && !ue.hasOwnProperty(tt) && (We[tt] = Ee[tt]);
    if (ye && ye.defaultProps) {
      var Ke = ye.defaultProps;
      for (tt in Ke)
        We[tt] === void 0 && (We[tt] = Ke[tt]);
    }
    if (Fe || Je) {
      var Ye = typeof ye == "function" ? ye.displayName || ye.name || "Unknown" : ye;
      Fe && function(Xe, Ae) {
        var Oe = function() {
          se || (se = !0, R("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ae));
        };
        Oe.isReactWarning = !0, Object.defineProperty(Xe, "key", { get: Oe, configurable: !0 });
      }(We, Ye), Je && function(Xe, Ae) {
        var Oe = function() {
          Y || (Y = !0, R("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ae));
        };
        Oe.isReactWarning = !0, Object.defineProperty(Xe, "ref", { get: Oe, configurable: !0 });
      }(We, Ye);
    }
    return function(Xe, Ae, Oe, lt, ve, mt, ut) {
      var st = { $$typeof: t, type: Xe, key: Ae, ref: Oe, props: ut, _owner: mt, _store: {} };
      return Object.defineProperty(st._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(st, "_self", { configurable: !1, enumerable: !1, writable: !1, value: lt }), Object.defineProperty(st, "_source", { configurable: !1, enumerable: !1, writable: !1, value: ve }), Object.freeze && (Object.freeze(st.props), Object.freeze(st)), st;
    }(ye, Fe, Je, $e, Be, I.current, We);
  }
  ie = {};
  var J, Q = N.ReactCurrentOwner;
  function G(ye) {
    re = ye;
  }
  function ne(ye) {
    return typeof ye == "object" && ye !== null && ye.$$typeof === t;
  }
  function H() {
    if (Q.current) {
      var ye = j(Q.current.type);
      if (ye)
        return `

Check the render method of \`` + ye + "`.";
    }
    return "";
  }
  N.ReactDebugCurrentFrame, J = !1;
  var ce = {};
  function ke(ye, Ee) {
    if (ye._store && !ye._store.validated && ye.key == null) {
      ye._store.validated = !0;
      var he = function($e) {
        var tt = H();
        if (!tt) {
          var We = typeof $e == "string" ? $e : $e.displayName || $e.name;
          We && (tt = `

Check the top-level render call using <` + We + ">.");
        }
        return tt;
      }(Ee);
      if (!ce[he]) {
        ce[he] = !0;
        var Be = "";
        ye && ye._owner && ye._owner !== Q.current && (Be = " It was passed a child from " + j(ye._owner.type) + "."), G(ye), R('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', he, Be), G(null);
      }
    }
  }
  function Se(ye, Ee) {
    if (typeof ye == "object") {
      if (Array.isArray(ye))
        for (var he = 0; he < ye.length; he++) {
          var Be = ye[he];
          ne(Be) && ke(Be, Ee);
        }
      else if (ne(ye))
        ye._store && (ye._store.validated = !0);
      else if (ye) {
        var $e = function(Fe) {
          if (Fe === null || typeof Fe != "object")
            return null;
          var Je = E && Fe[E] || Fe["@@iterator"];
          return typeof Je == "function" ? Je : null;
        }(ye);
        if (typeof $e == "function" && $e !== ye.entries)
          for (var tt, We = $e.call(ye); !(tt = We.next()).done; )
            ne(tt.value) && ke(tt.value, Ee);
      }
    }
  }
  function xe(ye) {
    var Ee, he = ye.type;
    if (he != null && typeof he != "string") {
      if (typeof he == "function")
        Ee = he.propTypes;
      else {
        if (typeof he != "object" || he.$$typeof !== c && he.$$typeof !== m)
          return;
        Ee = he.propTypes;
      }
      if (Ee) {
        var Be = j(he);
        (function($e, tt, We, Fe, Je) {
          var Ke = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var Ye in $e)
            if (Ke($e, Ye)) {
              var Xe = void 0;
              try {
                if (typeof $e[Ye] != "function") {
                  var Ae = Error((Fe || "React class") + ": " + We + " type `" + Ye + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof $e[Ye] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Ae.name = "Invariant Violation", Ae;
                }
                Xe = $e[Ye](tt, Ye, Fe, We, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Oe) {
                Xe = Oe;
              }
              !Xe || Xe instanceof Error || (X(Je), R("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Fe || "React class", We, Ye, typeof Xe), X(null)), Xe instanceof Error && !(Xe.message in Z) && (Z[Xe.message] = !0, X(Je), R("Failed %s type: %s", We, Xe.message), X(null));
            }
        })(Ee, ye.props, "prop", Be, ye);
      } else
        he.PropTypes === void 0 || J || (J = !0, R("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", j(he) || "Unknown"));
      typeof he.getDefaultProps != "function" || he.getDefaultProps.isReactClassApproved || R("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function De(ye, Ee, he, Be, $e, tt) {
    var We = function(Oe) {
      return typeof Oe == "string" || typeof Oe == "function" || Oe === Wi.Fragment || Oe === i || Oe === A || Oe === r || Oe === s || Oe === p || Oe === b || typeof Oe == "object" && Oe !== null && (Oe.$$typeof === g || Oe.$$typeof === m || Oe.$$typeof === o || Oe.$$typeof === d || Oe.$$typeof === c || Oe.$$typeof === y || Oe.$$typeof === x || Oe[0] === T);
    }(ye);
    if (!We) {
      var Fe = "";
      (ye === void 0 || typeof ye == "object" && ye !== null && Object.keys(ye).length === 0) && (Fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
      var Je, Ke = function(Oe) {
        return Oe !== void 0 ? `

Check your code at ` + Oe.fileName.replace(/^.*[\\\/]/, "") + ":" + Oe.lineNumber + "." : "";
      }($e);
      Fe += Ke || H(), ye === null ? Je = "null" : Array.isArray(ye) ? Je = "array" : ye !== void 0 && ye.$$typeof === t ? (Je = "<" + (j(ye.type) || "Unknown") + " />", Fe = " Did you accidentally export a JSX literal instead of a component?") : Je = typeof ye, R("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Je, Fe);
    }
    var Ye = te(ye, Ee, he, $e, tt);
    if (Ye == null)
      return Ye;
    if (We) {
      var Xe = Ee.children;
      if (Xe !== void 0)
        if (Be)
          if (Array.isArray(Xe)) {
            for (var Ae = 0; Ae < Xe.length; Ae++)
              Se(Xe[Ae], ye);
            Object.freeze && Object.freeze(Xe);
          } else
            R("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          Se(Xe, ye);
    }
    return ye === Wi.Fragment ? function(Oe) {
      for (var lt = Object.keys(Oe.props), ve = 0; ve < lt.length; ve++) {
        var mt = lt[ve];
        if (mt !== "children" && mt !== "key") {
          G(Oe), R("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", mt), G(null);
          break;
        }
      }
      Oe.ref !== null && (G(Oe), R("Invalid attribute `ref` supplied to `React.Fragment`."), G(null));
    }(Ye) : xe(Ye), Ye;
  }
  var je = function(ye, Ee, he) {
    return De(ye, Ee, he, !1);
  }, Ce = function(ye, Ee, he) {
    return De(ye, Ee, he, !0);
  };
  Wi.jsx = je, Wi.jsxs = Ce;
}(), ja.exports = Kp;
var tf, sg = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
tf = sg, function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var n = [], r = 0; r < arguments.length; r++) {
      var i = arguments[r];
      if (i) {
        var o = typeof i;
        if (o === "string" || o === "number")
          n.push(i);
        else if (Array.isArray(i)) {
          if (i.length) {
            var d = t.apply(null, i);
            d && n.push(d);
          }
        } else if (o === "object") {
          if (i.toString !== Object.prototype.toString && !i.toString.toString().includes("[native code]")) {
            n.push(i.toString());
            continue;
          }
          for (var c in i)
            e.call(i, c) && i[c] && n.push(c);
        }
      }
    }
    return n.join(" ");
  }
  tf.exports ? (t.default = t, tf.exports = t) : window.classNames = t;
}();
var Yp = sg.exports;
const Gp = (e, t, n) => {
  let r = null;
  return function(...i) {
    r && clearTimeout(r), r = setTimeout(() => {
      r = null, n || e.apply(this, i);
    }, t);
  };
}, ow = ({ content: e }) => ja.exports.jsx("span", { dangerouslySetInnerHTML: { __html: e } }), lw = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} }, sw = de.createContext({ getTooltipData: () => lw });
function ug(e = "DEFAULT_TOOLTIP_ID") {
  return de.useContext(sw).getTooltipData(e);
}
const Xp = async ({ elementReference: e = null, tooltipReference: t = null, tooltipArrowReference: n = null, place: r = "top", offset: i = 10, strategy: o = "absolute", middlewares: d = [tw(Number(i)), ew(), nw({ padding: 5 })] }) => {
  if (!e)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  if (t === null)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  const c = d;
  return n ? (c.push({ name: "arrow", options: s = { element: n, padding: 5 }, async fn(p) {
    const { element: m, padding: g = 0 } = s || {}, { x, y: T, placement: y, rects: A, platform: b } = p;
    if (m == null)
      return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."), {};
    const v = Zy(g), E = { x, y: T }, N = _s(y), R = Sh(N), L = await b.getDimensions(m), B = N === "y" ? "top" : "left", j = N === "y" ? "bottom" : "right", Z = A.reference[R] + A.reference[N] - E[N] - A.floating[R], re = E[N] - A.reference[N], X = await (b.getOffsetParent == null ? void 0 : b.getOffsetParent(m));
    let se = X ? N === "y" ? X.clientHeight || 0 : X.clientWidth || 0 : 0;
    se === 0 && (se = A.floating[R]);
    const Y = Z / 2 - re / 2, ie = v[B], I = se - L[R] - v[j], U = se / 2 - L[R] / 2 + Y, ue = Hf(ie, U, I), te = Ds(y) != null && U != ue && A.reference[R] / 2 - (U < ie ? v[B] : v[j]) - L[R] / 2 < 0;
    return { [N]: E[N] - (te ? U < ie ? ie - U : I - U : 0), data: { [N]: ue, centerOffset: U - ue } };
  } }), Up(e, t, { placement: r, strategy: o, middleware: c }).then(({ x: p, y: m, placement: g, middlewareData: x }) => {
    var T, y;
    const A = { left: `${p}px`, top: `${m}px` }, { x: b, y: v } = (T = x.arrow) !== null && T !== void 0 ? T : { x: 0, y: 0 };
    return { tooltipStyles: A, tooltipArrowStyles: { left: b != null ? `${b}px` : "", top: v != null ? `${v}px` : "", right: "", bottom: "", [(y = { top: "bottom", right: "left", bottom: "top", left: "right" }[g.split("-")[0]]) !== null && y !== void 0 ? y : "bottom"]: "-4px" } };
  })) : Up(e, t, { placement: "bottom", strategy: o, middleware: c }).then(({ x: p, y: m }) => ({ tooltipStyles: { left: `${p}px`, top: `${m}px` }, tooltipArrowStyles: {} }));
  var s;
};
var _a = { tooltip: "styles-module_tooltip__mnnfp", fixed: "styles-module_fixed__7ciUi", arrow: "styles-module_arrow__K0L3T", "no-arrow": "styles-module_no-arrow__KcFZN", clickable: "styles-module_clickable__Bv9o7", show: "styles-module_show__2NboJ", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
const qp = ({ id: e, className: t, classNameArrow: n, variant: r = "dark", anchorId: i, anchorSelect: o, place: d = "top", offset: c = 10, events: s = ["hover"], positionStrategy: p = "absolute", middlewares: m, wrapper: g, children: x = null, delayShow: T = 0, delayHide: y = 0, float: A = !1, noArrow: b = !1, clickable: v = !1, closeOnEsc: E = !1, style: N, position: R, afterShow: L, afterHide: B, content: j, html: Z, isOpen: re, setIsOpen: X, activeAnchor: se, setActiveAnchor: Y }) => {
  const ie = de.useRef(null), I = de.useRef(null), U = de.useRef(null), ue = de.useRef(null), [te, J] = de.useState({}), [Q, G] = de.useState({}), [ne, H] = de.useState(!1), [ce, ke] = de.useState(!1), Se = de.useRef(!1), xe = de.useRef(null), { anchorRefs: De, setActiveAnchor: je } = ug(e), Ce = de.useRef(!1), [ye, Ee] = de.useState([]), he = de.useRef(!1);
  de.useLayoutEffect(() => (he.current = !0, () => {
    he.current = !1;
  }), []), de.useEffect(() => {
    if (!ne) {
      const ve = setTimeout(() => {
        ke(!1);
      }, 150);
      return () => {
        clearTimeout(ve);
      };
    }
    return () => null;
  }, [ne]);
  const Be = (ve) => {
    he.current && (ve && ke(!0), setTimeout(() => {
      he.current && (X == null || X(ve), re === void 0 && H(ve));
    }, 10));
  };
  de.useEffect(() => {
    if (re === void 0)
      return () => null;
    re && ke(!0);
    const ve = setTimeout(() => {
      H(re);
    }, 10);
    return () => {
      clearTimeout(ve);
    };
  }, [re]), de.useEffect(() => {
    ne !== Se.current && (Se.current = ne, ne ? L == null || L() : B == null || B());
  }, [ne]);
  const $e = (ve = y) => {
    ue.current && clearTimeout(ue.current), ue.current = setTimeout(() => {
      Ce.current || Be(!1);
    }, ve);
  }, tt = (ve) => {
    var mt;
    if (!ve)
      return;
    T ? (U.current && clearTimeout(U.current), U.current = setTimeout(() => {
      Be(!0);
    }, T)) : Be(!0);
    const ut = (mt = ve.currentTarget) !== null && mt !== void 0 ? mt : ve.target;
    Y(ut), je({ current: ut }), ue.current && clearTimeout(ue.current);
  }, We = () => {
    v ? $e(y || 100) : y ? $e() : Be(!1), U.current && clearTimeout(U.current);
  }, Fe = ({ x: ve, y: mt }) => {
    Xp({ place: d, offset: c, elementReference: { getBoundingClientRect: () => ({ x: ve, y: mt, width: 0, height: 0, top: mt, left: ve, right: ve, bottom: mt }) }, tooltipReference: ie.current, tooltipArrowReference: I.current, strategy: p, middlewares: m }).then((ut) => {
      Object.keys(ut.tooltipStyles).length && J(ut.tooltipStyles), Object.keys(ut.tooltipArrowStyles).length && G(ut.tooltipArrowStyles);
    });
  }, Je = (ve) => {
    if (!ve)
      return;
    const mt = ve, ut = { x: mt.clientX, y: mt.clientY };
    Fe(ut), xe.current = ut;
  }, Ke = (ve) => {
    tt(ve), y && $e();
  }, Ye = (ve) => {
    const mt = document.querySelector(`[id='${i}']`);
    mt != null && mt.contains(ve.target) || ye.some((ut) => ut.contains(ve.target)) || Be(!1);
  }, Xe = (ve) => {
    ve.key === "Escape" && Be(!1);
  }, Ae = Gp(tt, 50), Oe = Gp(We, 50);
  de.useEffect(() => {
    var ve, mt;
    const ut = new Set(De);
    ye.forEach((It) => {
      ut.add({ current: It });
    });
    const st = document.querySelector(`[id='${i}']`);
    st && ut.add({ current: st }), E && window.addEventListener("keydown", Xe);
    const Lt = [];
    s.find((It) => It === "click") && (window.addEventListener("click", Ye), Lt.push({ event: "click", listener: Ke })), s.find((It) => It === "hover") && (Lt.push({ event: "mouseenter", listener: Ae }, { event: "mouseleave", listener: Oe }, { event: "focus", listener: Ae }, { event: "blur", listener: Oe }), A && Lt.push({ event: "mousemove", listener: Je }));
    const Kt = () => {
      Ce.current = !0;
    }, Xt = () => {
      Ce.current = !1, We();
    };
    return v && ((ve = ie.current) === null || ve === void 0 || ve.addEventListener("mouseenter", Kt), (mt = ie.current) === null || mt === void 0 || mt.addEventListener("mouseleave", Xt)), Lt.forEach(({ event: It, listener: ln }) => {
      ut.forEach((Tt) => {
        var Ot;
        (Ot = Tt.current) === null || Ot === void 0 || Ot.addEventListener(It, ln);
      });
    }), () => {
      var It, ln;
      s.find((Tt) => Tt === "click") && window.removeEventListener("click", Ye), E && window.removeEventListener("keydown", Xe), v && ((It = ie.current) === null || It === void 0 || It.removeEventListener("mouseenter", Kt), (ln = ie.current) === null || ln === void 0 || ln.removeEventListener("mouseleave", Xt)), Lt.forEach(({ event: Tt, listener: Ot }) => {
        ut.forEach((_t) => {
          var an;
          (an = _t.current) === null || an === void 0 || an.removeEventListener(Tt, Ot);
        });
      });
    };
  }, [ce, De, ye, E, s]), de.useEffect(() => {
    let ve = o ?? "";
    !ve && e && (ve = `[data-tooltip-id='${e}']`);
    const mt = new MutationObserver((ut) => {
      const st = [];
      ut.forEach((Lt) => {
        if (Lt.type === "attributes" && Lt.attributeName === "data-tooltip-id" && Lt.target.getAttribute("data-tooltip-id") === e && st.push(Lt.target), Lt.type === "childList" && (se && [...Lt.removedNodes].some((Kt) => !!Kt.contains(se) && (ke(!1), Be(!1), Y(null), !0)), ve))
          try {
            const Kt = [...Lt.addedNodes].filter((Xt) => Xt.nodeType === 1);
            st.push(...Kt.filter((Xt) => Xt.matches(ve))), st.push(...Kt.flatMap((Xt) => [...Xt.querySelectorAll(ve)]));
          } catch {
          }
      }), st.length && Ee((Lt) => [...Lt, ...st]);
    });
    return mt.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"] }), () => {
      mt.disconnect();
    };
  }, [e, o, se]), de.useEffect(() => {
    R ? Fe(R) : A ? xe.current && Fe(xe.current) : Xp({ place: d, offset: c, elementReference: se, tooltipReference: ie.current, tooltipArrowReference: I.current, strategy: p, middlewares: m }).then((ve) => {
      he.current && (Object.keys(ve.tooltipStyles).length && J(ve.tooltipStyles), Object.keys(ve.tooltipArrowStyles).length && G(ve.tooltipArrowStyles));
    });
  }, [ne, se, j, Z, d, c, p, R]), de.useEffect(() => {
    var ve;
    const mt = document.querySelector(`[id='${i}']`), ut = [...ye, mt];
    se && ut.includes(se) || Y((ve = ye[0]) !== null && ve !== void 0 ? ve : mt);
  }, [i, ye, se]), de.useEffect(() => () => {
    U.current && clearTimeout(U.current), ue.current && clearTimeout(ue.current);
  }, []), de.useEffect(() => {
    let ve = o;
    if (!ve && e && (ve = `[data-tooltip-id='${e}']`), ve)
      try {
        const mt = Array.from(document.querySelectorAll(ve));
        Ee(mt);
      } catch {
        Ee([]);
      }
  }, [e, o]);
  const lt = !!(Z || j || x) && ne && Object.keys(te).length > 0;
  return ce ? ja.exports.jsxs(g, { id: e, role: "tooltip", className: Yp("react-tooltip", _a.tooltip, _a[r], t, { [_a.show]: lt, [_a.fixed]: p === "fixed", [_a.clickable]: v }), style: { ...N, ...te }, ref: ie, children: [Z && ja.exports.jsx(ow, { content: Z }) || j || x, ja.exports.jsx(g, { className: Yp("react-tooltip-arrow", _a.arrow, n, { [_a["no-arrow"]]: b }), style: Q, ref: I })] }) : null;
}, xc = ({ id: e, anchorId: t, anchorSelect: n, content: r, html: i, className: o, classNameArrow: d, variant: c = "dark", place: s = "top", offset: p = 10, wrapper: m = "div", children: g = null, events: x = ["hover"], positionStrategy: T = "absolute", middlewares: y, delayShow: A = 0, delayHide: b = 0, float: v = !1, noArrow: E = !1, clickable: N = !1, closeOnEsc: R = !1, style: L, position: B, isOpen: j, setIsOpen: Z, afterShow: re, afterHide: X }) => {
  const [se, Y] = de.useState(r), [ie, I] = de.useState(i), [U, ue] = de.useState(s), [te, J] = de.useState(c), [Q, G] = de.useState(p), [ne, H] = de.useState(A), [ce, ke] = de.useState(b), [Se, xe] = de.useState(v), [De, je] = de.useState(m), [Ce, ye] = de.useState(x), [Ee, he] = de.useState(T), [Be, $e] = de.useState(null), { anchorRefs: tt, activeAnchor: We } = ug(e), Fe = (Ye) => Ye == null ? void 0 : Ye.getAttributeNames().reduce((Xe, Ae) => {
    var Oe;
    return Ae.startsWith("data-tooltip-") && (Xe[Ae.replace(/^data-tooltip-/, "")] = (Oe = Ye == null ? void 0 : Ye.getAttribute(Ae)) !== null && Oe !== void 0 ? Oe : null), Xe;
  }, {}), Je = (Ye) => {
    const Xe = { place: (Ae) => {
      var Oe;
      ue((Oe = Ae) !== null && Oe !== void 0 ? Oe : s);
    }, content: (Ae) => {
      Y(Ae ?? r);
    }, html: (Ae) => {
      I(Ae ?? i);
    }, variant: (Ae) => {
      var Oe;
      J((Oe = Ae) !== null && Oe !== void 0 ? Oe : c);
    }, offset: (Ae) => {
      G(Ae === null ? p : Number(Ae));
    }, wrapper: (Ae) => {
      var Oe;
      je((Oe = Ae) !== null && Oe !== void 0 ? Oe : m);
    }, events: (Ae) => {
      const Oe = Ae == null ? void 0 : Ae.split(" ");
      ye(Oe ?? x);
    }, "position-strategy": (Ae) => {
      var Oe;
      he((Oe = Ae) !== null && Oe !== void 0 ? Oe : T);
    }, "delay-show": (Ae) => {
      H(Ae === null ? A : Number(Ae));
    }, "delay-hide": (Ae) => {
      ke(Ae === null ? b : Number(Ae));
    }, float: (Ae) => {
      xe(Ae === null ? v : !!Ae);
    } };
    Object.values(Xe).forEach((Ae) => Ae(null)), Object.entries(Ye).forEach(([Ae, Oe]) => {
      var lt;
      (lt = Xe[Ae]) === null || lt === void 0 || lt.call(Xe, Oe);
    });
  };
  de.useEffect(() => {
    Y(r);
  }, [r]), de.useEffect(() => {
    I(i);
  }, [i]), de.useEffect(() => {
    ue(s);
  }, [s]), de.useEffect(() => {
    var Ye;
    const Xe = new Set(tt);
    let Ae = n;
    if (!Ae && e && (Ae = `[data-tooltip-id='${e}']`), Ae)
      try {
        document.querySelectorAll(Ae).forEach((ut) => {
          Xe.add({ current: ut });
        });
      } catch {
        console.warn(`[react-tooltip] "${n}" is not a valid CSS selector`);
      }
    const Oe = document.querySelector(`[id='${t}']`);
    if (Oe && Xe.add({ current: Oe }), !Xe.size)
      return () => null;
    const lt = (Ye = Be ?? Oe) !== null && Ye !== void 0 ? Ye : We.current, ve = new MutationObserver((ut) => {
      ut.forEach((st) => {
        var Lt;
        if (!lt || st.type !== "attributes" || !(!((Lt = st.attributeName) === null || Lt === void 0) && Lt.startsWith("data-tooltip-")))
          return;
        const Kt = Fe(lt);
        Je(Kt);
      });
    }), mt = { attributes: !0, childList: !1, subtree: !1 };
    if (lt) {
      const ut = Fe(lt);
      Je(ut), ve.observe(lt, mt);
    }
    return () => {
      ve.disconnect();
    };
  }, [tt, We, Be, t, n]);
  const Ke = { id: e, anchorId: t, anchorSelect: n, className: o, classNameArrow: d, content: se, html: ie, place: U, variant: te, offset: Q, wrapper: De, events: Ce, positionStrategy: Ee, middlewares: y, delayShow: ne, delayHide: ce, float: Se, noArrow: E, clickable: N, closeOnEsc: R, style: L, position: B, isOpen: j, setIsOpen: Z, afterShow: re, afterHide: X, activeAnchor: Be, setActiveAnchor: (Ye) => $e(Ye) };
  return g ? ja.exports.jsx(qp, { ...Ke, children: g }) : ja.exports.jsx(qp, { ...Ke });
};
function Zp(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function uw(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function nf(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      (r = +r) && (n += r);
  else {
    let r = -1;
    for (let i of e)
      (i = +t(i, ++r, e)) && (n += i);
  }
  return n;
}
function cw(e) {
  return e.depth;
}
function dw(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function zu(e) {
  return function() {
    return e;
  };
}
function Qp(e, t) {
  return bc(e.source, t.source) || e.index - t.index;
}
function Jp(e, t) {
  return bc(e.target, t.target) || e.index - t.index;
}
function bc(e, t) {
  return e.y0 - t.y0;
}
function rf(e) {
  return e.value;
}
function fw(e) {
  return e.index;
}
function hw(e) {
  return e.nodes;
}
function pw(e) {
  return e.links;
}
function em(e, t) {
  const n = e.get(t);
  if (!n)
    throw new Error("missing: " + t);
  return n;
}
function tm({ nodes: e }) {
  for (const t of e) {
    let n = t.y0, r = n;
    for (const i of t.sourceLinks)
      i.y0 = n + i.width / 2, n += i.width;
    for (const i of t.targetLinks)
      i.y1 = r + i.width / 2, r += i.width;
  }
}
function mw() {
  let e = 0, t = 0, n = 1, r = 1, i = 24, o = 8, d, c = fw, s = dw, p, m, g = hw, x = pw, T = 6;
  function y() {
    const U = { nodes: g.apply(null, arguments), links: x.apply(null, arguments) };
    return A(U), b(U), v(U), E(U), L(U), tm(U), U;
  }
  y.update = function(U) {
    return tm(U), U;
  }, y.nodeId = function(U) {
    return arguments.length ? (c = typeof U == "function" ? U : zu(U), y) : c;
  }, y.nodeAlign = function(U) {
    return arguments.length ? (s = typeof U == "function" ? U : zu(U), y) : s;
  }, y.nodeSort = function(U) {
    return arguments.length ? (p = U, y) : p;
  }, y.nodeWidth = function(U) {
    return arguments.length ? (i = +U, y) : i;
  }, y.nodePadding = function(U) {
    return arguments.length ? (o = d = +U, y) : o;
  }, y.nodes = function(U) {
    return arguments.length ? (g = typeof U == "function" ? U : zu(U), y) : g;
  }, y.links = function(U) {
    return arguments.length ? (x = typeof U == "function" ? U : zu(U), y) : x;
  }, y.linkSort = function(U) {
    return arguments.length ? (m = U, y) : m;
  }, y.size = function(U) {
    return arguments.length ? (e = t = 0, n = +U[0], r = +U[1], y) : [n - e, r - t];
  }, y.extent = function(U) {
    return arguments.length ? (e = +U[0][0], n = +U[1][0], t = +U[0][1], r = +U[1][1], y) : [[e, t], [n, r]];
  }, y.iterations = function(U) {
    return arguments.length ? (T = +U, y) : T;
  };
  function A({ nodes: U, links: ue }) {
    for (const [J, Q] of U.entries())
      Q.index = J, Q.sourceLinks = [], Q.targetLinks = [];
    const te = new Map(U.map((J, Q) => [c(J, Q, U), J]));
    for (const [J, Q] of ue.entries()) {
      Q.index = J;
      let { source: G, target: ne } = Q;
      typeof G != "object" && (G = Q.source = em(te, G)), typeof ne != "object" && (ne = Q.target = em(te, ne)), G.sourceLinks.push(Q), ne.targetLinks.push(Q);
    }
    if (m != null)
      for (const { sourceLinks: J, targetLinks: Q } of U)
        J.sort(m), Q.sort(m);
  }
  function b({ nodes: U }) {
    for (const ue of U)
      ue.value = ue.fixedValue === void 0 ? Math.max(nf(ue.sourceLinks, rf), nf(ue.targetLinks, rf)) : ue.fixedValue;
  }
  function v({ nodes: U }) {
    const ue = U.length;
    let te = new Set(U), J = /* @__PURE__ */ new Set(), Q = 0;
    for (; te.size; ) {
      for (const G of te) {
        G.depth = Q;
        for (const { target: ne } of G.sourceLinks)
          J.add(ne);
      }
      if (++Q > ue)
        throw new Error("circular link");
      te = J, J = /* @__PURE__ */ new Set();
    }
  }
  function E({ nodes: U }) {
    const ue = U.length;
    let te = new Set(U), J = /* @__PURE__ */ new Set(), Q = 0;
    for (; te.size; ) {
      for (const G of te) {
        G.height = Q;
        for (const { source: ne } of G.targetLinks)
          J.add(ne);
      }
      if (++Q > ue)
        throw new Error("circular link");
      te = J, J = /* @__PURE__ */ new Set();
    }
  }
  function N({ nodes: U }) {
    const ue = Zp(U, (Q) => Q.depth) + 1, te = (n - e - i) / (ue - 1), J = new Array(ue);
    for (const Q of U) {
      const G = Math.max(0, Math.min(ue - 1, Math.floor(s.call(null, Q, ue))));
      Q.layer = G, Q.x0 = e + G * te, Q.x1 = Q.x0 + i, J[G] ? J[G].push(Q) : J[G] = [Q];
    }
    if (p)
      for (const Q of J)
        Q.sort(p);
    return J;
  }
  function R(U) {
    const ue = uw(U, (te) => (r - t - (te.length - 1) * d) / nf(te, rf));
    for (const te of U) {
      let J = t;
      for (const Q of te) {
        Q.y0 = J, Q.y1 = J + Q.value * ue, J = Q.y1 + d;
        for (const G of Q.sourceLinks)
          G.width = G.value * ue;
      }
      J = (r - J + d) / (te.length + 1);
      for (let Q = 0; Q < te.length; ++Q) {
        const G = te[Q];
        G.y0 += J * (Q + 1), G.y1 += J * (Q + 1);
      }
      Y(te);
    }
  }
  function L(U) {
    const ue = N(U);
    d = Math.min(o, (r - t) / (Zp(ue, (te) => te.length) - 1)), R(ue);
    for (let te = 0; te < T; ++te) {
      const J = Math.pow(0.99, te), Q = Math.max(1 - J, (te + 1) / T);
      j(ue, J, Q), B(ue, J, Q);
    }
  }
  function B(U, ue, te) {
    for (let J = 1, Q = U.length; J < Q; ++J) {
      const G = U[J];
      for (const ne of G) {
        let H = 0, ce = 0;
        for (const { source: Se, value: xe } of ne.targetLinks) {
          let De = xe * (ne.layer - Se.layer);
          H += ie(Se, ne) * De, ce += De;
        }
        if (!(ce > 0))
          continue;
        let ke = (H / ce - ne.y0) * ue;
        ne.y0 += ke, ne.y1 += ke, se(ne);
      }
      p === void 0 && G.sort(bc), Z(G, te);
    }
  }
  function j(U, ue, te) {
    for (let J = U.length, Q = J - 2; Q >= 0; --Q) {
      const G = U[Q];
      for (const ne of G) {
        let H = 0, ce = 0;
        for (const { target: Se, value: xe } of ne.sourceLinks) {
          let De = xe * (Se.layer - ne.layer);
          H += I(ne, Se) * De, ce += De;
        }
        if (!(ce > 0))
          continue;
        let ke = (H / ce - ne.y0) * ue;
        ne.y0 += ke, ne.y1 += ke, se(ne);
      }
      p === void 0 && G.sort(bc), Z(G, te);
    }
  }
  function Z(U, ue) {
    const te = U.length >> 1, J = U[te];
    X(U, J.y0 - d, te - 1, ue), re(U, J.y1 + d, te + 1, ue), X(U, r, U.length - 1, ue), re(U, t, 0, ue);
  }
  function re(U, ue, te, J) {
    for (; te < U.length; ++te) {
      const Q = U[te], G = (ue - Q.y0) * J;
      G > 1e-6 && (Q.y0 += G, Q.y1 += G), ue = Q.y1 + d;
    }
  }
  function X(U, ue, te, J) {
    for (; te >= 0; --te) {
      const Q = U[te], G = (Q.y1 - ue) * J;
      G > 1e-6 && (Q.y0 -= G, Q.y1 -= G), ue = Q.y0 - d;
    }
  }
  function se({ sourceLinks: U, targetLinks: ue }) {
    if (m === void 0) {
      for (const { source: { sourceLinks: te } } of ue)
        te.sort(Jp);
      for (const { target: { targetLinks: te } } of U)
        te.sort(Qp);
    }
  }
  function Y(U) {
    if (m === void 0)
      for (const { sourceLinks: ue, targetLinks: te } of U)
        ue.sort(Jp), te.sort(Qp);
  }
  function ie(U, ue) {
    let te = U.y0 - (U.sourceLinks.length - 1) * d / 2;
    for (const { target: J, width: Q } of U.sourceLinks) {
      if (J === ue)
        break;
      te += Q + d;
    }
    for (const { source: J, width: Q } of ue.targetLinks) {
      if (J === U)
        break;
      te -= Q;
    }
    return te;
  }
  function I(U, ue) {
    let te = ue.y0 - (ue.targetLinks.length - 1) * d / 2;
    for (const { source: J, width: Q } of ue.targetLinks) {
      if (J === U)
        break;
      te += Q + d;
    }
    for (const { target: J, width: Q } of U.sourceLinks) {
      if (J === ue)
        break;
      te -= Q;
    }
    return te;
  }
  return y;
}
function yw(e) {
  return [e.source.x1, e.y0];
}
function gw(e) {
  return [e.target.x0, e.y1];
}
function vw() {
  return p0().source(yw).target(gw);
}
const xw = () => {
  const { config: e, handleChartTabbing: t, legendId: n } = de.useContext(vt), [r, i] = de.useState(!1), o = /* @__PURE__ */ z(Ue, { children: [
    "For best viewing we recommend portrait mode. If you are unable to put your device in portrait mode, please review the ",
    /* @__PURE__ */ a("a", { href: `#${t(e, n)}`, children: "data table" }),
    " below.",
    " ",
    /* @__PURE__ */ a("a", { onClick: () => i(!1), href: "#!", children: "Close this alert" }),
    " ",
    "to continue viewing the chart."
  ] }), d = () => {
    i(!1);
  }, c = r ? /* @__PURE__ */ z("div", { className: "alert alert-warning alert-dismissible", role: "alert", children: [
    /* @__PURE__ */ a("p", { style: { padding: "35px" }, children: o }),
    /* @__PURE__ */ a("button", { type: "button", className: "close", "data-dismiss": "alert", "aria-label": "Close", onClick: d, children: /* @__PURE__ */ a("span", { "aria-hidden": "true", children: "×" }) })
  ] }) : null;
  return de.useEffect(() => {
    const s = () => {
      window.innerWidth < 768 && window.innerHeight > window.innerWidth ? i(!0) : i(!1);
    };
    return window.addEventListener("resize", s), s(), () => {
      window.removeEventListener("resize", s);
    };
  }, []), {
    setShowAlert: i,
    showAlert: r,
    handleCloseModal: d,
    alertMessage: o,
    alert: c
  };
};
var Qi = {}, Oa = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nm;
function bw() {
  if (nm)
    return Oa;
  nm = 1;
  var e = de;
  function t(S) {
    for (var _ = "https://reactjs.org/docs/error-decoder.html?invariant=" + S, D = 1; D < arguments.length; D++)
      _ += "&args[]=" + encodeURIComponent(arguments[D]);
    return "Minified React error #" + S + "; visit " + _ + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = Object.prototype.hasOwnProperty, r = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, i = {}, o = {};
  function d(S) {
    return n.call(o, S) ? !0 : n.call(i, S) ? !1 : r.test(S) ? o[S] = !0 : (i[S] = !0, !1);
  }
  function c(S, _, D, K, pe, O, $) {
    this.acceptsBooleans = _ === 2 || _ === 3 || _ === 4, this.attributeName = K, this.attributeNamespace = pe, this.mustUseProperty = D, this.propertyName = S, this.type = _, this.sanitizeURL = O, this.removeEmptyString = $;
  }
  var s = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(S) {
    s[S] = new c(S, 0, !1, S, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(S) {
    var _ = S[0];
    s[_] = new c(_, 1, !1, S[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(S) {
    s[S] = new c(S, 2, !1, S.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(S) {
    s[S] = new c(S, 2, !1, S, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(S) {
    s[S] = new c(S, 3, !1, S.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(S) {
    s[S] = new c(S, 3, !0, S, null, !1, !1);
  }), ["capture", "download"].forEach(function(S) {
    s[S] = new c(S, 4, !1, S, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(S) {
    s[S] = new c(S, 6, !1, S, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(S) {
    s[S] = new c(S, 5, !1, S.toLowerCase(), null, !1, !1);
  });
  var p = /[\-:]([a-z])/g;
  function m(S) {
    return S[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(S) {
    var _ = S.replace(
      p,
      m
    );
    s[_] = new c(_, 1, !1, S, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(S) {
    var _ = S.replace(p, m);
    s[_] = new c(_, 1, !1, S, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(S) {
    var _ = S.replace(p, m);
    s[_] = new c(_, 1, !1, S, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(S) {
    s[S] = new c(S, 1, !1, S.toLowerCase(), null, !1, !1);
  }), s.xlinkHref = new c("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(S) {
    s[S] = new c(S, 1, !1, S.toLowerCase(), null, !0, !0);
  });
  var g = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, x = ["Webkit", "ms", "Moz", "O"];
  Object.keys(g).forEach(function(S) {
    x.forEach(function(_) {
      _ = _ + S.charAt(0).toUpperCase() + S.substring(1), g[_] = g[S];
    });
  });
  var T = /["'&<>]/;
  function y(S) {
    if (typeof S == "boolean" || typeof S == "number")
      return "" + S;
    S = "" + S;
    var _ = T.exec(S);
    if (_) {
      var D = "", K, pe = 0;
      for (K = _.index; K < S.length; K++) {
        switch (S.charCodeAt(K)) {
          case 34:
            _ = "&quot;";
            break;
          case 38:
            _ = "&amp;";
            break;
          case 39:
            _ = "&#x27;";
            break;
          case 60:
            _ = "&lt;";
            break;
          case 62:
            _ = "&gt;";
            break;
          default:
            continue;
        }
        pe !== K && (D += S.substring(pe, K)), pe = K + 1, D += _;
      }
      S = pe !== K ? D + S.substring(pe, K) : D;
    }
    return S;
  }
  var A = /([A-Z])/g, b = /^ms-/, v = Array.isArray;
  function E(S, _) {
    return { insertionMode: S, selectedValue: _ };
  }
  function N(S, _, D) {
    switch (_) {
      case "select":
        return E(1, D.value != null ? D.value : D.defaultValue);
      case "svg":
        return E(2, null);
      case "math":
        return E(3, null);
      case "foreignObject":
        return E(1, null);
      case "table":
        return E(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return E(5, null);
      case "colgroup":
        return E(7, null);
      case "tr":
        return E(6, null);
    }
    return 4 <= S.insertionMode || S.insertionMode === 0 ? E(1, null) : S;
  }
  var R = /* @__PURE__ */ new Map();
  function L(S, _, D) {
    if (typeof D != "object")
      throw Error(t(62));
    _ = !0;
    for (var K in D)
      if (n.call(D, K)) {
        var pe = D[K];
        if (pe != null && typeof pe != "boolean" && pe !== "") {
          if (K.indexOf("--") === 0) {
            var O = y(K);
            pe = y(("" + pe).trim());
          } else {
            O = K;
            var $ = R.get(O);
            $ !== void 0 || ($ = y(O.replace(A, "-$1").toLowerCase().replace(b, "-ms-")), R.set(O, $)), O = $, pe = typeof pe == "number" ? pe === 0 || n.call(g, K) ? "" + pe : pe + "px" : y(("" + pe).trim());
          }
          _ ? (_ = !1, S.push(' style="', O, ":", pe)) : S.push(";", O, ":", pe);
        }
      }
    _ || S.push('"');
  }
  function B(S, _, D, K) {
    switch (D) {
      case "style":
        L(S, _, K);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < D.length) || D[0] !== "o" && D[0] !== "O" || D[1] !== "n" && D[1] !== "N") {
      if (_ = s.hasOwnProperty(D) ? s[D] : null, _ !== null) {
        switch (typeof K) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!_.acceptsBooleans)
              return;
        }
        switch (D = _.attributeName, _.type) {
          case 3:
            K && S.push(" ", D, '=""');
            break;
          case 4:
            K === !0 ? S.push(" ", D, '=""') : K !== !1 && S.push(" ", D, '="', y(K), '"');
            break;
          case 5:
            isNaN(K) || S.push(" ", D, '="', y(K), '"');
            break;
          case 6:
            !isNaN(K) && 1 <= K && S.push(" ", D, '="', y(K), '"');
            break;
          default:
            _.sanitizeURL && (K = "" + K), S.push(" ", D, '="', y(K), '"');
        }
      } else if (d(D)) {
        switch (typeof K) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (_ = D.toLowerCase().slice(0, 5), _ !== "data-" && _ !== "aria-")
              return;
        }
        S.push(" ", D, '="', y(K), '"');
      }
    }
  }
  function j(S, _, D) {
    if (_ != null) {
      if (D != null)
        throw Error(t(60));
      if (typeof _ != "object" || !("__html" in _))
        throw Error(t(61));
      _ = _.__html, _ != null && S.push("" + _);
    }
  }
  function Z(S) {
    var _ = "";
    return e.Children.forEach(S, function(D) {
      D != null && (_ += D);
    }), _;
  }
  function re(S, _, D, K) {
    S.push(Y(D));
    var pe = D = null, O;
    for (O in _)
      if (n.call(_, O)) {
        var $ = _[O];
        if ($ != null)
          switch (O) {
            case "children":
              D = $;
              break;
            case "dangerouslySetInnerHTML":
              pe = $;
              break;
            default:
              B(S, K, O, $);
          }
      }
    return S.push(">"), j(S, pe, D), typeof D == "string" ? (S.push(y(D)), null) : D;
  }
  var X = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, se = /* @__PURE__ */ new Map();
  function Y(S) {
    var _ = se.get(S);
    if (_ === void 0) {
      if (!X.test(S))
        throw Error(t(65, S));
      _ = "<" + S, se.set(S, _);
    }
    return _;
  }
  function ie(S, _, D, K, pe) {
    switch (_) {
      case "select":
        S.push(Y("select"));
        var O = null, $ = null;
        for (Qe in D)
          if (n.call(D, Qe)) {
            var ee = D[Qe];
            if (ee != null)
              switch (Qe) {
                case "children":
                  O = ee;
                  break;
                case "dangerouslySetInnerHTML":
                  $ = ee;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  B(S, K, Qe, ee);
              }
          }
        return S.push(">"), j(S, $, O), O;
      case "option":
        $ = pe.selectedValue, S.push(Y("option"));
        var be = ee = null, Ie = null, Qe = null;
        for (O in D)
          if (n.call(D, O)) {
            var pt = D[O];
            if (pt != null)
              switch (O) {
                case "children":
                  ee = pt;
                  break;
                case "selected":
                  Ie = pt;
                  break;
                case "dangerouslySetInnerHTML":
                  Qe = pt;
                  break;
                case "value":
                  be = pt;
                default:
                  B(S, K, O, pt);
              }
          }
        if ($ != null)
          if (D = be !== null ? "" + be : Z(ee), v($)) {
            for (K = 0; K < $.length; K++)
              if ("" + $[K] === D) {
                S.push(' selected=""');
                break;
              }
          } else
            "" + $ === D && S.push(' selected=""');
        else
          Ie && S.push(' selected=""');
        return S.push(">"), j(S, Qe, ee), ee;
      case "textarea":
        S.push(Y("textarea")), Qe = $ = O = null;
        for (ee in D)
          if (n.call(D, ee) && (be = D[ee], be != null))
            switch (ee) {
              case "children":
                Qe = be;
                break;
              case "value":
                O = be;
                break;
              case "defaultValue":
                $ = be;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                B(
                  S,
                  K,
                  ee,
                  be
                );
            }
        if (O === null && $ !== null && (O = $), S.push(">"), Qe != null) {
          if (O != null)
            throw Error(t(92));
          if (v(Qe) && 1 < Qe.length)
            throw Error(t(93));
          O = "" + Qe;
        }
        return typeof O == "string" && O[0] === `
` && S.push(`
`), O !== null && S.push(y("" + O)), null;
      case "input":
        S.push(Y("input")), be = Qe = ee = O = null;
        for ($ in D)
          if (n.call(D, $) && (Ie = D[$], Ie != null))
            switch ($) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                be = Ie;
                break;
              case "defaultValue":
                ee = Ie;
                break;
              case "checked":
                Qe = Ie;
                break;
              case "value":
                O = Ie;
                break;
              default:
                B(S, K, $, Ie);
            }
        return Qe !== null ? B(S, K, "checked", Qe) : be !== null && B(S, K, "checked", be), O !== null ? B(S, K, "value", O) : ee !== null && B(S, K, "value", ee), S.push("/>"), null;
      case "menuitem":
        S.push(Y("menuitem"));
        for (var Ut in D)
          if (n.call(D, Ut) && (O = D[Ut], O != null))
            switch (Ut) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                B(S, K, Ut, O);
            }
        return S.push(">"), null;
      case "title":
        S.push(Y("title")), O = null;
        for (pt in D)
          if (n.call(D, pt) && ($ = D[pt], $ != null))
            switch (pt) {
              case "children":
                O = $;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                B(S, K, pt, $);
            }
        return S.push(">"), O;
      case "listing":
      case "pre":
        S.push(Y(_)), $ = O = null;
        for (be in D)
          if (n.call(D, be) && (ee = D[be], ee != null))
            switch (be) {
              case "children":
                O = ee;
                break;
              case "dangerouslySetInnerHTML":
                $ = ee;
                break;
              default:
                B(S, K, be, ee);
            }
        if (S.push(">"), $ != null) {
          if (O != null)
            throw Error(t(60));
          if (typeof $ != "object" || !("__html" in $))
            throw Error(t(61));
          D = $.__html, D != null && (typeof D == "string" && 0 < D.length && D[0] === `
` ? S.push(`
`, D) : S.push("" + D));
        }
        return typeof O == "string" && O[0] === `
` && S.push(`
`), O;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        S.push(Y(_));
        for (var $t in D)
          if (n.call(D, $t) && (O = D[$t], O != null))
            switch ($t) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, _));
              default:
                B(S, K, $t, O);
            }
        return S.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return re(
          S,
          D,
          _,
          K
        );
      case "html":
        return pe.insertionMode === 0 && S.push("<!DOCTYPE html>"), re(S, D, _, K);
      default:
        if (_.indexOf("-") === -1 && typeof D.is != "string")
          return re(S, D, _, K);
        S.push(Y(_)), $ = O = null;
        for (Ie in D)
          if (n.call(D, Ie) && (ee = D[Ie], ee != null))
            switch (Ie) {
              case "children":
                O = ee;
                break;
              case "dangerouslySetInnerHTML":
                $ = ee;
                break;
              case "style":
                L(S, K, ee);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                d(Ie) && typeof ee != "function" && typeof ee != "symbol" && S.push(" ", Ie, '="', y(ee), '"');
            }
        return S.push(">"), j(S, $, O), O;
    }
  }
  function I(S, _, D) {
    if (S.push('<!--$?--><template id="'), D === null)
      throw Error(t(395));
    return S.push(D), S.push('"></template>');
  }
  function U(S, _, D, K) {
    switch (D.insertionMode) {
      case 0:
      case 1:
        return S.push('<div hidden id="'), S.push(_.segmentPrefix), _ = K.toString(16), S.push(_), S.push('">');
      case 2:
        return S.push('<svg aria-hidden="true" style="display:none" id="'), S.push(_.segmentPrefix), _ = K.toString(16), S.push(_), S.push('">');
      case 3:
        return S.push('<math aria-hidden="true" style="display:none" id="'), S.push(_.segmentPrefix), _ = K.toString(16), S.push(_), S.push('">');
      case 4:
        return S.push('<table hidden id="'), S.push(_.segmentPrefix), _ = K.toString(16), S.push(_), S.push('">');
      case 5:
        return S.push('<table hidden><tbody id="'), S.push(_.segmentPrefix), _ = K.toString(16), S.push(_), S.push('">');
      case 6:
        return S.push('<table hidden><tr id="'), S.push(_.segmentPrefix), _ = K.toString(16), S.push(_), S.push('">');
      case 7:
        return S.push('<table hidden><colgroup id="'), S.push(_.segmentPrefix), _ = K.toString(16), S.push(_), S.push('">');
      default:
        throw Error(t(397));
    }
  }
  function ue(S, _) {
    switch (_.insertionMode) {
      case 0:
      case 1:
        return S.push("</div>");
      case 2:
        return S.push("</svg>");
      case 3:
        return S.push("</math>");
      case 4:
        return S.push("</table>");
      case 5:
        return S.push("</tbody></table>");
      case 6:
        return S.push("</tr></table>");
      case 7:
        return S.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var te = /[<\u2028\u2029]/g;
  function J(S) {
    return JSON.stringify(S).replace(te, function(_) {
      switch (_) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function Q(S, _) {
    return _ = _ === void 0 ? "" : _, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: _ + "P:", segmentPrefix: _ + "S:", boundaryPrefix: _ + "B:", idPrefix: _, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: S };
  }
  function G(S, _, D, K) {
    return D.generateStaticMarkup ? (S.push(y(_)), !1) : (_ === "" ? S = K : (K && S.push("<!-- -->"), S.push(y(_)), S = !0), S);
  }
  var ne = Object.assign, H = Symbol.for("react.element"), ce = Symbol.for("react.portal"), ke = Symbol.for("react.fragment"), Se = Symbol.for("react.strict_mode"), xe = Symbol.for("react.profiler"), De = Symbol.for("react.provider"), je = Symbol.for("react.context"), Ce = Symbol.for("react.forward_ref"), ye = Symbol.for("react.suspense"), Ee = Symbol.for("react.suspense_list"), he = Symbol.for("react.memo"), Be = Symbol.for("react.lazy"), $e = Symbol.for("react.scope"), tt = Symbol.for("react.debug_trace_mode"), We = Symbol.for("react.legacy_hidden"), Fe = Symbol.for("react.default_value"), Je = Symbol.iterator;
  function Ke(S) {
    if (S == null)
      return null;
    if (typeof S == "function")
      return S.displayName || S.name || null;
    if (typeof S == "string")
      return S;
    switch (S) {
      case ke:
        return "Fragment";
      case ce:
        return "Portal";
      case xe:
        return "Profiler";
      case Se:
        return "StrictMode";
      case ye:
        return "Suspense";
      case Ee:
        return "SuspenseList";
    }
    if (typeof S == "object")
      switch (S.$$typeof) {
        case je:
          return (S.displayName || "Context") + ".Consumer";
        case De:
          return (S._context.displayName || "Context") + ".Provider";
        case Ce:
          var _ = S.render;
          return S = S.displayName, S || (S = _.displayName || _.name || "", S = S !== "" ? "ForwardRef(" + S + ")" : "ForwardRef"), S;
        case he:
          return _ = S.displayName || null, _ !== null ? _ : Ke(S.type) || "Memo";
        case Be:
          _ = S._payload, S = S._init;
          try {
            return Ke(S(_));
          } catch {
          }
      }
    return null;
  }
  var Ye = {};
  function Xe(S, _) {
    if (S = S.contextTypes, !S)
      return Ye;
    var D = {}, K;
    for (K in S)
      D[K] = _[K];
    return D;
  }
  var Ae = null;
  function Oe(S, _) {
    if (S !== _) {
      S.context._currentValue2 = S.parentValue, S = S.parent;
      var D = _.parent;
      if (S === null) {
        if (D !== null)
          throw Error(t(401));
      } else {
        if (D === null)
          throw Error(t(401));
        Oe(S, D);
      }
      _.context._currentValue2 = _.value;
    }
  }
  function lt(S) {
    S.context._currentValue2 = S.parentValue, S = S.parent, S !== null && lt(S);
  }
  function ve(S) {
    var _ = S.parent;
    _ !== null && ve(_), S.context._currentValue2 = S.value;
  }
  function mt(S, _) {
    if (S.context._currentValue2 = S.parentValue, S = S.parent, S === null)
      throw Error(t(402));
    S.depth === _.depth ? Oe(S, _) : mt(S, _);
  }
  function ut(S, _) {
    var D = _.parent;
    if (D === null)
      throw Error(t(402));
    S.depth === D.depth ? Oe(S, D) : ut(S, D), _.context._currentValue2 = _.value;
  }
  function st(S) {
    var _ = Ae;
    _ !== S && (_ === null ? ve(S) : S === null ? lt(_) : _.depth === S.depth ? Oe(_, S) : _.depth > S.depth ? mt(_, S) : ut(_, S), Ae = S);
  }
  var Lt = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(S, _) {
    S = S._reactInternals, S.queue !== null && S.queue.push(_);
  }, enqueueReplaceState: function(S, _) {
    S = S._reactInternals, S.replace = !0, S.queue = [_];
  }, enqueueForceUpdate: function() {
  } };
  function Kt(S, _, D, K) {
    var pe = S.state !== void 0 ? S.state : null;
    S.updater = Lt, S.props = D, S.state = pe;
    var O = { queue: [], replace: !1 };
    S._reactInternals = O;
    var $ = _.contextType;
    if (S.context = typeof $ == "object" && $ !== null ? $._currentValue2 : K, $ = _.getDerivedStateFromProps, typeof $ == "function" && ($ = $(D, pe), pe = $ == null ? pe : ne({}, pe, $), S.state = pe), typeof _.getDerivedStateFromProps != "function" && typeof S.getSnapshotBeforeUpdate != "function" && (typeof S.UNSAFE_componentWillMount == "function" || typeof S.componentWillMount == "function"))
      if (_ = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), _ !== S.state && Lt.enqueueReplaceState(S, S.state, null), O.queue !== null && 0 < O.queue.length)
        if (_ = O.queue, $ = O.replace, O.queue = null, O.replace = !1, $ && _.length === 1)
          S.state = _[0];
        else {
          for (O = $ ? _[0] : S.state, pe = !0, $ = $ ? 1 : 0; $ < _.length; $++) {
            var ee = _[$];
            ee = typeof ee == "function" ? ee.call(S, O, D, K) : ee, ee != null && (pe ? (pe = !1, O = ne({}, O, ee)) : ne(O, ee));
          }
          S.state = O;
        }
      else
        O.queue = null;
  }
  var Xt = { id: 1, overflow: "" };
  function It(S, _, D) {
    var K = S.id;
    S = S.overflow;
    var pe = 32 - ln(K) - 1;
    K &= ~(1 << pe), D += 1;
    var O = 32 - ln(_) + pe;
    if (30 < O) {
      var $ = pe - pe % 5;
      return O = (K & (1 << $) - 1).toString(32), K >>= $, pe -= $, { id: 1 << 32 - ln(_) + pe | D << pe | K, overflow: O + S };
    }
    return { id: 1 << O | D << pe | K, overflow: S };
  }
  var ln = Math.clz32 ? Math.clz32 : _t, Tt = Math.log, Ot = Math.LN2;
  function _t(S) {
    return S >>>= 0, S === 0 ? 32 : 31 - (Tt(S) / Ot | 0) | 0;
  }
  function an(S, _) {
    return S === _ && (S !== 0 || 1 / S === 1 / _) || S !== S && _ !== _;
  }
  var dn = typeof Object.is == "function" ? Object.is : an, zt = null, Bt = null, on = null, rt = null, ht = !1, Pe = !1, _e = 0, we = null, yt = 0;
  function at() {
    if (zt === null)
      throw Error(t(321));
    return zt;
  }
  function bt() {
    if (0 < yt)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function wt() {
    return rt === null ? on === null ? (ht = !1, on = rt = bt()) : (ht = !0, rt = on) : rt.next === null ? (ht = !1, rt = rt.next = bt()) : (ht = !0, rt = rt.next), rt;
  }
  function qt() {
    Bt = zt = null, Pe = !1, on = null, yt = 0, rt = we = null;
  }
  function ct(S, _) {
    return typeof _ == "function" ? _(S) : _;
  }
  function dt(S, _, D) {
    if (zt = at(), rt = wt(), ht) {
      var K = rt.queue;
      if (_ = K.dispatch, we !== null && (D = we.get(K), D !== void 0)) {
        we.delete(K), K = rt.memoizedState;
        do
          K = S(K, D.action), D = D.next;
        while (D !== null);
        return rt.memoizedState = K, [K, _];
      }
      return [rt.memoizedState, _];
    }
    return S = S === ct ? typeof _ == "function" ? _() : _ : D !== void 0 ? D(_) : _, rt.memoizedState = S, S = rt.queue = { last: null, dispatch: null }, S = S.dispatch = Yt.bind(null, zt, S), [rt.memoizedState, S];
  }
  function Wt(S, _) {
    if (zt = at(), rt = wt(), _ = _ === void 0 ? null : _, rt !== null) {
      var D = rt.memoizedState;
      if (D !== null && _ !== null) {
        var K = D[1];
        e:
          if (K === null)
            K = !1;
          else {
            for (var pe = 0; pe < K.length && pe < _.length; pe++)
              if (!dn(_[pe], K[pe])) {
                K = !1;
                break e;
              }
            K = !0;
          }
        if (K)
          return D[0];
      }
    }
    return S = S(), rt.memoizedState = [S, _], S;
  }
  function Yt(S, _, D) {
    if (25 <= yt)
      throw Error(t(301));
    if (S === zt)
      if (Pe = !0, S = { action: D, next: null }, we === null && (we = /* @__PURE__ */ new Map()), D = we.get(_), D === void 0)
        we.set(_, S);
      else {
        for (_ = D; _.next !== null; )
          _ = _.next;
        _.next = S;
      }
  }
  function Rt() {
    throw Error(t(394));
  }
  function Ct() {
  }
  var xn = { readContext: function(S) {
    return S._currentValue2;
  }, useContext: function(S) {
    return at(), S._currentValue2;
  }, useMemo: Wt, useReducer: dt, useRef: function(S) {
    zt = at(), rt = wt();
    var _ = rt.memoizedState;
    return _ === null ? (S = { current: S }, rt.memoizedState = S) : _;
  }, useState: function(S) {
    return dt(ct, S);
  }, useInsertionEffect: Ct, useLayoutEffect: function() {
  }, useCallback: function(S, _) {
    return Wt(function() {
      return S;
    }, _);
  }, useImperativeHandle: Ct, useEffect: Ct, useDebugValue: Ct, useDeferredValue: function(S) {
    return at(), S;
  }, useTransition: function() {
    return at(), [
      !1,
      Rt
    ];
  }, useId: function() {
    var S = Bt.treeContext, _ = S.overflow;
    S = S.id, S = (S & ~(1 << 32 - ln(S) - 1)).toString(32) + _;
    var D = Sn;
    if (D === null)
      throw Error(t(404));
    return _ = _e++, S = ":" + D.idPrefix + "R" + S, 0 < _ && (S += "H" + _.toString(32)), S + ":";
  }, useMutableSource: function(S, _) {
    return at(), _(S._source);
  }, useSyncExternalStore: function(S, _, D) {
    if (D === void 0)
      throw Error(t(407));
    return D();
  } }, Sn = null, Ln = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function On(S) {
    return console.error(S), null;
  }
  function En() {
  }
  function rr(S, _, D, K, pe, O, $, ee, be) {
    var Ie = [], Qe = /* @__PURE__ */ new Set();
    return _ = { destination: null, responseState: _, progressiveChunkSize: K === void 0 ? 12800 : K, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Qe, pingedTasks: Ie, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: pe === void 0 ? On : pe, onAllReady: O === void 0 ? En : O, onShellReady: $ === void 0 ? En : $, onShellError: ee === void 0 ? En : ee, onFatalError: be === void 0 ? En : be }, D = wn(_, 0, null, D, !1, !1), D.parentFlushed = !0, S = Mn(_, S, null, D, Qe, Ye, null, Xt), Ie.push(S), _;
  }
  function Mn(S, _, D, K, pe, O, $, ee) {
    S.allPendingTasks++, D === null ? S.pendingRootTasks++ : D.pendingTasks++;
    var be = { node: _, ping: function() {
      var Ie = S.pingedTasks;
      Ie.push(be), Ie.length === 1 && yn(S);
    }, blockedBoundary: D, blockedSegment: K, abortSet: pe, legacyContext: O, context: $, treeContext: ee };
    return pe.add(be), be;
  }
  function wn(S, _, D, K, pe, O) {
    return { status: 0, id: -1, index: _, parentFlushed: !1, chunks: [], children: [], formatContext: K, boundary: D, lastPushedText: pe, textEmbedded: O };
  }
  function Pt(S, _) {
    if (S = S.onError(_), S != null && typeof S != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof S + '" instead');
    return S;
  }
  function jt(S, _) {
    var D = S.onShellError;
    D(_), D = S.onFatalError, D(_), S.destination !== null ? (S.status = 2, S.destination.destroy(_)) : (S.status = 1, S.fatalError = _);
  }
  function kn(S, _, D, K, pe) {
    for (zt = {}, Bt = _, _e = 0, S = D(K, pe); Pe; )
      Pe = !1, _e = 0, yt += 1, rt = null, S = D(K, pe);
    return qt(), S;
  }
  function tn(S, _, D, K) {
    var pe = D.render(), O = K.childContextTypes;
    if (O != null) {
      var $ = _.legacyContext;
      if (typeof D.getChildContext != "function")
        K = $;
      else {
        D = D.getChildContext();
        for (var ee in D)
          if (!(ee in O))
            throw Error(t(108, Ke(K) || "Unknown", ee));
        K = ne({}, $, D);
      }
      _.legacyContext = K, Dt(S, _, pe), _.legacyContext = $;
    } else
      Dt(S, _, pe);
  }
  function fn(S, _) {
    if (S && S.defaultProps) {
      _ = ne({}, _), S = S.defaultProps;
      for (var D in S)
        _[D] === void 0 && (_[D] = S[D]);
      return _;
    }
    return _;
  }
  function An(S, _, D, K, pe) {
    if (typeof D == "function")
      if (D.prototype && D.prototype.isReactComponent) {
        pe = Xe(D, _.legacyContext);
        var O = D.contextType;
        O = new D(K, typeof O == "object" && O !== null ? O._currentValue2 : pe), Kt(O, D, K, pe), tn(S, _, O, D);
      } else {
        O = Xe(D, _.legacyContext), pe = kn(S, _, D, K, O);
        var $ = _e !== 0;
        if (typeof pe == "object" && pe !== null && typeof pe.render == "function" && pe.$$typeof === void 0)
          Kt(pe, D, K, O), tn(S, _, pe, D);
        else if ($) {
          K = _.treeContext, _.treeContext = It(K, 1, 0);
          try {
            Dt(S, _, pe);
          } finally {
            _.treeContext = K;
          }
        } else
          Dt(S, _, pe);
      }
    else if (typeof D == "string") {
      switch (pe = _.blockedSegment, O = ie(pe.chunks, D, K, S.responseState, pe.formatContext), pe.lastPushedText = !1, $ = pe.formatContext, pe.formatContext = N($, D, K), sn(S, _, O), pe.formatContext = $, D) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          pe.chunks.push("</", D, ">");
      }
      pe.lastPushedText = !1;
    } else {
      switch (D) {
        case We:
        case tt:
        case Se:
        case xe:
        case ke:
          Dt(S, _, K.children);
          return;
        case Ee:
          Dt(S, _, K.children);
          return;
        case $e:
          throw Error(t(343));
        case ye:
          e: {
            D = _.blockedBoundary, pe = _.blockedSegment, O = K.fallback, K = K.children, $ = /* @__PURE__ */ new Set();
            var ee = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: $, errorDigest: null }, be = wn(S, pe.chunks.length, ee, pe.formatContext, !1, !1);
            pe.children.push(be), pe.lastPushedText = !1;
            var Ie = wn(S, 0, null, pe.formatContext, !1, !1);
            Ie.parentFlushed = !0, _.blockedBoundary = ee, _.blockedSegment = Ie;
            try {
              if (sn(
                S,
                _,
                K
              ), S.responseState.generateStaticMarkup || Ie.lastPushedText && Ie.textEmbedded && Ie.chunks.push("<!-- -->"), Ie.status = 1, Fn(ee, Ie), ee.pendingTasks === 0)
                break e;
            } catch (Qe) {
              Ie.status = 4, ee.forceClientRender = !0, ee.errorDigest = Pt(S, Qe);
            } finally {
              _.blockedBoundary = D, _.blockedSegment = pe;
            }
            _ = Mn(S, O, D, be, $, _.legacyContext, _.context, _.treeContext), S.pingedTasks.push(_);
          }
          return;
      }
      if (typeof D == "object" && D !== null)
        switch (D.$$typeof) {
          case Ce:
            if (K = kn(S, _, D.render, K, pe), _e !== 0) {
              D = _.treeContext, _.treeContext = It(D, 1, 0);
              try {
                Dt(S, _, K);
              } finally {
                _.treeContext = D;
              }
            } else
              Dt(S, _, K);
            return;
          case he:
            D = D.type, K = fn(D, K), An(S, _, D, K, pe);
            return;
          case De:
            if (pe = K.children, D = D._context, K = K.value, O = D._currentValue2, D._currentValue2 = K, $ = Ae, Ae = K = { parent: $, depth: $ === null ? 0 : $.depth + 1, context: D, parentValue: O, value: K }, _.context = K, Dt(S, _, pe), S = Ae, S === null)
              throw Error(t(403));
            K = S.parentValue, S.context._currentValue2 = K === Fe ? S.context._defaultValue : K, S = Ae = S.parent, _.context = S;
            return;
          case je:
            K = K.children, K = K(D._currentValue2), Dt(S, _, K);
            return;
          case Be:
            pe = D._init, D = pe(D._payload), K = fn(D, K), An(
              S,
              _,
              D,
              K,
              void 0
            );
            return;
        }
      throw Error(t(130, D == null ? D : typeof D, ""));
    }
  }
  function Dt(S, _, D) {
    if (_.node = D, typeof D == "object" && D !== null) {
      switch (D.$$typeof) {
        case H:
          An(S, _, D.type, D.props, D.ref);
          return;
        case ce:
          throw Error(t(257));
        case Be:
          var K = D._init;
          D = K(D._payload), Dt(S, _, D);
          return;
      }
      if (v(D)) {
        bn(S, _, D);
        return;
      }
      if (D === null || typeof D != "object" ? K = null : (K = Je && D[Je] || D["@@iterator"], K = typeof K == "function" ? K : null), K && (K = K.call(D))) {
        if (D = K.next(), !D.done) {
          var pe = [];
          do
            pe.push(D.value), D = K.next();
          while (!D.done);
          bn(S, _, pe);
        }
        return;
      }
      throw S = Object.prototype.toString.call(D), Error(t(31, S === "[object Object]" ? "object with keys {" + Object.keys(D).join(", ") + "}" : S));
    }
    typeof D == "string" ? (K = _.blockedSegment, K.lastPushedText = G(_.blockedSegment.chunks, D, S.responseState, K.lastPushedText)) : typeof D == "number" && (K = _.blockedSegment, K.lastPushedText = G(_.blockedSegment.chunks, "" + D, S.responseState, K.lastPushedText));
  }
  function bn(S, _, D) {
    for (var K = D.length, pe = 0; pe < K; pe++) {
      var O = _.treeContext;
      _.treeContext = It(O, K, pe);
      try {
        sn(S, _, D[pe]);
      } finally {
        _.treeContext = O;
      }
    }
  }
  function sn(S, _, D) {
    var K = _.blockedSegment.formatContext, pe = _.legacyContext, O = _.context;
    try {
      return Dt(S, _, D);
    } catch (be) {
      if (qt(), typeof be == "object" && be !== null && typeof be.then == "function") {
        D = be;
        var $ = _.blockedSegment, ee = wn(S, $.chunks.length, null, $.formatContext, $.lastPushedText, !0);
        $.children.push(ee), $.lastPushedText = !1, S = Mn(S, _.node, _.blockedBoundary, ee, _.abortSet, _.legacyContext, _.context, _.treeContext).ping, D.then(S, S), _.blockedSegment.formatContext = K, _.legacyContext = pe, _.context = O, st(O);
      } else
        throw _.blockedSegment.formatContext = K, _.legacyContext = pe, _.context = O, st(O), be;
    }
  }
  function hn(S) {
    var _ = S.blockedBoundary;
    S = S.blockedSegment, S.status = 3, Rn(this, _, S);
  }
  function ir(S, _, D) {
    var K = S.blockedBoundary;
    S.blockedSegment.status = 3, K === null ? (_.allPendingTasks--, _.status !== 2 && (_.status = 2, _.destination !== null && _.destination.push(null))) : (K.pendingTasks--, K.forceClientRender || (K.forceClientRender = !0, S = D === void 0 ? Error(t(432)) : D, K.errorDigest = _.onError(S), K.parentFlushed && _.clientRenderedBoundaries.push(K)), K.fallbackAbortableTasks.forEach(function(pe) {
      return ir(pe, _, D);
    }), K.fallbackAbortableTasks.clear(), _.allPendingTasks--, _.allPendingTasks === 0 && (K = _.onAllReady, K()));
  }
  function Fn(S, _) {
    if (_.chunks.length === 0 && _.children.length === 1 && _.children[0].boundary === null) {
      var D = _.children[0];
      D.id = _.id, D.parentFlushed = !0, D.status === 1 && Fn(S, D);
    } else
      S.completedSegments.push(_);
  }
  function Rn(S, _, D) {
    if (_ === null) {
      if (D.parentFlushed) {
        if (S.completedRootSegment !== null)
          throw Error(t(389));
        S.completedRootSegment = D;
      }
      S.pendingRootTasks--, S.pendingRootTasks === 0 && (S.onShellError = En, _ = S.onShellReady, _());
    } else
      _.pendingTasks--, _.forceClientRender || (_.pendingTasks === 0 ? (D.parentFlushed && D.status === 1 && Fn(_, D), _.parentFlushed && S.completedBoundaries.push(_), _.fallbackAbortableTasks.forEach(hn, S), _.fallbackAbortableTasks.clear()) : D.parentFlushed && D.status === 1 && (Fn(_, D), _.completedSegments.length === 1 && _.parentFlushed && S.partialBoundaries.push(_)));
    S.allPendingTasks--, S.allPendingTasks === 0 && (S = S.onAllReady, S());
  }
  function yn(S) {
    if (S.status !== 2) {
      var _ = Ae, D = Ln.current;
      Ln.current = xn;
      var K = Sn;
      Sn = S.responseState;
      try {
        var pe = S.pingedTasks, O;
        for (O = 0; O < pe.length; O++) {
          var $ = pe[O], ee = S, be = $.blockedSegment;
          if (be.status === 0) {
            st($.context);
            try {
              Dt(ee, $, $.node), ee.responseState.generateStaticMarkup || be.lastPushedText && be.textEmbedded && be.chunks.push("<!-- -->"), $.abortSet.delete($), be.status = 1, Rn(ee, $.blockedBoundary, be);
            } catch (Qt) {
              if (qt(), typeof Qt == "object" && Qt !== null && typeof Qt.then == "function") {
                var Ie = $.ping;
                Qt.then(Ie, Ie);
              } else {
                $.abortSet.delete($), be.status = 4;
                var Qe = $.blockedBoundary, pt = Qt, Ut = Pt(ee, pt);
                if (Qe === null ? jt(ee, pt) : (Qe.pendingTasks--, Qe.forceClientRender || (Qe.forceClientRender = !0, Qe.errorDigest = Ut, Qe.parentFlushed && ee.clientRenderedBoundaries.push(Qe))), ee.allPendingTasks--, ee.allPendingTasks === 0) {
                  var $t = ee.onAllReady;
                  $t();
                }
              }
            } finally {
            }
          }
        }
        pe.splice(0, O), S.destination !== null && jn(S, S.destination);
      } catch (Qt) {
        Pt(S, Qt), jt(S, Qt);
      } finally {
        Sn = K, Ln.current = D, D === xn && st(_);
      }
    }
  }
  function $n(S, _, D) {
    switch (D.parentFlushed = !0, D.status) {
      case 0:
        var K = D.id = S.nextSegmentId++;
        return D.lastPushedText = !1, D.textEmbedded = !1, S = S.responseState, _.push('<template id="'), _.push(S.placeholderPrefix), S = K.toString(16), _.push(S), _.push('"></template>');
      case 1:
        D.status = 2;
        var pe = !0;
        K = D.chunks;
        var O = 0;
        D = D.children;
        for (var $ = 0; $ < D.length; $++) {
          for (pe = D[$]; O < pe.index; O++)
            _.push(K[O]);
          pe = Hn(S, _, pe);
        }
        for (; O < K.length - 1; O++)
          _.push(K[O]);
        return O < K.length && (pe = _.push(K[O])), pe;
      default:
        throw Error(t(390));
    }
  }
  function Hn(S, _, D) {
    var K = D.boundary;
    if (K === null)
      return $n(S, _, D);
    if (K.parentFlushed = !0, K.forceClientRender)
      return S.responseState.generateStaticMarkup || (K = K.errorDigest, _.push("<!--$!-->"), _.push("<template"), K && (_.push(' data-dgst="'), K = y(K), _.push(K), _.push('"')), _.push("></template>")), $n(S, _, D), S = S.responseState.generateStaticMarkup ? !0 : _.push("<!--/$-->"), S;
    if (0 < K.pendingTasks) {
      K.rootSegmentID = S.nextSegmentId++, 0 < K.completedSegments.length && S.partialBoundaries.push(K);
      var pe = S.responseState, O = pe.nextSuspenseID++;
      return pe = pe.boundaryPrefix + O.toString(16), K = K.id = pe, I(_, S.responseState, K), $n(S, _, D), _.push("<!--/$-->");
    }
    if (K.byteSize > S.progressiveChunkSize)
      return K.rootSegmentID = S.nextSegmentId++, S.completedBoundaries.push(K), I(_, S.responseState, K.id), $n(S, _, D), _.push("<!--/$-->");
    if (S.responseState.generateStaticMarkup || _.push("<!--$-->"), D = K.completedSegments, D.length !== 1)
      throw Error(t(391));
    return Hn(S, _, D[0]), S = S.responseState.generateStaticMarkup ? !0 : _.push("<!--/$-->"), S;
  }
  function ar(S, _, D) {
    return U(_, S.responseState, D.formatContext, D.id), Hn(S, _, D), ue(_, D.formatContext);
  }
  function gr(S, _, D) {
    for (var K = D.completedSegments, pe = 0; pe < K.length; pe++)
      or(S, _, D, K[pe]);
    if (K.length = 0, S = S.responseState, K = D.id, D = D.rootSegmentID, _.push(S.startInlineScript), S.sentCompleteBoundaryFunction ? _.push('$RC("') : (S.sentCompleteBoundaryFunction = !0, _.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), K === null)
      throw Error(t(395));
    return D = D.toString(16), _.push(K), _.push('","'), _.push(S.segmentPrefix), _.push(D), _.push('")<\/script>');
  }
  function or(S, _, D, K) {
    if (K.status === 2)
      return !0;
    var pe = K.id;
    if (pe === -1) {
      if ((K.id = D.rootSegmentID) === -1)
        throw Error(t(392));
      return ar(S, _, K);
    }
    return ar(S, _, K), S = S.responseState, _.push(S.startInlineScript), S.sentCompleteSegmentFunction ? _.push('$RS("') : (S.sentCompleteSegmentFunction = !0, _.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), _.push(S.segmentPrefix), pe = pe.toString(16), _.push(pe), _.push('","'), _.push(S.placeholderPrefix), _.push(pe), _.push('")<\/script>');
  }
  function jn(S, _) {
    try {
      var D = S.completedRootSegment;
      if (D !== null && S.pendingRootTasks === 0) {
        Hn(S, _, D), S.completedRootSegment = null;
        var K = S.responseState.bootstrapChunks;
        for (D = 0; D < K.length - 1; D++)
          _.push(K[D]);
        D < K.length && _.push(K[D]);
      }
      var pe = S.clientRenderedBoundaries, O;
      for (O = 0; O < pe.length; O++) {
        var $ = pe[O];
        K = _;
        var ee = S.responseState, be = $.id, Ie = $.errorDigest, Qe = $.errorMessage, pt = $.errorComponentStack;
        if (K.push(ee.startInlineScript), ee.sentClientRenderFunction ? K.push('$RX("') : (ee.sentClientRenderFunction = !0, K.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), be === null)
          throw Error(t(395));
        if (K.push(be), K.push('"'), Ie || Qe || pt) {
          K.push(",");
          var Ut = J(Ie || "");
          K.push(Ut);
        }
        if (Qe || pt) {
          K.push(",");
          var $t = J(Qe || "");
          K.push($t);
        }
        if (pt) {
          K.push(",");
          var Qt = J(pt);
          K.push(Qt);
        }
        if (!K.push(")<\/script>")) {
          S.destination = null, O++, pe.splice(0, O);
          return;
        }
      }
      pe.splice(0, O);
      var Jt = S.completedBoundaries;
      for (O = 0; O < Jt.length; O++)
        if (!gr(S, _, Jt[O])) {
          S.destination = null, O++, Jt.splice(0, O);
          return;
        }
      Jt.splice(0, O);
      var en = S.partialBoundaries;
      for (O = 0; O < en.length; O++) {
        var Vn = en[O];
        e: {
          pe = S, $ = _;
          var Zn = Vn.completedSegments;
          for (ee = 0; ee < Zn.length; ee++)
            if (!or(pe, $, Vn, Zn[ee])) {
              ee++, Zn.splice(0, ee);
              var Qn = !1;
              break e;
            }
          Zn.splice(0, ee), Qn = !0;
        }
        if (!Qn) {
          S.destination = null, O++, en.splice(0, O);
          return;
        }
      }
      en.splice(0, O);
      var Un = S.completedBoundaries;
      for (O = 0; O < Un.length; O++)
        if (!gr(S, _, Un[O])) {
          S.destination = null, O++, Un.splice(0, O);
          return;
        }
      Un.splice(0, O);
    } finally {
      S.allPendingTasks === 0 && S.pingedTasks.length === 0 && S.clientRenderedBoundaries.length === 0 && S.completedBoundaries.length === 0 && _.push(null);
    }
  }
  function lr(S, _) {
    try {
      var D = S.abortableTasks;
      D.forEach(function(K) {
        return ir(K, S, _);
      }), D.clear(), S.destination !== null && jn(S, S.destination);
    } catch (K) {
      Pt(S, K), jt(S, K);
    }
  }
  function Xn() {
  }
  function qn(S, _, D, K) {
    var pe = !1, O = null, $ = "", ee = { push: function(Ie) {
      return Ie !== null && ($ += Ie), !0;
    }, destroy: function(Ie) {
      pe = !0, O = Ie;
    } }, be = !1;
    if (S = rr(S, Q(D, _ ? _.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, Xn, void 0, function() {
      be = !0;
    }, void 0, void 0), yn(S), lr(S, K), S.status === 1)
      S.status = 2, ee.destroy(S.fatalError);
    else if (S.status !== 2 && S.destination === null) {
      S.destination = ee;
      try {
        jn(S, ee);
      } catch (Ie) {
        Pt(S, Ie), jt(S, Ie);
      }
    }
    if (pe)
      throw O;
    if (!be)
      throw Error(t(426));
    return $;
  }
  return Oa.renderToNodeStream = function() {
    throw Error(t(207));
  }, Oa.renderToStaticMarkup = function(S, _) {
    return qn(S, _, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Oa.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, Oa.renderToString = function(S, _) {
    return qn(S, _, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Oa.version = "18.2.0", Oa;
}
var Bu = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rm;
function Sw() {
  if (rm)
    return Bu;
  rm = 1;
  var e = de;
  function t(w) {
    for (var M = "https://reactjs.org/docs/error-decoder.html?invariant=" + w, W = 1; W < arguments.length; W++)
      M += "&args[]=" + encodeURIComponent(arguments[W]);
    return "Minified React error #" + w + "; visit " + M + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = null, r = 0;
  function i(w, M) {
    if (M.length !== 0)
      if (512 < M.length)
        0 < r && (w.enqueue(new Uint8Array(n.buffer, 0, r)), n = new Uint8Array(512), r = 0), w.enqueue(M);
      else {
        var W = n.length - r;
        W < M.length && (W === 0 ? w.enqueue(n) : (n.set(M.subarray(0, W), r), w.enqueue(n), M = M.subarray(W)), n = new Uint8Array(512), r = 0), n.set(M, r), r += M.length;
      }
  }
  function o(w, M) {
    return i(w, M), !0;
  }
  function d(w) {
    n && 0 < r && (w.enqueue(new Uint8Array(n.buffer, 0, r)), n = null, r = 0);
  }
  var c = new TextEncoder();
  function s(w) {
    return c.encode(w);
  }
  function p(w) {
    return c.encode(w);
  }
  function m(w, M) {
    typeof w.error == "function" ? w.error(M) : w.close();
  }
  var g = Object.prototype.hasOwnProperty, x = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, T = {}, y = {};
  function A(w) {
    return g.call(y, w) ? !0 : g.call(T, w) ? !1 : x.test(w) ? y[w] = !0 : (T[w] = !0, !1);
  }
  function b(w, M, W, ae, Le, Te, Me) {
    this.acceptsBooleans = M === 2 || M === 3 || M === 4, this.attributeName = ae, this.attributeNamespace = Le, this.mustUseProperty = W, this.propertyName = w, this.type = M, this.sanitizeURL = Te, this.removeEmptyString = Me;
  }
  var v = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(w) {
    v[w] = new b(w, 0, !1, w, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(w) {
    var M = w[0];
    v[M] = new b(M, 1, !1, w[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(w) {
    v[w] = new b(w, 2, !1, w.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(w) {
    v[w] = new b(w, 2, !1, w, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(w) {
    v[w] = new b(w, 3, !1, w.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(w) {
    v[w] = new b(w, 3, !0, w, null, !1, !1);
  }), ["capture", "download"].forEach(function(w) {
    v[w] = new b(w, 4, !1, w, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(w) {
    v[w] = new b(w, 6, !1, w, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(w) {
    v[w] = new b(w, 5, !1, w.toLowerCase(), null, !1, !1);
  });
  var E = /[\-:]([a-z])/g;
  function N(w) {
    return w[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(w) {
    var M = w.replace(
      E,
      N
    );
    v[M] = new b(M, 1, !1, w, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(w) {
    var M = w.replace(E, N);
    v[M] = new b(M, 1, !1, w, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(w) {
    var M = w.replace(E, N);
    v[M] = new b(M, 1, !1, w, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(w) {
    v[w] = new b(w, 1, !1, w.toLowerCase(), null, !1, !1);
  }), v.xlinkHref = new b("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(w) {
    v[w] = new b(w, 1, !1, w.toLowerCase(), null, !0, !0);
  });
  var R = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, L = ["Webkit", "ms", "Moz", "O"];
  Object.keys(R).forEach(function(w) {
    L.forEach(function(M) {
      M = M + w.charAt(0).toUpperCase() + w.substring(1), R[M] = R[w];
    });
  });
  var B = /["'&<>]/;
  function j(w) {
    if (typeof w == "boolean" || typeof w == "number")
      return "" + w;
    w = "" + w;
    var M = B.exec(w);
    if (M) {
      var W = "", ae, Le = 0;
      for (ae = M.index; ae < w.length; ae++) {
        switch (w.charCodeAt(ae)) {
          case 34:
            M = "&quot;";
            break;
          case 38:
            M = "&amp;";
            break;
          case 39:
            M = "&#x27;";
            break;
          case 60:
            M = "&lt;";
            break;
          case 62:
            M = "&gt;";
            break;
          default:
            continue;
        }
        Le !== ae && (W += w.substring(Le, ae)), Le = ae + 1, W += M;
      }
      w = Le !== ae ? W + w.substring(Le, ae) : W;
    }
    return w;
  }
  var Z = /([A-Z])/g, re = /^ms-/, X = Array.isArray, se = p("<script>"), Y = p("<\/script>"), ie = p('<script src="'), I = p('<script type="module" src="'), U = p('" async=""><\/script>'), ue = /(<\/|<)(s)(cript)/gi;
  function te(w, M, W, ae) {
    return "" + M + (W === "s" ? "\\u0073" : "\\u0053") + ae;
  }
  function J(w, M, W, ae, Le) {
    w = w === void 0 ? "" : w, M = M === void 0 ? se : p('<script nonce="' + j(M) + '">');
    var Te = [];
    if (W !== void 0 && Te.push(M, s(("" + W).replace(ue, te)), Y), ae !== void 0)
      for (W = 0; W < ae.length; W++)
        Te.push(ie, s(j(ae[W])), U);
    if (Le !== void 0)
      for (ae = 0; ae < Le.length; ae++)
        Te.push(I, s(j(Le[ae])), U);
    return { bootstrapChunks: Te, startInlineScript: M, placeholderPrefix: p(w + "P:"), segmentPrefix: p(w + "S:"), boundaryPrefix: w + "B:", idPrefix: w, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function Q(w, M) {
    return { insertionMode: w, selectedValue: M };
  }
  function G(w) {
    return Q(w === "http://www.w3.org/2000/svg" ? 2 : w === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function ne(w, M, W) {
    switch (M) {
      case "select":
        return Q(1, W.value != null ? W.value : W.defaultValue);
      case "svg":
        return Q(2, null);
      case "math":
        return Q(3, null);
      case "foreignObject":
        return Q(1, null);
      case "table":
        return Q(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return Q(5, null);
      case "colgroup":
        return Q(7, null);
      case "tr":
        return Q(6, null);
    }
    return 4 <= w.insertionMode || w.insertionMode === 0 ? Q(1, null) : w;
  }
  var H = p("<!-- -->");
  function ce(w, M, W, ae) {
    return M === "" ? ae : (ae && w.push(H), w.push(s(j(M))), !0);
  }
  var ke = /* @__PURE__ */ new Map(), Se = p(' style="'), xe = p(":"), De = p(";");
  function je(w, M, W) {
    if (typeof W != "object")
      throw Error(t(62));
    M = !0;
    for (var ae in W)
      if (g.call(W, ae)) {
        var Le = W[ae];
        if (Le != null && typeof Le != "boolean" && Le !== "") {
          if (ae.indexOf("--") === 0) {
            var Te = s(j(ae));
            Le = s(j(("" + Le).trim()));
          } else {
            Te = ae;
            var Me = ke.get(Te);
            Me !== void 0 || (Me = p(j(Te.replace(Z, "-$1").toLowerCase().replace(re, "-ms-"))), ke.set(Te, Me)), Te = Me, Le = typeof Le == "number" ? Le === 0 || g.call(R, ae) ? s("" + Le) : s(Le + "px") : s(j(("" + Le).trim()));
          }
          M ? (M = !1, w.push(Se, Te, xe, Le)) : w.push(De, Te, xe, Le);
        }
      }
    M || w.push(Ee);
  }
  var Ce = p(" "), ye = p('="'), Ee = p('"'), he = p('=""');
  function Be(w, M, W, ae) {
    switch (W) {
      case "style":
        je(w, M, ae);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < W.length) || W[0] !== "o" && W[0] !== "O" || W[1] !== "n" && W[1] !== "N") {
      if (M = v.hasOwnProperty(W) ? v[W] : null, M !== null) {
        switch (typeof ae) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!M.acceptsBooleans)
              return;
        }
        switch (W = s(M.attributeName), M.type) {
          case 3:
            ae && w.push(Ce, W, he);
            break;
          case 4:
            ae === !0 ? w.push(Ce, W, he) : ae !== !1 && w.push(Ce, W, ye, s(j(ae)), Ee);
            break;
          case 5:
            isNaN(ae) || w.push(Ce, W, ye, s(j(ae)), Ee);
            break;
          case 6:
            !isNaN(ae) && 1 <= ae && w.push(Ce, W, ye, s(j(ae)), Ee);
            break;
          default:
            M.sanitizeURL && (ae = "" + ae), w.push(Ce, W, ye, s(j(ae)), Ee);
        }
      } else if (A(W)) {
        switch (typeof ae) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (M = W.toLowerCase().slice(0, 5), M !== "data-" && M !== "aria-")
              return;
        }
        w.push(Ce, s(W), ye, s(j(ae)), Ee);
      }
    }
  }
  var $e = p(">"), tt = p("/>");
  function We(w, M, W) {
    if (M != null) {
      if (W != null)
        throw Error(t(60));
      if (typeof M != "object" || !("__html" in M))
        throw Error(t(61));
      M = M.__html, M != null && w.push(s("" + M));
    }
  }
  function Fe(w) {
    var M = "";
    return e.Children.forEach(w, function(W) {
      W != null && (M += W);
    }), M;
  }
  var Je = p(' selected=""');
  function Ke(w, M, W, ae) {
    w.push(Oe(W));
    var Le = W = null, Te;
    for (Te in M)
      if (g.call(M, Te)) {
        var Me = M[Te];
        if (Me != null)
          switch (Te) {
            case "children":
              W = Me;
              break;
            case "dangerouslySetInnerHTML":
              Le = Me;
              break;
            default:
              Be(w, ae, Te, Me);
          }
      }
    return w.push($e), We(w, Le, W), typeof W == "string" ? (w.push(s(j(W))), null) : W;
  }
  var Ye = p(`
`), Xe = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Ae = /* @__PURE__ */ new Map();
  function Oe(w) {
    var M = Ae.get(w);
    if (M === void 0) {
      if (!Xe.test(w))
        throw Error(t(65, w));
      M = p("<" + w), Ae.set(w, M);
    }
    return M;
  }
  var lt = p("<!DOCTYPE html>");
  function ve(w, M, W, ae, Le) {
    switch (M) {
      case "select":
        w.push(Oe("select"));
        var Te = null, Me = null;
        for (At in W)
          if (g.call(W, At)) {
            var qe = W[At];
            if (qe != null)
              switch (At) {
                case "children":
                  Te = qe;
                  break;
                case "dangerouslySetInnerHTML":
                  Me = qe;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  Be(w, ae, At, qe);
              }
          }
        return w.push($e), We(w, Me, Te), Te;
      case "option":
        Me = Le.selectedValue, w.push(Oe("option"));
        var St = qe = null, Et = null, At = null;
        for (Te in W)
          if (g.call(W, Te)) {
            var nn = W[Te];
            if (nn != null)
              switch (Te) {
                case "children":
                  qe = nn;
                  break;
                case "selected":
                  Et = nn;
                  break;
                case "dangerouslySetInnerHTML":
                  At = nn;
                  break;
                case "value":
                  St = nn;
                default:
                  Be(w, ae, Te, nn);
              }
          }
        if (Me != null)
          if (W = St !== null ? "" + St : Fe(qe), X(Me)) {
            for (ae = 0; ae < Me.length; ae++)
              if ("" + Me[ae] === W) {
                w.push(Je);
                break;
              }
          } else
            "" + Me === W && w.push(Je);
        else
          Et && w.push(Je);
        return w.push($e), We(w, At, qe), qe;
      case "textarea":
        w.push(Oe("textarea")), At = Me = Te = null;
        for (qe in W)
          if (g.call(W, qe) && (St = W[qe], St != null))
            switch (qe) {
              case "children":
                At = St;
                break;
              case "value":
                Te = St;
                break;
              case "defaultValue":
                Me = St;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                Be(w, ae, qe, St);
            }
        if (Te === null && Me !== null && (Te = Me), w.push($e), At != null) {
          if (Te != null)
            throw Error(t(92));
          if (X(At) && 1 < At.length)
            throw Error(t(93));
          Te = "" + At;
        }
        return typeof Te == "string" && Te[0] === `
` && w.push(Ye), Te !== null && w.push(s(j("" + Te))), null;
      case "input":
        w.push(Oe("input")), St = At = qe = Te = null;
        for (Me in W)
          if (g.call(W, Me) && (Et = W[Me], Et != null))
            switch (Me) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                St = Et;
                break;
              case "defaultValue":
                qe = Et;
                break;
              case "checked":
                At = Et;
                break;
              case "value":
                Te = Et;
                break;
              default:
                Be(w, ae, Me, Et);
            }
        return At !== null ? Be(
          w,
          ae,
          "checked",
          At
        ) : St !== null && Be(w, ae, "checked", St), Te !== null ? Be(w, ae, "value", Te) : qe !== null && Be(w, ae, "value", qe), w.push(tt), null;
      case "menuitem":
        w.push(Oe("menuitem"));
        for (var Gn in W)
          if (g.call(W, Gn) && (Te = W[Gn], Te != null))
            switch (Gn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                Be(w, ae, Gn, Te);
            }
        return w.push($e), null;
      case "title":
        w.push(Oe("title")), Te = null;
        for (nn in W)
          if (g.call(W, nn) && (Me = W[nn], Me != null))
            switch (nn) {
              case "children":
                Te = Me;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                Be(w, ae, nn, Me);
            }
        return w.push($e), Te;
      case "listing":
      case "pre":
        w.push(Oe(M)), Me = Te = null;
        for (St in W)
          if (g.call(W, St) && (qe = W[St], qe != null))
            switch (St) {
              case "children":
                Te = qe;
                break;
              case "dangerouslySetInnerHTML":
                Me = qe;
                break;
              default:
                Be(w, ae, St, qe);
            }
        if (w.push($e), Me != null) {
          if (Te != null)
            throw Error(t(60));
          if (typeof Me != "object" || !("__html" in Me))
            throw Error(t(61));
          W = Me.__html, W != null && (typeof W == "string" && 0 < W.length && W[0] === `
` ? w.push(Ye, s(W)) : w.push(s("" + W)));
        }
        return typeof Te == "string" && Te[0] === `
` && w.push(Ye), Te;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        w.push(Oe(M));
        for (var cr in W)
          if (g.call(W, cr) && (Te = W[cr], Te != null))
            switch (cr) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, M));
              default:
                Be(w, ae, cr, Te);
            }
        return w.push(tt), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return Ke(w, W, M, ae);
      case "html":
        return Le.insertionMode === 0 && w.push(lt), Ke(w, W, M, ae);
      default:
        if (M.indexOf("-") === -1 && typeof W.is != "string")
          return Ke(w, W, M, ae);
        w.push(Oe(M)), Me = Te = null;
        for (Et in W)
          if (g.call(W, Et) && (qe = W[Et], qe != null))
            switch (Et) {
              case "children":
                Te = qe;
                break;
              case "dangerouslySetInnerHTML":
                Me = qe;
                break;
              case "style":
                je(w, ae, qe);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                A(Et) && typeof qe != "function" && typeof qe != "symbol" && w.push(Ce, s(Et), ye, s(j(qe)), Ee);
            }
        return w.push($e), We(w, Me, Te), Te;
    }
  }
  var mt = p("</"), ut = p(">"), st = p('<template id="'), Lt = p('"></template>'), Kt = p("<!--$-->"), Xt = p('<!--$?--><template id="'), It = p('"></template>'), ln = p("<!--$!-->"), Tt = p("<!--/$-->"), Ot = p("<template"), _t = p('"'), an = p(' data-dgst="');
  p(' data-msg="'), p(' data-stck="');
  var dn = p("></template>");
  function zt(w, M, W) {
    if (i(w, Xt), W === null)
      throw Error(t(395));
    return i(w, W), o(w, It);
  }
  var Bt = p('<div hidden id="'), on = p('">'), rt = p("</div>"), ht = p('<svg aria-hidden="true" style="display:none" id="'), Pe = p('">'), _e = p("</svg>"), we = p('<math aria-hidden="true" style="display:none" id="'), yt = p('">'), at = p("</math>"), bt = p('<table hidden id="'), wt = p('">'), qt = p("</table>"), ct = p('<table hidden><tbody id="'), dt = p('">'), Wt = p("</tbody></table>"), Yt = p('<table hidden><tr id="'), Rt = p('">'), Ct = p("</tr></table>"), xn = p('<table hidden><colgroup id="'), Sn = p('">'), Ln = p("</colgroup></table>");
  function On(w, M, W, ae) {
    switch (W.insertionMode) {
      case 0:
      case 1:
        return i(w, Bt), i(w, M.segmentPrefix), i(w, s(ae.toString(16))), o(w, on);
      case 2:
        return i(w, ht), i(w, M.segmentPrefix), i(w, s(ae.toString(16))), o(w, Pe);
      case 3:
        return i(w, we), i(w, M.segmentPrefix), i(w, s(ae.toString(16))), o(w, yt);
      case 4:
        return i(w, bt), i(w, M.segmentPrefix), i(w, s(ae.toString(16))), o(w, wt);
      case 5:
        return i(w, ct), i(w, M.segmentPrefix), i(w, s(ae.toString(16))), o(w, dt);
      case 6:
        return i(w, Yt), i(w, M.segmentPrefix), i(w, s(ae.toString(16))), o(w, Rt);
      case 7:
        return i(
          w,
          xn
        ), i(w, M.segmentPrefix), i(w, s(ae.toString(16))), o(w, Sn);
      default:
        throw Error(t(397));
    }
  }
  function En(w, M) {
    switch (M.insertionMode) {
      case 0:
      case 1:
        return o(w, rt);
      case 2:
        return o(w, _e);
      case 3:
        return o(w, at);
      case 4:
        return o(w, qt);
      case 5:
        return o(w, Wt);
      case 6:
        return o(w, Ct);
      case 7:
        return o(w, Ln);
      default:
        throw Error(t(397));
    }
  }
  var rr = p('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Mn = p('$RS("'), wn = p('","'), Pt = p('")<\/script>'), jt = p('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), kn = p('$RC("'), tn = p('","'), fn = p('")<\/script>'), An = p('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Dt = p('$RX("'), bn = p('"'), sn = p(")<\/script>"), hn = p(","), ir = /[<\u2028\u2029]/g;
  function Fn(w) {
    return JSON.stringify(w).replace(ir, function(M) {
      switch (M) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var Rn = Object.assign, yn = Symbol.for("react.element"), $n = Symbol.for("react.portal"), Hn = Symbol.for("react.fragment"), ar = Symbol.for("react.strict_mode"), gr = Symbol.for("react.profiler"), or = Symbol.for("react.provider"), jn = Symbol.for("react.context"), lr = Symbol.for("react.forward_ref"), Xn = Symbol.for("react.suspense"), qn = Symbol.for("react.suspense_list"), S = Symbol.for("react.memo"), _ = Symbol.for("react.lazy"), D = Symbol.for("react.scope"), K = Symbol.for("react.debug_trace_mode"), pe = Symbol.for("react.legacy_hidden"), O = Symbol.for("react.default_value"), $ = Symbol.iterator;
  function ee(w) {
    if (w == null)
      return null;
    if (typeof w == "function")
      return w.displayName || w.name || null;
    if (typeof w == "string")
      return w;
    switch (w) {
      case Hn:
        return "Fragment";
      case $n:
        return "Portal";
      case gr:
        return "Profiler";
      case ar:
        return "StrictMode";
      case Xn:
        return "Suspense";
      case qn:
        return "SuspenseList";
    }
    if (typeof w == "object")
      switch (w.$$typeof) {
        case jn:
          return (w.displayName || "Context") + ".Consumer";
        case or:
          return (w._context.displayName || "Context") + ".Provider";
        case lr:
          var M = w.render;
          return w = w.displayName, w || (w = M.displayName || M.name || "", w = w !== "" ? "ForwardRef(" + w + ")" : "ForwardRef"), w;
        case S:
          return M = w.displayName || null, M !== null ? M : ee(w.type) || "Memo";
        case _:
          M = w._payload, w = w._init;
          try {
            return ee(w(M));
          } catch {
          }
      }
    return null;
  }
  var be = {};
  function Ie(w, M) {
    if (w = w.contextTypes, !w)
      return be;
    var W = {}, ae;
    for (ae in w)
      W[ae] = M[ae];
    return W;
  }
  var Qe = null;
  function pt(w, M) {
    if (w !== M) {
      w.context._currentValue = w.parentValue, w = w.parent;
      var W = M.parent;
      if (w === null) {
        if (W !== null)
          throw Error(t(401));
      } else {
        if (W === null)
          throw Error(t(401));
        pt(w, W);
      }
      M.context._currentValue = M.value;
    }
  }
  function Ut(w) {
    w.context._currentValue = w.parentValue, w = w.parent, w !== null && Ut(w);
  }
  function $t(w) {
    var M = w.parent;
    M !== null && $t(M), w.context._currentValue = w.value;
  }
  function Qt(w, M) {
    if (w.context._currentValue = w.parentValue, w = w.parent, w === null)
      throw Error(t(402));
    w.depth === M.depth ? pt(w, M) : Qt(w, M);
  }
  function Jt(w, M) {
    var W = M.parent;
    if (W === null)
      throw Error(t(402));
    w.depth === W.depth ? pt(w, W) : Jt(w, W), M.context._currentValue = M.value;
  }
  function en(w) {
    var M = Qe;
    M !== w && (M === null ? $t(w) : w === null ? Ut(M) : M.depth === w.depth ? pt(M, w) : M.depth > w.depth ? Qt(M, w) : Jt(M, w), Qe = w);
  }
  var Vn = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(w, M) {
    w = w._reactInternals, w.queue !== null && w.queue.push(M);
  }, enqueueReplaceState: function(w, M) {
    w = w._reactInternals, w.replace = !0, w.queue = [M];
  }, enqueueForceUpdate: function() {
  } };
  function Zn(w, M, W, ae) {
    var Le = w.state !== void 0 ? w.state : null;
    w.updater = Vn, w.props = W, w.state = Le;
    var Te = { queue: [], replace: !1 };
    w._reactInternals = Te;
    var Me = M.contextType;
    if (w.context = typeof Me == "object" && Me !== null ? Me._currentValue : ae, Me = M.getDerivedStateFromProps, typeof Me == "function" && (Me = Me(W, Le), Le = Me == null ? Le : Rn({}, Le, Me), w.state = Le), typeof M.getDerivedStateFromProps != "function" && typeof w.getSnapshotBeforeUpdate != "function" && (typeof w.UNSAFE_componentWillMount == "function" || typeof w.componentWillMount == "function"))
      if (M = w.state, typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount(), M !== w.state && Vn.enqueueReplaceState(w, w.state, null), Te.queue !== null && 0 < Te.queue.length)
        if (M = Te.queue, Me = Te.replace, Te.queue = null, Te.replace = !1, Me && M.length === 1)
          w.state = M[0];
        else {
          for (Te = Me ? M[0] : w.state, Le = !0, Me = Me ? 1 : 0; Me < M.length; Me++) {
            var qe = M[Me];
            qe = typeof qe == "function" ? qe.call(w, Te, W, ae) : qe, qe != null && (Le ? (Le = !1, Te = Rn({}, Te, qe)) : Rn(Te, qe));
          }
          w.state = Te;
        }
      else
        Te.queue = null;
  }
  var Qn = { id: 1, overflow: "" };
  function Un(w, M, W) {
    var ae = w.id;
    w = w.overflow;
    var Le = 32 - Tr(ae) - 1;
    ae &= ~(1 << Le), W += 1;
    var Te = 32 - Tr(M) + Le;
    if (30 < Te) {
      var Me = Le - Le % 5;
      return Te = (ae & (1 << Me) - 1).toString(32), ae >>= Me, Le -= Me, { id: 1 << 32 - Tr(M) + Le | W << Le | ae, overflow: Te + w };
    }
    return { id: 1 << Te | W << Le | ae, overflow: w };
  }
  var Tr = Math.clz32 ? Math.clz32 : pn, wi = Math.log, Nt = Math.LN2;
  function pn(w) {
    return w >>>= 0, w === 0 ? 32 : 31 - (wi(w) / Nt | 0) | 0;
  }
  function oi(w, M) {
    return w === M && (w !== 0 || 1 / w === 1 / M) || w !== w && M !== M;
  }
  var Or = typeof Object.is == "function" ? Object.is : oi, sr = null, Mr = null, Kr = null, Ht = null, vr = !1, Kn = !1, Fr = 0, Ar = null, ki = 0;
  function Lr() {
    if (sr === null)
      throw Error(t(321));
    return sr;
  }
  function ur() {
    if (0 < ki)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function Ji() {
    return Ht === null ? Kr === null ? (vr = !1, Kr = Ht = ur()) : (vr = !0, Ht = Kr) : Ht.next === null ? (vr = !1, Ht = Ht.next = ur()) : (vr = !0, Ht = Ht.next), Ht;
  }
  function ea() {
    Mr = sr = null, Kn = !1, Kr = null, ki = 0, Ht = Ar = null;
  }
  function qa(w, M) {
    return typeof M == "function" ? M(w) : M;
  }
  function Za(w, M, W) {
    if (sr = Lr(), Ht = Ji(), vr) {
      var ae = Ht.queue;
      if (M = ae.dispatch, Ar !== null && (W = Ar.get(ae), W !== void 0)) {
        Ar.delete(ae), ae = Ht.memoizedState;
        do
          ae = w(ae, W.action), W = W.next;
        while (W !== null);
        return Ht.memoizedState = ae, [ae, M];
      }
      return [Ht.memoizedState, M];
    }
    return w = w === qa ? typeof M == "function" ? M() : M : W !== void 0 ? W(M) : M, Ht.memoizedState = w, w = Ht.queue = { last: null, dispatch: null }, w = w.dispatch = ml.bind(null, sr, w), [Ht.memoizedState, w];
  }
  function Qa(w, M) {
    if (sr = Lr(), Ht = Ji(), M = M === void 0 ? null : M, Ht !== null) {
      var W = Ht.memoizedState;
      if (W !== null && M !== null) {
        var ae = W[1];
        e:
          if (ae === null)
            ae = !1;
          else {
            for (var Le = 0; Le < ae.length && Le < M.length; Le++)
              if (!Or(M[Le], ae[Le])) {
                ae = !1;
                break e;
              }
            ae = !0;
          }
        if (ae)
          return W[0];
      }
    }
    return w = w(), Ht.memoizedState = [w, M], w;
  }
  function ml(w, M, W) {
    if (25 <= ki)
      throw Error(t(301));
    if (w === sr)
      if (Kn = !0, w = { action: W, next: null }, Ar === null && (Ar = /* @__PURE__ */ new Map()), W = Ar.get(M), W === void 0)
        Ar.set(M, w);
      else {
        for (M = W; M.next !== null; )
          M = M.next;
        M.next = w;
      }
  }
  function yl() {
    throw Error(t(394));
  }
  function Ti() {
  }
  var Ci = { readContext: function(w) {
    return w._currentValue;
  }, useContext: function(w) {
    return Lr(), w._currentValue;
  }, useMemo: Qa, useReducer: Za, useRef: function(w) {
    sr = Lr(), Ht = Ji();
    var M = Ht.memoizedState;
    return M === null ? (w = { current: w }, Ht.memoizedState = w) : M;
  }, useState: function(w) {
    return Za(qa, w);
  }, useInsertionEffect: Ti, useLayoutEffect: function() {
  }, useCallback: function(w, M) {
    return Qa(function() {
      return w;
    }, M);
  }, useImperativeHandle: Ti, useEffect: Ti, useDebugValue: Ti, useDeferredValue: function(w) {
    return Lr(), w;
  }, useTransition: function() {
    return Lr(), [!1, yl];
  }, useId: function() {
    var w = Mr.treeContext, M = w.overflow;
    w = w.id, w = (w & ~(1 << 32 - Tr(w) - 1)).toString(32) + M;
    var W = Ai;
    if (W === null)
      throw Error(t(404));
    return M = Fr++, w = ":" + W.idPrefix + "R" + w, 0 < M && (w += "H" + M.toString(32)), w + ":";
  }, useMutableSource: function(w, M) {
    return Lr(), M(w._source);
  }, useSyncExternalStore: function(w, M, W) {
    if (W === void 0)
      throw Error(t(407));
    return W();
  } }, Ai = null, li = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function gl(w) {
    return console.error(w), null;
  }
  function si() {
  }
  function ta(w, M, W, ae, Le, Te, Me, qe, St) {
    var Et = [], At = /* @__PURE__ */ new Set();
    return M = { destination: null, responseState: M, progressiveChunkSize: ae === void 0 ? 12800 : ae, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: At, pingedTasks: Et, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Le === void 0 ? gl : Le, onAllReady: Te === void 0 ? si : Te, onShellReady: Me === void 0 ? si : Me, onShellError: qe === void 0 ? si : qe, onFatalError: St === void 0 ? si : St }, W = Yr(M, 0, null, W, !1, !1), W.parentFlushed = !0, w = na(M, w, null, W, At, be, null, Qn), Et.push(w), M;
  }
  function na(w, M, W, ae, Le, Te, Me, qe) {
    w.allPendingTasks++, W === null ? w.pendingRootTasks++ : W.pendingTasks++;
    var St = { node: M, ping: function() {
      var Et = w.pingedTasks;
      Et.push(St), Et.length === 1 && io(w);
    }, blockedBoundary: W, blockedSegment: ae, abortSet: Le, legacyContext: Te, context: Me, treeContext: qe };
    return Le.add(St), St;
  }
  function Yr(w, M, W, ae, Le, Te) {
    return { status: 0, id: -1, index: M, parentFlushed: !1, chunks: [], children: [], formatContext: ae, boundary: W, lastPushedText: Le, textEmbedded: Te };
  }
  function Gr(w, M) {
    if (w = w.onError(M), w != null && typeof w != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof w + '" instead');
    return w;
  }
  function Li(w, M) {
    var W = w.onShellError;
    W(M), W = w.onFatalError, W(M), w.destination !== null ? (w.status = 2, m(w.destination, M)) : (w.status = 1, w.fatalError = M);
  }
  function Ja(w, M, W, ae, Le) {
    for (sr = {}, Mr = M, Fr = 0, w = W(ae, Le); Kn; )
      Kn = !1, Fr = 0, ki += 1, Ht = null, w = W(ae, Le);
    return ea(), w;
  }
  function ra(w, M, W, ae) {
    var Le = W.render(), Te = ae.childContextTypes;
    if (Te != null) {
      var Me = M.legacyContext;
      if (typeof W.getChildContext != "function")
        ae = Me;
      else {
        W = W.getChildContext();
        for (var qe in W)
          if (!(qe in Te))
            throw Error(t(108, ee(ae) || "Unknown", qe));
        ae = Rn({}, Me, W);
      }
      M.legacyContext = ae, Yn(w, M, Le), M.legacyContext = Me;
    } else
      Yn(w, M, Le);
  }
  function eo(w, M) {
    if (w && w.defaultProps) {
      M = Rn({}, M), w = w.defaultProps;
      for (var W in w)
        M[W] === void 0 && (M[W] = w[W]);
      return M;
    }
    return M;
  }
  function Ei(w, M, W, ae, Le) {
    if (typeof W == "function")
      if (W.prototype && W.prototype.isReactComponent) {
        Le = Ie(W, M.legacyContext);
        var Te = W.contextType;
        Te = new W(ae, typeof Te == "object" && Te !== null ? Te._currentValue : Le), Zn(Te, W, ae, Le), ra(w, M, Te, W);
      } else {
        Te = Ie(W, M.legacyContext), Le = Ja(w, M, W, ae, Te);
        var Me = Fr !== 0;
        if (typeof Le == "object" && Le !== null && typeof Le.render == "function" && Le.$$typeof === void 0)
          Zn(Le, W, ae, Te), ra(w, M, Le, W);
        else if (Me) {
          ae = M.treeContext, M.treeContext = Un(ae, 1, 0);
          try {
            Yn(w, M, Le);
          } finally {
            M.treeContext = ae;
          }
        } else
          Yn(w, M, Le);
      }
    else if (typeof W == "string") {
      switch (Le = M.blockedSegment, Te = ve(Le.chunks, W, ae, w.responseState, Le.formatContext), Le.lastPushedText = !1, Me = Le.formatContext, Le.formatContext = ne(Me, W, ae), Ri(w, M, Te), Le.formatContext = Me, W) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Le.chunks.push(mt, s(W), ut);
      }
      Le.lastPushedText = !1;
    } else {
      switch (W) {
        case pe:
        case K:
        case ar:
        case gr:
        case Hn:
          Yn(w, M, ae.children);
          return;
        case qn:
          Yn(w, M, ae.children);
          return;
        case D:
          throw Error(t(343));
        case Xn:
          e: {
            W = M.blockedBoundary, Le = M.blockedSegment, Te = ae.fallback, ae = ae.children, Me = /* @__PURE__ */ new Set();
            var qe = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Me, errorDigest: null }, St = Yr(w, Le.chunks.length, qe, Le.formatContext, !1, !1);
            Le.children.push(St), Le.lastPushedText = !1;
            var Et = Yr(w, 0, null, Le.formatContext, !1, !1);
            Et.parentFlushed = !0, M.blockedBoundary = qe, M.blockedSegment = Et;
            try {
              if (Ri(
                w,
                M,
                ae
              ), Et.lastPushedText && Et.textEmbedded && Et.chunks.push(H), Et.status = 1, Ni(qe, Et), qe.pendingTasks === 0)
                break e;
            } catch (At) {
              Et.status = 4, qe.forceClientRender = !0, qe.errorDigest = Gr(w, At);
            } finally {
              M.blockedBoundary = W, M.blockedSegment = Le;
            }
            M = na(w, Te, W, St, Me, M.legacyContext, M.context, M.treeContext), w.pingedTasks.push(M);
          }
          return;
      }
      if (typeof W == "object" && W !== null)
        switch (W.$$typeof) {
          case lr:
            if (ae = Ja(w, M, W.render, ae, Le), Fr !== 0) {
              W = M.treeContext, M.treeContext = Un(W, 1, 0);
              try {
                Yn(w, M, ae);
              } finally {
                M.treeContext = W;
              }
            } else
              Yn(w, M, ae);
            return;
          case S:
            W = W.type, ae = eo(W, ae), Ei(w, M, W, ae, Le);
            return;
          case or:
            if (Le = ae.children, W = W._context, ae = ae.value, Te = W._currentValue, W._currentValue = ae, Me = Qe, Qe = ae = { parent: Me, depth: Me === null ? 0 : Me.depth + 1, context: W, parentValue: Te, value: ae }, M.context = ae, Yn(w, M, Le), w = Qe, w === null)
              throw Error(t(403));
            ae = w.parentValue, w.context._currentValue = ae === O ? w.context._defaultValue : ae, w = Qe = w.parent, M.context = w;
            return;
          case jn:
            ae = ae.children, ae = ae(W._currentValue), Yn(w, M, ae);
            return;
          case _:
            Le = W._init, W = Le(W._payload), ae = eo(W, ae), Ei(w, M, W, ae, void 0);
            return;
        }
      throw Error(t(
        130,
        W == null ? W : typeof W,
        ""
      ));
    }
  }
  function Yn(w, M, W) {
    if (M.node = W, typeof W == "object" && W !== null) {
      switch (W.$$typeof) {
        case yn:
          Ei(w, M, W.type, W.props, W.ref);
          return;
        case $n:
          throw Error(t(257));
        case _:
          var ae = W._init;
          W = ae(W._payload), Yn(w, M, W);
          return;
      }
      if (X(W)) {
        to(w, M, W);
        return;
      }
      if (W === null || typeof W != "object" ? ae = null : (ae = $ && W[$] || W["@@iterator"], ae = typeof ae == "function" ? ae : null), ae && (ae = ae.call(W))) {
        if (W = ae.next(), !W.done) {
          var Le = [];
          do
            Le.push(W.value), W = ae.next();
          while (!W.done);
          to(w, M, Le);
        }
        return;
      }
      throw w = Object.prototype.toString.call(W), Error(t(31, w === "[object Object]" ? "object with keys {" + Object.keys(W).join(", ") + "}" : w));
    }
    typeof W == "string" ? (ae = M.blockedSegment, ae.lastPushedText = ce(M.blockedSegment.chunks, W, w.responseState, ae.lastPushedText)) : typeof W == "number" && (ae = M.blockedSegment, ae.lastPushedText = ce(M.blockedSegment.chunks, "" + W, w.responseState, ae.lastPushedText));
  }
  function to(w, M, W) {
    for (var ae = W.length, Le = 0; Le < ae; Le++) {
      var Te = M.treeContext;
      M.treeContext = Un(Te, ae, Le);
      try {
        Ri(w, M, W[Le]);
      } finally {
        M.treeContext = Te;
      }
    }
  }
  function Ri(w, M, W) {
    var ae = M.blockedSegment.formatContext, Le = M.legacyContext, Te = M.context;
    try {
      return Yn(w, M, W);
    } catch (St) {
      if (ea(), typeof St == "object" && St !== null && typeof St.then == "function") {
        W = St;
        var Me = M.blockedSegment, qe = Yr(w, Me.chunks.length, null, Me.formatContext, Me.lastPushedText, !0);
        Me.children.push(qe), Me.lastPushedText = !1, w = na(w, M.node, M.blockedBoundary, qe, M.abortSet, M.legacyContext, M.context, M.treeContext).ping, W.then(w, w), M.blockedSegment.formatContext = ae, M.legacyContext = Le, M.context = Te, en(Te);
      } else
        throw M.blockedSegment.formatContext = ae, M.legacyContext = Le, M.context = Te, en(Te), St;
    }
  }
  function vl(w) {
    var M = w.blockedBoundary;
    w = w.blockedSegment, w.status = 3, ro(this, M, w);
  }
  function no(w, M, W) {
    var ae = w.blockedBoundary;
    w.blockedSegment.status = 3, ae === null ? (M.allPendingTasks--, M.status !== 2 && (M.status = 2, M.destination !== null && M.destination.close())) : (ae.pendingTasks--, ae.forceClientRender || (ae.forceClientRender = !0, w = W === void 0 ? Error(t(432)) : W, ae.errorDigest = M.onError(w), ae.parentFlushed && M.clientRenderedBoundaries.push(ae)), ae.fallbackAbortableTasks.forEach(function(Le) {
      return no(Le, M, W);
    }), ae.fallbackAbortableTasks.clear(), M.allPendingTasks--, M.allPendingTasks === 0 && (ae = M.onAllReady, ae()));
  }
  function Ni(w, M) {
    if (M.chunks.length === 0 && M.children.length === 1 && M.children[0].boundary === null) {
      var W = M.children[0];
      W.id = M.id, W.parentFlushed = !0, W.status === 1 && Ni(w, W);
    } else
      w.completedSegments.push(M);
  }
  function ro(w, M, W) {
    if (M === null) {
      if (W.parentFlushed) {
        if (w.completedRootSegment !== null)
          throw Error(t(389));
        w.completedRootSegment = W;
      }
      w.pendingRootTasks--, w.pendingRootTasks === 0 && (w.onShellError = si, M = w.onShellReady, M());
    } else
      M.pendingTasks--, M.forceClientRender || (M.pendingTasks === 0 ? (W.parentFlushed && W.status === 1 && Ni(M, W), M.parentFlushed && w.completedBoundaries.push(M), M.fallbackAbortableTasks.forEach(vl, w), M.fallbackAbortableTasks.clear()) : W.parentFlushed && W.status === 1 && (Ni(M, W), M.completedSegments.length === 1 && M.parentFlushed && w.partialBoundaries.push(M)));
    w.allPendingTasks--, w.allPendingTasks === 0 && (w = w.onAllReady, w());
  }
  function io(w) {
    if (w.status !== 2) {
      var M = Qe, W = li.current;
      li.current = Ci;
      var ae = Ai;
      Ai = w.responseState;
      try {
        var Le = w.pingedTasks, Te;
        for (Te = 0; Te < Le.length; Te++) {
          var Me = Le[Te], qe = w, St = Me.blockedSegment;
          if (St.status === 0) {
            en(Me.context);
            try {
              Yn(qe, Me, Me.node), St.lastPushedText && St.textEmbedded && St.chunks.push(H), Me.abortSet.delete(Me), St.status = 1, ro(qe, Me.blockedBoundary, St);
            } catch (dr) {
              if (ea(), typeof dr == "object" && dr !== null && typeof dr.then == "function") {
                var Et = Me.ping;
                dr.then(Et, Et);
              } else {
                Me.abortSet.delete(Me), St.status = 4;
                var At = Me.blockedBoundary, nn = dr, Gn = Gr(qe, nn);
                if (At === null ? Li(qe, nn) : (At.pendingTasks--, At.forceClientRender || (At.forceClientRender = !0, At.errorDigest = Gn, At.parentFlushed && qe.clientRenderedBoundaries.push(At))), qe.allPendingTasks--, qe.allPendingTasks === 0) {
                  var cr = qe.onAllReady;
                  cr();
                }
              }
            } finally {
            }
          }
        }
        Le.splice(0, Te), w.destination !== null && ia(w, w.destination);
      } catch (dr) {
        Gr(w, dr), Li(w, dr);
      } finally {
        Ai = ae, li.current = W, W === Ci && en(M);
      }
    }
  }
  function Pi(w, M, W) {
    switch (W.parentFlushed = !0, W.status) {
      case 0:
        var ae = W.id = w.nextSegmentId++;
        return W.lastPushedText = !1, W.textEmbedded = !1, w = w.responseState, i(M, st), i(M, w.placeholderPrefix), w = s(ae.toString(16)), i(M, w), o(M, Lt);
      case 1:
        W.status = 2;
        var Le = !0;
        ae = W.chunks;
        var Te = 0;
        W = W.children;
        for (var Me = 0; Me < W.length; Me++) {
          for (Le = W[Me]; Te < Le.index; Te++)
            i(M, ae[Te]);
          Le = Di(w, M, Le);
        }
        for (; Te < ae.length - 1; Te++)
          i(M, ae[Te]);
        return Te < ae.length && (Le = o(M, ae[Te])), Le;
      default:
        throw Error(t(390));
    }
  }
  function Di(w, M, W) {
    var ae = W.boundary;
    if (ae === null)
      return Pi(w, M, W);
    if (ae.parentFlushed = !0, ae.forceClientRender)
      ae = ae.errorDigest, o(M, ln), i(M, Ot), ae && (i(M, an), i(M, s(j(ae))), i(M, _t)), o(M, dn), Pi(w, M, W);
    else if (0 < ae.pendingTasks) {
      ae.rootSegmentID = w.nextSegmentId++, 0 < ae.completedSegments.length && w.partialBoundaries.push(ae);
      var Le = w.responseState, Te = Le.nextSuspenseID++;
      Le = p(Le.boundaryPrefix + Te.toString(16)), ae = ae.id = Le, zt(M, w.responseState, ae), Pi(w, M, W);
    } else if (ae.byteSize > w.progressiveChunkSize)
      ae.rootSegmentID = w.nextSegmentId++, w.completedBoundaries.push(ae), zt(M, w.responseState, ae.id), Pi(w, M, W);
    else {
      if (o(M, Kt), W = ae.completedSegments, W.length !== 1)
        throw Error(t(391));
      Di(w, M, W[0]);
    }
    return o(M, Tt);
  }
  function ao(w, M, W) {
    return On(M, w.responseState, W.formatContext, W.id), Di(w, M, W), En(M, W.formatContext);
  }
  function oo(w, M, W) {
    for (var ae = W.completedSegments, Le = 0; Le < ae.length; Le++)
      lo(w, M, W, ae[Le]);
    if (ae.length = 0, w = w.responseState, ae = W.id, W = W.rootSegmentID, i(M, w.startInlineScript), w.sentCompleteBoundaryFunction ? i(M, kn) : (w.sentCompleteBoundaryFunction = !0, i(M, jt)), ae === null)
      throw Error(t(395));
    return W = s(W.toString(16)), i(M, ae), i(M, tn), i(M, w.segmentPrefix), i(M, W), o(M, fn);
  }
  function lo(w, M, W, ae) {
    if (ae.status === 2)
      return !0;
    var Le = ae.id;
    if (Le === -1) {
      if ((ae.id = W.rootSegmentID) === -1)
        throw Error(t(392));
      return ao(w, M, ae);
    }
    return ao(w, M, ae), w = w.responseState, i(M, w.startInlineScript), w.sentCompleteSegmentFunction ? i(M, Mn) : (w.sentCompleteSegmentFunction = !0, i(M, rr)), i(M, w.segmentPrefix), Le = s(Le.toString(16)), i(M, Le), i(M, wn), i(M, w.placeholderPrefix), i(M, Le), o(M, Pt);
  }
  function ia(w, M) {
    n = new Uint8Array(512), r = 0;
    try {
      var W = w.completedRootSegment;
      if (W !== null && w.pendingRootTasks === 0) {
        Di(w, M, W), w.completedRootSegment = null;
        var ae = w.responseState.bootstrapChunks;
        for (W = 0; W < ae.length - 1; W++)
          i(M, ae[W]);
        W < ae.length && o(M, ae[W]);
      }
      var Le = w.clientRenderedBoundaries, Te;
      for (Te = 0; Te < Le.length; Te++) {
        var Me = Le[Te];
        ae = M;
        var qe = w.responseState, St = Me.id, Et = Me.errorDigest, At = Me.errorMessage, nn = Me.errorComponentStack;
        if (i(ae, qe.startInlineScript), qe.sentClientRenderFunction ? i(ae, Dt) : (qe.sentClientRenderFunction = !0, i(
          ae,
          An
        )), St === null)
          throw Error(t(395));
        i(ae, St), i(ae, bn), (Et || At || nn) && (i(ae, hn), i(ae, s(Fn(Et || "")))), (At || nn) && (i(ae, hn), i(ae, s(Fn(At || "")))), nn && (i(ae, hn), i(ae, s(Fn(nn)))), o(ae, sn);
      }
      Le.splice(0, Te);
      var Gn = w.completedBoundaries;
      for (Te = 0; Te < Gn.length; Te++)
        oo(w, M, Gn[Te]);
      Gn.splice(0, Te), d(M), n = new Uint8Array(512), r = 0;
      var cr = w.partialBoundaries;
      for (Te = 0; Te < cr.length; Te++) {
        var dr = cr[Te];
        e: {
          Le = w, Me = M;
          var _i = dr.completedSegments;
          for (qe = 0; qe < _i.length; qe++)
            if (!lo(
              Le,
              Me,
              dr,
              _i[qe]
            )) {
              qe++, _i.splice(0, qe);
              var uo = !1;
              break e;
            }
          _i.splice(0, qe), uo = !0;
        }
        if (!uo) {
          w.destination = null, Te++, cr.splice(0, Te);
          return;
        }
      }
      cr.splice(0, Te);
      var aa = w.completedBoundaries;
      for (Te = 0; Te < aa.length; Te++)
        oo(w, M, aa[Te]);
      aa.splice(0, Te);
    } finally {
      d(M), w.allPendingTasks === 0 && w.pingedTasks.length === 0 && w.clientRenderedBoundaries.length === 0 && w.completedBoundaries.length === 0 && M.close();
    }
  }
  function so(w, M) {
    try {
      var W = w.abortableTasks;
      W.forEach(function(ae) {
        return no(ae, w, M);
      }), W.clear(), w.destination !== null && ia(w, w.destination);
    } catch (ae) {
      Gr(w, ae), Li(w, ae);
    }
  }
  return Bu.renderToReadableStream = function(w, M) {
    return new Promise(function(W, ae) {
      var Le, Te, Me = new Promise(function(At, nn) {
        Te = At, Le = nn;
      }), qe = ta(w, J(M ? M.identifierPrefix : void 0, M ? M.nonce : void 0, M ? M.bootstrapScriptContent : void 0, M ? M.bootstrapScripts : void 0, M ? M.bootstrapModules : void 0), G(M ? M.namespaceURI : void 0), M ? M.progressiveChunkSize : void 0, M ? M.onError : void 0, Te, function() {
        var At = new ReadableStream({ type: "bytes", pull: function(nn) {
          if (qe.status === 1)
            qe.status = 2, m(nn, qe.fatalError);
          else if (qe.status !== 2 && qe.destination === null) {
            qe.destination = nn;
            try {
              ia(qe, nn);
            } catch (Gn) {
              Gr(qe, Gn), Li(qe, Gn);
            }
          }
        }, cancel: function() {
          so(qe);
        } }, { highWaterMark: 0 });
        At.allReady = Me, W(At);
      }, function(At) {
        Me.catch(function() {
        }), ae(At);
      }, Le);
      if (M && M.signal) {
        var St = M.signal, Et = function() {
          so(qe, St.reason), St.removeEventListener("abort", Et);
        };
        St.addEventListener("abort", Et);
      }
      io(qe);
    });
  }, Bu.version = "18.2.0", Bu;
}
var Ma = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var im;
function ww() {
  return im || (im = 1, process.env.NODE_ENV !== "production" && function() {
    var e = de, t = "18.2.0", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(l) {
      {
        for (var f = arguments.length, k = new Array(f > 1 ? f - 1 : 0), P = 1; P < f; P++)
          k[P - 1] = arguments[P];
        o("warn", l, k);
      }
    }
    function i(l) {
      {
        for (var f = arguments.length, k = new Array(f > 1 ? f - 1 : 0), P = 1; P < f; P++)
          k[P - 1] = arguments[P];
        o("error", l, k);
      }
    }
    function o(l, f, k) {
      {
        var P = n.ReactDebugCurrentFrame, V = P.getStackAddendum();
        V !== "" && (f += "%s", k = k.concat([V]));
        var le = k.map(function(me) {
          return String(me);
        });
        le.unshift("Warning: " + f), Function.prototype.apply.call(console[l], console, le);
      }
    }
    function d(l) {
      l();
    }
    function c(l) {
    }
    function s(l, f) {
      p(l, f);
    }
    function p(l, f) {
      return l.push(f);
    }
    function m(l) {
    }
    function g(l) {
      l.push(null);
    }
    function x(l) {
      return l;
    }
    function T(l) {
      return l;
    }
    function y(l, f) {
      l.destroy(f);
    }
    function A(l) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, k = f && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return k;
      }
    }
    function b(l) {
      try {
        return v(l), !1;
      } catch {
        return !0;
      }
    }
    function v(l) {
      return "" + l;
    }
    function E(l, f) {
      if (b(l))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", f, A(l)), v(l);
    }
    function N(l, f) {
      if (b(l))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", f, A(l)), v(l);
    }
    function R(l) {
      if (b(l))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", A(l)), v(l);
    }
    var L = Object.prototype.hasOwnProperty, B = 0, j = 1, Z = 2, re = 3, X = 4, se = 5, Y = 6, ie = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", I = ie + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", U = new RegExp("^[" + ie + "][" + I + "]*$"), ue = {}, te = {};
    function J(l) {
      return L.call(te, l) ? !0 : L.call(ue, l) ? !1 : U.test(l) ? (te[l] = !0, !0) : (ue[l] = !0, i("Invalid attribute name: `%s`", l), !1);
    }
    function Q(l, f, k, P) {
      if (k !== null && k.type === B)
        return !1;
      switch (typeof f) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (P)
            return !1;
          if (k !== null)
            return !k.acceptsBooleans;
          var V = l.toLowerCase().slice(0, 5);
          return V !== "data-" && V !== "aria-";
        }
        default:
          return !1;
      }
    }
    function G(l) {
      return H.hasOwnProperty(l) ? H[l] : null;
    }
    function ne(l, f, k, P, V, le, me) {
      this.acceptsBooleans = f === Z || f === re || f === X, this.attributeName = P, this.attributeNamespace = V, this.mustUseProperty = k, this.propertyName = l, this.type = f, this.sanitizeURL = le, this.removeEmptyString = me;
    }
    var H = {}, ce = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ce.forEach(function(l) {
      H[l] = new ne(
        l,
        B,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
      var f = l[0], k = l[1];
      H[f] = new ne(
        f,
        j,
        !1,
        // mustUseProperty
        k,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
      H[l] = new ne(
        l,
        Z,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
      H[l] = new ne(
        l,
        Z,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(l) {
      H[l] = new ne(
        l,
        re,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      H[l] = new ne(
        l,
        re,
        !0,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      H[l] = new ne(
        l,
        X,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      H[l] = new ne(
        l,
        Y,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(l) {
      H[l] = new ne(
        l,
        se,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ke = /[\-\:]([a-z])/g, Se = function(l) {
      return l[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ke, Se);
      H[f] = new ne(
        f,
        j,
        !1,
        // mustUseProperty
        l,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ke, Se);
      H[f] = new ne(
        f,
        j,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ke, Se);
      H[f] = new ne(
        f,
        j,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(l) {
      H[l] = new ne(
        l,
        j,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var xe = "xlinkHref";
    H[xe] = new ne(
      "xlinkHref",
      j,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(l) {
      H[l] = new ne(
        l,
        j,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var De = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function je(l, f) {
      return l + f.charAt(0).toUpperCase() + f.substring(1);
    }
    var Ce = ["Webkit", "ms", "Moz", "O"];
    Object.keys(De).forEach(function(l) {
      Ce.forEach(function(f) {
        De[je(f, l)] = De[l];
      });
    });
    var ye = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Ee(l, f) {
      ye[f.type] || f.onChange || f.onInput || f.readOnly || f.disabled || f.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), f.onChange || f.readOnly || f.disabled || f.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function he(l, f) {
      if (l.indexOf("-") === -1)
        return typeof f.is == "string";
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Be = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, $e = {}, tt = new RegExp("^(aria)-[" + I + "]*$"), We = new RegExp("^(aria)[A-Z][" + I + "]*$");
    function Fe(l, f) {
      {
        if (L.call($e, f) && $e[f])
          return !0;
        if (We.test(f)) {
          var k = "aria-" + f.slice(4).toLowerCase(), P = Be.hasOwnProperty(k) ? k : null;
          if (P == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", f), $e[f] = !0, !0;
          if (f !== P)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", f, P), $e[f] = !0, !0;
        }
        if (tt.test(f)) {
          var V = f.toLowerCase(), le = Be.hasOwnProperty(V) ? V : null;
          if (le == null)
            return $e[f] = !0, !1;
          if (f !== le)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", f, le), $e[f] = !0, !0;
        }
      }
      return !0;
    }
    function Je(l, f) {
      {
        var k = [];
        for (var P in f) {
          var V = Fe(l, P);
          V || k.push(P);
        }
        var le = k.map(function(me) {
          return "`" + me + "`";
        }).join(", ");
        k.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", le, l) : k.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", le, l);
      }
    }
    function Ke(l, f) {
      he(l, f) || Je(l, f);
    }
    var Ye = !1;
    function Xe(l, f) {
      {
        if (l !== "input" && l !== "textarea" && l !== "select")
          return;
        f != null && f.value === null && !Ye && (Ye = !0, l === "select" && f.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", l) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", l));
      }
    }
    var Ae = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Oe = function() {
    };
    {
      var lt = {}, ve = /^on./, mt = /^on[^A-Z]/, ut = new RegExp("^(aria)-[" + I + "]*$"), st = new RegExp("^(aria)[A-Z][" + I + "]*$");
      Oe = function(l, f, k, P) {
        if (L.call(lt, f) && lt[f])
          return !0;
        var V = f.toLowerCase();
        if (V === "onfocusin" || V === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), lt[f] = !0, !0;
        if (P != null) {
          var le = P.registrationNameDependencies, me = P.possibleRegistrationNames;
          if (le.hasOwnProperty(f))
            return !0;
          var Re = me.hasOwnProperty(V) ? me[V] : null;
          if (Re != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", f, Re), lt[f] = !0, !0;
          if (ve.test(f))
            return i("Unknown event handler property `%s`. It will be ignored.", f), lt[f] = !0, !0;
        } else if (ve.test(f))
          return mt.test(f) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", f), lt[f] = !0, !0;
        if (ut.test(f) || st.test(f))
          return !0;
        if (V === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), lt[f] = !0, !0;
        if (V === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), lt[f] = !0, !0;
        if (V === "is" && k !== null && k !== void 0 && typeof k != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof k), lt[f] = !0, !0;
        if (typeof k == "number" && isNaN(k))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", f), lt[f] = !0, !0;
        var He = G(f), ot = He !== null && He.type === B;
        if (Ae.hasOwnProperty(V)) {
          var ft = Ae[V];
          if (ft !== f)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", f, ft), lt[f] = !0, !0;
        } else if (!ot && f !== V)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", f, V), lt[f] = !0, !0;
        return typeof k == "boolean" && Q(f, k, He, !1) ? (k ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', k, f, f, k, f) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', k, f, f, k, f, f, f), lt[f] = !0, !0) : ot ? !0 : Q(f, k, He, !1) ? (lt[f] = !0, !1) : ((k === "false" || k === "true") && He !== null && He.type === re && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", k, f, k === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', f, k), lt[f] = !0), !0);
      };
    }
    var Lt = function(l, f, k) {
      {
        var P = [];
        for (var V in f) {
          var le = Oe(l, V, f[V], k);
          le || P.push(V);
        }
        var me = P.map(function(Re) {
          return "`" + Re + "`";
        }).join(", ");
        P.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", me, l) : P.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", me, l);
      }
    };
    function Kt(l, f, k) {
      he(l, f) || Lt(l, f, k);
    }
    var Xt = function() {
    };
    {
      var It = /^(?:webkit|moz|o)[A-Z]/, ln = /^-ms-/, Tt = /-(.)/g, Ot = /;\s*$/, _t = {}, an = {}, dn = !1, zt = !1, Bt = function(l) {
        return l.replace(Tt, function(f, k) {
          return k.toUpperCase();
        });
      }, on = function(l) {
        _t.hasOwnProperty(l) && _t[l] || (_t[l] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          l,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Bt(l.replace(ln, "ms-"))
        ));
      }, rt = function(l) {
        _t.hasOwnProperty(l) && _t[l] || (_t[l] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", l, l.charAt(0).toUpperCase() + l.slice(1)));
      }, ht = function(l, f) {
        an.hasOwnProperty(f) && an[f] || (an[f] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, l, f.replace(Ot, "")));
      }, Pe = function(l, f) {
        dn || (dn = !0, i("`NaN` is an invalid value for the `%s` css style property.", l));
      }, _e = function(l, f) {
        zt || (zt = !0, i("`Infinity` is an invalid value for the `%s` css style property.", l));
      };
      Xt = function(l, f) {
        l.indexOf("-") > -1 ? on(l) : It.test(l) ? rt(l) : Ot.test(f) && ht(l, f), typeof f == "number" && (isNaN(f) ? Pe(l, f) : isFinite(f) || _e(l, f));
      };
    }
    var we = Xt, yt = /["'&<>]/;
    function at(l) {
      R(l);
      var f = "" + l, k = yt.exec(f);
      if (!k)
        return f;
      var P, V = "", le, me = 0;
      for (le = k.index; le < f.length; le++) {
        switch (f.charCodeAt(le)) {
          case 34:
            P = "&quot;";
            break;
          case 38:
            P = "&amp;";
            break;
          case 39:
            P = "&#x27;";
            break;
          case 60:
            P = "&lt;";
            break;
          case 62:
            P = "&gt;";
            break;
          default:
            continue;
        }
        me !== le && (V += f.substring(me, le)), me = le + 1, V += P;
      }
      return me !== le ? V + f.substring(me, le) : V;
    }
    function bt(l) {
      return typeof l == "boolean" || typeof l == "number" ? "" + l : at(l);
    }
    var wt = /([A-Z])/g, qt = /^ms-/;
    function ct(l) {
      return l.replace(wt, "-$1").toLowerCase().replace(qt, "-ms-");
    }
    var dt = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Wt = !1;
    function Yt(l) {
      !Wt && dt.test(l) && (Wt = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(l)));
    }
    var Rt = Array.isArray;
    function Ct(l) {
      return Rt(l);
    }
    var xn = "<script>", Sn = "<\/script>", Ln = '<script src="', On = '<script type="module" src="', En = '" async=""><\/script>';
    function rr(l) {
      return R(l), ("" + l).replace(Mn, wn);
    }
    var Mn = /(<\/|<)(s)(cript)/gi, wn = function(l, f, k, P) {
      return "" + f + (k === "s" ? "\\u0073" : "\\u0053") + P;
    };
    function Pt(l, f, k, P, V) {
      var le = l === void 0 ? "" : l, me = f === void 0 ? xn : '<script nonce="' + bt(f) + '">', Re = [];
      if (k !== void 0 && Re.push(me, rr(k), Sn), P !== void 0)
        for (var He = 0; He < P.length; He++)
          Re.push(Ln, bt(P[He]), En);
      if (V !== void 0)
        for (var ot = 0; ot < V.length; ot++)
          Re.push(On, bt(V[ot]), En);
      return {
        bootstrapChunks: Re,
        startInlineScript: me,
        placeholderPrefix: le + "P:",
        segmentPrefix: le + "S:",
        boundaryPrefix: le + "B:",
        idPrefix: le,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var jt = 0, kn = 1, tn = 2, fn = 3, An = 4, Dt = 5, bn = 6, sn = 7;
    function hn(l, f) {
      return {
        insertionMode: l,
        selectedValue: f
      };
    }
    function ir(l, f, k) {
      switch (f) {
        case "select":
          return hn(kn, k.value != null ? k.value : k.defaultValue);
        case "svg":
          return hn(tn, null);
        case "math":
          return hn(fn, null);
        case "foreignObject":
          return hn(kn, null);
        case "table":
          return hn(An, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return hn(Dt, null);
        case "colgroup":
          return hn(sn, null);
        case "tr":
          return hn(bn, null);
      }
      return l.insertionMode >= An || l.insertionMode === jt ? hn(kn, null) : l;
    }
    var Fn = null;
    function Rn(l) {
      var f = l.nextSuspenseID++;
      return l.boundaryPrefix + f.toString(16);
    }
    function yn(l, f, k) {
      var P = l.idPrefix, V = ":" + P + "R" + f;
      return k > 0 && (V += "H" + k.toString(32)), V + ":";
    }
    function $n(l) {
      return bt(l);
    }
    var Hn = "<!-- -->";
    function ar(l, f, k, P) {
      return f === "" ? P : (P && l.push(Hn), l.push($n(f)), !0);
    }
    function gr(l, f, k, P) {
      k && P && l.push(Hn);
    }
    var or = /* @__PURE__ */ new Map();
    function jn(l) {
      var f = or.get(l);
      if (f !== void 0)
        return f;
      var k = bt(ct(l));
      return or.set(l, k), k;
    }
    var lr = ' style="', Xn = ":", qn = ";";
    function S(l, f, k) {
      if (typeof k != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var P = !0;
      for (var V in k)
        if (L.call(k, V)) {
          var le = k[V];
          if (!(le == null || typeof le == "boolean" || le === "")) {
            var me = void 0, Re = void 0, He = V.indexOf("--") === 0;
            He ? (me = bt(V), N(le, V), Re = bt(("" + le).trim())) : (we(V, le), me = jn(V), typeof le == "number" ? le !== 0 && !L.call(De, V) ? Re = le + "px" : Re = "" + le : (N(le, V), Re = bt(("" + le).trim()))), P ? (P = !1, l.push(lr, me, Xn, Re)) : l.push(qn, me, Xn, Re);
          }
        }
      P || l.push(K);
    }
    var _ = " ", D = '="', K = '"', pe = '=""';
    function O(l, f, k, P) {
      switch (k) {
        case "style": {
          S(l, f, P);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(k.length > 2 && (k[0] === "o" || k[0] === "O") && (k[1] === "n" || k[1] === "N"))
      ) {
        var V = G(k);
        if (V !== null) {
          switch (typeof P) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!V.acceptsBooleans)
                return;
          }
          var le = V.attributeName, me = le;
          switch (V.type) {
            case re:
              P && l.push(_, me, pe);
              return;
            case X:
              P === !0 ? l.push(_, me, pe) : P === !1 || l.push(_, me, D, bt(P), K);
              return;
            case se:
              isNaN(P) || l.push(_, me, D, bt(P), K);
              break;
            case Y:
              !isNaN(P) && P >= 1 && l.push(_, me, D, bt(P), K);
              break;
            default:
              V.sanitizeURL && (E(P, le), P = "" + P, Yt(P)), l.push(_, me, D, bt(P), K);
          }
        } else if (J(k)) {
          switch (typeof P) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Re = k.toLowerCase().slice(0, 5);
              if (Re !== "data-" && Re !== "aria-")
                return;
            }
          }
          l.push(_, k, D, bt(P), K);
        }
      }
    }
    var $ = ">", ee = "/>";
    function be(l, f, k) {
      if (f != null) {
        if (k != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof f != "object" || !("__html" in f))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var P = f.__html;
        P != null && (R(P), l.push("" + P));
      }
    }
    var Ie = !1, Qe = !1, pt = !1, Ut = !1, $t = !1, Qt = !1, Jt = !1;
    function en(l, f) {
      {
        var k = l[f];
        if (k != null) {
          var P = Ct(k);
          l.multiple && !P ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", f) : !l.multiple && P && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", f);
        }
      }
    }
    function Vn(l, f, k) {
      Ee("select", f), en(f, "value"), en(f, "defaultValue"), f.value !== void 0 && f.defaultValue !== void 0 && !pt && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), pt = !0), l.push(Kn("select"));
      var P = null, V = null;
      for (var le in f)
        if (L.call(f, le)) {
          var me = f[le];
          if (me == null)
            continue;
          switch (le) {
            case "children":
              P = me;
              break;
            case "dangerouslySetInnerHTML":
              V = me;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              O(l, k, le, me);
              break;
          }
        }
      return l.push($), be(l, V, P), P;
    }
    function Zn(l) {
      var f = "";
      return e.Children.forEach(l, function(k) {
        k != null && (f += k, !$t && typeof k != "string" && typeof k != "number" && ($t = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), f;
    }
    var Qn = ' selected=""';
    function Un(l, f, k, P) {
      var V = P.selectedValue;
      l.push(Kn("option"));
      var le = null, me = null, Re = null, He = null;
      for (var ot in f)
        if (L.call(f, ot)) {
          var ft = f[ot];
          if (ft == null)
            continue;
          switch (ot) {
            case "children":
              le = ft;
              break;
            case "selected":
              Re = ft, Jt || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Jt = !0);
              break;
            case "dangerouslySetInnerHTML":
              He = ft;
              break;
            case "value":
              me = ft;
            default:
              O(l, k, ot, ft);
              break;
          }
        }
      if (V != null) {
        var kt;
        if (me !== null ? (E(me, "value"), kt = "" + me) : (He !== null && (Qt || (Qt = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), kt = Zn(le)), Ct(V))
          for (var un = 0; un < V.length; un++) {
            E(V[un], "value");
            var Bn = "" + V[un];
            if (Bn === kt) {
              l.push(Qn);
              break;
            }
          }
        else
          E(V, "select.value"), "" + V === kt && l.push(Qn);
      } else
        Re && l.push(Qn);
      return l.push($), be(l, He, le), le;
    }
    function Tr(l, f, k) {
      Ee("input", f), f.checked !== void 0 && f.defaultChecked !== void 0 && !Qe && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), Qe = !0), f.value !== void 0 && f.defaultValue !== void 0 && !Ie && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), Ie = !0), l.push(Kn("input"));
      var P = null, V = null, le = null, me = null;
      for (var Re in f)
        if (L.call(f, Re)) {
          var He = f[Re];
          if (He == null)
            continue;
          switch (Re) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              me = He;
              break;
            case "defaultValue":
              V = He;
              break;
            case "checked":
              le = He;
              break;
            case "value":
              P = He;
              break;
            default:
              O(l, k, Re, He);
              break;
          }
        }
      return le !== null ? O(l, k, "checked", le) : me !== null && O(l, k, "checked", me), P !== null ? O(l, k, "value", P) : V !== null && O(l, k, "value", V), l.push(ee), null;
    }
    function wi(l, f, k) {
      Ee("textarea", f), f.value !== void 0 && f.defaultValue !== void 0 && !Ut && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Ut = !0), l.push(Kn("textarea"));
      var P = null, V = null, le = null;
      for (var me in f)
        if (L.call(f, me)) {
          var Re = f[me];
          if (Re == null)
            continue;
          switch (me) {
            case "children":
              le = Re;
              break;
            case "value":
              P = Re;
              break;
            case "defaultValue":
              V = Re;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              O(l, k, me, Re);
              break;
          }
        }
      if (P === null && V !== null && (P = V), l.push($), le != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), P != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (Ct(le)) {
          if (le.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          R(le[0]), P = "" + le[0];
        }
        R(le), P = "" + le;
      }
      return typeof P == "string" && P[0] === `
` && l.push(Mr), P !== null && (E(P, "value"), l.push($n("" + P))), null;
    }
    function Nt(l, f, k, P) {
      l.push(Kn(k));
      for (var V in f)
        if (L.call(f, V)) {
          var le = f[V];
          if (le == null)
            continue;
          switch (V) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(k + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              O(l, P, V, le);
              break;
          }
        }
      return l.push(ee), null;
    }
    function pn(l, f, k) {
      l.push(Kn("menuitem"));
      for (var P in f)
        if (L.call(f, P)) {
          var V = f[P];
          if (V == null)
            continue;
          switch (P) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              O(l, k, P, V);
              break;
          }
        }
      return l.push($), null;
    }
    function oi(l, f, k) {
      l.push(Kn("title"));
      var P = null;
      for (var V in f)
        if (L.call(f, V)) {
          var le = f[V];
          if (le == null)
            continue;
          switch (V) {
            case "children":
              P = le;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              O(l, k, V, le);
              break;
          }
        }
      l.push($);
      {
        var me = Array.isArray(P) && P.length < 2 ? P[0] || null : P;
        Array.isArray(P) && P.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : me != null && me.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : me != null && typeof me != "string" && typeof me != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return P;
    }
    function Or(l, f, k, P) {
      l.push(Kn(k));
      var V = null, le = null;
      for (var me in f)
        if (L.call(f, me)) {
          var Re = f[me];
          if (Re == null)
            continue;
          switch (me) {
            case "children":
              V = Re;
              break;
            case "dangerouslySetInnerHTML":
              le = Re;
              break;
            default:
              O(l, P, me, Re);
              break;
          }
        }
      return l.push($), be(l, le, V), typeof V == "string" ? (l.push($n(V)), null) : V;
    }
    function sr(l, f, k, P) {
      l.push(Kn(k));
      var V = null, le = null;
      for (var me in f)
        if (L.call(f, me)) {
          var Re = f[me];
          if (Re == null)
            continue;
          switch (me) {
            case "children":
              V = Re;
              break;
            case "dangerouslySetInnerHTML":
              le = Re;
              break;
            case "style":
              S(l, P, Re);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              J(me) && typeof Re != "function" && typeof Re != "symbol" && l.push(_, me, D, bt(Re), K);
              break;
          }
        }
      return l.push($), be(l, le, V), V;
    }
    var Mr = `
`;
    function Kr(l, f, k, P) {
      l.push(Kn(k));
      var V = null, le = null;
      for (var me in f)
        if (L.call(f, me)) {
          var Re = f[me];
          if (Re == null)
            continue;
          switch (me) {
            case "children":
              V = Re;
              break;
            case "dangerouslySetInnerHTML":
              le = Re;
              break;
            default:
              O(l, P, me, Re);
              break;
          }
        }
      if (l.push($), le != null) {
        if (V != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof le != "object" || !("__html" in le))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var He = le.__html;
        He != null && (typeof He == "string" && He.length > 0 && He[0] === `
` ? l.push(Mr, He) : (R(He), l.push("" + He)));
      }
      return typeof V == "string" && V[0] === `
` && l.push(Mr), V;
    }
    var Ht = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, vr = /* @__PURE__ */ new Map();
    function Kn(l) {
      var f = vr.get(l);
      if (f === void 0) {
        if (!Ht.test(l))
          throw new Error("Invalid tag: " + l);
        f = "<" + l, vr.set(l, f);
      }
      return f;
    }
    var Fr = "<!DOCTYPE html>";
    function Ar(l, f, k, P, V) {
      switch (Ke(f, k), Xe(f, k), Kt(f, k, null), !k.suppressContentEditableWarning && k.contentEditable && k.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), V.insertionMode !== tn && V.insertionMode !== fn && f.indexOf("-") === -1 && typeof k.is != "string" && f.toLowerCase() !== f && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", f), f) {
        case "select":
          return Vn(l, k, P);
        case "option":
          return Un(l, k, P, V);
        case "textarea":
          return wi(l, k, P);
        case "input":
          return Tr(l, k, P);
        case "menuitem":
          return pn(l, k, P);
        case "title":
          return oi(l, k, P);
        case "listing":
        case "pre":
          return Kr(l, k, f, P);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Nt(l, k, f, P);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Or(l, k, f, P);
        case "html":
          return V.insertionMode === jt && l.push(Fr), Or(l, k, f, P);
        default:
          return f.indexOf("-") === -1 && typeof k.is != "string" ? Or(l, k, f, P) : sr(l, k, f, P);
      }
    }
    var ki = "</", Lr = ">";
    function ur(l, f, k) {
      switch (f) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          l.push(ki, f, Lr);
      }
    }
    function Ji(l, f) {
      for (var k = f.bootstrapChunks, P = 0; P < k.length - 1; P++)
        s(l, k[P]);
      return P < k.length ? p(l, k[P]) : !0;
    }
    var ea = '<template id="', qa = '"></template>';
    function Za(l, f, k) {
      s(l, ea), s(l, f.placeholderPrefix);
      var P = k.toString(16);
      return s(l, P), p(l, qa);
    }
    var Qa = "<!--$-->", ml = '<!--$?--><template id="', yl = '"></template>', Ti = "<!--$!-->", Ci = "<!--/$-->", Ai = "<template", li = '"', gl = ' data-dgst="', si = ' data-msg="', ta = ' data-stck="', na = "></template>";
    function Yr(l, f) {
      return p(l, Qa);
    }
    function Gr(l, f, k) {
      if (s(l, ml), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, k), p(l, yl);
    }
    function Li(l, f, k, P, V) {
      var le;
      return le = p(l, Ti), s(l, Ai), k && (s(l, gl), s(l, bt(k)), s(l, li)), P && (s(l, si), s(l, bt(P)), s(l, li)), V && (s(l, ta), s(l, bt(V)), s(l, li)), le = p(l, na), le;
    }
    function Ja(l, f) {
      return p(l, Ci);
    }
    function ra(l, f) {
      return p(l, Ci);
    }
    function eo(l, f) {
      return p(l, Ci);
    }
    var Ei = '<div hidden id="', Yn = '">', to = "</div>", Ri = '<svg aria-hidden="true" style="display:none" id="', vl = '">', no = "</svg>", Ni = '<math aria-hidden="true" style="display:none" id="', ro = '">', io = "</math>", Pi = '<table hidden id="', Di = '">', ao = "</table>", oo = '<table hidden><tbody id="', lo = '">', ia = "</tbody></table>", so = '<table hidden><tr id="', w = '">', M = "</tr></table>", W = '<table hidden><colgroup id="', ae = '">', Le = "</colgroup></table>";
    function Te(l, f, k, P) {
      switch (k.insertionMode) {
        case jt:
        case kn:
          return s(l, Ei), s(l, f.segmentPrefix), s(l, P.toString(16)), p(l, Yn);
        case tn:
          return s(l, Ri), s(l, f.segmentPrefix), s(l, P.toString(16)), p(l, vl);
        case fn:
          return s(l, Ni), s(l, f.segmentPrefix), s(l, P.toString(16)), p(l, ro);
        case An:
          return s(l, Pi), s(l, f.segmentPrefix), s(l, P.toString(16)), p(l, Di);
        case Dt:
          return s(l, oo), s(l, f.segmentPrefix), s(l, P.toString(16)), p(l, lo);
        case bn:
          return s(l, so), s(l, f.segmentPrefix), s(l, P.toString(16)), p(l, w);
        case sn:
          return s(l, W), s(l, f.segmentPrefix), s(l, P.toString(16)), p(l, ae);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Me(l, f) {
      switch (f.insertionMode) {
        case jt:
        case kn:
          return p(l, to);
        case tn:
          return p(l, no);
        case fn:
          return p(l, io);
        case An:
          return p(l, ao);
        case Dt:
          return p(l, ia);
        case bn:
          return p(l, M);
        case sn:
          return p(l, Le);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var qe = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", St = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Et = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', At = qe + ';$RS("', nn = '$RS("', Gn = '","', cr = '")<\/script>';
    function dr(l, f, k) {
      s(l, f.startInlineScript), f.sentCompleteSegmentFunction ? s(l, nn) : (f.sentCompleteSegmentFunction = !0, s(l, At)), s(l, f.segmentPrefix);
      var P = k.toString(16);
      return s(l, P), s(l, Gn), s(l, f.placeholderPrefix), s(l, P), p(l, cr);
    }
    var _i = St + ';$RC("', uo = '$RC("', aa = '","', Kc = '")<\/script>';
    function Yc(l, f, k, P) {
      if (s(l, f.startInlineScript), f.sentCompleteBoundaryFunction ? s(l, uo) : (f.sentCompleteBoundaryFunction = !0, s(l, _i)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var V = P.toString(16);
      return s(l, k), s(l, aa), s(l, f.segmentPrefix), s(l, V), p(l, Kc);
    }
    var Gc = Et + ';$RX("', Xc = '$RX("', qc = '"', Zc = ")<\/script>", xl = ",";
    function Qc(l, f, k, P, V, le) {
      if (s(l, f.startInlineScript), f.sentClientRenderFunction ? s(l, Xc) : (f.sentClientRenderFunction = !0, s(l, Gc)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, k), s(l, qc), (P || V || le) && (s(l, xl), s(l, bl(P || ""))), (V || le) && (s(l, xl), s(l, bl(V || ""))), le && (s(l, xl), s(l, bl(le))), p(l, Zc);
    }
    var Jc = /[<\u2028\u2029]/g;
    function bl(l) {
      var f = JSON.stringify(l);
      return f.replace(Jc, function(k) {
        switch (k) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function ed(l, f) {
      var k = Pt(f, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: k.bootstrapChunks,
        startInlineScript: k.startInlineScript,
        placeholderPrefix: k.placeholderPrefix,
        segmentPrefix: k.segmentPrefix,
        boundaryPrefix: k.boundaryPrefix,
        idPrefix: k.idPrefix,
        nextSuspenseID: k.nextSuspenseID,
        sentCompleteSegmentFunction: k.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: k.sentCompleteBoundaryFunction,
        sentClientRenderFunction: k.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: l
      };
    }
    function Sl() {
      return {
        insertionMode: kn,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function zs(l, f, k, P) {
      return k.generateStaticMarkup ? (l.push(bt(f)), !1) : ar(l, f, k, P);
    }
    function Bs(l, f, k, P) {
      if (!f.generateStaticMarkup)
        return gr(l, f, k, P);
    }
    function wl(l, f) {
      return f.generateStaticMarkup ? !0 : Yr(l);
    }
    function xr(l, f, k, P, V) {
      return f.generateStaticMarkup ? !0 : Li(l, f, k, P, V);
    }
    function td(l, f) {
      return f.generateStaticMarkup ? !0 : Ja(l);
    }
    function Is(l, f) {
      return f.generateStaticMarkup ? !0 : eo(l);
    }
    var fr = Object.assign, $s = Symbol.for("react.element"), kl = Symbol.for("react.portal"), co = Symbol.for("react.fragment"), fo = Symbol.for("react.strict_mode"), ho = Symbol.for("react.profiler"), oa = Symbol.for("react.provider"), la = Symbol.for("react.context"), sa = Symbol.for("react.forward_ref"), Oi = Symbol.for("react.suspense"), Tl = Symbol.for("react.suspense_list"), Cl = Symbol.for("react.memo"), po = Symbol.for("react.lazy"), nd = Symbol.for("react.scope"), Hs = Symbol.for("react.debug_trace_mode"), rd = Symbol.for("react.legacy_hidden"), id = Symbol.for("react.default_value"), Vs = Symbol.iterator, Ws = "@@iterator";
    function gn(l) {
      if (l === null || typeof l != "object")
        return null;
      var f = Vs && l[Vs] || l[Ws];
      return typeof f == "function" ? f : null;
    }
    function ua(l, f, k) {
      var P = l.displayName;
      if (P)
        return P;
      var V = f.displayName || f.name || "";
      return V !== "" ? k + "(" + V + ")" : k;
    }
    function Al(l) {
      return l.displayName || "Context";
    }
    function mn(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case co:
          return "Fragment";
        case kl:
          return "Portal";
        case ho:
          return "Profiler";
        case fo:
          return "StrictMode";
        case Oi:
          return "Suspense";
        case Tl:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case la:
            var f = l;
            return Al(f) + ".Consumer";
          case oa:
            var k = l;
            return Al(k._context) + ".Provider";
          case sa:
            return ua(l, l.render, "ForwardRef");
          case Cl:
            var P = l.displayName || null;
            return P !== null ? P : mn(l.type) || "Memo";
          case po: {
            var V = l, le = V._payload, me = V._init;
            try {
              return mn(me(le));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Mi = 0, Ll, El, Rl, Nl, Pl, js, Us;
    function mo() {
    }
    mo.__reactDisabledLog = !0;
    function Dl() {
      {
        if (Mi === 0) {
          Ll = console.log, El = console.info, Rl = console.warn, Nl = console.error, Pl = console.group, js = console.groupCollapsed, Us = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: mo,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        Mi++;
      }
    }
    function ca() {
      {
        if (Mi--, Mi === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: fr({}, l, {
              value: Ll
            }),
            info: fr({}, l, {
              value: El
            }),
            warn: fr({}, l, {
              value: Rl
            }),
            error: fr({}, l, {
              value: Nl
            }),
            group: fr({}, l, {
              value: Pl
            }),
            groupCollapsed: fr({}, l, {
              value: js
            }),
            groupEnd: fr({}, l, {
              value: Us
            })
          });
        }
        Mi < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var da = n.ReactCurrentDispatcher, Fi;
    function fa(l, f, k) {
      {
        if (Fi === void 0)
          try {
            throw Error();
          } catch (V) {
            var P = V.stack.trim().match(/\n( *(at )?)/);
            Fi = P && P[1] || "";
          }
        return `
` + Fi + l;
      }
    }
    var ha = !1, yo;
    {
      var Ks = typeof WeakMap == "function" ? WeakMap : Map;
      yo = new Ks();
    }
    function _l(l, f) {
      if (!l || ha)
        return "";
      {
        var k = yo.get(l);
        if (k !== void 0)
          return k;
      }
      var P;
      ha = !0;
      var V = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var le;
      le = da.current, da.current = null, Dl();
      try {
        if (f) {
          var me = function() {
            throw Error();
          };
          if (Object.defineProperty(me.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(me, []);
            } catch (kr) {
              P = kr;
            }
            Reflect.construct(l, [], me);
          } else {
            try {
              me.call();
            } catch (kr) {
              P = kr;
            }
            l.call(me.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (kr) {
            P = kr;
          }
          l();
        }
      } catch (kr) {
        if (kr && P && typeof kr.stack == "string") {
          for (var Re = kr.stack.split(`
`), He = P.stack.split(`
`), ot = Re.length - 1, ft = He.length - 1; ot >= 1 && ft >= 0 && Re[ot] !== He[ft]; )
            ft--;
          for (; ot >= 1 && ft >= 0; ot--, ft--)
            if (Re[ot] !== He[ft]) {
              if (ot !== 1 || ft !== 1)
                do
                  if (ot--, ft--, ft < 0 || Re[ot] !== He[ft]) {
                    var kt = `
` + Re[ot].replace(" at new ", " at ");
                    return l.displayName && kt.includes("<anonymous>") && (kt = kt.replace("<anonymous>", l.displayName)), typeof l == "function" && yo.set(l, kt), kt;
                  }
                while (ot >= 1 && ft >= 0);
              break;
            }
        }
      } finally {
        ha = !1, da.current = le, ca(), Error.prepareStackTrace = V;
      }
      var un = l ? l.displayName || l.name : "", Bn = un ? fa(un) : "";
      return typeof l == "function" && yo.set(l, Bn), Bn;
    }
    function Ol(l, f, k) {
      return _l(l, !0);
    }
    function Ml(l, f, k) {
      return _l(l, !1);
    }
    function Ys(l) {
      var f = l.prototype;
      return !!(f && f.isReactComponent);
    }
    function zi(l, f, k) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return _l(l, Ys(l));
      if (typeof l == "string")
        return fa(l);
      switch (l) {
        case Oi:
          return fa("Suspense");
        case Tl:
          return fa("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case sa:
            return Ml(l.render);
          case Cl:
            return zi(l.type, f, k);
          case po: {
            var P = l, V = P._payload, le = P._init;
            try {
              return zi(le(V), f, k);
            } catch {
            }
          }
        }
      return "";
    }
    var Fl = {}, go = n.ReactDebugCurrentFrame;
    function ui(l) {
      if (l) {
        var f = l._owner, k = zi(l.type, l._source, f ? f.type : null);
        go.setExtraStackFrame(k);
      } else
        go.setExtraStackFrame(null);
    }
    function zl(l, f, k, P, V) {
      {
        var le = Function.call.bind(L);
        for (var me in l)
          if (le(l, me)) {
            var Re = void 0;
            try {
              if (typeof l[me] != "function") {
                var He = Error((P || "React class") + ": " + k + " type `" + me + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[me] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw He.name = "Invariant Violation", He;
              }
              Re = l[me](f, me, P, k, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ot) {
              Re = ot;
            }
            Re && !(Re instanceof Error) && (ui(V), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", P || "React class", k, me, typeof Re), ui(null)), Re instanceof Error && !(Re.message in Fl) && (Fl[Re.message] = !0, ui(V), i("Failed %s type: %s", k, Re.message), ui(null));
          }
      }
    }
    var Bl;
    Bl = {};
    var Xr = {};
    Object.freeze(Xr);
    function Gs(l, f) {
      {
        var k = l.contextTypes;
        if (!k)
          return Xr;
        var P = {};
        for (var V in k)
          P[V] = f[V];
        {
          var le = mn(l) || "Unknown";
          zl(k, P, "context", le);
        }
        return P;
      }
    }
    function ci(l, f, k, P) {
      {
        if (typeof l.getChildContext != "function") {
          {
            var V = mn(f) || "Unknown";
            Bl[V] || (Bl[V] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", V, V));
          }
          return k;
        }
        var le = l.getChildContext();
        for (var me in le)
          if (!(me in P))
            throw new Error((mn(f) || "Unknown") + '.getChildContext(): key "' + me + '" is not defined in childContextTypes.');
        {
          var Re = mn(f) || "Unknown";
          zl(P, le, "child context", Re);
        }
        return fr({}, k, le);
      }
    }
    var di;
    di = {};
    var Il = null, Er = null;
    function vo(l) {
      l.context._currentValue2 = l.parentValue;
    }
    function xo(l) {
      l.context._currentValue2 = l.value;
    }
    function pa(l, f) {
      if (l !== f) {
        vo(l);
        var k = l.parent, P = f.parent;
        if (k === null) {
          if (P !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (P === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          pa(k, P);
        }
        xo(f);
      }
    }
    function $l(l) {
      vo(l);
      var f = l.parent;
      f !== null && $l(f);
    }
    function ma(l) {
      var f = l.parent;
      f !== null && ma(f), xo(l);
    }
    function Xs(l, f) {
      vo(l);
      var k = l.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      k.depth === f.depth ? pa(k, f) : Xs(k, f);
    }
    function qs(l, f) {
      var k = f.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      l.depth === k.depth ? pa(l, k) : qs(l, k), xo(f);
    }
    function bo(l) {
      var f = Er, k = l;
      f !== k && (f === null ? ma(k) : k === null ? $l(f) : f.depth === k.depth ? pa(f, k) : f.depth > k.depth ? Xs(f, k) : qs(f, k), Er = k);
    }
    function ya(l, f) {
      var k;
      k = l._currentValue2, l._currentValue2 = f, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== di && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = di;
      var P = Er, V = {
        parent: P,
        depth: P === null ? 0 : P.depth + 1,
        context: l,
        parentValue: k,
        value: f
      };
      return Er = V, V;
    }
    function Hl(l) {
      var f = Er;
      if (f === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      f.context !== l && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var k = f.parentValue;
        k === id ? f.context._currentValue2 = f.context._defaultValue : f.context._currentValue2 = k, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== di && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = di;
      }
      return Er = f.parent;
    }
    function ad() {
      return Er;
    }
    function Bi(l) {
      var f = l._currentValue2;
      return f;
    }
    function So(l) {
      return l._reactInternals;
    }
    function Vl(l, f) {
      l._reactInternals = f;
    }
    var wo = {}, ko = {}, ga, To, Ii, va, Co, $i, Ao, Lo, Eo;
    {
      ga = /* @__PURE__ */ new Set(), To = /* @__PURE__ */ new Set(), Ii = /* @__PURE__ */ new Set(), Ao = /* @__PURE__ */ new Set(), va = /* @__PURE__ */ new Set(), Lo = /* @__PURE__ */ new Set(), Eo = /* @__PURE__ */ new Set();
      var Zs = /* @__PURE__ */ new Set();
      $i = function(l, f) {
        if (!(l === null || typeof l == "function")) {
          var k = f + "_" + l;
          Zs.has(k) || (Zs.add(k), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, l));
        }
      }, Co = function(l, f) {
        if (f === void 0) {
          var k = mn(l) || "Component";
          va.has(k) || (va.add(k), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", k));
        }
      };
    }
    function Qs(l, f) {
      {
        var k = l.constructor, P = k && mn(k) || "ReactClass", V = P + "." + f;
        if (wo[V])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, f, f, P), wo[V] = !0;
      }
    }
    var Js = {
      isMounted: function(l) {
        return !1;
      },
      enqueueSetState: function(l, f, k) {
        var P = So(l);
        P.queue === null ? Qs(l, "setState") : (P.queue.push(f), k != null && $i(k, "setState"));
      },
      enqueueReplaceState: function(l, f, k) {
        var P = So(l);
        P.replace = !0, P.queue = [f], k != null && $i(k, "setState");
      },
      enqueueForceUpdate: function(l, f) {
        var k = So(l);
        k.queue === null ? Qs(l, "forceUpdate") : f != null && $i(f, "setState");
      }
    };
    function od(l, f, k, P, V) {
      var le = k(V, P);
      Co(f, le);
      var me = le == null ? P : fr({}, P, le);
      return me;
    }
    function ld(l, f, k) {
      var P = Xr, V = l.contextType;
      if ("contextType" in l) {
        var le = (
          // Allow null for conditional declaration
          V === null || V !== void 0 && V.$$typeof === la && V._context === void 0
        );
        if (!le && !Eo.has(l)) {
          Eo.add(l);
          var me = "";
          V === void 0 ? me = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof V != "object" ? me = " However, it is set to a " + typeof V + "." : V.$$typeof === oa ? me = " Did you accidentally pass the Context.Provider instead?" : V._context !== void 0 ? me = " Did you accidentally pass the Context.Consumer instead?" : me = " However, it is set to an object with keys {" + Object.keys(V).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", mn(l) || "Component", me);
        }
      }
      typeof V == "object" && V !== null ? P = Bi(V) : P = k;
      var Re = new l(f, P);
      {
        if (typeof l.getDerivedStateFromProps == "function" && (Re.state === null || Re.state === void 0)) {
          var He = mn(l) || "Component";
          ga.has(He) || (ga.add(He), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", He, Re.state === null ? "null" : "undefined", He));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof Re.getSnapshotBeforeUpdate == "function") {
          var ot = null, ft = null, kt = null;
          if (typeof Re.componentWillMount == "function" && Re.componentWillMount.__suppressDeprecationWarning !== !0 ? ot = "componentWillMount" : typeof Re.UNSAFE_componentWillMount == "function" && (ot = "UNSAFE_componentWillMount"), typeof Re.componentWillReceiveProps == "function" && Re.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? ft = "componentWillReceiveProps" : typeof Re.UNSAFE_componentWillReceiveProps == "function" && (ft = "UNSAFE_componentWillReceiveProps"), typeof Re.componentWillUpdate == "function" && Re.componentWillUpdate.__suppressDeprecationWarning !== !0 ? kt = "componentWillUpdate" : typeof Re.UNSAFE_componentWillUpdate == "function" && (kt = "UNSAFE_componentWillUpdate"), ot !== null || ft !== null || kt !== null) {
            var un = mn(l) || "Component", Bn = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Ii.has(un) || (Ii.add(un), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, un, Bn, ot !== null ? `
  ` + ot : "", ft !== null ? `
  ` + ft : "", kt !== null ? `
  ` + kt : ""));
          }
        }
      }
      return Re;
    }
    function eu(l, f, k) {
      {
        var P = mn(f) || "Component", V = l.render;
        V || (f.prototype && typeof f.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", P) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", P)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", P), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", P), l.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", P), l.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", P), l.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", P), f.contextType && f.contextTypes && !Lo.has(f) && (Lo.add(f), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", P)), typeof l.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", P), f.prototype && f.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", mn(f) || "A pure component"), typeof l.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", P), typeof l.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", P), typeof l.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", P), typeof l.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", P);
        var le = l.props !== k;
        l.props !== void 0 && le && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", P, P), l.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", P, P), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !To.has(f) && (To.add(f), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", mn(f))), typeof l.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", P), typeof l.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", P), typeof f.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", P);
        var me = l.state;
        me && (typeof me != "object" || Ct(me)) && i("%s.state: must be set to an object or null", P), typeof l.getChildContext == "function" && typeof f.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", P);
      }
    }
    function sd(l, f) {
      var k = f.state;
      if (typeof f.componentWillMount == "function") {
        if (f.componentWillMount.__suppressDeprecationWarning !== !0) {
          var P = mn(l) || "Unknown";
          ko[P] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            P
          ), ko[P] = !0);
        }
        f.componentWillMount();
      }
      typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), k !== f.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", mn(l) || "Component"), Js.enqueueReplaceState(f, f.state, null));
    }
    function ud(l, f, k, P) {
      if (l.queue !== null && l.queue.length > 0) {
        var V = l.queue, le = l.replace;
        if (l.queue = null, l.replace = !1, le && V.length === 1)
          f.state = V[0];
        else {
          for (var me = le ? V[0] : f.state, Re = !0, He = le ? 1 : 0; He < V.length; He++) {
            var ot = V[He], ft = typeof ot == "function" ? ot.call(f, me, k, P) : ot;
            ft != null && (Re ? (Re = !1, me = fr({}, me, ft)) : fr(me, ft));
          }
          f.state = me;
        }
      } else
        l.queue = null;
    }
    function Ro(l, f, k, P) {
      eu(l, f, k);
      var V = l.state !== void 0 ? l.state : null;
      l.updater = Js, l.props = k, l.state = V;
      var le = {
        queue: [],
        replace: !1
      };
      Vl(l, le);
      var me = f.contextType;
      if (typeof me == "object" && me !== null ? l.context = Bi(me) : l.context = P, l.state === k) {
        var Re = mn(f) || "Component";
        Ao.has(Re) || (Ao.add(Re), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Re));
      }
      var He = f.getDerivedStateFromProps;
      typeof He == "function" && (l.state = od(l, f, He, V, k)), typeof f.getDerivedStateFromProps != "function" && typeof l.getSnapshotBeforeUpdate != "function" && (typeof l.UNSAFE_componentWillMount == "function" || typeof l.componentWillMount == "function") && (sd(f, l), ud(le, l, k, P));
    }
    var No = {
      id: 1,
      overflow: ""
    };
    function cd(l) {
      var f = l.overflow, k = l.id, P = k & ~dd(k);
      return P.toString(32) + f;
    }
    function Wl(l, f, k) {
      var P = l.id, V = l.overflow, le = Po(P) - 1, me = P & ~(1 << le), Re = k + 1, He = Po(f) + le;
      if (He > 30) {
        var ot = le - le % 5, ft = (1 << ot) - 1, kt = (me & ft).toString(32), un = me >> ot, Bn = le - ot, kr = Po(f) + Bn, wu = Re << Bn, ku = wu | un, Tu = kt + V;
        return {
          id: 1 << kr | ku,
          overflow: Tu
        };
      } else {
        var Yo = Re << le, Sg = Yo | me, wg = V;
        return {
          id: 1 << He | Sg,
          overflow: wg
        };
      }
    }
    function Po(l) {
      return 32 - fd(l);
    }
    function dd(l) {
      return 1 << Po(l) - 1;
    }
    var fd = Math.clz32 ? Math.clz32 : zr, hd = Math.log, pd = Math.LN2;
    function zr(l) {
      var f = l >>> 0;
      return f === 0 ? 32 : 31 - (hd(f) / pd | 0) | 0;
    }
    function jl(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var Do = typeof Object.is == "function" ? Object.is : jl, Mt = null, fi = null, hi = null, Zt = null, br = !1, pi = !1, _o = 0, zn = null, Br = 0, mi = 25, Rr = !1, yi;
    function Ir() {
      if (Mt === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Rr && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Mt;
    }
    function md(l, f) {
      if (f === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", yi), !1;
      l.length !== f.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, yi, "[" + l.join(", ") + "]", "[" + f.join(", ") + "]");
      for (var k = 0; k < f.length && k < l.length; k++)
        if (!Do(l[k], f[k]))
          return !1;
      return !0;
    }
    function tu() {
      if (Br > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Oo() {
      return Zt === null ? hi === null ? (br = !1, hi = Zt = tu()) : (br = !0, Zt = hi) : Zt.next === null ? (br = !1, Zt = Zt.next = tu()) : (br = !0, Zt = Zt.next), Zt;
    }
    function Ul(l, f) {
      Mt = f, fi = l, Rr = !1, _o = 0;
    }
    function yd(l, f, k, P) {
      for (; pi; )
        pi = !1, _o = 0, Br += 1, Zt = null, k = l(f, P);
      return xa(), k;
    }
    function nu() {
      var l = _o !== 0;
      return l;
    }
    function xa() {
      Rr = !1, Mt = null, fi = null, pi = !1, hi = null, Br = 0, zn = null, Zt = null;
    }
    function gd(l) {
      return Rr && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Bi(l);
    }
    function ru(l) {
      return yi = "useContext", Ir(), Bi(l);
    }
    function Mo(l, f) {
      return typeof f == "function" ? f(l) : f;
    }
    function vd(l) {
      return yi = "useState", iu(
        Mo,
        // useReducer has a special case to support lazy useState initializers
        l
      );
    }
    function iu(l, f, k) {
      if (l !== Mo && (yi = "useReducer"), Mt = Ir(), Zt = Oo(), br) {
        var P = Zt.queue, V = P.dispatch;
        if (zn !== null) {
          var le = zn.get(P);
          if (le !== void 0) {
            zn.delete(P);
            var me = Zt.memoizedState, Re = le;
            do {
              var He = Re.action;
              Rr = !0, me = l(me, He), Rr = !1, Re = Re.next;
            } while (Re !== null);
            return Zt.memoizedState = me, [me, V];
          }
        }
        return [Zt.memoizedState, V];
      } else {
        Rr = !0;
        var ot;
        l === Mo ? ot = typeof f == "function" ? f() : f : ot = k !== void 0 ? k(f) : f, Rr = !1, Zt.memoizedState = ot;
        var ft = Zt.queue = {
          last: null,
          dispatch: null
        }, kt = ft.dispatch = Sd.bind(null, Mt, ft);
        return [Zt.memoizedState, kt];
      }
    }
    function au(l, f) {
      Mt = Ir(), Zt = Oo();
      var k = f === void 0 ? null : f;
      if (Zt !== null) {
        var P = Zt.memoizedState;
        if (P !== null && k !== null) {
          var V = P[1];
          if (md(k, V))
            return P[0];
        }
      }
      Rr = !0;
      var le = l();
      return Rr = !1, Zt.memoizedState = [le, k], le;
    }
    function xd(l) {
      Mt = Ir(), Zt = Oo();
      var f = Zt.memoizedState;
      if (f === null) {
        var k = {
          current: l
        };
        return Object.seal(k), Zt.memoizedState = k, k;
      } else
        return f;
    }
    function bd(l, f) {
      yi = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function Sd(l, f, k) {
      if (Br >= mi)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (l === Mt) {
        pi = !0;
        var P = {
          action: k,
          next: null
        };
        zn === null && (zn = /* @__PURE__ */ new Map());
        var V = zn.get(f);
        if (V === void 0)
          zn.set(f, P);
        else {
          for (var le = V; le.next !== null; )
            le = le.next;
          le.next = P;
        }
      }
    }
    function wd(l, f) {
      return au(function() {
        return l;
      }, f);
    }
    function kd(l, f, k) {
      return Ir(), f(l._source);
    }
    function Td(l, f, k) {
      if (k === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return k();
    }
    function Cd(l) {
      return Ir(), l;
    }
    function Fo() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function ou() {
      return Ir(), [!1, Fo];
    }
    function Kl() {
      var l = fi, f = cd(l.treeContext), k = Sa;
      if (k === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var P = _o++;
      return yn(k, f, P);
    }
    function ba() {
    }
    var lu = {
      readContext: gd,
      useContext: ru,
      useMemo: au,
      useReducer: iu,
      useRef: xd,
      useState: vd,
      useInsertionEffect: ba,
      useLayoutEffect: bd,
      useCallback: wd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: ba,
      // Effects are not run in the server environment.
      useEffect: ba,
      // Debugging effect
      useDebugValue: ba,
      useDeferredValue: Cd,
      useTransition: ou,
      useId: Kl,
      // Subscriptions are not setup in a server environment.
      useMutableSource: kd,
      useSyncExternalStore: Td
    }, Sa = null;
    function zo(l) {
      Sa = l;
    }
    function Yl(l) {
      try {
        var f = "", k = l;
        do {
          switch (k.tag) {
            case 0:
              f += fa(k.type, null, null);
              break;
            case 1:
              f += Ml(k.type, null, null);
              break;
            case 2:
              f += Ol(k.type, null, null);
              break;
          }
          k = k.parent;
        } while (k);
        return f;
      } catch (P) {
        return `
Error generating stack: ` + P.message + `
` + P.stack;
      }
    }
    var qr = n.ReactCurrentDispatcher, Bo = n.ReactDebugCurrentFrame, Io = 0, gi = 1, su = 2, Gl = 3, vi = 4, Ad = 0, uu = 1, Nr = 2, Ld = 12800;
    function Ed(l) {
      return console.error(l), null;
    }
    function wa() {
    }
    function Xl(l, f, k, P, V, le, me, Re, He) {
      var ot = [], ft = /* @__PURE__ */ new Set(), kt = {
        destination: null,
        responseState: f,
        progressiveChunkSize: P === void 0 ? Ld : P,
        status: Ad,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: ft,
        pingedTasks: ot,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: V === void 0 ? Ed : V,
        onAllReady: le === void 0 ? wa : le,
        onShellReady: me === void 0 ? wa : me,
        onShellError: Re === void 0 ? wa : Re,
        onFatalError: He === void 0 ? wa : He
      }, un = Zr(
        kt,
        0,
        null,
        k,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      un.parentFlushed = !0;
      var Bn = ka(kt, l, null, un, ft, Xr, Il, No);
      return ot.push(Bn), kt;
    }
    function $o(l, f) {
      var k = l.pingedTasks;
      k.push(f), k.length === 1 && d(function() {
        return bu(l);
      });
    }
    function $r(l, f) {
      return {
        id: Fn,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: f,
        errorDigest: null
      };
    }
    function ka(l, f, k, P, V, le, me, Re) {
      l.allPendingTasks++, k === null ? l.pendingRootTasks++ : k.pendingTasks++;
      var He = {
        node: f,
        ping: function() {
          return $o(l, He);
        },
        blockedBoundary: k,
        blockedSegment: P,
        abortSet: V,
        legacyContext: le,
        context: me,
        treeContext: Re
      };
      return He.componentStack = null, V.add(He), He;
    }
    function Zr(l, f, k, P, V, le) {
      return {
        status: Io,
        id: -1,
        // lazily assigned later
        index: f,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: P,
        boundary: k,
        lastPushedText: V,
        textEmbedded: le
      };
    }
    var Pr = null;
    function ql() {
      return Pr === null || Pr.componentStack === null ? "" : Yl(Pr.componentStack);
    }
    function Sr(l, f) {
      l.componentStack = {
        tag: 0,
        parent: l.componentStack,
        type: f
      };
    }
    function Hi(l, f) {
      l.componentStack = {
        tag: 1,
        parent: l.componentStack,
        type: f
      };
    }
    function Zl(l, f) {
      l.componentStack = {
        tag: 2,
        parent: l.componentStack,
        type: f
      };
    }
    function wr(l) {
      l.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : l.componentStack = l.componentStack.parent;
    }
    var Qr = null;
    function Ql(l, f) {
      {
        var k;
        typeof f == "string" ? k = f : f && typeof f.message == "string" ? k = f.message : k = String(f);
        var P = Qr || ql();
        Qr = null, l.errorMessage = k, l.errorComponentStack = P;
      }
    }
    function Ta(l, f) {
      var k = l.onError(f);
      if (k != null && typeof k != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof k + '" instead');
      return k;
    }
    function Ho(l, f) {
      var k = l.onShellError;
      k(f);
      var P = l.onFatalError;
      P(f), l.destination !== null ? (l.status = Nr, y(l.destination, f)) : (l.status = uu, l.fatalError = f);
    }
    function cu(l, f, k) {
      Sr(f, "Suspense");
      var P = f.blockedBoundary, V = f.blockedSegment, le = k.fallback, me = k.children, Re = /* @__PURE__ */ new Set(), He = $r(l, Re), ot = V.chunks.length, ft = Zr(
        l,
        ot,
        He,
        V.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      V.children.push(ft), V.lastPushedText = !1;
      var kt = Zr(
        l,
        0,
        null,
        V.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      kt.parentFlushed = !0, f.blockedBoundary = He, f.blockedSegment = kt;
      try {
        if (Vo(l, f, me), Bs(kt.chunks, l.responseState, kt.lastPushedText, kt.textEmbedded), kt.status = gi, La(He, kt), He.pendingTasks === 0) {
          wr(f);
          return;
        }
      } catch (Bn) {
        kt.status = vi, He.forceClientRender = !0, He.errorDigest = Ta(l, Bn), Ql(He, Bn);
      } finally {
        f.blockedBoundary = P, f.blockedSegment = V;
      }
      var un = ka(l, le, P, ft, Re, f.legacyContext, f.context, f.treeContext);
      un.componentStack = f.componentStack, l.pingedTasks.push(un), wr(f);
    }
    function du(l, f, k, P) {
      Sr(f, k);
      var V = f.blockedSegment, le = Ar(V.chunks, k, P, l.responseState, V.formatContext);
      V.lastPushedText = !1;
      var me = V.formatContext;
      V.formatContext = ir(me, k, P), Vo(l, f, le), V.formatContext = me, ur(V.chunks, k), V.lastPushedText = !1, wr(f);
    }
    function Rd(l) {
      return l.prototype && l.prototype.isReactComponent;
    }
    function Jl(l, f, k, P, V) {
      var le = {};
      Ul(f, le);
      var me = k(P, V);
      return yd(k, P, me, V);
    }
    function Ca(l, f, k, P, V) {
      var le = k.render();
      k.props !== V && (rs || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", mn(P) || "a component"), rs = !0);
      {
        var me = P.childContextTypes;
        if (me != null) {
          var Re = f.legacyContext, He = ci(k, P, Re, me);
          f.legacyContext = He, pr(l, f, le), f.legacyContext = Re;
          return;
        }
      }
      pr(l, f, le);
    }
    function fu(l, f, k, P) {
      Zl(f, k);
      var V = Gs(k, f.legacyContext), le = ld(k, P, V);
      Ro(le, k, P, V), Ca(l, f, le, k, P), wr(f);
    }
    var es = {}, Aa = {}, ts = {}, ns = {}, rs = !1, hu = !1, pu = !1, is = !1;
    function Nd(l, f, k, P) {
      var V;
      if (V = Gs(k, f.legacyContext), Hi(f, k), k.prototype && typeof k.prototype.render == "function") {
        var le = mn(k) || "Unknown";
        es[le] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", le, le), es[le] = !0);
      }
      var me = Jl(l, f, k, P, V), Re = nu();
      if (typeof me == "object" && me !== null && typeof me.render == "function" && me.$$typeof === void 0) {
        var He = mn(k) || "Unknown";
        Aa[He] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", He, He, He), Aa[He] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof me == "object" && me !== null && typeof me.render == "function" && me.$$typeof === void 0
      ) {
        {
          var ot = mn(k) || "Unknown";
          Aa[ot] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ot, ot, ot), Aa[ot] = !0);
        }
        Ro(me, k, P, V), Ca(l, f, me, k, P);
      } else if (Pd(k), Re) {
        var ft = f.treeContext, kt = 1, un = 0;
        f.treeContext = Wl(ft, kt, un);
        try {
          pr(l, f, me);
        } finally {
          f.treeContext = ft;
        }
      } else
        pr(l, f, me);
      wr(f);
    }
    function Pd(l) {
      {
        if (l && l.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), typeof l.getDerivedStateFromProps == "function") {
          var f = mn(l) || "Unknown";
          ns[f] || (i("%s: Function components do not support getDerivedStateFromProps.", f), ns[f] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var k = mn(l) || "Unknown";
          ts[k] || (i("%s: Function components do not support contextType.", k), ts[k] = !0);
        }
      }
    }
    function mu(l, f) {
      if (l && l.defaultProps) {
        var k = fr({}, f), P = l.defaultProps;
        for (var V in P)
          k[V] === void 0 && (k[V] = P[V]);
        return k;
      }
      return f;
    }
    function Dd(l, f, k, P, V) {
      Hi(f, k.render);
      var le = Jl(l, f, k.render, P, V), me = nu();
      if (me) {
        var Re = f.treeContext, He = 1, ot = 0;
        f.treeContext = Wl(Re, He, ot);
        try {
          pr(l, f, le);
        } finally {
          f.treeContext = Re;
        }
      } else
        pr(l, f, le);
      wr(f);
    }
    function _d(l, f, k, P, V) {
      var le = k.type, me = mu(le, P);
      os(l, f, le, me, V);
    }
    function as(l, f, k, P) {
      k._context === void 0 ? k !== k.Consumer && (is || (is = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : k = k._context;
      var V = P.children;
      typeof V != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var le = Bi(k), me = V(le);
      pr(l, f, me);
    }
    function Od(l, f, k, P) {
      var V = k._context, le = P.value, me = P.children, Re;
      Re = f.context, f.context = ya(V, le), pr(l, f, me), f.context = Hl(V), Re !== f.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function hr(l, f, k, P, V) {
      Sr(f, "Lazy");
      var le = k._payload, me = k._init, Re = me(le), He = mu(Re, P);
      os(l, f, Re, He, V), wr(f);
    }
    function os(l, f, k, P, V) {
      if (typeof k == "function")
        if (Rd(k)) {
          fu(l, f, k, P);
          return;
        } else {
          Nd(l, f, k, P);
          return;
        }
      if (typeof k == "string") {
        du(l, f, k, P);
        return;
      }
      switch (k) {
        case rd:
        case Hs:
        case fo:
        case ho:
        case co: {
          pr(l, f, P.children);
          return;
        }
        case Tl: {
          Sr(f, "SuspenseList"), pr(l, f, P.children), wr(f);
          return;
        }
        case nd:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Oi: {
          cu(l, f, P);
          return;
        }
      }
      if (typeof k == "object" && k !== null)
        switch (k.$$typeof) {
          case sa: {
            Dd(l, f, k, P, V);
            return;
          }
          case Cl: {
            _d(l, f, k, P, V);
            return;
          }
          case oa: {
            Od(l, f, k, P);
            return;
          }
          case la: {
            as(l, f, k, P);
            return;
          }
          case po: {
            hr(l, f, k, P);
            return;
          }
        }
      var le = "";
      throw (k === void 0 || typeof k == "object" && k !== null && Object.keys(k).length === 0) && (le += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (k == null ? k : typeof k) + "." + le));
    }
    function yu(l, f) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      l[Symbol.toStringTag] === "Generator" && (hu || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), hu = !0), l.entries === f && (pu || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), pu = !0);
    }
    function pr(l, f, k) {
      try {
        return ls(l, f, k);
      } catch (P) {
        throw typeof P == "object" && P !== null && typeof P.then == "function" || (Qr = Qr !== null ? Qr : ql()), P;
      }
    }
    function ls(l, f, k) {
      if (f.node = k, typeof k == "object" && k !== null) {
        switch (k.$$typeof) {
          case $s: {
            var P = k, V = P.type, le = P.props, me = P.ref;
            os(l, f, V, le, me);
            return;
          }
          case kl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case po: {
            var Re = k, He = Re._payload, ot = Re._init, ft;
            try {
              ft = ot(He);
            } catch (Yo) {
              throw typeof Yo == "object" && Yo !== null && typeof Yo.then == "function" && Sr(f, "Lazy"), Yo;
            }
            pr(l, f, ft);
            return;
          }
        }
        if (Ct(k)) {
          gu(l, f, k);
          return;
        }
        var kt = gn(k);
        if (kt) {
          yu(k, kt);
          var un = kt.call(k);
          if (un) {
            var Bn = un.next();
            if (!Bn.done) {
              var kr = [];
              do
                kr.push(Bn.value), Bn = un.next();
              while (!Bn.done);
              gu(l, f, kr);
              return;
            }
            return;
          }
        }
        var wu = Object.prototype.toString.call(k);
        throw new Error("Objects are not valid as a React child (found: " + (wu === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : wu) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof k == "string") {
        var ku = f.blockedSegment;
        ku.lastPushedText = zs(f.blockedSegment.chunks, k, l.responseState, ku.lastPushedText);
        return;
      }
      if (typeof k == "number") {
        var Tu = f.blockedSegment;
        Tu.lastPushedText = zs(f.blockedSegment.chunks, "" + k, l.responseState, Tu.lastPushedText);
        return;
      }
      typeof k == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function gu(l, f, k) {
      for (var P = k.length, V = 0; V < P; V++) {
        var le = f.treeContext;
        f.treeContext = Wl(le, P, V);
        try {
          Vo(l, f, k[V]);
        } finally {
          f.treeContext = le;
        }
      }
    }
    function Md(l, f, k) {
      var P = f.blockedSegment, V = P.chunks.length, le = Zr(
        l,
        V,
        null,
        P.formatContext,
        // Adopt the parent segment's leading text embed
        P.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      P.children.push(le), P.lastPushedText = !1;
      var me = ka(l, f.node, f.blockedBoundary, le, f.abortSet, f.legacyContext, f.context, f.treeContext);
      f.componentStack !== null && (me.componentStack = f.componentStack.parent);
      var Re = me.ping;
      k.then(Re, Re);
    }
    function Vo(l, f, k) {
      var P = f.blockedSegment.formatContext, V = f.legacyContext, le = f.context, me = null;
      me = f.componentStack;
      try {
        return pr(l, f, k);
      } catch (Re) {
        if (xa(), typeof Re == "object" && Re !== null && typeof Re.then == "function") {
          Md(l, f, Re), f.blockedSegment.formatContext = P, f.legacyContext = V, f.context = le, bo(le), f.componentStack = me;
          return;
        } else
          throw f.blockedSegment.formatContext = P, f.legacyContext = V, f.context = le, bo(le), f.componentStack = me, Re;
      }
    }
    function Wo(l, f, k, P) {
      var V = Ta(l, P);
      if (f === null ? Ho(l, P) : (f.pendingTasks--, f.forceClientRender || (f.forceClientRender = !0, f.errorDigest = V, Ql(f, P), f.parentFlushed && l.clientRenderedBoundaries.push(f))), l.allPendingTasks--, l.allPendingTasks === 0) {
        var le = l.onAllReady;
        le();
      }
    }
    function vu(l) {
      var f = this, k = l.blockedBoundary, P = l.blockedSegment;
      P.status = Gl, Ea(f, k, P);
    }
    function xu(l, f, k) {
      var P = l.blockedBoundary, V = l.blockedSegment;
      if (V.status = Gl, P === null)
        f.allPendingTasks--, f.status !== Nr && (f.status = Nr, f.destination !== null && g(f.destination));
      else {
        if (P.pendingTasks--, !P.forceClientRender) {
          P.forceClientRender = !0;
          var le = k === void 0 ? new Error("The render was aborted by the server without a reason.") : k;
          P.errorDigest = f.onError(le);
          {
            var me = "The server did not finish this Suspense boundary: ";
            le && typeof le.message == "string" ? le = me + le.message : le = me + String(le);
            var Re = Pr;
            Pr = l;
            try {
              Ql(P, le);
            } finally {
              Pr = Re;
            }
          }
          P.parentFlushed && f.clientRenderedBoundaries.push(P);
        }
        if (P.fallbackAbortableTasks.forEach(function(ot) {
          return xu(ot, f, k);
        }), P.fallbackAbortableTasks.clear(), f.allPendingTasks--, f.allPendingTasks === 0) {
          var He = f.onAllReady;
          He();
        }
      }
    }
    function La(l, f) {
      if (f.chunks.length === 0 && f.children.length === 1 && f.children[0].boundary === null) {
        var k = f.children[0];
        k.id = f.id, k.parentFlushed = !0, k.status === gi && La(l, k);
      } else {
        var P = l.completedSegments;
        P.push(f);
      }
    }
    function Ea(l, f, k) {
      if (f === null) {
        if (k.parentFlushed) {
          if (l.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          l.completedRootSegment = k;
        }
        if (l.pendingRootTasks--, l.pendingRootTasks === 0) {
          l.onShellError = wa;
          var P = l.onShellReady;
          P();
        }
      } else if (f.pendingTasks--, !f.forceClientRender) {
        if (f.pendingTasks === 0)
          k.parentFlushed && k.status === gi && La(f, k), f.parentFlushed && l.completedBoundaries.push(f), f.fallbackAbortableTasks.forEach(vu, l), f.fallbackAbortableTasks.clear();
        else if (k.parentFlushed && k.status === gi) {
          La(f, k);
          var V = f.completedSegments;
          V.length === 1 && f.parentFlushed && l.partialBoundaries.push(f);
        }
      }
      if (l.allPendingTasks--, l.allPendingTasks === 0) {
        var le = l.onAllReady;
        le();
      }
    }
    function jo(l, f) {
      var k = f.blockedSegment;
      if (k.status === Io) {
        bo(f.context);
        var P = null;
        P = Pr, Pr = f;
        try {
          pr(l, f, f.node), Bs(k.chunks, l.responseState, k.lastPushedText, k.textEmbedded), f.abortSet.delete(f), k.status = gi, Ea(l, f.blockedBoundary, k);
        } catch (le) {
          if (xa(), typeof le == "object" && le !== null && typeof le.then == "function") {
            var V = f.ping;
            le.then(V, V);
          } else
            f.abortSet.delete(f), k.status = vi, Wo(l, f.blockedBoundary, k, le);
        } finally {
          Pr = P;
        }
      }
    }
    function bu(l) {
      if (l.status !== Nr) {
        var f = ad(), k = qr.current;
        qr.current = lu;
        var P;
        P = Bo.getCurrentStack, Bo.getCurrentStack = ql;
        var V = Sa;
        zo(l.responseState);
        try {
          var le = l.pingedTasks, me;
          for (me = 0; me < le.length; me++) {
            var Re = le[me];
            jo(l, Re);
          }
          le.splice(0, me), l.destination !== null && Ko(l, l.destination);
        } catch (He) {
          Ta(l, He), Ho(l, He);
        } finally {
          zo(V), qr.current = k, Bo.getCurrentStack = P, k === lu && bo(f);
        }
      }
    }
    function Ra(l, f, k) {
      switch (k.parentFlushed = !0, k.status) {
        case Io: {
          var P = k.id = l.nextSegmentId++;
          return k.lastPushedText = !1, k.textEmbedded = !1, Za(f, l.responseState, P);
        }
        case gi: {
          k.status = su;
          for (var V = !0, le = k.chunks, me = 0, Re = k.children, He = 0; He < Re.length; He++) {
            for (var ot = Re[He]; me < ot.index; me++)
              s(f, le[me]);
            V = Na(l, f, ot);
          }
          for (; me < le.length - 1; me++)
            s(f, le[me]);
          return me < le.length && (V = p(f, le[me])), V;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Na(l, f, k) {
      var P = k.boundary;
      if (P === null)
        return Ra(l, f, k);
      if (P.parentFlushed = !0, P.forceClientRender)
        return xr(f, l.responseState, P.errorDigest, P.errorMessage, P.errorComponentStack), Ra(l, f, k), Is(f, l.responseState);
      if (P.pendingTasks > 0) {
        P.rootSegmentID = l.nextSegmentId++, P.completedSegments.length > 0 && l.partialBoundaries.push(P);
        var V = P.id = Rn(l.responseState);
        return Gr(f, l.responseState, V), Ra(l, f, k), ra(f, l.responseState);
      } else {
        if (P.byteSize > l.progressiveChunkSize)
          return P.rootSegmentID = l.nextSegmentId++, l.completedBoundaries.push(P), Gr(f, l.responseState, P.id), Ra(l, f, k), ra(f, l.responseState);
        wl(f, l.responseState);
        var le = P.completedSegments;
        if (le.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var me = le[0];
        return Na(l, f, me), td(f, l.responseState);
      }
    }
    function Fd(l, f, k) {
      return Qc(f, l.responseState, k.id, k.errorDigest, k.errorMessage, k.errorComponentStack);
    }
    function ss(l, f, k) {
      return Te(f, l.responseState, k.formatContext, k.id), Na(l, f, k), Me(f, k.formatContext);
    }
    function Uo(l, f, k) {
      for (var P = k.completedSegments, V = 0; V < P.length; V++) {
        var le = P[V];
        Su(l, f, k, le);
      }
      return P.length = 0, Yc(f, l.responseState, k.id, k.rootSegmentID);
    }
    function zd(l, f, k) {
      for (var P = k.completedSegments, V = 0; V < P.length; V++) {
        var le = P[V];
        if (!Su(l, f, k, le))
          return V++, P.splice(0, V), !1;
      }
      return P.splice(0, V), !0;
    }
    function Su(l, f, k, P) {
      if (P.status === su)
        return !0;
      var V = P.id;
      if (V === -1) {
        var le = P.id = k.rootSegmentID;
        if (le === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return ss(l, f, P);
      } else
        return ss(l, f, P), dr(f, l.responseState, V);
    }
    function Ko(l, f) {
      try {
        var k = l.completedRootSegment;
        k !== null && l.pendingRootTasks === 0 && (Na(l, f, k), l.completedRootSegment = null, Ji(f, l.responseState));
        var P = l.clientRenderedBoundaries, V;
        for (V = 0; V < P.length; V++) {
          var le = P[V];
          if (!Fd(l, f, le)) {
            l.destination = null, V++, P.splice(0, V);
            return;
          }
        }
        P.splice(0, V);
        var me = l.completedBoundaries;
        for (V = 0; V < me.length; V++) {
          var Re = me[V];
          if (!Uo(l, f, Re)) {
            l.destination = null, V++, me.splice(0, V);
            return;
          }
        }
        me.splice(0, V);
        var He = l.partialBoundaries;
        for (V = 0; V < He.length; V++) {
          var ot = He[V];
          if (!zd(l, f, ot)) {
            l.destination = null, V++, He.splice(0, V);
            return;
          }
        }
        He.splice(0, V);
        var ft = l.completedBoundaries;
        for (V = 0; V < ft.length; V++) {
          var kt = ft[V];
          if (!Uo(l, f, kt)) {
            l.destination = null, V++, ft.splice(0, V);
            return;
          }
        }
        ft.splice(0, V);
      } finally {
        l.allPendingTasks === 0 && l.pingedTasks.length === 0 && l.clientRenderedBoundaries.length === 0 && l.completedBoundaries.length === 0 && (l.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), g(f));
      }
    }
    function Bd(l) {
      d(function() {
        return bu(l);
      });
    }
    function u(l, f) {
      if (l.status === uu) {
        l.status = Nr, y(f, l.fatalError);
        return;
      }
      if (l.status !== Nr && l.destination === null) {
        l.destination = f;
        try {
          Ko(l, f);
        } catch (k) {
          Ta(l, k), Ho(l, k);
        }
      }
    }
    function h(l, f) {
      try {
        var k = l.abortableTasks;
        k.forEach(function(P) {
          return xu(P, l, f);
        }), k.clear(), l.destination !== null && Ko(l, l.destination);
      } catch (P) {
        Ta(l, P), Ho(l, P);
      }
    }
    function C() {
    }
    function F(l, f, k, P) {
      var V = !1, le = null, me = "", Re = {
        push: function(kt) {
          return kt !== null && (me += kt), !0;
        },
        destroy: function(kt) {
          V = !0, le = kt;
        }
      }, He = !1;
      function ot() {
        He = !0;
      }
      var ft = Xl(l, ed(k, f ? f.identifierPrefix : void 0), Sl(), 1 / 0, C, void 0, ot, void 0, void 0);
      if (Bd(ft), h(ft, P), u(ft, Re), V)
        throw le;
      if (!He)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return me;
    }
    function q(l, f) {
      return F(l, f, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function fe(l, f) {
      return F(l, f, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function ge() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Ne() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Ma.renderToNodeStream = ge, Ma.renderToStaticMarkup = fe, Ma.renderToStaticNodeStream = Ne, Ma.renderToString = q, Ma.version = t;
  }()), Ma;
}
var Iu = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var am;
function kw() {
  return am || (am = 1, process.env.NODE_ENV !== "production" && function() {
    var e = de, t = "18.2.0", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(u) {
      {
        for (var h = arguments.length, C = new Array(h > 1 ? h - 1 : 0), F = 1; F < h; F++)
          C[F - 1] = arguments[F];
        o("warn", u, C);
      }
    }
    function i(u) {
      {
        for (var h = arguments.length, C = new Array(h > 1 ? h - 1 : 0), F = 1; F < h; F++)
          C[F - 1] = arguments[F];
        o("error", u, C);
      }
    }
    function o(u, h, C) {
      {
        var F = n.ReactDebugCurrentFrame, q = F.getStackAddendum();
        q !== "" && (h += "%s", C = C.concat([q]));
        var fe = C.map(function(ge) {
          return String(ge);
        });
        fe.unshift("Warning: " + h), Function.prototype.apply.call(console[u], console, fe);
      }
    }
    function d(u) {
      u();
    }
    var c = 512, s = null, p = 0;
    function m(u) {
      s = new Uint8Array(c), p = 0;
    }
    function g(u, h) {
      if (h.length !== 0) {
        if (h.length > c) {
          p > 0 && (u.enqueue(new Uint8Array(s.buffer, 0, p)), s = new Uint8Array(c), p = 0), u.enqueue(h);
          return;
        }
        var C = h, F = s.length - p;
        F < C.length && (F === 0 ? u.enqueue(s) : (s.set(C.subarray(0, F), p), u.enqueue(s), C = C.subarray(F)), s = new Uint8Array(c), p = 0), s.set(C, p), p += C.length;
      }
    }
    function x(u, h) {
      return g(u, h), !0;
    }
    function T(u) {
      s && p > 0 && (u.enqueue(new Uint8Array(s.buffer, 0, p)), s = null, p = 0);
    }
    function y(u) {
      u.close();
    }
    var A = new TextEncoder();
    function b(u) {
      return A.encode(u);
    }
    function v(u) {
      return A.encode(u);
    }
    function E(u, h) {
      typeof u.error == "function" ? u.error(h) : u.close();
    }
    function N(u) {
      {
        var h = typeof Symbol == "function" && Symbol.toStringTag, C = h && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return C;
      }
    }
    function R(u) {
      try {
        return L(u), !1;
      } catch {
        return !0;
      }
    }
    function L(u) {
      return "" + u;
    }
    function B(u, h) {
      if (R(u))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", h, N(u)), L(u);
    }
    function j(u, h) {
      if (R(u))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", h, N(u)), L(u);
    }
    function Z(u) {
      if (R(u))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", N(u)), L(u);
    }
    var re = Object.prototype.hasOwnProperty, X = 0, se = 1, Y = 2, ie = 3, I = 4, U = 5, ue = 6, te = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", J = te + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Q = new RegExp("^[" + te + "][" + J + "]*$"), G = {}, ne = {};
    function H(u) {
      return re.call(ne, u) ? !0 : re.call(G, u) ? !1 : Q.test(u) ? (ne[u] = !0, !0) : (G[u] = !0, i("Invalid attribute name: `%s`", u), !1);
    }
    function ce(u, h, C, F) {
      if (C !== null && C.type === X)
        return !1;
      switch (typeof h) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (F)
            return !1;
          if (C !== null)
            return !C.acceptsBooleans;
          var q = u.toLowerCase().slice(0, 5);
          return q !== "data-" && q !== "aria-";
        }
        default:
          return !1;
      }
    }
    function ke(u) {
      return xe.hasOwnProperty(u) ? xe[u] : null;
    }
    function Se(u, h, C, F, q, fe, ge) {
      this.acceptsBooleans = h === Y || h === ie || h === I, this.attributeName = F, this.attributeNamespace = q, this.mustUseProperty = C, this.propertyName = u, this.type = h, this.sanitizeURL = fe, this.removeEmptyString = ge;
    }
    var xe = {}, De = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    De.forEach(function(u) {
      xe[u] = new Se(
        u,
        X,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(u) {
      var h = u[0], C = u[1];
      xe[h] = new Se(
        h,
        se,
        !1,
        // mustUseProperty
        C,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(u) {
      xe[u] = new Se(
        u,
        Y,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(u) {
      xe[u] = new Se(
        u,
        Y,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(u) {
      xe[u] = new Se(
        u,
        ie,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      xe[u] = new Se(
        u,
        ie,
        !0,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      xe[u] = new Se(
        u,
        I,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      xe[u] = new Se(
        u,
        ue,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(u) {
      xe[u] = new Se(
        u,
        U,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var je = /[\-\:]([a-z])/g, Ce = function(u) {
      return u[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(je, Ce);
      xe[h] = new Se(
        h,
        se,
        !1,
        // mustUseProperty
        u,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(je, Ce);
      xe[h] = new Se(
        h,
        se,
        !1,
        // mustUseProperty
        u,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(je, Ce);
      xe[h] = new Se(
        h,
        se,
        !1,
        // mustUseProperty
        u,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(u) {
      xe[u] = new Se(
        u,
        se,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ye = "xlinkHref";
    xe[ye] = new Se(
      "xlinkHref",
      se,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(u) {
      xe[u] = new Se(
        u,
        se,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ee = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function he(u, h) {
      return u + h.charAt(0).toUpperCase() + h.substring(1);
    }
    var Be = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Ee).forEach(function(u) {
      Be.forEach(function(h) {
        Ee[he(h, u)] = Ee[u];
      });
    });
    var $e = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function tt(u, h) {
      $e[h.type] || h.onChange || h.onInput || h.readOnly || h.disabled || h.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), h.onChange || h.readOnly || h.disabled || h.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function We(u, h) {
      if (u.indexOf("-") === -1)
        return typeof h.is == "string";
      switch (u) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Fe = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Je = {}, Ke = new RegExp("^(aria)-[" + J + "]*$"), Ye = new RegExp("^(aria)[A-Z][" + J + "]*$");
    function Xe(u, h) {
      {
        if (re.call(Je, h) && Je[h])
          return !0;
        if (Ye.test(h)) {
          var C = "aria-" + h.slice(4).toLowerCase(), F = Fe.hasOwnProperty(C) ? C : null;
          if (F == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", h), Je[h] = !0, !0;
          if (h !== F)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", h, F), Je[h] = !0, !0;
        }
        if (Ke.test(h)) {
          var q = h.toLowerCase(), fe = Fe.hasOwnProperty(q) ? q : null;
          if (fe == null)
            return Je[h] = !0, !1;
          if (h !== fe)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", h, fe), Je[h] = !0, !0;
        }
      }
      return !0;
    }
    function Ae(u, h) {
      {
        var C = [];
        for (var F in h) {
          var q = Xe(u, F);
          q || C.push(F);
        }
        var fe = C.map(function(ge) {
          return "`" + ge + "`";
        }).join(", ");
        C.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", fe, u) : C.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", fe, u);
      }
    }
    function Oe(u, h) {
      We(u, h) || Ae(u, h);
    }
    var lt = !1;
    function ve(u, h) {
      {
        if (u !== "input" && u !== "textarea" && u !== "select")
          return;
        h != null && h.value === null && !lt && (lt = !0, u === "select" && h.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", u) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", u));
      }
    }
    var mt = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, ut = function() {
    };
    {
      var st = {}, Lt = /^on./, Kt = /^on[^A-Z]/, Xt = new RegExp("^(aria)-[" + J + "]*$"), It = new RegExp("^(aria)[A-Z][" + J + "]*$");
      ut = function(u, h, C, F) {
        if (re.call(st, h) && st[h])
          return !0;
        var q = h.toLowerCase();
        if (q === "onfocusin" || q === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), st[h] = !0, !0;
        if (F != null) {
          var fe = F.registrationNameDependencies, ge = F.possibleRegistrationNames;
          if (fe.hasOwnProperty(h))
            return !0;
          var Ne = ge.hasOwnProperty(q) ? ge[q] : null;
          if (Ne != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", h, Ne), st[h] = !0, !0;
          if (Lt.test(h))
            return i("Unknown event handler property `%s`. It will be ignored.", h), st[h] = !0, !0;
        } else if (Lt.test(h))
          return Kt.test(h) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", h), st[h] = !0, !0;
        if (Xt.test(h) || It.test(h))
          return !0;
        if (q === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), st[h] = !0, !0;
        if (q === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), st[h] = !0, !0;
        if (q === "is" && C !== null && C !== void 0 && typeof C != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof C), st[h] = !0, !0;
        if (typeof C == "number" && isNaN(C))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", h), st[h] = !0, !0;
        var l = ke(h), f = l !== null && l.type === X;
        if (mt.hasOwnProperty(q)) {
          var k = mt[q];
          if (k !== h)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", h, k), st[h] = !0, !0;
        } else if (!f && h !== q)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", h, q), st[h] = !0, !0;
        return typeof C == "boolean" && ce(h, C, l, !1) ? (C ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', C, h, h, C, h) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', C, h, h, C, h, h, h), st[h] = !0, !0) : f ? !0 : ce(h, C, l, !1) ? (st[h] = !0, !1) : ((C === "false" || C === "true") && l !== null && l.type === ie && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", C, h, C === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', h, C), st[h] = !0), !0);
      };
    }
    var ln = function(u, h, C) {
      {
        var F = [];
        for (var q in h) {
          var fe = ut(u, q, h[q], C);
          fe || F.push(q);
        }
        var ge = F.map(function(Ne) {
          return "`" + Ne + "`";
        }).join(", ");
        F.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", ge, u) : F.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", ge, u);
      }
    };
    function Tt(u, h, C) {
      We(u, h) || ln(u, h, C);
    }
    var Ot = function() {
    };
    {
      var _t = /^(?:webkit|moz|o)[A-Z]/, an = /^-ms-/, dn = /-(.)/g, zt = /;\s*$/, Bt = {}, on = {}, rt = !1, ht = !1, Pe = function(u) {
        return u.replace(dn, function(h, C) {
          return C.toUpperCase();
        });
      }, _e = function(u) {
        Bt.hasOwnProperty(u) && Bt[u] || (Bt[u] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          u,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Pe(u.replace(an, "ms-"))
        ));
      }, we = function(u) {
        Bt.hasOwnProperty(u) && Bt[u] || (Bt[u] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", u, u.charAt(0).toUpperCase() + u.slice(1)));
      }, yt = function(u, h) {
        on.hasOwnProperty(h) && on[h] || (on[h] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, u, h.replace(zt, "")));
      }, at = function(u, h) {
        rt || (rt = !0, i("`NaN` is an invalid value for the `%s` css style property.", u));
      }, bt = function(u, h) {
        ht || (ht = !0, i("`Infinity` is an invalid value for the `%s` css style property.", u));
      };
      Ot = function(u, h) {
        u.indexOf("-") > -1 ? _e(u) : _t.test(u) ? we(u) : zt.test(h) && yt(u, h), typeof h == "number" && (isNaN(h) ? at(u, h) : isFinite(h) || bt(u, h));
      };
    }
    var wt = Ot, qt = /["'&<>]/;
    function ct(u) {
      Z(u);
      var h = "" + u, C = qt.exec(h);
      if (!C)
        return h;
      var F, q = "", fe, ge = 0;
      for (fe = C.index; fe < h.length; fe++) {
        switch (h.charCodeAt(fe)) {
          case 34:
            F = "&quot;";
            break;
          case 38:
            F = "&amp;";
            break;
          case 39:
            F = "&#x27;";
            break;
          case 60:
            F = "&lt;";
            break;
          case 62:
            F = "&gt;";
            break;
          default:
            continue;
        }
        ge !== fe && (q += h.substring(ge, fe)), ge = fe + 1, q += F;
      }
      return ge !== fe ? q + h.substring(ge, fe) : q;
    }
    function dt(u) {
      return typeof u == "boolean" || typeof u == "number" ? "" + u : ct(u);
    }
    var Wt = /([A-Z])/g, Yt = /^ms-/;
    function Rt(u) {
      return u.replace(Wt, "-$1").toLowerCase().replace(Yt, "-ms-");
    }
    var Ct = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, xn = !1;
    function Sn(u) {
      !xn && Ct.test(u) && (xn = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(u)));
    }
    var Ln = Array.isArray;
    function On(u) {
      return Ln(u);
    }
    var En = v("<script>"), rr = v("<\/script>"), Mn = v('<script src="'), wn = v('<script type="module" src="'), Pt = v('" async=""><\/script>');
    function jt(u) {
      return Z(u), ("" + u).replace(kn, tn);
    }
    var kn = /(<\/|<)(s)(cript)/gi, tn = function(u, h, C, F) {
      return "" + h + (C === "s" ? "\\u0073" : "\\u0053") + F;
    };
    function fn(u, h, C, F, q) {
      var fe = u === void 0 ? "" : u, ge = h === void 0 ? En : v('<script nonce="' + dt(h) + '">'), Ne = [];
      if (C !== void 0 && Ne.push(ge, b(jt(C)), rr), F !== void 0)
        for (var l = 0; l < F.length; l++)
          Ne.push(Mn, b(dt(F[l])), Pt);
      if (q !== void 0)
        for (var f = 0; f < q.length; f++)
          Ne.push(wn, b(dt(q[f])), Pt);
      return {
        bootstrapChunks: Ne,
        startInlineScript: ge,
        placeholderPrefix: v(fe + "P:"),
        segmentPrefix: v(fe + "S:"),
        boundaryPrefix: fe + "B:",
        idPrefix: fe,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var An = 0, Dt = 1, bn = 2, sn = 3, hn = 4, ir = 5, Fn = 6, Rn = 7;
    function yn(u, h) {
      return {
        insertionMode: u,
        selectedValue: h
      };
    }
    function $n(u) {
      var h = u === "http://www.w3.org/2000/svg" ? bn : u === "http://www.w3.org/1998/Math/MathML" ? sn : An;
      return yn(h, null);
    }
    function Hn(u, h, C) {
      switch (h) {
        case "select":
          return yn(Dt, C.value != null ? C.value : C.defaultValue);
        case "svg":
          return yn(bn, null);
        case "math":
          return yn(sn, null);
        case "foreignObject":
          return yn(Dt, null);
        case "table":
          return yn(hn, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return yn(ir, null);
        case "colgroup":
          return yn(Rn, null);
        case "tr":
          return yn(Fn, null);
      }
      return u.insertionMode >= hn || u.insertionMode === An ? yn(Dt, null) : u;
    }
    var ar = null;
    function gr(u) {
      var h = u.nextSuspenseID++;
      return v(u.boundaryPrefix + h.toString(16));
    }
    function or(u, h, C) {
      var F = u.idPrefix, q = ":" + F + "R" + h;
      return C > 0 && (q += "H" + C.toString(32)), q + ":";
    }
    function jn(u) {
      return dt(u);
    }
    var lr = v("<!-- -->");
    function Xn(u, h, C, F) {
      return h === "" ? F : (F && u.push(lr), u.push(b(jn(h))), !0);
    }
    function qn(u, h, C, F) {
      C && F && u.push(lr);
    }
    var S = /* @__PURE__ */ new Map();
    function _(u) {
      var h = S.get(u);
      if (h !== void 0)
        return h;
      var C = v(dt(Rt(u)));
      return S.set(u, C), C;
    }
    var D = v(' style="'), K = v(":"), pe = v(";");
    function O(u, h, C) {
      if (typeof C != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var F = !0;
      for (var q in C)
        if (re.call(C, q)) {
          var fe = C[q];
          if (!(fe == null || typeof fe == "boolean" || fe === "")) {
            var ge = void 0, Ne = void 0, l = q.indexOf("--") === 0;
            l ? (ge = b(dt(q)), j(fe, q), Ne = b(dt(("" + fe).trim()))) : (wt(q, fe), ge = _(q), typeof fe == "number" ? fe !== 0 && !re.call(Ee, q) ? Ne = b(fe + "px") : Ne = b("" + fe) : (j(fe, q), Ne = b(dt(("" + fe).trim())))), F ? (F = !1, u.push(D, ge, K, Ne)) : u.push(pe, ge, K, Ne);
          }
        }
      F || u.push(be);
    }
    var $ = v(" "), ee = v('="'), be = v('"'), Ie = v('=""');
    function Qe(u, h, C, F) {
      switch (C) {
        case "style": {
          O(u, h, F);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(C.length > 2 && (C[0] === "o" || C[0] === "O") && (C[1] === "n" || C[1] === "N"))
      ) {
        var q = ke(C);
        if (q !== null) {
          switch (typeof F) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!q.acceptsBooleans)
                return;
          }
          var fe = q.attributeName, ge = b(fe);
          switch (q.type) {
            case ie:
              F && u.push($, ge, Ie);
              return;
            case I:
              F === !0 ? u.push($, ge, Ie) : F === !1 || u.push($, ge, ee, b(dt(F)), be);
              return;
            case U:
              isNaN(F) || u.push($, ge, ee, b(dt(F)), be);
              break;
            case ue:
              !isNaN(F) && F >= 1 && u.push($, ge, ee, b(dt(F)), be);
              break;
            default:
              q.sanitizeURL && (B(F, fe), F = "" + F, Sn(F)), u.push($, ge, ee, b(dt(F)), be);
          }
        } else if (H(C)) {
          switch (typeof F) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Ne = C.toLowerCase().slice(0, 5);
              if (Ne !== "data-" && Ne !== "aria-")
                return;
            }
          }
          u.push($, b(C), ee, b(dt(F)), be);
        }
      }
    }
    var pt = v(">"), Ut = v("/>");
    function $t(u, h, C) {
      if (h != null) {
        if (C != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof h != "object" || !("__html" in h))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var F = h.__html;
        F != null && (Z(F), u.push(b("" + F)));
      }
    }
    var Qt = !1, Jt = !1, en = !1, Vn = !1, Zn = !1, Qn = !1, Un = !1;
    function Tr(u, h) {
      {
        var C = u[h];
        if (C != null) {
          var F = On(C);
          u.multiple && !F ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", h) : !u.multiple && F && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", h);
        }
      }
    }
    function wi(u, h, C) {
      tt("select", h), Tr(h, "value"), Tr(h, "defaultValue"), h.value !== void 0 && h.defaultValue !== void 0 && !en && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), en = !0), u.push(ur("select"));
      var F = null, q = null;
      for (var fe in h)
        if (re.call(h, fe)) {
          var ge = h[fe];
          if (ge == null)
            continue;
          switch (fe) {
            case "children":
              F = ge;
              break;
            case "dangerouslySetInnerHTML":
              q = ge;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              Qe(u, C, fe, ge);
              break;
          }
        }
      return u.push(pt), $t(u, q, F), F;
    }
    function Nt(u) {
      var h = "";
      return e.Children.forEach(u, function(C) {
        C != null && (h += C, !Zn && typeof C != "string" && typeof C != "number" && (Zn = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), h;
    }
    var pn = v(' selected=""');
    function oi(u, h, C, F) {
      var q = F.selectedValue;
      u.push(ur("option"));
      var fe = null, ge = null, Ne = null, l = null;
      for (var f in h)
        if (re.call(h, f)) {
          var k = h[f];
          if (k == null)
            continue;
          switch (f) {
            case "children":
              fe = k;
              break;
            case "selected":
              Ne = k, Un || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Un = !0);
              break;
            case "dangerouslySetInnerHTML":
              l = k;
              break;
            case "value":
              ge = k;
            default:
              Qe(u, C, f, k);
              break;
          }
        }
      if (q != null) {
        var P;
        if (ge !== null ? (B(ge, "value"), P = "" + ge) : (l !== null && (Qn || (Qn = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), P = Nt(fe)), On(q))
          for (var V = 0; V < q.length; V++) {
            B(q[V], "value");
            var le = "" + q[V];
            if (le === P) {
              u.push(pn);
              break;
            }
          }
        else
          B(q, "select.value"), "" + q === P && u.push(pn);
      } else
        Ne && u.push(pn);
      return u.push(pt), $t(u, l, fe), fe;
    }
    function Or(u, h, C) {
      tt("input", h), h.checked !== void 0 && h.defaultChecked !== void 0 && !Jt && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), Jt = !0), h.value !== void 0 && h.defaultValue !== void 0 && !Qt && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), Qt = !0), u.push(ur("input"));
      var F = null, q = null, fe = null, ge = null;
      for (var Ne in h)
        if (re.call(h, Ne)) {
          var l = h[Ne];
          if (l == null)
            continue;
          switch (Ne) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              ge = l;
              break;
            case "defaultValue":
              q = l;
              break;
            case "checked":
              fe = l;
              break;
            case "value":
              F = l;
              break;
            default:
              Qe(u, C, Ne, l);
              break;
          }
        }
      return fe !== null ? Qe(u, C, "checked", fe) : ge !== null && Qe(u, C, "checked", ge), F !== null ? Qe(u, C, "value", F) : q !== null && Qe(u, C, "value", q), u.push(Ut), null;
    }
    function sr(u, h, C) {
      tt("textarea", h), h.value !== void 0 && h.defaultValue !== void 0 && !Vn && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Vn = !0), u.push(ur("textarea"));
      var F = null, q = null, fe = null;
      for (var ge in h)
        if (re.call(h, ge)) {
          var Ne = h[ge];
          if (Ne == null)
            continue;
          switch (ge) {
            case "children":
              fe = Ne;
              break;
            case "value":
              F = Ne;
              break;
            case "defaultValue":
              q = Ne;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              Qe(u, C, ge, Ne);
              break;
          }
        }
      if (F === null && q !== null && (F = q), u.push(pt), fe != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), F != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (On(fe)) {
          if (fe.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          Z(fe[0]), F = "" + fe[0];
        }
        Z(fe), F = "" + fe;
      }
      return typeof F == "string" && F[0] === `
` && u.push(Fr), F !== null && (B(F, "value"), u.push(b(jn("" + F)))), null;
    }
    function Mr(u, h, C, F) {
      u.push(ur(C));
      for (var q in h)
        if (re.call(h, q)) {
          var fe = h[q];
          if (fe == null)
            continue;
          switch (q) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(C + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              Qe(u, F, q, fe);
              break;
          }
        }
      return u.push(Ut), null;
    }
    function Kr(u, h, C) {
      u.push(ur("menuitem"));
      for (var F in h)
        if (re.call(h, F)) {
          var q = h[F];
          if (q == null)
            continue;
          switch (F) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              Qe(u, C, F, q);
              break;
          }
        }
      return u.push(pt), null;
    }
    function Ht(u, h, C) {
      u.push(ur("title"));
      var F = null;
      for (var q in h)
        if (re.call(h, q)) {
          var fe = h[q];
          if (fe == null)
            continue;
          switch (q) {
            case "children":
              F = fe;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              Qe(u, C, q, fe);
              break;
          }
        }
      u.push(pt);
      {
        var ge = Array.isArray(F) && F.length < 2 ? F[0] || null : F;
        Array.isArray(F) && F.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : ge != null && ge.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : ge != null && typeof ge != "string" && typeof ge != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return F;
    }
    function vr(u, h, C, F) {
      u.push(ur(C));
      var q = null, fe = null;
      for (var ge in h)
        if (re.call(h, ge)) {
          var Ne = h[ge];
          if (Ne == null)
            continue;
          switch (ge) {
            case "children":
              q = Ne;
              break;
            case "dangerouslySetInnerHTML":
              fe = Ne;
              break;
            default:
              Qe(u, F, ge, Ne);
              break;
          }
        }
      return u.push(pt), $t(u, fe, q), typeof q == "string" ? (u.push(b(jn(q))), null) : q;
    }
    function Kn(u, h, C, F) {
      u.push(ur(C));
      var q = null, fe = null;
      for (var ge in h)
        if (re.call(h, ge)) {
          var Ne = h[ge];
          if (Ne == null)
            continue;
          switch (ge) {
            case "children":
              q = Ne;
              break;
            case "dangerouslySetInnerHTML":
              fe = Ne;
              break;
            case "style":
              O(u, F, Ne);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              H(ge) && typeof Ne != "function" && typeof Ne != "symbol" && u.push($, b(ge), ee, b(dt(Ne)), be);
              break;
          }
        }
      return u.push(pt), $t(u, fe, q), q;
    }
    var Fr = v(`
`);
    function Ar(u, h, C, F) {
      u.push(ur(C));
      var q = null, fe = null;
      for (var ge in h)
        if (re.call(h, ge)) {
          var Ne = h[ge];
          if (Ne == null)
            continue;
          switch (ge) {
            case "children":
              q = Ne;
              break;
            case "dangerouslySetInnerHTML":
              fe = Ne;
              break;
            default:
              Qe(u, F, ge, Ne);
              break;
          }
        }
      if (u.push(pt), fe != null) {
        if (q != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof fe != "object" || !("__html" in fe))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var l = fe.__html;
        l != null && (typeof l == "string" && l.length > 0 && l[0] === `
` ? u.push(Fr, b(l)) : (Z(l), u.push(b("" + l))));
      }
      return typeof q == "string" && q[0] === `
` && u.push(Fr), q;
    }
    var ki = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Lr = /* @__PURE__ */ new Map();
    function ur(u) {
      var h = Lr.get(u);
      if (h === void 0) {
        if (!ki.test(u))
          throw new Error("Invalid tag: " + u);
        h = v("<" + u), Lr.set(u, h);
      }
      return h;
    }
    var Ji = v("<!DOCTYPE html>");
    function ea(u, h, C, F, q) {
      switch (Oe(h, C), ve(h, C), Tt(h, C, null), !C.suppressContentEditableWarning && C.contentEditable && C.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), q.insertionMode !== bn && q.insertionMode !== sn && h.indexOf("-") === -1 && typeof C.is != "string" && h.toLowerCase() !== h && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", h), h) {
        case "select":
          return wi(u, C, F);
        case "option":
          return oi(u, C, F, q);
        case "textarea":
          return sr(u, C, F);
        case "input":
          return Or(u, C, F);
        case "menuitem":
          return Kr(u, C, F);
        case "title":
          return Ht(u, C, F);
        case "listing":
        case "pre":
          return Ar(u, C, h, F);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Mr(u, C, h, F);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return vr(u, C, h, F);
        case "html":
          return q.insertionMode === An && u.push(Ji), vr(u, C, h, F);
        default:
          return h.indexOf("-") === -1 && typeof C.is != "string" ? vr(u, C, h, F) : Kn(u, C, h, F);
      }
    }
    var qa = v("</"), Za = v(">");
    function Qa(u, h, C) {
      switch (h) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          u.push(qa, b(h), Za);
      }
    }
    function ml(u, h) {
      for (var C = h.bootstrapChunks, F = 0; F < C.length - 1; F++)
        g(u, C[F]);
      return F < C.length ? x(u, C[F]) : !0;
    }
    var yl = v('<template id="'), Ti = v('"></template>');
    function Ci(u, h, C) {
      g(u, yl), g(u, h.placeholderPrefix);
      var F = b(C.toString(16));
      return g(u, F), x(u, Ti);
    }
    var Ai = v("<!--$-->"), li = v('<!--$?--><template id="'), gl = v('"></template>'), si = v("<!--$!-->"), ta = v("<!--/$-->"), na = v("<template"), Yr = v('"'), Gr = v(' data-dgst="'), Li = v(' data-msg="'), Ja = v(' data-stck="'), ra = v("></template>");
    function eo(u, h) {
      return x(u, Ai);
    }
    function Ei(u, h, C) {
      if (g(u, li), C === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(u, C), x(u, gl);
    }
    function Yn(u, h, C, F, q) {
      var fe;
      return fe = x(u, si), g(u, na), C && (g(u, Gr), g(u, b(dt(C))), g(u, Yr)), F && (g(u, Li), g(u, b(dt(F))), g(u, Yr)), q && (g(u, Ja), g(u, b(dt(q))), g(u, Yr)), fe = x(u, ra), fe;
    }
    function to(u, h) {
      return x(u, ta);
    }
    function Ri(u, h) {
      return x(u, ta);
    }
    function vl(u, h) {
      return x(u, ta);
    }
    var no = v('<div hidden id="'), Ni = v('">'), ro = v("</div>"), io = v('<svg aria-hidden="true" style="display:none" id="'), Pi = v('">'), Di = v("</svg>"), ao = v('<math aria-hidden="true" style="display:none" id="'), oo = v('">'), lo = v("</math>"), ia = v('<table hidden id="'), so = v('">'), w = v("</table>"), M = v('<table hidden><tbody id="'), W = v('">'), ae = v("</tbody></table>"), Le = v('<table hidden><tr id="'), Te = v('">'), Me = v("</tr></table>"), qe = v('<table hidden><colgroup id="'), St = v('">'), Et = v("</colgroup></table>");
    function At(u, h, C, F) {
      switch (C.insertionMode) {
        case An:
        case Dt:
          return g(u, no), g(u, h.segmentPrefix), g(u, b(F.toString(16))), x(u, Ni);
        case bn:
          return g(u, io), g(u, h.segmentPrefix), g(u, b(F.toString(16))), x(u, Pi);
        case sn:
          return g(u, ao), g(u, h.segmentPrefix), g(u, b(F.toString(16))), x(u, oo);
        case hn:
          return g(u, ia), g(u, h.segmentPrefix), g(u, b(F.toString(16))), x(u, so);
        case ir:
          return g(u, M), g(u, h.segmentPrefix), g(u, b(F.toString(16))), x(u, W);
        case Fn:
          return g(u, Le), g(u, h.segmentPrefix), g(u, b(F.toString(16))), x(u, Te);
        case Rn:
          return g(u, qe), g(u, h.segmentPrefix), g(u, b(F.toString(16))), x(u, St);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function nn(u, h) {
      switch (h.insertionMode) {
        case An:
        case Dt:
          return x(u, ro);
        case bn:
          return x(u, Di);
        case sn:
          return x(u, lo);
        case hn:
          return x(u, w);
        case ir:
          return x(u, ae);
        case Fn:
          return x(u, Me);
        case Rn:
          return x(u, Et);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Gn = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", cr = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', dr = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', _i = v(Gn + ';$RS("'), uo = v('$RS("'), aa = v('","'), Kc = v('")<\/script>');
    function Yc(u, h, C) {
      g(u, h.startInlineScript), h.sentCompleteSegmentFunction ? g(u, uo) : (h.sentCompleteSegmentFunction = !0, g(u, _i)), g(u, h.segmentPrefix);
      var F = b(C.toString(16));
      return g(u, F), g(u, aa), g(u, h.placeholderPrefix), g(u, F), x(u, Kc);
    }
    var Gc = v(cr + ';$RC("'), Xc = v('$RC("'), qc = v('","'), Zc = v('")<\/script>');
    function xl(u, h, C, F) {
      if (g(u, h.startInlineScript), h.sentCompleteBoundaryFunction ? g(u, Xc) : (h.sentCompleteBoundaryFunction = !0, g(u, Gc)), C === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var q = b(F.toString(16));
      return g(u, C), g(u, qc), g(u, h.segmentPrefix), g(u, q), x(u, Zc);
    }
    var Qc = v(dr + ';$RX("'), Jc = v('$RX("'), bl = v('"'), ed = v(")<\/script>"), Sl = v(",");
    function zs(u, h, C, F, q, fe) {
      if (g(u, h.startInlineScript), h.sentClientRenderFunction ? g(u, Jc) : (h.sentClientRenderFunction = !0, g(u, Qc)), C === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(u, C), g(u, bl), (F || q || fe) && (g(u, Sl), g(u, b(wl(F || "")))), (q || fe) && (g(u, Sl), g(u, b(wl(q || "")))), fe && (g(u, Sl), g(u, b(wl(fe)))), x(u, ed);
    }
    var Bs = /[<\u2028\u2029]/g;
    function wl(u) {
      var h = JSON.stringify(u);
      return h.replace(Bs, function(C) {
        switch (C) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var xr = Object.assign, td = Symbol.for("react.element"), Is = Symbol.for("react.portal"), fr = Symbol.for("react.fragment"), $s = Symbol.for("react.strict_mode"), kl = Symbol.for("react.profiler"), co = Symbol.for("react.provider"), fo = Symbol.for("react.context"), ho = Symbol.for("react.forward_ref"), oa = Symbol.for("react.suspense"), la = Symbol.for("react.suspense_list"), sa = Symbol.for("react.memo"), Oi = Symbol.for("react.lazy"), Tl = Symbol.for("react.scope"), Cl = Symbol.for("react.debug_trace_mode"), po = Symbol.for("react.legacy_hidden"), nd = Symbol.for("react.default_value"), Hs = Symbol.iterator, rd = "@@iterator";
    function id(u) {
      if (u === null || typeof u != "object")
        return null;
      var h = Hs && u[Hs] || u[rd];
      return typeof h == "function" ? h : null;
    }
    function Vs(u, h, C) {
      var F = u.displayName;
      if (F)
        return F;
      var q = h.displayName || h.name || "";
      return q !== "" ? C + "(" + q + ")" : C;
    }
    function Ws(u) {
      return u.displayName || "Context";
    }
    function gn(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case fr:
          return "Fragment";
        case Is:
          return "Portal";
        case kl:
          return "Profiler";
        case $s:
          return "StrictMode";
        case oa:
          return "Suspense";
        case la:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case fo:
            var h = u;
            return Ws(h) + ".Consumer";
          case co:
            var C = u;
            return Ws(C._context) + ".Provider";
          case ho:
            return Vs(u, u.render, "ForwardRef");
          case sa:
            var F = u.displayName || null;
            return F !== null ? F : gn(u.type) || "Memo";
          case Oi: {
            var q = u, fe = q._payload, ge = q._init;
            try {
              return gn(ge(fe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ua = 0, Al, mn, Mi, Ll, El, Rl, Nl;
    function Pl() {
    }
    Pl.__reactDisabledLog = !0;
    function js() {
      {
        if (ua === 0) {
          Al = console.log, mn = console.info, Mi = console.warn, Ll = console.error, El = console.group, Rl = console.groupCollapsed, Nl = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: Pl,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        ua++;
      }
    }
    function Us() {
      {
        if (ua--, ua === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: xr({}, u, {
              value: Al
            }),
            info: xr({}, u, {
              value: mn
            }),
            warn: xr({}, u, {
              value: Mi
            }),
            error: xr({}, u, {
              value: Ll
            }),
            group: xr({}, u, {
              value: El
            }),
            groupCollapsed: xr({}, u, {
              value: Rl
            }),
            groupEnd: xr({}, u, {
              value: Nl
            })
          });
        }
        ua < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var mo = n.ReactCurrentDispatcher, Dl;
    function ca(u, h, C) {
      {
        if (Dl === void 0)
          try {
            throw Error();
          } catch (q) {
            var F = q.stack.trim().match(/\n( *(at )?)/);
            Dl = F && F[1] || "";
          }
        return `
` + Dl + u;
      }
    }
    var da = !1, Fi;
    {
      var fa = typeof WeakMap == "function" ? WeakMap : Map;
      Fi = new fa();
    }
    function ha(u, h) {
      if (!u || da)
        return "";
      {
        var C = Fi.get(u);
        if (C !== void 0)
          return C;
      }
      var F;
      da = !0;
      var q = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var fe;
      fe = mo.current, mo.current = null, js();
      try {
        if (h) {
          var ge = function() {
            throw Error();
          };
          if (Object.defineProperty(ge.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ge, []);
            } catch (me) {
              F = me;
            }
            Reflect.construct(u, [], ge);
          } else {
            try {
              ge.call();
            } catch (me) {
              F = me;
            }
            u.call(ge.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (me) {
            F = me;
          }
          u();
        }
      } catch (me) {
        if (me && F && typeof me.stack == "string") {
          for (var Ne = me.stack.split(`
`), l = F.stack.split(`
`), f = Ne.length - 1, k = l.length - 1; f >= 1 && k >= 0 && Ne[f] !== l[k]; )
            k--;
          for (; f >= 1 && k >= 0; f--, k--)
            if (Ne[f] !== l[k]) {
              if (f !== 1 || k !== 1)
                do
                  if (f--, k--, k < 0 || Ne[f] !== l[k]) {
                    var P = `
` + Ne[f].replace(" at new ", " at ");
                    return u.displayName && P.includes("<anonymous>") && (P = P.replace("<anonymous>", u.displayName)), typeof u == "function" && Fi.set(u, P), P;
                  }
                while (f >= 1 && k >= 0);
              break;
            }
        }
      } finally {
        da = !1, mo.current = fe, Us(), Error.prepareStackTrace = q;
      }
      var V = u ? u.displayName || u.name : "", le = V ? ca(V) : "";
      return typeof u == "function" && Fi.set(u, le), le;
    }
    function yo(u, h, C) {
      return ha(u, !0);
    }
    function Ks(u, h, C) {
      return ha(u, !1);
    }
    function _l(u) {
      var h = u.prototype;
      return !!(h && h.isReactComponent);
    }
    function Ol(u, h, C) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return ha(u, _l(u));
      if (typeof u == "string")
        return ca(u);
      switch (u) {
        case oa:
          return ca("Suspense");
        case la:
          return ca("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case ho:
            return Ks(u.render);
          case sa:
            return Ol(u.type, h, C);
          case Oi: {
            var F = u, q = F._payload, fe = F._init;
            try {
              return Ol(fe(q), h, C);
            } catch {
            }
          }
        }
      return "";
    }
    var Ml = {}, Ys = n.ReactDebugCurrentFrame;
    function zi(u) {
      if (u) {
        var h = u._owner, C = Ol(u.type, u._source, h ? h.type : null);
        Ys.setExtraStackFrame(C);
      } else
        Ys.setExtraStackFrame(null);
    }
    function Fl(u, h, C, F, q) {
      {
        var fe = Function.call.bind(re);
        for (var ge in u)
          if (fe(u, ge)) {
            var Ne = void 0;
            try {
              if (typeof u[ge] != "function") {
                var l = Error((F || "React class") + ": " + C + " type `" + ge + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[ge] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw l.name = "Invariant Violation", l;
              }
              Ne = u[ge](h, ge, F, C, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (f) {
              Ne = f;
            }
            Ne && !(Ne instanceof Error) && (zi(q), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", F || "React class", C, ge, typeof Ne), zi(null)), Ne instanceof Error && !(Ne.message in Ml) && (Ml[Ne.message] = !0, zi(q), i("Failed %s type: %s", C, Ne.message), zi(null));
          }
      }
    }
    var go;
    go = {};
    var ui = {};
    Object.freeze(ui);
    function zl(u, h) {
      {
        var C = u.contextTypes;
        if (!C)
          return ui;
        var F = {};
        for (var q in C)
          F[q] = h[q];
        {
          var fe = gn(u) || "Unknown";
          Fl(C, F, "context", fe);
        }
        return F;
      }
    }
    function Bl(u, h, C, F) {
      {
        if (typeof u.getChildContext != "function") {
          {
            var q = gn(h) || "Unknown";
            go[q] || (go[q] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", q, q));
          }
          return C;
        }
        var fe = u.getChildContext();
        for (var ge in fe)
          if (!(ge in F))
            throw new Error((gn(h) || "Unknown") + '.getChildContext(): key "' + ge + '" is not defined in childContextTypes.');
        {
          var Ne = gn(h) || "Unknown";
          Fl(F, fe, "child context", Ne);
        }
        return xr({}, C, fe);
      }
    }
    var Xr;
    Xr = {};
    var Gs = null, ci = null;
    function di(u) {
      u.context._currentValue = u.parentValue;
    }
    function Il(u) {
      u.context._currentValue = u.value;
    }
    function Er(u, h) {
      if (u !== h) {
        di(u);
        var C = u.parent, F = h.parent;
        if (C === null) {
          if (F !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (F === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          Er(C, F);
        }
        Il(h);
      }
    }
    function vo(u) {
      di(u);
      var h = u.parent;
      h !== null && vo(h);
    }
    function xo(u) {
      var h = u.parent;
      h !== null && xo(h), Il(u);
    }
    function pa(u, h) {
      di(u);
      var C = u.parent;
      if (C === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      C.depth === h.depth ? Er(C, h) : pa(C, h);
    }
    function $l(u, h) {
      var C = h.parent;
      if (C === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      u.depth === C.depth ? Er(u, C) : $l(u, C), Il(h);
    }
    function ma(u) {
      var h = ci, C = u;
      h !== C && (h === null ? xo(C) : C === null ? vo(h) : h.depth === C.depth ? Er(h, C) : h.depth > C.depth ? pa(h, C) : $l(h, C), ci = C);
    }
    function Xs(u, h) {
      var C;
      C = u._currentValue, u._currentValue = h, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== Xr && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = Xr;
      var F = ci, q = {
        parent: F,
        depth: F === null ? 0 : F.depth + 1,
        context: u,
        parentValue: C,
        value: h
      };
      return ci = q, q;
    }
    function qs(u) {
      var h = ci;
      if (h === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      h.context !== u && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var C = h.parentValue;
        C === nd ? h.context._currentValue = h.context._defaultValue : h.context._currentValue = C, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== Xr && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = Xr;
      }
      return ci = h.parent;
    }
    function bo() {
      return ci;
    }
    function ya(u) {
      var h = u._currentValue;
      return h;
    }
    function Hl(u) {
      return u._reactInternals;
    }
    function ad(u, h) {
      u._reactInternals = h;
    }
    var Bi = {}, So = {}, Vl, wo, ko, ga, To, Ii, va, Co, $i;
    {
      Vl = /* @__PURE__ */ new Set(), wo = /* @__PURE__ */ new Set(), ko = /* @__PURE__ */ new Set(), va = /* @__PURE__ */ new Set(), ga = /* @__PURE__ */ new Set(), Co = /* @__PURE__ */ new Set(), $i = /* @__PURE__ */ new Set();
      var Ao = /* @__PURE__ */ new Set();
      Ii = function(u, h) {
        if (!(u === null || typeof u == "function")) {
          var C = h + "_" + u;
          Ao.has(C) || (Ao.add(C), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", h, u));
        }
      }, To = function(u, h) {
        if (h === void 0) {
          var C = gn(u) || "Component";
          ga.has(C) || (ga.add(C), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", C));
        }
      };
    }
    function Lo(u, h) {
      {
        var C = u.constructor, F = C && gn(C) || "ReactClass", q = F + "." + h;
        if (Bi[q])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, h, h, F), Bi[q] = !0;
      }
    }
    var Eo = {
      isMounted: function(u) {
        return !1;
      },
      enqueueSetState: function(u, h, C) {
        var F = Hl(u);
        F.queue === null ? Lo(u, "setState") : (F.queue.push(h), C != null && Ii(C, "setState"));
      },
      enqueueReplaceState: function(u, h, C) {
        var F = Hl(u);
        F.replace = !0, F.queue = [h], C != null && Ii(C, "setState");
      },
      enqueueForceUpdate: function(u, h) {
        var C = Hl(u);
        C.queue === null ? Lo(u, "forceUpdate") : h != null && Ii(h, "setState");
      }
    };
    function Zs(u, h, C, F, q) {
      var fe = C(q, F);
      To(h, fe);
      var ge = fe == null ? F : xr({}, F, fe);
      return ge;
    }
    function Qs(u, h, C) {
      var F = ui, q = u.contextType;
      if ("contextType" in u) {
        var fe = (
          // Allow null for conditional declaration
          q === null || q !== void 0 && q.$$typeof === fo && q._context === void 0
        );
        if (!fe && !$i.has(u)) {
          $i.add(u);
          var ge = "";
          q === void 0 ? ge = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof q != "object" ? ge = " However, it is set to a " + typeof q + "." : q.$$typeof === co ? ge = " Did you accidentally pass the Context.Provider instead?" : q._context !== void 0 ? ge = " Did you accidentally pass the Context.Consumer instead?" : ge = " However, it is set to an object with keys {" + Object.keys(q).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", gn(u) || "Component", ge);
        }
      }
      typeof q == "object" && q !== null ? F = ya(q) : F = C;
      var Ne = new u(h, F);
      {
        if (typeof u.getDerivedStateFromProps == "function" && (Ne.state === null || Ne.state === void 0)) {
          var l = gn(u) || "Component";
          Vl.has(l) || (Vl.add(l), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", l, Ne.state === null ? "null" : "undefined", l));
        }
        if (typeof u.getDerivedStateFromProps == "function" || typeof Ne.getSnapshotBeforeUpdate == "function") {
          var f = null, k = null, P = null;
          if (typeof Ne.componentWillMount == "function" && Ne.componentWillMount.__suppressDeprecationWarning !== !0 ? f = "componentWillMount" : typeof Ne.UNSAFE_componentWillMount == "function" && (f = "UNSAFE_componentWillMount"), typeof Ne.componentWillReceiveProps == "function" && Ne.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? k = "componentWillReceiveProps" : typeof Ne.UNSAFE_componentWillReceiveProps == "function" && (k = "UNSAFE_componentWillReceiveProps"), typeof Ne.componentWillUpdate == "function" && Ne.componentWillUpdate.__suppressDeprecationWarning !== !0 ? P = "componentWillUpdate" : typeof Ne.UNSAFE_componentWillUpdate == "function" && (P = "UNSAFE_componentWillUpdate"), f !== null || k !== null || P !== null) {
            var V = gn(u) || "Component", le = typeof u.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            ko.has(V) || (ko.add(V), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, V, le, f !== null ? `
  ` + f : "", k !== null ? `
  ` + k : "", P !== null ? `
  ` + P : ""));
          }
        }
      }
      return Ne;
    }
    function Js(u, h, C) {
      {
        var F = gn(h) || "Component", q = u.render;
        q || (h.prototype && typeof h.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", F) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", F)), u.getInitialState && !u.getInitialState.isReactClassApproved && !u.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", F), u.getDefaultProps && !u.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", F), u.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", F), u.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", F), u.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", F), h.contextType && h.contextTypes && !Co.has(h) && (Co.add(h), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", F)), typeof u.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", F), h.prototype && h.prototype.isPureReactComponent && typeof u.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", gn(h) || "A pure component"), typeof u.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", F), typeof u.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", F), typeof u.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", F), typeof u.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", F);
        var fe = u.props !== C;
        u.props !== void 0 && fe && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", F, F), u.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", F, F), typeof u.getSnapshotBeforeUpdate == "function" && typeof u.componentDidUpdate != "function" && !wo.has(h) && (wo.add(h), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", gn(h))), typeof u.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", F), typeof u.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", F), typeof h.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", F);
        var ge = u.state;
        ge && (typeof ge != "object" || On(ge)) && i("%s.state: must be set to an object or null", F), typeof u.getChildContext == "function" && typeof h.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", F);
      }
    }
    function od(u, h) {
      var C = h.state;
      if (typeof h.componentWillMount == "function") {
        if (h.componentWillMount.__suppressDeprecationWarning !== !0) {
          var F = gn(u) || "Unknown";
          So[F] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            F
          ), So[F] = !0);
        }
        h.componentWillMount();
      }
      typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(), C !== h.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", gn(u) || "Component"), Eo.enqueueReplaceState(h, h.state, null));
    }
    function ld(u, h, C, F) {
      if (u.queue !== null && u.queue.length > 0) {
        var q = u.queue, fe = u.replace;
        if (u.queue = null, u.replace = !1, fe && q.length === 1)
          h.state = q[0];
        else {
          for (var ge = fe ? q[0] : h.state, Ne = !0, l = fe ? 1 : 0; l < q.length; l++) {
            var f = q[l], k = typeof f == "function" ? f.call(h, ge, C, F) : f;
            k != null && (Ne ? (Ne = !1, ge = xr({}, ge, k)) : xr(ge, k));
          }
          h.state = ge;
        }
      } else
        u.queue = null;
    }
    function eu(u, h, C, F) {
      Js(u, h, C);
      var q = u.state !== void 0 ? u.state : null;
      u.updater = Eo, u.props = C, u.state = q;
      var fe = {
        queue: [],
        replace: !1
      };
      ad(u, fe);
      var ge = h.contextType;
      if (typeof ge == "object" && ge !== null ? u.context = ya(ge) : u.context = F, u.state === C) {
        var Ne = gn(h) || "Component";
        va.has(Ne) || (va.add(Ne), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Ne));
      }
      var l = h.getDerivedStateFromProps;
      typeof l == "function" && (u.state = Zs(u, h, l, q, C)), typeof h.getDerivedStateFromProps != "function" && typeof u.getSnapshotBeforeUpdate != "function" && (typeof u.UNSAFE_componentWillMount == "function" || typeof u.componentWillMount == "function") && (od(h, u), ld(fe, u, C, F));
    }
    var sd = {
      id: 1,
      overflow: ""
    };
    function ud(u) {
      var h = u.overflow, C = u.id, F = C & ~cd(C);
      return F.toString(32) + h;
    }
    function Ro(u, h, C) {
      var F = u.id, q = u.overflow, fe = No(F) - 1, ge = F & ~(1 << fe), Ne = C + 1, l = No(h) + fe;
      if (l > 30) {
        var f = fe - fe % 5, k = (1 << f) - 1, P = (ge & k).toString(32), V = ge >> f, le = fe - f, me = No(h) + le, Re = Ne << le, He = Re | V, ot = P + q;
        return {
          id: 1 << me | He,
          overflow: ot
        };
      } else {
        var ft = Ne << fe, kt = ft | ge, un = q;
        return {
          id: 1 << l | kt,
          overflow: un
        };
      }
    }
    function No(u) {
      return 32 - Wl(u);
    }
    function cd(u) {
      return 1 << No(u) - 1;
    }
    var Wl = Math.clz32 ? Math.clz32 : fd, Po = Math.log, dd = Math.LN2;
    function fd(u) {
      var h = u >>> 0;
      return h === 0 ? 32 : 31 - (Po(h) / dd | 0) | 0;
    }
    function hd(u, h) {
      return u === h && (u !== 0 || 1 / u === 1 / h) || u !== u && h !== h;
    }
    var pd = typeof Object.is == "function" ? Object.is : hd, zr = null, jl = null, Do = null, Mt = null, fi = !1, hi = !1, Zt = 0, br = null, pi = 0, _o = 25, zn = !1, Br;
    function mi() {
      if (zr === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return zn && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), zr;
    }
    function Rr(u, h) {
      if (h === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Br), !1;
      u.length !== h.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Br, "[" + u.join(", ") + "]", "[" + h.join(", ") + "]");
      for (var C = 0; C < h.length && C < u.length; C++)
        if (!pd(u[C], h[C]))
          return !1;
      return !0;
    }
    function yi() {
      if (pi > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Ir() {
      return Mt === null ? Do === null ? (fi = !1, Do = Mt = yi()) : (fi = !0, Mt = Do) : Mt.next === null ? (fi = !1, Mt = Mt.next = yi()) : (fi = !0, Mt = Mt.next), Mt;
    }
    function md(u, h) {
      zr = h, jl = u, zn = !1, Zt = 0;
    }
    function tu(u, h, C, F) {
      for (; hi; )
        hi = !1, Zt = 0, pi += 1, Mt = null, C = u(h, F);
      return Ul(), C;
    }
    function Oo() {
      var u = Zt !== 0;
      return u;
    }
    function Ul() {
      zn = !1, zr = null, jl = null, hi = !1, Do = null, pi = 0, br = null, Mt = null;
    }
    function yd(u) {
      return zn && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), ya(u);
    }
    function nu(u) {
      return Br = "useContext", mi(), ya(u);
    }
    function xa(u, h) {
      return typeof h == "function" ? h(u) : h;
    }
    function gd(u) {
      return Br = "useState", ru(
        xa,
        // useReducer has a special case to support lazy useState initializers
        u
      );
    }
    function ru(u, h, C) {
      if (u !== xa && (Br = "useReducer"), zr = mi(), Mt = Ir(), fi) {
        var F = Mt.queue, q = F.dispatch;
        if (br !== null) {
          var fe = br.get(F);
          if (fe !== void 0) {
            br.delete(F);
            var ge = Mt.memoizedState, Ne = fe;
            do {
              var l = Ne.action;
              zn = !0, ge = u(ge, l), zn = !1, Ne = Ne.next;
            } while (Ne !== null);
            return Mt.memoizedState = ge, [ge, q];
          }
        }
        return [Mt.memoizedState, q];
      } else {
        zn = !0;
        var f;
        u === xa ? f = typeof h == "function" ? h() : h : f = C !== void 0 ? C(h) : h, zn = !1, Mt.memoizedState = f;
        var k = Mt.queue = {
          last: null,
          dispatch: null
        }, P = k.dispatch = au.bind(null, zr, k);
        return [Mt.memoizedState, P];
      }
    }
    function Mo(u, h) {
      zr = mi(), Mt = Ir();
      var C = h === void 0 ? null : h;
      if (Mt !== null) {
        var F = Mt.memoizedState;
        if (F !== null && C !== null) {
          var q = F[1];
          if (Rr(C, q))
            return F[0];
        }
      }
      zn = !0;
      var fe = u();
      return zn = !1, Mt.memoizedState = [fe, C], fe;
    }
    function vd(u) {
      zr = mi(), Mt = Ir();
      var h = Mt.memoizedState;
      if (h === null) {
        var C = {
          current: u
        };
        return Object.seal(C), Mt.memoizedState = C, C;
      } else
        return h;
    }
    function iu(u, h) {
      Br = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function au(u, h, C) {
      if (pi >= _o)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (u === zr) {
        hi = !0;
        var F = {
          action: C,
          next: null
        };
        br === null && (br = /* @__PURE__ */ new Map());
        var q = br.get(h);
        if (q === void 0)
          br.set(h, F);
        else {
          for (var fe = q; fe.next !== null; )
            fe = fe.next;
          fe.next = F;
        }
      }
    }
    function xd(u, h) {
      return Mo(function() {
        return u;
      }, h);
    }
    function bd(u, h, C) {
      return mi(), h(u._source);
    }
    function Sd(u, h, C) {
      if (C === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return C();
    }
    function wd(u) {
      return mi(), u;
    }
    function kd() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function Td() {
      return mi(), [!1, kd];
    }
    function Cd() {
      var u = jl, h = ud(u.treeContext), C = Kl;
      if (C === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var F = Zt++;
      return or(C, h, F);
    }
    function Fo() {
    }
    var ou = {
      readContext: yd,
      useContext: nu,
      useMemo: Mo,
      useReducer: ru,
      useRef: vd,
      useState: gd,
      useInsertionEffect: Fo,
      useLayoutEffect: iu,
      useCallback: xd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: Fo,
      // Effects are not run in the server environment.
      useEffect: Fo,
      // Debugging effect
      useDebugValue: Fo,
      useDeferredValue: wd,
      useTransition: Td,
      useId: Cd,
      // Subscriptions are not setup in a server environment.
      useMutableSource: bd,
      useSyncExternalStore: Sd
    }, Kl = null;
    function ba(u) {
      Kl = u;
    }
    function lu(u) {
      try {
        var h = "", C = u;
        do {
          switch (C.tag) {
            case 0:
              h += ca(C.type, null, null);
              break;
            case 1:
              h += Ks(C.type, null, null);
              break;
            case 2:
              h += yo(C.type, null, null);
              break;
          }
          C = C.parent;
        } while (C);
        return h;
      } catch (F) {
        return `
Error generating stack: ` + F.message + `
` + F.stack;
      }
    }
    var Sa = n.ReactCurrentDispatcher, zo = n.ReactDebugCurrentFrame, Yl = 0, qr = 1, Bo = 2, Io = 3, gi = 4, su = 0, Gl = 1, vi = 2, Ad = 12800;
    function uu(u) {
      return console.error(u), null;
    }
    function Nr() {
    }
    function Ld(u, h, C, F, q, fe, ge, Ne, l) {
      var f = [], k = /* @__PURE__ */ new Set(), P = {
        destination: null,
        responseState: h,
        progressiveChunkSize: F === void 0 ? Ad : F,
        status: su,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: k,
        pingedTasks: f,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: q === void 0 ? uu : q,
        onAllReady: fe === void 0 ? Nr : fe,
        onShellReady: ge === void 0 ? Nr : ge,
        onShellError: Ne === void 0 ? Nr : Ne,
        onFatalError: l === void 0 ? Nr : l
      }, V = $o(
        P,
        0,
        null,
        C,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      V.parentFlushed = !0;
      var le = Xl(P, u, null, V, k, ui, Gs, sd);
      return f.push(le), P;
    }
    function Ed(u, h) {
      var C = u.pingedTasks;
      C.push(h), C.length === 1 && d(function() {
        return La(u);
      });
    }
    function wa(u, h) {
      return {
        id: ar,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: h,
        errorDigest: null
      };
    }
    function Xl(u, h, C, F, q, fe, ge, Ne) {
      u.allPendingTasks++, C === null ? u.pendingRootTasks++ : C.pendingTasks++;
      var l = {
        node: h,
        ping: function() {
          return Ed(u, l);
        },
        blockedBoundary: C,
        blockedSegment: F,
        abortSet: q,
        legacyContext: fe,
        context: ge,
        treeContext: Ne
      };
      return l.componentStack = null, q.add(l), l;
    }
    function $o(u, h, C, F, q, fe) {
      return {
        status: Yl,
        id: -1,
        // lazily assigned later
        index: h,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: F,
        boundary: C,
        lastPushedText: q,
        textEmbedded: fe
      };
    }
    var $r = null;
    function ka() {
      return $r === null || $r.componentStack === null ? "" : lu($r.componentStack);
    }
    function Zr(u, h) {
      u.componentStack = {
        tag: 0,
        parent: u.componentStack,
        type: h
      };
    }
    function Pr(u, h) {
      u.componentStack = {
        tag: 1,
        parent: u.componentStack,
        type: h
      };
    }
    function ql(u, h) {
      u.componentStack = {
        tag: 2,
        parent: u.componentStack,
        type: h
      };
    }
    function Sr(u) {
      u.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : u.componentStack = u.componentStack.parent;
    }
    var Hi = null;
    function Zl(u, h) {
      {
        var C;
        typeof h == "string" ? C = h : h && typeof h.message == "string" ? C = h.message : C = String(h);
        var F = Hi || ka();
        Hi = null, u.errorMessage = C, u.errorComponentStack = F;
      }
    }
    function wr(u, h) {
      var C = u.onError(h);
      if (C != null && typeof C != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof C + '" instead');
      return C;
    }
    function Qr(u, h) {
      var C = u.onShellError;
      C(h);
      var F = u.onFatalError;
      F(h), u.destination !== null ? (u.status = vi, E(u.destination, h)) : (u.status = Gl, u.fatalError = h);
    }
    function Ql(u, h, C) {
      Zr(h, "Suspense");
      var F = h.blockedBoundary, q = h.blockedSegment, fe = C.fallback, ge = C.children, Ne = /* @__PURE__ */ new Set(), l = wa(u, Ne), f = q.chunks.length, k = $o(
        u,
        f,
        l,
        q.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      q.children.push(k), q.lastPushedText = !1;
      var P = $o(
        u,
        0,
        null,
        q.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      P.parentFlushed = !0, h.blockedBoundary = l, h.blockedSegment = P;
      try {
        if (ls(u, h, ge), qn(P.chunks, u.responseState, P.lastPushedText, P.textEmbedded), P.status = qr, Wo(l, P), l.pendingTasks === 0) {
          Sr(h);
          return;
        }
      } catch (le) {
        P.status = gi, l.forceClientRender = !0, l.errorDigest = wr(u, le), Zl(l, le);
      } finally {
        h.blockedBoundary = F, h.blockedSegment = q;
      }
      var V = Xl(u, fe, F, k, Ne, h.legacyContext, h.context, h.treeContext);
      V.componentStack = h.componentStack, u.pingedTasks.push(V), Sr(h);
    }
    function Ta(u, h, C, F) {
      Zr(h, C);
      var q = h.blockedSegment, fe = ea(q.chunks, C, F, u.responseState, q.formatContext);
      q.lastPushedText = !1;
      var ge = q.formatContext;
      q.formatContext = Hn(ge, C, F), ls(u, h, fe), q.formatContext = ge, Qa(q.chunks, C), q.lastPushedText = !1, Sr(h);
    }
    function Ho(u) {
      return u.prototype && u.prototype.isReactComponent;
    }
    function cu(u, h, C, F, q) {
      var fe = {};
      md(h, fe);
      var ge = C(F, q);
      return tu(C, F, ge, q);
    }
    function du(u, h, C, F, q) {
      var fe = C.render();
      C.props !== q && (Aa || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", gn(F) || "a component"), Aa = !0);
      {
        var ge = F.childContextTypes;
        if (ge != null) {
          var Ne = h.legacyContext, l = Bl(C, F, Ne, ge);
          h.legacyContext = l, hr(u, h, fe), h.legacyContext = Ne;
          return;
        }
      }
      hr(u, h, fe);
    }
    function Rd(u, h, C, F) {
      ql(h, C);
      var q = zl(C, h.legacyContext), fe = Qs(C, F, q);
      eu(fe, C, F, q), du(u, h, fe, C, F), Sr(h);
    }
    var Jl = {}, Ca = {}, fu = {}, es = {}, Aa = !1, ts = !1, ns = !1, rs = !1;
    function hu(u, h, C, F) {
      var q;
      if (q = zl(C, h.legacyContext), Pr(h, C), C.prototype && typeof C.prototype.render == "function") {
        var fe = gn(C) || "Unknown";
        Jl[fe] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", fe, fe), Jl[fe] = !0);
      }
      var ge = cu(u, h, C, F, q), Ne = Oo();
      if (typeof ge == "object" && ge !== null && typeof ge.render == "function" && ge.$$typeof === void 0) {
        var l = gn(C) || "Unknown";
        Ca[l] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", l, l, l), Ca[l] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof ge == "object" && ge !== null && typeof ge.render == "function" && ge.$$typeof === void 0
      ) {
        {
          var f = gn(C) || "Unknown";
          Ca[f] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", f, f, f), Ca[f] = !0);
        }
        eu(ge, C, F, q), du(u, h, ge, C, F);
      } else if (pu(C), Ne) {
        var k = h.treeContext, P = 1, V = 0;
        h.treeContext = Ro(k, P, V);
        try {
          hr(u, h, ge);
        } finally {
          h.treeContext = k;
        }
      } else
        hr(u, h, ge);
      Sr(h);
    }
    function pu(u) {
      {
        if (u && u.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", u.displayName || u.name || "Component"), typeof u.getDerivedStateFromProps == "function") {
          var h = gn(u) || "Unknown";
          es[h] || (i("%s: Function components do not support getDerivedStateFromProps.", h), es[h] = !0);
        }
        if (typeof u.contextType == "object" && u.contextType !== null) {
          var C = gn(u) || "Unknown";
          fu[C] || (i("%s: Function components do not support contextType.", C), fu[C] = !0);
        }
      }
    }
    function is(u, h) {
      if (u && u.defaultProps) {
        var C = xr({}, h), F = u.defaultProps;
        for (var q in F)
          C[q] === void 0 && (C[q] = F[q]);
        return C;
      }
      return h;
    }
    function Nd(u, h, C, F, q) {
      Pr(h, C.render);
      var fe = cu(u, h, C.render, F, q), ge = Oo();
      if (ge) {
        var Ne = h.treeContext, l = 1, f = 0;
        h.treeContext = Ro(Ne, l, f);
        try {
          hr(u, h, fe);
        } finally {
          h.treeContext = Ne;
        }
      } else
        hr(u, h, fe);
      Sr(h);
    }
    function Pd(u, h, C, F, q) {
      var fe = C.type, ge = is(fe, F);
      as(u, h, fe, ge, q);
    }
    function mu(u, h, C, F) {
      C._context === void 0 ? C !== C.Consumer && (rs || (rs = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : C = C._context;
      var q = F.children;
      typeof q != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var fe = ya(C), ge = q(fe);
      hr(u, h, ge);
    }
    function Dd(u, h, C, F) {
      var q = C._context, fe = F.value, ge = F.children, Ne;
      Ne = h.context, h.context = Xs(q, fe), hr(u, h, ge), h.context = qs(q), Ne !== h.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function _d(u, h, C, F, q) {
      Zr(h, "Lazy");
      var fe = C._payload, ge = C._init, Ne = ge(fe), l = is(Ne, F);
      as(u, h, Ne, l, q), Sr(h);
    }
    function as(u, h, C, F, q) {
      if (typeof C == "function")
        if (Ho(C)) {
          Rd(u, h, C, F);
          return;
        } else {
          hu(u, h, C, F);
          return;
        }
      if (typeof C == "string") {
        Ta(u, h, C, F);
        return;
      }
      switch (C) {
        case po:
        case Cl:
        case $s:
        case kl:
        case fr: {
          hr(u, h, F.children);
          return;
        }
        case la: {
          Zr(h, "SuspenseList"), hr(u, h, F.children), Sr(h);
          return;
        }
        case Tl:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case oa: {
          Ql(u, h, F);
          return;
        }
      }
      if (typeof C == "object" && C !== null)
        switch (C.$$typeof) {
          case ho: {
            Nd(u, h, C, F, q);
            return;
          }
          case sa: {
            Pd(u, h, C, F, q);
            return;
          }
          case co: {
            Dd(u, h, C, F);
            return;
          }
          case fo: {
            mu(u, h, C, F);
            return;
          }
          case Oi: {
            _d(u, h, C, F);
            return;
          }
        }
      var fe = "";
      throw (C === void 0 || typeof C == "object" && C !== null && Object.keys(C).length === 0) && (fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (C == null ? C : typeof C) + "." + fe));
    }
    function Od(u, h) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      u[Symbol.toStringTag] === "Generator" && (ts || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), ts = !0), u.entries === h && (ns || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), ns = !0);
    }
    function hr(u, h, C) {
      try {
        return os(u, h, C);
      } catch (F) {
        throw typeof F == "object" && F !== null && typeof F.then == "function" || (Hi = Hi !== null ? Hi : ka()), F;
      }
    }
    function os(u, h, C) {
      if (h.node = C, typeof C == "object" && C !== null) {
        switch (C.$$typeof) {
          case td: {
            var F = C, q = F.type, fe = F.props, ge = F.ref;
            as(u, h, q, fe, ge);
            return;
          }
          case Is:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Oi: {
            var Ne = C, l = Ne._payload, f = Ne._init, k;
            try {
              k = f(l);
            } catch (ft) {
              throw typeof ft == "object" && ft !== null && typeof ft.then == "function" && Zr(h, "Lazy"), ft;
            }
            hr(u, h, k);
            return;
          }
        }
        if (On(C)) {
          yu(u, h, C);
          return;
        }
        var P = id(C);
        if (P) {
          Od(C, P);
          var V = P.call(C);
          if (V) {
            var le = V.next();
            if (!le.done) {
              var me = [];
              do
                me.push(le.value), le = V.next();
              while (!le.done);
              yu(u, h, me);
              return;
            }
            return;
          }
        }
        var Re = Object.prototype.toString.call(C);
        throw new Error("Objects are not valid as a React child (found: " + (Re === "[object Object]" ? "object with keys {" + Object.keys(C).join(", ") + "}" : Re) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof C == "string") {
        var He = h.blockedSegment;
        He.lastPushedText = Xn(h.blockedSegment.chunks, C, u.responseState, He.lastPushedText);
        return;
      }
      if (typeof C == "number") {
        var ot = h.blockedSegment;
        ot.lastPushedText = Xn(h.blockedSegment.chunks, "" + C, u.responseState, ot.lastPushedText);
        return;
      }
      typeof C == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function yu(u, h, C) {
      for (var F = C.length, q = 0; q < F; q++) {
        var fe = h.treeContext;
        h.treeContext = Ro(fe, F, q);
        try {
          ls(u, h, C[q]);
        } finally {
          h.treeContext = fe;
        }
      }
    }
    function pr(u, h, C) {
      var F = h.blockedSegment, q = F.chunks.length, fe = $o(
        u,
        q,
        null,
        F.formatContext,
        // Adopt the parent segment's leading text embed
        F.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      F.children.push(fe), F.lastPushedText = !1;
      var ge = Xl(u, h.node, h.blockedBoundary, fe, h.abortSet, h.legacyContext, h.context, h.treeContext);
      h.componentStack !== null && (ge.componentStack = h.componentStack.parent);
      var Ne = ge.ping;
      C.then(Ne, Ne);
    }
    function ls(u, h, C) {
      var F = h.blockedSegment.formatContext, q = h.legacyContext, fe = h.context, ge = null;
      ge = h.componentStack;
      try {
        return hr(u, h, C);
      } catch (Ne) {
        if (Ul(), typeof Ne == "object" && Ne !== null && typeof Ne.then == "function") {
          pr(u, h, Ne), h.blockedSegment.formatContext = F, h.legacyContext = q, h.context = fe, ma(fe), h.componentStack = ge;
          return;
        } else
          throw h.blockedSegment.formatContext = F, h.legacyContext = q, h.context = fe, ma(fe), h.componentStack = ge, Ne;
      }
    }
    function gu(u, h, C, F) {
      var q = wr(u, F);
      if (h === null ? Qr(u, F) : (h.pendingTasks--, h.forceClientRender || (h.forceClientRender = !0, h.errorDigest = q, Zl(h, F), h.parentFlushed && u.clientRenderedBoundaries.push(h))), u.allPendingTasks--, u.allPendingTasks === 0) {
        var fe = u.onAllReady;
        fe();
      }
    }
    function Md(u) {
      var h = this, C = u.blockedBoundary, F = u.blockedSegment;
      F.status = Io, vu(h, C, F);
    }
    function Vo(u, h, C) {
      var F = u.blockedBoundary, q = u.blockedSegment;
      if (q.status = Io, F === null)
        h.allPendingTasks--, h.status !== vi && (h.status = vi, h.destination !== null && y(h.destination));
      else {
        if (F.pendingTasks--, !F.forceClientRender) {
          F.forceClientRender = !0;
          var fe = C === void 0 ? new Error("The render was aborted by the server without a reason.") : C;
          F.errorDigest = h.onError(fe);
          {
            var ge = "The server did not finish this Suspense boundary: ";
            fe && typeof fe.message == "string" ? fe = ge + fe.message : fe = ge + String(fe);
            var Ne = $r;
            $r = u;
            try {
              Zl(F, fe);
            } finally {
              $r = Ne;
            }
          }
          F.parentFlushed && h.clientRenderedBoundaries.push(F);
        }
        if (F.fallbackAbortableTasks.forEach(function(f) {
          return Vo(f, h, C);
        }), F.fallbackAbortableTasks.clear(), h.allPendingTasks--, h.allPendingTasks === 0) {
          var l = h.onAllReady;
          l();
        }
      }
    }
    function Wo(u, h) {
      if (h.chunks.length === 0 && h.children.length === 1 && h.children[0].boundary === null) {
        var C = h.children[0];
        C.id = h.id, C.parentFlushed = !0, C.status === qr && Wo(u, C);
      } else {
        var F = u.completedSegments;
        F.push(h);
      }
    }
    function vu(u, h, C) {
      if (h === null) {
        if (C.parentFlushed) {
          if (u.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          u.completedRootSegment = C;
        }
        if (u.pendingRootTasks--, u.pendingRootTasks === 0) {
          u.onShellError = Nr;
          var F = u.onShellReady;
          F();
        }
      } else if (h.pendingTasks--, !h.forceClientRender) {
        if (h.pendingTasks === 0)
          C.parentFlushed && C.status === qr && Wo(h, C), h.parentFlushed && u.completedBoundaries.push(h), h.fallbackAbortableTasks.forEach(Md, u), h.fallbackAbortableTasks.clear();
        else if (C.parentFlushed && C.status === qr) {
          Wo(h, C);
          var q = h.completedSegments;
          q.length === 1 && h.parentFlushed && u.partialBoundaries.push(h);
        }
      }
      if (u.allPendingTasks--, u.allPendingTasks === 0) {
        var fe = u.onAllReady;
        fe();
      }
    }
    function xu(u, h) {
      var C = h.blockedSegment;
      if (C.status === Yl) {
        ma(h.context);
        var F = null;
        F = $r, $r = h;
        try {
          hr(u, h, h.node), qn(C.chunks, u.responseState, C.lastPushedText, C.textEmbedded), h.abortSet.delete(h), C.status = qr, vu(u, h.blockedBoundary, C);
        } catch (fe) {
          if (Ul(), typeof fe == "object" && fe !== null && typeof fe.then == "function") {
            var q = h.ping;
            fe.then(q, q);
          } else
            h.abortSet.delete(h), C.status = gi, gu(u, h.blockedBoundary, C, fe);
        } finally {
          $r = F;
        }
      }
    }
    function La(u) {
      if (u.status !== vi) {
        var h = bo(), C = Sa.current;
        Sa.current = ou;
        var F;
        F = zo.getCurrentStack, zo.getCurrentStack = ka;
        var q = Kl;
        ba(u.responseState);
        try {
          var fe = u.pingedTasks, ge;
          for (ge = 0; ge < fe.length; ge++) {
            var Ne = fe[ge];
            xu(u, Ne);
          }
          fe.splice(0, ge), u.destination !== null && Uo(u, u.destination);
        } catch (l) {
          wr(u, l), Qr(u, l);
        } finally {
          ba(q), Sa.current = C, zo.getCurrentStack = F, C === ou && ma(h);
        }
      }
    }
    function Ea(u, h, C) {
      switch (C.parentFlushed = !0, C.status) {
        case Yl: {
          var F = C.id = u.nextSegmentId++;
          return C.lastPushedText = !1, C.textEmbedded = !1, Ci(h, u.responseState, F);
        }
        case qr: {
          C.status = Bo;
          for (var q = !0, fe = C.chunks, ge = 0, Ne = C.children, l = 0; l < Ne.length; l++) {
            for (var f = Ne[l]; ge < f.index; ge++)
              g(h, fe[ge]);
            q = jo(u, h, f);
          }
          for (; ge < fe.length - 1; ge++)
            g(h, fe[ge]);
          return ge < fe.length && (q = x(h, fe[ge])), q;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function jo(u, h, C) {
      var F = C.boundary;
      if (F === null)
        return Ea(u, h, C);
      if (F.parentFlushed = !0, F.forceClientRender)
        return Yn(h, u.responseState, F.errorDigest, F.errorMessage, F.errorComponentStack), Ea(u, h, C), vl(h, u.responseState);
      if (F.pendingTasks > 0) {
        F.rootSegmentID = u.nextSegmentId++, F.completedSegments.length > 0 && u.partialBoundaries.push(F);
        var q = F.id = gr(u.responseState);
        return Ei(h, u.responseState, q), Ea(u, h, C), Ri(h, u.responseState);
      } else {
        if (F.byteSize > u.progressiveChunkSize)
          return F.rootSegmentID = u.nextSegmentId++, u.completedBoundaries.push(F), Ei(h, u.responseState, F.id), Ea(u, h, C), Ri(h, u.responseState);
        eo(h, u.responseState);
        var fe = F.completedSegments;
        if (fe.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var ge = fe[0];
        return jo(u, h, ge), to(h, u.responseState);
      }
    }
    function bu(u, h, C) {
      return zs(h, u.responseState, C.id, C.errorDigest, C.errorMessage, C.errorComponentStack);
    }
    function Ra(u, h, C) {
      return At(h, u.responseState, C.formatContext, C.id), jo(u, h, C), nn(h, C.formatContext);
    }
    function Na(u, h, C) {
      for (var F = C.completedSegments, q = 0; q < F.length; q++) {
        var fe = F[q];
        ss(u, h, C, fe);
      }
      return F.length = 0, xl(h, u.responseState, C.id, C.rootSegmentID);
    }
    function Fd(u, h, C) {
      for (var F = C.completedSegments, q = 0; q < F.length; q++) {
        var fe = F[q];
        if (!ss(u, h, C, fe))
          return q++, F.splice(0, q), !1;
      }
      return F.splice(0, q), !0;
    }
    function ss(u, h, C, F) {
      if (F.status === Bo)
        return !0;
      var q = F.id;
      if (q === -1) {
        var fe = F.id = C.rootSegmentID;
        if (fe === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Ra(u, h, F);
      } else
        return Ra(u, h, F), Yc(h, u.responseState, q);
    }
    function Uo(u, h) {
      m();
      try {
        var C = u.completedRootSegment;
        C !== null && u.pendingRootTasks === 0 && (jo(u, h, C), u.completedRootSegment = null, ml(h, u.responseState));
        var F = u.clientRenderedBoundaries, q;
        for (q = 0; q < F.length; q++) {
          var fe = F[q];
          bu(u, h, fe);
        }
        F.splice(0, q);
        var ge = u.completedBoundaries;
        for (q = 0; q < ge.length; q++) {
          var Ne = ge[q];
          Na(u, h, Ne);
        }
        ge.splice(0, q), T(h), m(h);
        var l = u.partialBoundaries;
        for (q = 0; q < l.length; q++) {
          var f = l[q];
          if (!Fd(u, h, f)) {
            u.destination = null, q++, l.splice(0, q);
            return;
          }
        }
        l.splice(0, q);
        var k = u.completedBoundaries;
        for (q = 0; q < k.length; q++) {
          var P = k[q];
          Na(u, h, P);
        }
        k.splice(0, q);
      } finally {
        T(h), u.allPendingTasks === 0 && u.pingedTasks.length === 0 && u.clientRenderedBoundaries.length === 0 && u.completedBoundaries.length === 0 && (u.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), y(h));
      }
    }
    function zd(u) {
      d(function() {
        return La(u);
      });
    }
    function Su(u, h) {
      if (u.status === Gl) {
        u.status = vi, E(h, u.fatalError);
        return;
      }
      if (u.status !== vi && u.destination === null) {
        u.destination = h;
        try {
          Uo(u, h);
        } catch (C) {
          wr(u, C), Qr(u, C);
        }
      }
    }
    function Ko(u, h) {
      try {
        var C = u.abortableTasks;
        C.forEach(function(F) {
          return Vo(F, u, h);
        }), C.clear(), u.destination !== null && Uo(u, u.destination);
      } catch (F) {
        wr(u, F), Qr(u, F);
      }
    }
    function Bd(u, h) {
      return new Promise(function(C, F) {
        var q, fe, ge = new Promise(function(V, le) {
          fe = V, q = le;
        });
        function Ne() {
          var V = new ReadableStream(
            {
              type: "bytes",
              pull: function(le) {
                Su(f, le);
              },
              cancel: function(le) {
                Ko(f);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          V.allReady = ge, C(V);
        }
        function l(V) {
          ge.catch(function() {
          }), F(V);
        }
        var f = Ld(u, fn(h ? h.identifierPrefix : void 0, h ? h.nonce : void 0, h ? h.bootstrapScriptContent : void 0, h ? h.bootstrapScripts : void 0, h ? h.bootstrapModules : void 0), $n(h ? h.namespaceURI : void 0), h ? h.progressiveChunkSize : void 0, h ? h.onError : void 0, fe, Ne, l, q);
        if (h && h.signal) {
          var k = h.signal, P = function() {
            Ko(f, k.reason), k.removeEventListener("abort", P);
          };
          k.addEventListener("abort", P);
        }
        zd(f);
      });
    }
    Iu.renderToReadableStream = Bd, Iu.version = t;
  }()), Iu;
}
var Ka, Wf;
process.env.NODE_ENV === "production" ? (Ka = bw(), Wf = Sw()) : (Ka = ww(), Wf = kw());
Qi.version = Ka.version;
Qi.renderToString = Ka.renderToString;
Qi.renderToStaticMarkup = Ka.renderToStaticMarkup;
Qi.renderToNodeStream = Ka.renderToNodeStream;
Qi.renderToStaticNodeStream = Ka.renderToStaticNodeStream;
Qi.renderToReadableStream = Wf.renderToReadableStream;
const om = ({ columnData: e }) => /* @__PURE__ */ a("ul", { children: e == null ? void 0 : e.map((t, n) => /* @__PURE__ */ z("li", { children: [
  t.label,
  ": ",
  t.value,
  " (",
  t.additional_info,
  "%)"
] }, n)) }), Tw = (e, t) => {
  var m, g, x, T, y, A;
  const n = `${(((m = e == null ? void 0 : e.tooltips) == null ? void 0 : m.find((b) => b.node === t)) || {}).value}`, r = `${(((g = e == null ? void 0 : e.tooltips) == null ? void 0 : g.find((b) => b.node === t)) || {}).summary}`, i = (((x = e == null ? void 0 : e.tooltips) == null ? void 0 : x.find((b) => b.node === t)) || {}).column1Label, o = (((T = e == null ? void 0 : e.tooltips) == null ? void 0 : T.find((b) => b.node === t)) || {}).column2Label, d = (((y = e == null ? void 0 : e.tooltips) == null ? void 0 : y.find((b) => b.node === t)) || {}).column1, c = (((A = e == null ? void 0 : e.tooltips) == null ? void 0 : A.find((b) => b.node === t)) || {}).column2, s = Qi.renderToString(/* @__PURE__ */ a(om, { columnData: d })), p = Qi.renderToString(/* @__PURE__ */ a(om, { columnData: c }));
  return `<div class="sankey-chart__tooltip">
    <span class="sankey-chart__tooltip--tooltip-header">${t}</span>
    <span class="sankey-chart__tooltip--tooltip-header">${n}</span>
    <div class="divider"></div>
    <span><strong>Summary: </strong>${r}</span>
    <div class="divider"></div>
    <div class="sankey-chart__tooltip--info-section">
      <div>
        <span><strong>${i}</strong></span>
        ${s}
      </div>
      <div>
        <span><strong>${o}</strong></span>
        ${p}
      </div>
    </div>
  </div>
`;
}, Cw = ({ width: e, height: t, runtime: n }) => {
  var Y, ie;
  const { config: r } = de.useContext(vt), { sankey: i } = r, [o, d] = de.useState(0), [c, s] = de.useState(""), { showAlert: p, alert: m } = xw(), g = de.useRef([]), x = (I) => {
    const U = c;
    U && s(""), U !== I && s(I);
  };
  if (de.useEffect(() => {
    var U;
    let I = 0;
    (U = g == null ? void 0 : g.current) == null || U.map((ue) => {
      const te = ue == null ? void 0 : ue.getBoundingClientRect().width;
      te > I && (I = te);
    }), d(I);
  }, [g, i, window.innerWidth]), r.visualizationType !== "Sankey")
    return;
  const T = r == null ? void 0 : r.data[0], y = Array.from(new Set((Y = T == null ? void 0 : T.links) == null ? void 0 : Y.flatMap((I) => [I.source, I.target]))), A = {
    nodes: y.map((I) => ({ id: I })),
    links: (ie = T == null ? void 0 : T.links) == null ? void 0 : ie.map((I) => ({
      source: y.findIndex((U) => U === I.source),
      target: y.findIndex((U) => U === I.target),
      value: I.value
    }))
  };
  let b = 5;
  const v = 50, E = mw().nodeWidth(i.nodeSize.nodeWidth).nodePadding(i.nodePadding).iterations(i.iterations).nodeAlign(cw).extent([
    [i.margin.margin_x, Number(i.margin.margin_y)],
    [e - b - o, r.heights.vertical - v]
  ]), { links: N } = E(A), R = (I) => {
    var Q;
    let U = 30, ue = 0, te = "node-value--storynode", J = !0;
    return (Q = T == null ? void 0 : T.storyNodeText) != null && Q.every((G) => G.StoryNode !== I) && (J = !1, ue = 10, U = 8, te = "node-value"), { textPositionHorizontal: U, textPositionVertical: ue, classStyle: te, storyNodes: J };
  }, L = (I) => {
    if (!(A != null && A.nodes))
      return { sourceNodes: [], activeLinks: [] };
    const U = A.nodes.find((J) => J.id === I), ue = [], te = [];
    return U && (N.forEach((J) => {
      const Q = J.target, G = J.source;
      Q.id === I && ue.push(G.id);
    }), ue.forEach((J) => {
      N.forEach((Q) => {
        const G = Q.target, ne = Q.source;
        G.id === c && ne.id === J && te.push(Q);
      });
    })), { sourceNodes: ue, activeLinks: te };
  }, B = Tw(T, c), j = A.nodes.map((I, U) => {
    var Se, xe;
    let { textPositionHorizontal: ue, textPositionVertical: te, classStyle: J, storyNodes: Q } = R(I.id), { sourceNodes: G } = L(c), ne = i.opacity.nodeOpacityDefault, H = i.nodeColor.default;
    c !== I.id && c !== "" && !G.includes(I.id) && (H = i.nodeColor.inactive, ne = i.opacity.nodeOpacityInactive);
    const ce = E.nodeWidth(), ke = () => Math.sqrt(
      Math.pow(N[0].target.x0 - N[0].source.x1, 2) + Math.pow(N[0].target.y0 - N[0].source.y1, 2)
    ) - o;
    return /* @__PURE__ */ z(it, { className: "", children: [
      /* @__PURE__ */ a(
        "rect",
        {
          height: I.y1 - I.y0 + 2,
          width: ce,
          x: I.x0,
          y: I.y0 - 1,
          fill: H,
          fillOpacity: ne,
          rx: i.rxValue,
          "data-tooltip-html": T.tooltips && r.enableTooltips && c !== "" ? B : null,
          "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
          onClick: () => x(I.id),
          style: { pointerEvents: "visible", cursor: "pointer" }
        }
      ),
      Q ? /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ a(
          gt,
          {
            width: ke(),
            x: I.x0 + ue,
            textAnchor: A.nodes.length - 1 === U ? "end" : "start",
            verticalAnchor: "end",
            y: (I.y1 + I.y0) / 2 - 30,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            className: "node-text",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => x(I.id),
            "data-tooltip-html": T.tooltips && r.enableTooltips && c !== "" ? B : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: (((Se = T == null ? void 0 : T.storyNodeText) == null ? void 0 : Se.find((De) => De.StoryNode === I.id)) || {}).segmentTextBefore
          }
        ),
        /* @__PURE__ */ a(
          gt,
          {
            width: ke(),
            verticalAnchor: "middle",
            className: J,
            x: I.x0 + ue,
            y: (I.y1 + I.y0 + 25) / 2,
            fill: i.storyNodeFontColor || i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => x(I.id),
            "data-tooltip-html": T.tooltips && r.enableTooltips && c !== "" ? B : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: typeof I.value == "number" ? I.value.toLocaleString() : I.value
          }
        ),
        /* @__PURE__ */ a(
          gt,
          {
            width: ke(),
            x: I.x0 + ue,
            y: (I.y1 + I.y0) / 2 + 50,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: A.nodes.length === U ? "end" : "start",
            className: "node-text",
            verticalAnchor: "start",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => x(I.id),
            "data-tooltip-html": T.tooltips && r.enableTooltips && c !== "" ? B : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: (((xe = T == null ? void 0 : T.storyNodeText) == null ? void 0 : xe.find((De) => De.StoryNode === I.id)) || {}).segmentTextAfter
          }
        )
      ] }) : /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ a(
          gt,
          {
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => x(I.id),
            "data-tooltip-html": T.tooltips && r.enableTooltips && c !== "" ? B : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            x: I.x0 + ue,
            y: (I.y1 + I.y0) / 2 + te,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            children: I.id
          }
        ),
        /* @__PURE__ */ a(
          "text",
          {
            x: I.x0 + ue,
            y: (I.y1 + I.y0) / 2 + 30,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => x(I.id),
            "data-tooltip-html": T.tooltips && r.enableTooltips && c !== "" ? B : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: /* @__PURE__ */ a("tspan", { className: J, children: i.nodeValueStyle.textBefore + (typeof I.value == "number" ? I.value.toLocaleString() : I.value) + i.nodeValueStyle.textAfter })
          }
        )
      ] })
    ] }, U);
  }), Z = N.map((I, U) => {
    const te = vw()(I);
    let J = i.opacity.LinkOpacityDefault, Q = i.linkColor.default, { activeLinks: G } = L(c);
    return !G.includes(I) && c !== "" && (Q = i.linkColor.inactive, J = i.opacity.LinkOpacityInactive), /* @__PURE__ */ a(
      "path",
      {
        d: te,
        stroke: Q,
        fill: "none",
        strokeOpacity: J,
        strokeWidth: I.width + 2,
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(I.target.id || null),
        "data-tooltip-html": T.tooltips && r.enableTooltips && c !== "" ? B : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      U
    );
  }), re = A.nodes.reduce((I, U) => Math.max(I, U.depth), -1), se = A.nodes.filter((I) => I.depth === re).map((I, U) => {
    var ce, ke;
    let { textPositionHorizontal: ue, textPositionVertical: te, classStyle: J, storyNodes: Q } = R(I.id), { sourceNodes: G } = L(c), ne = i.opacity.nodeOpacityDefault, H = i.nodeColor.default;
    return c !== I.id && c !== "" && !G.includes(I.id) && (H = i.nodeColor.inactive, ne = i.opacity.nodeOpacityInactive), /* @__PURE__ */ z(it, { className: "", innerRef: (Se) => g.current[U] = Se, children: [
      /* @__PURE__ */ a(
        "rect",
        {
          height: I.y1 - I.y0 + 2,
          width: E.nodeWidth(),
          x: I.x0,
          y: I.y0 - 1,
          fill: H,
          fillOpacity: ne,
          rx: i.rxValue,
          "data-tooltip-html": T.tooltips && r.enableTooltips && c !== "" ? B : null,
          "data-tooltip-id": "tooltip",
          onClick: () => x(I.id),
          style: { pointerEvents: "visible", cursor: "pointer" }
        }
      ),
      Q ? /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ a(
          gt,
          {
            x: I.x0 + ue,
            textAnchor: A.nodes.length - 1 === U ? "end" : "start",
            verticalAnchor: "end",
            y: (I.y1 + I.y0) / 2 - 30,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            style: { pointerEvents: "none" },
            className: "node-text",
            children: (((ce = T == null ? void 0 : T.storyNodeText) == null ? void 0 : ce.find((Se) => Se.StoryNode === I.id)) || {}).segmentTextBefore
          }
        ),
        /* @__PURE__ */ a(
          gt,
          {
            verticalAnchor: "end",
            className: J,
            x: I.x0 + ue,
            y: (I.y1 + I.y0 + 25) / 2,
            fill: i.storyNodeFontColor || i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "none" },
            children: typeof I.value == "number" ? I.value.toLocaleString() : I.value
          }
        ),
        /* @__PURE__ */ a(
          gt,
          {
            x: I.x0 + ue,
            y: (I.y1 + I.y0) / 2 + 50,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: A.nodes.length === U ? "end" : "start",
            style: { pointerEvents: "none" },
            className: "node-text",
            verticalAnchor: "end",
            children: (((ke = T == null ? void 0 : T.storyNodeText) == null ? void 0 : ke.find((Se) => Se.StoryNode === I.id)) || {}).segmentTextAfter
          }
        )
      ] }) : /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ a(
          "text",
          {
            x: I.x0 + ue,
            y: (I.y1 + I.y0) / 2 + te,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "none" },
            children: /* @__PURE__ */ a("tspan", { id: I.id, className: "node-id", children: I.id })
          }
        ),
        /* @__PURE__ */ a(
          "text",
          {
            x: I.x0 + ue,
            y: (I.y1 + I.y0) / 2 + 30,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "none" },
            children: /* @__PURE__ */ a("tspan", { onClick: () => x(I.id), className: J, children: i.nodeValueStyle.textBefore + (typeof I.value == "number" ? I.value.toLocaleString() : I.value) + i.nodeValueStyle.textAfter })
          }
        )
      ] })
    ] }, U);
  });
  return p ? m : /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z("div", { className: "sankey-chart", children: [
    /* @__PURE__ */ z(
      "svg",
      {
        className: "sankey-chart__diagram",
        width: e,
        height: Number(r.heights.vertical),
        style: { overflow: "visible" },
        children: [
          /* @__PURE__ */ a(it, { className: "links", children: Z }),
          /* @__PURE__ */ a(it, { className: "nodes", children: j }),
          /* @__PURE__ */ a(it, { className: "finalNodes", style: { display: "none" }, children: se })
        ]
      }
    ),
    /* @__PURE__ */ a(
      xc,
      {
        id: `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
        afterHide: () => s(""),
        events: ["click"],
        place: "bottom",
        style: {
          backgroundColor: "rgba(238, 238, 238, 1)",
          color: "black",
          boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)"
        }
      }
    )
  ] }) });
};
var Aw = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const mr = Aw;
function Lw(e) {
  var t = e.labelOffset, n = e.labelProps, r = e.orientation, i = e.range, o = e.tickLabelFontSize, d = e.tickLength, c = r === mr.left || r === mr.top ? -1 : 1, s, p, m;
  if (r === mr.top || r === mr.bottom) {
    var g = r === mr.bottom && typeof n.fontSize == "number" ? n.fontSize : 0;
    s = (Number(i[0]) + Number(i[i.length - 1])) / 2, p = c * (d + t + o + g);
  } else
    s = c * ((Number(i[0]) + Number(i[i.length - 1])) / 2), p = -(d + t), m = "rotate(" + c * 90 + ")";
  return {
    x: s,
    y: p,
    transform: m
  };
}
function Ss() {
  return Ss = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ss.apply(this, arguments);
}
function Ew(e) {
  var t = e.hideTicks, n = e.horizontal, r = e.orientation, i = e.tickClassName, o = e.tickComponent, d = e.tickLabelProps, c = e.tickStroke, s = c === void 0 ? "#222" : c, p = e.tickTransform, m = e.ticks, g = e.strokeWidth, x = e.tickLineProps;
  return m.map(function(T) {
    var y, A = T.value, b = T.index, v = T.from, E = T.to, N = T.formattedValue, R = (y = d[b]) != null ? y : {}, L = Math.max(10, typeof R.fontSize == "number" && R.fontSize || 0), B = E.y + (n && r !== mr.top ? L : 0);
    return /* @__PURE__ */ Ve.createElement(it, {
      key: "visx-tick-" + A + "-" + b,
      className: Cn("visx-axis-tick", i),
      transform: p
    }, !t && /* @__PURE__ */ Ve.createElement(rn, Ss({
      from: v,
      to: E,
      stroke: s,
      strokeWidth: g,
      strokeLinecap: "square"
    }, x)), o ? o(Ss({}, R, {
      x: E.x,
      y: B,
      formattedValue: N
    })) : /* @__PURE__ */ Ve.createElement(gt, Ss({
      x: E.x,
      y: B
    }, R), N));
  });
}
function Sc() {
  return Sc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Sc.apply(this, arguments);
}
var lm = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function Rw(e) {
  var t = e.axisFromPoint, n = e.axisLineClassName, r = e.axisToPoint, i = e.hideAxisLine, o = e.hideTicks, d = e.horizontal, c = e.label, s = c === void 0 ? "" : c, p = e.labelClassName, m = e.labelOffset, g = m === void 0 ? 14 : m, x = e.labelProps, T = x === void 0 ? lm : x, y = e.orientation, A = y === void 0 ? mr.bottom : y, b = e.scale, v = e.stroke, E = v === void 0 ? "#222" : v, N = e.strokeDasharray, R = e.strokeWidth, L = R === void 0 ? 1 : R, B = e.tickClassName, j = e.tickComponent, Z = e.tickLineProps, re = e.tickLabelProps, X = e.tickLength, se = X === void 0 ? 8 : X, Y = e.tickStroke, ie = Y === void 0 ? "#222" : Y, I = e.tickTransform, U = e.ticks, ue = e.ticksComponent, te = ue === void 0 ? Ew : ue, J = Sc({}, lm, typeof re == "object" ? re : null), Q = U.map(function(ne) {
    var H = ne.value, ce = ne.index;
    return typeof re == "function" ? re(H, ce, U) : J;
  }), G = Math.max.apply(Math, [10].concat(Q.map(function(ne) {
    return typeof ne.fontSize == "number" ? ne.fontSize : 0;
  })));
  return /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, te({
    hideTicks: o,
    horizontal: d,
    orientation: A,
    scale: b,
    tickClassName: B,
    tickComponent: j,
    tickLabelProps: Q,
    tickStroke: ie,
    tickTransform: I,
    ticks: U,
    strokeWidth: L,
    tickLineProps: Z
  }), !i && /* @__PURE__ */ Ve.createElement(rn, {
    className: Cn("visx-axis-line", n),
    from: t,
    to: r,
    stroke: E,
    strokeWidth: L,
    strokeDasharray: N
  }), s && /* @__PURE__ */ Ve.createElement(gt, Sc({
    className: Cn("visx-axis-label", p)
  }, Lw({
    labelOffset: g,
    labelProps: T,
    orientation: A,
    range: b.range(),
    tickLabelFontSize: G,
    tickLength: se
  }), T), s));
}
function Nw(e, t) {
  t === void 0 && (t = "center");
  var n = e;
  if (t !== "start" && "bandwidth" in n) {
    var r = n.bandwidth();
    return t === "center" && (r /= 2), n.round() && (r = Math.round(r)), function(i) {
      var o = n(i);
      return typeof o == "number" ? o + r : o;
    };
  }
  return e;
}
function Pw(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : YS;
}
function $u(e, t) {
  var n = e.x, r = e.y;
  return new Eg(t ? {
    x: n,
    y: r
  } : {
    x: r,
    y: n
  });
}
function jf() {
  return jf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, jf.apply(this, arguments);
}
var af = 0;
function Dw(e) {
  return e === void 0 && (e = af), typeof e == "number" ? {
    start: e,
    end: e
  } : jf({
    start: af,
    end: af
  }, e);
}
var _w = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Uf() {
  return Uf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Uf.apply(this, arguments);
}
function Ow(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Vc(e) {
  var t = e.children, n = t === void 0 ? Rw : t, r = e.axisClassName, i = e.hideAxisLine, o = i === void 0 ? !1 : i, d = e.hideTicks, c = d === void 0 ? !1 : d, s = e.hideZero, p = s === void 0 ? !1 : s, m = e.innerRef, g = e.left, x = g === void 0 ? 0 : g, T = e.numTicks, y = T === void 0 ? 10 : T, A = e.orientation, b = A === void 0 ? mr.bottom : A, v = e.rangePadding, E = v === void 0 ? 0 : v, N = e.scale, R = e.tickFormat, L = e.tickLength, B = L === void 0 ? 8 : L, j = e.tickValues, Z = e.top, re = Z === void 0 ? 0 : Z, X = Ow(e, _w), se = R ?? Pw(N), Y = b === mr.left, ie = b === mr.top, I = ie || b === mr.bottom, U = Nw(N), ue = Y || ie ? -1 : 1, te = N.range(), J = Dw(E), Q = $u({
    x: Number(te[0]) + 0.5 - J.start,
    y: 0
  }, I), G = $u({
    x: Number(te[te.length - 1]) + 0.5 + J.end,
    y: 0
  }, I), ne = (j ?? qy(N, y)).filter(function(ce) {
    return !p || ce !== 0 && ce !== "0";
  }).map(function(ce, ke) {
    return {
      value: ce,
      index: ke
    };
  }), H = ne.map(function(ce) {
    var ke = ce.value, Se = ce.index, xe = KS(U(ke));
    return {
      value: ke,
      index: Se,
      from: $u({
        x: xe,
        y: 0
      }, I),
      to: $u({
        x: xe,
        y: B * ue
      }, I),
      formattedValue: se(ke, Se, ne)
    };
  });
  return /* @__PURE__ */ Ve.createElement(it, {
    className: Cn("visx-axis", r),
    innerRef: m,
    top: re,
    left: x
  }, n(Uf({}, X, {
    axisFromPoint: Q,
    axisToPoint: G,
    hideAxisLine: o,
    hideTicks: c,
    hideZero: p,
    horizontal: I,
    numTicks: y,
    orientation: b,
    rangePadding: E,
    scale: N,
    tickFormat: se,
    tickLength: B,
    tickPosition: U,
    tickSign: ue,
    ticks: H
  })));
}
var Mw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function wc() {
  return wc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, wc.apply(this, arguments);
}
function Fw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var zw = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function sm(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 36 : n, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = Fw(e, Mw), s = typeof d == "function" ? d : wc({}, zw, d);
  return /* @__PURE__ */ Ve.createElement(Vc, wc({
    axisClassName: Cn("visx-axis-left", t),
    labelOffset: r,
    orientation: mr.left,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var Bw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function kc() {
  return kc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, kc.apply(this, arguments);
}
function Iw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var $w = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function Hw(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 36 : n, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = Iw(e, Bw), s = typeof d == "function" ? d : kc({}, $w, d);
  return /* @__PURE__ */ Ve.createElement(Vc, kc({
    axisClassName: Cn("visx-axis-right", t),
    labelOffset: r,
    orientation: mr.right,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var Vw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Tc() {
  return Tc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Tc.apply(this, arguments);
}
function Ww(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var jw = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function Uw(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 8 : n, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = Ww(e, Vw), s = typeof d == "function" ? d : Tc({}, jw, d);
  return /* @__PURE__ */ Ve.createElement(Vc, Tc({
    axisClassName: Cn("visx-axis-top", t),
    labelOffset: r,
    orientation: mr.top,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var Kw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Cc() {
  return Cc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Cc.apply(this, arguments);
}
function Yw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var Gw = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function Yu(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 8 : n, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = Yw(e, Kw), s = typeof d == "function" ? d : Cc({}, Gw, d);
  return /* @__PURE__ */ Ve.createElement(Vc, Cc({
    axisClassName: Cn("visx-axis-bottom", t),
    labelOffset: r,
    orientation: mr.bottom,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
const of = (e) => () => e;
function Xw(e, {
  sourceEvent: t,
  target: n,
  selection: r,
  mode: i,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    selection: { value: r, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function qw(e) {
  e.stopImmediatePropagation();
}
function lf(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var um = { name: "drag" }, sf = { name: "space" }, Jo = { name: "handle" }, el = { name: "center" };
const { abs: cm, max: er, min: tr } = Math;
function dm(e) {
  return [+e[0], +e[1]];
}
function fm(e) {
  return [dm(e[0]), dm(e[1])];
}
var Gu = {
  name: "x",
  handles: ["w", "e"].map(Ac),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, uf = {
  name: "y",
  handles: ["n", "s"].map(Ac),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, xi = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, hm = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, pm = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, Zw = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, Qw = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Ac(e) {
  return { type: e };
}
function Jw(e) {
  return !e.ctrlKey && !e.button;
}
function ek() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function tk() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function cf(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function nk(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function rk() {
  return ik(Gu);
}
function ik(e) {
  var t = ek, n = Jw, r = tk, i = !0, o = Rg("start", "brush", "end"), d = 6, c;
  function s(b) {
    var v = b.property("__brush", A).selectAll(".overlay").data([Ac("overlay")]);
    v.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", xi.overlay).merge(v).each(function() {
      var N = cf(this).extent;
      nl(this).attr("x", N[0][0]).attr("y", N[0][1]).attr("width", N[1][0] - N[0][0]).attr("height", N[1][1] - N[0][1]);
    }), b.selectAll(".selection").data([Ac("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", xi.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var E = b.selectAll(".handle").data(e.handles, function(N) {
      return N.type;
    });
    E.exit().remove(), E.enter().append("rect").attr("class", function(N) {
      return "handle handle--" + N.type;
    }).attr("cursor", function(N) {
      return xi[N.type];
    }), b.each(p).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", x).filter(r).on("touchstart.brush", x).on("touchmove.brush", T).on("touchend.brush touchcancel.brush", y).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  s.move = function(b, v, E) {
    b.tween ? b.on("start.brush", function(N) {
      m(this, arguments).beforestart().start(N);
    }).on("interrupt.brush end.brush", function(N) {
      m(this, arguments).end(N);
    }).tween("brush", function() {
      var N = this, R = N.__brush, L = m(N, arguments), B = R.selection, j = e.input(typeof v == "function" ? v.apply(this, arguments) : v, R.extent), Z = cv(B, j);
      function re(X) {
        R.selection = X === 1 && j === null ? null : Z(X), p.call(N), L.brush();
      }
      return B !== null && j !== null ? re : re(1);
    }) : b.each(function() {
      var N = this, R = arguments, L = N.__brush, B = e.input(typeof v == "function" ? v.apply(N, R) : v, L.extent), j = m(N, R).beforestart();
      Fh(N), L.selection = B === null ? null : B, p.call(N), j.start(E).brush(E).end(E);
    });
  }, s.clear = function(b, v) {
    s.move(b, null, v);
  };
  function p() {
    var b = nl(this), v = cf(this).selection;
    v ? (b.selectAll(".selection").style("display", null).attr("x", v[0][0]).attr("y", v[0][1]).attr("width", v[1][0] - v[0][0]).attr("height", v[1][1] - v[0][1]), b.selectAll(".handle").style("display", null).attr("x", function(E) {
      return E.type[E.type.length - 1] === "e" ? v[1][0] - d / 2 : v[0][0] - d / 2;
    }).attr("y", function(E) {
      return E.type[0] === "s" ? v[1][1] - d / 2 : v[0][1] - d / 2;
    }).attr("width", function(E) {
      return E.type === "n" || E.type === "s" ? v[1][0] - v[0][0] + d : d;
    }).attr("height", function(E) {
      return E.type === "e" || E.type === "w" ? v[1][1] - v[0][1] + d : d;
    })) : b.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function m(b, v, E) {
    var N = b.__brush.emitter;
    return N && (!E || !N.clean) ? N : new g(b, v, E);
  }
  function g(b, v, E) {
    this.that = b, this.args = v, this.state = b.__brush, this.active = 0, this.clean = E;
  }
  g.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(b, v) {
      return this.starting ? (this.starting = !1, this.emit("start", b, v)) : this.emit("brush", b), this;
    },
    brush: function(b, v) {
      return this.emit("brush", b, v), this;
    },
    end: function(b, v) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", b, v)), this;
    },
    emit: function(b, v, E) {
      var N = nl(this.that).datum();
      o.call(
        b,
        this.that,
        new Xw(b, {
          sourceEvent: v,
          target: s,
          selection: e.output(this.state.selection),
          mode: E,
          dispatch: o
        }),
        N
      );
    }
  };
  function x(b) {
    if (c && !b.touches || !n.apply(this, arguments))
      return;
    var v = this, E = b.target.__data__.type, N = (i && b.metaKey ? E = "overlay" : E) === "selection" ? um : i && b.altKey ? el : Jo, R = e === uf ? null : Zw[E], L = e === Gu ? null : Qw[E], B = cf(v), j = B.extent, Z = B.selection, re = j[0][0], X, se, Y = j[0][1], ie, I, U = j[1][0], ue, te, J = j[1][1], Q, G, ne = 0, H = 0, ce, ke = R && L && i && b.shiftKey, Se, xe, De = Array.from(b.touches || [b], (Fe) => {
      const Je = Fe.identifier;
      return Fe = zh(Fe, v), Fe.point0 = Fe.slice(), Fe.identifier = Je, Fe;
    });
    Fh(v);
    var je = m(v, arguments, !0).beforestart();
    if (E === "overlay") {
      Z && (ce = !0);
      const Fe = [De[0], De[1] || De[0]];
      B.selection = Z = [[
        X = e === uf ? re : tr(Fe[0][0], Fe[1][0]),
        ie = e === Gu ? Y : tr(Fe[0][1], Fe[1][1])
      ], [
        ue = e === uf ? U : er(Fe[0][0], Fe[1][0]),
        Q = e === Gu ? J : er(Fe[0][1], Fe[1][1])
      ]], De.length > 1 && Be(b);
    } else
      X = Z[0][0], ie = Z[0][1], ue = Z[1][0], Q = Z[1][1];
    se = X, I = ie, te = ue, G = Q;
    var Ce = nl(v).attr("pointer-events", "none"), ye = Ce.selectAll(".overlay").attr("cursor", xi[E]);
    if (b.touches)
      je.moved = he, je.ended = $e;
    else {
      var Ee = nl(b.view).on("mousemove.brush", he, !0).on("mouseup.brush", $e, !0);
      i && Ee.on("keydown.brush", tt, !0).on("keyup.brush", We, !0), Ng(b.view);
    }
    p.call(v), je.start(b, N.name);
    function he(Fe) {
      for (const Je of Fe.changedTouches || [Fe])
        for (const Ke of De)
          Ke.identifier === Je.identifier && (Ke.cur = zh(Je, v));
      if (ke && !Se && !xe && De.length === 1) {
        const Je = De[0];
        cm(Je.cur[0] - Je[0]) > cm(Je.cur[1] - Je[1]) ? xe = !0 : Se = !0;
      }
      for (const Je of De)
        Je.cur && (Je[0] = Je.cur[0], Je[1] = Je.cur[1]);
      ce = !0, lf(Fe), Be(Fe);
    }
    function Be(Fe) {
      const Je = De[0], Ke = Je.point0;
      var Ye;
      switch (ne = Je[0] - Ke[0], H = Je[1] - Ke[1], N) {
        case sf:
        case um: {
          R && (ne = er(re - X, tr(U - ue, ne)), se = X + ne, te = ue + ne), L && (H = er(Y - ie, tr(J - Q, H)), I = ie + H, G = Q + H);
          break;
        }
        case Jo: {
          De[1] ? (R && (se = er(re, tr(U, De[0][0])), te = er(re, tr(U, De[1][0])), R = 1), L && (I = er(Y, tr(J, De[0][1])), G = er(Y, tr(J, De[1][1])), L = 1)) : (R < 0 ? (ne = er(re - X, tr(U - X, ne)), se = X + ne, te = ue) : R > 0 && (ne = er(re - ue, tr(U - ue, ne)), se = X, te = ue + ne), L < 0 ? (H = er(Y - ie, tr(J - ie, H)), I = ie + H, G = Q) : L > 0 && (H = er(Y - Q, tr(J - Q, H)), I = ie, G = Q + H));
          break;
        }
        case el: {
          R && (se = er(re, tr(U, X - ne * R)), te = er(re, tr(U, ue + ne * R))), L && (I = er(Y, tr(J, ie - H * L)), G = er(Y, tr(J, Q + H * L)));
          break;
        }
      }
      te < se && (R *= -1, Ye = X, X = ue, ue = Ye, Ye = se, se = te, te = Ye, E in hm && ye.attr("cursor", xi[E = hm[E]])), G < I && (L *= -1, Ye = ie, ie = Q, Q = Ye, Ye = I, I = G, G = Ye, E in pm && ye.attr("cursor", xi[E = pm[E]])), B.selection && (Z = B.selection), Se && (se = Z[0][0], te = Z[1][0]), xe && (I = Z[0][1], G = Z[1][1]), (Z[0][0] !== se || Z[0][1] !== I || Z[1][0] !== te || Z[1][1] !== G) && (B.selection = [[se, I], [te, G]], p.call(v), je.brush(Fe, N.name));
    }
    function $e(Fe) {
      if (qw(Fe), Fe.touches) {
        if (Fe.touches.length)
          return;
        c && clearTimeout(c), c = setTimeout(function() {
          c = null;
        }, 500);
      } else
        Pg(Fe.view, ce), Ee.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      Ce.attr("pointer-events", "all"), ye.attr("cursor", xi.overlay), B.selection && (Z = B.selection), nk(Z) && (B.selection = null, p.call(v)), je.end(Fe, N.name);
    }
    function tt(Fe) {
      switch (Fe.keyCode) {
        case 16: {
          ke = R && L;
          break;
        }
        case 18: {
          N === Jo && (R && (ue = te - ne * R, X = se + ne * R), L && (Q = G - H * L, ie = I + H * L), N = el, Be(Fe));
          break;
        }
        case 32: {
          (N === Jo || N === el) && (R < 0 ? ue = te - ne : R > 0 && (X = se - ne), L < 0 ? Q = G - H : L > 0 && (ie = I - H), N = sf, ye.attr("cursor", xi.selection), Be(Fe));
          break;
        }
        default:
          return;
      }
      lf(Fe);
    }
    function We(Fe) {
      switch (Fe.keyCode) {
        case 16: {
          ke && (Se = xe = ke = !1, Be(Fe));
          break;
        }
        case 18: {
          N === el && (R < 0 ? ue = te : R > 0 && (X = se), L < 0 ? Q = G : L > 0 && (ie = I), N = Jo, Be(Fe));
          break;
        }
        case 32: {
          N === sf && (Fe.altKey ? (R && (ue = te - ne * R, X = se + ne * R), L && (Q = G - H * L, ie = I + H * L), N = el) : (R < 0 ? ue = te : R > 0 && (X = se), L < 0 ? Q = G : L > 0 && (ie = I), N = Jo), ye.attr("cursor", xi[E]), Be(Fe));
          break;
        }
        default:
          return;
      }
      lf(Fe);
    }
  }
  function T(b) {
    m(this, arguments).moved(b);
  }
  function y(b) {
    m(this, arguments).ended(b);
  }
  function A() {
    var b = this.__brush || { selection: null };
    return b.extent = fm(t.apply(this, arguments)), b.dim = e, b;
  }
  return s.extent = function(b) {
    return arguments.length ? (t = typeof b == "function" ? b : of(fm(b)), s) : t;
  }, s.filter = function(b) {
    return arguments.length ? (n = typeof b == "function" ? b : of(!!b), s) : n;
  }, s.touchable = function(b) {
    return arguments.length ? (r = typeof b == "function" ? b : of(!!b), s) : r;
  }, s.handleSize = function(b) {
    return arguments.length ? (d = +b, s) : d;
  }, s.keyModifiers = function(b) {
    return arguments.length ? (i = !!b, s) : i;
  }, s.on = function() {
    var b = o.on.apply(o, arguments);
    return b === o ? s : b;
  }, s;
}
const ak = ({ xMax: e, yMax: t }) => {
  var I, U;
  const { tableData: n, config: r, dashboardConfig: i, formatDate: o, parseDate: d } = de.useContext(vt), c = de.useContext(Qf), [s, p] = de.useState({ isBrushing: !1, selection: [] }), [m, g] = de.useState(0), x = ((I = i == null ? void 0 : i.dashboard) == null ? void 0 : I.sharedFilters) ?? [], T = (x == null ? void 0 : x.length) > 0, [y, A] = de.useState(!1), b = de.useRef(), v = 25, E = 15, N = Dg(n, (ue) => new Date(ue[r.runtime.originalXAxis.dataKey])), R = Xy().domain(N).range([0, e]), B = yr("Drag edges to focus on a specific segment ", `normal ${16 / 1.1}px sans-serif`), j = 50, Z = 1.5, re = () => (i == null ? void 0 : i.type) === "dashboard" ? Number(t) + r.xAxis.axisBBox + v * Z + j : Number(t) + r.xAxis.axisBBox + v * Z, X = () => {
    s.selection[0] === 0 && e === s.selection[1] && A(!0);
  }, se = () => {
    (s.selection[0] !== 0 || s.selection[1] !== e) && A(!1), A(!1);
  }, Y = (ue, te, J, Q) => {
    const G = yr(J, `normal ${14.545454545454545}px sans-serif`), ne = te[0] < G ? 0 : -G, H = e - te[1] < G ? -G : 0;
    return ue.selectAll(".handle--custom").data([{ side: "left" }, { side: "right" }]).join((ce) => {
      const ke = ce.append("g").attr("class", "handle--custom");
      return ke.append("text").attr("x", (Se) => Se.side === "left" ? ne : H).attr("y", 30).text((Se) => Se.side === "left" ? J : Q).attr("font-size", "13px"), ke;
    }).attr("display", "block").attr("transform", te === null ? null : (ce, ke) => `translate(${te[ke]},10)`);
  }, ie = () => {
    const ue = nl(b.current).attr("overflow", "visible");
    ue.append("rect").attr("fill", "#949494").attr("stroke", "#c5c5c5").attr("stroke-width", 2).attr("ry", E).attr("rx", E).attr("height", v).attr("width", e);
    const te = (ne) => {
      const H = ne == null ? void 0 : ne.selection;
      let ce = ne.type === "brush" && H && H.length > 0;
      const [ke, Se] = H.map((We) => R.invert(We)), xe = nt.filter(n, (We) => {
        const Fe = new Date(We[r.xAxis.dataKey]);
        return Fe && !isNaN(Fe.getTime()) && Fe >= ke && Fe <= Se;
      }), De = r.xAxis.sortByRecentDate, je = nt.sortBy(xe, (We) => new Date(We[r.xAxis.dataKey])), Ce = De ? je.reverse() : je, ye = nt.get(nt.first(Ce), r.xAxis.dataKey, ""), Ee = nt.get(nt.last(Ce), r.xAxis.dataKey, "");
      ue.selectAll(".handle--custom").remove();
      const he = (We) => We ? o(d(We)) : "", Be = he(ye), $e = he(Ee);
      ue.call(Y, H, Be, $e);
      const tt = {
        active: r.brush.active,
        isBrushing: ce,
        data: Ce
      };
      c({ type: "SET_BRUSH_CONFIG", payload: tt }), p({
        isBrushing: !0,
        selection: H
      });
    }, J = rk().extent([
      [0, 0],
      [e, 25]
    ]).on("start brush end", te), Q = [0, e];
    let G = ue.append("g").call(J).call(J.move, Q);
    G.select(".overlay").style("pointer-events", "none"), G.selectAll(".selection").attr("fill", "#474747").attr("fill-opacity", 1).attr("rx", E).attr("ry", E);
  };
  return de.useEffect(() => {
    var J, Q, G;
    const ue = (J = r.filters) == null ? void 0 : J.some((ne) => ne.active), te = (Q = r.exclusions) == null ? void 0 : Q.active;
    return (ue || te || T) && ((G = r.brush) != null && G.active) && g((ne) => ne + 1), c({ type: "SET_BRUSH_CONFIG", payload: { ...r.brush, data: n } }), () => c({ type: "SET_BRUSH_CONFIG", payload: { ...r.brush, data: [] } });
  }, [r.filters, r.exclusions, (U = r.brush) == null ? void 0 : U.active, T]), de.useEffect(() => {
    let ue = null;
    const te = () => {
      e > 0 ? ie() : (clearTimeout(ue), ue = setTimeout(te, 500));
    };
    return te(), () => {
      ue && clearTimeout(ue);
    };
  }, [e]), de.useEffect(() => {
    m && ie();
  }, [m]), s.isBrushing || ie(), /* @__PURE__ */ z(
    it,
    {
      onMouseLeave: se,
      onMouseOver: X,
      className: "brush-container",
      left: Number(r.runtime.yAxis.size),
      top: re(),
      children: [
        /* @__PURE__ */ a(
          gt,
          {
            pointerEvents: "visiblePainted",
            display: y ? "block" : "none",
            fontSize: 16,
            x: (Number(e) - Number(B)) / 2,
            y: -10,
            children: "Drag edges to focus on a specific segment"
          }
        ),
        /* @__PURE__ */ a("svg", { width: "100%", height: v * 3, ref: b })
      ]
    }
  );
}, Ia = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: y0,
  curveBasisClosed: g0,
  curveBasisOpen: v0,
  curveBundle: x0,
  curveCardinal: b0,
  curveCardinalClosed: S0,
  curveCardinalOpen: w0,
  curveCatmullRom: k0,
  curveCatmullRomClosed: T0,
  curveCatmullRomOpen: C0,
  curveLinear: zc,
  curveLinearClosed: Af,
  curveMonotoneX: Ku,
  curveMonotoneY: A0,
  curveNatural: L0,
  curveStep: E0,
  curveStepAfter: N0,
  curveStepBefore: R0
}, Symbol.toStringTag, { value: "Module" })), ok = (e) => {
  var B, j;
  const { xScale: t, yScale: n, yMax: r, xMax: i, handleTooltipMouseOver: o, handleTooltipMouseOff: d, isDebug: c, children: s } = e;
  let { transformedData: p, config: m, handleLineType: g, parseDate: x, formatDate: T, formatNumber: y, seriesHighlight: A, colorScale: b, rawData: v, brushConfig: E } = de.useContext(vt);
  const N = (B = m.brush) != null && B.active && ((j = E.data) != null && j.length) ? E.data : p;
  if (!N)
    return;
  const R = (Z) => (Tn(m.xAxis) ? t(x(Z[m.xAxis.dataKey], !1)) : t(Z[m.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), L = (Z, re, X = void 0) => n(Z[X.dataKey]);
  return N && /* @__PURE__ */ a("svg", { children: /* @__PURE__ */ a(Ur, { component: "AreaChart", children: /* @__PURE__ */ z(it, { className: "area-chart", left: Number(m.yAxis.size), children: [
    (m.runtime.areaSeriesKeys || m.series).map((Z, re) => {
      let X = N.map((I) => ({
        [m.xAxis.dataKey]: I[m.xAxis.dataKey],
        [Z.dataKey]: I[Z.dataKey]
      })), se = Ia[Z.lineType], Y = m.legend.behavior === "highlight" && A.length > 0 && A.indexOf(Z.dataKey) === -1, ie = m.legend.behavior === "highlight" || A.length === 0 || A.indexOf(Z.dataKey) !== -1;
      return /* @__PURE__ */ z(Ve.Fragment, { children: [
        /* @__PURE__ */ a(
          jr,
          {
            data: X,
            x: (I) => R(I),
            y: (I) => L(I, re, Z),
            stroke: ie ? b ? b(m.runtime.seriesLabels ? m.runtime.seriesLabels[Z.dataKey] : Z.dataKey) : "#000" : "transparent",
            strokeWidth: 2,
            strokeOpacity: 1,
            shapeRendering: "geometricPrecision",
            curve: se,
            strokeDasharray: Z.type ? g(Z.type) : 0
          }
        ),
        /* @__PURE__ */ a(
          Df,
          {
            fill: ie ? b ? b(m.runtime.seriesLabels ? m.runtime.seriesLabels[Z.dataKey] : Z.dataKey) : "#000" : "transparent",
            fillOpacity: Y ? 0.25 : 0.5,
            data: X,
            x: (I) => R(I),
            y: (I) => L(I, re, Z),
            yScale: n,
            curve: se,
            strokeDasharray: Z.type ? g(Z.type) : 0
          },
          "area-chart"
        )
      ] }, re);
    }),
    /* @__PURE__ */ a(_r, { width: Number(i), height: Number(r), fill: "transparent", fillOpacity: 0.05, onMouseMove: (Z) => o(Z, v), onMouseLeave: d })
  ] }, "area-wrapper") }) });
}, lk = de.memo(ok), sk = ({ xScale: e, yScale: t, yMax: n, xMax: r, handleTooltipMouseOver: i, handleTooltipMouseOff: o, isDebug: d }) => {
  var A, b;
  let { transformedData: c, config: s, seriesHighlight: p, colorScale: m, rawData: g } = de.useContext(vt);
  const x = (A = s.brush) != null && A.active && ((b = s.brush.data) != null && b.length) ? s.brush.data : c;
  if (!x)
    return;
  const T = (v) => {
    if (s.xAxis.type === "categorical")
      return e(v);
    if (Tn(s.xAxis)) {
      let E = new Date(v);
      return e(E);
    }
  }, y = 2;
  return x && /* @__PURE__ */ a("svg", { height: Number(n), children: /* @__PURE__ */ a(Ur, { component: "AreaChartStacked", children: /* @__PURE__ */ z(
    it,
    {
      className: "area-chart",
      left: Number(s.yAxis.size) + y / 2,
      height: Number(n),
      style: { overflow: "hidden" },
      children: [
        /* @__PURE__ */ a(
          lS,
          {
            data: x,
            keys: s.runtime.areaSeriesKeys.map((v) => v.dataKey) || s.series.map((v) => v.dataKey),
            x0: (v) => T(v.data[s.xAxis.dataKey]),
            y0: (v) => Number(t(v[0])),
            y1: (v) => Number(t(v[1])),
            curve: Ia[ul[s.stackedAreaChartLineType]],
            children: ({ stacks: v, path: E }) => v.map((N, R) => {
              let L = s.legend.behavior === "highlight" && p.length > 0 && p.indexOf(N.key) === -1, B = s.legend.behavior === "highlight" || p.length === 0 || p.indexOf(N.key) !== -1;
              return (
                // prettier-ignore
                /* @__PURE__ */ a(
                  "path",
                  {
                    d: E(N) || "",
                    strokeWidth: 2,
                    stroke: B ? m ? m(s.runtime.seriesLabels ? s.runtime.seriesLabels[N.key] : N.key) : "#000" : "transparent",
                    fillOpacity: L ? 0.2 : 1,
                    fill: B ? m ? m(s.runtime.seriesLabels ? s.runtime.seriesLabels[N.key] : N.key) : "#000" : "transparent"
                  },
                  N.key
                )
              );
            })
          }
        ),
        /* @__PURE__ */ a(_r, { width: Number(r), height: Number(n), fill: "transparent", onMouseMove: (v) => i(v, g), onMouseLeave: o })
      ]
    },
    "area-wrapper"
  ) }) });
}, uk = de.memo(sk), Wc = () => {
  const { config: e, colorPalettes: t, tableData: n, updateConfig: r, parseDate: i, formatDate: o, setSeriesHighlight: d, seriesHighlight: c } = de.useContext(vt), s = de.useContext(Qf), { orientation: p } = e, [m, g] = de.useState(null), x = p === "horizontal", T = 1, y = e.lollipopSize === "large" ? 7 : e.lollipopSize === "medium" ? 6 : 5, A = e.lollipopSize === "large" ? 14 : e.lollipopSize === "medium" ? 12 : 10, b = e.yAxis.labelPlacement === "Below Bar", v = e.yAxis.displayNumbersOnBar, E = e.orientation === "horizontal" ? "yAxis" : "xAxis", N = e.barStyle === "rounded", R = e.visualizationSubType === "stacked", L = e.tipRounding, B = e.roundingStyle === "standard" ? "8px" : e.roundingStyle === "shallow" ? "5px" : e.roundingStyle === "finger" ? "15px" : "0px", j = e.runtime.seriesKeys.length, Z = Object.keys(e.runtime.seriesLabels).length > 1, X = e.visualizationType === "Bar" && e.legend.behavior === "isolate" && e.legend.axisAlign && (c != null && c.length) ? c : e.runtime.barSeriesKeys || e.runtime.seriesKeys;
  return de.useEffect(() => {
    p === "horizontal" && !e.yAxis.labelPlacement && r({
      ...e,
      yAxis: {
        ...e.yAxis,
        labelPlacement: "Below Bar"
      }
    });
  }, [e, r]), de.useEffect(() => {
    e.isLollipopChart === !1 && e.barHeight < 25 && r({ ...e, barHeight: 25 });
  }, [e.isLollipopChart]), de.useEffect(() => {
    e.visualizationSubType === "horizontal" && r({
      ...e,
      orientation: "horizontal"
    });
  }, []), de.useEffect(() => {
    e.barStyle === "lollipop" && !e.isLollipopChart && r({ ...e, isLollipopChart: !0 }), (N || e.barStyle === "flat") && r({ ...e, isLollipopChart: !1 });
  }, [e.barStyle]), {
    isHorizontal: x,
    barBorderWidth: T,
    lollipopBarWidth: y,
    lollipopShapeSize: A,
    isLabelBelowBar: b,
    displayNumbersOnBar: v,
    shouldSuppress: (G) => {
      var ne;
      return (ne = e.preliminaryData) == null ? void 0 : ne.some((H) => {
        const ce = H.column ? H.column === G.key : !0, ke = String(G.value) === String(H.value) && H.value !== "";
        return ce && ke && H.symbol && H.type === "suppression";
      });
    },
    section: E,
    isRounded: N,
    isStacked: R,
    tipRounding: L,
    radius: B,
    stackCount: j,
    barStackedSeriesKeys: X,
    hasMultipleSeries: Z,
    applyRadius: (G) => {
      if (G == null || !N)
        return {};
      let ne = {};
      return (R && G + 1 === j || !R) && (ne = x ? { borderRadius: `0 ${B}  ${B}  0` } : { borderRadius: `${B} ${B} 0 0` }), !R && G === -1 && (ne = x ? { borderRadius: `${B} 0  0 ${B} ` } : { borderRadius: ` 0  0 ${B} ${B}` }), L === "full" && R && G === 0 && j > 1 && (ne = x ? { borderRadius: `${B} 0 0 ${B}` } : { borderRadius: `0 0 ${B} ${B}` }), L === "full" && (R && G === 0 && j === 1 || !R) && (ne = { borderRadius: B }), ne;
    },
    updateBars: (G) => {
      if (e.visualizationType !== "Bar" && !x)
        return G;
      const ne = [...G];
      let H;
      const ce = {
        stacked: e.barHeight,
        lollipop: y
      };
      R ? H = ce.stacked : H = ce[e.isLollipopChart ? "lollipop" : "stacked"] * j;
      const ke = b ? Dc * 1.2 : 0;
      let Se = Number(e.barSpace), xe = ne.length * (H + ke + Se);
      return x && (e.heights.horizontal = xe), ne.map((De, je) => {
        let Ce = 0;
        return De.index !== 0 && (Ce = (H + Se + ke) * je), { ...De, y: Ce, height: H };
      });
    },
    assignColorsToValues: (G, ne, H) => {
      if (!e.legend.colorCode && e.series.length > 1)
        return H;
      const ce = e.customColors ?? t[e.palette], ke = n.map((je) => je[e.legend.colorCode]);
      let Se = /* @__PURE__ */ new Map(), xe = [];
      for (let je = 0; je < ke.length; je++)
        Se.has(ke[je]) || Se.set(ke[je], ce[Se.size % ce.length]), xe.push(Se.get(ke[je]));
      for (; xe.length < G; )
        xe = xe.concat(xe);
      return xe[ne];
    },
    getHighlightedBarColorByValue: (G) => {
      const ne = e == null ? void 0 : e.highlightedBarValues.find((H) => {
        if (H.value)
          return e.xAxis.type === "date" ? o(i(H.value)) === G : H.value === G;
      });
      return ne != null && ne.color ? ne.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (G) => {
      const ne = e == null ? void 0 : e.highlightedBarValues.filter((H) => {
        if (H.value)
          return e.xAxis.type === "date" ? o(i(H.value)) === G : H.value === G;
      })[0];
      return ne != null && ne.color ? ne : !1;
    },
    getAdditionalColumn: (G, ne) => {
      var De, je;
      if (!ne)
        return "";
      const H = e.columns, ce = [];
      let ke = "";
      const Se = (je = (De = e.runtime) == null ? void 0 : De.series) == null ? void 0 : je.find((Ce) => Ce == null ? void 0 : Ce.dynamicCategory), xe = n.find((Ce) => {
        const ye = Se ? Ce[Se.dynamicCategory] === G : !0;
        return Ce[e.xAxis.dataKey] === ne && ye;
      }) || {};
      return Object.keys(H).forEach((Ce) => {
        if (G && e.columns[Ce].series && e.columns[Ce].series !== G)
          return;
        const ye = {
          addColPrefix: e.columns[Ce].prefix,
          addColSuffix: e.columns[Ce].suffix,
          addColRoundTo: e.columns[Ce].roundToPlace ? e.columns[Ce].roundToPlace : "",
          addColCommas: e.columns[Ce].commas
        }, Ee = Zf(
          xe[e.columns[Ce].name],
          "left",
          !0,
          e,
          ye
        );
        e.columns[Ce].tooltips && ce.push([e.columns[Ce].label, Ee]);
      }), ce.forEach((Ce) => {
        ke += `${Ce[0]} : ${Ce[1]} <br/>`;
      }), ke;
    },
    hoveredBar: m,
    setHoveredBar: g,
    onMouseOverBar: (G, ne) => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && ne && s({ type: "SET_SERIES_HIGHLIGHT", payload: [ne] }), g(G);
    },
    onMouseLeaveBar: () => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && s({ type: "SET_SERIES_HIGHLIGHT", payload: [] });
    }
  };
}, Os = de.createContext(null), kh = ({
  xScale: e,
  barWidth: t = 0,
  totalBarsInGroup: n = 1,
  yMax: r,
  handleTooltipMouseOff: i,
  handleTooltipMouseOver: o,
  handleTooltipClick: d,
  tooltipData: c,
  showTooltip: s,
  hideTooltip: p
}) => {
  const { parseDate: m, config: g } = de.useContext(vt), { runtime: x, regions: T, visualizationType: y, orientation: A, xAxis: b } = g, v = e.domain(), E = (L) => {
    let B;
    if (!(L != null && L.fromType) || L.fromType === "Fixed") {
      const j = new Date(L.from), Z = m(us(g.xAxis.dateParseFormat, j)).getTime();
      B = e(Z), y === "Bar" && b.type === "date-time" && (B = B - t * n / 2);
    }
    if (L.fromType === "Previous Days") {
      const j = Number(L.from) || 0;
      v.map((se) => us(g.xAxis.dateParseFormat, new Date(se)));
      const Z = L.toType === "Last Date" ? new Date(v[v.length - 1]).getTime() : new Date(L.to), re = g.xAxis.type === "categorical" ? us(g.xAxis.dateParseFormat, Z) : us(g.xAxis.dateParseFormat, Z), X = new Date(re);
      if (B = new Date(X.setDate(X.getDate() - Number(j))), b.type === "date") {
        B = new Date(us(b.dateParseFormat, B)).getTime();
        let se = v[0], Y = Math.abs(B - se);
        for (let ie = 1; ie < v.length; ie++) {
          const I = Math.abs(B - v[ie]);
          I < Y && (Y = I, se = v[ie]);
        }
        B = se;
      }
      if (b.type === "categorical") {
        let se = v[0], Y = Math.abs(new Date(B).getTime() - new Date(se).getTime());
        for (let ie = 1; ie < v.length; ie++) {
          const I = Math.abs(new Date(B).getTime() - new Date(v[ie]).getTime());
          I < Y && (Y = I, se = v[ie]);
        }
        B = se;
      }
      B = e(B);
    }
    if (b.type === "categorical" && L.fromType !== "Previous Days" && (B = e(L.from)), y === "Line" || y === "Area Chart") {
      let j = Number(g.yAxis.size);
      e.bandwidth && (j += e.bandwidth() / 2), B = B + j;
    }
    return y === "Bar" && g.xAxis.type === "date-time" && L.fromType === "Previous Days" && (B = B - t * n / 2), B;
  }, N = (L) => {
    let B;
    if (b.type === "categorical" && (B = e(L.to)), Tn(b) && ((!(L != null && L.toType) || L.toType === "Fixed") && (B = e(m(L.to).getTime())), (y === "Bar" || g.visualizationType === "Combo") && (B = L.toType !== "Last Date" ? e(m(L.to).getTime()) + t * n : B)), L.toType === "Last Date") {
      const j = v[v.length - 1];
      B = Number(
        e(j) + ((y === "Bar" || y === "Combo") && g.xAxis.type === "date" ? t * n : 0)
      );
    }
    if (y === "Line" || y === "Area Chart") {
      let j = Number(g.yAxis.size);
      e.bandwidth && (j += e.bandwidth() / 2), B = B + j;
    }
    return y === "Bar" && g.xAxis.type === "date-time" && L.toType !== "Last Date" && (B = B - t * n / 2), (y === "Bar" || y === "Combo") && b.type === "categorical" && (B = B + (y === "Bar" || y === "Combo" ? t * n : 0)), B;
  }, R = (L, B) => L - B;
  if (T && A === "vertical")
    return T.map((L) => {
      const B = E(L), j = N(L), Z = R(j, B);
      if (!B || !j)
        return null;
      const re = () => /* @__PURE__ */ a("rect", { x: B, y: 0, width: Z, height: r, fill: L.background, opacity: 0.3 });
      return /* @__PURE__ */ z(
        it,
        {
          height: 100,
          fill: "red",
          className: "regions regions-group--line zzz",
          onMouseMove: o,
          onMouseLeave: i,
          handleTooltipClick: d,
          tooltipData: JSON.stringify(c),
          showTooltip: s,
          children: [
            /* @__PURE__ */ a(re, {}),
            /* @__PURE__ */ a(gt, { x: B + Z / 2, y: 5, fill: L.color, verticalAnchor: "start", textAnchor: "middle", children: L.label })
          ]
        },
        L.label
      );
    });
};
function Ms(e) {
  var H, ce;
  const { config: t, index: n, id: r, className: i, background: o, borderColor: d, borderWidth: c, width: s, height: p, x: m, y: g, onMouseOver: x, onMouseLeave: T, onClick: y, tooltipHtml: A, tooltipId: b, styleOverrides: v, seriesHighlight: E, type: N } = e, R = Math.max(0, s), L = Math.max(0, p), B = t.orientation === "horizontal", j = t.barStyle === "rounded", Z = t.visualizationSubType === "stacked", re = t.tipRounding, X = t.visualizationType === "Combo" && ((ce = (H = t.runtime) == null ? void 0 : H.barSeriesKeys) == null ? void 0 : ce.length), se = t.runtime.seriesKeys.length, Y = t.visualizationType === "Bar" && t.legend.axisAlign && (E != null && E.length) ? E == null ? void 0 : E.length : 0, ie = X || Y || se;
  let I = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  (I > R / 2 || I > L / 2) && (I = Math.min(R / 2, L / 2));
  const U = () => `M${m},${g + L}
      L${m},${g + I}
      Q${m},${g} ${m + I},${g}
      L${m + R - I},${g}
      Q${m + R},${g} ${m + R},${g + I}
      L${m + R},${g + L}
      L${m},${g + L}`, ue = () => `M${m},${g + L}
      L${m},${g}
      L${m + R - I},${g}
      Q${m + R},${g} ${m + R},${g + I}
      L${m + R},${g + L - I}
      Q${m + R},${g + L} ${m + R - I},${g + L}
      L${m},${g + L}`, te = () => `M${m + I},${g + L}
      Q${m},${g + L} ${m},${g + L - I}
      L${m},${g}
      L${m + R},${g}
      L${m + R},${g + L - I}
      Q${m + R},${g + L} ${m + R - I},${g + L}
      L${m + I},${g + L}`, J = () => `M${m + I},${g + L}
      Q${m},${g + L} ${m},${g + L - I}
      L${m},${g + I}
      Q${m},${g} ${m + I},${g}
      L${m + R},${g}
      L${m + R},${g + L}
      L${m + I},${g + L}`, Q = () => `M${m + I},${g + L}
      Q${m},${g + L} ${m},${g + L - I}
      L${m},${g + I}
      Q${m},${g} ${m + I},${g}
      L${m + R - I},${g}
      Q${m + R},${g} ${m + R},${g + I}
      L${m + R},${g + L - I}
      Q${m + R},${g + L} ${m + R - I},${g + L}
      L${m + I},${g + L}`, G = () => `M${m},${g}
      L${m + R},${g}
      L${m + R},${g + L}
      L${m},${g + L}
      L${m},${g}`;
  let ne;
  return n == null || !j || N == "axisBar" ? ne = G() : (ne = G(), (Z && n + 1 === ie || !Z) && (ne = B ? ue() : U()), !Z && n === -1 && (ne = B ? J() : te()), re === "full" && Z && n === 0 && ie > 1 && (ne = B ? J() : te()), re === "full" && (Z && n === 0 && ie === 1 || !Z) && (ne = Q())), /* @__PURE__ */ a(
    "path",
    {
      id: r,
      className: i,
      d: ne,
      fill: o,
      stroke: d,
      strokeWidth: c,
      onMouseOver: x,
      onMouseLeave: T,
      onClick: y,
      "data-tooltip-html": A,
      "data-tooltip-id": b,
      style: {
        transition: "all 0.2s linear",
        ...v
      }
    }
  );
}
const ck = () => {
  var se, Y;
  const [e, t] = de.useState(0), { xScale: n, yScale: r, seriesScale: i, xMax: o, yMax: d } = de.useContext(Os), { transformedData: c, colorScale: s, seriesHighlight: p, config: m, formatNumber: g, formatDate: x, parseDate: T, setSharedFilter: y } = de.useContext(vt), {
    isHorizontal: A,
    barBorderWidth: b,
    applyRadius: v,
    hoveredBar: E,
    getAdditionalColumn: N,
    onMouseLeaveBar: R,
    onMouseOverBar: L,
    barStackedSeriesKeys: B
  } = Wc(), { orientation: j } = m, Z = (se = m.brush) != null && se.active && ((Y = m.brush.data) != null && Y.length) ? m.brush.data : c, re = m.runtime.xAxis.type === "date-time" || m.runtime.xAxis.type === "date", X = m.runtime.xAxis.type === "date-time";
  return m.visualizationSubType === "stacked" && !A && /* @__PURE__ */ z(Ue, { children: [
    /* @__PURE__ */ a(
      zy,
      {
        data: Z,
        keys: B,
        x: (ie) => ie[m.runtime.xAxis.dataKey],
        xScale: n,
        yScale: r,
        color: s,
        children: (ie) => ie.reverse().map(
          (I) => I.bars.map((U) => {
            let ue = m.legend.behavior === "highlight" && p.length > 0 && p.indexOf(U.key) === -1, te = m.legend.behavior === "highlight" || p.length === 0 || p.indexOf(U.key) !== -1, J = re ? i.range()[1] - i.range()[0] : o / I.bars.length;
            m.runtime.xAxis.type !== "date" && (J = m.barThickness * J);
            const Q = U.bar.data[m.runtime.xAxis.dataKey], G = re ? x(T(Q)) : Q, ne = g(U.bar ? U.bar.data[U.key] : 0, "left");
            if (!ne)
              return;
            const H = n(re ? T(Q) : Q) - (X ? J / 2 : 0), ce = m.runtime.xAxis.label ? `${m.runtime.xAxis.label}: ${G}` : G, ke = N(E), Se = `${m.runtime.seriesLabels[U.key]}: ${ne}`, xe = `<ul>
                  <li class="tooltip-heading"">${ce}</li>
                  <li class="tooltip-body ">${Se}</li>
                  <li class="tooltip-body ">${ke}</li>
                    </li></ul>`;
            return t(J), /* @__PURE__ */ a(it, { children: /* @__PURE__ */ a(
              it,
              {
                id: `barStack${I.index}-${U.index}`,
                className: "stack vertical",
                children: Ms({
                  config: m,
                  seriesHighlight: p,
                  index: I.index,
                  background: s(m.runtime.seriesLabels[U.key]),
                  borderColor: "#333",
                  borderStyle: "solid",
                  borderWidth: `${m.barHasBorder === "true" ? b : 0}px`,
                  width: J,
                  height: U.height,
                  x: H,
                  y: U.y,
                  onMouseOver: () => L(G, U.key),
                  onMouseLeave: R,
                  tooltipHtml: xe,
                  tooltipId: `cdc-open-viz-tooltip-${m.runtime.uniqueId}`,
                  onClick: (De) => {
                    De.preventDefault(), y && (U[m.xAxis.dataKey] = G, y(m.uid, U));
                  },
                  styleOverrides: {
                    animationDelay: `${I.index * 0.5}s`,
                    transformOrigin: `${J / 2}px ${U.y + U.height}px`,
                    opacity: ue ? 0.2 : 1,
                    display: te ? "block" : "none"
                  }
                })
              },
              `bar-stack-${I.index}-${U.index}`
            ) }, `${I.index}--${U.index}--${j}`);
          })
        )
      }
    ),
    /* @__PURE__ */ a(kh, { xScale: n, yMax: d, barWidth: e, totalBarsInGroup: 1 })
  ] });
}, dk = () => {
  const { yMax: e, yScale: t, xScale: n } = de.useContext(Os), {
    animatedChart: r,
    colorScale: i,
    config: o,
    formatDate: d,
    formatNumber: c,
    parseDate: s,
    seriesHighlight: p,
    setSharedFilter: m,
    transformedData: g
  } = de.useContext(vt), { barBorderWidth: x, displayNumbersOnBar: T, getAdditionalColumn: y, hoveredBar: A, isHorizontal: b, isLabelBelowBar: v, onMouseLeaveBar: E, onMouseOverBar: N, updateBars: R, barStackedSeriesKeys: L } = Wc(), { orientation: B, visualizationSubType: j } = o;
  return o.visualizationSubType === "stacked" && b && /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ a(
    pS,
    {
      data: g,
      keys: L,
      height: e,
      y: (Z) => Z[o.runtime.yAxis.dataKey],
      xScale: n,
      yScale: t,
      color: i,
      offset: "none",
      children: (Z) => Z.map(
        (re) => R(re.bars).map((X, se) => {
          const Y = o.legend.behavior === "highlight" && p.length > 0 && p.indexOf(X.key) === -1, ie = o.legend.behavior === "highlight" || p.length === 0 || p.indexOf(X.key) !== -1;
          o.barHeight = Number(o.barHeight);
          let I = i(o.runtime.seriesLabels[X.key]), U = sl("#000", I);
          km("#000", I) < 7 && (U = "#fff");
          const J = c(g[X.index][X.key], "left"), Q = o.runtime.yAxis.type === "date" ? d(s(g[X.index][o.runtime.originalXAxis.dataKey])) : g[X.index][o.runtime.originalXAxis.dataKey], G = o.runtime.yAxis.label ? `${o.runtime.yAxis.label}: ${Q}` : Q, ne = yr(J), H = y(A), ce = `${o.runtime.seriesLabels[X.key]}: ${J}`, ke = `<ul>
                  <li class="tooltip-heading"">${G}</li>
                  <li class="tooltip-body ">${ce}</li>
                  <li class="tooltip-body ">${H}</li>
                    </li></ul>`;
          return /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z(it, { id: `barStack${re.index}-${X.index}`, className: "stack horizontal", children: [
            Ms({
              config: o,
              seriesHighlight: p,
              index: re.index,
              className: `animated-chart group ${r ? "animated" : ""}`,
              background: i(o.runtime.seriesLabels[X.key]),
              borderColor: "#333",
              borderStyle: "solid",
              borderWidth: `${o.barHasBorder === "true" ? x : 0}px`,
              width: X.width,
              height: X.height,
              x: X.x,
              y: X.y,
              onMouseOver: () => N(Q, X.key),
              onMouseLeave: E,
              tooltipHtml: ke,
              tooltipId: `cdc-open-viz-tooltip-${o.runtime.uniqueId}`,
              onClick: (Se) => {
                Se.preventDefault(), m && (X[o.xAxis.dataKey] = J, m(o.uid, X));
              },
              styleOverrides: {
                animationDelay: `${re.index * 0.5}s`,
                transformOrigin: `${X.x}px 0`,
                opacity: Y ? 0.2 : 1,
                display: ie ? "block" : "none"
              }
            }),
            B === "horizontal" && j === "stacked" && v && re.index === 0 && !o.yAxis.hideLabel && /* @__PURE__ */ a(
              gt,
              {
                x: `${X.x + (o.isLollipopChart ? 15 : 5)}`,
                y: X.y + X.height * 1.2,
                fill: "#000000",
                textAnchor: "start",
                verticalAnchor: "start",
                children: Q
              }
            ),
            T && ne < X.width && /* @__PURE__ */ a(
              gt,
              {
                display: ie ? "block" : "none",
                x: X.x + re.bars[X.index].width / 2,
                y: X.y + X.height / 2,
                fill: U,
                textAnchor: "middle",
                verticalAnchor: "middle",
                children: J
              }
            )
          ] }, se) });
        })
      )
    }
  ) });
}, jc = (e, t) => {
  var A;
  const { formatDate: n, parseDate: r } = de.useContext(vt);
  let i = [], o = "", d = [], c = [];
  ((A = e.series) == null ? void 0 : A.length) > 0 && e.data ? (i = e.series[0], o = e.series[0].dataKey, d = e.highlightedBarValues, c = e.data.map((b) => b[e.xAxis.dataKey])) : (i = [], o = "", d = [], c = []);
  const s = (b, v) => {
    const E = [...e.highlightedBarValues];
    E[v].borderWidth = b.target.value, t({
      ...e,
      highlightedBarValues: E
    });
  }, p = (b, v) => {
    b.preventDefault();
    const E = [...e.highlightedBarValues];
    E[v].value = b.target.value, E[v].dataKey = o, t({
      ...e,
      highlightedBarValues: E
    });
  }, m = (b, v) => {
    b.preventDefault();
    const E = [...e.highlightedBarValues];
    E.push({ dataKey: o }), t({
      ...e,
      highlightedBarValues: E
    });
  }, g = (b, v) => {
    b.preventDefault();
    const E = [...e.highlightedBarValues];
    E.splice(v, 1), t({
      ...e,
      highlightedBarValues: E
    });
  }, x = (b, v) => {
    const E = [...e.highlightedBarValues];
    E[v].color = b.target.value, t({
      ...e
    });
  }, T = (b, v) => {
    const E = [...e.highlightedBarValues];
    E[v].legendLabel = b.target.value, t({
      ...e,
      copyOfHighlightedBarValues: E
    });
  }, y = () => {
  };
  return y.checkFontColor = (b, v, E) => {
    if (e.xAxis.type === "date") {
      if (y.formatDates(v).includes(b))
        return "#000";
    } else if (v.includes(b))
      return "#000";
    return E;
  }, y.formatDates = (b) => b.map((v) => v ? n(r(v)) : !1), y.findDuplicates = (b) => {
    const v = {};
    return b == null ? void 0 : b.filter((N) => {
      const { legendLabel: R } = N;
      return v[R] ? !1 : (v[R] = !0, !0);
    });
  }, {
    HighLightedBarUtils: y,
    highlightedSeries: i,
    highlightedSeriesKey: o,
    highlightedBarValues: d,
    highlightedSeriesValues: c,
    handleUpdateHighlightedBar: p,
    handleAddNewHighlightedBar: m,
    handleRemoveHighlightedBar: g,
    handleUpdateHighlightedBarColor: x,
    handleHighlightedBarLegendLabel: T,
    handleUpdateHighlightedBorderWidth: s
  };
};
function Ua(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
const cg = ({
  bar: e,
  defaultBarHeight: t,
  defaultBarWidth: n,
  config: r,
  barWidth: i,
  isVertical: o
}) => {
  let c = t, s = n, p = "", m = !1, g = !1, x = !1;
  const T = r.general.showSuppressedSymbol;
  if (r.preliminaryData.forEach((b) => {
    (!b.column || b.column === e.key) && b.type === "suppression" && b.value && String(b.value) === String(e.value) && (!b.hideBarSymbol && T ? (c = i > 10 ? 3 : 0, s = 3, m = !0) : (c = 0, s = 0, m = !0));
  }), !m && !Ua(e.value) && r.general.showMissingDataLabel) {
    const b = yr(p, `normal ${i / 2}px sans-serif`), v = Number(b) < i && i > 10;
    g = !0, c = v ? 3 : 0, s = 3;
  }
  if (!m && e.value === "0" && r.general.showZeroValueData) {
    const b = yr("0", `normal ${i / 2}px sans-serif`), v = Number(b) < i && i > 10;
    x = !0, c = v ? 3 : 0, s = 3;
  }
  return { barWidthHorizontal: s, barHeight: c, isSuppressed: m, showMissingDataLabel: g, getBarY: (b, v) => m || g || x ? r.isLollipopChart ? v - 3 * 2 : v - 3 : b, getAbsentDataLabel: (b) => {
    let v = "";
    String(b) === "0" && (v = ""), m && (v = ""), g && (v = "N/A"), x && (v = "0");
    const E = yr(p, `normal ${i / 2}px sans-serif`), N = Number(E) < i && i > 10;
    return r.isLollipopChart || N && o ? v : o ? "" : v;
  } };
}, ws = (e) => e == null ? void 0 : /^0(\.0)?$/.test(e.toString()), dg = (e, t, n) => {
  const r = e.series.find((s) => s.dynamicCategory);
  if (!r)
    return t;
  const { dynamicCategory: i, dataKey: o } = r, d = e.runtime.originalXAxis.dataKey, c = nt.groupBy(t, d);
  return Object.values(c).map((s) => s.reduce((p, m) => {
    const g = m[o], x = m[i];
    if (n) {
      const { lower: T, upper: y } = e.confidenceKeys;
      p.CI || (p.CI = {});
      const A = m[T], b = m[y];
      p.CI[x] = { lower: A, upper: b };
    }
    return p[x] = g, p[d] = m[d], p.dynamicData = !0, p;
  }, {}));
}, fk = () => {
  const { xScale: e, yScale: t, xMax: n, yMax: r, seriesScale: i, convertLineToBarGraph: o } = de.useContext(Os), [d, c] = de.useState(0), [s, p] = de.useState(0), {
    // prettier-ignore
    assignColorsToValues: m,
    barBorderWidth: g,
    getAdditionalColumn: x,
    getHighlightedBarByValue: T,
    getHighlightedBarColorByValue: y,
    lollipopBarWidth: A,
    lollipopShapeSize: b,
    onMouseLeaveBar: v,
    onMouseOverBar: E,
    section: N
  } = Wc(), { colorScale: R, config: L, dashboardConfig: B, tableData: j, formatDate: Z, formatNumber: re, parseDate: X, seriesHighlight: se, setSharedFilter: Y, transformedData: ie, brushConfig: I } = de.useContext(vt), { HighLightedBarUtils: U } = jc(L), ue = document.documentElement, te = getComputedStyle(ue).getPropertyValue("--cool-gray-90");
  let J = ie;
  L.preliminaryData.some((H) => H.value && H.type === "suppression") && (J = j), I.data.length && (J = I.data);
  const G = Object.keys(L.confidenceKeys).length > 0, ne = dg(L, J, G);
  return L.visualizationSubType !== "stacked" && (L.visualizationType === "Bar" || L.visualizationType === "Combo" || o) && L.orientation === "vertical" && /* @__PURE__ */ z(it, { children: [
    /* @__PURE__ */ a(
      Oy,
      {
        data: ne,
        keys: L.runtime.barSeriesKeys || L.runtime.seriesKeys,
        height: r,
        x0: (H) => {
          const ce = H[L.runtime.originalXAxis.dataKey];
          return Tn(L.runtime.xAxis) ? X(ce) : ce;
        },
        x0Scale: e,
        x1Scale: i,
        yScale: t,
        color: () => "",
        children: (H) => H.map((ce, ke) => /* @__PURE__ */ a(
          it,
          {
            className: `bar-group-${ce.index}-${ce.x0}--${ke} ${L.orientation}`,
            id: `bar-group-${ce.index}-${ce.x0}--${ke}`,
            left: ce.x0,
            children: ce.bars.map((Se, xe) => {
              var we, yt;
              const De = ne[ce.index], je = De[L.runtime.originalXAxis.dataKey], Ce = L.yAxis.type === "logarithmic" ? 0.1 : 0;
              let ye = L.highlightedBarValues.map((at) => at.value).filter((at) => at !== void 0);
              ye = L.xAxis.type === "date" ? U.formatDates(ye) : ye;
              const Ee = L.legend.behavior === "highlight" && se.length > 0 && se.indexOf(Se.key) === -1, he = L.legend.behavior === "highlight" || se.length === 0 || se.indexOf(Se.key) !== -1;
              let Be = i.range()[1] - i.range()[0];
              const $e = Math.abs(t(Se.value) - t(Ce)), tt = Se.value >= 0 && Ua(Se.value) ? Se.y : t(0);
              let We = L.isLollipopChart ? A : i.bandwidth(), Fe = Se.x + (L.isLollipopChart ? (Be / ce.bars.length - A) / 2 : 0) - (L.xAxis.type === "date-time" ? Be / 2 : 0);
              c(We), p(ce.bars.length);
              const Je = re(/[a-zA-Z]/.test(String(Se.value)) ? "" : Se.value, "left"), Ke = L.runtime[N].type === "date" ? Z(X(je)) : je, Ye = Se.value < 0 ? -1 : xe, Xe = x(Se.key, je);
              let Ae = L.runtime.xAxis.label ? `${L.runtime.xAxis.label}: ${Ke}` : Ke;
              const Oe = `${L.runtime.seriesLabels[Se.key]}: ${Je}`, lt = `<ul>
                  <li class="tooltip-heading">${Ae}</li>
                  <li class="tooltip-body ">${Oe}</li>
                  ${Xe ? '<li class="tooltip-body ">' + Xe + "</li>" : ""}
                    </li></ul>`;
              let ve = "#000000";
              ve = U.checkFontColor(Je, ye, ve);
              const mt = L.isLollipopChart && L.lollipopColorStyle === "regular", ut = L.isLollipopChart && L.lollipopColorStyle === "two-tone", st = ye == null ? void 0 : ye.includes(Ke), Lt = y(Ke), Kt = T(Ke), Xt = st ? Lt : L.barHasBorder === "true" ? "#000" : "transparent", It = st ? Kt.borderWidth : L.isLollipopChart ? 0 : L.barHasBorder === "true" ? g : 0, { barHeight: ln, isSuppressed: Tt, getBarY: Ot, getAbsentDataLabel: _t } = cg({
                bar: Se,
                defaultBarHeight: $e,
                config: L,
                barWidth: We,
                isVertical: !0
              }), an = _t(Je), dn = Tt || !L.labels ? "" : Je, zt = Ot(tt, t(Ce)), Bt = ws(Se.value) ? "none" : "block", on = (at, bt) => {
                var ct;
                let wt = at, qt = bt || "#f2f2f2";
                if (B && ((ct = B.dashboard.sharedFilters) == null ? void 0 : ct.length) !== 0) {
                  const { sharedFilters: dt } = B.dashboard;
                  return wt = dt ? dt.map((Wt) => Wt.setBy === L.uid ? Wt.resetLabel === Wt.active || Wt.active === ie[ce.index][L.xAxis.dataKey] ? R(L.runtime.seriesLabels[Se.key]) : qt : R(L.runtime.seriesLabels[Se.key]))[0] : R(L.runtime.seriesLabels[Se.key]), mt && (wt = at), st && (wt = "transparent"), L.legend.colorCode && (wt = m(H.length, ce.index, at)), ut && (wt = Gi(at).brighten(1)), wt;
                }
                return ut && (wt = Gi(at).brighten(1)), L.legend.colorCode && (wt = m(H.length, ce.index, at)), st && (wt = "transparent"), wt;
              }, rt = 5, ht = Fe + (L.xAxis.type !== "date-time" ? We / 2 : 0), Pe = t(
                De.dynamicData && ((we = De == null ? void 0 : De.CI) != null && we[Se.key]) ? De.CI[Se.key].upper : De[L.confidenceKeys.upper]
              ), _e = t(
                De.dynamicData && ((yt = De == null ? void 0 : De.CI) != null && yt[Se.key]) ? De.CI[Se.key].lower : De[L.confidenceKeys.lower]
              );
              return /* @__PURE__ */ a(it, { children: /* @__PURE__ */ z(it, { children: [
                Ms({
                  config: L,
                  index: Ye,
                  id: `barGroup${ce.index}`,
                  background: on(R(L.runtime.seriesLabels[Se.key])),
                  borderColor: Xt,
                  borderStyle: "solid",
                  borderWidth: `${It}px`,
                  width: We,
                  height: ln,
                  x: Fe,
                  y: zt,
                  onMouseOver: () => E(Ke, Se.key),
                  onMouseLeave: v,
                  tooltipHtml: lt,
                  tooltipId: `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                  onClick: (at) => {
                    at.preventDefault(), Y && (Se[L.xAxis.dataKey] = Ke, Y(L.uid, Se));
                  },
                  styleOverrides: {
                    transformOrigin: `0 ${zt + ln}px`,
                    opacity: Ee ? 0.2 : 1,
                    display: he ? "block" : "none",
                    cursor: B ? "pointer" : "default"
                  }
                }),
                L.preliminaryData.map((at, bt) => {
                  const wt = !at.column || at.column === Se.key;
                  if (!(String(at.value) === String(Se.value) && at.value !== "" && wt) || We < 10 || !L.general.showSuppressedSymbol || at.hideBarSymbol)
                    return;
                  const dt = String(at.symbol).includes("Asterisk"), Wt = dt ? -5 : -8, Yt = dt ? "middle" : "end", Rt = at.symbol === "Asterisk" ? We * 1.2 : at.symbol === "Double Asterisk" ? We : We / 1.5, Ct = at.displayGray ? "#8b8b8a" : "#000";
                  return /* @__PURE__ */ a(
                    gt,
                    {
                      dy: Wt,
                      display: he ? "block" : "none",
                      opacity: Ee ? 0.5 : 1,
                      x: Fe + We / 2,
                      y: zt,
                      verticalAnchor: Yt,
                      fill: Ct,
                      textAnchor: "middle",
                      fontSize: `${Rt}px`,
                      children: at.iconCode
                    },
                    bt
                  );
                }),
                /* @__PURE__ */ a(
                  gt,
                  {
                    display: he ? "block" : "none",
                    opacity: Ee ? 0.5 : 1,
                    x: Fe + We / 2,
                    y: zt - 5,
                    fill: ve,
                    textAnchor: "middle",
                    children: ws(Se.value) ? "" : dn
                  }
                ),
                /* @__PURE__ */ a(
                  gt,
                  {
                    display: he ? "block" : "none",
                    opacity: Ee ? 0.5 : 1,
                    x: Fe + We / 2,
                    y: zt - 5,
                    fill: ve,
                    textAnchor: "middle",
                    fontSize: L.isLollipopChart ? null : We / 2,
                    children: an
                  }
                ),
                L.isLollipopChart && L.lollipopShape === "circle" && /* @__PURE__ */ a(
                  "circle",
                  {
                    display: Bt,
                    cx: Fe + b / 3.5,
                    cy: Se.y,
                    r: b / 2,
                    fill: on(R(L.runtime.seriesLabels[Se.key])),
                    "data-tooltip-html": lt,
                    "data-tooltip-id": `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                    style: { filter: "unset", opacity: 1 }
                  },
                  `circle--${Se.index}`
                ),
                L.isLollipopChart && L.lollipopShape === "square" && /* @__PURE__ */ a(
                  "rect",
                  {
                    display: Bt,
                    x: Fe - A / 2,
                    y: Se.y,
                    width: b,
                    height: b,
                    fill: on(R(L.runtime.seriesLabels[Se.key])),
                    "data-tooltip-html": lt,
                    "data-tooltip-id": `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                    style: { opacity: 1, filter: "unset" },
                    children: /* @__PURE__ */ a("animate", { attributeName: "height", values: `0, ${b}`, dur: "2.5s" })
                  },
                  `circle--${Se.index}`
                ),
                G && Se.value !== void 0 && De && /* @__PURE__ */ a(
                  "path",
                  {
                    stroke: te,
                    strokeWidth: "px",
                    d: `M${ht - rt} ${Pe}
                                L${ht + rt} ${Pe}
                                M${ht} ${Pe}
                                L${ht} ${_e}
                                M${ht - rt} ${_e}
                                L${ht + rt} ${_e}`
                  },
                  `confidence-interval-v-${De[L.runtime.originalXAxis.dataKey]}`
                )
              ] }, `bar-sub-group-${ce.index}-${ce.x0}-${zt}--${xe}`) }, `${ce.index}--${xe}`);
            })
          },
          `bar-group-${ce.index}-${ce.x0}--${ke}`
        ))
      }
    ),
    /* @__PURE__ */ a(kh, { xScale: e, yMax: r, barWidth: d, totalBarsInGroup: s })
  ] });
}, hk = () => {
  var J;
  const { xScale: e, yScale: t, yMax: n, seriesScale: r } = de.useContext(Os), {
    transformedData: i,
    tableData: o,
    colorScale: d,
    seriesHighlight: c,
    config: s,
    formatNumber: p,
    formatDate: m,
    parseDate: g,
    setSharedFilter: x,
    isNumber: T
  } = de.useContext(vt), {
    isHorizontal: y,
    barBorderWidth: A,
    updateBars: b,
    assignColorsToValues: v,
    section: E,
    isLabelBelowBar: N,
    displayNumbersOnBar: R,
    lollipopBarWidth: L,
    lollipopShapeSize: B,
    getHighlightedBarColorByValue: j,
    getHighlightedBarByValue: Z,
    getAdditionalColumn: re,
    hoveredBar: X,
    onMouseLeaveBar: se,
    onMouseOverBar: Y
  } = Wc(), { HighLightedBarUtils: ie } = jc(s), I = Object.keys(s.confidenceKeys).length > 0, U = dg(s, i, I), ue = document.documentElement, te = getComputedStyle(ue).getPropertyValue("--cool-gray-90");
  return s.visualizationSubType !== "stacked" && s.visualizationType === "Bar" && s.orientation === "horizontal" && /* @__PURE__ */ a(it, { children: /* @__PURE__ */ a(
    Oy,
    {
      data: (J = s.preliminaryData) != null && J.some((Q) => Q.value && Q.type === "suppression") ? o : U,
      keys: s.runtime.barSeriesKeys || s.runtime.seriesKeys,
      height: n,
      x0: (Q) => Q[s.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: r,
      yScale: e,
      color: () => "",
      children: (Q) => b(Q).map((G, ne) => /* @__PURE__ */ a(
        it,
        {
          className: `bar-group-${G.index}-${G.x0}--${ne} ${s.orientation}`,
          id: `bar-group-${G.index}-${G.x0}--${ne}`,
          top: G.y,
          children: G.bars.map((H, ce) => {
            var qt;
            const ke = U[G.index], Se = ke[s.runtime.originalXAxis.dataKey], xe = s.yAxis.type === "logarithmic" ? 0.1 : 0;
            let De = s.highlightedBarValues.map((ct) => ct.value).filter((ct) => ct !== void 0);
            De = s.xAxis.type === "date" ? ie.formatDates(De) : De;
            let je = s.legend.behavior === "highlight" && c.length > 0 && c.indexOf(H.key) === -1, Ce = s.legend.behavior === "highlight" || c.length === 0 || c.indexOf(H.key) !== -1, ye = s.barHeight, Ee = parseInt(s.isLollipopChart ? L : ye);
            isNaN(Ee) && (Ee = 25);
            let he = H.value >= 0 && T(H.value) ? H.y : t(xe);
            const Be = Math.abs(e(H.value) - e(xe)), $e = H.value >= 0 && T(H.value), {
              barWidthHorizontal: tt,
              isSuppressed: We,
              getAbsentDataLabel: Fe
            } = cg({ bar: H, defaultBarWidth: Be, config: s, isNumber: T, isVertical: !1 }), Je = H.value < 0 ? Math.abs(e(H.value)) : e(xe), Ke = p(H.value, "left"), Ye = s.runtime[E].type === "date" ? m(g(Se)) : Se, Xe = $e ? "above" : "below", Ae = Fe(Ke), Oe = s.yAxis.displayNumbersOnBar ? Ke : "", lt = yr(Oe), ve = Number(lt) < Be - 5;
            let mt = ve ? "end" : "start", ut = "start", st = ve ? -5 : 5, Lt = 10;
            Xe === "below" && (mt = ve ? "start" : "end", st = ve ? 5 : -5, s.isLollipopChart && (ut = "end", Lt = -10));
            const Kt = H.value < 0 ? -1 : ce;
            let Xt = s.runtime.yAxis.label ? `${s.runtime.yAxis.label}: ${Ye}` : Ye;
            const It = re(X), ln = `${s.runtime.seriesLabels[H.key]}: ${Ke}`, Tt = `<ul>
                  <li class="tooltip-heading"">${Xt}</li>
                  <li class="tooltip-body ">${ln}</li>
                  <li class="tooltip-body ">${It}</li>
                    </li></ul>`;
            let Ot = "#000000";
            Ot = ie.checkFontColor(Ke, De, Ot);
            let _t = s.runtime.seriesLabels && s.runtime.seriesLabels[H.key] ? d(s.runtime.seriesLabels[H.key]) : d(H.key);
            s.series.find((ct) => ct.dynamicCategory) || (_t = v(Q.length, G.index, _t));
            const dn = s.isLollipopChart && s.lollipopColorStyle === "regular", zt = s.isLollipopChart && s.lollipopColorStyle === "two-tone", Bt = De == null ? void 0 : De.includes(Ye), on = j(Ye), rt = Z(Ye), ht = Bt ? on : s.barHasBorder === "true" ? "#000" : "transparent", Pe = Bt ? rt.borderWidth : s.isLollipopChart ? 0 : s.barHasBorder === "true" ? A : 0, _e = ws(H.value) ? "none" : "block";
            _t && Ot && ve && (Ot = sl("#000", _t), km("#000", _t) < 7 && (Ot = "#fff"));
            const we = () => dn ? _t : zt ? Gi(_t).brighten(1) : Bt ? "transparent" : _t, yt = 5, at = ye * H.index + ye / 2, [bt, wt] = ["upper", "lower"].map((ct) => {
              if (!I)
                return;
              if (ke.dynamicData) {
                const Wt = ke.CI[H.key];
                if (!Wt)
                  return;
                const Yt = Wt[ct];
                return e(Yt);
              }
              const dt = ke[s.confidenceKeys[ct]];
              return e(dt);
            });
            return /* @__PURE__ */ a(it, { children: /* @__PURE__ */ z(it, { children: [
              Ms({
                config: s,
                index: Kt,
                id: `barGroup${G.index}`,
                background: we(),
                borderColor: ht,
                borderStyle: "solid",
                borderWidth: `${Pe}px`,
                width: tt,
                height: Ee,
                x: Je,
                y: ye * H.index,
                onMouseOver: () => Y(Ye, H.key),
                onMouseLeave: se,
                tooltipHtml: Tt,
                tooltipId: `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
                onClick: (ct) => {
                  ct.preventDefault(), x && (H[s.xAxis.dataKey] = Ke, x(s.uid, H));
                },
                styleOverrides: {
                  transformOrigin: `0 ${he + ye}px`,
                  opacity: je ? 0.2 : 1,
                  display: Ce ? "block" : "none"
                }
              }),
              (qt = s.preliminaryData) == null ? void 0 : qt.map((ct, dt) => {
                const Wt = !ct.column || ct.column === H.key;
                if (!(String(ct.value) === String(H.value) && ct.value !== "" && Wt) || ct.hideBarSymbol || !s.general.showSuppressedSymbol)
                  return;
                const xn = String(ct.symbol).includes("Asterisk") ? "middle" : "end", Sn = ct.symbol === "Asterisk" ? ye * 1.2 : ct.symbol === "Double Asterisk" ? ye : ye / 1.5, Ln = ct.displayGray ? "#8b8b8a" : "#000";
                return /* @__PURE__ */ a(
                  gt,
                  {
                    fontSize: Sn,
                    display: Ce ? "block" : "none",
                    opacity: je ? 0.5 : 1,
                    x: Je,
                    y: s.barHeight / 2 + s.barHeight * H.index,
                    fill: Ln,
                    dy: s.barHeight / 5,
                    dx: 10,
                    textAnchor: "start",
                    verticalAnchor: xn,
                    children: ct.iconCode
                  },
                  dt
                );
              }),
              !s.isLollipopChart && /* @__PURE__ */ a(
                gt,
                {
                  display: Ce ? "block" : "none",
                  x: H.y,
                  opacity: je ? 0.5 : 1,
                  y: s.barHeight / 2 + s.barHeight * H.index,
                  fill: Ot,
                  dx: st,
                  verticalAnchor: "middle",
                  textAnchor: mt,
                  children: ws(H.value) ? "" : Oe
                }
              ),
              /* @__PURE__ */ a(
                gt,
                {
                  display: Ce ? "block" : "none",
                  x: H.y,
                  opacity: je ? 0.5 : 1,
                  y: s.barHeight / 2 + s.barHeight * H.index,
                  fill: Ot,
                  dx: Ae === "N/A" ? 20 : st,
                  dy: s.isLollipopChart ? -10 : 0,
                  verticalAnchor: "middle",
                  textAnchor: Ae === "N/A" ? "middle" : mt,
                  children: Ae
                }
              ),
              s.isLollipopChart && /* @__PURE__ */ a(
                gt,
                {
                  display: Ce ? "block" : "none",
                  x: H.y,
                  y: 0,
                  fill: "#000000",
                  dx: Lt,
                  textAnchor: ut,
                  verticalAnchor: "middle",
                  fontWeight: "normal",
                  children: ws(H.value) ? "" : Oe
                }
              ),
              N && !s.yAxis.hideLabel && /* @__PURE__ */ a(
                gt,
                {
                  x: s.yAxis.hideAxis ? 0 : 5,
                  y: G.height,
                  dy: 4,
                  verticalAnchor: "start",
                  textAnchor: "start",
                  children: s.runtime.yAxis.type === "date" ? m(g(Se)) : y ? Se : p(Se)
                }
              ),
              s.isLollipopChart && s.lollipopShape === "circle" && /* @__PURE__ */ a(
                "circle",
                {
                  display: _e,
                  cx: H.y,
                  cy: ye * H.index + L / 2,
                  r: B / 2,
                  fill: _t,
                  "data-tooltip-html": Tt,
                  "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
                  style: { filter: "unset", opacity: 1 }
                },
                `circle--${H.index}`
              ),
              s.isLollipopChart && s.lollipopShape === "square" && /* @__PURE__ */ a(
                "rect",
                {
                  display: _e,
                  x: H.y > 10 ? H.y - B / 2 : 0,
                  y: 0 - L / 2,
                  width: B,
                  height: B,
                  fill: _t,
                  "data-tooltip-html": Tt,
                  "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
                  style: { opacity: 1, filter: "unset" },
                  children: /* @__PURE__ */ a("animate", { attributeName: "height", values: `0, ${B}`, dur: "2.5s" })
                },
                `circle--${H.index}`
              ),
              I && /* @__PURE__ */ a(
                "path",
                {
                  stroke: te,
                  strokeWidth: "px",
                  d: `
                                M${wt} ${at - yt}
                                L${wt} ${at + yt}
                                M${wt} ${at}
                                L${bt} ${at}
                                M${bt} ${at - yt}
                                L${bt} ${at + yt} `
                },
                `confidence-interval-h-${at}-${ke[s.runtime.originalXAxis.dataKey]}`
              )
            ] }, `bar-sub-group-${G.index}-${G.x0}-${he}--${ce}`) }, `${G.index}--${ce}`);
          })
        },
        `bar-group-${G.index}-${G.x0}--${ne}`
      ))
    }
  ) });
}, Hu = {
  Vertical: fk,
  Horizontal: hk,
  StackedVertical: ck,
  StackedHorizontal: dk
}, pk = ({
  xScale: e,
  yScale: t,
  seriesScale: n,
  xMax: r,
  yMax: i,
  handleTooltipMouseOver: o,
  handleTooltipMouseOff: d,
  handleTooltipClick: c
}) => {
  const { transformedData: s, config: p, convertLineToBarGraph: m } = de.useContext(vt), g = {
    xScale: e,
    yScale: t,
    xMax: r,
    yMax: i,
    seriesScale: n,
    convertLineToBarGraph: m
  };
  return /* @__PURE__ */ a(Ur, { component: "BarChart", children: /* @__PURE__ */ a(Os.Provider, { value: g, children: /* @__PURE__ */ z(it, { left: parseFloat(p.runtime.yAxis.size), children: [
    /* @__PURE__ */ a(Hu.StackedVertical, {}),
    /* @__PURE__ */ a(Hu.StackedHorizontal, {}),
    /* @__PURE__ */ a(Hu.Vertical, {}),
    /* @__PURE__ */ a(Hu.Horizontal, {}),
    /* @__PURE__ */ a(
      _r,
      {
        display: p.tooltips.singleSeries ? "none" : "block",
        width: Number(r),
        height: Number(i),
        fill: "transparent",
        fillOpacity: 0.05,
        onMouseMove: (x) => o(x, s),
        onMouseOut: d,
        onClick: (x) => c(x, s)
      },
      "bars"
    )
  ] }) }) });
};
function ji() {
  return ji = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ji.apply(this, arguments);
}
function Fa(e) {
  var t = e.x1, n = e.x2, r = e.y1, i = e.y2;
  return {
    x1: r,
    x2: i,
    y1: t,
    y2: n
  };
}
function fg(e) {
  var t = e.left, n = t === void 0 ? 0 : t, r = e.top, i = r === void 0 ? 0 : r, o = e.className, d = e.max, c = e.min, s = e.firstQuartile, p = e.thirdQuartile, m = e.median, g = e.boxWidth, x = g === void 0 ? 10 : g, T = e.fill, y = e.fillOpacity, A = e.stroke, b = e.strokeWidth, v = e.rx, E = v === void 0 ? 2 : v, N = e.ry, R = N === void 0 ? 2 : N, L = e.valueScale, B = e.outliers, j = B === void 0 ? [] : B, Z = e.horizontal, re = e.medianProps, X = re === void 0 ? {} : re, se = e.maxProps, Y = se === void 0 ? {} : se, ie = e.minProps, I = ie === void 0 ? {} : ie, U = e.boxProps, ue = U === void 0 ? {} : U, te = e.outlierProps, J = te === void 0 ? {} : te, Q = e.container, G = Q === void 0 ? !1 : Q, ne = e.containerProps, H = ne === void 0 ? {} : ne, ce = e.children, ke = Z ? i : n, Se = ke + (x || 0) / 2, xe = L.range(), De = L(c ?? 0), je = L(s ?? 0), Ce = L(m ?? 0), ye = L(p ?? 0), Ee = L(d ?? 0), he = {
    valueRange: xe,
    center: Se,
    offset: ke,
    boxWidth: x,
    max: {
      x1: Se - (x || 0) / 4,
      x2: Se + (x || 0) / 4,
      y1: Ee,
      y2: Ee
    },
    maxToThird: {
      x1: Se,
      x2: Se,
      y1: Ee,
      y2: ye
    },
    median: {
      x1: ke,
      x2: ke + (x || 0),
      y1: Ce,
      y2: Ce
    },
    minToFirst: {
      x1: Se,
      x2: Se,
      y1: je,
      y2: De
    },
    min: {
      x1: Se - (x || 0) / 4,
      x2: Se + (x || 0) / 4,
      y1: De,
      y2: De
    },
    box: {
      x1: ke,
      x2: x || 0,
      y1: ye,
      y2: Math.abs(ye - je)
    },
    container: {
      x1: ke,
      x2: x || 0,
      y1: Math.min.apply(Math, xe),
      y2: Math.abs(xe[0] - xe[1])
    }
  };
  return Z && (he.max = Fa(he.max), he.maxToThird = Fa(he.maxToThird), he.box.y1 = je, he.box = Fa(he.box), he.median = Fa(he.median), he.minToFirst = Fa(he.minToFirst), he.min = Fa(he.min), he.container = Fa(he.container), he.container.y1 = Math.min.apply(Math, xe)), ce ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, ce(he)) : /* @__PURE__ */ Ve.createElement(it, {
    className: Cn("visx-boxplot", o)
  }, j.map(function(Be, $e) {
    var tt = Z ? L(Be) : Se, We = Z ? Se : L(Be);
    return /* @__PURE__ */ Ve.createElement("circle", ji({
      key: "visx-boxplot-outlier-" + $e,
      className: "visx-boxplot-outlier",
      cx: tt,
      cy: We,
      r: 4,
      stroke: A,
      strokeWidth: b,
      fill: T,
      fillOpacity: y
    }, J));
  }), /* @__PURE__ */ Ve.createElement("line", ji({
    className: "visx-boxplot-max",
    x1: he.max.x1,
    y1: he.max.y1,
    x2: he.max.x2,
    y2: he.max.y2,
    stroke: A,
    strokeWidth: b
  }, Y)), /* @__PURE__ */ Ve.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: he.maxToThird.x1,
    y1: he.maxToThird.y1,
    x2: he.maxToThird.x2,
    y2: he.maxToThird.y2,
    stroke: A,
    strokeWidth: b
  }), /* @__PURE__ */ Ve.createElement("rect", ji({
    className: "visx-boxplot-box",
    x: he.box.x1,
    y: he.box.y1,
    width: he.box.x2,
    height: he.box.y2,
    stroke: A,
    strokeWidth: b,
    fill: T,
    fillOpacity: y,
    rx: E,
    ry: R
  }, ue)), /* @__PURE__ */ Ve.createElement("line", ji({
    className: "visx-boxplot-median",
    x1: he.median.x1,
    y1: he.median.y1,
    x2: he.median.x2,
    y2: he.median.y2,
    stroke: A,
    strokeWidth: b
  }, X)), /* @__PURE__ */ Ve.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: he.minToFirst.x1,
    y1: he.minToFirst.y1,
    x2: he.minToFirst.x2,
    y2: he.minToFirst.y2,
    stroke: A,
    strokeWidth: b
  }), /* @__PURE__ */ Ve.createElement("line", ji({
    className: "visx-boxplot-min",
    x1: he.min.x1,
    y1: he.min.y1,
    x2: he.min.x2,
    y2: he.min.y2,
    stroke: A,
    strokeWidth: b
  }, I)), G && /* @__PURE__ */ Ve.createElement("rect", ji({
    x: he.container.x1,
    y: he.container.y1,
    width: he.container.x2,
    height: he.container.y2,
    fillOpacity: "0"
  }, H)));
}
fg.propTypes = {
  max: ze.number,
  min: ze.number,
  firstQuartile: ze.number,
  thirdQuartile: ze.number,
  median: ze.number,
  boxWidth: ze.number,
  fill: ze.string,
  fillOpacity: ze.oneOfType([ze.number, ze.string]),
  stroke: ze.string,
  strokeWidth: ze.oneOfType([ze.number, ze.string]),
  rx: ze.number,
  ry: ze.number,
  outliers: ze.arrayOf(ze.number),
  container: ze.bool,
  children: ze.func
};
const mk = (e, t, n, r, i, o, d, c, s) => `
    <div class="p-2  text-red" style="max-width: 300px; word-wrap: break-word; opacity:0.7; background: rgba(255, 255, 255, 0.9)">
      <div class="fw-bold" style="color: ${s};">
        ${c ? `${c} : ${t}` : t}
      </div>
      <div class="" style="background: ${s}; height: 2px;"></div>
        <strong>Key:</strong> ${n}<br/>
        <strong>${e.labels.q1}:</strong> ${r}<br/>
        <strong>${e.labels.q3}:</strong> ${i}<br/>
        <strong>${e.labels.iqr}:</strong> ${d}<br/>
        <strong>${e.labels.median}:</strong> ${o}
    </div>
  `, yk = (e) => {
  if (!e || e.length === 0)
    return {};
  const t = nt.sortBy(e), n = Es(t, 0.25) ?? 0, r = Es(t, 0.75) ?? 0, i = r - n, o = n - 1.5 * i, d = r + 1.5 * i, c = t.filter((s) => s >= o && s <= d);
  return {
    min: Sf(c),
    // Smallest non-outlier value
    max: rc(c),
    // Largest non-outlier value
    median: ay(t),
    // Median of all values
    firstQuartile: n,
    thirdQuartile: r,
    iqr: i
  };
}, gk = (e, t, n) => {
  const r = t.series.map((d) => d == null ? void 0 : d.dataKey), i = {}, o = n.filter((d) => d[t.xAxis.dataKey] === e);
  return r.forEach((d) => {
    i[d] = o.map((c) => c[d]);
  }), i;
}, vk = (e, t, n) => {
  const r = n - t, i = t - 1.5 * r, o = n + 1.5 * r;
  return e.filter((d) => d < i || d > o);
}, xk = (e, t, n) => {
  const r = n - t, i = t - 1.5 * r, o = n + 1.5 * r;
  return e.filter((d) => d >= i && d <= o);
}, bk = (e, t) => {
  const n = e.map((o) => o[t.xAxis.dataKey]), r = [], i = nt.uniq(n);
  return i && i.length > 0 && i.forEach((o) => {
    const d = gk(o, t, e), c = {}, s = {}, p = {}, m = {}, g = {}, x = {}, T = {}, y = {};
    Object.keys(d).forEach((A) => {
      const b = d[A], { firstQuartile: v, thirdQuartile: E, min: N, max: R, median: L, iqr: B } = yk(b);
      c[A] = vk(b, v, E).map(Number), s[A] = xk(b, v, E).map(Number), p[A] = L, m[A] = N, g[A] = R, x[A] = v, T[A] = E, y[A] = B;
    }), r.push({
      columnCategory: o,
      keyValues: d,
      columnOutliers: c,
      columnNonOutliers: s,
      min: m,
      max: g,
      q1: x,
      q3: T,
      median: p,
      iqr: y
    });
  }), r;
}, Sk = ({ xScale: e, yScale: t, seriesScale: n }) => {
  const { config: r, colorScale: i, seriesHighlight: o, transformedData: d } = de.useContext(vt), { boxplot: c } = r, s = `cdc-open-viz-tooltip-${r.runtime.uniqueId}`, p = e.bandwidth(), g = getComputedStyle(document.body).getPropertyValue("--cool-gray-90").trim(), x = Math.min(40, p);
  nt.get(Cr, [r.palette, 0], "#000");
  const T = bk(d, r);
  return /* @__PURE__ */ a(Ur, { component: "BoxPlot", children: /* @__PURE__ */ a(it, { left: Number(r.yAxis.size), className: "boxplot", children: T.map((y, A) => {
    const b = p - x, v = 4;
    return /* @__PURE__ */ a(
      it,
      {
        left: e(y.columnCategory) + (e.bandwidth() - n.bandwidth()) / 2,
        children: r.series.map((E, N) => {
          const R = r.legend.behavior === "highlight" && o.length > 0 && o.indexOf(E.dataKey) === -1, L = r.legend.behavior === "highlight" || o.length === 0 || o.indexOf(E.dataKey) !== -1, B = R ? 0.3 : 0.5;
          return /* @__PURE__ */ z(it, { children: [
            c.plotNonOutlierValues && y.columnNonOutliers[E.dataKey].map((j, Z) => /* @__PURE__ */ a(
              "circle",
              {
                display: L ? "block" : "none",
                cx: n(E.dataKey) + n.bandwidth() / 2,
                cy: t(j),
                r: v,
                opacity: B,
                fill: g,
                style: { stroke: g }
              },
              `boxplot-${A}--circle-${Z}`
            )),
            L && /* @__PURE__ */ a(
              fg,
              {
                display: L ? "block" : "none",
                "data-left": e(y.columnCategory) + r.yAxis.size + b / 2 + 0.5,
                min: Number(y.min[E.dataKey]),
                max: Number(y.max[E.dataKey]),
                left: n(E.dataKey),
                firstQuartile: y.q1[E.dataKey],
                thirdQuartile: y.q3[E.dataKey],
                median: y.median[E.dataKey],
                boxWidth: n.bandwidth(),
                fill: i(E.dataKey),
                fillOpacity: 1,
                stroke: g,
                valueScale: t,
                outliers: c.plotOutlierValues ? nt.map(y.columnOutliers[E.dataKey], (j) => j) : [],
                outlierProps: {
                  style: {
                    fill: g,
                    opacity: B,
                    stroke: g
                  }
                },
                medianProps: {
                  style: {
                    opacity: B,
                    stroke: g
                  }
                },
                boxProps: {
                  style: {
                    stroke: g,
                    strokeWidth: c.borders === "true" ? 1.5 : 0,
                    opacity: B
                  }
                },
                maxProps: {
                  style: {
                    opacity: B,
                    stroke: g
                  }
                },
                container: !0,
                containerProps: {
                  "data-tooltip-html": mk(
                    c,
                    y.columnCategory,
                    E.dataKey,
                    nt.round(y.q1[E.dataKey], r.dataFormat.roundTo),
                    nt.round(y.q3[E.dataKey], r.dataFormat.roundTo),
                    nt.round(y.median[E.dataKey], r.dataFormat.roundTo),
                    nt.round(y.iqr[E.dataKey], r.dataFormat.roundTo),
                    r.xAxis.label,
                    g
                  ),
                  "data-tooltip-id": s,
                  tabIndex: -1
                }
              },
              `box-plot-${A}-${E}`
            )
          ] }, `boxplotplot-${E.dataKey}-${N}`);
        })
      },
      `boxplotplot-${y.columnCategory}`
    );
  }) }, "boxplot-group") });
}, wk = ({ xScale: e, yScale: t }) => {
  const {
    transformedData: n,
    config: r,
    tableData: i,
    formatNumber: o,
    seriesHighlight: d,
    colorPalettes: c
  } = de.useContext(vt), s = 4.5, p = Object.keys(r.runtime.seriesLabels).length > 1, m = Object.entries(r.columns).filter(([x, T]) => T.tooltips).map(([x, T]) => [
    T.label || T.name,
    T.name,
    {
      addColPrefix: T.prefix,
      addColSuffix: T.suffix,
      addColRoundTo: T.roundToPlace,
      addColCommas: T.commas
    }
  ]), g = (x, T, y) => `<div>
    ${r.legend.showLegendValuesTooltip && r.runtime.seriesLabels && p ? `${r.runtime.seriesLabels[T] || ""}<br/>` : ""}
    ${r.xAxis.label}: ${o(x[r.xAxis.dataKey], "bottom")} <br/>
    ${r.yAxis.label}: ${o(x[T], "left")}<br/>
   ${m.map(
    ([A, b, v]) => `${A} : ${Zf(i[y][b], "left", !1, r, v)}<br/>`
  ).join("")}
</div>`;
  return /* @__PURE__ */ a(it, { className: "scatter-plot", left: r.yAxis.size, children: n.map((x, T) => r.runtime.seriesKeys.map((y, A) => {
    const b = r.legend.behavior === "highlight" && d.length > 0 && d.indexOf(y) === -1, v = r.legend.behavior === "highlight" || d.length === 0 || d.indexOf(y) !== -1, E = r != null && r.customColors ? r.customColors[A] : r.palette ? c[r.palette][A] : "#000";
    let N = {
      filter: "unset",
      opacity: 1,
      stroke: v ? "black" : ""
    };
    return /* @__PURE__ */ a(
      "circle",
      {
        r: s,
        cx: e(x[r.xAxis.dataKey]),
        cy: t(x[y]),
        fill: v ? E : "transparent",
        fillOpacity: b ? 0.25 : 1,
        style: N,
        "data-tooltip-html": g(x, y, T),
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
        tabIndex: -1
      },
      `${T}-${A}`
    );
  })) });
};
function kk({ height: e, xScale: t }) {
  const {
    transformedData: n,
    config: r,
    formatNumber: i,
    twoColorPalette: o,
    updateConfig: d,
    parseDate: c,
    formatDate: s,
    currentViewport: p
  } = de.useContext(vt), { barStyle: m, tipRounding: g, roundingStyle: x, twoColor: T } = r, y = de.useRef([]), [A, b] = de.useState(window.innerWidth), v = x === "standard" ? "8px" : x === "shallow" ? "5px" : x === "finger" ? "15px" : "0px";
  r.barStyle;
  const E = Number(r.xAxis.target), N = r.series[0].dataKey, R = Number(t.domain()[1]), B = n.some((te) => te[N] < 0) || E > 0 || t.domain()[0] < 0, j = r.barHasBorder === "true" ? 1 : 0, Z = r.lollipopSize === "large" ? 7 : r.lollipopSize === "medium" ? 6 : 5, re = r.lollipopSize === "large" ? 14 : r.lollipopSize === "medium" ? 12 : 10, X = Math.max(t(0), Math.min(t(E), t(R))), se = (te) => {
    if (te == null || m !== "rounded")
      return;
    let J = {};
    return te === "left" && (J = { borderRadius: `${v} 0 0 ${v}` }), te === "right" && (J = { borderRadius: `0 ${v} ${v} 0` }), g === "full" && (J = { borderRadius: v }), J;
  }, Y = {
    calculate: function() {
      const J = n[0][N] < E ? "left" : "right", Q = `${r.xAxis.targetLabel} ${i(r.xAxis.target || 0, "left")}`, G = yr(Q, "bold 20px sans-serif");
      let ne = r.isLollipopChart ? Z / 2 : Number(r.barHeight) / 2, H = 0, ce = 0, ke = !1;
      J === "right" && (H = -10, ke = G - H < X, ce = X - G), J === "left" && (H = 10, ke = t(R) - X > G + H, ce = X), this.text = Q, this.y = ne, this.x = ce, this.padding = H, this.showLabel = r.xAxis.showTargetLabel ? ke : !1;
    }
  };
  Y.calculate();
  const ie = de.useRef(null), I = gh(ie, {});
  de.useEffect(() => {
    const te = () => {
      var J;
      b(window.innerWidth), (J = y.current) == null || J.forEach((Q) => {
        !Q || !Q.style || (Q.style.transition = "none", Q.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", te), () => {
      window.removeEventListener("resize", te);
    };
  }, []);
  const [U, ue] = de.useState(!1);
  return de.useEffect(() => {
    I != null && I.isIntersecting && setTimeout(() => {
      ue(!0);
    }, 100);
  }, [I == null ? void 0 : I.isIntersecting, r.animate]), de.useEffect(() => {
    var te;
    (te = y.current) == null || te.forEach((J, Q) => {
      if (!(!J || !J.style)) {
        if (r.animate) {
          const G = E / R * 100;
          J.style.opacity = "0", J.style.transform = `translate(${G / 1.07}%) scale(0, 1)`, setTimeout(() => {
            J.style.opacity = "1", J.style.transform = "translate(0) scale(1)", J.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          J.style.transition = "none", J.style.opacity = "0";
        r.animate || (J.style.transition = "none", J.style.opacity = "1");
      }
    });
  }, [r.animate, r, U]), /* @__PURE__ */ z(Ur, { component: "Deviation Bar", children: [
    /* @__PURE__ */ z(it, { left: Number(r.xAxis.size), children: [
      n.map((te, J) => {
        const Q = Number(te[N]), G = r.isLollipopChart ? Z : Number(r.barHeight), ne = Number(r.barSpace), H = Math.abs(t(Q) - X), ce = t(Q), ke = Q > E ? X : ce, Se = Q < E ? "left" : "right";
        let xe = 0;
        xe = J !== 0 ? (ne + G + j) * J : xe;
        const De = (ne + G + j) * n.length;
        r.heights.horizontal = De;
        const Ce = yr(i(Q, "left"), "normal 16px sans-serif") < H - 6, ye = ce, Ee = xe + G / 2, he = ce, Be = xe + G / 2, $e = ce, tt = xe - G / 2, We = se(Se), [Fe, Je] = o[T.palette], Ke = { left: Fe, right: Je }, Ye = sl("#000", Ke[Se]);
        let Xe = Tk(r.isLollipopChart, Ce, re, Ye);
        const Ae = i(Q, "left"), Oe = r.runtime.yAxis.type === "date" ? s(c(n[J][r.runtime.originalXAxis.dataKey])) : n[J][r.runtime.originalXAxis.dataKey];
        let lt = r.runtime.yAxis.label ? `${r.runtime.yAxis.label}: ${Oe}` : Oe, ve = r.runtime.xAxis.label ? `${r.runtime.xAxis.label}: ${Ae}` : Ae;
        const mt = `<div>
          ${lt}<br />
          ${ve}
            </div>`;
        return /* @__PURE__ */ z(it, { children: [
          /* @__PURE__ */ a(
            "foreignObject",
            {
              ref: (ut) => {
                y.current[J] = ut;
              },
              x: ke,
              y: xe,
              width: H,
              height: G,
              "data-tooltip-html": mt,
              "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
              tabIndex: -1,
              children: /* @__PURE__ */ a(
                "div",
                {
                  style: {
                    width: H,
                    height: G,
                    border: `${j}px solid #333`,
                    backgroundColor: Ke[Se],
                    ...We
                  }
                }
              )
            }
          ),
          r.yAxis.displayNumbersOnBar && /* @__PURE__ */ a(gt, { verticalAnchor: "middle", x: ye, y: Ee, ...Xe[Se], children: i(te[N], "left") }),
          r.isLollipopChart && r.lollipopShape === "circle" && /* @__PURE__ */ a(
            "circle",
            {
              cx: he,
              cy: Be,
              r: re / 2,
              fill: Ke[Se],
              style: { filter: "unset", opacity: 1 }
            }
          ),
          r.isLollipopChart && r.lollipopShape === "square" && /* @__PURE__ */ a(
            "rect",
            {
              x: $e,
              y: tt,
              width: re,
              height: re,
              fill: Ke[Se],
              style: { opacity: 1, filter: "unset" }
            }
          )
        ] }, `deviation-bar-${r.orientation}-${N}-${J}`);
      }),
      Y.showLabel && /* @__PURE__ */ a(gt, { fontWeight: "bold", dx: Y.padding, verticalAnchor: "middle", x: Y.x, y: Y.y, children: Y.text }),
      B && /* @__PURE__ */ a(rn, { from: { x: X, y: 0 }, to: { x: X, y: e }, stroke: "#333", strokeWidth: 2 })
    ] }),
    /* @__PURE__ */ a("foreignObject", { y: e / 2, ref: ie })
  ] });
}
function Tk(e, t, n, r) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: n + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -n,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? r : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? r : "#000000"
    }
  };
}
const Ck = ({ xScale: e, yScale: t, height: n, width: r, handleTooltipMouseOver: i, handleTooltipMouseOff: o }) => {
  var y;
  const { transformedData: d, rawData: c, config: s, seriesHighlight: p } = de.useContext(vt), { xAxis: m, yAxis: g, legend: x, runtime: T } = s;
  return d && /* @__PURE__ */ a(Ur, { component: "ForecastingChart", children: /* @__PURE__ */ z(it, { className: "forecasting-items", left: Number(g.size), children: [
    (y = T.forecastingSeriesKeys) == null ? void 0 : y.map((A, b) => !A || !A.stages ? !1 : A.stages.map((v, E) => {
      var j;
      const { behavior: N } = x, R = c.filter((Z) => Z[A.stageColumn] === v.key);
      let L = N === "highlight" && p.length > 0 && p.indexOf(v.key) === -1, B = N === "highlight" || p.length === 0 || p.indexOf(v.key) !== -1;
      return /* @__PURE__ */ a(it, { className: `forecasting-areas-combo-${b}`, children: (j = A.confidenceIntervals) == null ? void 0 : j.map((Z, re) => {
        const X = Zu[v.color] || Cr[v.color] || !1, se = () => B && X[2] ? X[2] : "transparent", Y = () => B && X[1] ? X[1] : "transparent";
        if (!(Z.high === "" || Z.low === ""))
          return /* @__PURE__ */ z(it, { children: [
            /* @__PURE__ */ a(
              J0,
              {
                curve: Ku,
                data: R,
                fill: se(),
                opacity: L ? 0.1 : 0.5,
                x: (ie) => e(Date.parse(ie[m.dataKey])),
                y0: (ie) => t(ie[Z.low]),
                y1: (ie) => t(ie[Z.high])
              }
            ),
            re === 0 && /* @__PURE__ */ z(Ue, { children: [
              /* @__PURE__ */ a(jr, { data: R, x: (ie) => Number(e(Date.parse(ie[m.dataKey]))), y: (ie) => Number(t(ie[Z.high])), curve: Ku, stroke: Y(), strokeWidth: 1, strokeOpacity: 1 }),
              /* @__PURE__ */ a(jr, { data: R, x: (ie) => Number(e(Date.parse(ie[m.dataKey]))), y: (ie) => Number(t(ie[Z.low])), curve: Ku, stroke: Y(), strokeWidth: 1, strokeOpacity: 1 })
            ] })
          ] }, `forecasting-areas--stage-${v.key.replaceAll(" ", "-")}--group-${E}-${re}`);
      }) }, `forecasting-areas--stage-${v.key.replaceAll(" ", "-")}-${b}`);
    })),
    /* @__PURE__ */ a(it, { children: /* @__PURE__ */ a(_r, { width: Number(r), height: Number(n), fill: "transparent", fillOpacity: 0.05, onMouseMove: (A) => i(A, d), onMouseOut: o }, "bars") }, "tooltip-hover-section")
  ] }, "forecasting-items-wrapper") });
};
function Uc(e, t) {
  const n = e.series.every(({ type: T }) => T === "Bar"), r = e.series.every(({ type: T }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(T)), i = (T) => (y) => T.reduce((A, b) => isNaN(Number(y[b])) ? A : A + Number(y[b]), 0), o = (T) => {
    const y = e.runtime.series.find((A) => A.dataKey === T);
    return y != null && y.dynamicCategory ? y.originalDataKey : T;
  }, d = () => {
    let T = Math.max(
      ...t == null ? void 0 : t.map(
        (y) => Math.max(
          ...e.runtime.seriesKeys.map((A) => {
            const b = o(A);
            return Ua(y[b]) ? Number(p(y[b])) : 0;
          })
        )
      )
    );
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && n) && e.visualizationSubType === "stacked") {
      const y = t.map(i(e.runtime.seriesKeys)).filter((A) => !isNaN(A));
      T = Math.max(...y);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const y = t.map(i(e.runtime.seriesKeys));
      T = Math.max(...y);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (T = Math.max(
      ...t.map((y) => Ua(y[e.series.dataKey]) ? Number(p(y[e.series.dataKey])) : 0)
    )), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !n && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const y = t.map(i(e.runtime.barSeriesKeys)), A = Math.max(
        ...t.map((v) => Math.max(...e.runtime.lineSeriesKeys.map((E) => Number(p(v[E])))))
      ), b = Math.max(...y);
      T = Math.max(b, A);
    }
    return T;
  }, c = () => {
    const T = Math.min(
      ...t.map(
        (y) => Math.min(
          ...e.runtime.seriesKeys.map((A) => {
            const b = o(A);
            return Ua(y[b]) ? Number(p(y[b])) : 1 / 0;
          })
        )
      )
    );
    return String(T);
  }, s = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((T) => t.some((y) => y[o(T)] >= 0)) : !1, p = (T) => T === null || T === "" ? "" : typeof T == "string" ? T.replace(/[,$]/g, "") : T, m = Number(d()), g = Number(c()), x = s();
  return { minValue: g, maxValue: m, existPositiveValue: x, isAllLine: r };
}
function Th({ config: e, yMax: t = 0, data: n = [], updateConfig: r }) {
  var x, T, y, A;
  const i = e.visualizationType === "Combo" && e.orientation === "vertical", o = e.series && e.series.filter((b) => b.axis === "Right").map((b) => b.dataKey);
  let { minValue: d } = Uc(e, n);
  const c = (b) => {
    if (!b)
      return [0];
    let v = [];
    return b.map((E, N) => v = [...v, ...n.map((R) => Number(R[E]))]), v;
  };
  let s = Math.max.apply(null, c(o));
  e.yAxis.rightMax > s && (s = e.yAxis.rightMax), e.yAxis.rightMin < d && (d = e.yAxis.rightMin);
  const p = ((T = (x = e.runtime) == null ? void 0 : x.barSeriesKeys) == null ? void 0 : T.length) > 0, m = ((A = (y = e.runtime) == null ? void 0 : y.lineSeriesKeys) == null ? void 0 : A.length) > 0;
  return (p || m) && d > 0 && (d = 0), { yScaleRight: In({
    domain: [d, s],
    range: [t, 0]
  }), hasRightAxis: i };
}
const Ak = (e) => {
  const { preliminaryData: t, data: n, stroke: r, strokeWidth: i, handleLineType: o, lineType: d, seriesKey: c } = e, s = t.filter(
    (x) => x.seriesKey && x.column && x.value && x.type && x.style && x.type === "effect"
  ), p = (x) => s.find(
    (T) => T.seriesKey === c && x[T.column] === T.value && T.type === "effect" && T.style !== "Open Circles"
  );
  let m = [];
  const g = (x) => ({
    stroke: r,
    strokeWidth: i,
    strokeDasharray: x
  });
  return n.forEach((x, T) => {
    let y = p(x), A = g(o(y ? y.style : d));
    m.push(A), y && T > 0 && (m[T - 1] = g(o(y.style)));
  }), m;
}, Lk = (e, t, n) => {
  const r = e == null ? void 0 : e.filter((o) => o.style.includes("Circles") && o.type === "effect").map((o) => ({
    column: o.column,
    value: o.value,
    seriesKey: o.seriesKey,
    circleSize: o.circleSize,
    style: o.style
  })), i = [];
  return t.forEach((o) => {
    r.forEach((d) => {
      if (o[d.column] === d.value && d.seriesKey === n && o[n] && d.style === "Open Circles") {
        const c = {
          data: o,
          size: d.circleSize,
          isFilled: !1
        };
        i.push(c);
      }
      if ((!d.value || o[d.column] === d.value) && d.seriesKey === n && o[n] && d.style === "Filled Circles") {
        const c = {
          data: o,
          size: d.circleSize,
          isFilled: !0
        };
        i.push(c);
      }
    });
  }), i;
}, Lc = (e) => !isNaN(parseFloat(e)) && isFinite(e), Ek = (e, t, n) => {
  let r = "0";
  const i = {
    data: { 0: [] },
    style: ""
  };
  if (!e.length)
    return i;
  const o = e[0], d = (s) => {
    if (!(s.type === "effect" || s.hideLineStyle))
      return s.type == "suppression" && s.value === o[t] && (!s.column || s.column === t);
  }, c = n.find(d);
  if (c && c.style) {
    const s = { ...o, [t]: 0 };
    i.data[r].push(s), i.style = c.style;
    let p = 1;
    for (; p < e.length && !Lc(e[p][t]); )
      p++;
    p < e.length && i.data[r].push(e[p]);
  } else
    i.data[r].push(o);
  return i;
}, Rk = (e, t, n) => {
  let r = "0";
  const i = {
    data: { 0: [] },
    style: ""
  };
  let o = -1;
  return n == null || n.forEach((d) => {
    if (d.type !== "effect" && e[e.length - 1][t] === d.value && d.style && (!d.column || d.column === t) && d.type == "suppression" && !d.hideLineStyle) {
      const c = e.length - 1, s = { ...e[c], [t]: 0 };
      i.data[r].push(s);
      let p = c - 1;
      for (; p >= 0 && !Lc(e[p][t]); )
        p--;
      p >= 0 && o !== p && (i.data[r].push(e[p]), o = p), i.style = d.style;
    }
  }), i;
};
function Nk(e, t, n) {
  let r = {
    data: {},
    style: ""
  }, i = 1;
  return e.forEach((o, d) => {
    n.forEach((c) => {
      const s = c.value;
      if (o[t] === s) {
        let p = null, m = null;
        for (let g = d - 1; g >= 0; g--)
          if (Lc(e[g][t])) {
            p = e[g];
            break;
          }
        for (let g = d + 1; g < e.length; g++)
          if (Lc(e[g][t])) {
            m = e[g];
            break;
          }
        p && m && (r.style = c.style, r.data[i++] = [p, m]);
      }
    });
  }), r;
}
const Pk = (e, t, n, r) => {
  const i = Ek(e, t, n), o = Rk(e, t, n), d = Nk(e, t, n);
  return [i, d, o];
};
var Dk = ["children", "className", "top", "left", "size"];
function Kf() {
  return Kf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Kf.apply(this, arguments);
}
function _k(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Ch(e) {
  var t = e.children, n = e.className, r = e.top, i = e.left, o = e.size, d = _k(e, Dk), c = _g();
  return c.type(m0), (typeof o == "number" || o) && c.size(o), t ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, t({
    path: c
  })) : /* @__PURE__ */ Ve.createElement(qf, {
    top: r,
    left: i
  }, /* @__PURE__ */ Ve.createElement("path", Kf({
    className: Cn("visx-glyph-cross", n),
    d: c() || ""
  }, d)));
}
Ch.propTypes = {
  children: ze.func,
  className: ze.string,
  top: ze.number,
  left: ze.number,
  size: ze.oneOfType([ze.number, ze.func])
};
const Ok = [
  Tm,
  Cm,
  Qu,
  Am,
  Qu,
  Ch,
  ({ fill: e }) => /* @__PURE__ */ a(qf, { children: /* @__PURE__ */ a(gt, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle", children: "⬟" }) })
], df = (e) => {
  var re, X, se, Y, ie, I, U;
  const {
    config: t,
    d: n,
    tableData: r,
    displayArea: i,
    seriesKey: o,
    tooltipData: d,
    xScale: c,
    yScale: s,
    colorScale: p,
    parseDate: m,
    yScaleRight: g,
    data: x,
    circleData: T,
    dataIndex: y,
    mode: A,
    seriesIndex: b
  } = e, { lineDatapointStyle: v, visual: E } = t, N = (re = t == null ? void 0 : t.series.filter((ue) => ue.dataKey === o)) == null ? void 0 : re[0], R = Ok[t.visual.lineDatapointSymbol === "standard" && b < E.maximumShapeAmount ? b : 0], L = b === 4, B = (ue, te) => `translate(${te}, ${ue})${L ? " rotate(180)" : ""}`, j = (ue, te, J, Q, G) => {
    const ne = J.runtime.seriesLabels || [], H = J.runtime.seriesLabelsAll || [];
    let ce = ue ? te(ne[Q] || H[b]) : " transparent";
    return J.lineDatapointColor === "Lighter than Line" && ce !== "transparent" && ce && (ce = Gi(ce).brighten(1)), ce;
  }, Z = (ue) => (t.xAxis.type === "categorical" ? c(ue) : c(m(ue))) + (c.bandwidth ? c.bandwidth() / 2 : 0);
  if (A === "ALWAYS_SHOW_POINTS" && v !== "hidden" && v === "always show") {
    if ((T == null ? void 0 : T.some(
      (Q) => Q[t.xAxis.dataKey] === n[t.xAxis.dataKey] && Q[o] === n[o]
    )) || !N || E.maximumShapeAmount === b && E.lineDatapointSymbol === "standard")
      return /* @__PURE__ */ a(Ue, {});
    const te = Z(n[t.xAxis.dataKey]), J = N.axis === "Right" ? g(n[N.dataKey]) : s(n[N.dataKey]);
    return /* @__PURE__ */ a("g", { transform: B(J, te), children: /* @__PURE__ */ a(
      R,
      {
        opacity: n[o] ? 1 : 0,
        fillOpacity: 1,
        fill: j(i, p, t, o),
        style: { filter: "unset", opacity: 1 }
      }
    ) });
  }
  if (A === "HOVER_POINTS" && v === "hover") {
    if (!d || !o || !d.data)
      return;
    let ue = (se = (X = d == null ? void 0 : d.data) == null ? void 0 : X[0]) == null ? void 0 : se[1];
    if (!ue)
      return;
    let te, J = d.data.filter((ce) => ce[0] === o), Q = (Y = J == null ? void 0 : J[0]) == null ? void 0 : Y[0], G = (ie = J == null ? void 0 : J[0]) == null ? void 0 : ie[2];
    const ne = t.runtime.series.find((ce) => ce.dynamicCategory), H = (ne == null ? void 0 : ne.originalDataKey) ?? o;
    return Q ? (te = (I = r == null ? void 0 : r.find((ce) => {
      const ke = ne == null ? void 0 : ne.dynamicCategory;
      return ce[t.xAxis.dataKey] === ue ? ke ? ce[ke] === Q : !0 : !1;
    })) == null ? void 0 : I[H], d == null ? void 0 : d.data.map((ce, ke) => {
      if (isNaN(te))
        return /* @__PURE__ */ a(Ue, {});
      if ((T == null ? void 0 : T.some((je) => je[t.xAxis.dataKey] === ue)) || !te || E.maximumShapeAmount === b && E.lineDatapointSymbol === "standard")
        return /* @__PURE__ */ a(Ue, {});
      const xe = G === "right" ? g(te) : s(te), De = Z(ue);
      return /* @__PURE__ */ a("g", { transform: B(xe, De), children: /* @__PURE__ */ a(
        R,
        {
          size: 55,
          opacity: 1,
          fillOpacity: 1,
          fill: j(i, p, t, Q),
          style: { filter: "unset", opacity: 1 }
        }
      ) });
    })) : void 0;
  }
  if (A === "ISOLATED_POINTS" && ((te, J) => {
    const Q = x[te], G = x[te - 1] || {}, ne = x[te + 1] || {};
    if (T.some((xe) => (xe == null ? void 0 : xe.data[J]) === Q[J]))
      return !1;
    const ce = te === 0 && !ne[J], ke = te === x.length - 1 && !G[J], Se = te > 0 && te < x.length - 1 && Q[J] && !G[J] && !ne[J];
    return ce || ke || Se;
  })(y, o)) {
    const te = (N == null ? void 0 : N.axis) === "Right" ? g(n[N == null ? void 0 : N.dataKey]) : s(n[N == null ? void 0 : N.dataKey]), J = Z(n[(U = t.xAxis) == null ? void 0 : U.dataKey]), Q = p(t.runtime.seriesLabelsAll[b]);
    return /* @__PURE__ */ a("g", { transform: B(te, J), children: /* @__PURE__ */ a(R, { size: 124, stroke: Q, fill: Q }) });
  }
  return null;
}, Mk = (e) => {
  var m, g;
  const { config: t, xScale: n, yScale: r, parseDate: i } = e;
  if (!((m = t == null ? void 0 : t.runtime) != null && m.series))
    return;
  const o = (x) => {
    if (t.xAxis.type === "date")
      return i(x).getTime();
    if (t.xAxis.type === "date-time")
      return new Date(x);
    if (t.xAxis.type === "categorical")
      return x;
  }, d = (x) => n.bandwidth ? n.bandwidth() / 2 + Number(x) : Number(x), c = (x) => {
    var T;
    return (T = Object.values(t.columns)) == null ? void 0 : T.filter((y) => y.tooltips).map((y) => `
        <li className='tooltip-body'>
          <strong>${y.label || y.name}</strong>: ${x[y.name]}
        </li>`).join(" ");
  }, s = (x) => `<ul> ${c(x)} </ul>`, p = (g = t.runtime) == null ? void 0 : g.series.map((x) => t.data.map((T, y) => {
    let A = T[x.dataKey], b = T[t.xAxis.dataKey];
    return /* @__PURE__ */ a(Ve.Fragment, { children: /* @__PURE__ */ a(it, { left: Number(t.runtime.yAxis.size), children: A && /* @__PURE__ */ z(Ue, { children: [
      /* @__PURE__ */ a(
        "circle",
        {
          "data-tooltip-html": s(T),
          "data-tooltip-id": "bump-chart",
          r: 10,
          cx: Number(d(n(o(b)))),
          cy: Number(r(A)),
          stroke: "#CACACA",
          strokeWidth: 1,
          fill: "#E5E4E2"
        },
        `bump-circle-${A}-${y}`
      ),
      A.toString().length === 2 ? (
        // prettier-ignore
        /* @__PURE__ */ a(
          "text",
          {
            x: Number(d(n(o(b)))) - 7,
            y: Number(r(A)) + 4,
            fill: "#000000",
            fontSize: 11.5,
            children: A
          }
        )
      ) : (
        // prettier-ignore
        /* @__PURE__ */ a(
          "text",
          {
            x: Number(d(n(o(b)))) - 4,
            y: Number(r(A)) + 4,
            fill: "#000000",
            fontSize: 11.5,
            children: A
          }
        )
      )
    ] }) }) }, `bump-circle-${A}-${y}`);
  }));
  return /* @__PURE__ */ a(Ue, { children: p });
}, mm = (e) => {
  var ie;
  const {
    getXAxisData: t,
    getYAxisData: n,
    handleTooltipClick: r,
    handleTooltipMouseOff: i,
    handleTooltipMouseOver: o,
    tooltipData: d,
    xMax: c,
    xScale: s,
    yMax: p,
    yScale: m
  } = e, { colorScale: g, config: x, formatNumber: T, handleLineType: y, parseDate: A, seriesHighlight: b, tableData: v, transformedData: E, updateConfig: N, brushConfig: R, clean: L } = de.useContext(vt), { yScaleRight: B } = Th({ config: x, yMax: p, data: E, updateConfig: N });
  if (!o)
    return;
  const { lineDatapointStyle: j, showLineSeriesLabels: Z, legend: re } = x;
  let X = E, se = v;
  R.data.length > 0 && ((ie = x.brush) != null && ie.active) && (X = L(R.data), se = L(R.data));
  const Y = (I) => s(t(I)) + (s.bandwidth ? s.bandwidth() / 2 : 0);
  return /* @__PURE__ */ z(Ur, { component: "LineChart", children: [
    /* @__PURE__ */ z(it, { left: Number(x.runtime.yAxis.size), children: [
      " ",
      (x.runtime.lineSeriesKeys || x.runtime.seriesKeys).map((I, U) => {
        var Se;
        const ue = x.runtime.series.find((xe) => xe.dataKey === I), te = ue.type, J = ue.axis || "left", Q = re.behavior === "highlight" || b.length === 0 || b.indexOf(I) !== -1, G = Pk(
          v,
          I,
          x.preliminaryData,
          x.xAxis.dataKey
        ), ne = ((Se = x == null ? void 0 : x.preliminaryData) == null ? void 0 : Se.filter((xe) => xe.style && !xe.style.includes("Circles")).length) > 0, H = ue.dynamicCategory ? X.filter((xe) => xe[ue.dynamicCategory] === I) : X, ce = ue.dynamicCategory ? ue.originalDataKey : I, ke = Lk(x == null ? void 0 : x.preliminaryData, se, ce);
        return /* @__PURE__ */ z(
          it,
          {
            opacity: re.behavior === "highlight" && b.length > 0 && b.indexOf(I) === -1 ? 0.5 : 1,
            display: re.behavior === "highlight" || b.length === 0 && !re.dynamicLegend || b.indexOf(I) !== -1 ? "block" : "none",
            children: [
              /* @__PURE__ */ a(
                _r,
                {
                  width: Number(c),
                  height: Number(p),
                  fill: "transparent",
                  fillOpacity: 0.05,
                  onMouseMove: (xe) => o(xe, v),
                  onMouseOut: i,
                  onClick: (xe) => r(xe, X)
                },
                "bars"
              ),
              H.map((xe, De) => Ua(xe[ce]) && /* @__PURE__ */ z(Ve.Fragment, { children: [
                x.labels && /* @__PURE__ */ a(
                  gt,
                  {
                    x: Y(xe),
                    y: J === "Right" ? B(n(xe, ce)) : m(n(xe, ce)),
                    fill: "#000",
                    textAnchor: "middle",
                    children: T(xe[ce], "left")
                  }
                ),
                j === "always show" && /* @__PURE__ */ a(
                  df,
                  {
                    mode: "ALWAYS_SHOW_POINTS",
                    dataIndex: De,
                    circleData: ke,
                    tableData: v,
                    data: H,
                    d: xe,
                    config: x,
                    seriesKey: ce,
                    displayArea: Q,
                    tooltipData: d,
                    xScale: s,
                    yScale: m,
                    colorScale: g,
                    parseDate: A,
                    yScaleRight: B,
                    seriesAxis: J,
                    seriesIndex: U
                  },
                  `line-circle--${De}`
                ),
                /* @__PURE__ */ a(
                  df,
                  {
                    mode: "ISOLATED_POINTS",
                    seriesIndex: U,
                    dataIndex: De,
                    tableData: v,
                    circleData: ke,
                    data: H,
                    d: xe,
                    config: x,
                    seriesKey: ce,
                    displayArea: Q,
                    tooltipData: d,
                    xScale: s,
                    yScale: m,
                    colorScale: g,
                    parseDate: A,
                    yScaleRight: B,
                    seriesAxis: J
                  },
                  `isolated-circle-${De}`
                )
              ] }, `series-${I}-point-${De}`)),
              /* @__PURE__ */ a(Ue, { children: j === "hover" && /* @__PURE__ */ a(
                df,
                {
                  seriesIndex: U,
                  tableData: v,
                  dataIndex: 0,
                  mode: "HOVER_POINTS",
                  circleData: ke,
                  data: H,
                  config: x,
                  seriesKey: I,
                  displayArea: Q,
                  tooltipData: d,
                  xScale: s,
                  yScale: m,
                  colorScale: g,
                  parseDate: A,
                  yScaleRight: B,
                  seriesAxis: J
                }
              ) }),
              ne ? /* @__PURE__ */ z(Ue, { children: [
                /* @__PURE__ */ a(
                  By,
                  {
                    curve: Ia[ue.lineType],
                    segments: H.map((xe) => [xe]),
                    segmentation: "x",
                    x: (xe) => Y(xe),
                    y: (xe) => J === "Right" ? B(n(xe, ce)) : m(Number(n(xe, ce))),
                    styles: Ak({
                      preliminaryData: x.preliminaryData,
                      data: se,
                      stroke: g(x.runtime.seriesLabels[I]),
                      strokeWidth: ue.weight || 2,
                      handleLineType: y,
                      lineType: te,
                      seriesKey: I
                    }),
                    defined: (xe, De) => xe[I] !== "" && xe[I] !== null && xe[I] !== void 0
                  }
                ),
                G.map((xe, De) => Object.entries(xe.data).map(([je, Ce]) => {
                  var ye;
                  return /* @__PURE__ */ a(
                    jr,
                    {
                      data: Ce,
                      x: (Ee) => Y(Ee),
                      y: (Ee) => J === "Right" ? B(n(Ee, I)) : m(Number(n(Ee, I))),
                      stroke: g(x.runtime.seriesLabels[I]),
                      strokeWidth: ((ye = ue[0]) == null ? void 0 : ye.weight) || 2,
                      strokeOpacity: 1,
                      shapeRendering: "geometricPrecision",
                      strokeDasharray: y(xe.style),
                      defined: (Ee, he) => Ee[I] !== "" && Ee[I] !== null && Ee[I] !== void 0
                    },
                    De
                  );
                }))
              ] }) : /* @__PURE__ */ z(Ue, { children: [
                x.confidenceKeys && x.series.map((xe, De) => xe.dynamicCategory ? [...new Set(X.map((Ce) => Ce[xe.dynamicCategory]))].map((Ce, ye) => {
                  const Ee = X.filter((he) => he[xe.dynamicCategory] === Ce);
                  return /* @__PURE__ */ a(
                    Df,
                    {
                      data: Ee,
                      x: (he) => Y(he),
                      y0: (he) => m(he[x.confidenceKeys.lower]),
                      y1: (he) => m(he[x.confidenceKeys.upper]),
                      opacity: 0.5,
                      fill: g(Ce),
                      yScale: m,
                      curve: Ia[xe.lineType]
                    },
                    `area-closed-${De}-${ye}`
                  );
                }) : /* @__PURE__ */ a(
                  Df,
                  {
                    data: X,
                    x: (je) => Y(je),
                    y0: (je) => m(je[x.confidenceKeys.lower]),
                    y1: (je) => m(je[x.confidenceKeys.upper]),
                    opacity: 0.5,
                    fill: g(
                      x.runtime.seriesLabels ? x.runtime.seriesLabels[xe.dataKey] : xe.dataKey
                    ),
                    yScale: m,
                    curve: Ia[xe.lineType]
                  },
                  `area-closed-${De}`
                )),
                /* @__PURE__ */ a(
                  jr,
                  {
                    curve: Ia[ue.lineType],
                    data: x.visualizationType == "Bump Chart" ? H : x.xAxis.type === "date-time" || x.xAxis.type === "date" ? H.sort((xe, De) => {
                      let je = t(xe), Ce = t(De);
                      return je < Ce ? -1 : Ce < je ? 1 : 0;
                    }) : H,
                    x: (xe) => Y(xe),
                    y: (xe) => J === "Right" ? B(n(xe, ce)) : m(Number(n(xe, ce))),
                    stroke: g(x.runtime.seriesLabels[I]),
                    strokeWidth: ue.weight || 2,
                    strokeOpacity: 1,
                    shapeRendering: "geometricPrecision",
                    strokeDasharray: te ? y(te) : 0,
                    defined: (xe, De) => xe[ce] !== "" && xe[ce] !== null && xe[ce] !== void 0
                  }
                )
              ] }),
              ke.map((xe, De) => /* @__PURE__ */ a(
                "circle",
                {
                  cx: Y(xe.data),
                  cy: J === "Right" ? B(n(xe.data, ce)) : m(Number(n(xe.data, ce))),
                  r: xe.size,
                  strokeWidth: ue.weight || 2,
                  stroke: g ? g(x.runtime.seriesLabels[I]) : "#000",
                  fill: xe.isFilled ? g ? g(x.runtime.seriesLabels[I]) : "#000" : "#fff"
                },
                De
              )),
              x.animate && /* @__PURE__ */ a(
                jr,
                {
                  className: "animation",
                  curve: Ia[ue.lineType],
                  data: H,
                  x: (xe) => Y(xe),
                  y: (xe) => J === "Right" ? B(n(xe, ce)) : m(Number(n(xe, ce))),
                  stroke: "#fff",
                  strokeWidth: 3,
                  strokeOpacity: 1,
                  shapeRendering: "geometricPrecision",
                  strokeDasharray: te ? y(te) : 0,
                  defined: (xe, De) => xe[I] !== "" && xe[I] !== null && xe[I] !== void 0
                }
              ),
              Z && (x.runtime.lineSeriesKeys || x.runtime.seriesKeys).map((xe) => {
                let De;
                for (let je = H.length - 1; je >= 0; je--)
                  if (H[je][xe]) {
                    De = H[je];
                    break;
                  }
                return De ? /* @__PURE__ */ a(
                  gt,
                  {
                    x: Y(De) + 5,
                    y: m(n(De, xe)),
                    alignmentBaseline: "middle",
                    fill: x.colorMatchLineSeriesLabels && g ? g(x.runtime.seriesLabels[xe] || xe) : "black",
                    children: x.runtime.seriesLabels[xe] || xe
                  }
                ) : /* @__PURE__ */ a(Ue, {});
              })
            ]
          },
          `series-${I}-${U}`
        );
      }),
      x.legend.dynamicLegend && b.length === 0 && /* @__PURE__ */ a(gt, { x: c / 2, y: p / 2, fill: "black", textAnchor: "middle", color: "black", children: x.legend.dynamicLegendChartMessage })
    ] }),
    x.visualizationType === "Bump Chart" && /* @__PURE__ */ a(Mk, { config: x, xScale: s, yScale: m })
  ] });
}, Fk = ({
  xScale: e,
  yScale: t,
  config: n,
  height: r,
  width: i,
  handleTooltipMouseOff: o,
  handleTooltipMouseOver: d,
  forestPlotRightLabelRef: c
}) => {
  const { rawData: s, updateConfig: p } = de.useContext(vt), { forestPlot: m } = n, g = n.xAxis.tickWidthMax + 10, [x, T] = de.useState(!1);
  de.useEffect(() => {
    try {
      const R = ["estimateField", "lower", "upper", "estimateRadius"], L = n, B = 10;
      for (let j = 0; j < B; j++)
        R.forEach((Z) => {
          var re;
          n.forestPlot[Z] && n.forestPlot[Z] !== ((re = L.columns[n.forestPlot[`additionalColumn${j}`]]) == null ? void 0 : re.name) && (delete L.columns[`additionalColumn${j}`], L.columns[n.forestPlot[Z]] = {}, L.columns[n.forestPlot[Z]].dataKey = L.forestPlot[Z], L.columns[n.forestPlot[Z]].name = L.forestPlot[Z], L.columns[n.forestPlot[Z]].dataTable = !0, L.columns[n.forestPlot[Z]].tooltips = !0, L.columns[n.forestPlot[Z]].label = L.forestPlot[Z]);
        });
      n.forestPlot.radius.scalingColumn && (L.columns[n.forestPlot.radius.scalingColumn] = {}, L.columns[n.forestPlot.radius.scalingColumn].dataKey = L.forestPlot.radius.scalingColumn, L.columns[n.forestPlot.radius.scalingColumn].name = L.forestPlot.radius.scalingColumn, L.columns[n.forestPlot.radius.scalingColumn].label = L.forestPlot.radius.scalingColumn, L.columns[n.forestPlot.radius.scalingColumn].dataTable = !0, L.columns[n.forestPlot.radius.scalingColumn].tooltips = !0), L.table.showVertical && (L.table.indexLabel = n.xAxis.dataKey), p(L);
    } catch (R) {
      console.log(R.message);
    }
  }, []), de.useEffect(() => {
    !x && n.forestPlot.type === "Logarithmic" && (p({
      ...n,
      dataFormat: {
        ...n.dataFormat,
        roundTo: 2
      }
    }), T(!0));
  }, [n.forestPlot.type]);
  const y = n.data.find((R) => R[n.xAxis.dataKey] === n.forestPlot.pooledResult.column), A = y ? [
    { x: e(y[n.forestPlot.lower]), y: r - Number(n.forestPlot.rowHeight) },
    {
      x: e(y[n.forestPlot.estimateField]),
      y: r - m.pooledResult.diamondHeight - Number(n.forestPlot.rowHeight)
    },
    { x: e(y[n.forestPlot.upper]), y: r - Number(n.forestPlot.rowHeight) },
    {
      x: e(y[n.forestPlot.estimateField]),
      y: r + m.pooledResult.diamondHeight - Number(n.forestPlot.rowHeight)
    },
    { x: e(y[n.forestPlot.lower]), y: r - Number(n.forestPlot.rowHeight) }
  ] : [], b = n.forestPlot.rowHeight, v = [
    { x: 0, y: b },
    { x: i, y: b }
  ], E = [
    { x: 0, y: r },
    { x: i, y: r }
  ], N = Object.entries(n.columns).map((R) => R[1]).filter((R) => R.forestPlot === !0);
  return /* @__PURE__ */ z(Ue, { children: [
    /* @__PURE__ */ z(it, { width: i, children: [
      m.title && /* @__PURE__ */ a(
        gt,
        {
          className: "forest-plot--title",
          x: m.type === "Linear" ? e(0) : e(1),
          y: 0,
          textAnchor: "middle",
          verticalAnchor: "start",
          fill: "black",
          children: m.title
        }
      ),
      m.lineOfNoEffect.show && m.type === "Linear" && /* @__PURE__ */ a(
        rn,
        {
          from: { x: e(0), y: 0 + b },
          to: { x: e(0), y: r },
          className: "forestplot__line-of-no-effect",
          stroke: m.regression.baseLineColor || "black"
        }
      ),
      m.lineOfNoEffect.show && m.type === "Logarithmic" && /* @__PURE__ */ a(
        rn,
        {
          from: { x: e(1), y: 0 + b },
          to: { x: e(1), y: r },
          className: "forestplot__line-of-no-effect",
          stroke: m.regression.baseLineColor || "black"
        }
      ),
      s.map((R, L) => {
        const B = In({
          domain: s.map((Y) => Y[m.radius.scalingColumn]),
          range: [m.radius.min, m.radius.max]
        }), j = m.radius.scalingColumn !== "" ? B(s[L][m.radius.scalingColumn]) : 4, Z = m.colors.shape ? m.colors.shape : "black", re = m.colors.line ? m.colors.line : "black", X = 4;
        return R[n.xAxis.dataKey] === m.pooledResult.column ? /* @__PURE__ */ a(
          jr,
          {
            data: A,
            x: (Y) => Y.x,
            y: (Y) => Y.y - Dc / 2,
            stroke: "black",
            strokeWidth: 2,
            fill: "black",
            curve: Af
          }
        ) : /* @__PURE__ */ z(it, { children: [
          /* @__PURE__ */ a(
            "path",
            {
              stroke: re,
              strokeWidth: 1,
              className: "lower-ci",
              d: `
                    M${e(R[m.lower])} ${t(L) - Number(X)}
                    L${e(R[m.lower])} ${t(L) + Number(X)}
                `
            }
          ),
          /* @__PURE__ */ a(
            "path",
            {
              stroke: re,
              strokeWidth: 1,
              className: "upper-ci",
              d: `
                    M${e(R[m.upper])} ${t(L) - Number(X)}
                    L${e(R[m.upper])} ${t(L) + Number(X)}
                `
            }
          ),
          /* @__PURE__ */ a(
            "line",
            {
              stroke: re,
              className: `line-${R[n.yAxis.dataKey]}`,
              x1: e(R[m.lower]),
              x2: e(R[m.upper]),
              y1: t(L),
              y2: t(L)
            },
            L
          ),
          m.shape === "circle" && /* @__PURE__ */ a(
            iv,
            {
              className: "forest-plot--circle",
              cx: e(Number(R[m.estimateField])),
              cy: t(L),
              r: m.radius.scalingColumn !== "" ? B(s[L][m.radius.scalingColumn]) : 4,
              fill: Z,
              style: { opacity: 1, filter: "unset" }
            }
          ),
          m.shape === "square" && /* @__PURE__ */ a(
            "rect",
            {
              className: "forest-plot--square",
              x: e(Number(R[m.estimateField])),
              y: t(L) - j / 2,
              width: j,
              height: j,
              fill: Z,
              style: { opacity: 1, filter: "unset" }
            }
          ),
          m.shape === "text" && /* @__PURE__ */ a(
            gt,
            {
              className: "forest-plot--text",
              x: e(Number(R[m.estimateField])),
              y: t(L),
              textAnchor: "middle",
              verticalAnchor: "middle",
              fill: Z,
              children: R[m.estimateField]
            }
          )
        ] });
      }),
      A && m.regression.showDiamond && /* @__PURE__ */ a(
        jr,
        {
          data: A,
          x: (R) => R.x,
          y: (R) => R.y,
          stroke: "black",
          strokeWidth: 2,
          fill: m.regression.baseLineColor,
          curve: Af
        }
      ),
      m.regression.description && /* @__PURE__ */ a(
        gt,
        {
          x: 0 - Number(n.xAxis.size),
          width: i,
          y: r - n.forestPlot.rowHeight - Number(m.rowHeight) / 3,
          verticalAnchor: "start",
          textAnchor: "start",
          style: { fontWeight: "bold", fontSize: 12 },
          children: m.regression.description
        }
      ),
      /* @__PURE__ */ a(
        _r,
        {
          className: "forest-plot-tooltip-area",
          width: i,
          height: r,
          fill: "transparent",
          fillOpacity: 0.5,
          onMouseMove: (R) => d(R, s),
          onMouseOut: o
        },
        "forest-plot-tooltip-area"
      )
    ] }),
    /* @__PURE__ */ a(
      rn,
      {
        from: v[0],
        to: v[1],
        style: { stroke: "black", strokeWidth: 2 },
        className: "forestplot__top-line"
      }
    ),
    /* @__PURE__ */ a(
      rn,
      {
        from: E[0],
        to: E[1],
        style: { stroke: "black", strokeWidth: 2 },
        className: "forestplot__bottom-line"
      }
    ),
    N.map((R) => s.map((L, B) => /* @__PURE__ */ a(
      gt,
      {
        className: `${L[R.name]}`,
        x: R.forestPlotAlignRight ? i : R.forestPlotStartingPoint,
        y: t(B),
        textAnchor: R.forestPlotAlignRight ? "end" : "start",
        verticalAnchor: "middle",
        fill: "black",
        children: L[R.name]
      }
    ))),
    !m.hideDateCategoryCol && s.map((R, L) => /* @__PURE__ */ a(
      gt,
      {
        className: `${R[n.xAxis.dataKey]}`,
        x: 0,
        y: t(L),
        textAnchor: "start",
        verticalAnchor: "middle",
        fill: "black",
        children: R[n.xAxis.dataKey]
      }
    )),
    !m.hideDateCategoryCol && n.xAxis.dataKey && /* @__PURE__ */ a(gt, { className: n.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fill: "black", children: n.xAxis.dataKey }),
    N.map((R) => /* @__PURE__ */ a(
      gt,
      {
        className: `${R.label}`,
        x: R.forestPlotAlignRight ? i : R.forestPlotStartingPoint,
        y: 0,
        textAnchor: R.forestPlotAlignRight ? "end" : "start",
        verticalAnchor: "start",
        fill: "black",
        children: R.label
      }
    )),
    m.leftLabel && /* @__PURE__ */ a(
      gt,
      {
        className: "forest-plot__left-label",
        x: m.type === "Linear" ? e(0) - 25 : e(1) - 25,
        y: r + g,
        textAnchor: "end",
        verticalAnchor: "start",
        children: m.leftLabel
      }
    ),
    m.rightLabel && /* @__PURE__ */ a(
      gt,
      {
        innerRef: c,
        className: "forest-plot__right-label",
        x: m.type === "Linear" ? e(0) + 25 : e(1) + 25,
        y: r + g,
        textAnchor: "start",
        verticalAnchor: "start",
        children: m.rightLabel
      }
    )
  ] });
}, zk = ({ width: e, height: t, originalWidth: n }) => {
  var v, E, N;
  const { config: r, colorScale: i, transformedData: o, formatNumber: d, seriesHighlight: c } = de.useContext(vt);
  if (!r || ((v = r == null ? void 0 : r.series) == null ? void 0 : v.length) < 2)
    return;
  const s = r.barHasBorder === "true" ? 1 : 0, p = e / 2, m = 1.02, g = {
    parentKey: (E = r.dataDescription) == null ? void 0 : E.seriesKey,
    dataKey: r.series[0].dataKey,
    dataKeyLabel: r.runtime.seriesLabels[r.series[0].dataKey] || r.series[0].dataKey,
    color: i(r.runtime.seriesLabels[r.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((R) => R[r.series[0].dataKey])
    ),
    labelColor: ""
  }, x = {
    parentKey: (N = r.dataDescription) == null ? void 0 : N.seriesKey,
    dataKey: r.series[1].dataKey,
    dataKeyLabel: r.runtime.seriesLabels[r.series[1].dataKey] || r.series[1].dataKey,
    color: i(r.runtime.seriesLabels[r.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((R) => R[r.series[1].dataKey])
    ),
    labelColor: ""
  }, T = In({
    domain: [0, Math.max(g.max * m, x.max * 1.1)],
    range: [0, p]
  });
  g.labelColor = g.color ? sl("#000", g.color) : "#000", x.labelColor = x.color ? sl("#000", x.color) : "#000";
  const y = r.yAxis.label ? `${r.yAxis.label}: ` : "", A = (R) => {
    var L;
    return `<p>
				${(L = r.dataDescription) == null ? void 0 : L.seriesKey}: ${g.dataKeyLabel}<br/>
				${r.xAxis.dataKey}: ${R[r.xAxis.dataKey]}<br/>
				${y}${d(R[g.dataKey], "left")}
			</p>`;
  }, b = (R) => {
    var L;
    return `<p>
				${(L = r.dataDescription) == null ? void 0 : L.seriesKey}: ${x.dataKeyLabel}<br/>
				${r.xAxis.dataKey}: ${R[r.xAxis.dataKey]}<br/>
				${y}${d(R[x.dataKey], "left")}
			</p>`;
  };
  return e > 0 && /* @__PURE__ */ z(Ue, { children: [
    /* @__PURE__ */ a("style", { children: `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				` }),
    /* @__PURE__ */ z(
      "svg",
      {
        id: "cdc-visualization__paired-bar-chart",
        width: n,
        height: t,
        viewBox: `0 0 ${e + Number(r.runtime.yAxis.size)} ${t}`,
        role: "img",
        tabIndex: 0,
        children: [
          /* @__PURE__ */ a("title", { children: `Paired bar chart graphic with the title ${r.title ? r.title : "No Title Found"}` }),
          /* @__PURE__ */ z(it, { top: 0, left: Number(r.xAxis.size), children: [
            o.filter((R) => r.series[0].dataKey === g.dataKey).map((R, L) => {
              var I, U;
              let B = r.legend.behavior === "highlight" && c.length > 0 && c.indexOf(r.series[0].dataKey) === -1, j = r.legend.behavior === "highlight" || c.length === 0 || c.indexOf(r.series[0].dataKey) !== -1, Z = T(R[r.series[0].dataKey]), re = Number(r.barHeight) ? Number(r.barHeight) : 25, X = 0;
              X = L !== 0 ? (Number(r.barSpace) + re + s) * L : X;
              const se = (Number(r.barSpace) + re + s) * o.length;
              r.heights.horizontal = se;
              const ie = yr(d(R[g.dataKey], "left")) < Z - 5;
              return /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z(it, { className: "horizontal", children: [
                /* @__PURE__ */ a(
                  _r,
                  {
                    id: `bar-${g.dataKey}-${R[(I = r.dataDescription) == null ? void 0 : I.xKey]}`,
                    className: "bar group-1",
                    x: p - Z,
                    y: X,
                    width: T(R[r.series[0].dataKey]),
                    height: re,
                    fill: g.color,
                    "data-tooltip-html": A(R),
                    "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
                    stroke: "#333",
                    strokeWidth: s,
                    opacity: B ? 0.5 : 1,
                    display: j ? "block" : "none",
                    tabIndex: -1
                  },
                  `bar-${g.dataKey}-${R[(U = r.dataDescription) == null ? void 0 : U.xKey]}`
                ),
                r.yAxis.displayNumbersOnBar && j && /* @__PURE__ */ a(
                  gt,
                  {
                    textAnchor: ie ? "start" : "end",
                    dx: ie ? 5 : -5,
                    verticalAnchor: "middle",
                    x: p - Z,
                    y: X + r.barHeight / 2,
                    fill: ie ? g.labelColor : "#000",
                    children: d(R[g.dataKey], "left")
                  }
                )
              ] }, `group-${g.dataKey}-${R[r.xAxis.dataKey]}`) });
            }),
            o.filter((R) => r.series[1].dataKey === x.dataKey).map((R, L) => {
              var I, U, ue;
              let B = T(R[r.series[1].dataKey]), j = r.legend.behavior === "highlight" && c.length > 0 && c.indexOf(r.series[1].dataKey) === -1, Z = r.legend.behavior === "highlight" || c.length === 0 || c.indexOf(r.series[1].dataKey) !== -1, re = r.barHeight ? Number(r.barHeight) : 25, X = 0;
              X = L !== 0 ? (Number(r.barSpace) + re + s) * L : X;
              const se = (Number(r.barSpace) + re + s) * o.length;
              r.heights.horizontal = se;
              const ie = yr(d(R[x.dataKey], "left")) < B - 5;
              return /* @__PURE__ */ z(Ue, { children: [
                /* @__PURE__ */ a("style", { children: `
                      .bar-${x.dataKey}-${R[r.xAxis.dataKey]} {
                          transform-origin: ${p}px ${X}px
                      }
							      ` }),
                /* @__PURE__ */ z(it, { className: "horizontal", children: [
                  /* @__PURE__ */ a(
                    _r,
                    {
                      id: `bar-${x.dataKey}-${R[(I = r.dataDescription) == null ? void 0 : I.xKey]}`,
                      className: "bar group-2",
                      x: p,
                      y: X,
                      width: T(R[r.series[1].dataKey]),
                      height: re,
                      fill: x.color,
                      "data-tooltip-html": b(R),
                      "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
                      strokeWidth: s,
                      stroke: "#333",
                      opacity: j ? 0.5 : 1,
                      display: Z ? "block" : "none",
                      tabIndex: -1
                    },
                    `bar-${x.dataKey}-${R[(U = r.dataDescription) == null ? void 0 : U.xKey]}`
                  ),
                  r.yAxis.displayNumbersOnBar && Z && /* @__PURE__ */ a(
                    gt,
                    {
                      textAnchor: ie ? "end" : "start",
                      dx: ie ? -5 : 5,
                      verticalAnchor: "middle",
                      x: p + B,
                      y: X + r.barHeight / 2,
                      fill: ie ? x.labelColor : "#000",
                      children: d(R[x.dataKey], "left")
                    }
                  )
                ] }, `group-${x.dataKey}-${R[(ue = r.dataDescription) == null ? void 0 : ue.xKey]}`)
              ] });
            })
          ] })
        ]
      }
    )
  ] });
}, Bk = ({ yMax: e, leftSize: t, max: n, xMax: r }) => {
  var b;
  const { config: i } = de.useContext(vt), { orientation: o } = i, d = (v, E = "#f1f1f1") => {
    try {
      return Gi(v).hex();
    } catch {
      return E;
    }
  }, c = (b = i.yAxis) == null ? void 0 : b.categories, m = ((v) => {
    const E = Object.keys(v), N = E[E.length - 1];
    if (v[N] === "") {
      const R = E.slice(0, -1).reduce((B, j) => {
        const Z = Number(v[j]);
        return B + (isNaN(Z) ? 0 : Z);
      }, 0), L = n - R;
      v[N] = L;
    }
    return [v];
  })(((v) => [...v].reduce((N, R) => (N[R.label] = R.height, N), {}))(c)), g = 0, x = mc({
    domain: [g],
    padding: 0,
    range: [0, t]
  }), T = In({
    domain: [0, n],
    range: [e, 0],
    clamp: !0
  }), y = bh({
    domain: c.map((v) => v == null ? void 0 : v.label),
    range: c.map((v) => {
      var E;
      return d((E = v == null ? void 0 : v.color) == null ? void 0 : E.trim());
    })
  }), A = Object.keys(m[0]);
  return /* @__PURE__ */ a(it, { left: t - x.bandwidth(), top: 0, children: /* @__PURE__ */ a(
    zy,
    {
      data: m,
      keys: A,
      x: () => x(g),
      xScale: x,
      yScale: T,
      color: y,
      children: (v) => v.map(
        (E) => E.bars.map((N) => {
          const R = i.yAxis.categories.length - 1 === E.index, L = Dc / 1.3, B = Gi(N.color).luminance() < 0.4 ? "#fff" : "#000", j = yr(N.key, `${L}px`), Z = Number(j) < N.width && N.height > L, re = `<ul>
              <li class="tooltip-heading""> Label : ${N.key}  </li>
                    </li></ul>`;
          return /* @__PURE__ */ a(it, { children: /* @__PURE__ */ z(
            it,
            {
              id: `barStack${E.index}-${N.index}`,
              className: "stack vertical",
              children: [
                Ms({
                  type: "axisBar",
                  config: i,
                  index: E.index,
                  background: y(N.key),
                  borderColor: "#333",
                  borderStyle: "solid",
                  borderWidth: 0,
                  width: x.bandwidth(),
                  height: N.height,
                  x: N.x,
                  y: N.y,
                  tooltipHtml: re,
                  tooltipId: `cdc-open-viz-tooltip-${i.runtime.uniqueId}`
                }),
                /* @__PURE__ */ a(
                  gt,
                  {
                    display: Z ? "block" : "none",
                    x: N.x + x.bandwidth() / 2,
                    y: N.y + N.height / 2,
                    fill: B,
                    textAnchor: "middle",
                    verticalAnchor: "middle",
                    style: { fontSize: L },
                    children: N.key
                  },
                  `text-${E.index}-${N.index}`
                ),
                i.runtime.yAxis.gridLines && /* @__PURE__ */ a(
                  rn,
                  {
                    from: { x: N.x + x.bandwidth(), y: N.y },
                    to: { x: r + x.bandwidth(), y: N.y },
                    stroke: "#d6d6d6"
                  }
                ),
                !R && /* @__PURE__ */ a("rect", { x: N.x, y: N.y, width: N.width, height: 1, fill: "#fff" }),
                /* @__PURE__ */ a("rect", { x: N.x + N.width, y: 0, width: 1, height: e, fill: "#000" })
              ]
            },
            `bar-stack-${E.index}-${N.index}`
          ) }, `${E.index}--${N.index}--${o}`);
        })
      )
    }
  ) });
};
function Ik({ orientation: e, heights: t, visualizationType: n }, r) {
  const o = e === "vertical" || n === "Forest Plot", c = (t == null ? void 0 : t.mobileVertical) && vf(r) ? "mobileVertical" : "vertical";
  return o ? c : "horizontal";
}
function $k({ heights: e, orientation: t, visualizationType: n }, r) {
  if (!e)
    return 0;
  const i = Ik({ orientation: t, heights: e, visualizationType: n }, r), o = Number(e == null ? void 0 : e[i]);
  return isNaN(o) ? 0 : o;
}
const hg = ({ config: e, minValue: t, maxValue: n, existPositiveValue: r, data: i, isAllLine: o, tableData: d }) => {
  let c = 0, s = 0, p = 0, m = 0;
  const { convertLineToBarGraph: g } = de.useContext(vt);
  if (!i)
    return { min: c, max: s };
  const { visualizationType: x, series: T } = e, { max: y, min: A } = e.runtime.yAxis, b = e.yAxis.enablePadding ? 1 + e.yAxis.scalePadding / 100 : 1, v = e.yAxis.type === "logarithmic", E = r ? Number(y) >= n : Number(y) >= 0, N = v ? Number(A) >= 0 : Number(A) <= 0 && t >= 0 || Number(A) <= t && t < 0;
  c = A && N ? Number(A) : t, s = y && E ? Number(y) : Number.MIN_VALUE;
  const { lower: R, upper: L } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (R && L && e.visualizationType === "Bar") {
    const B = c < 0 ? 1.1 : 0, j = Math.max(...i.flatMap((re) => [re[L], re[R]])) * b, Z = Math.min(...i.flatMap((re) => [re[L], re[R]])) * b * B;
    s = s > j ? s : j, c = c < Z ? c : Z;
  }
  if (e.series.filter((B) => (B == null ? void 0 : B.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: B }
    } = e;
    if ((B == null ? void 0 : B.length) > 0) {
      let j = [];
      B.forEach((se) => {
        var Y;
        (Y = se.confidenceIntervals) == null || Y.map((ie) => {
          j.push(ie.high), j.push(ie.low);
        });
      });
      const Z = i.map((se) => j.map((Y) => se[Y])), re = Math.max.apply(
        null,
        Z.map((se) => se[0])
      ), X = Math.min.apply(
        null,
        Z.map((se) => se[1])
      );
      re > s && (s = re), X < c && (c = X);
    }
  }
  if (x === "Combo")
    try {
      if (!i)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let B = T.filter((re) => re.axis === "Left"), j = T.filter((re) => re.axis === "Right");
      const Z = (re, X, se, Y = "left") => {
        let ie = 0;
        return (X.map((U) => U.dataKey) || []).forEach((U) => {
          let ue = X.find((Q) => Q.dataKey === U), te = re.map((Q) => Q[U]), J = Math.max.apply(null, te);
          e.visualizationSubType === "stacked" && Y === "left" && ue.type === "Bar" && (ie += J), J > se && (se = J), se < ie && (se = ie);
        }), se;
      };
      p = Z(i, B, p, "left"), m = Z(i, j, m, "right"), p < Number(y) && (p = Number(y));
    } catch (B) {
      console.error(B.message);
    }
  if ((x === "Bar" || g || x === "Combo" && !o) && c > 0 && (c = 0), (e.visualizationType === "Bar" || g || e.visualizationType === "Combo" && !o) && c < 0 && (c = c * 1.1), e.visualizationType === "Combo" && o && ((A == null || A === "") && c > 0 && (c = 0), A)) {
    const B = v ? Number(A) >= 0 && Number(A) < t : Number(A) < t;
    c = Number(A) && B ? Number(A) : t;
  }
  if (e.visualizationType === "Deviation Bar" && c > 0) {
    const B = Number(A) < Math.min(t, Number(e.xAxis.target));
    c = Number(A) && B ? Number(A) : 0;
  }
  if (e.visualizationType === "Line" && !g) {
    const B = v ? Number(A) >= 0 && Number(A) < t : Number(A) < t, j = d == null ? void 0 : d.some((re, X) => {
      var se;
      return (se = e.preliminaryData) == null ? void 0 : se.some((Y) => {
        var ue;
        if (Y.type !== "suppression" || !Y.style)
          return !1;
        const ie = nt.pick(re, (ue = e.runtime) == null ? void 0 : ue.seriesKeys), I = nt.values(ie).includes(Y.value);
        return (Y.column ? re[Y.column] === Y.value : I) && (X === 0 || X === d.length - 1);
      });
    });
    let Z = e.yAxis.type === "categorical";
    c = A !== "" && B ? Number(A) : j || Z ? 0 : t;
  }
  if (s === Number.MIN_VALUE && (s = r ? n : 0), e.runtime.yAxis.paddingPercent) {
    let B = (s - c) * e.runtime.yAxis.paddingPercent;
    c -= B, s += B;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const B = i.map((Z) => Z[e.series[0].dataKey]), j = Math.max(...B).toString().length;
    switch (!0) {
      case (j > 8 && j <= 12):
        s = s * 1.3;
        break;
      case (j > 4 && j <= 7):
        s = s * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (c < 0 ? (s *= 1 + e.yAxis.scalePadding * 2 / 100, c *= 1 + e.yAxis.scalePadding * 2 / 100) : s *= 1 + e.yAxis.scalePadding / 100), e.visualizationType === "Area Chart" && e.visualizationSubType === "stacked" && (c = 0), e.visualizationType === "Scatter Plot" && (s = s * 1.1), { min: c, max: s, leftMax: p, rightMax: m };
}, ti = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, Hk = (e) => {
  let { xAxisDataMapped: t, xMax: n, yMax: r, min: i, max: o, config: d, data: c } = e;
  const { rawData: s, dimensions: p } = de.useContext(vt), [m] = p, g = d.runtime.barSeriesKeys || d.runtime.seriesKeys, x = d.runtime.xAxis.type, T = d.orientation === "horizontal", { visualizationType: y, xAxis: A, forestPlot: b } = d;
  let v = null, E = null, N = null, R = null, L = null, B = null, j = In({
    domain: [0, 100],
    range: [0, n]
  });
  if (T && (v = Kk({ min: i * 1.03, ...e }), v.type = d.yAxis.type === "logarithmic" ? ti.LOG : ti.LINEAR, E = Gk(x, t), E.rangeRound([0, r]), L = Xk(g, [0, r])), T || (v = tl(t, [0, n], 1 - d.barThickness), E = Yk(e), L = tl(g, [0, v.bandwidth()], 0)), d.xAxis.type === "date" && !T) {
    const Z = ym(t, d.xAxis.sortByRecentDate);
    v = tl(Z, [0, n], 1 - d.barThickness);
  }
  if (A.type === "date-time" || A.type === "continuous") {
    let Z = Math.min(...t.map(Number)), re = Math.max(...t.map(Number));
    Z -= (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (re - Z), re += y === "Line" ? 0 : (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (re - Z);
    const X = d.xAxis.sortByRecentDate ? [n, 0] : [0, n];
    v = WS({
      domain: [Z, re],
      range: X
    }), v.type = ti.TIME;
    let se = Number.MAX_VALUE, Y = ym(t, d.xAxis.sortByRecentDate);
    for (let ie = 0; ie < Y.length - 1; ie++) {
      let I = v(Y[ie + 1]) - v(Y[ie]);
      I < se && (se = I);
    }
    (t.length === 1 || se > n / 4) && (se = n / 4), L = tl(g, [0, (d.barThickness || 1) * se], 0);
  }
  if (d.visualizationType === "Deviation Bar") {
    const Z = d.isLollipopChart ? 1.05 : 1.03;
    E = mc({
      domain: t,
      range: [0, r]
    }), v = In({
      domain: [i * Z, Math.max(Number(A.target), o)],
      range: [0, n],
      round: !0,
      nice: !0
    }), v.type = ti.LINEAR;
  }
  if (d.visualizationType === "Scatter Plot") {
    if (A.type === "continuous") {
      let Z = A.min ? A.min : Math.min.apply(null, v.domain()), re = A.max ? A.max : Math.max.apply(null, v.domain());
      v = In({
        domain: [Z, re],
        range: [0, n]
      }), v.type = ti.LINEAR;
    }
    if (A.type === "categorical") {
      const Z = t.map((re) => {
        const X = String(re), se = parseFloat(X);
        return isNaN(se) ? X : Math.round(se).toString();
      });
      v = tl(Z, [0, n], 1 - d.barThickness);
    }
  }
  if (y === "Box Plot") {
    const Z = [];
    if (d.boxplot.plots.map((U) => U.columnOutliers.map((ue) => Z.push(ue))) && !d.boxplot.hideOutliers) {
      let U = Math.min(...Z), ue = Math.max(...Z);
      U < i && (i = U), ue > o && (o = ue);
    }
    let X = Math.min(...d.boxplot.plots.map((U) => U.columnLowerBounds)), se = Math.max(...d.boxplot.plots.map((U) => U.columnUpperBounds));
    X < i && (i = X), se > o && (o = se);
    const Y = nt.uniq(c.map((U) => U[d.xAxis.dataKey])), ie = [0, d.barThickness * 100 || 1], I = nt.map(d.series, "dataKey");
    E = In({
      range: [r, 0],
      round: !0,
      domain: [i, o]
    }), v = mc({
      range: [0, n],
      domain: Y
    }), v.type = ti.BAND, L = tl(I, ie);
  }
  if (y === "Paired Bar") {
    let re = Math.max.apply(
      Math,
      c.map((se) => {
        var Y;
        return se[(Y = d.series[0]) == null ? void 0 : Y.dataKey];
      })
    ), X = Math.max.apply(
      Math,
      c.map((se) => {
        var Y;
        return se[(Y = d.series[1]) == null ? void 0 : Y.dataKey];
      })
    );
    R = In({
      domain: [0, Math.max(re, X) * 1.02],
      range: [n / 2, 0]
    }), N = In({
      domain: R.domain(),
      range: [n / 2, n],
      nice: !0
    });
  }
  if (y === "Forest Plot") {
    const Z = () => b.regression.showDiamond || b.regression.description ? [0 + b.rowHeight * 2, r - b.rowHeight] : [0 + b.rowHeight * 2, r];
    E = In({
      domain: [0, s.length],
      range: Z()
    });
    const re = 5, X = Number(b.leftWidthOffset) / 100 * n, se = Number(b.rightWidthOffset) / 100 * n, Y = Number(b.rightWidthOffsetMobile) / 100 * n, ie = Number(b.leftWidthOffsetMobile) / 100 * n;
    if (m > 480) {
      if (b.type === "Linear" && (v = In({
        domain: [
          Math.min(...c.map((I) => parseFloat(I[b.lower]))) - re,
          Math.max(...c.map((I) => parseFloat(I[b.upper]))) + re
        ],
        range: [X, Number(m) - se]
      }), v.type = ti.LINEAR), b.type === "Logarithmic") {
        let I = Math.max(...c.map((ue) => parseFloat(ue[b.upper]))), U = Math.min(...c.map((ue) => parseFloat(ue[b.lower])));
        v = yc({
          domain: [U, I],
          range: [X, n - se],
          nice: !0
        }), v.type = ti.LOG;
      }
    } else if (b.type === "Linear" && (v = In({
      domain: [
        Math.min(...c.map((I) => parseFloat(I[b.lower]))) - re,
        Math.max(...c.map((I) => parseFloat(I[b.upper]))) + re
      ],
      range: [ie, n - Y],
      type: ti.LINEAR
    })), b.type === "Logarithmic") {
      let I = Math.max(...c.map((ue) => parseFloat(ue[b.upper]))), U = Math.min(...c.map((ue) => parseFloat(ue[b.lower])));
      v = yc({
        domain: [U, I],
        range: [X, n - se],
        nice: !0,
        base: I > 1 ? 10 : 2,
        round: !1,
        type: ti.LOG
      });
    }
  }
  return { xScale: v, yScale: E, seriesScale: L, g1xScale: R, g2xScale: N, xScaleNoPadding: B, xScaleAnnotation: j };
}, Vk = (e) => {
  const t = new Date(e);
  return new Date(t.getFullYear(), t.getMonth(), 1).getTime();
}, Wk = (e) => (e.includes("%b") || e.includes("%B") || e.includes("%m") || e.includes("%-m") || e.includes("%_m")) && !e.includes("%d") && !e.includes("%-d") && !e.includes("%_d") && !e.includes("%e"), jk = (e, t, n, r) => {
  const i = t.domain();
  if (t.type === "time") {
    const o = e[e.length - 1], d = e[0], c = (o - d) / (n - 1);
    let s = [];
    for (let p = o; p >= d; p -= c)
      s.push(p);
    return s[s.length - 1] !== d && s.push(d), s.reverse(), Wk(r.xAxis.dateDisplayFormat) && (s = s.map((p) => Vk(p))), s;
  }
  if (i.length > 2) {
    const o = n || 1, d = [];
    for (let c = i.length; c > 0; c -= o) {
      const s = Math.max(Math.round(c) - 1, 0);
      d.push(i[s]);
    }
    return d.reverse(), d;
  }
}, Uk = (e, t, n, r) => {
  let i = t.ticks;
  const o = qy(t.scale, t.numTicks);
  if (o.length < n.length) {
    let d = 0;
    const c = n.indexOf(o[o.length - 1]);
    c < n.length - 1 && (d = e.xAxis.sortByRecentDate ? n.indexOf(o[0]) * -1 : n.length - 1 - c), i = o.map((s) => t.ticks[t.ticks.findIndex((p) => p.value === s) + d]);
  }
  return i.forEach((d, c) => {
    d.formattedValue = r(d.value, c, i);
  }), i;
}, Kk = ({ min: e, max: t, xMax: n, config: r }) => {
  const i = r.yAxis.type === "logarithmic";
  return e = i && e >= 0 && e < 1 ? e + 0.1 : e, (i ? yc : In)({
    domain: [e, t],
    range: [0, n],
    nice: i,
    zero: i
  });
}, Yk = ({ min: e, max: t, yMax: n, config: r, leftMax: i }) => {
  const o = r.yAxis.type === "logarithmic";
  e = o && e >= 0 && e < 1 ? e + 0.1 : e;
  const d = o ? yc : In;
  r.visualizationType === "Combo" && (t = i);
  const c = r.visualizationType === "Bump Chart" ? [1, t] : [e, t], s = r.visualizationType === "Bump Chart" ? [30, n] : [n, 0];
  return d({
    domain: c,
    range: s,
    nice: o,
    zero: o
  });
}, Gk = (e, t) => e === "date" ? In({
  domain: [Math.min(...t), Math.max(...t)]
}) : al({ domain: t, padding: 0.5 }), Xk = (e, t, n = 0) => al({
  domain: e,
  range: t,
  padding: n
}), tl = (e, t, n = 0) => mc({
  domain: e,
  range: t,
  padding: n
}), ym = (e, t) => !e || e.length === 0 ? [] : e.length === 1 ? e : t ? e.sort((n, r) => Number(r) - Number(n)) : e.sort((n, r) => Number(n) - Number(r));
function qk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const Fs = () => {
  const { config: e } = de.useContext(vt), { visualizationType: t, series: n, orientation: r, visualizationSubType: i } = e, o = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Bump Chart",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], d = [
    "theme-blue",
    "theme-purple",
    "theme-brown",
    "theme-teal",
    "theme-pink",
    "theme-orange",
    "theme-slate",
    "theme-indigo",
    "theme-cyan",
    "theme-green",
    "theme-amber"
  ], c = () => !["Forest Plot", "Sankey"].includes(t), s = () => !!["Scatter Plot"].includes(t), p = () => !!["Scatter Plot"].includes(t), m = () => !["Spark Line"].includes(t), g = () => !["Spark Line"].includes(t), x = () => ![
    "Area Chart",
    "Box Plot",
    "Pie",
    "Scatter Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), T = () => ![
    "Area Chart",
    "Scatter Plot",
    "Box Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), y = () => {
    switch (t) {
      case "Box Plot":
        return !0;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, A = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), b = () => !!["Bar", "Combo", "Line"].includes(e.visualizationType), v = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, E = () => {
    if ((t === "Bar" || "Combo") && i === "regular")
      return !0;
  }, N = () => e.xAxis.type === "categorical" ? !1 : ["Line", "Bar", "Area Chart", "Combo"].includes(t) && r === "vertical", R = () => ["Box Plot", "Scatter Plot", "Pie", "Line"].includes(t) ? !1 : n == null ? void 0 : n.some(
    (Oe) => Oe.type === "Bar" || Oe.type === "Paired Bar" || Oe.type === "Deviation Bar"
  ), L = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, B = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: o,
    headerColors: d,
    visCanAnimate: T,
    visHasAnchors: v,
    visHasBarBorders: R,
    visHasDataCutoff: L,
    visHasLabelOnData: x,
    visHasDataSuppression: E,
    visHasLegend: y,
    visHasLegendAxisAlign: () => t === "Bar" && i === "stacked" && e.legend.behavior === "isolate",
    visHasLegendColorCategory: () => {
      var Ae;
      return t === "Bar" && i === "regular" && ((Ae = e.series) == null ? void 0 : Ae.length) === 1;
    },
    visHasBrushChart: N,
    visHasNumbersOnBars: A,
    visHasaAdditionalLabelsOnBars: b,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : r === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsMobileChartHeight: () => !!["Bar", "Line", "Combo", "Area Chart"].includes(t),
    visSupportsDateCategoryAxis: c,
    visSupportsDateCategoryAxisMin: s,
    visSupportsDateCategoryAxisMax: p,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line", "Bump Chart"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !(["Spark Line", "Sankey", "Bump Chart"].includes(t) || e.orientation !== "horizontal"),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: g,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => !!["Line", "Bar", "Combo"].includes(t),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: m,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: B,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const Ae = ["Forest Plot"];
      return !(r === "horizontal" || Ae.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot", "Bump Chart"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (e.yAxis.type === "categorical" || ["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t) || t === "Bar" && e.tooltips.singleSeries)
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t),
    visSupportsDynamicSeries: () => t === "Line" || t === "Bar" || t === "Scatter Plot" || t === "Area Chart",
    visSupportsYPadding: () => {
      var Ae;
      return !e.dataFormat.onlyShowTopPrefixSuffix || !((Ae = e.dataFormat.suffix) != null && Ae.includes(" "));
    },
    visHasSingleSeriesTooltip: () => t === "Bar" || t === "Line" || t === "Area Chart" && i === "stacked",
    visHasCategoricalAxis: () => {
      if ((t === "Line" || t === "Bar" || t === "Combo" || t === "Area Chart") && e.yAxis.type === "categorical" && r === "vertical")
        return !0;
    }
  };
}, Zk = ({ data: e, xScale: t, yScale: n, config: r, xMax: i, annotationSeriesKey: o }, d) => {
  const { xAxis: c, visualizationType: s, orientation: p } = r, m = (b, v, E, N, R) => {
    let L = [];
    r.xAxis.type === "date-time" && (v = new Date(v), E = new Date(E), N = N.map((Z) => new Date(Z)), L = R.ticks().map((Z) => new Date(Z)));
    const B = (b - v) / (E - v), j = Math.round(B * (N.length - 1));
    return r.xAxis.type === "date-time" ? L[j] : N[j];
  }, x = ((b, v = !1) => {
    if (s !== "Pie" && p !== "horizontal") {
      if (r.xAxis.type === "date-time") {
        const E = new Date(t.invert(b)), N = r.data.map((B) => new Date(B[r.xAxis.dataKey]).getTime());
        let R = 1 / 0, L = null;
        return N.forEach((B) => {
          const j = Math.abs(E.getTime() - B);
          j < R && (R = j, L = B);
        }), new Date(L).getTime();
      }
      if (r.xAxis.type === "categorical" || s === "Combo" && p !== "horizontal" && s !== "Forest Plot") {
        const N = (t.range()[1] - t.range()[0]) / (t.domain().length + 1), L = Math.floor((Number(b) - N / 2) / N);
        return t.domain()[L];
      }
      if (r.xAxis.type === "date") {
        const E = m(b, 0, i, t.domain(), t);
        let N = null, R = Number.MAX_VALUE;
        return t.domain().forEach((L) => {
          const B = Math.abs(E - L);
          B < R && (R = B, N = L);
        }), N;
      }
      return b;
    }
  })(d - Number(r.yAxis.size || 0));
  let T = [];
  if (!x)
    return { x: 0, y: 0 };
  c.type === "categorical" && (T = r.data.filter((b) => b[r.xAxis.dataKey] === x)), (c.type === "date" || c.type === "date-time") && (T = r.data.filter((b) => new Date(b[r.xAxis.dataKey]).getTime() === x));
  const y = T[0][o];
  return { x, y };
}, Qk = (e, t, n) => {
  const { connectionLocation: r } = e;
  return r === "right" ? "end" : r === "left" ? "start" : r === "bottom" || r === "top" || t(e.xKey) + e.dx < n.yAxis.size ? "middle" : null;
}, Jk = (e, t, n) => {
  const { connectionLocation: r } = e;
  return r === "top" ? "start" : r === "bottom" ? "end" : r === "right" || r === "left" ? "middle" : t(e.xKey) + e.dx < n.yAxis.size ? "end" : null;
};
const eT = ({ xScale: e, yScale: t, xScaleAnnotation: n, xMax: r, svgRef: i, onDragStateChange: o }) => {
  const { config: d, dimensions: c, isEditor: s, updateConfig: p, colorScale: m } = de.useContext(vt), { annotations: g } = d, [x] = c, T = s ? Fg : zg;
  return g && g.map((y, A) => {
    var N;
    const b = y.text || "", v = n(y.x), E = () => ({
      __html: Em.sanitize(b)
    });
    return /* @__PURE__ */ z(
      T,
      {
        width: 200,
        height: x,
        dx: y.dx,
        dy: y.dy,
        x: v,
        y: y.y,
        canEditLabel: y.edit.label || !1,
        canEditSubject: y.edit.subject && y.connectionType !== "none" || !1,
        onDragStart: () => o(!0),
        onDragEnd: (R) => {
          o(!1);
          let L = [...g];
          if (y.x === n.invert(R.x) && y.y === R.y)
            L[A] = { ...L[A], dx: R.dx, dy: R.dy };
          else if (y.snapToNearestPoint) {
            let B = Zk(
              {
                data: d.data,
                xScale: e,
                yScale: t,
                config: d,
                xMax: r - d.yAxis.size / 2,
                annotationSeriesKey: y.seriesKey
              },
              R.x
            );
            L[A] = {
              ...L[A],
              x: n.invert(e(B.x)),
              y: t(B.y)
            };
          } else
            L[A] = {
              ...L[A],
              x: n.invert(R.x),
              y: R.y
            };
          p({
            ...d,
            annotations: L
          });
        },
        children: [
          /* @__PURE__ */ a(
            Og,
            {
              className: "annotation__desktop-label",
              showAnchorLine: !1,
              horizontalAnchor: Qk(y, e, d),
              verticalAnchor: Jk(y, e, d),
              children: /* @__PURE__ */ z(
                "div",
                {
                  style: {
                    borderRadius: 5,
                    // Optional: set border radius
                    backgroundColor: `rgba(255, 255, 255, ${y != null && y.opacity ? Number(y == null ? void 0 : y.opacity) / 100 : 1})`,
                    padding: "10px",
                    width: "auto",
                    display: d.general.showAnnotationDropdown ? "inline-flex" : "flex",
                    justifyContent: "start",
                    flexDirection: "row"
                  },
                  tabIndex: 0,
                  "aria-label": `Annotation text that reads: ${y.text}`,
                  children: [
                    ((N = d == null ? void 0 : d.general) == null ? void 0 : N.showAnnotationDropdown) && /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ a("p", { className: "annotation__has-dropdown-number", style: { margin: "2px 6px" }, children: A + 1 }) }),
                    /* @__PURE__ */ a("div", { dangerouslySetInnerHTML: E() })
                  ]
                }
              )
            }
          ),
          y.connectionType === "line" && /* @__PURE__ */ a(Bh, { type: "line", pathProps: { markerStart: `url(#marker-start--${A})` } }),
          y.connectionType === "elbow" && /* @__PURE__ */ a(Bh, { type: "elbow", pathProps: { markerStart: `url(#marker-start--${A})` } }),
          y.connectionType === "curve" && /* @__PURE__ */ a(
            jr,
            {
              d: `M ${v},${y.y}
                      Q ${v + y.dx / 2}, ${y.y + y.dy / 2 + Number(y == null ? void 0 : y.bezier) || 0} ${v + y.dx},${y.y + y.dy}`,
              stroke: "black",
              strokeWidth: "2",
              fill: "none",
              "marker-start": `url(#marker-start--${A})`
            }
          ),
          y.marker === "circle" && /* @__PURE__ */ a(
            Mg,
            {
              id: `marker-start--${A}`,
              className: "circle-subject",
              stroke: m(y.seriesKey),
              radius: 8
            }
          ),
          y.marker === "arrow" && /* @__PURE__ */ a(
            Lm,
            {
              fill: "black",
              id: `marker-start--${A}`,
              x: v,
              y: y.y,
              stroke: "#333",
              markerWidth: 10,
              size: 10,
              strokeWidth: 1,
              orient: "auto-start-reverse",
              markerUnits: "userSpaceOnUse"
            }
          ),
          /* @__PURE__ */ a(
            "circle",
            {
              fill: "white",
              cx: v + y.dx,
              cy: y.y + y.dy,
              r: 16,
              className: "annotation__mobile-label annotation__mobile-label-circle",
              stroke: m(y.seriesKey)
            }
          ),
          /* @__PURE__ */ a(
            "text",
            {
              height: 16,
              x: v + y.dx,
              y: y.y + y.dy,
              className: "annotation__mobile-label",
              alignmentBaseline: "middle",
              textAnchor: "middle",
              children: A + 1
            }
          )
        ]
      }
    );
  });
};
const tT = ({ useBootstrapVisibilityClasses: e = !0 }) => {
  const { config: t } = de.useContext(vt), n = t.annotations || [], r = () => {
    const o = ["annotation-list"];
    return e && o.push("d-block", "d-md-none"), o.join(" ");
  }, i = n.map((o, d) => {
    const c = o.text || "", s = () => ({
      __html: Em.sanitize(c)
    });
    return /* @__PURE__ */ a("li", { children: /* @__PURE__ */ z("div", { className: "annotation__title-wrapper", children: [
      /* @__PURE__ */ a("div", { className: "annotation__title-circle", children: d + 1 }),
      /* @__PURE__ */ a("p", { className: "annotation__subtext", dangerouslySetInnerHTML: s() })
    ] }) }, "annotation-li-item__annotationIndex");
  });
  return /* @__PURE__ */ a("ul", { className: r(), children: i });
};
const nT = () => {
  var s;
  const { currentViewport: e, config: t } = de.useContext(vt), [n, r] = de.useState(!1), i = ["sm", "xs", "xxs"].includes(e) ? "13px" : `${Dc}px`;
  de.useContext(vt);
  const o = {
    maxHeight: t.table.limitHeight && `${t.table.height}px`,
    OverflowY: "scroll"
  }, d = () => {
    const p = ["data-table-heading", "annotation__dropdown-list", "p-3"];
    return n || p.push("collapsed"), p.join(" ");
  };
  return /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z("section", { className: (() => {
    const p = ["data-table-container", e, "d-block", "d-lg-none", "w-100"];
    return t.general.showAnnotationDropdown && (p.push("d-lg-block"), p.splice(p.indexOf("d-lg-none"), 1)), p.join(" ");
  })(), children: [
    /* @__PURE__ */ z(
      "div",
      {
        style: { fontSize: i },
        role: "button",
        className: d(),
        onClick: () => {
          r(!n);
        },
        tabIndex: 0,
        onKeyDown: (p) => {
          p.keyCode === 13 && r(!n);
        },
        children: [
          /* @__PURE__ */ a(Ze, { display: n ? "minus" : "plus", base: !0 }),
          t.general.annotationDropdownText === "" ? "Annotations" : (s = t == null ? void 0 : t.general) == null ? void 0 : s.annotationDropdownText
        ]
      }
    ),
    n && /* @__PURE__ */ a("div", { className: "table-container annotation-dropdown__panel", style: o, children: /* @__PURE__ */ a(Ah.List, { useBootstrapVisibilityClasses: !1 }) })
  ] }) });
}, Ah = {
  Draggable: eT,
  // Mobile auto display
  List: tT,
  // Desktop Accessible Option
  Dropdown: nT
}, rT = ({ axis: e, max: t, runtime: n, currentViewport: r, isHorizontal: i, data: o, config: d, min: c }) => {
  let { numTicks: s } = n[e];
  n[e].viewportNumTicks && n[e].viewportNumTicks[r] && (s = n[e].viewportNumTicks[r]);
  let p;
  return e === "yAxis" && (p = i && !s ? o.length : i && s ? s : !i && !s ? void 0 : !i && s && s, p === void 0 && !d.dataFormat.roundTo && (Number(t) <= 3 ? p = 2 : p = 4), Number(p) > Number(t) && !i && (p = Number(c) < 0 ? Math.round(t) * 2 : Math.round(t))), e === "xAxis" && (p = i && !s ? void 0 : i && s ? s : !i && !s ? void 0 : !i && s && s, i && p === void 0 && !d.dataFormat.roundTo && (t <= 3 ? p = 2 : p = 4), d.visualizationType === "Forest Plot" && (p = d.yAxis.numTicks !== "" ? d.yAxis.numTicks : 4)), p;
}, ff = 9, hf = 4.5, pf = 8, iT = 1e3 * 60 * 60 * 24 * 30, aT = 16, oT = 13, lT = 18, sT = 14, uT = 4.5, mf = de.forwardRef(({ parentHeight: e, parentWidth: t }, n) => {
  var lr, Xn, qn, S, _;
  const {
    brushConfig: r,
    colorScale: i,
    config: o,
    convertLineToBarGraph: d,
    currentViewport: c,
    dimensions: s,
    formatDate: p,
    formatNumber: m,
    handleChartAriaLabels: g,
    handleLineType: x,
    handleDragStateChange: T,
    isDraggingAnnotation: y,
    legendRef: A,
    parseDate: b,
    parentRef: v,
    tableData: E,
    transformedData: N,
    updateConfig: R,
    seriesHighlight: L
  } = de.useContext(vt), {
    heights: B,
    visualizationType: j,
    visualizationSubType: Z,
    orientation: re,
    xAxis: X,
    yAxis: se,
    runtime: Y,
    legend: ie,
    forestPlot: I,
    brush: U,
    dataFormat: ue,
    debugSvg: te
  } = o, { suffix: J, onlyShowTopPrefixSuffix: Q } = ue, { labelsAboveGridlines: G, hideAxis: ne } = o.yAxis, { minValue: H, maxValue: ce, existPositiveValue: ke, isAllLine: Se } = Uc(o, N), { visSupportsReactTooltip: xe } = Fs(), { hasTopAxis: De } = qk(o), [je, Ce] = de.useState(!1), [ye, Ee] = de.useState({ x: 0, y: 0 }), [he, Be] = de.useState(0), [$e, tt] = de.useState(0), We = de.useRef(null), Fe = de.useRef(null), Je = de.useRef(null), Ke = de.useRef(null), Ye = de.useRef(), Xe = de.useRef([]), Ae = de.useRef(null), Oe = de.useRef(ce), lt = gh(Ye, {
    freezeOnceVisible: !1
  }), ve = !0, mt = re === "horizontal" || o.visualizationType === "Forest Plot", ut = o.yAxis.type === "logarithmic", st = j === "Forest Plot", Lt = o.xAxis.type === "date-time", Kt = !J.includes(" "), Xt = Q && !Kt, It = Number(re === "horizontal" ? o.xAxis.size : o.yAxis.size), ln = isNaN(parseInt(`${Y.yAxis.labelOffset}`)) ? 0 : parseInt(`${Y.yAxis.labelOffset}`), Tt = vf(c) ? oT : aT, Ot = vf(c) ? sT : lT, _t = `normal ${Tt}px Nunito, sans-serif`, an = st ? o.data.length * o.forestPlot.rowHeight : 0, dn = de.useMemo(
    () => $k(o, c),
    [o, c, e, (lr = o.heights) == null ? void 0 : lr.vertical, (Xn = o.heights) == null ? void 0 : Xn.horizontal]
  ), zt = de.useMemo(() => dn + an, [dn, an]), Bt = de.useMemo(() => {
    var ee;
    const D = s[0], K = ie == null ? void 0 : ie.hide, pe = ["bottom", "top"].includes((ee = o.legend) == null ? void 0 : ee.position), O = Ui(c);
    if (!(!st && !K && !pe && !O))
      return D;
    if (A.current) {
      const be = getComputedStyle(A.current);
      return D - A.current.getBoundingClientRect().width - parseInt(be.marginLeft) - parseInt(be.marginRight);
    }
    return D * 0.73;
  }, [s[0], o.legend, c, A.current]), on = de.useMemo(() => {
    var K;
    return Xe.current = (K = Xe.current) == null ? void 0 : K.filter((pe) => pe), Xe.current.length ? Math.max(...Xe.current.map((pe) => pe.getBBox().height)) + hf + pf : void 0;
  }, [s[0], o.xAxis, Xe.current, o.xAxis.tickRotation]), rt = Bt - Y.yAxis.size - (j === "Combo" ? o.yAxis.rightAxisSize : 0), ht = dn + an, Pe = o.filters && o.filters.values.length === 0 && N.length === 0, _e = (D) => Tn(o.runtime.xAxis) ? b(D[o.runtime.originalXAxis.dataKey]).getTime() : D[o.runtime.originalXAxis.dataKey], we = (D, K) => D[K], yt = o.brush.active && ((qn = r.data) != null && qn.length) ? r.data.map((D) => _e(D)) : N.map((D) => _e(D)), at = o.orientation === "horizontal" || o.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", bt = {
    data: N,
    tableData: E,
    config: {
      ...o,
      yAxis: {
        ...o.yAxis,
        scalePadding: Xt ? $e : o.yAxis.scalePadding,
        enablePadding: Xt || o.yAxis.enablePadding
      }
    },
    minValue: H,
    maxValue: ce,
    isAllLine: Se,
    existPositiveValue: ke,
    xAxisDataMapped: yt,
    xMax: rt,
    yMax: ht
  }, { min: wt, max: qt, leftMax: ct, rightMax: dt } = hg(bt), { yScaleRight: Wt, hasRightAxis: Yt } = Th({ config: o, yMax: ht, data: N, updateConfig: R }), { xScale: Rt, yScale: Ct, seriesScale: xn, g1xScale: Sn, g2xScale: Ln, xScaleNoPadding: On, xScaleAnnotation: En } = Hk({
    ...bt,
    min: wt,
    max: qt,
    leftMax: ct,
    rightMax: dt,
    dimensions: s,
    xMax: t - Number(o.orientation === "horizontal" ? o.xAxis.size : o.yAxis.size)
  }), [rr, Mn] = ["yAxis", "xAxis"].map(
    (D) => rT({ axis: D, max: qt, runtime: Y, currentViewport: c, isHorizontal: mt, data: N, config: o, min: wt })
  ), wn = st ? o.data.length : rr, { tooltipData: Pt, showTooltip: jt, hideTooltip: kn, tooltipOpen: tn, tooltipLeft: fn, tooltipTop: An } = Iy(), {
    handleTooltipMouseOver: Dt,
    handleTooltipClick: bn,
    handleTooltipMouseOff: sn,
    TooltipListItem: hn,
    getXValueFromCoordinate: ir
  } = jy({
    xScale: Rt,
    yScale: Ct,
    showTooltip: jt,
    hideTooltip: kn
  }), { dataKey: Fn } = Y.xAxis, Rn = N.length && Lt ? [0, N.length - 1].map((D) => b(N[D][Fn])).reduce((D, K) => Math.abs(D - K)) / iT : 0, yn = Lt && Rn > Mn, $n = (D, K, pe) => {
    if (ut && D === 0.1 && (D = 0), !(o.data && !o.data[K] && j === "Forest Plot"))
      return o.visualizationType === "Forest Plot" ? o.data[K][o.xAxis.dataKey] : Tn(Y.yAxis) ? p(b(D)) : re === "vertical" && qt - wt < 3 ? m(D, "left", ve, !1, !1, "1", { index: K, length: pe.length }) : re === "vertical" ? m(D, "left", ve, !1, !1, void 0, { index: K, length: pe.length }) : D;
  }, Hn = (D, K, pe) => (ut && D === 0.1 && (D = 0), Tn(Y.xAxis) && o.visualizationType !== "Forest Plot" ? p(D, K, pe) : re === "horizontal" && o.visualizationType !== "Forest Plot" ? m(D, "left", ve) : o.xAxis.type === "continuous" && o.visualizationType !== "Forest Plot" ? m(D, "bottom", ve) : o.visualizationType === "Forest Plot" ? m(
    D,
    "left",
    o.dataFormat.abbreviated,
    o.runtime.xAxis.prefix,
    o.runtime.xAxis.suffix,
    Number(o.dataFormat.roundTo)
  ) : D), ar = () => {
    const { visualizationType: D } = o;
    return D === "Combo" && Y.forecastingSeriesKeys > 0 || D === "Area Chart" || D === "Line" || D === "Bar";
  }, gr = () => {
    let D = o.xAxis.manualStep;
    return o.xAxis.viewportStepCount && o.xAxis.viewportStepCount[c] && (D = o.xAxis.viewportStepCount[c]), D;
  }, or = (D) => {
    const K = D.currentTarget.getBoundingClientRect(), pe = D.clientX - K.left, O = D.clientY - K.top;
    Ee({
      x: pe,
      y: O
    });
  };
  de.useEffect(() => {
    document.querySelector(".isEditor") && Ce((K) => !0);
  }), de.useEffect(() => {
    (lt == null ? void 0 : lt.isIntersecting) === !0 && o.animate && setTimeout(() => {
      Ce((D) => !0);
    }, 500);
  }, [lt == null ? void 0 : lt.isIntersecting, o.animate]), de.useEffect(() => {
    const D = Je.current;
    if (!D && !he)
      return;
    if (!D)
      return Be(0);
    const K = D.getBBox().width;
    Be(K);
  }, [o.dataFormat.suffix, o.dataFormat.onlyShowTopPrefixSuffix]), de.useEffect(() => {
    if (!st || X.hideLabel)
      return;
    const D = Fe.current;
    if (!D)
      return;
    const K = ht + Number(o.xAxis.axisPadding), O = D.getBBox().y - K + D.getBBox().height + ff;
    Ae.current && Ae.current.setAttribute("y", O);
  }, [(S = o == null ? void 0 : o.data) == null ? void 0 : S.length, an]), de.useEffect(() => {
    if (!We.current)
      return;
    const D = We.current.getBBox().height, K = j === "Forest Plot", pe = Ke.current && se.labelsAboveGridlines, O = U != null && U.active ? (U == null ? void 0 : U.height) + (U == null ? void 0 : U.height) : 0, $ = K ? o.data.length * I.rowHeight : 0, ee = pe ? Ke.current.getBBox().height : 0, be = D + O + $ + ee, Ie = dn + be;
    if (!v.current || (v.current.style.height = `${Ie}px`, !ee))
      return;
    const Qe = n.current;
    if (!Qe)
      return;
    const pt = v.current.getBoundingClientRect().width;
    if (Qe.setAttribute("viewBox", `0 ${-ee} ${pt} ${Ie}`), !A.current)
      return;
    const Ut = (ie == null ? void 0 : ie.position) !== "top" && (ie == null ? void 0 : ie.position) !== "bottom" && !Ui(c);
    A.current.style.transform = Ut ? `translateY(${ee}px)` : "none";
  }, [We.current, o, on, U, c, Ke.current, dn]), de.useEffect(() => {
    Oe.current !== ce && (Oe.current = ce, $e && tt(0));
  }, [ce]), de.useEffect(() => {
    if (re === "horizontal" || !Xt)
      return;
    const D = 0.025, pe = Math.max(...Ct.ticks(wn)) - ce * D;
    if (!(ce > pe))
      return;
    const $ = Ct.ticks(wn), ee = $.length === 1 ? $[0] : $[1] - $[0], be = Math.max(...Ct.ticks(wn)) + ee, Ie = H < 0 ? ce / 2 : ce, Qe = (be - ce) / Ie, pt = Qe > D ? Qe : Qe + ee / Ie;
    tt(pt * 100 + 0.1);
  }, [ce, Xt, Ct, wn]);
  const jn = () => {
    const D = on + ff, K = (pe, O) => {
      if (!pe.length)
        return !1;
      const $ = pe.filter((Jt) => Jt.index !== 0), ee = $ == null ? void 0 : $.length, be = O.range()[0] || rt / 2, Ie = $.map(
        (Jt) => yr(m(Jt.value, "left"), _t)
      ), Qe = 100, pt = Ie.reduce((Jt, en) => Jt + en, Qe), Ut = (be - pt) / ee;
      let $t = [0];
      for (let Jt = 1; Jt < Ie.length; Jt++)
        $t[Jt] = $t[Jt - 1] + Ie[Jt - 1] + Ut;
      let Qt = !1;
      return Ie.forEach((Jt, en) => {
        if ($t[en] + Ie[en] > $t[en + 1]) {
          Qt = !0;
          return;
        }
      }), Qt;
    };
    return /* @__PURE__ */ z(Ue, { children: [
      /* @__PURE__ */ a(
        Yu,
        {
          top: ht,
          left: Number(Y.yAxis.size),
          label: Y.xAxis.label,
          tickFormat: Tn(Y.xAxis) ? p : m,
          scale: Sn,
          stroke: "#333",
          tickStroke: "#333",
          numTicks: Y.xAxis.numTicks || void 0,
          children: (pe) => /* @__PURE__ */ z(it, { className: "bottom-axis", children: [
            pe.ticks.map((O, $) => {
              const ee = K(pe.ticks, Sn), be = Number(o.xAxis.maxTickRotation) || 90, Ie = o.isResponsiveTicks && ee, Qe = O.index !== 0 && (Ie ? be : Number(o.yAxis.tickRotation)), pt = Qe && O.index !== 0 ? "end" : "middle";
              return /* @__PURE__ */ z(it, { className: "vx-axis-tick", children: [
                !Y.yAxis.hideTicks && /* @__PURE__ */ a(rn, { from: O.from, to: O.to, stroke: "#333" }),
                !Y.yAxis.hideLabel && /* @__PURE__ */ a(
                  gt,
                  {
                    innerRef: (Ut) => Xe.current[$] = Ut,
                    x: O.to.x,
                    y: O.to.y,
                    angle: -Qe,
                    verticalAnchor: Qe ? "middle" : "start",
                    textAnchor: pt,
                    fontSize: Tt,
                    children: m(O.value, "left")
                  }
                )
              ] }, `vx-tick-${O.value}-${$}`);
            }),
            !Y.yAxis.hideAxis && /* @__PURE__ */ a(rn, { from: pe.axisFromPoint, to: pe.axisToPoint, stroke: "#333" })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        Yu,
        {
          innerRef: We,
          top: ht,
          left: Number(Y.yAxis.size),
          label: Y.xAxis.label,
          tickFormat: Tn(Y.xAxis) ? p : Y.xAxis.dataKey !== "Year" ? m : (pe) => pe,
          scale: Ln,
          stroke: "#333",
          tickStroke: "#333",
          numTicks: Y.xAxis.numTicks || void 0,
          children: (pe) => /* @__PURE__ */ z(Ue, { children: [
            /* @__PURE__ */ z(it, { className: "bottom-axis", children: [
              pe.ticks.map((O, $) => {
                const ee = K(pe.ticks, Ln), be = Number(o.xAxis.maxTickRotation) || 90, Ie = o.isResponsiveTicks && ee, Qe = O.index !== 0 && (Ie ? be : Number(o.yAxis.tickRotation)), pt = Qe && O.index !== 0 ? "end" : "middle";
                return $ ? /* @__PURE__ */ z(it, { className: "vx-axis-tick", children: [
                  !Y.yAxis.hideTicks && /* @__PURE__ */ a(rn, { from: O.from, to: O.to, stroke: "#333" }),
                  !Y.yAxis.hideLabel && /* @__PURE__ */ a(
                    gt,
                    {
                      x: O.to.x,
                      y: O.to.y + hf,
                      angle: -Qe,
                      verticalAnchor: Qe ? "middle" : "start",
                      textAnchor: pt,
                      fontSize: Tt,
                      children: m(O.value, "left")
                    }
                  )
                ] }, `vx-tick-${O.value}-${$}`) : /* @__PURE__ */ a(Ue, {});
              }),
              !Y.yAxis.hideAxis && /* @__PURE__ */ a(rn, { from: pe.axisFromPoint, to: pe.axisToPoint, stroke: "#333" })
            ] }),
            /* @__PURE__ */ a(it, { children: /* @__PURE__ */ a(
              gt,
              {
                className: "x-axis-title-label",
                x: rt / 2,
                y: D,
                stroke: "#333",
                textAnchor: "middle",
                verticalAnchor: "start",
                fontSize: Ot,
                children: Y.xAxis.label
              }
            ) })
          ] })
        }
      )
    ] });
  };
  return isNaN(Bt) ? /* @__PURE__ */ a(Ve.Fragment, {}) : /* @__PURE__ */ a(Ur, { component: "LinearChart", children: /* @__PURE__ */ z(
    "div",
    {
      style: { width: `${t}px`, overflow: "visible", position: "relative" },
      className: "tooltip-boundary",
      children: [
        /* @__PURE__ */ z(
          "svg",
          {
            ref: n,
            onMouseMove: or,
            width: t,
            height: Pe ? 1 : e,
            className: `linear ${o.animate ? "animated" : ""} ${je && o.animate ? "animate" : ""} ${te && "debug"} ${y && "dragging-annotation"}`,
            role: "img",
            "aria-label": g(o),
            style: { overflow: "visible" },
            children: [
              !y && /* @__PURE__ */ a(_r, { width: t, height: dn, fill: "transparent" }),
              " ",
              !["Spark Line", "Forest Plot"].includes(j) && o.yAxis.type !== "categorical" && /* @__PURE__ */ a(
                sm,
                {
                  scale: Ct,
                  left: Number(Y.yAxis.size) - o.yAxis.axisPadding,
                  numTicks: wn,
                  children: (D) => {
                    const K = o.orientation === "horizontal" ? (D.axisToPoint.y - D.axisFromPoint.y) / 2 : (D.axisFromPoint.y - D.axisToPoint.y) / 2;
                    return /* @__PURE__ */ z(it, { className: "left-axis", children: [
                      D.ticks.map((pe, O) => {
                        const $ = String(pe.value).startsWith("1") || pe.value === 0.1 ? "block" : "none", ee = pe.index === 0 && pe.value === 0 && o.xAxis.hideAxis;
                        return /* @__PURE__ */ a(it, { className: "vx-axis-tick", children: Y.yAxis.gridLines && !ee ? /* @__PURE__ */ a(
                          rn,
                          {
                            display: (ut && $).toString(),
                            from: { x: pe.from.x + rt, y: pe.from.y },
                            to: pe.from,
                            stroke: "#d6d6d6"
                          },
                          `${pe.value}--hide-hideGridLines`
                        ) : "" }, `vx-tick-${pe.value}-${O}`);
                      }),
                      /* @__PURE__ */ a(
                        gt,
                        {
                          className: "y-label",
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          transform: `translate(${-1 * Y.yAxis.size + ln}, ${K}) rotate(-90)`,
                          fontWeight: "bold",
                          fill: o.yAxis.labelColor,
                          fontSize: Ot,
                          children: D.label
                        }
                      )
                    ] });
                  }
                }
              ),
              j === "Paired Bar" && jn(),
              j === "Deviation Bar" && ((_ = o.runtime.series) == null ? void 0 : _.length) === 1 && /* @__PURE__ */ a(kk, { animatedChart: je, xScale: Rt, yScale: Ct, width: rt, height: ht }),
              j === "Paired Bar" && /* @__PURE__ */ a(zk, { originalWidth: Bt, width: rt, height: ht }),
              j === "Scatter Plot" && /* @__PURE__ */ a(
                wk,
                {
                  xScale: Rt,
                  yScale: Ct,
                  getXAxisData: _e,
                  getYAxisData: we,
                  xMax: rt,
                  yMax: ht,
                  handleTooltipMouseOver: Dt,
                  handleTooltipMouseOff: sn,
                  handleTooltipClick: bn,
                  tooltipData: Pt,
                  showTooltip: jt
                }
              ),
              j === "Box Plot" && /* @__PURE__ */ a(
                Sk,
                {
                  seriesScale: xn,
                  xMax: rt,
                  yMax: ht,
                  min: wt,
                  max: qt,
                  xScale: Rt,
                  yScale: Ct
                }
              ),
              (j === "Area Chart" && o.visualizationSubType === "regular" || j === "Combo") && /* @__PURE__ */ a(
                lk,
                {
                  xScale: Rt,
                  yScale: Ct,
                  yMax: ht,
                  xMax: rt,
                  chartRef: n,
                  width: rt,
                  height: ht,
                  handleTooltipMouseOver: Dt,
                  handleTooltipMouseOff: sn,
                  tooltipData: Pt,
                  showTooltip: jt
                }
              ),
              (j === "Area Chart" && o.visualizationSubType === "stacked" || j === "Combo") && /* @__PURE__ */ a(
                uk,
                {
                  xScale: Rt,
                  yScale: Ct,
                  yMax: ht,
                  xMax: rt,
                  chartRef: n,
                  width: rt,
                  height: ht,
                  handleTooltipMouseOver: Dt,
                  handleTooltipMouseOff: sn,
                  tooltipData: Pt,
                  showTooltip: jt
                }
              ),
              (j === "Bar" || j === "Combo" || d) && /* @__PURE__ */ a(
                pk,
                {
                  xScale: Rt,
                  yScale: Ct,
                  seriesScale: xn,
                  xMax: rt,
                  yMax: ht,
                  getXAxisData: _e,
                  getYAxisData: we,
                  animatedChart: je,
                  visible: je,
                  handleTooltipMouseOver: Dt,
                  handleTooltipMouseOff: sn,
                  handleTooltipClick: bn,
                  tooltipData: Pt,
                  showTooltip: jt,
                  chartRef: n
                }
              ),
              (j === "Line" && !d || j === "Combo" || j === "Bump Chart") && /* @__PURE__ */ a(
                mm,
                {
                  xScale: Rt,
                  yScale: Ct,
                  getXAxisData: _e,
                  getYAxisData: we,
                  xMax: rt,
                  yMax: ht,
                  seriesStyle: o.runtime.series,
                  handleTooltipMouseOver: Dt,
                  handleTooltipMouseOff: sn,
                  handleTooltipClick: bn,
                  tooltipData: Pt,
                  showTooltip: jt,
                  chartRef: n
                }
              ),
              (j === "Forecasting" || j === "Combo") && /* @__PURE__ */ a(
                Ck,
                {
                  showTooltip: jt,
                  tooltipData: Pt,
                  xScale: Rt,
                  yScale: Ct,
                  width: rt,
                  le: !0,
                  height: ht,
                  xScaleNoPadding: On,
                  chartRef: n,
                  getXValueFromCoordinate: ir,
                  handleTooltipMouseOver: Dt,
                  handleTooltipMouseOff: sn,
                  isBrush: !1
                }
              ),
              j === "Forest Plot" && /* @__PURE__ */ a(
                Fk,
                {
                  xScale: Rt,
                  yScale: Ct,
                  seriesScale: xn,
                  width: Bt,
                  height: zt,
                  getXAxisData: _e,
                  getYAxisData: we,
                  animatedChart: je,
                  visible: je,
                  handleTooltipMouseOver: Dt,
                  handleTooltipMouseOff: sn,
                  handleTooltipClick: bn,
                  tooltipData: Pt,
                  showTooltip: jt,
                  chartRef: n,
                  config: o,
                  forestPlotRightLabelRef: Fe
                }
              ),
              o.brush.active && o.xAxis.type !== "categorical" && /* @__PURE__ */ a(ak, { xMax: rt, yMax: ht }),
              !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(
                j
              ) && !d && /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ a(
                mm,
                {
                  xScale: Rt,
                  yScale: Ct,
                  getXAxisData: _e,
                  getYAxisData: we,
                  xMax: rt,
                  yMax: ht,
                  seriesStyle: o.runtime.series
                }
              ) }),
              o.yAxis.anchors && o.yAxis.anchors.map((D, K) => {
                let pe = Ct(D.value), O = 0;
                if (D.value && (o.yAxis.labelPlacement === "Below Bar" ? O = -6.5 + Number(o.series.length * o.barHeight) / o.series.length : O = 8, !!pe))
                  return (
                    // prettier-ignore
                    /* @__PURE__ */ a(
                      rn,
                      {
                        strokeDasharray: x(D.lineStyle),
                        stroke: D.color ? D.color : "rgba(0,0,0,1)",
                        className: "anchor-y",
                        from: { x: 0 + It, y: pe - O },
                        to: { x: Bt - o.yAxis.rightAxisSize, y: pe - O }
                      },
                      `yAxis-${D.value}--${K}`
                    )
                  );
              }),
              o.xAxis.anchors && o.xAxis.anchors.map((D, K) => {
                let pe = X;
                re === "horizontal" && (pe = se);
                let $ = (() => {
                  let ee;
                  return ee = Tn(pe) ? Rt(b(D.value, !1)) : Rt(D.value), (o.xAxis.type === "categorical" || o.xAxis.type === "date") && (ee = ee ? ee + (pe.type === "categorical" || pe.type === "date" ? Rt.bandwidth() : 0) / 2 : 0), ee;
                })();
                if ($)
                  return (
                    // prettier-ignore
                    /* @__PURE__ */ a(
                      rn,
                      {
                        strokeDasharray: x(D.lineStyle),
                        stroke: D.color ? D.color : "rgba(0,0,0,1)",
                        fill: D.color ? D.color : "rgba(0,0,0,1)",
                        className: "anchor-x",
                        from: { x: Number($) + Number(It), y: 0 },
                        to: { x: Number($) + Number(It), y: ht }
                      },
                      `xAxis-${D.value}--${K}`
                    )
                  );
              }),
              o.visualizationType !== "Bar" && o.visualizationType !== "Combo" && /* @__PURE__ */ a(
                kh,
                {
                  xScale: Rt,
                  handleTooltipClick: bn,
                  handleTooltipMouseOff: sn,
                  handleTooltipMouseOver: Dt,
                  showTooltip: jt,
                  hideTooltip: kn,
                  tooltipData: Pt,
                  yMax: ht,
                  width: Bt
                }
              ),
              ar && jt && Pt && o.visual.verticalHoverLine && /* @__PURE__ */ a(it, { className: "vertical-tooltip-line", children: /* @__PURE__ */ a(
                rn,
                {
                  from: { x: Pt.dataXPosition - 10, y: 0 },
                  to: { x: Pt.dataXPosition - 10, y: ht },
                  stroke: "black",
                  strokeWidth: 1,
                  pointerEvents: "none",
                  strokeDasharray: "5,5",
                  className: "vertical-tooltip-line"
                }
              ) }, "tooltipLine-vertical"),
              ar && jt && Pt && o.visual.horizontalHoverLine && /* @__PURE__ */ a(
                it,
                {
                  className: "horizontal-tooltip-line",
                  left: o.yAxis.size ? o.yAxis.size : 0,
                  children: /* @__PURE__ */ a(
                    rn,
                    {
                      from: { x: 0, y: Pt.dataYPosition },
                      to: { x: rt, y: Pt.dataYPosition },
                      stroke: "black",
                      strokeWidth: 1,
                      pointerEvents: "none",
                      strokeDasharray: "5,5",
                      className: "horizontal-tooltip-line"
                    }
                  )
                },
                "tooltipLine-horizontal"
              ),
              Pe && /* @__PURE__ */ a(
                gt,
                {
                  x: Number(o.yAxis.size) + Number(rt / 2),
                  y: dn / 2 - (o.xAxis.padding || 0) / 2,
                  textAnchor: "middle",
                  children: o.chartMessage.noData
                }
              ),
              (o.visualizationType === "Bar" || d) && o.tooltips.singleSeries && o.visual.horizontalHoverLine && /* @__PURE__ */ a(
                it,
                {
                  className: "horizontal-tooltip-line",
                  left: o.yAxis.size ? o.yAxis.size : 0,
                  children: /* @__PURE__ */ a(
                    rn,
                    {
                      from: { x: 0, y: ye.y },
                      to: { x: rt, y: ye.y },
                      stroke: "black",
                      strokeWidth: 1,
                      pointerEvents: "none",
                      strokeDasharray: "5,5",
                      className: "horizontal-tooltip-line"
                    }
                  )
                },
                "tooltipLine-horizontal"
              ),
              (o.visualizationType === "Bar" || d) && o.tooltips.singleSeries && o.visual.verticalHoverLine && /* @__PURE__ */ a(it, { className: "vertical-tooltip-line", children: /* @__PURE__ */ a(
                rn,
                {
                  from: { x: ye.x, y: 0 },
                  to: { x: ye.x, y: ht },
                  stroke: "black",
                  strokeWidth: 1,
                  pointerEvents: "none",
                  strokeDasharray: "5,5",
                  className: "vertical-tooltip-line"
                }
              ) }, "tooltipLine-vertical"),
              /* @__PURE__ */ a(it, { left: Number(o.runtime.yAxis.size), children: /* @__PURE__ */ a(
                Ah.Draggable,
                {
                  xScale: Rt,
                  yScale: Ct,
                  xScaleAnnotation: En,
                  xMax: rt,
                  svgRef: n,
                  onDragStateChange: T
                }
              ) }),
              !["Spark Line", "Forest Plot"].includes(j) && o.yAxis.type !== "categorical" && /* @__PURE__ */ a(
                sm,
                {
                  scale: Ct,
                  tickLength: ut ? 6 : 8,
                  left: Number(Y.yAxis.size) - o.yAxis.axisPadding,
                  label: Y.yAxis.label || Y.yAxis.label,
                  stroke: "#333",
                  tickFormat: $n,
                  numTicks: wn,
                  children: (D) => {
                    const K = o.orientation === "horizontal" ? (D.axisToPoint.y - D.axisFromPoint.y) / 2 : (D.axisFromPoint.y - D.axisToPoint.y) / 2, pe = ht / D.ticks.length / 2 - ht / D.ticks.length * (1 - o.barThickness) + 5;
                    return /* @__PURE__ */ z(it, { className: "left-axis", children: [
                      !o.yAxis.hideAxis && /* @__PURE__ */ a(
                        rn,
                        {
                          from: D.axisFromPoint,
                          to: Y.horizontal ? {
                            x: 0,
                            y: o.visualizationType === "Forest Plot" ? e : Number(B.horizontal)
                          } : D.axisToPoint,
                          stroke: "#000"
                        }
                      ),
                      Ct.domain()[0] < 0 && /* @__PURE__ */ a(
                        rn,
                        {
                          from: { x: D.axisFromPoint.x, y: Ct(0) },
                          to: { x: rt, y: Ct(0) },
                          stroke: "#333"
                        }
                      ),
                      j === "Bar" && re === "horizontal" && Rt.domain()[0] < 0 && /* @__PURE__ */ a(
                        rn,
                        {
                          from: { x: Rt(0), y: 0 },
                          to: { x: Rt(0), y: ht },
                          stroke: "#333",
                          strokeWidth: 2
                        }
                      ),
                      D.ticks.map((O, $) => {
                        const ee = D.ticks[0].to.y, be = 15, Ie = String(O.value).startsWith("1") || O.value === 0.1 ? "block" : "none", Qe = Ie === "block" ? 7 : 0, pt = { x: O.to.x - Qe, y: O.to.y }, Ut = D.ticks.length - 1 === $, $t = Ut && Q && J && !Kt, Jt = G ? ne ? -8 : -12 : uT, en = G ? 4 : 0, Vn = O.to.x - Jt, Zn = O.to.y - en, Qn = G ? "end" : "middle", Un = Q && G && J && Ut;
                        return /* @__PURE__ */ z(it, { className: "vx-axis-tick", children: [
                          !Y.yAxis.hideTicks && !G && !$t && /* @__PURE__ */ a(
                            rn,
                            {
                              from: O.from,
                              to: ut ? pt : O.to,
                              stroke: o.yAxis.tickColor,
                              display: re === "horizontal" ? "none" : "block",
                              fontSize: Tt
                            },
                            `${O.value}--hide-hideTicks`
                          ),
                          re === "horizontal" && Z !== "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            gt,
                            {
                              transform: `translate(${O.to.x - 5}, ${o.isLollipopChart ? O.to.y - ee : O.to.y - ee + (Number(o.barHeight * o.runtime.series.length) - be) / 2}) rotate(-${o.runtime.horizontal && o.runtime.yAxis.tickRotation || 0})`,
                              verticalAnchor: "start",
                              textAnchor: "end",
                              fontSize: Tt,
                              children: O.formattedValue
                            }
                          ),
                          re === "horizontal" && Z === "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            gt,
                            {
                              transform: `translate(${O.to.x - 5}, ${O.to.y - ee + (Number(o.barHeight) - be) / 2}) rotate(-${Y.horizontal ? Y.yAxis.tickRotation : 0})`,
                              verticalAnchor: "start",
                              textAnchor: "end",
                              fontSize: Tt,
                              children: O.formattedValue
                            }
                          ),
                          re === "horizontal" && j === "Paired Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            gt,
                            {
                              transform: `translate(${O.to.x - 5}, ${O.to.y - ee + Number(o.barHeight) / 2}) rotate(-${Y.horizontal ? Y.yAxis.tickRotation : 0})`,
                              textAnchor: "end",
                              verticalAnchor: "middle",
                              fontSize: Tt,
                              children: O.formattedValue
                            }
                          ),
                          re === "horizontal" && j === "Deviation Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            gt,
                            {
                              transform: `translate(${O.to.x - 5}, ${o.isLollipopChart ? O.to.y - ee + 2 : O.to.y - ee + Number(o.barHeight) / 2}) rotate(-${Y.horizontal ? Y.yAxis.tickRotation : 0})`,
                              textAnchor: "end",
                              verticalAnchor: "middle",
                              fontSize: Tt,
                              children: O.formattedValue
                            }
                          ),
                          re === "vertical" && j === "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ z(Ue, { children: [
                            /* @__PURE__ */ a(
                              gt,
                              {
                                display: o.useLogScale ? Ie : "block",
                                dx: o.useLogScale ? -6 : 0,
                                x: o.runtime.horizontal ? O.from.x + 2 : O.to.x - 8.5,
                                y: O.to.y - 13 + (o.runtime.horizontal ? pe : 0),
                                angle: -Number(o.yAxis.tickRotation) || 0,
                                verticalAnchor: o.runtime.horizontal ? "start" : "middle",
                                textAnchor: o.runtime.horizontal ? "start" : "end",
                                fill: o.yAxis.tickLabelColor,
                                fontSize: Tt,
                                children: o.runtime.seriesLabelsAll[O.formattedValue - 1]
                              }
                            ),
                            (L.length === 0 || L.includes(
                              o.runtime.seriesLabelsAll[O.formattedValue - 1]
                            )) && /* @__PURE__ */ a(
                              "rect",
                              {
                                x: 0 - Number(o.yAxis.size),
                                y: O.to.y - 8 + (o.runtime.horizontal ? pe : 7),
                                width: Number(o.yAxis.size) + Rt(Rt.domain()[0]),
                                height: "2",
                                fill: i(o.runtime.seriesLabelsAll[O.formattedValue - 1])
                              }
                            )
                          ] }),
                          re === "vertical" && j !== "Paired Bar" && j !== "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ z(Ue, { children: [
                            Q && Ut && !G && /* @__PURE__ */ a(
                              Yh,
                              {
                                innerRef: Je,
                                display: ut ? Ie : "block",
                                dx: ut ? -6 : 0,
                                x: Vn,
                                y: Zn,
                                angle: -Number(o.yAxis.tickRotation) || 0,
                                verticalAnchor: Qn,
                                textAnchor: Kt ? "end" : "start",
                                fill: o.yAxis.tickLabelColor,
                                stroke: "#fff",
                                paintOrder: "stroke",
                                strokeLinejoin: "round",
                                style: { whiteSpace: "pre-wrap" },
                                fontSize: Tt,
                                children: J
                              }
                            ),
                            /* @__PURE__ */ a(
                              Yh,
                              {
                                innerRef: (Tr) => Ut && (Ke.current = Tr),
                                display: ut ? Ie : "block",
                                dx: ut ? -6 : 0,
                                x: Kt ? Vn - he : Vn,
                                y: Zn + (o.runtime.horizontal ? pe : 0),
                                angle: -Number(o.yAxis.tickRotation) || 0,
                                verticalAnchor: o.runtime.horizontal ? "start" : Qn,
                                textAnchor: o.runtime.horizontal || G ? "start" : "end",
                                fill: o.yAxis.tickLabelColor,
                                stroke: "#fff",
                                disableStroke: !G,
                                strokeLinejoin: "round",
                                paintOrder: "stroke",
                                style: { whiteSpace: "pre-wrap" },
                                fontSize: Tt,
                                children: `${O.formattedValue}${Un ? J : ""}`
                              }
                            )
                          ] })
                        ] }, `vx-tick-${O.value}-${$}`);
                      }),
                      /* @__PURE__ */ a(
                        gt,
                        {
                          className: "y-label",
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          transform: `translate(${-1 * Y.yAxis.size + ln}, ${K}) rotate(-90)`,
                          fontWeight: "bold",
                          fill: o.yAxis.labelColor,
                          fontSize: Ot,
                          children: D.label
                        }
                      )
                    ] });
                  }
                }
              ),
              o.yAxis.type === "categorical" && o.orientation === "vertical" && /* @__PURE__ */ a(
                Bk,
                {
                  max: qt,
                  maxValue: ce,
                  height: dn,
                  xMax: rt,
                  yMax: ht,
                  leftSize: Number(Y.yAxis.size) - o.yAxis.axisPadding
                }
              ),
              Yt && /* @__PURE__ */ a(
                Hw,
                {
                  scale: Wt,
                  left: Number(Bt - o.yAxis.rightAxisSize),
                  label: o.yAxis.rightLabel,
                  tickFormat: (D) => m(D, "right"),
                  numTicks: Y.yAxis.rightNumTicks || void 0,
                  labelOffset: 45,
                  children: (D) => {
                    const K = o.orientation === "horizontal" ? (D.axisToPoint.y - D.axisFromPoint.y) / 2 : (D.axisFromPoint.y - D.axisToPoint.y) / 2, pe = ht / D.ticks.length / 2 - ht / D.ticks.length * (1 - o.barThickness) + 5;
                    return /* @__PURE__ */ z(it, { className: "right-axis", children: [
                      D.ticks.map((O, $) => /* @__PURE__ */ z(it, { className: "vx-axis-tick", children: [
                        !Y.yAxis.rightHideTicks && /* @__PURE__ */ a(
                          rn,
                          {
                            from: O.from,
                            to: O.to,
                            display: Y.horizontal ? "none" : "block",
                            stroke: o.yAxis.rightAxisTickColor
                          }
                        ),
                        Y.yAxis.rightGridLines ? /* @__PURE__ */ a(rn, { from: { x: O.from.x + rt, y: O.from.y }, to: O.from, stroke: "#d6d6d6" }) : "",
                        !o.yAxis.rightHideLabel && /* @__PURE__ */ a(
                          gt,
                          {
                            x: O.to.x,
                            y: O.to.y + (Y.horizontal ? pe : 0),
                            verticalAnchor: Y.horizontal ? "start" : "middle",
                            textAnchor: "start",
                            fill: o.yAxis.rightAxisTickLabelColor,
                            fontSize: Tt,
                            children: O.formattedValue
                          }
                        )
                      ] }, `vx-tick-${O.value}-${$}`)),
                      !o.yAxis.rightHideAxis && /* @__PURE__ */ a(rn, { from: D.axisFromPoint, to: D.axisToPoint, stroke: "#333" }),
                      /* @__PURE__ */ a(
                        gt,
                        {
                          className: "y-label",
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          transform: `translate(${o.yAxis.rightLabelOffsetSize ? o.yAxis.rightLabelOffsetSize : 0}, ${K}) rotate(-90)`,
                          fontWeight: "bold",
                          fill: o.yAxis.rightAxisLabelColor,
                          fontSize: Ot,
                          children: D.label
                        }
                      )
                    ] });
                  }
                }
              ),
              De && o.topAxis.hasLine && /* @__PURE__ */ a(
                Uw,
                {
                  stroke: "#333",
                  left: Number(Y.yAxis.size),
                  scale: Rt,
                  hideTicks: !0,
                  hideZero: !0,
                  tickLabelProps: () => ({
                    fill: "transparent"
                  })
                }
              ),
              j !== "Paired Bar" && j !== "Spark Line" && /* @__PURE__ */ a(
                Yu,
                {
                  innerRef: We,
                  top: Y.horizontal && o.visualizationType !== "Forest Plot" ? Number(B.horizontal) + Number(o.xAxis.axisPadding) : o.visualizationType === "Forest Plot" ? ht + Number(o.xAxis.axisPadding) : ht,
                  left: o.visualizationType !== "Forest Plot" ? Number(Y.yAxis.size) : 0,
                  label: o[at].label,
                  tickFormat: Hn,
                  scale: Rt,
                  stroke: "#333",
                  numTicks: yn ? Rn : Mn,
                  tickStroke: "#333",
                  tickValues: o.runtime.xAxis.manual ? jk(yt, Rt, Lt ? Mn : gr(), o) : o.runtime.xAxis.type === "date" ? yt : void 0,
                  children: (D) => {
                    var wi;
                    const K = o.series.some((Nt) => Nt.dynamicCategory);
                    o.runtime.xAxis.type === "date" && !o.runtime.xAxis.manual && !K && (D.ticks = Uk(o, D, yt, p));
                    const pe = yn && Rt.ticks(Mn).map(
                      (Nt) => D.ticks.findIndex(
                        (pn) => (typeof pn.value == "number" ? pn.value : pn.value.getTime()) === Nt.getTime()
                      )
                    ).slice(0, 2).reduce((Nt, pn) => pn - Nt), O = yn ? [...D.ticks].reverse().filter((Nt, pn) => pn % pe === 0).reverse().map((Nt, pn, oi) => ({
                      ...Nt,
                      // reformat in case showYearsOnce, since first month of year may have changed
                      formattedValue: Hn(Nt.value, pn, oi)
                    })) : D.ticks, $ = on + ff, ee = (Nt) => /\s/.test(Nt), be = O.some((Nt) => ee(Nt.value)), Ie = Math.max(
                      ...O.map((Nt) => yr(Nt.formattedValue, _t))
                    ), Qe = be ? 180 : 100, pt = O.map((Nt) => yr(Nt.formattedValue, _t)), Ut = pt.reduce((Nt, pn) => Nt + pn, Qe), $t = (rt - Ut) / (O.length - 1);
                    let Qt = [0];
                    for (let Nt = 1; Nt < pt.length; Nt++)
                      Qt[Nt] = Qt[Nt - 1] + pt[Nt - 1] + $t;
                    const Jt = (wi = We == null ? void 0 : We.current) == null ? void 0 : wi.getBBox().height;
                    o.xAxis.axisBBox = Jt;
                    let en = !1;
                    pt.forEach((Nt, pn) => {
                      if (Qt[pn] + pt[pn] > Qt[pn + 1]) {
                        en = !0;
                        return;
                      }
                    }), o.xAxis.showYearsOnce && (en = !0);
                    const Vn = pt[pt.length - 1], Qn = Qt[Qt.length - 1] + Vn + Vn / 2, Un = rt - Vn;
                    Qn > Un && (en = !0);
                    const Tr = en && o.isResponsiveTicks ? Ie + pf + 20 : 0;
                    return o.dynamicMarginTop = Tr, o.xAxis.tickWidthMax = Ie, /* @__PURE__ */ z(it, { className: "bottom-axis", width: s[0], children: [
                      O.map((Nt, pn, oi) => {
                        const Or = String(Nt.value).startsWith("1") || Nt.value === 0.1 ? "block" : "none", sr = Or === "block" ? 16 : pf, Mr = { x: Nt.to.x, y: sr }, Kr = 100 / oi.length;
                        o.yAxis.tickRotation = o.isResponsiveTicks && o.orientation === "horizontal" ? 0 : o.yAxis.tickRotation, o.xAxis.tickRotation = o.isResponsiveTicks && o.orientation === "vertical" ? 0 : o.xAxis.tickRotation;
                        const Ht = o.isResponsiveTicks && en ? -Number(o.xAxis.maxTickRotation) || -90 : -Number(o.runtime.xAxis.tickRotation);
                        return /* @__PURE__ */ z(it, { className: "vx-axis-tick", children: [
                          !o.xAxis.hideTicks && /* @__PURE__ */ a(
                            rn,
                            {
                              from: Nt.from,
                              to: re === "horizontal" && ut ? Mr : Nt.to,
                              stroke: o.xAxis.tickColor,
                              strokeWidth: Or === "block" && ut ? 1.3 : 1
                            }
                          ),
                          !o.xAxis.hideLabel && /* @__PURE__ */ a(
                            gt,
                            {
                              innerRef: (vr) => Xe.current[pn] = vr,
                              dy: o.orientation === "horizontal" && ut ? 8 : 0,
                              display: o.orientation === "horizontal" && ut ? Or : "block",
                              x: Nt.to.x,
                              y: Nt.to.y + hf,
                              angle: Ht,
                              verticalAnchor: Ht < -50 ? "middle" : "start",
                              textAnchor: Ht ? "end" : "middle",
                              width: en && !o.isResponsiveTicks && !Number(o[at].tickRotation) ? Kr : void 0,
                              fill: o.xAxis.tickLabelColor,
                              fontSize: Tt,
                              children: Nt.formattedValue
                            }
                          )
                        ] }, `vx-tick-${Nt.value}-${pn}`);
                      }),
                      !o.xAxis.hideAxis && /* @__PURE__ */ a(rn, { from: D.axisFromPoint, to: D.axisToPoint, stroke: "#333" }),
                      /* @__PURE__ */ a(
                        gt,
                        {
                          innerRef: Ae,
                          className: "x-axis-title-label",
                          x: rt / 2,
                          y: st ? 0 : $,
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          fontWeight: "bold",
                          fill: o.xAxis.labelColor,
                          fontSize: Ot,
                          children: D.label
                        }
                      )
                    ] });
                  }
                }
              )
            ]
          }
        ),
        !y && Pt && Object.entries(Pt.data).length > 0 && tn && jt && Pt.dataYPosition && Pt.dataXPosition && /* @__PURE__ */ z(Ue, { children: [
          /* @__PURE__ */ a("style", { children: `.tooltip {background-color: rgba(255,255,255, ${o.tooltips.opacity / 100}) !important;` }),
          /* @__PURE__ */ a("style", { children: ".tooltip {max-width:300px} !important; word-wrap: break-word; " }),
          /* @__PURE__ */ a(
            Wy,
            {
              className: "tooltip cdc-open-viz-module",
              left: fn,
              top: An,
              children: /* @__PURE__ */ a("ul", { children: typeof Pt == "object" && Object.entries(Pt.data).filter(([D, K]) => Array.isArray(K) && !K.includes(void 0)).map((D, K) => /* @__PURE__ */ a(hn, { item: D }, K)) })
            },
            Math.random()
          )
        ] }),
        o.visualizationType === "Bump Chart" && /* @__PURE__ */ a(
          xc,
          {
            id: "bump-chart",
            variant: "light",
            arrowColor: "rgba(0,0,0,0)",
            className: "tooltip",
            style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
          }
        ),
        xe() && !y && /* @__PURE__ */ a(
          xc,
          {
            id: `cdc-open-viz-tooltip-${Y.uniqueId}`,
            variant: "light",
            arrowColor: "rgba(0,0,0,0)",
            className: "tooltip",
            style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
          }
        ),
        /* @__PURE__ */ a("div", { className: "animation-trigger", ref: Ye })
      ]
    }
  ) });
});
const cT = (e) => {
  var se;
  const { width: t, height: n } = e, { transformedData: r, config: i, parseDate: o, formatDate: d, seriesHighlight: c, formatNumber: s, colorScale: p, handleChartAriaLabels: m } = de.useContext(vt);
  let g = Number(t);
  const { minValue: x, maxValue: T } = Uc(i, r), y = { top: 5, right: 10, bottom: 10, left: 10 }, A = Number(n), b = g - i.runtime.yAxis.size, v = A - y.top - 20, E = (Y) => i.runtime.xAxis.type === "date" ? o(Y[i.runtime.originalXAxis.dataKey]).getTime() : Y[i.runtime.originalXAxis.dataKey], N = (Y, ie) => Y[ie];
  let R, L;
  const { max: B, min: j } = i.runtime.yAxis, Z = Number(B) >= Number(T), re = Number(j) <= Number(x);
  if (r) {
    let Y = Number(j && re ? j : x), ie = Number(B && Z ? B : Number.MIN_VALUE);
    if (ie === Number.MIN_VALUE && (ie = T), i.runtime.yAxis.paddingPercent) {
      let U = (ie - Y) * i.runtime.yAxis.paddingPercent;
      Y -= U, ie += U;
    }
    let I = r.map((U) => E(U));
    i.runtime.horizontal ? (R = In({
      domain: [Y, ie],
      range: [0, b]
    }), L = i.runtime.xAxis.type === "date" ? In({ domain: [Math.min(...I), Math.max(...I)] }) : al({ domain: I, padding: 0.5 }), al({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, v]
    }), L.rangeRound([0, v])) : (Y = Y < 0 ? Y * 1.11 : Y, L = In({
      domain: [Y, ie],
      range: [v - y.bottom, y.top]
    }), R = al({
      domain: I,
      range: [y.left, g - y.right]
    }), al({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, b]
    }));
  }
  const X = [R.domain()[0], R.domain()[R.domain().length - 1]];
  return /* @__PURE__ */ a(Ur, { component: "SparkLine", children: /* @__PURE__ */ z("svg", { role: "img", "aria-label": m(i), width: t, height: 100, className: "sparkline", tabIndex: 0, children: [
    /* @__PURE__ */ a("title", { children: `Spark line graphic with the title ${i.title ? i.title : "No Title Found"}` }),
    ((se = i.runtime.lineSeriesKeys) == null ? void 0 : se.length) > 0 ? i.runtime.lineSeriesKeys : i.runtime.seriesKeys.map((Y, ie) => /* @__PURE__ */ z(Ue, { children: [
      /* @__PURE__ */ z(
        it,
        {
          style: { width: g },
          className: "sparkline-group",
          opacity: i.legend.behavior === "highlight" && c.length > 0 && c.indexOf(Y) === -1 ? 0.5 : 1,
          display: i.legend.behavior === "highlight" || c.length === 0 || c.indexOf(Y) !== -1 ? "block" : "none",
          children: [
            i.labels && r.map((I, U) => /* @__PURE__ */ a(it, { children: /* @__PURE__ */ a(gt, { x: R(E(I)), y: L(N(I, Y)), fill: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[Y] : Y) : "#000", textAnchor: "middle", children: s(I[Y]) }) }, `series-${Y}-point-${U}`)),
            /* @__PURE__ */ a(
              jr,
              {
                curve: zc,
                data: r,
                x: (I) => R(E(I)),
                y: (I) => L(N(I, Y)),
                stroke: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[Y] : Y) : "#000",
                strokeWidth: 2,
                strokeOpacity: 1,
                shapeRendering: "geometricPrecision",
                markerEnd: `url(#arrow--${ie})`
              }
            ),
            /* @__PURE__ */ a(Lm, { id: `arrow--${ie}`, refX: 2, size: 6, markerEnd: `url(#arrow--${ie})`, strokeOpacity: 1, fillOpacity: 1, fill: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[Y] : Y) : "#000" })
          ]
        },
        `series-${Y}`
      ),
      /* @__PURE__ */ a(
        Yu,
        {
          top: v + y.top,
          hideAxisLine: !0,
          hideTicks: !0,
          scale: R,
          tickValues: X,
          tickFormat: (I) => i.xAxis.type === "date" ? d(I) : null,
          stroke: "black",
          tickStroke: "black",
          tickLabelProps: () => ({
            fill: "black",
            fontSize: 11,
            textAnchor: "middle"
          })
        }
      )
    ] }))
  ] }) });
};
var dT = ["flexDirection", "alignItems", "margin", "display", "children"];
function Yf() {
  return Yf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Yf.apply(this, arguments);
}
function fT(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Ec(e) {
  var t = e.flexDirection, n = t === void 0 ? "row" : t, r = e.alignItems, i = r === void 0 ? "center" : r, o = e.margin, d = o === void 0 ? "0" : o, c = e.display, s = c === void 0 ? "flex" : c, p = e.children, m = fT(e, dT);
  return /* @__PURE__ */ Ve.createElement("div", Yf({
    className: "visx-legend-item",
    style: {
      display: s,
      alignItems: i,
      flexDirection: n,
      margin: d
    }
  }, m), p);
}
Ec.propTypes = {
  alignItems: ze.string,
  margin: ze.oneOfType([ze.string, ze.number]),
  children: ze.node,
  display: ze.string
};
var hT = ["flex", "label", "margin", "align", "children"];
function Gf() {
  return Gf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Gf.apply(this, arguments);
}
function pT(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Rc(e) {
  var t = e.flex, n = t === void 0 ? "1" : t, r = e.label, i = e.margin, o = i === void 0 ? "5px 0" : i, d = e.align, c = d === void 0 ? "left" : d, s = e.children, p = pT(e, hT);
  return /* @__PURE__ */ Ve.createElement("div", Gf({
    className: "visx-legend-label",
    style: {
      justifyContent: c,
      display: "flex",
      flex: n,
      margin: o
    }
  }, p), s || r);
}
Rc.propTypes = {
  align: ze.string,
  label: ze.node,
  flex: ze.oneOfType([ze.string, ze.number]),
  margin: ze.oneOfType([ze.string, ze.number]),
  children: ze.node
};
function Xf() {
  return Xf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Xf.apply(this, arguments);
}
function Lh(e) {
  var t = e.fill, n = e.width, r = e.height, i = e.style;
  return /* @__PURE__ */ Ve.createElement("div", {
    style: Xf({
      width: n,
      height: r,
      background: t
    }, i)
  });
}
Lh.propTypes = {
  fill: ze.string,
  width: ze.oneOfType([ze.string, ze.number]),
  height: ze.oneOfType([ze.string, ze.number])
};
function pg(e) {
  var t = e.fill, n = e.width, r = e.height, i = e.style, o = typeof n == "string" || typeof n > "u" ? 0 : n, d = typeof r == "string" || typeof r > "u" ? 0 : r, c = Math.max(o, d), s = c / 2;
  return /* @__PURE__ */ Ve.createElement("svg", {
    width: c,
    height: c
  }, /* @__PURE__ */ Ve.createElement(it, {
    top: s,
    left: s
  }, /* @__PURE__ */ Ve.createElement("circle", {
    r: s,
    fill: t,
    style: i
  })));
}
pg.propTypes = {
  fill: ze.string,
  width: ze.oneOfType([ze.string, ze.number]),
  height: ze.oneOfType([ze.string, ze.number])
};
function mg(e) {
  var t = e.fill, n = e.width, r = e.height, i = e.style, o = typeof r == "string" || typeof r > "u" ? 0 : r, d = typeof (i == null ? void 0 : i.strokeWidth) == "number" ? i == null ? void 0 : i.strokeWidth : 2;
  return /* @__PURE__ */ Ve.createElement("svg", {
    width: n,
    height: r
  }, /* @__PURE__ */ Ve.createElement(it, {
    top: o / 2 - d / 2
  }, /* @__PURE__ */ Ve.createElement("line", {
    x1: 0,
    x2: n,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: d,
    style: i
  })));
}
mg.propTypes = {
  fill: ze.string,
  width: ze.oneOfType([ze.string, ze.number]),
  height: ze.oneOfType([ze.string, ze.number])
};
function ks() {
  return ks = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ks.apply(this, arguments);
}
var yf = function() {
};
function mT(e) {
  var t = e.shape, n = t === void 0 ? "rect" : t, r = e.fill, i = r === void 0 ? yf : r, o = e.size, d = o === void 0 ? yf : o, c = e.width, s = e.height, p = e.label, m = e.item, g = e.itemIndex, x = e.shapeStyle, T = x === void 0 ? yf : x, y = {
    width: c,
    height: s,
    item: m,
    itemIndex: g,
    label: p,
    fill: i(ks({}, p)),
    size: d(ks({}, p)),
    style: T(ks({}, p))
  };
  return typeof n == "string" ? n === "circle" ? /* @__PURE__ */ Ve.createElement(pg, y) : n === "line" ? /* @__PURE__ */ Ve.createElement(mg, y) : /* @__PURE__ */ Ve.createElement(Lh, y) : /* @__PURE__ */ Ve.isValidElement(n) ? /* @__PURE__ */ Ve.cloneElement(n, y) : n ? /* @__PURE__ */ Ve.createElement(n, y) : null;
}
function Nc() {
  return Nc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Nc.apply(this, arguments);
}
function yg(e) {
  var t = e.shape, n = t === void 0 ? Lh : t, r = e.width, i = e.height, o = e.margin, d = e.label, c = e.item, s = e.itemIndex, p = e.fill, m = e.size, g = e.shapeStyle;
  return /* @__PURE__ */ Ve.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: m ? m(Nc({}, d)) : r,
      height: m ? m(Nc({}, d)) : i,
      margin: o
    }
  }, mT({
    shape: n,
    item: c,
    itemIndex: s,
    label: d,
    width: r,
    height: i,
    fill: p,
    shapeStyle: g
  }));
}
yg.propTypes = {
  itemIndex: ze.number.isRequired,
  margin: ze.oneOfType([ze.string, ze.number]),
  width: ze.oneOfType([ze.string, ze.number]),
  height: ze.oneOfType([ze.string, ze.number])
};
function gg(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function gm(e) {
  return String(gg(e));
}
function yT(e) {
  var t = e.scale, n = e.labelFormat;
  return function(r, i) {
    return {
      datum: r,
      index: i,
      text: "" + n(r, i),
      value: t(r)
    };
  };
}
var gT = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function Ts() {
  return Ts = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ts.apply(this, arguments);
}
function vT(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var xT = {
  display: "flex"
};
function vg(e) {
  var t = e.className, n = e.style, r = n === void 0 ? xT : n, i = e.scale, o = e.shape, d = e.domain, c = e.fill, s = c === void 0 ? gm : c, p = e.size, m = p === void 0 ? gm : p, g = e.labelFormat, x = g === void 0 ? gg : g, T = e.labelTransform, y = T === void 0 ? yT : T, A = e.shapeWidth, b = A === void 0 ? 15 : A, v = e.shapeHeight, E = v === void 0 ? 15 : v, N = e.shapeMargin, R = N === void 0 ? "2px 4px 2px 0" : N, L = e.shapeStyle, B = e.labelAlign, j = B === void 0 ? "left" : B, Z = e.labelFlex, re = Z === void 0 ? "1" : Z, X = e.labelMargin, se = X === void 0 ? "0 4px" : X, Y = e.itemMargin, ie = Y === void 0 ? "0" : Y, I = e.direction, U = I === void 0 ? "column" : I, ue = e.itemDirection, te = ue === void 0 ? "row" : ue, J = e.legendLabelProps, Q = e.children, G = vT(e, gT), ne = d || ("domain" in i ? i.domain() : []), H = y({
    scale: i,
    labelFormat: x
  }), ce = ne.map(H);
  return Q ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, Q(ce)) : /* @__PURE__ */ Ve.createElement("div", {
    className: Cn("visx-legend", t),
    style: Ts({}, r, {
      flexDirection: U
    })
  }, ce.map(function(ke, Se) {
    return /* @__PURE__ */ Ve.createElement(Ec, Ts({
      key: "legend-" + ke.text + "-" + Se,
      margin: ie,
      flexDirection: te
    }, G), /* @__PURE__ */ Ve.createElement(yg, {
      shape: o,
      height: E,
      width: b,
      margin: R,
      item: ne[Se],
      itemIndex: Se,
      label: ke,
      fill: s,
      size: m,
      shapeStyle: L
    }), /* @__PURE__ */ Ve.createElement(Rc, Ts({
      label: ke.text,
      flex: re,
      margin: se,
      align: j
    }, J)));
  }));
}
vg.propTypes = {
  children: ze.func,
  className: ze.string,
  domain: ze.array,
  shapeWidth: ze.oneOfType([ze.string, ze.number]),
  shapeHeight: ze.oneOfType([ze.string, ze.number]),
  shapeMargin: ze.oneOfType([ze.string, ze.number]),
  labelAlign: ze.string,
  labelFlex: ze.oneOfType([ze.string, ze.number]),
  labelMargin: ze.oneOfType([ze.string, ze.number]),
  itemMargin: ze.oneOfType([ze.string, ze.number]),
  fill: ze.func,
  size: ze.func,
  shapeStyle: ze.func
};
function bT(e) {
  return /* @__PURE__ */ Ve.createElement(vg, e);
}
const ST = (e) => {
  const { position: t, singleRow: n, verticalSorted: r, hideBorder: i } = e.legend, o = {
    left: "left",
    right: "right",
    bottom: "bottom",
    top: "top"
  }, d = {
    bottom: n ? ["single-row", "bottom"] : ["double-column", "bottom"],
    top: n ? ["single-row", "top"] : ["double-column", "top"]
  }, c = ["legend-container", o[t]].filter(Boolean), s = ["legend-container__inner", ...d[t] || []];
  ["bottom", "top"].includes(t) && r && s.push("vertical-sorted");
  const p = (["right", "left"].includes(t) || !t) && i.side, m = ["top", "bottom"].includes(t) && i.topBottom;
  return p || m ? c.push("border-0", "p-0") : c.push("p-3"), {
    containerClasses: c,
    innerClasses: s
  };
}, wT = (e, t, n) => {
  const i = t([{ datum: "", index: 0, text: "", value: "" }]), o = e.legend.colorCode ? i.map((c) => c == null ? void 0 : c.value) : (n == null ? void 0 : n.range()) ?? [], d = e.legend.colorCode ? i.map((c) => (c == null ? void 0 : c.text) || (c == null ? void 0 : c.datum)) : (n == null ? void 0 : n.domain()) ?? [];
  return { colors: o, labels: d };
}, kT = (e, t) => e && t.legend.hide || !e ? "0px" : e && t.brush.active && !t.legend.hide ? `${27 + t.brush.height + 25}px` : "27px", TT = (e, t) => {
  var o, d, c;
  const n = ((o = t.legend) == null ? void 0 : o.position) === "top" && !t.legend.hide, r = !t.legend.hideSuppressionLink && t.visualizationSubType !== "stacked" && ((d = t.preliminaryData) == null ? void 0 : d.some((s) => s.label && s.type === "suppression" && s.value && ((s == null ? void 0 : s.style) || s.symbol)));
  let i = 0;
  return n && (i = 27), n && ((c = t.dataFormat) != null && c.onlyShowTopPrefixSuffix) && (i += 9), e && (i += 9), r && (i += 40), `${i}px`;
}, CT = ({ config: e, isLegendBottom: t }) => {
  const { preliminaryData: n, visualizationType: r, visualizationSubType: i, legend: o } = e, d = () => (n == null ? void 0 : n.some((T) => T.label && T.type === "effect" && T.style !== "Filled Circles")) && ["Line", "Combo"].includes(r), c = () => !o.hideSuppressedLabels && (n == null ? void 0 : n.some(
    (T) => T.label && T.displayLegend && T.type === "suppression" && T.value && ((T == null ? void 0 : T.style) || T.symbol)
  )) && (r === "Bar" && i === "regular" || r === "Line" || r === "Combo"), s = () => n == null ? void 0 : n.map(
    (T, y) => T.label && T.type === "effect" && T.style && /* @__PURE__ */ z("div", { className: "legend-preliminary", children: [
      /* @__PURE__ */ a("span", { className: T.symbol, children: T.lineCode }),
      /* @__PURE__ */ a("p", { children: T.label })
    ] }, y)
  ), p = (T) => {
    T.preventDefault();
  }, m = () => {
    const T = (y) => y ? {
      color: "#777772"
    } : null;
    return n == null ? void 0 : n.map((y, A) => {
      if (!y.displayLegend || y.type !== "suppression")
        return null;
      const b = "legend-preliminary", v = A + r;
      return r === "Bar" ? /* @__PURE__ */ z("div", { style: T(y.displayGray), className: `${b} ${y.symbol}`, children: [
        /* @__PURE__ */ a("span", { className: y.symbol, children: y.iconCode }),
        /* @__PURE__ */ a("p", { className: y.type, children: y.label })
      ] }, v) : r === "Line" ? /* @__PURE__ */ z("div", { style: T(y.displayGray), className: b, children: [
        /* @__PURE__ */ a("span", { children: y.lineCode }),
        /* @__PURE__ */ a("p", { className: y.type, children: y.label })
      ] }, v) : r === "Combo" ? /* @__PURE__ */ z(Ve.Fragment, { children: [
        y.symbol && y.iconCode && /* @__PURE__ */ z("div", { style: T(y.displayGray), className: `${b} ${y.symbol}`, children: [
          /* @__PURE__ */ a("span", { className: y.symbol, children: y.iconCode }),
          /* @__PURE__ */ a("p", { className: y.type, children: y.label })
        ] }, v),
        y.style && y.lineCode && /* @__PURE__ */ z("div", { style: T(y.displayGray), className: b, children: [
          /* @__PURE__ */ a("span", { children: y.lineCode }),
          /* @__PURE__ */ a("p", { children: y.label })
        ] }, v)
      ] }) : null;
    });
  }, g = () => o.singleRow && t ? "legend-container__inner bottom single-row" : "", x = () => !e.legend.hideSuppressionLink && e.visualizationSubType !== "stacked" && (n == null ? void 0 : n.some((T) => T.label && T.type === "suppression" && T.value && ((T == null ? void 0 : T.style) || T.symbol)));
  return /* @__PURE__ */ z(Ve.Fragment, { children: [
    d() && /* @__PURE__ */ z(Ve.Fragment, { children: [
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("div", { className: g(), children: s() })
    ] }),
    c() && /* @__PURE__ */ z(Ve.Fragment, { children: [
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("div", { className: g(), children: m() })
    ] }),
    x() && /* @__PURE__ */ z("div", { className: "legend-container__outer definition-link", children: [
      /* @__PURE__ */ a(Ze, { alt: "info-icon", display: "info" }),
      /* @__PURE__ */ z("p", { children: [
        "This chart contains",
        /* @__PURE__ */ a(
          "a",
          {
            onClick: p,
            "data-tooltip-content": "Data is suppressed to maintain statistical reliability. This occurs when the number of respondents or reported values does not meet the minimum reporting threshold.",
            "data-tooltip-id": "my-tooltip",
            href: "no-router-link",
            children: "suppressed data"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ a(
      xc,
      {
        id: "my-tooltip",
        variant: "light",
        style: { background: `rgba(255,255,255, ${e.tooltips.opacity / 100})`, color: "black", maxWidth: "100%" }
      }
    )
  ] });
}, xg = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, AT = [
  Tm,
  Cm,
  Qu,
  Am,
  Qu,
  Ch,
  ({ fill: e }) => /* @__PURE__ */ a(qf, { children: /* @__PURE__ */ a(gt, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle", children: "⬟" }) })
], LT = (e) => {
  var c;
  const { config: t, label: n, index: r } = e, i = r === 4, o = AT[t.visual.lineDatapointSymbol === "standard" && r < t.visual.maximumShapeAmount ? r : 0], d = `translate(15, 3) ${i ? "rotate(180)" : ""}`;
  return /* @__PURE__ */ z("svg", { width: 30, height: 10, style: { overflow: "visible" }, className: "me-2", children: [
    /* @__PURE__ */ a(
      rn,
      {
        from: { x: 0, y: 3 },
        to: { x: 30, y: 3 },
        stroke: n.value,
        strokeWidth: 2,
        strokeDasharray: xg(((c = t.series[r]) == null ? void 0 : c.type) || "")
      }
    ),
    /* @__PURE__ */ a("g", { display: t.legend.hasShape ? "block" : "none", transform: d, children: /* @__PURE__ */ a(o, { fillOpacity: 1, fill: n.value }) })
  ] });
}, ET = 36, RT = de.forwardRef(
  ({
    config: e,
    colorScale: t,
    seriesHighlight: n,
    highlight: r,
    handleShowAll: i,
    currentViewport: o,
    formatLabels: d,
    skipId: c = "legend",
    dimensions: s
  }, p) => {
    const { innerClasses: m, containerClasses: g } = ST(e), { runtime: x, legend: T } = e, y = (T == null ? void 0 : T.position) === "bottom" || Ui(o) && !T.hide && (T == null ? void 0 : T.position) !== "top", A = {
      marginBottom: TT(y, e),
      marginTop: kT(y, e)
    }, { HighLightedBarUtils: b } = jc(e);
    let v = b.findDuplicates(e.highlightedBarValues);
    return T ? /* @__PURE__ */ z(
      "aside",
      {
        ref: p,
        style: A,
        id: c || "legend",
        className: g.join(" "),
        role: "region",
        "aria-label": "legend",
        tabIndex: 0,
        children: [
          (T.label || T.description) && /* @__PURE__ */ z("div", { className: T.description ? "mb-3" : "mb-2", children: [
            T.label && /* @__PURE__ */ a("h3", { className: "fw-bold", children: za(T.label) }),
            T.description && /* @__PURE__ */ a("p", { className: "mt-2", children: za(T.description) })
          ] }),
          /* @__PURE__ */ a(
            Bg,
            {
              config: e,
              ...wT(e, d, t),
              dimensions: s,
              parentPaddingToSubtract: T.hideBorder ? 0 : ET
            }
          ),
          /* @__PURE__ */ a(bT, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0", children: (E) => /* @__PURE__ */ z(Ue, { children: [
            /* @__PURE__ */ z("div", { className: m.join(" "), children: [
              d(E).map((N, R) => {
                var j, Z;
                let L = ["legend-item", `legend-text--${N.text.replace(" ", "").toLowerCase()}`], B = N.datum;
                if (e.exclusions.active && ((j = e.exclusions.keys) != null && j.includes(B)))
                  return null;
                if (x.seriesLabels) {
                  let re = e.runtime.seriesLabelsAll.indexOf(B);
                  B = e.runtime.seriesKeys[re], ((Z = x == null ? void 0 : x.forecastingSeriesKeys) == null ? void 0 : Z.length) > 0 && (B = N.text);
                }
                return n.length && (n.includes(B) ? L.push("highlighted") : L.push("inactive")), e.legend.style === "gradient" ? /* @__PURE__ */ a(Ue, {}) : /* @__PURE__ */ z(
                  Ec,
                  {
                    className: L.join(" "),
                    tabIndex: 0,
                    onKeyDown: (re) => {
                      re.key === "Enter" && (re.preventDefault(), r(N));
                    },
                    onClick: (re) => {
                      re.preventDefault(), r(N);
                    },
                    role: "button",
                    children: [
                      /* @__PURE__ */ a(Ue, { children: e.visualizationType === "Line" && e.legend.style === "lines" ? /* @__PURE__ */ a(Ve.Fragment, { children: /* @__PURE__ */ a(LT, { index: R, label: N, config: e }) }) : /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ a(
                        $h,
                        {
                          shape: e.legend.style === "boxes" ? "square" : "circle",
                          fill: N.value
                        }
                      ) }) }),
                      /* @__PURE__ */ a(Rc, { align: "left", className: "m-0", children: N.text })
                    ]
                  },
                  `legend-quantile-${R}`
                );
              }),
              v.map((N, R) => {
                let L = "legend-item", B = N.legendLabel;
                return B ? (n.length > 0 && n.includes(B) === !1 && (L += " inactive"), /* @__PURE__ */ z(
                  Ec,
                  {
                    className: L,
                    tabIndex: 0,
                    onKeyDown: (j) => {
                      j.key === "Enter" && (j.preventDefault(), r(N.legendLabel));
                    },
                    onClick: (j) => {
                      j.preventDefault(), r(N.legendLabel);
                    },
                    children: [
                      /* @__PURE__ */ a(
                        $h,
                        {
                          shape: e.legend.style === "boxes" ? "square" : "circle",
                          style: { borderRadius: "0px" },
                          fill: "transparent",
                          borderColor: N.color ? N.color : "rgba(255, 102, 1)"
                        }
                      ),
                      " ",
                      /* @__PURE__ */ a(Rc, { align: "left", children: N.legendLabel ? N.legendLabel : N.value })
                    ]
                  },
                  `legend-quantile-${R}`
                )) : !1;
              })
            ] }),
            /* @__PURE__ */ a(CT, { config: e, isLegendBottom: y })
          ] }) }),
          n.length > 0 && /* @__PURE__ */ a(Oc, { onClick: (E) => i(E), style: { marginTop: "1rem" }, children: "Show All" })
        ]
      }
    ) : null;
  }
);
function NT(e) {
  return Ig({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" } }] })(e);
}
const PT = (e, t, n, r) => (i) => {
  var T, y, A, b, v;
  const { visualizationType: o, visualizationSubType: d, series: c, runtime: s, legend: p } = e, m = (E) => p.verticalSorted ? nt.sortBy(nt.cloneDeep(E), (N) => {
    var L;
    const R = (L = N.datum) == null ? void 0 : L.match(/-?\d+(\.\d+)?/);
    return R ? parseFloat(R[0]) : Number.MAX_SAFE_INTEGER;
  }) : E, g = (E) => e.legend.reverseLabelOrder ? m(E).reverse() : m(E), x = (T = e.legend) == null ? void 0 : T.colorCode;
  if (o === "Deviation Bar") {
    const [E, N] = _c[e.twoColor.palette], R = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: E
    }, L = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: N
    };
    return g([R, L]);
  }
  if (o === "Bar" && d === "regular" && x && (c == null ? void 0 : c.length) === 1) {
    let E = Cr[e.palette];
    for (; t.length > E.length; )
      E = E.concat(E);
    E = E.slice(0, n.length);
    const N = /* @__PURE__ */ new Set();
    t.forEach((L) => N.add(L[x]));
    const R = Array.from(N).map((L, B) => ({
      datum: L,
      index: B,
      text: L,
      value: E[B]
    }));
    return g(R);
  }
  if (((y = s == null ? void 0 : s.forecastingSeriesKeys) == null ? void 0 : y.length) > 0) {
    let E = [];
    return (b = (A = e.runtime) == null ? void 0 : A.forecastingSeriesKeys) == null || b.map((N, R) => {
      var L;
      return (L = N == null ? void 0 : N.stages) == null ? void 0 : L.map((B, j) => {
        var X, se, Y, ie;
        let Z = (X = Zu[B.color]) != null && X[2] ? (se = Zu[B.color]) == null ? void 0 : se[2] : (Y = Cr[B.color]) != null && Y[2] ? (ie = Cr[B.color]) == null ? void 0 : ie[2] : "#ccc";
        const re = {
          datum: B.key,
          index: j,
          text: B.key,
          value: Z
        };
        E.push(re);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((N, R) => {
      let L = Cr[e.palette][R] ? Cr[e.palette][R] : "#ccc";
      const B = {
        datum: N,
        index: R,
        text: N,
        value: L
      };
      E.push(B);
    }), g(E);
  }
  if (e.series.some((E) => E.name)) {
    const E = Array.from(new Set(e.series.map((N) => N.name || N.dataKey))).map((N, R) => ({
      datum: N,
      index: R,
      text: N,
      value: r(N)
    }));
    return g(E);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const E = i.length - 1;
    let N = [];
    return (v = e.suppressedData) == null || v.forEach(({ label: R, icon: L }, B) => {
      if (R && L) {
        const j = {
          datum: R,
          index: E + B,
          text: R,
          icon: /* @__PURE__ */ a(NT, { color: "#000", size: 15 })
        };
        N.push(j);
      }
    }), [...i, ...N];
  }
  return g(i);
}, DT = de.forwardRef((e, t) => {
  const {
    // prettier-ignore
    config: n,
    colorScale: r,
    seriesHighlight: i,
    highlight: o,
    tableData: d,
    handleShowAll: c,
    transformedData: s,
    currentViewport: p,
    dimensions: m,
    getTextWidth: g
  } = de.useContext(vt);
  if (!n.legend)
    return null;
  const x = PT(n, d, s, r);
  return /* @__PURE__ */ a(de.Fragment, { children: /* @__PURE__ */ a(
    RT,
    {
      getTextWidth: g,
      dimensions: m,
      ref: t,
      skipId: e.skipId || "legend",
      config: n,
      colorScale: r,
      seriesHighlight: i,
      highlight: o,
      handleShowAll: c,
      currentViewport: p,
      formatLabels: x
    }
  ) });
}), Xu = {
  annotations: [],
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "true",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    annotationDropdownText: "Annotations",
    showDownloadButton: !1,
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0,
    showZeroValueData: !0,
    hideNullValue: !0
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !1,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: [],
    shoMissingDataLabel: !0,
    showMissingDataLine: !0,
    categories: []
  },
  boxplot: {
    plots: [],
    borders: "true",
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      count: "Count",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 0,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0,
    padding: 5,
    showYearsOnce: !1,
    sortByRecentDate: !1
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    showDownloadLinkBelow: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: "",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    label: "",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    hideSuppressionLink: !1,
    seriesHighlight: [],
    style: "circles",
    subStyle: "linear blocks",
    shape: "circle",
    tickRotation: "",
    hideBorder: {
      side: !1,
      topBottom: !0
    },
    position: "right"
  },
  brush: {
    height: 45,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  filters: [],
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1,
    lineDatapointSymbol: "none",
    maximumShapeAmount: 7
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, _T = ({
  config: e,
  deleteColumn: t,
  updateField: n,
  colKey: r,
  controls: i
}) => {
  var g, x, T, y;
  const [o, d] = i, c = (A, b) => {
    if (A === "dataTable" && b === !0) {
      const v = nt.cloneDeep(e.columns);
      v[r] = { ...v[r], dataTable: b }, n(null, null, "columns", v);
    } else
      n("columns", r, A, b);
  }, s = (A) => {
    const b = nt.cloneDeep(e.columns), E = { ...e.columns[r], name: A, label: A };
    if (E.dataTable === void 0 && (E.dataTable = !0), A !== r) {
      b[A] = E, delete b[r];
      const N = { ...nt.cloneDeep(o), [A]: !0 };
      delete N[r], d(N);
    }
    n(null, null, "columns", b);
  }, p = () => {
    var E;
    const A = e.data.flatMap((N) => Object.keys(N).map((R) => R)), b = Object.values(e.columns).map((N) => N.name), v = nt.uniq(A).filter((N) => !(e.table.groupBy === N || b.includes(N)));
    return (E = e.columns[r]) != null && E.name && v.push(e.columns[r].name), v;
  }, m = (g = e.columns[r]) == null ? void 0 : g.name;
  return /* @__PURE__ */ z(
    $g,
    {
      fieldName: m,
      fieldKey: r,
      fieldType: "Column",
      controls: i,
      deleteField: () => t(r),
      children: [
        /* @__PURE__ */ a(
          xt,
          {
            label: "Column",
            value: (x = e.columns[r]) == null ? void 0 : x.name,
            fieldName: "name",
            section: "columns",
            initial: "-Select-",
            options: p(),
            updateField: (A, b, v, E) => s(E)
          }
        ),
        e.type !== "table" && /* @__PURE__ */ a(
          xt,
          {
            label: "Associate to Series",
            value: (T = e.columns[r]) == null ? void 0 : T.series,
            fieldName: "series",
            section: "columns",
            initial: "Select series",
            options: ((y = e.series) == null ? void 0 : y.map((A) => A.dataKey)) || [],
            updateField: (A, b, v, E) => c("series", E)
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: e.columns[r].label,
            section: "columns",
            subsection: r,
            fieldName: "label",
            label: "Label",
            updateField: n
          }
        ),
        /* @__PURE__ */ z("ul", { className: "column-edit", children: [
          /* @__PURE__ */ z("li", { className: "three-col", children: [
            /* @__PURE__ */ a(
              Ge,
              {
                value: e.columns[r].prefix,
                section: "columns",
                subsection: r,
                fieldName: "prefix",
                label: "Prefix",
                updateField: n
              }
            ),
            /* @__PURE__ */ a(
              Ge,
              {
                value: e.columns[r].suffix,
                section: "columns",
                subsection: r,
                fieldName: "suffix",
                label: "Suffix",
                updateField: n
              }
            ),
            /* @__PURE__ */ a(
              Ge,
              {
                type: "number",
                value: e.columns[r].roundToPlace,
                section: "columns",
                subsection: r,
                fieldName: "roundToPlace",
                label: "Round",
                updateField: n
              }
            )
          ] }),
          /* @__PURE__ */ a("li", { children: /* @__PURE__ */ z("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].commas,
                onChange: (A) => {
                  c("commas", A.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Add Commas to Numbers" })
          ] }) }),
          /* @__PURE__ */ a("li", { children: e.table.showVertical && /* @__PURE__ */ z("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].dataTable ?? !0,
                onChange: (A) => {
                  c("dataTable", A.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in Data Table" })
          ] }) }),
          e.visualizationType === "Pie" && /* @__PURE__ */ a("li", { children: /* @__PURE__ */ z("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].showInViz,
                onChange: (A) => {
                  c("showInViz", A.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in Visualization" })
          ] }) }),
          e.type !== "table" && /* @__PURE__ */ a("li", { children: /* @__PURE__ */ z("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].tooltips || !1,
                onChange: (A) => {
                  n("columns", r, "tooltips", A.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in tooltip" })
          ] }) }),
          e.visualizationType === "Forest Plot" && /* @__PURE__ */ z(Ue, { children: [
            /* @__PURE__ */ a("li", { children: /* @__PURE__ */ z("label", { className: "checkbox", children: [
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: e.columns[r].forestPlot || !1,
                  onChange: (A) => {
                    c("forestPlot", A.target.checked);
                  }
                }
              ),
              /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in Forest Plot" })
            ] }) }),
            /* @__PURE__ */ a("li", { children: /* @__PURE__ */ z("label", { className: "checkbox", children: [
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: e.columns[r].forestPlotAlignRight || !1,
                  onChange: (A) => {
                    c("forestPlotAlignRight", A.target.checked);
                  }
                }
              ),
              /* @__PURE__ */ a("span", { className: "edit-label", children: "Align Right" })
            ] }) }),
            !e.columns[r].forestPlotAlignRight && /* @__PURE__ */ a("li", { children: /* @__PURE__ */ z("label", { className: "text", children: [
              /* @__PURE__ */ a("span", { className: "edit-label", children: "Forest Plot Starting Point" }),
              /* @__PURE__ */ a(
                "input",
                {
                  type: "number",
                  value: e.columns[r].forestPlotStartingPoint || 0,
                  onChange: (A) => {
                    c("forestPlotStartingPoint", A.target.value);
                  }
                }
              )
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ z("label", { children: [
          /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Order" }),
          /* @__PURE__ */ a(
            "input",
            {
              onWheel: (A) => A.currentTarget.blur(),
              type: "number",
              min: "1",
              value: e.columns[r].order,
              onChange: (A) => n("columns", r, "order", parseInt(A.target.value))
            }
          )
        ] })
      ]
    }
  );
}, OT = ({ config: e, updateField: t, deleteColumn: n }) => {
  var d;
  const r = de.useState({}), i = Object.keys(e.columns), o = (c) => {
    const s = `additionalColumn${c}`, p = {
      label: "New Column",
      dataTable: !0,
      tooltips: !1,
      prefix: "",
      suffix: "",
      forestPlot: !1,
      startingPoint: "0",
      forestPlotAlignRight: !1,
      roundToPlace: 0,
      commas: !1,
      showInViz: !1,
      forestPlotStartingPoint: 0
    }, [m, g] = r;
    g({ ...m, [s]: !0 }), t("columns", null, s, p);
  };
  return /* @__PURE__ */ z(Ue, { children: [
    e.type !== "navigation" && /* @__PURE__ */ z("fieldset", { children: [
      /* @__PURE__ */ a("label", { children: /* @__PURE__ */ z("span", { className: "edit-label", children: [
        "Configurations",
        /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "You can specify additional columns to display in tooltips and / or the supporting data table." }) })
        ] })
      ] }) }),
      i.map((c, s) => /* @__PURE__ */ a(
        _T,
        {
          controls: r,
          config: e,
          deleteColumn: n,
          updateField: t,
          colKey: c
        },
        c + s
      )),
      /* @__PURE__ */ a(
        "button",
        {
          className: "btn btn-primary",
          onClick: (c) => {
            c.preventDefault(), o(i.length + 1);
          },
          children: "Add Configuration"
        }
      )
    ] }),
    ((d = e.legend) == null ? void 0 : d.type) === "category" && /* @__PURE__ */ z("fieldset", { children: [
      /* @__PURE__ */ a("label", { children: /* @__PURE__ */ z("span", { className: "edit-label", children: [
        "Additional Category",
        /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "You can provide additional categories to ensure they appear in the legend" }) })
        ] })
      ] }) }),
      e.legend.additionalCategories && e.legend.additionalCategories.map((c, s) => /* @__PURE__ */ z("fieldset", { className: "edit-block", children: [
        /* @__PURE__ */ a(
          "button",
          {
            className: "remove-column",
            onClick: (p) => {
              p.preventDefault();
              const m = [...e.legend.additionalCategories];
              m.splice(s, 1), t("legend", null, "additionalCategories", m);
            },
            children: "Remove"
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: c,
            label: "Category",
            section: "legend",
            subsection: null,
            fieldName: "additionalCategories",
            updateField: (p, m, g, x) => {
              const T = [...e.legend.additionalCategories];
              T[s] = x, t(p, m, g, T);
            }
          }
        )
      ] }, c)),
      /* @__PURE__ */ a(
        "button",
        {
          className: "btn btn-primary full-width",
          onClick: (c) => {
            c.preventDefault();
            const s = [...e.legend.additionalCategories || []];
            s.push(""), t("legend", null, "additionalCategories", s);
          },
          children: "Add Category"
        }
      )
    ] })
  ] });
}, vm = "-Select-", MT = ({ config: e, updateField: t, isDashboard: n, columns: r }) => {
  var p, m, g, x, T, y, A;
  const i = ((p = e.dataKey) == null ? void 0 : p.includes("http://")) || ((m = e == null ? void 0 : e.dataKey) == null ? void 0 : m.includes("https://")), o = de.useMemo(() => Object.keys(e.columns).map((b) => [b, e.columns[b].dataTable]).filter(([b, v]) => !v).map(([b]) => b), [e.columns]), d = de.useMemo(() => {
    const b = e.data.flatMap(Object.keys);
    return nt.uniq(b).filter((E) => !0);
  }, [e.data]), c = (b) => {
    b === vm && (b = void 0), t("table", null, "groupBy", b);
  }, s = (b, v, E, N) => {
    const R = nt.cloneDeep(e.columns), L = [];
    for (let B in R) {
      const j = R[B];
      L.push(j.name), N.includes(j.name) ? R[B].dataTable = !1 : R[B].dataTable = !0;
    }
    N.forEach((B) => {
      L.includes(B) || (R[B] = { name: B, dataTable: !1 });
    }), t(null, null, "columns", R);
  };
  return /* @__PURE__ */ z(Ue, { children: [
    /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.label,
        updateField: t,
        section: "table",
        fieldName: "label",
        id: "tableLabel",
        label: "Data Table Title",
        placeholder: "Data Table",
        tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Label is required for Data Table for 508 Compliance" }) })
        ] })
      }
    ),
    e.type !== "table" ? /* @__PURE__ */ a(
      et,
      {
        value: e.table.show,
        fieldName: "show",
        label: "Show Data Table",
        section: "table",
        updateField: t,
        className: "column-heading",
        tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
            Ze,
            {
              display: "question",
              style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
            }
          ) }),
          /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Hiding the data table may affect accessibility. An alternate form of accessing visualization data is a 508 requirement." }) })
        ] })
      }
    ) : /* @__PURE__ */ a(
      et,
      {
        value: (g = e.general) == null ? void 0 : g.showDownloadButton,
        fieldName: "showDownloadButton",
        label: "Show Download CSV link",
        section: "general",
        updateField: t,
        className: "column-heading"
      }
    ),
    e.visualizationType !== "Box Plot" && e.type !== "table" && /* @__PURE__ */ a(
      et,
      {
        value: e.table.showVertical,
        fieldName: "showVertical",
        label: "Show Vertical Data",
        section: "table",
        updateField: t,
        className: "column-heading",
        tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
            Ze,
            {
              display: "question",
              style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
            }
          ) }),
          /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "This will draw the data table with vertical data instead of horizontal." }) })
        ] })
      }
    ),
    e.type !== "table" && /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.indexLabel,
        section: "table",
        fieldName: "indexLabel",
        label: "Index Column Header",
        updateField: t,
        tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "To comply with 508 standards, if the first column in the data table has no header, enter a brief one here." }) })
        ] })
      }
    ),
    /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.caption,
        updateField: t,
        section: "table",
        type: "textarea",
        fieldName: "caption",
        label: "Screen Reader Description",
        placeholder: " Data table",
        tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Enter a description of the data table to be read by screen readers." }) })
        ] })
      }
    ),
    /* @__PURE__ */ a(
      et,
      {
        value: e.table.limitHeight,
        section: "table",
        fieldName: "limitHeight",
        label: " Limit Table Height",
        updateField: t
      }
    ),
    e.table.limitHeight && /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.height,
        section: "table",
        fieldName: "height",
        label: "Data Table Height",
        type: "number",
        min: 0,
        max: 500,
        placeholder: "Height(px)",
        updateField: t
      }
    ),
    (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ z("label", { children: [
      /* @__PURE__ */ a("span", { className: "edit-label column-heading mt-1", children: "Exclude Columns " }),
      /* @__PURE__ */ a(
        Gh,
        {
          options: r.map((b) => ({ label: b, value: b })),
          selected: o,
          label: "Exclude Columns",
          fieldName: "dataTable",
          section: "columns",
          updateField: s
        },
        o.join("") + "excluded"
      )
    ] }),
    /* @__PURE__ */ a(
      et,
      {
        value: e.table.collapsible,
        fieldName: "collapsible",
        label: " Collapsible",
        section: "table",
        updateField: t
      }
    ),
    e.table.collapsible !== !1 && /* @__PURE__ */ a(
      et,
      {
        value: e.table.expanded,
        fieldName: "expanded",
        label: " Expanded by Default",
        section: "table",
        updateField: t
      }
    ),
    n && e.type !== "table" && /* @__PURE__ */ a(
      et,
      {
        value: e.table.showDataTableLink,
        fieldName: "showDataTableLink",
        label: "Show Data Table Name & Link",
        section: "table",
        updateField: t
      }
    ),
    i && /* @__PURE__ */ a(
      et,
      {
        value: e.table.showDownloadUrl,
        fieldName: "showDownloadUrl",
        label: "Show URL to Automatically Updated Data",
        section: "table",
        updateField: t
      }
    ),
    e.type !== "table" && /* @__PURE__ */ a(
      et,
      {
        value: e.table.showDownloadImgButton,
        fieldName: "showDownloadImgButton",
        label: "Display Image Button",
        section: "table",
        updateField: t
      }
    ),
    /* @__PURE__ */ a(
      et,
      {
        value: e.table.showDownloadLinkBelow,
        fieldName: "showDownloadLinkBelow",
        label: "Show Download Link Below Table",
        section: "table",
        updateField: t
      }
    ),
    /* @__PURE__ */ z("label", { children: [
      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Table Cell Min Width" }),
      /* @__PURE__ */ a(
        "input",
        {
          type: "number",
          value: e.table.cellMinWidth ? e.table.cellMinWidth : 0,
          onChange: (b) => t("table", null, "cellMinWidth", b.target.value)
        }
      )
    ] }),
    (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ a(
      xt,
      {
        value: e.table.groupBy,
        fieldName: "groupBy",
        section: "table",
        label: "Group By",
        updateField: (b, v, E, N) => c(N),
        initial: vm,
        options: d.filter(
          (b) => {
            var v, E;
            return b !== ((v = e.table.pivot) == null ? void 0 : v.columnName) && !(((E = e.table.pivot) == null ? void 0 : E.valueColumns) || []).includes(b);
          }
        ),
        tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Choose a column to use for grouping data rows. The selected column will not be shown in the data table. You will only be able to choose a column which does not have a column configuration." }) })
        ] })
      }
    ),
    /* @__PURE__ */ a(
      xt,
      {
        label: "Pivot Column",
        tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Select a Column whos data values will be pivoted to Column Values." }) })
        ] }),
        value: (x = e.table.pivot) == null ? void 0 : x.columnName,
        options: d.filter(
          (b) => {
            var v;
            return b !== e.table.groupBy && !(((v = e.table.pivot) == null ? void 0 : v.valueColumns) || []).includes(b);
          }
        ),
        initial: "-Select-",
        section: "table",
        subsection: "pivot",
        fieldName: "columnName",
        updateField: t
      }
    ),
    ((T = e.table.pivot) == null ? void 0 : T.columnName) && /* @__PURE__ */ z("label", { children: [
      /* @__PURE__ */ z("span", { className: "edit-label column-heading mt-1", children: [
        "Pivot Value Column(s)",
        /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "The column(s) whos values will be pivoted under the column selected as the Filter." }) })
        ] })
      ] }),
      /* @__PURE__ */ a(
        Gh,
        {
          options: d.filter((b) => {
            var v;
            return b !== ((v = e.table.pivot) == null ? void 0 : v.columnName) && b !== e.table.groupBy;
          }).map((b) => ({ label: b, value: b })),
          selected: (y = e.table.pivot) == null ? void 0 : y.valueColumns,
          label: "Pivot Value Column(s) ",
          section: "table",
          subsection: "pivot",
          fieldName: "valueColumns",
          updateField: t
        },
        (A = e.table.pivot) == null ? void 0 : A.columnName
      )
    ] })
  ] });
}, qu = (e) => /* @__PURE__ */ de.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ de.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), FT = ({ name: e }) => {
  var c, s, p, m, g;
  const { config: t, rawData: n, updateConfig: r } = de.useContext(vt);
  if (t.visualizationType !== "Forest Plot")
    return;
  const i = (x) => {
    x.orientation === "horizontal" && (x.labels = !1), x.table.show === void 0 && (x.table.show = !isDashboard), x.visualizationType === "Combo" && (x.orientation = "vertical");
  }, o = (x = !0) => {
    let T = {};
    return n.forEach((y) => {
      Object.keys(y).forEach((A) => T[A] = !0);
    }), x && Object.keys(T).forEach((y) => {
      (t.series && t.series.filter((A) => A.dataKey === y).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(y)) && delete T[y];
    }), Object.keys(T);
  }, d = (x, T, y, A) => {
    if (x === "boxplot" && T === "legend") {
      r({
        ...t,
        [x]: {
          ...t[x],
          [T]: {
            ...t.boxplot[T],
            [y]: A
          }
        }
      });
      return;
    }
    if (x === "boxplot" && T === "labels") {
      r({
        ...t,
        [x]: {
          ...t[x],
          [T]: {
            ...t.boxplot[T],
            [y]: A
          }
        }
      });
      return;
    }
    if (x === "forestPlot" && T) {
      let N = {
        ...t,
        [x]: {
          ...t[x],
          [T]: {
            ...t.forestPlot[T],
            [y]: A
          }
        }
      };
      r(N);
      return;
    }
    if (x === "columns" && T !== "" && y !== "") {
      r({
        ...t,
        [x]: {
          ...t[x],
          [T]: {
            ...t[x][T],
            [y]: A
          }
        }
      });
      return;
    }
    if (x === null && T === null) {
      let N = { ...t, [y]: A };
      i(N), r(N);
      return;
    }
    const b = Array.isArray(t[x]);
    let v = b ? [...t[x], A] : { ...t[x], [y]: A };
    T !== null && (b ? (v = [...t[x]], v[T] = { ...v[T], [y]: A }) : typeof A == "string" ? v[T] = A : v = { ...t[x], [T]: { ...t[x][T], [y]: A } });
    let E = { ...t, [x]: v };
    i(E), r(E);
  };
  return /* @__PURE__ */ z(Nn, { children: [
    /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ z(Dn, { children: [
      e,
      (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ a(qu, { width: "25", className: "warning-icon" })
    ] }) }),
    /* @__PURE__ */ z(_n, { children: [
      /* @__PURE__ */ a(
        xt,
        {
          value: t.xAxis.dataKey || "",
          section: "xAxis",
          fieldName: "dataKey",
          label: "Study Column",
          initial: "Select",
          required: !0,
          updateField: d,
          options: o(!1),
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Select the column or row containing the categories or dates for this axis. " }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        xt,
        {
          value: t.forestPlot.type,
          label: "Forest Plot Type",
          initial: "Select",
          required: !0,
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                type: x.target.value
              }
            }), x.target.value = "";
          },
          options: ["Linear", "Logarithmic"],
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ z("p", { children: [
              "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ",
              /* @__PURE__ */ a("br", {}),
              /* @__PURE__ */ a("br", {}),
              " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1."
            ] }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(Ge, { type: "text", value: ((c = t.forestPlot) == null ? void 0 : c.title) || "", updateField: d, section: "forestPlot", fieldName: "title", label: "Plot Title" }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { children: "Column Settings" }),
      /* @__PURE__ */ a(
        xt,
        {
          value: t.forestPlot.estimateField,
          label: "Point Estimate Column",
          initial: t.forestPlot.estimateField || "Select",
          required: !0,
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                estimateField: x.target.value
              }
            }), x.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ a(
        xt,
        {
          value: t.forestPlot.shape,
          label: "Point Estimate Shape",
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                shape: x.target.value
              }
            }), x.target.value = "";
          },
          options: ["text", "circle", "square"]
        }
      ),
      /* @__PURE__ */ a(
        xt,
        {
          value: t.forestPlot.lower,
          label: "Lower CI Column",
          required: !0,
          initial: t.forestPlot.lower || "Select",
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                lower: x.target.value
              }
            }), x.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ a(
        xt,
        {
          value: t.forestPlot.upper,
          label: "Upper CI Column",
          initial: t.forestPlot.upper || "Select",
          required: !0,
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                upper: x.target.value
              }
            }), x.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ a("label", { children: /* @__PURE__ */ z("span", { className: "edit-label column-heading", children: [
        "Pooled Result Column",
        /* @__PURE__ */ a(
          "input",
          {
            type: "text",
            value: t.forestPlot.pooledResult.column || "",
            label: "Pooled Result Row",
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  pooledResult: {
                    ...t.forestPlot.pooledResult,
                    column: x.target.value
                  }
                }
              }), x.target.value = "";
            }
          }
        )
      ] }) }),
      /* @__PURE__ */ a(et, { value: ((p = (s = t.forestPlot) == null ? void 0 : s.lineOfNoEffect) == null ? void 0 : p.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: d }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { children: "Width Settings" }),
      /* @__PURE__ */ z("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Left (%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.leftWidthOffset || 0,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  leftWidthOffset: x.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ z("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Left Mobile(%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.leftWidthOffsetMobile || 0,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  leftWidthOffsetMobile: x.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ z("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Right (%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.rightWidthOffset || 0,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  rightWidthOffset: x.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ z("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Right Mobile(%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.rightWidthOffsetMobile || 0,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  rightWidthOffsetMobile: x.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ a(Ge, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: d, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { children: "Labels Settings" }),
      /* @__PURE__ */ a(Ge, { type: "text", value: ((m = t.forestPlot) == null ? void 0 : m.leftLabel) || "", updateField: d, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }),
      /* @__PURE__ */ a(Ge, { type: "text", value: ((g = t.forestPlot) == null ? void 0 : g.rightLabel) || "", updateField: d, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a(
        xt,
        {
          value: t.forestPlot.radius.scalingColumn,
          label: "Weight Column",
          initial: "Select",
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                radius: {
                  ...t.forestPlot.radius,
                  scalingColumn: x.target.value
                }
              }
            }), x.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ z("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Radius Minimum Size" }),
        /* @__PURE__ */ a(
          "input",
          {
            min: 3,
            max: 6,
            value: t.forestPlot.radius.min || 3,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  radius: {
                    ...t.forestPlot.radius,
                    min: Number(x.target.value)
                  }
                }
              });
            },
            type: "number",
            label: "Radius Minimum",
            placeholder: " 1"
          }
        )
      ] }),
      /* @__PURE__ */ z("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Radius Maximum Size" }),
        /* @__PURE__ */ a(
          "input",
          {
            min: 7,
            max: 10,
            value: t.forestPlot.radius.max,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  radius: {
                    ...t.forestPlot.radius,
                    max: Number(x.target.value)
                  }
                }
              });
            },
            type: "number",
            label: "Radius Minimum",
            placeholder: " 1"
          }
        )
      ] })
    ] })
  ] });
}, Xa = Ve.createContext({}), zT = (e) => {
  const { updateConfig: t, config: n, rawData: r } = de.useContext(vt), { getColumns: i, selectComponent: o } = e, d = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], c = (s, p, m) => {
    let g = [...n.series];
    if (g[s][m] = p, m === "type" && p === "Bar" && (g[s].axis = "Left"), g[s].type === "Forecasting") {
      let x = Array.from(new Set(r.map((y) => y[g[s].dataKey]))), T = [];
      x.forEach((y) => {
        T.push({ key: y });
      }), g[s].stages = T, g[s].stageColumn = g[s].dataKey;
    }
    t({ ...n, series: g });
  };
  return /* @__PURE__ */ a(Xa.Provider, { value: { updateSeries: c, supportedRightAxisTypes: d, getColumns: i, selectComponent: o }, children: e.children });
}, BT = (e) => {
  const { config: t, updateConfig: n } = de.useContext(vt), { series: r, index: i } = e;
  if (!(() => {
    let s = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart", "Bump Chart"].some((m) => m.includes(r.type)) && (s = !0), s;
  })())
    return;
  const d = (s, p) => {
    let m = [...t.series];
    m[s].lineType = p, n({ ...t, series: m });
  };
  let c = [];
  return Object.keys(ul).map((s) => c.push(ul[s])), /* @__PURE__ */ a(
    Xi,
    {
      initial: "Select an option",
      value: r.lineType ? r.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (s) => {
        d(i, s.target.value);
      },
      options: c
    }
  );
}, IT = (e) => {
  const { config: t } = de.useContext(vt), { updateSeries: n } = de.useContext(Xa), { index: r, series: i } = e, o = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line" || t.visualizationType === "Bump Chart")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo", "Bump Chart"].includes(t.visualizationType))
    return /* @__PURE__ */ a(
      Xi,
      {
        initial: "Select an option",
        value: i.type,
        label: "Series Type",
        onChange: (d) => {
          n(r, d.target.value, "type");
        },
        options: o()
      }
    );
}, $T = (e) => {
  const { config: t, updateConfig: n, rawData: r } = de.useContext(vt), { updateSeries: i, getColumns: o } = de.useContext(Xa), { index: d, series: c } = e;
  return /* @__PURE__ */ a(
    Xi,
    {
      initial: "Select an option",
      value: c.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (s) => {
        let p = [], m = new Set(r == null ? void 0 : r.map((x) => x[s.target.value]));
        m = Array.from(m), m = m.filter((x) => x !== void 0), m.forEach((x) => p.push({ key: x }));
        const g = [...t.series];
        g[d] = { ...g[d], stages: p, stageColumn: s.target.value }, n({
          ...t,
          series: g
        });
      },
      options: o(!1)
    }
  );
}, HT = (e) => {
  const { config: t, rawData: n } = de.useContext(vt), { updateSeries: r } = de.useContext(Xa), { index: i, series: o } = e;
  if (o.type !== "Forecasting" || !n || !o.stageColumn)
    return;
  let d = new Set(n.map((c) => c[o.stageColumn]));
  return d = Array.from(d), d = d.filter((c) => c !== void 0), /* @__PURE__ */ a(
    Xi,
    {
      initial: "Select an option",
      value: o.stageItem,
      label: "Forecasting Item Column",
      onChange: (c) => {
        r(i, c.target.value, "stageItem");
      },
      options: d
    }
  );
}, VT = (e) => {
  const { config: t } = de.useContext(vt), { updateSeries: n, supportedRightAxisTypes: r } = de.useContext(Xa), { index: i, series: o } = e;
  if (!(t.visualizationType !== "Combo" || !o) && r.includes(o.type))
    return /* @__PURE__ */ a(
      Xi,
      {
        initial: "Select an option",
        value: o.axis ? o.axis : "Left",
        label: "Series Axis",
        onChange: (d) => {
          n(i, d.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, WT = (e) => {
  var o;
  const { config: t, updateConfig: n } = de.useContext(vt), { index: r, series: i } = e;
  if (i.type === "Forecasting" && i)
    return (o = i == null ? void 0 : i.stages) == null ? void 0 : o.map((d, c) => {
      var s, p, m, g;
      return /* @__PURE__ */ a(
        Xi,
        {
          initial: "Select an option",
          value: (p = (s = t.series) == null ? void 0 : s[r].stages) != null && p[c].color ? (g = (m = t.series) == null ? void 0 : m[r].stages) == null ? void 0 : g[c].color : "Select",
          label: `${d.key} Series Color`,
          onChange: (x) => {
            const T = [...t.series], y = T[r].stages;
            y[c].color = x.target.value, T[r] = { ...T[r], stages: y }, n({
              ...t,
              series: T
            });
          },
          options: Object.keys(Zu)
        },
        `${d}--${c}`
      );
    });
}, jT = (e) => {
  var d;
  const { config: t, updateConfig: n } = de.useContext(vt), { series: r, index: i } = e, { getColumns: o } = de.useContext(Xa);
  if (r.type === "Forecasting")
    return /* @__PURE__ */ z("div", { className: "edit-block", children: [
      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Confidence Interval Groups" }),
      /* @__PURE__ */ z("fieldset", { children: [
        /* @__PURE__ */ a(Ba, { allowZeroExpanded: !0, children: (d = r == null ? void 0 : r.confidenceIntervals) == null ? void 0 : d.map((c, s) => {
          const p = c.showInTooltip ? c.showInTooltip : !1, m = (g, x, T) => {
            g.preventDefault();
            let y = [...t.series];
            y[x].confidenceIntervals[T].showInTooltip = !p, n({
              ...t,
              series: y
            });
          };
          return /* @__PURE__ */ z(Nn, { className: "series-item series-item--chart", children: [
            /* @__PURE__ */ a(Pn, { className: "series-item__title", children: /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z(Dn, { className: "accordion__button accordion__button", children: [
              "Group ",
              s + 1,
              /* @__PURE__ */ a(
                "button",
                {
                  className: "series-list__remove",
                  onClick: (g) => {
                    g.preventDefault();
                    const x = [...t.series[i].confidenceIntervals];
                    x.splice(s, 1);
                    const T = [...t.series];
                    T[i] = { ...T[i], confidenceIntervals: [...x] }, n({
                      ...t,
                      series: T
                    });
                  },
                  children: "Remove"
                }
              )
            ] }) }) }),
            /* @__PURE__ */ z(_n, { children: [
              /* @__PURE__ */ z("div", { className: "input-group", children: [
                /* @__PURE__ */ a("label", { htmlFor: "showInTooltip", children: "Show In Tooltip" }),
                /* @__PURE__ */ z(
                  "div",
                  {
                    className: "cove-input__checkbox--small",
                    onClick: (g) => m(g, i, s),
                    children: [
                      /* @__PURE__ */ a(
                        "div",
                        {
                          className: "cove-input__checkbox-box custom-color",
                          style: { backgroundColor: "" },
                          children: p && /* @__PURE__ */ a(Bm, { className: "", style: { fill: "#025eaa" } })
                        }
                      ),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          className: "cove-input--hidden",
                          type: "checkbox",
                          name: "showInTooltip",
                          checked: p || !1,
                          readOnly: !0
                        }
                      )
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ a(
                Xi,
                {
                  initial: "Select an option",
                  value: t.series[i].confidenceIntervals[s].low ? t.series[i].confidenceIntervals[s].low : "Select",
                  label: "Low Confidence Interval",
                  onChange: (g) => {
                    const x = [...t.series[i].confidenceIntervals];
                    x[s].low = g.target.value;
                    const T = [...t.series];
                    T[i] = { ...T[i], confidenceIntervals: x }, n({
                      ...t,
                      series: T
                    });
                  },
                  options: o()
                }
              ),
              /* @__PURE__ */ a(
                Xi,
                {
                  initial: "Select an option",
                  value: t.series[i].confidenceIntervals[s].high ? t.series[i].confidenceIntervals[s].high : "Select",
                  label: "High Confidence Interval",
                  onChange: (g) => {
                    const x = [...t.series[i].confidenceIntervals];
                    x[s].high = g.target.value;
                    const T = [...t.series];
                    T[i] = { ...T[i], confidenceIntervals: x }, n({
                      ...t,
                      series: T
                    });
                  },
                  options: o()
                }
              )
            ] })
          ] }, `${s}`);
        }) }),
        /* @__PURE__ */ a(
          "button",
          {
            className: "btn btn-primary full-width",
            onClick: (c) => {
              c.preventDefault();
              let s = null;
              t.series[i].confidenceIntervals ? s = [...t.series[i].confidenceIntervals] : s = [];
              const p = [...t.series];
              p[i] = {
                ...p[i],
                confidenceIntervals: [...s, { high: "", low: "" }]
              }, n({
                ...t,
                series: p
              });
            },
            children: "Add Confidence Interval Group"
          }
        )
      ] })
    ] });
}, UT = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: i } = de.useContext(vt);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const d = (c, s, p, m) => {
    let g = [...r.series], x = { ...r.runtime.seriesLabels };
    g[c].weight = s && Math.max(Number(p), Math.min(Number(m), Number(s))), x[g[c].dataKey] = g[c].weight ? g[c].weight : g[c].dataKey;
    const T = {
      ...r,
      series: g,
      runtime: {
        ...r.runtime,
        seriesLabels: x
      }
    };
    i(T);
  };
  return /* @__PURE__ */ z(Ue, { children: [
    /* @__PURE__ */ a("label", { htmlFor: "series-weight", children: "Line Weight" }),
    /* @__PURE__ */ a(
      "input",
      {
        type: "number",
        value: t.weight ? t.weight : "",
        min: "1",
        max: "9",
        onChange: (c) => {
          d(n, c.target.value, c.target.min, c.target.max);
        }
      },
      `series-weight-${n}`
    )
  ] });
}, KT = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: i } = de.useContext(vt);
  if (![
    "Bump Chart",
    "Bar",
    "Line",
    "Area Chart",
    "Combo",
    "Deviation",
    "Paired",
    "Scatter",
    "dashed-sm",
    "dashed-md",
    "dashed-lg"
  ].includes(t.type))
    return;
  const d = (s, p) => {
    let m = [...r.series], g = { ...r.runtime.seriesLabels };
    m[s].name = p, g[m[s].dataKey] = m[s].name ? m[s].name : m[s].dataKey;
    let x = {
      ...r,
      series: m,
      runtime: {
        ...r.runtime,
        seriesLabels: g
      }
    };
    i(x);
  }, c = t.name !== void 0 && t.name !== t.dataKey ? t.name : t.dataKey;
  return /* @__PURE__ */ z(Ue, { children: [
    /* @__PURE__ */ a("label", { htmlFor: "series-name", children: "Series Name" }),
    /* @__PURE__ */ a(
      "input",
      {
        type: "text",
        value: c,
        onChange: (s) => {
          d(n, s.target.value);
        }
      },
      `series-name-${n}`
    )
  ] });
}, YT = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: i } = de.useContext(vt);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(r.visualizationType))
    return;
  const o = (d) => {
    let c = [...r.series];
    c[d].tooltip && c[d].tooltip, c[d].tooltip = !c[d].tooltip, i({
      ...r,
      series: c
    });
  };
  return /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z("div", { className: "input-group", children: [
    /* @__PURE__ */ a("label", { htmlFor: `series-tooltip--${n}`, children: "Show In Tooltip" }),
    /* @__PURE__ */ z("div", { className: "cove-input__checkbox--small", onClick: (d) => o(n), children: [
      /* @__PURE__ */ a("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" }, children: t.tooltip && /* @__PURE__ */ a(Bm, { className: "", style: { fill: "#025eaa" } }) }),
      /* @__PURE__ */ a(
        "input",
        {
          className: "cove-input--hidden",
          type: "checkbox",
          name: `series-tooltip--${n}`,
          checked: t.tooltip ? t.tooltip : !1,
          readOnly: !0
        }
      )
    ] })
  ] }) });
}, GT = (e) => {
  const { config: t, updateConfig: n } = de.useContext(vt), { series: r, index: i } = e, o = (c) => {
    let s = [...t.series], p = -1;
    for (let m = 0; m < s.length; m++)
      if (s[m].dataKey === c) {
        p = m;
        break;
      }
    if (p !== -1) {
      s.splice(p, 1);
      let m = { ...t, series: s };
      s.length === 0 && delete m.series, n(m);
    }
    t.visualizationType === "Paired Bar" && n({
      ...t,
      series: []
    });
  }, d = (c, s, p) => {
    c.preventDefault(), o(s.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ a("button", { className: "series-list__remove", onClick: (c) => d(c, r), children: "Remove" });
}, bg = (e) => {
  const { config: t } = de.useContext(vt), { updateSeries: n, getColumns: r } = de.useContext(Xa), { series: i, getItemStyle: o, sortableItemStyles: d, chartsWithOptions: c, index: s } = e, p = ["Bar", "Line"].includes(t.visualizationType) && t.visualizationSubType !== "Stacked" && !t.series.find((m) => m.dynamicCategory && m.dataKey !== i.dataKey);
  return /* @__PURE__ */ a(Hg, { draggableId: `draggableFilter-${i.dataKey}`, index: s, children: (m, g) => /* @__PURE__ */ a(
    "div",
    {
      className: g.isDragging ? "currently-dragging" : "",
      style: o(g.isDragging, m.draggableProps.style, d),
      ref: m.innerRef,
      ...m.draggableProps,
      ...m.dragHandleProps,
      children: /* @__PURE__ */ a(Ba, { allowZeroExpanded: !0, children: /* @__PURE__ */ z(Nn, { className: "series-item series-item--chart", children: [
        /* @__PURE__ */ a(Pn, { className: "series-item__title", children: /* @__PURE__ */ z(
          Dn,
          {
            className: c.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow",
            children: [
              /* @__PURE__ */ a(Ze, { display: "move", size: 15, style: { cursor: "default" } }),
              i.dataKey,
              /* @__PURE__ */ a(ni.Button.Remove, { series: i, index: s })
            ]
          }
        ) }),
        c.includes(t.visualizationType) && /* @__PURE__ */ z(_n, { children: [
          /* @__PURE__ */ a(ni.Input.Name, { series: i, index: s }),
          p && /* @__PURE__ */ a(
            xt,
            {
              label: "Dynamic Category",
              value: i.dynamicCategory,
              options: ["- Select - ", ...r().filter((x) => i.dataKey !== x)],
              updateField: (x, T, y, A) => {
                A === "- Select -" && (A = ""), n(s, A, "dynamicCategory");
              },
              tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "This field is Optional. If you have a dynamic data series you can select the category field here. You can only add one dynamic category per visualization." }) })
              ] })
            }
          ),
          /* @__PURE__ */ a(ni.Input.Weight, { series: i, index: s }),
          /* @__PURE__ */ a(ni.Dropdown.SeriesType, { series: i, index: s }),
          /* @__PURE__ */ a(ni.Dropdown.AxisPosition, { series: i, index: s }),
          /* @__PURE__ */ a(ni.Dropdown.LineType, { series: i, index: s }),
          /* @__PURE__ */ a(ni.Dropdown.ForecastingColor, { series: i, index: s }),
          /* @__PURE__ */ a(ni.Dropdown.ConfidenceInterval, { series: i, index: s }),
          /* @__PURE__ */ a(ni.Checkbox.DisplayInTooltip, { series: i, index: s })
        ] })
      ] }) })
    },
    s
  ) }, i.dataKey);
}, XT = (e) => {
  const { series: t, getItemStyle: n, sortableItemStyles: r, chartsWithOptions: i } = e;
  return t.map((o, d) => /* @__PURE__ */ a(
    bg,
    {
      getItemStyle: n,
      sortableItemStyles: r,
      chartsWithOptions: i,
      series: o,
      index: d
    },
    `series-list-${d}`
  ));
}, ni = {
  Wrapper: zT,
  Dropdown: {
    SeriesType: IT,
    AxisPosition: VT,
    ConfidenceInterval: jT,
    LineType: BT,
    ForecastingStage: $T,
    ForecastingColumn: HT,
    ForecastingColor: WT
  },
  Input: {
    Name: KT,
    Weight: UT
  },
  Checkbox: {
    DisplayInTooltip: YT
  },
  Button: {
    Remove: GT
  },
  Item: bg,
  List: XT
}, qT = de.memo(({ config: e, updateConfig: t }) => {
  let n = (s, p, m) => {
    let g = [];
    e.regions && (g = [...e.regions]), g[m][s] = p, t({ ...e, regions: g });
  }, r = (s, p, m, g, x) => n(m, g, x), i = (s) => {
    let p = [];
    e.regions && (p = [...e.regions]), p.splice(s, 1), t({ ...e, regions: p });
  }, o = () => {
    let s = [];
    e.regions && (s = [...e.regions]), s.push({}), t({ ...e, regions: s });
  };
  const d = ["Fixed", "Previous Days"], c = ["Last Date", "Fixed"];
  return /* @__PURE__ */ z(Ue, { children: [
    e.regions && e.regions.map(({ label: s, color: p, from: m, to: g, background: x, range: T = "Custom" }, y) => {
      var A;
      return /* @__PURE__ */ z("div", { className: "edit-block", children: [
        /* @__PURE__ */ a(
          "button",
          {
            type: "button",
            className: "btn btn-danger remove-column",
            onClick: (b) => {
              b.preventDefault(), i(y);
            },
            children: "Remove"
          }
        ),
        /* @__PURE__ */ a(Ge, { value: s, label: "Region Label", fieldName: "label", i: y, updateField: r }),
        /* @__PURE__ */ z("div", { className: "two-col-inputs", children: [
          /* @__PURE__ */ a(
            Ge,
            {
              value: p,
              label: "Text Color",
              fieldName: "color",
              updateField: (b, v, E, N) => n(E, N, y)
            }
          ),
          /* @__PURE__ */ a(
            Ge,
            {
              value: x,
              label: "Background",
              fieldName: "background",
              updateField: (b, v, E, N) => n(E, N, y)
            }
          )
        ] }),
        /* @__PURE__ */ a(
          xt,
          {
            value: e.regions[y].fromType ?? "Fixed",
            label: "Minimum Region Type",
            initial: "Select",
            required: !0,
            onChange: (b) => {
              if (b.target.value !== "" && b.target.value !== "Select") {
                const v = [...e.regions];
                v[y].fromType = b.target.value, t({
                  ...e,
                  regions: v
                });
              }
              b.target.value = "";
            },
            options: d
          }
        ),
        (e.regions[y].fromType === "Fixed" || e.regions[y].fromType === "Previous Days" || !e.regions[y].fromType) && /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ a(
          Ge,
          {
            value: m,
            label: e.regions[y].fromType === "Fixed" || !((A = e.regions[y]) != null && A.fromType) ? "From Value" : "Previous Number of Days",
            fieldName: "from",
            updateField: (b, v, E, N) => n(E, N, y),
            tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value." }) })
            ] })
          }
        ) }),
        /* @__PURE__ */ a(
          xt,
          {
            value: e.regions[y].toType ?? "Fixed",
            label: "Maximum Region Type",
            initial: "Select",
            required: !0,
            onChange: (b) => {
              if (b.target.value !== "" && b.target.value !== "Select") {
                const v = [...e.regions];
                v[y].toType = b.target.value, t({
                  ...e,
                  regions: v
                });
              }
              b.target.value = "";
            },
            options: c
          }
        ),
        (e.regions[y].toType === "Fixed" || !e.regions[y].toType) && /* @__PURE__ */ a(
          Ge,
          {
            value: g,
            label: "To Value",
            fieldName: "to",
            updateField: (b, v, E, N) => n(E, N, y)
          }
        )
      ] }, `region-${y}`);
    }),
    !e.regions && /* @__PURE__ */ a("p", { style: { textAlign: "center" }, children: "There are currently no regions." }),
    /* @__PURE__ */ a(
      "button",
      {
        type: "button",
        className: "btn btn-primary full-width",
        onClick: (s) => {
          s.preventDefault(), o();
        },
        children: "Add Region"
      }
    )
  ] });
}), ZT = ({ name: e }) => {
  const { visSupportsRegions: t } = Fs(), { config: n, updateConfig: r } = de.useContext(vt);
  return t() ? /* @__PURE__ */ z(Nn, { children: [
    /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ a(Dn, { children: e }) }),
    /* @__PURE__ */ a(_n, { children: /* @__PURE__ */ a(qT, { config: n, updateConfig: r }) })
  ] }) : null;
}, Eh = de.createContext(null), Rh = () => {
  const e = de.useContext(Eh);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, QT = (e) => {
  const { config: t } = de.useContext(vt), { updateField: n } = Rh(), {
    enabledChartTypes: r,
    visHasNumbersOnBars: i,
    visHasaAdditionalLabelsOnBars: o,
    visHasLabelOnData: d,
    visSupportsChartHeight: c,
    visSupportsMobileChartHeight: s,
    visSupportsSuperTitle: p,
    visSupportsFootnotes: m
  } = Fs(), { visualizationType: g, visualizationSubType: x, barStyle: T } = t, y = () => (g === "Bar" || g === "Deviation Bar") && x !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ z(Nn, { children: [
    " ",
    /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ a(Dn, { children: "General" }) }),
    /* @__PURE__ */ z(_n, { children: [
      (t == null ? void 0 : t.visualizationType) !== "Sankey" && /* @__PURE__ */ a(
        xt,
        {
          value: g,
          fieldName: "visualizationType",
          label: "Chart Type",
          updateField: n,
          options: r
        }
      ),
      c() && t.orientation === "vertical" && /* @__PURE__ */ z("div", { className: s() ? "two-col-inputs" : "", children: [
        /* @__PURE__ */ a(
          Ge,
          {
            type: "number",
            value: t.heights.vertical,
            section: "heights",
            fieldName: "vertical",
            label: "Chart Height",
            updateField: n,
            tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ z(oe.Target, { children: [
                "˝",
                /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } })
              ] }),
              /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "For some visualization types, such as the Sankey diagram, it may be necessary to adjust the chart height for optimal display." }) })
            ] })
          }
        ),
        s() && t.orientation === "vertical" && /* @__PURE__ */ a(
          Ge,
          {
            type: "number",
            value: t.heights.mobileVertical,
            section: "heights",
            fieldName: "mobileVertical",
            label: "Mobile Height",
            updateField: n,
            tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "If the chart height is not optimized for mobile, you can adjust the height for better display. Not setting a value will default to the chart height." }) })
            ] })
          }
        )
      ] }),
      (g === "Bar" || g === "Combo" || g === "Area Chart") && /* @__PURE__ */ a(
        xt,
        {
          value: x || "Regular",
          fieldName: "visualizationSubType",
          label: "Chart Subtype",
          updateField: n,
          options: ["regular", "stacked"]
        }
      ),
      g === "Area Chart" && x === "stacked" && /* @__PURE__ */ a(
        xt,
        {
          value: t.stackedAreaChartLineType || "Linear",
          fieldName: "stackedAreaChartLineType",
          label: "Stacked Area Chart Line Type",
          updateField: n,
          options: Object.keys(ul)
        }
      ),
      g === "Bar" && /* @__PURE__ */ a(
        xt,
        {
          value: t.orientation || "vertical",
          fieldName: "orientation",
          label: "Orientation",
          updateField: n,
          options: ["vertical", "horizontal"]
        }
      ),
      g === "Deviation Bar" && /* @__PURE__ */ a(xt, { label: "Orientation", options: ["horizontal"] }),
      (g === "Bar" || g === "Deviation Bar") && /* @__PURE__ */ a(
        xt,
        {
          value: t.isLollipopChart ? "lollipop" : T || "flat",
          fieldName: "barStyle",
          label: "bar style",
          updateField: n,
          options: y(),
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Consider using the 'Flat' bar style when presenting data that includes '0' values." }) })
          ] })
        }
      ),
      (g === "Bar" || g === "Deviation Bar") && T === "rounded" && /* @__PURE__ */ a(
        xt,
        {
          value: t.tipRounding || "top",
          fieldName: "tipRounding",
          label: "tip rounding",
          updateField: n,
          options: ["top", "full"]
        }
      ),
      (g === "Bar" || g === "Deviation Bar") && T === "rounded" && /* @__PURE__ */ a(
        xt,
        {
          value: t.roundingStyle || "standard",
          fieldName: "roundingStyle",
          label: "rounding style",
          updateField: n,
          options: ["standard", "shallow", "finger"]
        }
      ),
      g === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ a(
        xt,
        {
          value: t.yAxis.labelPlacement || "Below Bar",
          section: "yAxis",
          fieldName: "labelPlacement",
          label: "Label Placement",
          updateField: n,
          options: ["Below Bar", "On Date/Category Axis"]
        }
      ),
      i() ? /* @__PURE__ */ a(
        et,
        {
          value: t.yAxis.displayNumbersOnBar,
          section: "yAxis",
          fieldName: "displayNumbersOnBar",
          label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar",
          updateField: n
        }
      ) : d() && /* @__PURE__ */ a(
        et,
        {
          value: t.labels,
          fieldName: "labels",
          label: "Display label on data",
          updateField: n,
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ z(oe.Content, { children: [
              /* @__PURE__ */ a("p", { children: "Recommended set to display for Section 508 compliance." }),
              /* @__PURE__ */ a("hr", {}),
              /* @__PURE__ */ z("p", { children: [
                "Selecting this option will ",
                /* @__PURE__ */ a("i", { children: " not " }),
                ' hide the display of "zero value", "suppressed data", or "missing data" indicators on the chart (if applicable).'
              ] })
            ] })
          ] })
        }
      ),
      o() && /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ a(
          et,
          {
            tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: 'Selecting this option will display a thin line slightly above the Date/Category Axis to indicate "zero value" where zero values are indicated in the Data Series.' }) })
            ] }),
            value: t.general.showZeroValueData,
            section: "general",
            fieldName: "showZeroValueData",
            label: 'Display "Zero Data" Label',
            updateField: n
          }
        ),
        /* @__PURE__ */ a(
          et,
          {
            tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ z(oe.Content, { children: [
                t.visualizationSubType === "stacked" && /* @__PURE__ */ a("p", { children: "We do not recommend using stacked vertical/horizontal bar charts for missing data. If you choose to proceed, selecting this option will display 'N/A' in the tooltip hover and data table (e.g. nothing will display in chart)." }),
                t.visualizationSubType !== "stacked" && /* @__PURE__ */ a("p", { children: "Selecting this option will display 'N/A' on the Date/Category Axis, in the tooltip hover, and in the data table to indicate missing or undefined data values." })
              ] })
            ] }),
            value: t.general.showMissingDataLabel,
            section: "general",
            fieldName: "showMissingDataLabel",
            label: 'Display "Missing Data" Label',
            updateField: n
          }
        ),
        /* @__PURE__ */ a(
          et,
          {
            display: t.visualizationType === "Bar" || t.visualizationType === "Combo",
            tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting 'Remove Null Values' will hide the 'N/A' (no data indicator) when you hover over the chart." }) })
            ] }),
            value: t.general.hideNullValue,
            section: "general",
            fieldName: "hideNullValue",
            label: 'Remove "Null" Values From Hover',
            updateField: n
          }
        ),
        /* @__PURE__ */ a(
          et,
          {
            tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ z(oe.Content, { children: [
                t.visualizationSubType !== "stacked" && /* @__PURE__ */ z("p", { children: [
                  "Selecting this option will show the ",
                  /* @__PURE__ */ a("i", { children: "suppression indicator " }),
                  " on the Date/Category axis, within tooltips, and in the data table where suppressed data values appear in the Data Series."
                ] }),
                t.visualizationSubType === "stacked" && /* @__PURE__ */ a("p", { children: "We do not recommend using stacked vertical/horizontal bar charts for suppressed data. If you choose to proceed, selecting this option will display the 'suppressed data symbol' in the tooltip hover and data table (e.g., nothing will display in the chart)." })
              ] })
            ] }),
            value: t.general.showSuppressedSymbol,
            section: "general",
            fieldName: "showSuppressedSymbol",
            label: 'Display "suppressed data" label',
            updateField: n
          }
        )
      ] }),
      g === "Pie" && /* @__PURE__ */ a(xt, { fieldName: "pieType", label: "Pie Chart Type", updateField: n, options: ["Regular", "Donut"] }),
      g === "Line" && /* @__PURE__ */ a(
        et,
        {
          value: t.allowLineToBarGraph,
          fieldName: "allowLineToBarGraph",
          label: "Convert to Bar Graph",
          updateField: n,
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Switch to bar graph when less than 3 data points available." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          value: t.title || "Chart Title",
          fieldName: "title",
          id: "title",
          label: "Title",
          placeholder: "Chart Title",
          updateField: n,
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Title is required to set the name of the download file but can be hidden using the option below." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(et, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: n }),
      p() && /* @__PURE__ */ a(
        Ge,
        {
          value: t.superTitle,
          updateField: n,
          fieldName: "superTitle",
          label: "Super Title",
          placeholder: "Super Title",
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Super Title" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "textarea",
          value: t.introText,
          updateField: n,
          fieldName: "introText",
          label: "Message",
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Intro Text" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "textarea",
          value: t.description,
          fieldName: "description",
          label: "Subtext/Citation",
          updateField: n,
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub." }) })
          ] })
        }
      ),
      m() && /* @__PURE__ */ a(
        Ge,
        {
          type: "textarea",
          value: t.footnotes,
          updateField: n,
          fieldName: "footnotes",
          label: "Footnotes",
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data." }) })
          ] })
        }
      )
    ] })
  ] });
}, JT = (e) => {
  const { config: t } = de.useContext(vt), { boxplot: n } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: r } = Rh();
  return /* @__PURE__ */ z(Nn, { children: [
    /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ a(Dn, { children: e.name }) }),
    /* @__PURE__ */ z(_n, { children: [
      /* @__PURE__ */ a("h4", { style: { fontSize: "18px" }, children: "Labels for 5-Number Summary" }),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "text",
          value: n.labels.maximum,
          fieldName: "maximum",
          section: "boxplot",
          subsection: "labels",
          label: "Maximum",
          updateField: r,
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Highest value, excluding outliers" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "text",
          value: n.labels.q3,
          fieldName: "q3",
          section: "boxplot",
          subsection: "labels",
          label: "Upper Quartile",
          updateField: r,
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Represented by top line of box. 25% of data are higher." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "text",
          value: n.labels.median,
          fieldName: "median",
          section: "boxplot",
          subsection: "labels",
          label: "Median",
          updateField: r,
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Middle data point. Half of data are higher value." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "text",
          value: n.labels.q1,
          fieldName: "q1",
          section: "boxplot",
          subsection: "labels",
          label: "Lower Quartile",
          updateField: r,
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Represented by bottom line of box. 25% of data are lower." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "text",
          value: n.labels.minimum,
          fieldName: "minimum",
          section: "boxplot",
          subsection: "labels",
          label: "Minimum",
          updateField: r,
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Lowest value, excluding outliers" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { style: { fontSize: "18px" }, children: "Labels for Additional Measures" }),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "text",
          value: n.labels.iqr,
          fieldName: "iqr",
          section: "boxplot",
          subsection: "labels",
          label: "Interquartile Range",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "text",
          value: n.labels.count,
          fieldName: "count",
          section: "boxplot",
          subsection: "labels",
          label: "Count",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "text",
          value: n.labels.mean,
          fieldName: "mean",
          section: "boxplot",
          subsection: "labels",
          label: "Mean",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "text",
          value: n.labels.outliers,
          fieldName: "outliers",
          section: "boxplot",
          subsection: "labels",
          label: "Outliers",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          type: "text",
          value: n.labels.values,
          fieldName: "values",
          section: "boxplot",
          subsection: "labels",
          label: "Values",
          updateField: r
        }
      )
    ] })
  ] });
}, eC = (e, t) => {
  let n = [], r = [], i = [];
  const o = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const d = e.twoColor.isPaletteReversed;
    n = Object.keys(_c).filter(
      (c) => d ? c.endsWith("reverse") : !c.endsWith("reverse")
    );
  } else {
    const d = [], c = [];
    for (const s in Cr) {
      const p = s.startsWith("sequential"), m = s.startsWith("qualitative"), g = s.startsWith("colorblindsafe"), x = s.endsWith("reverse");
      p && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && d.push(s), m && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && c.push(s), g && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && o.push(s);
    }
    r = d, i = c;
  }
  return de.useEffect(() => {
    let d = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (d = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (d = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: d } });
  }, [e.twoColor.isPaletteReversed]), de.useEffect(() => {
    let d = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (d = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (d = e.palette.slice(0, -7)), t({ ...e, palette: d });
  }, [e.isPaletteReversed]), { twoColorPalettes: n, sequential: r, nonSequential: i, accessibleColors: o };
}, tC = (e) => {
  var re;
  const { config: t, updateConfig: n, colorPalettes: r, twoColorPalette: i } = de.useContext(vt), { visual: o } = t, { setLollipopShape: d, updateField: c } = Rh(), {
    visHasBarBorders: s,
    visCanAnimate: p,
    visSupportsNonSequentialPallete: m,
    headerColors: g,
    visSupportsTooltipOpacity: x,
    visSupportsTooltipLines: T,
    visSupportsBarSpace: y,
    visSupportsBarThickness: A,
    visHasDataCutoff: b,
    visSupportsSequentialPallete: v,
    visSupportsReverseColorPalette: E,
    visHasSingleSeriesTooltip: N
  } = Fs(), { twoColorPalettes: R, sequential: L, nonSequential: B, accessibleColors: j } = eC(t, n), Z = (X, se) => {
    if (console.log("value", se), X === "storyNodeFontColor") {
      n({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: se
        }
      });
      return;
    } else
      n({
        ...t,
        sankey: {
          ...t.sankey,
          [X]: {
            ...t.sankey[X],
            default: se
          }
        }
      });
  };
  return /* @__PURE__ */ z(Nn, { children: [
    /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ a(Dn, { children: "Visual" }) }),
    /* @__PURE__ */ z(_n, { children: [
      (t.barStyle === "lollipop" || t.isLollipopChart) && /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ z("fieldset", { className: "header", children: [
          /* @__PURE__ */ a("legend", { className: "edit-label", children: "Lollipop Shape" }),
          /* @__PURE__ */ z(
            "div",
            {
              onChange: (X) => {
                d(X.target.value);
              },
              children: [
                /* @__PURE__ */ z("label", { className: "radio-label", children: [
                  /* @__PURE__ */ a("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }),
                  "Circle"
                ] }),
                /* @__PURE__ */ z("label", { className: "radio-label", children: [
                  /* @__PURE__ */ a("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }),
                  "Square"
                ] })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ a(
          xt,
          {
            value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone",
            fieldName: "lollipopColorStyle",
            label: "Lollipop Color Style",
            updateField: c,
            options: ["regular", "two-tone"]
          }
        ),
        /* @__PURE__ */ a(
          xt,
          {
            value: t.lollipopSize ? t.lollipopSize : "small",
            fieldName: "lollipopSize",
            label: "Lollipop Size",
            updateField: c,
            options: ["small", "medium", "large"]
          }
        )
      ] }),
      t.visualizationType === "Box Plot" && /* @__PURE__ */ z("fieldset", { className: "fieldset fieldset--boxplot", children: [
        /* @__PURE__ */ a("legend", { className: "", children: "Box Plot Settings" }),
        /* @__PURE__ */ a(
          xt,
          {
            value: t.boxplot.borders,
            fieldName: "borders",
            section: "boxplot",
            label: "Box Plot Borders",
            updateField: c,
            options: ["true", "false"]
          }
        ),
        /* @__PURE__ */ a(
          et,
          {
            value: t.boxplot.plotOutlierValues,
            fieldName: "plotOutlierValues",
            section: "boxplot",
            label: "Plot Outliers",
            updateField: c
          }
        ),
        /* @__PURE__ */ a(
          et,
          {
            value: t.boxplot.plotNonOutlierValues,
            fieldName: "plotNonOutlierValues",
            section: "boxplot",
            label: "Plot non-outlier values",
            updateField: c
          }
        )
      ] }),
      s() && /* @__PURE__ */ a(
        xt,
        {
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
              Ze,
              {
                display: "question",
                style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
              }
            ) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Recommended set to display for Section 508 compliance." }) })
          ] }),
          value: t.barHasBorder,
          fieldName: "barHasBorder",
          label: "Bar Borders",
          updateField: c,
          options: ["true", "false"]
        }
      ),
      p() && /* @__PURE__ */ a(
        et,
        {
          value: t.animate,
          fieldName: "animate",
          label: "Animate Visualization",
          updateField: c
        }
      ),
      (((re = t.series) == null ? void 0 : re.some(
        (X) => X.type === "Line" || X.type === "dashed-lg" || X.type === "dashed-sm" || X.type === "dashed-md"
      )) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ a(
          xt,
          {
            tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                Ze,
                {
                  display: "question",
                  style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                }
              ) }),
              /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Shapes will appear in the following order: circle, square, triangle, diamond, and inverted triangle. Use with a maximum of 5 data points." }) })
            ] }),
            value: t.visual.lineDatapointSymbol,
            section: "visual",
            fieldName: "lineDatapointSymbol",
            label: "Line Datapoint Symbols",
            updateField: c,
            options: ["none", "standard"]
          }
        ),
        t.series.length > t.visual.maximumShapeAmount && t.visual.lineDatapointSymbol === "standard" && /* @__PURE__ */ a("small", { className: "text-danger", children: "Standard only supports up to 7 data points" }),
        /* @__PURE__ */ a(
          xt,
          {
            value: t.lineDatapointStyle,
            fieldName: "lineDatapointStyle",
            label: "Line Datapoint Style",
            updateField: c,
            options: ["hidden", "hover", "always show"]
          }
        ),
        /* @__PURE__ */ a(
          xt,
          {
            value: t.lineDatapointColor,
            fieldName: "lineDatapointColor",
            label: "Line Datapoint Color",
            updateField: c,
            options: ["Same as Line", "Lighter than Line"]
          }
        )
      ] }),
      /* @__PURE__ */ z("label", { className: "header", children: [
        /* @__PURE__ */ a("span", { className: "edit-label", children: "Header Theme" }),
        /* @__PURE__ */ a("ul", { className: "color-palette", children: g.map((X) => /* @__PURE__ */ a(
          "button",
          {
            title: X,
            onClick: (se) => {
              se.preventDefault(), n({ ...t, theme: X });
            },
            className: t.theme === X ? "selected " + X : X
          },
          X
        )) })
      ] }),
      (m() || m()) && /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ a("label", { children: /* @__PURE__ */ a("span", { className: "edit-label", children: "Chart Color Palette" }) }),
        E() && /* @__PURE__ */ a(
          Ih,
          {
            fieldName: "isPaletteReversed",
            size: "small",
            label: "Use selected palette in reverse order",
            updateField: c,
            value: t.isPaletteReversed
          }
        ),
        v() && /* @__PURE__ */ z(Ue, { children: [
          /* @__PURE__ */ a("span", { children: "Sequential" }),
          /* @__PURE__ */ a("ul", { className: "color-palette", children: L.map((X) => {
            const se = {
              backgroundColor: r[X][2]
            }, Y = {
              backgroundColor: r[X][3]
            }, ie = {
              backgroundColor: r[X][5]
            };
            return /* @__PURE__ */ z(
              "button",
              {
                title: X,
                onClick: (I) => {
                  I.preventDefault(), n({ ...t, palette: X });
                },
                className: t.palette === X ? "selected" : "",
                children: [
                  /* @__PURE__ */ a("span", { style: se }),
                  /* @__PURE__ */ a("span", { style: Y }),
                  /* @__PURE__ */ a("span", { style: ie })
                ]
              },
              X
            );
          }) })
        ] }),
        m() && /* @__PURE__ */ z(Ue, { children: [
          /* @__PURE__ */ a("span", { children: "Non-Sequential" }),
          /* @__PURE__ */ a("ul", { className: "color-palette", children: B.map((X) => {
            const se = {
              backgroundColor: r[X][2]
            }, Y = {
              backgroundColor: r[X][4]
            }, ie = {
              backgroundColor: r[X][6]
            };
            return /* @__PURE__ */ z(
              "button",
              {
                title: X,
                onClick: (I) => {
                  I.preventDefault(), n({ ...t, palette: X });
                },
                className: t.palette === X ? "selected" : "",
                children: [
                  /* @__PURE__ */ a("span", { style: se }),
                  /* @__PURE__ */ a("span", { style: Y }),
                  /* @__PURE__ */ a("span", { style: ie })
                ]
              },
              X
            );
          }) }),
          /* @__PURE__ */ a("span", { children: "Colorblind Safe" }),
          /* @__PURE__ */ a("ul", { className: "color-palette", children: j.map((X) => {
            const se = {
              backgroundColor: r[X][2]
            }, Y = {
              backgroundColor: r[X][3]
            }, ie = {
              backgroundColor: r[X][5]
            };
            return /* @__PURE__ */ z(
              "button",
              {
                title: X,
                onClick: (I) => {
                  I.preventDefault(), n({ ...t, palette: X });
                },
                className: t.palette === X ? "selected" : "",
                children: [
                  /* @__PURE__ */ a("span", { style: se }),
                  /* @__PURE__ */ a("span", { style: Y }),
                  /* @__PURE__ */ a("span", { style: ie })
                ]
              },
              X
            );
          }) })
        ] })
      ] }),
      t.visualizationType === "Sankey" && /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ z("span", { className: "sankey__color-input", children: [
          /* @__PURE__ */ a(
            "input",
            {
              type: "color",
              value: t.sankey.nodeColor.default,
              id: "storyNodeColor",
              name: "storyNodeColor",
              onChange: (X) => Z("nodeColor", X.target.value)
            }
          ),
          /* @__PURE__ */ a("label", { htmlFor: "storyNodeColor", children: "Story Node Color" })
        ] }),
        /* @__PURE__ */ z("span", { className: "sankey__color-input", children: [
          /* @__PURE__ */ a(
            "input",
            {
              type: "color",
              value: t.sankey.storyNodeFontColor || "red",
              id: "storyNodeFontColor",
              name: "storyNodeFontColor",
              onChange: (X) => Z("storyNodeFontColor", X.target.value)
            }
          ),
          /* @__PURE__ */ a("label", { htmlFor: "storyNodeFontColor", children: "Story Node Font Color" })
        ] }),
        /* @__PURE__ */ z("span", { className: "sankey__color-input", children: [
          /* @__PURE__ */ a(
            "input",
            {
              type: "color",
              value: t.sankey.linkColor.default,
              id: "linkColor",
              name: "linkColor",
              onChange: (X) => Z("linkColor", X.target.value)
            }
          ),
          /* @__PURE__ */ a("label", { htmlFor: "linkColor", children: "Link Color" })
        ] })
      ] }),
      (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ a(
          Ih,
          {
            section: "twoColor",
            fieldName: "isPaletteReversed",
            size: "small",
            label: "Use selected palette in reverse order",
            updateField: c,
            value: t.twoColor.isPaletteReversed
          }
        ),
        /* @__PURE__ */ a("ul", { className: "color-palette", children: R.map((X) => {
          const se = {
            backgroundColor: i[X][0]
          }, Y = {
            backgroundColor: i[X][1]
          };
          return /* @__PURE__ */ z(
            "button",
            {
              title: X,
              onClick: (ie) => {
                ie.preventDefault(), n({ ...t, twoColor: { ...t.twoColor, palette: X } });
              },
              className: t.twoColor.palette === X ? "selected" : "",
              children: [
                /* @__PURE__ */ a("span", { className: "two-color", style: se }),
                /* @__PURE__ */ a("span", { className: "two-color", style: Y })
              ]
            },
            X
          );
        }) })
      ] }),
      b() && /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ a(
        Ge,
        {
          value: t.dataCutoff,
          type: "number",
          fieldName: "dataCutoff",
          className: "number-narrow",
          label: "Data Cutoff",
          updateField: c,
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.' }) })
          ] })
        }
      ) }),
      A() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ a(
        Ge,
        {
          type: "number",
          value: t.barHeight || "25",
          fieldName: "barHeight",
          label: " Bar Thickness",
          updateField: c,
          min: 15
        }
      ),
      (t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ a(
        Ge,
        {
          value: t.barThickness,
          type: "number",
          fieldName: "barThickness",
          label: "Bar Thickness",
          updateField: c
        }
      ),
      y() && /* @__PURE__ */ a(
        Ge,
        {
          type: "number",
          value: t.barSpace || "15",
          fieldName: "barSpace",
          label: "Bar Space",
          updateField: c,
          min: 0
        }
      ),
      (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ a(
        et,
        {
          value: t.topAxis.hasLine,
          section: "topAxis",
          fieldName: "hasLine",
          label: "Add Top Axis Line",
          updateField: c
        }
      ),
      t.visualizationType === "Spark Line" && /* @__PURE__ */ z("div", { className: "cove-accordion__panel-section checkbox-group", children: [
        /* @__PURE__ */ a(
          et,
          {
            value: o == null ? void 0 : o.border,
            section: "visual",
            fieldName: "border",
            label: "Show Border",
            updateField: c
          }
        ),
        /* @__PURE__ */ a(
          et,
          {
            value: o == null ? void 0 : o.borderColorTheme,
            section: "visual",
            fieldName: "borderColorTheme",
            label: "Use Border Color Theme",
            updateField: c
          }
        ),
        /* @__PURE__ */ a(
          et,
          {
            value: o == null ? void 0 : o.accent,
            section: "visual",
            fieldName: "accent",
            label: "Use Accent Style",
            updateField: c
          }
        ),
        /* @__PURE__ */ a(
          et,
          {
            value: o == null ? void 0 : o.background,
            section: "visual",
            fieldName: "background",
            label: "Use Theme Background Color",
            updateField: c
          }
        ),
        /* @__PURE__ */ a(
          et,
          {
            value: o == null ? void 0 : o.hideBackgroundColor,
            section: "visual",
            fieldName: "hideBackgroundColor",
            label: "Hide Background Color",
            updateField: c
          }
        )
      ] }),
      (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ a(
        et,
        {
          value: t.showLineSeriesLabels,
          fieldName: "showLineSeriesLabels",
          label: "Append Series Name to End of Line Charts",
          updateField: c
        }
      ),
      (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ a(
        et,
        {
          value: t.colorMatchLineSeriesLabels,
          fieldName: "colorMatchLineSeriesLabels",
          label: "Match Series Color to Name at End of Line Charts",
          updateField: c
        }
      ),
      T() && /* @__PURE__ */ z(Ue, { children: [
        /* @__PURE__ */ a(
          et,
          {
            value: o.verticalHoverLine,
            fieldName: "verticalHoverLine",
            section: "visual",
            label: "Vertical Hover Line",
            updateField: c
          }
        ),
        /* @__PURE__ */ a(
          et,
          {
            value: o.horizontalHoverLine,
            fieldName: "horizontalHoverLine",
            section: "visual",
            label: "Horizontal Hover Line",
            updateField: c
          }
        )
      ] }),
      x() && /* @__PURE__ */ z("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Tooltip Opacity" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            value: t.tooltips.opacity ? t.tooltips.opacity : 100,
            onChange: (X) => n({
              ...t,
              tooltips: {
                ...t.tooltips,
                opacity: X.target.value
              }
            })
          }
        )
      ] }),
      N() && /* @__PURE__ */ a(
        et,
        {
          value: t.tooltips.singleSeries,
          fieldName: "singleSeries",
          section: "tooltips",
          label: "SHOW HOVER FOR SINGLE DATA SERIES",
          updateField: c
        }
      ),
      /* @__PURE__ */ z("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "No Data Message" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "text",
            value: t.chartMessage.noData ? t.chartMessage.noData : "",
            onChange: (X) => n({
              ...t,
              chartMessage: {
                ...t.chartMessage,
                noData: X.target.value
              }
            })
          }
        )
      ] })
    ] })
  ] });
}, nC = (e) => {
  var s, p, m, g, x;
  const { config: t, updateConfig: n } = de.useContext(vt), r = (s = t.data) == null ? void 0 : s[0], { updateField: i } = de.useContext(Eh);
  if (t.visualizationType !== "Sankey")
    return;
  const o = (T, y, A) => {
    let b = [];
    r != null && r.storyNodeText && (b = [...r == null ? void 0 : r.storyNodeText]), b[A][T] = y, n({
      ...t,
      sankey: {
        ...t.sankey,
        data: {
          ...t.sankey.data,
          storyNodeText: b
        }
      }
    });
  }, d = () => {
    const T = r;
    T.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), n({
      ...t,
      sankey: {
        ...t.sankey,
        data: [{ ...T }]
      }
    });
  }, c = (T) => {
    const y = r;
    y.storyNodeText.splice(T, 1), n({ ...t, sankey: { ...t.sankey, data: { ...y } } });
  };
  return /* @__PURE__ */ z(Nn, { children: [
    /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ a(Dn, { children: "Sankey Settings" }) }),
    /* @__PURE__ */ z(_n, { children: [
      /* @__PURE__ */ a("p", { children: "Node stories can provide additional details to support public health messaging. COVE can display a maximum of 3 node stories." }),
      (r == null ? void 0 : r.storyNodeText) && (r == null ? void 0 : r.storyNodeText.map(({ StoryNode: T, segmentTextBefore: y, segmentTextAfter: A }, b) => /* @__PURE__ */ z(
        "div",
        {
          style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" },
          children: [
            /* @__PURE__ */ z("label", { children: [
              "Story Node Text",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "text",
                  value: T,
                  fieldName: "StoryNode",
                  label: "StoryNode",
                  onChange: (v) => o("StoryNode", v.target.value, b)
                }
              )
            ] }),
            /* @__PURE__ */ z("label", { children: [
              "Story Text Before",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "text",
                  value: y,
                  fieldName: "segmentTextBefore",
                  label: "Segment Text Before",
                  onChange: (v) => o("segmentTextBefore", v.target.value, b)
                }
              )
            ] }),
            /* @__PURE__ */ z("label", { children: [
              "Story Text After",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "text",
                  value: A,
                  fieldName: "segmentTextAfter",
                  label: "Segment Text After",
                  onChange: (v) => o("segmentTextAfter", v.target.value, b)
                }
              )
            ] }),
            /* @__PURE__ */ a(Oc, { onClick: (v) => c(b), className: "btn btn-danger full-width", children: "Remove Story Node" })
          ]
        },
        b
      ))),
      ((p = r == null ? void 0 : r.storyNodeText) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ a(
        "button",
        {
          type: "button",
          className: "btn btn-primary full-width",
          onClick: (T) => {
            T.preventDefault(), d();
          },
          children: "Add StoryNode"
        }
      ),
      ((x = (g = (m = t.data) == null ? void 0 : m[0]) == null ? void 0 : g.tooltips) == null ? void 0 : x.length) > 0 && /* @__PURE__ */ a(
        et,
        {
          value: t.enableTooltips,
          fieldName: "enableTooltips",
          label: "Enable Tooltips",
          updateField: i
        }
      )
    ] })
  ] });
};
const rC = (e) => {
  var c, s, p;
  const { updateConfig: t, config: n, svgRef: r } = de.useContext(vt), i = (m, g, x) => {
    var b;
    const T = (b = document.querySelector(".chart-container  > svg")) == null ? void 0 : b.getBoundingClientRect(), y = [T == null ? void 0 : T.width, T == null ? void 0 : T.height], A = [...n == null ? void 0 : n.annotations];
    A[x][g] = m, A[x].savedDimensions = y, t({
      ...n,
      annotations: A
    });
  }, o = () => {
    var T, y, A, b, v, E, N, R, L, B;
    const m = [
      ((A = (y = (T = r == null ? void 0 : r.current) == null ? void 0 : T.width) == null ? void 0 : y.baseVal) == null ? void 0 : A.value) || ((b = r == null ? void 0 : r.current) == null ? void 0 : b.width),
      ((N = (E = (v = r == null ? void 0 : r.current) == null ? void 0 : v.height) == null ? void 0 : E.baseVal) == null ? void 0 : N.value) || ((R = r == null ? void 0 : r.current) == null ? void 0 : R.height)
    ], g = {
      text: "New Annotation",
      snapToNearestPoint: !1,
      fontSize: 16,
      bezier: 10,
      show: {
        desktop: !0,
        tablet: !0,
        mobile: !0
      },
      connectorType: "line",
      colors: {
        label: "black",
        connector: "black",
        marker: "black"
      },
      selected: !0,
      anchor: {
        vertical: !1,
        horizontal: !1
      },
      marker: "arrow",
      edit: {
        subject: !0,
        label: !0
      },
      seriesKey: "",
      x: 50,
      y: Number((m == null ? void 0 : m[1]) / 2),
      xKey: n.xAxis.type === "date" ? new Date((B = (L = n == null ? void 0 : n.data) == null ? void 0 : L[0]) == null ? void 0 : B[n.xAxis.dataKey]).getTime() : n.xAxis.type === "categorical" ? "1/15/2016" : "",
      yKey: "",
      dx: 20,
      dy: -20,
      opacity: "100",
      savedDimensions: m,
      connectionType: "line"
    }, x = Array.isArray(n.annotations) ? n.annotations : [];
    t({
      ...n,
      annotations: [...x, g]
    });
  }, d = (m) => {
    const g = n.annotations.filter((x, T) => T !== m);
    t({
      ...n,
      annotations: g
    });
  };
  return /* @__PURE__ */ a(Eu, { children: /* @__PURE__ */ z(Eu.Section, { title: e.name, children: [
    /* @__PURE__ */ z("label", { children: [
      "Show Annotation Dropdown",
      /* @__PURE__ */ a(
        "input",
        {
          type: "checkbox",
          checked: ((c = n == null ? void 0 : n.general) == null ? void 0 : c.showAnnotationDropdown) || !1,
          onChange: (m) => {
            t({
              ...n,
              general: {
                ...n.general,
                showAnnotationDropdown: m.target.checked
              }
            });
          }
        }
      )
    ] }, "key-1"),
    n.general.showAnnotationDropdown && /* @__PURE__ */ z("label", { children: [
      "Annotation Dropdown Title:",
      /* @__PURE__ */ a(
        "input",
        {
          type: "text",
          style: { marginBottom: "10px" },
          value: (s = n == null ? void 0 : n.general) == null ? void 0 : s.annotationDropdownText,
          onChange: (m) => {
            t({
              ...n,
              general: {
                ...n.general,
                annotationDropdownText: m.target.value
              }
            });
          }
        }
      )
    ] }, "key-2"),
    (n == null ? void 0 : n.annotations) && (n == null ? void 0 : n.annotations.map((m, g) => {
      var x, T, y, A, b, v, E, N;
      return /* @__PURE__ */ a(Eu, { children: /* @__PURE__ */ a(
        Eu.Section,
        {
          title: m.text ? m.text.substring(0, 15) + "..." : `Annotation ${g + 1}`,
          children: /* @__PURE__ */ z("div", { className: "annotation-group", children: [
            /* @__PURE__ */ z("label", { children: [
              "Annotation Text:",
              /* @__PURE__ */ a(
                "textarea",
                {
                  rows: 5,
                  value: m.text,
                  onChange: (R) => i(R.target.value, "text", g)
                }
              )
            ] }),
            /* @__PURE__ */ z("label", { children: [
              "Opacity",
              /* @__PURE__ */ a("br", {}),
              /* @__PURE__ */ a(
                "input",
                {
                  type: "range",
                  onChange: (R) => {
                    const L = nt.cloneDeep(n == null ? void 0 : n.annotations);
                    L[g].opacity = R.target.value, t({
                      ...n,
                      annotations: L
                    });
                  },
                  value: ((T = (x = n == null ? void 0 : n.annotations) == null ? void 0 : x[g]) == null ? void 0 : T.opacity) || "100"
                }
              )
            ] }),
            /* @__PURE__ */ z("label", { children: [
              "Edit Subject",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: ((A = (y = n == null ? void 0 : n.annotations[g]) == null ? void 0 : y.edit) == null ? void 0 : A.subject) || !1,
                  onChange: (R) => {
                    const L = nt.cloneDeep(n == null ? void 0 : n.annotations);
                    L[g].edit.subject = R.target.checked, t({
                      ...n,
                      annotations: L
                    });
                  }
                }
              )
            ] }),
            /* @__PURE__ */ z("label", { children: [
              "Edit Label",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: ((v = (b = n == null ? void 0 : n.annotations[g]) == null ? void 0 : b.edit) == null ? void 0 : v.label) || !1,
                  onChange: (R) => {
                    const L = nt.cloneDeep(n == null ? void 0 : n.annotations);
                    L[g].edit.label = R.target.checked, t({
                      ...n,
                      annotations: L
                    });
                  }
                }
              )
            ] }),
            /* @__PURE__ */ z("label", { children: [
              "Connection Type:",
              /* @__PURE__ */ z(
                "select",
                {
                  onChange: (R) => {
                    const L = nt.cloneDeep(n == null ? void 0 : n.annotations);
                    L[g].connectionType = R.target.value, t({
                      ...n,
                      annotations: L
                    });
                  },
                  value: (E = n == null ? void 0 : n.annotations[g]) == null ? void 0 : E.connectionType,
                  children: [
                    /* @__PURE__ */ a("option", { value: "select", children: "Select" }, "select"),
                    ["curve", "line", "elbow", "none"].map((R, L) => /* @__PURE__ */ a("option", { value: R, children: R }, R))
                  ]
                },
                "annotation-connection-type"
              )
            ] }),
            m.connectionType === "curve" && /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z("label", { children: [
              "Curve Control",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "range",
                  min: "-20",
                  max: "20",
                  value: ((N = n == null ? void 0 : n.annotations[g]) == null ? void 0 : N.bezier) || 0,
                  onChange: (R) => {
                    const L = nt.cloneDeep(n == null ? void 0 : n.annotations);
                    L[g].bezier = R.target.value, t({
                      ...n,
                      annotations: L
                    });
                  }
                }
              )
            ] }) }),
            /* @__PURE__ */ z("label", { children: [
              "Marker",
              /* @__PURE__ */ a(
                "select",
                {
                  value: m.marker,
                  onChange: (R) => {
                    const L = nt.cloneDeep(n == null ? void 0 : n.annotations);
                    L[g].marker = R.target.value, t({
                      ...n,
                      annotations: L
                    });
                  },
                  children: ["arrow", "circle"].map((R, L) => /* @__PURE__ */ a("option", { children: R }, `col-${L}`))
                },
                "annotation-marker"
              )
            ] }),
            /* @__PURE__ */ a(Oc, { className: "btn btn-danger full-width", onClick: () => d(g), children: "Delete Annotation" })
          ] })
        }
      ) }, g);
    })),
    ((p = n == null ? void 0 : n.annotations) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ a("button", { onClick: o, className: "btn btn-primary mt-2 full-width", children: "Add Annotation" })
  ] }, e.name) }, e.name);
}, bi = {
  ForestPlot: FT,
  Series: ni,
  Regions: ZT,
  General: QT,
  BoxPlot: JT,
  Visual: tC,
  Sankey: nC,
  Annotate: rC
};
const iC = new zm(), xm = (e, t) => {
  for (let n = 0; n < e.length; n++) {
    let r = Object.keys(e[n]), i = !0;
    for (let o = 0; o < r.length; o++)
      if (e[n][r[o]] !== t[r[o]]) {
        i = !1;
        break;
      }
    if (i)
      return n;
  }
  return -1;
}, aC = (e, t, n) => {
  var i;
  const r = nt.cloneDeep(e);
  if (r.rankByValue = t, e.rankByValue && !t) {
    const o = (i = e == null ? void 0 : e.xAxis) != null && i.dataKey ? iC.cleanData(e.data, e.xAxis.dataKey) : e.data, d = n.sort((c, s) => {
      const p = xm(o, c), m = xm(o, s);
      return p - m;
    });
    return [r, d];
  }
  return [r];
}, oC = ({ config: e, updateConfig: t, data: n }) => {
  var b, v, E;
  const r = e.visualizationType === "Combo", i = ((b = e.runtime.lineSeriesKeys) == null ? void 0 : b.length) > 0, o = ((v = e.runtime.barSeriesKeys) == null ? void 0 : v.length) > 0, d = r && i, c = r && o, s = () => nt.uniq(nt.flatMap(n, nt.keys)), p = () => e.visualizationType === "Line" || d ? ["effect", "suppression"] : ["suppression"], m = {
    "Dashed Small": "- - -",
    "Dashed Medium": "– –",
    "Dashed Large": "— –",
    "Open Circles": "◯",
    "Filled Circles": ""
  }, g = (N) => {
    const R = Object.keys(m);
    return N === "suppression" ? R.slice(0, -2) : R;
  }, x = () => {
    if (e.visualizationType === "Bar" || c)
      return Object.keys(Hh);
  };
  let T = (N) => {
    let R = [];
    e.preliminaryData && (R = [...e.preliminaryData]), R.splice(N, 1), t({ ...e, preliminaryData: R });
  }, y = () => {
    const N = e.visualizationType === "Line" ? "effect" : "suppression";
    let R = e.preliminaryData ? [...e.preliminaryData] : [];
    const L = {
      type: N,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: "",
      hideBarSymbol: !1,
      hideLineStyle: !1,
      circleSize: 6,
      displayGray: !0
    };
    R.push(L), t({ ...e, preliminaryData: R });
  }, A = (N, R, L) => {
    let B = [];
    e.preliminaryData && (B = [...e.preliminaryData]), B[L][N] = R, N === "symbol" && (B[L].iconCode = Hh[R]), N === "style" && (B[L].lineCode = m[R]), t({ ...e, preliminaryData: B });
  };
  return /* @__PURE__ */ z(Ue, { children: [
    e.preliminaryData && ((E = e.preliminaryData) == null ? void 0 : E.map(
      ({
        displayGray: N,
        circleSize: R,
        column: L,
        displayLegend: B,
        displayTable: j,
        displayTooltip: Z,
        label: re,
        seriesKey: X,
        style: se,
        symbol: Y,
        type: ie,
        value: I,
        hideBarSymbol: U,
        hideLineStyle: ue
      }, te) => {
        var J, Q;
        return /* @__PURE__ */ z("div", { className: "edit-block", children: [
          /* @__PURE__ */ z("p", { children: [
            " ",
            ie === "suppression" ? "Suppressed" : "Effect",
            " Data"
          ] }),
          /* @__PURE__ */ a(
            "button",
            {
              type: "button",
              className: "btn btn-danger",
              onClick: (G) => {
                G.preventDefault(), T(te);
              },
              children: "Remove"
            }
          ),
          /* @__PURE__ */ a(
            xt,
            {
              value: ie,
              initial: e.visualizationType == "Bar" ? "" : "Select",
              fieldName: "type",
              label: "Type",
              updateField: (G, ne, H, ce) => A(H, ce, te),
              options: p()
            }
          ),
          ie === "suppression" ? /* @__PURE__ */ z(Ue, { children: [
            /* @__PURE__ */ a(
              xt,
              {
                tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ z("p", { children: [
                    " ",
                    'Without a selected "Data Series", the suppression symbol will be applied for all series in the current dataset visualization. However, choosing a specific "data series" will isolate the suppression to that series.'
                  ] }) })
                ] }),
                value: L,
                initial: "Select",
                fieldName: "column",
                label: "Add Data Series",
                updateField: (G, ne, H, ce) => A(H, ce, te),
                options: (J = e.runtime) == null ? void 0 : J.seriesKeys
              }
            ),
            /* @__PURE__ */ a(
              Ge,
              {
                value: I,
                fieldName: "value",
                label: "Suppressed Data  Value",
                updateField: (G, ne, H, ce) => A(H, ce, te)
              }
            ),
            (d || e.visualizationType === "Line") && /* @__PURE__ */ z(Ue, { children: [
              /* @__PURE__ */ a(
                xt,
                {
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "The recommended approach for presenting data is to include a footnote indicating any data suppression." }) })
                  ] }),
                  value: se,
                  initial: "Select",
                  fieldName: "style",
                  label: "suppression line style",
                  updateField: (G, ne, H, ce) => A(H, ce, te),
                  options: g(ie)
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  value: ue,
                  fieldName: "hideLineStyle",
                  label: "Hide Suppressed line Style",
                  updateField: (G, ne, H, ce) => A(H, ce, te)
                }
              )
            ] }),
            (c || e.visualizationType === "Bar") && /* @__PURE__ */ z(Ue, { children: [
              /* @__PURE__ */ a(
                xt,
                {
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ z("p", { children: [
                      "A symbol is ",
                      /* @__PURE__ */ a("i", { children: "required" }),
                      ' to indicate suppressed data. We suggest "double asterisks." If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'
                    ] }) })
                  ] }),
                  value: Y,
                  initial: "Select",
                  fieldName: "symbol",
                  label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
                  updateField: (G, ne, H, ce) => A(H, ce, te),
                  options: x()
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  value: U,
                  fieldName: "hideBarSymbol",
                  label: "Hide Suppressed Bar Symbol  ",
                  updateField: (G, ne, H, ce) => A(H, ce, te)
                }
              )
            ] }),
            /* @__PURE__ */ a(
              Ge,
              {
                tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "This label will display in the tooltip and legend." }) })
                ] }),
                value: re || "Suppressed",
                fieldName: "label",
                label: "Suppressed Data Label",
                placeholder: "",
                updateField: (G, ne, H, ce) => A(H, ce, te)
              }
            ),
            /* @__PURE__ */ a(
              et,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: 'Deselecting the "Display In Tooltips" option prevents suppressed values from appearing in tooltips.' }) })
                ] }),
                value: Z,
                fieldName: "displayTooltip",
                label: "Display in tooltips",
                updateField: (G, ne, H, ce) => A(H, ce, te)
              }
            ),
            /* @__PURE__ */ a(
              et,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.' }) })
                ] }),
                value: B,
                fieldName: "displayLegend",
                label: "Display in legend",
                updateField: (G, ne, H, ce) => A(H, ce, te)
              }
            ),
            /* @__PURE__ */ a(
              et,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.' }) })
                ] }),
                value: j,
                fieldName: "displayTable",
                label: "Display in table",
                updateField: (G, ne, H, ce) => A(H, ce, te)
              }
            ),
            /* @__PURE__ */ a(
              et,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting this option will apply to chart, tooltip hover, legend, and data table." }) })
                ] }),
                value: N,
                fieldName: "displayGray",
                label: "Highlight Suppressed Data In Gray",
                updateField: (G, ne, H, ce) => A(H, ce, te)
              }
            )
          ] }) : /* @__PURE__ */ z(Ue, { children: [
            /* @__PURE__ */ a(
              xt,
              {
                value: X,
                initial: "Select",
                fieldName: "seriesKey",
                label: "ASSOCIATE TO SERIES",
                updateField: (G, ne, H, ce) => A(H, ce, te),
                options: e.runtime.lineSeriesKeys ?? ((Q = e.runtime) == null ? void 0 : Q.seriesKeys)
              }
            ),
            /* @__PURE__ */ a(
              xt,
              {
                value: L,
                initial: "Select",
                fieldName: "column",
                label: "COLUMN WITH CONFIGURATION VALUE",
                updateField: (G, ne, H, ce) => A(H, ce, te),
                options: s()
              }
            ),
            /* @__PURE__ */ a(
              Ge,
              {
                tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "If 'Filled Circles' is selected as the style, this field is optional, and the style 'Filled Circles' will apply to all points within the associated series data." }) })
                ] }),
                value: I,
                fieldName: "value",
                label: "VALUE TO TRIGGER",
                updateField: (G, ne, H, ce) => A(H, ce, te)
              }
            ),
            /* @__PURE__ */ a(
              xt,
              {
                value: se,
                initial: "Select",
                fieldName: "style",
                label: "Style",
                updateField: (G, ne, H, ce) => A(H, ce, te),
                options: g(ie)
              }
            ),
            se.includes("Circles") && /* @__PURE__ */ a(
              Ge,
              {
                className: "number-narrow",
                type: "number",
                value: R,
                fieldName: "circleSize",
                label: "circle size",
                updateField: (G, ne, H, ce) => A(H, ce, te)
              }
            ),
            se !== "Filled Circles" && /* @__PURE__ */ a(
              Ge,
              {
                value: re,
                fieldName: "label",
                label: "Label",
                placeholder: "",
                updateField: (G, ne, H, ce) => A(H, ce, te)
              }
            )
          ] })
        ] }, `preliminaryData-${te}`);
      }
    )),
    /* @__PURE__ */ a("button", { type: "button", onClick: y, className: "btn btn-primary full-width", children: e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line" })
  ] });
}, lC = ({ config: e, updateConfig: t, display: n }) => {
  var p, m, g, x;
  const r = (p = e == null ? void 0 : e.yAxis) == null ? void 0 : p.maxValue, i = ((g = (m = e == null ? void 0 : e.yAxis) == null ? void 0 : m.categories) == null ? void 0 : g.reduce((T, y) => T + (parseFloat(y.height) || 0), 0)) || 0, o = (T) => {
    let y = [];
    e.yAxis.categories && (y = [...e.yAxis.categories]), y.splice(T, 1), t({ ...e, yAxis: { ...e.yAxis, categories: y } });
  }, d = () => {
    var b, v;
    const T = (v = (b = e.yAxis) == null ? void 0 : b.categories) == null ? void 0 : v.length, y = 0.4;
    return Gi("#ddd").darken(y * T).hex();
  }, c = () => {
    const T = e.yAxis.categories ? [...e.yAxis.categories] : [], y = {
      label: "Label " + Number(T.length + 1),
      height: "",
      color: d()
    };
    T.push(y), t({ ...e, yAxis: { ...e.yAxis, categories: T } });
  }, s = (T, y, A) => {
    let b = [];
    e.yAxis.categories && (b = [...e.yAxis.categories]), b[A][T] = y, t({ ...e, yAxis: { ...e.yAxis, categories: b } });
  };
  return n ? /* @__PURE__ */ z(Ue, { children: [
    e.yAxis.type === "categorical" && ((x = e.yAxis.categories) == null ? void 0 : x.map(({ label: T, color: y, height: A }, b) => /* @__PURE__ */ z("div", { className: "edit-block", children: [
      /* @__PURE__ */ z("p", { children: [
        "Axis Category ",
        b + 1
      ] }),
      /* @__PURE__ */ a(
        "button",
        {
          type: "button",
          className: "btn btn-danger",
          onClick: (v) => {
            v.preventDefault(), o(b);
          },
          children: "Remove"
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ z("p", { children: [
              " ",
              "Category Height will be ignored for the last category. The last category will fill the rest of the axis height."
            ] }) })
          ] }),
          type: "number",
          value: A,
          fieldName: "height",
          label: "Category Height",
          updateField: (v, E, N, R) => s(N, R, b)
        }
      ),
      Number(i) > Number(r) && e.yAxis.categories.length - 1 === b && /* @__PURE__ */ a("span", { style: { color: "red", display: "block", fontSize: "15px" }, children: "Update Max value to show all categories" }),
      /* @__PURE__ */ z("div", { className: "two-col-inputs", children: [
        /* @__PURE__ */ a(
          Ge,
          {
            value: y,
            fieldName: "color",
            label: "Color",
            updateField: (v, E, N, R) => s(N, R, b)
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: T,
            fieldName: "label",
            label: "Label",
            updateField: (v, E, N, R) => s(N, R, b)
          }
        )
      ] })
    ] }, `preliminaryData-${b}`))),
    /* @__PURE__ */ a("button", { type: "button", onClick: c, className: "btn btn-primary full-width", children: "Add Axis Category" })
  ] }) : /* @__PURE__ */ a(Ue, {});
}, sC = () => {
  var fn, An, Dt, bn, sn, hn, ir, Fn, Rn, yn, $n, Hn, ar, gr, or, jn, lr, Xn, qn, S, _, D, K, pe;
  const {
    config: e,
    updateConfig: t,
    tableData: n,
    transformedData: r,
    isLoading: i,
    colorScale: o,
    colorPalettes: d,
    twoColorPalette: c,
    unfilteredData: s,
    excludedData: p,
    isDashboard: m,
    setParentConfig: g,
    missingRequiredSections: x,
    isDebug: T,
    setFilteredData: y,
    lineOptions: A,
    rawData: b,
    highlight: v,
    handleShowAll: E,
    dimensions: N
  } = de.useContext(vt), { minValue: R, maxValue: L, existPositiveValue: B, isAllLine: j } = Uc(e, s), Z = { data: r, config: e }, { leftMax: re, rightMax: X } = hg(Z), {
    visHasAnchors: se,
    visHasBrushChart: Y,
    visHasCategoricalAxis: ie,
    visHasLegend: I,
    visHasLegendAxisAlign: U,
    visHasLegendColorCategory: ue,
    visHasSelectableLegendValues: te,
    visSupportsDateCategoryAxis: J,
    visSupportsDateCategoryAxisLabel: Q,
    visSupportsDateCategoryAxisLine: G,
    visSupportsDateCategoryAxisMax: ne,
    visSupportsDateCategoryAxisMin: H,
    visSupportsDateCategoryAxisPadding: ce,
    visSupportsDateCategoryAxisTicks: ke,
    visSupportsDateCategoryHeight: Se,
    visSupportsDateCategoryNumTicks: xe,
    visSupportsDateCategoryTickRotation: De,
    visSupportsDynamicSeries: je,
    visSupportsFilters: Ce,
    visSupportsLeftValueAxis: ye,
    visSupportsPreliminaryData: Ee,
    visSupportsRankByValue: he,
    visSupportsResponsiveTicks: Be,
    visSupportsValueAxisGridLines: $e,
    visSupportsValueAxisLabels: tt,
    visSupportsValueAxisLine: We,
    visSupportsValueAxisMax: Fe,
    visSupportsValueAxisMin: Je,
    visSupportsValueAxisTicks: Ke,
    visSupportsYPadding: Ye
  } = Fs();
  de.useEffect(() => {
    let O = [];
    e.series && (O = e.series.map(($) => ({
      ...$,
      type: e.visualizationType === "Combo" ? "Bar" : e.visualizationType ? e.visualizationType : "Bar",
      axis: "Left"
    }))), t({
      ...e,
      series: O
    });
  }, [e.visualizationType]), de.useEffect(() => {
    e.visualizationType === "Scatter Plot" && t({
      ...e,
      xAxis: {
        ...e.xAxis,
        type: "continuous"
      }
    });
  }, []), de.useEffect(() => {
    e.visualizationType !== "Bar" && t({ ...e, tooltips: { ...e.tooltips, singleSeries: !1 } });
  }, [e.visualizationType]);
  const { hasRightAxis: Xe } = Th({ config: e, yMax: e.yAxis.size, data: e.data, updateConfig: t }), Ae = (O, $) => ({
    ...$
  }), Oe = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, lt = (O) => {
    O.orientation === "horizontal" && (O.labels = !1), O.table.show === void 0 && (O.table.show = !m), O.visualizationType === "Combo" && (O.orientation = "vertical"), Tn(O.xAxis) && !O.xAxis.padding && (O.xAxis.padding = 0), O.visualizationType === "Line" && (O.visualizationSubType = "regular", O.barStyle = "flat", O.isLollipopChart = !1);
  }, ve = (O, $, ee, be) => {
    if (T && console.log(
      "#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue",
      O,
      $,
      ee,
      be
    ), O === "boxplot" && ($ === "legend" || $ === "labels")) {
      t({
        ...e,
        [O]: {
          ...e[O],
          [$]: {
            ...e.boxplot[$],
            [ee]: be
          }
        }
      });
      return;
    }
    const Ie = ($t) => $t === 0 ? !0 : !!$t;
    if (O === "columns" && Ie($) && Ie(ee)) {
      t({
        ...e,
        columns: {
          ...e.columns,
          [$]: {
            ...e.columns[$],
            [ee]: be
          }
        }
      });
      return;
    }
    if (O === null && $ === null) {
      Ie(ee) || console.error("fieldName is required");
      let $t = { ...e, [ee]: be };
      lt($t), t($t);
      return;
    }
    const Qe = Array.isArray(e[O]);
    let pt = Qe ? [...e[O], be] : { ...e[O], [ee]: be };
    Ie($) && (Qe ? (pt = [...e[O]], pt[$] = { ...pt[$], [ee]: be }) : typeof be == "string" ? pt[$] = be : Ie(ee) && (pt = { ...e[O], [$]: { ...e[O][$], [ee]: be } }));
    let Ut = { ...e, [O]: pt };
    lt(Ut), t(Ut);
  }, [mt, ut] = de.useState(!0), [st, Lt] = de.useState(!1);
  if (i)
    return null;
  const Kt = (O) => {
    t({
      ...e,
      lollipopShape: O
    });
  }, Xt = (O) => {
    let $ = e.series ? [...e.series] : [], ee = Array.from(new Set(r.map((Ie) => Ie[O]))), be = [];
    ee.forEach((Ie) => {
      be.push({ key: Ie });
    }), e.visualizationType === "Forecasting" ? $.push({
      dataKey: O,
      type: e.visualizationType,
      stages: be,
      stageColumn: O,
      axis: "Left",
      tooltip: !0
    }) : $.push({ dataKey: O, type: e.visualizationType, axis: "Left", tooltip: !0 }), t({ ...e, series: $ });
  }, It = (O) => {
    let $ = [...e.exclusions.keys];
    $.push(O);
    let ee = { ...e.exclusions, keys: $ };
    t({ ...e, exclusions: ee });
  }, ln = (O) => {
    let $ = -1, ee = [...e.exclusions.keys];
    for (let be = 0; be < ee.length; be++)
      if (ee[be] === O) {
        $ = be;
        break;
      }
    if ($ !== -1) {
      ee.splice($, 1);
      let be = { ...e.exclusions, keys: ee }, Ie = { ...e, exclusions: be };
      ee.length === 0 && delete Ie.exclusions.keys, t(Ie);
    }
  }, Tt = (O = !0) => {
    let $ = {};
    if (s.forEach((ee) => {
      Object.keys(ee).forEach((be) => $[be] = !0);
    }), O) {
      const { lower: ee, upper: be } = e.confidenceKeys || {};
      Object.keys($).forEach((Ie) => {
        (e.series && e.series.filter((Qe) => Qe.dataKey === Ie).length > 0 || e.confidenceKeys && Object.keys(e.confidenceKeys).includes(Ie) && (ee && be || ee || be) && Ie !== ee && Ie !== be) && delete $[Ie];
      });
    }
    return Object.keys($);
  }, Ot = (O) => {
    const $ = [];
    switch (O) {
      case "style":
        $.push("circles", "boxes"), e.visualizationType === "Bar" && (!["right", "left"].includes(e.legend.position) || !e.legend.position) && $.push("gradient"), e.visualizationType === "Line" && $.push("lines");
        break;
      case "subStyle":
        e.visualizationType === "Bar" ? $.push("linear blocks") : $.push("linear blocks", "smooth");
        break;
    }
    return $;
  }, _t = (O) => {
    if (!O)
      return [];
    const $ = /* @__PURE__ */ new Set();
    for (let ee = 0; ee < O.length; ee++)
      for (const [be] of Object.entries(O[ee]))
        $.add(be);
    return Array.from($);
  }, an = (O, $ = !1) => {
    let ee = [];
    return p.forEach((be) => {
      ee.push(be[O]);
    }), $ ? [...new Set(ee)] : ee;
  }, dn = () => {
    ut(!mt), t({
      ...e,
      showEditorPanel: !mt
    });
  }, zt = () => {
    let O = JSON.parse(JSON.stringify(e));
    return x(e) === !1 && delete O.newViz, delete O.runtime, O;
  };
  de.useEffect(() => {
    if (g) {
      const O = zt();
      g(O);
    }
  }, [e]), de.useEffect(() => {
    const O = e.xAxis.anchors.length > 0 ? e.xAxis.anchors : [], $ = e.yAxis.anchors.length > 0 ? e.yAxis.anchors : [];
    t({
      ...e,
      xAxis: {
        ...e.xAxis,
        anchors: $
      },
      yAxis: {
        ...e.yAxis,
        anchors: O
      }
    });
  }, [e.orientation]), de.useEffect(() => {
    e.visualizationType === "Paired Bar" && t({
      ...e,
      orientation: "horizontal"
    });
  }, []), de.useEffect(() => {
    e.orientation === "horizontal" && t({
      ...e,
      lollipopShape: e.lollipopShape
    });
  }, [e.isLollipopChart, e.lollipopShape]), de.useEffect(() => {
    e.visualizationType === "Deviation Bar" && t({ ...e, orientation: "horizontal" });
  }, [e.visualizationType]);
  const Bt = de.useCallback(() => {
    const O = [...e.exclusions.keys];
    return /* @__PURE__ */ a("ul", { className: "series-list", children: O.map(($, ee) => /* @__PURE__ */ z("li", { children: [
      /* @__PURE__ */ a("div", { className: "series-list__name", "data-title": $, children: /* @__PURE__ */ a("div", { className: "series-list__name--text", children: $ }) }),
      /* @__PURE__ */ a("button", { className: "series-list__remove", onClick: () => ln($), children: "×" })
    ] }, $)) });
  }, [e]), on = (O, $) => {
    let ee = e.series, [be] = ee.splice(O, 1);
    ee.splice($, 0, be), t({ ...e, series: ee });
  };
  e.isLollipopChart && ((fn = e == null ? void 0 : e.series) == null ? void 0 : fn.length) > 1 && (e.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), e.visualizationType === "Paired Bar" && ((An = e == null ? void 0 : e.series) == null ? void 0 : An.length) !== 2 && (e.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), e.visualizationType === "Deviation Bar" && ((Dt = e == null ? void 0 : e.series) == null ? void 0 : Dt.length) !== 1 && (e.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), e.isLollipopChart && ((bn = e == null ? void 0 : e.series) == null ? void 0 : bn.length) === 0 && (e.runtime.editorErrorMessage = "Add a data series");
  const rt = e.orientation === "horizontal" ? "xAxis" : "yAxis", [ht, Pe] = de.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), _e = () => {
    const O = e[rt].max, $ = e[rt].rightMax;
    let ee = "", be = "";
    if (e.visualizationType !== "Combo")
      switch (!0) {
        case (O && parseFloat(O) < parseFloat(L) && B):
          ee = "Max value must be more than " + L;
          break;
        case (O && parseFloat(O) < 0 && !B):
          ee = "Value must be more than or equal to 0";
          break;
        default:
          ee = "";
      }
    if (e.visualizationType === "Combo")
      switch (!0) {
        case (O && parseFloat(O) < re):
          ee = "Max value must be more than " + re;
          break;
        case ($ && parseFloat($) < X):
          be = "Max value must be more than " + X;
          break;
        case (O && parseFloat(O) < 0 && !B):
          ee = "Value must be more than or equal to 0";
          break;
        default:
          ee = "";
      }
    Pe((Ie) => ({ ...Ie, maxMsg: ee, rightMaxMessage: be }));
  }, we = () => {
    const O = parseFloat(e[rt].min);
    let $ = Number(R), ee = "";
    switch (!0) {
      case (e.useLogScale && ["Line", "Combo", "Bar"].includes(e.visualizationType) && O < 0):
        ee = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((e.visualizationType === "Line" || e.visualizationType === "Spark Line") && O > $):
        ee = "Value should not exceed " + R;
        break;
      case (e.visualizationType === "Combo" && j && O > $):
        ee = "Value should not exceed " + R;
        break;
      case ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && !j) && $ > 0 && O > 0):
        ee = e.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (e.visualizationType === "Deviation Bar" && O >= Math.min($, e.xAxis.target)):
        ee = "Value must be less than " + Math.min($, e.xAxis.target);
        break;
      case (e.visualizationType !== "Deviation Bar" && O && $ < 0 && O > $):
        ee = "Value should not exceed " + R;
        break;
      default:
        ee = "";
    }
    Pe((be) => ({ ...be, minMsg: ee }));
  };
  de.useEffect(() => {
    we(), _e();
  }, [R, L, e]);
  const yt = ((sn = e == null ? void 0 : e.dataKey) == null ? void 0 : sn.includes("http://")) || ((hn = e == null ? void 0 : e.dataKey) == null ? void 0 : hn.includes("https://")), at = () => {
    var O, $;
    if (T !== void 0 && T && !((O = e == null ? void 0 : e.xAxis) != null && O.dataKey)) {
      let ee = Tt(!1);
      if (ee.includes("Date"))
        return "Date";
      if (ee.includes("Race"))
        return "Race";
      if (ee.includes("Month"))
        return "Month";
    }
    return (($ = e == null ? void 0 : e.xAxis) == null ? void 0 : $.dataKey) || "";
  }, bt = () => {
    if (T !== void 0 && T && Tt(!1).length > 0) {
      let O = Tt(!1).filter(($) => $ !== at());
      if (O.length > 0)
        return O[0];
    }
    return "";
  };
  if (T && !e.xAxis.dataKey && (e.xAxis.dataKey = at()), T && ((ir = e == null ? void 0 : e.series) == null ? void 0 : ir.length) === 0) {
    let O = bt();
    O !== "" && Xt(O), T && console.log("### COVE DEBUG: Chart: Setting default datacol=", O);
  }
  const wt = [
    "Bump Chart",
    "Area Chart",
    "Combo",
    "Line",
    "Bar",
    "Forecasting",
    "Scatter Plot",
    "Paired Bar",
    "Deviation Bar"
  ], qt = [
    /* @__PURE__ */ a("option", { value: "", children: "- Select Option -" }, "Select Option")
  ];
  if (e.data && e.series) {
    Object.keys(((Fn = e.data) == null ? void 0 : Fn[0]) || []).map(($) => {
      const ee = e == null ? void 0 : e.series.some((be) => be.dataKey === $);
      if ($ !== e.xAxis.dataKey && !ee)
        return qt.push(
          /* @__PURE__ */ a("option", { value: $, children: $ }, $)
        );
    });
    let O = {};
    e.data.forEach(($) => {
      Object.keys($).forEach((ee) => {
        O[ee] = O[ee] || [];
        const be = typeof $[ee] == "number" ? $[ee].toString() : $[ee];
        O[ee].indexOf(be) === -1 && O[ee].push(be);
      });
    });
  }
  if (!e.data && r) {
    if (!r[0])
      return;
    Object.keys(r[0]).map(($) => {
      const ee = r.some((be) => be.dataKey === $);
      if ($ !== e.xAxis.dataKey && !ee)
        return qt.push(
          /* @__PURE__ */ a("option", { value: $, children: $ }, $)
        );
    });
    let O = {};
    r.forEach(($) => {
      Object.keys($).forEach((ee) => {
        O[ee] = O[ee] || [];
        const be = typeof $[ee] == "number" ? $[ee].toString() : $[ee];
        O[ee].indexOf(be) === -1 && O[ee].push(be);
      });
    });
  }
  const ct = (O) => {
    const $ = nt.cloneDeep(e.columns);
    delete $[O], t({
      ...e,
      columns: $
    });
  }, dt = async (O, $, ee) => {
    switch ($) {
      case "name":
        t({
          ...e,
          columns: {
            ...e.columns,
            [O]: {
              ...e.columns[O],
              [$]: ee
            }
          }
        });
        break;
      default:
        t({
          ...e,
          columns: {
            ...e.columns,
            [O]: {
              ...e.columns[O],
              [$]: ee
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: Wt,
    highlightedSeriesValues: Yt,
    handleUpdateHighlightedBar: Rt,
    handleAddNewHighlightedBar: Ct,
    handleRemoveHighlightedBar: xn,
    handleUpdateHighlightedBarColor: Sn,
    handleHighlightedBarLegendLabel: Ln,
    handleUpdateHighlightedBorderWidth: On
  } = jc(e, t), En = e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1, rr = () => {
    const O = r.map(($) => $[e.legend.colorCode]);
    return En ? O : Tt(!1).filter(($) => $ !== e.xAxis.dataKey);
  }, Mn = (O) => {
    t({ ...e, legend: { ...e.legend, seriesHighlight: O } });
  }, wn = (O, $, ee) => {
    var Qe;
    const be = { ...e[O], [$]: ee }, Ie = { ...e, [O]: be };
    ee === "highlight" && ((Qe = e.legend.seriesHighlight) != null && Qe.length) && (Ie.legend.seriesHighlight.length = 0), t(Ie);
  }, Pt = (O, $, ee) => {
    const be = { ...e.xAxis[O] };
    be[$] = ee;
    const Ie = { ...e, xAxis: { ...e.xAxis, [O]: be } };
    t(Ie);
  }, jt = ![void 0, "- Select - "].includes((yn = (Rn = e.series) == null ? void 0 : Rn[0]) == null ? void 0 : yn.dynamicCategory), kn = (($n = e.series) == null ? void 0 : $n.length) > 1, tn = {
    addNewExclusion: It,
    data: r,
    editColumn: dt,
    getColumns: Tt,
    getDataValueOptions: _t,
    getDataValues: an,
    getItemStyle: Ae,
    handleSeriesChange: on,
    handleAddNewHighlightedBar: Ct,
    setCategoryAxis: at,
    updateField: ve,
    warningMsg: ht,
    highlightedBarValues: Wt,
    handleHighlightedBarLegendLabel: Ln,
    handleUpdateHighlightedBar: Rt,
    handleRemoveHighlightedBar: xn,
    isPaletteReversed: e.isPaletteReversed,
    highlightedSeriesValues: Yt,
    handleUpdateHighlightedBorderWidth: On,
    handleUpdateHighlightedBarColor: Sn,
    setLollipopShape: Kt
  };
  return /* @__PURE__ */ a(Eh.Provider, { value: tn, children: /* @__PURE__ */ a(Ur, { component: "EditorPanel", children: /* @__PURE__ */ z(
    gf.Sidebar,
    {
      displayPanel: mt,
      isDashboard: m,
      title: "Configure Chart",
      onBackClick: dn,
      children: [
        /* @__PURE__ */ z(Ba, { allowZeroExpanded: !0, children: [
          /* @__PURE__ */ a(bi.General, { name: "General" }),
          /* @__PURE__ */ a(bi.ForestPlot, { name: "Forest Plot Settings" }),
          /* @__PURE__ */ a(bi.Sankey, { name: "Sankey" }),
          e.visualizationType !== "Pie" && e.visualizationType !== "Forest Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ z(Nn, { children: [
            /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ z(Dn, { children: [
              "Data Series",
              " ",
              (!e.series || e.series.length === 0 || e.visualizationType === "Paired Bar" && e.series.length < 2) && !e.dynamicSeries && /* @__PURE__ */ a(qu, { width: "25", className: "warning-icon" })
            ] }) }),
            /* @__PURE__ */ z(_n, { children: [
              e.dynamicSeries && e.visualizationType === "Line" && /* @__PURE__ */ a(
                xt,
                {
                  fieldName: "dynamicSeriesType",
                  value: e.dynamicSeriesType,
                  label: "Series Type",
                  initial: "Select",
                  updateField: ve,
                  options: ["Line", "dashed-sm", "dashed-md", "dashed-lg"]
                }
              ),
              e.dynamicSeries && e.visualizationType === "Line" && e.dynamicSeriesType === "Line" && /* @__PURE__ */ a(
                xt,
                {
                  fieldName: "dynamicSeriesLineType",
                  value: e.dynamicSeriesLineType ? e.dynamicSeriesLineType : "curveLinear",
                  label: "Line Type",
                  initial: "Select",
                  updateField: ve,
                  options: Object.keys(ul).map((O) => ul[O])
                }
              ),
              (!je() || !e.dynamicSeries) && /* @__PURE__ */ z(Ue, { children: [
                (!e.series || e.series.length === 0) && !e.dynamicSeries && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a("p", { className: "warning", children: "At least one series is required" }),
                (!e.series || e.series.length === 0 || e.series.length < 2) && e.visualizationType === "Paired Bar" && /* @__PURE__ */ a("p", { className: "warning", children: "Select two data series for paired bar chart (e.g., Male and Female)." }),
                /* @__PURE__ */ z(Ue, { children: [
                  /* @__PURE__ */ a(
                    xt,
                    {
                      fieldName: "visualizationType",
                      label: "Add Data Series",
                      initial: "Select",
                      onChange: (O) => {
                        O.target.value !== "" && O.target.value !== "Select" && Xt(O.target.value), O.target.value = "";
                      },
                      options: Tt()
                    }
                  ),
                  e.series && e.series.length !== 0 && /* @__PURE__ */ z(bi.Series.Wrapper, { getColumns: Tt, children: [
                    /* @__PURE__ */ z("fieldset", { children: [
                      /* @__PURE__ */ a("legend", { className: "edit-label float-left", children: "Displaying" }),
                      /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "A data series is a set of related data points plotted in a chart and typically represented in the chart legend." }) })
                      ] })
                    ] }),
                    /* @__PURE__ */ a(
                      Vg,
                      {
                        onDragEnd: ({ source: O, destination: $ }) => on(O.index, $.index),
                        children: /* @__PURE__ */ a(Wg, { droppableId: "filter_order", children: (O) => /* @__PURE__ */ z("ul", { ...O.droppableProps, className: "series-list", ref: O.innerRef, children: [
                          /* @__PURE__ */ a(
                            bi.Series.List,
                            {
                              series: e.series,
                              getItemStyle: Ae,
                              sortableItemStyles: Oe,
                              chartsWithOptions: wt
                            }
                          ),
                          O.placeholder
                        ] }) })
                      }
                    )
                  ] })
                ] }),
                (e.series && e.series.length && e.visualizationType === "Bar" || e.series && e.series.length <= 1 && e.visualizationType === "Line") && /* @__PURE__ */ z(Ue, { children: [
                  /* @__PURE__ */ a("span", { className: "divider-heading", children: "Confidence Keys" }),
                  /* @__PURE__ */ a(
                    xt,
                    {
                      value: e.confidenceKeys.upper || "",
                      section: "confidenceKeys",
                      fieldName: "upper",
                      label: "Upper",
                      updateField: ve,
                      initial: "Select",
                      options: Tt()
                    }
                  ),
                  /* @__PURE__ */ a(
                    xt,
                    {
                      value: e.confidenceKeys.lower || "",
                      section: "confidenceKeys",
                      fieldName: "lower",
                      label: "Lower",
                      updateField: ve,
                      initial: "Select",
                      options: Tt()
                    }
                  )
                ] }),
                he() && e.series && e.series.length === 1 && /* @__PURE__ */ a(
                  xt,
                  {
                    value: e.rankByValue,
                    fieldName: "rankByValue",
                    label: "Rank by Value",
                    initial: "Select",
                    updateField: (O, $, ee, be) => {
                      const [Ie, Qe] = aC(e, be, r);
                      t(Ie, Qe);
                    },
                    options: ["asc", "desc"]
                  }
                ),
                Ee() && /* @__PURE__ */ a(oC, { config: e, updateConfig: t, data: r })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ a(bi.BoxPlot, { name: "Measures" }),
          ye() && /* @__PURE__ */ z(Nn, { children: [
            /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ z(Dn, { children: [
              e.visualizationType === "Pie" ? "Data Format" : e.orientation === "vertical" ? "Left Value Axis" : "Value Axis",
              e.visualizationType === "Pie" && !e.yAxis.dataKey && /* @__PURE__ */ a(qu, { width: "25", className: "warning-icon" })
            ] }) }),
            /* @__PURE__ */ z(_n, { children: [
              e.visualizationType === "Pie" && /* @__PURE__ */ a(
                xt,
                {
                  value: e.yAxis.dataKey || "",
                  section: "yAxis",
                  fieldName: "dataKey",
                  label: "Data Column",
                  initial: "Select",
                  required: !0,
                  updateField: ve,
                  options: Tt(!1),
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Select the source data to be visually represented." }) })
                  ] })
                }
              ),
              e.visualizationType !== "Pie" && /* @__PURE__ */ z(Ue, { children: [
                /* @__PURE__ */ z("label", { children: [
                  /* @__PURE__ */ z("span", { className: "edit-label", children: [
                    "Axis Type",
                    /* @__PURE__ */ z(oe, { style: { textTransform: "none", display: "inline-block" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(oe.Content, { children: "Select 'Numeric (Linear Scale)' for uniform scaling, 'Numeric (Logarithmic Scale)' for exponential data, or 'Categorical' for discrete categories." })
                    ] })
                  ] }),
                  /* @__PURE__ */ z(
                    "select",
                    {
                      value: e.yAxis.type,
                      onChange: (O) => t({
                        ...e,
                        yAxis: {
                          ...e.yAxis,
                          type: O.target.value
                        }
                      }),
                      children: [
                        /* @__PURE__ */ a("option", { value: "linear", children: "Numeric (Linear Scale)" }),
                        e.visualizationSubType !== "stacked" && /* @__PURE__ */ a("option", { value: "logarithmic", children: "Numeric (Logarithmic Scale)" }),
                        e.orientation !== "horizontal" && /* @__PURE__ */ a("option", { value: "categorical", children: "Categorical" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ a(
                  lC,
                  {
                    config: e,
                    updateConfig: t,
                    data: r,
                    display: ie()
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    display: !ie(),
                    value: e.yAxis.label,
                    section: "yAxis",
                    fieldName: "label",
                    label: "Label",
                    updateField: ve,
                    maxLength: 35,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "35 character limit" }) })
                    ] })
                  }
                ),
                e.runtime.seriesKeys && e.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(e.visualizationType) && /* @__PURE__ */ a(
                  et,
                  {
                    value: e.isLegendValue,
                    fieldName: "isLegendValue",
                    label: "Use Legend Value in Hover",
                    updateField: ve
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    display: !ie(),
                    value: e.yAxis.numTicks,
                    placeholder: "Auto",
                    type: "number",
                    section: "yAxis",
                    fieldName: "numTicks",
                    label: "Number of ticks",
                    className: "number-narrow",
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                        Ze,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used." }) })
                    ] }),
                    updateField: ve
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.yAxis.size,
                    type: "number",
                    section: "yAxis",
                    fieldName: "size",
                    label: e.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
                    className: "number-narrow",
                    updateField: ve,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                        Ze,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: `Increase the size if elements in the ${e.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.` }) })
                    ] })
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    display: !ie(),
                    value: e.yAxis.labelOffset,
                    section: "yAxis",
                    fieldName: "labelOffset",
                    label: "Label offset",
                    type: "number",
                    className: "number-narrow",
                    updateField: ve
                  }
                ),
                e.orientation === "horizontal" && /* @__PURE__ */ a(
                  et,
                  {
                    value: e.isResponsiveTicks,
                    fieldName: "isResponsiveTicks",
                    label: "Use Responsive Ticks",
                    updateField: ve
                  }
                ),
                (e.orientation === "vertical" || !e.isResponsiveTicks) && /* @__PURE__ */ a(
                  Ge,
                  {
                    display: !ie(),
                    value: e.yAxis.tickRotation || 0,
                    type: "number",
                    min: 0,
                    section: "yAxis",
                    fieldName: "tickRotation",
                    label: "Tick rotation (Degrees)",
                    className: "number-narrow",
                    updateField: ve
                  }
                ),
                e.isResponsiveTicks && e.orientation === "horizontal" && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.xAxis.maxTickRotation,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "maxTickRotation",
                    label: "Max Tick Rotation",
                    className: "number-narrow",
                    updateField: ve,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                        Ze,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Degrees ticks will be rotated if values overlap, especially in smaller viewports." }) })
                    ] })
                  }
                ),
                $e() && /* @__PURE__ */ a(
                  et,
                  {
                    value: e.yAxis.gridLines,
                    section: "yAxis",
                    fieldName: "gridLines",
                    label: "Show Gridlines",
                    updateField: ve
                  }
                ),
                $e() && /* @__PURE__ */ a(
                  et,
                  {
                    value: e.yAxis.labelsAboveGridlines,
                    section: "yAxis",
                    fieldName: "labelsAboveGridlines",
                    label: "Tick labels above gridlines",
                    updateField: ve,
                    disabled: !e.yAxis.gridLines,
                    title: e.yAxis.gridLines ? "" : "Show gridlines to enable"
                  }
                ),
                Ye() && /* @__PURE__ */ a(
                  et,
                  {
                    value: e.yAxis.enablePadding,
                    section: "yAxis",
                    fieldName: "enablePadding",
                    label: "Add Padding to Value Axis Scale",
                    updateField: ve
                  }
                ),
                e.yAxis.enablePadding && Ye() && /* @__PURE__ */ a(
                  Ge,
                  {
                    type: "number",
                    section: "yAxis",
                    fieldName: "scalePadding",
                    label: "Padding Percentage",
                    className: "number-narrow",
                    updateField: ve,
                    value: e.yAxis.scalePadding
                  }
                )
              ] }),
              /* @__PURE__ */ a("span", { className: "divider-heading", children: "Number Formatting" }),
              /* @__PURE__ */ a(
                et,
                {
                  value: e.dataFormat.commas,
                  section: "dataFormat",
                  fieldName: "commas",
                  label: "Add commas",
                  updateField: ve,
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                      Ze,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting this option will add commas to the left value axis, tooltip hover, and data table." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  display: !ie(),
                  value: e.dataFormat.abbreviated,
                  section: "dataFormat",
                  fieldName: "abbreviated",
                  label: "Abbreviate Axis Values",
                  updateField: ve,
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                      Ze,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "This option abbreviates very large or very small numbers on the value axis" }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: e.dataFormat.roundTo ? e.dataFormat.roundTo : 0,
                  type: "number",
                  section: "dataFormat",
                  fieldName: "roundTo",
                  label: "Round to decimal point",
                  className: "number-narrow",
                  updateField: ve,
                  min: 0
                }
              ),
              " ",
              /* @__PURE__ */ z("div", { className: "two-col-inputs", children: [
                /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.dataFormat.prefix,
                    section: "dataFormat",
                    fieldName: "prefix",
                    label: "Prefix",
                    updateField: ve,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ z(oe.Content, { children: [
                        e.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data prefix to display in the data table and chart tooltips, if applicable." }),
                        e.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data prefix (such as "$"), if applicable.' })
                      ] })
                    ] })
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.dataFormat.suffix,
                    section: "dataFormat",
                    fieldName: "suffix",
                    label: "Suffix",
                    updateField: ve,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ z(oe.Content, { children: [
                        e.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data suffix to display in the data table and tooltips, if applicable." }),
                        e.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data suffix (such as "%"), if applicable.' })
                      ] })
                    ] })
                  }
                )
              ] }),
              e.orientation === "horizontal" ? (
                // horizontal - x is vertical y is horizontal
                /* @__PURE__ */ z(Ue, { children: [
                  We() && /* @__PURE__ */ a(
                    et,
                    {
                      value: e.xAxis.hideAxis,
                      section: "xAxis",
                      fieldName: "hideAxis",
                      label: "Hide Axis",
                      updateField: ve
                    }
                  ),
                  tt() && /* @__PURE__ */ a(
                    et,
                    {
                      value: e.xAxis.hideLabel,
                      section: "xAxis",
                      fieldName: "hideLabel",
                      label: "Hide Tick Labels",
                      updateField: ve
                    }
                  ),
                  Ke() && /* @__PURE__ */ a(
                    et,
                    {
                      value: e.xAxis.hideTicks,
                      section: "xAxis",
                      fieldName: "hideTicks",
                      label: "Hide Ticks",
                      updateField: ve
                    }
                  ),
                  Fe() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: e.xAxis.max,
                      section: "xAxis",
                      fieldName: "max",
                      label: "max value",
                      type: "number",
                      placeholder: "Auto",
                      updateField: ve
                    }
                  ),
                  /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: ht.maxMsg }),
                  Je() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: e.xAxis.min,
                      section: "xAxis",
                      fieldName: "min",
                      type: "number",
                      label: "min value",
                      placeholder: "Auto",
                      updateField: ve
                    }
                  ),
                  /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: ht.minMsg }),
                  e.visualizationType === "Deviation Bar" && /* @__PURE__ */ z(Ue, { children: [
                    /* @__PURE__ */ a(
                      Ge,
                      {
                        value: e.xAxis.target,
                        section: "xAxis",
                        fieldName: "target",
                        type: "number",
                        label: "Deviation point",
                        placeholder: "Auto",
                        updateField: ve
                      }
                    ),
                    /* @__PURE__ */ a(
                      Ge,
                      {
                        value: e.xAxis.targetLabel || "Target",
                        section: "xAxis",
                        fieldName: "targetLabel",
                        type: "text",
                        label: "Deviation point Label",
                        updateField: ve
                      }
                    ),
                    /* @__PURE__ */ a(
                      et,
                      {
                        value: e.xAxis.showTargetLabel,
                        section: "xAxis",
                        fieldName: "showTargetLabel",
                        label: "Show Deviation point label",
                        updateField: ve
                      }
                    )
                  ] })
                ] })
              ) : e.visualizationType !== "Pie" && /* @__PURE__ */ z(Ue, { children: [
                /* @__PURE__ */ a(
                  et,
                  {
                    display: !ie(),
                    value: e.dataFormat.onlyShowTopPrefixSuffix,
                    section: "dataFormat",
                    fieldName: "onlyShowTopPrefixSuffix",
                    label: "Only Show Top Prefix/Suffix",
                    updateField: ve
                  }
                ),
                /* @__PURE__ */ a(
                  et,
                  {
                    display: !ie(),
                    value: e.yAxis.hideAxis,
                    section: "yAxis",
                    fieldName: "hideAxis",
                    label: "Hide Axis",
                    updateField: ve
                  }
                ),
                /* @__PURE__ */ a(
                  et,
                  {
                    display: !ie(),
                    value: e.yAxis.hideLabel,
                    section: "yAxis",
                    fieldName: "hideLabel",
                    label: "Hide Tick Labels",
                    updateField: ve
                  }
                ),
                /* @__PURE__ */ a(
                  et,
                  {
                    display: !ie(),
                    value: e.yAxis.hideTicks,
                    section: "yAxis",
                    fieldName: "hideTicks",
                    label: "Hide Ticks",
                    updateField: ve
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.yAxis.max,
                    section: "yAxis",
                    fieldName: "max",
                    type: "number",
                    label: "left axis max value",
                    placeholder: "Auto",
                    updateField: ve
                  }
                ),
                /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: ht.maxMsg }),
                e.visualizationType !== "Area Chart" && e.visualizationSubType !== "stacked" && /* @__PURE__ */ z(Ue, { children: [
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      value: e.yAxis.min,
                      section: "yAxis",
                      fieldName: "min",
                      type: "number",
                      label: "left axis min value",
                      placeholder: "Auto",
                      updateField: ve
                    }
                  ),
                  /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: ht.minMsg })
                ] })
              ] }),
              se() && e.orientation !== "horizontal" && /* @__PURE__ */ z("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(Ba, { allowZeroExpanded: !0, children: (ar = (Hn = e.yAxis) == null ? void 0 : Hn.anchors) == null ? void 0 : ar.map((O, $) => /* @__PURE__ */ z(Nn, { className: "series-item series-item--chart", children: [
                  /* @__PURE__ */ a(Pn, { className: "series-item__title", children: /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z(Dn, { className: "accordion__button accordion__button", children: [
                    "Anchor ",
                    $ + 1,
                    /* @__PURE__ */ a(
                      "button",
                      {
                        className: "series-list__remove",
                        onClick: (ee) => {
                          ee.preventDefault();
                          const be = [...e.yAxis.anchors];
                          be.splice($, 1), t({
                            ...e,
                            yAxis: {
                              ...e.yAxis,
                              anchors: be
                            }
                          });
                        },
                        children: "Remove"
                      }
                    )
                  ] }) }) }),
                  /* @__PURE__ */ z(_n, { children: [
                    /* @__PURE__ */ z("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                      /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                      ] }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.yAxis.anchors[$].value ? e.yAxis.anchors[$].value : "",
                          onChange: (ee) => {
                            ee.preventDefault();
                            const be = [...e.yAxis.anchors];
                            be[$].value = ee.target.value, t({
                              ...e,
                              yAxis: {
                                ...e.yAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ z("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.yAxis.anchors[$].color ? e.yAxis.anchors[$].color : "",
                          onChange: (ee) => {
                            ee.preventDefault();
                            const be = [...e.yAxis.anchors];
                            be[$].color = ee.target.value, t({
                              ...e,
                              yAxis: {
                                ...e.yAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ z("label", { children: [
                      "Anchor Line Style",
                      /* @__PURE__ */ z(
                        "select",
                        {
                          value: e.yAxis.anchors[$].lineStyle || "",
                          onChange: (ee) => {
                            const be = [...e.yAxis.anchors];
                            be[$].lineStyle = ee.target.value, t({
                              ...e,
                              yAxis: {
                                ...e.yAxis,
                                anchors: be
                              }
                            });
                          },
                          children: [
                            /* @__PURE__ */ a("option", { children: "Select" }),
                            A.map((ee) => /* @__PURE__ */ a("option", { children: ee.value }, ee.key))
                          ]
                        }
                      )
                    ] })
                  ] })
                ] }, `yaxis-anchors-2-${$}`)) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (O) => {
                      O.preventDefault();
                      const $ = [...e.yAxis.anchors];
                      $.push({}), t({
                        ...e,
                        yAxis: {
                          ...e.yAxis,
                          anchors: $
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] }),
              se() && e.orientation === "horizontal" && /* @__PURE__ */ z("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(Ba, { allowZeroExpanded: !0, children: (or = (gr = e.xAxis) == null ? void 0 : gr.anchors) == null ? void 0 : or.map((O, $) => /* @__PURE__ */ z(Nn, { className: "series-item series-item--chart", children: [
                  /* @__PURE__ */ a(Pn, { className: "series-item__title", children: /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z(Dn, { className: "accordion__button accordion__button", children: [
                    "Anchor ",
                    $ + 1,
                    /* @__PURE__ */ a(
                      "button",
                      {
                        className: "series-list__remove",
                        onClick: (ee) => {
                          ee.preventDefault();
                          const be = [...e.xAxis.anchors];
                          be.splice($, 1), t({
                            ...e,
                            xAxis: {
                              ...e.xAxis,
                              anchors: be
                            }
                          });
                        },
                        children: "Remove"
                      }
                    )
                  ] }) }) }),
                  /* @__PURE__ */ z(_n, { children: [
                    /* @__PURE__ */ z("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                      /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                      ] }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.xAxis.anchors[$].value ? e.xAxis.anchors[$].value : "",
                          onChange: (ee) => {
                            ee.preventDefault();
                            const be = [...e.xAxis.anchors];
                            be[$].value = ee.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ z("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.xAxis.anchors[$].color ? e.xAxis.anchors[$].color : "",
                          onChange: (ee) => {
                            ee.preventDefault();
                            const be = [...e.xAxis.anchors];
                            be[$].color = ee.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ z("label", { children: [
                      "Anchor Line Style",
                      /* @__PURE__ */ z(
                        "select",
                        {
                          value: e.xAxis.anchors[$].lineStyle || "",
                          onChange: (ee) => {
                            const be = [...e.xAxis.anchors];
                            be[$].lineStyle = ee.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          },
                          children: [
                            /* @__PURE__ */ a("option", { children: "Select" }),
                            A.map((ee) => /* @__PURE__ */ a("option", { children: ee.value }, ee.key))
                          ]
                        }
                      )
                    ] })
                  ] })
                ] }, `xaxis-anchors-${$}`)) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (O) => {
                      O.preventDefault();
                      const $ = [...e.xAxis.anchors];
                      $.push({}), t({
                        ...e,
                        xAxis: {
                          ...e.xAxis,
                          anchors: $
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] })
            ] })
          ] }),
          Xe && /* @__PURE__ */ z(Nn, { children: [
            /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ a(Dn, { children: "Right Value Axis" }) }),
            /* @__PURE__ */ z(_n, { children: [
              /* @__PURE__ */ a(
                Ge,
                {
                  value: e.yAxis.rightLabel,
                  section: "yAxis",
                  fieldName: "rightLabel",
                  label: "Label",
                  updateField: ve,
                  maxLength: 35,
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "35 character limit" }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: e.yAxis.rightNumTicks,
                  placeholder: "Auto",
                  type: "number",
                  section: "yAxis",
                  fieldName: "rightNumTicks",
                  label: "Number of ticks",
                  className: "number-narrow",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: e.yAxis.rightAxisSize,
                  type: "number",
                  section: "yAxis",
                  fieldName: "rightAxisSize",
                  label: "Size (Width)",
                  className: "number-narrow",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: e.yAxis.rightLabelOffsetSize,
                  type: "number",
                  section: "yAxis",
                  fieldName: "rightLabelOffsetSize",
                  label: "Label Offset",
                  className: "number-narrow",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a("span", { className: "divider-heading", children: "Number Formatting" }),
              /* @__PURE__ */ a(
                et,
                {
                  value: e.dataFormat.rightCommas,
                  section: "dataFormat",
                  fieldName: "rightCommas",
                  label: "Add commas",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: e.dataFormat.rightRoundTo,
                  type: "number",
                  section: "dataFormat",
                  fieldName: "rightRoundTo",
                  label: "Round to decimal point",
                  className: "number-narrow",
                  updateField: ve,
                  min: 0
                }
              ),
              /* @__PURE__ */ z("div", { className: "two-col-inputs", children: [
                /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.dataFormat.rightPrefix,
                    section: "dataFormat",
                    fieldName: "rightPrefix",
                    label: "Prefix",
                    updateField: ve,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ z(oe.Content, { children: [
                        e.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data prefix to display in the data table and chart tooltips, if applicable." }),
                        e.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data prefix (such as "$"), if applicable.' })
                      ] })
                    ] })
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.dataFormat.rightSuffix,
                    section: "dataFormat",
                    fieldName: "rightSuffix",
                    label: "Suffix",
                    updateField: ve,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ z(oe.Content, { children: [
                        e.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data suffix to display in the data table and tooltips, if applicable." }),
                        e.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data suffix (such as "%"), if applicable.' })
                      ] })
                    ] })
                  }
                )
              ] }),
              /* @__PURE__ */ a(
                et,
                {
                  value: e.yAxis.rightHideAxis,
                  section: "yAxis",
                  fieldName: "rightHideAxis",
                  label: "Hide Axis",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  value: e.yAxis.rightHideLabel,
                  section: "yAxis",
                  fieldName: "rightHideLabel",
                  label: "Hide Tick Labels",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  value: e.yAxis.rightHideTicks,
                  section: "yAxis",
                  fieldName: "rightHideTicks",
                  label: "Hide Ticks",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: e.yAxis.max,
                  section: "yAxis",
                  fieldName: "rightMax",
                  type: "number",
                  label: "right axis max value",
                  placeholder: "Auto",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: ht.rightMaxMessage }),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: e.yAxis.min,
                  section: "yAxis",
                  fieldName: "rightMin",
                  type: "number",
                  label: "right axis min value",
                  placeholder: "Auto",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: ht.minMsg })
            ] })
          ] }),
          J() && /* @__PURE__ */ z(Nn, { children: [
            /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ z(Dn, { children: [
              e.visualizationType === "Pie" ? "Segments" : "Date/Category Axis",
              !e.xAxis.dataKey && /* @__PURE__ */ a(qu, { width: "25", className: "warning-icon" })
            ] }) }),
            /* @__PURE__ */ z(_n, { children: [
              e.visualizationType !== "Pie" && /* @__PURE__ */ z(Ue, { children: [
                e.visualizationType !== "Forest Plot" && /* @__PURE__ */ z(Ue, { children: [
                  /* @__PURE__ */ z("label", { children: [
                    /* @__PURE__ */ z("span", { className: "edit-label", children: [
                      "Data Scaling Type",
                      /* @__PURE__ */ z(oe, { style: { textTransform: "none", display: "inline-block" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(oe.Content, { children: "Linear scales are employed for quantitative data, while time scales are used for time-series data." })
                      ] })
                    ] }),
                    /* @__PURE__ */ z(
                      "select",
                      {
                        value: e.xAxis.type,
                        onChange: (O) => t({
                          ...e,
                          xAxis: {
                            ...e.xAxis,
                            type: O.target.value
                          }
                        }),
                        children: [
                          e.visualizationType !== "Bump Chart" && /* @__PURE__ */ a("option", { value: "categorical", children: "Categorical (Linear Scale)" }),
                          e.visualizationType !== "Bump Chart" && /* @__PURE__ */ a("option", { value: "date", children: "Date (Linear Scale)" }),
                          /* @__PURE__ */ a("option", { value: "date-time", children: "Date (Date Time Scale)" }),
                          e.visualizationType === "Scatter Plot" && /* @__PURE__ */ a("option", { value: "continuous", children: "Continuous" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ a(
                    et,
                    {
                      value: e.xAxis.manual,
                      section: "xAxis",
                      fieldName: "manual",
                      label: "Manual Ticks",
                      updateField: ve
                    }
                  ),
                  /* @__PURE__ */ a(
                    et,
                    {
                      display: e.xAxis.type !== "categorical",
                      value: e.xAxis.sortByRecentDate,
                      section: "xAxis",
                      fieldName: "sortByRecentDate",
                      label: "Show dates newest to oldest",
                      updateField: ve
                    }
                  ),
                  ce() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: e.xAxis.padding,
                      type: "number",
                      min: 0,
                      section: "xAxis",
                      fieldName: "padding",
                      label: "Padding (Percent)",
                      className: "number-narrow",
                      updateField: ve,
                      tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified." }) })
                      ] })
                    }
                  )
                ] }),
                /* @__PURE__ */ a(
                  xt,
                  {
                    value: e.xAxis.dataKey || at() || "",
                    section: "xAxis",
                    fieldName: "dataKey",
                    label: "Data Key",
                    initial: "Select",
                    required: !0,
                    updateField: ve,
                    options: Tt(!1),
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Select the column or row containing the categories or dates for this axis. " }) })
                    ] })
                  }
                )
              ] }),
              e.visualizationType === "Pie" && /* @__PURE__ */ a(
                xt,
                {
                  value: e.xAxis.dataKey || "",
                  section: "xAxis",
                  fieldName: "dataKey",
                  label: "Segment Labels",
                  initial: "Select",
                  required: !0,
                  updateField: ve,
                  options: Tt(!1),
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."' }) })
                  ] })
                }
              ),
              e.visualizationType !== "Pie" && /* @__PURE__ */ z(Ue, { children: [
                /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.xAxis.label,
                    section: "xAxis",
                    fieldName: "label",
                    label: "Label",
                    updateField: ve,
                    maxLength: 35,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "35 character limit" }) })
                    ] })
                  }
                ),
                e.xAxis.type === "continuous" && /* @__PURE__ */ z(Ue, { children: [
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      value: e.dataFormat.bottomPrefix,
                      section: "dataFormat",
                      fieldName: "bottomPrefix",
                      label: "Prefix",
                      updateField: ve,
                      tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                          Ze,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: 'Enter a data prefix (such as "$"), if applicable.' }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      value: e.dataFormat.bottomSuffix,
                      section: "dataFormat",
                      fieldName: "bottomSuffix",
                      label: "Suffix",
                      updateField: ve,
                      tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                          Ze,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: 'Enter a data suffix (such as "%"), if applicable.' }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ a(
                    et,
                    {
                      value: e.dataFormat.bottomAbbreviated,
                      section: "dataFormat",
                      fieldName: "bottomAbbreviated",
                      label: "Abbreviate Axis Values",
                      updateField: ve,
                      tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                          Ze,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "This option abbreviates very large or very small numbers on the value axis" }) })
                      ] })
                    }
                  )
                ] }),
                Tn(e.xAxis) && /* @__PURE__ */ z(Ue, { children: [
                  /* @__PURE__ */ z("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" }, children: [
                    "Format how charts should parse and display your dates using",
                    " ",
                    /* @__PURE__ */ a("a", { href: "https://d3js.org/d3-time-format#locale_format", target: "_blank", rel: "noreferrer", children: "these guidelines" }),
                    "."
                  ] }),
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                          Ze,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ z("p", { children: [
                          "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed.",
                          " "
                        ] }) })
                      ] }),
                      value: e.xAxis.dateParseFormat,
                      section: "xAxis",
                      fieldName: "dateParseFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "Date Parse Format",
                      updateField: ve
                    }
                  ),
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                          Ze,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ z("p", { children: [
                          " ",
                          "Adjusts the date display format on the axis for clear, visual date representation."
                        ] }) })
                      ] }),
                      value: e.xAxis.dateDisplayFormat,
                      section: "xAxis",
                      fieldName: "dateDisplayFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "AXIS DATE DISPLAY FORMAT",
                      updateField: ve
                    }
                  ),
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                          Ze,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ z("p", { children: [
                          "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format.",
                          " "
                        ] }) })
                      ] }),
                      value: e.table.dateDisplayFormat,
                      section: "table",
                      fieldName: "dateDisplayFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "DATA TABLE DATE DISPLAY FORMAT",
                      updateField: ve
                    }
                  ),
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                          Ze,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ z("p", { children: [
                          "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format.",
                          " "
                        ] }) })
                      ] }),
                      value: e.tooltips.dateDisplayFormat,
                      section: "tooltips",
                      fieldName: "dateDisplayFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "HOVER DATE DISPLAY FORMAT",
                      updateField: ve
                    }
                  )
                ] }),
                /* @__PURE__ */ a(
                  et,
                  {
                    value: e.exclusions.active,
                    section: "exclusions",
                    fieldName: "active",
                    label: e.xAxis.type === "date" || e.xAxis.type === "date-time" ? "Limit by start and/or end dates" : "Exclude one or more values",
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                        Ze,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ z("p", { children: [
                        "When this option is checked, you can select source-file values for exclusion from the date/category axis.",
                        " "
                      ] }) })
                    ] }),
                    updateField: ve
                  }
                ),
                /* @__PURE__ */ a(
                  et,
                  {
                    value: e.xAxis.showYearsOnce,
                    section: "xAxis",
                    fieldName: "showYearsOnce",
                    label: "Show years once",
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                        Ze,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "When this option is checked and the date format for the axis includes years, each year will only be shown once in the axis." }) })
                    ] }),
                    updateField: ve
                  }
                ),
                Y() && /* @__PURE__ */ a(
                  et,
                  {
                    value: (jn = e.brush) == null ? void 0 : jn.active,
                    section: "brush",
                    fieldName: "active",
                    label: "Brush Slider ",
                    updateField: ve,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                        Ze,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ z("p", { children: [
                        "Use the brush slider to narrow down your data view to specific values along the axis. This tool is useful for examining detailed data segments within the larger dataset.",
                        " "
                      ] }) })
                    ] })
                  }
                ),
                e.exclusions.active && /* @__PURE__ */ z(Ue, { children: [
                  e.xAxis.type === "categorical" && /* @__PURE__ */ z(Ue, { children: [
                    e.exclusions.keys.length > 0 && /* @__PURE__ */ z(Ue, { children: [
                      /* @__PURE__ */ a("fieldset", { children: /* @__PURE__ */ a("legend", { className: "edit-label", children: "Excluded Keys" }) }),
                      /* @__PURE__ */ a(Bt, {})
                    ] }),
                    /* @__PURE__ */ a(
                      xt,
                      {
                        fieldName: "visualizationType",
                        label: "Add Exclusion",
                        initial: "Select",
                        onChange: (O) => {
                          O.target.value !== "" && O.target.value !== "Select" && It(O.target.value), O.target.value = "";
                        },
                        options: an(e.xAxis.dataKey, !0)
                      }
                    )
                  ] }),
                  e.xAxis.type === "date" || e.xAxis.type === "date-time" && /* @__PURE__ */ z(Ue, { children: [
                    /* @__PURE__ */ a(
                      Ge,
                      {
                        type: "date",
                        section: "exclusions",
                        fieldName: "dateStart",
                        label: "Start Date",
                        updateField: ve,
                        value: e.exclusions.dateStart || ""
                      }
                    ),
                    /* @__PURE__ */ a(
                      Ge,
                      {
                        type: "date",
                        section: "exclusions",
                        fieldName: "dateEnd",
                        label: "End Date",
                        updateField: ve,
                        value: e.exclusions.dateEnd || ""
                      }
                    )
                  ] })
                ] }),
                xe() && e.xAxis.type !== "date-time" && e.xAxis.manual && /* @__PURE__ */ z(Ue, { children: [
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      value: e.xAxis.manualStep,
                      placeholder: "Auto",
                      type: "number",
                      min: 1,
                      section: "xAxis",
                      fieldName: "manualStep",
                      label: "Step count",
                      className: "number-narrow",
                      updateField: ve,
                      tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                          Ze,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc." }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ z("div", { className: "viewport-overrides", children: [
                    /* @__PURE__ */ a("label", { children: /* @__PURE__ */ z(
                      "button",
                      {
                        onClick: () => Lt(!st),
                        className: "edit-label",
                        children: [
                          "Step Count: viewport overrides",
                          " ",
                          /* @__PURE__ */ a("span", { style: { transform: `rotate(${st ? "90deg" : "0deg"})` }, children: ">" })
                        ]
                      }
                    ) }),
                    st && /* @__PURE__ */ a("div", { className: "edit-block", children: Object.keys(Nh).map((O) => /* @__PURE__ */ a(
                      Ge,
                      {
                        value: e.xAxis.viewportStepCount ? e.xAxis.viewportStepCount[O] : void 0,
                        placeholder: "Auto",
                        type: "number",
                        label: O,
                        className: "number-narrow",
                        updateField: ($, ee, be, Ie) => Pt("viewportStepCount", O, Ie)
                      },
                      `viewport-step-count-input-${O}`
                    )) })
                  ] })
                ] }),
                xe() && (e.xAxis.type === "date-time" || !e.xAxis.manual) && /* @__PURE__ */ z(Ue, { children: [
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      value: e.xAxis.numTicks,
                      placeholder: "Auto",
                      type: "number",
                      min: 1,
                      section: "xAxis",
                      fieldName: "numTicks",
                      label: "Number of ticks",
                      className: "number-narrow",
                      updateField: ve,
                      tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                          Ze,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.' }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ z("div", { className: "viewport-overrides", children: [
                    /* @__PURE__ */ a("label", { children: /* @__PURE__ */ z(
                      "button",
                      {
                        onClick: () => Lt(!st),
                        className: "edit-label",
                        children: [
                          "Number of ticks: viewport overrides",
                          " ",
                          /* @__PURE__ */ a("span", { style: { transform: `rotate(${st ? "90deg" : "0deg"})` }, children: ">" })
                        ]
                      }
                    ) }),
                    st && /* @__PURE__ */ a("div", { className: "edit-block", children: Object.keys(Nh).map((O) => /* @__PURE__ */ a(
                      Ge,
                      {
                        value: e.xAxis.viewportNumTicks ? e.xAxis.viewportNumTicks[O] : void 0,
                        placeholder: "Auto",
                        type: "number",
                        label: O,
                        className: "number-narrow",
                        updateField: ($, ee, be, Ie) => Pt("viewportNumTicks", O, Ie)
                      },
                      `viewport-num-ticks-input-${O}`
                    )) })
                  ] })
                ] }),
                Se() && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.xAxis.size,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "size",
                    label: e.orientation === "horizontal" ? "Size (Width)" : "Size (Height)",
                    className: "number-narrow",
                    updateField: ve
                  }
                ),
                e.orientation === "horizontal" && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.xAxis.labelOffset,
                    section: "xAxis",
                    fieldName: "labelOffset",
                    label: "Label offset",
                    type: "number",
                    className: "number-narrow",
                    updateField: ve
                  }
                ),
                (e.xAxis.type === "continuous" || e.forestPlot.type === "Logarithmic") && /* @__PURE__ */ z(Ue, { children: [
                  /* @__PURE__ */ a(
                    et,
                    {
                      value: e.dataFormat.bottomCommas,
                      section: "dataFormat",
                      fieldName: "bottomCommas",
                      label: "Add commas",
                      updateField: ve
                    }
                  ),
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      value: e.dataFormat.bottomRoundTo,
                      type: "number",
                      section: "dataFormat",
                      fieldName: "bottomRoundTo",
                      label: "Round to decimal point",
                      className: "number-narrow",
                      updateField: ve,
                      min: 0
                    }
                  )
                ] }),
                Be() && e.orientation === "vertical" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a(
                  et,
                  {
                    value: e.isResponsiveTicks,
                    fieldName: "isResponsiveTicks",
                    label: "Use Responsive Ticks",
                    updateField: ve
                  }
                ),
                (e.orientation === "horizontal" || !e.isResponsiveTicks) && De() && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.xAxis.tickRotation,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "tickRotation",
                    label: "Tick rotation (Degrees)",
                    className: "number-narrow",
                    updateField: ve
                  }
                ),
                e.orientation === "vertical" && e.isResponsiveTicks && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: e.xAxis.maxTickRotation,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "maxTickRotation",
                    label: "Max Tick Rotation",
                    className: "number-narrow",
                    updateField: ve,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                        Ze,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Degrees ticks will be rotated if values overlap, especially in smaller viewports." }) })
                    ] })
                  }
                ),
                e.orientation === "horizontal" ? /* @__PURE__ */ z(Ue, { children: [
                  G() && /* @__PURE__ */ a(
                    et,
                    {
                      value: e.yAxis.hideAxis,
                      section: "yAxis",
                      fieldName: "hideAxis",
                      label: "Hide Axis",
                      updateField: ve
                    }
                  ),
                  Q() && /* @__PURE__ */ a(
                    et,
                    {
                      value: e.yAxis.hideLabel,
                      section: "yAxis",
                      fieldName: "hideLabel",
                      label: "Hide Tick Labels",
                      updateField: ve
                    }
                  )
                ] }) : /* @__PURE__ */ z(Ue, { children: [
                  G() && /* @__PURE__ */ a(
                    et,
                    {
                      value: e.xAxis.hideAxis,
                      section: "xAxis",
                      fieldName: "hideAxis",
                      label: "Hide Axis",
                      updateField: ve
                    }
                  ),
                  Q() && /* @__PURE__ */ a(
                    et,
                    {
                      value: e.xAxis.hideLabel,
                      section: "xAxis",
                      fieldName: "hideLabel",
                      label: "Hide Tick Labels",
                      updateField: ve
                    }
                  ),
                  ke() && /* @__PURE__ */ a(
                    et,
                    {
                      value: e.xAxis.hideTicks,
                      section: "xAxis",
                      fieldName: "hideTicks",
                      label: "Hide Ticks",
                      updateField: ve
                    }
                  )
                ] }),
                ((lr = e.series) == null ? void 0 : lr.length) === 1 && e.visualizationType === "Bar" && /* @__PURE__ */ z(Ue, { children: [
                  /* @__PURE__ */ a("label", { htmlFor: "barHighlight", children: "Bar Highlighting" }),
                  e.series.length === 1 && Wt.map((O, $) => /* @__PURE__ */ a("fieldset", { children: /* @__PURE__ */ z("div", { className: "edit-block", children: [
                    /* @__PURE__ */ a("button", { className: "btn btn-danger", onClick: (ee) => xn(ee, $), children: "Remove" }),
                    /* @__PURE__ */ z("p", { children: [
                      "Highlighted Bar ",
                      $ + 1
                    ] }),
                    /* @__PURE__ */ z("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Value" }),
                      /* @__PURE__ */ z(
                        "select",
                        {
                          value: e.highlightedBarValues[$].value,
                          onChange: (ee) => Rt(ee, $),
                          children: [
                            /* @__PURE__ */ a("option", { value: "", children: "- Select Value -" }),
                            Yt && [...new Set(Yt)].sort().map((ee) => /* @__PURE__ */ a("option", { children: ee }, `special-class-value-option-${$}-${ee}`))
                          ]
                        }
                      )
                    ] }),
                    /* @__PURE__ */ z("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.highlightedBarValues[$].color ? e.highlightedBarValues[$].color : "",
                          onChange: (ee) => Sn(ee, $)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ z("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Border Width" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          max: "5",
                          min: "0",
                          type: "number",
                          value: e.highlightedBarValues[$].borderWidth ? e.highlightedBarValues[$].borderWidth : "",
                          onChange: (ee) => On(ee, $)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ z("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Legend Label" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.highlightedBarValues[$].legendLabel ? e.highlightedBarValues[$].legendLabel : "",
                          onChange: (ee) => Ln(ee, $)
                        }
                      )
                    ] })
                  ] }, `highlighted-bar-${$}`) })),
                  /* @__PURE__ */ a("button", { className: "btn btn-primary full-width", onClick: (O) => Ct(O), children: "Add Highlighted Bar" })
                ] })
              ] }),
              e.visualizationType === "Pie" && /* @__PURE__ */ z(Ue, { children: [
                /* @__PURE__ */ a(
                  et,
                  {
                    value: e.exclusions.active,
                    section: "exclusions",
                    fieldName: "active",
                    label: "Exclude one or more values",
                    updateField: ve,
                    tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                        Ze,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "When this option is checked, you can select values for exclusion from the pie segments." }) })
                    ] })
                  }
                ),
                e.exclusions.active && /* @__PURE__ */ z(Ue, { children: [
                  e.exclusions.keys.length > 0 && /* @__PURE__ */ z(Ue, { children: [
                    /* @__PURE__ */ a("fieldset", { children: /* @__PURE__ */ a("legend", { className: "edit-label", children: "Excluded Keys" }) }),
                    /* @__PURE__ */ a(Bt, {})
                  ] }),
                  /* @__PURE__ */ a(
                    xt,
                    {
                      fieldName: "visualizationType",
                      label: "Add Exclusion",
                      initial: "Select",
                      onChange: (O) => {
                        O.target.value !== "" && O.target.value !== "Select" && It(O.target.value), O.target.value = "";
                      },
                      options: an(e.xAxis.dataKey, !0)
                    }
                  )
                ] })
              ] }),
              H() && /* @__PURE__ */ a(
                Ge,
                {
                  value: e.xAxis.min,
                  section: "xAxis",
                  fieldName: "min",
                  type: "number",
                  label: "min value",
                  placeholder: "Auto",
                  updateField: ve
                }
              ),
              ne() && /* @__PURE__ */ a(
                Ge,
                {
                  value: e.xAxis.max,
                  section: "xAxis",
                  fieldName: "max",
                  type: "number",
                  label: "max value",
                  placeholder: "Auto",
                  updateField: ve
                }
              ),
              se() && e.orientation !== "horizontal" && /* @__PURE__ */ z("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(Ba, { allowZeroExpanded: !0, children: (qn = (Xn = e.xAxis) == null ? void 0 : Xn.anchors) == null ? void 0 : qn.map((O, $) => /* @__PURE__ */ z(Nn, { className: "series-item series-item--chart", children: [
                  /* @__PURE__ */ a(Pn, { className: "series-item__title", children: /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z(Dn, { className: "accordion__button accordion__button", children: [
                    "Anchor ",
                    $ + 1,
                    /* @__PURE__ */ a(
                      "button",
                      {
                        className: "series-list__remove",
                        onClick: (ee) => {
                          ee.preventDefault();
                          const be = [...e.xAxis.anchors];
                          be.splice($, 1), t({
                            ...e,
                            xAxis: {
                              ...e.xAxis,
                              anchors: be
                            }
                          });
                        },
                        children: "Remove"
                      }
                    )
                  ] }) }) }),
                  /* @__PURE__ */ z(_n, { children: [
                    /* @__PURE__ */ z("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                      /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                      ] }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.xAxis.anchors[$].value ? e.xAxis.anchors[$].value : "",
                          onChange: (ee) => {
                            ee.preventDefault();
                            const be = [...e.xAxis.anchors];
                            be[$].value = ee.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ z("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.xAxis.anchors[$].color ? e.xAxis.anchors[$].color : "",
                          onChange: (ee) => {
                            ee.preventDefault();
                            const be = [...e.xAxis.anchors];
                            be[$].color = ee.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ z("label", { children: [
                      "Anchor Line Style",
                      /* @__PURE__ */ z(
                        "select",
                        {
                          value: e.xAxis.anchors[$].lineStyle || "",
                          onChange: (ee) => {
                            const be = [...e.xAxis.anchors];
                            be[$].lineStyle = ee.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          },
                          children: [
                            /* @__PURE__ */ a("option", { children: "Select" }),
                            A.map((ee) => /* @__PURE__ */ a("option", { children: ee.value }, ee.key))
                          ]
                        }
                      )
                    ] })
                  ] })
                ] }, `xaxis-anchors-2-${$}`)) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (O) => {
                      O.preventDefault();
                      const $ = [...e.xAxis.anchors];
                      $.push({}), t({
                        ...e,
                        xAxis: {
                          ...e.xAxis,
                          anchors: $
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] }),
              se() && e.orientation === "horizontal" && /* @__PURE__ */ z("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(Ba, { allowZeroExpanded: !0, children: (_ = (S = e.yAxis) == null ? void 0 : S.anchors) == null ? void 0 : _.map((O, $) => /* @__PURE__ */ z(
                  Nn,
                  {
                    className: "series-item series-item--chart",
                    children: [
                      /* @__PURE__ */ a(Pn, { className: "series-item__title", children: /* @__PURE__ */ a(Ue, { children: /* @__PURE__ */ z(Dn, { className: "accordion__button accordion__button", children: [
                        "Anchor ",
                        $ + 1,
                        /* @__PURE__ */ a(
                          "button",
                          {
                            className: "series-list__remove",
                            onClick: (ee) => {
                              ee.preventDefault();
                              const be = [...e.yAxis.anchors];
                              be.splice($, 1), t({
                                ...e,
                                yAxis: {
                                  ...e.yAxis,
                                  anchors: be
                                }
                              });
                            },
                            children: "Remove"
                          }
                        )
                      ] }) }) }),
                      /* @__PURE__ */ z(_n, { children: [
                        /* @__PURE__ */ z("label", { children: [
                          /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                          /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                            /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                            /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                          ] }),
                          /* @__PURE__ */ a(
                            "input",
                            {
                              type: "text",
                              value: e.yAxis.anchors[$].value ? e.yAxis.anchors[$].value : "",
                              onChange: (ee) => {
                                ee.preventDefault();
                                const be = [...e.yAxis.anchors];
                                be[$].value = ee.target.value, t({
                                  ...e,
                                  yAxis: {
                                    ...e.yAxis,
                                    anchors: be
                                  }
                                });
                              }
                            }
                          )
                        ] }),
                        /* @__PURE__ */ z("label", { children: [
                          /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                          /* @__PURE__ */ a(
                            "input",
                            {
                              type: "text",
                              value: e.yAxis.anchors[$].color ? e.yAxis.anchors[$].color : "",
                              onChange: (ee) => {
                                ee.preventDefault();
                                const be = [...e.yAxis.anchors];
                                be[$].color = ee.target.value, t({
                                  ...e,
                                  yAxis: {
                                    ...e.yAxis,
                                    anchors: be
                                  }
                                });
                              }
                            }
                          )
                        ] }),
                        /* @__PURE__ */ z("label", { children: [
                          "Anchor Line Style",
                          /* @__PURE__ */ z(
                            "select",
                            {
                              value: e.yAxis.anchors[$].lineStyle || "",
                              onChange: (ee) => {
                                const be = [...e.yAxis.anchors];
                                be[$].lineStyle = ee.target.value, t({
                                  ...e,
                                  yAxis: {
                                    ...e.yAxis,
                                    anchors: be
                                  }
                                });
                              },
                              children: [
                                /* @__PURE__ */ a("option", { children: "Select" }),
                                A.map((ee) => /* @__PURE__ */ a("option", { children: ee.value }, ee.key))
                              ]
                            }
                          )
                        ] })
                      ] })
                    ]
                  },
                  `accordion-yaxis-anchors-${$}`
                )) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (O) => {
                      O.preventDefault();
                      const $ = [...e.yAxis.anchors];
                      $.push({}), t({
                        ...e,
                        yAxis: {
                          ...e.yAxis,
                          anchors: $
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ a(bi.Regions, { name: "Regions" }),
          e.visualizationType !== "Box Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ z(Nn, { children: [
            /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ a(Dn, { children: "Columns" }) }),
            /* @__PURE__ */ z(_n, { children: [
              /* @__PURE__ */ a(OT, { config: e, updateField: ve, deleteColumn: ct }),
              " "
            ] })
          ] }),
          I() && /* @__PURE__ */ z(Nn, { children: [
            /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ a(Dn, { children: "Legend" }) }),
            /* @__PURE__ */ z(_n, { children: [
              /* @__PURE__ */ a(
                xt,
                {
                  value: (D = e.legend) == null ? void 0 : D.position,
                  section: "legend",
                  fieldName: "position",
                  label: "Position",
                  updateField: ve,
                  options: ["right", "left", "bottom", "top"]
                }
              ),
              (e.legend.position === "left" || e.legend.position === "right" || !e.legend.position) && e.legend.style === "gradient" && /* @__PURE__ */ a("span", { style: { color: "red", fontSize: "14px" }, children: "Position must be set to top or bottom to use gradient style." }),
              /* @__PURE__ */ a(
                xt,
                {
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                      Ze,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "If using gradient style, limit the legend to five items for better mobile visibility, and position the legend at the top or bottom." }) })
                  ] }),
                  display: !e.legend.hide,
                  value: e.legend.style,
                  section: "legend",
                  fieldName: "style",
                  label: "Legend Style",
                  updateField: ve,
                  options: Ot("style")
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                      Ze,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Choose option Shapes in Line Datapoint Symbols to display." }) })
                  ] }),
                  display: !e.legend.hide && e.legend.style === "lines",
                  value: e.legend.hasShape,
                  section: "legend",
                  fieldName: "hasShape",
                  label: "Shapes",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                xt,
                {
                  display: !e.legend.hide && e.legend.style === "gradient",
                  value: e.legend.subStyle,
                  section: "legend",
                  fieldName: "subStyle",
                  label: "Gradient Style",
                  updateField: ve,
                  options: Ot("subStyle")
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  display: e.legend.style === "gradient" && !e.legend.hide,
                  className: "number-narrow",
                  type: "number",
                  value: e.legend.tickRotation,
                  section: "legend",
                  fieldName: "tickRotation",
                  label: "Tick Rotation (Degrees)",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  display: (K = e.preliminaryData) == null ? void 0 : K.some((O) => O.label && O.type === "suppression" && O.value),
                  value: e.legend.hideSuppressedLabels,
                  section: "legend",
                  fieldName: "hideSuppressedLabels",
                  label: "Hide Suppressed Labels",
                  updateField: ve,
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                      Ze,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.` }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  display: (pe = e.preliminaryData) == null ? void 0 : pe.some((O) => O.label && O.type === "suppression" && O.value),
                  value: e.legend.hideSuppressionLink,
                  section: "legend",
                  fieldName: "hideSuppressionLink",
                  label: "Hide Suppression Definition Link",
                  updateField: ve,
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                      Ze,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting this option will hide the suppression definition link from display." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                xt,
                {
                  display: jt || kn,
                  value: e.legend.behavior,
                  section: "legend",
                  fieldName: "behavior",
                  label: "Legend Behavior (When clicked)",
                  updateField: (...[O, , $, ee]) => wn(O, $, ee),
                  options: ["highlight", "isolate"]
                }
              ),
              /* @__PURE__ */ a(
                xt,
                {
                  display: ue(),
                  value: e.legend.colorCode,
                  section: "legend",
                  fieldName: "colorCode",
                  label: "Color code by category",
                  initial: "Select",
                  updateField: ve,
                  options: _t(r)
                }
              ),
              U() && /* @__PURE__ */ a(
                et,
                {
                  value: e.legend.axisAlign,
                  fieldName: "axisAlign",
                  section: "legend",
                  label: "Align to Axis on Isolate",
                  updateField: ve
                }
              ),
              e.legend.behavior === "highlight" && e.tooltips.singleSeries && /* @__PURE__ */ a(
                et,
                {
                  value: e.legend.highlightOnHover,
                  section: "legend",
                  fieldName: "highlightOnHover",
                  label: "HIGHLIGHT DATA SERIES ON HOVER",
                  updateField: ve
                }
              ),
              te && e.legend.behavior === "isolate" && !En && /* @__PURE__ */ z("fieldset", { className: "primary-fieldset edit-block", children: [
                /* @__PURE__ */ a("label", { children: /* @__PURE__ */ z("span", { className: "edit-label", children: [
                  "Isolate Data Series",
                  /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(Ze, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend." }) })
                  ] })
                ] }) }),
                e.legend.seriesHighlight && e.legend.seriesHighlight.map((O, $) => /* @__PURE__ */ z("fieldset", { className: "edit-block", children: [
                  /* @__PURE__ */ a(
                    "button",
                    {
                      className: "btn btn-danger",
                      onClick: (ee) => {
                        ee.preventDefault();
                        const be = [...e.legend.seriesHighlight];
                        be.splice($, 1), ve("legend", null, "seriesHighlight", be), be.length || E();
                      },
                      children: "Remove"
                    }
                  ),
                  /* @__PURE__ */ a(
                    xt,
                    {
                      value: e.legend.seriesHighlight[$],
                      fieldName: "seriesHighlight",
                      label: "Isolate Value",
                      onChange: (ee) => {
                        const be = [...e.legend.seriesHighlight];
                        be.includes(ee.target.value) || (be[$] = ee.target.value, Mn([...be]));
                      },
                      options: rr()
                    }
                  )
                ] }, `${O}-${$}`)),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (O) => {
                      O.preventDefault();
                      const $ = rr(), ee = [...e.legend.seriesHighlight];
                      if (ee.length < $.length) {
                        const [Ie] = $.filter((Qe) => !ee.includes(Qe));
                        ee.push(Ie), Mn([...ee]);
                      }
                    },
                    children: "Add Isolate Value"
                  }
                )
              ] }, "additional-highlight-values"),
              /* @__PURE__ */ a(
                et,
                {
                  display: !e.legend.hide && e.legend.style !== "gradient",
                  value: e.legend.reverseLabelOrder,
                  section: "legend",
                  fieldName: "reverseLabelOrder",
                  label: "Reverse Labels",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  display: !e.legend.hide,
                  value: ["left", "right"].includes(e.legend.position) ? e.legend.hideBorder.side : e.legend.hideBorder.topBottom,
                  section: "legend",
                  subsection: "hideBorder",
                  fieldName: ["left", "right"].includes(e.legend.position) ? "side" : "topBottom",
                  label: "Hide Legend Box",
                  updateField: ve,
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                      Ze,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "Default option for top and bottom legends is ‘No Box.’." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  display: !e.legend.hide && !["left", "right"].includes(e.legend.position) && e.legend.style !== "gradient",
                  value: e.legend.singleRow,
                  section: "legend",
                  fieldName: "singleRow",
                  label: "Single Row Legend",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  display: ["bottom", "top"].includes(e.legend.position) && !e.legend.hide && e.legend.style !== "gradient" && !e.legend.singleRow && !e.legend.singleRow,
                  value: e.legend.verticalSorted,
                  section: "legend",
                  fieldName: "verticalSorted",
                  label: "Vertical sorted Legend",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                et,
                {
                  value: !!e.legend.hide,
                  section: "legend",
                  fieldName: "hide",
                  label: "Hide Legend",
                  updateField: ve,
                  tooltip: /* @__PURE__ */ z(oe, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(oe.Target, { children: /* @__PURE__ */ a(
                      Ze,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(oe.Content, { children: /* @__PURE__ */ a("p", { children: "With a single-series chart, consider hiding the legend to reduce visual clutter." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: e.legend.label,
                  section: "legend",
                  fieldName: "label",
                  label: "Title",
                  updateField: ve
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  type: "textarea",
                  value: e.legend.description,
                  updateField: ve,
                  section: "legend",
                  fieldName: "description",
                  label: "Legend Description"
                }
              )
            ] })
          ] }),
          Ce() && /* @__PURE__ */ z(Nn, { children: [
            /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ a(Dn, { children: "Filters" }) }),
            /* @__PURE__ */ a(_n, { children: /* @__PURE__ */ a(jg, { config: e, updateField: ve, rawData: b }) })
          ] }),
          /* @__PURE__ */ a(bi.Visual, { name: "Visual" }),
          e.visualizationType !== "Spark Line" && /* @__PURE__ */ z(Nn, { children: [
            /* @__PURE__ */ a(Pn, { children: /* @__PURE__ */ a(Dn, { children: "Data Table" }) }),
            /* @__PURE__ */ z(_n, { children: [
              /* @__PURE__ */ a(
                MT,
                {
                  config: e,
                  columns: Object.keys(r[0] || {}),
                  updateField: ve,
                  isDashboard: m,
                  isLoadedFromUrl: yt
                }
              ),
              " "
            ] })
          ] }),
          /* @__PURE__ */ a(bi.Annotate, { name: "Text Annotations" })
        ] }),
        e.type !== "Spark Line" && /* @__PURE__ */ a(Ug, { loadConfig: t, config: e, convertStateToConfig: zt })
      ]
    }
  ) }) });
}, bm = (e) => {
  let t = "", n = Math.abs(e);
  return n >= 1e9 ? (t = "B", e = e / 1e9) : n >= 1e6 ? (t = "M", e = e / 1e6) : n >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, ps = (e, t) => {
  var n;
  return e ? (n = e.legend) != null && n.hide ? e != null && e.title ? `dataTableSection__${e.title.replace(/\s/g, "")}` : "dataTableSection" : t : "dataTableSection";
}, uC = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], Sm = (e) => typeof e == "string" ? parseFloat(e.replace(/,/g, "")) : Number(e), cC = (e, t) => {
  if (t.rankByValue) {
    const n = t.series[0].dataKey, r = e.sort((i, o) => Sm(i[n]) - Sm(o[n]));
    return t.rankByValue === "asc" ? r : r.reverse();
  }
  return e;
}, wm = (e = "#000000", t = !1) => {
  let n = Gi(e), r = t ? n.brighten(0.5).hex() : n.saturate(1.3).hex();
  return [e, r, n.darken(0.3).hex()];
}, dC = de.createContext({ displayName: "ConfigContext", setTempConfig: () => {
} }), XC = de.createContext(() => {
}), fC = (e, t) => {
  const { allowLineToBarGraph: n, formattedData: r, series: i, visualizationType: o, xAxis: d } = e;
  if (!n)
    return !1;
  const c = o === "Line" && (t == null ? void 0 : t.length) < 3, p = (i == null ? void 0 : i.some((m) => m.dynamicCategory)) && nt.uniq(r == null ? void 0 : r.map((m) => m[d.dataKey])).length <= 2;
  return c || p;
}, hC = (e, t) => {
  const n = t, r = nt.uniq(nt.map(n, e.xAxis.dataKey)), i = nt.map(e.series, "dataKey"), o = [];
  r.forEach((c) => {
    i.forEach((s) => {
      try {
        if (!c)
          throw new Error("No groups resolved in box plots");
        const { count: p, sortedData: m } = nt.chain(n).filter((v) => v[e.xAxis.dataKey] === c).thru((v) => ({
          count: v.length,
          sortedData: nt.map(v, (E) => Number(E[s])).sort()
        })).value();
        if (!m)
          throw new Error("boxplots dont have data yet");
        if (!o)
          throw new Error("boxplots dont have plots yet");
        const g = Es(m, 0.25), x = Es(m, 0.75), T = x - g, y = g - 1.5 * T, A = x + 1.5 * T, b = m.filter((v) => v >= y && v <= A);
        o.push({
          columnCategory: c,
          columnMax: rc(b),
          columnThirdQuartile: nt.round(x, e.dataFormat.roundTo),
          columnMedian: Number(ay(m)).toFixed(e.dataFormat.roundTo),
          columnFirstQuartile: nt.round(g, e.dataFormat.roundTo),
          columnMin: nt.min(b),
          columnCount: p,
          columnSd: Number(ux(m)).toFixed(e.dataFormat.roundTo),
          columnMean: Number(cx(m)).toFixed(e.dataFormat.roundTo),
          columnIqr: nt.round(T, e.dataFormat.roundTo),
          values: m,
          columnLowerBounds: y,
          columnUpperBounds: A,
          columnOutliers: nt.filter(m, (v) => v < y || v > A),
          columnNonOutliers: nt.filter(m, (v) => v >= y && v <= A)
        });
      } catch (p) {
        console.error("COVE: ", p.message);
      }
    });
  });
  const d = i.length > 1 ? nt.flatMap(r, (c) => nt.map(i, (s) => `${nt.capitalize(s)} - ${nt.capitalize(c)}`)) : r;
  return [o, d];
}, pC = (e) => {
  if (e.visualizationType !== "Combo" || !e.series)
    return;
  const t = {
    barSeriesKeys: [],
    lineSeriesKeys: [],
    areaSeriesKeys: [],
    forecastingSeriesKeys: []
  }, n = /* @__PURE__ */ new Map([
    ["Area Chart", "areaSeriesKeys"],
    ["Forecasting", "forecastingSeriesKeys"],
    ["Bar", "barSeriesKeys"],
    ["Combo", "barSeriesKeys"],
    ["Line", "lineSeriesKeys"],
    ["dashed-sm", "lineSeriesKeys"],
    ["dashed-md", "lineSeriesKeys"],
    ["dashed-lg", "lineSeriesKeys"]
  ]);
  return e.series.forEach((r) => {
    const i = n.get(r.type);
    if (i) {
      const o = i === "barSeriesKeys" || i === "lineSeriesKeys" ? r.dataKey : r;
      t[i].push(o);
    }
    r.type === "Combo" && (r.type = "Bar");
  }), { ...e.runtime, ...t };
}, mC = (e, t) => {
  var r;
  let n = t;
  if (e.exclusions && e.exclusions.active)
    if (e.xAxis.type === "categorical" && ((r = e.exclusions.keys) == null ? void 0 : r.length) > 0)
      n = t.filter((i) => !e.exclusions.keys.includes(i[e.xAxis.dataKey]));
    else if (Tn(e.xAxis) && (e.exclusions.dateStart || e.exclusions.dateEnd) && e.xAxis.dateParseFormat) {
      const i = (p) => new Date(p).getTime();
      let o = i(e.exclusions.dateStart), d = i(e.exclusions.dateEnd) + 86399999, c = typeof o !== void 0 && isNaN(o) === !1, s = typeof d !== void 0 && isNaN(d) === !1;
      c && s ? n = t.filter(
        (p) => i(p[e.xAxis.dataKey]) >= o && i(p[e.xAxis.dataKey]) <= d
      ) : c ? n = t.filter((p) => i(p[e.xAxis.dataKey]) >= o) : s && (n = t.filter((p) => i(p[e.xAxis.dataKey]) <= d));
    } else
      n = t;
  return n;
}, yC = (e) => {
  const t = ["Paired Bar", "Deviation Bar"].includes(e.visualizationType) ? e.twoColor.palette : e.palette, n = { ...Cr, ..._c };
  let r = e.customColors || n[t], i = e.runtime.seriesKeys.length;
  for (; i > r.length; )
    r = r.concat(r);
  return r = r.slice(0, i), bh({
    domain: e.runtime.seriesLabelsAll,
    range: r,
    unknown: null
  });
};
const gC = (e) => {
  var t, n, r;
  return {
    isLoading: !0,
    config: Xu,
    stateData: nt.cloneDeep(e == null ? void 0 : e.data) || [],
    colorScale: null,
    excludedData: void 0,
    filteredData: void 0,
    seriesHighlight: e && ((n = (t = e == null ? void 0 : e.legend) == null ? void 0 : t.seriesHighlight) != null && n.length) ? [...(r = e == null ? void 0 : e.legend) == null ? void 0 : r.seriesHighlight] : [],
    currentViewport: "lg",
    dimensions: [0, 0],
    container: null,
    coveLoadedEventRan: !1,
    isDraggingAnnotation: !1,
    imageId: `cove-${Math.random().toString(16).slice(-4)}`,
    brushConfig: {
      data: [],
      isActive: !1,
      isBrushing: !1
    }
  };
}, vC = (e, t) => {
  switch (t.type) {
    case "SET_LOADING":
      return { ...e, isLoading: t.payload };
    case "SET_CONFIG":
      return { ...e, config: t.payload };
    case "UPDATE_CONFIG":
      return { ...e, config: t.payload };
    case "SET_COLOR_SCALE":
      return { ...e, colorScale: t.payload };
    case "SET_STATE_DATA":
      return { ...e, stateData: t.payload };
    case "SET_EXCLUDED_DATA":
      return { ...e, excludedData: t.payload };
    case "SET_FILTERED_DATA":
      return { ...e, filteredData: t.payload };
    case "SET_SERIES_HIGHLIGHT":
      return { ...e, seriesHighlight: t.payload };
    case "SET_VIEWPORT":
      return { ...e, currentViewpsort: t.payload };
    case "SET_DIMENSIONS":
      return { ...e, dimensions: t.payload };
    case "SET_CONTAINER":
      return { ...e, container: t.payload };
    case "SET_LOADED_EVENT":
      return { ...e, coveLoadedEventRan: t.payload };
    case "SET_DRAG_ANNOTATIONS":
      return { ...e, isDraggingAnnotation: t.payload };
    case "SET_BRUSH_CONFIG":
      return { ...e, brushConfig: t.payload };
  }
}, xC = ({
  config: e,
  isEditor: t = !1,
  isDebug: n = !1,
  isDashboard: r = !1,
  setConfig: i,
  setEditing: o,
  link: d,
  setSharedFilter: c,
  setSharedFilterValue: s,
  dashboardConfig: p
}) => {
  var _t, an, dn, zt, Bt, on, rt, ht;
  const m = new zm(), g = gC(e), [x, T] = de.useReducer(vC, g), {
    config: y,
    stateData: A,
    excludedData: b,
    filteredData: v,
    currentViewport: E,
    isLoading: N,
    dimensions: R,
    container: L,
    coveLoadedEventRan: B,
    imageId: j,
    seriesHighlight: Z,
    colorScale: re,
    brushConfig: X
  } = x, { description: se, visualizationType: Y } = y, ie = de.useRef(null), I = de.useContext(dC), [U, ue] = de.useState(), te = (Pe) => {
    T({ type: "SET_CONFIG", payload: Pe }), t && !r && I.setTempConfig(Pe);
  }, J = (Pe) => {
    T({ type: "SET_FILTERED_DATA", payload: Pe });
  }, Q = de.useRef(null), G = de.useRef(null), ne = (Pe) => {
    T({ type: "SET_DRAG_ANNOTATIONS", payload: Pe });
  };
  n && console.log("Chart config, isEditor", y, t);
  let { legend: H, title: ce } = y;
  t && (!ce || ce === "") && (ce = "Chart Title"), y.table && (!((_t = y.table) != null && _t.label) || ((an = y.table) == null ? void 0 : an.label) === "") && (y.table.label = "Data Table");
  const { lineDatapointClass: ke, contentClasses: Se, sparkLineStyles: xe } = Kg(y), De = de.useId(), Ce = (y.xAxis || y.yAxis) && ["date-time", "date"].includes((y.xAxis || y.yAxis).type) && y.xAxis.dataKey, ye = fC(y, v), Ee = async (Pe) => {
    let _e = nt.defaultsDeep(Pe, Xu);
    return nt.defaultsDeep(_e, {
      table: { showVertical: !1 }
    }), nt.set(_e, "table.show", nt.get(_e, "table.show", !r)), nt.forEach(_e.series, (we) => {
      nt.defaults(we, {
        tooltip: !0,
        axis: "Left"
      });
    }), _e.visualizationType === "Bump Chart" && _e.xAxis.type, { ...qg(_e) };
  }, he = (Pe, _e) => {
    var wt, qt;
    const we = nt.cloneDeep(Pe);
    let yt = _e || A;
    yt = cC(yt, we), Object.keys(Xu).forEach((ct) => {
      we[ct] && typeof we[ct] == "object" && !Array.isArray(we[ct]) && (we[ct] = { ...Xu[ct], ...we[ct] });
    });
    const at = mC(we, _e || A);
    T({ type: "SET_EXCLUDED_DATA", payload: at });
    let bt = [];
    if (we.filters) {
      const ct = hv(we.filters, at);
      bt = Go(ct, at), T({ type: "SET_FILTERED_DATA", payload: bt });
    }
    if (we.xAxis.type === "date-time" && y.orientation === "horizontal" && (we.xAxis.type = "date"), we.runtime = {}, we.runtime.series = nt.cloneDeep(we.series), we.runtime.seriesLabels = {}, we.runtime.seriesLabelsAll = [], we.runtime.originalXAxis = we.xAxis, we.visualizationType === "Pie")
      we.runtime.seriesKeys = (_e || yt).map((ct) => ct[we.xAxis.dataKey]), we.runtime.seriesLabelsAll = we.runtime.seriesKeys;
    else {
      const ct = _e || we.formattedData || we.data;
      we.runtime.seriesKeys = (we.runtime.series || []).flatMap((dt) => {
        if (dt.dynamicCategory) {
          nt.remove(we.runtime.seriesLabelsAll, (Yt) => Yt === dt.dataKey), nt.remove(we.runtime.series, (Yt) => Yt.dataKey === dt.dataKey);
          const Wt = nt.uniq(ct.map((Yt) => Yt[dt.dynamicCategory]));
          return Wt.forEach((Yt) => {
            we.runtime.seriesLabels[Yt] = Yt, we.runtime.seriesLabelsAll.push(Yt), we.runtime.series.push({
              dataKey: Yt,
              type: dt.type,
              lineType: dt.lineType,
              originalDataKey: dt.dataKey,
              dynamicCategory: dt.dynamicCategory,
              tooltip: !0
            });
          }), Wt;
        } else
          return we.runtime.seriesLabels[dt.dataKey] = dt.name || dt.label || dt.dataKey, we.runtime.seriesLabelsAll.push(dt.name || dt.dataKey), [dt.dataKey];
      });
    }
    if (we.visualizationType === "Box Plot" && we.series) {
      const [ct, dt] = hC(we, A);
      we.boxplot.categories = dt, we.boxplot.plots = ct;
    }
    we.visualizationType === "Combo" && we.series && (we.runtime = pC(we)), we.visualizationType === "Forecasting" && we.series && (we.runtime.forecastingSeriesKeys = [], we.series.forEach((ct) => {
      ct.type === "Forecasting" && we.runtime.forecastingSeriesKeys.push(ct);
    })), we.visualizationType === "Area Chart" && we.series && (we.runtime.areaSeriesKeys = [], we.series.forEach((ct) => {
      we.runtime.areaSeriesKeys.push({ ...ct, type: "Area Chart" });
    })), we.visualizationType === "Bar" && we.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(we.visualizationType) ? (we.runtime.xAxis = we.yAxis.yAxis ? we.yAxis.yAxis : we.yAxis, we.runtime.yAxis = we.xAxis.xAxis ? we.xAxis.xAxis : we.xAxis, we.runtime.yAxis.labelOffset *= -1, we.runtime.horizontal = !1, we.orientation = "horizontal", we.yAxis.type = we.yAxis.type === "categorical" ? "linear" : we.yAxis.type) : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(we.visualizationType) && !ye ? (we.runtime.xAxis = we.xAxis, we.runtime.yAxis = we.yAxis, we.runtime.horizontal = !1, we.orientation = "vertical") : (we.runtime.xAxis = we.xAxis, we.runtime.yAxis = we.yAxis, we.runtime.horizontal = !1), we.runtime.uniqueId = Date.now(), we.runtime.editorErrorMessage = we.visualizationType === "Pie" && !we.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", we.runtime.editorErrorMessage = "", (wt = we.legend.seriesHighlight) != null && wt.length && T({ type: "SET_SERIES_HIGHLIGHT", payload: (qt = we.legend) == null ? void 0 : qt.seriesHighlight }), te(we);
  }, Be = (Pe, _e) => {
    let we = y.visualizationType === "Bar" && y.visualizationSubType === "horizontal" ? y.xAxis.dataKey : y.yAxis.sortKey, yt = parseFloat(Pe[we]), at = parseFloat(_e[we]);
    return yt < at ? y.sortData === "ascending" ? 1 : -1 : yt > at ? y.sortData === "ascending" ? -1 : 1 : 0;
  }, $e = new kg((Pe) => {
    for (let _e of Pe) {
      let { width: we, height: yt } = _e.contentRect;
      const at = 15;
      we = t ? we - 350 : we;
      const wt = Tg(we);
      T({ type: "SET_VIEWPORT", payload: wt }), _e.target.dataset.lollipop === "true" && (we = we - 2.5), we = we - at, T({ type: "SET_DIMENSIONS", payload: [we, yt] });
    }
  }), tt = de.useCallback((Pe) => {
    Pe !== null && $e.observe(Pe), T({ type: "SET_CONTAINER", payload: Pe });
  }, []), We = async (Pe) => {
    try {
      const _e = Pe.filters ? Pe.filters.filter((we) => we.type === "url").length > 0 : !1;
      if (Pe.dataUrl && !_e) {
        Pe.dataUrl && (Pe.dataUrl = `${Pe.dataUrl}`);
        let we = await Cg(Pe.dataUrl, "Chart");
        we && Pe.dataDescription && (we = m.autoStandardize(we), we = m.developerStandardize(we, Pe.dataDescription)), we && (Pe.data = we);
      } else
        Pe.formattedData ? Pe.data = Pe.formattedData : Pe.dataDescription && (Pe.data = m.autoStandardize(Pe.data), Pe.data = m.developerStandardize(Pe.data, Pe.dataDescription));
    } catch (_e) {
      console.log("Error on prepareData function ", _e);
    }
    return Pe;
  };
  de.useEffect(() => {
    (async () => {
      try {
        if (e) {
          const _e = await Ee(e);
          let we = await We(_e);
          T({ type: "SET_STATE_DATA", payload: we.data }), T({ type: "SET_EXCLUDED_DATA", payload: we.data }), he(_e, we.data);
        }
      } catch {
        console.error("Could not Load!");
      }
    })();
  }, [(dn = e == null ? void 0 : e.data) != null && dn.length ? e.data : null]), de.useEffect(() => {
    L && !nt.isEmpty(y) && !B && (Yg("cove_loaded", { config: y }), T({ type: "SET_LOADED_EVENT", payload: !0 }));
  }, [L, y]), de.useEffect(() => {
    const Pe = (_e) => {
      let we = [];
      we.push(_e.detail), ue(we);
    };
    return Gg("cove_filterData", (_e) => Pe(_e)), () => {
      Xg("cove_filterData", Pe);
    };
  }, [y]), de.useEffect(() => {
    if (U && U[0] && !U[0].hasOwnProperty("active")) {
      let _e = { ...y };
      delete _e.filters, te(_e), T({ type: "SET_FILTERED_DATA", payload: Go(U, b) });
    }
    if (U && U.length > 0 && U.length > 0 && U[0].hasOwnProperty("active")) {
      let Pe = { ...y, filters: U };
      te(Pe), T({ type: "SET_FILTERED_DATA", payload: Go(U, b) });
    }
  }, [U]), de.useEffect(() => {
    var Pe;
    if (A && y.xAxis && ((Pe = y.runtime) != null && Pe.seriesKeys)) {
      const _e = yC(y);
      T({ type: "SET_COLOR_SCALE", payload: _e }), T({ type: "SET_LOADING", payload: !1 });
    }
    y && A && y.sortData && A.sort(Be);
  }, [y, A]);
  const Fe = (Pe) => {
    if (Z.length + 1 === y.runtime.seriesKeys.length && y.visualizationType !== "Forecasting")
      return Je();
    const _e = nt.findKey(y.runtime.seriesLabels, (yt) => yt === Pe.datum) || Pe.datum, we = nt.xor(Z, [_e]);
    T({ type: "SET_SERIES_HIGHLIGHT", payload: we });
  }, Je = () => {
    try {
      const Pe = Q.current;
      if (!Pe)
        throw new Vd("No legend available to set previous focus on.");
      Pe.focus();
    } catch (Pe) {
      console.error("COVE:", Pe.message);
    }
    T({ type: "SET_SERIES_HIGHLIGHT", payload: [] });
  }, Ke = y.orientation === "horizontal" ? "yAxis" : "xAxis", Ye = (Pe, _e = !0) => {
    let we = cy(y.runtime[Ke].dateParseFormat)(Pe);
    return we || (_e && (y.runtime.editorErrorMessage = `Error parsing date "${Pe}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, Xe = (Pe, _e, we) => {
    var at, bt;
    let yt = ju(y.runtime[Ke].dateDisplayFormat)(Pe);
    if ((at = y.runtime[Ke].dateDisplayFormat) != null && at.includes("%b.") && yt.includes("May.") && (yt = yt.replace(/May\./g, "May")), y.xAxis.showYearsOnce && ((bt = y.runtime[Ke].dateDisplayFormat) != null && bt.includes("%Y")) && we) {
      const wt = we[_e - 1] ? we[_e - 1].value : null, qt = ju(y.runtime[Ke].dateDisplayFormat)(wt), ct = yt.match(/\d{4}/), dt = qt.match(/\d{4}/);
      ct && dt && ct[0] === dt[0] && (yt = yt.replace(ct, ""));
    }
    return yt;
  }, Ae = (Pe) => ju(y.tooltips.dateDisplayFormat)(Pe), Oe = (Pe, _e, we = !1, yt, at, bt, { index: wt, length: qt } = { index: null, length: null }) => {
    if (isNaN(Pe) || !Pe)
      return Pe;
    const ct = Pe < 0;
    (_e === void 0 || !_e) && (_e = "left"), ct && (Pe = Math.abs(Pe));
    let {
      dataFormat: {
        commas: dt,
        abbreviated: Wt,
        roundTo: Yt,
        prefix: Rt,
        suffix: Ct,
        rightRoundTo: xn,
        bottomRoundTo: Sn,
        rightPrefix: Ln,
        rightSuffix: On,
        bottomPrefix: En,
        bottomSuffix: rr,
        bottomAbbreviated: Mn,
        onlyShowTopPrefixSuffix: wn
      }
    } = y;
    String(Pe).indexOf(",") !== -1 && (Pe = Pe.replaceAll(",", ""));
    let Pt = Pe, jt = {
      useGrouping: !!dt
      // for old chart data table to work right cant just leave this to undefined
    };
    if (_e === "left" || _e === void 0) {
      let fn;
      bt !== void 0 ? fn = bt ? Number(bt) : 0 : fn = Yt ? Number(Yt) : 0, jt = {
        useGrouping: bt ? !0 : !!y.dataFormat.commas,
        minimumFractionDigits: fn,
        maximumFractionDigits: fn
      };
    }
    _e === "right" && (jt = {
      useGrouping: !!y.dataFormat.rightCommas,
      minimumFractionDigits: xn ? Number(xn) : 0,
      maximumFractionDigits: xn ? Number(xn) : 0
    });
    const kn = () => y.forestPlot.type === "Logarithmic" && !Sn ? 2 : Number(Sn) ? Number(Sn) : 0;
    if (_e === "bottom" && (jt = {
      useGrouping: !!y.dataFormat.bottomCommas,
      minimumFractionDigits: kn(),
      maximumFractionDigits: kn()
    }), Pe = qh(Pe), isNaN(Pe))
      return y.runtime.editorErrorMessage = `Unable to parse number from data ${Pt}. Try reviewing your data and selections in the Data Series section.`, Pt;
    if (!y.dataFormat)
      return Pe;
    if (y.dataCutoff) {
      let fn = qh(y.dataCutoff);
      Pe < fn && (Pe = fn);
    }
    _e === "left" && dt && Wt && we || _e === "bottom" && dt && Wt && we ? Pe = Pe : Pe = Pe.toLocaleString("en-US", jt);
    let tn = "";
    if (Wt && _e === "left" && we && (Pe = bm(parseFloat(Pe))), Mn && _e === "bottom" && we && (Pe = bm(parseFloat(Pe))), yt && _e === "left")
      tn = yt + tn;
    else {
      const fn = wn && qt - 1 !== wt;
      Rt && _e === "left" && !fn && (tn += Rt);
    }
    return Ln && _e === "right" && (tn += Ln), En && _e === "bottom" && (tn += En), tn += Pe, at && _e === "left" ? tn += at : Ct && _e === "left" && !wn && (tn += Ct), On && _e === "right" && (tn += On), rr && _e === "bottom" && (tn += rr), ct && (tn = "-" + tn), String(tn);
  }, lt = (Pe) => {
    try {
      if (!Pe)
        throw new Vd("COVE: No rowObj in applyLegendToRow");
      if (y.type === "navigation") {
        let _e = Cr[y.color] || Cr.bluegreenreverse;
        return wm(_e[3]);
      }
      return wm();
    } catch (_e) {
      console.error("COVE: ", _e);
    }
  }, ve = (Pe) => {
    var yt;
    if (!Array.isArray(Pe))
      return [];
    if (y.visualizationType === "Forecasting")
      return Pe;
    const _e = y.series.map((at) => at.dataKey), we = y.xAxis.dataKey;
    return (yt = y == null ? void 0 : y.xAxis) != null && yt.dataKey ? m.cleanData(Pe, we, _e) : Pe;
  }, mt = () => {
    var yt, at, bt;
    if (Y === "Sankey")
      return (at = (yt = y == null ? void 0 : y.data) == null ? void 0 : yt[0]) == null ? void 0 : at.tableData;
    const Pe = v || b, _e = y.series.find((wt) => !!wt.dynamicCategory);
    if (!_e)
      return Pe;
    const we = Object.values(y.columns).filter((wt) => wt.dataTable).map((wt) => wt.name).concat([_e.dynamicCategory, _e.dataKey]);
    return (bt = y.xAxis) != null && bt.dataKey && we.push(y.xAxis.dataKey), Pe.map((wt) => nt.pick(wt, we));
  }, ut = (Pe) => {
    const _e = nt.cloneDeep(Pe), we = _e.series.find((yt) => !!yt.dynamicCategory);
    if (we) {
      const yt = { columnName: we.dynamicCategory, valueColumns: [we.dataKey] };
      _e.table.pivot = yt;
    }
    return _e;
  };
  let st = /* @__PURE__ */ a(ev, {});
  const Lt = (Pe) => {
    if (nt.isString(Pe))
      return nt.kebabCase(Pe);
  }, Kt = () => {
    var we;
    const Pe = (H == null ? void 0 : H.position) === "bottom" || Ui(E), _e = ["chart-container", "p-relative"];
    return H != null && H.position && (Ui(E) && (H == null ? void 0 : H.position) !== "top" ? _e.push("legend-bottom") : _e.push(`legend-${H.position}`)), H != null && H.hide && _e.push("legend-hidden"), ke && _e.push(ke), y.barHasBorder || _e.push("chart-bar--no-border"), (we = y.brush) != null && we.active && (p == null ? void 0 : p.type) === "dashboard" && (!Pe || H.hide) && _e.push("dashboard-brush"), _e.push(...Se), _e;
  }, Xt = () => {
    var we, yt;
    const Pe = ["subtext mt-4"], _e = (H == null ? void 0 : H.position) === "bottom" || Ui(E);
    return y.isResponsiveTicks && Pe.push("subtext--responsive-ticks "), (we = y.brush) != null && we.active && !_e && Pe.push("subtext--brush-active "), (yt = y.brush) != null && yt.active && y.legend.hide && Pe.push("subtext--brush-active "), Pe;
  };
  if (!N) {
    const Pe = /* @__PURE__ */ z("a", { href: `#data-table-${y.dataKey}`, className: "margin-left-href", children: [
      y.dataKey,
      " (Go to Table)"
    ] });
    st = /* @__PURE__ */ z(Ue, { children: [
      t && /* @__PURE__ */ a(sC, {}),
      /* @__PURE__ */ z(gf.Responsive, { isEditor: t, children: [
        y.newViz && /* @__PURE__ */ a(pv, { updateConfig: he, config: y }),
        y.newViz === void 0 && t && y.runtime && ((zt = y.runtime) == null ? void 0 : zt.editorErrorMessage) && /* @__PURE__ */ a(Vd, { errorMessage: y.runtime.editorErrorMessage }),
        !xf(y) && !y.newViz && /* @__PURE__ */ z(
          "div",
          {
            className: `cdc-chart-inner-container cove-component__content type-${Lt(
              y.visualizationType
            )}`,
            "aria-label": $f(y),
            tabIndex: 0,
            children: [
              /* @__PURE__ */ a(
                Jg,
                {
                  showTitle: y.showTitle,
                  isDashboard: r,
                  title: ce,
                  superTitle: y.superTitle,
                  classes: ["chart-title", `${y.theme}`, "cove-component__header", "mb-3"],
                  style: void 0
                }
              ),
              /* @__PURE__ */ z("div", { className: Kt().join(" "), children: [
                (y == null ? void 0 : y.introText) && y.visualizationType !== "Spark Line" && /* @__PURE__ */ a("section", { className: "introText mb-4", children: za(y.introText) }),
                y.filters && !U && y.visualizationType !== "Spark Line" && /* @__PURE__ */ a(
                  Xh,
                  {
                    config: y,
                    setConfig: te,
                    setFilteredData: J,
                    filteredData: v,
                    excludedData: b,
                    filterData: Go,
                    dimensions: R
                  }
                ),
                /* @__PURE__ */ a(Vh, { skipId: ps(y, De), skipMessage: "Skip Over Chart Container" }),
                ((Bt = y.annotations) == null ? void 0 : Bt.length) > 0 && /* @__PURE__ */ a(
                  Vh,
                  {
                    skipId: ps(y, De),
                    skipMessage: "Skip over annotations"
                  },
                  "skip-annotations"
                ),
                /* @__PURE__ */ z(wv, { children: [
                  /* @__PURE__ */ z(
                    "div",
                    {
                      className: H.hide || Ui(E) || H.position === "bottom" || H.position === "top" || Y === "Sankey" ? "w-100" : "w-75",
                      children: [
                        !["Spark Line", "Line", "Sankey", "Pie", "Sankey"].includes(y.visualizationType) && /* @__PURE__ */ a("div", { ref: G, style: { width: "100%" }, children: /* @__PURE__ */ a(Xo, { children: (_e) => /* @__PURE__ */ a(mf, { ref: ie, parentWidth: _e.width, parentHeight: _e.height }) }) }),
                        y.visualizationType === "Pie" && /* @__PURE__ */ a(Xo, { className: "justify-content-center d-flex", style: { width: "100%" }, children: (_e) => /* @__PURE__ */ a(GS, { ref: ie, parentWidth: _e.width, parentHeight: _e.height }) }),
                        y.visualizationType === "Line" && (ye ? /* @__PURE__ */ a("div", { ref: G, style: { width: "100%" }, children: /* @__PURE__ */ a(Xo, { children: (_e) => /* @__PURE__ */ a(mf, { ref: ie, parentWidth: _e.width, parentHeight: _e.height }) }) }) : /* @__PURE__ */ a("div", { ref: G, style: { width: "100%" }, children: /* @__PURE__ */ a(Xo, { children: (_e) => /* @__PURE__ */ a(mf, { ref: ie, parentWidth: _e.width, parentHeight: _e.height }) }) })),
                        y.visualizationType === "Spark Line" && /* @__PURE__ */ z(Ue, { children: [
                          /* @__PURE__ */ a(
                            Xh,
                            {
                              config: y,
                              setConfig: te,
                              setFilteredData: J,
                              filteredData: v,
                              excludedData: b,
                              filterData: Go,
                              dimensions: R
                            }
                          ),
                          (y == null ? void 0 : y.introText) && /* @__PURE__ */ a("section", { className: "introText mb-4", style: { padding: "0px 0 35px" }, children: za(y.introText) }),
                          /* @__PURE__ */ a("div", { style: { height: "100px", width: "100%", ...xe }, children: /* @__PURE__ */ a(Xo, { children: (_e) => /* @__PURE__ */ a(cT, { width: _e.width, height: _e.height }) }) }),
                          se && /* @__PURE__ */ a("div", { className: "subtext", style: { padding: "35px 0 15px" }, children: za(se) })
                        ] }),
                        y.visualizationType === "Sankey" && /* @__PURE__ */ a(Xo, { "aria-hidden": "true", children: (_e) => /* @__PURE__ */ a(Cw, { runtime: y.runtime, width: _e.width, height: _e.height }) })
                      ]
                    }
                  ),
                  !y.legend.hide && y.visualizationType !== "Spark Line" && y.visualizationType !== "Sankey" && /* @__PURE__ */ a(DT, { ref: Q, skipId: ps(y, De) })
                ] }),
                r && y.table && y.table.show && y.table.showDataTableLink ? Pe : d && d,
                y.description && y.visualizationType !== "Spark Line" && /* @__PURE__ */ a("div", { className: Xt().join(" "), children: za(y.description) }),
                /* @__PURE__ */ z($d.Section, { classes: ["download-buttons"], children: [
                  y.table.showDownloadImgButton && /* @__PURE__ */ a(
                    $d.Button,
                    {
                      text: "Download Image",
                      title: "Download Chart as Image",
                      type: "image",
                      state: y,
                      elementToCapture: j
                    }
                  ),
                  y.table.showDownloadPdfButton && /* @__PURE__ */ a(
                    $d.Button,
                    {
                      text: "Download PDF",
                      title: "Download Chart as PDF",
                      type: "pdf",
                      state: y,
                      elementToCapture: j
                    }
                  )
                ] }),
                (y.xAxis.dataKey && y.table.show && y.visualizationType !== "Spark Line" && y.visualizationType !== "Sankey" || y.visualizationType === "Sankey" && y.table.show) && /* @__PURE__ */ a(
                  Qg,
                  {
                    config: ut(y),
                    rawData: y.visualizationType === "Sankey" ? (rt = (on = y == null ? void 0 : y.data) == null ? void 0 : on[0]) == null ? void 0 : rt.tableData : y.table.customTableConfig ? Go(y.filters, y.data) : y.data,
                    runtimeData: mt(),
                    expandDataTable: y.table.expanded,
                    columns: y.columns,
                    defaultSortBy: Ce,
                    displayGeoName: (_e) => _e,
                    applyLegendToRow: lt,
                    tableTitle: y.table.label,
                    indexTitle: y.table.indexLabel,
                    vizTitle: ce,
                    viewport: E,
                    tabbingId: ps(y, De),
                    colorScale: re
                  },
                  Ce
                ),
                ((ht = y == null ? void 0 : y.annotations) == null ? void 0 : ht.length) > 0 && /* @__PURE__ */ a(Ah.Dropdown, {}),
                (y == null ? void 0 : y.footnotes) && /* @__PURE__ */ a("section", { className: "footnotes pt-2 mt-4", children: za(y.footnotes) })
              ] })
            ]
          }
        )
      ] })
    ] });
  }
  const Ot = {
    ...x,
    brushConfig: X,
    capitalize: (Pe) => Pe.charAt(0).toUpperCase() + Pe.slice(1),
    convertLineToBarGraph: ye,
    clean: ve,
    colorPalettes: Cr,
    dashboardConfig: p,
    debugSvg: n,
    formatDate: Xe,
    formatNumber: Oe,
    formatTooltipsDate: Ae,
    getXAxisData: (Pe) => Tn(y.runtime.xAxis) ? Ye(Pe[y.runtime.originalXAxis.dataKey]).getTime() : Pe[y.runtime.originalXAxis.dataKey],
    getYAxisData: (Pe, _e) => Pe[_e],
    handleChartAriaLabels: $f,
    handleLineType: xg,
    handleChartTabbing: ps,
    highlight: Fe,
    handleShowAll: Je,
    isDashboard: r,
    isDebug: n,
    handleDragStateChange: ne,
    isEditor: t,
    isNumber: Ua,
    legend: H,
    legendId: De,
    legendRef: Q,
    lineOptions: uC,
    missingRequiredSections: xf,
    outerContainerRef: tt,
    parentRef: G,
    parseDate: Ye,
    rawData: nt.cloneDeep(A) ?? {},
    setConfig: te,
    setEditing: o,
    setParentConfig: i,
    setSharedFilter: c,
    setSharedFilterValue: s,
    svgRef: ie,
    tableData: v || b,
    transformedData: ve(v || b),
    twoColorPalette: _c,
    unfilteredData: nt.cloneDeep(A),
    updateConfig: he
  };
  return /* @__PURE__ */ a(vt.Provider, { value: Ot, children: /* @__PURE__ */ a(Qf.Provider, { value: T, children: /* @__PURE__ */ a(
    gf.VisualizationWrapper,
    {
      config: y,
      isEditor: t,
      currentViewport: E,
      ref: tt,
      imageId: j,
      showEditorPanel: y == null ? void 0 : y.showEditorPanel,
      children: st
    }
  ) }) });
}, qC = xC;
export {
  qC as C,
  MT as D,
  XC as E,
  dC as a,
  OT as b
};
