import { r as ie, R as n } from "./storybook-index-45401197.es.js";
import { v as kp, a as gg, i as wp, b as Tp, g as vg } from "./storybook-isSolr-cb863e7a.es.js";
import { _ as Jr, p as Cp, F as Li, J as qr, a as an, K as Ap, b as Rc, N as ir, t as ju, O as Qo, Q as Md, R as Lp, S as nr, U as Pp, V as xg, W as bg, l as Np, X as pr, r as rl, P as Eg, d as Sg, e as Zo, h as Rp, g as Dp, j as kg, y as wg, B as Tg, Y as Kn, q as al, Z as Ju, $ as ks, H as Cg, C as _p, m as Ag, M as xm, E as Lg, n as Pg, o as bm, L as Ng, G as Rg, D as Em, w as Sm, x as km, I as Op, A as Dg } from "./storybook-InputToggle-1920f351.es.js";
import { L as mf, u as _g, p as Og, s as Fg, a as Mg, c as zg } from "./storybook-coveUpdateWorker-2249800a.es.js";
import { B as ws } from "./storybook-Button-d74e310e.es.js";
import { p as Bg, P as je } from "./storybook-index-43433e35.es.js";
import { d as $g } from "./storybook-debounce-cc216a80.es.js";
import { a as Ig } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { P as Fp } from "./storybook-papaparse.min-b07ddc33.es.js";
import { H as Mi, T as Hg } from "./storybook-index-e5bf02db.es.js";
import { _ as En } from "./storybook-extends-70f3d2a3.es.js";
import { t as Vg, a as Dn, b as Yf, c as is, g as Pi, d as Wg, f as wm, e as ga, L as Mp, S as zp, M as zd, D as jg } from "./storybook-DataTable-c585f042.es.js";
import { E as Hr, L as Ug } from "./storybook-Loading-f180d060.es.js";
import { s as cs, t as Tm, a as Cm, b as Am, d as Ns, B as Nr, c as Vn, C as Kg } from "./storybook-Circle-f595886d.es.js";
import { q as Dc, t as Yg, u as Lm, v as Bp, w as Xg, x as qg, y as Gg, z as $p, A as Zg, G as st, g as _n, B as Qg } from "./storybook-Group-eff0b1b9.es.js";
import { R as Jg } from "./storybook-index-633d712d.es.js";
import { T as St } from "./storybook-Text-c19e6344.es.js";
import { t as Pm, m as Bd, f as Nm, d as Tu, a as Cu, b as Au, n as Ip, o as ev, p as Hp, c as Rm, e as Dm } from "./storybook-year-24bd1dc7.es.js";
import { e as ja, a as Fn, b as Mn, c as zn, d as Bn, A as zi, D as _m } from "./storybook-DataTransform-8cd95c19.es.js";
import { _ as jt } from "./storybook-lodash-a4231e1c.es.js";
import { a as tt, S as Om } from "./storybook-Icon-73ec66ec.es.js";
import { B as Vp } from "./storybook-BlurStrokeText-adc27352.es.js";
import { T as ae } from "./storybook-Tooltip-4102bd69.es.js";
import { T as Qe, S as vt, C as lt } from "./storybook-Inputs-776ab3df.es.js";
import { M as yf } from "./storybook-MultiSelect-25c4ae51.es.js";
import { e as gf, h as vf, i as tv, f as Ni, F as Wp, j as nv } from "./storybook-Filters-a07e1940.es.js";
import { I as Ua } from "./storybook-InputSelect-20478396.es.js";
import { A as Lu } from "./storybook-Accordion-f47153d9.es.js";
import { n as jp } from "./storybook-numberFromString-24623c03.es.js";
import { c as Up } from "./storybook-cacheBustingString-7a3dd9ba.es.js";
function Fm(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Kp(e) {
  let t = e, r = e;
  e.length === 1 && (t = (d, c) => e(d) - c, r = rv(e));
  function a(d, c, s, p) {
    for (s == null && (s = 0), p == null && (p = d.length); s < p; ) {
      const m = s + p >>> 1;
      r(d[m], c) < 0 ? s = m + 1 : p = m;
    }
    return s;
  }
  function i(d, c, s, p) {
    for (s == null && (s = 0), p == null && (p = d.length); s < p; ) {
      const m = s + p >>> 1;
      r(d[m], c) > 0 ? p = m : s = m + 1;
    }
    return s;
  }
  function o(d, c, s, p) {
    s == null && (s = 0), p == null && (p = d.length);
    const m = a(d, c, s, p - 1);
    return m > s && t(d[m - 1], c) > -t(d[m], c) ? m - 1 : m;
  }
  return { left: a, center: o, right: i };
}
function rv(e) {
  return (t, r) => Fm(e(t), r);
}
function* av(e, t) {
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && (yield r);
  else {
    let r = -1;
    for (let a of e)
      (a = t(a, ++r, e)) != null && (a = +a) >= a && (yield a);
  }
}
function iv(e, t) {
  let r = 0, a, i = 0, o = 0;
  if (t === void 0)
    for (let d of e)
      d != null && (d = +d) >= d && (a = d - i, i += a / ++r, o += a * (d - i));
  else {
    let d = -1;
    for (let c of e)
      (c = t(c, ++d, e)) != null && (c = +c) >= c && (a = c - i, i += a / ++r, o += a * (c - i));
  }
  if (r > 1)
    return o / (r - 1);
}
function ov(e, t) {
  const r = iv(e, t);
  return r && Math.sqrt(r);
}
function ds(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r < a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function fs(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r > a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function Mm(e, t, r = 0, a = e.length - 1, i = Fm) {
  for (; a > r; ) {
    if (a - r > 600) {
      const s = a - r + 1, p = t - r + 1, m = Math.log(s), v = 0.5 * Math.exp(2 * m / 3), g = 0.5 * Math.sqrt(m * v * (s - v) / s) * (p - s / 2 < 0 ? -1 : 1), A = Math.max(r, Math.floor(t - p * v / s + g)), k = Math.min(a, Math.floor(t + (s - p) * v / s + g));
      Mm(e, t, A, k, i);
    }
    const o = e[t];
    let d = r, c = a;
    for (os(e, r, t), i(e[a], o) > 0 && os(e, r, a); d < c; ) {
      for (os(e, d, c), ++d, --c; i(e[d], o) < 0; )
        ++d;
      for (; i(e[c], o) > 0; )
        --c;
    }
    i(e[r], o) === 0 ? os(e, r, c) : (++c, os(e, c, a)), c <= t && (r = c + 1), t <= c && (a = c - 1);
  }
  return e;
}
function os(e, t, r) {
  const a = e[t];
  e[t] = e[r], e[r] = a;
}
function lv(e, t, r) {
  if (e = Float64Array.from(av(e, r)), !!(a = e.length)) {
    if ((t = +t) <= 0 || a < 2)
      return fs(e);
    if (t >= 1)
      return ds(e);
    var a, i = (a - 1) * t, o = Math.floor(i), d = ds(Mm(e, o).subarray(0, o + 1)), c = fs(e.subarray(o + 1));
    return d + (c - d) * (i - o);
  }
}
function sv(e, t) {
  let r = 0, a = 0;
  if (t === void 0)
    for (let i of e)
      i != null && (i = +i) >= i && (++r, a += i);
  else {
    let i = -1;
    for (let o of e)
      (o = t(o, ++i, e)) != null && (o = +o) >= o && (++r, a += o);
  }
  if (r)
    return a / r;
}
function uv(e, t) {
  return lv(e, 0.5, t);
}
class Yp extends Map {
  constructor(t, r = fv) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), t != null)
      for (const [a, i] of t)
        this.set(a, i);
  }
  get(t) {
    return super.get(Xp(this, t));
  }
  has(t) {
    return super.has(Xp(this, t));
  }
  set(t, r) {
    return super.set(cv(this, t), r);
  }
  delete(t) {
    return super.delete(dv(this, t));
  }
}
function Xp({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) ? e.get(a) : r;
}
function cv({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) ? e.get(a) : (e.set(a, r), r);
}
function dv({ _intern: e, _key: t }, r) {
  const a = t(r);
  return e.has(a) && (r = e.get(a), e.delete(a)), r;
}
function fv(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function pv(e, t, r) {
  e = +e, t = +t, r = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +r;
  for (var a = -1, i = Math.max(0, Math.ceil((t - e) / r)) | 0, o = new Array(i); ++a < i; )
    o[a] = e + a * r;
  return o;
}
const qp = Symbol("implicit");
function Xf() {
  var e = new Yp(), t = [], r = [], a = qp;
  function i(o) {
    let d = e.get(o);
    if (d === void 0) {
      if (a !== qp)
        return a;
      e.set(o, d = t.push(o) - 1);
    }
    return r[d % r.length];
  }
  return i.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new Yp();
    for (const d of o)
      e.has(d) || e.set(d, t.push(d) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (r = Array.from(o), i) : r.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (a = o, i) : a;
  }, i.copy = function() {
    return Xf(t, r).unknown(a);
  }, Dc.apply(i, arguments), i;
}
function qf() {
  var e = Xf().unknown(void 0), t = e.domain, r = e.range, a = 0, i = 1, o, d, c = !1, s = 0, p = 0, m = 0.5;
  delete e.unknown;
  function v() {
    var g = t().length, A = i < a, k = A ? i : a, E = A ? a : i;
    o = (E - k) / Math.max(1, g - s + p * 2), c && (o = Math.floor(o)), k += (E - k - o * (g - s)) * m, d = o * (1 - s), c && (k = Math.round(k), d = Math.round(d));
    var T = pv(g).map(function(b) {
      return k + o * b;
    });
    return r(A ? T.reverse() : T);
  }
  return e.domain = function(g) {
    return arguments.length ? (t(g), v()) : t();
  }, e.range = function(g) {
    return arguments.length ? ([a, i] = g, a = +a, i = +i, v()) : [a, i];
  }, e.rangeRound = function(g) {
    return [a, i] = g, a = +a, i = +i, c = !0, v();
  }, e.bandwidth = function() {
    return d;
  }, e.step = function() {
    return o;
  }, e.round = function(g) {
    return arguments.length ? (c = !!g, v()) : c;
  }, e.padding = function(g) {
    return arguments.length ? (s = Math.min(1, p = +g), v()) : s;
  }, e.paddingInner = function(g) {
    return arguments.length ? (s = Math.min(1, g), v()) : s;
  }, e.paddingOuter = function(g) {
    return arguments.length ? (p = +g, v()) : p;
  }, e.align = function(g) {
    return arguments.length ? (m = Math.max(0, Math.min(1, g)), v()) : m;
  }, e.copy = function() {
    return qf(t(), [a, i]).round(c).paddingInner(s).paddingOuter(p).align(m);
  }, Dc.apply(v(), arguments);
}
function zm(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return zm(t());
  }, e;
}
function hv() {
  return zm(qf.apply(null, arguments).paddingInner(1));
}
function Bm(e, t) {
  e = e.slice();
  var r = 0, a = e.length - 1, i = e[r], o = e[a], d;
  return o < i && (d = r, r = a, a = d, d = i, i = o, o = d), e[r] = t.floor(i), e[a] = t.ceil(o), e;
}
function Gp(e) {
  return Math.log(e);
}
function Zp(e) {
  return Math.exp(e);
}
function mv(e) {
  return -Math.log(-e);
}
function yv(e) {
  return -Math.exp(-e);
}
function gv(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function vv(e) {
  return e === 10 ? gv : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function xv(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function Qp(e) {
  return (t, r) => -e(-t, r);
}
function bv(e) {
  const t = e(Gp, Zp), r = t.domain;
  let a = 10, i, o;
  function d() {
    return i = xv(a), o = vv(a), r()[0] < 0 ? (i = Qp(i), o = Qp(o), e(mv, yv)) : e(Gp, Zp), t;
  }
  return t.base = function(c) {
    return arguments.length ? (a = +c, d()) : a;
  }, t.domain = function(c) {
    return arguments.length ? (r(c), d()) : r();
  }, t.ticks = (c) => {
    const s = r();
    let p = s[0], m = s[s.length - 1];
    const v = m < p;
    v && ([p, m] = [m, p]);
    let g = i(p), A = i(m), k, E;
    const T = c == null ? 10 : +c;
    let b = [];
    if (!(a % 1) && A - g < T) {
      if (g = Math.floor(g), A = Math.ceil(A), p > 0) {
        for (; g <= A; ++g)
          for (k = 1; k < a; ++k)
            if (E = g < 0 ? k / o(-g) : k * o(g), !(E < p)) {
              if (E > m)
                break;
              b.push(E);
            }
      } else
        for (; g <= A; ++g)
          for (k = a - 1; k >= 1; --k)
            if (E = g > 0 ? k / o(-g) : k * o(g), !(E < p)) {
              if (E > m)
                break;
              b.push(E);
            }
      b.length * 2 < T && (b = Bp(p, m, T));
    } else
      b = Bp(g, A, Math.min(A - g, T)).map(o);
    return v ? b.reverse() : b;
  }, t.tickFormat = (c, s) => {
    if (c == null && (c = 10), s == null && (s = a === 10 ? "s" : ","), typeof s != "function" && (!(a % 1) && (s = Xg(s)).precision == null && (s.trim = !0), s = qg(s)), c === 1 / 0)
      return s;
    const p = Math.max(1, a * c / t.ticks().length);
    return (m) => {
      let v = m / o(Math.round(i(m)));
      return v * a < a - 0.5 && (v *= a), v <= p ? s(m) : "";
    };
  }, t.nice = () => r(Bm(r(), {
    floor: (c) => o(Math.floor(i(c))),
    ceil: (c) => o(Math.ceil(i(c)))
  })), t;
}
function $m() {
  const e = bv(Yg()).domain([1, 10]);
  return e.copy = () => Lm(e, $m()).base(e.base()), Dc.apply(e, arguments), e;
}
const ec = Pm(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
ec.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Pm((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, r) => {
  t.setTime(+t + r * e);
}, (t, r) => (r - t) / e) : ec);
ec.range;
function Ev(e, t, r, a, i, o) {
  const d = [
    [cs, 1, Tu],
    [cs, 5, 5 * Tu],
    [cs, 15, 15 * Tu],
    [cs, 30, 30 * Tu],
    [o, 1, Cu],
    [o, 5, 5 * Cu],
    [o, 15, 15 * Cu],
    [o, 30, 30 * Cu],
    [i, 1, Au],
    [i, 3, 3 * Au],
    [i, 6, 6 * Au],
    [i, 12, 12 * Au],
    [a, 1, Ip],
    [a, 2, 2 * Ip],
    [r, 1, ev],
    [t, 1, Hp],
    [t, 3, 3 * Hp],
    [e, 1, Bd]
  ];
  function c(p, m, v) {
    const g = m < p;
    g && ([p, m] = [m, p]);
    const A = v && typeof v.range == "function" ? v : s(p, m, v), k = A ? A.range(p, +m + 1) : [];
    return g ? k.reverse() : k;
  }
  function s(p, m, v) {
    const g = Math.abs(m - p) / v, A = Gg(([, , T]) => T).right(d, g);
    if (A === d.length)
      return e.every($p(p / Bd, m / Bd, v));
    if (A === 0)
      return ec.every(Math.max($p(p, m, v), 1));
    const [k, E] = d[g / d[A - 1][2] < d[A][2] / g ? A - 1 : A];
    return k.every(E);
  }
  return [c, s];
}
const [Sv, kv] = Ev(Nm, Am, Dm, Rm, Cm, Tm);
function wv(e) {
  return new Date(e);
}
function Tv(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Im(e, t, r, a, i, o, d, c, s, p) {
  var m = Zg(), v = m.invert, g = m.domain, A = p(".%L"), k = p(":%S"), E = p("%I:%M"), T = p("%I %p"), b = p("%a %d"), y = p("%b %d"), N = p("%B"), C = p("%Y");
  function P(O) {
    return (s(O) < O ? A : c(O) < O ? k : d(O) < O ? E : o(O) < O ? T : a(O) < O ? i(O) < O ? b : y : r(O) < O ? N : C)(O);
  }
  return m.invert = function(O) {
    return new Date(v(O));
  }, m.domain = function(O) {
    return arguments.length ? g(Array.from(O, Tv)) : g().map(wv);
  }, m.ticks = function(O) {
    var K = g();
    return e(K[0], K[K.length - 1], O ?? 10);
  }, m.tickFormat = function(O, K) {
    return K == null ? P : p(K);
  }, m.nice = function(O) {
    var K = g();
    return (!O || typeof O.range != "function") && (O = t(K[0], K[K.length - 1], O ?? 10)), O ? g(Bm(K, O)) : m;
  }, m.copy = function() {
    return Lm(m, Im(e, t, r, a, i, o, d, c, s, p));
  }, m;
}
function Hm() {
  return Dc.apply(Im(Sv, kv, Nm, Am, Dm, Rm, Cm, Tm, cs, Vg).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var Cv = Ns("domain", "range", "reverse", "align", "padding", "round");
function tc(e) {
  return Cv(qf(), e);
}
var Av = Ns("domain", "range", "reverse", "align", "padding", "round");
function Jo(e) {
  return Av(hv(), e);
}
var Lv = Ns("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function Pv(e) {
  return Lv(Hm(), e);
}
var Nv = Ns("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function nc(e) {
  return Nv($m(), e);
}
var Rv = Ns("domain", "range", "reverse", "unknown");
function Bi(e) {
  return Rv(Xf(), e);
}
function Dv(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function _v(e, t) {
  var r = e;
  return "ticks" in r ? r.ticks(t) : r.domain().filter(function(a, i, o) {
    return t == null || o.length <= t || i % Math.round((o.length - 1) / t) === 0;
  });
}
function Ov(e) {
  return e == null ? void 0 : e.toString();
}
var $i = [], Fv = function() {
  return $i.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Mv = function() {
  return $i.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, Jp = "ResizeObserver loop completed with undelivered notifications.", zv = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: Jp
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = Jp), window.dispatchEvent(e);
}, Ts;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Ts || (Ts = {}));
var Ii = function(e) {
  return Object.freeze(e);
}, Vm = function() {
  function e(t, r) {
    this.inlineSize = t, this.blockSize = r, Ii(this);
  }
  return e;
}(), Wm = function() {
  function e(t, r, a, i) {
    return this.x = t, this.y = r, this.width = a, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Ii(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, r = t.x, a = t.y, i = t.top, o = t.right, d = t.bottom, c = t.left, s = t.width, p = t.height;
    return { x: r, y: a, top: i, right: o, bottom: d, left: c, width: s, height: p };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Gf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, jm = function(e) {
  if (Gf(e)) {
    var t = e.getBBox(), r = t.width, a = t.height;
    return !r && !a;
  }
  var i = e, o = i.offsetWidth, d = i.offsetHeight;
  return !(o || d || e.getClientRects().length);
}, eh = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var r = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(r && e instanceof r.Element);
}, Bv = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ps = typeof window < "u" ? window : {}, Pu = /* @__PURE__ */ new WeakMap(), th = /auto|scroll/, $v = /^tb|vertical/, Iv = /msie|trident/i.test(ps.navigator && ps.navigator.userAgent), Gr = function(e) {
  return parseFloat(e || "0");
}, tl = function(e, t, r) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), r === void 0 && (r = !1), new Vm((r ? t : e) || 0, (r ? e : t) || 0);
}, nh = Ii({
  devicePixelContentBoxSize: tl(),
  borderBoxSize: tl(),
  contentBoxSize: tl(),
  contentRect: new Wm(0, 0, 0, 0)
}), Um = function(e, t) {
  if (t === void 0 && (t = !1), Pu.has(e) && !t)
    return Pu.get(e);
  if (jm(e))
    return Pu.set(e, nh), nh;
  var r = getComputedStyle(e), a = Gf(e) && e.ownerSVGElement && e.getBBox(), i = !Iv && r.boxSizing === "border-box", o = $v.test(r.writingMode || ""), d = !a && th.test(r.overflowY || ""), c = !a && th.test(r.overflowX || ""), s = a ? 0 : Gr(r.paddingTop), p = a ? 0 : Gr(r.paddingRight), m = a ? 0 : Gr(r.paddingBottom), v = a ? 0 : Gr(r.paddingLeft), g = a ? 0 : Gr(r.borderTopWidth), A = a ? 0 : Gr(r.borderRightWidth), k = a ? 0 : Gr(r.borderBottomWidth), E = a ? 0 : Gr(r.borderLeftWidth), T = v + p, b = s + m, y = E + A, N = g + k, C = c ? e.offsetHeight - N - e.clientHeight : 0, P = d ? e.offsetWidth - y - e.clientWidth : 0, O = i ? T + y : 0, K = i ? b + N : 0, W = a ? a.width : Gr(r.width) - O - P, J = a ? a.height : Gr(r.height) - K - C, j = W + T + P + y, B = J + b + C + N, Z = Ii({
    devicePixelContentBoxSize: tl(Math.round(W * devicePixelRatio), Math.round(J * devicePixelRatio), o),
    borderBoxSize: tl(j, B, o),
    contentBoxSize: tl(W, J, o),
    contentRect: new Wm(v, s, W, J)
  });
  return Pu.set(e, Z), Z;
}, Km = function(e, t, r) {
  var a = Um(e, r), i = a.borderBoxSize, o = a.contentBoxSize, d = a.devicePixelContentBoxSize;
  switch (t) {
    case Ts.DEVICE_PIXEL_CONTENT_BOX:
      return d;
    case Ts.BORDER_BOX:
      return i;
    default:
      return o;
  }
}, Ym = function() {
  function e(t) {
    var r = Um(t);
    this.target = t, this.contentRect = r.contentRect, this.borderBoxSize = Ii([r.borderBoxSize]), this.contentBoxSize = Ii([r.contentBoxSize]), this.devicePixelContentBoxSize = Ii([r.devicePixelContentBoxSize]);
  }
  return e;
}(), Xm = function(e) {
  if (jm(e))
    return 1 / 0;
  for (var t = 0, r = e.parentNode; r; )
    t += 1, r = r.parentNode;
  return t;
}, Hv = function() {
  var e = 1 / 0, t = [];
  $i.forEach(function(d) {
    if (d.activeTargets.length !== 0) {
      var c = [];
      d.activeTargets.forEach(function(p) {
        var m = new Ym(p.target), v = Xm(p.target);
        c.push(m), p.lastReportedSize = Km(p.target, p.observedBox), v < e && (e = v);
      }), t.push(function() {
        d.callback.call(d.observer, c, d.observer);
      }), d.activeTargets.splice(0, d.activeTargets.length);
    }
  });
  for (var r = 0, a = t; r < a.length; r++) {
    var i = a[r];
    i();
  }
  return e;
}, rh = function(e) {
  $i.forEach(function(r) {
    r.activeTargets.splice(0, r.activeTargets.length), r.skippedTargets.splice(0, r.skippedTargets.length), r.observationTargets.forEach(function(i) {
      i.isActive() && (Xm(i.target) > e ? r.activeTargets.push(i) : r.skippedTargets.push(i));
    });
  });
}, Vv = function() {
  var e = 0;
  for (rh(e); Fv(); )
    e = Hv(), rh(e);
  return Mv() && zv(), e > 0;
}, $d, qm = [], Wv = function() {
  return qm.splice(0).forEach(function(e) {
    return e();
  });
}, jv = function(e) {
  if (!$d) {
    var t = 0, r = document.createTextNode(""), a = { characterData: !0 };
    new MutationObserver(function() {
      return Wv();
    }).observe(r, a), $d = function() {
      r.textContent = "".concat(t ? t-- : t++);
    };
  }
  qm.push(e), $d();
}, Uv = function(e) {
  jv(function() {
    requestAnimationFrame(e);
  });
}, Uu = 0, Kv = function() {
  return !!Uu;
}, Yv = 250, Xv = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, ah = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], ih = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Id = !1, qv = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var r = this;
    if (t === void 0 && (t = Yv), !Id) {
      Id = !0;
      var a = ih(t);
      Uv(function() {
        var i = !1;
        try {
          i = Vv();
        } finally {
          if (Id = !1, t = a - ih(), !Kv())
            return;
          i ? r.run(1e3) : t > 0 ? r.run(t) : r.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, r = function() {
      return t.observer && t.observer.observe(document.body, Xv);
    };
    document.body ? r() : ps.addEventListener("DOMContentLoaded", r);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), ah.forEach(function(r) {
      return ps.addEventListener(r, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), ah.forEach(function(r) {
      return ps.removeEventListener(r, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), xf = new qv(), oh = function(e) {
  !Uu && e > 0 && xf.start(), Uu += e, !Uu && xf.stop();
}, Gv = function(e) {
  return !Gf(e) && !Bv(e) && getComputedStyle(e).display === "inline";
}, Zv = function() {
  function e(t, r) {
    this.target = t, this.observedBox = r || Ts.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Km(this.target, this.observedBox, !0);
    return Gv(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Qv = function() {
  function e(t, r) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = r;
  }
  return e;
}(), Nu = /* @__PURE__ */ new WeakMap(), lh = function(e, t) {
  for (var r = 0; r < e.length; r += 1)
    if (e[r].target === t)
      return r;
  return -1;
}, Ru = function() {
  function e() {
  }
  return e.connect = function(t, r) {
    var a = new Qv(t, r);
    Nu.set(t, a);
  }, e.observe = function(t, r, a) {
    var i = Nu.get(t), o = i.observationTargets.length === 0;
    lh(i.observationTargets, r) < 0 && (o && $i.push(i), i.observationTargets.push(new Zv(r, a && a.box)), oh(1), xf.schedule());
  }, e.unobserve = function(t, r) {
    var a = Nu.get(t), i = lh(a.observationTargets, r), o = a.observationTargets.length === 1;
    i >= 0 && (o && $i.splice($i.indexOf(a), 1), a.observationTargets.splice(i, 1), oh(-1));
  }, e.disconnect = function(t) {
    var r = this, a = Nu.get(t);
    a.observationTargets.slice().forEach(function(i) {
      return r.unobserve(t, i.target);
    }), a.activeTargets.splice(0, a.activeTargets.length);
  }, e;
}(), Jv = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Ru.connect(this, t);
  }
  return e.prototype.observe = function(t, r) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!eh(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Ru.observe(this, t, r);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!eh(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Ru.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Ru.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const ex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: Jv,
  ResizeObserverEntry: Ym,
  ResizeObserverSize: Vm
}, Symbol.toStringTag, { value: "Module" })), tx = /* @__PURE__ */ Ig(ex);
var Uo = Qm, $a = Zm(Bg), nx = Zm($g), Ko = ix(ie), rx = tx, ax = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function Gm(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (Gm = function(i) {
    return i ? r : t;
  })(e);
}
function ix(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var r = Gm(t);
  if (r && r.has(e))
    return r.get(e);
  var a = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var d = i ? Object.getOwnPropertyDescriptor(e, o) : null;
      d && (d.get || d.set) ? Object.defineProperty(a, o, d) : a[o] = e[o];
    }
  return a.default = e, r && r.set(e, a), a;
}
function Zm(e) {
  return e && e.__esModule ? e : { default: e };
}
function rc() {
  return rc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, rc.apply(this, arguments);
}
function ox(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var lx = [];
function Qm(e) {
  var t = e.className, r = e.children, a = e.debounceTime, i = a === void 0 ? 300 : a, o = e.ignoreDimensions, d = o === void 0 ? lx : o, c = e.parentSizeStyles, s = c === void 0 ? {
    width: "100%",
    height: "100%"
  } : c, p = e.enableDebounceLeadingCall, m = p === void 0 ? !0 : p, v = ox(e, ax), g = (0, Ko.useRef)(null), A = (0, Ko.useRef)(0), k = (0, Ko.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), E = k[0], T = k[1], b = (0, Ko.useMemo)(function() {
    var y = Array.isArray(d) ? d : [d];
    return (0, nx.default)(function(N) {
      T(function(C) {
        var P = Object.keys(C), O = P.filter(function(W) {
          return C[W] !== N[W];
        }), K = O.every(function(W) {
          return y.includes(W);
        });
        return K ? C : N;
      });
    }, i, {
      leading: m
    });
  }, [i, m, d]);
  return (0, Ko.useEffect)(function() {
    var y = new rx.ResizeObserver(function(N) {
      N === void 0 && (N = []), N.forEach(function(C) {
        var P = C.contentRect, O = P.left, K = P.top, W = P.width, J = P.height;
        A.current = window.requestAnimationFrame(function() {
          b({
            width: W,
            height: J,
            top: K,
            left: O
          });
        });
      });
    });
    return g.current && y.observe(g.current), function() {
      window.cancelAnimationFrame(A.current), y.disconnect(), b != null && b.cancel && b.cancel();
    };
  }, [b]), /* @__PURE__ */ Ko.default.createElement("div", rc({
    style: s,
    ref: g,
    className: t
  }, v), r(rc({}, E, {
    ref: g.current,
    resize: b
  })));
}
Qm.propTypes = {
  className: $a.default.string,
  debounceTime: $a.default.number,
  enableDebounceLeadingCall: $a.default.bool,
  ignoreDimensions: $a.default.oneOfType([$a.default.any, $a.default.arrayOf($a.default.any)]),
  children: $a.default.func.isRequired
};
var Hd = /* @__PURE__ */ new Date(), Vd = /* @__PURE__ */ new Date();
function va(e, t, r, a) {
  function i(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return i.floor = function(o) {
    return e(o = /* @__PURE__ */ new Date(+o)), o;
  }, i.ceil = function(o) {
    return e(o = new Date(o - 1)), t(o, 1), e(o), o;
  }, i.round = function(o) {
    var d = i(o), c = i.ceil(o);
    return o - d < c - o ? d : c;
  }, i.offset = function(o, d) {
    return t(o = /* @__PURE__ */ new Date(+o), d == null ? 1 : Math.floor(d)), o;
  }, i.range = function(o, d, c) {
    var s = [], p;
    if (o = i.ceil(o), c = c == null ? 1 : Math.floor(c), !(o < d) || !(c > 0))
      return s;
    do
      s.push(p = /* @__PURE__ */ new Date(+o)), t(o, c), e(o);
    while (p < o && o < d);
    return s;
  }, i.filter = function(o) {
    return va(function(d) {
      if (d >= d)
        for (; e(d), !o(d); )
          d.setTime(d - 1);
    }, function(d, c) {
      if (d >= d)
        if (c < 0)
          for (; ++c <= 0; )
            for (; t(d, -1), !o(d); )
              ;
        else
          for (; --c >= 0; )
            for (; t(d, 1), !o(d); )
              ;
    });
  }, r && (i.count = function(o, d) {
    return Hd.setTime(+o), Vd.setTime(+d), e(Hd), e(Vd), Math.floor(r(Hd, Vd));
  }, i.every = function(o) {
    return o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(a ? function(d) {
      return a(d) % o === 0;
    } : function(d) {
      return i.count(0, d) % o === 0;
    }) : i;
  }), i;
}
const sx = 1e3, Zf = sx * 60, ux = Zf * 60, Qf = ux * 24, Jm = Qf * 7;
var ey = va(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Zf) / Qf,
  (e) => e.getDate() - 1
);
const ty = ey;
ey.range;
function Ui(e) {
  return va(function(t) {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setDate(t.getDate() + r * 7);
  }, function(t, r) {
    return (r - t - (r.getTimezoneOffset() - t.getTimezoneOffset()) * Zf) / Jm;
  });
}
var ny = Ui(0), ac = Ui(1), cx = Ui(2), dx = Ui(3), il = Ui(4), fx = Ui(5), px = Ui(6);
ny.range;
ac.range;
cx.range;
dx.range;
il.range;
fx.range;
px.range;
var Jf = va(function(e) {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setFullYear(e.getFullYear() + t);
}, function(e, t) {
  return t.getFullYear() - e.getFullYear();
}, function(e) {
  return e.getFullYear();
});
Jf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : va(function(t) {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setFullYear(t.getFullYear() + r * e);
  });
};
const Cs = Jf;
Jf.range;
var ry = va(function(e) {
  e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCDate(e.getUTCDate() + t);
}, function(e, t) {
  return (t - e) / Qf;
}, function(e) {
  return e.getUTCDate() - 1;
});
const ay = ry;
ry.range;
function Ki(e) {
  return va(function(t) {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setUTCDate(t.getUTCDate() + r * 7);
  }, function(t, r) {
    return (r - t) / Jm;
  });
}
var iy = Ki(0), ic = Ki(1), hx = Ki(2), mx = Ki(3), ol = Ki(4), yx = Ki(5), gx = Ki(6);
iy.range;
ic.range;
hx.range;
mx.range;
ol.range;
yx.range;
gx.range;
var ep = va(function(e) {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, function(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}, function(e) {
  return e.getUTCFullYear();
});
ep.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : va(function(t) {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function(t, r) {
    t.setUTCFullYear(t.getUTCFullYear() + r * e);
  });
};
const As = ep;
ep.range;
function Wd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function jd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function ls(e, t, r) {
  return { y: e, m: t, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function vx(e) {
  var t = e.dateTime, r = e.date, a = e.time, i = e.periods, o = e.days, d = e.shortDays, c = e.months, s = e.shortMonths, p = ss(i), m = us(i), v = ss(o), g = us(o), A = ss(d), k = us(d), E = ss(c), T = us(c), b = ss(s), y = us(s), N = {
    a: re,
    A: G,
    b: U,
    B: q,
    c: null,
    d: ph,
    e: ph,
    f: Hx,
    g: Zx,
    G: Jx,
    H: Bx,
    I: $x,
    j: Ix,
    L: oy,
    m: Vx,
    M: Wx,
    p: H,
    q: oe,
    Q: yh,
    s: gh,
    S: jx,
    u: Ux,
    U: Kx,
    V: Yx,
    w: Xx,
    W: qx,
    x: null,
    X: null,
    y: Gx,
    Y: Qx,
    Z: eb,
    "%": mh
  }, C = {
    a: ue,
    A: ke,
    b: De,
    B: pe,
    c: null,
    d: hh,
    e: hh,
    f: ab,
    g: hb,
    G: yb,
    H: tb,
    I: nb,
    j: rb,
    L: sy,
    m: ib,
    M: ob,
    p: Be,
    q: qe,
    Q: yh,
    s: gh,
    S: lb,
    u: sb,
    U: ub,
    V: cb,
    w: db,
    W: fb,
    x: null,
    X: null,
    y: pb,
    Y: mb,
    Z: gb,
    "%": mh
  }, P = {
    a: j,
    A: B,
    b: Z,
    B: te,
    c: V,
    d: dh,
    e: dh,
    f: Ox,
    g: ch,
    G: uh,
    H: fh,
    I: fh,
    j: Nx,
    L: _x,
    m: Px,
    M: Rx,
    p: J,
    q: Lx,
    Q: Mx,
    s: zx,
    S: Dx,
    u: kx,
    U: wx,
    V: Tx,
    w: Sx,
    W: Cx,
    x: ee,
    X: ce,
    y: ch,
    Y: uh,
    Z: Ax,
    "%": Fx
  };
  N.x = O(r, N), N.X = O(a, N), N.c = O(t, N), C.x = O(r, C), C.X = O(a, C), C.c = O(t, C);
  function O(Pe, ve) {
    return function($e) {
      var z = [], Re = -1, be = 0, He = Pe.length, Ve, Oe, Ge;
      for ($e instanceof Date || ($e = /* @__PURE__ */ new Date(+$e)); ++Re < He; )
        Pe.charCodeAt(Re) === 37 && (z.push(Pe.slice(be, Re)), (Oe = sh[Ve = Pe.charAt(++Re)]) != null ? Ve = Pe.charAt(++Re) : Oe = Ve === "e" ? " " : "0", (Ge = ve[Ve]) && (Ve = Ge($e, Oe)), z.push(Ve), be = Re + 1);
      return z.push(Pe.slice(be, Re)), z.join("");
    };
  }
  function K(Pe, ve) {
    return function($e) {
      var z = ls(1900, void 0, 1), Re = W(z, Pe, $e += "", 0), be, He;
      if (Re != $e.length)
        return null;
      if ("Q" in z)
        return new Date(z.Q);
      if ("s" in z)
        return new Date(z.s * 1e3 + ("L" in z ? z.L : 0));
      if (ve && !("Z" in z) && (z.Z = 0), "p" in z && (z.H = z.H % 12 + z.p * 12), z.m === void 0 && (z.m = "q" in z ? z.q : 0), "V" in z) {
        if (z.V < 1 || z.V > 53)
          return null;
        "w" in z || (z.w = 1), "Z" in z ? (be = jd(ls(z.y, 0, 1)), He = be.getUTCDay(), be = He > 4 || He === 0 ? ic.ceil(be) : ic(be), be = ay.offset(be, (z.V - 1) * 7), z.y = be.getUTCFullYear(), z.m = be.getUTCMonth(), z.d = be.getUTCDate() + (z.w + 6) % 7) : (be = Wd(ls(z.y, 0, 1)), He = be.getDay(), be = He > 4 || He === 0 ? ac.ceil(be) : ac(be), be = ty.offset(be, (z.V - 1) * 7), z.y = be.getFullYear(), z.m = be.getMonth(), z.d = be.getDate() + (z.w + 6) % 7);
      } else
        ("W" in z || "U" in z) && ("w" in z || (z.w = "u" in z ? z.u % 7 : "W" in z ? 1 : 0), He = "Z" in z ? jd(ls(z.y, 0, 1)).getUTCDay() : Wd(ls(z.y, 0, 1)).getDay(), z.m = 0, z.d = "W" in z ? (z.w + 6) % 7 + z.W * 7 - (He + 5) % 7 : z.w + z.U * 7 - (He + 6) % 7);
      return "Z" in z ? (z.H += z.Z / 100 | 0, z.M += z.Z % 100, jd(z)) : Wd(z);
    };
  }
  function W(Pe, ve, $e, z) {
    for (var Re = 0, be = ve.length, He = $e.length, Ve, Oe; Re < be; ) {
      if (z >= He)
        return -1;
      if (Ve = ve.charCodeAt(Re++), Ve === 37) {
        if (Ve = ve.charAt(Re++), Oe = P[Ve in sh ? ve.charAt(Re++) : Ve], !Oe || (z = Oe(Pe, $e, z)) < 0)
          return -1;
      } else if (Ve != $e.charCodeAt(z++))
        return -1;
    }
    return z;
  }
  function J(Pe, ve, $e) {
    var z = p.exec(ve.slice($e));
    return z ? (Pe.p = m.get(z[0].toLowerCase()), $e + z[0].length) : -1;
  }
  function j(Pe, ve, $e) {
    var z = A.exec(ve.slice($e));
    return z ? (Pe.w = k.get(z[0].toLowerCase()), $e + z[0].length) : -1;
  }
  function B(Pe, ve, $e) {
    var z = v.exec(ve.slice($e));
    return z ? (Pe.w = g.get(z[0].toLowerCase()), $e + z[0].length) : -1;
  }
  function Z(Pe, ve, $e) {
    var z = b.exec(ve.slice($e));
    return z ? (Pe.m = y.get(z[0].toLowerCase()), $e + z[0].length) : -1;
  }
  function te(Pe, ve, $e) {
    var z = E.exec(ve.slice($e));
    return z ? (Pe.m = T.get(z[0].toLowerCase()), $e + z[0].length) : -1;
  }
  function V(Pe, ve, $e) {
    return W(Pe, t, ve, $e);
  }
  function ee(Pe, ve, $e) {
    return W(Pe, r, ve, $e);
  }
  function ce(Pe, ve, $e) {
    return W(Pe, a, ve, $e);
  }
  function re(Pe) {
    return d[Pe.getDay()];
  }
  function G(Pe) {
    return o[Pe.getDay()];
  }
  function U(Pe) {
    return s[Pe.getMonth()];
  }
  function q(Pe) {
    return c[Pe.getMonth()];
  }
  function H(Pe) {
    return i[+(Pe.getHours() >= 12)];
  }
  function oe(Pe) {
    return 1 + ~~(Pe.getMonth() / 3);
  }
  function ue(Pe) {
    return d[Pe.getUTCDay()];
  }
  function ke(Pe) {
    return o[Pe.getUTCDay()];
  }
  function De(Pe) {
    return s[Pe.getUTCMonth()];
  }
  function pe(Pe) {
    return c[Pe.getUTCMonth()];
  }
  function Be(Pe) {
    return i[+(Pe.getUTCHours() >= 12)];
  }
  function qe(Pe) {
    return 1 + ~~(Pe.getUTCMonth() / 3);
  }
  return {
    format: function(Pe) {
      var ve = O(Pe += "", N);
      return ve.toString = function() {
        return Pe;
      }, ve;
    },
    parse: function(Pe) {
      var ve = K(Pe += "", !1);
      return ve.toString = function() {
        return Pe;
      }, ve;
    },
    utcFormat: function(Pe) {
      var ve = O(Pe += "", C);
      return ve.toString = function() {
        return Pe;
      }, ve;
    },
    utcParse: function(Pe) {
      var ve = K(Pe += "", !0);
      return ve.toString = function() {
        return Pe;
      }, ve;
    }
  };
}
var sh = { "-": "", _: " ", 0: "0" }, Yn = /^\s*\d+/, xx = /^%/, bx = /[\\^$*+?|[\]().{}]/g;
function sn(e, t, r) {
  var a = e < 0 ? "-" : "", i = (a ? -e : e) + "", o = i.length;
  return a + (o < r ? new Array(r - o + 1).join(t) + i : i);
}
function Ex(e) {
  return e.replace(bx, "\\$&");
}
function ss(e) {
  return new RegExp("^(?:" + e.map(Ex).join("|") + ")", "i");
}
function us(e) {
  return new Map(e.map((t, r) => [t.toLowerCase(), r]));
}
function Sx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 1));
  return a ? (e.w = +a[0], r + a[0].length) : -1;
}
function kx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 1));
  return a ? (e.u = +a[0], r + a[0].length) : -1;
}
function wx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.U = +a[0], r + a[0].length) : -1;
}
function Tx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.V = +a[0], r + a[0].length) : -1;
}
function Cx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.W = +a[0], r + a[0].length) : -1;
}
function uh(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 4));
  return a ? (e.y = +a[0], r + a[0].length) : -1;
}
function ch(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), r + a[0].length) : -1;
}
function Ax(e, t, r) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(r, r + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), r + a[0].length) : -1;
}
function Lx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 1));
  return a ? (e.q = a[0] * 3 - 3, r + a[0].length) : -1;
}
function Px(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.m = a[0] - 1, r + a[0].length) : -1;
}
function dh(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.d = +a[0], r + a[0].length) : -1;
}
function Nx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 3));
  return a ? (e.m = 0, e.d = +a[0], r + a[0].length) : -1;
}
function fh(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.H = +a[0], r + a[0].length) : -1;
}
function Rx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.M = +a[0], r + a[0].length) : -1;
}
function Dx(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 2));
  return a ? (e.S = +a[0], r + a[0].length) : -1;
}
function _x(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 3));
  return a ? (e.L = +a[0], r + a[0].length) : -1;
}
function Ox(e, t, r) {
  var a = Yn.exec(t.slice(r, r + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), r + a[0].length) : -1;
}
function Fx(e, t, r) {
  var a = xx.exec(t.slice(r, r + 1));
  return a ? r + a[0].length : -1;
}
function Mx(e, t, r) {
  var a = Yn.exec(t.slice(r));
  return a ? (e.Q = +a[0], r + a[0].length) : -1;
}
function zx(e, t, r) {
  var a = Yn.exec(t.slice(r));
  return a ? (e.s = +a[0], r + a[0].length) : -1;
}
function ph(e, t) {
  return sn(e.getDate(), t, 2);
}
function Bx(e, t) {
  return sn(e.getHours(), t, 2);
}
function $x(e, t) {
  return sn(e.getHours() % 12 || 12, t, 2);
}
function Ix(e, t) {
  return sn(1 + ty.count(Cs(e), e), t, 3);
}
function oy(e, t) {
  return sn(e.getMilliseconds(), t, 3);
}
function Hx(e, t) {
  return oy(e, t) + "000";
}
function Vx(e, t) {
  return sn(e.getMonth() + 1, t, 2);
}
function Wx(e, t) {
  return sn(e.getMinutes(), t, 2);
}
function jx(e, t) {
  return sn(e.getSeconds(), t, 2);
}
function Ux(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function Kx(e, t) {
  return sn(ny.count(Cs(e) - 1, e), t, 2);
}
function ly(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? il(e) : il.ceil(e);
}
function Yx(e, t) {
  return e = ly(e), sn(il.count(Cs(e), e) + (Cs(e).getDay() === 4), t, 2);
}
function Xx(e) {
  return e.getDay();
}
function qx(e, t) {
  return sn(ac.count(Cs(e) - 1, e), t, 2);
}
function Gx(e, t) {
  return sn(e.getFullYear() % 100, t, 2);
}
function Zx(e, t) {
  return e = ly(e), sn(e.getFullYear() % 100, t, 2);
}
function Qx(e, t) {
  return sn(e.getFullYear() % 1e4, t, 4);
}
function Jx(e, t) {
  var r = e.getDay();
  return e = r >= 4 || r === 0 ? il(e) : il.ceil(e), sn(e.getFullYear() % 1e4, t, 4);
}
function eb(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + sn(t / 60 | 0, "0", 2) + sn(t % 60, "0", 2);
}
function hh(e, t) {
  return sn(e.getUTCDate(), t, 2);
}
function tb(e, t) {
  return sn(e.getUTCHours(), t, 2);
}
function nb(e, t) {
  return sn(e.getUTCHours() % 12 || 12, t, 2);
}
function rb(e, t) {
  return sn(1 + ay.count(As(e), e), t, 3);
}
function sy(e, t) {
  return sn(e.getUTCMilliseconds(), t, 3);
}
function ab(e, t) {
  return sy(e, t) + "000";
}
function ib(e, t) {
  return sn(e.getUTCMonth() + 1, t, 2);
}
function ob(e, t) {
  return sn(e.getUTCMinutes(), t, 2);
}
function lb(e, t) {
  return sn(e.getUTCSeconds(), t, 2);
}
function sb(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function ub(e, t) {
  return sn(iy.count(As(e) - 1, e), t, 2);
}
function uy(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? ol(e) : ol.ceil(e);
}
function cb(e, t) {
  return e = uy(e), sn(ol.count(As(e), e) + (As(e).getUTCDay() === 4), t, 2);
}
function db(e) {
  return e.getUTCDay();
}
function fb(e, t) {
  return sn(ic.count(As(e) - 1, e), t, 2);
}
function pb(e, t) {
  return sn(e.getUTCFullYear() % 100, t, 2);
}
function hb(e, t) {
  return e = uy(e), sn(e.getUTCFullYear() % 100, t, 2);
}
function mb(e, t) {
  return sn(e.getUTCFullYear() % 1e4, t, 4);
}
function yb(e, t) {
  var r = e.getUTCDay();
  return e = r >= 4 || r === 0 ? ol(e) : ol.ceil(e), sn(e.getUTCFullYear() % 1e4, t, 4);
}
function gb() {
  return "+0000";
}
function mh() {
  return "%";
}
function yh(e) {
  return +e;
}
function gh(e) {
  return Math.floor(+e / 1e3);
}
var Yo, Ku, cy;
vb({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function vb(e) {
  return Yo = vx(e), Ku = Yo.format, cy = Yo.parse, Yo.utcFormat, Yo.utcParse, Yo;
}
const Et = ie.createContext({}), en = {
  arr: Array.isArray,
  obj: (e) => Object.prototype.toString.call(e) === "[object Object]",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0,
  nul: (e) => e === null,
  set: (e) => e instanceof Set,
  map: (e) => e instanceof Map,
  equ(e, t) {
    if (typeof e != typeof t)
      return !1;
    if (en.str(e) || en.num(e))
      return e === t;
    if (en.obj(e) && en.obj(t) && Object.keys(e).length + Object.keys(t).length === 0)
      return !0;
    let r;
    for (r in e)
      if (!(r in t))
        return !1;
    for (r in t)
      if (e[r] !== t[r])
        return !1;
    return en.und(r) ? e === t : !0;
  }
};
function xb(e, t) {
  return t === void 0 && (t = !0), (r) => (en.arr(r) ? r : Object.keys(r)).reduce((a, i) => {
    const o = t ? i[0].toLowerCase() + i.substring(1) : i;
    return a[o] = e(o), a;
  }, e);
}
function dy() {
  const e = ie.useState(!1), t = e[1];
  return ie.useCallback(() => t((a) => !a), []);
}
function Ri(e, t) {
  return en.und(e) || en.nul(e) ? t : e;
}
function el(e) {
  return en.und(e) ? [] : en.arr(e) ? e : [e];
}
function zr(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    r[a - 1] = arguments[a];
  return en.fun(e) ? e(...r) : e;
}
function bb(e) {
  return e.to, e.from, e.config, e.onStart, e.onRest, e.onFrame, e.children, e.reset, e.reverse, e.force, e.immediate, e.delay, e.attach, e.destroyed, e.interpolateTo, e.ref, e.lazy, Jr(e, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
}
function Ud(e) {
  const t = bb(e);
  if (en.und(t))
    return En({
      to: t
    }, e);
  const r = Object.keys(e).reduce((a, i) => en.und(t[i]) ? En({}, a, {
    [i]: e[i]
  }) : a, {});
  return En({
    to: t
  }, r);
}
function Eb(e, t) {
  return t && (en.fun(t) ? t(e) : en.obj(t) && (t.current = e)), e;
}
class Br {
  constructor() {
    this.payload = void 0, this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(t) {
    this.children.length === 0 && this.attach(), this.children.push(t);
  }
  removeChild(t) {
    const r = this.children.indexOf(t);
    this.children.splice(r, 1), this.children.length === 0 && this.detach();
  }
}
class bf extends Br {
  constructor() {
    super(...arguments), this.payload = [], this.attach = () => this.payload.forEach((t) => t instanceof Br && t.addChild(this)), this.detach = () => this.payload.forEach((t) => t instanceof Br && t.removeChild(this));
  }
}
class fy extends Br {
  constructor() {
    super(...arguments), this.payload = {}, this.attach = () => Object.values(this.payload).forEach((t) => t instanceof Br && t.addChild(this)), this.detach = () => Object.values(this.payload).forEach((t) => t instanceof Br && t.removeChild(this));
  }
  getValue(t) {
    t === void 0 && (t = !1);
    const r = {};
    for (const a in this.payload) {
      const i = this.payload[a];
      t && !(i instanceof Br) || (r[a] = i instanceof Br ? i[t ? "getAnimatedValue" : "getValue"]() : i);
    }
    return r;
  }
  getAnimatedValue() {
    return this.getValue(!0);
  }
}
let tp;
function Sb(e, t) {
  tp = {
    fn: e,
    transform: t
  };
}
let py;
function kb(e) {
  py = e;
}
let hy = (e) => typeof window < "u" ? window.requestAnimationFrame(e) : -1, oc;
function wb(e) {
  oc = e;
}
let my = () => Date.now(), Tb = (e) => e.current, yy;
function Cb(e) {
  yy = e;
}
class Ab extends fy {
  constructor(t, r) {
    super(), this.update = void 0, this.payload = t.style ? En({}, t, {
      style: yy(t.style)
    }) : t, this.update = r, this.attach();
  }
}
const Lb = (e) => en.fun(e) && !(e.prototype instanceof n.Component), Pb = (e) => ie.forwardRef((r, a) => {
  const i = dy(), o = ie.useRef(!0), d = ie.useRef(null), c = ie.useRef(null), s = ie.useCallback((g) => {
    const A = d.current, k = () => {
      let E = !1;
      c.current && (E = tp.fn(c.current, d.current.getAnimatedValue())), (!c.current || E === !1) && i();
    };
    d.current = new Ab(g, k), A && A.detach();
  }, []);
  ie.useEffect(() => () => {
    o.current = !1, d.current && d.current.detach();
  }, []), ie.useImperativeHandle(a, () => Tb(c)), s(r);
  const p = d.current.getValue();
  p.scrollTop, p.scrollLeft;
  const m = Jr(p, ["scrollTop", "scrollLeft"]), v = Lb(e) ? void 0 : (g) => c.current = Eb(g, a);
  return n.createElement(e, En({}, m, {
    ref: v
  }));
});
let hs = !1;
const Hi = /* @__PURE__ */ new Set(), gy = () => {
  if (!hs)
    return !1;
  let e = my();
  for (let t of Hi) {
    let r = !1;
    for (let a = 0; a < t.configs.length; a++) {
      let i = t.configs[a], o, d;
      for (let c = 0; c < i.animatedValues.length; c++) {
        let s = i.animatedValues[c];
        if (s.done)
          continue;
        let p = i.fromValues[c], m = i.toValues[c], v = s.lastPosition, g = m instanceof Br, A = Array.isArray(i.initialVelocity) ? i.initialVelocity[c] : i.initialVelocity;
        if (g && (m = m.getValue()), i.immediate) {
          s.setValue(m), s.done = !0;
          continue;
        }
        if (typeof p == "string" || typeof m == "string") {
          s.setValue(m), s.done = !0;
          continue;
        }
        if (i.duration !== void 0)
          v = p + i.easing((e - s.startTime) / i.duration) * (m - p), o = e >= s.startTime + i.duration;
        else if (i.decay)
          v = p + A / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (e - s.startTime))), o = Math.abs(s.lastPosition - v) < 0.1, o && (m = v);
        else {
          d = s.lastTime !== void 0 ? s.lastTime : e, A = s.lastVelocity !== void 0 ? s.lastVelocity : i.initialVelocity, e > d + 64 && (d = e);
          let k = Math.floor(e - d);
          for (let y = 0; y < k; ++y) {
            let N = -i.tension * (v - m), C = -i.friction * A, P = (N + C) / i.mass;
            A = A + P * 1 / 1e3, v = v + A * 1 / 1e3;
          }
          let E = i.clamp && i.tension !== 0 ? p < m ? v > m : v < m : !1, T = Math.abs(A) <= i.precision, b = i.tension !== 0 ? Math.abs(m - v) <= i.precision : !0;
          o = E || T && b, s.lastVelocity = A, s.lastTime = e;
        }
        g && !i.toValues[c].done && (o = !1), o ? (s.value !== m && (v = m), s.done = !0) : r = !0, s.setValue(v), s.lastPosition = v;
      }
      t.props.onFrame && (t.values[i.name] = i.interpolation.getValue());
    }
    t.props.onFrame && t.props.onFrame(t.values), r || (Hi.delete(t), t.stop(!0));
  }
  return Hi.size ? hy(gy) : hs = !1, hs;
}, Nb = (e) => {
  Hi.has(e) || Hi.add(e), hs || (hs = !0, hy(gy));
}, Rb = (e) => {
  Hi.has(e) && Hi.delete(e);
};
function lc(e, t, r) {
  if (typeof e == "function")
    return e;
  if (Array.isArray(e))
    return lc({
      range: e,
      output: t,
      extrapolate: r
    });
  if (oc && typeof e.output[0] == "string")
    return oc(e);
  const a = e, i = a.output, o = a.range || [0, 1], d = a.extrapolateLeft || a.extrapolate || "extend", c = a.extrapolateRight || a.extrapolate || "extend", s = a.easing || ((p) => p);
  return (p) => {
    const m = _b(p, o);
    return Db(p, o[m], o[m + 1], i[m], i[m + 1], s, d, c, a.map);
  };
}
function Db(e, t, r, a, i, o, d, c, s) {
  let p = s ? s(e) : e;
  if (p < t) {
    if (d === "identity")
      return p;
    d === "clamp" && (p = t);
  }
  if (p > r) {
    if (c === "identity")
      return p;
    c === "clamp" && (p = r);
  }
  return a === i ? a : t === r ? e <= t ? a : i : (t === -1 / 0 ? p = -p : r === 1 / 0 ? p = p - t : p = (p - t) / (r - t), p = o(p), a === -1 / 0 ? p = -p : i === 1 / 0 ? p = p + a : p = p * (i - a) + a, p);
}
function _b(e, t) {
  for (var r = 1; r < t.length - 1 && !(t[r] >= e); ++r)
    ;
  return r - 1;
}
class ll extends bf {
  constructor(t, r, a, i) {
    super(), this.calc = void 0, this.payload = t instanceof bf && !(t instanceof ll) ? t.getPayload() : Array.isArray(t) ? t : [t], this.calc = lc(r, a, i);
  }
  getValue() {
    return this.calc(...this.payload.map((t) => t.getValue()));
  }
  updateConfig(t, r, a) {
    this.calc = lc(t, r, a);
  }
  interpolate(t, r, a) {
    return new ll(this, t, r, a);
  }
}
const Ob = (e, t, r) => e && new ll(e, t, r);
function vy(e, t) {
  "update" in e ? t.add(e) : e.getChildren().forEach((r) => vy(r, t));
}
class Ef extends Br {
  constructor(t) {
    var r;
    super(), r = this, this.animatedStyles = /* @__PURE__ */ new Set(), this.value = void 0, this.startPosition = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.startTime = void 0, this.lastTime = void 0, this.done = !1, this.setValue = function(a, i) {
      i === void 0 && (i = !0), r.value = a, i && r.flush();
    }, this.value = t, this.startPosition = t, this.lastPosition = t;
  }
  flush() {
    this.animatedStyles.size === 0 && vy(this, this.animatedStyles), this.animatedStyles.forEach((t) => t.update());
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  getValue() {
    return this.value;
  }
  interpolate(t, r, a) {
    return new ll(this, t, r, a);
  }
}
class Fb extends bf {
  constructor(t) {
    super(), this.payload = t.map((r) => new Ef(r));
  }
  setValue(t, r) {
    r === void 0 && (r = !0), Array.isArray(t) ? t.length === this.payload.length && t.forEach((a, i) => this.payload[i].setValue(a, r)) : this.payload.forEach((a) => a.setValue(t, r));
  }
  getValue() {
    return this.payload.map((t) => t.getValue());
  }
  interpolate(t, r) {
    return new ll(this, t, r);
  }
}
let Mb = 0;
class zb {
  constructor() {
    this.id = void 0, this.idle = !0, this.hasChanged = !1, this.guid = 0, this.local = 0, this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.listeners = [], this.queue = [], this.localQueue = void 0, this.getValues = () => this.interpolations, this.id = Mb++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */
  update(t) {
    if (!t)
      return this;
    const r = Ud(t), a = r.delay, i = a === void 0 ? 0 : a, o = r.to, d = Jr(r, ["delay", "to"]);
    if (en.arr(o) || en.fun(o))
      this.queue.push(En({}, d, {
        delay: i,
        to: o
      }));
    else if (o) {
      let c = {};
      Object.entries(o).forEach((s) => {
        let p = s[0], m = s[1];
        const v = En({
          to: {
            [p]: m
          },
          delay: zr(i, p)
        }, d), g = c[v.delay] && c[v.delay].to;
        c[v.delay] = En({}, c[v.delay], v, {
          to: En({}, g, v.to)
        });
      }), this.queue = Object.values(c);
    }
    return this.queue = this.queue.sort((c, s) => c.delay - s.delay), this.diff(d), this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  start(t) {
    if (this.queue.length) {
      this.idle = !1, this.localQueue && this.localQueue.forEach((i) => {
        let o = i.from, d = o === void 0 ? {} : o, c = i.to, s = c === void 0 ? {} : c;
        en.obj(d) && (this.merged = En({}, d, this.merged)), en.obj(s) && (this.merged = En({}, this.merged, s));
      });
      const r = this.local = ++this.guid, a = this.localQueue = this.queue;
      this.queue = [], a.forEach((i, o) => {
        let d = i.delay, c = Jr(i, ["delay"]);
        const s = (m) => {
          o === a.length - 1 && r === this.guid && m && (this.idle = !0, this.props.onRest && this.props.onRest(this.merged)), t && t();
        };
        let p = en.arr(c.to) || en.fun(c.to);
        d ? setTimeout(() => {
          r === this.guid && (p ? this.runAsync(c, s) : this.diff(c).start(s));
        }, d) : p ? this.runAsync(c, s) : this.diff(c).start(s);
      });
    } else
      en.fun(t) && this.listeners.push(t), this.props.onStart && this.props.onStart(), Nb(this);
    return this;
  }
  stop(t) {
    return this.listeners.forEach((r) => r(t)), this.listeners = [], this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  pause(t) {
    return this.stop(!0), t && Rb(this), this;
  }
  runAsync(t, r) {
    var a = this;
    t.delay;
    let i = Jr(t, ["delay"]);
    const o = this.local;
    let d = Promise.resolve(void 0);
    if (en.arr(i.to))
      for (let c = 0; c < i.to.length; c++) {
        const s = c, p = En({}, i, Ud(i.to[s]));
        en.arr(p.config) && (p.config = p.config[s]), d = d.then(() => {
          if (o === this.guid)
            return new Promise((m) => this.diff(p).start(m));
        });
      }
    else if (en.fun(i.to)) {
      let c = 0, s;
      d = d.then(() => i.to(
        // next(props)
        (p) => {
          const m = En({}, i, Ud(p));
          if (en.arr(m.config) && (m.config = m.config[c]), c++, o === this.guid)
            return s = new Promise((v) => this.diff(m).start(v));
        },
        // cancel()
        function(p) {
          return p === void 0 && (p = !0), a.stop(p);
        }
      ).then(() => s));
    }
    d.then(r);
  }
  diff(t) {
    this.props = En({}, this.props, t);
    let r = this.props, a = r.from, i = a === void 0 ? {} : a, o = r.to, d = o === void 0 ? {} : o, c = r.config, s = c === void 0 ? {} : c, p = r.reverse, m = r.attach, v = r.reset, g = r.immediate;
    if (p) {
      var A = [d, i];
      i = A[0], d = A[1];
    }
    this.merged = En({}, i, this.merged, d), this.hasChanged = !1;
    let k = m && m(this);
    if (this.animations = Object.entries(this.merged).reduce((E, T) => {
      let b = T[0], y = T[1], N = E[b] || {};
      const C = en.num(y), P = en.str(y) && !y.startsWith("#") && !/\d/.test(y) && !py[y], O = en.arr(y), K = !C && !O && !P;
      let W = en.und(i[b]) ? y : i[b], J = C || O || P ? y : 1, j = zr(s, b);
      k && (J = k.animations[b].parent);
      let B = N.parent, Z = N.interpolation, te = el(k ? J.getPayload() : J), V, ee = y;
      K && (ee = oc({
        range: [0, 1],
        output: [y, y]
      })(1));
      let ce = Z && Z.getValue();
      const G = !en.und(B) && N.animatedValues.some((oe) => !oe.done), U = !en.equ(ee, ce), q = !en.equ(ee, N.previous), H = !en.equ(j, N.config);
      if (v || q && U || H) {
        if (C || P)
          B = Z = N.parent || new Ef(W);
        else if (O)
          B = Z = N.parent || new Fb(W);
        else if (K) {
          let oe = N.interpolation && N.interpolation.calc(N.parent.value);
          oe = oe !== void 0 && !v ? oe : W, N.parent ? (B = N.parent, B.setValue(0, !1)) : B = new Ef(0);
          const ue = {
            output: [oe, y]
          };
          N.interpolation ? (Z = N.interpolation, N.interpolation.updateConfig(ue)) : Z = B.interpolate(ue);
        }
        return te = el(k ? J.getPayload() : J), V = el(B.getPayload()), v && !K && B.setValue(W, !1), this.hasChanged = !0, V.forEach((oe) => {
          oe.startPosition = oe.value, oe.lastPosition = oe.value, oe.lastVelocity = G ? oe.lastVelocity : void 0, oe.lastTime = G ? oe.lastTime : void 0, oe.startTime = my(), oe.done = !1, oe.animatedStyles.clear();
        }), zr(g, b) && B.setValue(K ? J : y, !1), En({}, E, {
          [b]: En({}, N, {
            name: b,
            parent: B,
            interpolation: Z,
            animatedValues: V,
            toValues: te,
            previous: ee,
            config: j,
            fromValues: el(B.getValue()),
            immediate: zr(g, b),
            initialVelocity: Ri(j.velocity, 0),
            clamp: Ri(j.clamp, !1),
            precision: Ri(j.precision, 0.01),
            tension: Ri(j.tension, 170),
            friction: Ri(j.friction, 26),
            mass: Ri(j.mass, 1),
            duration: j.duration,
            easing: Ri(j.easing, (oe) => oe),
            decay: j.decay
          })
        });
      } else
        return U ? E : (K && (B.setValue(1, !1), Z.updateConfig({
          output: [ee, ee]
        })), B.done = !0, this.hasChanged = !0, En({}, E, {
          [b]: En({}, E[b], {
            previous: ee
          })
        }));
    }, this.animations), this.hasChanged) {
      this.configs = Object.values(this.animations), this.values = {}, this.interpolations = {};
      for (let E in this.animations)
        this.interpolations[E] = this.animations[E].interpolation, this.values[E] = this.animations[E].interpolation.getValue();
    }
    return this;
  }
  destroy() {
    this.stop(), this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.local = 0;
  }
}
let Bb = 0;
const Yu = "enter", Kd = "leave", Yd = "update", $b = (e, t) => (typeof t == "function" ? e.map(t) : el(t)).map(String), Sf = (e) => {
  let t = e.items, r = e.keys, a = r === void 0 ? (o) => o : r, i = Jr(e, ["items", "keys"]);
  return t = el(t !== void 0 ? t : null), En({
    items: t,
    keys: $b(t, a)
  }, i);
};
function Ib(e, t, r) {
  const a = En({
    items: e,
    keys: t || ((y) => y)
  }, r), i = Sf(a), o = i.lazy, d = o === void 0 ? !1 : o;
  i.unique;
  const c = i.reset, s = c === void 0 ? !1 : c;
  i.enter, i.leave, i.update;
  const p = i.onDestroyed;
  i.keys, i.items;
  const m = i.onFrame, v = i.onRest, g = i.onStart, A = i.ref, k = Jr(i, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]), E = dy(), T = ie.useRef(!1), b = ie.useRef({
    mounted: !1,
    first: !0,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!a.ref,
    instances: !T.current && /* @__PURE__ */ new Map(),
    forceUpdate: E
  });
  return ie.useImperativeHandle(a.ref, () => ({
    start: () => Promise.all(Array.from(b.current.instances).map((y) => {
      let N = y[1];
      return new Promise((C) => N.start(C));
    })),
    stop: (y) => Array.from(b.current.instances).forEach((N) => N[1].stop(y)),
    get controllers() {
      return Array.from(b.current.instances).map((y) => y[1]);
    }
  })), b.current = Hb(b.current, a), b.current.changed && b.current.transitions.forEach((y) => {
    const N = y.slot, C = y.from, P = y.to, O = y.config, K = y.trail, W = y.key, J = y.item;
    b.current.instances.has(W) || b.current.instances.set(W, new zb());
    const j = b.current.instances.get(W), B = En({}, k, {
      to: P,
      from: C,
      config: O,
      ref: A,
      onRest: (Z) => {
        b.current.mounted && (y.destroyed && (!A && !d && vh(b, W), p && p(J)), !Array.from(b.current.instances).some((ee) => !ee[1].idle) && (A || d) && b.current.deleted.length > 0 && vh(b), v && v(J, N, Z));
      },
      onStart: g && (() => g(J, N)),
      onFrame: m && ((Z) => m(J, N, Z)),
      delay: K,
      reset: s && N === Yu
      // Update controller
    });
    j.update(B), b.current.paused || j.start();
  }), ie.useEffect(() => (b.current.mounted = T.current = !0, () => {
    b.current.mounted = T.current = !1, Array.from(b.current.instances).map((y) => y[1].destroy()), b.current.instances.clear();
  }), []), b.current.transitions.map((y) => {
    let N = y.item, C = y.slot, P = y.key;
    return {
      item: N,
      key: P,
      state: C,
      props: b.current.instances.get(P).getValues()
    };
  });
}
function vh(e, t) {
  const r = e.current.deleted;
  for (let a of r) {
    let i = a.key;
    const o = (d) => d.key !== i;
    (en.und(t) || t === i) && (e.current.instances.delete(i), e.current.transitions = e.current.transitions.filter(o), e.current.deleted = e.current.deleted.filter(o));
  }
  e.current.forceUpdate();
}
function Hb(e, t) {
  let r = e.first, a = e.prevProps, i = Jr(e, ["first", "prevProps"]), o = Sf(t), d = o.items, c = o.keys, s = o.initial, p = o.from, m = o.enter, v = o.leave, g = o.update, A = o.trail, k = A === void 0 ? 0 : A, E = o.unique, T = o.config, b = o.order, y = b === void 0 ? [Yu, Kd, Yd] : b, N = Sf(a), C = N.keys, P = N.items, O = En({}, i.current), K = [...i.deleted], W = Object.keys(O), J = new Set(W), j = new Set(c), B = c.filter((ce) => !J.has(ce)), Z = i.transitions.filter((ce) => !ce.destroyed && !j.has(ce.originalKey)).map((ce) => ce.originalKey), te = c.filter((ce) => J.has(ce)), V = -k;
  for (; y.length; )
    switch (y.shift()) {
      case Yu: {
        B.forEach((re, G) => {
          E && K.find((oe) => oe.originalKey === re) && (K = K.filter((oe) => oe.originalKey !== re));
          const U = c.indexOf(re), q = d[U], H = r && s !== void 0 ? "initial" : Yu;
          O[re] = {
            slot: H,
            originalKey: re,
            key: E ? String(re) : Bb++,
            item: q,
            trail: V = V + k,
            config: zr(T, q, H),
            from: zr(r && s !== void 0 ? s || {} : p, q),
            to: zr(m, q)
          };
        });
        break;
      }
      case Kd: {
        Z.forEach((re) => {
          const G = C.indexOf(re), U = P[G], q = Kd;
          K.unshift(En({}, O[re], {
            slot: q,
            destroyed: !0,
            left: C[Math.max(0, G - 1)],
            right: C[Math.min(C.length, G + 1)],
            trail: V = V + k,
            config: zr(T, U, q),
            to: zr(v, U)
          })), delete O[re];
        });
        break;
      }
      case Yd: {
        te.forEach((re) => {
          const G = c.indexOf(re), U = d[G], q = Yd;
          O[re] = En({}, O[re], {
            item: U,
            slot: q,
            trail: V = V + k,
            config: zr(T, U, q),
            to: zr(g, U)
          });
        });
        break;
      }
    }
  let ee = c.map((ce) => O[ce]);
  return K.forEach((ce) => {
    let re = ce.left;
    ce.right;
    let G = Jr(ce, ["left", "right"]), U;
    (U = ee.findIndex((q) => q.originalKey === re)) !== -1 && (U += 1), U = Math.max(0, U), ee = [...ee.slice(0, U), G, ...ee.slice(U)];
  }), En({}, i, {
    changed: B.length || Z.length || te.length,
    first: r && B.length === 0,
    transitions: ee,
    current: O,
    deleted: K,
    prevProps: t
  });
}
class Vb extends fy {
  constructor(t) {
    t === void 0 && (t = {}), super(), t.transform && !(t.transform instanceof Br) && (t = tp.transform(t)), this.payload = t;
  }
}
const sc = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, $r = "[-+]?\\d*\\.?\\d+", uc = $r + "%";
function _c() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const Wb = new RegExp("rgb" + _c($r, $r, $r)), jb = new RegExp("rgba" + _c($r, $r, $r, $r)), Ub = new RegExp("hsl" + _c($r, uc, uc)), Kb = new RegExp("hsla" + _c($r, uc, uc, $r)), Yb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Xb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, qb = /^#([0-9a-fA-F]{6})$/, Gb = /^#([0-9a-fA-F]{8})$/;
function Zb(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = qb.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : sc.hasOwnProperty(e) ? sc[e] : (t = Wb.exec(e)) ? (Xo(t[1]) << 24 | // r
  Xo(t[2]) << 16 | // g
  Xo(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = jb.exec(e)) ? (Xo(t[1]) << 24 | // r
  Xo(t[2]) << 16 | // g
  Xo(t[3]) << 8 | // b
  Eh(t[4])) >>> // a
  0 : (t = Yb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = Gb.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = Xb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = Ub.exec(e)) ? (xh(
    bh(t[1]),
    // h
    Du(t[2]),
    // s
    Du(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = Kb.exec(e)) ? (xh(
    bh(t[1]),
    // h
    Du(t[2]),
    // s
    Du(t[3])
    // l
  ) | Eh(t[4])) >>> // a
  0 : null;
}
function Xd(e, t, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function xh(e, t, r) {
  const a = r < 0.5 ? r * (1 + t) : r + t - r * t, i = 2 * r - a, o = Xd(i, a, e + 1 / 3), d = Xd(i, a, e), c = Xd(i, a, e - 1 / 3);
  return Math.round(o * 255) << 24 | Math.round(d * 255) << 16 | Math.round(c * 255) << 8;
}
function Xo(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function bh(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function Eh(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function Du(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function Sh(e) {
  let t = Zb(e);
  if (t === null)
    return e;
  t = t || 0;
  let r = (t & 4278190080) >>> 24, a = (t & 16711680) >>> 16, i = (t & 65280) >>> 8, o = (t & 255) / 255;
  return `rgba(${r}, ${a}, ${i}, ${o})`;
}
const _u = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Qb = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Jb = new RegExp(`(${Object.keys(sc).join("|")})`, "g"), e0 = (e) => {
  const t = e.output.map((i) => i.replace(Qb, Sh)).map((i) => i.replace(Jb, Sh)), r = t[0].match(_u).map(() => []);
  t.forEach((i) => {
    i.match(_u).forEach((o, d) => r[d].push(+o));
  });
  const a = t[0].match(_u).map((i, o) => lc(En({}, e, {
    output: r[o]
  })));
  return (i) => {
    let o = 0;
    return t[0].replace(_u, () => a[o++](i)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (d, c, s, p, m) => `rgba(${Math.round(c)}, ${Math.round(s)}, ${Math.round(p)}, ${m})`);
  };
};
let ms = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const t0 = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), n0 = ["Webkit", "Ms", "Moz", "O"];
ms = Object.keys(ms).reduce((e, t) => (n0.forEach((r) => e[t0(r, t)] = e[t]), e), ms);
function r0(e, t, r) {
  return t == null || typeof t == "boolean" || t === "" ? "" : !r && typeof t == "number" && t !== 0 && !(ms.hasOwnProperty(e) && ms[e]) ? t + "px" : ("" + t).trim();
}
const kh = {};
Cb((e) => new Vb(e));
wb(e0);
kb(sc);
Sb((e, t) => {
  if (e.nodeType && e.setAttribute !== void 0) {
    const i = t.style, o = t.children, d = t.scrollTop, c = t.scrollLeft, s = Jr(t, ["style", "children", "scrollTop", "scrollLeft"]), p = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter";
    d !== void 0 && (e.scrollTop = d), c !== void 0 && (e.scrollLeft = c), o !== void 0 && (e.textContent = o);
    for (let m in i)
      if (i.hasOwnProperty(m)) {
        var r = m.indexOf("--") === 0, a = r0(m, i[m], r);
        m === "float" && (m = "cssFloat"), r ? e.style.setProperty(m, a) : e.style[m] = a;
      }
    for (let m in s) {
      const v = p ? m : kh[m] || (kh[m] = m.replace(/([A-Z])/g, (g) => "-" + g.toLowerCase()));
      typeof e.getAttribute(v) < "u" && e.setAttribute(v, s[m]);
    }
    return;
  } else
    return !1;
}, (e) => e);
const a0 = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], i0 = xb(Pb, !1), wh = i0(a0);
function o0(e) {
  return e.innerRadius;
}
function l0(e) {
  return e.outerRadius;
}
function s0(e) {
  return e.startAngle;
}
function u0(e) {
  return e.endAngle;
}
function c0(e) {
  return e && e.padAngle;
}
function d0(e, t, r, a, i, o, d, c) {
  var s = r - e, p = a - t, m = d - i, v = c - o, g = v * s - m * p;
  if (!(g * g < ir))
    return g = (m * (t - o) - v * (e - i)) / g, [e + g * s, t + g * p];
}
function Ou(e, t, r, a, i, o, d) {
  var c = e - r, s = t - a, p = (d ? o : -o) / Qo(c * c + s * s), m = p * s, v = -p * c, g = e + m, A = t + v, k = r + m, E = a + v, T = (g + k) / 2, b = (A + E) / 2, y = k - g, N = E - A, C = y * y + N * N, P = i - o, O = g * E - k * A, K = (N < 0 ? -1 : 1) * Qo(bg(0, P * P * C - O * O)), W = (O * N - y * K) / C, J = (-O * y - N * K) / C, j = (O * N + y * K) / C, B = (-O * y + N * K) / C, Z = W - T, te = J - b, V = j - T, ee = B - b;
  return Z * Z + te * te > V * V + ee * ee && (W = j, J = B), {
    cx: W,
    cy: J,
    x01: -m,
    y01: -v,
    x11: W * (i / P - 1),
    y11: J * (i / P - 1)
  };
}
function f0() {
  var e = o0, t = l0, r = an(0), a = null, i = s0, o = u0, d = c0, c = null;
  function s() {
    var p, m, v = +e.apply(this, arguments), g = +t.apply(this, arguments), A = i.apply(this, arguments) - Ap, k = o.apply(this, arguments) - Ap, E = Lp(k - A), T = k > A;
    if (c || (c = p = Rc()), g < v && (m = g, g = v, v = m), !(g > ir))
      c.moveTo(0, 0);
    else if (E > ju - ir)
      c.moveTo(g * Li(A), g * qr(A)), c.arc(0, 0, g, A, k, !T), v > ir && (c.moveTo(v * Li(k), v * qr(k)), c.arc(0, 0, v, k, A, T));
    else {
      var b = A, y = k, N = A, C = k, P = E, O = E, K = d.apply(this, arguments) / 2, W = K > ir && (a ? +a.apply(this, arguments) : Qo(v * v + g * g)), J = Md(Lp(g - v) / 2, +r.apply(this, arguments)), j = J, B = J, Z, te;
      if (W > ir) {
        var V = Pp(W / v * qr(K)), ee = Pp(W / g * qr(K));
        (P -= V * 2) > ir ? (V *= T ? 1 : -1, N += V, C -= V) : (P = 0, N = C = (A + k) / 2), (O -= ee * 2) > ir ? (ee *= T ? 1 : -1, b += ee, y -= ee) : (O = 0, b = y = (A + k) / 2);
      }
      var ce = g * Li(b), re = g * qr(b), G = v * Li(C), U = v * qr(C);
      if (J > ir) {
        var q = g * Li(y), H = g * qr(y), oe = v * Li(N), ue = v * qr(N), ke;
        if (E < Cp && (ke = d0(ce, re, oe, ue, q, H, G, U))) {
          var De = ce - ke[0], pe = re - ke[1], Be = q - ke[0], qe = H - ke[1], Pe = 1 / qr(xg((De * Be + pe * qe) / (Qo(De * De + pe * pe) * Qo(Be * Be + qe * qe))) / 2), ve = Qo(ke[0] * ke[0] + ke[1] * ke[1]);
          j = Md(J, (v - ve) / (Pe - 1)), B = Md(J, (g - ve) / (Pe + 1));
        }
      }
      O > ir ? B > ir ? (Z = Ou(oe, ue, ce, re, g, B, T), te = Ou(q, H, G, U, g, B, T), c.moveTo(Z.cx + Z.x01, Z.cy + Z.y01), B < J ? c.arc(Z.cx, Z.cy, B, nr(Z.y01, Z.x01), nr(te.y01, te.x01), !T) : (c.arc(Z.cx, Z.cy, B, nr(Z.y01, Z.x01), nr(Z.y11, Z.x11), !T), c.arc(0, 0, g, nr(Z.cy + Z.y11, Z.cx + Z.x11), nr(te.cy + te.y11, te.cx + te.x11), !T), c.arc(te.cx, te.cy, B, nr(te.y11, te.x11), nr(te.y01, te.x01), !T))) : (c.moveTo(ce, re), c.arc(0, 0, g, b, y, !T)) : c.moveTo(ce, re), !(v > ir) || !(P > ir) ? c.lineTo(G, U) : j > ir ? (Z = Ou(G, U, q, H, v, -j, T), te = Ou(ce, re, oe, ue, v, -j, T), c.lineTo(Z.cx + Z.x01, Z.cy + Z.y01), j < J ? c.arc(Z.cx, Z.cy, j, nr(Z.y01, Z.x01), nr(te.y01, te.x01), !T) : (c.arc(Z.cx, Z.cy, j, nr(Z.y01, Z.x01), nr(Z.y11, Z.x11), !T), c.arc(0, 0, v, nr(Z.cy + Z.y11, Z.cx + Z.x11), nr(te.cy + te.y11, te.cx + te.x11), T), c.arc(te.cx, te.cy, j, nr(te.y11, te.x11), nr(te.y01, te.x01), !T))) : c.arc(0, 0, v, C, N, T);
    }
    if (c.closePath(), p)
      return c = null, p + "" || null;
  }
  return s.centroid = function() {
    var p = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, m = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Cp / 2;
    return [Li(m) * p, qr(m) * p];
  }, s.innerRadius = function(p) {
    return arguments.length ? (e = typeof p == "function" ? p : an(+p), s) : e;
  }, s.outerRadius = function(p) {
    return arguments.length ? (t = typeof p == "function" ? p : an(+p), s) : t;
  }, s.cornerRadius = function(p) {
    return arguments.length ? (r = typeof p == "function" ? p : an(+p), s) : r;
  }, s.padRadius = function(p) {
    return arguments.length ? (a = p == null ? null : typeof p == "function" ? p : an(+p), s) : a;
  }, s.startAngle = function(p) {
    return arguments.length ? (i = typeof p == "function" ? p : an(+p), s) : i;
  }, s.endAngle = function(p) {
    return arguments.length ? (o = typeof p == "function" ? p : an(+p), s) : o;
  }, s.padAngle = function(p) {
    return arguments.length ? (d = typeof p == "function" ? p : an(+p), s) : d;
  }, s.context = function(p) {
    return arguments.length ? (c = p ?? null, s) : c;
  }, s;
}
function xy(e) {
  this._context = e;
}
xy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Oc(e) {
  return new xy(e);
}
function np(e) {
  return e[0];
}
function rp(e) {
  return e[1];
}
function by() {
  var e = np, t = rp, r = an(!0), a = null, i = Oc, o = null;
  function d(c) {
    var s, p = c.length, m, v = !1, g;
    for (a == null && (o = i(g = Rc())), s = 0; s <= p; ++s)
      !(s < p && r(m = c[s], s, c)) === v && ((v = !v) ? o.lineStart() : o.lineEnd()), v && o.point(+e(m, s, c), +t(m, s, c));
    if (g)
      return o = null, g + "" || null;
  }
  return d.x = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : an(+c), d) : e;
  }, d.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : an(+c), d) : t;
  }, d.defined = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : an(!!c), d) : r;
  }, d.curve = function(c) {
    return arguments.length ? (i = c, a != null && (o = i(a)), d) : i;
  }, d.context = function(c) {
    return arguments.length ? (c == null ? a = o = null : o = i(a = c), d) : a;
  }, d;
}
function p0() {
  var e = np, t = null, r = an(0), a = rp, i = an(!0), o = null, d = Oc, c = null;
  function s(m) {
    var v, g, A, k = m.length, E, T = !1, b, y = new Array(k), N = new Array(k);
    for (o == null && (c = d(b = Rc())), v = 0; v <= k; ++v) {
      if (!(v < k && i(E = m[v], v, m)) === T)
        if (T = !T)
          g = v, c.areaStart(), c.lineStart();
        else {
          for (c.lineEnd(), c.lineStart(), A = v - 1; A >= g; --A)
            c.point(y[A], N[A]);
          c.lineEnd(), c.areaEnd();
        }
      T && (y[v] = +e(E, v, m), N[v] = +r(E, v, m), c.point(t ? +t(E, v, m) : y[v], a ? +a(E, v, m) : N[v]));
    }
    if (b)
      return c = null, b + "" || null;
  }
  function p() {
    return by().defined(i).curve(d).context(o);
  }
  return s.x = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : an(+m), t = null, s) : e;
  }, s.x0 = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : an(+m), s) : e;
  }, s.x1 = function(m) {
    return arguments.length ? (t = m == null ? null : typeof m == "function" ? m : an(+m), s) : t;
  }, s.y = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : an(+m), a = null, s) : r;
  }, s.y0 = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : an(+m), s) : r;
  }, s.y1 = function(m) {
    return arguments.length ? (a = m == null ? null : typeof m == "function" ? m : an(+m), s) : a;
  }, s.lineX0 = s.lineY0 = function() {
    return p().x(e).y(r);
  }, s.lineY1 = function() {
    return p().x(e).y(a);
  }, s.lineX1 = function() {
    return p().x(t).y(r);
  }, s.defined = function(m) {
    return arguments.length ? (i = typeof m == "function" ? m : an(!!m), s) : i;
  }, s.curve = function(m) {
    return arguments.length ? (d = m, o != null && (c = d(o)), s) : d;
  }, s.context = function(m) {
    return arguments.length ? (m == null ? o = c = null : c = d(o = m), s) : o;
  }, s;
}
function h0(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function m0(e) {
  return e;
}
function y0() {
  var e = m0, t = h0, r = null, a = an(0), i = an(ju), o = an(0);
  function d(c) {
    var s, p = c.length, m, v, g = 0, A = new Array(p), k = new Array(p), E = +a.apply(this, arguments), T = Math.min(ju, Math.max(-ju, i.apply(this, arguments) - E)), b, y = Math.min(Math.abs(T) / p, o.apply(this, arguments)), N = y * (T < 0 ? -1 : 1), C;
    for (s = 0; s < p; ++s)
      (C = k[A[s] = s] = +e(c[s], s, c)) > 0 && (g += C);
    for (t != null ? A.sort(function(P, O) {
      return t(k[P], k[O]);
    }) : r != null && A.sort(function(P, O) {
      return r(c[P], c[O]);
    }), s = 0, v = g ? (T - p * N) / g : 0; s < p; ++s, E = b)
      m = A[s], C = k[m], b = E + (C > 0 ? C * v : 0) + N, k[m] = {
        data: c[m],
        index: s,
        value: C,
        startAngle: E,
        endAngle: b,
        padAngle: y
      };
    return k;
  }
  return d.value = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : an(+c), d) : e;
  }, d.sortValues = function(c) {
    return arguments.length ? (t = c, r = null, d) : t;
  }, d.sort = function(c) {
    return arguments.length ? (r = c, t = null, d) : r;
  }, d.startAngle = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : an(+c), d) : a;
  }, d.endAngle = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : an(+c), d) : i;
  }, d.padAngle = function(c) {
    return arguments.length ? (o = typeof c == "function" ? c : an(+c), d) : o;
  }, d;
}
var kf = Array.prototype.slice;
function g0(e) {
  return e.source;
}
function v0(e) {
  return e.target;
}
function x0(e) {
  var t = g0, r = v0, a = np, i = rp, o = null;
  function d() {
    var c, s = kf.call(arguments), p = t.apply(this, s), m = r.apply(this, s);
    if (o || (o = c = Rc()), e(o, +a.apply(this, (s[0] = p, s)), +i.apply(this, s), +a.apply(this, (s[0] = m, s)), +i.apply(this, s)), c)
      return o = null, c + "" || null;
  }
  return d.source = function(c) {
    return arguments.length ? (t = c, d) : t;
  }, d.target = function(c) {
    return arguments.length ? (r = c, d) : r;
  }, d.x = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : an(+c), d) : a;
  }, d.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : an(+c), d) : i;
  }, d.context = function(c) {
    return arguments.length ? (o = c ?? null, d) : o;
  }, d;
}
function b0(e, t, r, a, i) {
  e.moveTo(t, r), e.bezierCurveTo(t = (t + a) / 2, r, t, i, a, i);
}
function E0() {
  return x0(b0);
}
function Ka() {
}
function cc(e, t, r) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + r) / 6
  );
}
function Fc(e) {
  this._context = e;
}
Fc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        cc(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        cc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function S0(e) {
  return new Fc(e);
}
function Ey(e) {
  this._context = e;
}
Ey.prototype = {
  areaStart: Ka,
  areaEnd: Ka,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        cc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function k0(e) {
  return new Ey(e);
}
function Sy(e) {
  this._context = e;
}
Sy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + e) / 6, a = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(r, a) : this._context.moveTo(r, a);
        break;
      case 3:
        this._point = 4;
      default:
        cc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function w0(e) {
  return new Sy(e);
}
function ky(e, t) {
  this._basis = new Fc(e), this._beta = t;
}
ky.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length - 1;
    if (r > 0)
      for (var a = e[0], i = t[0], o = e[r] - a, d = t[r] - i, c = -1, s; ++c <= r; )
        s = c / r, this._basis.point(
          this._beta * e[c] + (1 - this._beta) * (a + s * o),
          this._beta * t[c] + (1 - this._beta) * (i + s * d)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const T0 = function e(t) {
  function r(a) {
    return t === 1 ? new Fc(a) : new ky(a, t);
  }
  return r.beta = function(a) {
    return e(+a);
  }, r;
}(0.85);
function dc(e, t, r) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - r),
    e._x2,
    e._y2
  );
}
function ap(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
ap.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        dc(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        dc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const C0 = function e(t) {
  function r(a) {
    return new ap(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function ip(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
ip.prototype = {
  areaStart: Ka,
  areaEnd: Ka,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        dc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const A0 = function e(t) {
  function r(a) {
    return new ip(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function op(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
op.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        dc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const L0 = function e(t) {
  function r(a) {
    return new op(a, t);
  }
  return r.tension = function(a) {
    return e(+a);
  }, r;
}(0);
function lp(e, t, r) {
  var a = e._x1, i = e._y1, o = e._x2, d = e._y2;
  if (e._l01_a > ir) {
    var c = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, s = 3 * e._l01_a * (e._l01_a + e._l12_a);
    a = (a * c - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / s, i = (i * c - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / s;
  }
  if (e._l23_a > ir) {
    var p = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, m = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * p + e._x1 * e._l23_2a - t * e._l12_2a) / m, d = (d * p + e._y1 * e._l23_2a - r * e._l12_2a) / m;
  }
  e._context.bezierCurveTo(a, i, o, d, e._x2, e._y2);
}
function wy(e, t) {
  this._context = e, this._alpha = t;
}
wy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        lp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const P0 = function e(t) {
  function r(a) {
    return t ? new wy(a, t) : new ap(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function Ty(e, t) {
  this._context = e, this._alpha = t;
}
Ty.prototype = {
  areaStart: Ka,
  areaEnd: Ka,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        lp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const N0 = function e(t) {
  function r(a) {
    return t ? new Ty(a, t) : new ip(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function Cy(e, t) {
  this._context = e, this._alpha = t;
}
Cy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        lp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const R0 = function e(t) {
  function r(a) {
    return t ? new Cy(a, t) : new op(a, 0);
  }
  return r.alpha = function(a) {
    return e(+a);
  }, r;
}(0.5);
function Ay(e) {
  this._context = e;
}
Ay.prototype = {
  areaStart: Ka,
  areaEnd: Ka,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function wf(e) {
  return new Ay(e);
}
function Th(e) {
  return e < 0 ? -1 : 1;
}
function Ch(e, t, r) {
  var a = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (a || i < 0 && -0), d = (r - e._y1) / (i || a < 0 && -0), c = (o * i + d * a) / (a + i);
  return (Th(o) + Th(d)) * Math.min(Math.abs(o), Math.abs(d), 0.5 * Math.abs(c)) || 0;
}
function Ah(e, t) {
  var r = e._x1 - e._x0;
  return r ? (3 * (e._y1 - e._y0) / r - t) / 2 : t;
}
function qd(e, t, r) {
  var a = e._x0, i = e._y0, o = e._x1, d = e._y1, c = (o - a) / 3;
  e._context.bezierCurveTo(a + c, i + c * t, o - c, d - c * r, o, d);
}
function fc(e) {
  this._context = e;
}
fc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        qd(this, this._t0, Ah(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var r = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, qd(this, Ah(this, r = Ch(this, e, t)), r);
          break;
        default:
          qd(this, this._t0, r = Ch(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = r;
    }
  }
};
function Ly(e) {
  this._context = new Py(e);
}
(Ly.prototype = Object.create(fc.prototype)).point = function(e, t) {
  fc.prototype.point.call(this, t, e);
};
function Py(e) {
  this._context = e;
}
Py.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, r, a, i, o) {
    this._context.bezierCurveTo(t, e, a, r, o, i);
  }
};
function Xu(e) {
  return new fc(e);
}
function D0(e) {
  return new Ly(e);
}
function Ny(e) {
  this._context = e;
}
Ny.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length;
    if (r)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), r === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var a = Lh(e), i = Lh(t), o = 0, d = 1; d < r; ++o, ++d)
          this._context.bezierCurveTo(a[0][o], i[0][o], a[1][o], i[1][o], e[d], t[d]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Lh(e) {
  var t, r = e.length - 1, a, i = new Array(r), o = new Array(r), d = new Array(r);
  for (i[0] = 0, o[0] = 2, d[0] = e[0] + 2 * e[1], t = 1; t < r - 1; ++t)
    i[t] = 1, o[t] = 4, d[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[r - 1] = 2, o[r - 1] = 7, d[r - 1] = 8 * e[r - 1] + e[r], t = 1; t < r; ++t)
    a = i[t] / o[t - 1], o[t] -= a, d[t] -= a * d[t - 1];
  for (i[r - 1] = d[r - 1] / o[r - 1], t = r - 2; t >= 0; --t)
    i[t] = (d[t] - i[t + 1]) / o[t];
  for (o[r - 1] = (e[r] + i[r - 1]) / 2, t = 0; t < r - 1; ++t)
    o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function _0(e) {
  return new Ny(e);
}
function Mc(e, t) {
  this._context = e, this._t = t;
}
Mc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var r = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function O0(e) {
  return new Mc(e, 0.5);
}
function F0(e) {
  return new Mc(e, 0);
}
function M0(e) {
  return new Mc(e, 1);
}
function sl(e, t) {
  if ((d = e.length) > 1)
    for (var r = 1, a, i, o = e[t[0]], d, c = o.length; r < d; ++r)
      for (i = o, o = e[t[r]], a = 0; a < c; ++a)
        o[a][1] += o[a][0] = isNaN(i[a][1]) ? i[a][0] : i[a][1];
}
function ul(e) {
  for (var t = e.length, r = new Array(t); --t >= 0; )
    r[t] = t;
  return r;
}
function z0(e, t) {
  return e[t];
}
function sp() {
  var e = an([]), t = ul, r = sl, a = z0;
  function i(o) {
    var d = e.apply(this, arguments), c, s = o.length, p = d.length, m = new Array(p), v;
    for (c = 0; c < p; ++c) {
      for (var g = d[c], A = m[c] = new Array(s), k = 0, E; k < s; ++k)
        A[k] = E = [0, +a(o[k], g, k, o)], E.data = o[k];
      A.key = g;
    }
    for (c = 0, v = t(m); c < p; ++c)
      m[v[c]].index = c;
    return r(m, v), m;
  }
  return i.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : an(kf.call(o)), i) : e;
  }, i.value = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : an(+o), i) : a;
  }, i.order = function(o) {
    return arguments.length ? (t = o == null ? ul : typeof o == "function" ? o : an(kf.call(o)), i) : t;
  }, i.offset = function(o) {
    return arguments.length ? (r = o ?? sl, i) : r;
  }, i;
}
function B0(e, t) {
  if ((a = e.length) > 0) {
    for (var r, a, i = 0, o = e[0].length, d; i < o; ++i) {
      for (d = r = 0; r < a; ++r)
        d += e[r][i][1] || 0;
      if (d)
        for (r = 0; r < a; ++r)
          e[r][i][1] /= d;
    }
    sl(e, t);
  }
}
function $0(e, t) {
  if ((s = e.length) > 0)
    for (var r, a = 0, i, o, d, c, s, p = e[t[0]].length; a < p; ++a)
      for (d = c = 0, r = 0; r < s; ++r)
        (o = (i = e[t[r]][a])[1] - i[0]) > 0 ? (i[0] = d, i[1] = d += o) : o < 0 ? (i[1] = c, i[0] = c += o) : (i[0] = 0, i[1] = o);
}
function I0(e, t) {
  if ((i = e.length) > 0) {
    for (var r = 0, a = e[t[0]], i, o = a.length; r < o; ++r) {
      for (var d = 0, c = 0; d < i; ++d)
        c += e[d][r][1] || 0;
      a[r][1] += a[r][0] = -c / 2;
    }
    sl(e, t);
  }
}
function H0(e, t) {
  if (!(!((d = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var r = 0, a = 1, i, o, d; a < o; ++a) {
      for (var c = 0, s = 0, p = 0; c < d; ++c) {
        for (var m = e[t[c]], v = m[a][1] || 0, g = m[a - 1][1] || 0, A = (v - g) / 2, k = 0; k < c; ++k) {
          var E = e[t[k]], T = E[a][1] || 0, b = E[a - 1][1] || 0;
          A += T - b;
        }
        s += v, p += A * v;
      }
      i[a - 1][1] += i[a - 1][0] = r, s && (r -= p / s);
    }
    i[a - 1][1] += i[a - 1][0] = r, sl(e, t);
  }
}
function V0(e) {
  var t = e.map(W0);
  return ul(e).sort(function(r, a) {
    return t[r] - t[a];
  });
}
function W0(e) {
  for (var t = -1, r = 0, a = e.length, i, o = -1 / 0; ++t < a; )
    (i = +e[t][1]) > o && (o = i, r = t);
  return r;
}
function Ry(e) {
  var t = e.map(Dy);
  return ul(e).sort(function(r, a) {
    return t[r] - t[a];
  });
}
function Dy(e) {
  for (var t = 0, r = -1, a = e.length, i; ++r < a; )
    (i = +e[r][1]) && (t += i);
  return t;
}
function j0(e) {
  return Ry(e).reverse();
}
function U0(e) {
  var t = e.length, r, a, i = e.map(Dy), o = V0(e), d = 0, c = 0, s = [], p = [];
  for (r = 0; r < t; ++r)
    a = o[r], d < c ? (d += i[a], s.push(a)) : (c += i[a], p.push(a));
  return p.reverse().concat(s);
}
function K0(e) {
  return ul(e).reverse();
}
function Cn(e, t) {
  e(t);
}
var Ph = {
  ascending: Ry,
  descending: j0,
  insideout: U0,
  none: ul,
  reverse: K0
};
function up(e) {
  return e && Ph[e] || Ph.none;
}
var Nh = {
  expand: B0,
  diverging: $0,
  none: sl,
  silhouette: I0,
  wiggle: H0
};
function cp(e) {
  return e && Nh[e] || Nh.none;
}
function Y0(e) {
  var t = e === void 0 ? {} : e, r = t.innerRadius, a = t.outerRadius, i = t.cornerRadius, o = t.startAngle, d = t.endAngle, c = t.padAngle, s = t.padRadius, p = f0();
  return r != null && Cn(p.innerRadius, r), a != null && Cn(p.outerRadius, a), i != null && Cn(p.cornerRadius, i), o != null && Cn(p.startAngle, o), d != null && Cn(p.endAngle, d), c != null && Cn(p.padAngle, c), s != null && Cn(p.padRadius, s), p;
}
function dp(e) {
  var t = e === void 0 ? {} : e, r = t.x, a = t.x0, i = t.x1, o = t.y, d = t.y0, c = t.y1, s = t.defined, p = t.curve, m = p0();
  return r && Cn(m.x, r), a && Cn(m.x0, a), i && Cn(m.x1, i), o && Cn(m.y, o), d && Cn(m.y0, d), c && Cn(m.y1, c), s && m.defined(s), p && m.curve(p), m;
}
function _y(e) {
  var t = e === void 0 ? {} : e, r = t.x, a = t.y, i = t.defined, o = t.curve, d = by();
  return r && Cn(d.x, r), a && Cn(d.y, a), i && d.defined(i), o && d.curve(o), d;
}
function X0(e) {
  var t = e === void 0 ? {} : e, r = t.startAngle, a = t.endAngle, i = t.padAngle, o = t.value, d = t.sort, c = t.sortValues, s = y0();
  return (d === null || d != null) && s.sort(d), (c === null || c != null) && s.sortValues(c), o != null && s.value(o), i != null && Cn(s.padAngle, i), r != null && Cn(s.startAngle, r), a != null && Cn(s.endAngle, a), s;
}
function q0(e) {
  var t = e.keys, r = e.value, a = e.order, i = e.offset, o = sp();
  return t && o.keys(t), r && Cn(o.value, r), a && o.order(up(a)), i && o.offset(cp(i)), o;
}
var G0 = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function Tf() {
  return Tf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Tf.apply(this, arguments);
}
function Z0(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Q0(e) {
  var t = e.className, r = e.top, a = e.left, i = e.data, o = i === void 0 ? [] : i, d = e.centroid, c = e.innerRadius, s = c === void 0 ? 0 : c, p = e.outerRadius, m = e.cornerRadius, v = e.startAngle, g = e.endAngle, A = e.padAngle, k = e.padRadius, E = e.pieSort, T = e.pieSortValues, b = e.pieValue, y = e.children, N = e.fill, C = N === void 0 ? "" : N, P = Z0(e, G0), O = Y0({
    innerRadius: s,
    outerRadius: p,
    cornerRadius: m,
    padRadius: k
  }), K = X0({
    startAngle: v,
    endAngle: g,
    padAngle: A,
    value: b,
    sort: E,
    sortValues: T
  }), W = K(o);
  return y ? /* @__PURE__ */ n.createElement(n.Fragment, null, y({
    arcs: W,
    path: O,
    pie: K
  })) : /* @__PURE__ */ n.createElement(st, {
    className: "visx-pie-arcs-group",
    top: r,
    left: a
  }, W.map(function(J, j) {
    return /* @__PURE__ */ n.createElement("g", {
      key: "pie-arc-" + j
    }, /* @__PURE__ */ n.createElement("path", Tf({
      className: _n("visx-pie-arc", t),
      d: O(J) || "",
      fill: C == null || typeof C == "string" ? C : C(J)
    }, P)), d == null ? void 0 : d(O.centroid(J), J));
  }));
}
var J0 = ["from", "to", "fill", "className", "innerRef"];
function Cf() {
  return Cf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Cf.apply(this, arguments);
}
function eE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function mn(e) {
  var t = e.from, r = t === void 0 ? {
    x: 0,
    y: 0
  } : t, a = e.to, i = a === void 0 ? {
    x: 1,
    y: 1
  } : a, o = e.fill, d = o === void 0 ? "transparent" : o, c = e.className, s = e.innerRef, p = eE(e, J0), m = r.x === i.x || r.y === i.y;
  return /* @__PURE__ */ n.createElement("line", Cf({
    ref: s,
    className: _n("visx-line", c),
    x1: r.x,
    y1: r.y,
    x2: i.x,
    y2: i.y,
    fill: d,
    shapeRendering: m ? "crispEdges" : "auto"
  }, p));
}
var tE = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function Af() {
  return Af = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Af.apply(this, arguments);
}
function nE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Ir(e) {
  var t = e.children, r = e.data, a = r === void 0 ? [] : r, i = e.x, o = e.y, d = e.fill, c = d === void 0 ? "transparent" : d, s = e.className, p = e.curve, m = e.innerRef, v = e.defined, g = v === void 0 ? function() {
    return !0;
  } : v, A = nE(e, tE), k = _y({
    x: i,
    y: o,
    defined: g,
    curve: p
  });
  return t ? /* @__PURE__ */ n.createElement(n.Fragment, null, t({
    path: k
  })) : /* @__PURE__ */ n.createElement("path", Af({
    ref: m,
    className: _n("visx-linepath", s),
    d: k(a) || "",
    fill: c,
    strokeLinecap: "round"
  }, A));
}
var rE = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function Lf() {
  return Lf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Lf.apply(this, arguments);
}
function aE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function iE(e) {
  var t = e.children, r = e.x, a = e.x0, i = e.x1, o = e.y, d = e.y0, c = e.y1, s = e.data, p = s === void 0 ? [] : s, m = e.defined, v = m === void 0 ? function() {
    return !0;
  } : m, g = e.className, A = e.curve, k = e.innerRef, E = aE(e, rE), T = dp({
    x: r,
    x0: a,
    x1: i,
    y: o,
    y0: d,
    y1: c,
    defined: v,
    curve: A
  });
  return t ? /* @__PURE__ */ n.createElement(n.Fragment, null, t({
    path: T
  })) : /* @__PURE__ */ n.createElement("path", Lf({
    ref: k,
    className: _n("visx-area", g),
    d: T(p) || ""
  }, E));
}
var oE = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function Pf() {
  return Pf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Pf.apply(this, arguments);
}
function lE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function sE(e) {
  var t = e.x, r = e.x0, a = e.x1, i = e.y, o = e.y1, d = e.y0, c = e.yScale, s = e.data, p = s === void 0 ? [] : s, m = e.defined, v = m === void 0 ? function() {
    return !0;
  } : m, g = e.className, A = e.curve, k = e.innerRef, E = e.children, T = lE(e, oE), b = dp({
    x: t,
    x0: r,
    x1: a,
    defined: v,
    curve: A
  });
  return d == null ? b.y0(c.range()[0]) : Cn(b.y0, d), i && !o && Cn(b.y1, i), o && !i && Cn(b.y1, o), E ? /* @__PURE__ */ n.createElement(n.Fragment, null, E({
    path: b
  })) : /* @__PURE__ */ n.createElement("path", Pf({
    ref: k,
    className: _n("visx-area-closed", g),
    d: b(p) || ""
  }, T));
}
var uE = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function Nf() {
  return Nf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Nf.apply(this, arguments);
}
function cE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function dE(e) {
  var t = e.className, r = e.top, a = e.left, i = e.keys, o = e.data, d = e.curve, c = e.defined, s = e.x, p = e.x0, m = e.x1, v = e.y0, g = e.y1, A = e.value, k = e.order, E = e.offset, T = e.color, b = e.children, y = cE(e, uE), N = q0({
    keys: i,
    value: A,
    order: k,
    offset: E
  }), C = dp({
    x: s,
    x0: p,
    x1: m,
    y0: v,
    y1: g,
    curve: d,
    defined: c
  }), P = N(o);
  return b ? /* @__PURE__ */ n.createElement(n.Fragment, null, b({
    stacks: P,
    path: C,
    stack: N
  })) : /* @__PURE__ */ n.createElement(st, {
    top: r,
    left: a
  }, P.map(function(O, K) {
    return /* @__PURE__ */ n.createElement("path", Nf({
      className: _n("visx-stack", t),
      key: "stack-" + K + "-" + (O.key || ""),
      d: C(O) || "",
      fill: T == null ? void 0 : T(O.key, K)
    }, y));
  }));
}
var fE = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function pc() {
  return pc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, pc.apply(this, arguments);
}
function pE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function hE(e) {
  var t = e.className, r = e.top, a = e.left, i = e.keys, o = e.data, d = e.curve, c = e.defined, s = e.x, p = e.x0, m = e.x1, v = e.y0, g = e.y1, A = e.value, k = e.order, E = e.offset, T = e.color, b = e.children, y = pE(e, fE);
  return /* @__PURE__ */ n.createElement(dE, pc({
    className: t,
    top: r,
    left: a,
    keys: i,
    data: o,
    curve: d,
    defined: c,
    x: s,
    x0: p,
    x1: m,
    y0: v,
    y1: g,
    value: A,
    order: k,
    offset: E,
    color: T
  }, y), b || function(N) {
    var C = N.stacks, P = N.path;
    return C.map(function(O, K) {
      return /* @__PURE__ */ n.createElement("path", pc({
        className: _n("visx-area-stack", t),
        key: "area-stack-" + K + "-" + (O.key || ""),
        d: P(O) || "",
        fill: T == null ? void 0 : T(O.key, K)
      }, y));
    });
  });
}
function fp(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), r = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / r.length;
}
var mE = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function Rf() {
  return Rf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Rf.apply(this, arguments);
}
function yE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Oy(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.x0, d = e.x0Scale, c = e.x1Scale, s = e.yScale, p = e.color, m = e.keys, v = e.height, g = e.children, A = yE(e, mE), k = fp(c), E = t.map(function(T, b) {
    return {
      index: b,
      x0: d(o(T)),
      bars: m.map(function(y, N) {
        var C = T[y];
        return {
          index: N,
          key: y,
          value: C,
          width: k,
          x: c(y) || 0,
          y: s(C) || 0,
          color: p(y, N),
          height: v - (s(C) || 0)
        };
      })
    };
  });
  return g ? /* @__PURE__ */ n.createElement(n.Fragment, null, g(E)) : /* @__PURE__ */ n.createElement(st, {
    className: _n("visx-bar-group", r),
    top: a,
    left: i
  }, E.map(function(T) {
    return /* @__PURE__ */ n.createElement(st, {
      key: "bar-group-" + T.index + "-" + T.x0,
      left: T.x0
    }, T.bars.map(function(b) {
      return /* @__PURE__ */ n.createElement(Nr, Rf({
        key: "bar-group-bar-" + T.index + "-" + b.index + "-" + b.value + "-" + b.key,
        x: b.x,
        y: b.y,
        width: b.width,
        height: b.height,
        fill: b.color
      }, A));
    }));
  }));
}
function Fy(e) {
  return e == null ? void 0 : e[0];
}
function My(e) {
  return e == null ? void 0 : e[1];
}
var gE = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function Df() {
  return Df = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Df.apply(this, arguments);
}
function vE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function zy(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.x, d = e.y0, c = d === void 0 ? Fy : d, s = e.y1, p = s === void 0 ? My : s, m = e.xScale, v = e.yScale, g = e.color, A = e.keys, k = e.value, E = e.order, T = e.offset, b = e.children, y = vE(e, gE), N = sp();
  A && N.keys(A), k && Cn(N.value, k), E && N.order(up(E)), T && N.offset(cp(T));
  var C = N(t), P = fp(m), O = C.map(function(K, W) {
    var J = K.key;
    return {
      index: W,
      key: J,
      bars: K.map(function(j, B) {
        var Z = (v(c(j)) || 0) - (v(p(j)) || 0), te = v(p(j)), V = "bandwidth" in m ? m(o(j.data)) : Math.max((m(o(j.data)) || 0) - P / 2);
        return {
          bar: j,
          key: J,
          index: B,
          height: Z,
          width: P,
          x: V || 0,
          y: te || 0,
          color: g(K.key, B)
        };
      })
    };
  });
  return b ? /* @__PURE__ */ n.createElement(n.Fragment, null, b(O)) : /* @__PURE__ */ n.createElement(st, {
    className: _n("visx-bar-stack", r),
    top: a,
    left: i
  }, O.map(function(K) {
    return K.bars.map(function(W) {
      return /* @__PURE__ */ n.createElement(Nr, Df({
        key: "bar-stack-" + K.index + "-" + W.index,
        x: W.x,
        y: W.y,
        height: W.height,
        width: W.width,
        fill: W.color
      }, y));
    });
  }));
}
var xE = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function _f() {
  return _f = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, _f.apply(this, arguments);
}
function bE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function EE(e) {
  var t = e.data, r = e.className, a = e.top, i = e.left, o = e.y, d = e.x0, c = d === void 0 ? Fy : d, s = e.x1, p = s === void 0 ? My : s, m = e.xScale, v = e.yScale, g = e.color, A = e.keys, k = e.value, E = e.order, T = e.offset, b = e.children, y = bE(e, xE), N = sp();
  A && N.keys(A), k && Cn(N.value, k), E && N.order(up(E)), T && N.offset(cp(T));
  var C = N(t), P = fp(v), O = C.map(function(K, W) {
    var J = K.key;
    return {
      index: W,
      key: J,
      bars: K.map(function(j, B) {
        var Z = (m(p(j)) || 0) - (m(c(j)) || 0), te = m(c(j)), V = "bandwidth" in v ? v(o(j.data)) : Math.max((v(o(j.data)) || 0) - Z / 2);
        return {
          bar: j,
          key: J,
          index: B,
          height: P,
          width: Z,
          x: te || 0,
          y: V || 0,
          color: g(K.key, B)
        };
      })
    };
  });
  return b ? /* @__PURE__ */ n.createElement(n.Fragment, null, b(O)) : /* @__PURE__ */ n.createElement(st, {
    className: _n("visx-bar-stack-horizontal", r),
    top: a,
    left: i
  }, O.map(function(K) {
    return K.bars.map(function(W) {
      return /* @__PURE__ */ n.createElement(Nr, _f({
        key: "bar-stack-" + K.index + "-" + W.index,
        x: W.x,
        y: W.y,
        height: W.height,
        width: W.width,
        fill: W.color
      }, y));
    });
  }));
}
var Rh = "http://www.w3.org/2000/svg";
function SE(e) {
  var t = document.getElementById(e);
  if (!t) {
    var r = document.createElementNS(Rh, "svg");
    r.setAttribute("aria-hidden", "true"), r.style.opacity = "0", r.style.width = "0", r.style.height = "0", r.style.position = "absolute", r.style.top = "-100%", r.style.left = "-100%", r.style.pointerEvents = "none", t = document.createElementNS(Rh, "path"), t.setAttribute("id", e), r.appendChild(t), document.body.appendChild(r);
  }
  return t;
}
var kE = "__visx_splitpath_svg_path_measurement_id", Dh = function() {
  return !0;
};
function wE(e) {
  var t = e.path, r = e.pointsInSegments, a = e.segmentation, i = a === void 0 ? "x" : a, o = e.sampleRate, d = o === void 0 ? 1 : o;
  try {
    var c = SE(kE);
    c.setAttribute("d", t);
    var s = c.getTotalLength(), p = r.length, m = r.map(function() {
      return [];
    });
    if (i === "x" || i === "y")
      for (var v = r.map(function(te) {
        var V;
        return (V = te.find(function(ee) {
          return typeof ee[i] == "number";
        })) == null ? void 0 : V[i];
      }), g = c.getPointAtLength(0), A = c.getPointAtLength(s), k = A[i] > g[i], E = k ? v.map(function(te) {
        return typeof te > "u" ? Dh : function(V) {
          return V >= te;
        };
      }) : v.map(function(te) {
        return typeof te > "u" ? Dh : function(V) {
          return V <= te;
        };
      }), T = 0, b = 0; b <= s; b += d) {
        for (var y = c.getPointAtLength(b), N = y[i]; T < p - 1 && E[T + 1](N); )
          T += 1;
        m[T].push(y);
      }
    else {
      var C = r.map(function(te) {
        return te.length;
      }), P = C.reduce(function(te, V) {
        return te + V;
      }, 0), O = s / Math.max(1, P - 1), K = C.slice(0, p - 1);
      K.unshift(0);
      for (var W = 2; W < p; W += 1)
        K[W] += K[W - 1];
      for (var J = 0; J < p; J += 1)
        K[J] *= O;
      for (var j = 0, B = 0; B <= s; B += d) {
        for (var Z = c.getPointAtLength(B); j < p - 1 && B >= K[j + 1]; )
          j += 1;
        m[j].push(Z);
      }
    }
    return m;
  } catch {
    return [];
  }
}
function Of() {
  return Of = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Of.apply(this, arguments);
}
var TE = function(t) {
  return t.x || 0;
}, CE = function(t) {
  return t.y || 0;
};
function By(e) {
  var t = e.children, r = e.className, a = e.curve, i = e.defined, o = e.segmentation, d = e.sampleRate, c = e.segments, s = e.x, p = e.y, m = e.styles, v = ie.useMemo(function() {
    var k = typeof s == "number" || typeof s > "u" ? function() {
      return s;
    } : s, E = typeof p == "number" || typeof p > "u" ? function() {
      return p;
    } : p;
    return c.map(function(T) {
      return T.map(function(b, y) {
        return {
          x: k(b, y, T),
          y: E(b, y, T)
        };
      });
    });
  }, [s, p, c]), g = ie.useMemo(function() {
    var k = _y({
      x: s,
      y: p,
      defined: i,
      curve: a
    });
    return k(c.flat()) || "";
  }, [s, p, i, a, c]), A = ie.useMemo(function() {
    return wE({
      path: g,
      segmentation: o,
      pointsInSegments: v,
      sampleRate: d
    });
  }, [g, o, v, d]);
  return /* @__PURE__ */ n.createElement("g", null, A.map(function(k, E) {
    return t ? /* @__PURE__ */ n.createElement(n.Fragment, {
      key: E
    }, t({
      index: E,
      segment: k,
      styles: m[E] || m[E % m.length]
    })) : /* @__PURE__ */ n.createElement(Ir, Of({
      key: E,
      className: r,
      data: k,
      x: TE,
      y: CE
    }, m[E] || m[E % m.length]));
  }));
}
By.propTypes = {
  segments: je.arrayOf(je.array).isRequired,
  styles: je.array.isRequired,
  children: je.func,
  className: je.string
};
var AE = ["tooltipOpen"];
function LE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function hc() {
  return hc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, hc.apply(this, arguments);
}
function $y(e) {
  var t = ie.useState(hc({
    tooltipOpen: !1
  }, e)), r = t[0], a = t[1], i = ie.useCallback(function(d) {
    return a(typeof d == "function" ? function(c) {
      c.tooltipOpen;
      var s = LE(c, AE);
      return hc({}, d(s), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: d.tooltipLeft,
      tooltipTop: d.tooltipTop,
      tooltipData: d.tooltipData
    });
  }, [a]), o = ie.useCallback(function() {
    return a({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [a]);
  return {
    tooltipOpen: r.tooltipOpen,
    tooltipLeft: r.tooltipLeft,
    tooltipTop: r.tooltipTop,
    tooltipData: r.tooltipData,
    updateTooltip: a,
    showTooltip: i,
    hideTooltip: o
  };
}
var PE = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function mc() {
  return mc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, mc.apply(this, arguments);
}
function NE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var Iy = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, pp = /* @__PURE__ */ n.forwardRef(function(e, t) {
  var r = e.className, a = e.top, i = e.left, o = e.offsetLeft, d = o === void 0 ? 10 : o, c = e.offsetTop, s = c === void 0 ? 10 : c, p = e.style, m = p === void 0 ? Iy : p, v = e.children, g = e.unstyled, A = g === void 0 ? !1 : g, k = e.applyPositionStyle, E = k === void 0 ? !1 : k, T = NE(e, PE);
  return /* @__PURE__ */ n.createElement("div", mc({
    ref: t,
    className: _n("visx-tooltip", r),
    style: mc({
      top: a == null || s == null ? a : a + s,
      left: i == null || d == null ? i : i + d
    }, E && {
      position: "absolute"
    }, !A && m)
  }, T), v);
});
pp.propTypes = {
  children: je.node,
  className: je.string,
  left: je.number,
  offsetLeft: je.number,
  offsetTop: je.number,
  top: je.number,
  applyPositionStyle: je.bool,
  unstyled: je.bool
};
pp.displayName = "Tooltip";
const RE = pp;
function Ff() {
  return Ff = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ff.apply(this, arguments);
}
function DE(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _E(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Mf(e, t);
}
function Mf(e, t) {
  return Mf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, i) {
    return a.__proto__ = i, a;
  }, Mf(e, t);
}
var _h = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function OE(e) {
  var t;
  return t = /* @__PURE__ */ function(r) {
    _E(a, r);
    function a(o) {
      var d;
      return d = r.call(this, o) || this, d.state = {
        rect: void 0,
        parentRect: void 0
      }, d.nodeRef = /* @__PURE__ */ n.createRef(), d.getRects = d.getRects.bind(DE(d)), d;
    }
    var i = a.prototype;
    return i.componentDidMount = function() {
      var d, c = this;
      this.node = (d = this.nodeRef) != null && d.current ? this.nodeRef.current : Jg.findDOMNode(this), this.setState(function() {
        return c.getRects();
      });
    }, i.getRects = function() {
      if (!this.node)
        return this.state;
      var d = this.node, c = d.parentNode, s = d.getBoundingClientRect ? d.getBoundingClientRect() : _h, p = c != null && c.getBoundingClientRect ? c.getBoundingClientRect() : _h;
      return {
        rect: s,
        parentRect: p
      };
    }, i.render = function() {
      return /* @__PURE__ */ n.createElement(e, Ff({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, a;
  }(n.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var Hy = /* @__PURE__ */ ie.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), FE = Hy.Provider;
Hy.Consumer;
var ME = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function yc() {
  return yc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, yc.apply(this, arguments);
}
function zE(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Vy(e) {
  var t = e.children;
  e.getRects;
  var r = e.left, a = r === void 0 ? 0 : r, i = e.offsetLeft, o = i === void 0 ? 10 : i, d = e.offsetTop, c = d === void 0 ? 10 : d, s = e.parentRect, p = e.rect, m = e.style, v = m === void 0 ? Iy : m, g = e.top, A = g === void 0 ? 0 : g, k = e.unstyled, E = k === void 0 ? !1 : k, T = e.nodeRef, b = zE(e, ME), y, N = !1, C = !1;
  if (p && s) {
    var P = a, O = A;
    if (s.width) {
      var K = P + o + p.width - s.width, W = p.width - P - o;
      N = K > 0 && K > W;
    } else {
      var J = P + o + p.width - window.innerWidth, j = p.width - P - o;
      N = J > 0 && J > j;
    }
    if (s.height) {
      var B = O + c + p.height - s.height, Z = p.height - O - c;
      C = B > 0 && B > Z;
    } else
      C = O + c + p.height > window.innerHeight;
    P = N ? P - p.width - o : P + o, O = C ? O - p.height - c : O + c, P = Math.round(P), O = Math.round(O), y = "translate(" + P + "px, " + O + "px)";
  }
  return /* @__PURE__ */ n.createElement(RE, yc({
    ref: T,
    style: yc({
      left: 0,
      top: 0,
      transform: y
    }, !E && v)
  }, b), /* @__PURE__ */ n.createElement(FE, {
    value: {
      isFlippedVertically: !C,
      isFlippedHorizontally: !N
    }
  }, t));
}
Vy.propTypes = {
  nodeRef: je.oneOfType([je.string, je.func, je.object])
};
const Wy = OE(Vy), jy = (e) => {
  const {
    tableData: t,
    config: r,
    formatNumber: a,
    capitalize: i,
    formatDate: o,
    formatTooltipsDate: d,
    parseDate: c,
    setSharedFilter: s,
    isDraggingAnnotation: p
  } = ie.useContext(Et), { xScale: m, yScale: v, showTooltip: g, hideTooltip: A } = e, { xAxis: k, visualizationType: E, orientation: T, yAxis: b, runtime: y } = r, N = (re, G) => {
    var ue;
    let U = 0, q = Number(v.invert(re)), H = null, oe = null;
    for (let ke of (ue = r.runtime) == null ? void 0 : ue.seriesKeys)
      if (G.hasOwnProperty(ke) && (U += Number(G[ke]), U >= q)) {
        oe = G[ke], H = ke;
        break;
      }
    return [H, oe];
  }, C = (re, G, U, q) => {
    const H = U.general.showMissingDataLabel && (!G || G === "null");
    let oe = re === U.xAxis.dataKey ? G : a(G, q(re));
    return oe = H ? "N/A" : oe, oe;
  }, P = (re, G) => {
    const { x: U, y: q } = G, oe = {
      data: re || {},
      dataXPosition: U + 10,
      dataYPosition: q
    };
    return {
      tooltipLeft: oe.dataXPosition,
      tooltipTop: oe.dataYPosition,
      tooltipData: oe
    };
  }, O = (re, G) => {
    if (E === "Bump Chart" || (re.stopPropagation(), p))
      return;
    const U = Np(re), { x: q, y: H } = U, { data: oe, arc: ue } = G ?? {}, ke = J(q - Number(r.yAxis.size || 0)), De = E !== "Pie" ? r.runtime.series.filter((be) => be.tooltip === !0).map((be) => be.dataKey) : r.runtime.series.map((be) => be.dataKey);
    De.push(r.xAxis.dataKey), r.visualizationType === "Forecasting" && r.runtime.series.map((be) => {
      be.confidenceIntervals.map((He) => {
        He.showInTooltip && (De.push(He.high), De.push(He.low));
      });
    });
    function pe(be) {
      let He = [];
      for (let Ve in be)
        be.hasOwnProperty(Ve) && He.push(be[Ve].name);
      return He;
    }
    De.push(...pe(r.columns)), De.push(...pe(r.columns));
    const Be = Z(ke, De), qe = t.filter((be) => be[k.dataKey] === j(H)), Pe = T === "vertical" ? Be : qe, ve = (be) => {
      const He = r.runtime.series.filter((Oe) => Oe.dataKey === be)[0];
      return He != null && He.axis ? String(He.axis).toLowerCase() : "left";
    }, z = (() => {
      var Ge, Xe, rt;
      const be = r.columns, He = [], Ve = [];
      for (const [Ue, ze] of Object.entries(be)) {
        const Ne = {
          addColPrefix: r.columns[Ue].prefix,
          addColSuffix: r.columns[Ue].suffix,
          addColRoundTo: r.columns[Ue].roundToPlace ? r.columns[Ue].roundToPlace : "",
          addColCommas: r.columns[Ue].commas
        };
        let ot = null;
        r.visualizationType === "Pie" ? ot = ue == null ? void 0 : ue.data[ze.name] : ot = (Ge = Pe[0]) == null ? void 0 : Ge[ze.name];
        const nt = Yf(ot, "left", !0, r, Ne);
        ze.tooltips && He.push([ze.label, nt]);
      }
      const Oe = [];
      if (He.forEach((Ue) => {
        Oe.push([Ue[0], Ue[1]]);
      }), E === "Pie" && Ve.push(
        // ignore
        [r.xAxis.dataKey, oe],
        [r.runtime.yAxis.dataKey, a(ue == null ? void 0 : ue.data[r.runtime.yAxis.dataKey])],
        ["Percent", `${Math.round(((ue == null ? void 0 : ue.endAngle) - (ue == null ? void 0 : ue.startAngle)) * 180 / Math.PI / 360 * 100) + "%"}`]
      ), E === "Forest Plot" && Ve.push([r.xAxis.dataKey, j(H)]), E !== "Pie" && E !== "Forest Plot" && !r.tooltips.singleSeries && Ve.push(
        ...(rt = (Xe = te()) == null ? void 0 : Xe.filter(
          (Ue) => {
            var ze, Ne;
            return ((ze = r.runtime.series) == null ? void 0 : ze.find((ot) => ot.dataKey === Ue && (ot == null ? void 0 : ot.tooltip))) || ((Ne = r.xAxis) == null ? void 0 : Ne.dataKey) == Ue || E === "Forecasting";
          }
        )) == null ? void 0 : rt.flatMap((Ue) => {
          var ot;
          const ze = (ot = Pe[0]) == null ? void 0 : ot[Ue], Ne = C(Ue, ze, r, ve);
          return (ze == null || ze === "" || Ne === "N/A") && r.general.hideNullValue ? [] : [[Ue, Ne, ve(Ue)]];
        })
      ), E !== "Pie" && E !== "Forest Plot" && r.tooltips.singleSeries) {
        const [Ue, ze] = N(H, Pe[0]);
        if (Ue && ze) {
          Ve.push([r.xAxis.dataKey, ke]);
          const Ne = C(Ue, ze, r, ve);
          Ve.push([Ue, Ne]);
        }
      }
      return [...Ve, ...Oe];
    })();
    if (!z)
      return;
    const Re = P(z, U);
    g(Re);
  }, K = () => {
    r.visualizationType === "Area Chart" ? setTimeout(() => {
      A();
    }, 3e3) : A();
  }, W = (re) => {
    if (r.xAxis.type === "categorical" || r.visualizationType === "Combo") {
      let G = m.step();
      const q = Math.floor(Number(re) / G);
      return m.domain()[q - 1];
    }
    if (Dn(r.xAxis) && r.visualizationType !== "Combo") {
      const G = Kp((oe) => c(oe[r.xAxis.dataKey])).left, U = m.invert(m(re)), q = G(r.data, U, 1);
      return c(r.data[q - 1][r.xAxis.dataKey]);
    }
  }, J = (re, G = !1) => {
    if (E !== "Pie" && T !== "horizontal") {
      if (m.type === "point" || k.type === "continuous" || Dn(k)) {
        let U = null, q = Number.MAX_VALUE, H = re;
        return t.forEach((oe) => {
          const ue = Dn(k) ? m(c(oe[k.dataKey])) : m(oe[k.dataKey]);
          let ke = r.barHeight;
          const De = Math.abs(Number(ue - H + (G ? ke * 2 : 0)));
          De <= q && (q = De, U = (Dn(k), oe[k.dataKey]));
        }), U;
      }
      if (r.xAxis.type === "categorical" || E === "Combo" && T !== "horizontal" && E !== "Forest Plot") {
        let q = (m.range()[1] - m.range()[0]) / (m.domain().length + 1);
        const oe = Math.floor((Number(re) - q / 2) / q);
        return m.domain()[oe];
      }
      if (Dn(k) && E !== "Combo" && T !== "horizontal") {
        const U = Kp((ue) => c(ue[r.xAxis.dataKey])).left, q = m.invert(re), H = U(r.data, q, 1);
        return c(r.data[H - 1][r.xAxis.dataKey]);
      }
    }
  }, j = (re, G) => {
    if (E === "Pie")
      return;
    let U = Number.MAX_VALUE, q = null;
    return t.forEach((H, oe) => {
      const ue = v(E !== "Forest Plot" ? H[r.xAxis.dataKey] : oe), ke = Math.abs(ue - re);
      ke < U && (U = ke, q = G ? H[G] : H[r.xAxis.dataKey]);
    }), q;
  }, B = (re) => {
    var G, U;
    try {
      if (r.visualizationType === "Bump Chart")
        return;
      const q = Np(re), { x: H } = q;
      if (!H)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let oe = J(H, !0), ue = (G = r.data) == null ? void 0 : G.filter((ke) => ke[r.xAxis.dataKey] === oe);
      if (!oe)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (Dn(k) && oe && (oe = new Date(oe), oe = o(oe), ue = (U = r.data) == null ? void 0 : U.filter((ke) => o(new Date(ke[r.xAxis.dataKey])) === oe)), !ue[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${oe}`);
      s && (r != null && r.uid) && (ue != null && ue[0]) && s(r.uid, ue[0]);
    } catch (q) {
      console.error(q.message);
    }
  }, Z = (re, G) => {
    try {
      let U;
      return k.type === "categorical" ? U = t.filter((H) => H[k.dataKey] === re) : U = t.filter((H) => H[k.dataKey] === re), !U || U.length === 0 ? [] : U.map((H) => Object.fromEntries(Object.entries(H).filter(([oe, ue]) => G.includes(oe))));
    } catch (U) {
      console.error("COVE", U);
    }
  }, te = () => {
    var re;
    try {
      let G, U = [], q = [];
      if ((re = r.runtime.series) == null || re.forEach((H) => {
        H.type === "Forecasting" && (U.push(H.stageColumn), H == null || H.confidenceIntervals.forEach((oe) => {
          oe.showInTooltip === !0 && (q.push(oe.low), q.push(oe.high));
        }));
      }), !r.dashboard)
        switch (E) {
          case "Combo":
            G = [y.xAxis.dataKey, ...y == null ? void 0 : y.seriesKeys, ...q];
            break;
          case "Forecasting":
            G = [y.xAxis.dataKey, ...U, ...q];
            break;
          case "Line":
            G = [y.xAxis.dataKey, ...y == null ? void 0 : y.seriesKeys];
            break;
          case "Area Chart":
            G = [y.xAxis.dataKey, ...y == null ? void 0 : y.seriesKeys];
            break;
          case "Bar":
            G = T === "vertical" ? [y.xAxis.dataKey, ...y == null ? void 0 : y.seriesKeys] : [y.yAxis.dataKey, ...y == null ? void 0 : y.seriesKeys];
            break;
          case "Pie":
            G = [y.xAxis.dataKey, ...y == null ? void 0 : y.seriesKeys];
          default:
            throw new Error("No visualization type found in handleTooltipMouseOver");
        }
      return r.dashboard && (G = [
        y.xAxis.dataKey,
        ...y == null ? void 0 : y.barSeriesKeys,
        ...y == null ? void 0 : y.lineSeriesKeys,
        ...U,
        ...q
      ]), G;
    } catch (G) {
      console.error("COVE", G);
    }
  }, V = (re) => {
    const { dataXPosition: G, dataYPosition: U } = re;
    return {
      opacity: r.tooltips.opacity ? r.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${G}px, ${Number(U)}px)`
    };
  }, ee = (re) => {
    var U, q;
    let G = r.runtime.series.filter((H) => H.dataKey === re);
    return (U = G[0]) != null && U.name ? (q = G[0]) == null ? void 0 : q.name : re;
  };
  return {
    getIncludedTooltipSeries: te,
    getXValueFromCoordinate: J,
    getXValueFromCoordinateDate: W,
    getYScaleValues: Z,
    handleTooltipClick: B,
    handleTooltipMouseOff: K,
    handleTooltipMouseOver: O,
    TooltipListItem: ({ item: re }) => {
      var qe;
      const [G, U] = re, [q, H, oe] = U;
      if (E === "Forest Plot")
        return q === r.xAxis.dataKey ? /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(r.xAxis.dataKey ? `${r.xAxis.dataKey}: ` : "")} ${Dn(b) ? o(c(q, !1)) : H}`) : /* @__PURE__ */ n.createElement("li", { className: "tooltip-body" }, `${ee(q)}: ${a(H, "left")}`);
      const ue = r.tooltips.dateDisplayFormat ? d(c(H, !1)) : o(c(H, !1));
      if (E === "Bar" && T === "horizontal" && q === r.xAxis.dataKey)
        return /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(
          r.runtime.yAxis.label ? `${r.runtime.yAxis.label}: ` : ""
        )} ${r.xAxis.type === "date" ? ue : H}`);
      if (q === r.xAxis.dataKey)
        return /* @__PURE__ */ n.createElement("li", { className: "tooltip-heading" }, `${i(
          r.runtime.xAxis.label ? `${r.runtime.xAxis.label}: ` : ""
        )} ${Dn(k) ? ue : H}`);
      const { label: ke, displayGray: De } = r.visualizationSubType !== "stacked" && r.general.showSuppressedSymbol && ((qe = r.preliminaryData) == null ? void 0 : qe.find(
        (Pe) => Pe.label && Pe.type === "suppression" && Pe.displayTooltip && H === Pe.value && (!Pe.column || q === Pe.column)
      )) || {}, pe = ke || H, Be = De ? { color: "#8b8b8a" } : {};
      return /* @__PURE__ */ n.createElement("li", { style: Be, className: "tooltip-body" }, `${ee(q)}: ${pe}`);
    },
    tooltipStyles: V
  };
};
function hp(e, { threshold: t = 0, root: r = null, rootMargin: a = "0%", freezeOnceVisible: i = !1 }) {
  const [o, d] = ie.useState(), c = (o == null ? void 0 : o.isIntersecting) && i, s = ([p]) => {
    d(p);
  };
  return ie.useEffect(() => {
    setTimeout(() => {
      const p = e == null ? void 0 : e.current;
      if (!!!window.IntersectionObserver || c || !p)
        return;
      const v = { threshold: t, root: r, rootMargin: a }, g = new IntersectionObserver(s, v);
      return g.observe(p), () => g.disconnect();
    }, 500);
  }, [e, t, r, a, c]), o;
}
const zf = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let r = "";
    return e.visualizationType && (r += `${e.visualizationType} chart`), e.title && e.visualizationType && (r += ` with the title: ${e.title}`), r;
  } catch (r) {
    console.error("COVE: ", r.message);
  }
}, Fu = ({ startAngle: e, endAngle: t }) => ({
  startAngle: e,
  endAngle: t
}), BE = (e) => {
  const {
    transformedData: t,
    config: r,
    colorScale: a,
    currentViewport: i,
    seriesHighlight: o,
    isDraggingAnnotation: d
  } = ie.useContext(Et), { tooltipData: c, showTooltip: s, hideTooltip: p, tooltipOpen: m, tooltipLeft: v, tooltipTop: g } = $y(), { handleTooltipMouseOver: A, handleTooltipMouseOff: k, TooltipListItem: E } = jy({
    xScale: !1,
    yScale: !1,
    showTooltip: s,
    hideTooltip: p
  }), [T, b] = ie.useState(void 0), [y, N] = ie.useState(!1), C = Object.values(r.columns).filter((q) => q.showInViz), P = C.length > 0, O = P ? "pivotColumn" : void 0, K = ie.useMemo(() => {
    if (P) {
      let q = [];
      const H = r.yAxis.dataKey, oe = C.map((De) => De.name), ue = [H, ...oe], ke = r.xAxis.dataKey;
      return t.forEach((De) => {
        ue.forEach((pe) => {
          const Be = De[pe];
          Be && q.push({
            [O]: Be,
            [ke]: `${De[ke]} - ${pe}`
          });
        });
      }), q;
    }
    return t;
  }, [t, P]), W = ie.useMemo(() => {
    if (P) {
      const q = {};
      K.forEach((ue) => {
        q[ue[r.xAxis.dataKey]] || (q[ue[r.xAxis.dataKey]] = !0);
      });
      const H = Object.entries(q).length;
      let oe = r.customColors || pr[r.palette];
      return oe = oe.slice(0, H), Bi({
        domain: Object.keys(q),
        range: oe,
        unknown: null
      });
    }
    return a;
  }, [a, P]), J = ie.useRef(), j = hp(J, {
    freezeOnceVisible: !1
  });
  ie.useEffect(() => {
    document.querySelector(".isEditor") && N((H) => !0);
  }), ie.useEffect(() => {
    j != null && j.isIntersecting && r.animate && !y && setTimeout(() => {
      N(!0);
    }, 500);
  }, [j == null ? void 0 : j.isIntersecting, r.animate]);
  const B = ({ arcs: q, path: H, getKey: oe }) => {
    const ue = Ib(q, oe, {
      from: Fu,
      enter: Fu,
      update: Fu,
      leave: Fu
    });
    return ie.useEffect(() => {
      const ke = setTimeout(() => {
        p();
      }, 500);
      return () => {
        clearTimeout(ke);
      };
    }, [c]), /* @__PURE__ */ n.createElement(n.Fragment, null, ue.map(({ item: ke, props: De, key: pe }, Be) => /* @__PURE__ */ n.createElement(
      st,
      {
        className: ke.data[r.xAxis.dataKey],
        key: `${pe}-${Be}`,
        style: {
          opacity: r.legend.behavior === "highlight" && o.length > 0 && o.indexOf(ke.data[r.runtime.xAxis.dataKey]) === -1 ? 0.5 : 1
        }
      },
      /* @__PURE__ */ n.createElement(
        wh.path,
        {
          d: Ob(
            [De.startAngle, De.endAngle],
            (qe, Pe) => H({
              ...ke,
              startAngle: qe,
              endAngle: Pe
            })
          ),
          fill: W(ke.data[r.runtime.xAxis.dataKey]),
          onMouseEnter: (qe) => A(qe, { data: ke.data[r.runtime.xAxis.dataKey], arc: ke }),
          onMouseLeave: (qe) => k()
        }
      )
    )), ue.map(({ item: ke, key: De }, pe) => {
      const [Be, qe] = H.centroid(ke), Pe = ke.endAngle - ke.startAngle >= 0.1;
      let ve = "#FFF";
      return W(ke.data[r.runtime.xAxis.dataKey]) && (ve = rl(ve, W(ke.data[r.runtime.xAxis.dataKey]))), /* @__PURE__ */ n.createElement(wh.g, { key: `${De}${pe}` }, Pe && /* @__PURE__ */ n.createElement(
        St,
        {
          style: { fill: ve },
          x: Be,
          y: qe,
          dy: ".33em",
          textAnchor: "middle",
          pointerEvents: "none"
        },
        Math.round((ke.endAngle - ke.startAngle) * 180 / Math.PI / 360 * 100) + "%"
      ));
    }));
  };
  let Z = e.parentWidth, te = e.parentWidth;
  r && r.legend && !r.legend.hide && i === "lg" && (te = Number(Z) * 0.73);
  const V = r.heights.vertical, ee = Math.min(te, V) / 2, ce = V / 2, re = e.parentWidth / 2, G = r.pieType === "Donut" ? 75 : ee;
  ie.useEffect(() => {
    if (o.length > 0 && r.legend.behavior !== "highlight") {
      let q = [];
      K.forEach((H) => {
        o.indexOf(H[r.runtime.xAxis.dataKey]) !== -1 && q.push(H);
      }), b(q);
    } else
      b(void 0);
  }, [o]);
  const U = () => {
    let q = ["animated-pie", "group"];
    return (r.animate === !1 || y) && q.push("animated"), q.join(" ");
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Hr, { component: "PieChart" }, /* @__PURE__ */ n.createElement(
    "svg",
    {
      width: ee * 2,
      height: V,
      className: U(),
      role: "img",
      "aria-label": zf(r)
    },
    /* @__PURE__ */ n.createElement(st, { top: ce, left: ee }, /* @__PURE__ */ n.createElement(
      Q0,
      {
        data: T || K,
        pieValue: (q) => q[O || r.runtime.yAxis.dataKey],
        pieSortValues: () => -1,
        innerRadius: ee - G,
        outerRadius: ee
      },
      (q) => /* @__PURE__ */ n.createElement(B, { ...q, getKey: (H) => H.data[r.runtime.xAxis.dataKey] })
    ))
  ), /* @__PURE__ */ n.createElement("div", { ref: J }), !d && c && Object.entries(c.data).length > 0 && m && s && c.dataYPosition && c.dataXPosition && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${r.tooltips.opacity / 100}) !important`), /* @__PURE__ */ n.createElement(
    Wy,
    {
      key: Math.random(),
      className: "tooltip cdc-open-viz-module",
      left: v + re - ee,
      top: g
    },
    /* @__PURE__ */ n.createElement("ul", null, typeof c == "object" && Object.entries(c.data).map((q, H) => /* @__PURE__ */ n.createElement(E, { item: q, key: H })))
  ))));
};
function Rs(e) {
  return e.split("-")[1];
}
function mp(e) {
  return e === "y" ? "height" : "width";
}
function Vi(e) {
  return e.split("-")[0];
}
function Ds(e) {
  return ["top", "bottom"].includes(Vi(e)) ? "x" : "y";
}
function Oh(e, t, r) {
  let { reference: a, floating: i } = e;
  const o = a.x + a.width / 2 - i.width / 2, d = a.y + a.height / 2 - i.height / 2, c = Ds(t), s = mp(c), p = a[s] / 2 - i[s] / 2, m = c === "x";
  let v;
  switch (Vi(t)) {
    case "top":
      v = { x: o, y: a.y - i.height };
      break;
    case "bottom":
      v = { x: o, y: a.y + a.height };
      break;
    case "right":
      v = { x: a.x + a.width, y: d };
      break;
    case "left":
      v = { x: a.x - i.width, y: d };
      break;
    default:
      v = { x: a.x, y: a.y };
  }
  switch (Rs(t)) {
    case "start":
      v[c] -= p * (r && m ? -1 : 1);
      break;
    case "end":
      v[c] += p * (r && m ? -1 : 1);
  }
  return v;
}
function Uy(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function ys(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Ky(e, t) {
  var r;
  t === void 0 && (t = {});
  const { x: a, y: i, platform: o, rects: d, elements: c, strategy: s } = e, { boundary: p = "clippingAncestors", rootBoundary: m = "viewport", elementContext: v = "floating", altBoundary: g = !1, padding: A = 0 } = t, k = Uy(A), E = c[g ? v === "floating" ? "reference" : "floating" : v], T = ys(await o.getClippingRect({ element: (r = await (o.isElement == null ? void 0 : o.isElement(E))) == null || r ? E : E.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(c.floating)), boundary: p, rootBoundary: m, strategy: s })), b = v === "floating" ? { ...d.floating, x: a, y: i } : d.reference, y = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c.floating)), N = await (o.isElement == null ? void 0 : o.isElement(y)) && await (o.getScale == null ? void 0 : o.getScale(y)) || { x: 1, y: 1 }, C = ys(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: b, offsetParent: y, strategy: s }) : b);
  return { top: (T.top - C.top + k.top) / N.y, bottom: (C.bottom - T.bottom + k.bottom) / N.y, left: (T.left - C.left + k.left) / N.x, right: (C.right - T.right + k.right) / N.x };
}
const $E = Math.min, IE = Math.max;
function Bf(e, t, r) {
  return IE(e, $E(t, r));
}
["top", "right", "bottom", "left"].reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const HE = { left: "right", right: "left", bottom: "top", top: "bottom" };
function gc(e) {
  return e.replace(/left|right|bottom|top/g, (t) => HE[t]);
}
function VE(e, t, r) {
  r === void 0 && (r = !1);
  const a = Rs(e), i = Ds(e), o = mp(i);
  let d = i === "x" ? a === (r ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (d = gc(d)), { main: d, cross: gc(d) };
}
const WE = { start: "end", end: "start" };
function Gd(e) {
  return e.replace(/start|end/g, (t) => WE[t]);
}
const jE = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var r;
    const { placement: a, middlewareData: i, rects: o, initialPlacement: d, platform: c, elements: s } = t, { mainAxis: p = !0, crossAxis: m = !0, fallbackPlacements: v, fallbackStrategy: g = "bestFit", fallbackAxisSideDirection: A = "none", flipAlignment: k = !0, ...E } = e, T = Vi(a), b = Vi(d) === d, y = await (c.isRTL == null ? void 0 : c.isRTL(s.floating)), N = v || (b || !k ? [gc(d)] : function(B) {
      const Z = gc(B);
      return [Gd(B), Z, Gd(Z)];
    }(d));
    v || A === "none" || N.push(...function(B, Z, te, V) {
      const ee = Rs(B);
      let ce = function(re, G, U) {
        const q = ["left", "right"], H = ["right", "left"], oe = ["top", "bottom"], ue = ["bottom", "top"];
        switch (re) {
          case "top":
          case "bottom":
            return U ? G ? H : q : G ? q : H;
          case "left":
          case "right":
            return G ? oe : ue;
          default:
            return [];
        }
      }(Vi(B), te === "start", V);
      return ee && (ce = ce.map((re) => re + "-" + ee), Z && (ce = ce.concat(ce.map(Gd)))), ce;
    }(d, k, A, y));
    const C = [d, ...N], P = await Ky(t, E), O = [];
    let K = ((r = i.flip) == null ? void 0 : r.overflows) || [];
    if (p && O.push(P[T]), m) {
      const { main: B, cross: Z } = VE(a, o, y);
      O.push(P[B], P[Z]);
    }
    if (K = [...K, { placement: a, overflows: O }], !O.every((B) => B <= 0)) {
      var W, J;
      const B = (((W = i.flip) == null ? void 0 : W.index) || 0) + 1, Z = C[B];
      if (Z)
        return { data: { index: B, overflows: K }, reset: { placement: Z } };
      let te = (J = K.find((V) => V.overflows[0] <= 0)) == null ? void 0 : J.placement;
      if (!te)
        switch (g) {
          case "bestFit": {
            var j;
            const V = (j = K.map((ee) => [ee.placement, ee.overflows.filter((ce) => ce > 0).reduce((ce, re) => ce + re, 0)]).sort((ee, ce) => ee[1] - ce[1])[0]) == null ? void 0 : j[0];
            V && (te = V);
            break;
          }
          case "initialPlacement":
            te = d;
        }
      if (a !== te)
        return { reset: { placement: te } };
    }
    return {};
  } };
}, UE = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: r, y: a } = t, i = await async function(o, d) {
      const { placement: c, platform: s, elements: p } = o, m = await (s.isRTL == null ? void 0 : s.isRTL(p.floating)), v = Vi(c), g = Rs(c), A = Ds(c) === "x", k = ["left", "top"].includes(v) ? -1 : 1, E = m && A ? -1 : 1, T = typeof d == "function" ? d(o) : d;
      let { mainAxis: b, crossAxis: y, alignmentAxis: N } = typeof T == "number" ? { mainAxis: T, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...T };
      return g && typeof N == "number" && (y = g === "end" ? -1 * N : N), A ? { x: y * E, y: b * k } : { x: b * k, y: y * E };
    }(t, e);
    return { x: r + i.x, y: a + i.y, data: i };
  } };
}, KE = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: r, y: a, placement: i } = t, { mainAxis: o = !0, crossAxis: d = !1, limiter: c = { fn: (T) => {
      let { x: b, y } = T;
      return { x: b, y };
    } }, ...s } = e, p = { x: r, y: a }, m = await Ky(t, s), v = Ds(Vi(i)), g = v === "x" ? "y" : "x";
    let A = p[v], k = p[g];
    if (o) {
      const T = v === "y" ? "bottom" : "right";
      A = Bf(A + m[v === "y" ? "top" : "left"], A, A - m[T]);
    }
    if (d) {
      const T = g === "y" ? "bottom" : "right";
      k = Bf(k + m[g === "y" ? "top" : "left"], k, k - m[T]);
    }
    const E = c.fn({ ...t, [v]: A, [g]: k });
    return { ...E, data: { x: E.x - r, y: E.y - a } };
  } };
};
function Pr(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function ea(e) {
  return Pr(e).getComputedStyle(e);
}
const Fh = Math.min, gs = Math.max, vc = Math.round;
function Yy(e) {
  const t = ea(e);
  let r = parseFloat(t.width), a = parseFloat(t.height);
  const i = e.offsetWidth, o = e.offsetHeight, d = vc(r) !== i || vc(a) !== o;
  return d && (r = i, a = o), { width: r, height: a, fallback: d };
}
function Ya(e) {
  return qy(e) ? (e.nodeName || "").toLowerCase() : "";
}
let Mu;
function Xy() {
  if (Mu)
    return Mu;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (Mu = e.brands.map((t) => t.brand + "/" + t.version).join(" "), Mu) : navigator.userAgent;
}
function ta(e) {
  return e instanceof Pr(e).HTMLElement;
}
function Va(e) {
  return e instanceof Pr(e).Element;
}
function qy(e) {
  return e instanceof Pr(e).Node;
}
function Mh(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Pr(e).ShadowRoot || e instanceof ShadowRoot;
}
function zc(e) {
  const { overflow: t, overflowX: r, overflowY: a, display: i } = ea(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + r) && !["inline", "contents"].includes(i);
}
function YE(e) {
  return ["table", "td", "th"].includes(Ya(e));
}
function $f(e) {
  const t = /firefox/i.test(Xy()), r = ea(e), a = r.backdropFilter || r.WebkitBackdropFilter;
  return r.transform !== "none" || r.perspective !== "none" || !!a && a !== "none" || t && r.willChange === "filter" || t && !!r.filter && r.filter !== "none" || ["transform", "perspective"].some((i) => r.willChange.includes(i)) || ["paint", "layout", "strict", "content"].some((i) => {
    const o = r.contain;
    return o != null && o.includes(i);
  });
}
function Gy() {
  return !/^((?!chrome|android).)*safari/i.test(Xy());
}
function yp(e) {
  return ["html", "body", "#document"].includes(Ya(e));
}
function Zy(e) {
  return Va(e) ? e : e.contextElement;
}
const Qy = { x: 1, y: 1 };
function nl(e) {
  const t = Zy(e);
  if (!ta(t))
    return Qy;
  const r = t.getBoundingClientRect(), { width: a, height: i, fallback: o } = Yy(t);
  let d = (o ? vc(r.width) : r.width) / a, c = (o ? vc(r.height) : r.height) / i;
  return d && Number.isFinite(d) || (d = 1), c && Number.isFinite(c) || (c = 1), { x: d, y: c };
}
function Ls(e, t, r, a) {
  var i, o;
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  const d = e.getBoundingClientRect(), c = Zy(e);
  let s = Qy;
  t && (a ? Va(a) && (s = nl(a)) : s = nl(e));
  const p = c ? Pr(c) : window, m = !Gy() && r;
  let v = (d.left + (m && ((i = p.visualViewport) == null ? void 0 : i.offsetLeft) || 0)) / s.x, g = (d.top + (m && ((o = p.visualViewport) == null ? void 0 : o.offsetTop) || 0)) / s.y, A = d.width / s.x, k = d.height / s.y;
  if (c) {
    const E = Pr(c), T = a && Va(a) ? Pr(a) : a;
    let b = E.frameElement;
    for (; b && a && T !== E; ) {
      const y = nl(b), N = b.getBoundingClientRect(), C = getComputedStyle(b);
      N.x += (b.clientLeft + parseFloat(C.paddingLeft)) * y.x, N.y += (b.clientTop + parseFloat(C.paddingTop)) * y.y, v *= y.x, g *= y.y, A *= y.x, k *= y.y, v += N.x, g += N.y, b = Pr(b).frameElement;
    }
  }
  return { width: A, height: k, top: g, right: v + A, bottom: g + k, left: v, x: v, y: g };
}
function Wa(e) {
  return ((qy(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function Bc(e) {
  return Va(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function Jy(e) {
  return Ls(Wa(e)).left + Bc(e).scrollLeft;
}
function Ps(e) {
  if (Ya(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || Mh(e) && e.host || Wa(e);
  return Mh(t) ? t.host : t;
}
function eg(e) {
  const t = Ps(e);
  return yp(t) ? t.ownerDocument.body : ta(t) && zc(t) ? t : eg(t);
}
function tg(e, t) {
  var r;
  t === void 0 && (t = []);
  const a = eg(e), i = a === ((r = e.ownerDocument) == null ? void 0 : r.body), o = Pr(a);
  return i ? t.concat(o, o.visualViewport || [], zc(a) ? a : []) : t.concat(a, tg(a));
}
function zh(e, t, r) {
  return t === "viewport" ? ys(function(a, i) {
    const o = Pr(a), d = Wa(a), c = o.visualViewport;
    let s = d.clientWidth, p = d.clientHeight, m = 0, v = 0;
    if (c) {
      s = c.width, p = c.height;
      const g = Gy();
      (g || !g && i === "fixed") && (m = c.offsetLeft, v = c.offsetTop);
    }
    return { width: s, height: p, x: m, y: v };
  }(e, r)) : Va(t) ? ys(function(a, i) {
    const o = Ls(a, !0, i === "fixed"), d = o.top + a.clientTop, c = o.left + a.clientLeft, s = ta(a) ? nl(a) : { x: 1, y: 1 };
    return { width: a.clientWidth * s.x, height: a.clientHeight * s.y, x: c * s.x, y: d * s.y };
  }(t, r)) : ys(function(a) {
    const i = Wa(a), o = Bc(a), d = a.ownerDocument.body, c = gs(i.scrollWidth, i.clientWidth, d.scrollWidth, d.clientWidth), s = gs(i.scrollHeight, i.clientHeight, d.scrollHeight, d.clientHeight);
    let p = -o.scrollLeft + Jy(a);
    const m = -o.scrollTop;
    return ea(d).direction === "rtl" && (p += gs(i.clientWidth, d.clientWidth) - c), { width: c, height: s, x: p, y: m };
  }(Wa(e)));
}
function Bh(e) {
  return ta(e) && ea(e).position !== "fixed" ? e.offsetParent : null;
}
function $h(e) {
  const t = Pr(e);
  let r = Bh(e);
  for (; r && YE(r) && ea(r).position === "static"; )
    r = Bh(r);
  return r && (Ya(r) === "html" || Ya(r) === "body" && ea(r).position === "static" && !$f(r)) ? t : r || function(a) {
    let i = Ps(a);
    for (; ta(i) && !yp(i); ) {
      if ($f(i))
        return i;
      i = Ps(i);
    }
    return null;
  }(e) || t;
}
function XE(e, t, r) {
  const a = ta(t), i = Wa(t), o = Ls(e, !0, r === "fixed", t);
  let d = { scrollLeft: 0, scrollTop: 0 };
  const c = { x: 0, y: 0 };
  if (a || !a && r !== "fixed")
    if ((Ya(t) !== "body" || zc(i)) && (d = Bc(t)), ta(t)) {
      const s = Ls(t, !0);
      c.x = s.x + t.clientLeft, c.y = s.y + t.clientTop;
    } else
      i && (c.x = Jy(i));
  return { x: o.left + d.scrollLeft - c.x, y: o.top + d.scrollTop - c.y, width: o.width, height: o.height };
}
const qE = { getClippingRect: function(e) {
  let { element: t, boundary: r, rootBoundary: a, strategy: i } = e;
  const o = r === "clippingAncestors" ? function(p, m) {
    const v = m.get(p);
    if (v)
      return v;
    let g = tg(p).filter((T) => Va(T) && Ya(T) !== "body"), A = null;
    const k = ea(p).position === "fixed";
    let E = k ? Ps(p) : p;
    for (; Va(E) && !yp(E); ) {
      const T = ea(E), b = $f(E);
      (k ? b || A : b || T.position !== "static" || !A || !["absolute", "fixed"].includes(A.position)) ? A = T : g = g.filter((y) => y !== E), E = Ps(E);
    }
    return m.set(p, g), g;
  }(t, this._c) : [].concat(r), d = [...o, a], c = d[0], s = d.reduce((p, m) => {
    const v = zh(t, m, i);
    return p.top = gs(v.top, p.top), p.right = Fh(v.right, p.right), p.bottom = Fh(v.bottom, p.bottom), p.left = gs(v.left, p.left), p;
  }, zh(t, c, i));
  return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: r, strategy: a } = e;
  const i = ta(r), o = Wa(r);
  if (r === o)
    return t;
  let d = { scrollLeft: 0, scrollTop: 0 }, c = { x: 1, y: 1 };
  const s = { x: 0, y: 0 };
  if ((i || !i && a !== "fixed") && ((Ya(r) !== "body" || zc(o)) && (d = Bc(r)), ta(r))) {
    const p = Ls(r);
    c = nl(r), s.x = p.x + r.clientLeft, s.y = p.y + r.clientTop;
  }
  return { width: t.width * c.x, height: t.height * c.y, x: t.x * c.x - d.scrollLeft * c.x + s.x, y: t.y * c.y - d.scrollTop * c.y + s.y };
}, isElement: Va, getDimensions: function(e) {
  return ta(e) ? Yy(e) : e.getBoundingClientRect();
}, getOffsetParent: $h, getDocumentElement: Wa, getScale: nl, async getElementRects(e) {
  let { reference: t, floating: r, strategy: a } = e;
  const i = this.getOffsetParent || $h, o = this.getDimensions;
  return { reference: XE(t, await i(r), a), floating: { x: 0, y: 0, ...await o(r) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => ea(e).direction === "rtl" }, Ih = (e, t, r) => {
  const a = /* @__PURE__ */ new Map(), i = { platform: qE, ...r }, o = { ...i.platform, _c: a };
  return (async (d, c, s) => {
    const { placement: p = "bottom", strategy: m = "absolute", middleware: v = [], platform: g } = s, A = v.filter(Boolean), k = await (g.isRTL == null ? void 0 : g.isRTL(c));
    if (g == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), A.filter((P) => {
      let { name: O } = P;
      return O === "autoPlacement" || O === "flip";
    }).length > 1)
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    d && c || console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    let E = await g.getElementRects({ reference: d, floating: c, strategy: m }), { x: T, y: b } = Oh(E, p, k), y = p, N = {}, C = 0;
    for (let P = 0; P < A.length; P++) {
      const { name: O, fn: K } = A[P], { x: W, y: J, data: j, reset: B } = await K({ x: T, y: b, initialPlacement: p, placement: y, strategy: m, middlewareData: N, rects: E, platform: g, elements: { reference: d, floating: c } });
      T = W ?? T, b = J ?? b, N = { ...N, [O]: { ...N[O], ...j } }, C > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), B && C <= 50 && (C++, typeof B == "object" && (B.placement && (y = B.placement), B.rects && (E = B.rects === !0 ? await g.getElementRects({ reference: d, floating: c, strategy: m }) : B.rects), { x: T, y: b } = Oh(E, y, k)), P = -1);
    }
    return { x: T, y: b, placement: y, strategy: m, middlewareData: N };
  })(e, t, { ...i, platform: o });
};
var Ia, Wi = { exports: {} }, Hh = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Ia = Hh, function() {
  var e = n, t = 60103, r = 60106;
  Ia.Fragment = 60107;
  var a = 60108, i = 60114, o = 60109, d = 60110, c = 60112, s = 60113, p = 60120, m = 60115, v = 60116, g = 60121, A = 60122, k = 60117, E = 60129, T = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var b = Symbol.for;
    t = b("react.element"), r = b("react.portal"), Ia.Fragment = b("react.fragment"), a = b("react.strict_mode"), i = b("react.profiler"), o = b("react.provider"), d = b("react.context"), c = b("react.forward_ref"), s = b("react.suspense"), p = b("react.suspense_list"), m = b("react.memo"), v = b("react.lazy"), g = b("react.block"), A = b("react.server.block"), k = b("react.fundamental"), b("react.scope"), b("react.opaque.id"), E = b("react.debug_trace_mode"), b("react.offscreen"), T = b("react.legacy_hidden");
  }
  var y = typeof Symbol == "function" && Symbol.iterator, N = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function C(ve) {
    for (var $e = arguments.length, z = new Array($e > 1 ? $e - 1 : 0), Re = 1; Re < $e; Re++)
      z[Re - 1] = arguments[Re];
    P("error", ve, z);
  }
  function P(ve, $e, z) {
    var Re = N.ReactDebugCurrentFrame, be = "";
    if (J) {
      var He = K(J.type), Ve = J._owner;
      be += function(Ge, Xe, rt) {
        var Ue = "";
        if (Xe) {
          var ze = Xe.fileName, Ne = ze.replace(O, "");
          if (/^index\./.test(Ne)) {
            var ot = ze.match(O);
            if (ot) {
              var nt = ot[1];
              nt && (Ne = nt.replace(O, "") + "/" + Ne);
            }
          }
          Ue = " (at " + Ne + ":" + Xe.lineNumber + ")";
        } else
          rt && (Ue = " (created by " + rt + ")");
        return `
    in ` + (Ge || "Unknown") + Ue;
      }(He, J._source, Ve && K(Ve.type));
    }
    (be += Re.getStackAddendum()) !== "" && ($e += "%s", z = z.concat([be]));
    var Oe = z.map(function(Ge) {
      return "" + Ge;
    });
    Oe.unshift("Warning: " + $e), Function.prototype.apply.call(console[ve], console, Oe);
  }
  var O = /^(.*)[\\\/]/;
  function K(ve) {
    if (ve == null)
      return null;
    if (typeof ve.tag == "number" && C("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof ve == "function")
      return ve.displayName || ve.name || null;
    if (typeof ve == "string")
      return ve;
    switch (ve) {
      case Ia.Fragment:
        return "Fragment";
      case r:
        return "Portal";
      case i:
        return "Profiler";
      case a:
        return "StrictMode";
      case s:
        return "Suspense";
      case p:
        return "SuspenseList";
    }
    if (typeof ve == "object")
      switch (ve.$$typeof) {
        case d:
          return "Context.Consumer";
        case o:
          return "Context.Provider";
        case c:
          return Re = ve, be = ve.render, He = "ForwardRef", Ve = be.displayName || be.name || "", Re.displayName || (Ve !== "" ? He + "(" + Ve + ")" : He);
        case m:
          return K(ve.type);
        case g:
          return K(ve.render);
        case v:
          var $e = (z = ve)._status === 1 ? z._result : null;
          if ($e)
            return K($e);
      }
    var z, Re, be, He, Ve;
    return null;
  }
  var W = {};
  N.ReactDebugCurrentFrame;
  var J = null;
  function j(ve) {
    J = ve;
  }
  var B, Z, te, V = N.ReactCurrentOwner, ee = Object.prototype.hasOwnProperty, ce = { key: !0, ref: !0, __self: !0, __source: !0 };
  function re(ve, $e, z, Re, be) {
    var He, Ve = {}, Oe = null, Ge = null;
    for (He in z !== void 0 && (Oe = "" + z), function(Ue) {
      if (ee.call(Ue, "key")) {
        var ze = Object.getOwnPropertyDescriptor(Ue, "key").get;
        if (ze && ze.isReactWarning)
          return !1;
      }
      return Ue.key !== void 0;
    }($e) && (Oe = "" + $e.key), function(Ue) {
      if (ee.call(Ue, "ref")) {
        var ze = Object.getOwnPropertyDescriptor(Ue, "ref").get;
        if (ze && ze.isReactWarning)
          return !1;
      }
      return Ue.ref !== void 0;
    }($e) && (Ge = $e.ref, function(Ue, ze) {
      if (typeof Ue.ref == "string" && V.current && ze && V.current.stateNode !== ze) {
        var Ne = K(V.current.type);
        te[Ne] || (C('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', K(V.current.type), Ue.ref), te[Ne] = !0);
      }
    }($e, be)), $e)
      ee.call($e, He) && !ce.hasOwnProperty(He) && (Ve[He] = $e[He]);
    if (ve && ve.defaultProps) {
      var Xe = ve.defaultProps;
      for (He in Xe)
        Ve[He] === void 0 && (Ve[He] = Xe[He]);
    }
    if (Oe || Ge) {
      var rt = typeof ve == "function" ? ve.displayName || ve.name || "Unknown" : ve;
      Oe && function(Ue, ze) {
        var Ne = function() {
          B || (B = !0, C("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ze));
        };
        Ne.isReactWarning = !0, Object.defineProperty(Ue, "key", { get: Ne, configurable: !0 });
      }(Ve, rt), Ge && function(Ue, ze) {
        var Ne = function() {
          Z || (Z = !0, C("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ze));
        };
        Ne.isReactWarning = !0, Object.defineProperty(Ue, "ref", { get: Ne, configurable: !0 });
      }(Ve, rt);
    }
    return function(Ue, ze, Ne, ot, nt, mt, wt) {
      var xt = { $$typeof: t, type: Ue, key: ze, ref: Ne, props: wt, _owner: mt, _store: {} };
      return Object.defineProperty(xt._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(xt, "_self", { configurable: !1, enumerable: !1, writable: !1, value: ot }), Object.defineProperty(xt, "_source", { configurable: !1, enumerable: !1, writable: !1, value: nt }), Object.freeze && (Object.freeze(xt.props), Object.freeze(xt)), xt;
    }(ve, Oe, Ge, be, Re, V.current, Ve);
  }
  te = {};
  var G, U = N.ReactCurrentOwner;
  function q(ve) {
    J = ve;
  }
  function H(ve) {
    return typeof ve == "object" && ve !== null && ve.$$typeof === t;
  }
  function oe() {
    if (U.current) {
      var ve = K(U.current.type);
      if (ve)
        return `

Check the render method of \`` + ve + "`.";
    }
    return "";
  }
  N.ReactDebugCurrentFrame, G = !1;
  var ue = {};
  function ke(ve, $e) {
    if (ve._store && !ve._store.validated && ve.key == null) {
      ve._store.validated = !0;
      var z = function(be) {
        var He = oe();
        if (!He) {
          var Ve = typeof be == "string" ? be : be.displayName || be.name;
          Ve && (He = `

Check the top-level render call using <` + Ve + ">.");
        }
        return He;
      }($e);
      if (!ue[z]) {
        ue[z] = !0;
        var Re = "";
        ve && ve._owner && ve._owner !== U.current && (Re = " It was passed a child from " + K(ve._owner.type) + "."), q(ve), C('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', z, Re), q(null);
      }
    }
  }
  function De(ve, $e) {
    if (typeof ve == "object") {
      if (Array.isArray(ve))
        for (var z = 0; z < ve.length; z++) {
          var Re = ve[z];
          H(Re) && ke(Re, $e);
        }
      else if (H(ve))
        ve._store && (ve._store.validated = !0);
      else if (ve) {
        var be = function(Oe) {
          if (Oe === null || typeof Oe != "object")
            return null;
          var Ge = y && Oe[y] || Oe["@@iterator"];
          return typeof Ge == "function" ? Ge : null;
        }(ve);
        if (typeof be == "function" && be !== ve.entries)
          for (var He, Ve = be.call(ve); !(He = Ve.next()).done; )
            H(He.value) && ke(He.value, $e);
      }
    }
  }
  function pe(ve) {
    var $e, z = ve.type;
    if (z != null && typeof z != "string") {
      if (typeof z == "function")
        $e = z.propTypes;
      else {
        if (typeof z != "object" || z.$$typeof !== c && z.$$typeof !== m)
          return;
        $e = z.propTypes;
      }
      if ($e) {
        var Re = K(z);
        (function(be, He, Ve, Oe, Ge) {
          var Xe = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var rt in be)
            if (Xe(be, rt)) {
              var Ue = void 0;
              try {
                if (typeof be[rt] != "function") {
                  var ze = Error((Oe || "React class") + ": " + Ve + " type `" + rt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof be[rt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw ze.name = "Invariant Violation", ze;
                }
                Ue = be[rt](He, rt, Oe, Ve, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Ne) {
                Ue = Ne;
              }
              !Ue || Ue instanceof Error || (j(Ge), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Oe || "React class", Ve, rt, typeof Ue), j(null)), Ue instanceof Error && !(Ue.message in W) && (W[Ue.message] = !0, j(Ge), C("Failed %s type: %s", Ve, Ue.message), j(null));
            }
        })($e, ve.props, "prop", Re, ve);
      } else
        z.PropTypes === void 0 || G || (G = !0, C("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", K(z) || "Unknown"));
      typeof z.getDefaultProps != "function" || z.getDefaultProps.isReactClassApproved || C("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function Be(ve, $e, z, Re, be, He) {
    var Ve = function(Ne) {
      return typeof Ne == "string" || typeof Ne == "function" || Ne === Ia.Fragment || Ne === i || Ne === E || Ne === a || Ne === s || Ne === p || Ne === T || typeof Ne == "object" && Ne !== null && (Ne.$$typeof === v || Ne.$$typeof === m || Ne.$$typeof === o || Ne.$$typeof === d || Ne.$$typeof === c || Ne.$$typeof === k || Ne.$$typeof === g || Ne[0] === A);
    }(ve);
    if (!Ve) {
      var Oe = "";
      (ve === void 0 || typeof ve == "object" && ve !== null && Object.keys(ve).length === 0) && (Oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
      var Ge, Xe = function(Ne) {
        return Ne !== void 0 ? `

Check your code at ` + Ne.fileName.replace(/^.*[\\\/]/, "") + ":" + Ne.lineNumber + "." : "";
      }(be);
      Oe += Xe || oe(), ve === null ? Ge = "null" : Array.isArray(ve) ? Ge = "array" : ve !== void 0 && ve.$$typeof === t ? (Ge = "<" + (K(ve.type) || "Unknown") + " />", Oe = " Did you accidentally export a JSX literal instead of a component?") : Ge = typeof ve, C("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ge, Oe);
    }
    var rt = re(ve, $e, z, be, He);
    if (rt == null)
      return rt;
    if (Ve) {
      var Ue = $e.children;
      if (Ue !== void 0)
        if (Re)
          if (Array.isArray(Ue)) {
            for (var ze = 0; ze < Ue.length; ze++)
              De(Ue[ze], ve);
            Object.freeze && Object.freeze(Ue);
          } else
            C("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          De(Ue, ve);
    }
    return ve === Ia.Fragment ? function(Ne) {
      for (var ot = Object.keys(Ne.props), nt = 0; nt < ot.length; nt++) {
        var mt = ot[nt];
        if (mt !== "children" && mt !== "key") {
          q(Ne), C("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", mt), q(null);
          break;
        }
      }
      Ne.ref !== null && (q(Ne), C("Invalid attribute `ref` supplied to `React.Fragment`."), q(null));
    }(rt) : pe(rt), rt;
  }
  var qe = function(ve, $e, z) {
    return Be(ve, $e, z, !1);
  }, Pe = function(ve, $e, z) {
    return Be(ve, $e, z, !0);
  };
  Ia.jsx = qe, Ia.jsxs = Pe;
}(), Wi.exports = Hh;
var Zd, ng = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
Zd = ng, function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var r = [], a = 0; a < arguments.length; a++) {
      var i = arguments[a];
      if (i) {
        var o = typeof i;
        if (o === "string" || o === "number")
          r.push(i);
        else if (Array.isArray(i)) {
          if (i.length) {
            var d = t.apply(null, i);
            d && r.push(d);
          }
        } else if (o === "object") {
          if (i.toString !== Object.prototype.toString && !i.toString.toString().includes("[native code]")) {
            r.push(i.toString());
            continue;
          }
          for (var c in i)
            e.call(i, c) && i[c] && r.push(c);
        }
      }
    }
    return r.join(" ");
  }
  Zd.exports ? (t.default = t, Zd.exports = t) : window.classNames = t;
}();
var Vh = ng.exports;
const Wh = (e, t, r) => {
  let a = null;
  return function(...i) {
    a && clearTimeout(a), a = setTimeout(() => {
      a = null, r || e.apply(this, i);
    }, t);
  };
}, GE = ({ content: e }) => Wi.exports.jsx("span", { dangerouslySetInnerHTML: { __html: e } }), ZE = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} }, QE = ie.createContext({ getTooltipData: () => ZE });
function rg(e = "DEFAULT_TOOLTIP_ID") {
  return ie.useContext(QE).getTooltipData(e);
}
const jh = async ({ elementReference: e = null, tooltipReference: t = null, tooltipArrowReference: r = null, place: a = "top", offset: i = 10, strategy: o = "absolute", middlewares: d = [UE(Number(i)), jE(), KE({ padding: 5 })] }) => {
  if (!e)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  if (t === null)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  const c = d;
  return r ? (c.push({ name: "arrow", options: s = { element: r, padding: 5 }, async fn(p) {
    const { element: m, padding: v = 0 } = s || {}, { x: g, y: A, placement: k, rects: E, platform: T } = p;
    if (m == null)
      return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."), {};
    const b = Uy(v), y = { x: g, y: A }, N = Ds(k), C = mp(N), P = await T.getDimensions(m), O = N === "y" ? "top" : "left", K = N === "y" ? "bottom" : "right", W = E.reference[C] + E.reference[N] - y[N] - E.floating[C], J = y[N] - E.reference[N], j = await (T.getOffsetParent == null ? void 0 : T.getOffsetParent(m));
    let B = j ? N === "y" ? j.clientHeight || 0 : j.clientWidth || 0 : 0;
    B === 0 && (B = E.floating[C]);
    const Z = W / 2 - J / 2, te = b[O], V = B - P[C] - b[K], ee = B / 2 - P[C] / 2 + Z, ce = Bf(te, ee, V), re = Rs(k) != null && ee != ce && E.reference[C] / 2 - (ee < te ? b[O] : b[K]) - P[C] / 2 < 0;
    return { [N]: y[N] - (re ? ee < te ? te - ee : V - ee : 0), data: { [N]: ce, centerOffset: ee - ce } };
  } }), Ih(e, t, { placement: a, strategy: o, middleware: c }).then(({ x: p, y: m, placement: v, middlewareData: g }) => {
    var A, k;
    const E = { left: `${p}px`, top: `${m}px` }, { x: T, y: b } = (A = g.arrow) !== null && A !== void 0 ? A : { x: 0, y: 0 };
    return { tooltipStyles: E, tooltipArrowStyles: { left: T != null ? `${T}px` : "", top: b != null ? `${b}px` : "", right: "", bottom: "", [(k = { top: "bottom", right: "left", bottom: "top", left: "right" }[v.split("-")[0]]) !== null && k !== void 0 ? k : "bottom"]: "-4px" } };
  })) : Ih(e, t, { placement: "bottom", strategy: o, middleware: c }).then(({ x: p, y: m }) => ({ tooltipStyles: { left: `${p}px`, top: `${m}px` }, tooltipArrowStyles: {} }));
  var s;
};
var Di = { tooltip: "styles-module_tooltip__mnnfp", fixed: "styles-module_fixed__7ciUi", arrow: "styles-module_arrow__K0L3T", "no-arrow": "styles-module_no-arrow__KcFZN", clickable: "styles-module_clickable__Bv9o7", show: "styles-module_show__2NboJ", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
const Uh = ({ id: e, className: t, classNameArrow: r, variant: a = "dark", anchorId: i, anchorSelect: o, place: d = "top", offset: c = 10, events: s = ["hover"], positionStrategy: p = "absolute", middlewares: m, wrapper: v, children: g = null, delayShow: A = 0, delayHide: k = 0, float: E = !1, noArrow: T = !1, clickable: b = !1, closeOnEsc: y = !1, style: N, position: C, afterShow: P, afterHide: O, content: K, html: W, isOpen: J, setIsOpen: j, activeAnchor: B, setActiveAnchor: Z }) => {
  const te = ie.useRef(null), V = ie.useRef(null), ee = ie.useRef(null), ce = ie.useRef(null), [re, G] = ie.useState({}), [U, q] = ie.useState({}), [H, oe] = ie.useState(!1), [ue, ke] = ie.useState(!1), De = ie.useRef(!1), pe = ie.useRef(null), { anchorRefs: Be, setActiveAnchor: qe } = rg(e), Pe = ie.useRef(!1), [ve, $e] = ie.useState([]), z = ie.useRef(!1);
  ie.useLayoutEffect(() => (z.current = !0, () => {
    z.current = !1;
  }), []), ie.useEffect(() => {
    if (!H) {
      const nt = setTimeout(() => {
        ke(!1);
      }, 150);
      return () => {
        clearTimeout(nt);
      };
    }
    return () => null;
  }, [H]);
  const Re = (nt) => {
    z.current && (nt && ke(!0), setTimeout(() => {
      z.current && (j == null || j(nt), J === void 0 && oe(nt));
    }, 10));
  };
  ie.useEffect(() => {
    if (J === void 0)
      return () => null;
    J && ke(!0);
    const nt = setTimeout(() => {
      oe(J);
    }, 10);
    return () => {
      clearTimeout(nt);
    };
  }, [J]), ie.useEffect(() => {
    H !== De.current && (De.current = H, H ? P == null || P() : O == null || O());
  }, [H]);
  const be = (nt = k) => {
    ce.current && clearTimeout(ce.current), ce.current = setTimeout(() => {
      Pe.current || Re(!1);
    }, nt);
  }, He = (nt) => {
    var mt;
    if (!nt)
      return;
    A ? (ee.current && clearTimeout(ee.current), ee.current = setTimeout(() => {
      Re(!0);
    }, A)) : Re(!0);
    const wt = (mt = nt.currentTarget) !== null && mt !== void 0 ? mt : nt.target;
    Z(wt), qe({ current: wt }), ce.current && clearTimeout(ce.current);
  }, Ve = () => {
    b ? be(k || 100) : k ? be() : Re(!1), ee.current && clearTimeout(ee.current);
  }, Oe = ({ x: nt, y: mt }) => {
    jh({ place: d, offset: c, elementReference: { getBoundingClientRect: () => ({ x: nt, y: mt, width: 0, height: 0, top: mt, left: nt, right: nt, bottom: mt }) }, tooltipReference: te.current, tooltipArrowReference: V.current, strategy: p, middlewares: m }).then((wt) => {
      Object.keys(wt.tooltipStyles).length && G(wt.tooltipStyles), Object.keys(wt.tooltipArrowStyles).length && q(wt.tooltipArrowStyles);
    });
  }, Ge = (nt) => {
    if (!nt)
      return;
    const mt = nt, wt = { x: mt.clientX, y: mt.clientY };
    Oe(wt), pe.current = wt;
  }, Xe = (nt) => {
    He(nt), k && be();
  }, rt = (nt) => {
    const mt = document.querySelector(`[id='${i}']`);
    mt != null && mt.contains(nt.target) || ve.some((wt) => wt.contains(nt.target)) || Re(!1);
  }, Ue = (nt) => {
    nt.key === "Escape" && Re(!1);
  }, ze = Wh(He, 50), Ne = Wh(Ve, 50);
  ie.useEffect(() => {
    var nt, mt;
    const wt = new Set(Be);
    ve.forEach((Ut) => {
      wt.add({ current: Ut });
    });
    const xt = document.querySelector(`[id='${i}']`);
    xt && wt.add({ current: xt }), y && window.addEventListener("keydown", Ue);
    const Pt = [];
    s.find((Ut) => Ut === "click") && (window.addEventListener("click", rt), Pt.push({ event: "click", listener: Xe })), s.find((Ut) => Ut === "hover") && (Pt.push({ event: "mouseenter", listener: ze }, { event: "mouseleave", listener: Ne }, { event: "focus", listener: ze }, { event: "blur", listener: Ne }), E && Pt.push({ event: "mousemove", listener: Ge }));
    const ln = () => {
      Pe.current = !0;
    }, Gt = () => {
      Pe.current = !1, Ve();
    };
    return b && ((nt = te.current) === null || nt === void 0 || nt.addEventListener("mouseenter", ln), (mt = te.current) === null || mt === void 0 || mt.addEventListener("mouseleave", Gt)), Pt.forEach(({ event: Ut, listener: yt }) => {
      wt.forEach((Tt) => {
        var Dt;
        (Dt = Tt.current) === null || Dt === void 0 || Dt.addEventListener(Ut, yt);
      });
    }), () => {
      var Ut, yt;
      s.find((Tt) => Tt === "click") && window.removeEventListener("click", rt), y && window.removeEventListener("keydown", Ue), b && ((Ut = te.current) === null || Ut === void 0 || Ut.removeEventListener("mouseenter", ln), (yt = te.current) === null || yt === void 0 || yt.removeEventListener("mouseleave", Gt)), Pt.forEach(({ event: Tt, listener: Dt }) => {
        wt.forEach((nn) => {
          var yn;
          (yn = nn.current) === null || yn === void 0 || yn.removeEventListener(Tt, Dt);
        });
      });
    };
  }, [ue, Be, ve, y, s]), ie.useEffect(() => {
    let nt = o ?? "";
    !nt && e && (nt = `[data-tooltip-id='${e}']`);
    const mt = new MutationObserver((wt) => {
      const xt = [];
      wt.forEach((Pt) => {
        if (Pt.type === "attributes" && Pt.attributeName === "data-tooltip-id" && Pt.target.getAttribute("data-tooltip-id") === e && xt.push(Pt.target), Pt.type === "childList" && (B && [...Pt.removedNodes].some((ln) => !!ln.contains(B) && (ke(!1), Re(!1), Z(null), !0)), nt))
          try {
            const ln = [...Pt.addedNodes].filter((Gt) => Gt.nodeType === 1);
            xt.push(...ln.filter((Gt) => Gt.matches(nt))), xt.push(...ln.flatMap((Gt) => [...Gt.querySelectorAll(nt)]));
          } catch {
          }
      }), xt.length && $e((Pt) => [...Pt, ...xt]);
    });
    return mt.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"] }), () => {
      mt.disconnect();
    };
  }, [e, o, B]), ie.useEffect(() => {
    C ? Oe(C) : E ? pe.current && Oe(pe.current) : jh({ place: d, offset: c, elementReference: B, tooltipReference: te.current, tooltipArrowReference: V.current, strategy: p, middlewares: m }).then((nt) => {
      z.current && (Object.keys(nt.tooltipStyles).length && G(nt.tooltipStyles), Object.keys(nt.tooltipArrowStyles).length && q(nt.tooltipArrowStyles));
    });
  }, [H, B, K, W, d, c, p, C]), ie.useEffect(() => {
    var nt;
    const mt = document.querySelector(`[id='${i}']`), wt = [...ve, mt];
    B && wt.includes(B) || Z((nt = ve[0]) !== null && nt !== void 0 ? nt : mt);
  }, [i, ve, B]), ie.useEffect(() => () => {
    ee.current && clearTimeout(ee.current), ce.current && clearTimeout(ce.current);
  }, []), ie.useEffect(() => {
    let nt = o;
    if (!nt && e && (nt = `[data-tooltip-id='${e}']`), nt)
      try {
        const mt = Array.from(document.querySelectorAll(nt));
        $e(mt);
      } catch {
        $e([]);
      }
  }, [e, o]);
  const ot = !!(W || K || g) && H && Object.keys(re).length > 0;
  return ue ? Wi.exports.jsxs(v, { id: e, role: "tooltip", className: Vh("react-tooltip", Di.tooltip, Di[a], t, { [Di.show]: ot, [Di.fixed]: p === "fixed", [Di.clickable]: b }), style: { ...N, ...re }, ref: te, children: [W && Wi.exports.jsx(GE, { content: W }) || K || g, Wi.exports.jsx(v, { className: Vh("react-tooltip-arrow", Di.arrow, r, { [Di["no-arrow"]]: T }), style: U, ref: V })] }) : null;
}, xc = ({ id: e, anchorId: t, anchorSelect: r, content: a, html: i, className: o, classNameArrow: d, variant: c = "dark", place: s = "top", offset: p = 10, wrapper: m = "div", children: v = null, events: g = ["hover"], positionStrategy: A = "absolute", middlewares: k, delayShow: E = 0, delayHide: T = 0, float: b = !1, noArrow: y = !1, clickable: N = !1, closeOnEsc: C = !1, style: P, position: O, isOpen: K, setIsOpen: W, afterShow: J, afterHide: j }) => {
  const [B, Z] = ie.useState(a), [te, V] = ie.useState(i), [ee, ce] = ie.useState(s), [re, G] = ie.useState(c), [U, q] = ie.useState(p), [H, oe] = ie.useState(E), [ue, ke] = ie.useState(T), [De, pe] = ie.useState(b), [Be, qe] = ie.useState(m), [Pe, ve] = ie.useState(g), [$e, z] = ie.useState(A), [Re, be] = ie.useState(null), { anchorRefs: He, activeAnchor: Ve } = rg(e), Oe = (rt) => rt == null ? void 0 : rt.getAttributeNames().reduce((Ue, ze) => {
    var Ne;
    return ze.startsWith("data-tooltip-") && (Ue[ze.replace(/^data-tooltip-/, "")] = (Ne = rt == null ? void 0 : rt.getAttribute(ze)) !== null && Ne !== void 0 ? Ne : null), Ue;
  }, {}), Ge = (rt) => {
    const Ue = { place: (ze) => {
      var Ne;
      ce((Ne = ze) !== null && Ne !== void 0 ? Ne : s);
    }, content: (ze) => {
      Z(ze ?? a);
    }, html: (ze) => {
      V(ze ?? i);
    }, variant: (ze) => {
      var Ne;
      G((Ne = ze) !== null && Ne !== void 0 ? Ne : c);
    }, offset: (ze) => {
      q(ze === null ? p : Number(ze));
    }, wrapper: (ze) => {
      var Ne;
      qe((Ne = ze) !== null && Ne !== void 0 ? Ne : m);
    }, events: (ze) => {
      const Ne = ze == null ? void 0 : ze.split(" ");
      ve(Ne ?? g);
    }, "position-strategy": (ze) => {
      var Ne;
      z((Ne = ze) !== null && Ne !== void 0 ? Ne : A);
    }, "delay-show": (ze) => {
      oe(ze === null ? E : Number(ze));
    }, "delay-hide": (ze) => {
      ke(ze === null ? T : Number(ze));
    }, float: (ze) => {
      pe(ze === null ? b : !!ze);
    } };
    Object.values(Ue).forEach((ze) => ze(null)), Object.entries(rt).forEach(([ze, Ne]) => {
      var ot;
      (ot = Ue[ze]) === null || ot === void 0 || ot.call(Ue, Ne);
    });
  };
  ie.useEffect(() => {
    Z(a);
  }, [a]), ie.useEffect(() => {
    V(i);
  }, [i]), ie.useEffect(() => {
    ce(s);
  }, [s]), ie.useEffect(() => {
    var rt;
    const Ue = new Set(He);
    let ze = r;
    if (!ze && e && (ze = `[data-tooltip-id='${e}']`), ze)
      try {
        document.querySelectorAll(ze).forEach((wt) => {
          Ue.add({ current: wt });
        });
      } catch {
        console.warn(`[react-tooltip] "${r}" is not a valid CSS selector`);
      }
    const Ne = document.querySelector(`[id='${t}']`);
    if (Ne && Ue.add({ current: Ne }), !Ue.size)
      return () => null;
    const ot = (rt = Re ?? Ne) !== null && rt !== void 0 ? rt : Ve.current, nt = new MutationObserver((wt) => {
      wt.forEach((xt) => {
        var Pt;
        if (!ot || xt.type !== "attributes" || !(!((Pt = xt.attributeName) === null || Pt === void 0) && Pt.startsWith("data-tooltip-")))
          return;
        const ln = Oe(ot);
        Ge(ln);
      });
    }), mt = { attributes: !0, childList: !1, subtree: !1 };
    if (ot) {
      const wt = Oe(ot);
      Ge(wt), nt.observe(ot, mt);
    }
    return () => {
      nt.disconnect();
    };
  }, [He, Ve, Re, t, r]);
  const Xe = { id: e, anchorId: t, anchorSelect: r, className: o, classNameArrow: d, content: B, html: te, place: ee, variant: re, offset: U, wrapper: Be, events: Pe, positionStrategy: $e, middlewares: k, delayShow: H, delayHide: ue, float: De, noArrow: y, clickable: N, closeOnEsc: C, style: P, position: O, isOpen: K, setIsOpen: W, afterShow: J, afterHide: j, activeAnchor: Re, setActiveAnchor: (rt) => be(rt) };
  return v ? Wi.exports.jsx(Uh, { ...Xe, children: v }) : Wi.exports.jsx(Uh, { ...Xe });
};
function Kh(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r < a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function JE(e, t) {
  let r;
  if (t === void 0)
    for (const a of e)
      a != null && (r > a || r === void 0 && a >= a) && (r = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function Qd(e, t) {
  let r = 0;
  if (t === void 0)
    for (let a of e)
      (a = +a) && (r += a);
  else {
    let a = -1;
    for (let i of e)
      (i = +t(i, ++a, e)) && (r += i);
  }
  return r;
}
function eS(e) {
  return e.depth;
}
function tS(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function zu(e) {
  return function() {
    return e;
  };
}
function Yh(e, t) {
  return bc(e.source, t.source) || e.index - t.index;
}
function Xh(e, t) {
  return bc(e.target, t.target) || e.index - t.index;
}
function bc(e, t) {
  return e.y0 - t.y0;
}
function Jd(e) {
  return e.value;
}
function nS(e) {
  return e.index;
}
function rS(e) {
  return e.nodes;
}
function aS(e) {
  return e.links;
}
function qh(e, t) {
  const r = e.get(t);
  if (!r)
    throw new Error("missing: " + t);
  return r;
}
function Gh({ nodes: e }) {
  for (const t of e) {
    let r = t.y0, a = r;
    for (const i of t.sourceLinks)
      i.y0 = r + i.width / 2, r += i.width;
    for (const i of t.targetLinks)
      i.y1 = a + i.width / 2, a += i.width;
  }
}
function iS() {
  let e = 0, t = 0, r = 1, a = 1, i = 24, o = 8, d, c = nS, s = tS, p, m, v = rS, g = aS, A = 6;
  function k() {
    const ee = { nodes: v.apply(null, arguments), links: g.apply(null, arguments) };
    return E(ee), T(ee), b(ee), y(ee), P(ee), Gh(ee), ee;
  }
  k.update = function(ee) {
    return Gh(ee), ee;
  }, k.nodeId = function(ee) {
    return arguments.length ? (c = typeof ee == "function" ? ee : zu(ee), k) : c;
  }, k.nodeAlign = function(ee) {
    return arguments.length ? (s = typeof ee == "function" ? ee : zu(ee), k) : s;
  }, k.nodeSort = function(ee) {
    return arguments.length ? (p = ee, k) : p;
  }, k.nodeWidth = function(ee) {
    return arguments.length ? (i = +ee, k) : i;
  }, k.nodePadding = function(ee) {
    return arguments.length ? (o = d = +ee, k) : o;
  }, k.nodes = function(ee) {
    return arguments.length ? (v = typeof ee == "function" ? ee : zu(ee), k) : v;
  }, k.links = function(ee) {
    return arguments.length ? (g = typeof ee == "function" ? ee : zu(ee), k) : g;
  }, k.linkSort = function(ee) {
    return arguments.length ? (m = ee, k) : m;
  }, k.size = function(ee) {
    return arguments.length ? (e = t = 0, r = +ee[0], a = +ee[1], k) : [r - e, a - t];
  }, k.extent = function(ee) {
    return arguments.length ? (e = +ee[0][0], r = +ee[1][0], t = +ee[0][1], a = +ee[1][1], k) : [[e, t], [r, a]];
  }, k.iterations = function(ee) {
    return arguments.length ? (A = +ee, k) : A;
  };
  function E({ nodes: ee, links: ce }) {
    for (const [G, U] of ee.entries())
      U.index = G, U.sourceLinks = [], U.targetLinks = [];
    const re = new Map(ee.map((G, U) => [c(G, U, ee), G]));
    for (const [G, U] of ce.entries()) {
      U.index = G;
      let { source: q, target: H } = U;
      typeof q != "object" && (q = U.source = qh(re, q)), typeof H != "object" && (H = U.target = qh(re, H)), q.sourceLinks.push(U), H.targetLinks.push(U);
    }
    if (m != null)
      for (const { sourceLinks: G, targetLinks: U } of ee)
        G.sort(m), U.sort(m);
  }
  function T({ nodes: ee }) {
    for (const ce of ee)
      ce.value = ce.fixedValue === void 0 ? Math.max(Qd(ce.sourceLinks, Jd), Qd(ce.targetLinks, Jd)) : ce.fixedValue;
  }
  function b({ nodes: ee }) {
    const ce = ee.length;
    let re = new Set(ee), G = /* @__PURE__ */ new Set(), U = 0;
    for (; re.size; ) {
      for (const q of re) {
        q.depth = U;
        for (const { target: H } of q.sourceLinks)
          G.add(H);
      }
      if (++U > ce)
        throw new Error("circular link");
      re = G, G = /* @__PURE__ */ new Set();
    }
  }
  function y({ nodes: ee }) {
    const ce = ee.length;
    let re = new Set(ee), G = /* @__PURE__ */ new Set(), U = 0;
    for (; re.size; ) {
      for (const q of re) {
        q.height = U;
        for (const { source: H } of q.targetLinks)
          G.add(H);
      }
      if (++U > ce)
        throw new Error("circular link");
      re = G, G = /* @__PURE__ */ new Set();
    }
  }
  function N({ nodes: ee }) {
    const ce = Kh(ee, (U) => U.depth) + 1, re = (r - e - i) / (ce - 1), G = new Array(ce);
    for (const U of ee) {
      const q = Math.max(0, Math.min(ce - 1, Math.floor(s.call(null, U, ce))));
      U.layer = q, U.x0 = e + q * re, U.x1 = U.x0 + i, G[q] ? G[q].push(U) : G[q] = [U];
    }
    if (p)
      for (const U of G)
        U.sort(p);
    return G;
  }
  function C(ee) {
    const ce = JE(ee, (re) => (a - t - (re.length - 1) * d) / Qd(re, Jd));
    for (const re of ee) {
      let G = t;
      for (const U of re) {
        U.y0 = G, U.y1 = G + U.value * ce, G = U.y1 + d;
        for (const q of U.sourceLinks)
          q.width = q.value * ce;
      }
      G = (a - G + d) / (re.length + 1);
      for (let U = 0; U < re.length; ++U) {
        const q = re[U];
        q.y0 += G * (U + 1), q.y1 += G * (U + 1);
      }
      Z(re);
    }
  }
  function P(ee) {
    const ce = N(ee);
    d = Math.min(o, (a - t) / (Kh(ce, (re) => re.length) - 1)), C(ce);
    for (let re = 0; re < A; ++re) {
      const G = Math.pow(0.99, re), U = Math.max(1 - G, (re + 1) / A);
      K(ce, G, U), O(ce, G, U);
    }
  }
  function O(ee, ce, re) {
    for (let G = 1, U = ee.length; G < U; ++G) {
      const q = ee[G];
      for (const H of q) {
        let oe = 0, ue = 0;
        for (const { source: De, value: pe } of H.targetLinks) {
          let Be = pe * (H.layer - De.layer);
          oe += te(De, H) * Be, ue += Be;
        }
        if (!(ue > 0))
          continue;
        let ke = (oe / ue - H.y0) * ce;
        H.y0 += ke, H.y1 += ke, B(H);
      }
      p === void 0 && q.sort(bc), W(q, re);
    }
  }
  function K(ee, ce, re) {
    for (let G = ee.length, U = G - 2; U >= 0; --U) {
      const q = ee[U];
      for (const H of q) {
        let oe = 0, ue = 0;
        for (const { target: De, value: pe } of H.sourceLinks) {
          let Be = pe * (De.layer - H.layer);
          oe += V(H, De) * Be, ue += Be;
        }
        if (!(ue > 0))
          continue;
        let ke = (oe / ue - H.y0) * ce;
        H.y0 += ke, H.y1 += ke, B(H);
      }
      p === void 0 && q.sort(bc), W(q, re);
    }
  }
  function W(ee, ce) {
    const re = ee.length >> 1, G = ee[re];
    j(ee, G.y0 - d, re - 1, ce), J(ee, G.y1 + d, re + 1, ce), j(ee, a, ee.length - 1, ce), J(ee, t, 0, ce);
  }
  function J(ee, ce, re, G) {
    for (; re < ee.length; ++re) {
      const U = ee[re], q = (ce - U.y0) * G;
      q > 1e-6 && (U.y0 += q, U.y1 += q), ce = U.y1 + d;
    }
  }
  function j(ee, ce, re, G) {
    for (; re >= 0; --re) {
      const U = ee[re], q = (U.y1 - ce) * G;
      q > 1e-6 && (U.y0 -= q, U.y1 -= q), ce = U.y0 - d;
    }
  }
  function B({ sourceLinks: ee, targetLinks: ce }) {
    if (m === void 0) {
      for (const { source: { sourceLinks: re } } of ce)
        re.sort(Xh);
      for (const { target: { targetLinks: re } } of ee)
        re.sort(Yh);
    }
  }
  function Z(ee) {
    if (m === void 0)
      for (const { sourceLinks: ce, targetLinks: re } of ee)
        ce.sort(Xh), re.sort(Yh);
  }
  function te(ee, ce) {
    let re = ee.y0 - (ee.sourceLinks.length - 1) * d / 2;
    for (const { target: G, width: U } of ee.sourceLinks) {
      if (G === ce)
        break;
      re += U + d;
    }
    for (const { source: G, width: U } of ce.targetLinks) {
      if (G === ee)
        break;
      re -= U;
    }
    return re;
  }
  function V(ee, ce) {
    let re = ce.y0 - (ce.targetLinks.length - 1) * d / 2;
    for (const { source: G, width: U } of ce.targetLinks) {
      if (G === ee)
        break;
      re += U + d;
    }
    for (const { target: G, width: U } of ee.sourceLinks) {
      if (G === ce)
        break;
      re -= U;
    }
    return re;
  }
  return k;
}
function oS(e) {
  return [e.source.x1, e.y0];
}
function lS(e) {
  return [e.target.x0, e.y1];
}
function sS() {
  return E0().source(oS).target(lS);
}
var Xa = {}, _i = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zh;
function uS() {
  if (Zh)
    return _i;
  Zh = 1;
  var e = ie;
  function t(x) {
    for (var D = "https://reactjs.org/docs/error-decoder.html?invariant=" + x, M = 1; M < arguments.length; M++)
      D += "&args[]=" + encodeURIComponent(arguments[M]);
    return "Minified React error #" + x + "; visit " + D + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = Object.prototype.hasOwnProperty, a = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, i = {}, o = {};
  function d(x) {
    return r.call(o, x) ? !0 : r.call(i, x) ? !1 : a.test(x) ? o[x] = !0 : (i[x] = !0, !1);
  }
  function c(x, D, M, X, me, ge, Ae) {
    this.acceptsBooleans = D === 2 || D === 3 || D === 4, this.attributeName = X, this.attributeNamespace = me, this.mustUseProperty = M, this.propertyName = x, this.type = D, this.sanitizeURL = ge, this.removeEmptyString = Ae;
  }
  var s = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(x) {
    s[x] = new c(x, 0, !1, x, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(x) {
    var D = x[0];
    s[D] = new c(D, 1, !1, x[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(x) {
    s[x] = new c(x, 2, !1, x.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(x) {
    s[x] = new c(x, 2, !1, x, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(x) {
    s[x] = new c(x, 3, !1, x.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(x) {
    s[x] = new c(x, 3, !0, x, null, !1, !1);
  }), ["capture", "download"].forEach(function(x) {
    s[x] = new c(x, 4, !1, x, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(x) {
    s[x] = new c(x, 6, !1, x, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(x) {
    s[x] = new c(x, 5, !1, x.toLowerCase(), null, !1, !1);
  });
  var p = /[\-:]([a-z])/g;
  function m(x) {
    return x[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(x) {
    var D = x.replace(
      p,
      m
    );
    s[D] = new c(D, 1, !1, x, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(x) {
    var D = x.replace(p, m);
    s[D] = new c(D, 1, !1, x, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(x) {
    var D = x.replace(p, m);
    s[D] = new c(D, 1, !1, x, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(x) {
    s[x] = new c(x, 1, !1, x.toLowerCase(), null, !1, !1);
  }), s.xlinkHref = new c("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(x) {
    s[x] = new c(x, 1, !1, x.toLowerCase(), null, !0, !0);
  });
  var v = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, g = ["Webkit", "ms", "Moz", "O"];
  Object.keys(v).forEach(function(x) {
    g.forEach(function(D) {
      D = D + x.charAt(0).toUpperCase() + x.substring(1), v[D] = v[x];
    });
  });
  var A = /["'&<>]/;
  function k(x) {
    if (typeof x == "boolean" || typeof x == "number")
      return "" + x;
    x = "" + x;
    var D = A.exec(x);
    if (D) {
      var M = "", X, me = 0;
      for (X = D.index; X < x.length; X++) {
        switch (x.charCodeAt(X)) {
          case 34:
            D = "&quot;";
            break;
          case 38:
            D = "&amp;";
            break;
          case 39:
            D = "&#x27;";
            break;
          case 60:
            D = "&lt;";
            break;
          case 62:
            D = "&gt;";
            break;
          default:
            continue;
        }
        me !== X && (M += x.substring(me, X)), me = X + 1, M += D;
      }
      x = me !== X ? M + x.substring(me, X) : M;
    }
    return x;
  }
  var E = /([A-Z])/g, T = /^ms-/, b = Array.isArray;
  function y(x, D) {
    return { insertionMode: x, selectedValue: D };
  }
  function N(x, D, M) {
    switch (D) {
      case "select":
        return y(1, M.value != null ? M.value : M.defaultValue);
      case "svg":
        return y(2, null);
      case "math":
        return y(3, null);
      case "foreignObject":
        return y(1, null);
      case "table":
        return y(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return y(5, null);
      case "colgroup":
        return y(7, null);
      case "tr":
        return y(6, null);
    }
    return 4 <= x.insertionMode || x.insertionMode === 0 ? y(1, null) : x;
  }
  var C = /* @__PURE__ */ new Map();
  function P(x, D, M) {
    if (typeof M != "object")
      throw Error(t(62));
    D = !0;
    for (var X in M)
      if (r.call(M, X)) {
        var me = M[X];
        if (me != null && typeof me != "boolean" && me !== "") {
          if (X.indexOf("--") === 0) {
            var ge = k(X);
            me = k(("" + me).trim());
          } else {
            ge = X;
            var Ae = C.get(ge);
            Ae !== void 0 || (Ae = k(ge.replace(E, "-$1").toLowerCase().replace(T, "-ms-")), C.set(ge, Ae)), ge = Ae, me = typeof me == "number" ? me === 0 || r.call(v, X) ? "" + me : me + "px" : k(("" + me).trim());
          }
          D ? (D = !1, x.push(' style="', ge, ":", me)) : x.push(";", ge, ":", me);
        }
      }
    D || x.push('"');
  }
  function O(x, D, M, X) {
    switch (M) {
      case "style":
        P(x, D, X);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < M.length) || M[0] !== "o" && M[0] !== "O" || M[1] !== "n" && M[1] !== "N") {
      if (D = s.hasOwnProperty(M) ? s[M] : null, D !== null) {
        switch (typeof X) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!D.acceptsBooleans)
              return;
        }
        switch (M = D.attributeName, D.type) {
          case 3:
            X && x.push(" ", M, '=""');
            break;
          case 4:
            X === !0 ? x.push(" ", M, '=""') : X !== !1 && x.push(" ", M, '="', k(X), '"');
            break;
          case 5:
            isNaN(X) || x.push(" ", M, '="', k(X), '"');
            break;
          case 6:
            !isNaN(X) && 1 <= X && x.push(" ", M, '="', k(X), '"');
            break;
          default:
            D.sanitizeURL && (X = "" + X), x.push(" ", M, '="', k(X), '"');
        }
      } else if (d(M)) {
        switch (typeof X) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (D = M.toLowerCase().slice(0, 5), D !== "data-" && D !== "aria-")
              return;
        }
        x.push(" ", M, '="', k(X), '"');
      }
    }
  }
  function K(x, D, M) {
    if (D != null) {
      if (M != null)
        throw Error(t(60));
      if (typeof D != "object" || !("__html" in D))
        throw Error(t(61));
      D = D.__html, D != null && x.push("" + D);
    }
  }
  function W(x) {
    var D = "";
    return e.Children.forEach(x, function(M) {
      M != null && (D += M);
    }), D;
  }
  function J(x, D, M, X) {
    x.push(Z(M));
    var me = M = null, ge;
    for (ge in D)
      if (r.call(D, ge)) {
        var Ae = D[ge];
        if (Ae != null)
          switch (ge) {
            case "children":
              M = Ae;
              break;
            case "dangerouslySetInnerHTML":
              me = Ae;
              break;
            default:
              O(x, X, ge, Ae);
          }
      }
    return x.push(">"), K(x, me, M), typeof M == "string" ? (x.push(k(M)), null) : M;
  }
  var j = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, B = /* @__PURE__ */ new Map();
  function Z(x) {
    var D = B.get(x);
    if (D === void 0) {
      if (!j.test(x))
        throw Error(t(65, x));
      D = "<" + x, B.set(x, D);
    }
    return D;
  }
  function te(x, D, M, X, me) {
    switch (D) {
      case "select":
        x.push(Z("select"));
        var ge = null, Ae = null;
        for (pt in M)
          if (r.call(M, pt)) {
            var Ye = M[pt];
            if (Ye != null)
              switch (pt) {
                case "children":
                  ge = Ye;
                  break;
                case "dangerouslySetInnerHTML":
                  Ae = Ye;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  O(x, X, pt, Ye);
              }
          }
        return x.push(">"), K(x, Ae, ge), ge;
      case "option":
        Ae = me.selectedValue, x.push(Z("option"));
        var ut = Ye = null, gt = null, pt = null;
        for (ge in M)
          if (r.call(M, ge)) {
            var Mt = M[ge];
            if (Mt != null)
              switch (ge) {
                case "children":
                  Ye = Mt;
                  break;
                case "selected":
                  gt = Mt;
                  break;
                case "dangerouslySetInnerHTML":
                  pt = Mt;
                  break;
                case "value":
                  ut = Mt;
                default:
                  O(x, X, ge, Mt);
              }
          }
        if (Ae != null)
          if (M = ut !== null ? "" + ut : W(Ye), b(Ae)) {
            for (X = 0; X < Ae.length; X++)
              if ("" + Ae[X] === M) {
                x.push(' selected=""');
                break;
              }
          } else
            "" + Ae === M && x.push(' selected=""');
        else
          gt && x.push(' selected=""');
        return x.push(">"), K(x, pt, Ye), Ye;
      case "textarea":
        x.push(Z("textarea")), pt = Ae = ge = null;
        for (Ye in M)
          if (r.call(M, Ye) && (ut = M[Ye], ut != null))
            switch (Ye) {
              case "children":
                pt = ut;
                break;
              case "value":
                ge = ut;
                break;
              case "defaultValue":
                Ae = ut;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                O(
                  x,
                  X,
                  Ye,
                  ut
                );
            }
        if (ge === null && Ae !== null && (ge = Ae), x.push(">"), pt != null) {
          if (ge != null)
            throw Error(t(92));
          if (b(pt) && 1 < pt.length)
            throw Error(t(93));
          ge = "" + pt;
        }
        return typeof ge == "string" && ge[0] === `
` && x.push(`
`), ge !== null && x.push(k("" + ge)), null;
      case "input":
        x.push(Z("input")), ut = pt = Ye = ge = null;
        for (Ae in M)
          if (r.call(M, Ae) && (gt = M[Ae], gt != null))
            switch (Ae) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                ut = gt;
                break;
              case "defaultValue":
                Ye = gt;
                break;
              case "checked":
                pt = gt;
                break;
              case "value":
                ge = gt;
                break;
              default:
                O(x, X, Ae, gt);
            }
        return pt !== null ? O(x, X, "checked", pt) : ut !== null && O(x, X, "checked", ut), ge !== null ? O(x, X, "value", ge) : Ye !== null && O(x, X, "value", Ye), x.push("/>"), null;
      case "menuitem":
        x.push(Z("menuitem"));
        for (var Pn in M)
          if (r.call(M, Pn) && (ge = M[Pn], ge != null))
            switch (Pn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                O(x, X, Pn, ge);
            }
        return x.push(">"), null;
      case "title":
        x.push(Z("title")), ge = null;
        for (Mt in M)
          if (r.call(M, Mt) && (Ae = M[Mt], Ae != null))
            switch (Mt) {
              case "children":
                ge = Ae;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                O(x, X, Mt, Ae);
            }
        return x.push(">"), ge;
      case "listing":
      case "pre":
        x.push(Z(D)), Ae = ge = null;
        for (ut in M)
          if (r.call(M, ut) && (Ye = M[ut], Ye != null))
            switch (ut) {
              case "children":
                ge = Ye;
                break;
              case "dangerouslySetInnerHTML":
                Ae = Ye;
                break;
              default:
                O(x, X, ut, Ye);
            }
        if (x.push(">"), Ae != null) {
          if (ge != null)
            throw Error(t(60));
          if (typeof Ae != "object" || !("__html" in Ae))
            throw Error(t(61));
          M = Ae.__html, M != null && (typeof M == "string" && 0 < M.length && M[0] === `
` ? x.push(`
`, M) : x.push("" + M));
        }
        return typeof ge == "string" && ge[0] === `
` && x.push(`
`), ge;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        x.push(Z(D));
        for (var Nn in M)
          if (r.call(M, Nn) && (ge = M[Nn], ge != null))
            switch (Nn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, D));
              default:
                O(x, X, Nn, ge);
            }
        return x.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return J(
          x,
          M,
          D,
          X
        );
      case "html":
        return me.insertionMode === 0 && x.push("<!DOCTYPE html>"), J(x, M, D, X);
      default:
        if (D.indexOf("-") === -1 && typeof M.is != "string")
          return J(x, M, D, X);
        x.push(Z(D)), Ae = ge = null;
        for (gt in M)
          if (r.call(M, gt) && (Ye = M[gt], Ye != null))
            switch (gt) {
              case "children":
                ge = Ye;
                break;
              case "dangerouslySetInnerHTML":
                Ae = Ye;
                break;
              case "style":
                P(x, X, Ye);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                d(gt) && typeof Ye != "function" && typeof Ye != "symbol" && x.push(" ", gt, '="', k(Ye), '"');
            }
        return x.push(">"), K(x, Ae, ge), ge;
    }
  }
  function V(x, D, M) {
    if (x.push('<!--$?--><template id="'), M === null)
      throw Error(t(395));
    return x.push(M), x.push('"></template>');
  }
  function ee(x, D, M, X) {
    switch (M.insertionMode) {
      case 0:
      case 1:
        return x.push('<div hidden id="'), x.push(D.segmentPrefix), D = X.toString(16), x.push(D), x.push('">');
      case 2:
        return x.push('<svg aria-hidden="true" style="display:none" id="'), x.push(D.segmentPrefix), D = X.toString(16), x.push(D), x.push('">');
      case 3:
        return x.push('<math aria-hidden="true" style="display:none" id="'), x.push(D.segmentPrefix), D = X.toString(16), x.push(D), x.push('">');
      case 4:
        return x.push('<table hidden id="'), x.push(D.segmentPrefix), D = X.toString(16), x.push(D), x.push('">');
      case 5:
        return x.push('<table hidden><tbody id="'), x.push(D.segmentPrefix), D = X.toString(16), x.push(D), x.push('">');
      case 6:
        return x.push('<table hidden><tr id="'), x.push(D.segmentPrefix), D = X.toString(16), x.push(D), x.push('">');
      case 7:
        return x.push('<table hidden><colgroup id="'), x.push(D.segmentPrefix), D = X.toString(16), x.push(D), x.push('">');
      default:
        throw Error(t(397));
    }
  }
  function ce(x, D) {
    switch (D.insertionMode) {
      case 0:
      case 1:
        return x.push("</div>");
      case 2:
        return x.push("</svg>");
      case 3:
        return x.push("</math>");
      case 4:
        return x.push("</table>");
      case 5:
        return x.push("</tbody></table>");
      case 6:
        return x.push("</tr></table>");
      case 7:
        return x.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var re = /[<\u2028\u2029]/g;
  function G(x) {
    return JSON.stringify(x).replace(re, function(D) {
      switch (D) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function U(x, D) {
    return D = D === void 0 ? "" : D, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: D + "P:", segmentPrefix: D + "S:", boundaryPrefix: D + "B:", idPrefix: D, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: x };
  }
  function q(x, D, M, X) {
    return M.generateStaticMarkup ? (x.push(k(D)), !1) : (D === "" ? x = X : (X && x.push("<!-- -->"), x.push(k(D)), x = !0), x);
  }
  var H = Object.assign, oe = Symbol.for("react.element"), ue = Symbol.for("react.portal"), ke = Symbol.for("react.fragment"), De = Symbol.for("react.strict_mode"), pe = Symbol.for("react.profiler"), Be = Symbol.for("react.provider"), qe = Symbol.for("react.context"), Pe = Symbol.for("react.forward_ref"), ve = Symbol.for("react.suspense"), $e = Symbol.for("react.suspense_list"), z = Symbol.for("react.memo"), Re = Symbol.for("react.lazy"), be = Symbol.for("react.scope"), He = Symbol.for("react.debug_trace_mode"), Ve = Symbol.for("react.legacy_hidden"), Oe = Symbol.for("react.default_value"), Ge = Symbol.iterator;
  function Xe(x) {
    if (x == null)
      return null;
    if (typeof x == "function")
      return x.displayName || x.name || null;
    if (typeof x == "string")
      return x;
    switch (x) {
      case ke:
        return "Fragment";
      case ue:
        return "Portal";
      case pe:
        return "Profiler";
      case De:
        return "StrictMode";
      case ve:
        return "Suspense";
      case $e:
        return "SuspenseList";
    }
    if (typeof x == "object")
      switch (x.$$typeof) {
        case qe:
          return (x.displayName || "Context") + ".Consumer";
        case Be:
          return (x._context.displayName || "Context") + ".Provider";
        case Pe:
          var D = x.render;
          return x = x.displayName, x || (x = D.displayName || D.name || "", x = x !== "" ? "ForwardRef(" + x + ")" : "ForwardRef"), x;
        case z:
          return D = x.displayName || null, D !== null ? D : Xe(x.type) || "Memo";
        case Re:
          D = x._payload, x = x._init;
          try {
            return Xe(x(D));
          } catch {
          }
      }
    return null;
  }
  var rt = {};
  function Ue(x, D) {
    if (x = x.contextTypes, !x)
      return rt;
    var M = {}, X;
    for (X in x)
      M[X] = D[X];
    return M;
  }
  var ze = null;
  function Ne(x, D) {
    if (x !== D) {
      x.context._currentValue2 = x.parentValue, x = x.parent;
      var M = D.parent;
      if (x === null) {
        if (M !== null)
          throw Error(t(401));
      } else {
        if (M === null)
          throw Error(t(401));
        Ne(x, M);
      }
      D.context._currentValue2 = D.value;
    }
  }
  function ot(x) {
    x.context._currentValue2 = x.parentValue, x = x.parent, x !== null && ot(x);
  }
  function nt(x) {
    var D = x.parent;
    D !== null && nt(D), x.context._currentValue2 = x.value;
  }
  function mt(x, D) {
    if (x.context._currentValue2 = x.parentValue, x = x.parent, x === null)
      throw Error(t(402));
    x.depth === D.depth ? Ne(x, D) : mt(x, D);
  }
  function wt(x, D) {
    var M = D.parent;
    if (M === null)
      throw Error(t(402));
    x.depth === M.depth ? Ne(x, M) : wt(x, M), D.context._currentValue2 = D.value;
  }
  function xt(x) {
    var D = ze;
    D !== x && (D === null ? nt(x) : x === null ? ot(D) : D.depth === x.depth ? Ne(D, x) : D.depth > x.depth ? mt(D, x) : wt(D, x), ze = x);
  }
  var Pt = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(x, D) {
    x = x._reactInternals, x.queue !== null && x.queue.push(D);
  }, enqueueReplaceState: function(x, D) {
    x = x._reactInternals, x.replace = !0, x.queue = [D];
  }, enqueueForceUpdate: function() {
  } };
  function ln(x, D, M, X) {
    var me = x.state !== void 0 ? x.state : null;
    x.updater = Pt, x.props = M, x.state = me;
    var ge = { queue: [], replace: !1 };
    x._reactInternals = ge;
    var Ae = D.contextType;
    if (x.context = typeof Ae == "object" && Ae !== null ? Ae._currentValue2 : X, Ae = D.getDerivedStateFromProps, typeof Ae == "function" && (Ae = Ae(M, me), me = Ae == null ? me : H({}, me, Ae), x.state = me), typeof D.getDerivedStateFromProps != "function" && typeof x.getSnapshotBeforeUpdate != "function" && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function"))
      if (D = x.state, typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount(), D !== x.state && Pt.enqueueReplaceState(x, x.state, null), ge.queue !== null && 0 < ge.queue.length)
        if (D = ge.queue, Ae = ge.replace, ge.queue = null, ge.replace = !1, Ae && D.length === 1)
          x.state = D[0];
        else {
          for (ge = Ae ? D[0] : x.state, me = !0, Ae = Ae ? 1 : 0; Ae < D.length; Ae++) {
            var Ye = D[Ae];
            Ye = typeof Ye == "function" ? Ye.call(x, ge, M, X) : Ye, Ye != null && (me ? (me = !1, ge = H({}, ge, Ye)) : H(ge, Ye));
          }
          x.state = ge;
        }
      else
        ge.queue = null;
  }
  var Gt = { id: 1, overflow: "" };
  function Ut(x, D, M) {
    var X = x.id;
    x = x.overflow;
    var me = 32 - yt(X) - 1;
    X &= ~(1 << me), M += 1;
    var ge = 32 - yt(D) + me;
    if (30 < ge) {
      var Ae = me - me % 5;
      return ge = (X & (1 << Ae) - 1).toString(32), X >>= Ae, me -= Ae, { id: 1 << 32 - yt(D) + me | M << me | X, overflow: ge + x };
    }
    return { id: 1 << ge | M << me | X, overflow: x };
  }
  var yt = Math.clz32 ? Math.clz32 : nn, Tt = Math.log, Dt = Math.LN2;
  function nn(x) {
    return x >>>= 0, x === 0 ? 32 : 31 - (Tt(x) / Dt | 0) | 0;
  }
  function yn(x, D) {
    return x === D && (x !== 0 || 1 / x === 1 / D) || x !== x && D !== D;
  }
  var Nt = typeof Object.is == "function" ? Object.is : yn, un = null, Kt = null, Fe = null, bt = null, xn = !1, Ot = !1, Ln = 0, An = null, $t = 0;
  function It() {
    if (un === null)
      throw Error(t(321));
    return un;
  }
  function rn() {
    if (0 < $t)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function fn() {
    return bt === null ? Fe === null ? (xn = !1, Fe = bt = rn()) : (xn = !0, bt = Fe) : bt.next === null ? (xn = !1, bt = bt.next = rn()) : (xn = !0, bt = bt.next), bt;
  }
  function On() {
    Kt = un = null, Ot = !1, Fe = null, $t = 0, bt = An = null;
  }
  function Wn(x, D) {
    return typeof D == "function" ? D(x) : D;
  }
  function on(x, D, M) {
    if (un = It(), bt = fn(), xn) {
      var X = bt.queue;
      if (D = X.dispatch, An !== null && (M = An.get(X), M !== void 0)) {
        An.delete(X), X = bt.memoizedState;
        do
          X = x(X, M.action), M = M.next;
        while (M !== null);
        return bt.memoizedState = X, [X, D];
      }
      return [bt.memoizedState, D];
    }
    return x = x === Wn ? typeof D == "function" ? D() : D : M !== void 0 ? M(D) : D, bt.memoizedState = x, x = bt.queue = { last: null, dispatch: null }, x = x.dispatch = or.bind(null, un, x), [bt.memoizedState, x];
  }
  function er(x, D) {
    if (un = It(), bt = fn(), D = D === void 0 ? null : D, bt !== null) {
      var M = bt.memoizedState;
      if (M !== null && D !== null) {
        var X = M[1];
        e:
          if (X === null)
            X = !1;
          else {
            for (var me = 0; me < X.length && me < D.length; me++)
              if (!Nt(D[me], X[me])) {
                X = !1;
                break e;
              }
            X = !0;
          }
        if (X)
          return M[0];
      }
    }
    return x = x(), bt.memoizedState = [x, D], x;
  }
  function or(x, D, M) {
    if (25 <= $t)
      throw Error(t(301));
    if (x === un)
      if (Ot = !0, x = { action: M, next: null }, An === null && (An = /* @__PURE__ */ new Map()), M = An.get(D), M === void 0)
        An.set(D, x);
      else {
        for (D = M; D.next !== null; )
          D = D.next;
        D.next = x;
      }
  }
  function Xn() {
    throw Error(t(394));
  }
  function Ht() {
  }
  var gn = { readContext: function(x) {
    return x._currentValue2;
  }, useContext: function(x) {
    return It(), x._currentValue2;
  }, useMemo: er, useReducer: on, useRef: function(x) {
    un = It(), bt = fn();
    var D = bt.memoizedState;
    return D === null ? (x = { current: x }, bt.memoizedState = x) : D;
  }, useState: function(x) {
    return on(Wn, x);
  }, useInsertionEffect: Ht, useLayoutEffect: function() {
  }, useCallback: function(x, D) {
    return er(function() {
      return x;
    }, D);
  }, useImperativeHandle: Ht, useEffect: Ht, useDebugValue: Ht, useDeferredValue: function(x) {
    return It(), x;
  }, useTransition: function() {
    return It(), [
      !1,
      Xn
    ];
  }, useId: function() {
    var x = Kt.treeContext, D = x.overflow;
    x = x.id, x = (x & ~(1 << 32 - yt(x) - 1)).toString(32) + D;
    var M = Tn;
    if (M === null)
      throw Error(t(404));
    return D = Ln++, x = ":" + M.idPrefix + "R" + x, 0 < D && (x += "H" + D.toString(32)), x + ":";
  }, useMutableSource: function(x, D) {
    return It(), D(x._source);
  }, useSyncExternalStore: function(x, D, M) {
    if (M === void 0)
      throw Error(t(407));
    return M();
  } }, Tn = null, qn = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function jn(x) {
    return console.error(x), null;
  }
  function $n() {
  }
  function Te(x, D, M, X, me, ge, Ae, Ye, ut) {
    var gt = [], pt = /* @__PURE__ */ new Set();
    return D = { destination: null, responseState: D, progressiveChunkSize: X === void 0 ? 12800 : X, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: pt, pingedTasks: gt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: me === void 0 ? jn : me, onAllReady: ge === void 0 ? $n : ge, onShellReady: Ae === void 0 ? $n : Ae, onShellError: Ye === void 0 ? $n : Ye, onFatalError: ut === void 0 ? $n : ut }, M = se(D, 0, null, M, !1, !1), M.parentFlushed = !0, x = _e(D, x, null, M, pt, rt, null, Gt), gt.push(x), D;
  }
  function _e(x, D, M, X, me, ge, Ae, Ye) {
    x.allPendingTasks++, M === null ? x.pendingRootTasks++ : M.pendingTasks++;
    var ut = { node: D, ping: function() {
      var gt = x.pingedTasks;
      gt.push(ut), gt.length === 1 && et(x);
    }, blockedBoundary: M, blockedSegment: X, abortSet: me, legacyContext: ge, context: Ae, treeContext: Ye };
    return me.add(ut), ut;
  }
  function se(x, D, M, X, me, ge) {
    return { status: 0, id: -1, index: D, parentFlushed: !1, chunks: [], children: [], formatContext: X, boundary: M, lastPushedText: me, textEmbedded: ge };
  }
  function it(x, D) {
    if (x = x.onError(D), x != null && typeof x != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof x + '" instead');
    return x;
  }
  function ft(x, D) {
    var M = x.onShellError;
    M(D), M = x.onFatalError, M(D), x.destination !== null ? (x.status = 2, x.destination.destroy(D)) : (x.status = 1, x.fatalError = D);
  }
  function dt(x, D, M, X, me) {
    for (un = {}, Kt = D, Ln = 0, x = M(X, me); Ot; )
      Ot = !1, Ln = 0, $t += 1, bt = null, x = M(X, me);
    return On(), x;
  }
  function Ct(x, D, M, X) {
    var me = M.render(), ge = X.childContextTypes;
    if (ge != null) {
      var Ae = D.legacyContext;
      if (typeof M.getChildContext != "function")
        X = Ae;
      else {
        M = M.getChildContext();
        for (var Ye in M)
          if (!(Ye in ge))
            throw Error(t(108, Xe(X) || "Unknown", Ye));
        X = H({}, Ae, M);
      }
      D.legacyContext = X, at(x, D, me), D.legacyContext = Ae;
    } else
      at(x, D, me);
  }
  function Yt(x, D) {
    if (x && x.defaultProps) {
      D = H({}, D), x = x.defaultProps;
      for (var M in x)
        D[M] === void 0 && (D[M] = x[M]);
      return D;
    }
    return D;
  }
  function Zt(x, D, M, X, me) {
    if (typeof M == "function")
      if (M.prototype && M.prototype.isReactComponent) {
        me = Ue(M, D.legacyContext);
        var ge = M.contextType;
        ge = new M(X, typeof ge == "object" && ge !== null ? ge._currentValue2 : me), ln(ge, M, X, me), Ct(x, D, ge, M);
      } else {
        ge = Ue(M, D.legacyContext), me = dt(x, D, M, X, ge);
        var Ae = Ln !== 0;
        if (typeof me == "object" && me !== null && typeof me.render == "function" && me.$$typeof === void 0)
          ln(me, M, X, ge), Ct(x, D, me, M);
        else if (Ae) {
          X = D.treeContext, D.treeContext = Ut(X, 1, 0);
          try {
            at(x, D, me);
          } finally {
            D.treeContext = X;
          }
        } else
          at(x, D, me);
      }
    else if (typeof M == "string") {
      switch (me = D.blockedSegment, ge = te(me.chunks, M, X, x.responseState, me.formatContext), me.lastPushedText = !1, Ae = me.formatContext, me.formatContext = N(Ae, M, X), cn(x, D, ge), me.formatContext = Ae, M) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          me.chunks.push("</", M, ">");
      }
      me.lastPushedText = !1;
    } else {
      switch (M) {
        case Ve:
        case He:
        case De:
        case pe:
        case ke:
          at(x, D, X.children);
          return;
        case $e:
          at(x, D, X.children);
          return;
        case be:
          throw Error(t(343));
        case ve:
          e: {
            M = D.blockedBoundary, me = D.blockedSegment, ge = X.fallback, X = X.children, Ae = /* @__PURE__ */ new Set();
            var Ye = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Ae, errorDigest: null }, ut = se(x, me.chunks.length, Ye, me.formatContext, !1, !1);
            me.children.push(ut), me.lastPushedText = !1;
            var gt = se(x, 0, null, me.formatContext, !1, !1);
            gt.parentFlushed = !0, D.blockedBoundary = Ye, D.blockedSegment = gt;
            try {
              if (cn(
                x,
                D,
                X
              ), x.responseState.generateStaticMarkup || gt.lastPushedText && gt.textEmbedded && gt.chunks.push("<!-- -->"), gt.status = 1, Wt(Ye, gt), Ye.pendingTasks === 0)
                break e;
            } catch (pt) {
              gt.status = 4, Ye.forceClientRender = !0, Ye.errorDigest = it(x, pt);
            } finally {
              D.blockedBoundary = M, D.blockedSegment = me;
            }
            D = _e(x, ge, M, ut, Ae, D.legacyContext, D.context, D.treeContext), x.pingedTasks.push(D);
          }
          return;
      }
      if (typeof M == "object" && M !== null)
        switch (M.$$typeof) {
          case Pe:
            if (X = dt(x, D, M.render, X, me), Ln !== 0) {
              M = D.treeContext, D.treeContext = Ut(M, 1, 0);
              try {
                at(x, D, X);
              } finally {
                D.treeContext = M;
              }
            } else
              at(x, D, X);
            return;
          case z:
            M = M.type, X = Yt(M, X), Zt(x, D, M, X, me);
            return;
          case Be:
            if (me = X.children, M = M._context, X = X.value, ge = M._currentValue2, M._currentValue2 = X, Ae = ze, ze = X = { parent: Ae, depth: Ae === null ? 0 : Ae.depth + 1, context: M, parentValue: ge, value: X }, D.context = X, at(x, D, me), x = ze, x === null)
              throw Error(t(403));
            X = x.parentValue, x.context._currentValue2 = X === Oe ? x.context._defaultValue : X, x = ze = x.parent, D.context = x;
            return;
          case qe:
            X = X.children, X = X(M._currentValue2), at(x, D, X);
            return;
          case Re:
            me = M._init, M = me(M._payload), X = Yt(M, X), Zt(
              x,
              D,
              M,
              X,
              void 0
            );
            return;
        }
      throw Error(t(130, M == null ? M : typeof M, ""));
    }
  }
  function at(x, D, M) {
    if (D.node = M, typeof M == "object" && M !== null) {
      switch (M.$$typeof) {
        case oe:
          Zt(x, D, M.type, M.props, M.ref);
          return;
        case ue:
          throw Error(t(257));
        case Re:
          var X = M._init;
          M = X(M._payload), at(x, D, M);
          return;
      }
      if (b(M)) {
        tn(x, D, M);
        return;
      }
      if (M === null || typeof M != "object" ? X = null : (X = Ge && M[Ge] || M["@@iterator"], X = typeof X == "function" ? X : null), X && (X = X.call(M))) {
        if (M = X.next(), !M.done) {
          var me = [];
          do
            me.push(M.value), M = X.next();
          while (!M.done);
          tn(x, D, me);
        }
        return;
      }
      throw x = Object.prototype.toString.call(M), Error(t(31, x === "[object Object]" ? "object with keys {" + Object.keys(M).join(", ") + "}" : x));
    }
    typeof M == "string" ? (X = D.blockedSegment, X.lastPushedText = q(D.blockedSegment.chunks, M, x.responseState, X.lastPushedText)) : typeof M == "number" && (X = D.blockedSegment, X.lastPushedText = q(D.blockedSegment.chunks, "" + M, x.responseState, X.lastPushedText));
  }
  function tn(x, D, M) {
    for (var X = M.length, me = 0; me < X; me++) {
      var ge = D.treeContext;
      D.treeContext = Ut(ge, X, me);
      try {
        cn(x, D, M[me]);
      } finally {
        D.treeContext = ge;
      }
    }
  }
  function cn(x, D, M) {
    var X = D.blockedSegment.formatContext, me = D.legacyContext, ge = D.context;
    try {
      return at(x, D, M);
    } catch (ut) {
      if (On(), typeof ut == "object" && ut !== null && typeof ut.then == "function") {
        M = ut;
        var Ae = D.blockedSegment, Ye = se(x, Ae.chunks.length, null, Ae.formatContext, Ae.lastPushedText, !0);
        Ae.children.push(Ye), Ae.lastPushedText = !1, x = _e(x, D.node, D.blockedBoundary, Ye, D.abortSet, D.legacyContext, D.context, D.treeContext).ping, M.then(x, x), D.blockedSegment.formatContext = X, D.legacyContext = me, D.context = ge, xt(ge);
      } else
        throw D.blockedSegment.formatContext = X, D.legacyContext = me, D.context = ge, xt(ge), ut;
    }
  }
  function qt(x) {
    var D = x.blockedBoundary;
    x = x.blockedSegment, x.status = 3, Ee(this, D, x);
  }
  function Sn(x, D, M) {
    var X = x.blockedBoundary;
    x.blockedSegment.status = 3, X === null ? (D.allPendingTasks--, D.status !== 2 && (D.status = 2, D.destination !== null && D.destination.push(null))) : (X.pendingTasks--, X.forceClientRender || (X.forceClientRender = !0, x = M === void 0 ? Error(t(432)) : M, X.errorDigest = D.onError(x), X.parentFlushed && D.clientRenderedBoundaries.push(X)), X.fallbackAbortableTasks.forEach(function(me) {
      return Sn(me, D, M);
    }), X.fallbackAbortableTasks.clear(), D.allPendingTasks--, D.allPendingTasks === 0 && (X = D.onAllReady, X()));
  }
  function Wt(x, D) {
    if (D.chunks.length === 0 && D.children.length === 1 && D.children[0].boundary === null) {
      var M = D.children[0];
      M.id = D.id, M.parentFlushed = !0, M.status === 1 && Wt(x, M);
    } else
      x.completedSegments.push(D);
  }
  function Ee(x, D, M) {
    if (D === null) {
      if (M.parentFlushed) {
        if (x.completedRootSegment !== null)
          throw Error(t(389));
        x.completedRootSegment = M;
      }
      x.pendingRootTasks--, x.pendingRootTasks === 0 && (x.onShellError = $n, D = x.onShellReady, D());
    } else
      D.pendingTasks--, D.forceClientRender || (D.pendingTasks === 0 ? (M.parentFlushed && M.status === 1 && Wt(D, M), D.parentFlushed && x.completedBoundaries.push(D), D.fallbackAbortableTasks.forEach(qt, x), D.fallbackAbortableTasks.clear()) : M.parentFlushed && M.status === 1 && (Wt(D, M), D.completedSegments.length === 1 && D.parentFlushed && x.partialBoundaries.push(D)));
    x.allPendingTasks--, x.allPendingTasks === 0 && (x = x.onAllReady, x());
  }
  function et(x) {
    if (x.status !== 2) {
      var D = ze, M = qn.current;
      qn.current = gn;
      var X = Tn;
      Tn = x.responseState;
      try {
        var me = x.pingedTasks, ge;
        for (ge = 0; ge < me.length; ge++) {
          var Ae = me[ge], Ye = x, ut = Ae.blockedSegment;
          if (ut.status === 0) {
            xt(Ae.context);
            try {
              at(Ye, Ae, Ae.node), Ye.responseState.generateStaticMarkup || ut.lastPushedText && ut.textEmbedded && ut.chunks.push("<!-- -->"), Ae.abortSet.delete(Ae), ut.status = 1, Ee(Ye, Ae.blockedBoundary, ut);
            } catch (Rn) {
              if (On(), typeof Rn == "object" && Rn !== null && typeof Rn.then == "function") {
                var gt = Ae.ping;
                Rn.then(gt, gt);
              } else {
                Ae.abortSet.delete(Ae), ut.status = 4;
                var pt = Ae.blockedBoundary, Mt = Rn, Pn = it(Ye, Mt);
                if (pt === null ? ft(Ye, Mt) : (pt.pendingTasks--, pt.forceClientRender || (pt.forceClientRender = !0, pt.errorDigest = Pn, pt.parentFlushed && Ye.clientRenderedBoundaries.push(pt))), Ye.allPendingTasks--, Ye.allPendingTasks === 0) {
                  var Nn = Ye.onAllReady;
                  Nn();
                }
              }
            } finally {
            }
          }
        }
        me.splice(0, ge), x.destination !== null && Rt(x, x.destination);
      } catch (Rn) {
        it(x, Rn), ft(x, Rn);
      } finally {
        Tn = X, qn.current = M, M === gn && xt(D);
      }
    }
  }
  function Ze(x, D, M) {
    switch (M.parentFlushed = !0, M.status) {
      case 0:
        var X = M.id = x.nextSegmentId++;
        return M.lastPushedText = !1, M.textEmbedded = !1, x = x.responseState, D.push('<template id="'), D.push(x.placeholderPrefix), x = X.toString(16), D.push(x), D.push('"></template>');
      case 1:
        M.status = 2;
        var me = !0;
        X = M.chunks;
        var ge = 0;
        M = M.children;
        for (var Ae = 0; Ae < M.length; Ae++) {
          for (me = M[Ae]; ge < me.index; ge++)
            D.push(X[ge]);
          me = Ke(x, D, me);
        }
        for (; ge < X.length - 1; ge++)
          D.push(X[ge]);
        return ge < X.length && (me = D.push(X[ge])), me;
      default:
        throw Error(t(390));
    }
  }
  function Ke(x, D, M) {
    var X = M.boundary;
    if (X === null)
      return Ze(x, D, M);
    if (X.parentFlushed = !0, X.forceClientRender)
      return x.responseState.generateStaticMarkup || (X = X.errorDigest, D.push("<!--$!-->"), D.push("<template"), X && (D.push(' data-dgst="'), X = k(X), D.push(X), D.push('"')), D.push("></template>")), Ze(x, D, M), x = x.responseState.generateStaticMarkup ? !0 : D.push("<!--/$-->"), x;
    if (0 < X.pendingTasks) {
      X.rootSegmentID = x.nextSegmentId++, 0 < X.completedSegments.length && x.partialBoundaries.push(X);
      var me = x.responseState, ge = me.nextSuspenseID++;
      return me = me.boundaryPrefix + ge.toString(16), X = X.id = me, V(D, x.responseState, X), Ze(x, D, M), D.push("<!--/$-->");
    }
    if (X.byteSize > x.progressiveChunkSize)
      return X.rootSegmentID = x.nextSegmentId++, x.completedBoundaries.push(X), V(D, x.responseState, X.id), Ze(x, D, M), D.push("<!--/$-->");
    if (x.responseState.generateStaticMarkup || D.push("<!--$-->"), M = X.completedSegments, M.length !== 1)
      throw Error(t(391));
    return Ke(x, D, M[0]), x = x.responseState.generateStaticMarkup ? !0 : D.push("<!--/$-->"), x;
  }
  function Vt(x, D, M) {
    return ee(D, x.responseState, M.formatContext, M.id), Ke(x, D, M), ce(D, M.formatContext);
  }
  function At(x, D, M) {
    for (var X = M.completedSegments, me = 0; me < X.length; me++)
      Xt(x, D, M, X[me]);
    if (X.length = 0, x = x.responseState, X = M.id, M = M.rootSegmentID, D.push(x.startInlineScript), x.sentCompleteBoundaryFunction ? D.push('$RC("') : (x.sentCompleteBoundaryFunction = !0, D.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), X === null)
      throw Error(t(395));
    return M = M.toString(16), D.push(X), D.push('","'), D.push(x.segmentPrefix), D.push(M), D.push('")<\/script>');
  }
  function Xt(x, D, M, X) {
    if (X.status === 2)
      return !0;
    var me = X.id;
    if (me === -1) {
      if ((X.id = M.rootSegmentID) === -1)
        throw Error(t(392));
      return Vt(x, D, X);
    }
    return Vt(x, D, X), x = x.responseState, D.push(x.startInlineScript), x.sentCompleteSegmentFunction ? D.push('$RS("') : (x.sentCompleteSegmentFunction = !0, D.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), D.push(x.segmentPrefix), me = me.toString(16), D.push(me), D.push('","'), D.push(x.placeholderPrefix), D.push(me), D.push('")<\/script>');
  }
  function Rt(x, D) {
    try {
      var M = x.completedRootSegment;
      if (M !== null && x.pendingRootTasks === 0) {
        Ke(x, D, M), x.completedRootSegment = null;
        var X = x.responseState.bootstrapChunks;
        for (M = 0; M < X.length - 1; M++)
          D.push(X[M]);
        M < X.length && D.push(X[M]);
      }
      var me = x.clientRenderedBoundaries, ge;
      for (ge = 0; ge < me.length; ge++) {
        var Ae = me[ge];
        X = D;
        var Ye = x.responseState, ut = Ae.id, gt = Ae.errorDigest, pt = Ae.errorMessage, Mt = Ae.errorComponentStack;
        if (X.push(Ye.startInlineScript), Ye.sentClientRenderFunction ? X.push('$RX("') : (Ye.sentClientRenderFunction = !0, X.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), ut === null)
          throw Error(t(395));
        if (X.push(ut), X.push('"'), gt || pt || Mt) {
          X.push(",");
          var Pn = G(gt || "");
          X.push(Pn);
        }
        if (pt || Mt) {
          X.push(",");
          var Nn = G(pt || "");
          X.push(Nn);
        }
        if (Mt) {
          X.push(",");
          var Rn = G(Mt);
          X.push(Rn);
        }
        if (!X.push(")<\/script>")) {
          x.destination = null, ge++, me.splice(0, ge);
          return;
        }
      }
      me.splice(0, ge);
      var tr = x.completedBoundaries;
      for (ge = 0; ge < tr.length; ge++)
        if (!At(x, D, tr[ge])) {
          x.destination = null, ge++, tr.splice(0, ge);
          return;
        }
      tr.splice(0, ge);
      var Un = x.partialBoundaries;
      for (ge = 0; ge < Un.length; ge++) {
        var ye = Un[ge];
        e: {
          me = x, Ae = D;
          var fe = ye.completedSegments;
          for (Ye = 0; Ye < fe.length; Ye++)
            if (!Xt(me, Ae, ye, fe[Ye])) {
              Ye++, fe.splice(0, Ye);
              var xe = !1;
              break e;
            }
          fe.splice(0, Ye), xe = !0;
        }
        if (!xe) {
          x.destination = null, ge++, Un.splice(0, ge);
          return;
        }
      }
      Un.splice(0, ge);
      var Me = x.completedBoundaries;
      for (ge = 0; ge < Me.length; ge++)
        if (!At(x, D, Me[ge])) {
          x.destination = null, ge++, Me.splice(0, ge);
          return;
        }
      Me.splice(0, ge);
    } finally {
      x.allPendingTasks === 0 && x.pingedTasks.length === 0 && x.clientRenderedBoundaries.length === 0 && x.completedBoundaries.length === 0 && D.push(null);
    }
  }
  function Qt(x, D) {
    try {
      var M = x.abortableTasks;
      M.forEach(function(X) {
        return Sn(X, x, D);
      }), M.clear(), x.destination !== null && Rt(x, x.destination);
    } catch (X) {
      it(x, X), ft(x, X);
    }
  }
  function pn() {
  }
  function _t(x, D, M, X) {
    var me = !1, ge = null, Ae = "", Ye = { push: function(gt) {
      return gt !== null && (Ae += gt), !0;
    }, destroy: function(gt) {
      me = !0, ge = gt;
    } }, ut = !1;
    if (x = Te(x, U(M, D ? D.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, pn, void 0, function() {
      ut = !0;
    }, void 0, void 0), et(x), Qt(x, X), x.status === 1)
      x.status = 2, Ye.destroy(x.fatalError);
    else if (x.status !== 2 && x.destination === null) {
      x.destination = Ye;
      try {
        Rt(x, Ye);
      } catch (gt) {
        it(x, gt), ft(x, gt);
      }
    }
    if (me)
      throw ge;
    if (!ut)
      throw Error(t(426));
    return Ae;
  }
  return _i.renderToNodeStream = function() {
    throw Error(t(207));
  }, _i.renderToStaticMarkup = function(x, D) {
    return _t(x, D, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, _i.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, _i.renderToString = function(x, D) {
    return _t(x, D, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, _i.version = "18.2.0", _i;
}
var Bu = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Qh;
function cS() {
  if (Qh)
    return Bu;
  Qh = 1;
  var e = ie;
  function t(S) {
    for (var _ = "https://reactjs.org/docs/error-decoder.html?invariant=" + S, I = 1; I < arguments.length; I++)
      _ += "&args[]=" + encodeURIComponent(arguments[I]);
    return "Minified React error #" + S + "; visit " + _ + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = null, a = 0;
  function i(S, _) {
    if (_.length !== 0)
      if (512 < _.length)
        0 < a && (S.enqueue(new Uint8Array(r.buffer, 0, a)), r = new Uint8Array(512), a = 0), S.enqueue(_);
      else {
        var I = r.length - a;
        I < _.length && (I === 0 ? S.enqueue(r) : (r.set(_.subarray(0, I), a), S.enqueue(r), _ = _.subarray(I)), r = new Uint8Array(512), a = 0), r.set(_, a), a += _.length;
      }
  }
  function o(S, _) {
    return i(S, _), !0;
  }
  function d(S) {
    r && 0 < a && (S.enqueue(new Uint8Array(r.buffer, 0, a)), r = null, a = 0);
  }
  var c = new TextEncoder();
  function s(S) {
    return c.encode(S);
  }
  function p(S) {
    return c.encode(S);
  }
  function m(S, _) {
    typeof S.error == "function" ? S.error(_) : S.close();
  }
  var v = Object.prototype.hasOwnProperty, g = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, A = {}, k = {};
  function E(S) {
    return v.call(k, S) ? !0 : v.call(A, S) ? !1 : g.test(S) ? k[S] = !0 : (A[S] = !0, !1);
  }
  function T(S, _, I, Q, we, Se, Ie) {
    this.acceptsBooleans = _ === 2 || _ === 3 || _ === 4, this.attributeName = Q, this.attributeNamespace = we, this.mustUseProperty = I, this.propertyName = S, this.type = _, this.sanitizeURL = Se, this.removeEmptyString = Ie;
  }
  var b = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(S) {
    b[S] = new T(S, 0, !1, S, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(S) {
    var _ = S[0];
    b[_] = new T(_, 1, !1, S[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(S) {
    b[S] = new T(S, 2, !1, S.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(S) {
    b[S] = new T(S, 2, !1, S, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(S) {
    b[S] = new T(S, 3, !1, S.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(S) {
    b[S] = new T(S, 3, !0, S, null, !1, !1);
  }), ["capture", "download"].forEach(function(S) {
    b[S] = new T(S, 4, !1, S, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(S) {
    b[S] = new T(S, 6, !1, S, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(S) {
    b[S] = new T(S, 5, !1, S.toLowerCase(), null, !1, !1);
  });
  var y = /[\-:]([a-z])/g;
  function N(S) {
    return S[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(S) {
    var _ = S.replace(
      y,
      N
    );
    b[_] = new T(_, 1, !1, S, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(S) {
    var _ = S.replace(y, N);
    b[_] = new T(_, 1, !1, S, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(S) {
    var _ = S.replace(y, N);
    b[_] = new T(_, 1, !1, S, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(S) {
    b[S] = new T(S, 1, !1, S.toLowerCase(), null, !1, !1);
  }), b.xlinkHref = new T("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(S) {
    b[S] = new T(S, 1, !1, S.toLowerCase(), null, !0, !0);
  });
  var C = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, P = ["Webkit", "ms", "Moz", "O"];
  Object.keys(C).forEach(function(S) {
    P.forEach(function(_) {
      _ = _ + S.charAt(0).toUpperCase() + S.substring(1), C[_] = C[S];
    });
  });
  var O = /["'&<>]/;
  function K(S) {
    if (typeof S == "boolean" || typeof S == "number")
      return "" + S;
    S = "" + S;
    var _ = O.exec(S);
    if (_) {
      var I = "", Q, we = 0;
      for (Q = _.index; Q < S.length; Q++) {
        switch (S.charCodeAt(Q)) {
          case 34:
            _ = "&quot;";
            break;
          case 38:
            _ = "&amp;";
            break;
          case 39:
            _ = "&#x27;";
            break;
          case 60:
            _ = "&lt;";
            break;
          case 62:
            _ = "&gt;";
            break;
          default:
            continue;
        }
        we !== Q && (I += S.substring(we, Q)), we = Q + 1, I += _;
      }
      S = we !== Q ? I + S.substring(we, Q) : I;
    }
    return S;
  }
  var W = /([A-Z])/g, J = /^ms-/, j = Array.isArray, B = p("<script>"), Z = p("<\/script>"), te = p('<script src="'), V = p('<script type="module" src="'), ee = p('" async=""><\/script>'), ce = /(<\/|<)(s)(cript)/gi;
  function re(S, _, I, Q) {
    return "" + _ + (I === "s" ? "\\u0073" : "\\u0053") + Q;
  }
  function G(S, _, I, Q, we) {
    S = S === void 0 ? "" : S, _ = _ === void 0 ? B : p('<script nonce="' + K(_) + '">');
    var Se = [];
    if (I !== void 0 && Se.push(_, s(("" + I).replace(ce, re)), Z), Q !== void 0)
      for (I = 0; I < Q.length; I++)
        Se.push(te, s(K(Q[I])), ee);
    if (we !== void 0)
      for (Q = 0; Q < we.length; Q++)
        Se.push(V, s(K(we[Q])), ee);
    return { bootstrapChunks: Se, startInlineScript: _, placeholderPrefix: p(S + "P:"), segmentPrefix: p(S + "S:"), boundaryPrefix: S + "B:", idPrefix: S, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function U(S, _) {
    return { insertionMode: S, selectedValue: _ };
  }
  function q(S) {
    return U(S === "http://www.w3.org/2000/svg" ? 2 : S === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function H(S, _, I) {
    switch (_) {
      case "select":
        return U(1, I.value != null ? I.value : I.defaultValue);
      case "svg":
        return U(2, null);
      case "math":
        return U(3, null);
      case "foreignObject":
        return U(1, null);
      case "table":
        return U(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return U(5, null);
      case "colgroup":
        return U(7, null);
      case "tr":
        return U(6, null);
    }
    return 4 <= S.insertionMode || S.insertionMode === 0 ? U(1, null) : S;
  }
  var oe = p("<!-- -->");
  function ue(S, _, I, Q) {
    return _ === "" ? Q : (Q && S.push(oe), S.push(s(K(_))), !0);
  }
  var ke = /* @__PURE__ */ new Map(), De = p(' style="'), pe = p(":"), Be = p(";");
  function qe(S, _, I) {
    if (typeof I != "object")
      throw Error(t(62));
    _ = !0;
    for (var Q in I)
      if (v.call(I, Q)) {
        var we = I[Q];
        if (we != null && typeof we != "boolean" && we !== "") {
          if (Q.indexOf("--") === 0) {
            var Se = s(K(Q));
            we = s(K(("" + we).trim()));
          } else {
            Se = Q;
            var Ie = ke.get(Se);
            Ie !== void 0 || (Ie = p(K(Se.replace(W, "-$1").toLowerCase().replace(J, "-ms-"))), ke.set(Se, Ie)), Se = Ie, we = typeof we == "number" ? we === 0 || v.call(C, Q) ? s("" + we) : s(we + "px") : s(K(("" + we).trim()));
          }
          _ ? (_ = !1, S.push(De, Se, pe, we)) : S.push(Be, Se, pe, we);
        }
      }
    _ || S.push($e);
  }
  var Pe = p(" "), ve = p('="'), $e = p('"'), z = p('=""');
  function Re(S, _, I, Q) {
    switch (I) {
      case "style":
        qe(S, _, Q);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < I.length) || I[0] !== "o" && I[0] !== "O" || I[1] !== "n" && I[1] !== "N") {
      if (_ = b.hasOwnProperty(I) ? b[I] : null, _ !== null) {
        switch (typeof Q) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!_.acceptsBooleans)
              return;
        }
        switch (I = s(_.attributeName), _.type) {
          case 3:
            Q && S.push(Pe, I, z);
            break;
          case 4:
            Q === !0 ? S.push(Pe, I, z) : Q !== !1 && S.push(Pe, I, ve, s(K(Q)), $e);
            break;
          case 5:
            isNaN(Q) || S.push(Pe, I, ve, s(K(Q)), $e);
            break;
          case 6:
            !isNaN(Q) && 1 <= Q && S.push(Pe, I, ve, s(K(Q)), $e);
            break;
          default:
            _.sanitizeURL && (Q = "" + Q), S.push(Pe, I, ve, s(K(Q)), $e);
        }
      } else if (E(I)) {
        switch (typeof Q) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (_ = I.toLowerCase().slice(0, 5), _ !== "data-" && _ !== "aria-")
              return;
        }
        S.push(Pe, s(I), ve, s(K(Q)), $e);
      }
    }
  }
  var be = p(">"), He = p("/>");
  function Ve(S, _, I) {
    if (_ != null) {
      if (I != null)
        throw Error(t(60));
      if (typeof _ != "object" || !("__html" in _))
        throw Error(t(61));
      _ = _.__html, _ != null && S.push(s("" + _));
    }
  }
  function Oe(S) {
    var _ = "";
    return e.Children.forEach(S, function(I) {
      I != null && (_ += I);
    }), _;
  }
  var Ge = p(' selected=""');
  function Xe(S, _, I, Q) {
    S.push(Ne(I));
    var we = I = null, Se;
    for (Se in _)
      if (v.call(_, Se)) {
        var Ie = _[Se];
        if (Ie != null)
          switch (Se) {
            case "children":
              I = Ie;
              break;
            case "dangerouslySetInnerHTML":
              we = Ie;
              break;
            default:
              Re(S, Q, Se, Ie);
          }
      }
    return S.push(be), Ve(S, we, I), typeof I == "string" ? (S.push(s(K(I))), null) : I;
  }
  var rt = p(`
`), Ue = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, ze = /* @__PURE__ */ new Map();
  function Ne(S) {
    var _ = ze.get(S);
    if (_ === void 0) {
      if (!Ue.test(S))
        throw Error(t(65, S));
      _ = p("<" + S), ze.set(S, _);
    }
    return _;
  }
  var ot = p("<!DOCTYPE html>");
  function nt(S, _, I, Q, we) {
    switch (_) {
      case "select":
        S.push(Ne("select"));
        var Se = null, Ie = null;
        for (Ft in I)
          if (v.call(I, Ft)) {
            var Je = I[Ft];
            if (Je != null)
              switch (Ft) {
                case "children":
                  Se = Je;
                  break;
                case "dangerouslySetInnerHTML":
                  Ie = Je;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  Re(S, Q, Ft, Je);
              }
          }
        return S.push(be), Ve(S, Ie, Se), Se;
      case "option":
        Ie = we.selectedValue, S.push(Ne("option"));
        var kt = Je = null, Bt = null, Ft = null;
        for (Se in I)
          if (v.call(I, Se)) {
            var vn = I[Se];
            if (vn != null)
              switch (Se) {
                case "children":
                  Je = vn;
                  break;
                case "selected":
                  Bt = vn;
                  break;
                case "dangerouslySetInnerHTML":
                  Ft = vn;
                  break;
                case "value":
                  kt = vn;
                default:
                  Re(S, Q, Se, vn);
              }
          }
        if (Ie != null)
          if (I = kt !== null ? "" + kt : Oe(Je), j(Ie)) {
            for (Q = 0; Q < Ie.length; Q++)
              if ("" + Ie[Q] === I) {
                S.push(Ge);
                break;
              }
          } else
            "" + Ie === I && S.push(Ge);
        else
          Bt && S.push(Ge);
        return S.push(be), Ve(S, Ft, Je), Je;
      case "textarea":
        S.push(Ne("textarea")), Ft = Ie = Se = null;
        for (Je in I)
          if (v.call(I, Je) && (kt = I[Je], kt != null))
            switch (Je) {
              case "children":
                Ft = kt;
                break;
              case "value":
                Se = kt;
                break;
              case "defaultValue":
                Ie = kt;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                Re(S, Q, Je, kt);
            }
        if (Se === null && Ie !== null && (Se = Ie), S.push(be), Ft != null) {
          if (Se != null)
            throw Error(t(92));
          if (j(Ft) && 1 < Ft.length)
            throw Error(t(93));
          Se = "" + Ft;
        }
        return typeof Se == "string" && Se[0] === `
` && S.push(rt), Se !== null && S.push(s(K("" + Se))), null;
      case "input":
        S.push(Ne("input")), kt = Ft = Je = Se = null;
        for (Ie in I)
          if (v.call(I, Ie) && (Bt = I[Ie], Bt != null))
            switch (Ie) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                kt = Bt;
                break;
              case "defaultValue":
                Je = Bt;
                break;
              case "checked":
                Ft = Bt;
                break;
              case "value":
                Se = Bt;
                break;
              default:
                Re(S, Q, Ie, Bt);
            }
        return Ft !== null ? Re(
          S,
          Q,
          "checked",
          Ft
        ) : kt !== null && Re(S, Q, "checked", kt), Se !== null ? Re(S, Q, "value", Se) : Je !== null && Re(S, Q, "value", Je), S.push(He), null;
      case "menuitem":
        S.push(Ne("menuitem"));
        for (var Jn in I)
          if (v.call(I, Jn) && (Se = I[Jn], Se != null))
            switch (Jn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                Re(S, Q, Jn, Se);
            }
        return S.push(be), null;
      case "title":
        S.push(Ne("title")), Se = null;
        for (vn in I)
          if (v.call(I, vn) && (Ie = I[vn], Ie != null))
            switch (vn) {
              case "children":
                Se = Ie;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                Re(S, Q, vn, Ie);
            }
        return S.push(be), Se;
      case "listing":
      case "pre":
        S.push(Ne(_)), Ie = Se = null;
        for (kt in I)
          if (v.call(I, kt) && (Je = I[kt], Je != null))
            switch (kt) {
              case "children":
                Se = Je;
                break;
              case "dangerouslySetInnerHTML":
                Ie = Je;
                break;
              default:
                Re(S, Q, kt, Je);
            }
        if (S.push(be), Ie != null) {
          if (Se != null)
            throw Error(t(60));
          if (typeof Ie != "object" || !("__html" in Ie))
            throw Error(t(61));
          I = Ie.__html, I != null && (typeof I == "string" && 0 < I.length && I[0] === `
` ? S.push(rt, s(I)) : S.push(s("" + I)));
        }
        return typeof Se == "string" && Se[0] === `
` && S.push(rt), Se;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        S.push(Ne(_));
        for (var sr in I)
          if (v.call(I, sr) && (Se = I[sr], Se != null))
            switch (sr) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, _));
              default:
                Re(S, Q, sr, Se);
            }
        return S.push(He), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return Xe(S, I, _, Q);
      case "html":
        return we.insertionMode === 0 && S.push(ot), Xe(S, I, _, Q);
      default:
        if (_.indexOf("-") === -1 && typeof I.is != "string")
          return Xe(S, I, _, Q);
        S.push(Ne(_)), Ie = Se = null;
        for (Bt in I)
          if (v.call(I, Bt) && (Je = I[Bt], Je != null))
            switch (Bt) {
              case "children":
                Se = Je;
                break;
              case "dangerouslySetInnerHTML":
                Ie = Je;
                break;
              case "style":
                qe(S, Q, Je);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                E(Bt) && typeof Je != "function" && typeof Je != "symbol" && S.push(Pe, s(Bt), ve, s(K(Je)), $e);
            }
        return S.push(be), Ve(S, Ie, Se), Se;
    }
  }
  var mt = p("</"), wt = p(">"), xt = p('<template id="'), Pt = p('"></template>'), ln = p("<!--$-->"), Gt = p('<!--$?--><template id="'), Ut = p('"></template>'), yt = p("<!--$!-->"), Tt = p("<!--/$-->"), Dt = p("<template"), nn = p('"'), yn = p(' data-dgst="');
  p(' data-msg="'), p(' data-stck="');
  var Nt = p("></template>");
  function un(S, _, I) {
    if (i(S, Gt), I === null)
      throw Error(t(395));
    return i(S, I), o(S, Ut);
  }
  var Kt = p('<div hidden id="'), Fe = p('">'), bt = p("</div>"), xn = p('<svg aria-hidden="true" style="display:none" id="'), Ot = p('">'), Ln = p("</svg>"), An = p('<math aria-hidden="true" style="display:none" id="'), $t = p('">'), It = p("</math>"), rn = p('<table hidden id="'), fn = p('">'), On = p("</table>"), Wn = p('<table hidden><tbody id="'), on = p('">'), er = p("</tbody></table>"), or = p('<table hidden><tr id="'), Xn = p('">'), Ht = p("</tr></table>"), gn = p('<table hidden><colgroup id="'), Tn = p('">'), qn = p("</colgroup></table>");
  function jn(S, _, I, Q) {
    switch (I.insertionMode) {
      case 0:
      case 1:
        return i(S, Kt), i(S, _.segmentPrefix), i(S, s(Q.toString(16))), o(S, Fe);
      case 2:
        return i(S, xn), i(S, _.segmentPrefix), i(S, s(Q.toString(16))), o(S, Ot);
      case 3:
        return i(S, An), i(S, _.segmentPrefix), i(S, s(Q.toString(16))), o(S, $t);
      case 4:
        return i(S, rn), i(S, _.segmentPrefix), i(S, s(Q.toString(16))), o(S, fn);
      case 5:
        return i(S, Wn), i(S, _.segmentPrefix), i(S, s(Q.toString(16))), o(S, on);
      case 6:
        return i(S, or), i(S, _.segmentPrefix), i(S, s(Q.toString(16))), o(S, Xn);
      case 7:
        return i(
          S,
          gn
        ), i(S, _.segmentPrefix), i(S, s(Q.toString(16))), o(S, Tn);
      default:
        throw Error(t(397));
    }
  }
  function $n(S, _) {
    switch (_.insertionMode) {
      case 0:
      case 1:
        return o(S, bt);
      case 2:
        return o(S, Ln);
      case 3:
        return o(S, It);
      case 4:
        return o(S, On);
      case 5:
        return o(S, er);
      case 6:
        return o(S, Ht);
      case 7:
        return o(S, qn);
      default:
        throw Error(t(397));
    }
  }
  var Te = p('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), _e = p('$RS("'), se = p('","'), it = p('")<\/script>'), ft = p('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), dt = p('$RC("'), Ct = p('","'), Yt = p('")<\/script>'), Zt = p('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), at = p('$RX("'), tn = p('"'), cn = p(")<\/script>"), qt = p(","), Sn = /[<\u2028\u2029]/g;
  function Wt(S) {
    return JSON.stringify(S).replace(Sn, function(_) {
      switch (_) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var Ee = Object.assign, et = Symbol.for("react.element"), Ze = Symbol.for("react.portal"), Ke = Symbol.for("react.fragment"), Vt = Symbol.for("react.strict_mode"), At = Symbol.for("react.profiler"), Xt = Symbol.for("react.provider"), Rt = Symbol.for("react.context"), Qt = Symbol.for("react.forward_ref"), pn = Symbol.for("react.suspense"), _t = Symbol.for("react.suspense_list"), x = Symbol.for("react.memo"), D = Symbol.for("react.lazy"), M = Symbol.for("react.scope"), X = Symbol.for("react.debug_trace_mode"), me = Symbol.for("react.legacy_hidden"), ge = Symbol.for("react.default_value"), Ae = Symbol.iterator;
  function Ye(S) {
    if (S == null)
      return null;
    if (typeof S == "function")
      return S.displayName || S.name || null;
    if (typeof S == "string")
      return S;
    switch (S) {
      case Ke:
        return "Fragment";
      case Ze:
        return "Portal";
      case At:
        return "Profiler";
      case Vt:
        return "StrictMode";
      case pn:
        return "Suspense";
      case _t:
        return "SuspenseList";
    }
    if (typeof S == "object")
      switch (S.$$typeof) {
        case Rt:
          return (S.displayName || "Context") + ".Consumer";
        case Xt:
          return (S._context.displayName || "Context") + ".Provider";
        case Qt:
          var _ = S.render;
          return S = S.displayName, S || (S = _.displayName || _.name || "", S = S !== "" ? "ForwardRef(" + S + ")" : "ForwardRef"), S;
        case x:
          return _ = S.displayName || null, _ !== null ? _ : Ye(S.type) || "Memo";
        case D:
          _ = S._payload, S = S._init;
          try {
            return Ye(S(_));
          } catch {
          }
      }
    return null;
  }
  var ut = {};
  function gt(S, _) {
    if (S = S.contextTypes, !S)
      return ut;
    var I = {}, Q;
    for (Q in S)
      I[Q] = _[Q];
    return I;
  }
  var pt = null;
  function Mt(S, _) {
    if (S !== _) {
      S.context._currentValue = S.parentValue, S = S.parent;
      var I = _.parent;
      if (S === null) {
        if (I !== null)
          throw Error(t(401));
      } else {
        if (I === null)
          throw Error(t(401));
        Mt(S, I);
      }
      _.context._currentValue = _.value;
    }
  }
  function Pn(S) {
    S.context._currentValue = S.parentValue, S = S.parent, S !== null && Pn(S);
  }
  function Nn(S) {
    var _ = S.parent;
    _ !== null && Nn(_), S.context._currentValue = S.value;
  }
  function Rn(S, _) {
    if (S.context._currentValue = S.parentValue, S = S.parent, S === null)
      throw Error(t(402));
    S.depth === _.depth ? Mt(S, _) : Rn(S, _);
  }
  function tr(S, _) {
    var I = _.parent;
    if (I === null)
      throw Error(t(402));
    S.depth === I.depth ? Mt(S, I) : tr(S, I), _.context._currentValue = _.value;
  }
  function Un(S) {
    var _ = pt;
    _ !== S && (_ === null ? Nn(S) : S === null ? Pn(_) : _.depth === S.depth ? Mt(_, S) : _.depth > S.depth ? Rn(_, S) : tr(_, S), pt = S);
  }
  var ye = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(S, _) {
    S = S._reactInternals, S.queue !== null && S.queue.push(_);
  }, enqueueReplaceState: function(S, _) {
    S = S._reactInternals, S.replace = !0, S.queue = [_];
  }, enqueueForceUpdate: function() {
  } };
  function fe(S, _, I, Q) {
    var we = S.state !== void 0 ? S.state : null;
    S.updater = ye, S.props = I, S.state = we;
    var Se = { queue: [], replace: !1 };
    S._reactInternals = Se;
    var Ie = _.contextType;
    if (S.context = typeof Ie == "object" && Ie !== null ? Ie._currentValue : Q, Ie = _.getDerivedStateFromProps, typeof Ie == "function" && (Ie = Ie(I, we), we = Ie == null ? we : Ee({}, we, Ie), S.state = we), typeof _.getDerivedStateFromProps != "function" && typeof S.getSnapshotBeforeUpdate != "function" && (typeof S.UNSAFE_componentWillMount == "function" || typeof S.componentWillMount == "function"))
      if (_ = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), _ !== S.state && ye.enqueueReplaceState(S, S.state, null), Se.queue !== null && 0 < Se.queue.length)
        if (_ = Se.queue, Ie = Se.replace, Se.queue = null, Se.replace = !1, Ie && _.length === 1)
          S.state = _[0];
        else {
          for (Se = Ie ? _[0] : S.state, we = !0, Ie = Ie ? 1 : 0; Ie < _.length; Ie++) {
            var Je = _[Ie];
            Je = typeof Je == "function" ? Je.call(S, Se, I, Q) : Je, Je != null && (we ? (we = !1, Se = Ee({}, Se, Je)) : Ee(Se, Je));
          }
          S.state = Se;
        }
      else
        Se.queue = null;
  }
  var xe = { id: 1, overflow: "" };
  function Me(S, _, I) {
    var Q = S.id;
    S = S.overflow;
    var we = 32 - zt(Q) - 1;
    Q &= ~(1 << we), I += 1;
    var Se = 32 - zt(_) + we;
    if (30 < Se) {
      var Ie = we - we % 5;
      return Se = (Q & (1 << Ie) - 1).toString(32), Q >>= Ie, we -= Ie, { id: 1 << 32 - zt(_) + we | I << we | Q, overflow: Se + S };
    }
    return { id: 1 << Se | I << we | Q, overflow: S };
  }
  var zt = Math.clz32 ? Math.clz32 : Vr, Gn = Math.log, Er = Math.LN2;
  function Vr(S) {
    return S >>>= 0, S === 0 ? 32 : 31 - (Gn(S) / Er | 0) | 0;
  }
  function Rr(S, _) {
    return S === _ && (S !== 0 || 1 / S === 1 / _) || S !== S && _ !== _;
  }
  var qa = typeof Object.is == "function" ? Object.is : Rr, br = null, na = null, xa = null, hn = null, Sr = !1, Zn = !1, Dr = 0, kr = null, ba = 0;
  function wr() {
    if (br === null)
      throw Error(t(321));
    return br;
  }
  function lr() {
    if (0 < ba)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function Ga() {
    return hn === null ? xa === null ? (Sr = !1, xa = hn = lr()) : (Sr = !0, hn = xa) : hn.next === null ? (Sr = !1, hn = hn.next = lr()) : (Sr = !0, hn = hn.next), hn;
  }
  function Za() {
    na = br = null, Zn = !1, xa = null, ba = 0, hn = kr = null;
  }
  function Yi(S, _) {
    return typeof _ == "function" ? _(S) : _;
  }
  function Xi(S, _, I) {
    if (br = wr(), hn = Ga(), Sr) {
      var Q = hn.queue;
      if (_ = Q.dispatch, kr !== null && (I = kr.get(Q), I !== void 0)) {
        kr.delete(Q), Q = hn.memoizedState;
        do
          Q = S(Q, I.action), I = I.next;
        while (I !== null);
        return hn.memoizedState = Q, [Q, _];
      }
      return [hn.memoizedState, _];
    }
    return S = S === Yi ? typeof _ == "function" ? _() : _ : I !== void 0 ? I(_) : _, hn.memoizedState = S, S = hn.queue = { last: null, dispatch: null }, S = S.dispatch = dl.bind(null, br, S), [hn.memoizedState, S];
  }
  function qi(S, _) {
    if (br = wr(), hn = Ga(), _ = _ === void 0 ? null : _, hn !== null) {
      var I = hn.memoizedState;
      if (I !== null && _ !== null) {
        var Q = I[1];
        e:
          if (Q === null)
            Q = !1;
          else {
            for (var we = 0; we < Q.length && we < _.length; we++)
              if (!qa(_[we], Q[we])) {
                Q = !1;
                break e;
              }
            Q = !0;
          }
        if (Q)
          return I[0];
      }
    }
    return S = S(), hn.memoizedState = [S, _], S;
  }
  function dl(S, _, I) {
    if (25 <= ba)
      throw Error(t(301));
    if (S === br)
      if (Zn = !0, S = { action: I, next: null }, kr === null && (kr = /* @__PURE__ */ new Map()), I = kr.get(_), I === void 0)
        kr.set(_, S);
      else {
        for (_ = I; _.next !== null; )
          _ = _.next;
        _.next = S;
      }
  }
  function fl() {
    throw Error(t(394));
  }
  function Ea() {
  }
  var Sa = { readContext: function(S) {
    return S._currentValue;
  }, useContext: function(S) {
    return wr(), S._currentValue;
  }, useMemo: qi, useReducer: Xi, useRef: function(S) {
    br = wr(), hn = Ga();
    var _ = hn.memoizedState;
    return _ === null ? (S = { current: S }, hn.memoizedState = S) : _;
  }, useState: function(S) {
    return Xi(Yi, S);
  }, useInsertionEffect: Ea, useLayoutEffect: function() {
  }, useCallback: function(S, _) {
    return qi(function() {
      return S;
    }, _);
  }, useImperativeHandle: Ea, useEffect: Ea, useDebugValue: Ea, useDeferredValue: function(S) {
    return wr(), S;
  }, useTransition: function() {
    return wr(), [!1, fl];
  }, useId: function() {
    var S = na.treeContext, _ = S.overflow;
    S = S.id, S = (S & ~(1 << 32 - zt(S) - 1)).toString(32) + _;
    var I = ka;
    if (I === null)
      throw Error(t(404));
    return _ = Dr++, S = ":" + I.idPrefix + "R" + S, 0 < _ && (S += "H" + _.toString(32)), S + ":";
  }, useMutableSource: function(S, _) {
    return wr(), _(S._source);
  }, useSyncExternalStore: function(S, _, I) {
    if (I === void 0)
      throw Error(t(407));
    return I();
  } }, ka = null, ra = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function pl(S) {
    return console.error(S), null;
  }
  function aa() {
  }
  function Qa(S, _, I, Q, we, Se, Ie, Je, kt) {
    var Bt = [], Ft = /* @__PURE__ */ new Set();
    return _ = { destination: null, responseState: _, progressiveChunkSize: Q === void 0 ? 12800 : Q, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Ft, pingedTasks: Bt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: we === void 0 ? pl : we, onAllReady: Se === void 0 ? aa : Se, onShellReady: Ie === void 0 ? aa : Ie, onShellError: Je === void 0 ? aa : Je, onFatalError: kt === void 0 ? aa : kt }, I = Wr(_, 0, null, I, !1, !1), I.parentFlushed = !0, S = Ja(_, S, null, I, Ft, ut, null, xe), Bt.push(S), _;
  }
  function Ja(S, _, I, Q, we, Se, Ie, Je) {
    S.allPendingTasks++, I === null ? S.pendingRootTasks++ : I.pendingTasks++;
    var kt = { node: _, ping: function() {
      var Bt = S.pingedTasks;
      Bt.push(kt), Bt.length === 1 && to(S);
    }, blockedBoundary: I, blockedSegment: Q, abortSet: we, legacyContext: Se, context: Ie, treeContext: Je };
    return we.add(kt), kt;
  }
  function Wr(S, _, I, Q, we, Se) {
    return { status: 0, id: -1, index: _, parentFlushed: !1, chunks: [], children: [], formatContext: Q, boundary: I, lastPushedText: we, textEmbedded: Se };
  }
  function jr(S, _) {
    if (S = S.onError(_), S != null && typeof S != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof S + '" instead');
    return S;
  }
  function wa(S, _) {
    var I = S.onShellError;
    I(_), I = S.onFatalError, I(_), S.destination !== null ? (S.status = 2, m(S.destination, _)) : (S.status = 1, S.fatalError = _);
  }
  function Gi(S, _, I, Q, we) {
    for (br = {}, na = _, Dr = 0, S = I(Q, we); Zn; )
      Zn = !1, Dr = 0, ba += 1, hn = null, S = I(Q, we);
    return Za(), S;
  }
  function ei(S, _, I, Q) {
    var we = I.render(), Se = Q.childContextTypes;
    if (Se != null) {
      var Ie = _.legacyContext;
      if (typeof I.getChildContext != "function")
        Q = Ie;
      else {
        I = I.getChildContext();
        for (var Je in I)
          if (!(Je in Se))
            throw Error(t(108, Ye(Q) || "Unknown", Je));
        Q = Ee({}, Ie, I);
      }
      _.legacyContext = Q, Qn(S, _, we), _.legacyContext = Ie;
    } else
      Qn(S, _, we);
  }
  function Zi(S, _) {
    if (S && S.defaultProps) {
      _ = Ee({}, _), S = S.defaultProps;
      for (var I in S)
        _[I] === void 0 && (_[I] = S[I]);
      return _;
    }
    return _;
  }
  function Ta(S, _, I, Q, we) {
    if (typeof I == "function")
      if (I.prototype && I.prototype.isReactComponent) {
        we = gt(I, _.legacyContext);
        var Se = I.contextType;
        Se = new I(Q, typeof Se == "object" && Se !== null ? Se._currentValue : we), fe(Se, I, Q, we), ei(S, _, Se, I);
      } else {
        Se = gt(I, _.legacyContext), we = Gi(S, _, I, Q, Se);
        var Ie = Dr !== 0;
        if (typeof we == "object" && we !== null && typeof we.render == "function" && we.$$typeof === void 0)
          fe(we, I, Q, Se), ei(S, _, we, I);
        else if (Ie) {
          Q = _.treeContext, _.treeContext = Me(Q, 1, 0);
          try {
            Qn(S, _, we);
          } finally {
            _.treeContext = Q;
          }
        } else
          Qn(S, _, we);
      }
    else if (typeof I == "string") {
      switch (we = _.blockedSegment, Se = nt(we.chunks, I, Q, S.responseState, we.formatContext), we.lastPushedText = !1, Ie = we.formatContext, we.formatContext = H(Ie, I, Q), Ca(S, _, Se), we.formatContext = Ie, I) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          we.chunks.push(mt, s(I), wt);
      }
      we.lastPushedText = !1;
    } else {
      switch (I) {
        case me:
        case X:
        case Vt:
        case At:
        case Ke:
          Qn(S, _, Q.children);
          return;
        case _t:
          Qn(S, _, Q.children);
          return;
        case M:
          throw Error(t(343));
        case pn:
          e: {
            I = _.blockedBoundary, we = _.blockedSegment, Se = Q.fallback, Q = Q.children, Ie = /* @__PURE__ */ new Set();
            var Je = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Ie, errorDigest: null }, kt = Wr(S, we.chunks.length, Je, we.formatContext, !1, !1);
            we.children.push(kt), we.lastPushedText = !1;
            var Bt = Wr(S, 0, null, we.formatContext, !1, !1);
            Bt.parentFlushed = !0, _.blockedBoundary = Je, _.blockedSegment = Bt;
            try {
              if (Ca(
                S,
                _,
                Q
              ), Bt.lastPushedText && Bt.textEmbedded && Bt.chunks.push(oe), Bt.status = 1, Aa(Je, Bt), Je.pendingTasks === 0)
                break e;
            } catch (Ft) {
              Bt.status = 4, Je.forceClientRender = !0, Je.errorDigest = jr(S, Ft);
            } finally {
              _.blockedBoundary = I, _.blockedSegment = we;
            }
            _ = Ja(S, Se, I, kt, Ie, _.legacyContext, _.context, _.treeContext), S.pingedTasks.push(_);
          }
          return;
      }
      if (typeof I == "object" && I !== null)
        switch (I.$$typeof) {
          case Qt:
            if (Q = Gi(S, _, I.render, Q, we), Dr !== 0) {
              I = _.treeContext, _.treeContext = Me(I, 1, 0);
              try {
                Qn(S, _, Q);
              } finally {
                _.treeContext = I;
              }
            } else
              Qn(S, _, Q);
            return;
          case x:
            I = I.type, Q = Zi(I, Q), Ta(S, _, I, Q, we);
            return;
          case Xt:
            if (we = Q.children, I = I._context, Q = Q.value, Se = I._currentValue, I._currentValue = Q, Ie = pt, pt = Q = { parent: Ie, depth: Ie === null ? 0 : Ie.depth + 1, context: I, parentValue: Se, value: Q }, _.context = Q, Qn(S, _, we), S = pt, S === null)
              throw Error(t(403));
            Q = S.parentValue, S.context._currentValue = Q === ge ? S.context._defaultValue : Q, S = pt = S.parent, _.context = S;
            return;
          case Rt:
            Q = Q.children, Q = Q(I._currentValue), Qn(S, _, Q);
            return;
          case D:
            we = I._init, I = we(I._payload), Q = Zi(I, Q), Ta(S, _, I, Q, void 0);
            return;
        }
      throw Error(t(
        130,
        I == null ? I : typeof I,
        ""
      ));
    }
  }
  function Qn(S, _, I) {
    if (_.node = I, typeof I == "object" && I !== null) {
      switch (I.$$typeof) {
        case et:
          Ta(S, _, I.type, I.props, I.ref);
          return;
        case Ze:
          throw Error(t(257));
        case D:
          var Q = I._init;
          I = Q(I._payload), Qn(S, _, I);
          return;
      }
      if (j(I)) {
        Qi(S, _, I);
        return;
      }
      if (I === null || typeof I != "object" ? Q = null : (Q = Ae && I[Ae] || I["@@iterator"], Q = typeof Q == "function" ? Q : null), Q && (Q = Q.call(I))) {
        if (I = Q.next(), !I.done) {
          var we = [];
          do
            we.push(I.value), I = Q.next();
          while (!I.done);
          Qi(S, _, we);
        }
        return;
      }
      throw S = Object.prototype.toString.call(I), Error(t(31, S === "[object Object]" ? "object with keys {" + Object.keys(I).join(", ") + "}" : S));
    }
    typeof I == "string" ? (Q = _.blockedSegment, Q.lastPushedText = ue(_.blockedSegment.chunks, I, S.responseState, Q.lastPushedText)) : typeof I == "number" && (Q = _.blockedSegment, Q.lastPushedText = ue(_.blockedSegment.chunks, "" + I, S.responseState, Q.lastPushedText));
  }
  function Qi(S, _, I) {
    for (var Q = I.length, we = 0; we < Q; we++) {
      var Se = _.treeContext;
      _.treeContext = Me(Se, Q, we);
      try {
        Ca(S, _, I[we]);
      } finally {
        _.treeContext = Se;
      }
    }
  }
  function Ca(S, _, I) {
    var Q = _.blockedSegment.formatContext, we = _.legacyContext, Se = _.context;
    try {
      return Qn(S, _, I);
    } catch (kt) {
      if (Za(), typeof kt == "object" && kt !== null && typeof kt.then == "function") {
        I = kt;
        var Ie = _.blockedSegment, Je = Wr(S, Ie.chunks.length, null, Ie.formatContext, Ie.lastPushedText, !0);
        Ie.children.push(Je), Ie.lastPushedText = !1, S = Ja(S, _.node, _.blockedBoundary, Je, _.abortSet, _.legacyContext, _.context, _.treeContext).ping, I.then(S, S), _.blockedSegment.formatContext = Q, _.legacyContext = we, _.context = Se, Un(Se);
      } else
        throw _.blockedSegment.formatContext = Q, _.legacyContext = we, _.context = Se, Un(Se), kt;
    }
  }
  function hl(S) {
    var _ = S.blockedBoundary;
    S = S.blockedSegment, S.status = 3, eo(this, _, S);
  }
  function Ji(S, _, I) {
    var Q = S.blockedBoundary;
    S.blockedSegment.status = 3, Q === null ? (_.allPendingTasks--, _.status !== 2 && (_.status = 2, _.destination !== null && _.destination.close())) : (Q.pendingTasks--, Q.forceClientRender || (Q.forceClientRender = !0, S = I === void 0 ? Error(t(432)) : I, Q.errorDigest = _.onError(S), Q.parentFlushed && _.clientRenderedBoundaries.push(Q)), Q.fallbackAbortableTasks.forEach(function(we) {
      return Ji(we, _, I);
    }), Q.fallbackAbortableTasks.clear(), _.allPendingTasks--, _.allPendingTasks === 0 && (Q = _.onAllReady, Q()));
  }
  function Aa(S, _) {
    if (_.chunks.length === 0 && _.children.length === 1 && _.children[0].boundary === null) {
      var I = _.children[0];
      I.id = _.id, I.parentFlushed = !0, I.status === 1 && Aa(S, I);
    } else
      S.completedSegments.push(_);
  }
  function eo(S, _, I) {
    if (_ === null) {
      if (I.parentFlushed) {
        if (S.completedRootSegment !== null)
          throw Error(t(389));
        S.completedRootSegment = I;
      }
      S.pendingRootTasks--, S.pendingRootTasks === 0 && (S.onShellError = aa, _ = S.onShellReady, _());
    } else
      _.pendingTasks--, _.forceClientRender || (_.pendingTasks === 0 ? (I.parentFlushed && I.status === 1 && Aa(_, I), _.parentFlushed && S.completedBoundaries.push(_), _.fallbackAbortableTasks.forEach(hl, S), _.fallbackAbortableTasks.clear()) : I.parentFlushed && I.status === 1 && (Aa(_, I), _.completedSegments.length === 1 && _.parentFlushed && S.partialBoundaries.push(_)));
    S.allPendingTasks--, S.allPendingTasks === 0 && (S = S.onAllReady, S());
  }
  function to(S) {
    if (S.status !== 2) {
      var _ = pt, I = ra.current;
      ra.current = Sa;
      var Q = ka;
      ka = S.responseState;
      try {
        var we = S.pingedTasks, Se;
        for (Se = 0; Se < we.length; Se++) {
          var Ie = we[Se], Je = S, kt = Ie.blockedSegment;
          if (kt.status === 0) {
            Un(Ie.context);
            try {
              Qn(Je, Ie, Ie.node), kt.lastPushedText && kt.textEmbedded && kt.chunks.push(oe), Ie.abortSet.delete(Ie), kt.status = 1, eo(Je, Ie.blockedBoundary, kt);
            } catch (ur) {
              if (Za(), typeof ur == "object" && ur !== null && typeof ur.then == "function") {
                var Bt = Ie.ping;
                ur.then(Bt, Bt);
              } else {
                Ie.abortSet.delete(Ie), kt.status = 4;
                var Ft = Ie.blockedBoundary, vn = ur, Jn = jr(Je, vn);
                if (Ft === null ? wa(Je, vn) : (Ft.pendingTasks--, Ft.forceClientRender || (Ft.forceClientRender = !0, Ft.errorDigest = Jn, Ft.parentFlushed && Je.clientRenderedBoundaries.push(Ft))), Je.allPendingTasks--, Je.allPendingTasks === 0) {
                  var sr = Je.onAllReady;
                  sr();
                }
              }
            } finally {
            }
          }
        }
        we.splice(0, Se), S.destination !== null && ti(S, S.destination);
      } catch (ur) {
        jr(S, ur), wa(S, ur);
      } finally {
        ka = Q, ra.current = I, I === Sa && Un(_);
      }
    }
  }
  function La(S, _, I) {
    switch (I.parentFlushed = !0, I.status) {
      case 0:
        var Q = I.id = S.nextSegmentId++;
        return I.lastPushedText = !1, I.textEmbedded = !1, S = S.responseState, i(_, xt), i(_, S.placeholderPrefix), S = s(Q.toString(16)), i(_, S), o(_, Pt);
      case 1:
        I.status = 2;
        var we = !0;
        Q = I.chunks;
        var Se = 0;
        I = I.children;
        for (var Ie = 0; Ie < I.length; Ie++) {
          for (we = I[Ie]; Se < we.index; Se++)
            i(_, Q[Se]);
          we = Pa(S, _, we);
        }
        for (; Se < Q.length - 1; Se++)
          i(_, Q[Se]);
        return Se < Q.length && (we = o(_, Q[Se])), we;
      default:
        throw Error(t(390));
    }
  }
  function Pa(S, _, I) {
    var Q = I.boundary;
    if (Q === null)
      return La(S, _, I);
    if (Q.parentFlushed = !0, Q.forceClientRender)
      Q = Q.errorDigest, o(_, yt), i(_, Dt), Q && (i(_, yn), i(_, s(K(Q))), i(_, nn)), o(_, Nt), La(S, _, I);
    else if (0 < Q.pendingTasks) {
      Q.rootSegmentID = S.nextSegmentId++, 0 < Q.completedSegments.length && S.partialBoundaries.push(Q);
      var we = S.responseState, Se = we.nextSuspenseID++;
      we = p(we.boundaryPrefix + Se.toString(16)), Q = Q.id = we, un(_, S.responseState, Q), La(S, _, I);
    } else if (Q.byteSize > S.progressiveChunkSize)
      Q.rootSegmentID = S.nextSegmentId++, S.completedBoundaries.push(Q), un(_, S.responseState, Q.id), La(S, _, I);
    else {
      if (o(_, ln), I = Q.completedSegments, I.length !== 1)
        throw Error(t(391));
      Pa(S, _, I[0]);
    }
    return o(_, Tt);
  }
  function no(S, _, I) {
    return jn(_, S.responseState, I.formatContext, I.id), Pa(S, _, I), $n(_, I.formatContext);
  }
  function ro(S, _, I) {
    for (var Q = I.completedSegments, we = 0; we < Q.length; we++)
      ao(S, _, I, Q[we]);
    if (Q.length = 0, S = S.responseState, Q = I.id, I = I.rootSegmentID, i(_, S.startInlineScript), S.sentCompleteBoundaryFunction ? i(_, dt) : (S.sentCompleteBoundaryFunction = !0, i(_, ft)), Q === null)
      throw Error(t(395));
    return I = s(I.toString(16)), i(_, Q), i(_, Ct), i(_, S.segmentPrefix), i(_, I), o(_, Yt);
  }
  function ao(S, _, I, Q) {
    if (Q.status === 2)
      return !0;
    var we = Q.id;
    if (we === -1) {
      if ((Q.id = I.rootSegmentID) === -1)
        throw Error(t(392));
      return no(S, _, Q);
    }
    return no(S, _, Q), S = S.responseState, i(_, S.startInlineScript), S.sentCompleteSegmentFunction ? i(_, _e) : (S.sentCompleteSegmentFunction = !0, i(_, Te)), i(_, S.segmentPrefix), we = s(we.toString(16)), i(_, we), i(_, se), i(_, S.placeholderPrefix), i(_, we), o(_, it);
  }
  function ti(S, _) {
    r = new Uint8Array(512), a = 0;
    try {
      var I = S.completedRootSegment;
      if (I !== null && S.pendingRootTasks === 0) {
        Pa(S, _, I), S.completedRootSegment = null;
        var Q = S.responseState.bootstrapChunks;
        for (I = 0; I < Q.length - 1; I++)
          i(_, Q[I]);
        I < Q.length && o(_, Q[I]);
      }
      var we = S.clientRenderedBoundaries, Se;
      for (Se = 0; Se < we.length; Se++) {
        var Ie = we[Se];
        Q = _;
        var Je = S.responseState, kt = Ie.id, Bt = Ie.errorDigest, Ft = Ie.errorMessage, vn = Ie.errorComponentStack;
        if (i(Q, Je.startInlineScript), Je.sentClientRenderFunction ? i(Q, at) : (Je.sentClientRenderFunction = !0, i(
          Q,
          Zt
        )), kt === null)
          throw Error(t(395));
        i(Q, kt), i(Q, tn), (Bt || Ft || vn) && (i(Q, qt), i(Q, s(Wt(Bt || "")))), (Ft || vn) && (i(Q, qt), i(Q, s(Wt(Ft || "")))), vn && (i(Q, qt), i(Q, s(Wt(vn)))), o(Q, cn);
      }
      we.splice(0, Se);
      var Jn = S.completedBoundaries;
      for (Se = 0; Se < Jn.length; Se++)
        ro(S, _, Jn[Se]);
      Jn.splice(0, Se), d(_), r = new Uint8Array(512), a = 0;
      var sr = S.partialBoundaries;
      for (Se = 0; Se < sr.length; Se++) {
        var ur = sr[Se];
        e: {
          we = S, Ie = _;
          var Na = ur.completedSegments;
          for (Je = 0; Je < Na.length; Je++)
            if (!ao(
              we,
              Ie,
              ur,
              Na[Je]
            )) {
              Je++, Na.splice(0, Je);
              var oo = !1;
              break e;
            }
          Na.splice(0, Je), oo = !0;
        }
        if (!oo) {
          S.destination = null, Se++, sr.splice(0, Se);
          return;
        }
      }
      sr.splice(0, Se);
      var ni = S.completedBoundaries;
      for (Se = 0; Se < ni.length; Se++)
        ro(S, _, ni[Se]);
      ni.splice(0, Se);
    } finally {
      d(_), S.allPendingTasks === 0 && S.pingedTasks.length === 0 && S.clientRenderedBoundaries.length === 0 && S.completedBoundaries.length === 0 && _.close();
    }
  }
  function io(S, _) {
    try {
      var I = S.abortableTasks;
      I.forEach(function(Q) {
        return Ji(Q, S, _);
      }), I.clear(), S.destination !== null && ti(S, S.destination);
    } catch (Q) {
      jr(S, Q), wa(S, Q);
    }
  }
  return Bu.renderToReadableStream = function(S, _) {
    return new Promise(function(I, Q) {
      var we, Se, Ie = new Promise(function(Ft, vn) {
        Se = Ft, we = vn;
      }), Je = Qa(S, G(_ ? _.identifierPrefix : void 0, _ ? _.nonce : void 0, _ ? _.bootstrapScriptContent : void 0, _ ? _.bootstrapScripts : void 0, _ ? _.bootstrapModules : void 0), q(_ ? _.namespaceURI : void 0), _ ? _.progressiveChunkSize : void 0, _ ? _.onError : void 0, Se, function() {
        var Ft = new ReadableStream({ type: "bytes", pull: function(vn) {
          if (Je.status === 1)
            Je.status = 2, m(vn, Je.fatalError);
          else if (Je.status !== 2 && Je.destination === null) {
            Je.destination = vn;
            try {
              ti(Je, vn);
            } catch (Jn) {
              jr(Je, Jn), wa(Je, Jn);
            }
          }
        }, cancel: function() {
          io(Je);
        } }, { highWaterMark: 0 });
        Ft.allReady = Ie, I(Ft);
      }, function(Ft) {
        Ie.catch(function() {
        }), Q(Ft);
      }, we);
      if (_ && _.signal) {
        var kt = _.signal, Bt = function() {
          io(Je, kt.reason), kt.removeEventListener("abort", Bt);
        };
        kt.addEventListener("abort", Bt);
      }
      to(Je);
    });
  }, Bu.version = "18.2.0", Bu;
}
var Oi = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Jh;
function dS() {
  return Jh || (Jh = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ie, t = "18.2.0", r = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(l) {
      {
        for (var f = arguments.length, w = new Array(f > 1 ? f - 1 : 0), R = 1; R < f; R++)
          w[R - 1] = arguments[R];
        o("warn", l, w);
      }
    }
    function i(l) {
      {
        for (var f = arguments.length, w = new Array(f > 1 ? f - 1 : 0), R = 1; R < f; R++)
          w[R - 1] = arguments[R];
        o("error", l, w);
      }
    }
    function o(l, f, w) {
      {
        var R = r.ReactDebugCurrentFrame, $ = R.getStackAddendum();
        $ !== "" && (f += "%s", w = w.concat([$]));
        var ne = w.map(function(de) {
          return String(de);
        });
        ne.unshift("Warning: " + f), Function.prototype.apply.call(console[l], console, ne);
      }
    }
    function d(l) {
      l();
    }
    function c(l) {
    }
    function s(l, f) {
      p(l, f);
    }
    function p(l, f) {
      return l.push(f);
    }
    function m(l) {
    }
    function v(l) {
      l.push(null);
    }
    function g(l) {
      return l;
    }
    function A(l) {
      return l;
    }
    function k(l, f) {
      l.destroy(f);
    }
    function E(l) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, w = f && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return w;
      }
    }
    function T(l) {
      try {
        return b(l), !1;
      } catch {
        return !0;
      }
    }
    function b(l) {
      return "" + l;
    }
    function y(l, f) {
      if (T(l))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", f, E(l)), b(l);
    }
    function N(l, f) {
      if (T(l))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", f, E(l)), b(l);
    }
    function C(l) {
      if (T(l))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", E(l)), b(l);
    }
    var P = Object.prototype.hasOwnProperty, O = 0, K = 1, W = 2, J = 3, j = 4, B = 5, Z = 6, te = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", V = te + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ee = new RegExp("^[" + te + "][" + V + "]*$"), ce = {}, re = {};
    function G(l) {
      return P.call(re, l) ? !0 : P.call(ce, l) ? !1 : ee.test(l) ? (re[l] = !0, !0) : (ce[l] = !0, i("Invalid attribute name: `%s`", l), !1);
    }
    function U(l, f, w, R) {
      if (w !== null && w.type === O)
        return !1;
      switch (typeof f) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (R)
            return !1;
          if (w !== null)
            return !w.acceptsBooleans;
          var $ = l.toLowerCase().slice(0, 5);
          return $ !== "data-" && $ !== "aria-";
        }
        default:
          return !1;
      }
    }
    function q(l) {
      return oe.hasOwnProperty(l) ? oe[l] : null;
    }
    function H(l, f, w, R, $, ne, de) {
      this.acceptsBooleans = f === W || f === J || f === j, this.attributeName = R, this.attributeNamespace = $, this.mustUseProperty = w, this.propertyName = l, this.type = f, this.sanitizeURL = ne, this.removeEmptyString = de;
    }
    var oe = {}, ue = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ue.forEach(function(l) {
      oe[l] = new H(
        l,
        O,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
      var f = l[0], w = l[1];
      oe[f] = new H(
        f,
        K,
        !1,
        // mustUseProperty
        w,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
      oe[l] = new H(
        l,
        W,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
      oe[l] = new H(
        l,
        W,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(l) {
      oe[l] = new H(
        l,
        J,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      oe[l] = new H(
        l,
        J,
        !0,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      oe[l] = new H(
        l,
        j,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      oe[l] = new H(
        l,
        Z,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(l) {
      oe[l] = new H(
        l,
        B,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ke = /[\-\:]([a-z])/g, De = function(l) {
      return l[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ke, De);
      oe[f] = new H(
        f,
        K,
        !1,
        // mustUseProperty
        l,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ke, De);
      oe[f] = new H(
        f,
        K,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(ke, De);
      oe[f] = new H(
        f,
        K,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(l) {
      oe[l] = new H(
        l,
        K,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var pe = "xlinkHref";
    oe[pe] = new H(
      "xlinkHref",
      K,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(l) {
      oe[l] = new H(
        l,
        K,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Be = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function qe(l, f) {
      return l + f.charAt(0).toUpperCase() + f.substring(1);
    }
    var Pe = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Be).forEach(function(l) {
      Pe.forEach(function(f) {
        Be[qe(f, l)] = Be[l];
      });
    });
    var ve = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function $e(l, f) {
      ve[f.type] || f.onChange || f.onInput || f.readOnly || f.disabled || f.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), f.onChange || f.readOnly || f.disabled || f.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function z(l, f) {
      if (l.indexOf("-") === -1)
        return typeof f.is == "string";
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Re = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, be = {}, He = new RegExp("^(aria)-[" + V + "]*$"), Ve = new RegExp("^(aria)[A-Z][" + V + "]*$");
    function Oe(l, f) {
      {
        if (P.call(be, f) && be[f])
          return !0;
        if (Ve.test(f)) {
          var w = "aria-" + f.slice(4).toLowerCase(), R = Re.hasOwnProperty(w) ? w : null;
          if (R == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", f), be[f] = !0, !0;
          if (f !== R)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", f, R), be[f] = !0, !0;
        }
        if (He.test(f)) {
          var $ = f.toLowerCase(), ne = Re.hasOwnProperty($) ? $ : null;
          if (ne == null)
            return be[f] = !0, !1;
          if (f !== ne)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", f, ne), be[f] = !0, !0;
        }
      }
      return !0;
    }
    function Ge(l, f) {
      {
        var w = [];
        for (var R in f) {
          var $ = Oe(l, R);
          $ || w.push(R);
        }
        var ne = w.map(function(de) {
          return "`" + de + "`";
        }).join(", ");
        w.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ne, l) : w.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ne, l);
      }
    }
    function Xe(l, f) {
      z(l, f) || Ge(l, f);
    }
    var rt = !1;
    function Ue(l, f) {
      {
        if (l !== "input" && l !== "textarea" && l !== "select")
          return;
        f != null && f.value === null && !rt && (rt = !0, l === "select" && f.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", l) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", l));
      }
    }
    var ze = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Ne = function() {
    };
    {
      var ot = {}, nt = /^on./, mt = /^on[^A-Z]/, wt = new RegExp("^(aria)-[" + V + "]*$"), xt = new RegExp("^(aria)[A-Z][" + V + "]*$");
      Ne = function(l, f, w, R) {
        if (P.call(ot, f) && ot[f])
          return !0;
        var $ = f.toLowerCase();
        if ($ === "onfocusin" || $ === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), ot[f] = !0, !0;
        if (R != null) {
          var ne = R.registrationNameDependencies, de = R.possibleRegistrationNames;
          if (ne.hasOwnProperty(f))
            return !0;
          var Ce = de.hasOwnProperty($) ? de[$] : null;
          if (Ce != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", f, Ce), ot[f] = !0, !0;
          if (nt.test(f))
            return i("Unknown event handler property `%s`. It will be ignored.", f), ot[f] = !0, !0;
        } else if (nt.test(f))
          return mt.test(f) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", f), ot[f] = !0, !0;
        if (wt.test(f) || xt.test(f))
          return !0;
        if ($ === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), ot[f] = !0, !0;
        if ($ === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), ot[f] = !0, !0;
        if ($ === "is" && w !== null && w !== void 0 && typeof w != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof w), ot[f] = !0, !0;
        if (typeof w == "number" && isNaN(w))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", f), ot[f] = !0, !0;
        var We = q(f), ct = We !== null && We.type === O;
        if (ze.hasOwnProperty($)) {
          var ht = ze[$];
          if (ht !== f)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", f, ht), ot[f] = !0, !0;
        } else if (!ct && f !== $)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", f, $), ot[f] = !0, !0;
        return typeof w == "boolean" && U(f, w, We, !1) ? (w ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', w, f, f, w, f) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', w, f, f, w, f, f, f), ot[f] = !0, !0) : ct ? !0 : U(f, w, We, !1) ? (ot[f] = !0, !1) : ((w === "false" || w === "true") && We !== null && We.type === J && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", w, f, w === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', f, w), ot[f] = !0), !0);
      };
    }
    var Pt = function(l, f, w) {
      {
        var R = [];
        for (var $ in f) {
          var ne = Ne(l, $, f[$], w);
          ne || R.push($);
        }
        var de = R.map(function(Ce) {
          return "`" + Ce + "`";
        }).join(", ");
        R.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", de, l) : R.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", de, l);
      }
    };
    function ln(l, f, w) {
      z(l, f) || Pt(l, f, w);
    }
    var Gt = function() {
    };
    {
      var Ut = /^(?:webkit|moz|o)[A-Z]/, yt = /^-ms-/, Tt = /-(.)/g, Dt = /;\s*$/, nn = {}, yn = {}, Nt = !1, un = !1, Kt = function(l) {
        return l.replace(Tt, function(f, w) {
          return w.toUpperCase();
        });
      }, Fe = function(l) {
        nn.hasOwnProperty(l) && nn[l] || (nn[l] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          l,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Kt(l.replace(yt, "ms-"))
        ));
      }, bt = function(l) {
        nn.hasOwnProperty(l) && nn[l] || (nn[l] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", l, l.charAt(0).toUpperCase() + l.slice(1)));
      }, xn = function(l, f) {
        yn.hasOwnProperty(f) && yn[f] || (yn[f] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, l, f.replace(Dt, "")));
      }, Ot = function(l, f) {
        Nt || (Nt = !0, i("`NaN` is an invalid value for the `%s` css style property.", l));
      }, Ln = function(l, f) {
        un || (un = !0, i("`Infinity` is an invalid value for the `%s` css style property.", l));
      };
      Gt = function(l, f) {
        l.indexOf("-") > -1 ? Fe(l) : Ut.test(l) ? bt(l) : Dt.test(f) && xn(l, f), typeof f == "number" && (isNaN(f) ? Ot(l, f) : isFinite(f) || Ln(l, f));
      };
    }
    var An = Gt, $t = /["'&<>]/;
    function It(l) {
      C(l);
      var f = "" + l, w = $t.exec(f);
      if (!w)
        return f;
      var R, $ = "", ne, de = 0;
      for (ne = w.index; ne < f.length; ne++) {
        switch (f.charCodeAt(ne)) {
          case 34:
            R = "&quot;";
            break;
          case 38:
            R = "&amp;";
            break;
          case 39:
            R = "&#x27;";
            break;
          case 60:
            R = "&lt;";
            break;
          case 62:
            R = "&gt;";
            break;
          default:
            continue;
        }
        de !== ne && ($ += f.substring(de, ne)), de = ne + 1, $ += R;
      }
      return de !== ne ? $ + f.substring(de, ne) : $;
    }
    function rn(l) {
      return typeof l == "boolean" || typeof l == "number" ? "" + l : It(l);
    }
    var fn = /([A-Z])/g, On = /^ms-/;
    function Wn(l) {
      return l.replace(fn, "-$1").toLowerCase().replace(On, "-ms-");
    }
    var on = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, er = !1;
    function or(l) {
      !er && on.test(l) && (er = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(l)));
    }
    var Xn = Array.isArray;
    function Ht(l) {
      return Xn(l);
    }
    var gn = "<script>", Tn = "<\/script>", qn = '<script src="', jn = '<script type="module" src="', $n = '" async=""><\/script>';
    function Te(l) {
      return C(l), ("" + l).replace(_e, se);
    }
    var _e = /(<\/|<)(s)(cript)/gi, se = function(l, f, w, R) {
      return "" + f + (w === "s" ? "\\u0073" : "\\u0053") + R;
    };
    function it(l, f, w, R, $) {
      var ne = l === void 0 ? "" : l, de = f === void 0 ? gn : '<script nonce="' + rn(f) + '">', Ce = [];
      if (w !== void 0 && Ce.push(de, Te(w), Tn), R !== void 0)
        for (var We = 0; We < R.length; We++)
          Ce.push(qn, rn(R[We]), $n);
      if ($ !== void 0)
        for (var ct = 0; ct < $.length; ct++)
          Ce.push(jn, rn($[ct]), $n);
      return {
        bootstrapChunks: Ce,
        startInlineScript: de,
        placeholderPrefix: ne + "P:",
        segmentPrefix: ne + "S:",
        boundaryPrefix: ne + "B:",
        idPrefix: ne,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var ft = 0, dt = 1, Ct = 2, Yt = 3, Zt = 4, at = 5, tn = 6, cn = 7;
    function qt(l, f) {
      return {
        insertionMode: l,
        selectedValue: f
      };
    }
    function Sn(l, f, w) {
      switch (f) {
        case "select":
          return qt(dt, w.value != null ? w.value : w.defaultValue);
        case "svg":
          return qt(Ct, null);
        case "math":
          return qt(Yt, null);
        case "foreignObject":
          return qt(dt, null);
        case "table":
          return qt(Zt, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return qt(at, null);
        case "colgroup":
          return qt(cn, null);
        case "tr":
          return qt(tn, null);
      }
      return l.insertionMode >= Zt || l.insertionMode === ft ? qt(dt, null) : l;
    }
    var Wt = null;
    function Ee(l) {
      var f = l.nextSuspenseID++;
      return l.boundaryPrefix + f.toString(16);
    }
    function et(l, f, w) {
      var R = l.idPrefix, $ = ":" + R + "R" + f;
      return w > 0 && ($ += "H" + w.toString(32)), $ + ":";
    }
    function Ze(l) {
      return rn(l);
    }
    var Ke = "<!-- -->";
    function Vt(l, f, w, R) {
      return f === "" ? R : (R && l.push(Ke), l.push(Ze(f)), !0);
    }
    function At(l, f, w, R) {
      w && R && l.push(Ke);
    }
    var Xt = /* @__PURE__ */ new Map();
    function Rt(l) {
      var f = Xt.get(l);
      if (f !== void 0)
        return f;
      var w = rn(Wn(l));
      return Xt.set(l, w), w;
    }
    var Qt = ' style="', pn = ":", _t = ";";
    function x(l, f, w) {
      if (typeof w != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var R = !0;
      for (var $ in w)
        if (P.call(w, $)) {
          var ne = w[$];
          if (!(ne == null || typeof ne == "boolean" || ne === "")) {
            var de = void 0, Ce = void 0, We = $.indexOf("--") === 0;
            We ? (de = rn($), N(ne, $), Ce = rn(("" + ne).trim())) : (An($, ne), de = Rt($), typeof ne == "number" ? ne !== 0 && !P.call(Be, $) ? Ce = ne + "px" : Ce = "" + ne : (N(ne, $), Ce = rn(("" + ne).trim()))), R ? (R = !1, l.push(Qt, de, pn, Ce)) : l.push(_t, de, pn, Ce);
          }
        }
      R || l.push(X);
    }
    var D = " ", M = '="', X = '"', me = '=""';
    function ge(l, f, w, R) {
      switch (w) {
        case "style": {
          x(l, f, R);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(w.length > 2 && (w[0] === "o" || w[0] === "O") && (w[1] === "n" || w[1] === "N"))
      ) {
        var $ = q(w);
        if ($ !== null) {
          switch (typeof R) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!$.acceptsBooleans)
                return;
          }
          var ne = $.attributeName, de = ne;
          switch ($.type) {
            case J:
              R && l.push(D, de, me);
              return;
            case j:
              R === !0 ? l.push(D, de, me) : R === !1 || l.push(D, de, M, rn(R), X);
              return;
            case B:
              isNaN(R) || l.push(D, de, M, rn(R), X);
              break;
            case Z:
              !isNaN(R) && R >= 1 && l.push(D, de, M, rn(R), X);
              break;
            default:
              $.sanitizeURL && (y(R, ne), R = "" + R, or(R)), l.push(D, de, M, rn(R), X);
          }
        } else if (G(w)) {
          switch (typeof R) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Ce = w.toLowerCase().slice(0, 5);
              if (Ce !== "data-" && Ce !== "aria-")
                return;
            }
          }
          l.push(D, w, M, rn(R), X);
        }
      }
    }
    var Ae = ">", Ye = "/>";
    function ut(l, f, w) {
      if (f != null) {
        if (w != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof f != "object" || !("__html" in f))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var R = f.__html;
        R != null && (C(R), l.push("" + R));
      }
    }
    var gt = !1, pt = !1, Mt = !1, Pn = !1, Nn = !1, Rn = !1, tr = !1;
    function Un(l, f) {
      {
        var w = l[f];
        if (w != null) {
          var R = Ht(w);
          l.multiple && !R ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", f) : !l.multiple && R && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", f);
        }
      }
    }
    function ye(l, f, w) {
      $e("select", f), Un(f, "value"), Un(f, "defaultValue"), f.value !== void 0 && f.defaultValue !== void 0 && !Mt && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Mt = !0), l.push(Zn("select"));
      var R = null, $ = null;
      for (var ne in f)
        if (P.call(f, ne)) {
          var de = f[ne];
          if (de == null)
            continue;
          switch (ne) {
            case "children":
              R = de;
              break;
            case "dangerouslySetInnerHTML":
              $ = de;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              ge(l, w, ne, de);
              break;
          }
        }
      return l.push(Ae), ut(l, $, R), R;
    }
    function fe(l) {
      var f = "";
      return e.Children.forEach(l, function(w) {
        w != null && (f += w, !Nn && typeof w != "string" && typeof w != "number" && (Nn = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), f;
    }
    var xe = ' selected=""';
    function Me(l, f, w, R) {
      var $ = R.selectedValue;
      l.push(Zn("option"));
      var ne = null, de = null, Ce = null, We = null;
      for (var ct in f)
        if (P.call(f, ct)) {
          var ht = f[ct];
          if (ht == null)
            continue;
          switch (ct) {
            case "children":
              ne = ht;
              break;
            case "selected":
              Ce = ht, tr || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), tr = !0);
              break;
            case "dangerouslySetInnerHTML":
              We = ht;
              break;
            case "value":
              de = ht;
            default:
              ge(l, w, ct, ht);
              break;
          }
        }
      if ($ != null) {
        var Lt;
        if (de !== null ? (y(de, "value"), Lt = "" + de) : (We !== null && (Rn || (Rn = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), Lt = fe(ne)), Ht($))
          for (var bn = 0; bn < $.length; bn++) {
            y($[bn], "value");
            var Hn = "" + $[bn];
            if (Hn === Lt) {
              l.push(xe);
              break;
            }
          }
        else
          y($, "select.value"), "" + $ === Lt && l.push(xe);
      } else
        Ce && l.push(xe);
      return l.push(Ae), ut(l, We, ne), ne;
    }
    function zt(l, f, w) {
      $e("input", f), f.checked !== void 0 && f.defaultChecked !== void 0 && !pt && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), pt = !0), f.value !== void 0 && f.defaultValue !== void 0 && !gt && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), gt = !0), l.push(Zn("input"));
      var R = null, $ = null, ne = null, de = null;
      for (var Ce in f)
        if (P.call(f, Ce)) {
          var We = f[Ce];
          if (We == null)
            continue;
          switch (Ce) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              de = We;
              break;
            case "defaultValue":
              $ = We;
              break;
            case "checked":
              ne = We;
              break;
            case "value":
              R = We;
              break;
            default:
              ge(l, w, Ce, We);
              break;
          }
        }
      return ne !== null ? ge(l, w, "checked", ne) : de !== null && ge(l, w, "checked", de), R !== null ? ge(l, w, "value", R) : $ !== null && ge(l, w, "value", $), l.push(Ye), null;
    }
    function Gn(l, f, w) {
      $e("textarea", f), f.value !== void 0 && f.defaultValue !== void 0 && !Pn && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Pn = !0), l.push(Zn("textarea"));
      var R = null, $ = null, ne = null;
      for (var de in f)
        if (P.call(f, de)) {
          var Ce = f[de];
          if (Ce == null)
            continue;
          switch (de) {
            case "children":
              ne = Ce;
              break;
            case "value":
              R = Ce;
              break;
            case "defaultValue":
              $ = Ce;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              ge(l, w, de, Ce);
              break;
          }
        }
      if (R === null && $ !== null && (R = $), l.push(Ae), ne != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), R != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (Ht(ne)) {
          if (ne.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          C(ne[0]), R = "" + ne[0];
        }
        C(ne), R = "" + ne;
      }
      return typeof R == "string" && R[0] === `
` && l.push(na), R !== null && (y(R, "value"), l.push(Ze("" + R))), null;
    }
    function Er(l, f, w, R) {
      l.push(Zn(w));
      for (var $ in f)
        if (P.call(f, $)) {
          var ne = f[$];
          if (ne == null)
            continue;
          switch ($) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(w + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              ge(l, R, $, ne);
              break;
          }
        }
      return l.push(Ye), null;
    }
    function Vr(l, f, w) {
      l.push(Zn("menuitem"));
      for (var R in f)
        if (P.call(f, R)) {
          var $ = f[R];
          if ($ == null)
            continue;
          switch (R) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              ge(l, w, R, $);
              break;
          }
        }
      return l.push(Ae), null;
    }
    function Rr(l, f, w) {
      l.push(Zn("title"));
      var R = null;
      for (var $ in f)
        if (P.call(f, $)) {
          var ne = f[$];
          if (ne == null)
            continue;
          switch ($) {
            case "children":
              R = ne;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              ge(l, w, $, ne);
              break;
          }
        }
      l.push(Ae);
      {
        var de = Array.isArray(R) && R.length < 2 ? R[0] || null : R;
        Array.isArray(R) && R.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : de != null && de.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : de != null && typeof de != "string" && typeof de != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return R;
    }
    function qa(l, f, w, R) {
      l.push(Zn(w));
      var $ = null, ne = null;
      for (var de in f)
        if (P.call(f, de)) {
          var Ce = f[de];
          if (Ce == null)
            continue;
          switch (de) {
            case "children":
              $ = Ce;
              break;
            case "dangerouslySetInnerHTML":
              ne = Ce;
              break;
            default:
              ge(l, R, de, Ce);
              break;
          }
        }
      return l.push(Ae), ut(l, ne, $), typeof $ == "string" ? (l.push(Ze($)), null) : $;
    }
    function br(l, f, w, R) {
      l.push(Zn(w));
      var $ = null, ne = null;
      for (var de in f)
        if (P.call(f, de)) {
          var Ce = f[de];
          if (Ce == null)
            continue;
          switch (de) {
            case "children":
              $ = Ce;
              break;
            case "dangerouslySetInnerHTML":
              ne = Ce;
              break;
            case "style":
              x(l, R, Ce);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              G(de) && typeof Ce != "function" && typeof Ce != "symbol" && l.push(D, de, M, rn(Ce), X);
              break;
          }
        }
      return l.push(Ae), ut(l, ne, $), $;
    }
    var na = `
`;
    function xa(l, f, w, R) {
      l.push(Zn(w));
      var $ = null, ne = null;
      for (var de in f)
        if (P.call(f, de)) {
          var Ce = f[de];
          if (Ce == null)
            continue;
          switch (de) {
            case "children":
              $ = Ce;
              break;
            case "dangerouslySetInnerHTML":
              ne = Ce;
              break;
            default:
              ge(l, R, de, Ce);
              break;
          }
        }
      if (l.push(Ae), ne != null) {
        if ($ != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof ne != "object" || !("__html" in ne))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var We = ne.__html;
        We != null && (typeof We == "string" && We.length > 0 && We[0] === `
` ? l.push(na, We) : (C(We), l.push("" + We)));
      }
      return typeof $ == "string" && $[0] === `
` && l.push(na), $;
    }
    var hn = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Sr = /* @__PURE__ */ new Map();
    function Zn(l) {
      var f = Sr.get(l);
      if (f === void 0) {
        if (!hn.test(l))
          throw new Error("Invalid tag: " + l);
        f = "<" + l, Sr.set(l, f);
      }
      return f;
    }
    var Dr = "<!DOCTYPE html>";
    function kr(l, f, w, R, $) {
      switch (Xe(f, w), Ue(f, w), ln(f, w, null), !w.suppressContentEditableWarning && w.contentEditable && w.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), $.insertionMode !== Ct && $.insertionMode !== Yt && f.indexOf("-") === -1 && typeof w.is != "string" && f.toLowerCase() !== f && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", f), f) {
        case "select":
          return ye(l, w, R);
        case "option":
          return Me(l, w, R, $);
        case "textarea":
          return Gn(l, w, R);
        case "input":
          return zt(l, w, R);
        case "menuitem":
          return Vr(l, w, R);
        case "title":
          return Rr(l, w, R);
        case "listing":
        case "pre":
          return xa(l, w, f, R);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Er(l, w, f, R);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return qa(l, w, f, R);
        case "html":
          return $.insertionMode === ft && l.push(Dr), qa(l, w, f, R);
        default:
          return f.indexOf("-") === -1 && typeof w.is != "string" ? qa(l, w, f, R) : br(l, w, f, R);
      }
    }
    var ba = "</", wr = ">";
    function lr(l, f, w) {
      switch (f) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          l.push(ba, f, wr);
      }
    }
    function Ga(l, f) {
      for (var w = f.bootstrapChunks, R = 0; R < w.length - 1; R++)
        s(l, w[R]);
      return R < w.length ? p(l, w[R]) : !0;
    }
    var Za = '<template id="', Yi = '"></template>';
    function Xi(l, f, w) {
      s(l, Za), s(l, f.placeholderPrefix);
      var R = w.toString(16);
      return s(l, R), p(l, Yi);
    }
    var qi = "<!--$-->", dl = '<!--$?--><template id="', fl = '"></template>', Ea = "<!--$!-->", Sa = "<!--/$-->", ka = "<template", ra = '"', pl = ' data-dgst="', aa = ' data-msg="', Qa = ' data-stck="', Ja = "></template>";
    function Wr(l, f) {
      return p(l, qi);
    }
    function jr(l, f, w) {
      if (s(l, dl), w === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, w), p(l, fl);
    }
    function wa(l, f, w, R, $) {
      var ne;
      return ne = p(l, Ea), s(l, ka), w && (s(l, pl), s(l, rn(w)), s(l, ra)), R && (s(l, aa), s(l, rn(R)), s(l, ra)), $ && (s(l, Qa), s(l, rn($)), s(l, ra)), ne = p(l, Ja), ne;
    }
    function Gi(l, f) {
      return p(l, Sa);
    }
    function ei(l, f) {
      return p(l, Sa);
    }
    function Zi(l, f) {
      return p(l, Sa);
    }
    var Ta = '<div hidden id="', Qn = '">', Qi = "</div>", Ca = '<svg aria-hidden="true" style="display:none" id="', hl = '">', Ji = "</svg>", Aa = '<math aria-hidden="true" style="display:none" id="', eo = '">', to = "</math>", La = '<table hidden id="', Pa = '">', no = "</table>", ro = '<table hidden><tbody id="', ao = '">', ti = "</tbody></table>", io = '<table hidden><tr id="', S = '">', _ = "</tr></table>", I = '<table hidden><colgroup id="', Q = '">', we = "</colgroup></table>";
    function Se(l, f, w, R) {
      switch (w.insertionMode) {
        case ft:
        case dt:
          return s(l, Ta), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, Qn);
        case Ct:
          return s(l, Ca), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, hl);
        case Yt:
          return s(l, Aa), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, eo);
        case Zt:
          return s(l, La), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, Pa);
        case at:
          return s(l, ro), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, ao);
        case tn:
          return s(l, io), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, S);
        case cn:
          return s(l, I), s(l, f.segmentPrefix), s(l, R.toString(16)), p(l, Q);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Ie(l, f) {
      switch (f.insertionMode) {
        case ft:
        case dt:
          return p(l, Qi);
        case Ct:
          return p(l, Ji);
        case Yt:
          return p(l, to);
        case Zt:
          return p(l, no);
        case at:
          return p(l, ti);
        case tn:
          return p(l, _);
        case cn:
          return p(l, we);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Je = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", kt = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Bt = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Ft = Je + ';$RS("', vn = '$RS("', Jn = '","', sr = '")<\/script>';
    function ur(l, f, w) {
      s(l, f.startInlineScript), f.sentCompleteSegmentFunction ? s(l, vn) : (f.sentCompleteSegmentFunction = !0, s(l, Ft)), s(l, f.segmentPrefix);
      var R = w.toString(16);
      return s(l, R), s(l, Jn), s(l, f.placeholderPrefix), s(l, R), p(l, sr);
    }
    var Na = kt + ';$RC("', oo = '$RC("', ni = '","', Wc = '")<\/script>';
    function jc(l, f, w, R) {
      if (s(l, f.startInlineScript), f.sentCompleteBoundaryFunction ? s(l, oo) : (f.sentCompleteBoundaryFunction = !0, s(l, Na)), w === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var $ = R.toString(16);
      return s(l, w), s(l, ni), s(l, f.segmentPrefix), s(l, $), p(l, Wc);
    }
    var Uc = Bt + ';$RX("', Kc = '$RX("', Yc = '"', Xc = ")<\/script>", ml = ",";
    function qc(l, f, w, R, $, ne) {
      if (s(l, f.startInlineScript), f.sentClientRenderFunction ? s(l, Kc) : (f.sentClientRenderFunction = !0, s(l, Uc)), w === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, w), s(l, Yc), (R || $ || ne) && (s(l, ml), s(l, yl(R || ""))), ($ || ne) && (s(l, ml), s(l, yl($ || ""))), ne && (s(l, ml), s(l, yl(ne))), p(l, Xc);
    }
    var Gc = /[<\u2028\u2029]/g;
    function yl(l) {
      var f = JSON.stringify(l);
      return f.replace(Gc, function(w) {
        switch (w) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Zc(l, f) {
      var w = it(f, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: w.bootstrapChunks,
        startInlineScript: w.startInlineScript,
        placeholderPrefix: w.placeholderPrefix,
        segmentPrefix: w.segmentPrefix,
        boundaryPrefix: w.boundaryPrefix,
        idPrefix: w.idPrefix,
        nextSuspenseID: w.nextSuspenseID,
        sentCompleteSegmentFunction: w.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: w.sentCompleteBoundaryFunction,
        sentClientRenderFunction: w.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: l
      };
    }
    function gl() {
      return {
        insertionMode: dt,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function zs(l, f, w, R) {
      return w.generateStaticMarkup ? (l.push(rn(f)), !1) : Vt(l, f, w, R);
    }
    function Bs(l, f, w, R) {
      if (!f.generateStaticMarkup)
        return At(l, f, w, R);
    }
    function vl(l, f) {
      return f.generateStaticMarkup ? !0 : Wr(l);
    }
    function mr(l, f, w, R, $) {
      return f.generateStaticMarkup ? !0 : wa(l, f, w, R, $);
    }
    function Qc(l, f) {
      return f.generateStaticMarkup ? !0 : Gi(l);
    }
    function $s(l, f) {
      return f.generateStaticMarkup ? !0 : Zi(l);
    }
    var cr = Object.assign, Is = Symbol.for("react.element"), xl = Symbol.for("react.portal"), lo = Symbol.for("react.fragment"), so = Symbol.for("react.strict_mode"), uo = Symbol.for("react.profiler"), ri = Symbol.for("react.provider"), ai = Symbol.for("react.context"), ii = Symbol.for("react.forward_ref"), Ra = Symbol.for("react.suspense"), bl = Symbol.for("react.suspense_list"), El = Symbol.for("react.memo"), co = Symbol.for("react.lazy"), Jc = Symbol.for("react.scope"), Hs = Symbol.for("react.debug_trace_mode"), ed = Symbol.for("react.legacy_hidden"), td = Symbol.for("react.default_value"), Vs = Symbol.iterator, Ws = "@@iterator";
    function wn(l) {
      if (l === null || typeof l != "object")
        return null;
      var f = Vs && l[Vs] || l[Ws];
      return typeof f == "function" ? f : null;
    }
    function oi(l, f, w) {
      var R = l.displayName;
      if (R)
        return R;
      var $ = f.displayName || f.name || "";
      return $ !== "" ? w + "(" + $ + ")" : w;
    }
    function Sl(l) {
      return l.displayName || "Context";
    }
    function kn(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case lo:
          return "Fragment";
        case xl:
          return "Portal";
        case uo:
          return "Profiler";
        case so:
          return "StrictMode";
        case Ra:
          return "Suspense";
        case bl:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ai:
            var f = l;
            return Sl(f) + ".Consumer";
          case ri:
            var w = l;
            return Sl(w._context) + ".Provider";
          case ii:
            return oi(l, l.render, "ForwardRef");
          case El:
            var R = l.displayName || null;
            return R !== null ? R : kn(l.type) || "Memo";
          case co: {
            var $ = l, ne = $._payload, de = $._init;
            try {
              return kn(de(ne));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Da = 0, kl, wl, Tl, Cl, Al, js, Us;
    function fo() {
    }
    fo.__reactDisabledLog = !0;
    function Ll() {
      {
        if (Da === 0) {
          kl = console.log, wl = console.info, Tl = console.warn, Cl = console.error, Al = console.group, js = console.groupCollapsed, Us = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: fo,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        Da++;
      }
    }
    function li() {
      {
        if (Da--, Da === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: cr({}, l, {
              value: kl
            }),
            info: cr({}, l, {
              value: wl
            }),
            warn: cr({}, l, {
              value: Tl
            }),
            error: cr({}, l, {
              value: Cl
            }),
            group: cr({}, l, {
              value: Al
            }),
            groupCollapsed: cr({}, l, {
              value: js
            }),
            groupEnd: cr({}, l, {
              value: Us
            })
          });
        }
        Da < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var si = r.ReactCurrentDispatcher, _a;
    function ui(l, f, w) {
      {
        if (_a === void 0)
          try {
            throw Error();
          } catch ($) {
            var R = $.stack.trim().match(/\n( *(at )?)/);
            _a = R && R[1] || "";
          }
        return `
` + _a + l;
      }
    }
    var ci = !1, po;
    {
      var Ks = typeof WeakMap == "function" ? WeakMap : Map;
      po = new Ks();
    }
    function Pl(l, f) {
      if (!l || ci)
        return "";
      {
        var w = po.get(l);
        if (w !== void 0)
          return w;
      }
      var R;
      ci = !0;
      var $ = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ne;
      ne = si.current, si.current = null, Ll();
      try {
        if (f) {
          var de = function() {
            throw Error();
          };
          if (Object.defineProperty(de.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(de, []);
            } catch (xr) {
              R = xr;
            }
            Reflect.construct(l, [], de);
          } else {
            try {
              de.call();
            } catch (xr) {
              R = xr;
            }
            l.call(de.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (xr) {
            R = xr;
          }
          l();
        }
      } catch (xr) {
        if (xr && R && typeof xr.stack == "string") {
          for (var Ce = xr.stack.split(`
`), We = R.stack.split(`
`), ct = Ce.length - 1, ht = We.length - 1; ct >= 1 && ht >= 0 && Ce[ct] !== We[ht]; )
            ht--;
          for (; ct >= 1 && ht >= 0; ct--, ht--)
            if (Ce[ct] !== We[ht]) {
              if (ct !== 1 || ht !== 1)
                do
                  if (ct--, ht--, ht < 0 || Ce[ct] !== We[ht]) {
                    var Lt = `
` + Ce[ct].replace(" at new ", " at ");
                    return l.displayName && Lt.includes("<anonymous>") && (Lt = Lt.replace("<anonymous>", l.displayName)), typeof l == "function" && po.set(l, Lt), Lt;
                  }
                while (ct >= 1 && ht >= 0);
              break;
            }
        }
      } finally {
        ci = !1, si.current = ne, li(), Error.prepareStackTrace = $;
      }
      var bn = l ? l.displayName || l.name : "", Hn = bn ? ui(bn) : "";
      return typeof l == "function" && po.set(l, Hn), Hn;
    }
    function Nl(l, f, w) {
      return Pl(l, !0);
    }
    function Rl(l, f, w) {
      return Pl(l, !1);
    }
    function Ys(l) {
      var f = l.prototype;
      return !!(f && f.isReactComponent);
    }
    function Oa(l, f, w) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return Pl(l, Ys(l));
      if (typeof l == "string")
        return ui(l);
      switch (l) {
        case Ra:
          return ui("Suspense");
        case bl:
          return ui("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ii:
            return Rl(l.render);
          case El:
            return Oa(l.type, f, w);
          case co: {
            var R = l, $ = R._payload, ne = R._init;
            try {
              return Oa(ne($), f, w);
            } catch {
            }
          }
        }
      return "";
    }
    var Dl = {}, ho = r.ReactDebugCurrentFrame;
    function ia(l) {
      if (l) {
        var f = l._owner, w = Oa(l.type, l._source, f ? f.type : null);
        ho.setExtraStackFrame(w);
      } else
        ho.setExtraStackFrame(null);
    }
    function _l(l, f, w, R, $) {
      {
        var ne = Function.call.bind(P);
        for (var de in l)
          if (ne(l, de)) {
            var Ce = void 0;
            try {
              if (typeof l[de] != "function") {
                var We = Error((R || "React class") + ": " + w + " type `" + de + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[de] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw We.name = "Invariant Violation", We;
              }
              Ce = l[de](f, de, R, w, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ct) {
              Ce = ct;
            }
            Ce && !(Ce instanceof Error) && (ia($), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", R || "React class", w, de, typeof Ce), ia(null)), Ce instanceof Error && !(Ce.message in Dl) && (Dl[Ce.message] = !0, ia($), i("Failed %s type: %s", w, Ce.message), ia(null));
          }
      }
    }
    var Ol;
    Ol = {};
    var Ur = {};
    Object.freeze(Ur);
    function Xs(l, f) {
      {
        var w = l.contextTypes;
        if (!w)
          return Ur;
        var R = {};
        for (var $ in w)
          R[$] = f[$];
        {
          var ne = kn(l) || "Unknown";
          _l(w, R, "context", ne);
        }
        return R;
      }
    }
    function oa(l, f, w, R) {
      {
        if (typeof l.getChildContext != "function") {
          {
            var $ = kn(f) || "Unknown";
            Ol[$] || (Ol[$] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", $, $));
          }
          return w;
        }
        var ne = l.getChildContext();
        for (var de in ne)
          if (!(de in R))
            throw new Error((kn(f) || "Unknown") + '.getChildContext(): key "' + de + '" is not defined in childContextTypes.');
        {
          var Ce = kn(f) || "Unknown";
          _l(R, ne, "child context", Ce);
        }
        return cr({}, w, ne);
      }
    }
    var la;
    la = {};
    var Fl = null, Tr = null;
    function mo(l) {
      l.context._currentValue2 = l.parentValue;
    }
    function yo(l) {
      l.context._currentValue2 = l.value;
    }
    function di(l, f) {
      if (l !== f) {
        mo(l);
        var w = l.parent, R = f.parent;
        if (w === null) {
          if (R !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (R === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          di(w, R);
        }
        yo(f);
      }
    }
    function Ml(l) {
      mo(l);
      var f = l.parent;
      f !== null && Ml(f);
    }
    function fi(l) {
      var f = l.parent;
      f !== null && fi(f), yo(l);
    }
    function qs(l, f) {
      mo(l);
      var w = l.parent;
      if (w === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      w.depth === f.depth ? di(w, f) : qs(w, f);
    }
    function Gs(l, f) {
      var w = f.parent;
      if (w === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      l.depth === w.depth ? di(l, w) : Gs(l, w), yo(f);
    }
    function go(l) {
      var f = Tr, w = l;
      f !== w && (f === null ? fi(w) : w === null ? Ml(f) : f.depth === w.depth ? di(f, w) : f.depth > w.depth ? qs(f, w) : Gs(f, w), Tr = w);
    }
    function pi(l, f) {
      var w;
      w = l._currentValue2, l._currentValue2 = f, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== la && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = la;
      var R = Tr, $ = {
        parent: R,
        depth: R === null ? 0 : R.depth + 1,
        context: l,
        parentValue: w,
        value: f
      };
      return Tr = $, $;
    }
    function zl(l) {
      var f = Tr;
      if (f === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      f.context !== l && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var w = f.parentValue;
        w === td ? f.context._currentValue2 = f.context._defaultValue : f.context._currentValue2 = w, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== la && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = la;
      }
      return Tr = f.parent;
    }
    function nd() {
      return Tr;
    }
    function Fa(l) {
      var f = l._currentValue2;
      return f;
    }
    function vo(l) {
      return l._reactInternals;
    }
    function Bl(l, f) {
      l._reactInternals = f;
    }
    var xo = {}, bo = {}, hi, Eo, Ma, mi, So, za, ko, wo, To;
    {
      hi = /* @__PURE__ */ new Set(), Eo = /* @__PURE__ */ new Set(), Ma = /* @__PURE__ */ new Set(), ko = /* @__PURE__ */ new Set(), mi = /* @__PURE__ */ new Set(), wo = /* @__PURE__ */ new Set(), To = /* @__PURE__ */ new Set();
      var Zs = /* @__PURE__ */ new Set();
      za = function(l, f) {
        if (!(l === null || typeof l == "function")) {
          var w = f + "_" + l;
          Zs.has(w) || (Zs.add(w), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, l));
        }
      }, So = function(l, f) {
        if (f === void 0) {
          var w = kn(l) || "Component";
          mi.has(w) || (mi.add(w), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", w));
        }
      };
    }
    function Qs(l, f) {
      {
        var w = l.constructor, R = w && kn(w) || "ReactClass", $ = R + "." + f;
        if (xo[$])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, f, f, R), xo[$] = !0;
      }
    }
    var Js = {
      isMounted: function(l) {
        return !1;
      },
      enqueueSetState: function(l, f, w) {
        var R = vo(l);
        R.queue === null ? Qs(l, "setState") : (R.queue.push(f), w != null && za(w, "setState"));
      },
      enqueueReplaceState: function(l, f, w) {
        var R = vo(l);
        R.replace = !0, R.queue = [f], w != null && za(w, "setState");
      },
      enqueueForceUpdate: function(l, f) {
        var w = vo(l);
        w.queue === null ? Qs(l, "forceUpdate") : f != null && za(f, "setState");
      }
    };
    function rd(l, f, w, R, $) {
      var ne = w($, R);
      So(f, ne);
      var de = ne == null ? R : cr({}, R, ne);
      return de;
    }
    function ad(l, f, w) {
      var R = Ur, $ = l.contextType;
      if ("contextType" in l) {
        var ne = (
          // Allow null for conditional declaration
          $ === null || $ !== void 0 && $.$$typeof === ai && $._context === void 0
        );
        if (!ne && !To.has(l)) {
          To.add(l);
          var de = "";
          $ === void 0 ? de = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof $ != "object" ? de = " However, it is set to a " + typeof $ + "." : $.$$typeof === ri ? de = " Did you accidentally pass the Context.Provider instead?" : $._context !== void 0 ? de = " Did you accidentally pass the Context.Consumer instead?" : de = " However, it is set to an object with keys {" + Object.keys($).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", kn(l) || "Component", de);
        }
      }
      typeof $ == "object" && $ !== null ? R = Fa($) : R = w;
      var Ce = new l(f, R);
      {
        if (typeof l.getDerivedStateFromProps == "function" && (Ce.state === null || Ce.state === void 0)) {
          var We = kn(l) || "Component";
          hi.has(We) || (hi.add(We), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", We, Ce.state === null ? "null" : "undefined", We));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof Ce.getSnapshotBeforeUpdate == "function") {
          var ct = null, ht = null, Lt = null;
          if (typeof Ce.componentWillMount == "function" && Ce.componentWillMount.__suppressDeprecationWarning !== !0 ? ct = "componentWillMount" : typeof Ce.UNSAFE_componentWillMount == "function" && (ct = "UNSAFE_componentWillMount"), typeof Ce.componentWillReceiveProps == "function" && Ce.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? ht = "componentWillReceiveProps" : typeof Ce.UNSAFE_componentWillReceiveProps == "function" && (ht = "UNSAFE_componentWillReceiveProps"), typeof Ce.componentWillUpdate == "function" && Ce.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Lt = "componentWillUpdate" : typeof Ce.UNSAFE_componentWillUpdate == "function" && (Lt = "UNSAFE_componentWillUpdate"), ct !== null || ht !== null || Lt !== null) {
            var bn = kn(l) || "Component", Hn = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Ma.has(bn) || (Ma.add(bn), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, bn, Hn, ct !== null ? `
  ` + ct : "", ht !== null ? `
  ` + ht : "", Lt !== null ? `
  ` + Lt : ""));
          }
        }
      }
      return Ce;
    }
    function eu(l, f, w) {
      {
        var R = kn(f) || "Component", $ = l.render;
        $ || (f.prototype && typeof f.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", R) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", R)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", R), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", R), l.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", R), l.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", R), l.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", R), f.contextType && f.contextTypes && !wo.has(f) && (wo.add(f), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", R)), typeof l.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", R), f.prototype && f.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", kn(f) || "A pure component"), typeof l.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", R), typeof l.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", R), typeof l.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", R), typeof l.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", R);
        var ne = l.props !== w;
        l.props !== void 0 && ne && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", R, R), l.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", R, R), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !Eo.has(f) && (Eo.add(f), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", kn(f))), typeof l.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", R), typeof l.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", R), typeof f.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", R);
        var de = l.state;
        de && (typeof de != "object" || Ht(de)) && i("%s.state: must be set to an object or null", R), typeof l.getChildContext == "function" && typeof f.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", R);
      }
    }
    function id(l, f) {
      var w = f.state;
      if (typeof f.componentWillMount == "function") {
        if (f.componentWillMount.__suppressDeprecationWarning !== !0) {
          var R = kn(l) || "Unknown";
          bo[R] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            R
          ), bo[R] = !0);
        }
        f.componentWillMount();
      }
      typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), w !== f.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", kn(l) || "Component"), Js.enqueueReplaceState(f, f.state, null));
    }
    function od(l, f, w, R) {
      if (l.queue !== null && l.queue.length > 0) {
        var $ = l.queue, ne = l.replace;
        if (l.queue = null, l.replace = !1, ne && $.length === 1)
          f.state = $[0];
        else {
          for (var de = ne ? $[0] : f.state, Ce = !0, We = ne ? 1 : 0; We < $.length; We++) {
            var ct = $[We], ht = typeof ct == "function" ? ct.call(f, de, w, R) : ct;
            ht != null && (Ce ? (Ce = !1, de = cr({}, de, ht)) : cr(de, ht));
          }
          f.state = de;
        }
      } else
        l.queue = null;
    }
    function Co(l, f, w, R) {
      eu(l, f, w);
      var $ = l.state !== void 0 ? l.state : null;
      l.updater = Js, l.props = w, l.state = $;
      var ne = {
        queue: [],
        replace: !1
      };
      Bl(l, ne);
      var de = f.contextType;
      if (typeof de == "object" && de !== null ? l.context = Fa(de) : l.context = R, l.state === w) {
        var Ce = kn(f) || "Component";
        ko.has(Ce) || (ko.add(Ce), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Ce));
      }
      var We = f.getDerivedStateFromProps;
      typeof We == "function" && (l.state = rd(l, f, We, $, w)), typeof f.getDerivedStateFromProps != "function" && typeof l.getSnapshotBeforeUpdate != "function" && (typeof l.UNSAFE_componentWillMount == "function" || typeof l.componentWillMount == "function") && (id(f, l), od(ne, l, w, R));
    }
    var Ao = {
      id: 1,
      overflow: ""
    };
    function ld(l) {
      var f = l.overflow, w = l.id, R = w & ~sd(w);
      return R.toString(32) + f;
    }
    function $l(l, f, w) {
      var R = l.id, $ = l.overflow, ne = Lo(R) - 1, de = R & ~(1 << ne), Ce = w + 1, We = Lo(f) + ne;
      if (We > 30) {
        var ct = ne - ne % 5, ht = (1 << ct) - 1, Lt = (de & ht).toString(32), bn = de >> ct, Hn = ne - ct, xr = Lo(f) + Hn, Su = Ce << Hn, ku = Su | bn, wu = Lt + $;
        return {
          id: 1 << xr | ku,
          overflow: wu
        };
      } else {
        var jo = Ce << ne, mg = jo | de, yg = $;
        return {
          id: 1 << We | mg,
          overflow: yg
        };
      }
    }
    function Lo(l) {
      return 32 - ud(l);
    }
    function sd(l) {
      return 1 << Lo(l) - 1;
    }
    var ud = Math.clz32 ? Math.clz32 : _r, cd = Math.log, dd = Math.LN2;
    function _r(l) {
      var f = l >>> 0;
      return f === 0 ? 32 : 31 - (cd(f) / dd | 0) | 0;
    }
    function Il(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var Po = typeof Object.is == "function" ? Object.is : Il, Jt = null, sa = null, ua = null, dn = null, yr = !1, ca = !1, No = 0, In = null, Or = 0, da = 25, Cr = !1, fa;
    function Fr() {
      if (Jt === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Cr && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Jt;
    }
    function fd(l, f) {
      if (f === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", fa), !1;
      l.length !== f.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, fa, "[" + l.join(", ") + "]", "[" + f.join(", ") + "]");
      for (var w = 0; w < f.length && w < l.length; w++)
        if (!Po(l[w], f[w]))
          return !1;
      return !0;
    }
    function tu() {
      if (Or > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Ro() {
      return dn === null ? ua === null ? (yr = !1, ua = dn = tu()) : (yr = !0, dn = ua) : dn.next === null ? (yr = !1, dn = dn.next = tu()) : (yr = !0, dn = dn.next), dn;
    }
    function Hl(l, f) {
      Jt = f, sa = l, Cr = !1, No = 0;
    }
    function pd(l, f, w, R) {
      for (; ca; )
        ca = !1, No = 0, Or += 1, dn = null, w = l(f, R);
      return yi(), w;
    }
    function nu() {
      var l = No !== 0;
      return l;
    }
    function yi() {
      Cr = !1, Jt = null, sa = null, ca = !1, ua = null, Or = 0, In = null, dn = null;
    }
    function hd(l) {
      return Cr && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Fa(l);
    }
    function ru(l) {
      return fa = "useContext", Fr(), Fa(l);
    }
    function Do(l, f) {
      return typeof f == "function" ? f(l) : f;
    }
    function md(l) {
      return fa = "useState", au(
        Do,
        // useReducer has a special case to support lazy useState initializers
        l
      );
    }
    function au(l, f, w) {
      if (l !== Do && (fa = "useReducer"), Jt = Fr(), dn = Ro(), yr) {
        var R = dn.queue, $ = R.dispatch;
        if (In !== null) {
          var ne = In.get(R);
          if (ne !== void 0) {
            In.delete(R);
            var de = dn.memoizedState, Ce = ne;
            do {
              var We = Ce.action;
              Cr = !0, de = l(de, We), Cr = !1, Ce = Ce.next;
            } while (Ce !== null);
            return dn.memoizedState = de, [de, $];
          }
        }
        return [dn.memoizedState, $];
      } else {
        Cr = !0;
        var ct;
        l === Do ? ct = typeof f == "function" ? f() : f : ct = w !== void 0 ? w(f) : f, Cr = !1, dn.memoizedState = ct;
        var ht = dn.queue = {
          last: null,
          dispatch: null
        }, Lt = ht.dispatch = vd.bind(null, Jt, ht);
        return [dn.memoizedState, Lt];
      }
    }
    function iu(l, f) {
      Jt = Fr(), dn = Ro();
      var w = f === void 0 ? null : f;
      if (dn !== null) {
        var R = dn.memoizedState;
        if (R !== null && w !== null) {
          var $ = R[1];
          if (fd(w, $))
            return R[0];
        }
      }
      Cr = !0;
      var ne = l();
      return Cr = !1, dn.memoizedState = [ne, w], ne;
    }
    function yd(l) {
      Jt = Fr(), dn = Ro();
      var f = dn.memoizedState;
      if (f === null) {
        var w = {
          current: l
        };
        return Object.seal(w), dn.memoizedState = w, w;
      } else
        return f;
    }
    function gd(l, f) {
      fa = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function vd(l, f, w) {
      if (Or >= da)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (l === Jt) {
        ca = !0;
        var R = {
          action: w,
          next: null
        };
        In === null && (In = /* @__PURE__ */ new Map());
        var $ = In.get(f);
        if ($ === void 0)
          In.set(f, R);
        else {
          for (var ne = $; ne.next !== null; )
            ne = ne.next;
          ne.next = R;
        }
      }
    }
    function xd(l, f) {
      return iu(function() {
        return l;
      }, f);
    }
    function bd(l, f, w) {
      return Fr(), f(l._source);
    }
    function Ed(l, f, w) {
      if (w === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return w();
    }
    function Sd(l) {
      return Fr(), l;
    }
    function _o() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function ou() {
      return Fr(), [!1, _o];
    }
    function Vl() {
      var l = sa, f = ld(l.treeContext), w = vi;
      if (w === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var R = No++;
      return et(w, f, R);
    }
    function gi() {
    }
    var lu = {
      readContext: hd,
      useContext: ru,
      useMemo: iu,
      useReducer: au,
      useRef: yd,
      useState: md,
      useInsertionEffect: gi,
      useLayoutEffect: gd,
      useCallback: xd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: gi,
      // Effects are not run in the server environment.
      useEffect: gi,
      // Debugging effect
      useDebugValue: gi,
      useDeferredValue: Sd,
      useTransition: ou,
      useId: Vl,
      // Subscriptions are not setup in a server environment.
      useMutableSource: bd,
      useSyncExternalStore: Ed
    }, vi = null;
    function Oo(l) {
      vi = l;
    }
    function Wl(l) {
      try {
        var f = "", w = l;
        do {
          switch (w.tag) {
            case 0:
              f += ui(w.type, null, null);
              break;
            case 1:
              f += Rl(w.type, null, null);
              break;
            case 2:
              f += Nl(w.type, null, null);
              break;
          }
          w = w.parent;
        } while (w);
        return f;
      } catch (R) {
        return `
Error generating stack: ` + R.message + `
` + R.stack;
      }
    }
    var Kr = r.ReactCurrentDispatcher, Fo = r.ReactDebugCurrentFrame, Mo = 0, pa = 1, su = 2, jl = 3, ha = 4, kd = 0, uu = 1, Ar = 2, wd = 12800;
    function Td(l) {
      return console.error(l), null;
    }
    function xi() {
    }
    function Ul(l, f, w, R, $, ne, de, Ce, We) {
      var ct = [], ht = /* @__PURE__ */ new Set(), Lt = {
        destination: null,
        responseState: f,
        progressiveChunkSize: R === void 0 ? wd : R,
        status: kd,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: ht,
        pingedTasks: ct,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: $ === void 0 ? Td : $,
        onAllReady: ne === void 0 ? xi : ne,
        onShellReady: de === void 0 ? xi : de,
        onShellError: Ce === void 0 ? xi : Ce,
        onFatalError: We === void 0 ? xi : We
      }, bn = Yr(
        Lt,
        0,
        null,
        w,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      bn.parentFlushed = !0;
      var Hn = bi(Lt, l, null, bn, ht, Ur, Fl, Ao);
      return ct.push(Hn), Lt;
    }
    function zo(l, f) {
      var w = l.pingedTasks;
      w.push(f), w.length === 1 && d(function() {
        return bu(l);
      });
    }
    function Mr(l, f) {
      return {
        id: Wt,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: f,
        errorDigest: null
      };
    }
    function bi(l, f, w, R, $, ne, de, Ce) {
      l.allPendingTasks++, w === null ? l.pendingRootTasks++ : w.pendingTasks++;
      var We = {
        node: f,
        ping: function() {
          return zo(l, We);
        },
        blockedBoundary: w,
        blockedSegment: R,
        abortSet: $,
        legacyContext: ne,
        context: de,
        treeContext: Ce
      };
      return We.componentStack = null, $.add(We), We;
    }
    function Yr(l, f, w, R, $, ne) {
      return {
        status: Mo,
        id: -1,
        // lazily assigned later
        index: f,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: R,
        boundary: w,
        lastPushedText: $,
        textEmbedded: ne
      };
    }
    var Lr = null;
    function Kl() {
      return Lr === null || Lr.componentStack === null ? "" : Wl(Lr.componentStack);
    }
    function gr(l, f) {
      l.componentStack = {
        tag: 0,
        parent: l.componentStack,
        type: f
      };
    }
    function Ba(l, f) {
      l.componentStack = {
        tag: 1,
        parent: l.componentStack,
        type: f
      };
    }
    function Yl(l, f) {
      l.componentStack = {
        tag: 2,
        parent: l.componentStack,
        type: f
      };
    }
    function vr(l) {
      l.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : l.componentStack = l.componentStack.parent;
    }
    var Xr = null;
    function Xl(l, f) {
      {
        var w;
        typeof f == "string" ? w = f : f && typeof f.message == "string" ? w = f.message : w = String(f);
        var R = Xr || Kl();
        Xr = null, l.errorMessage = w, l.errorComponentStack = R;
      }
    }
    function Ei(l, f) {
      var w = l.onError(f);
      if (w != null && typeof w != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof w + '" instead');
      return w;
    }
    function Bo(l, f) {
      var w = l.onShellError;
      w(f);
      var R = l.onFatalError;
      R(f), l.destination !== null ? (l.status = Ar, k(l.destination, f)) : (l.status = uu, l.fatalError = f);
    }
    function cu(l, f, w) {
      gr(f, "Suspense");
      var R = f.blockedBoundary, $ = f.blockedSegment, ne = w.fallback, de = w.children, Ce = /* @__PURE__ */ new Set(), We = Mr(l, Ce), ct = $.chunks.length, ht = Yr(
        l,
        ct,
        We,
        $.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      $.children.push(ht), $.lastPushedText = !1;
      var Lt = Yr(
        l,
        0,
        null,
        $.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      Lt.parentFlushed = !0, f.blockedBoundary = We, f.blockedSegment = Lt;
      try {
        if ($o(l, f, de), Bs(Lt.chunks, l.responseState, Lt.lastPushedText, Lt.textEmbedded), Lt.status = pa, wi(We, Lt), We.pendingTasks === 0) {
          vr(f);
          return;
        }
      } catch (Hn) {
        Lt.status = ha, We.forceClientRender = !0, We.errorDigest = Ei(l, Hn), Xl(We, Hn);
      } finally {
        f.blockedBoundary = R, f.blockedSegment = $;
      }
      var bn = bi(l, ne, R, ht, Ce, f.legacyContext, f.context, f.treeContext);
      bn.componentStack = f.componentStack, l.pingedTasks.push(bn), vr(f);
    }
    function du(l, f, w, R) {
      gr(f, w);
      var $ = f.blockedSegment, ne = kr($.chunks, w, R, l.responseState, $.formatContext);
      $.lastPushedText = !1;
      var de = $.formatContext;
      $.formatContext = Sn(de, w, R), $o(l, f, ne), $.formatContext = de, lr($.chunks, w), $.lastPushedText = !1, vr(f);
    }
    function Cd(l) {
      return l.prototype && l.prototype.isReactComponent;
    }
    function ql(l, f, w, R, $) {
      var ne = {};
      Hl(f, ne);
      var de = w(R, $);
      return pd(w, R, de, $);
    }
    function Si(l, f, w, R, $) {
      var ne = w.render();
      w.props !== $ && (Jl || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", kn(R) || "a component"), Jl = !0);
      {
        var de = R.childContextTypes;
        if (de != null) {
          var Ce = f.legacyContext, We = oa(w, R, Ce, de);
          f.legacyContext = We, fr(l, f, ne), f.legacyContext = Ce;
          return;
        }
      }
      fr(l, f, ne);
    }
    function fu(l, f, w, R) {
      Yl(f, w);
      var $ = Xs(w, f.legacyContext), ne = ad(w, R, $);
      Co(ne, w, R, $), Si(l, f, ne, w, R), vr(f);
    }
    var Gl = {}, ki = {}, Zl = {}, Ql = {}, Jl = !1, pu = !1, hu = !1, es = !1;
    function Ad(l, f, w, R) {
      var $;
      if ($ = Xs(w, f.legacyContext), Ba(f, w), w.prototype && typeof w.prototype.render == "function") {
        var ne = kn(w) || "Unknown";
        Gl[ne] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", ne, ne), Gl[ne] = !0);
      }
      var de = ql(l, f, w, R, $), Ce = nu();
      if (typeof de == "object" && de !== null && typeof de.render == "function" && de.$$typeof === void 0) {
        var We = kn(w) || "Unknown";
        ki[We] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", We, We, We), ki[We] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof de == "object" && de !== null && typeof de.render == "function" && de.$$typeof === void 0
      ) {
        {
          var ct = kn(w) || "Unknown";
          ki[ct] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ct, ct, ct), ki[ct] = !0);
        }
        Co(de, w, R, $), Si(l, f, de, w, R);
      } else if (Ld(w), Ce) {
        var ht = f.treeContext, Lt = 1, bn = 0;
        f.treeContext = $l(ht, Lt, bn);
        try {
          fr(l, f, de);
        } finally {
          f.treeContext = ht;
        }
      } else
        fr(l, f, de);
      vr(f);
    }
    function Ld(l) {
      {
        if (l && l.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), typeof l.getDerivedStateFromProps == "function") {
          var f = kn(l) || "Unknown";
          Ql[f] || (i("%s: Function components do not support getDerivedStateFromProps.", f), Ql[f] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var w = kn(l) || "Unknown";
          Zl[w] || (i("%s: Function components do not support contextType.", w), Zl[w] = !0);
        }
      }
    }
    function mu(l, f) {
      if (l && l.defaultProps) {
        var w = cr({}, f), R = l.defaultProps;
        for (var $ in R)
          w[$] === void 0 && (w[$] = R[$]);
        return w;
      }
      return f;
    }
    function Pd(l, f, w, R, $) {
      Ba(f, w.render);
      var ne = ql(l, f, w.render, R, $), de = nu();
      if (de) {
        var Ce = f.treeContext, We = 1, ct = 0;
        f.treeContext = $l(Ce, We, ct);
        try {
          fr(l, f, ne);
        } finally {
          f.treeContext = Ce;
        }
      } else
        fr(l, f, ne);
      vr(f);
    }
    function Nd(l, f, w, R, $) {
      var ne = w.type, de = mu(ne, R);
      ns(l, f, ne, de, $);
    }
    function ts(l, f, w, R) {
      w._context === void 0 ? w !== w.Consumer && (es || (es = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : w = w._context;
      var $ = R.children;
      typeof $ != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var ne = Fa(w), de = $(ne);
      fr(l, f, de);
    }
    function Rd(l, f, w, R) {
      var $ = w._context, ne = R.value, de = R.children, Ce;
      Ce = f.context, f.context = pi($, ne), fr(l, f, de), f.context = zl($), Ce !== f.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function dr(l, f, w, R, $) {
      gr(f, "Lazy");
      var ne = w._payload, de = w._init, Ce = de(ne), We = mu(Ce, R);
      ns(l, f, Ce, We, $), vr(f);
    }
    function ns(l, f, w, R, $) {
      if (typeof w == "function")
        if (Cd(w)) {
          fu(l, f, w, R);
          return;
        } else {
          Ad(l, f, w, R);
          return;
        }
      if (typeof w == "string") {
        du(l, f, w, R);
        return;
      }
      switch (w) {
        case ed:
        case Hs:
        case so:
        case uo:
        case lo: {
          fr(l, f, R.children);
          return;
        }
        case bl: {
          gr(f, "SuspenseList"), fr(l, f, R.children), vr(f);
          return;
        }
        case Jc:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Ra: {
          cu(l, f, R);
          return;
        }
      }
      if (typeof w == "object" && w !== null)
        switch (w.$$typeof) {
          case ii: {
            Pd(l, f, w, R, $);
            return;
          }
          case El: {
            Nd(l, f, w, R, $);
            return;
          }
          case ri: {
            Rd(l, f, w, R);
            return;
          }
          case ai: {
            ts(l, f, w, R);
            return;
          }
          case co: {
            dr(l, f, w, R);
            return;
          }
        }
      var ne = "";
      throw (w === void 0 || typeof w == "object" && w !== null && Object.keys(w).length === 0) && (ne += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (w == null ? w : typeof w) + "." + ne));
    }
    function yu(l, f) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      l[Symbol.toStringTag] === "Generator" && (pu || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), pu = !0), l.entries === f && (hu || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), hu = !0);
    }
    function fr(l, f, w) {
      try {
        return rs(l, f, w);
      } catch (R) {
        throw typeof R == "object" && R !== null && typeof R.then == "function" || (Xr = Xr !== null ? Xr : Kl()), R;
      }
    }
    function rs(l, f, w) {
      if (f.node = w, typeof w == "object" && w !== null) {
        switch (w.$$typeof) {
          case Is: {
            var R = w, $ = R.type, ne = R.props, de = R.ref;
            ns(l, f, $, ne, de);
            return;
          }
          case xl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case co: {
            var Ce = w, We = Ce._payload, ct = Ce._init, ht;
            try {
              ht = ct(We);
            } catch (jo) {
              throw typeof jo == "object" && jo !== null && typeof jo.then == "function" && gr(f, "Lazy"), jo;
            }
            fr(l, f, ht);
            return;
          }
        }
        if (Ht(w)) {
          gu(l, f, w);
          return;
        }
        var Lt = wn(w);
        if (Lt) {
          yu(w, Lt);
          var bn = Lt.call(w);
          if (bn) {
            var Hn = bn.next();
            if (!Hn.done) {
              var xr = [];
              do
                xr.push(Hn.value), Hn = bn.next();
              while (!Hn.done);
              gu(l, f, xr);
              return;
            }
            return;
          }
        }
        var Su = Object.prototype.toString.call(w);
        throw new Error("Objects are not valid as a React child (found: " + (Su === "[object Object]" ? "object with keys {" + Object.keys(w).join(", ") + "}" : Su) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof w == "string") {
        var ku = f.blockedSegment;
        ku.lastPushedText = zs(f.blockedSegment.chunks, w, l.responseState, ku.lastPushedText);
        return;
      }
      if (typeof w == "number") {
        var wu = f.blockedSegment;
        wu.lastPushedText = zs(f.blockedSegment.chunks, "" + w, l.responseState, wu.lastPushedText);
        return;
      }
      typeof w == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function gu(l, f, w) {
      for (var R = w.length, $ = 0; $ < R; $++) {
        var ne = f.treeContext;
        f.treeContext = $l(ne, R, $);
        try {
          $o(l, f, w[$]);
        } finally {
          f.treeContext = ne;
        }
      }
    }
    function Dd(l, f, w) {
      var R = f.blockedSegment, $ = R.chunks.length, ne = Yr(
        l,
        $,
        null,
        R.formatContext,
        // Adopt the parent segment's leading text embed
        R.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      R.children.push(ne), R.lastPushedText = !1;
      var de = bi(l, f.node, f.blockedBoundary, ne, f.abortSet, f.legacyContext, f.context, f.treeContext);
      f.componentStack !== null && (de.componentStack = f.componentStack.parent);
      var Ce = de.ping;
      w.then(Ce, Ce);
    }
    function $o(l, f, w) {
      var R = f.blockedSegment.formatContext, $ = f.legacyContext, ne = f.context, de = null;
      de = f.componentStack;
      try {
        return fr(l, f, w);
      } catch (Ce) {
        if (yi(), typeof Ce == "object" && Ce !== null && typeof Ce.then == "function") {
          Dd(l, f, Ce), f.blockedSegment.formatContext = R, f.legacyContext = $, f.context = ne, go(ne), f.componentStack = de;
          return;
        } else
          throw f.blockedSegment.formatContext = R, f.legacyContext = $, f.context = ne, go(ne), f.componentStack = de, Ce;
      }
    }
    function Io(l, f, w, R) {
      var $ = Ei(l, R);
      if (f === null ? Bo(l, R) : (f.pendingTasks--, f.forceClientRender || (f.forceClientRender = !0, f.errorDigest = $, Xl(f, R), f.parentFlushed && l.clientRenderedBoundaries.push(f))), l.allPendingTasks--, l.allPendingTasks === 0) {
        var ne = l.onAllReady;
        ne();
      }
    }
    function vu(l) {
      var f = this, w = l.blockedBoundary, R = l.blockedSegment;
      R.status = jl, Ti(f, w, R);
    }
    function xu(l, f, w) {
      var R = l.blockedBoundary, $ = l.blockedSegment;
      if ($.status = jl, R === null)
        f.allPendingTasks--, f.status !== Ar && (f.status = Ar, f.destination !== null && v(f.destination));
      else {
        if (R.pendingTasks--, !R.forceClientRender) {
          R.forceClientRender = !0;
          var ne = w === void 0 ? new Error("The render was aborted by the server without a reason.") : w;
          R.errorDigest = f.onError(ne);
          {
            var de = "The server did not finish this Suspense boundary: ";
            ne && typeof ne.message == "string" ? ne = de + ne.message : ne = de + String(ne);
            var Ce = Lr;
            Lr = l;
            try {
              Xl(R, ne);
            } finally {
              Lr = Ce;
            }
          }
          R.parentFlushed && f.clientRenderedBoundaries.push(R);
        }
        if (R.fallbackAbortableTasks.forEach(function(ct) {
          return xu(ct, f, w);
        }), R.fallbackAbortableTasks.clear(), f.allPendingTasks--, f.allPendingTasks === 0) {
          var We = f.onAllReady;
          We();
        }
      }
    }
    function wi(l, f) {
      if (f.chunks.length === 0 && f.children.length === 1 && f.children[0].boundary === null) {
        var w = f.children[0];
        w.id = f.id, w.parentFlushed = !0, w.status === pa && wi(l, w);
      } else {
        var R = l.completedSegments;
        R.push(f);
      }
    }
    function Ti(l, f, w) {
      if (f === null) {
        if (w.parentFlushed) {
          if (l.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          l.completedRootSegment = w;
        }
        if (l.pendingRootTasks--, l.pendingRootTasks === 0) {
          l.onShellError = xi;
          var R = l.onShellReady;
          R();
        }
      } else if (f.pendingTasks--, !f.forceClientRender) {
        if (f.pendingTasks === 0)
          w.parentFlushed && w.status === pa && wi(f, w), f.parentFlushed && l.completedBoundaries.push(f), f.fallbackAbortableTasks.forEach(vu, l), f.fallbackAbortableTasks.clear();
        else if (w.parentFlushed && w.status === pa) {
          wi(f, w);
          var $ = f.completedSegments;
          $.length === 1 && f.parentFlushed && l.partialBoundaries.push(f);
        }
      }
      if (l.allPendingTasks--, l.allPendingTasks === 0) {
        var ne = l.onAllReady;
        ne();
      }
    }
    function Ho(l, f) {
      var w = f.blockedSegment;
      if (w.status === Mo) {
        go(f.context);
        var R = null;
        R = Lr, Lr = f;
        try {
          fr(l, f, f.node), Bs(w.chunks, l.responseState, w.lastPushedText, w.textEmbedded), f.abortSet.delete(f), w.status = pa, Ti(l, f.blockedBoundary, w);
        } catch (ne) {
          if (yi(), typeof ne == "object" && ne !== null && typeof ne.then == "function") {
            var $ = f.ping;
            ne.then($, $);
          } else
            f.abortSet.delete(f), w.status = ha, Io(l, f.blockedBoundary, w, ne);
        } finally {
          Lr = R;
        }
      }
    }
    function bu(l) {
      if (l.status !== Ar) {
        var f = nd(), w = Kr.current;
        Kr.current = lu;
        var R;
        R = Fo.getCurrentStack, Fo.getCurrentStack = Kl;
        var $ = vi;
        Oo(l.responseState);
        try {
          var ne = l.pingedTasks, de;
          for (de = 0; de < ne.length; de++) {
            var Ce = ne[de];
            Ho(l, Ce);
          }
          ne.splice(0, de), l.destination !== null && Wo(l, l.destination);
        } catch (We) {
          Ei(l, We), Bo(l, We);
        } finally {
          Oo($), Kr.current = w, Fo.getCurrentStack = R, w === lu && go(f);
        }
      }
    }
    function Ci(l, f, w) {
      switch (w.parentFlushed = !0, w.status) {
        case Mo: {
          var R = w.id = l.nextSegmentId++;
          return w.lastPushedText = !1, w.textEmbedded = !1, Xi(f, l.responseState, R);
        }
        case pa: {
          w.status = su;
          for (var $ = !0, ne = w.chunks, de = 0, Ce = w.children, We = 0; We < Ce.length; We++) {
            for (var ct = Ce[We]; de < ct.index; de++)
              s(f, ne[de]);
            $ = Ai(l, f, ct);
          }
          for (; de < ne.length - 1; de++)
            s(f, ne[de]);
          return de < ne.length && ($ = p(f, ne[de])), $;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ai(l, f, w) {
      var R = w.boundary;
      if (R === null)
        return Ci(l, f, w);
      if (R.parentFlushed = !0, R.forceClientRender)
        return mr(f, l.responseState, R.errorDigest, R.errorMessage, R.errorComponentStack), Ci(l, f, w), $s(f, l.responseState);
      if (R.pendingTasks > 0) {
        R.rootSegmentID = l.nextSegmentId++, R.completedSegments.length > 0 && l.partialBoundaries.push(R);
        var $ = R.id = Ee(l.responseState);
        return jr(f, l.responseState, $), Ci(l, f, w), ei(f, l.responseState);
      } else {
        if (R.byteSize > l.progressiveChunkSize)
          return R.rootSegmentID = l.nextSegmentId++, l.completedBoundaries.push(R), jr(f, l.responseState, R.id), Ci(l, f, w), ei(f, l.responseState);
        vl(f, l.responseState);
        var ne = R.completedSegments;
        if (ne.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var de = ne[0];
        return Ai(l, f, de), Qc(f, l.responseState);
      }
    }
    function _d(l, f, w) {
      return qc(f, l.responseState, w.id, w.errorDigest, w.errorMessage, w.errorComponentStack);
    }
    function as(l, f, w) {
      return Se(f, l.responseState, w.formatContext, w.id), Ai(l, f, w), Ie(f, w.formatContext);
    }
    function Vo(l, f, w) {
      for (var R = w.completedSegments, $ = 0; $ < R.length; $++) {
        var ne = R[$];
        Eu(l, f, w, ne);
      }
      return R.length = 0, jc(f, l.responseState, w.id, w.rootSegmentID);
    }
    function Od(l, f, w) {
      for (var R = w.completedSegments, $ = 0; $ < R.length; $++) {
        var ne = R[$];
        if (!Eu(l, f, w, ne))
          return $++, R.splice(0, $), !1;
      }
      return R.splice(0, $), !0;
    }
    function Eu(l, f, w, R) {
      if (R.status === su)
        return !0;
      var $ = R.id;
      if ($ === -1) {
        var ne = R.id = w.rootSegmentID;
        if (ne === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return as(l, f, R);
      } else
        return as(l, f, R), ur(f, l.responseState, $);
    }
    function Wo(l, f) {
      try {
        var w = l.completedRootSegment;
        w !== null && l.pendingRootTasks === 0 && (Ai(l, f, w), l.completedRootSegment = null, Ga(f, l.responseState));
        var R = l.clientRenderedBoundaries, $;
        for ($ = 0; $ < R.length; $++) {
          var ne = R[$];
          if (!_d(l, f, ne)) {
            l.destination = null, $++, R.splice(0, $);
            return;
          }
        }
        R.splice(0, $);
        var de = l.completedBoundaries;
        for ($ = 0; $ < de.length; $++) {
          var Ce = de[$];
          if (!Vo(l, f, Ce)) {
            l.destination = null, $++, de.splice(0, $);
            return;
          }
        }
        de.splice(0, $);
        var We = l.partialBoundaries;
        for ($ = 0; $ < We.length; $++) {
          var ct = We[$];
          if (!Od(l, f, ct)) {
            l.destination = null, $++, We.splice(0, $);
            return;
          }
        }
        We.splice(0, $);
        var ht = l.completedBoundaries;
        for ($ = 0; $ < ht.length; $++) {
          var Lt = ht[$];
          if (!Vo(l, f, Lt)) {
            l.destination = null, $++, ht.splice(0, $);
            return;
          }
        }
        ht.splice(0, $);
      } finally {
        l.allPendingTasks === 0 && l.pingedTasks.length === 0 && l.clientRenderedBoundaries.length === 0 && l.completedBoundaries.length === 0 && (l.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), v(f));
      }
    }
    function Fd(l) {
      d(function() {
        return bu(l);
      });
    }
    function u(l, f) {
      if (l.status === uu) {
        l.status = Ar, k(f, l.fatalError);
        return;
      }
      if (l.status !== Ar && l.destination === null) {
        l.destination = f;
        try {
          Wo(l, f);
        } catch (w) {
          Ei(l, w), Bo(l, w);
        }
      }
    }
    function h(l, f) {
      try {
        var w = l.abortableTasks;
        w.forEach(function(R) {
          return xu(R, l, f);
        }), w.clear(), l.destination !== null && Wo(l, l.destination);
      } catch (R) {
        Ei(l, R), Bo(l, R);
      }
    }
    function L() {
    }
    function F(l, f, w, R) {
      var $ = !1, ne = null, de = "", Ce = {
        push: function(Lt) {
          return Lt !== null && (de += Lt), !0;
        },
        destroy: function(Lt) {
          $ = !0, ne = Lt;
        }
      }, We = !1;
      function ct() {
        We = !0;
      }
      var ht = Ul(l, Zc(w, f ? f.identifierPrefix : void 0), gl(), 1 / 0, L, void 0, ct, void 0, void 0);
      if (Fd(ht), h(ht, R), u(ht, Ce), $)
        throw ne;
      if (!We)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return de;
    }
    function Y(l, f) {
      return F(l, f, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function le(l, f) {
      return F(l, f, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function he() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Le() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Oi.renderToNodeStream = he, Oi.renderToStaticMarkup = le, Oi.renderToStaticNodeStream = Le, Oi.renderToString = Y, Oi.version = t;
  }()), Oi;
}
var $u = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var em;
function fS() {
  return em || (em = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ie, t = "18.2.0", r = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(u) {
      {
        for (var h = arguments.length, L = new Array(h > 1 ? h - 1 : 0), F = 1; F < h; F++)
          L[F - 1] = arguments[F];
        o("warn", u, L);
      }
    }
    function i(u) {
      {
        for (var h = arguments.length, L = new Array(h > 1 ? h - 1 : 0), F = 1; F < h; F++)
          L[F - 1] = arguments[F];
        o("error", u, L);
      }
    }
    function o(u, h, L) {
      {
        var F = r.ReactDebugCurrentFrame, Y = F.getStackAddendum();
        Y !== "" && (h += "%s", L = L.concat([Y]));
        var le = L.map(function(he) {
          return String(he);
        });
        le.unshift("Warning: " + h), Function.prototype.apply.call(console[u], console, le);
      }
    }
    function d(u) {
      u();
    }
    var c = 512, s = null, p = 0;
    function m(u) {
      s = new Uint8Array(c), p = 0;
    }
    function v(u, h) {
      if (h.length !== 0) {
        if (h.length > c) {
          p > 0 && (u.enqueue(new Uint8Array(s.buffer, 0, p)), s = new Uint8Array(c), p = 0), u.enqueue(h);
          return;
        }
        var L = h, F = s.length - p;
        F < L.length && (F === 0 ? u.enqueue(s) : (s.set(L.subarray(0, F), p), u.enqueue(s), L = L.subarray(F)), s = new Uint8Array(c), p = 0), s.set(L, p), p += L.length;
      }
    }
    function g(u, h) {
      return v(u, h), !0;
    }
    function A(u) {
      s && p > 0 && (u.enqueue(new Uint8Array(s.buffer, 0, p)), s = null, p = 0);
    }
    function k(u) {
      u.close();
    }
    var E = new TextEncoder();
    function T(u) {
      return E.encode(u);
    }
    function b(u) {
      return E.encode(u);
    }
    function y(u, h) {
      typeof u.error == "function" ? u.error(h) : u.close();
    }
    function N(u) {
      {
        var h = typeof Symbol == "function" && Symbol.toStringTag, L = h && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return L;
      }
    }
    function C(u) {
      try {
        return P(u), !1;
      } catch {
        return !0;
      }
    }
    function P(u) {
      return "" + u;
    }
    function O(u, h) {
      if (C(u))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", h, N(u)), P(u);
    }
    function K(u, h) {
      if (C(u))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", h, N(u)), P(u);
    }
    function W(u) {
      if (C(u))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", N(u)), P(u);
    }
    var J = Object.prototype.hasOwnProperty, j = 0, B = 1, Z = 2, te = 3, V = 4, ee = 5, ce = 6, re = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", G = re + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", U = new RegExp("^[" + re + "][" + G + "]*$"), q = {}, H = {};
    function oe(u) {
      return J.call(H, u) ? !0 : J.call(q, u) ? !1 : U.test(u) ? (H[u] = !0, !0) : (q[u] = !0, i("Invalid attribute name: `%s`", u), !1);
    }
    function ue(u, h, L, F) {
      if (L !== null && L.type === j)
        return !1;
      switch (typeof h) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (F)
            return !1;
          if (L !== null)
            return !L.acceptsBooleans;
          var Y = u.toLowerCase().slice(0, 5);
          return Y !== "data-" && Y !== "aria-";
        }
        default:
          return !1;
      }
    }
    function ke(u) {
      return pe.hasOwnProperty(u) ? pe[u] : null;
    }
    function De(u, h, L, F, Y, le, he) {
      this.acceptsBooleans = h === Z || h === te || h === V, this.attributeName = F, this.attributeNamespace = Y, this.mustUseProperty = L, this.propertyName = u, this.type = h, this.sanitizeURL = le, this.removeEmptyString = he;
    }
    var pe = {}, Be = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Be.forEach(function(u) {
      pe[u] = new De(
        u,
        j,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(u) {
      var h = u[0], L = u[1];
      pe[h] = new De(
        h,
        B,
        !1,
        // mustUseProperty
        L,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(u) {
      pe[u] = new De(
        u,
        Z,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(u) {
      pe[u] = new De(
        u,
        Z,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(u) {
      pe[u] = new De(
        u,
        te,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      pe[u] = new De(
        u,
        te,
        !0,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      pe[u] = new De(
        u,
        V,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      pe[u] = new De(
        u,
        ce,
        !1,
        // mustUseProperty
        u,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(u) {
      pe[u] = new De(
        u,
        ee,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var qe = /[\-\:]([a-z])/g, Pe = function(u) {
      return u[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(qe, Pe);
      pe[h] = new De(
        h,
        B,
        !1,
        // mustUseProperty
        u,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(qe, Pe);
      pe[h] = new De(
        h,
        B,
        !1,
        // mustUseProperty
        u,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(u) {
      var h = u.replace(qe, Pe);
      pe[h] = new De(
        h,
        B,
        !1,
        // mustUseProperty
        u,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(u) {
      pe[u] = new De(
        u,
        B,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ve = "xlinkHref";
    pe[ve] = new De(
      "xlinkHref",
      B,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(u) {
      pe[u] = new De(
        u,
        B,
        !1,
        // mustUseProperty
        u.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var $e = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function z(u, h) {
      return u + h.charAt(0).toUpperCase() + h.substring(1);
    }
    var Re = ["Webkit", "ms", "Moz", "O"];
    Object.keys($e).forEach(function(u) {
      Re.forEach(function(h) {
        $e[z(h, u)] = $e[u];
      });
    });
    var be = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function He(u, h) {
      be[h.type] || h.onChange || h.onInput || h.readOnly || h.disabled || h.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), h.onChange || h.readOnly || h.disabled || h.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ve(u, h) {
      if (u.indexOf("-") === -1)
        return typeof h.is == "string";
      switch (u) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Oe = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ge = {}, Xe = new RegExp("^(aria)-[" + G + "]*$"), rt = new RegExp("^(aria)[A-Z][" + G + "]*$");
    function Ue(u, h) {
      {
        if (J.call(Ge, h) && Ge[h])
          return !0;
        if (rt.test(h)) {
          var L = "aria-" + h.slice(4).toLowerCase(), F = Oe.hasOwnProperty(L) ? L : null;
          if (F == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", h), Ge[h] = !0, !0;
          if (h !== F)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", h, F), Ge[h] = !0, !0;
        }
        if (Xe.test(h)) {
          var Y = h.toLowerCase(), le = Oe.hasOwnProperty(Y) ? Y : null;
          if (le == null)
            return Ge[h] = !0, !1;
          if (h !== le)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", h, le), Ge[h] = !0, !0;
        }
      }
      return !0;
    }
    function ze(u, h) {
      {
        var L = [];
        for (var F in h) {
          var Y = Ue(u, F);
          Y || L.push(F);
        }
        var le = L.map(function(he) {
          return "`" + he + "`";
        }).join(", ");
        L.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", le, u) : L.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", le, u);
      }
    }
    function Ne(u, h) {
      Ve(u, h) || ze(u, h);
    }
    var ot = !1;
    function nt(u, h) {
      {
        if (u !== "input" && u !== "textarea" && u !== "select")
          return;
        h != null && h.value === null && !ot && (ot = !0, u === "select" && h.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", u) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", u));
      }
    }
    var mt = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, wt = function() {
    };
    {
      var xt = {}, Pt = /^on./, ln = /^on[^A-Z]/, Gt = new RegExp("^(aria)-[" + G + "]*$"), Ut = new RegExp("^(aria)[A-Z][" + G + "]*$");
      wt = function(u, h, L, F) {
        if (J.call(xt, h) && xt[h])
          return !0;
        var Y = h.toLowerCase();
        if (Y === "onfocusin" || Y === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), xt[h] = !0, !0;
        if (F != null) {
          var le = F.registrationNameDependencies, he = F.possibleRegistrationNames;
          if (le.hasOwnProperty(h))
            return !0;
          var Le = he.hasOwnProperty(Y) ? he[Y] : null;
          if (Le != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", h, Le), xt[h] = !0, !0;
          if (Pt.test(h))
            return i("Unknown event handler property `%s`. It will be ignored.", h), xt[h] = !0, !0;
        } else if (Pt.test(h))
          return ln.test(h) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", h), xt[h] = !0, !0;
        if (Gt.test(h) || Ut.test(h))
          return !0;
        if (Y === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), xt[h] = !0, !0;
        if (Y === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), xt[h] = !0, !0;
        if (Y === "is" && L !== null && L !== void 0 && typeof L != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof L), xt[h] = !0, !0;
        if (typeof L == "number" && isNaN(L))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", h), xt[h] = !0, !0;
        var l = ke(h), f = l !== null && l.type === j;
        if (mt.hasOwnProperty(Y)) {
          var w = mt[Y];
          if (w !== h)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", h, w), xt[h] = !0, !0;
        } else if (!f && h !== Y)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", h, Y), xt[h] = !0, !0;
        return typeof L == "boolean" && ue(h, L, l, !1) ? (L ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', L, h, h, L, h) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', L, h, h, L, h, h, h), xt[h] = !0, !0) : f ? !0 : ue(h, L, l, !1) ? (xt[h] = !0, !1) : ((L === "false" || L === "true") && l !== null && l.type === te && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", L, h, L === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', h, L), xt[h] = !0), !0);
      };
    }
    var yt = function(u, h, L) {
      {
        var F = [];
        for (var Y in h) {
          var le = wt(u, Y, h[Y], L);
          le || F.push(Y);
        }
        var he = F.map(function(Le) {
          return "`" + Le + "`";
        }).join(", ");
        F.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, u) : F.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, u);
      }
    };
    function Tt(u, h, L) {
      Ve(u, h) || yt(u, h, L);
    }
    var Dt = function() {
    };
    {
      var nn = /^(?:webkit|moz|o)[A-Z]/, yn = /^-ms-/, Nt = /-(.)/g, un = /;\s*$/, Kt = {}, Fe = {}, bt = !1, xn = !1, Ot = function(u) {
        return u.replace(Nt, function(h, L) {
          return L.toUpperCase();
        });
      }, Ln = function(u) {
        Kt.hasOwnProperty(u) && Kt[u] || (Kt[u] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          u,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Ot(u.replace(yn, "ms-"))
        ));
      }, An = function(u) {
        Kt.hasOwnProperty(u) && Kt[u] || (Kt[u] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", u, u.charAt(0).toUpperCase() + u.slice(1)));
      }, $t = function(u, h) {
        Fe.hasOwnProperty(h) && Fe[h] || (Fe[h] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, u, h.replace(un, "")));
      }, It = function(u, h) {
        bt || (bt = !0, i("`NaN` is an invalid value for the `%s` css style property.", u));
      }, rn = function(u, h) {
        xn || (xn = !0, i("`Infinity` is an invalid value for the `%s` css style property.", u));
      };
      Dt = function(u, h) {
        u.indexOf("-") > -1 ? Ln(u) : nn.test(u) ? An(u) : un.test(h) && $t(u, h), typeof h == "number" && (isNaN(h) ? It(u, h) : isFinite(h) || rn(u, h));
      };
    }
    var fn = Dt, On = /["'&<>]/;
    function Wn(u) {
      W(u);
      var h = "" + u, L = On.exec(h);
      if (!L)
        return h;
      var F, Y = "", le, he = 0;
      for (le = L.index; le < h.length; le++) {
        switch (h.charCodeAt(le)) {
          case 34:
            F = "&quot;";
            break;
          case 38:
            F = "&amp;";
            break;
          case 39:
            F = "&#x27;";
            break;
          case 60:
            F = "&lt;";
            break;
          case 62:
            F = "&gt;";
            break;
          default:
            continue;
        }
        he !== le && (Y += h.substring(he, le)), he = le + 1, Y += F;
      }
      return he !== le ? Y + h.substring(he, le) : Y;
    }
    function on(u) {
      return typeof u == "boolean" || typeof u == "number" ? "" + u : Wn(u);
    }
    var er = /([A-Z])/g, or = /^ms-/;
    function Xn(u) {
      return u.replace(er, "-$1").toLowerCase().replace(or, "-ms-");
    }
    var Ht = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, gn = !1;
    function Tn(u) {
      !gn && Ht.test(u) && (gn = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(u)));
    }
    var qn = Array.isArray;
    function jn(u) {
      return qn(u);
    }
    var $n = b("<script>"), Te = b("<\/script>"), _e = b('<script src="'), se = b('<script type="module" src="'), it = b('" async=""><\/script>');
    function ft(u) {
      return W(u), ("" + u).replace(dt, Ct);
    }
    var dt = /(<\/|<)(s)(cript)/gi, Ct = function(u, h, L, F) {
      return "" + h + (L === "s" ? "\\u0073" : "\\u0053") + F;
    };
    function Yt(u, h, L, F, Y) {
      var le = u === void 0 ? "" : u, he = h === void 0 ? $n : b('<script nonce="' + on(h) + '">'), Le = [];
      if (L !== void 0 && Le.push(he, T(ft(L)), Te), F !== void 0)
        for (var l = 0; l < F.length; l++)
          Le.push(_e, T(on(F[l])), it);
      if (Y !== void 0)
        for (var f = 0; f < Y.length; f++)
          Le.push(se, T(on(Y[f])), it);
      return {
        bootstrapChunks: Le,
        startInlineScript: he,
        placeholderPrefix: b(le + "P:"),
        segmentPrefix: b(le + "S:"),
        boundaryPrefix: le + "B:",
        idPrefix: le,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var Zt = 0, at = 1, tn = 2, cn = 3, qt = 4, Sn = 5, Wt = 6, Ee = 7;
    function et(u, h) {
      return {
        insertionMode: u,
        selectedValue: h
      };
    }
    function Ze(u) {
      var h = u === "http://www.w3.org/2000/svg" ? tn : u === "http://www.w3.org/1998/Math/MathML" ? cn : Zt;
      return et(h, null);
    }
    function Ke(u, h, L) {
      switch (h) {
        case "select":
          return et(at, L.value != null ? L.value : L.defaultValue);
        case "svg":
          return et(tn, null);
        case "math":
          return et(cn, null);
        case "foreignObject":
          return et(at, null);
        case "table":
          return et(qt, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return et(Sn, null);
        case "colgroup":
          return et(Ee, null);
        case "tr":
          return et(Wt, null);
      }
      return u.insertionMode >= qt || u.insertionMode === Zt ? et(at, null) : u;
    }
    var Vt = null;
    function At(u) {
      var h = u.nextSuspenseID++;
      return b(u.boundaryPrefix + h.toString(16));
    }
    function Xt(u, h, L) {
      var F = u.idPrefix, Y = ":" + F + "R" + h;
      return L > 0 && (Y += "H" + L.toString(32)), Y + ":";
    }
    function Rt(u) {
      return on(u);
    }
    var Qt = b("<!-- -->");
    function pn(u, h, L, F) {
      return h === "" ? F : (F && u.push(Qt), u.push(T(Rt(h))), !0);
    }
    function _t(u, h, L, F) {
      L && F && u.push(Qt);
    }
    var x = /* @__PURE__ */ new Map();
    function D(u) {
      var h = x.get(u);
      if (h !== void 0)
        return h;
      var L = b(on(Xn(u)));
      return x.set(u, L), L;
    }
    var M = b(' style="'), X = b(":"), me = b(";");
    function ge(u, h, L) {
      if (typeof L != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var F = !0;
      for (var Y in L)
        if (J.call(L, Y)) {
          var le = L[Y];
          if (!(le == null || typeof le == "boolean" || le === "")) {
            var he = void 0, Le = void 0, l = Y.indexOf("--") === 0;
            l ? (he = T(on(Y)), K(le, Y), Le = T(on(("" + le).trim()))) : (fn(Y, le), he = D(Y), typeof le == "number" ? le !== 0 && !J.call($e, Y) ? Le = T(le + "px") : Le = T("" + le) : (K(le, Y), Le = T(on(("" + le).trim())))), F ? (F = !1, u.push(M, he, X, Le)) : u.push(me, he, X, Le);
          }
        }
      F || u.push(ut);
    }
    var Ae = b(" "), Ye = b('="'), ut = b('"'), gt = b('=""');
    function pt(u, h, L, F) {
      switch (L) {
        case "style": {
          ge(u, h, F);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(L.length > 2 && (L[0] === "o" || L[0] === "O") && (L[1] === "n" || L[1] === "N"))
      ) {
        var Y = ke(L);
        if (Y !== null) {
          switch (typeof F) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!Y.acceptsBooleans)
                return;
          }
          var le = Y.attributeName, he = T(le);
          switch (Y.type) {
            case te:
              F && u.push(Ae, he, gt);
              return;
            case V:
              F === !0 ? u.push(Ae, he, gt) : F === !1 || u.push(Ae, he, Ye, T(on(F)), ut);
              return;
            case ee:
              isNaN(F) || u.push(Ae, he, Ye, T(on(F)), ut);
              break;
            case ce:
              !isNaN(F) && F >= 1 && u.push(Ae, he, Ye, T(on(F)), ut);
              break;
            default:
              Y.sanitizeURL && (O(F, le), F = "" + F, Tn(F)), u.push(Ae, he, Ye, T(on(F)), ut);
          }
        } else if (oe(L)) {
          switch (typeof F) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Le = L.toLowerCase().slice(0, 5);
              if (Le !== "data-" && Le !== "aria-")
                return;
            }
          }
          u.push(Ae, T(L), Ye, T(on(F)), ut);
        }
      }
    }
    var Mt = b(">"), Pn = b("/>");
    function Nn(u, h, L) {
      if (h != null) {
        if (L != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof h != "object" || !("__html" in h))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var F = h.__html;
        F != null && (W(F), u.push(T("" + F)));
      }
    }
    var Rn = !1, tr = !1, Un = !1, ye = !1, fe = !1, xe = !1, Me = !1;
    function zt(u, h) {
      {
        var L = u[h];
        if (L != null) {
          var F = jn(L);
          u.multiple && !F ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", h) : !u.multiple && F && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", h);
        }
      }
    }
    function Gn(u, h, L) {
      He("select", h), zt(h, "value"), zt(h, "defaultValue"), h.value !== void 0 && h.defaultValue !== void 0 && !Un && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Un = !0), u.push(lr("select"));
      var F = null, Y = null;
      for (var le in h)
        if (J.call(h, le)) {
          var he = h[le];
          if (he == null)
            continue;
          switch (le) {
            case "children":
              F = he;
              break;
            case "dangerouslySetInnerHTML":
              Y = he;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              pt(u, L, le, he);
              break;
          }
        }
      return u.push(Mt), Nn(u, Y, F), F;
    }
    function Er(u) {
      var h = "";
      return e.Children.forEach(u, function(L) {
        L != null && (h += L, !fe && typeof L != "string" && typeof L != "number" && (fe = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), h;
    }
    var Vr = b(' selected=""');
    function Rr(u, h, L, F) {
      var Y = F.selectedValue;
      u.push(lr("option"));
      var le = null, he = null, Le = null, l = null;
      for (var f in h)
        if (J.call(h, f)) {
          var w = h[f];
          if (w == null)
            continue;
          switch (f) {
            case "children":
              le = w;
              break;
            case "selected":
              Le = w, Me || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Me = !0);
              break;
            case "dangerouslySetInnerHTML":
              l = w;
              break;
            case "value":
              he = w;
            default:
              pt(u, L, f, w);
              break;
          }
        }
      if (Y != null) {
        var R;
        if (he !== null ? (O(he, "value"), R = "" + he) : (l !== null && (xe || (xe = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), R = Er(le)), jn(Y))
          for (var $ = 0; $ < Y.length; $++) {
            O(Y[$], "value");
            var ne = "" + Y[$];
            if (ne === R) {
              u.push(Vr);
              break;
            }
          }
        else
          O(Y, "select.value"), "" + Y === R && u.push(Vr);
      } else
        Le && u.push(Vr);
      return u.push(Mt), Nn(u, l, le), le;
    }
    function qa(u, h, L) {
      He("input", h), h.checked !== void 0 && h.defaultChecked !== void 0 && !tr && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), tr = !0), h.value !== void 0 && h.defaultValue !== void 0 && !Rn && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), Rn = !0), u.push(lr("input"));
      var F = null, Y = null, le = null, he = null;
      for (var Le in h)
        if (J.call(h, Le)) {
          var l = h[Le];
          if (l == null)
            continue;
          switch (Le) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              he = l;
              break;
            case "defaultValue":
              Y = l;
              break;
            case "checked":
              le = l;
              break;
            case "value":
              F = l;
              break;
            default:
              pt(u, L, Le, l);
              break;
          }
        }
      return le !== null ? pt(u, L, "checked", le) : he !== null && pt(u, L, "checked", he), F !== null ? pt(u, L, "value", F) : Y !== null && pt(u, L, "value", Y), u.push(Pn), null;
    }
    function br(u, h, L) {
      He("textarea", h), h.value !== void 0 && h.defaultValue !== void 0 && !ye && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), ye = !0), u.push(lr("textarea"));
      var F = null, Y = null, le = null;
      for (var he in h)
        if (J.call(h, he)) {
          var Le = h[he];
          if (Le == null)
            continue;
          switch (he) {
            case "children":
              le = Le;
              break;
            case "value":
              F = Le;
              break;
            case "defaultValue":
              Y = Le;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              pt(u, L, he, Le);
              break;
          }
        }
      if (F === null && Y !== null && (F = Y), u.push(Mt), le != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), F != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (jn(le)) {
          if (le.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          W(le[0]), F = "" + le[0];
        }
        W(le), F = "" + le;
      }
      return typeof F == "string" && F[0] === `
` && u.push(Dr), F !== null && (O(F, "value"), u.push(T(Rt("" + F)))), null;
    }
    function na(u, h, L, F) {
      u.push(lr(L));
      for (var Y in h)
        if (J.call(h, Y)) {
          var le = h[Y];
          if (le == null)
            continue;
          switch (Y) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(L + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              pt(u, F, Y, le);
              break;
          }
        }
      return u.push(Pn), null;
    }
    function xa(u, h, L) {
      u.push(lr("menuitem"));
      for (var F in h)
        if (J.call(h, F)) {
          var Y = h[F];
          if (Y == null)
            continue;
          switch (F) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              pt(u, L, F, Y);
              break;
          }
        }
      return u.push(Mt), null;
    }
    function hn(u, h, L) {
      u.push(lr("title"));
      var F = null;
      for (var Y in h)
        if (J.call(h, Y)) {
          var le = h[Y];
          if (le == null)
            continue;
          switch (Y) {
            case "children":
              F = le;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              pt(u, L, Y, le);
              break;
          }
        }
      u.push(Mt);
      {
        var he = Array.isArray(F) && F.length < 2 ? F[0] || null : F;
        Array.isArray(F) && F.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && he.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && typeof he != "string" && typeof he != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return F;
    }
    function Sr(u, h, L, F) {
      u.push(lr(L));
      var Y = null, le = null;
      for (var he in h)
        if (J.call(h, he)) {
          var Le = h[he];
          if (Le == null)
            continue;
          switch (he) {
            case "children":
              Y = Le;
              break;
            case "dangerouslySetInnerHTML":
              le = Le;
              break;
            default:
              pt(u, F, he, Le);
              break;
          }
        }
      return u.push(Mt), Nn(u, le, Y), typeof Y == "string" ? (u.push(T(Rt(Y))), null) : Y;
    }
    function Zn(u, h, L, F) {
      u.push(lr(L));
      var Y = null, le = null;
      for (var he in h)
        if (J.call(h, he)) {
          var Le = h[he];
          if (Le == null)
            continue;
          switch (he) {
            case "children":
              Y = Le;
              break;
            case "dangerouslySetInnerHTML":
              le = Le;
              break;
            case "style":
              ge(u, F, Le);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              oe(he) && typeof Le != "function" && typeof Le != "symbol" && u.push(Ae, T(he), Ye, T(on(Le)), ut);
              break;
          }
        }
      return u.push(Mt), Nn(u, le, Y), Y;
    }
    var Dr = b(`
`);
    function kr(u, h, L, F) {
      u.push(lr(L));
      var Y = null, le = null;
      for (var he in h)
        if (J.call(h, he)) {
          var Le = h[he];
          if (Le == null)
            continue;
          switch (he) {
            case "children":
              Y = Le;
              break;
            case "dangerouslySetInnerHTML":
              le = Le;
              break;
            default:
              pt(u, F, he, Le);
              break;
          }
        }
      if (u.push(Mt), le != null) {
        if (Y != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof le != "object" || !("__html" in le))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var l = le.__html;
        l != null && (typeof l == "string" && l.length > 0 && l[0] === `
` ? u.push(Dr, T(l)) : (W(l), u.push(T("" + l))));
      }
      return typeof Y == "string" && Y[0] === `
` && u.push(Dr), Y;
    }
    var ba = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, wr = /* @__PURE__ */ new Map();
    function lr(u) {
      var h = wr.get(u);
      if (h === void 0) {
        if (!ba.test(u))
          throw new Error("Invalid tag: " + u);
        h = b("<" + u), wr.set(u, h);
      }
      return h;
    }
    var Ga = b("<!DOCTYPE html>");
    function Za(u, h, L, F, Y) {
      switch (Ne(h, L), nt(h, L), Tt(h, L, null), !L.suppressContentEditableWarning && L.contentEditable && L.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), Y.insertionMode !== tn && Y.insertionMode !== cn && h.indexOf("-") === -1 && typeof L.is != "string" && h.toLowerCase() !== h && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", h), h) {
        case "select":
          return Gn(u, L, F);
        case "option":
          return Rr(u, L, F, Y);
        case "textarea":
          return br(u, L, F);
        case "input":
          return qa(u, L, F);
        case "menuitem":
          return xa(u, L, F);
        case "title":
          return hn(u, L, F);
        case "listing":
        case "pre":
          return kr(u, L, h, F);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return na(u, L, h, F);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Sr(u, L, h, F);
        case "html":
          return Y.insertionMode === Zt && u.push(Ga), Sr(u, L, h, F);
        default:
          return h.indexOf("-") === -1 && typeof L.is != "string" ? Sr(u, L, h, F) : Zn(u, L, h, F);
      }
    }
    var Yi = b("</"), Xi = b(">");
    function qi(u, h, L) {
      switch (h) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          u.push(Yi, T(h), Xi);
      }
    }
    function dl(u, h) {
      for (var L = h.bootstrapChunks, F = 0; F < L.length - 1; F++)
        v(u, L[F]);
      return F < L.length ? g(u, L[F]) : !0;
    }
    var fl = b('<template id="'), Ea = b('"></template>');
    function Sa(u, h, L) {
      v(u, fl), v(u, h.placeholderPrefix);
      var F = T(L.toString(16));
      return v(u, F), g(u, Ea);
    }
    var ka = b("<!--$-->"), ra = b('<!--$?--><template id="'), pl = b('"></template>'), aa = b("<!--$!-->"), Qa = b("<!--/$-->"), Ja = b("<template"), Wr = b('"'), jr = b(' data-dgst="'), wa = b(' data-msg="'), Gi = b(' data-stck="'), ei = b("></template>");
    function Zi(u, h) {
      return g(u, ka);
    }
    function Ta(u, h, L) {
      if (v(u, ra), L === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return v(u, L), g(u, pl);
    }
    function Qn(u, h, L, F, Y) {
      var le;
      return le = g(u, aa), v(u, Ja), L && (v(u, jr), v(u, T(on(L))), v(u, Wr)), F && (v(u, wa), v(u, T(on(F))), v(u, Wr)), Y && (v(u, Gi), v(u, T(on(Y))), v(u, Wr)), le = g(u, ei), le;
    }
    function Qi(u, h) {
      return g(u, Qa);
    }
    function Ca(u, h) {
      return g(u, Qa);
    }
    function hl(u, h) {
      return g(u, Qa);
    }
    var Ji = b('<div hidden id="'), Aa = b('">'), eo = b("</div>"), to = b('<svg aria-hidden="true" style="display:none" id="'), La = b('">'), Pa = b("</svg>"), no = b('<math aria-hidden="true" style="display:none" id="'), ro = b('">'), ao = b("</math>"), ti = b('<table hidden id="'), io = b('">'), S = b("</table>"), _ = b('<table hidden><tbody id="'), I = b('">'), Q = b("</tbody></table>"), we = b('<table hidden><tr id="'), Se = b('">'), Ie = b("</tr></table>"), Je = b('<table hidden><colgroup id="'), kt = b('">'), Bt = b("</colgroup></table>");
    function Ft(u, h, L, F) {
      switch (L.insertionMode) {
        case Zt:
        case at:
          return v(u, Ji), v(u, h.segmentPrefix), v(u, T(F.toString(16))), g(u, Aa);
        case tn:
          return v(u, to), v(u, h.segmentPrefix), v(u, T(F.toString(16))), g(u, La);
        case cn:
          return v(u, no), v(u, h.segmentPrefix), v(u, T(F.toString(16))), g(u, ro);
        case qt:
          return v(u, ti), v(u, h.segmentPrefix), v(u, T(F.toString(16))), g(u, io);
        case Sn:
          return v(u, _), v(u, h.segmentPrefix), v(u, T(F.toString(16))), g(u, I);
        case Wt:
          return v(u, we), v(u, h.segmentPrefix), v(u, T(F.toString(16))), g(u, Se);
        case Ee:
          return v(u, Je), v(u, h.segmentPrefix), v(u, T(F.toString(16))), g(u, kt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function vn(u, h) {
      switch (h.insertionMode) {
        case Zt:
        case at:
          return g(u, eo);
        case tn:
          return g(u, Pa);
        case cn:
          return g(u, ao);
        case qt:
          return g(u, S);
        case Sn:
          return g(u, Q);
        case Wt:
          return g(u, Ie);
        case Ee:
          return g(u, Bt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Jn = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", sr = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', ur = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Na = b(Jn + ';$RS("'), oo = b('$RS("'), ni = b('","'), Wc = b('")<\/script>');
    function jc(u, h, L) {
      v(u, h.startInlineScript), h.sentCompleteSegmentFunction ? v(u, oo) : (h.sentCompleteSegmentFunction = !0, v(u, Na)), v(u, h.segmentPrefix);
      var F = T(L.toString(16));
      return v(u, F), v(u, ni), v(u, h.placeholderPrefix), v(u, F), g(u, Wc);
    }
    var Uc = b(sr + ';$RC("'), Kc = b('$RC("'), Yc = b('","'), Xc = b('")<\/script>');
    function ml(u, h, L, F) {
      if (v(u, h.startInlineScript), h.sentCompleteBoundaryFunction ? v(u, Kc) : (h.sentCompleteBoundaryFunction = !0, v(u, Uc)), L === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var Y = T(F.toString(16));
      return v(u, L), v(u, Yc), v(u, h.segmentPrefix), v(u, Y), g(u, Xc);
    }
    var qc = b(ur + ';$RX("'), Gc = b('$RX("'), yl = b('"'), Zc = b(")<\/script>"), gl = b(",");
    function zs(u, h, L, F, Y, le) {
      if (v(u, h.startInlineScript), h.sentClientRenderFunction ? v(u, Gc) : (h.sentClientRenderFunction = !0, v(u, qc)), L === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return v(u, L), v(u, yl), (F || Y || le) && (v(u, gl), v(u, T(vl(F || "")))), (Y || le) && (v(u, gl), v(u, T(vl(Y || "")))), le && (v(u, gl), v(u, T(vl(le)))), g(u, Zc);
    }
    var Bs = /[<\u2028\u2029]/g;
    function vl(u) {
      var h = JSON.stringify(u);
      return h.replace(Bs, function(L) {
        switch (L) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var mr = Object.assign, Qc = Symbol.for("react.element"), $s = Symbol.for("react.portal"), cr = Symbol.for("react.fragment"), Is = Symbol.for("react.strict_mode"), xl = Symbol.for("react.profiler"), lo = Symbol.for("react.provider"), so = Symbol.for("react.context"), uo = Symbol.for("react.forward_ref"), ri = Symbol.for("react.suspense"), ai = Symbol.for("react.suspense_list"), ii = Symbol.for("react.memo"), Ra = Symbol.for("react.lazy"), bl = Symbol.for("react.scope"), El = Symbol.for("react.debug_trace_mode"), co = Symbol.for("react.legacy_hidden"), Jc = Symbol.for("react.default_value"), Hs = Symbol.iterator, ed = "@@iterator";
    function td(u) {
      if (u === null || typeof u != "object")
        return null;
      var h = Hs && u[Hs] || u[ed];
      return typeof h == "function" ? h : null;
    }
    function Vs(u, h, L) {
      var F = u.displayName;
      if (F)
        return F;
      var Y = h.displayName || h.name || "";
      return Y !== "" ? L + "(" + Y + ")" : L;
    }
    function Ws(u) {
      return u.displayName || "Context";
    }
    function wn(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case cr:
          return "Fragment";
        case $s:
          return "Portal";
        case xl:
          return "Profiler";
        case Is:
          return "StrictMode";
        case ri:
          return "Suspense";
        case ai:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case so:
            var h = u;
            return Ws(h) + ".Consumer";
          case lo:
            var L = u;
            return Ws(L._context) + ".Provider";
          case uo:
            return Vs(u, u.render, "ForwardRef");
          case ii:
            var F = u.displayName || null;
            return F !== null ? F : wn(u.type) || "Memo";
          case Ra: {
            var Y = u, le = Y._payload, he = Y._init;
            try {
              return wn(he(le));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var oi = 0, Sl, kn, Da, kl, wl, Tl, Cl;
    function Al() {
    }
    Al.__reactDisabledLog = !0;
    function js() {
      {
        if (oi === 0) {
          Sl = console.log, kn = console.info, Da = console.warn, kl = console.error, wl = console.group, Tl = console.groupCollapsed, Cl = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: Al,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        oi++;
      }
    }
    function Us() {
      {
        if (oi--, oi === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: mr({}, u, {
              value: Sl
            }),
            info: mr({}, u, {
              value: kn
            }),
            warn: mr({}, u, {
              value: Da
            }),
            error: mr({}, u, {
              value: kl
            }),
            group: mr({}, u, {
              value: wl
            }),
            groupCollapsed: mr({}, u, {
              value: Tl
            }),
            groupEnd: mr({}, u, {
              value: Cl
            })
          });
        }
        oi < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var fo = r.ReactCurrentDispatcher, Ll;
    function li(u, h, L) {
      {
        if (Ll === void 0)
          try {
            throw Error();
          } catch (Y) {
            var F = Y.stack.trim().match(/\n( *(at )?)/);
            Ll = F && F[1] || "";
          }
        return `
` + Ll + u;
      }
    }
    var si = !1, _a;
    {
      var ui = typeof WeakMap == "function" ? WeakMap : Map;
      _a = new ui();
    }
    function ci(u, h) {
      if (!u || si)
        return "";
      {
        var L = _a.get(u);
        if (L !== void 0)
          return L;
      }
      var F;
      si = !0;
      var Y = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var le;
      le = fo.current, fo.current = null, js();
      try {
        if (h) {
          var he = function() {
            throw Error();
          };
          if (Object.defineProperty(he.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(he, []);
            } catch (de) {
              F = de;
            }
            Reflect.construct(u, [], he);
          } else {
            try {
              he.call();
            } catch (de) {
              F = de;
            }
            u.call(he.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (de) {
            F = de;
          }
          u();
        }
      } catch (de) {
        if (de && F && typeof de.stack == "string") {
          for (var Le = de.stack.split(`
`), l = F.stack.split(`
`), f = Le.length - 1, w = l.length - 1; f >= 1 && w >= 0 && Le[f] !== l[w]; )
            w--;
          for (; f >= 1 && w >= 0; f--, w--)
            if (Le[f] !== l[w]) {
              if (f !== 1 || w !== 1)
                do
                  if (f--, w--, w < 0 || Le[f] !== l[w]) {
                    var R = `
` + Le[f].replace(" at new ", " at ");
                    return u.displayName && R.includes("<anonymous>") && (R = R.replace("<anonymous>", u.displayName)), typeof u == "function" && _a.set(u, R), R;
                  }
                while (f >= 1 && w >= 0);
              break;
            }
        }
      } finally {
        si = !1, fo.current = le, Us(), Error.prepareStackTrace = Y;
      }
      var $ = u ? u.displayName || u.name : "", ne = $ ? li($) : "";
      return typeof u == "function" && _a.set(u, ne), ne;
    }
    function po(u, h, L) {
      return ci(u, !0);
    }
    function Ks(u, h, L) {
      return ci(u, !1);
    }
    function Pl(u) {
      var h = u.prototype;
      return !!(h && h.isReactComponent);
    }
    function Nl(u, h, L) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return ci(u, Pl(u));
      if (typeof u == "string")
        return li(u);
      switch (u) {
        case ri:
          return li("Suspense");
        case ai:
          return li("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case uo:
            return Ks(u.render);
          case ii:
            return Nl(u.type, h, L);
          case Ra: {
            var F = u, Y = F._payload, le = F._init;
            try {
              return Nl(le(Y), h, L);
            } catch {
            }
          }
        }
      return "";
    }
    var Rl = {}, Ys = r.ReactDebugCurrentFrame;
    function Oa(u) {
      if (u) {
        var h = u._owner, L = Nl(u.type, u._source, h ? h.type : null);
        Ys.setExtraStackFrame(L);
      } else
        Ys.setExtraStackFrame(null);
    }
    function Dl(u, h, L, F, Y) {
      {
        var le = Function.call.bind(J);
        for (var he in u)
          if (le(u, he)) {
            var Le = void 0;
            try {
              if (typeof u[he] != "function") {
                var l = Error((F || "React class") + ": " + L + " type `" + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[he] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw l.name = "Invariant Violation", l;
              }
              Le = u[he](h, he, F, L, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (f) {
              Le = f;
            }
            Le && !(Le instanceof Error) && (Oa(Y), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", F || "React class", L, he, typeof Le), Oa(null)), Le instanceof Error && !(Le.message in Rl) && (Rl[Le.message] = !0, Oa(Y), i("Failed %s type: %s", L, Le.message), Oa(null));
          }
      }
    }
    var ho;
    ho = {};
    var ia = {};
    Object.freeze(ia);
    function _l(u, h) {
      {
        var L = u.contextTypes;
        if (!L)
          return ia;
        var F = {};
        for (var Y in L)
          F[Y] = h[Y];
        {
          var le = wn(u) || "Unknown";
          Dl(L, F, "context", le);
        }
        return F;
      }
    }
    function Ol(u, h, L, F) {
      {
        if (typeof u.getChildContext != "function") {
          {
            var Y = wn(h) || "Unknown";
            ho[Y] || (ho[Y] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", Y, Y));
          }
          return L;
        }
        var le = u.getChildContext();
        for (var he in le)
          if (!(he in F))
            throw new Error((wn(h) || "Unknown") + '.getChildContext(): key "' + he + '" is not defined in childContextTypes.');
        {
          var Le = wn(h) || "Unknown";
          Dl(F, le, "child context", Le);
        }
        return mr({}, L, le);
      }
    }
    var Ur;
    Ur = {};
    var Xs = null, oa = null;
    function la(u) {
      u.context._currentValue = u.parentValue;
    }
    function Fl(u) {
      u.context._currentValue = u.value;
    }
    function Tr(u, h) {
      if (u !== h) {
        la(u);
        var L = u.parent, F = h.parent;
        if (L === null) {
          if (F !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (F === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          Tr(L, F);
        }
        Fl(h);
      }
    }
    function mo(u) {
      la(u);
      var h = u.parent;
      h !== null && mo(h);
    }
    function yo(u) {
      var h = u.parent;
      h !== null && yo(h), Fl(u);
    }
    function di(u, h) {
      la(u);
      var L = u.parent;
      if (L === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      L.depth === h.depth ? Tr(L, h) : di(L, h);
    }
    function Ml(u, h) {
      var L = h.parent;
      if (L === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      u.depth === L.depth ? Tr(u, L) : Ml(u, L), Fl(h);
    }
    function fi(u) {
      var h = oa, L = u;
      h !== L && (h === null ? yo(L) : L === null ? mo(h) : h.depth === L.depth ? Tr(h, L) : h.depth > L.depth ? di(h, L) : Ml(h, L), oa = L);
    }
    function qs(u, h) {
      var L;
      L = u._currentValue, u._currentValue = h, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== Ur && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = Ur;
      var F = oa, Y = {
        parent: F,
        depth: F === null ? 0 : F.depth + 1,
        context: u,
        parentValue: L,
        value: h
      };
      return oa = Y, Y;
    }
    function Gs(u) {
      var h = oa;
      if (h === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      h.context !== u && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var L = h.parentValue;
        L === Jc ? h.context._currentValue = h.context._defaultValue : h.context._currentValue = L, u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== Ur && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), u._currentRenderer = Ur;
      }
      return oa = h.parent;
    }
    function go() {
      return oa;
    }
    function pi(u) {
      var h = u._currentValue;
      return h;
    }
    function zl(u) {
      return u._reactInternals;
    }
    function nd(u, h) {
      u._reactInternals = h;
    }
    var Fa = {}, vo = {}, Bl, xo, bo, hi, Eo, Ma, mi, So, za;
    {
      Bl = /* @__PURE__ */ new Set(), xo = /* @__PURE__ */ new Set(), bo = /* @__PURE__ */ new Set(), mi = /* @__PURE__ */ new Set(), hi = /* @__PURE__ */ new Set(), So = /* @__PURE__ */ new Set(), za = /* @__PURE__ */ new Set();
      var ko = /* @__PURE__ */ new Set();
      Ma = function(u, h) {
        if (!(u === null || typeof u == "function")) {
          var L = h + "_" + u;
          ko.has(L) || (ko.add(L), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", h, u));
        }
      }, Eo = function(u, h) {
        if (h === void 0) {
          var L = wn(u) || "Component";
          hi.has(L) || (hi.add(L), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", L));
        }
      };
    }
    function wo(u, h) {
      {
        var L = u.constructor, F = L && wn(L) || "ReactClass", Y = F + "." + h;
        if (Fa[Y])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, h, h, F), Fa[Y] = !0;
      }
    }
    var To = {
      isMounted: function(u) {
        return !1;
      },
      enqueueSetState: function(u, h, L) {
        var F = zl(u);
        F.queue === null ? wo(u, "setState") : (F.queue.push(h), L != null && Ma(L, "setState"));
      },
      enqueueReplaceState: function(u, h, L) {
        var F = zl(u);
        F.replace = !0, F.queue = [h], L != null && Ma(L, "setState");
      },
      enqueueForceUpdate: function(u, h) {
        var L = zl(u);
        L.queue === null ? wo(u, "forceUpdate") : h != null && Ma(h, "setState");
      }
    };
    function Zs(u, h, L, F, Y) {
      var le = L(Y, F);
      Eo(h, le);
      var he = le == null ? F : mr({}, F, le);
      return he;
    }
    function Qs(u, h, L) {
      var F = ia, Y = u.contextType;
      if ("contextType" in u) {
        var le = (
          // Allow null for conditional declaration
          Y === null || Y !== void 0 && Y.$$typeof === so && Y._context === void 0
        );
        if (!le && !za.has(u)) {
          za.add(u);
          var he = "";
          Y === void 0 ? he = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof Y != "object" ? he = " However, it is set to a " + typeof Y + "." : Y.$$typeof === lo ? he = " Did you accidentally pass the Context.Provider instead?" : Y._context !== void 0 ? he = " Did you accidentally pass the Context.Consumer instead?" : he = " However, it is set to an object with keys {" + Object.keys(Y).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", wn(u) || "Component", he);
        }
      }
      typeof Y == "object" && Y !== null ? F = pi(Y) : F = L;
      var Le = new u(h, F);
      {
        if (typeof u.getDerivedStateFromProps == "function" && (Le.state === null || Le.state === void 0)) {
          var l = wn(u) || "Component";
          Bl.has(l) || (Bl.add(l), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", l, Le.state === null ? "null" : "undefined", l));
        }
        if (typeof u.getDerivedStateFromProps == "function" || typeof Le.getSnapshotBeforeUpdate == "function") {
          var f = null, w = null, R = null;
          if (typeof Le.componentWillMount == "function" && Le.componentWillMount.__suppressDeprecationWarning !== !0 ? f = "componentWillMount" : typeof Le.UNSAFE_componentWillMount == "function" && (f = "UNSAFE_componentWillMount"), typeof Le.componentWillReceiveProps == "function" && Le.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? w = "componentWillReceiveProps" : typeof Le.UNSAFE_componentWillReceiveProps == "function" && (w = "UNSAFE_componentWillReceiveProps"), typeof Le.componentWillUpdate == "function" && Le.componentWillUpdate.__suppressDeprecationWarning !== !0 ? R = "componentWillUpdate" : typeof Le.UNSAFE_componentWillUpdate == "function" && (R = "UNSAFE_componentWillUpdate"), f !== null || w !== null || R !== null) {
            var $ = wn(u) || "Component", ne = typeof u.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            bo.has($) || (bo.add($), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, $, ne, f !== null ? `
  ` + f : "", w !== null ? `
  ` + w : "", R !== null ? `
  ` + R : ""));
          }
        }
      }
      return Le;
    }
    function Js(u, h, L) {
      {
        var F = wn(h) || "Component", Y = u.render;
        Y || (h.prototype && typeof h.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", F) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", F)), u.getInitialState && !u.getInitialState.isReactClassApproved && !u.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", F), u.getDefaultProps && !u.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", F), u.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", F), u.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", F), u.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", F), h.contextType && h.contextTypes && !So.has(h) && (So.add(h), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", F)), typeof u.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", F), h.prototype && h.prototype.isPureReactComponent && typeof u.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", wn(h) || "A pure component"), typeof u.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", F), typeof u.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", F), typeof u.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", F), typeof u.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", F);
        var le = u.props !== L;
        u.props !== void 0 && le && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", F, F), u.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", F, F), typeof u.getSnapshotBeforeUpdate == "function" && typeof u.componentDidUpdate != "function" && !xo.has(h) && (xo.add(h), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", wn(h))), typeof u.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", F), typeof u.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", F), typeof h.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", F);
        var he = u.state;
        he && (typeof he != "object" || jn(he)) && i("%s.state: must be set to an object or null", F), typeof u.getChildContext == "function" && typeof h.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", F);
      }
    }
    function rd(u, h) {
      var L = h.state;
      if (typeof h.componentWillMount == "function") {
        if (h.componentWillMount.__suppressDeprecationWarning !== !0) {
          var F = wn(u) || "Unknown";
          vo[F] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            F
          ), vo[F] = !0);
        }
        h.componentWillMount();
      }
      typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(), L !== h.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", wn(u) || "Component"), To.enqueueReplaceState(h, h.state, null));
    }
    function ad(u, h, L, F) {
      if (u.queue !== null && u.queue.length > 0) {
        var Y = u.queue, le = u.replace;
        if (u.queue = null, u.replace = !1, le && Y.length === 1)
          h.state = Y[0];
        else {
          for (var he = le ? Y[0] : h.state, Le = !0, l = le ? 1 : 0; l < Y.length; l++) {
            var f = Y[l], w = typeof f == "function" ? f.call(h, he, L, F) : f;
            w != null && (Le ? (Le = !1, he = mr({}, he, w)) : mr(he, w));
          }
          h.state = he;
        }
      } else
        u.queue = null;
    }
    function eu(u, h, L, F) {
      Js(u, h, L);
      var Y = u.state !== void 0 ? u.state : null;
      u.updater = To, u.props = L, u.state = Y;
      var le = {
        queue: [],
        replace: !1
      };
      nd(u, le);
      var he = h.contextType;
      if (typeof he == "object" && he !== null ? u.context = pi(he) : u.context = F, u.state === L) {
        var Le = wn(h) || "Component";
        mi.has(Le) || (mi.add(Le), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Le));
      }
      var l = h.getDerivedStateFromProps;
      typeof l == "function" && (u.state = Zs(u, h, l, Y, L)), typeof h.getDerivedStateFromProps != "function" && typeof u.getSnapshotBeforeUpdate != "function" && (typeof u.UNSAFE_componentWillMount == "function" || typeof u.componentWillMount == "function") && (rd(h, u), ad(le, u, L, F));
    }
    var id = {
      id: 1,
      overflow: ""
    };
    function od(u) {
      var h = u.overflow, L = u.id, F = L & ~ld(L);
      return F.toString(32) + h;
    }
    function Co(u, h, L) {
      var F = u.id, Y = u.overflow, le = Ao(F) - 1, he = F & ~(1 << le), Le = L + 1, l = Ao(h) + le;
      if (l > 30) {
        var f = le - le % 5, w = (1 << f) - 1, R = (he & w).toString(32), $ = he >> f, ne = le - f, de = Ao(h) + ne, Ce = Le << ne, We = Ce | $, ct = R + Y;
        return {
          id: 1 << de | We,
          overflow: ct
        };
      } else {
        var ht = Le << le, Lt = ht | he, bn = Y;
        return {
          id: 1 << l | Lt,
          overflow: bn
        };
      }
    }
    function Ao(u) {
      return 32 - $l(u);
    }
    function ld(u) {
      return 1 << Ao(u) - 1;
    }
    var $l = Math.clz32 ? Math.clz32 : ud, Lo = Math.log, sd = Math.LN2;
    function ud(u) {
      var h = u >>> 0;
      return h === 0 ? 32 : 31 - (Lo(h) / sd | 0) | 0;
    }
    function cd(u, h) {
      return u === h && (u !== 0 || 1 / u === 1 / h) || u !== u && h !== h;
    }
    var dd = typeof Object.is == "function" ? Object.is : cd, _r = null, Il = null, Po = null, Jt = null, sa = !1, ua = !1, dn = 0, yr = null, ca = 0, No = 25, In = !1, Or;
    function da() {
      if (_r === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return In && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), _r;
    }
    function Cr(u, h) {
      if (h === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Or), !1;
      u.length !== h.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Or, "[" + u.join(", ") + "]", "[" + h.join(", ") + "]");
      for (var L = 0; L < h.length && L < u.length; L++)
        if (!dd(u[L], h[L]))
          return !1;
      return !0;
    }
    function fa() {
      if (ca > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Fr() {
      return Jt === null ? Po === null ? (sa = !1, Po = Jt = fa()) : (sa = !0, Jt = Po) : Jt.next === null ? (sa = !1, Jt = Jt.next = fa()) : (sa = !0, Jt = Jt.next), Jt;
    }
    function fd(u, h) {
      _r = h, Il = u, In = !1, dn = 0;
    }
    function tu(u, h, L, F) {
      for (; ua; )
        ua = !1, dn = 0, ca += 1, Jt = null, L = u(h, F);
      return Hl(), L;
    }
    function Ro() {
      var u = dn !== 0;
      return u;
    }
    function Hl() {
      In = !1, _r = null, Il = null, ua = !1, Po = null, ca = 0, yr = null, Jt = null;
    }
    function pd(u) {
      return In && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), pi(u);
    }
    function nu(u) {
      return Or = "useContext", da(), pi(u);
    }
    function yi(u, h) {
      return typeof h == "function" ? h(u) : h;
    }
    function hd(u) {
      return Or = "useState", ru(
        yi,
        // useReducer has a special case to support lazy useState initializers
        u
      );
    }
    function ru(u, h, L) {
      if (u !== yi && (Or = "useReducer"), _r = da(), Jt = Fr(), sa) {
        var F = Jt.queue, Y = F.dispatch;
        if (yr !== null) {
          var le = yr.get(F);
          if (le !== void 0) {
            yr.delete(F);
            var he = Jt.memoizedState, Le = le;
            do {
              var l = Le.action;
              In = !0, he = u(he, l), In = !1, Le = Le.next;
            } while (Le !== null);
            return Jt.memoizedState = he, [he, Y];
          }
        }
        return [Jt.memoizedState, Y];
      } else {
        In = !0;
        var f;
        u === yi ? f = typeof h == "function" ? h() : h : f = L !== void 0 ? L(h) : h, In = !1, Jt.memoizedState = f;
        var w = Jt.queue = {
          last: null,
          dispatch: null
        }, R = w.dispatch = iu.bind(null, _r, w);
        return [Jt.memoizedState, R];
      }
    }
    function Do(u, h) {
      _r = da(), Jt = Fr();
      var L = h === void 0 ? null : h;
      if (Jt !== null) {
        var F = Jt.memoizedState;
        if (F !== null && L !== null) {
          var Y = F[1];
          if (Cr(L, Y))
            return F[0];
        }
      }
      In = !0;
      var le = u();
      return In = !1, Jt.memoizedState = [le, L], le;
    }
    function md(u) {
      _r = da(), Jt = Fr();
      var h = Jt.memoizedState;
      if (h === null) {
        var L = {
          current: u
        };
        return Object.seal(L), Jt.memoizedState = L, L;
      } else
        return h;
    }
    function au(u, h) {
      Or = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function iu(u, h, L) {
      if (ca >= No)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (u === _r) {
        ua = !0;
        var F = {
          action: L,
          next: null
        };
        yr === null && (yr = /* @__PURE__ */ new Map());
        var Y = yr.get(h);
        if (Y === void 0)
          yr.set(h, F);
        else {
          for (var le = Y; le.next !== null; )
            le = le.next;
          le.next = F;
        }
      }
    }
    function yd(u, h) {
      return Do(function() {
        return u;
      }, h);
    }
    function gd(u, h, L) {
      return da(), h(u._source);
    }
    function vd(u, h, L) {
      if (L === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return L();
    }
    function xd(u) {
      return da(), u;
    }
    function bd() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function Ed() {
      return da(), [!1, bd];
    }
    function Sd() {
      var u = Il, h = od(u.treeContext), L = Vl;
      if (L === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var F = dn++;
      return Xt(L, h, F);
    }
    function _o() {
    }
    var ou = {
      readContext: pd,
      useContext: nu,
      useMemo: Do,
      useReducer: ru,
      useRef: md,
      useState: hd,
      useInsertionEffect: _o,
      useLayoutEffect: au,
      useCallback: yd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: _o,
      // Effects are not run in the server environment.
      useEffect: _o,
      // Debugging effect
      useDebugValue: _o,
      useDeferredValue: xd,
      useTransition: Ed,
      useId: Sd,
      // Subscriptions are not setup in a server environment.
      useMutableSource: gd,
      useSyncExternalStore: vd
    }, Vl = null;
    function gi(u) {
      Vl = u;
    }
    function lu(u) {
      try {
        var h = "", L = u;
        do {
          switch (L.tag) {
            case 0:
              h += li(L.type, null, null);
              break;
            case 1:
              h += Ks(L.type, null, null);
              break;
            case 2:
              h += po(L.type, null, null);
              break;
          }
          L = L.parent;
        } while (L);
        return h;
      } catch (F) {
        return `
Error generating stack: ` + F.message + `
` + F.stack;
      }
    }
    var vi = r.ReactCurrentDispatcher, Oo = r.ReactDebugCurrentFrame, Wl = 0, Kr = 1, Fo = 2, Mo = 3, pa = 4, su = 0, jl = 1, ha = 2, kd = 12800;
    function uu(u) {
      return console.error(u), null;
    }
    function Ar() {
    }
    function wd(u, h, L, F, Y, le, he, Le, l) {
      var f = [], w = /* @__PURE__ */ new Set(), R = {
        destination: null,
        responseState: h,
        progressiveChunkSize: F === void 0 ? kd : F,
        status: su,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: w,
        pingedTasks: f,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: Y === void 0 ? uu : Y,
        onAllReady: le === void 0 ? Ar : le,
        onShellReady: he === void 0 ? Ar : he,
        onShellError: Le === void 0 ? Ar : Le,
        onFatalError: l === void 0 ? Ar : l
      }, $ = zo(
        R,
        0,
        null,
        L,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      $.parentFlushed = !0;
      var ne = Ul(R, u, null, $, w, ia, Xs, id);
      return f.push(ne), R;
    }
    function Td(u, h) {
      var L = u.pingedTasks;
      L.push(h), L.length === 1 && d(function() {
        return wi(u);
      });
    }
    function xi(u, h) {
      return {
        id: Vt,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: h,
        errorDigest: null
      };
    }
    function Ul(u, h, L, F, Y, le, he, Le) {
      u.allPendingTasks++, L === null ? u.pendingRootTasks++ : L.pendingTasks++;
      var l = {
        node: h,
        ping: function() {
          return Td(u, l);
        },
        blockedBoundary: L,
        blockedSegment: F,
        abortSet: Y,
        legacyContext: le,
        context: he,
        treeContext: Le
      };
      return l.componentStack = null, Y.add(l), l;
    }
    function zo(u, h, L, F, Y, le) {
      return {
        status: Wl,
        id: -1,
        // lazily assigned later
        index: h,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: F,
        boundary: L,
        lastPushedText: Y,
        textEmbedded: le
      };
    }
    var Mr = null;
    function bi() {
      return Mr === null || Mr.componentStack === null ? "" : lu(Mr.componentStack);
    }
    function Yr(u, h) {
      u.componentStack = {
        tag: 0,
        parent: u.componentStack,
        type: h
      };
    }
    function Lr(u, h) {
      u.componentStack = {
        tag: 1,
        parent: u.componentStack,
        type: h
      };
    }
    function Kl(u, h) {
      u.componentStack = {
        tag: 2,
        parent: u.componentStack,
        type: h
      };
    }
    function gr(u) {
      u.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : u.componentStack = u.componentStack.parent;
    }
    var Ba = null;
    function Yl(u, h) {
      {
        var L;
        typeof h == "string" ? L = h : h && typeof h.message == "string" ? L = h.message : L = String(h);
        var F = Ba || bi();
        Ba = null, u.errorMessage = L, u.errorComponentStack = F;
      }
    }
    function vr(u, h) {
      var L = u.onError(h);
      if (L != null && typeof L != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof L + '" instead');
      return L;
    }
    function Xr(u, h) {
      var L = u.onShellError;
      L(h);
      var F = u.onFatalError;
      F(h), u.destination !== null ? (u.status = ha, y(u.destination, h)) : (u.status = jl, u.fatalError = h);
    }
    function Xl(u, h, L) {
      Yr(h, "Suspense");
      var F = h.blockedBoundary, Y = h.blockedSegment, le = L.fallback, he = L.children, Le = /* @__PURE__ */ new Set(), l = xi(u, Le), f = Y.chunks.length, w = zo(
        u,
        f,
        l,
        Y.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      Y.children.push(w), Y.lastPushedText = !1;
      var R = zo(
        u,
        0,
        null,
        Y.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      R.parentFlushed = !0, h.blockedBoundary = l, h.blockedSegment = R;
      try {
        if (rs(u, h, he), _t(R.chunks, u.responseState, R.lastPushedText, R.textEmbedded), R.status = Kr, Io(l, R), l.pendingTasks === 0) {
          gr(h);
          return;
        }
      } catch (ne) {
        R.status = pa, l.forceClientRender = !0, l.errorDigest = vr(u, ne), Yl(l, ne);
      } finally {
        h.blockedBoundary = F, h.blockedSegment = Y;
      }
      var $ = Ul(u, le, F, w, Le, h.legacyContext, h.context, h.treeContext);
      $.componentStack = h.componentStack, u.pingedTasks.push($), gr(h);
    }
    function Ei(u, h, L, F) {
      Yr(h, L);
      var Y = h.blockedSegment, le = Za(Y.chunks, L, F, u.responseState, Y.formatContext);
      Y.lastPushedText = !1;
      var he = Y.formatContext;
      Y.formatContext = Ke(he, L, F), rs(u, h, le), Y.formatContext = he, qi(Y.chunks, L), Y.lastPushedText = !1, gr(h);
    }
    function Bo(u) {
      return u.prototype && u.prototype.isReactComponent;
    }
    function cu(u, h, L, F, Y) {
      var le = {};
      fd(h, le);
      var he = L(F, Y);
      return tu(L, F, he, Y);
    }
    function du(u, h, L, F, Y) {
      var le = L.render();
      L.props !== Y && (ki || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", wn(F) || "a component"), ki = !0);
      {
        var he = F.childContextTypes;
        if (he != null) {
          var Le = h.legacyContext, l = Ol(L, F, Le, he);
          h.legacyContext = l, dr(u, h, le), h.legacyContext = Le;
          return;
        }
      }
      dr(u, h, le);
    }
    function Cd(u, h, L, F) {
      Kl(h, L);
      var Y = _l(L, h.legacyContext), le = Qs(L, F, Y);
      eu(le, L, F, Y), du(u, h, le, L, F), gr(h);
    }
    var ql = {}, Si = {}, fu = {}, Gl = {}, ki = !1, Zl = !1, Ql = !1, Jl = !1;
    function pu(u, h, L, F) {
      var Y;
      if (Y = _l(L, h.legacyContext), Lr(h, L), L.prototype && typeof L.prototype.render == "function") {
        var le = wn(L) || "Unknown";
        ql[le] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", le, le), ql[le] = !0);
      }
      var he = cu(u, h, L, F, Y), Le = Ro();
      if (typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0) {
        var l = wn(L) || "Unknown";
        Si[l] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", l, l, l), Si[l] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0
      ) {
        {
          var f = wn(L) || "Unknown";
          Si[f] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", f, f, f), Si[f] = !0);
        }
        eu(he, L, F, Y), du(u, h, he, L, F);
      } else if (hu(L), Le) {
        var w = h.treeContext, R = 1, $ = 0;
        h.treeContext = Co(w, R, $);
        try {
          dr(u, h, he);
        } finally {
          h.treeContext = w;
        }
      } else
        dr(u, h, he);
      gr(h);
    }
    function hu(u) {
      {
        if (u && u.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", u.displayName || u.name || "Component"), typeof u.getDerivedStateFromProps == "function") {
          var h = wn(u) || "Unknown";
          Gl[h] || (i("%s: Function components do not support getDerivedStateFromProps.", h), Gl[h] = !0);
        }
        if (typeof u.contextType == "object" && u.contextType !== null) {
          var L = wn(u) || "Unknown";
          fu[L] || (i("%s: Function components do not support contextType.", L), fu[L] = !0);
        }
      }
    }
    function es(u, h) {
      if (u && u.defaultProps) {
        var L = mr({}, h), F = u.defaultProps;
        for (var Y in F)
          L[Y] === void 0 && (L[Y] = F[Y]);
        return L;
      }
      return h;
    }
    function Ad(u, h, L, F, Y) {
      Lr(h, L.render);
      var le = cu(u, h, L.render, F, Y), he = Ro();
      if (he) {
        var Le = h.treeContext, l = 1, f = 0;
        h.treeContext = Co(Le, l, f);
        try {
          dr(u, h, le);
        } finally {
          h.treeContext = Le;
        }
      } else
        dr(u, h, le);
      gr(h);
    }
    function Ld(u, h, L, F, Y) {
      var le = L.type, he = es(le, F);
      ts(u, h, le, he, Y);
    }
    function mu(u, h, L, F) {
      L._context === void 0 ? L !== L.Consumer && (Jl || (Jl = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : L = L._context;
      var Y = F.children;
      typeof Y != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var le = pi(L), he = Y(le);
      dr(u, h, he);
    }
    function Pd(u, h, L, F) {
      var Y = L._context, le = F.value, he = F.children, Le;
      Le = h.context, h.context = qs(Y, le), dr(u, h, he), h.context = Gs(Y), Le !== h.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function Nd(u, h, L, F, Y) {
      Yr(h, "Lazy");
      var le = L._payload, he = L._init, Le = he(le), l = es(Le, F);
      ts(u, h, Le, l, Y), gr(h);
    }
    function ts(u, h, L, F, Y) {
      if (typeof L == "function")
        if (Bo(L)) {
          Cd(u, h, L, F);
          return;
        } else {
          pu(u, h, L, F);
          return;
        }
      if (typeof L == "string") {
        Ei(u, h, L, F);
        return;
      }
      switch (L) {
        case co:
        case El:
        case Is:
        case xl:
        case cr: {
          dr(u, h, F.children);
          return;
        }
        case ai: {
          Yr(h, "SuspenseList"), dr(u, h, F.children), gr(h);
          return;
        }
        case bl:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case ri: {
          Xl(u, h, F);
          return;
        }
      }
      if (typeof L == "object" && L !== null)
        switch (L.$$typeof) {
          case uo: {
            Ad(u, h, L, F, Y);
            return;
          }
          case ii: {
            Ld(u, h, L, F, Y);
            return;
          }
          case lo: {
            Pd(u, h, L, F);
            return;
          }
          case so: {
            mu(u, h, L, F);
            return;
          }
          case Ra: {
            Nd(u, h, L, F);
            return;
          }
        }
      var le = "";
      throw (L === void 0 || typeof L == "object" && L !== null && Object.keys(L).length === 0) && (le += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (L == null ? L : typeof L) + "." + le));
    }
    function Rd(u, h) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      u[Symbol.toStringTag] === "Generator" && (Zl || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Zl = !0), u.entries === h && (Ql || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Ql = !0);
    }
    function dr(u, h, L) {
      try {
        return ns(u, h, L);
      } catch (F) {
        throw typeof F == "object" && F !== null && typeof F.then == "function" || (Ba = Ba !== null ? Ba : bi()), F;
      }
    }
    function ns(u, h, L) {
      if (h.node = L, typeof L == "object" && L !== null) {
        switch (L.$$typeof) {
          case Qc: {
            var F = L, Y = F.type, le = F.props, he = F.ref;
            ts(u, h, Y, le, he);
            return;
          }
          case $s:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Ra: {
            var Le = L, l = Le._payload, f = Le._init, w;
            try {
              w = f(l);
            } catch (ht) {
              throw typeof ht == "object" && ht !== null && typeof ht.then == "function" && Yr(h, "Lazy"), ht;
            }
            dr(u, h, w);
            return;
          }
        }
        if (jn(L)) {
          yu(u, h, L);
          return;
        }
        var R = td(L);
        if (R) {
          Rd(L, R);
          var $ = R.call(L);
          if ($) {
            var ne = $.next();
            if (!ne.done) {
              var de = [];
              do
                de.push(ne.value), ne = $.next();
              while (!ne.done);
              yu(u, h, de);
              return;
            }
            return;
          }
        }
        var Ce = Object.prototype.toString.call(L);
        throw new Error("Objects are not valid as a React child (found: " + (Ce === "[object Object]" ? "object with keys {" + Object.keys(L).join(", ") + "}" : Ce) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof L == "string") {
        var We = h.blockedSegment;
        We.lastPushedText = pn(h.blockedSegment.chunks, L, u.responseState, We.lastPushedText);
        return;
      }
      if (typeof L == "number") {
        var ct = h.blockedSegment;
        ct.lastPushedText = pn(h.blockedSegment.chunks, "" + L, u.responseState, ct.lastPushedText);
        return;
      }
      typeof L == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function yu(u, h, L) {
      for (var F = L.length, Y = 0; Y < F; Y++) {
        var le = h.treeContext;
        h.treeContext = Co(le, F, Y);
        try {
          rs(u, h, L[Y]);
        } finally {
          h.treeContext = le;
        }
      }
    }
    function fr(u, h, L) {
      var F = h.blockedSegment, Y = F.chunks.length, le = zo(
        u,
        Y,
        null,
        F.formatContext,
        // Adopt the parent segment's leading text embed
        F.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      F.children.push(le), F.lastPushedText = !1;
      var he = Ul(u, h.node, h.blockedBoundary, le, h.abortSet, h.legacyContext, h.context, h.treeContext);
      h.componentStack !== null && (he.componentStack = h.componentStack.parent);
      var Le = he.ping;
      L.then(Le, Le);
    }
    function rs(u, h, L) {
      var F = h.blockedSegment.formatContext, Y = h.legacyContext, le = h.context, he = null;
      he = h.componentStack;
      try {
        return dr(u, h, L);
      } catch (Le) {
        if (Hl(), typeof Le == "object" && Le !== null && typeof Le.then == "function") {
          fr(u, h, Le), h.blockedSegment.formatContext = F, h.legacyContext = Y, h.context = le, fi(le), h.componentStack = he;
          return;
        } else
          throw h.blockedSegment.formatContext = F, h.legacyContext = Y, h.context = le, fi(le), h.componentStack = he, Le;
      }
    }
    function gu(u, h, L, F) {
      var Y = vr(u, F);
      if (h === null ? Xr(u, F) : (h.pendingTasks--, h.forceClientRender || (h.forceClientRender = !0, h.errorDigest = Y, Yl(h, F), h.parentFlushed && u.clientRenderedBoundaries.push(h))), u.allPendingTasks--, u.allPendingTasks === 0) {
        var le = u.onAllReady;
        le();
      }
    }
    function Dd(u) {
      var h = this, L = u.blockedBoundary, F = u.blockedSegment;
      F.status = Mo, vu(h, L, F);
    }
    function $o(u, h, L) {
      var F = u.blockedBoundary, Y = u.blockedSegment;
      if (Y.status = Mo, F === null)
        h.allPendingTasks--, h.status !== ha && (h.status = ha, h.destination !== null && k(h.destination));
      else {
        if (F.pendingTasks--, !F.forceClientRender) {
          F.forceClientRender = !0;
          var le = L === void 0 ? new Error("The render was aborted by the server without a reason.") : L;
          F.errorDigest = h.onError(le);
          {
            var he = "The server did not finish this Suspense boundary: ";
            le && typeof le.message == "string" ? le = he + le.message : le = he + String(le);
            var Le = Mr;
            Mr = u;
            try {
              Yl(F, le);
            } finally {
              Mr = Le;
            }
          }
          F.parentFlushed && h.clientRenderedBoundaries.push(F);
        }
        if (F.fallbackAbortableTasks.forEach(function(f) {
          return $o(f, h, L);
        }), F.fallbackAbortableTasks.clear(), h.allPendingTasks--, h.allPendingTasks === 0) {
          var l = h.onAllReady;
          l();
        }
      }
    }
    function Io(u, h) {
      if (h.chunks.length === 0 && h.children.length === 1 && h.children[0].boundary === null) {
        var L = h.children[0];
        L.id = h.id, L.parentFlushed = !0, L.status === Kr && Io(u, L);
      } else {
        var F = u.completedSegments;
        F.push(h);
      }
    }
    function vu(u, h, L) {
      if (h === null) {
        if (L.parentFlushed) {
          if (u.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          u.completedRootSegment = L;
        }
        if (u.pendingRootTasks--, u.pendingRootTasks === 0) {
          u.onShellError = Ar;
          var F = u.onShellReady;
          F();
        }
      } else if (h.pendingTasks--, !h.forceClientRender) {
        if (h.pendingTasks === 0)
          L.parentFlushed && L.status === Kr && Io(h, L), h.parentFlushed && u.completedBoundaries.push(h), h.fallbackAbortableTasks.forEach(Dd, u), h.fallbackAbortableTasks.clear();
        else if (L.parentFlushed && L.status === Kr) {
          Io(h, L);
          var Y = h.completedSegments;
          Y.length === 1 && h.parentFlushed && u.partialBoundaries.push(h);
        }
      }
      if (u.allPendingTasks--, u.allPendingTasks === 0) {
        var le = u.onAllReady;
        le();
      }
    }
    function xu(u, h) {
      var L = h.blockedSegment;
      if (L.status === Wl) {
        fi(h.context);
        var F = null;
        F = Mr, Mr = h;
        try {
          dr(u, h, h.node), _t(L.chunks, u.responseState, L.lastPushedText, L.textEmbedded), h.abortSet.delete(h), L.status = Kr, vu(u, h.blockedBoundary, L);
        } catch (le) {
          if (Hl(), typeof le == "object" && le !== null && typeof le.then == "function") {
            var Y = h.ping;
            le.then(Y, Y);
          } else
            h.abortSet.delete(h), L.status = pa, gu(u, h.blockedBoundary, L, le);
        } finally {
          Mr = F;
        }
      }
    }
    function wi(u) {
      if (u.status !== ha) {
        var h = go(), L = vi.current;
        vi.current = ou;
        var F;
        F = Oo.getCurrentStack, Oo.getCurrentStack = bi;
        var Y = Vl;
        gi(u.responseState);
        try {
          var le = u.pingedTasks, he;
          for (he = 0; he < le.length; he++) {
            var Le = le[he];
            xu(u, Le);
          }
          le.splice(0, he), u.destination !== null && Vo(u, u.destination);
        } catch (l) {
          vr(u, l), Xr(u, l);
        } finally {
          gi(Y), vi.current = L, Oo.getCurrentStack = F, L === ou && fi(h);
        }
      }
    }
    function Ti(u, h, L) {
      switch (L.parentFlushed = !0, L.status) {
        case Wl: {
          var F = L.id = u.nextSegmentId++;
          return L.lastPushedText = !1, L.textEmbedded = !1, Sa(h, u.responseState, F);
        }
        case Kr: {
          L.status = Fo;
          for (var Y = !0, le = L.chunks, he = 0, Le = L.children, l = 0; l < Le.length; l++) {
            for (var f = Le[l]; he < f.index; he++)
              v(h, le[he]);
            Y = Ho(u, h, f);
          }
          for (; he < le.length - 1; he++)
            v(h, le[he]);
          return he < le.length && (Y = g(h, le[he])), Y;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ho(u, h, L) {
      var F = L.boundary;
      if (F === null)
        return Ti(u, h, L);
      if (F.parentFlushed = !0, F.forceClientRender)
        return Qn(h, u.responseState, F.errorDigest, F.errorMessage, F.errorComponentStack), Ti(u, h, L), hl(h, u.responseState);
      if (F.pendingTasks > 0) {
        F.rootSegmentID = u.nextSegmentId++, F.completedSegments.length > 0 && u.partialBoundaries.push(F);
        var Y = F.id = At(u.responseState);
        return Ta(h, u.responseState, Y), Ti(u, h, L), Ca(h, u.responseState);
      } else {
        if (F.byteSize > u.progressiveChunkSize)
          return F.rootSegmentID = u.nextSegmentId++, u.completedBoundaries.push(F), Ta(h, u.responseState, F.id), Ti(u, h, L), Ca(h, u.responseState);
        Zi(h, u.responseState);
        var le = F.completedSegments;
        if (le.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var he = le[0];
        return Ho(u, h, he), Qi(h, u.responseState);
      }
    }
    function bu(u, h, L) {
      return zs(h, u.responseState, L.id, L.errorDigest, L.errorMessage, L.errorComponentStack);
    }
    function Ci(u, h, L) {
      return Ft(h, u.responseState, L.formatContext, L.id), Ho(u, h, L), vn(h, L.formatContext);
    }
    function Ai(u, h, L) {
      for (var F = L.completedSegments, Y = 0; Y < F.length; Y++) {
        var le = F[Y];
        as(u, h, L, le);
      }
      return F.length = 0, ml(h, u.responseState, L.id, L.rootSegmentID);
    }
    function _d(u, h, L) {
      for (var F = L.completedSegments, Y = 0; Y < F.length; Y++) {
        var le = F[Y];
        if (!as(u, h, L, le))
          return Y++, F.splice(0, Y), !1;
      }
      return F.splice(0, Y), !0;
    }
    function as(u, h, L, F) {
      if (F.status === Fo)
        return !0;
      var Y = F.id;
      if (Y === -1) {
        var le = F.id = L.rootSegmentID;
        if (le === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Ci(u, h, F);
      } else
        return Ci(u, h, F), jc(h, u.responseState, Y);
    }
    function Vo(u, h) {
      m();
      try {
        var L = u.completedRootSegment;
        L !== null && u.pendingRootTasks === 0 && (Ho(u, h, L), u.completedRootSegment = null, dl(h, u.responseState));
        var F = u.clientRenderedBoundaries, Y;
        for (Y = 0; Y < F.length; Y++) {
          var le = F[Y];
          bu(u, h, le);
        }
        F.splice(0, Y);
        var he = u.completedBoundaries;
        for (Y = 0; Y < he.length; Y++) {
          var Le = he[Y];
          Ai(u, h, Le);
        }
        he.splice(0, Y), A(h), m(h);
        var l = u.partialBoundaries;
        for (Y = 0; Y < l.length; Y++) {
          var f = l[Y];
          if (!_d(u, h, f)) {
            u.destination = null, Y++, l.splice(0, Y);
            return;
          }
        }
        l.splice(0, Y);
        var w = u.completedBoundaries;
        for (Y = 0; Y < w.length; Y++) {
          var R = w[Y];
          Ai(u, h, R);
        }
        w.splice(0, Y);
      } finally {
        A(h), u.allPendingTasks === 0 && u.pingedTasks.length === 0 && u.clientRenderedBoundaries.length === 0 && u.completedBoundaries.length === 0 && (u.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), k(h));
      }
    }
    function Od(u) {
      d(function() {
        return wi(u);
      });
    }
    function Eu(u, h) {
      if (u.status === jl) {
        u.status = ha, y(h, u.fatalError);
        return;
      }
      if (u.status !== ha && u.destination === null) {
        u.destination = h;
        try {
          Vo(u, h);
        } catch (L) {
          vr(u, L), Xr(u, L);
        }
      }
    }
    function Wo(u, h) {
      try {
        var L = u.abortableTasks;
        L.forEach(function(F) {
          return $o(F, u, h);
        }), L.clear(), u.destination !== null && Vo(u, u.destination);
      } catch (F) {
        vr(u, F), Xr(u, F);
      }
    }
    function Fd(u, h) {
      return new Promise(function(L, F) {
        var Y, le, he = new Promise(function($, ne) {
          le = $, Y = ne;
        });
        function Le() {
          var $ = new ReadableStream(
            {
              type: "bytes",
              pull: function(ne) {
                Eu(f, ne);
              },
              cancel: function(ne) {
                Wo(f);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          $.allReady = he, L($);
        }
        function l($) {
          he.catch(function() {
          }), F($);
        }
        var f = wd(u, Yt(h ? h.identifierPrefix : void 0, h ? h.nonce : void 0, h ? h.bootstrapScriptContent : void 0, h ? h.bootstrapScripts : void 0, h ? h.bootstrapModules : void 0), Ze(h ? h.namespaceURI : void 0), h ? h.progressiveChunkSize : void 0, h ? h.onError : void 0, le, Le, l, Y);
        if (h && h.signal) {
          var w = h.signal, R = function() {
            Wo(f, w.reason), w.removeEventListener("abort", R);
          };
          w.addEventListener("abort", R);
        }
        Od(f);
      });
    }
    $u.renderToReadableStream = Fd, $u.version = t;
  }()), $u;
}
var ji, If;
process.env.NODE_ENV === "production" ? (ji = uS(), If = cS()) : (ji = dS(), If = fS());
Xa.version = ji.version;
Xa.renderToString = ji.renderToString;
Xa.renderToStaticMarkup = ji.renderToStaticMarkup;
Xa.renderToNodeStream = ji.renderToNodeStream;
Xa.renderToStaticNodeStream = ji.renderToStaticNodeStream;
Xa.renderToReadableStream = If.renderToReadableStream;
const pS = ({ width: e, height: t, runtime: r }) => {
  var ke, De, pe, Be, qe, Pe, ve, $e;
  const { config: a } = ie.useContext(Et), { sankey: i } = a, o = (z) => z.visualizationType === "Sankey", [d, c] = ie.useState(0), s = ie.useRef([]), [p, m] = ie.useState(""), [v, g] = ie.useState(!1), A = (z) => {
    const Re = p;
    Re && m(""), Re !== z && m(z);
  };
  ie.useEffect(() => {
    window.innerWidth < 768 && window.innerHeight > window.innerWidth && g(!0);
  }, [window.innerWidth]);
  const k = () => {
    g(!1);
  };
  if (ie.useEffect(() => {
    var Re;
    let z = 0;
    (Re = s == null ? void 0 : s.current) == null || Re.map((be) => {
      const He = be == null ? void 0 : be.getBoundingClientRect().width;
      He > z && (z = He);
    }), c(z);
  }, [s, i, window.innerWidth]), !o(a))
    return;
  const E = a == null ? void 0 : a.data[0], T = Array.from(new Set((ke = E == null ? void 0 : E.links) == null ? void 0 : ke.flatMap((z) => [z.source, z.target]))), b = {
    nodes: T.map((z) => ({ id: z })),
    links: (De = E == null ? void 0 : E.links) == null ? void 0 : De.map((z) => ({
      source: T.findIndex((Re) => Re === z.source),
      target: T.findIndex((Re) => Re === z.target),
      value: z.value
    }))
  };
  let y = 5;
  const N = 50, C = iS().nodeWidth(i.nodeSize.nodeWidth).nodePadding(i.nodePadding).iterations(i.iterations).nodeAlign(eS).extent([
    [i.margin.margin_x, Number(i.margin.margin_y)],
    [e - y - d, a.heights.vertical - N]
  ]), { nodes: P, links: O } = C(b), K = (z) => {
    var Oe;
    let Re = 30, be = 0, He = "node-value--storynode", Ve = !0;
    return (Oe = E == null ? void 0 : E.storyNodeText) != null && Oe.every((Ge) => Ge.StoryNode !== z) && (Ve = !1, be = 10, Re = 8, He = "node-value"), { textPositionHorizontal: Re, textPositionVertical: be, classStyle: He, storyNodes: Ve };
  }, W = (z) => {
    if (!(b != null && b.nodes))
      return { sourceNodes: [], activeLinks: [] };
    const Re = b.nodes.find((Ve) => Ve.id === z), be = [], He = [];
    return Re && (O.forEach((Ve) => {
      const Oe = Ve.target, Ge = Ve.source;
      Oe.id === z && be.push(Ge.id);
    }), be.forEach((Ve) => {
      O.forEach((Oe) => {
        const Ge = Oe.target, Xe = Oe.source;
        Ge.id === p && Xe.id === Ve && He.push(Oe);
      });
    })), { sourceNodes: be, activeLinks: He };
  }, J = `${(((pe = E == null ? void 0 : E.tooltips) == null ? void 0 : pe.find((z) => z.node === p)) || {}).value}`, j = `${(((Be = E == null ? void 0 : E.tooltips) == null ? void 0 : Be.find((z) => z.node === p)) || {}).summary}`, B = (((qe = E == null ? void 0 : E.tooltips) == null ? void 0 : qe.find((z) => z.node === p)) || {}).column1Label, Z = (((Pe = E == null ? void 0 : E.tooltips) == null ? void 0 : Pe.find((z) => z.node === p)) || {}).column2Label, te = (((ve = E == null ? void 0 : E.tooltips) == null ? void 0 : ve.find((z) => z.node === p)) || {}).column1, V = ((($e = E == null ? void 0 : E.tooltips) == null ? void 0 : $e.find((z) => z.node === p)) || {}).column2, ee = ({ columnData: z }) => /* @__PURE__ */ n.createElement("ul", null, z == null ? void 0 : z.map((Re, be) => /* @__PURE__ */ n.createElement("li", { key: be }, Re.label, ": ", Re.value, " (", Re.additional_info, "%)"))), ce = Xa.renderToString(/* @__PURE__ */ n.createElement(ee, { columnData: te })), re = Xa.renderToString(/* @__PURE__ */ n.createElement(ee, { columnData: V })), G = `<div class="sankey-chart__tooltip">
                    <span class="sankey-chart__tooltip--tooltip-header">${p}</span>
                    <span class="sankey-chart__tooltip--tooltip-header">${J}</span>
                    <div class="divider"></div>
                    <span><strong>Summary: </strong>${j}</span>
                    <div class="divider"></div>
                      <div class="sankey-chart__tooltip--info-section">
                        <div>
                          <span><strong>${B}<strong></span>
                          ${ce}
                        </div>
                        <div>
                          <span><strong>${Z}<strong></span>
                          ${re}
                        </div>
                      </div>
                    </div>`, U = b.nodes.map((z, Re) => {
    var Ue, ze;
    let { textPositionHorizontal: be, textPositionVertical: He, classStyle: Ve, storyNodes: Oe } = K(z.id), { sourceNodes: Ge } = W(p), Xe = i.opacity.nodeOpacityDefault, rt = i.nodeColor.default;
    return p !== z.id && p !== "" && !Ge.includes(z.id) && (rt = i.nodeColor.inactive, Xe = i.opacity.nodeOpacityInactive), /* @__PURE__ */ n.createElement(st, { className: "", key: Re }, /* @__PURE__ */ n.createElement(
      "rect",
      {
        height: z.y1 - z.y0 + 2,
        width: C.nodeWidth(),
        x: z.x0,
        y: z.y0 - 1,
        fill: rt,
        fillOpacity: Xe,
        rx: i.rxValue,
        "data-tooltip-html": E.tooltips && a.enableTooltips && p !== "" ? G : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
        onClick: () => A(z.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), Oe ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      St,
      {
        x: z.x0 + be,
        textAnchor: b.nodes.length - 1 === Re ? "end" : "start",
        verticalAnchor: "end",
        y: (z.y1 + z.y0) / 2 - 30,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        className: "node-text",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => A(z.id),
        "data-tooltip-html": E.tooltips && a.enableTooltips && p !== "" ? G : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      (((Ue = E == null ? void 0 : E.storyNodeText) == null ? void 0 : Ue.find((Ne) => Ne.StoryNode === z.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ n.createElement(
      St,
      {
        verticalAnchor: "end",
        className: Ve,
        x: z.x0 + be,
        y: (z.y1 + z.y0 + 25) / 2,
        fill: i.storyNodeFontColor || i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => A(z.id),
        "data-tooltip-html": E.tooltips && a.enableTooltips && p !== "" ? G : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      typeof z.value == "number" ? z.value.toLocaleString() : z.value
    ), /* @__PURE__ */ n.createElement(
      St,
      {
        x: z.x0 + be,
        y: (z.y1 + z.y0) / 2 + 50,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: b.nodes.length === Re ? "end" : "start",
        className: "node-text",
        verticalAnchor: "end",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => A(z.id),
        "data-tooltip-html": E.tooltips && a.enableTooltips && p !== "" ? G : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      (((ze = E == null ? void 0 : E.storyNodeText) == null ? void 0 : ze.find((Ne) => Ne.StoryNode === z.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      St,
      {
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => A(z.id),
        "data-tooltip-html": E.tooltips && a.enableTooltips && p !== "" ? G : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`,
        x: z.x0 + be,
        y: (z.y1 + z.y0) / 2 + He,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start"
      },
      z.id
    ), /* @__PURE__ */ n.createElement(
      "text",
      {
        x: z.x0 + be,
        y: (z.y1 + z.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => A(z.id),
        "data-tooltip-html": E.tooltips && a.enableTooltips && p !== "" ? G : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      },
      /* @__PURE__ */ n.createElement("tspan", { className: Ve }, i.nodeValueStyle.textBefore + (typeof z.value == "number" ? z.value.toLocaleString() : z.value) + i.nodeValueStyle.textAfter)
    )));
  }), q = O.map((z, Re) => {
    const He = sS()(z);
    let Ve = i.opacity.LinkOpacityDefault, Oe = i.linkColor.default, { activeLinks: Ge } = W(p);
    return !Ge.includes(z) && p !== "" && (Oe = i.linkColor.inactive, Ve = i.opacity.LinkOpacityInactive), /* @__PURE__ */ n.createElement(
      "path",
      {
        key: Re,
        d: He,
        stroke: Oe,
        fill: "none",
        strokeOpacity: Ve,
        strokeWidth: z.width + 2,
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => A(z.target.id || null),
        "data-tooltip-html": E.tooltips && a.enableTooltips && p !== "" ? G : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.uniqueId}-sankey`
      }
    );
  }), H = b.nodes.reduce((z, Re) => Math.max(z, Re.depth), -1), ue = b.nodes.filter((z) => z.depth === H).map((z, Re) => {
    var Ue, ze;
    let { textPositionHorizontal: be, textPositionVertical: He, classStyle: Ve, storyNodes: Oe } = K(z.id), { sourceNodes: Ge } = W(p), Xe = i.opacity.nodeOpacityDefault, rt = i.nodeColor.default;
    return p !== z.id && p !== "" && !Ge.includes(z.id) && (rt = i.nodeColor.inactive, Xe = i.opacity.nodeOpacityInactive), /* @__PURE__ */ n.createElement(st, { className: "", key: Re, innerRef: (Ne) => s.current[Re] = Ne }, /* @__PURE__ */ n.createElement(
      "rect",
      {
        height: z.y1 - z.y0 + 2,
        width: C.nodeWidth(),
        x: z.x0,
        y: z.y0 - 1,
        fill: rt,
        fillOpacity: Xe,
        rx: i.rxValue,
        "data-tooltip-html": E.tooltips && a.enableTooltips && p !== "" ? G : null,
        "data-tooltip-id": "tooltip",
        onClick: () => A(z.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), Oe ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      St,
      {
        x: z.x0 + be,
        textAnchor: b.nodes.length - 1 === Re ? "end" : "start",
        verticalAnchor: "end",
        y: (z.y1 + z.y0) / 2 - 30,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        style: { pointerEvents: "none" },
        className: "node-text"
      },
      (((Ue = E == null ? void 0 : E.storyNodeText) == null ? void 0 : Ue.find((Ne) => Ne.StoryNode === z.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ n.createElement(St, { verticalAnchor: "end", className: Ve, x: z.x0 + be, y: (z.y1 + z.y0 + 25) / 2, fill: i.storyNodeFontColor || i.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, typeof z.value == "number" ? z.value.toLocaleString() : z.value), /* @__PURE__ */ n.createElement(
      St,
      {
        x: z.x0 + be,
        y: (z.y1 + z.y0) / 2 + 50,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: b.nodes.length === Re ? "end" : "start",
        style: { pointerEvents: "none" },
        className: "node-text",
        verticalAnchor: "end"
      },
      (((ze = E == null ? void 0 : E.storyNodeText) == null ? void 0 : ze.find((Ne) => Ne.StoryNode === z.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("text", { x: z.x0 + be, y: (z.y1 + z.y0) / 2 + He, dominantBaseline: "text-before-edge", fill: i.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, /* @__PURE__ */ n.createElement("tspan", { id: z.id, className: "node-id" }, z.id)), /* @__PURE__ */ n.createElement(
      "text",
      {
        x: z.x0 + be,
        y: (z.y1 + z.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ n.createElement("tspan", { onClick: () => A(z.id), className: Ve }, i.nodeValueStyle.textBefore + (typeof z.value == "number" ? z.value.toLocaleString() : z.value) + i.nodeValueStyle.textAfter)
    )));
  });
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: "sankey-chart" }, /* @__PURE__ */ n.createElement("svg", { className: "sankey-chart__diagram", width: e, height: Number(a.heights.vertical), style: { overflow: "visible" } }, /* @__PURE__ */ n.createElement(st, { className: "links" }, q), /* @__PURE__ */ n.createElement(st, { className: "nodes" }, U), /* @__PURE__ */ n.createElement(st, { className: "finalNodes", style: { display: "none" } }, ue)), /* @__PURE__ */ n.createElement(xc, { id: `cdc-open-viz-tooltip-${r.uniqueId}-sankey`, afterHide: () => m(""), events: ["click"], place: "bottom", style: { backgroundColor: "rgba(238, 238, 238, 1)", color: "black", boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)" } }), v && /* @__PURE__ */ n.createElement("div", { className: "popup" }, /* @__PURE__ */ n.createElement("div", { className: "popup-content" }, /* @__PURE__ */ n.createElement("button", { className: "visually-hidden", onClick: k }, "Select for accessible version."), /* @__PURE__ */ n.createElement("p", null, /* @__PURE__ */ n.createElement("strong", null, "Please change the orientation of your screen or increase the size of your browser to view the diagram better."))))));
};
var hS = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const hr = hS;
function mS(e) {
  var t = e.labelOffset, r = e.labelProps, a = e.orientation, i = e.range, o = e.tickLabelFontSize, d = e.tickLength, c = a === hr.left || a === hr.top ? -1 : 1, s, p, m;
  if (a === hr.top || a === hr.bottom) {
    var v = a === hr.bottom && typeof r.fontSize == "number" ? r.fontSize : 0;
    s = (Number(i[0]) + Number(i[i.length - 1])) / 2, p = c * (d + t + o + v);
  } else
    s = c * ((Number(i[0]) + Number(i[i.length - 1])) / 2), p = -(d + t), m = "rotate(" + c * 90 + ")";
  return {
    x: s,
    y: p,
    transform: m
  };
}
function vs() {
  return vs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, vs.apply(this, arguments);
}
function yS(e) {
  var t = e.hideTicks, r = e.horizontal, a = e.orientation, i = e.tickClassName, o = e.tickComponent, d = e.tickLabelProps, c = e.tickStroke, s = c === void 0 ? "#222" : c, p = e.tickTransform, m = e.ticks, v = e.strokeWidth, g = e.tickLineProps;
  return m.map(function(A) {
    var k, E = A.value, T = A.index, b = A.from, y = A.to, N = A.formattedValue, C = (k = d[T]) != null ? k : {}, P = Math.max(10, typeof C.fontSize == "number" && C.fontSize || 0), O = y.y + (r && a !== hr.top ? P : 0);
    return /* @__PURE__ */ n.createElement(st, {
      key: "visx-tick-" + E + "-" + T,
      className: _n("visx-axis-tick", i),
      transform: p
    }, !t && /* @__PURE__ */ n.createElement(mn, vs({
      from: b,
      to: y,
      stroke: s,
      strokeWidth: v,
      strokeLinecap: "square"
    }, g)), o ? o(vs({}, C, {
      x: y.x,
      y: O,
      formattedValue: N
    })) : /* @__PURE__ */ n.createElement(St, vs({
      x: y.x,
      y: O
    }, C), N));
  });
}
function Ec() {
  return Ec = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ec.apply(this, arguments);
}
var tm = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function gS(e) {
  var t = e.axisFromPoint, r = e.axisLineClassName, a = e.axisToPoint, i = e.hideAxisLine, o = e.hideTicks, d = e.horizontal, c = e.label, s = c === void 0 ? "" : c, p = e.labelClassName, m = e.labelOffset, v = m === void 0 ? 14 : m, g = e.labelProps, A = g === void 0 ? tm : g, k = e.orientation, E = k === void 0 ? hr.bottom : k, T = e.scale, b = e.stroke, y = b === void 0 ? "#222" : b, N = e.strokeDasharray, C = e.strokeWidth, P = C === void 0 ? 1 : C, O = e.tickClassName, K = e.tickComponent, W = e.tickLineProps, J = e.tickLabelProps, j = e.tickLength, B = j === void 0 ? 8 : j, Z = e.tickStroke, te = Z === void 0 ? "#222" : Z, V = e.tickTransform, ee = e.ticks, ce = e.ticksComponent, re = ce === void 0 ? yS : ce, G = Ec({}, tm, typeof J == "object" ? J : null), U = ee.map(function(H) {
    var oe = H.value, ue = H.index;
    return typeof J == "function" ? J(oe, ue, ee) : G;
  }), q = Math.max.apply(Math, [10].concat(U.map(function(H) {
    return typeof H.fontSize == "number" ? H.fontSize : 0;
  })));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, re({
    hideTicks: o,
    horizontal: d,
    orientation: E,
    scale: T,
    tickClassName: O,
    tickComponent: K,
    tickLabelProps: U,
    tickStroke: te,
    tickTransform: V,
    ticks: ee,
    strokeWidth: P,
    tickLineProps: W
  }), !i && /* @__PURE__ */ n.createElement(mn, {
    className: _n("visx-axis-line", r),
    from: t,
    to: a,
    stroke: y,
    strokeWidth: P,
    strokeDasharray: N
  }), s && /* @__PURE__ */ n.createElement(St, Ec({
    className: _n("visx-axis-label", p)
  }, mS({
    labelOffset: v,
    labelProps: A,
    orientation: E,
    range: T.range(),
    tickLabelFontSize: q,
    tickLength: B
  }), A), s));
}
function vS(e, t) {
  t === void 0 && (t = "center");
  var r = e;
  if (t !== "start" && "bandwidth" in r) {
    var a = r.bandwidth();
    return t === "center" && (a /= 2), r.round() && (a = Math.round(a)), function(i) {
      var o = r(i);
      return typeof o == "number" ? o + a : o;
    };
  }
  return e;
}
function xS(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : Ov;
}
function Iu(e, t) {
  var r = e.x, a = e.y;
  return new Eg(t ? {
    x: r,
    y: a
  } : {
    x: a,
    y: r
  });
}
function Hf() {
  return Hf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Hf.apply(this, arguments);
}
var ef = 0;
function bS(e) {
  return e === void 0 && (e = ef), typeof e == "number" ? {
    start: e,
    end: e
  } : Hf({
    start: ef,
    end: ef
  }, e);
}
var ES = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Vf() {
  return Vf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Vf.apply(this, arguments);
}
function SS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function $c(e) {
  var t = e.children, r = t === void 0 ? gS : t, a = e.axisClassName, i = e.hideAxisLine, o = i === void 0 ? !1 : i, d = e.hideTicks, c = d === void 0 ? !1 : d, s = e.hideZero, p = s === void 0 ? !1 : s, m = e.innerRef, v = e.left, g = v === void 0 ? 0 : v, A = e.numTicks, k = A === void 0 ? 10 : A, E = e.orientation, T = E === void 0 ? hr.bottom : E, b = e.rangePadding, y = b === void 0 ? 0 : b, N = e.scale, C = e.tickFormat, P = e.tickLength, O = P === void 0 ? 8 : P, K = e.tickValues, W = e.top, J = W === void 0 ? 0 : W, j = SS(e, ES), B = C ?? xS(N), Z = T === hr.left, te = T === hr.top, V = te || T === hr.bottom, ee = vS(N), ce = Z || te ? -1 : 1, re = N.range(), G = bS(y), U = Iu({
    x: Number(re[0]) + 0.5 - G.start,
    y: 0
  }, V), q = Iu({
    x: Number(re[re.length - 1]) + 0.5 + G.end,
    y: 0
  }, V), H = (K ?? _v(N, k)).filter(function(ue) {
    return !p || ue !== 0 && ue !== "0";
  }).map(function(ue, ke) {
    return {
      value: ue,
      index: ke
    };
  }), oe = H.map(function(ue) {
    var ke = ue.value, De = ue.index, pe = Dv(ee(ke));
    return {
      value: ke,
      index: De,
      from: Iu({
        x: pe,
        y: 0
      }, V),
      to: Iu({
        x: pe,
        y: O * ce
      }, V),
      formattedValue: B(ke, De, H)
    };
  });
  return /* @__PURE__ */ n.createElement(st, {
    className: _n("visx-axis", a),
    innerRef: m,
    top: J,
    left: g
  }, r(Vf({}, j, {
    axisFromPoint: U,
    axisToPoint: q,
    hideAxisLine: o,
    hideTicks: c,
    hideZero: p,
    horizontal: V,
    numTicks: k,
    orientation: T,
    rangePadding: y,
    scale: N,
    tickFormat: B,
    tickLength: O,
    tickPosition: ee,
    tickSign: ce,
    ticks: oe
  })));
}
var kS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Sc() {
  return Sc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Sc.apply(this, arguments);
}
function wS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var TS = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function nm(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 36 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = wS(e, kS), s = typeof d == "function" ? d : Sc({}, TS, d);
  return /* @__PURE__ */ n.createElement($c, Sc({
    axisClassName: _n("visx-axis-left", t),
    labelOffset: a,
    orientation: hr.left,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var CS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function kc() {
  return kc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, kc.apply(this, arguments);
}
function AS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var LS = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function PS(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 36 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = AS(e, CS), s = typeof d == "function" ? d : kc({}, LS, d);
  return /* @__PURE__ */ n.createElement($c, kc({
    axisClassName: _n("visx-axis-right", t),
    labelOffset: a,
    orientation: hr.right,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var NS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function wc() {
  return wc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, wc.apply(this, arguments);
}
function RS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var DS = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function _S(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 8 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = RS(e, NS), s = typeof d == "function" ? d : wc({}, DS, d);
  return /* @__PURE__ */ n.createElement($c, wc({
    axisClassName: _n("visx-axis-top", t),
    labelOffset: a,
    orientation: hr.top,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
var OS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Tc() {
  return Tc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Tc.apply(this, arguments);
}
function FS(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var MS = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function qu(e) {
  var t = e.axisClassName, r = e.labelOffset, a = r === void 0 ? 8 : r, i = e.tickLength, o = i === void 0 ? 8 : i, d = e.tickLabelProps, c = FS(e, OS), s = typeof d == "function" ? d : Tc({}, MS, d);
  return /* @__PURE__ */ n.createElement($c, Tc({
    axisClassName: _n("visx-axis-bottom", t),
    labelOffset: a,
    orientation: hr.bottom,
    tickLabelProps: s,
    tickLength: o
  }, c));
}
const tf = (e) => () => e;
function zS(e, {
  sourceEvent: t,
  target: r,
  selection: a,
  mode: i,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    selection: { value: a, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function BS(e) {
  e.stopImmediatePropagation();
}
function nf(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var rm = { name: "drag" }, rf = { name: "space" }, qo = { name: "handle" }, Go = { name: "center" };
const { abs: am, max: rr, min: ar } = Math;
function im(e) {
  return [+e[0], +e[1]];
}
function om(e) {
  return [im(e[0]), im(e[1])];
}
var Gu = {
  name: "x",
  handles: ["w", "e"].map(Cc),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, af = {
  name: "y",
  handles: ["n", "s"].map(Cc),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, ma = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, lm = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, sm = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, $S = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, IS = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Cc(e) {
  return { type: e };
}
function HS(e) {
  return !e.ctrlKey && !e.button;
}
function VS() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function WS() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function of(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function jS(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function US() {
  return KS(Gu);
}
function KS(e) {
  var t = VS, r = HS, a = WS, i = !0, o = Sg("start", "brush", "end"), d = 6, c;
  function s(T) {
    var b = T.property("__brush", E).selectAll(".overlay").data([Cc("overlay")]);
    b.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", ma.overlay).merge(b).each(function() {
      var N = of(this).extent;
      Zo(this).attr("x", N[0][0]).attr("y", N[0][1]).attr("width", N[1][0] - N[0][0]).attr("height", N[1][1] - N[0][1]);
    }), T.selectAll(".selection").data([Cc("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", ma.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var y = T.selectAll(".handle").data(e.handles, function(N) {
      return N.type;
    });
    y.exit().remove(), y.enter().append("rect").attr("class", function(N) {
      return "handle handle--" + N.type;
    }).attr("cursor", function(N) {
      return ma[N.type];
    }), T.each(p).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", g).filter(a).on("touchstart.brush", g).on("touchmove.brush", A).on("touchend.brush touchcancel.brush", k).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  s.move = function(T, b, y) {
    T.tween ? T.on("start.brush", function(N) {
      m(this, arguments).beforestart().start(N);
    }).on("interrupt.brush end.brush", function(N) {
      m(this, arguments).end(N);
    }).tween("brush", function() {
      var N = this, C = N.__brush, P = m(N, arguments), O = C.selection, K = e.input(typeof b == "function" ? b.apply(this, arguments) : b, C.extent), W = Qg(O, K);
      function J(j) {
        C.selection = j === 1 && K === null ? null : W(j), p.call(N), P.brush();
      }
      return O !== null && K !== null ? J : J(1);
    }) : T.each(function() {
      var N = this, C = arguments, P = N.__brush, O = e.input(typeof b == "function" ? b.apply(N, C) : b, P.extent), K = m(N, C).beforestart();
      Rp(N), P.selection = O === null ? null : O, p.call(N), K.start(y).brush(y).end(y);
    });
  }, s.clear = function(T, b) {
    s.move(T, null, b);
  };
  function p() {
    var T = Zo(this), b = of(this).selection;
    b ? (T.selectAll(".selection").style("display", null).attr("x", b[0][0]).attr("y", b[0][1]).attr("width", b[1][0] - b[0][0]).attr("height", b[1][1] - b[0][1]), T.selectAll(".handle").style("display", null).attr("x", function(y) {
      return y.type[y.type.length - 1] === "e" ? b[1][0] - d / 2 : b[0][0] - d / 2;
    }).attr("y", function(y) {
      return y.type[0] === "s" ? b[1][1] - d / 2 : b[0][1] - d / 2;
    }).attr("width", function(y) {
      return y.type === "n" || y.type === "s" ? b[1][0] - b[0][0] + d : d;
    }).attr("height", function(y) {
      return y.type === "e" || y.type === "w" ? b[1][1] - b[0][1] + d : d;
    })) : T.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function m(T, b, y) {
    var N = T.__brush.emitter;
    return N && (!y || !N.clean) ? N : new v(T, b, y);
  }
  function v(T, b, y) {
    this.that = T, this.args = b, this.state = T.__brush, this.active = 0, this.clean = y;
  }
  v.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(T, b) {
      return this.starting ? (this.starting = !1, this.emit("start", T, b)) : this.emit("brush", T), this;
    },
    brush: function(T, b) {
      return this.emit("brush", T, b), this;
    },
    end: function(T, b) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", T, b)), this;
    },
    emit: function(T, b, y) {
      var N = Zo(this.that).datum();
      o.call(
        T,
        this.that,
        new zS(T, {
          sourceEvent: b,
          target: s,
          selection: e.output(this.state.selection),
          mode: y,
          dispatch: o
        }),
        N
      );
    }
  };
  function g(T) {
    if (c && !T.touches || !r.apply(this, arguments))
      return;
    var b = this, y = T.target.__data__.type, N = (i && T.metaKey ? y = "overlay" : y) === "selection" ? rm : i && T.altKey ? Go : qo, C = e === af ? null : $S[y], P = e === Gu ? null : IS[y], O = of(b), K = O.extent, W = O.selection, J = K[0][0], j, B, Z = K[0][1], te, V, ee = K[1][0], ce, re, G = K[1][1], U, q, H = 0, oe = 0, ue, ke = C && P && i && T.shiftKey, De, pe, Be = Array.from(T.touches || [T], (Oe) => {
      const Ge = Oe.identifier;
      return Oe = Dp(Oe, b), Oe.point0 = Oe.slice(), Oe.identifier = Ge, Oe;
    });
    Rp(b);
    var qe = m(b, arguments, !0).beforestart();
    if (y === "overlay") {
      W && (ue = !0);
      const Oe = [Be[0], Be[1] || Be[0]];
      O.selection = W = [[
        j = e === af ? J : ar(Oe[0][0], Oe[1][0]),
        te = e === Gu ? Z : ar(Oe[0][1], Oe[1][1])
      ], [
        ce = e === af ? ee : rr(Oe[0][0], Oe[1][0]),
        U = e === Gu ? G : rr(Oe[0][1], Oe[1][1])
      ]], Be.length > 1 && Re(T);
    } else
      j = W[0][0], te = W[0][1], ce = W[1][0], U = W[1][1];
    B = j, V = te, re = ce, q = U;
    var Pe = Zo(b).attr("pointer-events", "none"), ve = Pe.selectAll(".overlay").attr("cursor", ma[y]);
    if (T.touches)
      qe.moved = z, qe.ended = be;
    else {
      var $e = Zo(T.view).on("mousemove.brush", z, !0).on("mouseup.brush", be, !0);
      i && $e.on("keydown.brush", He, !0).on("keyup.brush", Ve, !0), kg(T.view);
    }
    p.call(b), qe.start(T, N.name);
    function z(Oe) {
      for (const Ge of Oe.changedTouches || [Oe])
        for (const Xe of Be)
          Xe.identifier === Ge.identifier && (Xe.cur = Dp(Ge, b));
      if (ke && !De && !pe && Be.length === 1) {
        const Ge = Be[0];
        am(Ge.cur[0] - Ge[0]) > am(Ge.cur[1] - Ge[1]) ? pe = !0 : De = !0;
      }
      for (const Ge of Be)
        Ge.cur && (Ge[0] = Ge.cur[0], Ge[1] = Ge.cur[1]);
      ue = !0, nf(Oe), Re(Oe);
    }
    function Re(Oe) {
      const Ge = Be[0], Xe = Ge.point0;
      var rt;
      switch (H = Ge[0] - Xe[0], oe = Ge[1] - Xe[1], N) {
        case rf:
        case rm: {
          C && (H = rr(J - j, ar(ee - ce, H)), B = j + H, re = ce + H), P && (oe = rr(Z - te, ar(G - U, oe)), V = te + oe, q = U + oe);
          break;
        }
        case qo: {
          Be[1] ? (C && (B = rr(J, ar(ee, Be[0][0])), re = rr(J, ar(ee, Be[1][0])), C = 1), P && (V = rr(Z, ar(G, Be[0][1])), q = rr(Z, ar(G, Be[1][1])), P = 1)) : (C < 0 ? (H = rr(J - j, ar(ee - j, H)), B = j + H, re = ce) : C > 0 && (H = rr(J - ce, ar(ee - ce, H)), B = j, re = ce + H), P < 0 ? (oe = rr(Z - te, ar(G - te, oe)), V = te + oe, q = U) : P > 0 && (oe = rr(Z - U, ar(G - U, oe)), V = te, q = U + oe));
          break;
        }
        case Go: {
          C && (B = rr(J, ar(ee, j - H * C)), re = rr(J, ar(ee, ce + H * C))), P && (V = rr(Z, ar(G, te - oe * P)), q = rr(Z, ar(G, U + oe * P)));
          break;
        }
      }
      re < B && (C *= -1, rt = j, j = ce, ce = rt, rt = B, B = re, re = rt, y in lm && ve.attr("cursor", ma[y = lm[y]])), q < V && (P *= -1, rt = te, te = U, U = rt, rt = V, V = q, q = rt, y in sm && ve.attr("cursor", ma[y = sm[y]])), O.selection && (W = O.selection), De && (B = W[0][0], re = W[1][0]), pe && (V = W[0][1], q = W[1][1]), (W[0][0] !== B || W[0][1] !== V || W[1][0] !== re || W[1][1] !== q) && (O.selection = [[B, V], [re, q]], p.call(b), qe.brush(Oe, N.name));
    }
    function be(Oe) {
      if (BS(Oe), Oe.touches) {
        if (Oe.touches.length)
          return;
        c && clearTimeout(c), c = setTimeout(function() {
          c = null;
        }, 500);
      } else
        wg(Oe.view, ue), $e.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      Pe.attr("pointer-events", "all"), ve.attr("cursor", ma.overlay), O.selection && (W = O.selection), jS(W) && (O.selection = null, p.call(b)), qe.end(Oe, N.name);
    }
    function He(Oe) {
      switch (Oe.keyCode) {
        case 16: {
          ke = C && P;
          break;
        }
        case 18: {
          N === qo && (C && (ce = re - H * C, j = B + H * C), P && (U = q - oe * P, te = V + oe * P), N = Go, Re(Oe));
          break;
        }
        case 32: {
          (N === qo || N === Go) && (C < 0 ? ce = re - H : C > 0 && (j = B - H), P < 0 ? U = q - oe : P > 0 && (te = V - oe), N = rf, ve.attr("cursor", ma.selection), Re(Oe));
          break;
        }
        default:
          return;
      }
      nf(Oe);
    }
    function Ve(Oe) {
      switch (Oe.keyCode) {
        case 16: {
          ke && (De = pe = ke = !1, Re(Oe));
          break;
        }
        case 18: {
          N === Go && (C < 0 ? ce = re : C > 0 && (j = B), P < 0 ? U = q : P > 0 && (te = V), N = qo, Re(Oe));
          break;
        }
        case 32: {
          N === rf && (Oe.altKey ? (C && (ce = re - H * C, j = B + H * C), P && (U = q - oe * P, te = V + oe * P), N = Go) : (C < 0 ? ce = re : C > 0 && (j = B), P < 0 ? U = q : P > 0 && (te = V), N = qo), ve.attr("cursor", ma[y]), Re(Oe));
          break;
        }
        default:
          return;
      }
      nf(Oe);
    }
  }
  function A(T) {
    m(this, arguments).moved(T);
  }
  function k(T) {
    m(this, arguments).ended(T);
  }
  function E() {
    var T = this.__brush || { selection: null };
    return T.extent = om(t.apply(this, arguments)), T.dim = e, T;
  }
  return s.extent = function(T) {
    return arguments.length ? (t = typeof T == "function" ? T : tf(om(T)), s) : t;
  }, s.filter = function(T) {
    return arguments.length ? (r = typeof T == "function" ? T : tf(!!T), s) : r;
  }, s.touchable = function(T) {
    return arguments.length ? (a = typeof T == "function" ? T : tf(!!T), s) : a;
  }, s.handleSize = function(T) {
    return arguments.length ? (d = +T, s) : d;
  }, s.keyModifiers = function(T) {
    return arguments.length ? (i = !!T, s) : i;
  }, s.on = function() {
    var T = o.on.apply(o, arguments);
    return T === o ? s : T;
  }, s;
}
const YS = ({ xMax: e, yMax: t }) => {
  var B, Z;
  const { tableData: r, config: a, setBrushConfig: i, dashboardConfig: o, formatDate: d } = ie.useContext(Et), [c, s] = ie.useState({ isBrushing: !1, selection: [] }), [p, m] = ie.useState(0), v = ((B = o == null ? void 0 : o.dashboard) == null ? void 0 : B.sharedFilters) ?? [], g = (v == null ? void 0 : v.length) > 0, [A, k] = ie.useState(!1), E = ie.useRef(), T = 25, b = 15, y = Tg(r, (te) => new Date(te[a.runtime.originalXAxis.dataKey])), N = Hm().domain(y).range([0, e]), P = Kn("Drag edges to focus on a specific segment ", `normal ${16 / 1.1}px sans-serif`), O = () => Number(t) + a.xAxis.axisBBox + T * 1.5, K = () => {
    c.selection[0] === 0 && e === c.selection[1] && k(!0);
  }, W = () => {
    (c.selection[0] !== 0 || c.selection[1] !== e) && k(!1), k(!1);
  }, J = (te, V, ee, ce) => {
    const re = Kn(ee, `normal ${14.545454545454545}px sans-serif`);
    return te.selectAll(".handle--custom").data([{ side: "left" }, { side: "right" }]).join((G) => {
      const U = G.append("g").attr("class", "handle--custom");
      return U.append("text").attr("x", (q) => q.side === "left" ? 0 : -re).attr("y", 30).text((q) => q.side === "left" ? ee : ce).attr("font-size", "13px"), U;
    }).attr("display", "block").attr("transform", V === null ? null : (G, U) => `translate(${V[U]},10)`);
  }, j = () => {
    const te = Zo(E.current).attr("overflow", "visible");
    te.append("rect").attr("fill", "#949494").attr("stroke", "#c5c5c5").attr("stroke-width", 2).attr("ry", b).attr("rx", b).attr("height", T).attr("width", e);
    const V = (G) => {
      var pe, Be, qe, Pe;
      const U = G == null ? void 0 : G.selection;
      let q = G.type === "brush" && U && U.length > 0;
      const [H, oe] = U.map((ve) => N.invert(ve)), ue = r.filter((ve) => {
        const $e = ve[a.runtime.originalXAxis.dataKey];
        if (!$e)
          return !1;
        const z = new Date($e);
        if (isNaN(z.getTime()))
          return !1;
        if (z >= H && z <= oe)
          return !0;
      }), ke = (ue.length && ue[0][(Be = (pe = a == null ? void 0 : a.runtime) == null ? void 0 : pe.originalXAxis) == null ? void 0 : Be.dataKey]) ?? "", De = (ue.length && ue[ue.length - 1][(Pe = (qe = a == null ? void 0 : a.runtime) == null ? void 0 : qe.originalXAxis) == null ? void 0 : Pe.dataKey]) ?? "";
      te.selectAll(".handle--custom").remove(), te.call(J, U, ke, De), i({
        active: a.brush.active,
        isBrushing: q,
        data: ue
      }), s({
        isBrushing: !0,
        selection: U
      });
    }, ee = US().extent([
      [0, 0],
      [e, 25]
    ]).on("start brush end", V), ce = [0, e];
    let re = te.append("g").call(ee).call(ee.move, ce);
    re.select(".overlay").style("pointer-events", "none"), re.selectAll(".selection").attr("fill", "#474747").attr("fill-opacity", 1).attr("rx", b).attr("ry", b);
  };
  return ie.useEffect(() => {
    var ee, ce, re;
    const te = (ee = a.filters) == null ? void 0 : ee.some((G) => G.active), V = (ce = a.exclusions) == null ? void 0 : ce.active;
    return (te || V || g) && ((re = a.brush) != null && re.active) && (m((G) => G + 1), i((G) => ({
      ...G,
      data: r
    }))), () => i((G) => ({
      ...G,
      data: []
    }));
  }, [a.filters, a.exclusions, (Z = a.brush) == null ? void 0 : Z.active, g]), ie.useEffect(() => {
    p && j();
  }, [p]), c.isBrushing || j(), /* @__PURE__ */ n.createElement(
    st,
    {
      onMouseLeave: W,
      onMouseOver: K,
      className: "brush-container",
      left: Number(a.runtime.yAxis.size),
      top: O()
    },
    /* @__PURE__ */ n.createElement(
      St,
      {
        pointerEvents: "visiblePainted",
        display: A ? "block" : "none",
        fontSize: 16,
        x: (Number(e) - Number(P)) / 2,
        y: -10
      },
      "Drag edges to focus on a specific segment"
    ),
    /* @__PURE__ */ n.createElement("svg", { width: "100%", height: T * 3, ref: E })
  );
}, xs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: S0,
  curveBasisClosed: k0,
  curveBasisOpen: w0,
  curveBundle: T0,
  curveCardinal: C0,
  curveCardinalClosed: A0,
  curveCardinalOpen: L0,
  curveCatmullRom: P0,
  curveCatmullRomClosed: N0,
  curveCatmullRomOpen: R0,
  curveLinear: Oc,
  curveLinearClosed: wf,
  curveMonotoneX: Xu,
  curveMonotoneY: D0,
  curveNatural: _0,
  curveStep: O0,
  curveStepAfter: M0,
  curveStepBefore: F0
}, Symbol.toStringTag, { value: "Module" })), XS = (e) => {
  var O, K;
  const { xScale: t, yScale: r, yMax: a, xMax: i, handleTooltipMouseOver: o, handleTooltipMouseOff: d, isDebug: c, children: s } = e;
  let { transformedData: p, config: m, handleLineType: v, parseDate: g, formatDate: A, formatNumber: k, seriesHighlight: E, colorScale: T, rawData: b, brushConfig: y } = ie.useContext(Et);
  const N = (O = m.brush) != null && O.active && ((K = y.data) != null && K.length) ? y.data : p;
  if (!N)
    return;
  const C = (W) => (Dn(m.xAxis) ? t(g(W[m.xAxis.dataKey], !1)) : t(W[m.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), P = (W, J, j = void 0) => r(W[j.dataKey]);
  return N && /* @__PURE__ */ n.createElement("svg", null, /* @__PURE__ */ n.createElement(Hr, { component: "AreaChart" }, /* @__PURE__ */ n.createElement(st, { className: "area-chart", key: "area-wrapper", left: Number(m.yAxis.size) }, (m.runtime.areaSeriesKeys || m.series).map((W, J) => {
    let j = N.map((V) => ({
      [m.xAxis.dataKey]: V[m.xAxis.dataKey],
      [W.dataKey]: V[W.dataKey]
    })), B = xs[W.lineType], Z = m.legend.behavior === "highlight" && E.length > 0 && E.indexOf(W.dataKey) === -1, te = m.legend.behavior === "highlight" || E.length === 0 || E.indexOf(W.dataKey) !== -1;
    return /* @__PURE__ */ n.createElement(n.Fragment, { key: J }, /* @__PURE__ */ n.createElement(
      Ir,
      {
        data: j,
        x: (V) => C(V),
        y: (V) => P(V, J, W),
        stroke: te ? T ? T(m.runtime.seriesLabels ? m.runtime.seriesLabels[W.dataKey] : W.dataKey) : "#000" : "transparent",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        curve: B,
        strokeDasharray: W.type ? v(W.type) : 0
      }
    ), /* @__PURE__ */ n.createElement(
      sE,
      {
        key: "area-chart",
        fill: te ? T ? T(m.runtime.seriesLabels ? m.runtime.seriesLabels[W.dataKey] : W.dataKey) : "#000" : "transparent",
        fillOpacity: Z ? 0.25 : 0.5,
        data: j,
        x: (V) => C(V),
        y: (V) => P(V, J, W),
        yScale: r,
        curve: B,
        strokeDasharray: W.type ? v(W.type) : 0
      }
    ));
  }), /* @__PURE__ */ n.createElement(Nr, { width: Number(i), height: Number(a), fill: "transparent", fillOpacity: 0.05, onMouseMove: (W) => o(W, b), onMouseLeave: d }))));
}, qS = ie.memo(XS), GS = ({ xScale: e, yScale: t, yMax: r, xMax: a, handleTooltipMouseOver: i, handleTooltipMouseOff: o, isDebug: d }) => {
  var E, T;
  let { transformedData: c, config: s, seriesHighlight: p, colorScale: m, rawData: v } = ie.useContext(Et);
  const g = (E = s.brush) != null && E.active && ((T = s.brush.data) != null && T.length) ? s.brush.data : c;
  if (!g)
    return;
  const A = (b) => {
    if (s.xAxis.type === "categorical")
      return e(b);
    if (Dn(s.xAxis)) {
      let y = new Date(b);
      return e(y);
    }
  }, k = 2;
  return g && /* @__PURE__ */ n.createElement("svg", { height: Number(r) }, /* @__PURE__ */ n.createElement(Hr, { component: "AreaChartStacked" }, /* @__PURE__ */ n.createElement(st, { className: "area-chart", key: "area-wrapper", left: Number(s.yAxis.size) + k / 2, height: Number(r), style: { overflow: "hidden" } }, /* @__PURE__ */ n.createElement(
    hE,
    {
      data: g,
      keys: s.runtime.areaSeriesKeys.map((b) => b.dataKey) || s.series.map((b) => b.dataKey),
      x0: (b) => A(b.data[s.xAxis.dataKey]),
      y0: (b) => Number(t(b[0])),
      y1: (b) => Number(t(b[1])),
      curve: xs[al[s.stackedAreaChartLineType]]
    },
    ({ stacks: b, path: y }) => b.map((N, C) => {
      let P = s.legend.behavior === "highlight" && p.length > 0 && p.indexOf(N.key) === -1, O = s.legend.behavior === "highlight" || p.length === 0 || p.indexOf(N.key) !== -1;
      return (
        // prettier-ignore
        /* @__PURE__ */ n.createElement(
          "path",
          {
            key: N.key,
            d: y(N) || "",
            strokeWidth: 2,
            stroke: O ? m ? m(s.runtime.seriesLabels ? s.runtime.seriesLabels[N.key] : N.key) : "#000" : "transparent",
            fillOpacity: P ? 0.2 : 1,
            fill: O ? m ? m(s.runtime.seriesLabels ? s.runtime.seriesLabels[N.key] : N.key) : "#000" : "transparent"
          }
        )
      );
    })
  ), /* @__PURE__ */ n.createElement(Nr, { width: Number(a), height: Number(r), fill: "transparent", onMouseMove: (b) => i(b, v), onMouseLeave: o }))));
}, ZS = ie.memo(GS), _s = () => {
  const { config: e, colorPalettes: t, tableData: r, updateConfig: a, parseDate: i, formatDate: o, setSeriesHighlight: d, seriesHighlight: c } = ie.useContext(Et), { orientation: s } = e, [p, m] = ie.useState(null), v = s === "horizontal", g = 1, A = e.lollipopSize === "large" ? 7 : e.lollipopSize === "medium" ? 6 : 5, k = e.lollipopSize === "large" ? 14 : e.lollipopSize === "medium" ? 12 : 10, E = e.yAxis.labelPlacement === "Below Bar", T = e.yAxis.displayNumbersOnBar, b = e.orientation === "horizontal" ? "yAxis" : "xAxis", y = e.barStyle === "rounded", N = e.visualizationSubType === "stacked", C = e.tipRounding, P = e.roundingStyle === "standard" ? "8px" : e.roundingStyle === "shallow" ? "5px" : e.roundingStyle === "finger" ? "15px" : "0px", O = e.runtime.seriesKeys.length, K = { small: 16, medium: 18, large: 20 }, W = Object.keys(e.runtime.seriesLabels).length > 1, j = e.visualizationType === "Bar" && e.legend.behavior === "isolate" && e.legend.axisAlign && (c != null && c.length) ? c : e.runtime.barSeriesKeys || e.runtime.seriesKeys;
  return ie.useEffect(() => {
    s === "horizontal" && !e.yAxis.labelPlacement && a({
      ...e,
      yAxis: {
        ...e.yAxis,
        labelPlacement: "Below Bar"
      }
    });
  }, [e, a]), ie.useEffect(() => {
    e.isLollipopChart === !1 && e.barHeight < 25 && a({ ...e, barHeight: 25 });
  }, [e.isLollipopChart]), ie.useEffect(() => {
    e.visualizationSubType === "horizontal" && a({
      ...e,
      orientation: "horizontal"
    });
  }, []), ie.useEffect(() => {
    e.barStyle === "lollipop" && !e.isLollipopChart && a({ ...e, isLollipopChart: !0 }), (y || e.barStyle === "flat") && a({ ...e, isLollipopChart: !1 });
  }, [e.barStyle]), {
    isHorizontal: v,
    barBorderWidth: g,
    lollipopBarWidth: A,
    lollipopShapeSize: k,
    isLabelBelowBar: E,
    displayNumbersOnBar: T,
    shouldSuppress: (q) => {
      var H;
      return (H = e.preliminaryData) == null ? void 0 : H.some((oe) => {
        const ue = oe.column ? oe.column === q.key : !0, ke = String(q.value) === String(oe.value) && oe.value !== "";
        return ue && ke && oe.symbol && oe.type === "suppression";
      });
    },
    section: b,
    isRounded: y,
    isStacked: N,
    tipRounding: C,
    radius: P,
    stackCount: O,
    barStackedSeriesKeys: j,
    fontSize: K,
    hasMultipleSeries: W,
    applyRadius: (q) => {
      if (q == null || !y)
        return {};
      let H = {};
      return (N && q + 1 === O || !N) && (H = v ? { borderRadius: `0 ${P}  ${P}  0` } : { borderRadius: `${P} ${P} 0 0` }), !N && q === -1 && (H = v ? { borderRadius: `${P} 0  0 ${P} ` } : { borderRadius: ` 0  0 ${P} ${P}` }), C === "full" && N && q === 0 && O > 1 && (H = v ? { borderRadius: `${P} 0 0 ${P}` } : { borderRadius: `0 0 ${P} ${P}` }), C === "full" && (N && q === 0 && O === 1 || !N) && (H = { borderRadius: P }), H;
    },
    updateBars: (q) => {
      if (e.visualizationType !== "Bar" && !v)
        return q;
      const H = [...q];
      let oe;
      const ue = {
        stacked: e.barHeight,
        lollipop: A
      };
      N ? oe = ue.stacked : oe = ue[e.isLollipopChart ? "lollipop" : "stacked"] * O;
      const ke = E ? K[e.fontSize] * 1.2 : 0;
      let De = Number(e.barSpace), pe = H.length * (oe + ke + De);
      return v && (e.heights.horizontal = pe), H.map((Be, qe) => {
        let Pe = 0;
        return Be.index !== 0 && (Pe = (oe + De + ke) * qe), { ...Be, y: Pe, height: oe };
      });
    },
    assignColorsToValues: (q, H, oe) => {
      if (!e.legend.colorCode && e.series.length > 1)
        return oe;
      const ue = e.customColors ?? t[e.palette], ke = r.map((qe) => qe[e.legend.colorCode]);
      let De = /* @__PURE__ */ new Map(), pe = [];
      for (let qe = 0; qe < ke.length; qe++)
        De.has(ke[qe]) || De.set(ke[qe], ue[De.size % ue.length]), pe.push(De.get(ke[qe]));
      for (; pe.length < q; )
        pe = pe.concat(pe);
      return pe[H];
    },
    getHighlightedBarColorByValue: (q) => {
      const H = e == null ? void 0 : e.highlightedBarValues.find((oe) => {
        if (oe.value)
          return e.xAxis.type === "date" ? o(i(oe.value)) === q : oe.value === q;
      });
      return H != null && H.color ? H.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (q) => {
      const H = e == null ? void 0 : e.highlightedBarValues.filter((oe) => {
        if (oe.value)
          return e.xAxis.type === "date" ? o(i(oe.value)) === q : oe.value === q;
      })[0];
      return H != null && H.color ? H : !1;
    },
    getAdditionalColumn: (q, H) => {
      if (!H)
        return "";
      const oe = e.columns, ue = [];
      let ke = "";
      const De = r.find((pe) => pe[e.xAxis.dataKey] === H) || {};
      return Object.keys(oe).forEach((pe) => {
        if (q && e.columns[pe].series && e.columns[pe].series !== q)
          return;
        const Be = {
          addColPrefix: e.columns[pe].prefix,
          addColSuffix: e.columns[pe].suffix,
          addColRoundTo: e.columns[pe].roundToPlace ? e.columns[pe].roundToPlace : "",
          addColCommas: e.columns[pe].commas
        }, qe = Yf(De[e.columns[pe].name], "left", !0, e, Be);
        e.columns[pe].tooltips && ue.push([e.columns[pe].label, qe]);
      }), ue.forEach((pe) => {
        ke += `${pe[0]} : ${pe[1]} <br/>`;
      }), ke;
    },
    hoveredBar: p,
    setHoveredBar: m,
    onMouseOverBar: (q, H) => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && H && d([H]), m(q);
    },
    onMouseLeaveBar: () => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && d([]);
    }
  };
}, Os = ie.createContext(null), gp = ({
  xScale: e,
  barWidth: t = 0,
  totalBarsInGroup: r = 1,
  yMax: a,
  handleTooltipMouseOff: i,
  handleTooltipMouseOver: o,
  handleTooltipClick: d,
  tooltipData: c,
  showTooltip: s,
  hideTooltip: p
}) => {
  const { parseDate: m, config: v } = ie.useContext(Et), { runtime: g, regions: A, visualizationType: k, orientation: E, xAxis: T } = v, b = e.domain(), y = (P) => {
    let O;
    if (!(P != null && P.fromType) || P.fromType === "Fixed") {
      const K = new Date(P.from), W = m(is(v.xAxis.dateParseFormat, K)).getTime();
      O = e(W), k === "Bar" && T.type === "date-time" && (O = O - t * r / 2);
    }
    if (P.fromType === "Previous Days") {
      const K = Number(P.from) || 0;
      b.map((B) => is(v.xAxis.dateParseFormat, new Date(B)));
      const W = P.toType === "Last Date" ? new Date(b[b.length - 1]).getTime() : new Date(P.to), J = v.xAxis.type === "categorical" ? is(v.xAxis.dateParseFormat, W) : is(v.xAxis.dateParseFormat, W), j = new Date(J);
      if (O = new Date(j.setDate(j.getDate() - Number(K))), T.type === "date") {
        O = new Date(is(T.dateParseFormat, O)).getTime();
        let B = b[0], Z = Math.abs(O - B);
        for (let te = 1; te < b.length; te++) {
          const V = Math.abs(O - b[te]);
          V < Z && (Z = V, B = b[te]);
        }
        O = B;
      }
      if (T.type === "categorical") {
        let B = b[0], Z = Math.abs(new Date(O).getTime() - new Date(B).getTime());
        for (let te = 1; te < b.length; te++) {
          const V = Math.abs(new Date(O).getTime() - new Date(b[te]).getTime());
          V < Z && (Z = V, B = b[te]);
        }
        O = B;
      }
      O = e(O);
    }
    if (T.type === "categorical" && P.fromType !== "Previous Days" && (O = e(P.from)), k === "Line" || k === "Area Chart") {
      let K = Number(v.yAxis.size);
      e.bandwidth && (K += e.bandwidth() / 2), O = O + K;
    }
    return k === "Bar" && v.xAxis.type === "date-time" && P.fromType === "Previous Days" && (O = O - t * r / 2), O;
  }, N = (P) => {
    let O;
    if (T.type === "categorical" && (O = e(P.to)), Dn(T) && ((!(P != null && P.toType) || P.toType === "Fixed") && (O = e(m(P.to).getTime())), (k === "Bar" || v.visualizationType === "Combo") && (O = P.toType !== "Last Date" ? e(m(P.to).getTime()) + t * r : O)), P.toType === "Last Date") {
      const K = b[b.length - 1];
      O = Number(
        e(K) + ((k === "Bar" || k === "Combo") && v.xAxis.type === "date" ? t * r : 0)
      );
    }
    if (k === "Line" || k === "Area Chart") {
      let K = Number(v.yAxis.size);
      e.bandwidth && (K += e.bandwidth() / 2), O = O + K;
    }
    return k === "Bar" && v.xAxis.type === "date-time" && P.toType !== "Last Date" && (O = O - t * r / 2), (k === "Bar" || k === "Combo") && T.type === "categorical" && (O = O + (k === "Bar" || k === "Combo" ? t * r : 0)), O;
  }, C = (P, O) => P - O;
  if (A && E === "vertical")
    return A.map((P) => {
      const O = y(P), K = N(P), W = C(K, O);
      if (!O || !K)
        return null;
      const J = () => /* @__PURE__ */ n.createElement("rect", { x: O, y: 0, width: W, height: a, fill: P.background, opacity: 0.3 });
      return /* @__PURE__ */ n.createElement(
        st,
        {
          height: 100,
          fill: "red",
          className: "regions regions-group--line zzz",
          key: P.label,
          onMouseMove: o,
          onMouseLeave: i,
          handleTooltipClick: d,
          tooltipData: JSON.stringify(c),
          showTooltip: s
        },
        /* @__PURE__ */ n.createElement(J, null),
        /* @__PURE__ */ n.createElement(St, { x: O + W / 2, y: 5, fill: P.color, verticalAnchor: "start", textAnchor: "middle" }, P.label)
      );
    });
};
function Fs(e) {
  var oe, ue;
  const { config: t, index: r, id: a, className: i, background: o, borderColor: d, borderWidth: c, width: s, height: p, x: m, y: v, onMouseOver: g, onMouseLeave: A, onClick: k, tooltipHtml: E, tooltipId: T, styleOverrides: b, seriesHighlight: y, type: N } = e, C = Math.max(0, s), P = Math.max(0, p), O = t.orientation === "horizontal", K = t.barStyle === "rounded", W = t.visualizationSubType === "stacked", J = t.tipRounding, j = t.visualizationType === "Combo" && ((ue = (oe = t.runtime) == null ? void 0 : oe.barSeriesKeys) == null ? void 0 : ue.length), B = t.runtime.seriesKeys.length, Z = t.visualizationType === "Bar" && t.legend.axisAlign && (y != null && y.length) ? y == null ? void 0 : y.length : 0, te = j || Z || B;
  let V = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  (V > C / 2 || V > P / 2) && (V = Math.min(C / 2, P / 2));
  const ee = () => `M${m},${v + P}
      L${m},${v + V}
      Q${m},${v} ${m + V},${v}
      L${m + C - V},${v}
      Q${m + C},${v} ${m + C},${v + V}
      L${m + C},${v + P}
      L${m},${v + P}`, ce = () => `M${m},${v + P}
      L${m},${v}
      L${m + C - V},${v}
      Q${m + C},${v} ${m + C},${v + V}
      L${m + C},${v + P - V}
      Q${m + C},${v + P} ${m + C - V},${v + P}
      L${m},${v + P}`, re = () => `M${m + V},${v + P}
      Q${m},${v + P} ${m},${v + P - V}
      L${m},${v}
      L${m + C},${v}
      L${m + C},${v + P - V}
      Q${m + C},${v + P} ${m + C - V},${v + P}
      L${m + V},${v + P}`, G = () => `M${m + V},${v + P}
      Q${m},${v + P} ${m},${v + P - V}
      L${m},${v + V}
      Q${m},${v} ${m + V},${v}
      L${m + C},${v}
      L${m + C},${v + P}
      L${m + V},${v + P}`, U = () => `M${m + V},${v + P}
      Q${m},${v + P} ${m},${v + P - V}
      L${m},${v + V}
      Q${m},${v} ${m + V},${v}
      L${m + C - V},${v}
      Q${m + C},${v} ${m + C},${v + V}
      L${m + C},${v + P - V}
      Q${m + C},${v + P} ${m + C - V},${v + P}
      L${m + V},${v + P}`, q = () => `M${m},${v}
      L${m + C},${v}
      L${m + C},${v + P}
      L${m},${v + P}
      L${m},${v}`;
  let H;
  return r == null || !K || N == "axisBar" ? H = q() : (H = q(), (W && r + 1 === te || !W) && (H = O ? ce() : ee()), !W && r === -1 && (H = O ? G() : re()), J === "full" && W && r === 0 && te > 1 && (H = O ? G() : re()), J === "full" && (W && r === 0 && te === 1 || !W) && (H = U())), /* @__PURE__ */ n.createElement(
    "path",
    {
      id: a,
      className: i,
      d: H,
      fill: o,
      stroke: d,
      strokeWidth: c,
      onMouseOver: g,
      onMouseLeave: A,
      onClick: k,
      "data-tooltip-html": E,
      "data-tooltip-id": T,
      style: {
        transition: "all 0.2s linear",
        ...b
      }
    }
  );
}
const QS = () => {
  var j, B;
  const [e, t] = ie.useState(0), { xScale: r, yScale: a, seriesScale: i, xMax: o, yMax: d } = ie.useContext(Os), { transformedData: c, colorScale: s, seriesHighlight: p, config: m, formatNumber: v, formatDate: g, parseDate: A, setSharedFilter: k } = ie.useContext(Et), { isHorizontal: E, barBorderWidth: T, applyRadius: b, hoveredBar: y, getAdditionalColumn: N, onMouseLeaveBar: C, onMouseOverBar: P, barStackedSeriesKeys: O } = _s(), { orientation: K } = m, W = (j = m.brush) != null && j.active && ((B = m.brush.data) != null && B.length) ? m.brush.data : c, J = m.runtime.xAxis.type === "date-time" || m.runtime.xAxis.type === "date";
  return m.visualizationSubType === "stacked" && !E && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(zy, { data: W, keys: O, x: (Z) => Z[m.runtime.xAxis.dataKey], xScale: r, yScale: a, color: s }, (Z) => Z.reverse().map(
    (te) => te.bars.map((V) => {
      let ee = m.legend.behavior === "highlight" && p.length > 0 && p.indexOf(V.key) === -1, ce = m.legend.behavior === "highlight" || p.length === 0 || p.indexOf(V.key) !== -1, re = J ? i.range()[1] - i.range()[0] : o / te.bars.length;
      m.runtime.xAxis.type !== "date" && (re = m.barThickness * re);
      const G = V.bar.data[m.runtime.xAxis.dataKey], U = J ? g(A(G)) : G, q = v(V.bar ? V.bar.data[V.key] : 0, "left");
      if (!q)
        return;
      const H = r(J ? A(G) : G) - (J ? re / 2 : 0), oe = m.runtime.xAxis.label ? `${m.runtime.xAxis.label}: ${U}` : U, ue = N(y), ke = `${m.runtime.seriesLabels[V.key]}: ${q}`, De = `<ul>
                  <li class="tooltip-heading"">${oe}</li>
                  <li class="tooltip-body ">${ke}</li>
                  <li class="tooltip-body ">${ue}</li>
                    </li></ul>`;
      return t(re), /* @__PURE__ */ n.createElement(st, { key: `${te.index}--${V.index}--${K}` }, /* @__PURE__ */ n.createElement(st, { key: `bar-stack-${te.index}-${V.index}`, id: `barStack${te.index}-${V.index}`, className: "stack vertical" }, Fs({
        config: m,
        seriesHighlight: p,
        index: te.index,
        background: s(m.runtime.seriesLabels[V.key]),
        borderColor: "#333",
        borderStyle: "solid",
        borderWidth: `${m.barHasBorder === "true" ? T : 0}px`,
        width: re,
        height: V.height,
        x: H,
        y: V.y,
        onMouseOver: () => P(U, V.key),
        onMouseLeave: C,
        tooltipHtml: De,
        tooltipId: `cdc-open-viz-tooltip-${m.runtime.uniqueId}`,
        onClick: (pe) => {
          pe.preventDefault(), k && (V[m.xAxis.dataKey] = U, k(m.uid, V));
        },
        styleOverrides: {
          animationDelay: `${te.index * 0.5}s`,
          transformOrigin: `${re / 2}px ${V.y + V.height}px`,
          opacity: ee ? 0.2 : 1,
          display: ce ? "block" : "none"
        }
      })));
    })
  )), /* @__PURE__ */ n.createElement(gp, { xScale: r, yMax: d, barWidth: e, totalBarsInGroup: 1 }));
}, JS = () => {
  const { yMax: e, yScale: t, xScale: r } = ie.useContext(Os), {
    animatedChart: a,
    colorScale: i,
    config: o,
    formatDate: d,
    formatNumber: c,
    parseDate: s,
    seriesHighlight: p,
    setSharedFilter: m,
    transformedData: v
  } = ie.useContext(Et), { barBorderWidth: g, displayNumbersOnBar: A, fontSize: k, getAdditionalColumn: E, hoveredBar: T, isHorizontal: b, isLabelBelowBar: y, onMouseLeaveBar: N, onMouseOverBar: C, updateBars: P, barStackedSeriesKeys: O } = _s(), { orientation: K, visualizationSubType: W } = o;
  return o.visualizationSubType === "stacked" && b && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    EE,
    {
      data: v,
      keys: O,
      height: e,
      y: (J) => J[o.runtime.yAxis.dataKey],
      xScale: r,
      yScale: t,
      color: i,
      offset: "none"
    },
    (J) => J.map(
      (j) => P(j.bars).map((B, Z) => {
        const te = o.legend.behavior === "highlight" && p.length > 0 && p.indexOf(B.key) === -1, V = o.legend.behavior === "highlight" || p.length === 0 || p.indexOf(B.key) !== -1;
        o.barHeight = Number(o.barHeight);
        const ee = rl("#000", i(o.runtime.seriesLabels[B.key])), ce = c(v[B.index][B.key], "left"), re = o.runtime.yAxis.type === "date" ? d(s(v[B.index][o.runtime.originalXAxis.dataKey])) : v[B.index][o.runtime.originalXAxis.dataKey], G = o.runtime.yAxis.label ? `${o.runtime.yAxis.label}: ${re}` : re, U = Kn(ce, `normal ${k[o.fontSize]}px sans-serif`), q = E(T), H = `${o.runtime.seriesLabels[B.key]}: ${ce}`, oe = `<ul>
                  <li class="tooltip-heading"">${G}</li>
                  <li class="tooltip-body ">${H}</li>
                  <li class="tooltip-body ">${q}</li>
                    </li></ul>`;
        return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(st, { key: Z, id: `barStack${j.index}-${B.index}`, className: "stack horizontal" }, Fs({
          config: o,
          seriesHighlight: p,
          index: j.index,
          className: `animated-chart group ${a ? "animated" : ""}`,
          background: i(o.runtime.seriesLabels[B.key]),
          borderColor: "#333",
          borderStyle: "solid",
          borderWidth: `${o.barHasBorder === "true" ? g : 0}px`,
          width: B.width,
          height: B.height,
          x: B.x,
          y: B.y,
          onMouseOver: () => C(re, B.key),
          onMouseLeave: N,
          tooltipHtml: oe,
          tooltipId: `cdc-open-viz-tooltip-${o.runtime.uniqueId}`,
          onClick: (ue) => {
            ue.preventDefault(), m && (B[o.xAxis.dataKey] = ce, m(o.uid, B));
          },
          styleOverrides: {
            animationDelay: `${j.index * 0.5}s`,
            transformOrigin: `${B.x}px 0`,
            opacity: te ? 0.2 : 1,
            display: V ? "block" : "none"
          }
        }), K === "horizontal" && W === "stacked" && y && j.index === 0 && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          St,
          {
            x: `${B.x + (o.isLollipopChart ? 15 : 5)}`,
            y: B.y + B.height * 1.2,
            fill: "#000000",
            textAnchor: "start",
            verticalAnchor: "start"
          },
          re
        ), A && U < B.width && /* @__PURE__ */ n.createElement(
          St,
          {
            display: V ? "block" : "none",
            x: B.x + j.bars[B.index].width / 2,
            y: B.y + B.height / 2,
            fill: ee,
            textAnchor: "middle",
            verticalAnchor: "middle"
          },
          ce
        )));
      })
    )
  ));
}, Ic = (e, t) => {
  var E;
  const { formatDate: r, parseDate: a } = ie.useContext(Et);
  let i = [], o = "", d = [], c = [];
  ((E = e.series) == null ? void 0 : E.length) > 0 && e.data ? (i = e.series[0], o = e.series[0].dataKey, d = e.highlightedBarValues, c = e.data.map((T) => T[e.xAxis.dataKey])) : (i = [], o = "", d = [], c = []);
  const s = (T, b) => {
    const y = [...e.highlightedBarValues];
    y[b].borderWidth = T.target.value, t({
      ...e,
      highlightedBarValues: y
    });
  }, p = (T, b) => {
    T.preventDefault();
    const y = [...e.highlightedBarValues];
    y[b].value = T.target.value, y[b].dataKey = o, t({
      ...e,
      highlightedBarValues: y
    });
  }, m = (T, b) => {
    T.preventDefault();
    const y = [...e.highlightedBarValues];
    y.push({ dataKey: o }), t({
      ...e,
      highlightedBarValues: y
    });
  }, v = (T, b) => {
    T.preventDefault();
    const y = [...e.highlightedBarValues];
    y.splice(b, 1), t({
      ...e,
      highlightedBarValues: y
    });
  }, g = (T, b) => {
    const y = [...e.highlightedBarValues];
    y[b].color = T.target.value, t({
      ...e
    });
  }, A = (T, b) => {
    const y = [...e.highlightedBarValues];
    y[b].legendLabel = T.target.value, t({
      ...e,
      copyOfHighlightedBarValues: y
    });
  }, k = () => {
  };
  return k.checkFontColor = (T, b, y) => {
    if (e.xAxis.type === "date") {
      if (k.formatDates(b).includes(T))
        return "#000";
    } else if (b.includes(T))
      return "#000";
    return y;
  }, k.formatDates = (T) => T.map((b) => b ? r(a(b)) : !1), k.findDuplicates = (T) => {
    const b = {};
    return T == null ? void 0 : T.filter((N) => {
      const { legendLabel: C } = N;
      return b[C] ? !1 : (b[C] = !0, !0);
    });
  }, {
    HighLightedBarUtils: k,
    highlightedSeries: i,
    highlightedSeriesKey: o,
    highlightedBarValues: d,
    highlightedSeriesValues: c,
    handleUpdateHighlightedBar: p,
    handleAddNewHighlightedBar: m,
    handleRemoveHighlightedBar: v,
    handleUpdateHighlightedBarColor: g,
    handleHighlightedBarLegendLabel: A,
    handleUpdateHighlightedBorderWidth: s
  };
}, ag = ({
  bar: e,
  defaultBarHeight: t,
  defaultBarWidth: r,
  config: a,
  isNumber: i,
  barWidth: o,
  isVertical: d
}) => {
  let s = t, p = r, m = "", v = !1, g = !1, A = !1;
  const k = a.general.showSuppressedSymbol;
  if (a.preliminaryData.forEach((b) => {
    (!b.column || b.column === e.key) && b.type === "suppression" && b.value && String(b.value) === String(e.value) && (!b.hideBarSymbol && k ? (s = o > 10 ? 3 : 0, p = 3, v = !0) : (s = 0, p = 0, v = !0));
  }), !v && !i(e.value) && a.general.showMissingDataLabel) {
    const b = Kn(m, `normal ${o / 2}px sans-serif`), y = Number(b) < o && o > 10;
    g = !0, s = y ? 3 : 0, p = 3;
  }
  if (!v && e.value === "0" && a.general.showZeroValueData) {
    const b = Kn("0", `normal ${o / 2}px sans-serif`), y = Number(b) < o && o > 10;
    A = !0, s = y ? 3 : 0, p = 3;
  }
  return { barWidthHorizontal: p, barHeight: s, isSuppressed: v, showMissingDataLabel: g, getBarY: (b, y) => v || g || A ? a.isLollipopChart ? y - 3 * 2 : y - 3 : b, getAbsentDataLabel: (b) => {
    let y = "";
    String(b) === "0" && (y = ""), v && (y = ""), g && (y = "N/A"), A && (y = "0");
    const N = Kn(m, `normal ${o / 2}px sans-serif`), C = Number(N) < o && o > 10;
    return a.isLollipopChart || C && d ? y : d ? "" : y;
  } };
}, bs = (e) => e == null ? void 0 : /^0(\.0)?$/.test(e.toString()), Hc = (e, t, r) => !!(e === "Line" && (t == null ? void 0 : t.length) < 3 && r), ek = () => {
  const { xScale: e, yScale: t, xMax: r, yMax: a, seriesScale: i } = ie.useContext(Os), [o, d] = ie.useState(0), [c, s] = ie.useState(0), {
    // prettier-ignore
    assignColorsToValues: p,
    barBorderWidth: m,
    getAdditionalColumn: v,
    getHighlightedBarByValue: g,
    getHighlightedBarColorByValue: A,
    lollipopBarWidth: k,
    lollipopShapeSize: E,
    onMouseLeaveBar: T,
    onMouseOverBar: b,
    section: y
  } = _s(), { colorScale: N, config: C, dashboardConfig: P, tableData: O, formatDate: K, formatNumber: W, getXAxisData: J, getYAxisData: j, isNumber: B, parseDate: Z, seriesHighlight: te, setSharedFilter: V, transformedData: ee, brushConfig: ce } = ie.useContext(Et), { HighLightedBarUtils: re } = Ic(C);
  let G = ee;
  return C.preliminaryData.some((q) => q.value && q.type === "suppression") && (G = O), ce.data.length && (G = ce.data), C.visualizationSubType !== "stacked" && (C.visualizationType === "Bar" || C.visualizationType === "Combo" || Hc(C.visualizationType, G, C.allowLineToBarGraph)) && C.orientation === "vertical" && /* @__PURE__ */ n.createElement(st, null, /* @__PURE__ */ n.createElement(
    Oy,
    {
      data: G,
      keys: C.runtime.barSeriesKeys || C.runtime.seriesKeys,
      height: a,
      x0: (q) => {
        const H = q[C.runtime.originalXAxis.dataKey];
        return Dn(C.runtime.xAxis) ? Z(H) : H;
      },
      x0Scale: e,
      x1Scale: i,
      yScale: t,
      color: () => ""
    },
    (q) => q.map((H, oe) => /* @__PURE__ */ n.createElement(
      st,
      {
        className: `bar-group-${H.index}-${H.x0}--${oe} ${C.orientation}`,
        key: `bar-group-${H.index}-${H.x0}--${oe}`,
        id: `bar-group-${H.index}-${H.x0}--${oe}`,
        left: H.x0
      },
      H.bars.map((ue, ke) => {
        const De = C.yAxis.type === "logarithmic" ? 0.1 : 0;
        let pe = C.highlightedBarValues.map((Nt) => Nt.value).filter((Nt) => Nt !== void 0);
        pe = C.xAxis.type === "date" ? re.formatDates(pe) : pe;
        const Be = C.legend.behavior === "highlight" && te.length > 0 && te.indexOf(ue.key) === -1, qe = C.legend.behavior === "highlight" || te.length === 0 || te.indexOf(ue.key) !== -1;
        let Pe = i.range()[1] - i.range()[0];
        const ve = Math.abs(t(ue.value) - t(De)), $e = ue.value >= 0 && B(ue.value) ? ue.y : t(0);
        let z = C.isLollipopChart ? k : i.bandwidth(), Re = ue.x + (C.isLollipopChart ? (Pe / H.bars.length - k) / 2 : 0) - (C.xAxis.type === "date-time" ? Pe / 2 : 0);
        d(z), s(H.bars.length);
        const be = W(/[a-zA-Z]/.test(String(ue.value)) ? "" : ue.value, "left"), He = C.runtime[y].type === "date" ? K(Z(G[H.index][C.runtime.originalXAxis.dataKey])) : G[H.index][C.runtime.originalXAxis.dataKey], Ve = ue.value < 0 ? -1 : ke, Oe = v(
          ue.key,
          G[H.index][C.runtime.originalXAxis.dataKey]
        );
        let Ge = C.runtime.xAxis.label ? `${C.runtime.xAxis.label}: ${He}` : He;
        const Xe = `${C.runtime.seriesLabels[ue.key]}: ${be}`, rt = `<ul>
                  <li class="tooltip-heading">${Ge}</li>
                  <li class="tooltip-body ">${Xe}</li>
                  ${Oe ? '<li class="tooltip-body ">' + Oe + "</li>" : ""}
                    </li></ul>`;
        let Ue = "#000000";
        Ue = re.checkFontColor(be, pe, Ue), C.runtime.seriesLabels && C.runtime.seriesLabels[ue.key] ? N(C.runtime.seriesLabels[ue.key]) : N(ue.key);
        const ze = C.isLollipopChart && C.lollipopColorStyle === "regular", Ne = C.isLollipopChart && C.lollipopColorStyle === "two-tone", ot = pe == null ? void 0 : pe.includes(He), nt = A(He), mt = g(He), wt = ot ? nt : C.barHasBorder === "true" ? "#000" : "transparent", xt = ot ? mt.borderWidth : C.isLollipopChart ? 0 : C.barHasBorder === "true" ? m : 0, { barHeight: Pt, isSuppressed: ln, getBarY: Gt, getAbsentDataLabel: Ut } = ag({
          bar: ue,
          defaultBarHeight: ve,
          config: C,
          isNumber: B,
          barWidth: z,
          isVertical: !0,
          yAxisValue: be
        }), yt = Ut(be), Tt = ln || !C.labels ? "" : be, Dt = Gt($e, t(De)), nn = bs(ue.value) ? "none" : "block", yn = (Nt, un) => {
          var bt;
          let Kt = Nt, Fe = un || "#f2f2f2";
          if (P && ((bt = P.dashboard.sharedFilters) == null ? void 0 : bt.length) !== 0) {
            const { sharedFilters: xn } = P.dashboard;
            return Kt = xn ? xn.map((Ot) => Ot.setBy === C.uid ? Ot.resetLabel === Ot.active || Ot.active === ee[H.index][C.xAxis.dataKey] ? N(C.runtime.seriesLabels[ue.key]) : Fe : N(C.runtime.seriesLabels[ue.key]))[0] : N(C.runtime.seriesLabels[ue.key]), ze && (Kt = Nt), ot && (Kt = "transparent"), C.legend.colorCode && (Kt = p(q.length, H.index, Nt)), Ne && (Kt = ja(Nt).brighten(1)), Kt;
          }
          return Ne && (Kt = ja(Nt).brighten(1)), C.legend.colorCode && (Kt = p(q.length, H.index, Nt)), ot && (Kt = "transparent"), Kt;
        };
        return /* @__PURE__ */ n.createElement(st, { key: `${H.index}--${ke}` }, /* @__PURE__ */ n.createElement(st, { key: `bar-sub-group-${H.index}-${H.x0}-${Dt}--${ke}` }, Fs({
          config: C,
          index: Ve,
          id: `barGroup${H.index}`,
          background: yn(N(C.runtime.seriesLabels[ue.key])),
          borderColor: wt,
          borderStyle: "solid",
          borderWidth: `${xt}px`,
          width: z,
          height: Pt,
          x: Re,
          y: Dt,
          onMouseOver: () => b(He, ue.key),
          onMouseLeave: T,
          tooltipHtml: rt,
          tooltipId: `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
          onClick: (Nt) => {
            Nt.preventDefault(), V && (ue[C.xAxis.dataKey] = He, V(C.uid, ue));
          },
          styleOverrides: {
            transformOrigin: `0 ${Dt + Pt}px`,
            opacity: Be ? 0.2 : 1,
            display: qe ? "block" : "none",
            cursor: P ? "pointer" : "default"
          }
        }), C.preliminaryData.map((Nt, un) => {
          const Kt = !Nt.column || Nt.column === ue.key;
          if (!(String(Nt.value) === String(ue.value) && Nt.value !== "" && Kt) || z < 10 || !C.general.showSuppressedSymbol || Nt.hideBarSymbol)
            return;
          const xn = String(Nt.symbol).includes("Asterisk"), Ot = xn ? -5 : -8, Ln = xn ? "middle" : "end", An = Nt.symbol === "Asterisk" ? z * 1.2 : Nt.symbol === "Double Asterisk" ? z : z / 1.5, $t = Nt.displayGray ? "#8b8b8a" : "#000";
          return /* @__PURE__ */ n.createElement(
            St,
            {
              key: un,
              dy: Ot,
              display: qe ? "block" : "none",
              opacity: Be ? 0.5 : 1,
              x: Re + z / 2,
              y: Dt,
              verticalAnchor: Ln,
              fill: $t,
              textAnchor: "middle",
              fontSize: `${An}px`
            },
            Nt.iconCode
          );
        }), /* @__PURE__ */ n.createElement(
          St,
          {
            display: qe ? "block" : "none",
            opacity: Be ? 0.5 : 1,
            x: Re + z / 2,
            y: Dt - 5,
            fill: Ue,
            textAnchor: "middle"
          },
          bs(ue.value) ? "" : Tt
        ), /* @__PURE__ */ n.createElement(
          St,
          {
            display: qe ? "block" : "none",
            opacity: Be ? 0.5 : 1,
            x: Re + z / 2,
            y: Dt - 5,
            fill: Ue,
            textAnchor: "middle",
            fontSize: C.isLollipopChart ? null : z / 2
          },
          yt
        ), C.isLollipopChart && C.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: nn,
            cx: Re + E / 3.5,
            cy: ue.y,
            r: E / 2,
            fill: yn(N(C.runtime.seriesLabels[ue.key])),
            key: `circle--${ue.index}`,
            "data-tooltip-html": rt,
            "data-tooltip-id": `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
            style: { filter: "unset", opacity: 1 }
          }
        ), C.isLollipopChart && C.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
          "rect",
          {
            display: nn,
            x: Re - k / 2,
            y: Dt,
            width: E,
            height: E,
            fill: yn(N(C.runtime.seriesLabels[ue.key])),
            key: `circle--${ue.index}`,
            "data-tooltip-html": rt,
            "data-tooltip-id": `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
            style: { opacity: 1, filter: "unset" }
          },
          /* @__PURE__ */ n.createElement("animate", { attributeName: "height", values: `0, ${E}`, dur: "2.5s" })
        )));
      })
    ))
  ), Object.keys(C.confidenceKeys).length > 0 ? G.map((q) => {
    let H, oe, ue, ke, De = 5;
    return H = e(J(q)) + (C.xAxis.type !== "date-time" ? i.range()[1] / 2 : 0), ue = t(j(q, C.confidenceKeys.lower)), ke = t(j(q, C.confidenceKeys.upper)), /* @__PURE__ */ n.createElement(
      "path",
      {
        key: `confidence-interval-v-${oe}-${q[C.runtime.originalXAxis.dataKey]}`,
        stroke: "#333",
        strokeWidth: "px",
        d: `
                    M${H - De} ${ue}
                    L${H + De} ${ue}
                    M${H} ${ue}
                    L${H} ${ke}
                    M${H - De} ${ke}
                    L${H + De} ${ke}`
      }
    );
  }) : "", /* @__PURE__ */ n.createElement(gp, { xScale: e, yMax: a, barWidth: o, totalBarsInGroup: c }));
}, tk = () => {
  var re;
  const { xScale: e, yScale: t, yMax: r, seriesScale: a } = ie.useContext(Os), {
    transformedData: i,
    tableData: o,
    colorScale: d,
    seriesHighlight: c,
    config: s,
    formatNumber: p,
    formatDate: m,
    parseDate: v,
    setSharedFilter: g,
    isNumber: A,
    getYAxisData: k,
    getXAxisData: E
  } = ie.useContext(Et), {
    isHorizontal: T,
    barBorderWidth: b,
    updateBars: y,
    assignColorsToValues: N,
    section: C,
    fontSize: P,
    isLabelBelowBar: O,
    displayNumbersOnBar: K,
    lollipopBarWidth: W,
    lollipopShapeSize: J,
    getHighlightedBarColorByValue: j,
    getHighlightedBarByValue: B,
    getAdditionalColumn: Z,
    hoveredBar: te,
    onMouseLeaveBar: V,
    onMouseOverBar: ee
  } = _s(), { HighLightedBarUtils: ce } = Ic(s);
  return s.visualizationSubType !== "stacked" && s.visualizationType === "Bar" && s.orientation === "horizontal" && /* @__PURE__ */ n.createElement(st, null, /* @__PURE__ */ n.createElement(
    Oy,
    {
      data: (re = s.preliminaryData) != null && re.some((G) => G.value && G.type === "suppression") ? o : i,
      keys: s.runtime.barSeriesKeys || s.runtime.seriesKeys,
      height: r,
      x0: (G) => G[s.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: a,
      yScale: e,
      color: () => ""
    },
    (G) => y(G).map((U, q) => /* @__PURE__ */ n.createElement(
      st,
      {
        className: `bar-group-${U.index}-${U.x0}--${q} ${s.orientation}`,
        key: `bar-group-${U.index}-${U.x0}--${q}`,
        id: `bar-group-${U.index}-${U.x0}--${q}`,
        top: U.y
      },
      U.bars.map((H, oe) => {
        var xn;
        const ue = s.yAxis.type === "logarithmic" ? 0.1 : 0;
        let ke = s.highlightedBarValues.map((Ot) => Ot.value).filter((Ot) => Ot !== void 0);
        ke = s.xAxis.type === "date" ? ce.formatDates(ke) : ke;
        let De = s.legend.behavior === "highlight" && c.length > 0 && c.indexOf(H.key) === -1, pe = s.legend.behavior === "highlight" || c.length === 0 || c.indexOf(H.key) !== -1, Be = s.barHeight, qe = parseInt(s.isLollipopChart ? W : Be);
        isNaN(qe) && (qe = 25);
        let Pe = H.value >= 0 && A(H.value) ? H.y : t(ue);
        const ve = Math.abs(e(H.value) - e(ue)), $e = H.value >= 0 && A(H.value), {
          barWidthHorizontal: z,
          isSuppressed: Re,
          getAbsentDataLabel: be
        } = ag({ bar: H, defaultBarWidth: ve, config: s, isNumber: A, isVertical: !1 }), He = H.value < 0 ? Math.abs(e(H.value)) : e(ue), Ve = p(H.value, "left"), Oe = s.runtime[C].type === "date" ? m(v(i[U.index][s.runtime.originalXAxis.dataKey])) : i[U.index][s.runtime.originalXAxis.dataKey], Ge = $e ? "above" : "below", Xe = be(Ve), rt = s.yAxis.displayNumbersOnBar ? Ve : "", Ue = Kn(rt, `normal ${P[s.fontSize]}px sans-serif`), ze = Number(Ue) < ve - 5;
        let Ne = ze ? "end" : "start", ot = "start", nt = ze ? -5 : 5, mt = 10;
        Ge === "below" && (Ne = ze ? "start" : "end", nt = ze ? 5 : -5, s.isLollipopChart && (ot = "end", mt = -10));
        const wt = H.value < 0 ? -1 : oe;
        let xt = s.runtime.yAxis.label ? `${s.runtime.yAxis.label}: ${Oe}` : Oe;
        const Pt = Z(te), ln = `${s.runtime.seriesLabels[H.key]}: ${Ve}`, Gt = `<ul>
                  <li class="tooltip-heading"">${xt}</li>
                  <li class="tooltip-body ">${ln}</li>
                  <li class="tooltip-body ">${Pt}</li>
                    </li></ul>`;
        let Ut = "#000000";
        Ut = ce.checkFontColor(Ve, ke, Ut);
        let yt = s.runtime.seriesLabels && s.runtime.seriesLabels[H.key] ? d(s.runtime.seriesLabels[H.key]) : d(H.key);
        yt = N(G.length, U.index, yt);
        const Tt = s.isLollipopChart && s.lollipopColorStyle === "regular", Dt = s.isLollipopChart && s.lollipopColorStyle === "two-tone", nn = ke == null ? void 0 : ke.includes(Oe), yn = j(Oe), Nt = B(Oe), un = nn ? yn : s.barHasBorder === "true" ? "#000" : "transparent", Kt = nn ? Nt.borderWidth : s.isLollipopChart ? 0 : s.barHasBorder === "true" ? b : 0, Fe = bs(H.value) ? "none" : "block";
        yt && Ut && ze && (Ut = rl("#000", yt));
        const bt = () => Tt ? yt : Dt ? ja(yt).brighten(1) : nn ? "transparent" : yt;
        return /* @__PURE__ */ n.createElement(st, { key: `${U.index}--${oe}` }, /* @__PURE__ */ n.createElement(st, { key: `bar-sub-group-${U.index}-${U.x0}-${Pe}--${oe}` }, Fs({
          config: s,
          index: wt,
          id: `barGroup${U.index}`,
          background: bt(),
          borderColor: un,
          borderStyle: "solid",
          borderWidth: `${Kt}px`,
          width: z,
          height: qe,
          x: He,
          y: Be * H.index,
          onMouseOver: () => ee(Oe, H.key),
          onMouseLeave: V,
          tooltipHtml: Gt,
          tooltipId: `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
          onClick: (Ot) => {
            Ot.preventDefault(), g && (H[s.xAxis.dataKey] = Ve, g(s.uid, H));
          },
          styleOverrides: {
            transformOrigin: `0 ${Pe + Be}px`,
            opacity: De ? 0.2 : 1,
            display: pe ? "block" : "none"
          }
        }), (xn = s.preliminaryData) == null ? void 0 : xn.map((Ot, Ln) => {
          const An = !Ot.column || Ot.column === H.key;
          if (!(String(Ot.value) === String(H.value) && Ot.value !== "" && An) || Ot.hideBarSymbol || !s.general.showSuppressedSymbol)
            return;
          const fn = String(Ot.symbol).includes("Asterisk") ? "middle" : "end", On = Ot.symbol === "Asterisk" ? Be * 1.2 : Ot.symbol === "Double Asterisk" ? Be : Be / 1.5, Wn = Ot.displayGray ? "#8b8b8a" : "#000";
          return /* @__PURE__ */ n.createElement(
            St,
            {
              key: Ln,
              fontSize: On,
              display: pe ? "block" : "none",
              opacity: De ? 0.5 : 1,
              x: He,
              y: s.barHeight / 2 + s.barHeight * H.index,
              fill: Wn,
              dy: s.barHeight / 5,
              dx: 10,
              textAnchor: "start",
              verticalAnchor: fn
            },
            Ot.iconCode
          );
        }), !s.isLollipopChart && /* @__PURE__ */ n.createElement(
          St,
          {
            display: pe ? "block" : "none",
            x: H.y,
            opacity: De ? 0.5 : 1,
            y: s.barHeight / 2 + s.barHeight * H.index,
            fill: Ut,
            dx: nt,
            verticalAnchor: "middle",
            textAnchor: Ne
          },
          bs(H.value) ? "" : rt
        ), /* @__PURE__ */ n.createElement(
          St,
          {
            display: pe ? "block" : "none",
            x: H.y,
            opacity: De ? 0.5 : 1,
            y: s.barHeight / 2 + s.barHeight * H.index,
            fill: Ut,
            dx: Xe === "N/A" ? 20 : nt,
            dy: s.isLollipopChart ? -10 : 0,
            verticalAnchor: "middle",
            textAnchor: Xe === "N/A" ? "middle" : Ne
          },
          Xe
        ), s.isLollipopChart && /* @__PURE__ */ n.createElement(
          St,
          {
            display: pe ? "block" : "none",
            x: H.y,
            y: 0,
            fill: "#000000",
            dx: mt,
            textAnchor: ot,
            verticalAnchor: "middle",
            fontWeight: "normal"
          },
          bs(H.value) ? "" : rt
        ), O && !s.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          St,
          {
            x: s.yAxis.hideAxis ? 0 : 5,
            y: U.height,
            dy: 4,
            verticalAnchor: "start",
            textAnchor: "start"
          },
          s.runtime.yAxis.type === "date" ? m(v(i[U.index][s.runtime.originalXAxis.dataKey])) : T ? i[U.index][s.runtime.originalXAxis.dataKey] : p(i[U.index][s.runtime.originalXAxis.dataKey])
        ), s.isLollipopChart && s.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
          "circle",
          {
            display: Fe,
            cx: H.y,
            cy: Be * H.index + W / 2,
            r: J / 2,
            fill: yt,
            key: `circle--${H.index}`,
            "data-tooltip-html": Gt,
            "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
            style: { filter: "unset", opacity: 1 }
          }
        ), s.isLollipopChart && s.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
          "rect",
          {
            display: Fe,
            x: H.y > 10 ? H.y - J / 2 : 0,
            y: 0 - W / 2,
            width: J,
            height: J,
            fill: yt,
            key: `circle--${H.index}`,
            "data-tooltip-html": Gt,
            "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
            style: { opacity: 1, filter: "unset" }
          },
          /* @__PURE__ */ n.createElement("animate", { attributeName: "height", values: `0, ${J}`, dur: "2.5s" })
        )));
      })
    ))
  ), Object.keys(s.confidenceKeys).length > 0 ? i.map((G) => {
    let U, q, H, oe = 5;
    return U = t(E(G)) - 0.75 * s.barHeight, q = e(k(G, s.confidenceKeys.upper)), H = e(k(G, s.confidenceKeys.lower)), /* @__PURE__ */ n.createElement(
      "path",
      {
        key: `confidence-interval-h-${U}-${G[s.runtime.originalXAxis.dataKey]}`,
        stroke: "#333",
        strokeWidth: "px",
        d: `
                    M${H} ${U - oe}
                    L${H} ${U + oe}
                    M${H} ${U}
                    L${q} ${U}
                    M${q} ${U - oe}
                    L${q} ${U + oe} `
      }
    );
  }) : "");
}, Hu = {
  Vertical: ek,
  Horizontal: tk,
  StackedVertical: QS,
  StackedHorizontal: JS
}, nk = ({ xScale: e, yScale: t, seriesScale: r, xMax: a, yMax: i, handleTooltipMouseOver: o, handleTooltipMouseOff: d, handleTooltipClick: c }) => {
  const { transformedData: s, config: p } = ie.useContext(Et), m = {
    xScale: e,
    yScale: t,
    xMax: a,
    yMax: i,
    seriesScale: r
  };
  return /* @__PURE__ */ n.createElement(Hr, { component: "BarChart" }, /* @__PURE__ */ n.createElement(Os.Provider, { value: m }, /* @__PURE__ */ n.createElement(st, { left: parseFloat(p.runtime.yAxis.size) }, /* @__PURE__ */ n.createElement(Hu.StackedVertical, null), /* @__PURE__ */ n.createElement(Hu.StackedHorizontal, null), /* @__PURE__ */ n.createElement(Hu.Vertical, null), /* @__PURE__ */ n.createElement(Hu.Horizontal, null), /* @__PURE__ */ n.createElement(Nr, { key: "bars", display: p.tooltips.singleSeries ? "none" : "block", width: Number(a), height: Number(i), fill: "transparent", fillOpacity: 0.05, onMouseMove: (v) => o(v, s), onMouseOut: d, onClick: (v) => c(v, s) }))));
};
function Ha() {
  return Ha = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ha.apply(this, arguments);
}
function Fi(e) {
  var t = e.x1, r = e.x2, a = e.y1, i = e.y2;
  return {
    x1: a,
    x2: i,
    y1: t,
    y2: r
  };
}
function ig(e) {
  var t = e.left, r = t === void 0 ? 0 : t, a = e.top, i = a === void 0 ? 0 : a, o = e.className, d = e.max, c = e.min, s = e.firstQuartile, p = e.thirdQuartile, m = e.median, v = e.boxWidth, g = v === void 0 ? 10 : v, A = e.fill, k = e.fillOpacity, E = e.stroke, T = e.strokeWidth, b = e.rx, y = b === void 0 ? 2 : b, N = e.ry, C = N === void 0 ? 2 : N, P = e.valueScale, O = e.outliers, K = O === void 0 ? [] : O, W = e.horizontal, J = e.medianProps, j = J === void 0 ? {} : J, B = e.maxProps, Z = B === void 0 ? {} : B, te = e.minProps, V = te === void 0 ? {} : te, ee = e.boxProps, ce = ee === void 0 ? {} : ee, re = e.outlierProps, G = re === void 0 ? {} : re, U = e.container, q = U === void 0 ? !1 : U, H = e.containerProps, oe = H === void 0 ? {} : H, ue = e.children, ke = W ? i : r, De = ke + (g || 0) / 2, pe = P.range(), Be = P(c ?? 0), qe = P(s ?? 0), Pe = P(m ?? 0), ve = P(p ?? 0), $e = P(d ?? 0), z = {
    valueRange: pe,
    center: De,
    offset: ke,
    boxWidth: g,
    max: {
      x1: De - (g || 0) / 4,
      x2: De + (g || 0) / 4,
      y1: $e,
      y2: $e
    },
    maxToThird: {
      x1: De,
      x2: De,
      y1: $e,
      y2: ve
    },
    median: {
      x1: ke,
      x2: ke + (g || 0),
      y1: Pe,
      y2: Pe
    },
    minToFirst: {
      x1: De,
      x2: De,
      y1: qe,
      y2: Be
    },
    min: {
      x1: De - (g || 0) / 4,
      x2: De + (g || 0) / 4,
      y1: Be,
      y2: Be
    },
    box: {
      x1: ke,
      x2: g || 0,
      y1: ve,
      y2: Math.abs(ve - qe)
    },
    container: {
      x1: ke,
      x2: g || 0,
      y1: Math.min.apply(Math, pe),
      y2: Math.abs(pe[0] - pe[1])
    }
  };
  return W && (z.max = Fi(z.max), z.maxToThird = Fi(z.maxToThird), z.box.y1 = qe, z.box = Fi(z.box), z.median = Fi(z.median), z.minToFirst = Fi(z.minToFirst), z.min = Fi(z.min), z.container = Fi(z.container), z.container.y1 = Math.min.apply(Math, pe)), ue ? /* @__PURE__ */ n.createElement(n.Fragment, null, ue(z)) : /* @__PURE__ */ n.createElement(st, {
    className: _n("visx-boxplot", o)
  }, K.map(function(Re, be) {
    var He = W ? P(Re) : De, Ve = W ? De : P(Re);
    return /* @__PURE__ */ n.createElement("circle", Ha({
      key: "visx-boxplot-outlier-" + be,
      className: "visx-boxplot-outlier",
      cx: He,
      cy: Ve,
      r: 4,
      stroke: E,
      strokeWidth: T,
      fill: A,
      fillOpacity: k
    }, G));
  }), /* @__PURE__ */ n.createElement("line", Ha({
    className: "visx-boxplot-max",
    x1: z.max.x1,
    y1: z.max.y1,
    x2: z.max.x2,
    y2: z.max.y2,
    stroke: E,
    strokeWidth: T
  }, Z)), /* @__PURE__ */ n.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: z.maxToThird.x1,
    y1: z.maxToThird.y1,
    x2: z.maxToThird.x2,
    y2: z.maxToThird.y2,
    stroke: E,
    strokeWidth: T
  }), /* @__PURE__ */ n.createElement("rect", Ha({
    className: "visx-boxplot-box",
    x: z.box.x1,
    y: z.box.y1,
    width: z.box.x2,
    height: z.box.y2,
    stroke: E,
    strokeWidth: T,
    fill: A,
    fillOpacity: k,
    rx: y,
    ry: C
  }, ce)), /* @__PURE__ */ n.createElement("line", Ha({
    className: "visx-boxplot-median",
    x1: z.median.x1,
    y1: z.median.y1,
    x2: z.median.x2,
    y2: z.median.y2,
    stroke: E,
    strokeWidth: T
  }, j)), /* @__PURE__ */ n.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: z.minToFirst.x1,
    y1: z.minToFirst.y1,
    x2: z.minToFirst.x2,
    y2: z.minToFirst.y2,
    stroke: E,
    strokeWidth: T
  }), /* @__PURE__ */ n.createElement("line", Ha({
    className: "visx-boxplot-min",
    x1: z.min.x1,
    y1: z.min.y1,
    x2: z.min.x2,
    y2: z.min.y2,
    stroke: E,
    strokeWidth: T
  }, V)), q && /* @__PURE__ */ n.createElement("rect", Ha({
    x: z.container.x1,
    y: z.container.y1,
    width: z.container.x2,
    height: z.container.y2,
    fillOpacity: "0"
  }, oe)));
}
ig.propTypes = {
  max: je.number,
  min: je.number,
  firstQuartile: je.number,
  thirdQuartile: je.number,
  median: je.number,
  boxWidth: je.number,
  fill: je.string,
  fillOpacity: je.oneOfType([je.number, je.string]),
  stroke: je.string,
  strokeWidth: je.oneOfType([je.number, je.string]),
  rx: je.number,
  ry: je.number,
  outliers: je.arrayOf(je.number),
  container: je.bool,
  children: je.func
};
const rk = ({ xScale: e, yScale: t }) => {
  const { config: r, setConfig: a } = ie.useContext(Et), { boxplot: i } = r;
  ie.useEffect(() => {
    r.legend.hide === !1 && a({
      ...r,
      legend: {
        ...r.legend,
        hide: !0
      }
    });
  }, []);
  const o = `cdc-open-viz-tooltip-${r.runtime.uniqueId}`, d = (T) => `
      <strong>${T.columnCategory}</strong></br>
      ${i.labels.q1}: ${T.columnFirstQuartile}<br/>
      ${i.labels.q3}: ${T.columnThirdQuartile}<br/>
      ${i.labels.iqr}: ${T.columnIqr}<br/>
      ${i.labels.median}: ${T.columnMedian}
    `, c = (T) => Number(T.columnMax), s = (T) => Number(T.columnMin), p = (T) => Number(T.columnMedian), m = (T) => Number(T.columnThirdQuartile), v = (T) => Number(T.columnFirstQuartile), g = 0.5, A = e.bandwidth(), k = Math.min(40, A), E = pr[r == null ? void 0 : r.palette][0] ? pr[r == null ? void 0 : r.palette][0] : "#000";
  return /* @__PURE__ */ n.createElement(Hr, { component: "BoxPlot" }, /* @__PURE__ */ n.createElement(st, { className: "boxplot", key: "boxplot-group" }, i.plots.map((T, b) => {
    const y = A - k, N = 4;
    return /* @__PURE__ */ n.createElement(st, { key: `boxplotplot-${b}` }, i.plotNonOutlierValues && T.nonOutlierValues.map((C, P) => /* @__PURE__ */ n.createElement("circle", { cx: e(T.columnCategory) + Number(r.yAxis.size) + A / 2, cy: t(C), r: N, fill: "#ccc", style: { opacity: 1, fillOpacity: 1, stroke: "black" }, key: `boxplot-${b}--circle-${P}` })), /* @__PURE__ */ n.createElement(
      ig,
      {
        "data-left": e(T.columnCategory) + r.yAxis.size + y / 2 + 0.5,
        key: `box-plot-${b}`,
        min: s(T),
        max: c(T),
        left: Number(e(T.columnCategory)) + Number(r.yAxis.size) + y / 2 + 0.5,
        firstQuartile: v(T),
        thirdQuartile: m(T),
        median: p(T),
        boxWidth: k,
        fill: E,
        fillOpacity: g,
        stroke: "black",
        valueScale: t,
        outliers: i.plotOutlierValues ? T.columnOutliers : [],
        outlierProps: {
          style: {
            fill: `${E}`,
            opacity: 1
          }
        },
        medianProps: {
          style: {
            stroke: "black"
          }
        },
        boxProps: {
          style: {
            stroke: "black",
            strokeWidth: i.borders === "true" ? 1 : 0
          }
        },
        maxProps: {
          style: {
            stroke: "black"
          }
        },
        container: !0,
        containerProps: {
          "data-tooltip-html": d(T),
          "data-tooltip-id": o,
          tabIndex: -1
        }
      }
    ));
  })));
}, ak = ({ xScale: e, yScale: t }) => {
  const {
    transformedData: r,
    config: a,
    tableData: i,
    formatNumber: o,
    seriesHighlight: d,
    colorPalettes: c
  } = ie.useContext(Et), s = 4.5, p = Object.keys(a.runtime.seriesLabels).length > 1, m = Object.entries(a.columns).filter(([g, A]) => A.tooltips).map(([g, A]) => [
    A.label || A.name,
    A.name,
    {
      addColPrefix: A.prefix,
      addColSuffix: A.suffix,
      addColRoundTo: A.roundToPlace,
      addColCommas: A.commas
    }
  ]), v = (g, A, k) => `<div>
    ${a.legend.showLegendValuesTooltip && a.runtime.seriesLabels && p ? `${a.runtime.seriesLabels[A] || ""}<br/>` : ""}
    ${a.xAxis.label}: ${o(g[a.xAxis.dataKey], "bottom")} <br/>
    ${a.yAxis.label}: ${o(g[A], "left")}<br/>
   ${m.map(
    ([E, T, b]) => `${E} : ${Yf(i[k][T], "left", !1, a, b)}<br/>`
  ).join("")}
</div>`;
  return /* @__PURE__ */ n.createElement(st, { className: "scatter-plot", left: a.yAxis.size }, r.map((g, A) => a.runtime.seriesKeys.map((k, E) => {
    const T = a.legend.behavior === "highlight" && d.length > 0 && d.indexOf(k) === -1, b = a.legend.behavior === "highlight" || d.length === 0 || d.indexOf(k) !== -1, y = a != null && a.customColors ? a.customColors[E] : a.palette ? c[a.palette][E] : "#000";
    let N = {
      filter: "unset",
      opacity: 1,
      stroke: b ? "black" : ""
    };
    return /* @__PURE__ */ n.createElement(
      "circle",
      {
        key: `${A}-${E}`,
        r: s,
        cx: e(g[a.xAxis.dataKey]),
        cy: t(g[k]),
        fill: b ? y : "transparent",
        fillOpacity: T ? 0.25 : 1,
        style: N,
        "data-tooltip-html": v(g, k, A),
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      }
    );
  })));
};
function ik({ height: e, xScale: t }) {
  const {
    transformedData: r,
    config: a,
    formatNumber: i,
    twoColorPalette: o,
    updateConfig: d,
    parseDate: c,
    formatDate: s,
    currentViewport: p
  } = ie.useContext(Et), { barStyle: m, tipRounding: v, roundingStyle: g, twoColor: A } = a, k = ie.useRef([]), [E, T] = ie.useState(window.innerWidth), b = g === "standard" ? "8px" : g === "shallow" ? "5px" : g === "finger" ? "15px" : "0px", y = { small: 16, medium: 18, large: 20 };
  a.barStyle;
  const N = Number(a.xAxis.target), C = a.series[0].dataKey, P = Number(t.domain()[1]), K = r.some((G) => G[C] < 0) || N > 0 || t.domain()[0] < 0, W = a.barHasBorder === "true" ? 1 : 0, J = a.lollipopSize === "large" ? 7 : a.lollipopSize === "medium" ? 6 : 5, j = a.lollipopSize === "large" ? 14 : a.lollipopSize === "medium" ? 12 : 10, B = Math.max(t(0), Math.min(t(N), t(P))), Z = (G) => {
    if (G == null || m !== "rounded")
      return;
    let U = {};
    return G === "left" && (U = { borderRadius: `${b} 0 0 ${b}` }), G === "right" && (U = { borderRadius: `0 ${b} ${b} 0` }), v === "full" && (U = { borderRadius: b }), U;
  }, te = {
    calculate: function() {
      const U = r[0][C] < N ? "left" : "right", q = `${a.xAxis.targetLabel} ${i(a.xAxis.target || 0, "left")}`, H = Kn(q, `bold ${y[a.fontSize]}px sans-serif`);
      let oe = a.isLollipopChart ? J / 2 : Number(a.barHeight) / 2, ue = 0, ke = 0, De = !1;
      U === "right" && (ue = -10, De = H - ue < B, ke = B - H), U === "left" && (ue = 10, De = t(P) - B > H + ue, ke = B), this.text = q, this.y = oe, this.x = ke, this.padding = ue, this.showLabel = a.xAxis.showTargetLabel ? De : !1;
    }
  };
  te.calculate();
  const V = ie.useRef(null), ee = hp(V, {});
  ie.useEffect(() => {
    const G = () => {
      var U;
      T(window.innerWidth), (U = k.current) == null || U.forEach((q) => {
        !q || !q.style || (q.style.transition = "none", q.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", G), () => {
      window.removeEventListener("resize", G);
    };
  }, []);
  const [ce, re] = ie.useState(!1);
  return ie.useEffect(() => {
    ee != null && ee.isIntersecting && setTimeout(() => {
      re(!0);
    }, 100);
  }, [ee == null ? void 0 : ee.isIntersecting, a.animate]), ie.useEffect(() => {
    var G;
    (G = k.current) == null || G.forEach((U, q) => {
      if (!(!U || !U.style)) {
        if (a.animate) {
          const H = N / P * 100;
          U.style.opacity = "0", U.style.transform = `translate(${H / 1.07}%) scale(0, 1)`, setTimeout(() => {
            U.style.opacity = "1", U.style.transform = "translate(0) scale(1)", U.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          U.style.transition = "none", U.style.opacity = "0";
        a.animate || (U.style.transition = "none", U.style.opacity = "1");
      }
    });
  }, [a.animate, a, ce]), /* @__PURE__ */ n.createElement(Hr, { component: "Deviation Bar" }, /* @__PURE__ */ n.createElement(st, { left: Number(a.xAxis.size) }, r.map((G, U) => {
    const q = Number(G[C]), H = a.isLollipopChart ? J : Number(a.barHeight), oe = Number(a.barSpace), ue = Math.abs(t(q) - B), ke = t(q), De = q > N ? B : ke, pe = q < N ? "left" : "right";
    let Be = 0;
    Be = U !== 0 ? (oe + H + W) * U : Be;
    const qe = (oe + H + W) * r.length;
    a.heights.horizontal = qe;
    const ve = Kn(
      i(q, "left"),
      `normal ${y[a.fontSize]}px sans-serif`
    ) < ue - 6, $e = ke, z = Be + H / 2, Re = ke, be = Be + H / 2, He = ke, Ve = Be - H / 2, Oe = Z(pe), [Ge, Xe] = o[A.palette], rt = { left: Ge, right: Xe }, Ue = rl("#000", rt[pe]);
    let ze = ok(a.isLollipopChart, ve, j, Ue);
    const Ne = i(q, "left"), ot = a.runtime.yAxis.type === "date" ? s(c(r[U][a.runtime.originalXAxis.dataKey])) : r[U][a.runtime.originalXAxis.dataKey];
    let nt = a.runtime.yAxis.label ? `${a.runtime.yAxis.label}: ${ot}` : ot, mt = a.runtime.xAxis.label ? `${a.runtime.xAxis.label}: ${Ne}` : Ne;
    const wt = `<div>
          ${nt}<br />
          ${mt}
            </div>`;
    return /* @__PURE__ */ n.createElement(st, { key: `deviation-bar-${a.orientation}-${C}-${U}` }, /* @__PURE__ */ n.createElement(
      "foreignObject",
      {
        ref: (xt) => {
          k.current[U] = xt;
        },
        x: De,
        y: Be,
        width: ue,
        height: H,
        "data-tooltip-html": wt,
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      },
      /* @__PURE__ */ n.createElement(
        "div",
        {
          style: {
            width: ue,
            height: H,
            border: `${W}px solid #333`,
            backgroundColor: rt[pe],
            ...Oe
          }
        }
      )
    ), a.yAxis.displayNumbersOnBar && /* @__PURE__ */ n.createElement(St, { verticalAnchor: "middle", x: $e, y: z, ...ze[pe] }, i(G[C], "left")), a.isLollipopChart && a.lollipopShape === "circle" && /* @__PURE__ */ n.createElement(
      "circle",
      {
        cx: Re,
        cy: be,
        r: j / 2,
        fill: rt[pe],
        style: { filter: "unset", opacity: 1 }
      }
    ), a.isLollipopChart && a.lollipopShape === "square" && /* @__PURE__ */ n.createElement(
      "rect",
      {
        x: He,
        y: Ve,
        width: j,
        height: j,
        fill: rt[pe],
        style: { opacity: 1, filter: "unset" }
      }
    ));
  }), te.showLabel && /* @__PURE__ */ n.createElement(St, { fontWeight: "bold", dx: te.padding, verticalAnchor: "middle", x: te.x, y: te.y }, te.text), K && /* @__PURE__ */ n.createElement(mn, { from: { x: B, y: 0 }, to: { x: B, y: e }, stroke: "#333", strokeWidth: 2 })), /* @__PURE__ */ n.createElement("foreignObject", { y: e / 2, ref: V }));
}
function ok(e, t, r, a) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: r + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -r,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? a : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? a : "#000000"
    }
  };
}
const lk = ({ xScale: e, yScale: t, height: r, width: a, handleTooltipMouseOver: i, handleTooltipMouseOff: o }) => {
  var k;
  const { transformedData: d, rawData: c, config: s, seriesHighlight: p } = ie.useContext(Et), { xAxis: m, yAxis: v, legend: g, runtime: A } = s;
  return d && /* @__PURE__ */ n.createElement(Hr, { component: "ForecastingChart" }, /* @__PURE__ */ n.createElement(st, { className: "forecasting-items", key: "forecasting-items-wrapper", left: Number(v.size) }, (k = A.forecastingSeriesKeys) == null ? void 0 : k.map((E, T) => !E || !E.stages ? !1 : E.stages.map((b, y) => {
    var K;
    const { behavior: N } = g, C = c.filter((W) => W[E.stageColumn] === b.key);
    let P = N === "highlight" && p.length > 0 && p.indexOf(b.key) === -1, O = N === "highlight" || p.length === 0 || p.indexOf(b.key) !== -1;
    return /* @__PURE__ */ n.createElement(st, { className: `forecasting-areas-combo-${T}`, key: `forecasting-areas--stage-${b.key.replaceAll(" ", "-")}-${T}` }, (K = E.confidenceIntervals) == null ? void 0 : K.map((W, J) => {
      const j = Ju[b.color] || pr[b.color] || !1, B = () => O && j[2] ? j[2] : "transparent", Z = () => O && j[1] ? j[1] : "transparent";
      if (!(W.high === "" || W.low === ""))
        return /* @__PURE__ */ n.createElement(st, { key: `forecasting-areas--stage-${b.key.replaceAll(" ", "-")}--group-${y}-${J}` }, /* @__PURE__ */ n.createElement(
          iE,
          {
            curve: Xu,
            data: C,
            fill: B(),
            opacity: P ? 0.1 : 0.5,
            x: (te) => e(Date.parse(te[m.dataKey])),
            y0: (te) => t(te[W.low]),
            y1: (te) => t(te[W.high])
          }
        ), J === 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(Ir, { data: C, x: (te) => Number(e(Date.parse(te[m.dataKey]))), y: (te) => Number(t(te[W.high])), curve: Xu, stroke: Z(), strokeWidth: 1, strokeOpacity: 1 }), /* @__PURE__ */ n.createElement(Ir, { data: C, x: (te) => Number(e(Date.parse(te[m.dataKey]))), y: (te) => Number(t(te[W.low])), curve: Xu, stroke: Z(), strokeWidth: 1, strokeOpacity: 1 })));
    }));
  })), /* @__PURE__ */ n.createElement(st, { key: "tooltip-hover-section" }, /* @__PURE__ */ n.createElement(Nr, { key: "bars", width: Number(a), height: Number(r), fill: "transparent", fillOpacity: 0.05, onMouseMove: (E) => i(E, d), onMouseOut: o }))));
};
function Zu(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
function Vc(e, t) {
  const r = e.series.every(({ type: g }) => g === "Bar"), a = e.series.every(({ type: g }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(g)), i = (g) => (A) => g.reduce((k, E) => isNaN(Number(A[E])) ? k : k + Number(A[E]), 0), o = () => {
    let g = Math.max(...t.map((A) => Math.max(...e.runtime.seriesKeys.map((k) => Zu(A[k]) ? Number(s(A[k])) : 0))));
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && r) && e.visualizationSubType === "stacked") {
      const A = t.map(i(e.runtime.seriesKeys)).filter((k) => !isNaN(k));
      g = Math.max(...A);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const A = t.map(i(e.runtime.seriesKeys));
      g = Math.max(...A);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (g = Math.max(...t.map((A) => Zu(A[e.series.dataKey]) ? Number(s(A[e.series.dataKey])) : 0))), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !r && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const A = t.map(i(e.runtime.barSeriesKeys)), k = Math.max(...t.map((T) => Math.max(...e.runtime.lineSeriesKeys.map((b) => Number(s(T[b])))))), E = Math.max(...A);
      g = Math.max(E, k);
    }
    return g;
  }, d = () => {
    const g = Math.min(...t.map((A) => Math.min(...e.runtime.seriesKeys.map((k) => Zu(A[k]) ? Number(s(A[k])) : 1 / 0))));
    return String(g);
  }, c = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((g) => t.some((A) => A[g] >= 0)) : !1, s = (g) => g === null || g === "" ? "" : typeof g == "string" ? g.replace(/[,$]/g, "") : g, p = Number(o()), m = Number(d()), v = c();
  return { minValue: m, maxValue: p, existPositiveValue: v, isAllLine: a };
}
function vp({ config: e, yMax: t = 0, data: r = [], updateConfig: a }) {
  var g, A, k, E;
  const i = e.visualizationType === "Combo" && e.orientation === "vertical", o = e.series && e.series.filter((T) => T.axis === "Right").map((T) => T.dataKey);
  let { minValue: d } = Vc(e, r);
  const c = (T) => {
    if (!T)
      return [0];
    let b = [];
    return T.map((y, N) => b = [...b, ...r.map((C) => Number(C[y]))]), b;
  };
  let s = Math.max.apply(null, c(o));
  e.yAxis.rightMax > s && (s = e.yAxis.rightMax), e.yAxis.rightMin < d && (d = e.yAxis.rightMin);
  const p = ((A = (g = e.runtime) == null ? void 0 : g.barSeriesKeys) == null ? void 0 : A.length) > 0, m = ((E = (k = e.runtime) == null ? void 0 : k.lineSeriesKeys) == null ? void 0 : E.length) > 0;
  return (p || m) && d > 0 && (d = 0), { yScaleRight: Vn({
    domain: [d, s],
    range: [t, 0]
  }), hasRightAxis: i };
}
const sk = (e) => {
  const { preliminaryData: t, data: r, stroke: a, strokeWidth: i, handleLineType: o, lineType: d, seriesKey: c } = e, s = t.filter(
    (g) => g.seriesKey && g.column && g.value && g.type && g.style && g.type === "effect"
  ), p = (g) => s.find(
    (A) => A.seriesKey === c && g[A.column] === A.value && A.type === "effect" && A.style !== "Open Circles"
  );
  let m = [];
  const v = (g) => ({
    stroke: a,
    strokeWidth: i,
    strokeDasharray: g
  });
  return r.forEach((g, A) => {
    let k = p(g), E = v(o(k ? k.style : d));
    m.push(E), k && A > 0 && (m[A - 1] = v(o(k.style)));
  }), m;
}, uk = (e, t, r) => {
  const a = e == null ? void 0 : e.filter((o) => o.style.includes("Circles") && o.type === "effect").map((o) => ({
    column: o.column,
    value: o.value,
    seriesKey: o.seriesKey,
    circleSize: o.circleSize,
    style: o.style
  })), i = [];
  return t.forEach((o) => {
    a.forEach((d) => {
      if (o[d.column] === d.value && d.seriesKey === r && o[r] && d.style === "Open Circles") {
        const c = {
          data: o,
          size: d.circleSize,
          isFilled: !1
        };
        i.push(c);
      }
      if ((!d.value || o[d.column] === d.value) && d.seriesKey === r && o[r] && d.style === "Filled Circles") {
        const c = {
          data: o,
          size: d.circleSize,
          isFilled: !0
        };
        i.push(c);
      }
    });
  }), i;
}, Ac = (e) => !isNaN(parseFloat(e)) && isFinite(e), ck = (e, t, r) => {
  const a = {
    data: [],
    style: ""
  };
  if (!e.length)
    return a;
  const i = e[0], o = (c) => {
    if (!(c.type === "effect" || c.hideLineStyle))
      return c.type == "suppression" && c.value === i[t] && (!c.column || c.column === t);
  }, d = r.find(o);
  if (d && d.style) {
    const c = { ...i, [t]: 0 };
    a.data.push(c), a.style = d.style;
    let s = 1;
    for (; s < e.length && !Ac(e[s][t]); )
      s++;
    s < e.length && a.data.push(e[s]);
  } else
    a.data.push(i);
  return a;
}, dk = (e, t, r) => {
  const a = {
    data: [],
    style: ""
  };
  let i = -1;
  return r == null || r.forEach((o) => {
    if (o.type !== "effect" && e[e.length - 1][t] === o.value && o.style && (!o.column || o.column === t) && o.type == "suppression" && !o.hideLineStyle) {
      const d = e.length - 1, c = { ...e[d], [t]: 0 };
      a.data.push(c);
      let s = d - 1;
      for (; s >= 0 && !Ac(e[s][t]); )
        s--;
      s >= 0 && i !== s && (a.data.push(e[s]), i = s), a.style = o.style;
    }
  }), a;
};
function fk(e, t, r, a) {
  const i = {
    data: [],
    style: ""
  }, o = (d) => d > 0 && d < e.length - 1;
  return a == null || a.forEach((d) => {
    if (d.type === "effect" || d.hideLineStyle)
      return;
    const c = d.value;
    e.reduce((p, m, v) => (m[t] === c && o(v) && (!d.column || d.column === t) && p.push(v), p), []).forEach((p) => {
      i.style = d.style, Ac(e[p - 1][t]) && i.data.push(e[p - 1]);
      const m = e.slice(p + 1).findIndex((v) => v[t] !== c && Ac(v[t]));
      m !== -1 && i.data.push(e[p + 1 + m]);
    });
  }), i.data = jt.uniqWith(i.data, (d, c) => d[r] === c[r] && d[t] === c[t]), i;
}
const pk = (e, t, r, a) => {
  const i = ck(e, t, r), o = dk(e, t, r), d = fk(e, t, a, r);
  return [i, d, o].filter((c) => c.data.length > 0 && c.style !== "");
}, lf = (e) => {
  var C, P, O, K, W, J, j, B, Z;
  const {
    config: t,
    d: r,
    tableData: a,
    displayArea: i,
    seriesKey: o,
    tooltipData: d,
    xScale: c,
    yScale: s,
    colorScale: p,
    parseDate: m,
    yScaleRight: v,
    data: g,
    circleData: A,
    dataIndex: k,
    mode: E
  } = e, { lineDatapointStyle: T } = t, b = (P = (C = t == null ? void 0 : t.runtime) == null ? void 0 : C.series.filter((te) => te.dataKey === o)) == null ? void 0 : P[0], y = (te, V, ee, ce, re) => {
    const G = ee.runtime.seriesLabels || [];
    let U;
    return te ? U = V(G[ce] || re) : U = "transparent", ee.lineDatapointColor === "Lighter than Line" && U !== "transparent" && U && (U = ja(U).brighten(1)), U;
  }, N = (te) => (t.xAxis.type === "categorical" ? c(te) : c(m(te))) + (c.bandwidth ? c.bandwidth() / 2 : 0);
  if (E === "ALWAYS_SHOW_POINTS") {
    if (T === "hidden")
      return /* @__PURE__ */ n.createElement(n.Fragment, null);
    if (T === "always show")
      return (A == null ? void 0 : A.some(
        (V) => V[t.xAxis.dataKey] === r[t.xAxis.dataKey] && V[o] === r[o]
      )) ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(
        "circle",
        {
          cx: N(r[t.xAxis.dataKey]),
          cy: b.axis === "Right" ? v(r[b.dataKey]) : s(r[b.dataKey]),
          r: 4.5,
          opacity: r[o] ? 1 : 0,
          fillOpacity: 1,
          fill: y(i, p, t, o, o),
          style: { filter: "unset", opacity: 1 }
        }
      );
  }
  if (E === "HOVER_POINTS" && T === "hover") {
    if (!d || !o || !d.data)
      return;
    let te = (K = (O = d == null ? void 0 : d.data) == null ? void 0 : O[0]) == null ? void 0 : K[1];
    if (!te)
      return;
    let V, ee = d.data.filter((G) => G[0] === o), ce = (W = ee == null ? void 0 : ee[0]) == null ? void 0 : W[0], re = (J = ee == null ? void 0 : ee[0]) == null ? void 0 : J[2];
    return ce ? (d == null || d.data.indexOf(ce), V = (j = a == null ? void 0 : a.find((G) => G[t == null ? void 0 : t.xAxis.dataKey] === te)) == null ? void 0 : j[o], d == null ? void 0 : d.data.map((G, U) => (t.runtime.seriesLabelsAll.indexOf(te), isNaN(V) ? /* @__PURE__ */ n.createElement(n.Fragment, null) : (A == null ? void 0 : A.some((H) => H[t.xAxis.dataKey] === te)) || !V ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(
      "circle",
      {
        cx: N(te),
        cy: re === "right" ? v(V) : s(V),
        r: 4.5,
        opacity: 1,
        fillOpacity: 1,
        fill: y(i, p, t, ce, o),
        style: { filter: "unset", opacity: 1 },
        key: `line-chart-circle--${JSON.stringify(G)}--${U}`
      }
    )))) : void 0;
  }
  return E === "ISOLATED_POINTS" && E && ((V, ee) => {
    let ce = !1;
    const re = g[V], G = V > 0 ? g[V - 1] : null, U = V < g.length - 1 ? g[V + 1] : null;
    let q = !1;
    return A.forEach((H) => {
      (H == null ? void 0 : H.data[ee]) === re[ee] && (ce = !0);
    }), V === 0 && U && !U[ee] && (q = !0), V === g.length - 1 && G && !G[ee] && (q = !0), V > 0 && V < g.length - 1 && re && re[ee] && (!G || !G[ee]) && (!U || !U[ee]) && (q = !0), ce && (q = !1), q;
  })(k, o) ? /* @__PURE__ */ n.createElement(
    "circle",
    {
      cx: N(r[(B = t.xAxis) == null ? void 0 : B.dataKey]),
      cy: (b == null ? void 0 : b.axis) === "Right" ? v(r[b == null ? void 0 : b.dataKey]) : s(r[b == null ? void 0 : b.dataKey]),
      r: 5.3,
      strokeWidth: 2,
      stroke: p(t.runtime.seriesLabels[o]),
      fill: p((Z = t.runtime) == null ? void 0 : Z.seriesLabels[o])
    }
  ) : null;
}, hk = (e) => {
  var m, v;
  const { config: t, xScale: r, yScale: a, parseDate: i } = e;
  if (!((m = t == null ? void 0 : t.runtime) != null && m.series))
    return;
  const o = (g) => {
    if (t.xAxis.type === "date")
      return i(g).getTime();
    if (t.xAxis.type === "date-time")
      return new Date(g);
    if (t.xAxis.type === "categorical")
      return g;
  }, d = (g) => r.bandwidth ? r.bandwidth() / 2 + Number(g) : Number(g), c = (g) => {
    var A;
    return (A = Object.values(t.columns)) == null ? void 0 : A.filter((k) => k.tooltips).map((k) => `
        <li className='tooltip-body'>
          <strong>${k.label || k.name}</strong>: ${g[k.name]}
        </li>`).join(" ");
  }, s = (g) => `<ul> ${c(g)} </ul>`, p = (v = t.runtime) == null ? void 0 : v.series.map((g) => t.data.map((A, k) => {
    let E = A[g.dataKey], T = A[t.xAxis.dataKey];
    return /* @__PURE__ */ n.createElement(n.Fragment, { key: `bump-circle-${E}-${k}` }, /* @__PURE__ */ n.createElement(st, { left: Number(t.runtime.yAxis.size) }, E && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      "circle",
      {
        key: `bump-circle-${E}-${k}`,
        "data-tooltip-html": s(A),
        "data-tooltip-id": "bump-chart",
        r: 10,
        cx: Number(d(r(o(T)))),
        cy: Number(a(E)),
        stroke: "#CACACA",
        strokeWidth: 1,
        fill: "#E5E4E2"
      }
    ), E.toString().length === 2 ? (
      // prettier-ignore
      /* @__PURE__ */ n.createElement(
        "text",
        {
          x: Number(d(r(o(T)))) - 7,
          y: Number(a(E)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        E
      )
    ) : (
      // prettier-ignore
      /* @__PURE__ */ n.createElement(
        "text",
        {
          x: Number(d(r(o(T)))) - 4,
          y: Number(a(E)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        E
      )
    ))));
  }));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, p);
}, um = (e) => {
  var te;
  const {
    getXAxisData: t,
    getYAxisData: r,
    handleTooltipClick: a,
    handleTooltipMouseOff: i,
    handleTooltipMouseOver: o,
    tooltipData: d,
    xMax: c,
    xScale: s,
    yMax: p,
    yScale: m
  } = e, { colorScale: v, config: g, formatNumber: A, handleLineType: k, isNumber: E, parseDate: T, seriesHighlight: b, tableData: y, transformedData: N, updateConfig: C, brushConfig: P, clean: O } = ie.useContext(Et), { yScaleRight: K } = vp({ config: g, yMax: p, data: N, updateConfig: C });
  if (!o)
    return;
  const { lineDatapointStyle: W, showLineSeriesLabels: J, legend: j } = g;
  let B = N, Z = y;
  return P.data.length > 0 && ((te = g.brush) != null && te.active) && (B = O(P.data), Z = O(P.data)), /* @__PURE__ */ n.createElement(Hr, { component: "LineChart" }, /* @__PURE__ */ n.createElement(st, { left: Number(g.runtime.yAxis.size) }, " ", (g.runtime.lineSeriesKeys || g.runtime.seriesKeys).map((V, ee) => {
    var De;
    let ce = g.runtime.series.filter((pe) => pe.dataKey === V)[0].type;
    const re = g.runtime.series.filter((pe) => pe.dataKey === V), G = re[0].axis ? re[0].axis : "left";
    let U = j.behavior === "highlight" || b.length === 0 || b.indexOf(V) !== -1;
    const q = uk(g == null ? void 0 : g.preliminaryData, Z, V);
    let H = sk({
      preliminaryData: g.preliminaryData,
      data: Z,
      stroke: v(g.runtime.seriesLabels[V]),
      strokeWidth: re[0].weight || 2,
      handleLineType: k,
      lineType: ce,
      seriesKey: V
    });
    const oe = pk(
      y,
      V,
      g.preliminaryData,
      g.xAxis.dataKey
    ), ue = (De = g == null ? void 0 : g.preliminaryData) == null ? void 0 : De.filter((pe) => pe.style && !pe.style.includes("Circles"));
    let ke = (pe) => s(t(pe)) + (s.bandwidth ? s.bandwidth() / 2 : 0);
    return /* @__PURE__ */ n.createElement(
      st,
      {
        key: `series-${V}`,
        opacity: j.behavior === "highlight" && b.length > 0 && b.indexOf(V) === -1 ? 0.5 : 1,
        display: j.behavior === "highlight" || b.length === 0 && !j.dynamicLegend || b.indexOf(V) !== -1 ? "block" : "none"
      },
      /* @__PURE__ */ n.createElement(
        Nr,
        {
          key: "bars",
          width: Number(c),
          height: Number(p),
          fill: "transparent",
          fillOpacity: 0.05,
          onMouseMove: (pe) => o(pe, y),
          onMouseOut: i,
          onClick: (pe) => a(pe, B)
        }
      ),
      B.map((pe, Be) => pe[V] !== void 0 && pe[V] !== "" && pe[V] !== null && E(pe[V]) && /* @__PURE__ */ n.createElement(n.Fragment, { key: `series-${V}-point-${Be}` }, g.labels && /* @__PURE__ */ n.createElement(
        St,
        {
          x: ke(pe),
          y: G === "Right" ? K(r(pe, V)) : m(r(pe, V)),
          fill: "#000",
          textAnchor: "middle"
        },
        A(pe[V], "left")
      ), W === "always show" && /* @__PURE__ */ n.createElement(
        lf,
        {
          mode: "ALWAYS_SHOW_POINTS",
          dataIndex: Be,
          circleData: q,
          tableData: y,
          data: B,
          d: pe,
          config: g,
          seriesKey: V,
          displayArea: U,
          tooltipData: d,
          xScale: s,
          yScale: m,
          colorScale: v,
          parseDate: T,
          yScaleRight: K,
          seriesAxis: G,
          key: `line-circle--${Be}`
        }
      ), /* @__PURE__ */ n.createElement(
        lf,
        {
          mode: "ISOLATED_POINTS",
          dataIndex: Be,
          tableData: y,
          circleData: q,
          data: B,
          d: pe,
          config: g,
          seriesKey: V,
          displayArea: U,
          tooltipData: d,
          xScale: s,
          yScale: m,
          colorScale: v,
          parseDate: T,
          yScaleRight: K,
          seriesAxis: G,
          key: `isolated-circle-${Be}`
        }
      ))),
      /* @__PURE__ */ n.createElement(n.Fragment, null, W === "hover" && /* @__PURE__ */ n.createElement(
        lf,
        {
          tableData: y,
          dataIndex: 0,
          mode: "HOVER_POINTS",
          circleData: q,
          data: B,
          config: g,
          seriesKey: V,
          displayArea: U,
          tooltipData: d,
          xScale: s,
          yScale: m,
          colorScale: v,
          parseDate: T,
          yScaleRight: K,
          seriesAxis: G
        }
      )),
      ue.length > 0 ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        By,
        {
          curve: xs[re[0].lineType],
          segments: B.map((pe) => [pe]),
          segmentation: "x",
          x: (pe) => ke(pe),
          y: (pe) => G === "Right" ? K(r(pe, V)) : m(Number(r(pe, V))),
          styles: H,
          defined: (pe, Be) => pe[V] !== "" && pe[V] !== null && pe[V] !== void 0
        }
      ), oe.map((pe, Be) => /* @__PURE__ */ n.createElement(
        Ir,
        {
          key: Be,
          data: pe.data,
          x: (qe) => ke(qe),
          y: (qe) => G === "Right" ? K(r(qe, V)) : m(Number(r(qe, V))),
          stroke: v(g.runtime.seriesLabels[V]),
          strokeWidth: re[0].weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: k(pe.style),
          defined: (qe, Pe) => qe[V] !== "" && qe[V] !== null && qe[V] !== void 0
        }
      ))) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        Ir,
        {
          curve: xs[re[0].lineType],
          data: g.visualizationType == "Bump Chart" ? B : g.xAxis.type === "date-time" || g.xAxis.type === "date" ? B.sort((pe, Be) => {
            let qe = t(pe), Pe = t(Be);
            return qe < Pe ? -1 : Pe < qe ? 1 : 0;
          }) : B,
          x: (pe) => ke(pe),
          y: (pe) => G === "Right" ? K(r(pe, V)) : m(Number(r(pe, V))),
          stroke: v(g.runtime.seriesLabels[V]),
          strokeWidth: re[0].weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: ce ? k(ce) : 0,
          defined: (pe, Be) => pe[V] !== "" && pe[V] !== null && pe[V] !== void 0
        }
      )),
      q.map((pe, Be) => /* @__PURE__ */ n.createElement(
        "circle",
        {
          key: Be,
          cx: ke(pe.data),
          cy: G === "Right" ? K(r(pe.data, V)) : m(Number(r(pe.data, V))),
          r: pe.size,
          strokeWidth: re[0].weight || 2,
          stroke: v ? v(g.runtime.seriesLabels[V]) : "#000",
          fill: pe.isFilled ? v ? v(g.runtime.seriesLabels[V]) : "#000" : "#fff"
        }
      )),
      g.animate && /* @__PURE__ */ n.createElement(
        Ir,
        {
          className: "animation",
          curve: xs[re[0].lineType],
          data: B,
          x: (pe) => ke(pe),
          y: (pe) => G === "Right" ? K(r(pe, V)) : m(Number(r(pe, V))),
          stroke: "#fff",
          strokeWidth: 3,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: ce ? k(ce) : 0,
          defined: (pe, Be) => pe[V] !== "" && pe[V] !== null && pe[V] !== void 0
        }
      ),
      J && (g.runtime.lineSeriesKeys || g.runtime.seriesKeys).map((pe) => {
        let Be;
        for (let qe = B.length - 1; qe >= 0; qe--)
          if (B[qe][pe]) {
            Be = B[qe];
            break;
          }
        return Be ? /* @__PURE__ */ n.createElement(
          "text",
          {
            x: ke(Be) + 5,
            y: m(r(Be, pe)),
            alignmentBaseline: "middle",
            fill: g.colorMatchLineSeriesLabels && v ? v(g.runtime.seriesLabels[pe] || pe) : "black"
          },
          g.runtime.seriesLabels[pe] || pe
        ) : /* @__PURE__ */ n.createElement(n.Fragment, null);
      })
    );
  }), g.legend.dynamicLegend && b.length === 0 && /* @__PURE__ */ n.createElement(St, { x: c / 2, y: p / 2, fill: "black", textAnchor: "middle", color: "black" }, g.legend.dynamicLegendChartMessage)), g.visualizationType === "Bump Chart" && /* @__PURE__ */ n.createElement(hk, { config: g, xScale: s, yScale: m }));
}, mk = ({ xScale: e, yScale: t, config: r, height: a, width: i, handleTooltipMouseOff: o, handleTooltipMouseOver: d, forestPlotRightLabelRef: c }) => {
  const { rawData: s, updateConfig: p } = ie.useContext(Et), { forestPlot: m } = r, v = r.xAxis.tickWidthMax + 10, [g, A] = ie.useState(!1);
  ie.useEffect(() => {
    try {
      const C = ["estimateField", "lower", "upper", "estimateRadius"], P = r, O = 10;
      for (let K = 0; K < O; K++)
        C.forEach((W) => {
          var J;
          r.forestPlot[W] && r.forestPlot[W] !== ((J = P.columns[r.forestPlot[`additionalColumn${K}`]]) == null ? void 0 : J.name) && (delete P.columns[`additionalColumn${K}`], P.columns[r.forestPlot[W]] = {}, P.columns[r.forestPlot[W]].dataKey = P.forestPlot[W], P.columns[r.forestPlot[W]].name = P.forestPlot[W], P.columns[r.forestPlot[W]].dataTable = !0, P.columns[r.forestPlot[W]].tooltips = !0, P.columns[r.forestPlot[W]].label = P.forestPlot[W]);
        });
      r.forestPlot.radius.scalingColumn && (P.columns[r.forestPlot.radius.scalingColumn] = {}, P.columns[r.forestPlot.radius.scalingColumn].dataKey = P.forestPlot.radius.scalingColumn, P.columns[r.forestPlot.radius.scalingColumn].name = P.forestPlot.radius.scalingColumn, P.columns[r.forestPlot.radius.scalingColumn].label = P.forestPlot.radius.scalingColumn, P.columns[r.forestPlot.radius.scalingColumn].dataTable = !0, P.columns[r.forestPlot.radius.scalingColumn].tooltips = !0), P.table.showVertical && (P.table.indexLabel = r.xAxis.dataKey), p(P);
    } catch (C) {
      console.log(C.message);
    }
  }, []), ie.useEffect(() => {
    !g && r.forestPlot.type === "Logarithmic" && (p({
      ...r,
      dataFormat: {
        ...r.dataFormat,
        roundTo: 2
      }
    }), A(!0));
  }, [r.forestPlot.type]);
  const k = r.data.find((C) => C[r.xAxis.dataKey] === r.forestPlot.pooledResult.column), E = k ? [
    { x: e(k[r.forestPlot.lower]), y: a - Number(r.forestPlot.rowHeight) },
    { x: e(k[r.forestPlot.estimateField]), y: a - m.pooledResult.diamondHeight - Number(r.forestPlot.rowHeight) },
    { x: e(k[r.forestPlot.upper]), y: a - Number(r.forestPlot.rowHeight) },
    { x: e(k[r.forestPlot.estimateField]), y: a + m.pooledResult.diamondHeight - Number(r.forestPlot.rowHeight) },
    { x: e(k[r.forestPlot.lower]), y: a - Number(r.forestPlot.rowHeight) }
  ] : [], T = r.forestPlot.rowHeight, b = [
    { x: 0, y: T },
    { x: i, y: T }
  ], y = [
    { x: 0, y: a },
    { x: i, y: a }
  ], N = Object.entries(r.columns).map((C) => C[1]).filter((C) => C.forestPlot === !0);
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(st, { width: i }, m.title && /* @__PURE__ */ n.createElement(St, { className: "forest-plot--title", x: m.type === "Linear" ? e(0) : e(1), y: 0, textAnchor: "middle", verticalAnchor: "start", fontSize: Pi(r.fontSize), fill: "black" }, m.title), m.lineOfNoEffect.show && m.type === "Linear" && /* @__PURE__ */ n.createElement(mn, { from: { x: e(0), y: 0 + T }, to: { x: e(0), y: a }, className: "forestplot__line-of-no-effect", stroke: m.regression.baseLineColor || "black" }), m.lineOfNoEffect.show && m.type === "Logarithmic" && /* @__PURE__ */ n.createElement(mn, { from: { x: e(1), y: 0 + T }, to: { x: e(1), y: a }, className: "forestplot__line-of-no-effect", stroke: m.regression.baseLineColor || "black" }), s.map((C, P) => {
    const O = Vn({
      domain: s.map((Z) => Z[m.radius.scalingColumn]),
      range: [m.radius.min, m.radius.max]
    }), K = m.radius.scalingColumn !== "" ? O(s[P][m.radius.scalingColumn]) : 4, W = m.colors.shape ? m.colors.shape : "black", J = m.colors.line ? m.colors.line : "black", j = 4;
    return C[r.xAxis.dataKey] === m.pooledResult.column ? /* @__PURE__ */ n.createElement(Ir, { data: E, x: (Z) => Z.x, y: (Z) => Z.y - Pi(r.fontSize) / 2, stroke: "black", strokeWidth: 2, fill: "black", curve: wf }) : /* @__PURE__ */ n.createElement(st, null, /* @__PURE__ */ n.createElement(
      "path",
      {
        stroke: J,
        strokeWidth: 1,
        className: "lower-ci",
        d: `
                    M${e(C[m.lower])} ${t(P) - Number(j)}
                    L${e(C[m.lower])} ${t(P) + Number(j)}
                `
      }
    ), /* @__PURE__ */ n.createElement(
      "path",
      {
        stroke: J,
        strokeWidth: 1,
        className: "upper-ci",
        d: `
                    M${e(C[m.upper])} ${t(P) - Number(j)}
                    L${e(C[m.upper])} ${t(P) + Number(j)}
                `
      }
    ), /* @__PURE__ */ n.createElement("line", { stroke: J, className: `line-${C[r.yAxis.dataKey]}`, key: P, x1: e(C[m.lower]), x2: e(C[m.upper]), y1: t(P), y2: t(P) }), m.shape === "circle" && /* @__PURE__ */ n.createElement(Kg, { className: "forest-plot--circle", cx: e(Number(C[m.estimateField])), cy: t(P), r: m.radius.scalingColumn !== "" ? O(s[P][m.radius.scalingColumn]) : 4, fill: W, style: { opacity: 1, filter: "unset" } }), m.shape === "square" && /* @__PURE__ */ n.createElement("rect", { className: "forest-plot--square", x: e(Number(C[m.estimateField])), y: t(P) - K / 2, width: K, height: K, fill: W, style: { opacity: 1, filter: "unset" } }), m.shape === "text" && /* @__PURE__ */ n.createElement(St, { className: "forest-plot--text", x: e(Number(C[m.estimateField])), y: t(P), textAnchor: "middle", verticalAnchor: "middle", fontSize: Pi(r.fontSize), fill: W }, C[m.estimateField]));
  }), E && m.regression.showDiamond && /* @__PURE__ */ n.createElement(Ir, { data: E, x: (C) => C.x, y: (C) => C.y, stroke: "black", strokeWidth: 2, fill: m.regression.baseLineColor, curve: wf }), m.regression.description && /* @__PURE__ */ n.createElement(St, { x: 0 - Number(r.xAxis.size), width: i, y: a - r.forestPlot.rowHeight - Number(m.rowHeight) / 3, verticalAnchor: "start", textAnchor: "start", style: { fontWeight: "bold", fontSize: 12 } }, m.regression.description), /* @__PURE__ */ n.createElement(Nr, { key: "forest-plot-tooltip-area", className: "forest-plot-tooltip-area", width: i, height: a, fill: "transparent", fillOpacity: 0.5, onMouseMove: (C) => d(C, s), onMouseOut: o })), /* @__PURE__ */ n.createElement(mn, { from: b[0], to: b[1], style: { stroke: "black", strokeWidth: 2 }, className: "forestplot__top-line" }), /* @__PURE__ */ n.createElement(mn, { from: y[0], to: y[1], style: { stroke: "black", strokeWidth: 2 }, className: "forestplot__bottom-line" }), N.map((C) => s.map((P, O) => /* @__PURE__ */ n.createElement(St, { className: `${P[C.name]}`, x: C.forestPlotAlignRight ? i : C.forestPlotStartingPoint, y: t(O), textAnchor: C.forestPlotAlignRight ? "end" : "start", verticalAnchor: "middle", fontSize: Pi(r.fontSize), fill: "black" }, P[C.name]))), !m.hideDateCategoryCol && s.map((C, P) => /* @__PURE__ */ n.createElement(St, { className: `${C[r.xAxis.dataKey]}`, x: 0, y: t(P), textAnchor: "start", verticalAnchor: "middle", fontSize: Pi(r.fontSize), fill: "black" }, C[r.xAxis.dataKey])), !m.hideDateCategoryCol && r.xAxis.dataKey && /* @__PURE__ */ n.createElement(St, { className: r.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fontSize: Pi(r.fontSize), fill: "black" }, r.xAxis.dataKey), N.map((C) => /* @__PURE__ */ n.createElement(St, { className: `${C.label}`, x: C.forestPlotAlignRight ? i : C.forestPlotStartingPoint, y: 0, textAnchor: C.forestPlotAlignRight ? "end" : "start", verticalAnchor: "start", fontSize: Pi(r.fontSize), fill: "black" }, C.label)), m.leftLabel && /* @__PURE__ */ n.createElement(St, { className: "forest-plot__left-label", x: m.type === "Linear" ? e(0) - 25 : e(1) - 25, y: a + v, textAnchor: "end", verticalAnchor: "start" }, m.leftLabel), m.rightLabel && /* @__PURE__ */ n.createElement(St, { innerRef: c, className: "forest-plot__right-label", x: m.type === "Linear" ? e(0) + 25 : e(1) + 25, y: a + v, textAnchor: "start", verticalAnchor: "start" }, m.rightLabel));
}, yk = ({ width: e, height: t, originalWidth: r }) => {
  var y, N, C;
  const { config: a, colorScale: i, transformedData: o, formatNumber: d, seriesHighlight: c } = ie.useContext(Et);
  if (!a || ((y = a == null ? void 0 : a.series) == null ? void 0 : y.length) < 2)
    return;
  const s = a.barHasBorder === "true" ? 1 : 0, p = e / 2, m = { small: 16, medium: 18, large: 20 }, v = 1.02, g = {
    parentKey: (N = a.dataDescription) == null ? void 0 : N.seriesKey,
    dataKey: a.series[0].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[0].dataKey] || a.series[0].dataKey,
    color: i(a.runtime.seriesLabels[a.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((P) => P[a.series[0].dataKey])
    ),
    labelColor: ""
  }, A = {
    parentKey: (C = a.dataDescription) == null ? void 0 : C.seriesKey,
    dataKey: a.series[1].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[1].dataKey] || a.series[1].dataKey,
    color: i(a.runtime.seriesLabels[a.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((P) => P[a.series[1].dataKey])
    ),
    labelColor: ""
  }, k = Vn({
    domain: [0, Math.max(g.max * v, A.max * 1.1)],
    range: [0, p]
  });
  g.labelColor = g.color ? rl("#000", g.color) : "#000", A.labelColor = A.color ? rl("#000", A.color) : "#000";
  const E = a.yAxis.label ? `${a.yAxis.label}: ` : "", T = (P) => {
    var O;
    return `<p>
				${(O = a.dataDescription) == null ? void 0 : O.seriesKey}: ${g.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${P[a.xAxis.dataKey]}<br/>
				${E}${d(P[g.dataKey], "left")}
			</p>`;
  }, b = (P) => {
    var O;
    return `<p>
				${(O = a.dataDescription) == null ? void 0 : O.seriesKey}: ${A.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${P[a.xAxis.dataKey]}<br/>
				${E}${d(P[A.dataKey], "left")}
			</p>`;
  };
  return e > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				`), /* @__PURE__ */ n.createElement(
    "svg",
    {
      id: "cdc-visualization__paired-bar-chart",
      width: r,
      height: t,
      viewBox: `0 0 ${e + Number(a.runtime.yAxis.size)} ${t}`,
      role: "img",
      tabIndex: 0
    },
    /* @__PURE__ */ n.createElement("title", null, `Paired bar chart graphic with the title ${a.title ? a.title : "No Title Found"}`),
    /* @__PURE__ */ n.createElement(st, { top: 0, left: Number(a.xAxis.size) }, o.filter((P) => a.series[0].dataKey === g.dataKey).map((P, O) => {
      var ee, ce;
      let K = a.legend.behavior === "highlight" && c.length > 0 && c.indexOf(a.series[0].dataKey) === -1, W = a.legend.behavior === "highlight" || c.length === 0 || c.indexOf(a.series[0].dataKey) !== -1, J = k(P[a.series[0].dataKey]), j = Number(a.barHeight) ? Number(a.barHeight) : 25, B = 0;
      B = O !== 0 ? (Number(a.barSpace) + j + s) * O : B;
      const Z = (Number(a.barSpace) + j + s) * o.length;
      a.heights.horizontal = Z;
      const V = Kn(
        d(P[g.dataKey], "left"),
        `normal ${m[a.fontSize]}px sans-serif`
      ) < J - 5;
      return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(st, { key: `group-${g.dataKey}-${P[a.xAxis.dataKey]}`, className: "horizontal" }, /* @__PURE__ */ n.createElement(
        Nr,
        {
          id: `bar-${g.dataKey}-${P[(ee = a.dataDescription) == null ? void 0 : ee.xKey]}`,
          className: "bar group-1",
          key: `bar-${g.dataKey}-${P[(ce = a.dataDescription) == null ? void 0 : ce.xKey]}`,
          x: p - J,
          y: B,
          width: k(P[a.series[0].dataKey]),
          height: j,
          fill: g.color,
          "data-tooltip-html": T(P),
          "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
          stroke: "#333",
          strokeWidth: s,
          opacity: K ? 0.5 : 1,
          display: W ? "block" : "none",
          tabIndex: -1
        }
      ), a.yAxis.displayNumbersOnBar && W && /* @__PURE__ */ n.createElement(
        St,
        {
          textAnchor: V ? "start" : "end",
          dx: V ? 5 : -5,
          verticalAnchor: "middle",
          x: p - J,
          y: B + a.barHeight / 2,
          fill: V ? g.labelColor : "#000"
        },
        d(P[g.dataKey], "left")
      )));
    }), o.filter((P) => a.series[1].dataKey === A.dataKey).map((P, O) => {
      var ee, ce, re;
      let K = k(P[a.series[1].dataKey]), W = a.legend.behavior === "highlight" && c.length > 0 && c.indexOf(a.series[1].dataKey) === -1, J = a.legend.behavior === "highlight" || c.length === 0 || c.indexOf(a.series[1].dataKey) !== -1, j = a.barHeight ? Number(a.barHeight) : 25, B = 0;
      B = O !== 0 ? (Number(a.barSpace) + j + s) * O : B;
      const Z = (Number(a.barSpace) + j + s) * o.length;
      a.heights.horizontal = Z;
      const V = Kn(
        d(P[A.dataKey], "left"),
        `normal ${m[a.fontSize]}px sans-serif`
      ) < K - 5;
      return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `
                      .bar-${A.dataKey}-${P[a.xAxis.dataKey]} {
                          transform-origin: ${p}px ${B}px
                      }
							      `), /* @__PURE__ */ n.createElement(st, { key: `group-${A.dataKey}-${P[(ee = a.dataDescription) == null ? void 0 : ee.xKey]}`, className: "horizontal" }, /* @__PURE__ */ n.createElement(
        Nr,
        {
          id: `bar-${A.dataKey}-${P[(ce = a.dataDescription) == null ? void 0 : ce.xKey]}`,
          className: "bar group-2",
          key: `bar-${A.dataKey}-${P[(re = a.dataDescription) == null ? void 0 : re.xKey]}`,
          x: p,
          y: B,
          width: k(P[a.series[1].dataKey]),
          height: j,
          fill: A.color,
          "data-tooltip-html": b(P),
          "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
          strokeWidth: s,
          stroke: "#333",
          opacity: W ? 0.5 : 1,
          display: J ? "block" : "none",
          tabIndex: -1
        }
      ), a.yAxis.displayNumbersOnBar && J && /* @__PURE__ */ n.createElement(
        St,
        {
          textAnchor: V ? "end" : "start",
          dx: V ? -5 : 5,
          verticalAnchor: "middle",
          x: p + K,
          y: B + a.barHeight / 2,
          fill: V ? A.labelColor : "#000"
        },
        d(P[A.dataKey], "left")
      )));
    }))
  ));
}, gk = ({ yMax: e, leftSize: t, max: r, xMax: a }) => {
  var b;
  const { config: i } = ie.useContext(Et), { fontSize: o } = _s(), { orientation: d } = i, c = (y, N = "#f1f1f1") => {
    try {
      return ja(y).hex();
    } catch {
      return N;
    }
  }, s = (b = i.yAxis) == null ? void 0 : b.categories, v = ((y) => {
    const N = Object.keys(y), C = N[N.length - 1];
    if (y[C] === "") {
      const P = N.slice(0, -1).reduce((K, W) => {
        const J = parseInt(y[W], 10);
        return K + (isNaN(J) ? 0 : J);
      }, 0), O = r - P;
      y[C] = O.toString();
    }
    return [y];
  })(((y) => [...y].reduce((C, P) => (C[P.label] = P.height, C), {}))(s)), g = 0, A = tc({
    domain: [g],
    padding: 0,
    range: [0, t]
  }), k = Vn({
    domain: [0, r],
    range: [e, 0],
    clamp: !0
  }), E = Bi({
    domain: s.map((y) => y == null ? void 0 : y.label),
    range: s.map((y) => {
      var N;
      return c((N = y == null ? void 0 : y.color) == null ? void 0 : N.trim());
    })
  }), T = Object.keys(v[0]);
  return /* @__PURE__ */ n.createElement(st, { left: t - A.bandwidth(), top: 0 }, /* @__PURE__ */ n.createElement(
    zy,
    {
      data: v,
      keys: T,
      x: () => A(g),
      xScale: A,
      yScale: k,
      color: E
    },
    (y) => y.map(
      (N) => N.bars.map((C) => {
        const P = i.yAxis.categories.length - 1 === N.index, O = o[i.fontSize] / 1.3, K = ja(C.color).luminance() < 0.4 ? "#fff" : "#000", W = Kn(C.key, `normal ${O}px sans-serif`), J = Number(W) < C.width && C.height > O, j = `<ul>
              <li class="tooltip-heading""> Label : ${C.key}  </li>
                    </li></ul>`;
        return /* @__PURE__ */ n.createElement(st, { key: `${N.index}--${C.index}--${d}` }, /* @__PURE__ */ n.createElement(
          st,
          {
            key: `bar-stack-${N.index}-${C.index}`,
            id: `barStack${N.index}-${C.index}`,
            className: "stack vertical"
          },
          Fs({
            type: "axisBar",
            config: i,
            index: N.index,
            background: E(C.key),
            borderColor: "#333",
            borderStyle: "solid",
            borderWidth: 0,
            width: A.bandwidth(),
            height: C.height,
            x: C.x,
            y: C.y,
            tooltipHtml: j,
            tooltipId: `cdc-open-viz-tooltip-${i.runtime.uniqueId}`
          }),
          /* @__PURE__ */ n.createElement(
            St,
            {
              display: J ? "block" : "none",
              key: `text-${N.index}-${C.index}`,
              x: C.x + A.bandwidth() / 2,
              y: C.y + C.height / 2,
              fill: K,
              textAnchor: "middle",
              verticalAnchor: "middle",
              style: { fontSize: O }
            },
            C.key
          ),
          i.runtime.yAxis.gridLines && /* @__PURE__ */ n.createElement(
            mn,
            {
              from: { x: C.x + A.bandwidth(), y: C.y },
              to: { x: a + A.bandwidth(), y: C.y },
              stroke: "#d6d6d6"
            }
          ),
          !P && /* @__PURE__ */ n.createElement("rect", { x: C.x, y: C.y, width: C.width, height: 1, fill: "#fff" }),
          /* @__PURE__ */ n.createElement("rect", { x: C.x + C.width, y: 0, width: 1, height: e, fill: "#000" })
        ));
      })
    )
  ));
};
function vk({ orientation: e, heights: t, visualizationType: r }, a) {
  const o = e === "vertical" || r === "Forest Plot", c = (t == null ? void 0 : t.mobileVertical) && Wg(a) ? "mobileVertical" : "vertical";
  return o ? c : "horizontal";
}
function xk({ heights: e, orientation: t, visualizationType: r }, a) {
  if (!e)
    return 0;
  const i = vk({ orientation: t, heights: e, visualizationType: r }, a), o = Number(e == null ? void 0 : e[i]);
  return isNaN(o) ? 0 : o;
}
const og = ({ config: e, minValue: t, maxValue: r, existPositiveValue: a, data: i, isAllLine: o, tableData: d }) => {
  let c = 0, s = 0, p = 0, m = 0;
  if (!i)
    return { min: c, max: s };
  const v = () => Hc(e.visualizationType, i, e.allowLineToBarGraph), { visualizationType: g, series: A } = e, { max: k, min: E } = e.runtime.yAxis, T = e.yAxis.type === "logarithmic", b = a ? k >= r : k >= 0, y = T ? E >= 0 : E <= 0 && t >= 0 || E <= t && t < 0;
  c = E && y ? E : t, s = k && b ? k : Number.MIN_VALUE;
  const { lower: N, upper: C } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (N && C && e.visualizationType === "Bar") {
    const P = c < 0 ? 1.1 : 0;
    s = Math.max(r, Math.max(...i.flatMap((O) => [O[C], O[N]])) * 1.15), c = Math.min(t, Math.min(...i.flatMap((O) => [O[C], O[N]])) * 1.15) * P;
  }
  if (e.series.filter((P) => (P == null ? void 0 : P.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: P }
    } = e;
    if ((P == null ? void 0 : P.length) > 0) {
      let O = [];
      P.forEach((j) => {
        var B;
        (B = j.confidenceIntervals) == null || B.map((Z) => {
          O.push(Z.high), O.push(Z.low);
        });
      });
      const K = i.map((j) => O.map((B) => j[B])), W = Math.max.apply(
        null,
        K.map((j) => j[0])
      ), J = Math.min.apply(
        null,
        K.map((j) => j[1])
      );
      W > s && (s = W), J < c && (c = J);
    }
  }
  if (g === "Combo")
    try {
      if (!i)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let P = A.filter((W) => W.axis === "Left"), O = A.filter((W) => W.axis === "Right");
      const K = (W, J, j, B = "left") => {
        let Z = 0;
        return (J.map((V) => V.dataKey) || []).forEach((V) => {
          let ee = J.find((G) => G.dataKey === V), ce = W.map((G) => G[V]), re = Math.max.apply(null, ce);
          e.visualizationSubType === "stacked" && B === "left" && ee.type === "Bar" && (Z += re), re > j && (j = re), j < Z && (j = Z);
        }), j;
      };
      p = K(i, P, p, "left"), m = K(i, O, m, "right"), p < k && (p = k);
    } catch (P) {
      console.error(P.message);
    }
  if ((g === "Bar" || v() || g === "Combo" && !o) && c > 0 && (c = 0), (e.visualizationType === "Bar" || v() || e.visualizationType === "Combo" && !o) && c < 0 && (c = c * 1.1), e.visualizationType === "Combo" && o && ((E == null || E === "") && c > 0 && (c = 0), E)) {
    const P = T ? E >= 0 && E < t : E < t;
    c = E && P ? E : t;
  }
  if (e.visualizationType === "Deviation Bar" && c > 0) {
    const P = Number(E) < Math.min(t, Number(e.xAxis.target));
    c = E && P ? E : 0;
  }
  if (e.visualizationType === "Line" && !v()) {
    const P = T ? E >= 0 && E < t : E < t, O = d == null ? void 0 : d.some((K, W) => {
      var J;
      return (J = e.preliminaryData) == null ? void 0 : J.some((j) => {
        var V;
        if (j.type !== "suppression" || !j.style)
          return !1;
        const B = jt.pick(K, (V = e.runtime) == null ? void 0 : V.seriesKeys), Z = jt.values(B).includes(j.value);
        return (j.column ? K[j.column] === j.value : Z) && (W === 0 || W === d.length - 1);
      });
    });
    c = E && P ? E : O ? 0 : t;
  }
  if (s === Number.MIN_VALUE && (s = a ? r : 0), e.runtime.yAxis.paddingPercent) {
    let P = (s - c) * e.runtime.yAxis.paddingPercent;
    c -= P, s += P;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const P = i.map((K) => K[e.series[0].dataKey]), O = Math.max(...P).toString().length;
    switch (!0) {
      case (O > 8 && O <= 12):
        s = s * 1.3;
        break;
      case (O > 4 && O <= 7):
        s = s * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (c < 0 ? (s *= 1 + e.yAxis.scalePadding * 2 / 100, c *= 1 + e.yAxis.scalePadding * 2 / 100) : s *= 1 + e.yAxis.scalePadding / 100), { min: c, max: s, leftMax: p, rightMax: m };
}, Zr = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, bk = (e) => {
  let { xAxisDataMapped: t, xMax: r, yMax: a, min: i, max: o, config: d, data: c } = e;
  const { rawData: s, dimensions: p } = ie.useContext(Et), [m] = p, v = d.runtime.barSeriesKeys || d.runtime.seriesKeys, g = d.runtime.xAxis.type, A = d.orientation === "horizontal", { visualizationType: k } = d;
  let E = null, T = null, b = null, y = null, N = null, C = null, P = Vn({
    domain: [0, 100],
    range: [0, r]
  });
  if (A && (E = wk({ min: i * 1.03, ...e }), E.type = d.yAxis.type === "logarithmic" ? Zr.LOG : Zr.LINEAR, T = Ck(g, t), T.rangeRound([0, a]), N = Ak(v, [0, a])), A || (E = Vu(t, [0, r], 1 - d.barThickness), T = Tk(e), N = Vu(v, [0, E.bandwidth()], 0)), d.xAxis.type === "date" && !A) {
    const O = t ? t.sort() : [];
    E = Vu(O, [0, r], 1 - d.barThickness);
  }
  if (d.xAxis.type === "date-time") {
    let O = Math.min(...t.map(Number)), K = Math.max(...t.map(Number));
    O -= (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (K - O), K += k === "Line" ? 0 : (d.xAxis.padding ? d.xAxis.padding * 0.01 : 0) * (K - O), E = Pv({
      domain: [O, K],
      range: [0, r]
    }), E.type = Zr.TIME;
    let W = Number.MAX_VALUE, J = t ? t.sort() : [];
    for (let j = 0; j < J.length - 1; j++) {
      let B = E(J[j + 1]) - E(J[j]);
      B < W && (W = B);
    }
    (t.length === 1 || W > r / 4) && (W = r / 4), N = Vu(v, [0, (d.barThickness || 1) * W], 0);
  }
  if (d.visualizationType === "Deviation Bar") {
    const O = d.isLollipopChart ? 1.05 : 1.03;
    T = tc({
      domain: t,
      range: [0, a]
    }), E = Vn({
      domain: [i * O, Math.max(Number(d.xAxis.target), o)],
      range: [0, r],
      round: !0,
      nice: !0
    }), E.type = Zr.LINEAR;
  }
  if (d.visualizationType === "Scatter Plot" && d.xAxis.type === "continuous" && (E = Vn({
    domain: [0, Math.max.apply(null, E.domain())],
    range: [0, r]
  }), E.type = Zr.LINEAR), k === "Box Plot") {
    const O = [];
    if (d.boxplot.plots.map((j) => j.columnOutliers.map((B) => O.push(B))) && !d.boxplot.hideOutliers) {
      let j = Math.min(...O), B = Math.max(...O);
      j < i && (i = j), B > o && (o = B);
    }
    let W = Math.min(...d.boxplot.plots.map((j) => j.columnLowerBounds)), J = Math.max(...d.boxplot.plots.map((j) => j.columnUpperBounds));
    W < i && (i = W), J > o && (o = J), T = Vn({
      range: [a, 0],
      round: !0,
      domain: [i, o]
    }), E = tc({
      range: [0, r],
      round: !0,
      domain: d.boxplot.categories,
      padding: 0.4
    }), E.type = Zr.BAND;
  }
  if (k === "Paired Bar") {
    let K = Math.max.apply(
      Math,
      c.map((J) => {
        var j;
        return J[(j = d.series[0]) == null ? void 0 : j.dataKey];
      })
    ), W = Math.max.apply(
      Math,
      c.map((J) => {
        var j;
        return J[(j = d.series[1]) == null ? void 0 : j.dataKey];
      })
    );
    y = Vn({
      domain: [0, Math.max(K, W) * 1.02],
      range: [r / 2, 0]
    }), b = Vn({
      domain: y.domain(),
      range: [r / 2, r],
      nice: !0
    });
  }
  if (k === "Forest Plot") {
    const O = () => d.forestPlot.regression.showDiamond || d.forestPlot.regression.description ? [0 + d.forestPlot.rowHeight * 2, a - d.forestPlot.rowHeight] : [0 + d.forestPlot.rowHeight * 2, a];
    T = Vn({
      domain: [0, s.length],
      range: O()
    });
    const K = 5, W = Number(d.forestPlot.leftWidthOffset) / 100 * r, J = Number(d.forestPlot.rightWidthOffset) / 100 * r, j = Number(d.forestPlot.rightWidthOffsetMobile) / 100 * r, B = Number(d.forestPlot.leftWidthOffsetMobile) / 100 * r;
    if (m > 480) {
      if (d.forestPlot.type === "Linear" && (E = Vn({
        domain: [
          Math.min(...c.map((Z) => parseFloat(Z[d.forestPlot.lower]))) - K,
          Math.max(...c.map((Z) => parseFloat(Z[d.forestPlot.upper]))) + K
        ],
        range: [W, Number(m) - J]
      }), E.type = Zr.LINEAR), d.forestPlot.type === "Logarithmic") {
        let Z = Math.max(...c.map((V) => parseFloat(V[d.forestPlot.upper]))), te = Math.min(...c.map((V) => parseFloat(V[d.forestPlot.lower])));
        E = nc({
          domain: [te, Z],
          range: [W, r - J],
          nice: !0
        }), E.type = Zr.LOG;
      }
    } else if (d.forestPlot.type === "Linear" && (E = Vn({
      domain: [
        Math.min(...c.map((Z) => parseFloat(Z[d.forestPlot.lower]))) - K,
        Math.max(...c.map((Z) => parseFloat(Z[d.forestPlot.upper]))) + K
      ],
      range: [B, r - j],
      type: Zr.LINEAR
    })), d.forestPlot.type === "Logarithmic") {
      let Z = Math.max(...c.map((V) => parseFloat(V[d.forestPlot.upper]))), te = Math.min(...c.map((V) => parseFloat(V[d.forestPlot.lower])));
      E = nc({
        domain: [te, Z],
        range: [W, r - J],
        nice: !0,
        base: Z > 1 ? 10 : 2,
        round: !1,
        type: Zr.LOG
      });
    }
  }
  return { xScale: E, yScale: T, seriesScale: N, g1xScale: y, g2xScale: b, xScaleNoPadding: C, xScaleAnnotation: P };
}, Ek = (e) => {
  const t = new Date(e);
  return new Date(t.getFullYear(), t.getMonth(), 1).getTime();
}, Sk = (e) => (e.includes("%b") || e.includes("%B") || e.includes("%m") || e.includes("%-m") || e.includes("%_m")) && !e.includes("%d") && !e.includes("%-d") && !e.includes("%_d") && !e.includes("%e"), kk = (e, t, r, a) => {
  const i = t.domain();
  if (t.type === "time") {
    const o = e[e.length - 1], d = e[0], c = (o - d) / (r - 1);
    let s = [];
    for (let p = o; p >= d; p -= c)
      s.push(p);
    return s[s.length - 1] !== d && s.push(d), s.reverse(), Sk(a.xAxis.dateDisplayFormat) && (s = s.map((p) => Ek(p))), s;
  }
  if (i.length > 2) {
    const o = r || 1, d = [];
    for (let c = i.length; c > 0; c -= o) {
      const s = Math.max(Math.round(c) - 1, 0);
      d.push(i[s]);
    }
    return d.reverse(), d;
  }
}, wk = ({ min: e, max: t, xMax: r, config: a }) => {
  const i = a.yAxis.type === "logarithmic";
  return e = i && e >= 0 && e < 1 ? e + 0.1 : e, (i ? nc : Vn)({
    domain: [e, t],
    range: [0, r],
    nice: i,
    zero: i
  });
}, Tk = ({ min: e, max: t, yMax: r, config: a, leftMax: i }) => {
  const o = a.yAxis.type === "logarithmic";
  e = o && e >= 0 && e < 1 ? e + 0.1 : e;
  const d = o ? nc : Vn;
  a.visualizationType === "Combo" && (t = i);
  const c = a.visualizationType === "Bump Chart" ? [1, t] : [e, t], s = a.visualizationType === "Bump Chart" ? [30, r] : [r, 0];
  return d({
    domain: c,
    range: s,
    nice: o,
    zero: o
  });
}, Ck = (e, t) => e === "date" ? Vn({
  domain: [Math.min(...t), Math.max(...t)]
}) : Jo({ domain: t, padding: 0.5 }), Ak = (e, t, r = 0) => Jo({
  domain: e,
  range: t,
  padding: r
}), Vu = (e, t, r = 0) => tc({
  domain: e,
  range: t,
  padding: r
});
function Lk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const Ms = () => {
  const { config: e } = ie.useContext(Et), { visualizationType: t, series: r, orientation: a, visualizationSubType: i } = e, o = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Bump Chart",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], d = [
    "theme-blue",
    "theme-purple",
    "theme-brown",
    "theme-teal",
    "theme-pink",
    "theme-orange",
    "theme-slate",
    "theme-indigo",
    "theme-cyan",
    "theme-green",
    "theme-amber"
  ], c = () => !["Forest Plot", "Sankey"].includes(t), s = () => !["Spark Line"].includes(t), p = () => !["Spark Line"].includes(t), m = () => ![
    "Area Chart",
    "Box Plot",
    "Pie",
    "Scatter Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), v = () => ![
    "Area Chart",
    "Scatter Plot",
    "Box Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), g = () => {
    switch (t) {
      case "Box Plot":
        return !1;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, A = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), k = () => !!["Bar", "Combo", "Line"].includes(e.visualizationType), E = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, T = () => {
    if ((t === "Bar" || "Combo") && i === "regular")
      return !0;
  }, b = () => !1, y = () => ["Box Plot", "Scatter Plot", "Pie", "Line"].includes(t) ? !1 : r == null ? void 0 : r.some(
    (rt) => rt.type === "Bar" || rt.type === "Paired Bar" || rt.type === "Deviation Bar"
  ), N = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, C = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: o,
    headerColors: d,
    visCanAnimate: v,
    visHasAnchors: E,
    visHasBarBorders: y,
    visHasDataCutoff: N,
    visHasLabelOnData: m,
    visHasDataSuppression: T,
    visHasLegend: g,
    visHasLegendAxisAlign: () => t === "Bar" && i === "stacked" && e.legend.behavior === "isolate",
    visHasLegendColorCategory: () => {
      var Xe;
      return t === "Bar" && i === "regular" && ((Xe = e.series) == null ? void 0 : Xe.length) === 1;
    },
    visHasBrushChart: b,
    visHasNumbersOnBars: A,
    visHasaAdditionalLabelsOnBars: k,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : a === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsMobileChartHeight: () => !!["Bar", "Line", "Combo", "Area Chart"].includes(t),
    visSupportsDateCategoryAxis: c,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line", "Bump Chart"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !(["Spark Line", "Sankey", "Bump Chart"].includes(t) || e.orientation !== "horizontal"),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: p,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => !!["Line", "Bar", "Combo"].includes(t),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: s,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: C,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const Xe = ["Forest Plot"];
      return !(a === "horizontal" || Xe.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot", "Bump Chart"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (e.yAxis.type === "categorical" || ["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t) || t === "Bar" && e.tooltips.singleSeries)
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t),
    visSupportsDynamicSeries: () => t === "Line" || t === "Bar" || t === "Scatter Plot" || t === "Area Chart",
    visHasSingleSeriesTooltip: () => t === "Bar" || t === "Line" || t === "Area Chart" && i === "stacked",
    visHasCategoricalAxis: () => {
      if ((t === "Line" || t === "Bar" || t === "Combo" || t === "Area Chart") && e.yAxis.type === "categorical" && a === "vertical")
        return !0;
    }
  };
}, Pk = ({ data: e, xScale: t, yScale: r, config: a, xMax: i, annotationSeriesKey: o }, d) => {
  const { xAxis: c, visualizationType: s, orientation: p } = a, m = (T, b, y, N, C) => {
    let P = [];
    a.xAxis.type === "date-time" && (b = new Date(b), y = new Date(y), N = N.map((W) => new Date(W)), P = C.ticks().map((W) => new Date(W)));
    const O = (T - b) / (y - b), K = Math.round(O * (N.length - 1));
    return a.xAxis.type === "date-time" ? P[K] : N[K];
  }, g = ((T, b = !1) => {
    if (s !== "Pie" && p !== "horizontal") {
      if (a.xAxis.type === "date-time") {
        const y = new Date(t.invert(T)), N = a.data.map((O) => new Date(O[a.xAxis.dataKey]).getTime());
        let C = 1 / 0, P = null;
        return N.forEach((O) => {
          const K = Math.abs(y.getTime() - O);
          K < C && (C = K, P = O);
        }), new Date(P).getTime();
      }
      if (a.xAxis.type === "categorical" || s === "Combo" && p !== "horizontal" && s !== "Forest Plot") {
        const N = (t.range()[1] - t.range()[0]) / (t.domain().length + 1), P = Math.floor((Number(T) - N / 2) / N);
        return t.domain()[P];
      }
      if (a.xAxis.type === "date") {
        const y = m(T, 0, i, t.domain(), t);
        let N = null, C = Number.MAX_VALUE;
        return t.domain().forEach((P) => {
          const O = Math.abs(y - P);
          O < C && (C = O, N = P);
        }), N;
      }
      return T;
    }
  })(d - Number(a.yAxis.size || 0));
  let A = [];
  if (!g)
    return { x: 0, y: 0 };
  c.type === "categorical" && (A = a.data.filter((T) => T[a.xAxis.dataKey] === g)), (c.type === "date" || c.type === "date-time") && (A = a.data.filter((T) => new Date(T[a.xAxis.dataKey]).getTime() === g));
  const k = A[0][o];
  return { x: g, y: k };
}, Nk = (e, t, r) => {
  const { connectionLocation: a } = e;
  return a === "right" ? "end" : a === "left" ? "start" : a === "bottom" || a === "top" || t(e.xKey) + e.dx < r.yAxis.size ? "middle" : null;
}, Rk = (e, t, r) => {
  const { connectionLocation: a } = e;
  return a === "top" ? "start" : a === "bottom" ? "end" : a === "right" || a === "left" ? "middle" : t(e.xKey) + e.dx < r.yAxis.size ? "end" : null;
}, Dk = () => {
  var s;
  const { config: e, data: t } = ie.useContext(Et), { visualizationSubType: r, visualizationType: a, series: i, legend: o } = e, d = (p) => {
    if (!(i != null && i.length))
      return [];
    const v = ["Paired Bar", "Deviation Bar"].includes(a) ? e.twoColor.palette : e.palette, g = { ...pr, ...ks };
    let A = e.customColors || g[v];
    for (; p > A.length; )
      A = A.concat(A);
    return A.slice(0, p);
  };
  let c = Bi({
    domain: (s = e == null ? void 0 : e.runtime) == null ? void 0 : s.seriesLabelsAll,
    range: d(i.length)
  });
  if (a === "Deviation Bar") {
    const { targetLabel: p } = e.xAxis;
    c = Bi({
      domain: [`Below ${p}`, `Above ${p}`],
      range: d(2)
    });
  }
  if (a === "Bar" && r === "regular" && (i == null ? void 0 : i.length) === 1 && (o != null && o.colorCode)) {
    const p = new Set(t == null ? void 0 : t.map((m) => m[o.colorCode]));
    c = Bi({
      domain: [...p],
      range: d([...p].length)
    });
  }
  if (e.series.some((p) => p.name)) {
    const p = new Set(i.map((m) => m.name || m.dataKey));
    c = c = Bi({
      domain: [...p],
      range: d(i.length)
    });
  }
  return { colorScale: c };
};
const _k = ({ xScale: e, yScale: t, xScaleAnnotation: r, xMax: a, svgRef: i, onDragStateChange: o }) => {
  const {
    config: d,
    dimensions: c,
    isEditor: s,
    updateConfig: p
  } = ie.useContext(Et), { annotations: m } = d, [v] = c, { colorScale: g } = Dk(), A = s ? Lg : Pg;
  return m && m.map((k, E) => {
    var N;
    const T = k.text || "", b = r(k.x), y = () => ({
      __html: bm.sanitize(T)
    });
    return /* @__PURE__ */ n.createElement(
      A,
      {
        width: 200,
        height: v,
        dx: k.dx,
        dy: k.dy,
        x: b,
        y: k.y,
        canEditLabel: k.edit.label || !1,
        canEditSubject: k.edit.subject && k.connectionType !== "none" || !1,
        onDragStart: () => o(!0),
        onDragEnd: (C) => {
          o(!1);
          let P = [...m];
          if (k.x === r.invert(C.x) && k.y === C.y)
            P[E] = { ...P[E], dx: C.dx, dy: C.dy };
          else if (k.snapToNearestPoint) {
            let O = Pk(
              {
                data: d.data,
                xScale: e,
                yScale: t,
                config: d,
                xMax: a - d.yAxis.size / 2,
                annotationSeriesKey: k.seriesKey
              },
              C.x
            );
            P[E] = {
              ...P[E],
              x: r.invert(e(O.x)),
              y: t(O.y)
            };
          } else
            P[E] = {
              ...P[E],
              x: r.invert(C.x),
              y: C.y
            };
          p({
            ...d,
            annotations: P
          });
        }
      },
      /* @__PURE__ */ n.createElement(
        Cg,
        {
          className: "annotation__desktop-label",
          showAnchorLine: !1,
          horizontalAnchor: Nk(k, e, d),
          verticalAnchor: Rk(k, e, d)
        },
        /* @__PURE__ */ n.createElement(
          "div",
          {
            style: {
              borderRadius: 5,
              // Optional: set border radius
              backgroundColor: `rgba(255, 255, 255, ${k != null && k.opacity ? Number(k == null ? void 0 : k.opacity) / 100 : 1})`,
              padding: "10px",
              width: "auto",
              display: d.general.showAnnotationDropdown ? "inline-flex" : "flex",
              justifyContent: "start",
              flexDirection: "row"
            },
            tabIndex: 0,
            "aria-label": `Annotation text that reads: ${k.text}`
          },
          ((N = d == null ? void 0 : d.general) == null ? void 0 : N.showAnnotationDropdown) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("p", { className: "annotation__has-dropdown-number", style: { margin: "2px 6px" } }, E + 1)),
          /* @__PURE__ */ n.createElement("div", { style: { fontSize: wm[d.fontSize] }, dangerouslySetInnerHTML: y() })
        )
      ),
      k.connectionType === "line" && /* @__PURE__ */ n.createElement(_p, { type: "line", pathProps: { markerStart: `url(#marker-start--${E})` } }),
      k.connectionType === "elbow" && /* @__PURE__ */ n.createElement(_p, { type: "elbow", pathProps: { markerStart: `url(#marker-start--${E})` } }),
      k.connectionType === "curve" && /* @__PURE__ */ n.createElement(
        Ir,
        {
          d: `M ${b},${k.y}
                      Q ${b + k.dx / 2}, ${k.y + k.dy / 2 + Number(k == null ? void 0 : k.bezier) || 0} ${b + k.dx},${k.y + k.dy}`,
          stroke: "black",
          strokeWidth: "2",
          fill: "none",
          "marker-start": `url(#marker-start--${E})`
        }
      ),
      k.marker === "circle" && /* @__PURE__ */ n.createElement(
        Ag,
        {
          id: `marker-start--${E}`,
          className: "circle-subject",
          stroke: g(k.seriesKey),
          radius: 8
        }
      ),
      k.marker === "arrow" && /* @__PURE__ */ n.createElement(
        xm,
        {
          fill: "black",
          id: `marker-start--${E}`,
          x: b,
          y: k.y,
          stroke: "#333",
          markerWidth: 10,
          size: 10,
          strokeWidth: 1,
          orient: "auto-start-reverse",
          markerUnits: "userSpaceOnUse"
        }
      ),
      /* @__PURE__ */ n.createElement(
        "circle",
        {
          fill: "white",
          cx: b + k.dx,
          cy: k.y + k.dy,
          r: 16,
          className: "annotation__mobile-label annotation__mobile-label-circle",
          stroke: g(k.seriesKey)
        }
      ),
      /* @__PURE__ */ n.createElement(
        "text",
        {
          height: 16,
          x: b + k.dx,
          y: k.y + k.dy,
          className: "annotation__mobile-label",
          alignmentBaseline: "middle",
          textAnchor: "middle"
        },
        E + 1
      )
    );
  });
};
const Ok = ({ useBootstrapVisibilityClasses: e = !0 }) => {
  const { config: t } = ie.useContext(Et), r = t.annotations || [], a = () => {
    const o = ["annotation-list"];
    return e && o.push("d-block", "d-md-none"), o.join(" ");
  }, i = r.map((o, d) => {
    const c = o.text || "", s = () => ({
      __html: bm.sanitize(c)
    });
    return /* @__PURE__ */ n.createElement("li", { key: "annotation-li-item__annotationIndex" }, /* @__PURE__ */ n.createElement("div", { className: "annotation__title-wrapper" }, /* @__PURE__ */ n.createElement("div", { className: "annotation__title-circle" }, d + 1), /* @__PURE__ */ n.createElement("p", { className: "annotation__subtext", dangerouslySetInnerHTML: s() })));
  });
  return /* @__PURE__ */ n.createElement("ul", { className: a() }, i);
};
const Fk = () => {
  var s;
  const { currentViewport: e, config: t } = ie.useContext(Et), [r, a] = ie.useState(!1), i = ["sm", "xs", "xxs"].includes(e) ? "13px" : `${wm[t == null ? void 0 : t.fontSize]}px`;
  ie.useContext(Et);
  const o = {
    maxHeight: t.table.limitHeight && `${t.table.height}px`,
    OverflowY: "scroll"
  }, d = () => {
    const p = ["data-table-heading", "annotation__dropdown-list"];
    return r || p.push("collapsed"), p.join(" ");
  }, c = () => {
    const p = ["data-table-container", e, "d-block", "d-lg-none", "w-100"];
    return t.general.showAnnotationDropdown && (p.push("d-lg-block"), p.splice(p.indexOf("d-lg-none"), 1)), p.join(" ");
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("section", { className: c() }, /* @__PURE__ */ n.createElement(
    "div",
    {
      style: { fontSize: i },
      role: "button",
      className: d(),
      onClick: () => {
        a(!r);
      },
      tabIndex: 0,
      onKeyDown: (p) => {
        p.keyCode === 13 && a(!r);
      }
    },
    /* @__PURE__ */ n.createElement(tt, { display: r ? "minus" : "plus", base: !0 }),
    t.general.annotationDropdownText === "" ? "Annotations" : (s = t == null ? void 0 : t.general) == null ? void 0 : s.annotationDropdownText
  ), r && /* @__PURE__ */ n.createElement("div", { className: "table-container annotation-dropdown__panel", style: o }, /* @__PURE__ */ n.createElement(xp.List, { useBootstrapVisibilityClasses: !1 }))));
}, xp = {
  Draggable: _k,
  // Mobile auto display
  List: Ok,
  // Desktop Accessible Option
  Dropdown: Fk
}, sf = 9, uf = 3, cf = 8, df = ie.forwardRef(({ parentHeight: e, parentWidth: t }, r) => {
  var qt, Sn, Wt;
  const {
    brushConfig: a,
    colorScale: i,
    config: o,
    currentViewport: d,
    dimensions: c,
    formatDate: s,
    formatNumber: p,
    handleChartAriaLabels: m,
    handleLineType: v,
    handleDragStateChange: g,
    isDraggingAnnotation: A,
    legendRef: k,
    parseDate: E,
    parentRef: T,
    tableData: b,
    transformedData: y,
    updateConfig: N,
    seriesHighlight: C
  } = ie.useContext(Et), {
    heights: P,
    visualizationType: O,
    visualizationSubType: K,
    orientation: W,
    xAxis: J,
    yAxis: j,
    runtime: B,
    legend: Z,
    forestPlot: te,
    brush: V,
    dataFormat: ee,
    debugSvg: ce
  } = o, { suffix: re, onlyShowTopPrefixSuffix: G } = ee, { labelsAboveGridlines: U, hideAxis: q } = o.yAxis, { minValue: H, maxValue: oe, existPositiveValue: ue, isAllLine: ke } = Vc(o, y), { visSupportsReactTooltip: De } = Ms(), { hasTopAxis: pe } = Lk(o), [Be, qe] = ie.useState(!1), [Pe, ve] = ie.useState({ x: 0, y: 0 }), [$e, z] = ie.useState(0), Re = ie.useRef(null), be = ie.useRef(null), He = ie.useRef(null), Ve = ie.useRef(null), Oe = ie.useRef(), Ge = ie.useRef([]), Xe = ie.useRef(null), rt = ie.useRef(null), Ue = hp(Oe, {
    freezeOnceVisible: !1
  }), ze = !0, Ne = W === "horizontal" || o.visualizationType === "Forest Plot", ot = o.yAxis.type === "logarithmic", nt = O === "Forest Plot", mt = !re.includes(" "), wt = isNaN(parseInt(`${B.yAxis.labelOffset}`)) ? 0 : parseInt(`${B.yAxis.labelOffset}`), xt = nt ? o.data.length * o.forestPlot.rowHeight : 0, Pt = ie.useMemo(
    () => xk(o, d),
    [o, d, e]
  ), ln = ie.useMemo(() => Pt + xt, [Pt, xt]), Gt = ie.useMemo(() => {
    var At;
    const Ee = c[0], et = Z == null ? void 0 : Z.hide, Ze = ["bottom", "top"].includes((At = o.legend) == null ? void 0 : At.position), Ke = ga(d);
    if (!(!nt && !et && !Ze && !Ke))
      return Ee;
    if (k.current) {
      const Xt = getComputedStyle(k.current);
      return Ee - k.current.getBoundingClientRect().width - parseInt(Xt.marginLeft) - parseInt(Xt.marginRight);
    }
    return Ee * 0.73;
  }, [c[0], o.legend, d, k.current]), Ut = ie.useMemo(() => {
    var et;
    return Ge.current = (et = Ge.current) == null ? void 0 : et.filter((Ze) => Ze), Ge.current.length ? Math.max(...Ge.current.map((Ze) => Ze.getBBox().height)) + uf + cf : void 0;
  }, [c[0], o.xAxis, Ge.current, o.xAxis.tickRotation]), yt = Gt - B.yAxis.size - (O === "Combo" ? o.yAxis.rightAxisSize : 0), Tt = Pt + xt, Dt = () => Hc(o.visualizationType, y, o.allowLineToBarGraph), nn = (Ee) => Dn(o.runtime.xAxis) ? E(Ee[o.runtime.originalXAxis.dataKey]).getTime() : Ee[o.runtime.originalXAxis.dataKey], yn = (Ee, et) => Ee[et], Nt = o.brush.active && ((qt = a.data) != null && qt.length) ? a.data.map((Ee) => nn(Ee)) : y.map((Ee) => nn(Ee)), un = o.orientation === "horizontal" || o.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", Kt = {
    data: y,
    tableData: b,
    config: o,
    minValue: H,
    maxValue: oe,
    isAllLine: ke,
    existPositiveValue: ue,
    xAxisDataMapped: Nt,
    xMax: yt,
    yMax: Tt
  }, { min: Fe, max: bt, leftMax: xn, rightMax: Ot } = og(Kt), { yScaleRight: Ln, hasRightAxis: An } = vp({ config: o, yMax: Tt, data: y, updateConfig: N }), { xScale: $t, yScale: It, seriesScale: rn, g1xScale: fn, g2xScale: On, xScaleNoPadding: Wn, xScaleAnnotation: on } = bk({
    ...Kt,
    min: Fe,
    max: bt,
    leftMax: xn,
    rightMax: Ot,
    dimensions: c,
    xMax: t - Number(o.orientation === "horizontal" ? o.xAxis.size : o.yAxis.size)
  }), er = (Ee, et, Ze) => {
    if (ot && Ee === 0.1 && (Ee = 0), !(o.data && !o.data[et] && O === "Forest Plot"))
      return o.visualizationType === "Forest Plot" ? o.data[et][o.xAxis.dataKey] : Dn(B.yAxis) ? s(E(Ee)) : W === "vertical" && bt - Fe < 3 ? p(Ee, "left", ze, !1, !1, "1", { index: et, length: Ze.length }) : W === "vertical" ? p(Ee, "left", ze, !1, !1, void 0, { index: et, length: Ze.length }) : Ee;
  }, or = (Ee) => {
    if (ot && Ee === 0.1 && (Ee = 0), Dn(B.xAxis) && o.visualizationType !== "Forest Plot") {
      const et = s(Ee, rt.current);
      return rt.current = Ee, et;
    }
    return W === "horizontal" && o.visualizationType !== "Forest Plot" ? p(Ee, "left", ze) : o.xAxis.type === "continuous" && o.visualizationType !== "Forest Plot" ? p(Ee, "bottom", ze) : o.visualizationType === "Forest Plot" ? p(
      Ee,
      "left",
      o.dataFormat.abbreviated,
      o.runtime.xAxis.prefix,
      o.runtime.xAxis.suffix,
      Number(o.dataFormat.roundTo)
    ) : Ee;
  }, Xn = (Ee) => {
    let { numTicks: et } = B[Ee];
    B[Ee].viewportNumTicks && B[Ee].viewportNumTicks[d] && (et = B[Ee].viewportNumTicks[d]);
    let Ze;
    return Ee === "yAxis" && (Ze = Ne && !et ? y.length : Ne && et ? et : !Ne && !et ? void 0 : !Ne && et && et, Ze === void 0 && !o.dataFormat.roundTo && (Number(bt) <= 3 ? Ze = 2 : Ze = 4), Number(Ze) > Number(bt) && (Ze = Number(Fe) < 0 ? Math.round(bt) * 2 : Math.round(bt))), Ee === "xAxis" && (Ze = Ne && !et ? void 0 : Ne && et ? et : !Ne && !et ? void 0 : !Ne && et && et, Ne && Ze === void 0 && !o.dataFormat.roundTo && (bt <= 3 ? Ze = 2 : Ze = 4), o.visualizationType === "Forest Plot" && (Ze = o.yAxis.numTicks !== "" ? o.yAxis.numTicks : 4)), Ze;
  }, { tooltipData: Ht, showTooltip: gn, hideTooltip: Tn, tooltipOpen: qn, tooltipLeft: jn, tooltipTop: $n } = $y(), {
    handleTooltipMouseOver: Te,
    handleTooltipClick: _e,
    handleTooltipMouseOff: se,
    TooltipListItem: it,
    getXValueFromCoordinate: ft
  } = jy({
    xScale: $t,
    yScale: It,
    showTooltip: gn,
    hideTooltip: Tn
  });
  ie.useEffect(() => {
    document.querySelector(".isEditor") && qe((et) => !0);
  }), ie.useEffect(() => {
    (Ue == null ? void 0 : Ue.isIntersecting) === !0 && o.animate && setTimeout(() => {
      qe((Ee) => !0);
    }, 500);
  }, [Ue == null ? void 0 : Ue.isIntersecting, o.animate]), ie.useEffect(() => {
    const Ee = He.current;
    if (!Ee && !$e)
      return;
    if (!Ee)
      return z(0);
    const et = Ee.getBBox().width;
    z(et);
  }, [o.dataFormat.suffix, o.dataFormat.onlyShowTopPrefixSuffix]), ie.useEffect(() => {
    if (!nt || J.hideLabel)
      return;
    const Ee = be.current;
    if (!Ee)
      return;
    const et = Tt + Number(o.xAxis.axisPadding), Ke = Ee.getBBox().y - et + Ee.getBBox().height + sf;
    Xe.current && Xe.current.setAttribute("y", Ke);
  }, [(Sn = o == null ? void 0 : o.data) == null ? void 0 : Sn.length, xt]), ie.useEffect(() => {
    if (!Re.current)
      return;
    const Ee = Re.current.getBBox().height, et = O === "Forest Plot", Ze = Ve.current && j.labelsAboveGridlines, Ke = V != null && V.active ? V == null ? void 0 : V.height : 0, Vt = et ? o.data.length * te.rowHeight : 0, At = Ze ? Ve.current.getBBox().height : 0, Xt = Ee + Ke + Vt + At, Rt = Pt + Xt;
    if (!T.current || (T.current.style.height = `${Rt}px`, !At))
      return;
    const Qt = r.current;
    if (!Qt)
      return;
    const pn = T.current.getBoundingClientRect().width;
    if (Qt.setAttribute("viewBox", `0 ${-At} ${pn} ${Rt}`), !k.current)
      return;
    const _t = (Z == null ? void 0 : Z.position) !== "top" && (Z == null ? void 0 : Z.position) !== "bottom" && !ga(d);
    k.current.style.transform = _t ? `translateY(${At}px)` : "none";
  }, [Re.current, o, Ut, V, d, Ve.current]);
  const dt = () => {
    const { visualizationType: Ee } = o;
    return Ee === "Combo" && B.forecastingSeriesKeys > 0 || Ee === "Area Chart" || Ee === "Line" || Ee === "Bar";
  }, Ct = Number(W === "horizontal" ? o.xAxis.size : o.yAxis.size), Yt = { small: 16, medium: 18, large: 20 }, Zt = () => o.visualizationType === "Forest Plot" ? o.data.length : Xn("yAxis"), at = () => {
    let Ee = o.xAxis.manualStep;
    return o.xAxis.viewportStepCount && o.xAxis.viewportStepCount[d] && (Ee = o.xAxis.viewportStepCount[d]), Ee;
  }, tn = (Ee) => {
    const et = Ee.currentTarget.getBoundingClientRect(), Ze = Ee.clientX - et.left, Ke = Ee.clientY - et.top;
    ve({
      x: Ze,
      y: Ke
    });
  }, cn = () => {
    const Ee = Ut + sf, et = (Ze, Ke) => {
      if (!Ze.length)
        return !1;
      const Vt = Ze.filter((M) => M.index !== 0), At = Vt == null ? void 0 : Vt.length, Xt = Ke.range()[0] || yt / 2, Rt = Vt.map(
        (M) => Kn(p(M.value, "left"), `normal ${Yt[o.fontSize]}px sans-serif`)
      ), Qt = 100, pn = Rt.reduce((M, X) => M + X, Qt), _t = (Xt - pn) / At;
      let x = [0];
      for (let M = 1; M < Rt.length; M++)
        x[M] = x[M - 1] + Rt[M - 1] + _t;
      let D = !1;
      return Rt.forEach((M, X) => {
        if (x[X] + Rt[X] > x[X + 1]) {
          D = !0;
          return;
        }
      }), D;
    };
    return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      qu,
      {
        top: Tt,
        left: Number(B.yAxis.size),
        label: B.xAxis.label,
        tickFormat: Dn(B.xAxis) ? s : p,
        scale: fn,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: B.xAxis.numTicks || void 0
      },
      (Ze) => /* @__PURE__ */ n.createElement(st, { className: "bottom-axis" }, Ze.ticks.map((Ke, Vt) => {
        Kn(
          p(Ke.value, "left"),
          `normal ${Yt[o.fontSize]}px sans-serif`
        );
        const At = et(Ze.ticks, fn), Xt = Number(o.xAxis.maxTickRotation) || 90, Rt = o.isResponsiveTicks && At, Qt = Ke.index !== 0 && (Rt ? Xt : Number(o.yAxis.tickRotation)), pn = Qt && Ke.index !== 0 ? "end" : "middle";
        return /* @__PURE__ */ n.createElement(st, { key: `vx-tick-${Ke.value}-${Vt}`, className: "vx-axis-tick" }, !B.yAxis.hideTicks && /* @__PURE__ */ n.createElement(mn, { from: Ke.from, to: Ke.to, stroke: "#333" }), !B.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          St,
          {
            innerRef: (_t) => Ge.current[Vt] = _t,
            x: Ke.to.x,
            y: Ke.to.y,
            angle: -Qt,
            verticalAnchor: Qt ? "middle" : "start",
            textAnchor: pn
          },
          p(Ke.value, "left")
        ));
      }), !B.yAxis.hideAxis && /* @__PURE__ */ n.createElement(mn, { from: Ze.axisFromPoint, to: Ze.axisToPoint, stroke: "#333" }))
    ), /* @__PURE__ */ n.createElement(
      qu,
      {
        innerRef: Re,
        top: Tt,
        left: Number(B.yAxis.size),
        label: B.xAxis.label,
        tickFormat: Dn(B.xAxis) ? s : B.xAxis.dataKey !== "Year" ? p : (Ze) => Ze,
        scale: On,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: B.xAxis.numTicks || void 0
      },
      (Ze) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(st, { className: "bottom-axis" }, Ze.ticks.map((Ke, Vt) => {
        Kn(
          p(Ke.value, "left"),
          `normal ${Yt[o.fontSize]}px sans-serif`
        );
        const At = et(Ze.ticks, On), Xt = Number(o.xAxis.maxTickRotation) || 90, Rt = o.isResponsiveTicks && At, Qt = Ke.index !== 0 && (Rt ? Xt : Number(o.yAxis.tickRotation)), pn = Qt && Ke.index !== 0 ? "end" : "middle";
        return Vt ? /* @__PURE__ */ n.createElement(st, { key: `vx-tick-${Ke.value}-${Vt}`, className: "vx-axis-tick" }, !B.yAxis.hideTicks && /* @__PURE__ */ n.createElement(mn, { from: Ke.from, to: Ke.to, stroke: "#333" }), !B.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
          St,
          {
            x: Ke.to.x,
            y: Ke.to.y + uf,
            angle: -Qt,
            verticalAnchor: Qt ? "middle" : "start",
            textAnchor: pn
          },
          p(Ke.value, "left")
        )) : /* @__PURE__ */ n.createElement(n.Fragment, null);
      }), !B.yAxis.hideAxis && /* @__PURE__ */ n.createElement(mn, { from: Ze.axisFromPoint, to: Ze.axisToPoint, stroke: "#333" })), /* @__PURE__ */ n.createElement(st, null, /* @__PURE__ */ n.createElement(
        St,
        {
          className: "x-axis-title-label",
          x: yt / 2,
          y: Ee,
          stroke: "#333",
          textAnchor: "middle",
          verticalAnchor: "start"
        },
        B.xAxis.label
      )))
    ));
  };
  return isNaN(Gt) ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(Hr, { component: "LinearChart" }, /* @__PURE__ */ n.createElement(
    "div",
    {
      style: { width: `${t}px`, overflow: "visible", position: "relative" },
      className: "tooltip-boundary"
    },
    /* @__PURE__ */ n.createElement(
      "svg",
      {
        ref: r,
        onMouseMove: tn,
        width: t,
        height: e,
        className: `linear ${o.animate ? "animated" : ""} ${Be && o.animate ? "animate" : ""} ${ce && "debug"} ${A && "dragging-annotation"}`,
        role: "img",
        "aria-label": m(o),
        style: { overflow: "visible" }
      },
      !A && /* @__PURE__ */ n.createElement(Nr, { width: t, height: Pt, fill: "transparent" }),
      " ",
      !["Spark Line", "Forest Plot"].includes(O) && o.yAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(
        nm,
        {
          scale: It,
          left: Number(B.yAxis.size) - o.yAxis.axisPadding,
          numTicks: Zt()
        },
        (Ee) => {
          const et = o.orientation === "horizontal" ? (Ee.axisToPoint.y - Ee.axisFromPoint.y) / 2 : (Ee.axisFromPoint.y - Ee.axisToPoint.y) / 2;
          return /* @__PURE__ */ n.createElement(st, { className: "left-axis" }, Ee.ticks.map((Ze, Ke) => {
            const Vt = String(Ze.value).startsWith("1") || Ze.value === 0.1 ? "block" : "none", At = Ze.index === 0 && Ze.value === 0 && o.xAxis.hideAxis;
            return /* @__PURE__ */ n.createElement(st, { key: `vx-tick-${Ze.value}-${Ke}`, className: "vx-axis-tick" }, B.yAxis.gridLines && !At ? /* @__PURE__ */ n.createElement(
              mn,
              {
                key: `${Ze.value}--hide-hideGridLines`,
                display: (ot && Vt).toString(),
                from: { x: Ze.from.x + yt, y: Ze.from.y },
                to: Ze.from,
                stroke: "#d6d6d6"
              }
            ) : "");
          }), /* @__PURE__ */ n.createElement(
            St,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${-1 * B.yAxis.size + wt}, ${et}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.labelColor
            },
            Ee.label
          ));
        }
      ),
      O === "Paired Bar" && cn(),
      O === "Deviation Bar" && ((Wt = o.runtime.series) == null ? void 0 : Wt.length) === 1 && /* @__PURE__ */ n.createElement(ik, { animatedChart: Be, xScale: $t, yScale: It, width: yt, height: Tt }),
      O === "Paired Bar" && /* @__PURE__ */ n.createElement(yk, { originalWidth: Gt, width: yt, height: Tt }),
      O === "Scatter Plot" && /* @__PURE__ */ n.createElement(
        ak,
        {
          xScale: $t,
          yScale: It,
          getXAxisData: nn,
          getYAxisData: yn,
          xMax: yt,
          yMax: Tt,
          handleTooltipMouseOver: Te,
          handleTooltipMouseOff: se,
          handleTooltipClick: _e,
          tooltipData: Ht,
          showTooltip: gn
        }
      ),
      O === "Box Plot" && /* @__PURE__ */ n.createElement(rk, { xScale: $t, yScale: It }),
      (O === "Area Chart" && o.visualizationSubType === "regular" || O === "Combo") && /* @__PURE__ */ n.createElement(
        qS,
        {
          xScale: $t,
          yScale: It,
          yMax: Tt,
          xMax: yt,
          chartRef: r,
          width: yt,
          height: Tt,
          handleTooltipMouseOver: Te,
          handleTooltipMouseOff: se,
          tooltipData: Ht,
          showTooltip: gn
        }
      ),
      (O === "Area Chart" && o.visualizationSubType === "stacked" || O === "Combo") && /* @__PURE__ */ n.createElement(
        ZS,
        {
          xScale: $t,
          yScale: It,
          yMax: Tt,
          xMax: yt,
          chartRef: r,
          width: yt,
          height: Tt,
          handleTooltipMouseOver: Te,
          handleTooltipMouseOff: se,
          tooltipData: Ht,
          showTooltip: gn
        }
      ),
      (O === "Bar" || O === "Combo" || Dt()) && /* @__PURE__ */ n.createElement(
        nk,
        {
          xScale: $t,
          yScale: It,
          seriesScale: rn,
          xMax: yt,
          yMax: Tt,
          getXAxisData: nn,
          getYAxisData: yn,
          animatedChart: Be,
          visible: Be,
          handleTooltipMouseOver: Te,
          handleTooltipMouseOff: se,
          handleTooltipClick: _e,
          tooltipData: Ht,
          showTooltip: gn,
          chartRef: r
        }
      ),
      (O === "Line" && !Dt() || O === "Combo" || O === "Bump Chart") && /* @__PURE__ */ n.createElement(
        um,
        {
          xScale: $t,
          yScale: It,
          getXAxisData: nn,
          getYAxisData: yn,
          xMax: yt,
          yMax: Tt,
          seriesStyle: o.runtime.series,
          handleTooltipMouseOver: Te,
          handleTooltipMouseOff: se,
          handleTooltipClick: _e,
          tooltipData: Ht,
          showTooltip: gn,
          chartRef: r
        }
      ),
      (O === "Forecasting" || O === "Combo") && /* @__PURE__ */ n.createElement(
        lk,
        {
          showTooltip: gn,
          tooltipData: Ht,
          xScale: $t,
          yScale: It,
          width: yt,
          le: !0,
          height: Tt,
          xScaleNoPadding: Wn,
          chartRef: r,
          getXValueFromCoordinate: ft,
          handleTooltipMouseOver: Te,
          handleTooltipMouseOff: se,
          isBrush: !1
        }
      ),
      o.yAxis.anchors && o.yAxis.anchors.map((Ee) => /* @__PURE__ */ n.createElement(
        mn,
        {
          strokeDasharray: v(Ee.lineStyle),
          stroke: "rgba(0,0,0,1)",
          className: "customAnchor",
          from: { x: 0 + o.yAxis.size, y: It(Ee.value) },
          to: { x: yt, y: It(Ee.value) },
          display: B.horizontal ? "none" : "block"
        }
      )),
      O === "Forest Plot" && /* @__PURE__ */ n.createElement(
        mk,
        {
          xScale: $t,
          yScale: It,
          seriesScale: rn,
          width: Gt,
          height: ln,
          getXAxisData: nn,
          getYAxisData: yn,
          animatedChart: Be,
          visible: Be,
          handleTooltipMouseOver: Te,
          handleTooltipMouseOff: se,
          handleTooltipClick: _e,
          tooltipData: Ht,
          showTooltip: gn,
          chartRef: r,
          config: o,
          forestPlotRightLabelRef: be
        }
      ),
      o.brush.active && o.xAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(
        YS,
        {
          xScaleBrush,
          yScale: It,
          xMax: yt,
          yMax: Tt,
          xScale: $t,
          seriesScale: rn
        }
      ),
      !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(
        O
      ) && !Dt() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        um,
        {
          xScale: $t,
          yScale: It,
          getXAxisData: nn,
          getYAxisData: yn,
          xMax: yt,
          yMax: Tt,
          seriesStyle: o.runtime.series
        }
      )),
      o.yAxis.anchors && o.yAxis.anchors.map((Ee, et) => {
        let Ze = It(Ee.value);
        if (!Ee.value)
          return;
        const Ke = W === "horizontal" && O === "Bar" ? o.barHeight / 4 : 0;
        if (Ze)
          return (
            // prettier-ignore
            /* @__PURE__ */ n.createElement(
              mn,
              {
                key: `yAxis-${Ee.value}--${et}`,
                strokeDasharray: v(Ee.lineStyle),
                stroke: Ee.color ? Ee.color : "rgba(0,0,0,1)",
                className: "anchor-y",
                from: { x: 0 + Ct, y: Ze - Ke },
                to: { x: Gt - o.yAxis.rightAxisSize, y: Ze - Ke }
              }
            )
          );
      }),
      o.xAxis.anchors && o.xAxis.anchors.map((Ee, et) => {
        let Ze = J;
        W === "horizontal" && (Ze = j);
        let Ke = Dn(Ze) ? $t(E(Ee.value, !1)) : $t(Ee.value);
        if (Ke)
          return (
            // prettier-ignore
            /* @__PURE__ */ n.createElement(
              mn,
              {
                key: `xAxis-${Ee.value}--${et}`,
                strokeDasharray: v(Ee.lineStyle),
                stroke: Ee.color ? Ee.color : "rgba(0,0,0,1)",
                fill: Ee.color ? Ee.color : "rgba(0,0,0,1)",
                className: "anchor-x",
                from: { x: Number(Ke) + Number(Ct), y: 0 },
                to: { x: Number(Ke) + Number(Ct), y: Tt }
              }
            )
          );
      }),
      o.visualizationType !== "Bar" && o.visualizationType !== "Combo" && /* @__PURE__ */ n.createElement(
        gp,
        {
          xScale: $t,
          handleTooltipClick: _e,
          handleTooltipMouseOff: se,
          handleTooltipMouseOver: Te,
          showTooltip: gn,
          hideTooltip: Tn,
          tooltipData: Ht,
          yMax: Tt,
          width: Gt
        }
      ),
      dt && gn && Ht && o.visual.verticalHoverLine && /* @__PURE__ */ n.createElement(st, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ n.createElement(
        mn,
        {
          from: { x: Ht.dataXPosition - 10, y: 0 },
          to: { x: Ht.dataXPosition - 10, y: Tt },
          stroke: "black",
          strokeWidth: 1,
          pointerEvents: "none",
          strokeDasharray: "5,5",
          className: "vertical-tooltip-line"
        }
      )),
      dt && gn && Ht && o.visual.horizontalHoverLine && /* @__PURE__ */ n.createElement(
        st,
        {
          key: "tooltipLine-horizontal",
          className: "horizontal-tooltip-line",
          left: o.yAxis.size ? o.yAxis.size : 0
        },
        /* @__PURE__ */ n.createElement(
          mn,
          {
            from: { x: 0, y: Ht.dataYPosition },
            to: { x: yt, y: Ht.dataYPosition },
            stroke: "black",
            strokeWidth: 1,
            pointerEvents: "none",
            strokeDasharray: "5,5",
            className: "horizontal-tooltip-line"
          }
        )
      ),
      o.filters && o.filters.values.length === 0 && y.length === 0 && /* @__PURE__ */ n.createElement(
        St,
        {
          x: Number(o.yAxis.size) + Number(yt / 2),
          y: Pt / 2 - (o.xAxis.padding || 0) / 2,
          textAnchor: "middle"
        },
        o.chartMessage.noData
      ),
      (o.visualizationType === "Bar" || Dt()) && o.tooltips.singleSeries && o.visual.horizontalHoverLine && /* @__PURE__ */ n.createElement(
        st,
        {
          key: "tooltipLine-horizontal",
          className: "horizontal-tooltip-line",
          left: o.yAxis.size ? o.yAxis.size : 0
        },
        /* @__PURE__ */ n.createElement(
          mn,
          {
            from: { x: 0, y: Pe.y },
            to: { x: yt, y: Pe.y },
            stroke: "black",
            strokeWidth: 1,
            pointerEvents: "none",
            strokeDasharray: "5,5",
            className: "horizontal-tooltip-line"
          }
        )
      ),
      (o.visualizationType === "Bar" || Dt()) && o.tooltips.singleSeries && o.visual.verticalHoverLine && /* @__PURE__ */ n.createElement(st, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ n.createElement(
        mn,
        {
          from: { x: Pe.x, y: 0 },
          to: { x: Pe.x, y: Tt },
          stroke: "black",
          strokeWidth: 1,
          pointerEvents: "none",
          strokeDasharray: "5,5",
          className: "vertical-tooltip-line"
        }
      )),
      /* @__PURE__ */ n.createElement(st, { left: Number(o.runtime.yAxis.size) }, /* @__PURE__ */ n.createElement(
        xp.Draggable,
        {
          xScale: $t,
          yScale: It,
          xScaleAnnotation: on,
          xMax: yt,
          svgRef: r,
          onDragStateChange: g
        }
      )),
      !["Spark Line", "Forest Plot"].includes(O) && o.yAxis.type !== "categorical" && /* @__PURE__ */ n.createElement(
        nm,
        {
          scale: It,
          tickLength: ot ? 6 : 8,
          left: Number(B.yAxis.size) - o.yAxis.axisPadding,
          label: B.yAxis.label || B.yAxis.label,
          stroke: "#333",
          tickFormat: er,
          numTicks: Zt()
        },
        (Ee) => {
          const et = o.orientation === "horizontal" ? (Ee.axisToPoint.y - Ee.axisFromPoint.y) / 2 : (Ee.axisFromPoint.y - Ee.axisToPoint.y) / 2, Ze = Tt / Ee.ticks.length / 2 - Tt / Ee.ticks.length * (1 - o.barThickness) + 5;
          return /* @__PURE__ */ n.createElement(st, { className: "left-axis" }, !o.yAxis.hideAxis && /* @__PURE__ */ n.createElement(
            mn,
            {
              from: Ee.axisFromPoint,
              to: B.horizontal ? {
                x: 0,
                y: o.visualizationType === "Forest Plot" ? e : Number(P.horizontal)
              } : Ee.axisToPoint,
              stroke: "#000"
            }
          ), It.domain()[0] < 0 && /* @__PURE__ */ n.createElement(
            mn,
            {
              from: { x: Ee.axisFromPoint.x, y: It(0) },
              to: { x: yt, y: It(0) },
              stroke: "#333"
            }
          ), O === "Bar" && W === "horizontal" && $t.domain()[0] < 0 && /* @__PURE__ */ n.createElement(
            mn,
            {
              from: { x: $t(0), y: 0 },
              to: { x: $t(0), y: Tt },
              stroke: "#333",
              strokeWidth: 2
            }
          ), Ee.ticks.map((Ke, Vt) => {
            const At = Ee.ticks[0].to.y, Xt = 15, Rt = String(Ke.value).startsWith("1") || Ke.value === 0.1 ? "block" : "none", Qt = Rt === "block" ? 7 : 0, pn = { x: Ke.to.x - Qt, y: Ke.to.y }, _t = Ee.ticks.length - 1 === Vt, x = _t && G && re && !mt, M = U ? q ? -8 : -12 : 2, X = U ? 4 : 0, me = Ke.to.x - M, ge = Ke.to.y - X, Ae = U ? "end" : "middle", Ye = G && U && re && _t;
            return /* @__PURE__ */ n.createElement(st, { key: `vx-tick-${Ke.value}-${Vt}`, className: "vx-axis-tick" }, !B.yAxis.hideTicks && !U && !x && /* @__PURE__ */ n.createElement(
              mn,
              {
                key: `${Ke.value}--hide-hideTicks`,
                from: Ke.from,
                to: ot ? pn : Ke.to,
                stroke: o.yAxis.tickColor,
                display: W === "horizontal" ? "none" : "block"
              }
            ), W === "horizontal" && K !== "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              St,
              {
                transform: `translate(${Ke.to.x - 5}, ${o.isLollipopChart ? Ke.to.y - At : Ke.to.y - At + (Number(o.barHeight * o.runtime.series.length) - Xt) / 2}) rotate(-${o.runtime.horizontal && o.runtime.yAxis.tickRotation || 0})`,
                verticalAnchor: "start",
                textAnchor: "end"
              },
              Ke.formattedValue
            ), W === "horizontal" && K === "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              St,
              {
                transform: `translate(${Ke.to.x - 5}, ${Ke.to.y - At + (Number(o.barHeight) - Xt) / 2}) rotate(-${B.horizontal ? B.yAxis.tickRotation : 0})`,
                verticalAnchor: "start",
                textAnchor: "end"
              },
              Ke.formattedValue
            ), W === "horizontal" && O === "Paired Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              St,
              {
                transform: `translate(${Ke.to.x - 5}, ${Ke.to.y - At + Number(o.barHeight) / 2}) rotate(-${B.horizontal ? B.yAxis.tickRotation : 0})`,
                textAnchor: "end",
                verticalAnchor: "middle"
              },
              Ke.formattedValue
            ), W === "horizontal" && O === "Deviation Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(
              St,
              {
                transform: `translate(${Ke.to.x - 5}, ${o.isLollipopChart ? Ke.to.y - At + 2 : Ke.to.y - At + Number(o.barHeight) / 2}) rotate(-${B.horizontal ? B.yAxis.tickRotation : 0})`,
                textAnchor: "end",
                verticalAnchor: "middle"
              },
              Ke.formattedValue
            ), W === "vertical" && O === "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
              St,
              {
                display: o.useLogScale ? Rt : "block",
                dx: o.useLogScale ? -6 : 0,
                x: o.runtime.horizontal ? Ke.from.x + 2 : Ke.to.x - 8.5,
                y: Ke.to.y - 13 + (o.runtime.horizontal ? Ze : 0),
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: o.runtime.horizontal ? "start" : "middle",
                textAnchor: o.runtime.horizontal ? "start" : "end",
                fill: o.yAxis.tickLabelColor
              },
              o.runtime.seriesLabelsAll[Ke.formattedValue - 1]
            ), (C.length === 0 || C.includes(
              o.runtime.seriesLabelsAll[Ke.formattedValue - 1]
            )) && /* @__PURE__ */ n.createElement(
              "rect",
              {
                x: 0 - Number(o.yAxis.size),
                y: Ke.to.y - 8 + (o.runtime.horizontal ? Ze : 7),
                width: Number(o.yAxis.size) + $t($t.domain()[0]),
                height: "2",
                fill: i(o.runtime.seriesLabelsAll[Ke.formattedValue - 1])
              }
            )), W === "vertical" && O !== "Paired Bar" && O !== "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ n.createElement(n.Fragment, null, G && _t && !U && /* @__PURE__ */ n.createElement(
              Vp,
              {
                innerRef: He,
                display: ot ? Rt : "block",
                dx: ot ? -6 : 0,
                x: me,
                y: ge,
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: Ae,
                textAnchor: mt ? "end" : "start",
                fill: o.yAxis.tickLabelColor,
                stroke: "#fff",
                paintOrder: "stroke",
                strokeLinejoin: "round",
                style: { whiteSpace: "pre-wrap" }
              },
              re
            ), /* @__PURE__ */ n.createElement(
              Vp,
              {
                innerRef: (ut) => _t && (Ve.current = ut),
                display: ot ? Rt : "block",
                dx: ot ? -6 : 0,
                x: mt ? me - $e : me,
                y: ge + (o.runtime.horizontal ? Ze : 0),
                angle: -Number(o.yAxis.tickRotation) || 0,
                verticalAnchor: o.runtime.horizontal ? "start" : Ae,
                textAnchor: o.runtime.horizontal || U ? "start" : "end",
                fill: o.yAxis.tickLabelColor,
                stroke: "#fff",
                disableStroke: !U,
                strokeLinejoin: "round",
                paintOrder: "stroke",
                style: { whiteSpace: "pre-wrap" }
              },
              `${Ke.formattedValue}${Ye ? re : ""}`
            )));
          }), /* @__PURE__ */ n.createElement(
            St,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${-1 * B.yAxis.size + wt}, ${et}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.labelColor
            },
            Ee.label
          ));
        }
      ),
      o.yAxis.type === "categorical" && o.orientation === "vertical" && /* @__PURE__ */ n.createElement(
        gk,
        {
          max: bt,
          maxValue: oe,
          height: Pt,
          xMax: yt,
          yMax: Tt,
          leftSize: Number(B.yAxis.size) - o.yAxis.axisPadding
        }
      ),
      An && /* @__PURE__ */ n.createElement(
        PS,
        {
          scale: Ln,
          left: Number(Gt - o.yAxis.rightAxisSize),
          label: o.yAxis.rightLabel,
          tickFormat: (Ee) => p(Ee, "right"),
          numTicks: B.yAxis.rightNumTicks || void 0,
          labelOffset: 45
        },
        (Ee) => {
          const et = o.orientation === "horizontal" ? (Ee.axisToPoint.y - Ee.axisFromPoint.y) / 2 : (Ee.axisFromPoint.y - Ee.axisToPoint.y) / 2, Ze = Tt / Ee.ticks.length / 2 - Tt / Ee.ticks.length * (1 - o.barThickness) + 5;
          return /* @__PURE__ */ n.createElement(st, { className: "right-axis" }, Ee.ticks.map((Ke, Vt) => /* @__PURE__ */ n.createElement(st, { key: `vx-tick-${Ke.value}-${Vt}`, className: "vx-axis-tick" }, !B.yAxis.rightHideTicks && /* @__PURE__ */ n.createElement(
            mn,
            {
              from: Ke.from,
              to: Ke.to,
              display: B.horizontal ? "none" : "block",
              stroke: o.yAxis.rightAxisTickColor
            }
          ), B.yAxis.rightGridLines ? /* @__PURE__ */ n.createElement(mn, { from: { x: Ke.from.x + yt, y: Ke.from.y }, to: Ke.from, stroke: "#d6d6d6" }) : "", !o.yAxis.rightHideLabel && /* @__PURE__ */ n.createElement(
            St,
            {
              x: Ke.to.x,
              y: Ke.to.y + (B.horizontal ? Ze : 0),
              verticalAnchor: B.horizontal ? "start" : "middle",
              textAnchor: "start",
              fill: o.yAxis.rightAxisTickLabelColor
            },
            Ke.formattedValue
          ))), !o.yAxis.rightHideAxis && /* @__PURE__ */ n.createElement(mn, { from: Ee.axisFromPoint, to: Ee.axisToPoint, stroke: "#333" }), /* @__PURE__ */ n.createElement(
            St,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${o.yAxis.rightLabelOffsetSize ? o.yAxis.rightLabelOffsetSize : 0}, ${et}) rotate(-90)`,
              fontWeight: "bold",
              fill: o.yAxis.rightAxisLabelColor
            },
            Ee.label
          ));
        }
      ),
      pe && o.topAxis.hasLine && /* @__PURE__ */ n.createElement(
        _S,
        {
          stroke: "#333",
          left: Number(B.yAxis.size),
          scale: $t,
          hideTicks: !0,
          hideZero: !0,
          tickLabelProps: () => ({
            fill: "transparent"
          })
        }
      ),
      O !== "Paired Bar" && O !== "Spark Line" && /* @__PURE__ */ n.createElement(
        qu,
        {
          innerRef: Re,
          top: B.horizontal && o.visualizationType !== "Forest Plot" ? Number(P.horizontal) + Number(o.xAxis.axisPadding) : o.visualizationType === "Forest Plot" ? Tt + Number(o.xAxis.axisPadding) : Tt,
          left: o.visualizationType !== "Forest Plot" ? Number(B.yAxis.size) : 0,
          label: o[un].label,
          tickFormat: or,
          scale: $t,
          stroke: "#333",
          numTicks: Xn("xAxis"),
          tickStroke: "#333",
          tickValues: o.xAxis.manual ? kk(
            Nt,
            $t,
            o.xAxis.type === "date-time" ? Xn("xAxis") : at(),
            o
          ) : void 0
        },
        (Ee) => {
          var X;
          const et = Ut + sf, Ze = o.visualizationType !== "Forest Plot" ? (Ee.axisToPoint.x - Ee.axisFromPoint.x) / 2 : c[0] / 2, Ke = (me) => /\s/.test(me), Vt = Ee.ticks.some((me) => Ke(me.value)), At = Math.max(
            ...Ee.ticks.map(
              (me) => Kn(me.formattedValue, `normal ${Yt[o.fontSize]}px sans-serif`)
            )
          ), Xt = Vt ? 180 : 100, Rt = Ee.ticks.map(
            (me) => Kn(me.formattedValue, `normal ${Yt[o.fontSize]}px sans-serif`)
          ), Qt = Rt.reduce((me, ge) => me + ge, Xt), pn = (yt - Qt) / (Ee.ticks.length - 1);
          let _t = [0];
          for (let me = 1; me < Rt.length; me++)
            _t[me] = _t[me - 1] + Rt[me - 1] + pn;
          const x = (X = Re == null ? void 0 : Re.current) == null ? void 0 : X.getBBox().height;
          o.xAxis.axisBBox = x;
          let D = !1;
          Rt.forEach((me, ge) => {
            if (_t[ge] + Rt[ge] > _t[ge + 1]) {
              D = !0;
              return;
            }
          }), o.xAxis.showYearsOnce && (D = !0);
          const M = D && o.isResponsiveTicks ? At + cf + 20 : 0;
          return o.dynamicMarginTop = M, o.xAxis.tickWidthMax = At, /* @__PURE__ */ n.createElement(st, { className: "bottom-axis", width: c[0] }, Ee.ticks.map((me, ge, Ae) => {
            const Ye = String(me.value).startsWith("1") || me.value === 0.1 ? "block" : "none", ut = Ye === "block" ? 16 : cf, gt = { x: me.to.x, y: ut };
            Kn(
              me.formattedValue,
              `normal ${Yt[o.fontSize]}px sans-serif`
            );
            const pt = 100 / Ae.length;
            o.yAxis.tickRotation = o.isResponsiveTicks && o.orientation === "horizontal" ? 0 : o.yAxis.tickRotation, o.xAxis.tickRotation = o.isResponsiveTicks && o.orientation === "vertical" ? 0 : o.xAxis.tickRotation;
            const Mt = o.isResponsiveTicks && D ? -Number(o.xAxis.maxTickRotation) || -90 : -Number(o.runtime.xAxis.tickRotation);
            return /* @__PURE__ */ n.createElement(st, { key: `vx-tick-${me.value}-${ge}`, className: "vx-axis-tick" }, !o.xAxis.hideTicks && /* @__PURE__ */ n.createElement(
              mn,
              {
                from: me.from,
                to: W === "horizontal" && ot ? gt : me.to,
                stroke: o.xAxis.tickColor,
                strokeWidth: Ye === "block" && ot ? 1.3 : 1
              }
            ), !o.xAxis.hideLabel && /* @__PURE__ */ n.createElement(
              St,
              {
                innerRef: (Pn) => Ge.current[ge] = Pn,
                dy: o.orientation === "horizontal" && ot ? 8 : 0,
                display: o.orientation === "horizontal" && ot ? Ye : "block",
                x: me.to.x,
                y: me.to.y + uf,
                angle: Mt,
                verticalAnchor: Mt < -50 ? "middle" : "start",
                textAnchor: Mt ? "end" : "middle",
                width: D && !o.isResponsiveTicks && !Number(o[un].tickRotation) ? pt : void 0,
                fill: o.xAxis.tickLabelColor
              },
              me.formattedValue
            ));
          }), !o.xAxis.hideAxis && /* @__PURE__ */ n.createElement(mn, { from: Ee.axisFromPoint, to: Ee.axisToPoint, stroke: "#333" }), /* @__PURE__ */ n.createElement(
            St,
            {
              innerRef: Xe,
              className: "x-axis-title-label",
              x: Ze,
              y: nt ? 0 : et,
              textAnchor: "middle",
              verticalAnchor: "start",
              fontWeight: "bold",
              fill: o.xAxis.labelColor
            },
            Ee.label
          ));
        }
      )
    ),
    !A && Ht && Object.entries(Ht.data).length > 0 && qn && gn && Ht.dataYPosition && Ht.dataXPosition && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${o.tooltips.opacity / 100}) !important;`), /* @__PURE__ */ n.createElement("style", null, ".tooltip {max-width:300px} !important; word-wrap: break-word; "), /* @__PURE__ */ n.createElement(
      Wy,
      {
        key: Math.random(),
        className: "tooltip cdc-open-viz-module",
        left: jn,
        top: $n
      },
      /* @__PURE__ */ n.createElement("ul", null, typeof Ht == "object" && Object.entries(Ht.data).map((Ee, et) => /* @__PURE__ */ n.createElement(it, { item: Ee, key: et })))
    )),
    o.visualizationType === "Bump Chart" && /* @__PURE__ */ n.createElement(
      xc,
      {
        id: "bump-chart",
        variant: "light",
        arrowColor: "rgba(0,0,0,0)",
        className: "tooltip",
        style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
      }
    ),
    De() && !A && /* @__PURE__ */ n.createElement(
      xc,
      {
        id: `cdc-open-viz-tooltip-${B.uniqueId}`,
        variant: "light",
        arrowColor: "rgba(0,0,0,0)",
        className: "tooltip",
        style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
      }
    ),
    /* @__PURE__ */ n.createElement("div", { className: "animation-trigger", ref: Oe })
  ));
});
const Mk = (e) => {
  var B;
  const { width: t, height: r } = e, { transformedData: a, config: i, parseDate: o, formatDate: d, seriesHighlight: c, formatNumber: s, colorScale: p, handleChartAriaLabels: m } = ie.useContext(Et);
  let v = Number(t);
  const { minValue: g, maxValue: A } = Vc(i, a), k = { top: 5, right: 10, bottom: 10, left: 10 }, E = Number(r), T = v - i.runtime.yAxis.size, b = E - k.top - 20, y = (Z) => i.runtime.xAxis.type === "date" ? o(Z[i.runtime.originalXAxis.dataKey]).getTime() : Z[i.runtime.originalXAxis.dataKey], N = (Z, te) => Z[te];
  let C, P;
  const { max: O, min: K } = i.runtime.yAxis, W = Number(O) >= Number(A), J = Number(K) <= Number(g);
  if (a) {
    let Z = Number(K && J ? K : g), te = Number(O && W ? O : Number.MIN_VALUE);
    if (te === Number.MIN_VALUE && (te = A), i.runtime.yAxis.paddingPercent) {
      let ee = (te - Z) * i.runtime.yAxis.paddingPercent;
      Z -= ee, te += ee;
    }
    let V = a.map((ee) => y(ee));
    i.runtime.horizontal ? (C = Vn({
      domain: [Z, te],
      range: [0, T]
    }), P = i.runtime.xAxis.type === "date" ? Vn({ domain: [Math.min(...V), Math.max(...V)] }) : Jo({ domain: V, padding: 0.5 }), Jo({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, b]
    }), P.rangeRound([0, b])) : (Z = Z < 0 ? Z * 1.11 : Z, P = Vn({
      domain: [Z, te],
      range: [b - k.bottom, k.top]
    }), C = Jo({
      domain: V,
      range: [k.left, v - k.right]
    }), Jo({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, T]
    }));
  }
  const j = [C.domain()[0], C.domain()[C.domain().length - 1]];
  return /* @__PURE__ */ n.createElement(Hr, { component: "SparkLine" }, /* @__PURE__ */ n.createElement("svg", { role: "img", "aria-label": m(i), width: t, height: 100, className: "sparkline", tabIndex: 0 }, /* @__PURE__ */ n.createElement("title", null, `Spark line graphic with the title ${i.title ? i.title : "No Title Found"}`), ((B = i.runtime.lineSeriesKeys) == null ? void 0 : B.length) > 0 ? i.runtime.lineSeriesKeys : i.runtime.seriesKeys.map((Z, te) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    st,
    {
      style: { width: v },
      className: "sparkline-group",
      key: `series-${Z}`,
      opacity: i.legend.behavior === "highlight" && c.length > 0 && c.indexOf(Z) === -1 ? 0.5 : 1,
      display: i.legend.behavior === "highlight" || c.length === 0 || c.indexOf(Z) !== -1 ? "block" : "none"
    },
    i.labels && a.map((V, ee) => /* @__PURE__ */ n.createElement(st, { key: `series-${Z}-point-${ee}` }, /* @__PURE__ */ n.createElement(St, { x: C(y(V)), y: P(N(V, Z)), fill: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[Z] : Z) : "#000", textAnchor: "middle" }, s(V[Z])))),
    /* @__PURE__ */ n.createElement(
      Ir,
      {
        curve: Oc,
        data: a,
        x: (V) => C(y(V)),
        y: (V) => P(N(V, Z)),
        stroke: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[Z] : Z) : "#000",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        markerEnd: `url(#arrow--${te})`
      }
    ),
    /* @__PURE__ */ n.createElement(xm, { id: `arrow--${te}`, refX: 2, size: 6, markerEnd: `url(#arrow--${te})`, strokeOpacity: 1, fillOpacity: 1, fill: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[Z] : Z) : "#000" })
  ), /* @__PURE__ */ n.createElement(
    qu,
    {
      top: b + k.top,
      hideAxisLine: !0,
      hideTicks: !0,
      scale: C,
      tickValues: j,
      tickFormat: (V) => i.xAxis.type === "date" ? d(V) : null,
      stroke: "black",
      tickStroke: "black",
      tickLabelProps: () => ({
        fill: "black",
        fontSize: 11,
        textAnchor: "middle"
      })
    }
  )))));
};
var zk = ["flexDirection", "alignItems", "margin", "display", "children"];
function Wf() {
  return Wf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Wf.apply(this, arguments);
}
function Bk(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Lc(e) {
  var t = e.flexDirection, r = t === void 0 ? "row" : t, a = e.alignItems, i = a === void 0 ? "center" : a, o = e.margin, d = o === void 0 ? "0" : o, c = e.display, s = c === void 0 ? "flex" : c, p = e.children, m = Bk(e, zk);
  return /* @__PURE__ */ n.createElement("div", Wf({
    className: "visx-legend-item",
    style: {
      display: s,
      alignItems: i,
      flexDirection: r,
      margin: d
    }
  }, m), p);
}
Lc.propTypes = {
  alignItems: je.string,
  margin: je.oneOfType([je.string, je.number]),
  children: je.node,
  display: je.string
};
var $k = ["flex", "label", "margin", "align", "children"];
function jf() {
  return jf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, jf.apply(this, arguments);
}
function Ik(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function Pc(e) {
  var t = e.flex, r = t === void 0 ? "1" : t, a = e.label, i = e.margin, o = i === void 0 ? "5px 0" : i, d = e.align, c = d === void 0 ? "left" : d, s = e.children, p = Ik(e, $k);
  return /* @__PURE__ */ n.createElement("div", jf({
    className: "visx-legend-label",
    style: {
      justifyContent: c,
      display: "flex",
      flex: r,
      margin: o
    }
  }, p), s || a);
}
Pc.propTypes = {
  align: je.string,
  label: je.node,
  flex: je.oneOfType([je.string, je.number]),
  margin: je.oneOfType([je.string, je.number]),
  children: je.node
};
function Uf() {
  return Uf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Uf.apply(this, arguments);
}
function bp(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style;
  return /* @__PURE__ */ n.createElement("div", {
    style: Uf({
      width: r,
      height: a,
      background: t
    }, i)
  });
}
bp.propTypes = {
  fill: je.string,
  width: je.oneOfType([je.string, je.number]),
  height: je.oneOfType([je.string, je.number])
};
function lg(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style, o = typeof r == "string" || typeof r > "u" ? 0 : r, d = typeof a == "string" || typeof a > "u" ? 0 : a, c = Math.max(o, d), s = c / 2;
  return /* @__PURE__ */ n.createElement("svg", {
    width: c,
    height: c
  }, /* @__PURE__ */ n.createElement(st, {
    top: s,
    left: s
  }, /* @__PURE__ */ n.createElement("circle", {
    r: s,
    fill: t,
    style: i
  })));
}
lg.propTypes = {
  fill: je.string,
  width: je.oneOfType([je.string, je.number]),
  height: je.oneOfType([je.string, je.number])
};
function sg(e) {
  var t = e.fill, r = e.width, a = e.height, i = e.style, o = typeof a == "string" || typeof a > "u" ? 0 : a, d = typeof (i == null ? void 0 : i.strokeWidth) == "number" ? i == null ? void 0 : i.strokeWidth : 2;
  return /* @__PURE__ */ n.createElement("svg", {
    width: r,
    height: a
  }, /* @__PURE__ */ n.createElement(st, {
    top: o / 2 - d / 2
  }, /* @__PURE__ */ n.createElement("line", {
    x1: 0,
    x2: r,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: d,
    style: i
  })));
}
sg.propTypes = {
  fill: je.string,
  width: je.oneOfType([je.string, je.number]),
  height: je.oneOfType([je.string, je.number])
};
function Es() {
  return Es = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Es.apply(this, arguments);
}
var ff = function() {
};
function Hk(e) {
  var t = e.shape, r = t === void 0 ? "rect" : t, a = e.fill, i = a === void 0 ? ff : a, o = e.size, d = o === void 0 ? ff : o, c = e.width, s = e.height, p = e.label, m = e.item, v = e.itemIndex, g = e.shapeStyle, A = g === void 0 ? ff : g, k = {
    width: c,
    height: s,
    item: m,
    itemIndex: v,
    label: p,
    fill: i(Es({}, p)),
    size: d(Es({}, p)),
    style: A(Es({}, p))
  };
  return typeof r == "string" ? r === "circle" ? /* @__PURE__ */ n.createElement(lg, k) : r === "line" ? /* @__PURE__ */ n.createElement(sg, k) : /* @__PURE__ */ n.createElement(bp, k) : /* @__PURE__ */ n.isValidElement(r) ? /* @__PURE__ */ n.cloneElement(r, k) : r ? /* @__PURE__ */ n.createElement(r, k) : null;
}
function Nc() {
  return Nc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Nc.apply(this, arguments);
}
function ug(e) {
  var t = e.shape, r = t === void 0 ? bp : t, a = e.width, i = e.height, o = e.margin, d = e.label, c = e.item, s = e.itemIndex, p = e.fill, m = e.size, v = e.shapeStyle;
  return /* @__PURE__ */ n.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: m ? m(Nc({}, d)) : a,
      height: m ? m(Nc({}, d)) : i,
      margin: o
    }
  }, Hk({
    shape: r,
    item: c,
    itemIndex: s,
    label: d,
    width: a,
    height: i,
    fill: p,
    shapeStyle: v
  }));
}
ug.propTypes = {
  itemIndex: je.number.isRequired,
  margin: je.oneOfType([je.string, je.number]),
  width: je.oneOfType([je.string, je.number]),
  height: je.oneOfType([je.string, je.number])
};
function cg(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function cm(e) {
  return String(cg(e));
}
function Vk(e) {
  var t = e.scale, r = e.labelFormat;
  return function(a, i) {
    return {
      datum: a,
      index: i,
      text: "" + r(a, i),
      value: t(a)
    };
  };
}
var Wk = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function Ss() {
  return Ss = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, Ss.apply(this, arguments);
}
function jk(e, t) {
  if (e == null)
    return {};
  var r = {}, a = Object.keys(e), i, o;
  for (o = 0; o < a.length; o++)
    i = a[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
var Uk = {
  display: "flex"
};
function dg(e) {
  var t = e.className, r = e.style, a = r === void 0 ? Uk : r, i = e.scale, o = e.shape, d = e.domain, c = e.fill, s = c === void 0 ? cm : c, p = e.size, m = p === void 0 ? cm : p, v = e.labelFormat, g = v === void 0 ? cg : v, A = e.labelTransform, k = A === void 0 ? Vk : A, E = e.shapeWidth, T = E === void 0 ? 15 : E, b = e.shapeHeight, y = b === void 0 ? 15 : b, N = e.shapeMargin, C = N === void 0 ? "2px 4px 2px 0" : N, P = e.shapeStyle, O = e.labelAlign, K = O === void 0 ? "left" : O, W = e.labelFlex, J = W === void 0 ? "1" : W, j = e.labelMargin, B = j === void 0 ? "0 4px" : j, Z = e.itemMargin, te = Z === void 0 ? "0" : Z, V = e.direction, ee = V === void 0 ? "column" : V, ce = e.itemDirection, re = ce === void 0 ? "row" : ce, G = e.legendLabelProps, U = e.children, q = jk(e, Wk), H = d || ("domain" in i ? i.domain() : []), oe = k({
    scale: i,
    labelFormat: g
  }), ue = H.map(oe);
  return U ? /* @__PURE__ */ n.createElement(n.Fragment, null, U(ue)) : /* @__PURE__ */ n.createElement("div", {
    className: _n("visx-legend", t),
    style: Ss({}, a, {
      flexDirection: ee
    })
  }, ue.map(function(ke, De) {
    return /* @__PURE__ */ n.createElement(Lc, Ss({
      key: "legend-" + ke.text + "-" + De,
      margin: te,
      flexDirection: re
    }, q), /* @__PURE__ */ n.createElement(ug, {
      shape: o,
      height: y,
      width: T,
      margin: C,
      item: H[De],
      itemIndex: De,
      label: ke,
      fill: s,
      size: m,
      shapeStyle: P
    }), /* @__PURE__ */ n.createElement(Pc, Ss({
      label: ke.text,
      flex: J,
      margin: B,
      align: K
    }, G)));
  }));
}
dg.propTypes = {
  children: je.func,
  className: je.string,
  domain: je.array,
  shapeWidth: je.oneOfType([je.string, je.number]),
  shapeHeight: je.oneOfType([je.string, je.number]),
  shapeMargin: je.oneOfType([je.string, je.number]),
  labelAlign: je.string,
  labelFlex: je.oneOfType([je.string, je.number]),
  labelMargin: je.oneOfType([je.string, je.number]),
  itemMargin: je.oneOfType([je.string, je.number]),
  fill: je.func,
  size: je.func,
  shapeStyle: je.func
};
function Kk(e) {
  return /* @__PURE__ */ n.createElement(dg, e);
}
const Yk = (e) => {
  const { position: t, singleRow: r, reverseLabelOrder: a, verticalSorted: i, hideBorder: o } = e.legend, d = ["legend-container"], c = ["legend-container__inner"];
  switch (t) {
    case "left":
      d.push("left");
      break;
    case "right":
      d.push("right");
      break;
    case "bottom":
      d.push("bottom"), c.push("double-column", "bottom");
      break;
    case "top":
      d.push("top"), c.push("double-column", "top");
      break;
  }
  return ["bottom", "top"].includes(t) && r && c.push("single-row"), a && c.push("d-flex", "flex-column-reverse"), ["bottom", "top"].includes(t) && i && c.push("vertical-sorted"), o.side && (["right", "left"].includes(t) || !t) && d.push("no-border"), o.topBottom && ["top", "bottom"].includes(t) && d.push("no-border"), o.topBottom && ["top"].includes(t) && d.push("p-0"), {
    containerClasses: d,
    innerClasses: c
  };
}, fg = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, Xk = (e, t, r) => {
  const i = t([{ datum: "", index: 0, text: "", value: "" }]), o = e.legend.colorCode ? i.map((c) => c == null ? void 0 : c.value) : (r == null ? void 0 : r.range()) ?? [], d = e.legend.colorCode ? i.map((c) => (c == null ? void 0 : c.text) || (c == null ? void 0 : c.datum)) : (r == null ? void 0 : r.domain()) ?? [];
  return { colors: o, labels: d };
}, qk = (e, t) => {
  var r;
  return e ? e && ((r = t.brush) != null && r.active) ? "35px" : "20px" : "0px";
}, Gk = (e, t) => {
  var i;
  const r = ((i = e.legend) == null ? void 0 : i.position) === "top" && !e.legend.hide;
  let a = 0;
  return r && (a = e.legend.hideBorder.topBottom ? 15 : 25), t && (a += 40), `${a}px`;
}, Zk = ({ config: e, isBottomOrSmallViewport: t, setHasSuppression: r }) => {
  const { preliminaryData: a, visualizationType: i, visualizationSubType: o, legend: d } = e, c = () => (a == null ? void 0 : a.some((k) => k.label && k.type === "effect" && k.style !== "Filled Circles")) && ["Line", "Combo"].includes(i), s = () => !d.hideSuppressedLabels && (a == null ? void 0 : a.some(
    (k) => k.label && k.displayLegend && k.type === "suppression" && k.value && ((k == null ? void 0 : k.style) || k.symbol)
  )) && (i === "Bar" && o === "regular" || i === "Line" || i === "Combo"), p = () => a == null ? void 0 : a.map(
    (k, E) => k.label && k.type === "effect" && k.style && /* @__PURE__ */ n.createElement("div", { key: E, className: "legend-preliminary" }, /* @__PURE__ */ n.createElement("span", { className: k.symbol }, k.lineCode), /* @__PURE__ */ n.createElement("p", null, k.label))
  ), m = (k) => {
    k.preventDefault();
  }, v = () => {
    const k = (E) => E ? {
      color: "#777772"
    } : null;
    return a == null ? void 0 : a.map((E, T) => {
      if (!E.displayLegend || E.type !== "suppression")
        return null;
      const b = "legend-preliminary", y = T + i;
      return i === "Bar" ? /* @__PURE__ */ n.createElement("div", { style: k(E.displayGray), key: y, className: `${b} ${E.symbol}` }, /* @__PURE__ */ n.createElement("span", { className: E.symbol }, E.iconCode), /* @__PURE__ */ n.createElement("p", { className: E.type }, E.label)) : i === "Line" ? /* @__PURE__ */ n.createElement("div", { style: k(E.displayGray), key: y, className: b }, /* @__PURE__ */ n.createElement("span", null, E.lineCode), /* @__PURE__ */ n.createElement("p", { className: E.type }, E.label)) : i === "Combo" ? /* @__PURE__ */ n.createElement(n.Fragment, null, E.symbol && E.iconCode && /* @__PURE__ */ n.createElement("div", { style: k(E.displayGray), key: y, className: `${b} ${E.symbol}` }, /* @__PURE__ */ n.createElement("span", { className: E.symbol }, E.iconCode), /* @__PURE__ */ n.createElement("p", { className: E.type }, E.label)), E.style && E.lineCode && /* @__PURE__ */ n.createElement("div", { style: k(E.displayGray), key: y, className: b }, /* @__PURE__ */ n.createElement("span", null, E.lineCode), /* @__PURE__ */ n.createElement("p", null, E.label))) : null;
    });
  }, g = () => d.singleRow && t ? "legend-container__inner bottom single-row" : "", A = () => !e.legend.hideSuppressionLink && e.visualizationSubType !== "stacked" && (a == null ? void 0 : a.some((k) => k.label && k.type === "suppression" && k.value && ((k == null ? void 0 : k.style) || k.symbol)));
  return r(A()), /* @__PURE__ */ n.createElement(n.Fragment, null, c() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("div", { className: g() }, p())), s() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("div", { className: g() }, v())), A() && /* @__PURE__ */ n.createElement("div", { className: "legend-container__outer definition-link" }, /* @__PURE__ */ n.createElement(tt, { alt: "info-icon", display: "info" }), /* @__PURE__ */ n.createElement("p", null, "This chart contains", /* @__PURE__ */ n.createElement(
    "a",
    {
      onClick: m,
      "data-tooltip-content": "Data is suppressed to maintain statistical reliability. This occurs when the number of respondents or reported values does not meet the minimum reporting threshold.",
      "data-tooltip-id": "my-tooltip",
      href: "no-router-link"
    },
    "suppressed data"
  ))), /* @__PURE__ */ n.createElement(
    xc,
    {
      id: "my-tooltip",
      variant: "light",
      style: { background: `rgba(255,255,255, ${e.tooltips.opacity / 100})`, color: "black", maxWidth: "100%" }
    }
  ));
}, Qk = 30, Jk = ie.forwardRef(
  ({
    config: e,
    colorScale: t,
    seriesHighlight: r,
    highlight: a,
    highlightReset: i,
    currentViewport: o,
    formatLabels: d,
    skipId: c = "legend",
    dimensions: s
  }, p) => {
    const { innerClasses: m, containerClasses: v } = Yk(e), { runtime: g, legend: A } = e, [k, E] = ie.useState(!1), T = (A == null ? void 0 : A.position) === "bottom" || ga(o) && !A.hide, b = {
      marginBottom: Gk(e, k),
      marginTop: qk(T, e)
    }, { HighLightedBarUtils: y } = Ic(e);
    let N = y.findDuplicates(e.highlightedBarValues);
    return A ? /* @__PURE__ */ n.createElement(
      "aside",
      {
        ref: p,
        style: b,
        id: c || "legend",
        className: v.join(" "),
        role: "region",
        "aria-label": "legend",
        tabIndex: 0
      },
      A.label && /* @__PURE__ */ n.createElement("h3", null, Mi(A.label)),
      A.description && /* @__PURE__ */ n.createElement("p", null, Mi(A.description)),
      /* @__PURE__ */ n.createElement(
        Ng,
        {
          config: e,
          ...Xk(e, d, t),
          dimensions: s,
          parentPaddingToSubtract: Qk
        }
      ),
      /* @__PURE__ */ n.createElement(Kk, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0" }, (C) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: m.join(" ") }, d(C).map((P, O) => {
        var J, j, B, Z;
        let K = ["legend-item", `legend-text--${P.text.replace(" ", "").toLowerCase()}`], W = P.datum;
        if (e.exclusions.active && ((J = e.exclusions.keys) != null && J.includes(W)))
          return null;
        if (g.seriesLabels) {
          let te = e.runtime.seriesLabelsAll.indexOf(W);
          W = e.runtime.seriesKeys[te], ((j = g == null ? void 0 : g.forecastingSeriesKeys) == null ? void 0 : j.length) > 0 && (W = P.text);
        }
        return r.length > 0 && r.includes(W) === !1 && K.push("inactive"), e.legend.style === "gradient" ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(
          Lc,
          {
            className: K.join(" "),
            tabIndex: 0,
            key: `legend-quantile-${O}`,
            onKeyDown: (te) => {
              te.key === "Enter" && (te.preventDefault(), a(P));
            },
            onClick: (te) => {
              te.preventDefault(), a(P);
            },
            role: "button"
          },
          /* @__PURE__ */ n.createElement(n.Fragment, null, e.visualizationType === "Line" && e.legend.style === "lines" ? /* @__PURE__ */ n.createElement("svg", { width: 40, height: 25 }, /* @__PURE__ */ n.createElement(
            mn,
            {
              from: { x: 10, y: 10 },
              to: { x: 40, y: 10 },
              stroke: P.value,
              strokeWidth: 2,
              strokeDasharray: fg((B = e.series[O]) != null && B.type ? (Z = e.series[O]) == null ? void 0 : Z.type : "")
            }
          )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
            Mp,
            {
              shape: e.legend.style === "boxes" ? "square" : "circle",
              fill: P.value
            }
          ))),
          /* @__PURE__ */ n.createElement(Pc, { align: "left", margin: "0 0 0 4px" }, P.text)
        );
      }), N.map((P, O) => {
        let K = "legend-item", W = P.legendLabel;
        return W ? (r.length > 0 && r.includes(W) === !1 && (K += " inactive"), /* @__PURE__ */ n.createElement(
          Lc,
          {
            className: K,
            tabIndex: 0,
            key: `legend-quantile-${O}`,
            onKeyDown: (J) => {
              J.key === "Enter" && (J.preventDefault(), a(P.legendLabel));
            },
            onClick: (J) => {
              J.preventDefault(), a(P.legendLabel);
            }
          },
          /* @__PURE__ */ n.createElement(
            Mp,
            {
              shape: e.legend.style === "boxes" ? "square" : "circle",
              style: { borderRadius: "0px" },
              fill: "transparent",
              borderColor: P.color ? P.color : "rgba(255, 102, 1)"
            }
          ),
          " ",
          /* @__PURE__ */ n.createElement(Pc, { align: "left", margin: "0 0 0 4px" }, P.legendLabel ? P.legendLabel : P.value)
        )) : !1;
      })), /* @__PURE__ */ n.createElement(
        Zk,
        {
          config: e,
          isBottomOrSmallViewport: T,
          setHasSuppression: E
        }
      ))),
      r.length > 0 && /* @__PURE__ */ n.createElement(ws, { onClick: (C) => i(C), style: { marginTop: "1rem" } }, "Reset")
    ) : null;
  }
);
function ew(e) {
  return Rg({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" } }] })(e);
}
const tw = (e, t, r, a) => (i) => {
  var g, A, k, E, T;
  const { visualizationType: o, visualizationSubType: d, series: c, runtime: s } = e, p = (b) => {
    var y;
    return e.legend.reverseLabelOrder && ((y = e.legend) == null ? void 0 : y.position) === "bottom" ? b.reverse() : b;
  }, m = (g = e.legend) == null ? void 0 : g.colorCode;
  if (o === "Deviation Bar") {
    const [b, y] = ks[e.twoColor.palette], N = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: b
    }, C = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: y
    };
    return p([N, C]);
  }
  if (o === "Bar" && d === "regular" && m && (c == null ? void 0 : c.length) === 1) {
    let b = pr[e.palette];
    for (; t.length > b.length; )
      b = b.concat(b);
    b = b.slice(0, r.length);
    const y = /* @__PURE__ */ new Set();
    t.forEach((C) => y.add(C[m]));
    const N = Array.from(y).map((C, P) => ({
      datum: C,
      index: P,
      text: C,
      value: b[P]
    }));
    return p(N);
  }
  if (((A = s == null ? void 0 : s.forecastingSeriesKeys) == null ? void 0 : A.length) > 0) {
    let b = [];
    return (E = (k = e.runtime) == null ? void 0 : k.forecastingSeriesKeys) == null || E.map((y, N) => {
      var C;
      return (C = y == null ? void 0 : y.stages) == null ? void 0 : C.map((P, O) => {
        var J, j, B, Z;
        let K = (J = Ju[P.color]) != null && J[2] ? (j = Ju[P.color]) == null ? void 0 : j[2] : (B = pr[P.color]) != null && B[2] ? (Z = pr[P.color]) == null ? void 0 : Z[2] : "#ccc";
        const W = {
          datum: P.key,
          index: O,
          text: P.key,
          value: K
        };
        b.push(W);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((y, N) => {
      let C = pr[e.palette][N] ? pr[e.palette][N] : "#ccc";
      const P = {
        datum: y,
        index: N,
        text: y,
        value: C
      };
      b.push(P);
    }), p(b);
  }
  if (e.series.filter((b) => !!b.name).length > 0) {
    const b = /* @__PURE__ */ new Set();
    e.series.forEach((N) => {
      b.add(N.name || N.dataKey);
    });
    const y = Array.from(b).map((N, C) => ({
      datum: N,
      index: C,
      text: N,
      value: a(N)
    }));
    return p(y);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const b = i.length - 1;
    let y = [];
    return (T = e.suppressedData) == null || T.forEach(({ label: N, icon: C }, P) => {
      if (N && C) {
        const O = {
          datum: N,
          index: b + P,
          text: N,
          icon: /* @__PURE__ */ n.createElement(ew, { color: "#000", size: 15 })
        };
        y.push(O);
      }
    }), [...i, ...y];
  }
  return p(i);
}, nw = ie.forwardRef((e, t) => {
  const {
    // prettier-ignore
    config: r,
    colorScale: a,
    seriesHighlight: i,
    highlight: o,
    tableData: d,
    highlightReset: c,
    transformedData: s,
    currentViewport: p,
    dimensions: m
  } = ie.useContext(Et);
  if (!r.legend)
    return null;
  const v = tw(r, d, s, a);
  return !["Box Plot"].includes(r.visualizationType) && /* @__PURE__ */ n.createElement(ie.Fragment, null, /* @__PURE__ */ n.createElement(
    Jk,
    {
      dimensions: m,
      ref: t,
      skipId: e.skipId || "legend",
      config: r,
      colorScale: a,
      seriesHighlight: i,
      highlight: o,
      highlightReset: c,
      currentViewport: p,
      formatLabels: v
    }
  ));
}), pf = {
  annotations: [],
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  fontSize: "medium",
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "false",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    annotationDropdownText: "Annotations",
    showDownloadButton: !1,
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0,
    showZeroValueData: !0,
    hideNullValue: !0
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !0,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: [],
    shoMissingDataLabel: !0,
    showMissingDataLine: !0,
    categories: []
  },
  boxplot: {
    plots: [],
    borders: "true",
    firstQuartilePercentage: 25,
    thirdQuartilePercentage: 75,
    boxWidthPercentage: 40,
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    legend: {
      showHowToReadText: !1,
      howToReadText: ""
    },
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      total: "Total",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 0,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0,
    padding: 5,
    showYearsOnce: !1
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    showDownloadLinkBelow: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: "",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    label: "",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    hideSuppressionLink: !1,
    seriesHighlight: [],
    style: "circles",
    subStyle: "linear blocks",
    tickRotation: "",
    hideBorder: {
      side: !1,
      topBottom: !0
    }
  },
  brush: {
    height: 25,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, pg = ({ fieldName: e, fieldKey: t, fieldType: r, controls: a, deleteField: i, children: o }) => {
  const [d, c] = a, s = d[t], p = (m, v) => {
    c({ ...d, [m]: v });
  };
  return s ? /* @__PURE__ */ n.createElement("fieldset", { className: "edit-block mb-1", key: t }, /* @__PURE__ */ n.createElement("div", { className: "d-flex justify-content-between" }, /* @__PURE__ */ n.createElement("button", { className: "btn btn-light", onClick: () => p(t, !1) }, /* @__PURE__ */ n.createElement(tt, { display: "caretUp" })), /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "btn btn-danger btn-sm",
      onClick: (m) => {
        m.preventDefault(), i();
      }
    },
    "Remove"
  )), o) : /* @__PURE__ */ n.createElement("div", { className: "mb-1" }, /* @__PURE__ */ n.createElement("button", { className: "btn btn-light", onClick: () => p(t, !0) }, /* @__PURE__ */ n.createElement(tt, { display: "caretDown" })), /* @__PURE__ */ n.createElement("span", null, " ", e ? `${e}` : "New " + r));
}, rw = ({
  config: e,
  deleteColumn: t,
  updateField: r,
  colKey: a,
  controls: i
}) => {
  var v, g, A, k;
  const [o, d] = i, c = (E, T) => {
    if (E === "dataTable" && T === !0) {
      const b = jt.cloneDeep(e.columns);
      b[a] = { ...b[a], dataTable: T }, r(null, null, "columns", b);
    } else
      r("columns", a, E, T);
  }, s = (E) => {
    const T = jt.cloneDeep(e.columns), y = { ...e.columns[a], name: E, label: E };
    if (y.dataTable === void 0 && (y.dataTable = !0), E !== a) {
      T[E] = y, delete T[a];
      const N = { ...jt.cloneDeep(o), [E]: !0 };
      delete N[a], d(N);
    }
    r(null, null, "columns", T);
  }, p = () => {
    var y;
    const E = e.data.flatMap((N) => Object.keys(N).map((C) => C)), T = Object.values(e.columns).map((N) => N.name), b = jt.uniq(E).filter((N) => !(e.table.groupBy === N || T.includes(N)));
    return (y = e.columns[a]) != null && y.name && b.push(e.columns[a].name), b;
  }, m = (v = e.columns[a]) == null ? void 0 : v.name;
  return /* @__PURE__ */ n.createElement(
    pg,
    {
      fieldName: m,
      fieldKey: a,
      fieldType: "Column",
      controls: i,
      deleteField: () => t(a)
    },
    /* @__PURE__ */ n.createElement(
      vt,
      {
        label: "Column",
        value: (g = e.columns[a]) == null ? void 0 : g.name,
        fieldName: "name",
        section: "columns",
        initial: "-Select-",
        options: p(),
        updateField: (E, T, b, y) => s(y)
      }
    ),
    e.type !== "table" && /* @__PURE__ */ n.createElement(
      vt,
      {
        label: "Associate to Series",
        value: (A = e.columns[a]) == null ? void 0 : A.series,
        fieldName: "series",
        section: "columns",
        initial: "Select series",
        options: ((k = e.series) == null ? void 0 : k.map((E) => E.dataKey)) || [],
        updateField: (E, T, b, y) => c("series", y)
      }
    ),
    /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.columns[a].label,
        section: "columns",
        subsection: a,
        fieldName: "label",
        label: "Label",
        updateField: r
      }
    ),
    /* @__PURE__ */ n.createElement("ul", { className: "column-edit" }, /* @__PURE__ */ n.createElement("li", { className: "three-col" }, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.columns[a].prefix,
        section: "columns",
        subsection: a,
        fieldName: "prefix",
        label: "Prefix",
        updateField: r
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.columns[a].suffix,
        section: "columns",
        subsection: a,
        fieldName: "suffix",
        label: "Suffix",
        updateField: r
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        type: "number",
        value: e.columns[a].roundToPlace,
        section: "columns",
        subsection: a,
        fieldName: "roundToPlace",
        label: "Round",
        updateField: r
      }
    )), /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].commas,
        onChange: (E) => {
          c("commas", E.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Add Commas to Numbers"))), /* @__PURE__ */ n.createElement("li", null, e.table.showVertical && /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].dataTable ?? !0,
        onChange: (E) => {
          c("dataTable", E.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Data Table"))), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].showInViz,
        onChange: (E) => {
          c("showInViz", E.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Visualization"))), e.type !== "table" && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].tooltips || !1,
        onChange: (E) => {
          r("columns", a, "tooltips", E.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in tooltip"))), e.visualizationType === "Forest Plot" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].forestPlot || !1,
        onChange: (E) => {
          c("forestPlot", E.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Show in Forest Plot"))), /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "checkbox" }, /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[a].forestPlotAlignRight || !1,
        onChange: (E) => {
          c("forestPlotAlignRight", E.target.checked);
        }
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Align Right"))), !e.columns[a].forestPlotAlignRight && /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement("label", { className: "text" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Forest Plot Starting Point"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "number",
        value: e.columns[a].forestPlotStartingPoint || 0,
        onChange: (E) => {
          c("forestPlotStartingPoint", E.target.value);
        }
      }
    ))))),
    /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Order"), /* @__PURE__ */ n.createElement(
      "input",
      {
        onWheel: (E) => E.currentTarget.blur(),
        type: "number",
        min: "1",
        value: e.columns[a].order,
        onChange: (E) => r("columns", a, "order", parseInt(E.target.value))
      }
    ))
  );
}, aw = ({ config: e, updateField: t, deleteColumn: r }) => {
  var d;
  const a = ie.useState({}), i = Object.keys(e.columns), o = (c) => {
    const s = `additionalColumn${c}`, p = {
      label: "New Column",
      dataTable: !0,
      tooltips: !1,
      prefix: "",
      suffix: "",
      forestPlot: !1,
      startingPoint: "0",
      forestPlotAlignRight: !1,
      roundToPlace: 0,
      commas: !1,
      showInViz: !1,
      forestPlotStartingPoint: 0
    }, [m, v] = a;
    v({ ...m, [s]: !0 }), t("columns", null, s, p);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.type !== "navigation" && /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Configurations", /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can specify additional columns to display in tooltips and / or the supporting data table."))))), i.map((c, s) => /* @__PURE__ */ n.createElement(
    rw,
    {
      key: c + s,
      controls: a,
      config: e,
      deleteColumn: r,
      updateField: t,
      colKey: c
    }
  )), /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "btn btn-primary",
      onClick: (c) => {
        c.preventDefault(), o(i.length + 1);
      }
    },
    "Add Configuration"
  )), ((d = e.legend) == null ? void 0 : d.type) === "category" && /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Additional Category", /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can provide additional categories to ensure they appear in the legend"))))), e.legend.additionalCategories && e.legend.additionalCategories.map((c, s) => /* @__PURE__ */ n.createElement("fieldset", { className: "edit-block", key: c }, /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "remove-column",
      onClick: (p) => {
        p.preventDefault();
        const m = [...e.legend.additionalCategories];
        m.splice(s, 1), t("legend", null, "additionalCategories", m);
      }
    },
    "Remove"
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: c,
      label: "Category",
      section: "legend",
      subsection: null,
      fieldName: "additionalCategories",
      updateField: (p, m, v, g) => {
        const A = [...e.legend.additionalCategories];
        A[s] = g, t(p, m, v, A);
      }
    }
  ))), /* @__PURE__ */ n.createElement(
    "button",
    {
      className: "btn btn-primary full-width",
      onClick: (c) => {
        c.preventDefault();
        const s = [...e.legend.additionalCategories || []];
        s.push(""), t("legend", null, "additionalCategories", s);
      }
    },
    "Add Category"
  )));
}, dm = "-Select-", iw = ({ config: e, updateField: t, isDashboard: r, columns: a }) => {
  var p, m, v, g, A, k;
  const i = ((p = e.dataKey) == null ? void 0 : p.includes("http://")) || ((m = e == null ? void 0 : e.dataKey) == null ? void 0 : m.includes("https://")), o = ie.useMemo(() => Object.keys(e.columns).map((E) => [E, e.columns[E].dataTable]).filter(([E, T]) => !T).map(([E]) => E), [e.columns]), d = ie.useMemo(() => {
    const E = e.data.flatMap(Object.keys);
    return jt.uniq(E).filter((b) => !0);
  }, [e.data]), c = (E) => {
    E === dm && (E = void 0), t("table", null, "groupBy", E);
  }, s = (E, T, b, y) => {
    const N = jt.cloneDeep(e.columns), C = [];
    for (let P in N) {
      const O = N[P];
      C.push(O.name), y.includes(O.name) ? N[P].dataTable = !1 : N[P].dataTable = !0;
    }
    y.forEach((P) => {
      C.includes(P) || (N[P] = { name: P, dataTable: !1 });
    }), t(null, null, "columns", N);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.label,
      updateField: t,
      section: "table",
      fieldName: "label",
      id: "tableLabel",
      label: "Data Table Title",
      placeholder: "Data Table",
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Label is required for Data Table for 508 Compliance")))
    }
  ), e.type !== "table" && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: e.table.show,
      fieldName: "show",
      label: "Show Data Table",
      section: "table",
      updateField: t,
      className: "column-heading",
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
        tt,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Hiding the data table may affect accessibility. An alternate form of accessing visualization data is a 508 requirement.")))
    }
  ), e.visualizationType !== "Box Plot" && e.type !== "table" && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: e.table.showVertical,
      fieldName: "showVertical",
      label: "Show Vertical Data",
      section: "table",
      updateField: t,
      className: "column-heading",
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
        tt,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "This will draw the data table with vertical data instead of horizontal.")))
    }
  ), e.type !== "table" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.indexLabel,
      section: "table",
      fieldName: "indexLabel",
      label: "Index Column Header",
      updateField: t,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "To comply with 508 standards, if the first column in the data table has no header, enter a brief one here.")))
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.caption,
      updateField: t,
      section: "table",
      type: "textarea",
      fieldName: "caption",
      label: "Screen Reader Description",
      placeholder: " Data table",
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter a description of the data table to be read by screen readers.")))
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      value: e.table.limitHeight,
      section: "table",
      fieldName: "limitHeight",
      label: " Limit Table Height",
      updateField: t
    }
  ), e.table.limitHeight && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: e.table.height,
      section: "table",
      fieldName: "height",
      label: "Data Table Height",
      type: "number",
      min: 0,
      max: 500,
      placeholder: "Height(px)",
      updateField: t
    }
  ), (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement(
    yf,
    {
      key: o.join("") + "excluded",
      options: a.map((E) => ({ label: E, value: E })),
      selected: o,
      fieldName: "dataTable",
      label: "Exclude Columns",
      section: "columns",
      updateField: s
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      value: e.table.collapsible,
      fieldName: "collapsible",
      label: " Collapsible",
      section: "table",
      updateField: t
    }
  ), e.table.collapsible !== !1 && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: e.table.expanded,
      fieldName: "expanded",
      label: " Expanded by Default",
      section: "table",
      updateField: t
    }
  ), r && e.type !== "table" && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: e.table.showDataTableLink,
      fieldName: "showDataTableLink",
      label: "Show Data Table Name & Link",
      section: "table",
      updateField: t
    }
  ), i && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: e.table.showDownloadUrl,
      fieldName: "showDownloadUrl",
      label: "Show URL to Automatically Updated Data",
      section: "table",
      updateField: t
    }
  ), e.type !== "table" && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: e.table.showDownloadImgButton,
      fieldName: "showDownloadImgButton",
      label: "Display Image Button",
      section: "table",
      updateField: t
    }
  ), e.type !== "table" && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: e.table.showDownloadLinkBelow,
      fieldName: "showDownloadLinkBelow",
      label: "Show Download Link Below Table",
      section: "table",
      updateField: t
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Table Cell Min Width"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      value: e.table.cellMinWidth ? e.table.cellMinWidth : 0,
      onChange: (E) => t("table", null, "cellMinWidth", E.target.value)
    }
  )), (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement(
    vt,
    {
      value: e.table.groupBy,
      fieldName: "groupBy",
      section: "table",
      label: "Group By",
      updateField: (E, T, b, y) => c(y),
      initial: dm,
      options: d.filter(
        (E) => {
          var T, b;
          return E !== ((T = e.table.pivot) == null ? void 0 : T.columnName) && !((b = e.table.pivot) != null && b.valueColumns.includes(E));
        }
      ),
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Choose a column to use for grouping data rows. The selected column will not be shown in the data table. You will only be able to choose a column which does not have a column configuration.")))
    }
  ), /* @__PURE__ */ n.createElement(
    vt,
    {
      label: "Pivot Column",
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select a Column whos data values will be pivoted to Column Values."))),
      value: (v = e.table.pivot) == null ? void 0 : v.columnName,
      options: d.filter(
        (E) => {
          var T;
          return E !== e.table.groupBy && !((T = e.table.pivot) != null && T.valueColumns.includes(E));
        }
      ),
      initial: "-Select-",
      section: "table",
      subsection: "pivot",
      fieldName: "columnName",
      updateField: t
    }
  ), ((g = e.table.pivot) == null ? void 0 : g.columnName) && /* @__PURE__ */ n.createElement(
    yf,
    {
      key: (A = e.table.pivot) == null ? void 0 : A.columnName,
      options: d.filter((E) => {
        var T;
        return E !== ((T = e.table.pivot) == null ? void 0 : T.columnName) && E !== e.table.groupBy;
      }).map((E) => ({ label: E, value: E })),
      selected: (k = e.table.pivot) == null ? void 0 : k.valueColumns,
      label: "Pivot Value Column(s) ",
      section: "table",
      subsection: "pivot",
      fieldName: "valueColumns",
      updateField: t,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "The column(s) whos values will be pivoted under the column selected as the Filter.")))
    }
  ));
}, Kf = ({ orderedValues: e, handleFilterOrder: t }) => /* @__PURE__ */ n.createElement(Em, { onDragEnd: ({ source: r, destination: a }) => t(r == null ? void 0 : r.index, a == null ? void 0 : a.index) }, /* @__PURE__ */ n.createElement(Sm, { droppableId: "filter_order" }, (r) => /* @__PURE__ */ n.createElement("ul", { ...r.droppableProps, className: "sort-list", ref: r.innerRef, style: { marginTop: "1em" } }, e == null ? void 0 : e.map((a, i) => /* @__PURE__ */ n.createElement(km, { key: a, draggableId: `draggableFilter-${a}`, index: i }, (o, d) => /* @__PURE__ */ n.createElement("li", null, /* @__PURE__ */ n.createElement(
  "div",
  {
    className: d.isDragging ? "currently-dragging" : "",
    style: o.draggableProps.style,
    ref: o.innerRef,
    ...o.draggableProps,
    ...o.dragHandleProps
  },
  a
)))), r.placeholder))), ow = ({
  config: e,
  dataColumns: t,
  handleGroupingCustomOrder: r,
  handleNameChange: a,
  filterIndex: i,
  rawData: o,
  updateField: d
}) => {
  const c = e.filters[i], s = c == null ? void 0 : c.subGrouping, p = [];
  e.filters.forEach((N, C) => {
    i !== C && (p.push(N.columnName), s != null && s.columnName && p.push(s.columnName));
  });
  const m = (N, C) => {
    d("filters", i, N, C);
  }, v = (N) => {
    const C = {
      values: jt.cloneDeep(c.values),
      order: N
    }, P = vf(C).values, O = jt.cloneDeep(e.filters);
    O[i] = { ...c, values: P, order: N }, N === "cust" ? O[i].orderedValues = P : delete O[i].orderedValues, d(null, null, "filters", O);
  }, g = (N) => {
    d("filters", i, "subGrouping", N);
  }, A = (N) => {
    var K;
    const P = ((K = c.orderedValues) != null && K.length ? c.orderedValues : c.values).reduce((W, J) => {
      const j = jt.uniq(
        o.map((B) => B[c.columnName] === J ? B[N] : "").filter((B) => B !== "")
      ).sort();
      return W[J] = {
        values: j
        // add temp values when column changes
      }, W;
    }, {}), O = {
      ...s,
      columnName: N,
      valuesLookup: P
    };
    g(O);
  }, k = (N) => {
    const C = Object.keys(s.valuesLookup).reduce((O, K) => {
      const W = s.valuesLookup[K], { values: J } = vf({ values: W.values, order: N });
      return O[K] = {
        values: J
      }, N === "cust" ? O[K].orderedValues = J : delete O[K].orderedValues, O;
    }, {}), P = { ...s, order: N, valuesLookup: C };
    g(P);
  }, E = (N, C, P, O) => {
    const K = jt.cloneDeep(P), [W] = K.splice(N, 1);
    K.splice(C, 0, W);
    const J = jt.cloneDeep(s);
    J.valuesLookup[O].values = K, J.valuesLookup[O].orderedValues = K, g({ ...J, order: "cust" });
  }, T = t.filter((N) => !p.includes(N)), b = ie.useMemo(() => {
    var C;
    const N = e.filters[i];
    return !!(N.setByQueryParameter && ((C = N.subGrouping) != null && C.setByQueryParameter));
  }, [e, i]), y = (N) => {
    const C = e.filters, { checked: P } = N.target, O = P ? c.columnName : "", K = P ? s.columnName : "";
    C[i] = {
      ...e.filters[i],
      setByQueryParameter: O,
      subGrouping: { ...s, setByQueryParameter: K }
    }, d(null, null, "filters", C);
  };
  return /* @__PURE__ */ n.createElement("div", { className: "nesteddropdown-editor" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading mt-2" }, "Label"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: c.label,
      onChange: (N) => {
        m("label", N.target.value);
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("div", { className: "edit-label column-heading mt-2" }, "Filter Grouping", /* @__PURE__ */ n.createElement("span", null)), /* @__PURE__ */ n.createElement("select", { value: c.columnName, onChange: (N) => a(N.target.value) }, /* @__PURE__ */ n.createElement("option", { value: "" }, "- Select Option -"), T.map((N, C) => /* @__PURE__ */ n.createElement("option", { value: N, key: C }, N)))), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("div", { className: "edit-label column-heading mt-2" }, "Filter SubGrouping", /* @__PURE__ */ n.createElement("span", null)), /* @__PURE__ */ n.createElement(
    "select",
    {
      value: (s == null ? void 0 : s.columnName) ?? "",
      onChange: (N) => {
        A(N.target.value);
      }
    },
    /* @__PURE__ */ n.createElement("option", { value: "" }, "- Select Option -"),
    T.map((N, C) => {
      if (N !== c.columnName)
        return /* @__PURE__ */ n.createElement("option", { value: N, key: C }, N);
    })
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "checkbox",
      checked: b,
      "aria-label": "Create query parameters",
      disabled: !c.columnName || !(s != null && s.columnName),
      onChange: (N) => y(N)
    }
  ), /* @__PURE__ */ n.createElement("span", null, " Create query parameters"), b && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading mt-2" }, "Grouping: Default Value Set By Query String Parameter"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: c.setByQueryParameter,
      onChange: (N) => {
        m("setByQueryParameter", N.target.value);
      }
    }
  ), /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading mt-2" }, "SubGrouping: Default Value Set By Query String Parameter"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: s == null ? void 0 : s.setByQueryParameter,
      onChange: (N) => {
        const C = N.target.value;
        g({ ...s, setByQueryParameter: C });
      }
    }
  ))), /* @__PURE__ */ n.createElement("label", { className: "mt-2" }, /* @__PURE__ */ n.createElement("div", { className: "edit-label column-heading float-right" }, c.columnName, " "), /* @__PURE__ */ n.createElement("span", { className: "edit-filterOrder column-heading " }, "Group Order"), /* @__PURE__ */ n.createElement("select", { value: c.order, onChange: (N) => v(N.target.value) }, gf.map((N, C) => /* @__PURE__ */ n.createElement("option", { value: N.value, key: `filter-${N.label}-${C}` }, N.label))), c.order === "cust" && /* @__PURE__ */ n.createElement(Kf, { orderedValues: c.orderedValues, handleFilterOrder: r })), (s == null ? void 0 : s.columnName) && /* @__PURE__ */ n.createElement("label", { className: "mt-2" }, /* @__PURE__ */ n.createElement("span", { className: "edit-filterOrder column-heading" }, "SubGrouping Order"), /* @__PURE__ */ n.createElement("div", { className: "edit-label column-heading float-right" }, s.columnName, " "), /* @__PURE__ */ n.createElement(
    "select",
    {
      value: s.order ? s.order : "asc",
      onChange: (N) => k(N.target.value)
    },
    gf.map((N, C) => /* @__PURE__ */ n.createElement("option", { value: N.value, key: `filter-${C}` }, N.label))
  ), (s == null ? void 0 : s.order) === "cust" && c.values.map((N, C) => {
    const P = s.valuesLookup[N].orderedValues;
    return /* @__PURE__ */ n.createElement("div", { key: `group-subgroup-values-${N}-${C}` }, /* @__PURE__ */ n.createElement("span", { className: "font-weight-bold" }, N), /* @__PURE__ */ n.createElement(
      Kf,
      {
        key: `subgroup-values-${N}-${C}`,
        orderedValues: P,
        handleFilterOrder: (O, K) => {
          E(O, K, P, N);
        }
      }
    ));
  })));
}, lw = ({ config: e, updateField: t, rawData: r }) => {
  const a = ie.useState({}), i = ie.useMemo(() => jt.uniq(jt.flatten(r == null ? void 0 : r.map((g) => Object.keys(g)))), [r]), o = (g) => {
    let A = jt.cloneDeep(e.filters);
    A.splice(g, 1), t(null, null, "filters", A);
  }, d = (g, A, k) => {
    t("filters", A, g, k);
  }, c = (g, A) => {
    const k = jt.cloneDeep(e.filters), E = { ...k[g], orderedValues: k[g].values };
    E.filterStyle = A, A === "multi-select" ? E.active = Array.isArray(E.active) ? E.active : [E.active] : Array.isArray(E.active) && (E.active = E.active[0]), A === "nested-dropdown" && (E.showDropdown = !0), k[g] = E, t(null, null, "filters", k);
  }, s = (g, A) => {
    const k = jt.uniq(r.map((b) => b[A])), E = { ...jt.cloneDeep(e.filters[g]), columnName: A, values: k };
    vf(E), E.active = E.values[0];
    const T = e.filters.map((b, y) => y === g ? E : b);
    t(null, null, "filters", T);
  }, p = () => {
    const g = e.filters ? [...e.filters] : [], A = { values: [], filterStyle: "dropdown", id: Date.now() };
    g.push(A), t(null, null, "filters", g);
  }, m = (g, A, k) => {
    const E = e.filters[k], T = [...E.orderedValues || E.values], [b] = T.splice(g, 1);
    T.splice(A, 0, b);
    const y = jt.cloneDeep(e.filters), N = { ...y[k] };
    N.values = T, N.orderedValues = T, N.active = T[0], N.order = "cust", y[k] = N, t(null, null, "filters", y);
  }, v = (g) => e.filters.filter((A, k) => k !== g).map(({ label: A, columnName: k, id: E }) => ({ label: A || k, value: E }));
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.filters && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    vt,
    {
      value: e.filterBehavior,
      fieldName: "filterBehavior",
      label: "Filter Behavior",
      updateField: t,
      options: ["Apply Button", "Filter Change"],
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, 'The Apply Button option changes the visualization when the user clicks "apply". The Filter Change option immediately changes the visualization when the selection is changed.')))
    }
  ), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("ul", { className: "filters-list" }, e.filters.map((g, A) => g.type === "url" ? /* @__PURE__ */ n.createElement(n.Fragment, null) : /* @__PURE__ */ n.createElement(
    pg,
    {
      key: g.columnName,
      fieldName: g.columnName,
      fieldKey: A,
      fieldType: "Filter",
      controls: a,
      deleteField: () => o(A)
    },
    /* @__PURE__ */ n.createElement(
      vt,
      {
        value: g.filterStyle,
        fieldName: "filterStyle",
        label: "Filter Style",
        updateField: (k, E, T, b) => c(A, b),
        options: tv
      }
    ),
    g.filterStyle !== "nested-dropdown" ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      vt,
      {
        value: g.columnName,
        fieldName: "columnName",
        label: "Filter",
        updateField: (k, E, T, b) => s(A, b),
        options: i,
        initial: "- Select Option -"
      }
    ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-showDropdown column-heading" }, "Show Filter Input"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "checkbox",
        checked: g.showDropdown === void 0 ? !0 : g.showDropdown,
        onChange: (k) => {
          d("showDropdown", A, k.target.checked);
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Label"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: g.label,
        onChange: (k) => {
          d("label", A, k.target.value);
        }
      }
    )), g.filterStyle === "multi-select" && /* @__PURE__ */ n.createElement(
      Qe,
      {
        label: "Select Limit",
        value: g.selectLimit,
        updateField: t,
        section: "filters",
        subsection: A,
        fieldName: "selectLimit",
        type: "number",
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "The maximum number of items that can be selected.")))
      }
    ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Default Value Set By Query String Parameter"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: g.setByQueryParameter,
        onChange: (k) => {
          d("setByQueryParameter", A, k.target.value);
        }
      }
    )), /* @__PURE__ */ n.createElement(
      vt,
      {
        value: g.order || "asc",
        fieldName: "order",
        label: "Filter Order",
        updateField: (k, E, T, b) => d("order", A, b),
        options: gf
      }
    ), g.order === "cust" && /* @__PURE__ */ n.createElement(
      Kf,
      {
        orderedValues: g.orderedValues || g.values,
        handleFilterOrder: (k, E) => m(k, E, A)
      }
    )) : /* @__PURE__ */ n.createElement(
      ow,
      {
        config: e,
        dataColumns: i,
        filterIndex: A,
        rawData: r,
        handleGroupingCustomOrder: (k, E) => m(k, E, A),
        handleNameChange: (k) => s(A, k),
        updateField: t,
        updateFilterStyle: c
      }
    ),
    /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Filter Parents", " ", /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "A selected parent's value will be used to filter the available options of this child filter.")))), /* @__PURE__ */ n.createElement(
      yf,
      {
        fieldName: "parents",
        updateField: (k, E, T, b) => {
          d("parents", A, b);
        },
        options: v(A)
      }
    ))
  )))), !e.filters && /* @__PURE__ */ n.createElement("p", { style: { textAlign: "center" } }, "There are currently no filters."), /* @__PURE__ */ n.createElement("button", { type: "button", onClick: p, className: "btn btn-primary full-width" }, "Add Filter"));
}, Qu = (e) => /* @__PURE__ */ ie.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ ie.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), sw = ({ name: e }) => {
  var c, s, p, m, v;
  const { config: t, rawData: r, updateConfig: a } = ie.useContext(Et);
  if (t.visualizationType !== "Forest Plot")
    return;
  const i = (g) => {
    g.orientation === "horizontal" && (g.labels = !1), g.table.show === void 0 && (g.table.show = !isDashboard), g.visualizationType === "Combo" && (g.orientation = "vertical");
  }, o = (g = !0) => {
    let A = {};
    return r.forEach((k) => {
      Object.keys(k).forEach((E) => A[E] = !0);
    }), g && Object.keys(A).forEach((k) => {
      (t.series && t.series.filter((E) => E.dataKey === k).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(k)) && delete A[k];
    }), Object.keys(A);
  }, d = (g, A, k, E) => {
    if (g === "boxplot" && A === "legend") {
      a({
        ...t,
        [g]: {
          ...t[g],
          [A]: {
            ...t.boxplot[A],
            [k]: E
          }
        }
      });
      return;
    }
    if (g === "boxplot" && A === "labels") {
      a({
        ...t,
        [g]: {
          ...t[g],
          [A]: {
            ...t.boxplot[A],
            [k]: E
          }
        }
      });
      return;
    }
    if (g === "forestPlot" && A) {
      let N = {
        ...t,
        [g]: {
          ...t[g],
          [A]: {
            ...t.forestPlot[A],
            [k]: E
          }
        }
      };
      a(N);
      return;
    }
    if (g === "columns" && A !== "" && k !== "") {
      a({
        ...t,
        [g]: {
          ...t[g],
          [A]: {
            ...t[g][A],
            [k]: E
          }
        }
      });
      return;
    }
    if (g === null && A === null) {
      let N = { ...t, [k]: E };
      i(N), a(N);
      return;
    }
    const T = Array.isArray(t[g]);
    let b = T ? [...t[g], E] : { ...t[g], [k]: E };
    A !== null && (T ? (b = [...t[g]], b[A] = { ...b[A], [k]: E }) : typeof E == "string" ? b[A] = E : b = { ...t[g], [A]: { ...t[g][A], [k]: E } });
    let y = { ...t, [g]: b };
    i(y), a(y);
  };
  return /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, e, (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ n.createElement(Qu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Study Column",
      initial: "Select",
      required: !0,
      updateField: d,
      options: o(!1),
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  ), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.forestPlot.type,
      label: "Forest Plot Type",
      initial: "Select",
      required: !0,
      onChange: (g) => {
        g.target.value !== "" && g.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            type: g.target.value
          }
        }), g.target.value = "";
      },
      options: ["Linear", "Logarithmic"],
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ", /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("br", null), " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1.")))
    }
  ), /* @__PURE__ */ n.createElement(Qe, { type: "text", value: ((c = t.forestPlot) == null ? void 0 : c.title) || "", updateField: d, section: "forestPlot", fieldName: "title", label: "Plot Title" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Column Settings"), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.forestPlot.estimateField,
      label: "Point Estimate Column",
      initial: t.forestPlot.estimateField || "Select",
      required: !0,
      onChange: (g) => {
        g.target.value !== "" && g.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            estimateField: g.target.value
          }
        }), g.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.forestPlot.shape,
      label: "Point Estimate Shape",
      onChange: (g) => {
        g.target.value !== "" && g.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            shape: g.target.value
          }
        }), g.target.value = "";
      },
      options: ["text", "circle", "square"]
    }
  ), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.forestPlot.lower,
      label: "Lower CI Column",
      required: !0,
      initial: t.forestPlot.lower || "Select",
      onChange: (g) => {
        g.target.value !== "" && g.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            lower: g.target.value
          }
        }), g.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.forestPlot.upper,
      label: "Upper CI Column",
      initial: t.forestPlot.upper || "Select",
      required: !0,
      onChange: (g) => {
        g.target.value !== "" && g.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            upper: g.target.value
          }
        }), g.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Pooled Result Column", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: t.forestPlot.pooledResult.column || "",
      label: "Pooled Result Row",
      onChange: (g) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            pooledResult: {
              ...t.forestPlot.pooledResult,
              column: g.target.value
            }
          }
        }), g.target.value = "";
      }
    }
  ))), /* @__PURE__ */ n.createElement(lt, { value: ((p = (s = t.forestPlot) == null ? void 0 : s.lineOfNoEffect) == null ? void 0 : p.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: d }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Width Settings"), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left (%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffset || 0,
      onChange: (g) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffset: g.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left Mobile(%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffsetMobile || 0,
      onChange: (g) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffsetMobile: g.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right (%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffset || 0,
      onChange: (g) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffset: g.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right Mobile(%)"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffsetMobile || 0,
      onChange: (g) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffsetMobile: g.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ n.createElement(Qe, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: d, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", null, "Labels Settings"), /* @__PURE__ */ n.createElement(Qe, { type: "text", value: ((m = t.forestPlot) == null ? void 0 : m.leftLabel) || "", updateField: d, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }), /* @__PURE__ */ n.createElement(Qe, { type: "text", value: ((v = t.forestPlot) == null ? void 0 : v.rightLabel) || "", updateField: d, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("hr", null), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.forestPlot.radius.scalingColumn,
      label: "Weight Column",
      initial: "Select",
      onChange: (g) => {
        g.target.value !== "" && g.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              scalingColumn: g.target.value
            }
          }
        }), g.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Radius Minimum Size"), /* @__PURE__ */ n.createElement(
    "input",
    {
      min: 3,
      max: 6,
      value: t.forestPlot.radius.min || 3,
      onChange: (g) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              min: Number(g.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Radius Maximum Size"), /* @__PURE__ */ n.createElement(
    "input",
    {
      min: 7,
      max: 10,
      value: t.forestPlot.radius.max,
      onChange: (g) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              max: Number(g.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  ))));
}, cl = n.createContext({}), uw = (e) => {
  const { updateConfig: t, config: r, rawData: a } = ie.useContext(Et), { getColumns: i, selectComponent: o } = e, d = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], c = (s, p, m) => {
    let v = [...r.series];
    if (v[s][m] = p, m === "type" && p === "Bar" && (v[s].axis = "Left"), v[s].type === "Forecasting") {
      let g = Array.from(new Set(a.map((k) => k[v[s].dataKey]))), A = [];
      g.forEach((k) => {
        A.push({ key: k });
      }), v[s].stages = A, v[s].stageColumn = v[s].dataKey;
    }
    t({ ...r, series: v });
  };
  return /* @__PURE__ */ n.createElement(cl.Provider, { value: { updateSeries: c, supportedRightAxisTypes: d, getColumns: i, selectComponent: o } }, e.children);
}, cw = (e) => {
  const { config: t, updateConfig: r } = ie.useContext(Et), { series: a, index: i } = e;
  if (!(() => {
    let s = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart", "Bump Chart"].some((m) => m.includes(a.type)) && (s = !0), s;
  })())
    return;
  const d = (s, p) => {
    let m = [...t.series];
    m[s].lineType = p, r({ ...t, series: m });
  };
  let c = [];
  return Object.keys(al).map((s) => c.push(al[s])), /* @__PURE__ */ n.createElement(
    Ua,
    {
      initial: "Select an option",
      value: a.lineType ? a.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (s) => {
        d(i, s.target.value);
      },
      options: c
    }
  );
}, dw = (e) => {
  const { config: t } = ie.useContext(Et), { updateSeries: r } = ie.useContext(cl), { index: a, series: i } = e, o = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line" || t.visualizationType === "Bump Chart")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo", "Bump Chart"].includes(t.visualizationType))
    return /* @__PURE__ */ n.createElement(
      Ua,
      {
        initial: "Select an option",
        value: i.type,
        label: "Series Type",
        onChange: (d) => {
          r(a, d.target.value, "type");
        },
        options: o()
      }
    );
}, fw = (e) => {
  const { config: t, updateConfig: r, rawData: a } = ie.useContext(Et), { updateSeries: i, getColumns: o } = ie.useContext(cl), { index: d, series: c } = e;
  return /* @__PURE__ */ n.createElement(
    Ua,
    {
      initial: "Select an option",
      value: c.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (s) => {
        let p = [], m = new Set(a == null ? void 0 : a.map((g) => g[s.target.value]));
        m = Array.from(m), m = m.filter((g) => g !== void 0), m.forEach((g) => p.push({ key: g }));
        const v = [...t.series];
        v[d] = { ...v[d], stages: p, stageColumn: s.target.value }, r({
          ...t,
          series: v
        });
      },
      options: o(!1)
    }
  );
}, pw = (e) => {
  const { config: t, rawData: r } = ie.useContext(Et), { updateSeries: a } = ie.useContext(cl), { index: i, series: o } = e;
  if (o.type !== "Forecasting" || !r || !o.stageColumn)
    return;
  let d = new Set(r.map((c) => c[o.stageColumn]));
  return d = Array.from(d), d = d.filter((c) => c !== void 0), /* @__PURE__ */ n.createElement(
    Ua,
    {
      initial: "Select an option",
      value: o.stageItem,
      label: "Forecasting Item Column",
      onChange: (c) => {
        a(i, c.target.value, "stageItem");
      },
      options: d
    }
  );
}, hw = (e) => {
  const { config: t } = ie.useContext(Et), { updateSeries: r, supportedRightAxisTypes: a } = ie.useContext(cl), { index: i, series: o } = e;
  if (!(t.visualizationType !== "Combo" || !o) && a.includes(o.type))
    return /* @__PURE__ */ n.createElement(
      Ua,
      {
        initial: "Select an option",
        value: o.axis ? o.axis : "Left",
        label: "Series Axis",
        onChange: (d) => {
          r(i, d.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, mw = (e) => {
  var o;
  const { config: t, updateConfig: r } = ie.useContext(Et), { index: a, series: i } = e;
  if (i.type === "Forecasting" && i)
    return (o = i == null ? void 0 : i.stages) == null ? void 0 : o.map((d, c) => {
      var s, p, m, v;
      return /* @__PURE__ */ n.createElement(
        Ua,
        {
          key: `${d}--${c}`,
          initial: "Select an option",
          value: (p = (s = t.series) == null ? void 0 : s[a].stages) != null && p[c].color ? (v = (m = t.series) == null ? void 0 : m[a].stages) == null ? void 0 : v[c].color : "Select",
          label: `${d.key} Series Color`,
          onChange: (g) => {
            const A = [...t.series], k = A[a].stages;
            k[c].color = g.target.value, A[a] = { ...A[a], stages: k }, r({
              ...t,
              series: A
            });
          },
          options: Object.keys(Ju)
        }
      );
    });
}, yw = (e) => {
  var d;
  const { config: t, updateConfig: r } = ie.useContext(Et), { series: a, index: i } = e, { getColumns: o } = ie.useContext(cl);
  if (a.type === "Forecasting")
    return /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Confidence Interval Groups"), /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement(zi, { allowZeroExpanded: !0 }, (d = a == null ? void 0 : a.confidenceIntervals) == null ? void 0 : d.map((c, s) => {
      const p = c.showInTooltip ? c.showInTooltip : !1, m = (v, g, A) => {
        v.preventDefault();
        let k = [...t.series];
        k[g].confidenceIntervals[A].showInTooltip = !p, r({
          ...t,
          series: k
        });
      };
      return /* @__PURE__ */ n.createElement(Fn, { className: "series-item series-item--chart", key: `${s}` }, /* @__PURE__ */ n.createElement(Mn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(zn, { className: "accordion__button accordion__button" }, "Group ", s + 1, /* @__PURE__ */ n.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (v) => {
            v.preventDefault();
            const g = [...t.series[i].confidenceIntervals];
            g.splice(s, 1);
            const A = [...t.series];
            A[i] = { ...A[i], confidenceIntervals: [...g] }, r({
              ...t,
              series: A
            });
          }
        },
        "Remove"
      )))), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement("div", { className: "input-group" }, /* @__PURE__ */ n.createElement("label", { htmlFor: "showInTooltip" }, "Show In Tooltip"), /* @__PURE__ */ n.createElement("div", { className: "cove-input__checkbox--small", onClick: (v) => m(v, i, s) }, /* @__PURE__ */ n.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, p && /* @__PURE__ */ n.createElement(Om, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ n.createElement("input", { className: "cove-input--hidden", type: "checkbox", name: "showInTooltip", checked: p || !1, readOnly: !0 }))), /* @__PURE__ */ n.createElement(
        Ua,
        {
          initial: "Select an option",
          value: t.series[i].confidenceIntervals[s].low ? t.series[i].confidenceIntervals[s].low : "Select",
          label: "Low Confidence Interval",
          onChange: (v) => {
            const g = [...t.series[i].confidenceIntervals];
            g[s].low = v.target.value;
            const A = [...t.series];
            A[i] = { ...A[i], confidenceIntervals: g }, r({
              ...t,
              series: A
            });
          },
          options: o()
        }
      ), /* @__PURE__ */ n.createElement(
        Ua,
        {
          initial: "Select an option",
          value: t.series[i].confidenceIntervals[s].high ? t.series[i].confidenceIntervals[s].high : "Select",
          label: "High Confidence Interval",
          onChange: (v) => {
            const g = [...t.series[i].confidenceIntervals];
            g[s].high = v.target.value;
            const A = [...t.series];
            A[i] = { ...A[i], confidenceIntervals: g }, r({
              ...t,
              series: A
            });
          },
          options: o()
        }
      )));
    })), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn full-width",
        onClick: (c) => {
          c.preventDefault();
          let s = null;
          t.series[i].confidenceIntervals ? s = [...t.series[i].confidenceIntervals] : s = [];
          const p = [...t.series];
          p[i] = { ...p[i], confidenceIntervals: [...s, { high: "", low: "" }] }, r({
            ...t,
            series: p
          });
        }
      },
      "Add Confidence Interval Group"
    )));
}, gw = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = ie.useContext(Et);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const d = (c, s, p, m) => {
    let v = [...a.series], g = { ...a.runtime.seriesLabels };
    v[c].weight = s && Math.max(Number(p), Math.min(Number(m), Number(s))), g[v[c].dataKey] = v[c].weight ? v[c].weight : v[c].dataKey;
    const A = {
      ...a,
      series: v,
      runtime: {
        ...a.runtime,
        seriesLabels: g
      }
    };
    i(A);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "series-weight" }, "Line Weight"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      key: `series-weight-${r}`,
      value: t.weight ? t.weight : "",
      min: "1",
      max: "9",
      onChange: (c) => {
        d(r, c.target.value, c.target.min, c.target.max);
      }
    }
  ));
}, vw = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = ie.useContext(Et);
  if (!["Bump Chart", "Bar", "Line", "Area Chart", "Combo", "Deviation", "Paired", "Scatter", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const d = (c, s) => {
    let p = [...a.series], m = { ...a.runtime.seriesLabels };
    p[c].name = s, m[p[c].dataKey] = p[c].name ? p[c].name : p[c].dataKey;
    let v = {
      ...a,
      series: p,
      runtime: {
        ...a.runtime,
        seriesLabels: m
      }
    };
    i(v);
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "series-name" }, "Series Name"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      key: `series-name-${r}`,
      value: t.name ? t.name : "",
      onChange: (c) => {
        d(r, c.target.value);
      }
    }
  ));
}, xw = (e) => {
  const { series: t, index: r } = e, { config: a, updateConfig: i } = ie.useContext(Et);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(a.visualizationType))
    return;
  const o = (d) => {
    let c = [...a.series];
    c[d].tooltip && c[d].tooltip, c[d].tooltip = !c[d].tooltip, i({
      ...a,
      series: c
    });
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: "input-group" }, /* @__PURE__ */ n.createElement("label", { htmlFor: `series-tooltip--${r}` }, "Show In Tooltip"), /* @__PURE__ */ n.createElement("div", { className: "cove-input__checkbox--small", onClick: (d) => o(r) }, /* @__PURE__ */ n.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, t.tooltip && /* @__PURE__ */ n.createElement(Om, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ n.createElement("input", { className: "cove-input--hidden", type: "checkbox", name: `series-tooltip--${r}`, checked: t.tooltip ? t.tooltip : !1, readOnly: !0 }))));
}, bw = (e) => {
  const { config: t, updateConfig: r } = ie.useContext(Et), { series: a, index: i } = e, o = (c) => {
    let s = [...t.series], p = -1;
    for (let m = 0; m < s.length; m++)
      if (s[m].dataKey === c) {
        p = m;
        break;
      }
    if (p !== -1) {
      s.splice(p, 1);
      let m = { ...t, series: s };
      s.length === 0 && delete m.series, r(m);
    }
    t.visualizationType === "Paired Bar" && r({
      ...t,
      series: []
    });
  }, d = (c, s, p) => {
    c.preventDefault(), o(s.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ n.createElement("button", { className: "series-list__remove", onClick: (c) => d(c, a) }, "Remove");
}, hg = (e) => {
  const { config: t } = ie.useContext(Et), { series: r, getItemStyle: a, sortableItemStyles: i, chartsWithOptions: o, index: d } = e;
  return /* @__PURE__ */ n.createElement(km, { key: r.dataKey, draggableId: `draggableFilter-${r.dataKey}`, index: d }, (c, s) => /* @__PURE__ */ n.createElement("div", { key: d, className: s.isDragging ? "currently-dragging" : "", style: a(s.isDragging, c.draggableProps.style, i), ref: c.innerRef, ...c.draggableProps, ...c.dragHandleProps }, /* @__PURE__ */ n.createElement(zi, { allowZeroExpanded: !0 }, /* @__PURE__ */ n.createElement(Fn, { className: "series-item series-item--chart" }, /* @__PURE__ */ n.createElement(Mn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(zn, { className: o.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow" }, /* @__PURE__ */ n.createElement(tt, { display: "move", size: 15, style: { cursor: "default" } }), r.dataKey, /* @__PURE__ */ n.createElement(Qr.Button.Remove, { series: r, index: d }))), o.includes(t.visualizationType) && /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement(Qr.Input.Name, { series: r, index: d }), /* @__PURE__ */ n.createElement(Qr.Input.Weight, { series: r, index: d }), /* @__PURE__ */ n.createElement(Qr.Dropdown.SeriesType, { series: r, index: d }), /* @__PURE__ */ n.createElement(Qr.Dropdown.AxisPosition, { series: r, index: d }), /* @__PURE__ */ n.createElement(Qr.Dropdown.LineType, { series: r, index: d }), /* @__PURE__ */ n.createElement(Qr.Dropdown.ForecastingColor, { series: r, index: d }), /* @__PURE__ */ n.createElement(Qr.Dropdown.ConfidenceInterval, { series: r, index: d }), /* @__PURE__ */ n.createElement(Qr.Checkbox.DisplayInTooltip, { series: r, index: d }))))));
}, Ew = (e) => {
  const { series: t, getItemStyle: r, sortableItemStyles: a, chartsWithOptions: i } = e;
  return t.map((o, d) => /* @__PURE__ */ n.createElement(hg, { getItemStyle: r, sortableItemStyles: a, chartsWithOptions: i, series: o, index: d, key: `series-list-${d}` }));
}, Qr = {
  Wrapper: uw,
  Dropdown: {
    SeriesType: dw,
    AxisPosition: hw,
    ConfidenceInterval: yw,
    LineType: cw,
    ForecastingStage: fw,
    ForecastingColumn: pw,
    ForecastingColor: mw
  },
  Input: {
    Name: vw,
    Weight: gw
  },
  Checkbox: {
    DisplayInTooltip: xw
  },
  Button: {
    Remove: bw
  },
  Item: hg,
  List: Ew
}, Sw = ie.memo(({ config: e, updateConfig: t }) => {
  let r = (s, p, m) => {
    let v = [];
    e.regions && (v = [...e.regions]), v[m][s] = p, t({ ...e, regions: v });
  }, a = (s, p, m, v, g) => r(m, v, g), i = (s) => {
    let p = [];
    e.regions && (p = [...e.regions]), p.splice(s, 1), t({ ...e, regions: p });
  }, o = () => {
    let s = [];
    e.regions && (s = [...e.regions]), s.push({}), t({ ...e, regions: s });
  };
  const d = ["Fixed", "Previous Days"], c = ["Last Date", "Fixed"];
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.regions && e.regions.map(({ label: s, color: p, from: m, to: v, background: g, range: A = "Custom" }, k) => {
    var E;
    return /* @__PURE__ */ n.createElement("div", { className: "edit-block", key: `region-${k}` }, /* @__PURE__ */ n.createElement(
      "button",
      {
        type: "button",
        className: "btn btn-danger remove-column",
        onClick: (T) => {
          T.preventDefault(), i(k);
        }
      },
      "Remove"
    ), /* @__PURE__ */ n.createElement(Qe, { value: s, label: "Region Label", fieldName: "label", i: k, updateField: a }), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: p,
        label: "Text Color",
        fieldName: "color",
        updateField: (T, b, y, N) => r(y, N, k)
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: g,
        label: "Background",
        fieldName: "background",
        updateField: (T, b, y, N) => r(y, N, k)
      }
    )), /* @__PURE__ */ n.createElement(
      vt,
      {
        value: e.regions[k].fromType ?? "Fixed",
        label: "Minimum Region Type",
        initial: "Select",
        required: !0,
        onChange: (T) => {
          if (T.target.value !== "" && T.target.value !== "Select") {
            const b = [...e.regions];
            b[k].fromType = T.target.value, t({
              ...e,
              regions: b
            });
          }
          T.target.value = "";
        },
        options: d
      }
    ), (e.regions[k].fromType === "Fixed" || e.regions[k].fromType === "Previous Days" || !e.regions[k].fromType) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: m,
        label: e.regions[k].fromType === "Fixed" || !((E = e.regions[k]) != null && E.fromType) ? "From Value" : "Previous Number of Days",
        fieldName: "from",
        updateField: (T, b, y, N) => r(y, N, k),
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value.")))
      }
    )), /* @__PURE__ */ n.createElement(
      vt,
      {
        value: e.regions[k].toType ?? "Fixed",
        label: "Maximum Region Type",
        initial: "Select",
        required: !0,
        onChange: (T) => {
          if (T.target.value !== "" && T.target.value !== "Select") {
            const b = [...e.regions];
            b[k].toType = T.target.value, t({
              ...e,
              regions: b
            });
          }
          T.target.value = "";
        },
        options: c
      }
    ), (e.regions[k].toType === "Fixed" || !e.regions[k].toType) && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: v,
        label: "To Value",
        fieldName: "to",
        updateField: (T, b, y, N) => r(y, N, k)
      }
    ));
  }), !e.regions && /* @__PURE__ */ n.createElement("p", { style: { textAlign: "center" } }, "There are currently no regions."), /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-primary full-width",
      onClick: (s) => {
        s.preventDefault(), o();
      }
    },
    "Add Region"
  ));
}), kw = ({ name: e }) => {
  const { visSupportsRegions: t } = Ms(), { config: r, updateConfig: a } = ie.useContext(Et);
  return t() ? /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, e)), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement(Sw, { config: r, updateConfig: a }))) : null;
}, Ep = ie.createContext(null), Sp = () => {
  const e = ie.useContext(Ep);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, ww = (e) => {
  const { config: t } = ie.useContext(Et), { updateField: r } = Sp(), {
    enabledChartTypes: a,
    visHasNumbersOnBars: i,
    visHasaAdditionalLabelsOnBars: o,
    visHasLabelOnData: d,
    visSupportsChartHeight: c,
    visSupportsMobileChartHeight: s,
    visSupportsSuperTitle: p,
    visSupportsFootnotes: m
  } = Ms(), { visualizationType: v, visualizationSubType: g, barStyle: A } = t, k = () => (v === "Bar" || v === "Deviation Bar") && g !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ n.createElement(Fn, null, " ", /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, "General")), /* @__PURE__ */ n.createElement(Bn, null, (t == null ? void 0 : t.visualizationType) !== "Sankey" && /* @__PURE__ */ n.createElement(
    vt,
    {
      value: v,
      fieldName: "visualizationType",
      label: "Chart Type",
      updateField: r,
      options: a
    }
  ), c() && t.orientation === "vertical" && /* @__PURE__ */ n.createElement("div", { className: s() ? "two-col-inputs" : "" }, /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "number",
      value: t.heights.vertical,
      section: "heights",
      fieldName: "vertical",
      label: "Chart Height",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, "", /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "For some visualization types, such as the Sankey diagram, it may be necessary to adjust the chart height for optimal display.")))
    }
  ), s() && t.orientation === "vertical" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "number",
      value: t.heights.mobileVertical,
      section: "heights",
      fieldName: "mobileVertical",
      label: "Mobile Height",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "If the chart height is not optimized for mobile, you can adjust the height for better display. Not setting a value will default to the chart height.")))
    }
  )), (v === "Bar" || v === "Combo" || v === "Area Chart") && /* @__PURE__ */ n.createElement(
    vt,
    {
      value: g || "Regular",
      fieldName: "visualizationSubType",
      label: "Chart Subtype",
      updateField: r,
      options: ["regular", "stacked"]
    }
  ), v === "Area Chart" && g === "stacked" && /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.stackedAreaChartLineType || "Linear",
      fieldName: "stackedAreaChartLineType",
      label: "Stacked Area Chart Line Type",
      updateField: r,
      options: Object.keys(al)
    }
  ), v === "Bar" && /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.orientation || "vertical",
      fieldName: "orientation",
      label: "Orientation",
      updateField: r,
      options: ["vertical", "horizontal"]
    }
  ), v === "Deviation Bar" && /* @__PURE__ */ n.createElement(vt, { label: "Orientation", options: ["horizontal"] }), (v === "Bar" || v === "Deviation Bar") && /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.isLollipopChart ? "lollipop" : A || "flat",
      fieldName: "barStyle",
      label: "bar style",
      updateField: r,
      options: k(),
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Consider using the 'Flat' bar style when presenting data that includes '0' values.")))
    }
  ), (v === "Bar" || v === "Deviation Bar") && A === "rounded" && /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.tipRounding || "top",
      fieldName: "tipRounding",
      label: "tip rounding",
      updateField: r,
      options: ["top", "full"]
    }
  ), (v === "Bar" || v === "Deviation Bar") && A === "rounded" && /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.roundingStyle || "standard",
      fieldName: "roundingStyle",
      label: "rounding style",
      updateField: r,
      options: ["standard", "shallow", "finger"]
    }
  ), v === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.yAxis.labelPlacement || "Below Bar",
      section: "yAxis",
      fieldName: "labelPlacement",
      label: "Label Placement",
      updateField: r,
      options: ["Below Bar", "On Date/Category Axis"]
    }
  ), i() ? /* @__PURE__ */ n.createElement(
    lt,
    {
      value: t.yAxis.displayNumbersOnBar,
      section: "yAxis",
      fieldName: "displayNumbersOnBar",
      label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar",
      updateField: r
    }
  ) : d() && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: t.labels,
      fieldName: "labels",
      label: "Display label on data",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will ", /* @__PURE__ */ n.createElement("i", null, " not "), ' hide the display of "zero value", "suppressed data", or "missing data" indicators on the chart (if applicable).')))
    }
  ), o() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    lt,
    {
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Selecting this option will display a thin line slightly above the Date/Category Axis to indicate "zero value" where zero values are indicated in the Data Series.'))),
      value: t.general.showZeroValueData,
      section: "general",
      fieldName: "showZeroValueData",
      label: 'Display "Zero Data" Label',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, t.visualizationSubType === "stacked" && /* @__PURE__ */ n.createElement("p", null, "We do not recommend using stacked vertical/horizontal bar charts for missing data. If you choose to proceed, selecting this option will display 'N/A' in the tooltip hover and data table (e.g. nothing will display in chart)."), t.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("p", null, "Selecting this option will display 'N/A' on the Date/Category Axis, in the tooltip hover, and in the data table to indicate missing or undefined data values."))),
      value: t.general.showMissingDataLabel,
      section: "general",
      fieldName: "showMissingDataLabel",
      label: 'Display "Missing Data" Label',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      display: t.visualizationType === "Bar" || t.visualizationType === "Combo",
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting 'Remove Null Values' will hide the 'N/A' (no data indicator) when you hover over the chart."))),
      value: t.general.hideNullValue,
      section: "general",
      fieldName: "hideNullValue",
      label: 'Remove "Null" Values From Hover',
      updateField: r
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, t.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("p", null, "Selecting this option will show the ", /* @__PURE__ */ n.createElement("i", null, "suppression indicator "), " on the Date/Category axis, within tooltips, and in the data table where suppressed data values appear in the Data Series."), t.visualizationSubType === "stacked" && /* @__PURE__ */ n.createElement("p", null, "We do not recommend using stacked vertical/horizontal bar charts for suppressed data. If you choose to proceed, selecting this option will display the 'suppressed data symbol' in the tooltip hover and data table (e.g., nothing will display in the chart)."))),
      value: t.general.showSuppressedSymbol,
      section: "general",
      fieldName: "showSuppressedSymbol",
      label: 'Display "suppressed data" label',
      updateField: r
    }
  )), v === "Pie" && /* @__PURE__ */ n.createElement(vt, { fieldName: "pieType", label: "Pie Chart Type", updateField: r, options: ["Regular", "Donut"] }), v === "Line" && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: t.allowLineToBarGraph,
      fieldName: "allowLineToBarGraph",
      label: "Convert to Bar Graph",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Switch to bar graph when less than 3 data points available.")))
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.title || "Chart Title",
      fieldName: "title",
      id: "title",
      label: "Title",
      placeholder: "Chart Title",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Title is required to set the name of the download file but can be hidden using the option below.")))
    }
  ), /* @__PURE__ */ n.createElement(lt, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: r }), p() && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.superTitle,
      updateField: r,
      fieldName: "superTitle",
      label: "Super Title",
      placeholder: "Super Title",
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Super Title")))
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "textarea",
      value: t.introText,
      updateField: r,
      fieldName: "introText",
      label: "Message",
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Intro Text")))
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "textarea",
      value: t.description,
      fieldName: "description",
      label: "Subtext/Citation",
      updateField: r,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub.")))
    }
  ), m() && /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "textarea",
      value: t.footnotes,
      updateField: r,
      fieldName: "footnotes",
      label: "Footnotes",
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data.")))
    }
  )));
}, Tw = (e) => {
  const { config: t } = ie.useContext(Et), { boxplot: r } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: a } = Sp();
  return /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, e.name)), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement("h4", { style: { fontSize: "18px" } }, "Labels for 5-Number Summary"), /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "text",
      value: r.labels.maximum,
      fieldName: "maximum",
      section: "boxplot",
      subsection: "labels",
      label: "Maximum",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Highest value, excluding outliers")))
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "text",
      value: r.labels.q3,
      fieldName: "q3",
      section: "boxplot",
      subsection: "labels",
      label: "Upper Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Represented by top line of box. 25% of data are higher.")))
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "text",
      value: r.labels.median,
      fieldName: "median",
      section: "boxplot",
      subsection: "labels",
      label: "Median",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Middle data point. Half of data are higher value.")))
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "text",
      value: r.labels.q1,
      fieldName: "q1",
      section: "boxplot",
      subsection: "labels",
      label: "Lower Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Represented by bottom line of box. 25% of data are lower.")))
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "text",
      value: r.labels.minimum,
      fieldName: "minimum",
      section: "boxplot",
      subsection: "labels",
      label: "Minimum",
      updateField: a,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Lowest value, excluding outliers")))
    }
  ), /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement("h4", { style: { fontSize: "18px" } }, "Labels for Additional Measures"), /* @__PURE__ */ n.createElement(Qe, { type: "text", value: r.labels.iqr, fieldName: "iqr", section: "boxplot", subsection: "labels", label: "Interquartile Range", updateField: a }), /* @__PURE__ */ n.createElement(Qe, { type: "text", value: r.labels.total, fieldName: "total", section: "boxplot", subsection: "labels", label: "Total", updateField: a }), /* @__PURE__ */ n.createElement(Qe, { type: "text", value: r.labels.mean, fieldName: "mean", section: "boxplot", subsection: "labels", label: "Mean", updateField: a }), /* @__PURE__ */ n.createElement(Qe, { type: "text", value: r.labels.outliers, fieldName: "outliers", section: "boxplot", subsection: "labels", label: "Outliers", updateField: a }), /* @__PURE__ */ n.createElement(Qe, { type: "text", value: r.labels.values, fieldName: "values", section: "boxplot", subsection: "labels", label: "Values", updateField: a })));
}, Cw = (e, t) => {
  let r = [], a = [], i = [];
  const o = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const d = e.twoColor.isPaletteReversed;
    r = Object.keys(ks).filter(
      (c) => d ? c.endsWith("reverse") : !c.endsWith("reverse")
    );
  } else {
    const d = [], c = [];
    for (const s in pr) {
      const p = s.startsWith("sequential"), m = s.startsWith("qualitative"), v = s.startsWith("colorblindsafe"), g = s.endsWith("reverse");
      p && (!e.isPaletteReversed && !g || e.isPaletteReversed && g) && d.push(s), m && (!e.isPaletteReversed && !g || e.isPaletteReversed && g) && c.push(s), v && (!e.isPaletteReversed && !g || e.isPaletteReversed && g) && o.push(s);
    }
    a = d, i = c;
  }
  return ie.useEffect(() => {
    let d = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (d = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (d = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: d } });
  }, [e.twoColor.isPaletteReversed]), ie.useEffect(() => {
    let d = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (d = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (d = e.palette.slice(0, -7)), t({ ...e, palette: d });
  }, [e.isPaletteReversed]), { twoColorPalettes: r, sequential: a, nonSequential: i, accessibleColors: o };
}, Aw = (e) => {
  var J;
  const { config: t, updateConfig: r, colorPalettes: a, twoColorPalette: i } = ie.useContext(Et), { visual: o } = t, { setLollipopShape: d, updateField: c } = Sp(), {
    visHasBarBorders: s,
    visCanAnimate: p,
    visSupportsNonSequentialPallete: m,
    headerColors: v,
    visSupportsTooltipOpacity: g,
    visSupportsTooltipLines: A,
    visSupportsBarSpace: k,
    visSupportsBarThickness: E,
    visHasDataCutoff: T,
    visSupportsSequentialPallete: b,
    visSupportsReverseColorPalette: y,
    visHasSingleSeriesTooltip: N
  } = Ms(), { twoColorPalettes: C, sequential: P, nonSequential: O, accessibleColors: K } = Cw(t, r), W = (j, B) => {
    if (console.log("value", B), j === "storyNodeFontColor") {
      r({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: B
        }
      });
      return;
    } else
      r({
        ...t,
        sankey: {
          ...t.sankey,
          [j]: {
            ...t.sankey[j],
            default: B
          }
        }
      });
  };
  return /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, "Visual")), /* @__PURE__ */ n.createElement(Bn, null, (t.barStyle === "lollipop" || t.isLollipopChart) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", { className: "header" }, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Lollipop Shape"), /* @__PURE__ */ n.createElement(
    "div",
    {
      onChange: (j) => {
        d(j.target.value);
      }
    },
    /* @__PURE__ */ n.createElement("label", { className: "radio-label" }, /* @__PURE__ */ n.createElement("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }), "Circle"),
    /* @__PURE__ */ n.createElement("label", { className: "radio-label" }, /* @__PURE__ */ n.createElement("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }), "Square")
  )), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone",
      fieldName: "lollipopColorStyle",
      label: "Lollipop Color Style",
      updateField: c,
      options: ["regular", "two-tone"]
    }
  ), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.lollipopSize ? t.lollipopSize : "small",
      fieldName: "lollipopSize",
      label: "Lollipop Size",
      updateField: c,
      options: ["small", "medium", "large"]
    }
  )), t.visualizationType === "Box Plot" && /* @__PURE__ */ n.createElement("fieldset", { className: "fieldset fieldset--boxplot" }, /* @__PURE__ */ n.createElement("legend", { className: "" }, "Box Plot Settings"), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.boxplot.borders,
      fieldName: "borders",
      section: "boxplot",
      label: "Box Plot Borders",
      updateField: c,
      options: ["true", "false"]
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      value: t.boxplot.plotOutlierValues,
      fieldName: "plotOutlierValues",
      section: "boxplot",
      label: "Plot Outliers",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      value: t.boxplot.plotNonOutlierValues,
      fieldName: "plotNonOutlierValues",
      section: "boxplot",
      label: "Plot non-outlier values",
      updateField: c
    }
  )), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.fontSize,
      fieldName: "fontSize",
      label: "Font Size",
      updateField: c,
      options: ["small", "medium", "large"]
    }
  ), s() && /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.barHasBorder,
      fieldName: "barHasBorder",
      label: "Bar Borders",
      updateField: c,
      options: ["true", "false"]
    }
  ), p() && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: t.animate,
      fieldName: "animate",
      label: "Animate Visualization",
      updateField: c
    }
  ), (((J = t.series) == null ? void 0 : J.some(
    (j) => j.type === "Line" || j.type === "dashed-lg" || j.type === "dashed-sm" || j.type === "dashed-md"
  )) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.lineDatapointStyle,
      fieldName: "lineDatapointStyle",
      label: "Line Datapoint Style",
      updateField: c,
      options: ["hidden", "hover", "always show"]
    }
  ), /* @__PURE__ */ n.createElement(
    vt,
    {
      value: t.lineDatapointColor,
      fieldName: "lineDatapointColor",
      label: "Line Datapoint Color",
      updateField: c,
      options: ["Same as Line", "Lighter than Line"]
    }
  )), /* @__PURE__ */ n.createElement("label", { className: "header" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Header Theme"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, v.map((j) => /* @__PURE__ */ n.createElement(
    "button",
    {
      title: j,
      key: j,
      onClick: (B) => {
        B.preventDefault(), r({ ...t, theme: j });
      },
      className: t.theme === j ? "selected " + j : j
    }
  )))), (m() || m()) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Chart Color Palette")), y() && /* @__PURE__ */ n.createElement(
    Op,
    {
      fieldName: "isPaletteReversed",
      size: "small",
      label: "Use selected palette in reverse order",
      updateField: c,
      value: t.isPaletteReversed
    }
  ), b() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", null, "Sequential"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, P.map((j) => {
    const B = {
      backgroundColor: a[j][2]
    }, Z = {
      backgroundColor: a[j][3]
    }, te = {
      backgroundColor: a[j][5]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: j,
        key: j,
        onClick: (V) => {
          V.preventDefault(), r({ ...t, palette: j });
        },
        className: t.palette === j ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: B }),
      /* @__PURE__ */ n.createElement("span", { style: Z }),
      /* @__PURE__ */ n.createElement("span", { style: te })
    );
  }))), m() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", null, "Non-Sequential"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, O.map((j) => {
    const B = {
      backgroundColor: a[j][2]
    }, Z = {
      backgroundColor: a[j][4]
    }, te = {
      backgroundColor: a[j][6]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: j,
        key: j,
        onClick: (V) => {
          V.preventDefault(), r({ ...t, palette: j });
        },
        className: t.palette === j ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: B }),
      /* @__PURE__ */ n.createElement("span", { style: Z }),
      /* @__PURE__ */ n.createElement("span", { style: te })
    );
  })), /* @__PURE__ */ n.createElement("span", null, "Colorblind Safe"), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, K.map((j) => {
    const B = {
      backgroundColor: a[j][2]
    }, Z = {
      backgroundColor: a[j][3]
    }, te = {
      backgroundColor: a[j][5]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: j,
        key: j,
        onClick: (V) => {
          V.preventDefault(), r({ ...t, palette: j });
        },
        className: t.palette === j ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { style: B }),
      /* @__PURE__ */ n.createElement("span", { style: Z }),
      /* @__PURE__ */ n.createElement("span", { style: te })
    );
  })))), t.visualizationType === "Sankey" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.nodeColor.default,
      id: "storyNodeColor",
      name: "storyNodeColor",
      onChange: (j) => W("nodeColor", j.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "storyNodeColor" }, "Story Node Color")), /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.storyNodeFontColor || "red",
      id: "storyNodeFontColor",
      name: "storyNodeFontColor",
      onChange: (j) => W("storyNodeFontColor", j.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "storyNodeFontColor" }, "Story Node Font Color")), /* @__PURE__ */ n.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.linkColor.default,
      id: "linkColor",
      name: "linkColor",
      onChange: (j) => W("linkColor", j.target.value)
    }
  ), /* @__PURE__ */ n.createElement("label", { htmlFor: "linkColor" }, "Link Color"))), (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Op,
    {
      section: "twoColor",
      fieldName: "isPaletteReversed",
      size: "small",
      label: "Use selected palette in reverse order",
      updateField: c,
      value: t.twoColor.isPaletteReversed
    }
  ), /* @__PURE__ */ n.createElement("ul", { className: "color-palette" }, C.map((j) => {
    const B = {
      backgroundColor: i[j][0]
    }, Z = {
      backgroundColor: i[j][1]
    };
    return /* @__PURE__ */ n.createElement(
      "button",
      {
        title: j,
        key: j,
        onClick: (te) => {
          te.preventDefault(), r({ ...t, twoColor: { ...t.twoColor, palette: j } });
        },
        className: t.twoColor.palette === j ? "selected" : ""
      },
      /* @__PURE__ */ n.createElement("span", { className: "two-color", style: B }),
      /* @__PURE__ */ n.createElement("span", { className: "two-color", style: Z })
    );
  }))), T() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.dataCutoff,
      type: "number",
      fieldName: "dataCutoff",
      className: "number-narrow",
      label: "Data Cutoff",
      updateField: c,
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.')))
    }
  )), E() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "number",
      value: t.barHeight || "25",
      fieldName: "barHeight",
      label: " Bar Thickness",
      updateField: c,
      min: 15
    }
  ), (t.visualizationType === "Bar" && t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: t.barThickness,
      type: "number",
      fieldName: "barThickness",
      label: "Bar Thickness",
      updateField: c
    }
  ), k() && /* @__PURE__ */ n.createElement(
    Qe,
    {
      type: "number",
      value: t.barSpace || "15",
      fieldName: "barSpace",
      label: "Bar Space",
      updateField: c,
      min: 0
    }
  ), (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: t.topAxis.hasLine,
      section: "topAxis",
      fieldName: "hasLine",
      label: "Add Top Axis Line",
      updateField: c
    }
  ), t.visualizationType === "Spark Line" && /* @__PURE__ */ n.createElement("div", { className: "cove-accordion__panel-section checkbox-group" }, /* @__PURE__ */ n.createElement(
    lt,
    {
      value: o == null ? void 0 : o.border,
      section: "visual",
      fieldName: "border",
      label: "Show Border",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      value: o == null ? void 0 : o.borderColorTheme,
      section: "visual",
      fieldName: "borderColorTheme",
      label: "Use Border Color Theme",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      value: o == null ? void 0 : o.accent,
      section: "visual",
      fieldName: "accent",
      label: "Use Accent Style",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      value: o == null ? void 0 : o.background,
      section: "visual",
      fieldName: "background",
      label: "Use Theme Background Color",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      value: o == null ? void 0 : o.hideBackgroundColor,
      section: "visual",
      fieldName: "hideBackgroundColor",
      label: "Hide Background Color",
      updateField: c
    }
  )), (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: t.showLineSeriesLabels,
      fieldName: "showLineSeriesLabels",
      label: "Append Series Name to End of Line Charts",
      updateField: c
    }
  ), (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: t.colorMatchLineSeriesLabels,
      fieldName: "colorMatchLineSeriesLabels",
      label: "Match Series Color to Name at End of Line Charts",
      updateField: c
    }
  ), A() && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
    lt,
    {
      value: o.verticalHoverLine,
      fieldName: "verticalHoverLine",
      section: "visual",
      label: "Vertical Hover Line",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement(
    lt,
    {
      value: o.horizontalHoverLine,
      fieldName: "horizontalHoverLine",
      section: "visual",
      label: "Horizontal Hover Line",
      updateField: c
    }
  )), g() && /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Tooltip Opacity"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "number",
      value: t.tooltips.opacity ? t.tooltips.opacity : 100,
      onChange: (j) => r({
        ...t,
        tooltips: {
          ...t.tooltips,
          opacity: j.target.value
        }
      })
    }
  )), N() && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: t.tooltips.singleSeries,
      fieldName: "singleSeries",
      section: "tooltips",
      label: "SHOW HOVER FOR SINGLE DATA SERIES",
      updateField: c
    }
  ), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "No Data Message"), /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      value: t.chartMessage.noData ? t.chartMessage.noData : "",
      onChange: (j) => r({
        ...t,
        chartMessage: {
          ...t.chartMessage,
          noData: j.target.value
        }
      })
    }
  ))));
}, Lw = () => {
  var c, s, p, m, v;
  const { config: e, updateConfig: t } = ie.useContext(Et), r = (c = e.data) == null ? void 0 : c[0], { updateField: a } = ie.useContext(Ep);
  if (e.visualizationType !== "Sankey")
    return;
  const i = (g, A, k) => {
    let E = [];
    r != null && r.storyNodeText && (E = [...r == null ? void 0 : r.storyNodeText]), E[k][g] = A, t({
      ...e,
      sankey: {
        ...e.sankey,
        data: {
          ...e.sankey.data,
          storyNodeText: E
        }
      }
    });
  }, o = () => {
    const g = r;
    g.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), t({
      ...e,
      sankey: {
        ...e.sankey,
        data: [{ ...g }]
      }
    });
  }, d = (g) => {
    const A = r;
    A.storyNodeText.splice(g, 1), t({ ...e, sankey: { ...e.sankey, data: { ...A } } });
  };
  return /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, "Sankey Settings")), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement("p", null, "Node stories can provide additional details to support public health messaging. COVE can display a maximum of 3 node stories."), (r == null ? void 0 : r.storyNodeText) && (r == null ? void 0 : r.storyNodeText.map(({ StoryNode: g, segmentTextBefore: A, segmentTextAfter: k }, E) => /* @__PURE__ */ n.createElement(
    "div",
    {
      key: E,
      style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" }
    },
    /* @__PURE__ */ n.createElement("label", null, "Story Node Text", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: g,
        fieldName: "StoryNode",
        label: "StoryNode",
        onChange: (T) => i("StoryNode", T.target.value, E)
      }
    )),
    /* @__PURE__ */ n.createElement("label", null, "Story Text Before", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: A,
        fieldName: "segmentTextBefore",
        label: "Segment Text Before",
        onChange: (T) => i("segmentTextBefore", T.target.value, E)
      }
    )),
    /* @__PURE__ */ n.createElement("label", null, "Story Text After", /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: k,
        fieldName: "segmentTextAfter",
        label: "Segment Text After",
        onChange: (T) => i("segmentTextAfter", T.target.value, E)
      }
    )),
    /* @__PURE__ */ n.createElement(ws, { onClick: (T) => d(E), className: "btn", style: { background: "tomato" } }, "Remove Story Node")
  ))), ((s = r == null ? void 0 : r.storyNodeText) == null ? void 0 : s.length) < 3 && /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "btn full-width",
      onClick: (g) => {
        g.preventDefault(), o();
      }
    },
    "Add StoryNode"
  ), ((v = (m = (p = e.data) == null ? void 0 : p[0]) == null ? void 0 : m.tooltips) == null ? void 0 : v.length) > 0 && /* @__PURE__ */ n.createElement(
    lt,
    {
      value: e.enableTooltips,
      fieldName: "enableTooltips",
      label: "Enable Tooltips",
      updateField: a
    }
  )));
};
const Pw = (e) => {
  var c, s, p;
  const { updateConfig: t, config: r, svgRef: a } = ie.useContext(Et), i = (m, v, g) => {
    var T;
    const A = (T = document.querySelector(".chart-container  > svg")) == null ? void 0 : T.getBoundingClientRect(), k = [A == null ? void 0 : A.width, A == null ? void 0 : A.height], E = [...r == null ? void 0 : r.annotations];
    E[g][v] = m, E[g].savedDimensions = k, t({
      ...r,
      annotations: E
    });
  }, o = () => {
    var A, k, E, T, b, y, N, C, P, O;
    const m = [
      ((E = (k = (A = a == null ? void 0 : a.current) == null ? void 0 : A.width) == null ? void 0 : k.baseVal) == null ? void 0 : E.value) || ((T = a == null ? void 0 : a.current) == null ? void 0 : T.width),
      ((N = (y = (b = a == null ? void 0 : a.current) == null ? void 0 : b.height) == null ? void 0 : y.baseVal) == null ? void 0 : N.value) || ((C = a == null ? void 0 : a.current) == null ? void 0 : C.height)
    ], v = {
      text: "New Annotation",
      snapToNearestPoint: !1,
      fontSize: 16,
      bezier: 10,
      show: {
        desktop: !0,
        tablet: !0,
        mobile: !0
      },
      connectorType: "line",
      colors: {
        label: "black",
        connector: "black",
        marker: "black"
      },
      selected: !0,
      anchor: {
        vertical: !1,
        horizontal: !1
      },
      marker: "arrow",
      edit: {
        subject: !0,
        label: !0
      },
      seriesKey: "",
      x: 50,
      y: Number((m == null ? void 0 : m[1]) / 2),
      xKey: r.xAxis.type === "date" ? new Date((O = (P = r == null ? void 0 : r.data) == null ? void 0 : P[0]) == null ? void 0 : O[r.xAxis.dataKey]).getTime() : r.xAxis.type === "categorical" ? "1/15/2016" : "",
      yKey: "",
      dx: 20,
      dy: -20,
      opacity: "100",
      savedDimensions: m,
      connectionType: "line"
    }, g = Array.isArray(r.annotations) ? r.annotations : [];
    t({
      ...r,
      annotations: [...g, v]
    });
  }, d = (m) => {
    const v = r.annotations.filter((g, A) => A !== m);
    t({
      ...r,
      annotations: v
    });
  };
  return /* @__PURE__ */ n.createElement(Lu, { key: e.name }, /* @__PURE__ */ n.createElement(Lu.Section, { title: e.name, key: e.name }, /* @__PURE__ */ n.createElement("label", { key: "key-1" }, "Show Annotation Dropdown", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "checkbox",
      checked: ((c = r == null ? void 0 : r.general) == null ? void 0 : c.showAnnotationDropdown) || !1,
      onChange: (m) => {
        t({
          ...r,
          general: {
            ...r.general,
            showAnnotationDropdown: m.target.checked
          }
        });
      }
    }
  )), r.general.showAnnotationDropdown && /* @__PURE__ */ n.createElement("label", { key: "key-2" }, "Annotation Dropdown Title:", /* @__PURE__ */ n.createElement(
    "input",
    {
      type: "text",
      style: { marginBottom: "10px" },
      value: (s = r == null ? void 0 : r.general) == null ? void 0 : s.annotationDropdownText,
      onChange: (m) => {
        t({
          ...r,
          general: {
            ...r.general,
            annotationDropdownText: m.target.value
          }
        });
      }
    }
  )), (r == null ? void 0 : r.annotations) && (r == null ? void 0 : r.annotations.map((m, v) => {
    var g, A, k, E, T, b, y, N;
    return /* @__PURE__ */ n.createElement(Lu, { key: v }, /* @__PURE__ */ n.createElement(
      Lu.Section,
      {
        title: m.text ? m.text.substring(0, 15) + "..." : `Annotation ${v + 1}`
      },
      /* @__PURE__ */ n.createElement("div", { className: "annotation-group" }, /* @__PURE__ */ n.createElement("label", null, "Annotation Text:", /* @__PURE__ */ n.createElement(
        "textarea",
        {
          rows: 5,
          value: m.text,
          onChange: (C) => i(C.target.value, "text", v)
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Opacity", /* @__PURE__ */ n.createElement("br", null), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "range",
          onChange: (C) => {
            const P = jt.cloneDeep(r == null ? void 0 : r.annotations);
            P[v].opacity = C.target.value, t({
              ...r,
              annotations: P
            });
          },
          value: ((A = (g = r == null ? void 0 : r.annotations) == null ? void 0 : g[v]) == null ? void 0 : A.opacity) || "100"
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Edit Subject", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "checkbox",
          checked: ((E = (k = r == null ? void 0 : r.annotations[v]) == null ? void 0 : k.edit) == null ? void 0 : E.subject) || !1,
          onChange: (C) => {
            const P = jt.cloneDeep(r == null ? void 0 : r.annotations);
            P[v].edit.subject = C.target.checked, t({
              ...r,
              annotations: P
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Edit Label", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "checkbox",
          checked: ((b = (T = r == null ? void 0 : r.annotations[v]) == null ? void 0 : T.edit) == null ? void 0 : b.label) || !1,
          onChange: (C) => {
            const P = jt.cloneDeep(r == null ? void 0 : r.annotations);
            P[v].edit.label = C.target.checked, t({
              ...r,
              annotations: P
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Connection Type:", /* @__PURE__ */ n.createElement(
        "select",
        {
          key: "annotation-connection-type",
          onChange: (C) => {
            const P = jt.cloneDeep(r == null ? void 0 : r.annotations);
            P[v].connectionType = C.target.value, t({
              ...r,
              annotations: P
            });
          },
          value: (y = r == null ? void 0 : r.annotations[v]) == null ? void 0 : y.connectionType
        },
        /* @__PURE__ */ n.createElement("option", { key: "select", value: "select" }, "Select"),
        ["curve", "line", "elbow", "none"].map((C, P) => /* @__PURE__ */ n.createElement("option", { key: C, value: C }, C))
      )), m.connectionType === "curve" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, "Curve Control", /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "range",
          min: "-20",
          max: "20",
          value: ((N = r == null ? void 0 : r.annotations[v]) == null ? void 0 : N.bezier) || 0,
          onChange: (C) => {
            const P = jt.cloneDeep(r == null ? void 0 : r.annotations);
            P[v].bezier = C.target.value, t({
              ...r,
              annotations: P
            });
          }
        }
      ))), /* @__PURE__ */ n.createElement("label", null, "Marker", /* @__PURE__ */ n.createElement(
        "select",
        {
          key: "annotation-marker",
          value: m.marker,
          onChange: (C) => {
            const P = jt.cloneDeep(r == null ? void 0 : r.annotations);
            P[v].marker = C.target.value, t({
              ...r,
              annotations: P
            });
          }
        },
        ["arrow", "circle"].map((C, P) => /* @__PURE__ */ n.createElement("option", { key: `col-${P}` }, C))
      )), /* @__PURE__ */ n.createElement(ws, { className: "warn btn-warn btn btn-remove delete", onClick: () => d(v) }, "Delete Annotation"))
    ));
  })), ((p = r == null ? void 0 : r.annotations) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ n.createElement(ws, { onClick: o, className: "mt-2" }, "Add Annotation")));
}, ya = {
  ForestPlot: sw,
  Series: Qr,
  Regions: kw,
  General: ww,
  BoxPlot: Tw,
  Visual: Aw,
  Sankey: Lw,
  Annotate: Pw
};
const fm = [
  ["*", "Asterisk"],
  ["", "Dagger"],
  ["", "Section Symbol"],
  ["", "Paragraph Symbol"]
], Nw = fm.concat(fm.map(([e, t]) => [e + e, "Double " + t])), pm = jt.fromPairs(jt.map(Nw, ([e, t]) => [t, e])), Rw = new _m(), hm = (e, t) => {
  for (let r = 0; r < e.length; r++) {
    let a = Object.keys(e[r]), i = !0;
    for (let o = 0; o < a.length; o++)
      if (e[r][a[o]] !== t[a[o]]) {
        i = !1;
        break;
      }
    if (i)
      return r;
  }
  return -1;
}, Dw = (e, t, r) => {
  var i;
  const a = jt.cloneDeep(e);
  if (a.rankByValue = t, e.rankByValue && !t) {
    const o = (i = e == null ? void 0 : e.xAxis) != null && i.dataKey ? Rw.cleanData(e.data, e.xAxis.dataKey) : e.data, d = r.sort((c, s) => {
      const p = hm(o, c), m = hm(o, s);
      return p - m;
    });
    return [a, d];
  }
  return [a];
}, _w = ({ config: e, updateConfig: t, data: r }) => {
  var T, b, y;
  const a = e.visualizationType === "Combo", i = ((T = e.runtime.lineSeriesKeys) == null ? void 0 : T.length) > 0, o = ((b = e.runtime.barSeriesKeys) == null ? void 0 : b.length) > 0, d = a && i, c = a && o, s = () => jt.uniq(jt.flatMap(r, jt.keys)), p = () => e.visualizationType === "Line" || d ? ["effect", "suppression"] : ["suppression"], m = {
    "Dashed Small": "- - -",
    "Dashed Medium": " ",
    "Dashed Large": " ",
    "Open Circles": "",
    "Filled Circles": ""
  }, v = (N) => {
    const C = Object.keys(m);
    return N === "suppression" ? C.slice(0, -2) : C;
  }, g = () => {
    if (e.visualizationType === "Bar" || c)
      return Object.keys(pm);
  };
  let A = (N) => {
    let C = [];
    e.preliminaryData && (C = [...e.preliminaryData]), C.splice(N, 1), t({ ...e, preliminaryData: C });
  }, k = () => {
    const N = e.visualizationType === "Line" ? "effect" : "suppression";
    let C = e.preliminaryData ? [...e.preliminaryData] : [];
    const P = {
      type: N,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: "",
      hideBarSymbol: !1,
      hideLineStyle: !1,
      circleSize: 6,
      displayGray: !0
    };
    C.push(P), t({ ...e, preliminaryData: C });
  }, E = (N, C, P) => {
    let O = [];
    e.preliminaryData && (O = [...e.preliminaryData]), O[P][N] = C, N === "symbol" && (O[P].iconCode = pm[C]), N === "style" && (O[P].lineCode = m[C]), t({ ...e, preliminaryData: O });
  };
  return /* @__PURE__ */ n.createElement(n.Fragment, null, e.preliminaryData && ((y = e.preliminaryData) == null ? void 0 : y.map(
    ({
      displayGray: N,
      circleSize: C,
      column: P,
      displayLegend: O,
      displayTable: K,
      displayTooltip: W,
      label: J,
      seriesKey: j,
      style: B,
      symbol: Z,
      type: te,
      value: V,
      hideBarSymbol: ee,
      hideLineStyle: ce
    }, re) => {
      var G, U;
      return /* @__PURE__ */ n.createElement("div", { key: `preliminaryData-${re}`, className: "edit-block" }, /* @__PURE__ */ n.createElement("p", null, " ", te === "suppression" ? "Suppressed" : "Effect", " Data"), /* @__PURE__ */ n.createElement(
        "button",
        {
          type: "button",
          className: "remove-column",
          onClick: (q) => {
            q.preventDefault(), A(re);
          }
        },
        "Remove"
      ), /* @__PURE__ */ n.createElement(
        vt,
        {
          value: te,
          initial: e.visualizationType == "Bar" ? "" : "Select",
          fieldName: "type",
          label: "Type",
          updateField: (q, H, oe, ue) => E(oe, ue, re),
          options: p()
        }
      ), te === "suppression" ? /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        vt,
        {
          tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", 'Without a selected "Data Series", the suppression symbol will be applied for all series in the current dataset visualization. However, choosing a specific "data series" will isolate the suppression to that series.'))),
          value: P,
          initial: "Select",
          fieldName: "column",
          label: "Add Data Series",
          updateField: (q, H, oe, ue) => E(oe, ue, re),
          options: (G = e.runtime) == null ? void 0 : G.seriesKeys
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: V,
          fieldName: "value",
          label: "Suppressed Data  Value",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      ), (d || e.visualizationType === "Line") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        vt,
        {
          tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "The recommended approach for presenting data is to include a footnote indicating any data suppression."))),
          value: B,
          initial: "Select",
          fieldName: "style",
          label: "suppression line style",
          updateField: (q, H, oe, ue) => E(oe, ue, re),
          options: v(te)
        }
      ), /* @__PURE__ */ n.createElement(
        lt,
        {
          value: ce,
          fieldName: "hideLineStyle",
          label: "Hide Suppressed line Style",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      )), (c || e.visualizationType === "Bar") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        vt,
        {
          tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "A symbol is ", /* @__PURE__ */ n.createElement("i", null, "required"), ' to indicate suppressed data. We suggest "double asterisks." If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'))),
          value: Z,
          initial: "Select",
          fieldName: "symbol",
          label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
          updateField: (q, H, oe, ue) => E(oe, ue, re),
          options: g()
        }
      ), /* @__PURE__ */ n.createElement(
        lt,
        {
          value: ee,
          fieldName: "hideBarSymbol",
          label: "Hide Suppressed Bar Symbol  ",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      )), /* @__PURE__ */ n.createElement(
        Qe,
        {
          tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "This label will display in the tooltip and legend."))),
          value: J || "Suppressed",
          fieldName: "label",
          label: "Suppressed Data Label",
          placeholder: "",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      ), /* @__PURE__ */ n.createElement(
        lt,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting the "Display In Tooltips" option prevents suppressed values from appearing in tooltips.'))),
          value: W,
          fieldName: "displayTooltip",
          label: "Display in tooltips",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      ), /* @__PURE__ */ n.createElement(
        lt,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.'))),
          value: O,
          fieldName: "displayLegend",
          label: "Display in legend",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      ), /* @__PURE__ */ n.createElement(
        lt,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.'))),
          value: K,
          fieldName: "displayTable",
          label: "Display in table",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      ), /* @__PURE__ */ n.createElement(
        lt,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will apply to chart, tooltip hover, legend, and data table."))),
          value: N,
          fieldName: "displayGray",
          label: "Highlight Suppressed Data In Gray",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      )) : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        vt,
        {
          value: j,
          initial: "Select",
          fieldName: "seriesKey",
          label: "ASSOCIATE TO SERIES",
          updateField: (q, H, oe, ue) => E(oe, ue, re),
          options: e.runtime.lineSeriesKeys ?? ((U = e.runtime) == null ? void 0 : U.seriesKeys)
        }
      ), /* @__PURE__ */ n.createElement(
        vt,
        {
          value: P,
          initial: "Select",
          fieldName: "column",
          label: "COLUMN WITH CONFIGURATION VALUE",
          updateField: (q, H, oe, ue) => E(oe, ue, re),
          options: s()
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "If 'Filled Circles' is selected as the style, this field is optional, and the style 'Filled Circles' will apply to all points within the associated series data."))),
          value: V,
          fieldName: "value",
          label: "VALUE TO TRIGGER",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      ), /* @__PURE__ */ n.createElement(
        vt,
        {
          value: B,
          initial: "Select",
          fieldName: "style",
          label: "Style",
          updateField: (q, H, oe, ue) => E(oe, ue, re),
          options: v(te)
        }
      ), B.includes("Circles") && /* @__PURE__ */ n.createElement(
        Qe,
        {
          className: "number-narrow",
          type: "number",
          value: C,
          fieldName: "circleSize",
          label: "circle size",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      ), B !== "Filled Circles" && /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: J,
          fieldName: "label",
          label: "Label",
          placeholder: "",
          updateField: (q, H, oe, ue) => E(oe, ue, re)
        }
      )));
    }
  )), /* @__PURE__ */ n.createElement("button", { type: "button", onClick: k, className: "btn btn-primary full-width" }, e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line"));
}, Ow = ({ config: e, updateConfig: t, display: r }) => {
  var p, m, v, g;
  const a = (p = e == null ? void 0 : e.yAxis) == null ? void 0 : p.maxValue, i = ((v = (m = e == null ? void 0 : e.yAxis) == null ? void 0 : m.categories) == null ? void 0 : v.reduce((A, k) => A + (parseFloat(k.height) || 0), 0)) || 0, o = (A) => {
    let k = [];
    e.yAxis.categories && (k = [...e.yAxis.categories]), k.splice(A, 1), t({ ...e, yAxis: { ...e.yAxis, categories: k } });
  }, d = () => {
    var T, b;
    const A = (b = (T = e.yAxis) == null ? void 0 : T.categories) == null ? void 0 : b.length, k = 0.4;
    return ja("#ddd").darken(k * A).hex();
  }, c = () => {
    const A = e.yAxis.categories ? [...e.yAxis.categories] : [], k = {
      label: "Label " + Number(A.length + 1),
      height: "",
      color: d()
    };
    A.push(k), t({ ...e, yAxis: { ...e.yAxis, categories: A } });
  }, s = (A, k, E) => {
    let T = [];
    e.yAxis.categories && (T = [...e.yAxis.categories]), T[E][A] = k, t({ ...e, yAxis: { ...e.yAxis, categories: T } });
  };
  return r ? /* @__PURE__ */ n.createElement(n.Fragment, null, e.yAxis.type === "categorical" && ((g = e.yAxis.categories) == null ? void 0 : g.map(({ label: A, color: k, height: E }, T) => /* @__PURE__ */ n.createElement("div", { key: `preliminaryData-${T}`, className: "edit-block" }, /* @__PURE__ */ n.createElement("p", null, "Axis Category ", T + 1), /* @__PURE__ */ n.createElement(
    "button",
    {
      type: "button",
      className: "remove-column",
      onClick: (b) => {
        b.preventDefault(), o(T);
      }
    },
    "Remove"
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", "Category Height will be ignored for the last category. The last category will fill the rest of the axis height."))),
      type: "number",
      value: E,
      fieldName: "height",
      label: "Category Height",
      updateField: (b, y, N, C) => s(N, C, T)
    }
  ), Number(i) > Number(a) && e.yAxis.categories.length - 1 === T && /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block", fontSize: "15px" } }, "Update Max value to show all categories"), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: k,
      fieldName: "color",
      label: "Color",
      updateField: (b, y, N, C) => s(N, C, T)
    }
  ), /* @__PURE__ */ n.createElement(
    Qe,
    {
      value: A,
      fieldName: "label",
      label: "Label",
      updateField: (b, y, N, C) => s(N, C, T)
    }
  ))))), /* @__PURE__ */ n.createElement("button", { type: "button", onClick: c, className: "btn full-width" }, "Add Axis Category")) : /* @__PURE__ */ n.createElement(n.Fragment, null);
}, Fw = () => {
  var Xt, Rt, Qt, pn, _t, x, D, M, X, me, ge, Ae, Ye, ut, gt, pt, Mt, Pn, Nn, Rn, tr, Un;
  const {
    config: e,
    updateConfig: t,
    tableData: r,
    transformedData: a,
    loading: i,
    colorScale: o,
    colorPalettes: d,
    twoColorPalette: c,
    unfilteredData: s,
    excludedData: p,
    isDashboard: m,
    setParentConfig: v,
    missingRequiredSections: g,
    isDebug: A,
    setFilteredData: k,
    lineOptions: E,
    rawData: T,
    highlight: b,
    highlightReset: y,
    dimensions: N
  } = ie.useContext(Et), { minValue: C, maxValue: P, existPositiveValue: O, isAllLine: K } = Vc(e, s), W = { data: a, config: e }, { leftMax: J, rightMax: j } = og(W), {
    headerColors: B,
    visSupportsTooltipLines: Z,
    visSupportsNonSequentialPallete: te,
    visSupportsSequentialPallete: V,
    visSupportsReverseColorPalette: ee,
    visHasLabelOnData: ce,
    visHasNumbersOnBars: re,
    visHasAnchors: G,
    visHasBarBorders: U,
    visHasDataCutoff: q,
    visHasSelectableLegendValues: H,
    visCanAnimate: oe,
    visHasLegend: ue,
    visHasLegendAxisAlign: ke,
    visHasLegendColorCategory: De,
    visHasBrushChart: pe,
    visSupportsDateCategoryAxis: Be,
    visSupportsValueAxisMin: qe,
    visSupportsValueAxisMax: Pe,
    visSupportsDateCategoryAxisLabel: ve,
    visSupportsDateCategoryAxisLine: $e,
    visSupportsDateCategoryAxisTicks: z,
    visSupportsDateCategoryTickRotation: Re,
    visSupportsDateCategoryNumTicks: be,
    visSupportsDateCategoryAxisPadding: He,
    visSupportsRegions: Ve,
    visSupportsFilters: Oe,
    visSupportsPreliminaryData: Ge,
    visSupportsValueAxisGridLines: Xe,
    visSupportsValueAxisLine: rt,
    visSupportsValueAxisTicks: Ue,
    visSupportsValueAxisLabels: ze,
    visSupportsBarSpace: Ne,
    visSupportsBarThickness: ot,
    visSupportsFootnotes: nt,
    visSupportsSuperTitle: mt,
    visSupportsDataCutoff: wt,
    visSupportsChartHeight: xt,
    visSupportsLeftValueAxis: Pt,
    visSupportsTooltipOpacity: ln,
    visSupportsRankByValue: Gt,
    visSupportsResponsiveTicks: Ut,
    visSupportsDateCategoryHeight: yt,
    visHasDataSuppression: Tt,
    visHasCategoricalAxis: Dt,
    visSupportsDynamicSeries: nn
  } = Ms();
  ie.useEffect(() => {
    let ye = [];
    e.series && (ye = e.series.map((fe) => ({
      ...fe,
      type: e.visualizationType === "Combo" ? "Bar" : e.visualizationType ? e.visualizationType : "Bar",
      axis: "Left"
    }))), t({
      ...e,
      series: ye
    });
  }, [e.visualizationType]), ie.useEffect(() => {
    e.visualizationType === "Scatter Plot" && t({
      ...e,
      xAxis: {
        ...e.xAxis,
        type: "continuous"
      }
    });
  }, []), ie.useEffect(() => {
    e.visualizationType !== "Bar" && t({ ...e, tooltips: { ...e.tooltips, singleSeries: !1 } });
  }, [e.visualizationType]);
  const { hasRightAxis: yn } = vp({ config: e, yMax: e.yAxis.size, data: e.data, updateConfig: t }), Nt = (ye, fe) => ({
    ...fe
  }), un = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, Kt = (ye) => {
    ye.orientation === "horizontal" && (ye.labels = !1), ye.table.show === void 0 && (ye.table.show = !m), ye.visualizationType === "Combo" && (ye.orientation = "vertical"), Dn(ye.xAxis) && !ye.xAxis.padding && (ye.xAxis.padding = 0), ye.visualizationType === "Line" && (ye.visualizationSubType = "regular", ye.barStyle = "flat", ye.isLollipopChart = !1);
  }, Fe = (ye, fe, xe, Me) => {
    if (A && console.log(
      "#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue",
      ye,
      fe,
      xe,
      Me
    ), ye === "boxplot" && fe === "legend") {
      t({
        ...e,
        [ye]: {
          ...e[ye],
          [fe]: {
            ...e.boxplot[fe],
            [xe]: Me
          }
        }
      });
      return;
    }
    const zt = (Rr) => Rr === 0 ? !0 : !!Rr;
    if (ye === "columns" && zt(fe) && zt(xe)) {
      t({
        ...e,
        columns: {
          ...e.columns,
          [fe]: {
            ...e.columns[fe],
            [xe]: Me
          }
        }
      });
      return;
    }
    if (ye === null && fe === null) {
      zt(xe) || console.error("fieldName is required");
      let Rr = { ...e, [xe]: Me };
      Kt(Rr), t(Rr);
      return;
    }
    const Gn = Array.isArray(e[ye]);
    let Er = Gn ? [...e[ye], Me] : { ...e[ye], [xe]: Me };
    zt(fe) && (Gn ? (Er = [...e[ye]], Er[fe] = { ...Er[fe], [xe]: Me }) : typeof Me == "string" ? Er[fe] = Me : zt(xe) && (Er = { ...e[ye], [fe]: { ...e[ye][fe], [xe]: Me } }));
    let Vr = { ...e, [ye]: Er };
    Kt(Vr), t(Vr);
  }, [bt, xn] = ie.useState(!0), [Ot, Ln] = ie.useState(!1);
  if (i)
    return null;
  ie.useEffect(() => {
    var ye;
    (ye = e.general) != null && ye.boxplot && (e.general.boxplot.firstQuartilePercentage || t({
      ...e,
      boxplot: {
        ...e.boxplot,
        firstQuartilePercentage: 25
      }
    }));
  }, [e]);
  const An = (ye) => {
    t({
      ...e,
      lollipopShape: ye
    });
  }, $t = (ye) => {
    let fe = e.series ? [...e.series] : [], xe = Array.from(new Set(a.map((zt) => zt[ye]))), Me = [];
    xe.forEach((zt) => {
      Me.push({ key: zt });
    }), e.visualizationType === "Forecasting" ? fe.push({
      dataKey: ye,
      type: e.visualizationType,
      stages: Me,
      stageColumn: ye,
      axis: "Left",
      tooltip: !0
    }) : fe.push({ dataKey: ye, type: e.visualizationType, axis: "Left", tooltip: !0 }), t({ ...e, series: fe });
  }, It = (ye) => {
    let fe = [...e.exclusions.keys];
    fe.push(ye);
    let xe = { ...e.exclusions, keys: fe };
    t({ ...e, exclusions: xe });
  }, rn = (ye) => {
    let fe = -1, xe = [...e.exclusions.keys];
    for (let Me = 0; Me < xe.length; Me++)
      if (xe[Me] === ye) {
        fe = Me;
        break;
      }
    if (fe !== -1) {
      xe.splice(fe, 1);
      let Me = { ...e.exclusions, keys: xe }, zt = { ...e, exclusions: Me };
      xe.length === 0 && delete zt.exclusions.keys, t(zt);
    }
  }, fn = (ye = !0) => {
    let fe = {};
    if (s.forEach((xe) => {
      Object.keys(xe).forEach((Me) => fe[Me] = !0);
    }), ye) {
      const { lower: xe, upper: Me } = e.confidenceKeys || {};
      Object.keys(fe).forEach((zt) => {
        (e.series && e.series.filter((Gn) => Gn.dataKey === zt).length > 0 || e.confidenceKeys && Object.keys(e.confidenceKeys).includes(zt) && (xe && Me || xe || Me) && zt !== xe && zt !== Me) && delete fe[zt];
      });
    }
    return Object.keys(fe);
  }, On = (ye) => {
    const fe = [];
    switch (ye) {
      case "style":
        fe.push("circles", "boxes"), e.visualizationType === "Bar" && (!["right", "left"].includes(e.legend.position) || !e.legend.position) && fe.push("gradient"), e.visualizationType === "Line" && fe.push("lines");
        break;
      case "subStyle":
        e.visualizationType === "Bar" ? fe.push("linear blocks") : fe.push("linear blocks", "smooth");
        break;
    }
    return fe;
  }, Wn = (ye) => {
    if (!ye)
      return [];
    const fe = /* @__PURE__ */ new Set();
    for (let xe = 0; xe < ye.length; xe++)
      for (const [Me] of Object.entries(ye[xe]))
        fe.add(Me);
    return Array.from(fe);
  }, on = (ye, fe = !1) => {
    let xe = [];
    return p.forEach((Me) => {
      xe.push(Me[ye]);
    }), fe ? [...new Set(xe)] : xe;
  }, er = () => {
    xn(!bt), t({
      ...e,
      showEditorPanel: !bt
    });
  }, or = () => {
    let ye = JSON.parse(JSON.stringify(e));
    return g() === !1 && delete ye.newViz, delete ye.runtime, ye;
  };
  ie.useEffect(() => {
    if (v) {
      const ye = or();
      v(ye);
    }
  }, [e]), ie.useEffect(() => {
    const ye = e.xAxis.anchors.length > 0 ? e.xAxis.anchors : [], fe = e.yAxis.anchors.length > 0 ? e.yAxis.anchors : [];
    t({
      ...e,
      xAxis: {
        ...e.xAxis,
        anchors: fe
      },
      yAxis: {
        ...e.yAxis,
        anchors: ye
      }
    });
  }, [e.orientation]), ie.useEffect(() => {
    e.visualizationType === "Paired Bar" && t({
      ...e,
      orientation: "horizontal"
    });
  }, []), ie.useEffect(() => {
    e.orientation === "horizontal" && t({
      ...e,
      lollipopShape: e.lollipopShape
    });
  }, [e.isLollipopChart, e.lollipopShape]), ie.useEffect(() => {
    e.visualizationType === "Deviation Bar" && t({ ...e, orientation: "horizontal" });
  }, [e.visualizationType]);
  const Xn = ie.useCallback(() => {
    const ye = [...e.exclusions.keys];
    return /* @__PURE__ */ n.createElement("ul", { className: "series-list" }, ye.map((fe, xe) => /* @__PURE__ */ n.createElement("li", { key: fe }, /* @__PURE__ */ n.createElement("div", { className: "series-list__name", "data-title": fe }, /* @__PURE__ */ n.createElement("div", { className: "series-list__name--text" }, fe)), /* @__PURE__ */ n.createElement("button", { className: "series-list__remove", onClick: () => rn(fe) }, ""))));
  }, [e]), Ht = (ye, fe) => {
    let xe = e.series, [Me] = xe.splice(ye, 1);
    xe.splice(fe, 0, Me), t({ ...e, series: xe });
  };
  e.isLollipopChart && ((Xt = e == null ? void 0 : e.series) == null ? void 0 : Xt.length) > 1 && (e.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), e.visualizationType === "Paired Bar" && ((Rt = e == null ? void 0 : e.series) == null ? void 0 : Rt.length) !== 2 && (e.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), e.visualizationType === "Deviation Bar" && ((Qt = e == null ? void 0 : e.series) == null ? void 0 : Qt.length) !== 1 && (e.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), e.isLollipopChart && ((pn = e == null ? void 0 : e.series) == null ? void 0 : pn.length) === 0 && (e.runtime.editorErrorMessage = "Add a data series");
  const gn = e.orientation === "horizontal" ? "xAxis" : "yAxis", [Tn, qn] = ie.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), jn = () => {
    const ye = e[gn].max, fe = e[gn].rightMax;
    let xe = "", Me = "";
    if (e.visualizationType !== "Combo")
      switch (!0) {
        case (ye && parseFloat(ye) < parseFloat(P) && O):
          xe = "Max value must be more than " + P;
          break;
        case (ye && parseFloat(ye) < 0 && !O):
          xe = "Value must be more than or equal to 0";
          break;
        default:
          xe = "";
      }
    if (e.visualizationType === "Combo")
      switch (!0) {
        case (ye && parseFloat(ye) < J):
          xe = "Max value must be more than " + J;
          break;
        case (fe && parseFloat(fe) < j):
          Me = "Max value must be more than " + j;
          break;
        case (ye && parseFloat(ye) < 0 && !O):
          xe = "Value must be more than or equal to 0";
          break;
        default:
          xe = "";
      }
    qn((zt) => ({ ...zt, maxMsg: xe, rightMaxMessage: Me }));
  }, $n = () => {
    const ye = parseFloat(e[gn].min);
    let fe = Number(C), xe = "";
    switch (!0) {
      case (e.useLogScale && ["Line", "Combo", "Bar"].includes(e.visualizationType) && ye < 0):
        xe = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((e.visualizationType === "Line" || e.visualizationType === "Spark Line") && ye > fe):
        xe = "Value should not exceed " + C;
        break;
      case (e.visualizationType === "Combo" && K && ye > fe):
        xe = "Value should not exceed " + C;
        break;
      case ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && !K) && fe > 0 && ye > 0):
        xe = e.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (e.visualizationType === "Deviation Bar" && ye >= Math.min(fe, e.xAxis.target)):
        xe = "Value must be less than " + Math.min(fe, e.xAxis.target);
        break;
      case (e.visualizationType !== "Deviation Bar" && ye && fe < 0 && ye > fe):
        xe = "Value should not exceed " + C;
        break;
      default:
        xe = "";
    }
    qn((Me) => ({ ...Me, minMsg: xe }));
  };
  ie.useEffect(() => {
    $n(), jn();
  }, [C, P, e]);
  const Te = ((_t = e == null ? void 0 : e.dataKey) == null ? void 0 : _t.includes("http://")) || ((x = e == null ? void 0 : e.dataKey) == null ? void 0 : x.includes("https://")), _e = () => {
    var ye, fe;
    if (A !== void 0 && A && !((ye = e == null ? void 0 : e.xAxis) != null && ye.dataKey)) {
      let xe = fn(!1);
      if (xe.includes("Date"))
        return "Date";
      if (xe.includes("Race"))
        return "Race";
      if (xe.includes("Month"))
        return "Month";
    }
    return ((fe = e == null ? void 0 : e.xAxis) == null ? void 0 : fe.dataKey) || "";
  }, se = () => {
    if (A !== void 0 && A && fn(!1).length > 0) {
      let ye = fn(!1).filter((fe) => fe !== _e());
      if (ye.length > 0)
        return ye[0];
    }
    return "";
  };
  if (A && !e.xAxis.dataKey && (e.xAxis.dataKey = _e()), A && ((D = e == null ? void 0 : e.series) == null ? void 0 : D.length) === 0) {
    let ye = se();
    ye !== "" && $t(ye), A && console.log("### COVE DEBUG: Chart: Setting default datacol=", ye);
  }
  const it = [
    "Bump Chart",
    "Area Chart",
    "Combo",
    "Line",
    "Bar",
    "Forecasting",
    "Scatter Plot",
    "Paired Bar",
    "Deviation Bar"
  ], ft = [
    /* @__PURE__ */ n.createElement("option", { value: "", key: "Select Option" }, "- Select Option -")
  ];
  if (e.data && e.series) {
    Object.keys(((M = e.data) == null ? void 0 : M[0]) || []).map((fe) => {
      const xe = e == null ? void 0 : e.series.some((Me) => Me.dataKey === fe);
      if (fe !== e.xAxis.dataKey && !xe)
        return ft.push(
          /* @__PURE__ */ n.createElement("option", { value: fe, key: fe }, fe)
        );
    });
    let ye = {};
    e.data.forEach((fe) => {
      Object.keys(fe).forEach((xe) => {
        ye[xe] = ye[xe] || [];
        const Me = typeof fe[xe] == "number" ? fe[xe].toString() : fe[xe];
        ye[xe].indexOf(Me) === -1 && ye[xe].push(Me);
      });
    });
  }
  if (!e.data && a) {
    if (!a[0])
      return;
    Object.keys(a[0]).map((fe) => {
      const xe = a.some((Me) => Me.dataKey === fe);
      if (fe !== e.xAxis.dataKey && !xe)
        return ft.push(
          /* @__PURE__ */ n.createElement("option", { value: fe, key: fe }, fe)
        );
    });
    let ye = {};
    a.forEach((fe) => {
      Object.keys(fe).forEach((xe) => {
        ye[xe] = ye[xe] || [];
        const Me = typeof fe[xe] == "number" ? fe[xe].toString() : fe[xe];
        ye[xe].indexOf(Me) === -1 && ye[xe].push(Me);
      });
    });
  }
  const dt = (ye) => {
    const fe = jt.cloneDeep(e.columns);
    delete fe[ye], t({
      ...e,
      columns: fe
    });
  }, Ct = async (ye, fe, xe) => {
    switch (fe) {
      case "name":
        t({
          ...e,
          columns: {
            ...e.columns,
            [ye]: {
              ...e.columns[ye],
              [fe]: xe
            }
          }
        });
        break;
      default:
        t({
          ...e,
          columns: {
            ...e.columns,
            [ye]: {
              ...e.columns[ye],
              [fe]: xe
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: Yt,
    highlightedSeriesValues: Zt,
    handleUpdateHighlightedBar: at,
    handleAddNewHighlightedBar: tn,
    handleRemoveHighlightedBar: cn,
    handleUpdateHighlightedBarColor: qt,
    handleHighlightedBarLegendLabel: Sn,
    handleUpdateHighlightedBorderWidth: Wt
  } = Ic(e, t), Ee = e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1, et = () => {
    const ye = a.map((fe) => fe[e.legend.colorCode]);
    return Ee ? ye : fn(!1).filter((fe) => fe !== e.xAxis.dataKey);
  }, Ze = (ye) => {
    t({ ...e, legend: { ...e.legend, seriesHighlight: ye } });
  }, Ke = (ye, fe, xe) => {
    var Gn;
    const Me = { ...e[ye], [fe]: xe }, zt = { ...e, [ye]: Me };
    xe === "highlight" && ((Gn = e.legend.seriesHighlight) != null && Gn.length) && (zt.legend.seriesHighlight.length = 0), t(zt);
  }, Vt = (ye, fe, xe) => {
    const Me = { ...e.xAxis[ye] };
    Me[fe] = xe;
    const zt = { ...e, xAxis: { ...e.xAxis, [ye]: Me } };
    t(zt);
  }, At = {
    addNewExclusion: It,
    data: a,
    editColumn: Ct,
    getColumns: fn,
    getDataValueOptions: Wn,
    getDataValues: on,
    getItemStyle: Nt,
    handleSeriesChange: Ht,
    handleAddNewHighlightedBar: tn,
    setCategoryAxis: _e,
    updateField: Fe,
    warningMsg: Tn,
    highlightedBarValues: Yt,
    handleHighlightedBarLegendLabel: Sn,
    handleUpdateHighlightedBar: at,
    handleRemoveHighlightedBar: cn,
    isPaletteReversed: e.isPaletteReversed,
    highlightedSeriesValues: Zt,
    handleUpdateHighlightedBorderWidth: Wt,
    handleUpdateHighlightedBarColor: qt,
    setLollipopShape: An
  };
  return /* @__PURE__ */ n.createElement(Ep.Provider, { value: At }, /* @__PURE__ */ n.createElement(Hr, { component: "EditorPanel" }, /* @__PURE__ */ n.createElement(
    mf.Sidebar,
    {
      displayPanel: bt,
      isDashboard: m,
      title: "Configure Chart",
      onBackClick: er
    },
    /* @__PURE__ */ n.createElement(zi, { allowZeroExpanded: !0 }, /* @__PURE__ */ n.createElement(ya.General, { name: "General" }), /* @__PURE__ */ n.createElement(ya.ForestPlot, { name: "Forest Plot Settings" }), /* @__PURE__ */ n.createElement(ya.Sankey, { name: "Sankey" }), e.visualizationType !== "Pie" && e.visualizationType !== "Forest Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, "Data Series", " ", (!e.series || e.series.length === 0 || e.visualizationType === "Paired Bar" && e.series.length < 2) && !e.dynamicSeries && /* @__PURE__ */ n.createElement(Qu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(Bn, null, nn() && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.dynamicSeries,
        fieldName: "dynamicSeries",
        label: "Dynamically generate series",
        updateField: Fe
      }
    ), e.dynamicSeries && e.visualizationType === "Line" && /* @__PURE__ */ n.createElement(
      vt,
      {
        fieldName: "dynamicSeriesType",
        value: e.dynamicSeriesType,
        label: "Series Type",
        initial: "Select",
        updateField: Fe,
        options: ["Line", "dashed-sm", "dashed-md", "dashed-lg"]
      }
    ), e.dynamicSeries && e.visualizationType === "Line" && e.dynamicSeriesType === "Line" && /* @__PURE__ */ n.createElement(
      vt,
      {
        fieldName: "dynamicSeriesLineType",
        value: e.dynamicSeriesLineType ? e.dynamicSeriesLineType : "curveLinear",
        label: "Line Type",
        initial: "Select",
        updateField: Fe,
        options: Object.keys(al).map((ye) => al[ye])
      }
    ), (!nn() || !e.dynamicSeries) && /* @__PURE__ */ n.createElement(n.Fragment, null, (!e.series || e.series.length === 0) && !e.dynamicSeries && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement("p", { className: "warning" }, "At least one series is required"), (!e.series || e.series.length === 0 || e.series.length < 2) && e.visualizationType === "Paired Bar" && /* @__PURE__ */ n.createElement("p", { className: "warning" }, "Select two data series for paired bar chart (e.g., Male and Female)."), /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      vt,
      {
        fieldName: "visualizationType",
        label: "Add Data Series",
        initial: "Select",
        onChange: (ye) => {
          ye.target.value !== "" && ye.target.value !== "Select" && $t(ye.target.value), ye.target.value = "";
        },
        options: fn()
      }
    ), e.series && e.series.length !== 0 && /* @__PURE__ */ n.createElement(ya.Series.Wrapper, { getColumns: fn }, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label float-left" }, "Displaying"), /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "A data series is a set of related data points plotted in a chart and typically represented in the chart legend.")))), /* @__PURE__ */ n.createElement(
      Em,
      {
        onDragEnd: ({ source: ye, destination: fe }) => Ht(ye.index, fe.index)
      },
      /* @__PURE__ */ n.createElement(Sm, { droppableId: "filter_order" }, (ye) => /* @__PURE__ */ n.createElement("ul", { ...ye.droppableProps, className: "series-list", ref: ye.innerRef }, /* @__PURE__ */ n.createElement(
        ya.Series.List,
        {
          series: e.series,
          getItemStyle: Nt,
          sortableItemStyles: un,
          chartsWithOptions: it
        }
      ), ye.placeholder))
    ))), e.series && e.series.length <= 1 && e.visualizationType === "Bar" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Confidence Keys"), /* @__PURE__ */ n.createElement(
      vt,
      {
        value: e.confidenceKeys.upper || "",
        section: "confidenceKeys",
        fieldName: "upper",
        label: "Upper",
        updateField: Fe,
        initial: "Select",
        options: fn()
      }
    ), /* @__PURE__ */ n.createElement(
      vt,
      {
        value: e.confidenceKeys.lower || "",
        section: "confidenceKeys",
        fieldName: "lower",
        label: "Lower",
        updateField: Fe,
        initial: "Select",
        options: fn()
      }
    )), Gt() && e.series && e.series.length === 1 && /* @__PURE__ */ n.createElement(
      vt,
      {
        value: e.rankByValue,
        fieldName: "rankByValue",
        label: "Rank by Value",
        initial: "Select",
        updateField: (ye, fe, xe, Me) => {
          const [zt, Gn] = Dw(e, Me, a);
          t(zt, Gn);
        },
        options: ["asc", "desc"]
      }
    ), Ge() && /* @__PURE__ */ n.createElement(_w, { config: e, updateConfig: t, data: a })))), /* @__PURE__ */ n.createElement(ya.BoxPlot, { name: "Measures" }), Pt() && /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, e.visualizationType === "Pie" ? "Data Format" : e.orientation === "vertical" ? "Left Value Axis" : "Value Axis", e.visualizationType === "Pie" && !e.yAxis.dataKey && /* @__PURE__ */ n.createElement(Qu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(Bn, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(
      vt,
      {
        value: e.yAxis.dataKey || "",
        section: "yAxis",
        fieldName: "dataKey",
        label: "Data Column",
        initial: "Select",
        required: !0,
        updateField: Fe,
        options: fn(!1),
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the source data to be visually represented.")))
      }
    ), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Axis Type", /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, "Select 'Numeric (Linear Scale)' for uniform scaling, 'Numeric (Logarithmic Scale)' for exponential data, or 'Categorical' for discrete categories."))), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.yAxis.type,
        onChange: (ye) => t({
          ...e,
          yAxis: {
            ...e.yAxis,
            type: ye.target.value
          }
        })
      },
      /* @__PURE__ */ n.createElement("option", { value: "linear" }, "Numeric (Linear Scale)"),
      e.visualizationSubType !== "stacked" && /* @__PURE__ */ n.createElement("option", { value: "logarithmic" }, "Numeric (Logarithmic Scale)"),
      e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("option", { value: "categorical" }, "Categorical")
    )), /* @__PURE__ */ n.createElement(
      Ow,
      {
        config: e,
        updateConfig: t,
        data: a,
        display: Dt()
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !Dt(),
        value: e.yAxis.label,
        section: "yAxis",
        fieldName: "label",
        label: "Label ",
        updateField: Fe
      }
    ), e.runtime.seriesKeys && e.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(e.visualizationType) && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.isLegendValue,
        fieldName: "isLegendValue",
        label: "Use Legend Value in Hover",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !Dt(),
        value: e.yAxis.numTicks,
        placeholder: "Auto",
        type: "number",
        section: "yAxis",
        fieldName: "numTicks",
        label: "Number of ticks",
        className: "number-narrow",
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used."))),
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.size,
        type: "number",
        section: "yAxis",
        fieldName: "size",
        label: e.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
        className: "number-narrow",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, `Increase the size if elements in the ${e.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.`)))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !Dt(),
        value: e.yAxis.labelOffset,
        section: "yAxis",
        fieldName: "labelOffset",
        label: "Label offset",
        type: "number",
        className: "number-narrow",
        updateField: Fe
      }
    ), e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.isResponsiveTicks,
        fieldName: "isResponsiveTicks",
        label: "Use Responsive Ticks",
        updateField: Fe
      }
    ), (e.orientation === "vertical" || !e.isResponsiveTicks) && /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: !Dt(),
        value: e.yAxis.tickRotation || 0,
        type: "number",
        min: 0,
        section: "yAxis",
        fieldName: "tickRotation",
        label: "Tick rotation (Degrees)",
        className: "number-narrow",
        updateField: Fe
      }
    ), e.isResponsiveTicks && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.maxTickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "maxTickRotation",
        label: "Max Tick Rotation",
        className: "number-narrow",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
      }
    ), Xe() && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.yAxis.gridLines,
        section: "yAxis",
        fieldName: "gridLines",
        label: "Show Gridlines",
        updateField: Fe
      }
    ), Xe() && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.yAxis.labelsAboveGridlines,
        section: "yAxis",
        fieldName: "labelsAboveGridlines",
        label: "Tick labels above gridlines",
        updateField: Fe,
        disabled: !e.yAxis.gridLines,
        title: e.yAxis.gridLines ? "" : "Show gridlines to enable"
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.yAxis.enablePadding,
        section: "yAxis",
        fieldName: "enablePadding",
        label: "Add Padding to Value Axis Scale",
        updateField: Fe
      }
    ), e.yAxis.enablePadding && /* @__PURE__ */ n.createElement(
      Qe,
      {
        type: "number",
        section: "yAxis",
        fieldName: "scalePadding",
        label: "Padding Percentage",
        className: "number-narrow",
        updateField: Fe,
        value: e.yAxis.scalePadding
      }
    )), /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.dataFormat.commas,
        section: "dataFormat",
        fieldName: "commas",
        label: "Add commas",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will add commas to the left value axis, tooltip hover, and data table.")))
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        display: !Dt(),
        value: e.dataFormat.abbreviated,
        section: "dataFormat",
        fieldName: "abbreviated",
        label: "Abbreviate Axis Values",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.roundTo ? e.dataFormat.roundTo : 0,
        type: "number",
        section: "dataFormat",
        fieldName: "roundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: Fe,
        min: 0
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.prefix,
        section: "dataFormat",
        fieldName: "prefix",
        label: "Prefix",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.suffix,
        section: "dataFormat",
        fieldName: "suffix",
        label: "Suffix",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    )), e.orientation === "horizontal" ? (
      // horizontal - x is vertical y is horizontal
      /* @__PURE__ */ n.createElement(n.Fragment, null, rt() && /* @__PURE__ */ n.createElement(
        lt,
        {
          value: e.xAxis.hideAxis,
          section: "xAxis",
          fieldName: "hideAxis",
          label: "Hide Axis",
          updateField: Fe
        }
      ), ze() && /* @__PURE__ */ n.createElement(
        lt,
        {
          value: e.xAxis.hideLabel,
          section: "xAxis",
          fieldName: "hideLabel",
          label: "Hide Tick Labels",
          updateField: Fe
        }
      ), Ue() && /* @__PURE__ */ n.createElement(
        lt,
        {
          value: e.xAxis.hideTicks,
          section: "xAxis",
          fieldName: "hideTicks",
          label: "Hide Ticks",
          updateField: Fe
        }
      ), Pe() && /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.max,
          section: "xAxis",
          fieldName: "max",
          label: "max value",
          type: "number",
          placeholder: "Auto",
          updateField: Fe
        }
      ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Tn.maxMsg), qe() && /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.min,
          section: "xAxis",
          fieldName: "min",
          type: "number",
          label: "min value",
          placeholder: "Auto",
          updateField: Fe
        }
      ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Tn.minMsg), e.visualizationType === "Deviation Bar" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.target,
          section: "xAxis",
          fieldName: "target",
          type: "number",
          label: "Deviation point",
          placeholder: "Auto",
          updateField: Fe
        }
      ), /* @__PURE__ */ n.createElement(
        Qe,
        {
          value: e.xAxis.targetLabel || "Target",
          section: "xAxis",
          fieldName: "targetLabel",
          type: "text",
          label: "Deviation point Label",
          updateField: Fe
        }
      ), /* @__PURE__ */ n.createElement(
        lt,
        {
          value: e.xAxis.showTargetLabel,
          section: "xAxis",
          fieldName: "showTargetLabel",
          label: "Show Deviation point label",
          updateField: Fe
        }
      )))
    ) : e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      lt,
      {
        display: !Dt(),
        value: e.dataFormat.onlyShowTopPrefixSuffix,
        section: "dataFormat",
        fieldName: "onlyShowTopPrefixSuffix",
        label: "Only Show Top Prefix/Suffix",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        display: !Dt(),
        value: e.yAxis.hideAxis,
        section: "yAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        display: !Dt(),
        value: e.yAxis.hideLabel,
        section: "yAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        display: !Dt(),
        value: e.yAxis.hideTicks,
        section: "yAxis",
        fieldName: "hideTicks",
        label: "Hide Ticks",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.max,
        section: "yAxis",
        fieldName: "max",
        type: "number",
        label: "left axis max value",
        placeholder: "Auto",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Tn.maxMsg), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.min,
        section: "yAxis",
        fieldName: "min",
        type: "number",
        label: "left axis min value",
        placeholder: "Auto",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Tn.minMsg)), G() && e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(zi, { allowZeroExpanded: !0 }, (me = (X = e.yAxis) == null ? void 0 : X.anchors) == null ? void 0 : me.map((ye, fe) => /* @__PURE__ */ n.createElement(Fn, { className: "series-item series-item--chart", key: `yaxis-anchors-2-${fe}` }, /* @__PURE__ */ n.createElement(Mn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(zn, { className: "accordion__button accordion__button" }, "Anchor ", fe + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (xe) => {
          xe.preventDefault();
          const Me = [...e.yAxis.anchors];
          Me.splice(fe, 1), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: Me
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.yAxis.anchors[fe].value ? e.yAxis.anchors[fe].value : "",
        onChange: (xe) => {
          xe.preventDefault();
          const Me = [...e.yAxis.anchors];
          Me[fe].value = xe.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: Me
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.yAxis.anchors[fe].color ? e.yAxis.anchors[fe].color : "",
        onChange: (xe) => {
          xe.preventDefault();
          const Me = [...e.yAxis.anchors];
          Me[fe].color = xe.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: Me
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.yAxis.anchors[fe].lineStyle || "",
        onChange: (xe) => {
          const Me = [...e.yAxis.anchors];
          Me[fe].lineStyle = xe.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: Me
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      E.map((xe) => /* @__PURE__ */ n.createElement("option", { key: xe.key }, xe.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (ye) => {
          ye.preventDefault();
          const fe = [...e.yAxis.anchors];
          fe.push({}), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: fe
            }
          });
        }
      },
      "Add Anchor"
    )), G() && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(zi, { allowZeroExpanded: !0 }, (Ae = (ge = e.xAxis) == null ? void 0 : ge.anchors) == null ? void 0 : Ae.map((ye, fe) => /* @__PURE__ */ n.createElement(Fn, { className: "series-item series-item--chart", key: `xaxis-anchors-${fe}` }, /* @__PURE__ */ n.createElement(Mn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(zn, { className: "accordion__button accordion__button" }, "Anchor ", fe + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (xe) => {
          xe.preventDefault();
          const Me = [...e.xAxis.anchors];
          Me.splice(fe, 1), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: Me
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[fe].value ? e.xAxis.anchors[fe].value : "",
        onChange: (xe) => {
          xe.preventDefault();
          const Me = [...e.xAxis.anchors];
          Me[fe].value = xe.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: Me
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[fe].color ? e.xAxis.anchors[fe].color : "",
        onChange: (xe) => {
          xe.preventDefault();
          const Me = [...e.xAxis.anchors];
          Me[fe].color = xe.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: Me
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.anchors[fe].lineStyle || "",
        onChange: (xe) => {
          const Me = [...e.xAxis.anchors];
          Me[fe].lineStyle = xe.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: Me
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      E.map((xe) => /* @__PURE__ */ n.createElement("option", { key: xe.key }, xe.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (ye) => {
          ye.preventDefault();
          const fe = [...e.xAxis.anchors];
          fe.push({}), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: fe
            }
          });
        }
      },
      "Add Anchor"
    )))), yn && /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, "Right Value Axis")), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.rightLabel,
        section: "yAxis",
        fieldName: "rightLabel",
        label: "Label",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.rightNumTicks,
        placeholder: "Auto",
        type: "number",
        section: "yAxis",
        fieldName: "rightNumTicks",
        label: "Number of ticks",
        className: "number-narrow",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.rightAxisSize,
        type: "number",
        section: "yAxis",
        fieldName: "rightAxisSize",
        label: "Size (Width)",
        className: "number-narrow",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.rightLabelOffsetSize,
        type: "number",
        section: "yAxis",
        fieldName: "rightLabelOffsetSize",
        label: "Label Offset",
        className: "number-narrow",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.dataFormat.rightCommas,
        section: "dataFormat",
        fieldName: "rightCommas",
        label: "Add commas",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.rightRoundTo,
        type: "number",
        section: "dataFormat",
        fieldName: "rightRoundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: Fe,
        min: 0
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.rightPrefix,
        section: "dataFormat",
        fieldName: "rightPrefix",
        label: "Prefix",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.rightSuffix,
        section: "dataFormat",
        fieldName: "rightSuffix",
        label: "Suffix",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    )), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.yAxis.rightHideAxis,
        section: "yAxis",
        fieldName: "rightHideAxis",
        label: "Hide Axis",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.yAxis.rightHideLabel,
        section: "yAxis",
        fieldName: "rightHideLabel",
        label: "Hide Tick Labels",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.yAxis.rightHideTicks,
        section: "yAxis",
        fieldName: "rightHideTicks",
        label: "Hide Ticks",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.max,
        section: "yAxis",
        fieldName: "rightMax",
        type: "number",
        label: "right axis max value",
        placeholder: "Auto",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Tn.rightMaxMessage), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.yAxis.min,
        section: "yAxis",
        fieldName: "rightMin",
        type: "number",
        label: "right axis min value",
        placeholder: "Auto",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement("span", { style: { color: "red", display: "block" } }, Tn.minMsg))), Be() && /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, e.visualizationType === "Pie" ? "Segments" : "Date/Category Axis", !e.xAxis.dataKey && /* @__PURE__ */ n.createElement(Qu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ n.createElement(Bn, null, e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, e.visualizationType !== "Forest Plot" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Data Scaling Type", /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, "Linear scales are employed for quantitative data, while time scales are used for time-series data."))), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.type,
        onChange: (ye) => t({
          ...e,
          xAxis: {
            ...e.xAxis,
            type: ye.target.value
          }
        })
      },
      e.visualizationType !== "Bump Chart" && /* @__PURE__ */ n.createElement("option", { value: "categorical" }, "Categorical (Linear Scale)"),
      e.visualizationType !== "Bump Chart" && /* @__PURE__ */ n.createElement("option", { value: "date" }, "Date (Linear Scale)"),
      /* @__PURE__ */ n.createElement("option", { value: "date-time" }, "Date (Date Time Scale)"),
      e.visualizationType === "Scatter Plot" && /* @__PURE__ */ n.createElement("option", { value: "continuous" }, "Continuous")
    )), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.xAxis.manual,
        section: "xAxis",
        fieldName: "manual",
        label: "Manual Ticks",
        updateField: Fe
      }
    ), He() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.padding,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "padding",
        label: "Padding (Percent)",
        className: "number-narrow",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified.")))
      }
    )), /* @__PURE__ */ n.createElement(
      vt,
      {
        value: e.xAxis.dataKey || _e() || "",
        section: "xAxis",
        fieldName: "dataKey",
        label: "Data Key",
        initial: "Select",
        required: !0,
        updateField: Fe,
        options: fn(!1),
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
      }
    )), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(
      vt,
      {
        value: e.xAxis.dataKey || "",
        section: "xAxis",
        fieldName: "dataKey",
        label: "Segment Labels",
        initial: "Select",
        required: !0,
        updateField: Fe,
        options: fn(!1),
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."')))
      }
    ), e.visualizationType !== "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.label,
        section: "xAxis",
        fieldName: "label",
        label: "Label",
        updateField: Fe
      }
    ), e.xAxis.type === "continuous" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.bottomPrefix,
        section: "dataFormat",
        fieldName: "bottomPrefix",
        label: "Prefix",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.bottomSuffix,
        section: "dataFormat",
        fieldName: "bottomSuffix",
        label: "Suffix",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.dataFormat.bottomAbbreviated,
        section: "dataFormat",
        fieldName: "bottomAbbreviated",
        label: "Abbreviate Axis Values",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
      }
    )), Dn(e.xAxis) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" } }, "Format how charts should parse and display your dates using", " ", /* @__PURE__ */ n.createElement("a", { href: "https://d3js.org/d3-time-format#locale_format", target: "_blank", rel: "noreferrer" }, "these guidelines"), "."), /* @__PURE__ */ n.createElement(
      Qe,
      {
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed.", " "))),
        value: e.xAxis.dateParseFormat,
        section: "xAxis",
        fieldName: "dateParseFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "Date Parse Format",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, " ", "Adjusts the date display format on the axis for clear, visual date representation."))),
        value: e.xAxis.dateDisplayFormat,
        section: "xAxis",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "AXIS DATE DISPLAY FORMAT",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format.", " "))),
        value: e.table.dateDisplayFormat,
        section: "table",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "DATA TABLE DATE DISPLAY FORMAT",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format.", " "))),
        value: e.tooltips.dateDisplayFormat,
        section: "tooltips",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "HOVER DATE DISPLAY FORMAT",
        updateField: Fe
      }
    )), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.exclusions.active,
        section: "exclusions",
        fieldName: "active",
        label: e.xAxis.type === "date" ? "Limit by start and/or end dates" : "Exclude one or more values",
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked, you can select source-file values for exclusion from the date/category axis.", " "))),
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.xAxis.showYearsOnce,
        section: "xAxis",
        fieldName: "showYearsOnce",
        label: "Show years once",
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked and the date format for the axis includes years, each year will only be shown once in the axis."))),
        updateField: Fe
      }
    ), pe() && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: (Ye = e.brush) == null ? void 0 : Ye.active,
        section: "brush",
        fieldName: "active",
        label: "Brush Slider ",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Use the brush slider to narrow down your data view to specific values along the axis. This tool is useful for examining detailed data segments within the larger dataset.", " ")))
      }
    ), e.exclusions.active && /* @__PURE__ */ n.createElement(n.Fragment, null, e.xAxis.type === "categorical" && /* @__PURE__ */ n.createElement(n.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ n.createElement(Xn, null)), /* @__PURE__ */ n.createElement(
      vt,
      {
        fieldName: "visualizationType",
        label: "Add Exclusion",
        initial: "Select",
        onChange: (ye) => {
          ye.target.value !== "" && ye.target.value !== "Select" && It(ye.target.value), ye.target.value = "";
        },
        options: on(e.xAxis.dataKey, !0)
      }
    )), e.xAxis.type === "date" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        type: "date",
        section: "exclusions",
        fieldName: "dateStart",
        label: "Start Date",
        updateField: Fe,
        value: e.exclusions.dateStart || ""
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        type: "date",
        section: "exclusions",
        fieldName: "dateEnd",
        label: "End Date",
        updateField: Fe,
        value: e.exclusions.dateEnd || ""
      }
    ))), be() && e.xAxis.type !== "date-time" && e.xAxis.manual && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.manualStep,
        placeholder: "Auto",
        type: "number",
        min: 1,
        section: "xAxis",
        fieldName: "manualStep",
        label: "Step count",
        className: "number-narrow",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc.")))
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement(
      "button",
      {
        onClick: () => Ln(!Ot),
        className: "edit-label"
      },
      "Step Count: viewport overrides",
      " ",
      /* @__PURE__ */ n.createElement("span", { style: { transform: `rotate(${Ot ? "90deg" : "0deg"})` } }, ">")
    )), Ot && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, Object.keys(kp).map((ye) => /* @__PURE__ */ n.createElement(
      Qe,
      {
        key: `viewport-step-count-input-${ye}`,
        value: e.xAxis.viewportStepCount ? e.xAxis.viewportStepCount[ye] : void 0,
        placeholder: "Auto",
        type: "number",
        label: ye,
        className: "number-narrow",
        updateField: (fe, xe, Me, zt) => Vt("viewportStepCount", ye, zt)
      }
    ))))), be() && (e.xAxis.type === "date-time" || !e.xAxis.manual) && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.numTicks,
        placeholder: "Auto",
        type: "number",
        min: 1,
        section: "xAxis",
        fieldName: "numTicks",
        label: "Number of ticks",
        className: "number-narrow",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.')))
      }
    ), /* @__PURE__ */ n.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement(
      "button",
      {
        onClick: () => Ln(!Ot),
        className: "edit-label"
      },
      "Number of ticks: viewport overrides",
      " ",
      /* @__PURE__ */ n.createElement("span", { style: { transform: `rotate(${Ot ? "90deg" : "0deg"})` } }, ">")
    )), Ot && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, Object.keys(kp).map((ye) => /* @__PURE__ */ n.createElement(
      Qe,
      {
        key: `viewport-num-ticks-input-${ye}`,
        value: e.xAxis.viewportNumTicks ? e.xAxis.viewportNumTicks[ye] : void 0,
        placeholder: "Auto",
        type: "number",
        label: ye,
        className: "number-narrow",
        updateField: (fe, xe, Me, zt) => Vt("viewportNumTicks", ye, zt)
      }
    ))))), yt() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.size,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "size",
        label: e.orientation === "horizontal" ? "Size (Width)" : "Size (Height)",
        className: "number-narrow",
        updateField: Fe
      }
    ), e.orientation === "horizontal" && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.labelOffset,
        section: "xAxis",
        fieldName: "labelOffset",
        label: "Label offset",
        type: "number",
        className: "number-narrow",
        updateField: Fe
      }
    ), (e.xAxis.type === "continuous" || e.forestPlot.type === "Logarithmic") && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.dataFormat.bottomCommas,
        section: "dataFormat",
        fieldName: "bottomCommas",
        label: "Add commas",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.dataFormat.bottomRoundTo,
        type: "number",
        section: "dataFormat",
        fieldName: "bottomRoundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: Fe,
        min: 0
      }
    )), Ut() && e.orientation === "vertical" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.isResponsiveTicks,
        fieldName: "isResponsiveTicks",
        label: "Use Responsive Ticks",
        updateField: Fe
      }
    ), (e.orientation === "horizontal" || !e.isResponsiveTicks) && Re() && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.tickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "tickRotation",
        label: "Tick rotation (Degrees)",
        className: "number-narrow",
        updateField: Fe
      }
    ), e.orientation === "vertical" && e.isResponsiveTicks && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.xAxis.maxTickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "maxTickRotation",
        label: "Max Tick Rotation",
        className: "number-narrow",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
      }
    ), e.orientation === "horizontal" ? /* @__PURE__ */ n.createElement(n.Fragment, null, $e() && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.yAxis.hideAxis,
        section: "yAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: Fe
      }
    ), ve() && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.yAxis.hideLabel,
        section: "yAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: Fe
      }
    )) : /* @__PURE__ */ n.createElement(n.Fragment, null, $e() && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.xAxis.hideAxis,
        section: "xAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: Fe
      }
    ), ve() && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.xAxis.hideLabel,
        section: "xAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: Fe
      }
    ), z() && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.xAxis.hideTicks,
        section: "xAxis",
        fieldName: "hideTicks",
        label: "Hide Ticks",
        updateField: Fe
      }
    )), ((ut = e.series) == null ? void 0 : ut.length) === 1 && e.visualizationType === "Bar" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("label", { htmlFor: "barHighlight" }, "Bar Highlighting"), e.series.length === 1 && Yt.map((ye, fe) => /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("div", { className: "edit-block", key: `highlighted-bar-${fe}` }, /* @__PURE__ */ n.createElement("button", { className: "remove-column", onClick: (xe) => cn(xe, fe) }, "Remove"), /* @__PURE__ */ n.createElement("p", null, "Highlighted Bar ", fe + 1), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Value"), /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.highlightedBarValues[fe].value,
        onChange: (xe) => at(xe, fe)
      },
      /* @__PURE__ */ n.createElement("option", { value: "" }, "- Select Value -"),
      Zt && [...new Set(Zt)].sort().map((xe) => /* @__PURE__ */ n.createElement("option", { key: `special-class-value-option-${fe}-${xe}` }, xe))
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.highlightedBarValues[fe].color ? e.highlightedBarValues[fe].color : "",
        onChange: (xe) => qt(xe, fe)
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Border Width"), /* @__PURE__ */ n.createElement(
      "input",
      {
        max: "5",
        min: "0",
        type: "number",
        value: e.highlightedBarValues[fe].borderWidth ? e.highlightedBarValues[fe].borderWidth : "",
        onChange: (xe) => Wt(xe, fe)
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Legend Label"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.highlightedBarValues[fe].legendLabel ? e.highlightedBarValues[fe].legendLabel : "",
        onChange: (xe) => Sn(xe, fe)
      }
    ))))), /* @__PURE__ */ n.createElement("button", { className: "btn full-width", onClick: (ye) => tn(ye) }, "Add Highlighted Bar"))), e.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.exclusions.active,
        section: "exclusions",
        fieldName: "active",
        label: "Exclude one or more values",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "When this option is checked, you can select values for exclusion from the pie segments.")))
      }
    ), e.exclusions.active && /* @__PURE__ */ n.createElement(n.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("fieldset", null, /* @__PURE__ */ n.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ n.createElement(Xn, null)), /* @__PURE__ */ n.createElement(
      vt,
      {
        fieldName: "visualizationType",
        label: "Add Exclusion",
        initial: "Select",
        onChange: (ye) => {
          ye.target.value !== "" && ye.target.value !== "Select" && It(ye.target.value), ye.target.value = "";
        },
        options: on(e.xAxis.dataKey, !0)
      }
    ))), G() && e.orientation !== "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(zi, { allowZeroExpanded: !0 }, (pt = (gt = e.xAxis) == null ? void 0 : gt.anchors) == null ? void 0 : pt.map((ye, fe) => /* @__PURE__ */ n.createElement(Fn, { className: "series-item series-item--chart", key: `xaxis-anchors-2-${fe}` }, /* @__PURE__ */ n.createElement(Mn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(zn, { className: "accordion__button accordion__button" }, "Anchor ", fe + 1, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (xe) => {
          xe.preventDefault();
          const Me = [...e.xAxis.anchors];
          Me.splice(fe, 1), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: Me
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[fe].value ? e.xAxis.anchors[fe].value : "",
        onChange: (xe) => {
          xe.preventDefault();
          const Me = [...e.xAxis.anchors];
          Me[fe].value = xe.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: Me
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[fe].color ? e.xAxis.anchors[fe].color : "",
        onChange: (xe) => {
          xe.preventDefault();
          const Me = [...e.xAxis.anchors];
          Me[fe].color = xe.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: Me
            }
          });
        }
      }
    )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
      "select",
      {
        value: e.xAxis.anchors[fe].lineStyle || "",
        onChange: (xe) => {
          const Me = [...e.xAxis.anchors];
          Me[fe].lineStyle = xe.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: Me
            }
          });
        }
      },
      /* @__PURE__ */ n.createElement("option", null, "Select"),
      E.map((xe) => /* @__PURE__ */ n.createElement("option", { key: xe.key }, xe.value))
    )))))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (ye) => {
          ye.preventDefault();
          const fe = [...e.xAxis.anchors];
          fe.push({}), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: fe
            }
          });
        }
      },
      "Add Anchor"
    )), G() && e.orientation === "horizontal" && /* @__PURE__ */ n.createElement("div", { className: "edit-block" }, /* @__PURE__ */ n.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ n.createElement(zi, { allowZeroExpanded: !0 }, (Pn = (Mt = e.yAxis) == null ? void 0 : Mt.anchors) == null ? void 0 : Pn.map((ye, fe) => /* @__PURE__ */ n.createElement(
      Fn,
      {
        className: "series-item series-item--chart",
        key: `accordion-yaxis-anchors-${fe}`
      },
      /* @__PURE__ */ n.createElement(Mn, { className: "series-item__title" }, /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(zn, { className: "accordion__button accordion__button" }, "Anchor ", fe + 1, /* @__PURE__ */ n.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (xe) => {
            xe.preventDefault();
            const Me = [...e.yAxis.anchors];
            Me.splice(fe, 1), t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: Me
              }
            });
          }
        },
        "Remove"
      )))),
      /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Value"), /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "text",
          value: e.yAxis.anchors[fe].value ? e.yAxis.anchors[fe].value : "",
          onChange: (xe) => {
            xe.preventDefault();
            const Me = [...e.yAxis.anchors];
            Me[fe].value = xe.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: Me
              }
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", null, "Anchor Color"), /* @__PURE__ */ n.createElement(
        "input",
        {
          type: "text",
          value: e.yAxis.anchors[fe].color ? e.yAxis.anchors[fe].color : "",
          onChange: (xe) => {
            xe.preventDefault();
            const Me = [...e.yAxis.anchors];
            Me[fe].color = xe.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: Me
              }
            });
          }
        }
      )), /* @__PURE__ */ n.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ n.createElement(
        "select",
        {
          value: e.yAxis.anchors[fe].lineStyle || "",
          onChange: (xe) => {
            const Me = [...e.yAxis.anchors];
            Me[fe].lineStyle = xe.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: Me
              }
            });
          }
        },
        /* @__PURE__ */ n.createElement("option", null, "Select"),
        E.map((xe) => /* @__PURE__ */ n.createElement("option", { key: xe.key }, xe.value))
      )))
    ))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (ye) => {
          ye.preventDefault();
          const fe = [...e.yAxis.anchors];
          fe.push({}), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: fe
            }
          });
        }
      },
      "Add Anchor"
    )))), /* @__PURE__ */ n.createElement(ya.Regions, { name: "Regions" }), e.visualizationType !== "Box Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, "Columns")), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement(aw, { config: e, updateField: Fe, deleteColumn: dt }), " ")), ue() && /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, "Legend")), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement(
      vt,
      {
        value: (Nn = e.legend) == null ? void 0 : Nn.position,
        section: "legend",
        fieldName: "position",
        label: "Position",
        updateField: Fe,
        options: ["right", "left", "bottom", "top"]
      }
    ), (e.legend.position === "left" || e.legend.position === "right" || !e.legend.position) && e.legend.style === "gradient" && /* @__PURE__ */ n.createElement("span", { style: { color: "red", fontSize: "14px" } }, "Position must be set to top or bottom to use gradient style."), /* @__PURE__ */ n.createElement(
      vt,
      {
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "If using gradient style, limit the legend to five items for better mobile visibility, and position the legend at the top or bottom."))),
        display: !e.legend.hide,
        value: e.legend.style,
        section: "legend",
        fieldName: "style",
        label: "Legend Style",
        updateField: Fe,
        options: On("style")
      }
    ), /* @__PURE__ */ n.createElement(
      vt,
      {
        display: !e.legend.hide && e.legend.style === "gradient",
        value: e.legend.subStyle,
        section: "legend",
        fieldName: "subStyle",
        label: "Gradient Style",
        updateField: Fe,
        options: On("subStyle")
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        display: e.legend.style === "gradient" && !e.legend.hide,
        className: "number-narrow",
        type: "number",
        value: e.legend.tickRotation,
        section: "legend",
        fieldName: "tickRotation",
        label: "Tick Rotation (Degrees)",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: !!e.legend.hide,
        section: "legend",
        fieldName: "hide",
        label: "Hide Legend",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "With a single-series chart, consider hiding the legend to reduce visual clutter.")))
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        display: (Rn = e.preliminaryData) == null ? void 0 : Rn.some((ye) => ye.label && ye.type === "suppression" && ye.value),
        value: e.legend.hideSuppressedLabels,
        section: "legend",
        fieldName: "hideSuppressedLabels",
        label: "Hide Suppressed Labels",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.`)))
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        display: (tr = e.preliminaryData) == null ? void 0 : tr.some((ye) => ye.label && ye.type === "suppression" && ye.value),
        value: e.legend.hideSuppressionLink,
        section: "legend",
        fieldName: "hideSuppressionLink",
        label: "Hide Suppression Definition Link",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Selecting this option will hide the suppression definition link from display.")))
      }
    ), /* @__PURE__ */ n.createElement(
      vt,
      {
        display: ((Un = e.series) == null ? void 0 : Un.length) > 1,
        value: e.legend.behavior,
        section: "legend",
        fieldName: "behavior",
        label: "Legend Behavior (When clicked)",
        updateField: (...[ye, , fe, xe]) => Ke(ye, fe, xe),
        options: ["highlight", "isolate"]
      }
    ), /* @__PURE__ */ n.createElement(
      vt,
      {
        display: De(),
        value: e.legend.colorCode,
        section: "legend",
        fieldName: "colorCode",
        label: "Color code by category",
        initial: "Select",
        updateField: Fe,
        options: Wn(a)
      }
    ), ke() && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.legend.axisAlign,
        fieldName: "axisAlign",
        section: "legend",
        label: "Align to Axis on Isolate",
        updateField: Fe
      }
    ), e.legend.behavior === "highlight" && e.tooltips.singleSeries && /* @__PURE__ */ n.createElement(
      lt,
      {
        value: e.legend.highlightOnHover,
        section: "legend",
        fieldName: "highlightOnHover",
        label: "HIGHLIGHT DATA SERIES ON HOVER",
        updateField: Fe
      }
    ), H && e.legend.behavior === "isolate" && !Ee && /* @__PURE__ */ n.createElement("fieldset", { className: "primary-fieldset edit-block", key: "additional-highlight-values" }, /* @__PURE__ */ n.createElement("label", null, /* @__PURE__ */ n.createElement("span", { className: "edit-label" }, "Isolate Data Series", /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(tt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend."))))), e.legend.seriesHighlight && e.legend.seriesHighlight.map((ye, fe) => /* @__PURE__ */ n.createElement("fieldset", { className: "edit-block", key: `${ye}-${fe}` }, /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "remove-column",
        onClick: (xe) => {
          xe.preventDefault();
          const Me = [...e.legend.seriesHighlight];
          Me.splice(fe, 1), Fe("legend", null, "seriesHighlight", Me), Me.length || y();
        }
      },
      "Remove"
    ), /* @__PURE__ */ n.createElement(
      vt,
      {
        value: e.legend.seriesHighlight[fe],
        fieldName: "seriesHighlight",
        label: "Isolate Value",
        onChange: (xe) => {
          const Me = [...e.legend.seriesHighlight];
          Me.includes(xe.target.value) || (Me[fe] = xe.target.value, Ze([...Me]));
        },
        options: et()
      }
    ))), /* @__PURE__ */ n.createElement(
      "button",
      {
        className: "btn full-width",
        onClick: (ye) => {
          ye.preventDefault();
          const fe = et(), xe = [...e.legend.seriesHighlight];
          if (xe.length < fe.length) {
            const [zt] = fe.filter((Gn) => !xe.includes(Gn));
            xe.push(zt), Ze([...xe]);
          }
        }
      },
      "Add Isolate Value"
    )), /* @__PURE__ */ n.createElement(
      lt,
      {
        display: !e.legend.hide && e.legend.style !== "gradient",
        value: e.legend.reverseLabelOrder,
        section: "legend",
        fieldName: "reverseLabelOrder",
        label: "Reverse Labels",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        display: !e.legend.hide,
        value: ["left", "right"].includes(e.legend.position) ? e.legend.hideBorder.side : e.legend.hideBorder.topBottom,
        section: "legend",
        subsection: "hideBorder",
        fieldName: ["left", "right"].includes(e.legend.position) ? "side" : "topBottom",
        label: "Hide Legend Box",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "Default option for top and bottom legends is No Box..")))
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        display: !e.legend.hide && !["left", "right"].includes(e.legend.position) && e.legend.style !== "gradient",
        value: e.legend.singleRow,
        section: "legend",
        fieldName: "singleRow",
        label: "Single Row Legend",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        display: ["bottom", "top"].includes(e.legend.position) && !e.legend.hide && e.legend.style !== "gradient",
        value: e.legend.verticalSorted,
        section: "legend",
        fieldName: "verticalSorted",
        label: "Vertical sorted Legend",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      lt,
      {
        value: !!e.legend.hide,
        section: "legend",
        fieldName: "hide",
        label: "Hide Legend",
        updateField: Fe,
        tooltip: /* @__PURE__ */ n.createElement(ae, { style: { textTransform: "none" } }, /* @__PURE__ */ n.createElement(ae.Target, null, /* @__PURE__ */ n.createElement(
          tt,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ n.createElement(ae.Content, null, /* @__PURE__ */ n.createElement("p", null, "With a single-series chart, consider hiding the legend to reduce visual clutter.")))
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        value: e.legend.label,
        section: "legend",
        fieldName: "label",
        label: "Title",
        updateField: Fe
      }
    ), /* @__PURE__ */ n.createElement(
      Qe,
      {
        type: "textarea",
        value: e.legend.description,
        updateField: Fe,
        section: "legend",
        fieldName: "description",
        label: "Legend Description"
      }
    ))), Oe() && /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, "Filters")), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement(lw, { config: e, updateField: Fe, rawData: T }))), /* @__PURE__ */ n.createElement(ya.Visual, { name: "Visual" }), e.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement(Fn, null, /* @__PURE__ */ n.createElement(Mn, null, /* @__PURE__ */ n.createElement(zn, null, "Data Table")), /* @__PURE__ */ n.createElement(Bn, null, /* @__PURE__ */ n.createElement(
      iw,
      {
        config: e,
        columns: Object.keys(a[0] || {}),
        updateField: Fe,
        isDashboard: m,
        isLoadedFromUrl: Te
      }
    ), " ")), /* @__PURE__ */ n.createElement(ya.Annotate, { name: "Text Annotations" })),
    e.type !== "Spark Line" && /* @__PURE__ */ n.createElement(Dg, { loadConfig: t, config: e, convertStateToConfig: or })
  )));
}, mm = (e) => {
  let t = "", r = Math.abs(e);
  return r >= 1e9 ? (t = "B", e = e / 1e9) : r >= 1e6 ? (t = "M", e = e / 1e6) : r >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, Wu = (e, t) => {
  var r;
  return e ? (r = e.legend) != null && r.hide ? e != null && e.title ? `dataTableSection__${e.title.replace(/\s/g, "")}` : "dataTableSection" : t : "dataTableSection";
}, Mw = (e) => {
  e.sort((p, m) => p - m);
  const t = Math.floor(e.length / 2), r = e.length % 2 === 0, a = r ? e.slice(0, t) : e.slice(0, t + 1), i = r ? e.slice(t) : e.slice(t + 1), o = Math.floor(a.length / 2), d = r ? (a[o - 1] + a[o]) / 2 : a[o], c = Math.floor(i.length / 2), s = r ? (i[c - 1] + i[c]) / 2 : i[c];
  return { q1: d, q3: s };
}, zw = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], ym = (e) => typeof e == "string" ? parseFloat(e.replace(/,/g, "")) : Number(e), hf = (e, t) => {
  if (t.rankByValue) {
    const r = t.series[0].dataKey, a = e.sort((i, o) => ym(i[r]) - ym(o[r]));
    return t.rankByValue === "asc" ? a : a.reverse();
  }
  return e;
}, gm = (e = "#000000", t = !1) => {
  let r = ja(e), a = t ? r.brighten(0.5).hex() : r.saturate(1.3).hex();
  return [e, a, r.darken(0.3).hex()];
};
const vm = (e) => {
  const t = /(?:\.([^.]+))$/, r = /[?&]wt=(csv|json)(?:&|$)/, a = new URL(e, window.location.origin), i = a.pathname, o = a.search, d = t.exec(i);
  if (d && d[1])
    return d[1];
  const c = r.exec(o);
  return c && c[1] ? c[1] : "";
}, Bw = (e) => {
  const { children: t } = e, { config: r, currentViewport: a } = ie.useContext(Et), i = () => {
    let o = ["legend-wrapper", "d-flex", "flex-nowrap", "w-100"];
    const { legend: d } = r;
    return (d.position === "bottom" || d.position === "top" || ga(a)) && (o = o.filter((c) => c !== "flex-nowrap"), o.push("flex-wrap")), o.join(" ");
  };
  return /* @__PURE__ */ n.createElement("div", { className: i() }, ...t);
}, mT = ({
  configUrl: e,
  config: t,
  isEditor: r = !1,
  isDebug: a = !1,
  isDashboard: i = !1,
  setConfig: o,
  setEditing: d,
  hostname: c,
  link: s,
  setSharedFilter: p,
  setSharedFilterValue: m,
  dashboardConfig: v
}) => {
  var fn, On, Wn, on, er, or, Xn, Ht, gn, Tn, qn, jn, $n;
  const g = new _m(), [A, k] = ie.useState(!0), E = ie.useRef(null), [T, b] = ie.useState(null), [y, N] = ie.useState({}), [C, P] = ie.useState(jt.cloneDeep(t == null ? void 0 : t.data) || []), [O, K] = ie.useState(void 0), [W, J] = ie.useState(void 0), [j, B] = ie.useState(
    t && ((On = (fn = t == null ? void 0 : t.legend) == null ? void 0 : fn.seriesHighlight) != null && On.length) ? [...(Wn = t == null ? void 0 : t.legend) == null ? void 0 : Wn.seriesHighlight] : []
  ), [Z, te] = ie.useState("lg"), [V, ee] = ie.useState([0, 0]), [ce, re] = ie.useState(), [G, U] = ie.useState(), [q, H] = ie.useState(!1), [oe, ue] = ie.useState(!1), [ke, De] = ie.useState([]), [pe] = ie.useState(`cove-${Math.random().toString(16).slice(-4)}`), [Be, qe] = ie.useState({
    data: [],
    isActive: !1,
    isBrushing: !1
  }), { description: Pe, visualizationType: ve } = y, $e = ie.useRef(null), z = ie.useRef(null), Re = (Te) => {
    ue(Te);
  };
  a && console.log("Chart config, isEditor", y, r);
  let { legend: be, title: He } = y;
  r && (!He || He === "") && (He = "Chart Title"), y.table && (!((on = y.table) != null && on.label) || ((er = y.table) == null ? void 0 : er.label) === "") && (y.table.label = "Data Table");
  const { lineDatapointClass: Ve, contentClasses: Oe, sparkLineStyles: Ge } = _g(y), Xe = ie.useId(), rt = () => Hc(y.visualizationType, W, y.allowLineToBarGraph), Ue = async () => {
    var Te;
    if (y.dataUrl) {
      const _e = new URL(y.runtimeDataUrl || y.dataUrl, window.location.origin);
      let se = Object.fromEntries(new URLSearchParams(_e.search)), it = !1;
      if ((Te = y.filters) == null || Te.forEach((Ct) => {
        Ct.type === "url" && se[Ct.queryParameter] !== decodeURIComponent(Ct.active) && (se[Ct.queryParameter] = Ct.active, it = !0);
      }), (!y.formattedData || y.formattedData.urlFiltered) && !it)
        return;
      let ft = `${_e.origin}${_e.pathname}${Object.keys(se).map((Ct, Yt) => {
        let Zt = Yt === 0 ? "?" : "&";
        return Zt += Ct + "=", Zt += se[Ct], Zt;
      }).join("")}`, dt = [];
      try {
        const Ct = vm(_e.href);
        Ct === "csv" || wp(ft) ? dt = await fetch(ft).then((Yt) => Yt.text()).then((Yt) => Fp.parse(Yt, {
          header: !0,
          dynamicTyping: !0,
          skipEmptyLines: !0
        }).data) : Ct === "json" || Tp(ft) ? dt = await fetch(ft).then((Yt) => Yt.json()) : dt = [];
      } catch {
        console.error(`Cannot parse URL: ${ft}`), dt = [];
      }
      y.dataDescription && (dt = g.autoStandardize(dt), dt = g.developerStandardize(dt, y.dataDescription)), Object.assign(dt, { urlFiltered: !0 }), dt = hf(dt, y), Ne({ ...y, runtimeDataUrl: ft, data: dt, formattedData: dt }), dt && (P(dt), K(dt), J(Ni(y.filters, dt)));
    }
  }, ze = async () => {
    const Te = jt.cloneDeep(t) || await (await fetch(e)).json();
    let _e = Te.data || [];
    const se = Te.filters ? Te.filters.filter((dt) => dt.type === "url").length > 0 : !1;
    if (Te.dataUrl && !se)
      try {
        const dt = vm(Te.dataUrl);
        (dt === "csv" || wp(Te.dataUrl)) && (_e = await fetch(Te.dataUrl + `?v=${Up()}`).then((Ct) => Ct.text()).then((Ct) => (Ct = Ct.replace(/(".*?")|,/g, (...Zt) => Zt[1] || "|"), Ct = Ct.replace(/["]+/g, ""), Fp.parse(Ct, {
          //quotes: "true",  // dont need these
          //quoteChar: "'",  // has no effect that I can tell
          header: !0,
          dynamicTyping: !0,
          skipEmptyLines: !0,
          delimiter: "|"
          // we are using pipe symbol as delimiter so setting this explicitly for Papa.parse
        }).data))), (dt === "json" || Tp(Te.dataUrl)) && (_e = await fetch(Te.dataUrl + `?v=${Up()}`).then((Ct) => Ct.json()));
      } catch {
        console.error(`COVE: Cannot parse URL: ${Te.dataUrl}`), _e = [];
      }
    Te.dataDescription && (_e = g.autoStandardize(_e), _e = g.developerStandardize(_e, Te.dataDescription)), _e = hf(_e, Te), _e && (P(_e), K(_e)), Te !== void 0 && Te.table !== void 0 && (!Te.table || !Te.table.showVertical) && (Te.table = Te.table || {}, Te.table.showVertical = !1);
    let it = { ...pf, ...Te };
    it.visualizationType === "Box Plot" && (it.legend.hide = !0), it.table.show === void 0 && (it.table.show = !i), it.series.forEach((dt) => {
      (dt.tooltip === void 0 || dt.tooltip === null) && (dt.tooltip = !0), dt.axis || (dt.axis = "Left");
    }), _e && (it.data = _e);
    const ft = { ...zg(it) };
    Ne(ft, _e);
  }, Ne = (Te, _e) => {
    var Ct, Yt, Zt;
    const se = jt.cloneDeep(Te);
    let it = _e || C;
    it = hf(it, se), Object.keys(pf).forEach((at) => {
      se[at] && typeof se[at] == "object" && !Array.isArray(se[at]) && (se[at] = { ...pf[at], ...se[at] });
    });
    let ft = [];
    if (se.exclusions && se.exclusions.active)
      if (se.xAxis.type === "categorical" && ((Ct = se.exclusions.keys) == null ? void 0 : Ct.length) > 0)
        ft = it.filter((at) => !se.exclusions.keys.includes(at[se.xAxis.dataKey]));
      else if (Dn(se.xAxis) && (se.exclusions.dateStart || se.exclusions.dateEnd) && se.xAxis.dateParseFormat) {
        const at = (Wt) => new Date(Wt).getTime();
        let tn = at(se.exclusions.dateStart), cn = at(se.exclusions.dateEnd) + 86399999, qt = typeof tn !== void 0 && isNaN(tn) === !1, Sn = typeof cn !== void 0 && isNaN(cn) === !1;
        qt && Sn ? ft = it.filter(
          (Wt) => at(Wt[se.xAxis.dataKey]) >= tn && at(Wt[se.xAxis.dataKey]) <= cn
        ) : qt ? ft = it.filter((Wt) => at(Wt[se.xAxis.dataKey]) >= tn) : Sn && (ft = it.filter((Wt) => at(Wt[se.xAxis.dataKey]) <= cn));
      } else
        ft = _e || C;
    else
      ft = _e || C;
    K(ft);
    let dt = [];
    if (se.filters) {
      const at = nv(se.filters, ft);
      dt = Ni(at, ft), J(dt);
    }
    if (se.xAxis.type === "date-time" && y.orientation === "horizontal" && (se.xAxis.type = "date"), se.runtime = {}, se.runtime.series = se.dynamicSeries ? [] : se.series, se.runtime.seriesLabels = {}, se.runtime.seriesLabelsAll = [], se.runtime.originalXAxis = se.xAxis, se.dynamicSeries) {
      let at = _e || se.formattedData || se.data;
      at && at.length && at.length > 0 && Object.keys(at[0]).forEach((tn) => {
        tn !== se.xAxis.dataKey && (!se.filters || se.filters.filter((cn) => cn.columnName === tn).length === 0) && (!se.columns || Object.keys(se.columns).indexOf(tn) === -1) && se.runtime.series.push({
          dataKey: tn,
          type: se.dynamicSeriesType,
          lineType: se.dynamicSeriesLineType,
          tooltip: !0
        });
      });
    }
    if (se.visualizationType === "Pie" ? (se.runtime.seriesKeys = (_e || it).map((at) => at[se.xAxis.dataKey]), se.runtime.seriesLabelsAll = se.runtime.seriesKeys) : se.runtime.seriesKeys = se.runtime.series ? se.runtime.series.map((at) => (se.runtime.seriesLabels[at.dataKey] = at.name || at.label || at.dataKey, se.runtime.seriesLabelsAll.push(at.name || at.dataKey), at.dataKey)) : [], se.visualizationType === "Box Plot" && se.series) {
      let at = ft ? ft.map((Ee) => Ee[se.xAxis.dataKey]) : it.map((Ee) => Ee[se.xAxis.dataKey]), tn = ft ? ft.map((Ee) => {
        var et;
        return Number(Ee[(et = se == null ? void 0 : se.series[0]) == null ? void 0 : et.dataKey]);
      }) : it.map((Ee) => {
        var et;
        return Number(Ee[(et = se == null ? void 0 : se.series[0]) == null ? void 0 : et.dataKey]);
      });
      const qt = function(Ee) {
        return Ee.filter(function(et, Ze, Ke) {
          return Ke.indexOf(et) === Ze;
        });
      }(at);
      let Sn = [];
      const Wt = [];
      if (!qt)
        return;
      qt.forEach((Ee) => {
        try {
          if (!Ee)
            throw new Nt("No groups resolved in box plots");
          let et = ft ? ft.filter((X) => X[se.xAxis.dataKey] === Ee) : it.filter((X) => X[se.xAxis.dataKey] === Ee), Ze = et.map((X) => {
            var me;
            return Number(X[(me = se == null ? void 0 : se.series[0]) == null ? void 0 : me.dataKey]);
          }), Ke = Ze.sort((X, me) => X - me);
          const Vt = Mw(Ke);
          if (!et)
            throw new Nt("boxplots dont have data yet");
          if (!Wt)
            throw new Nt("boxplots dont have plots yet");
          se.boxplot.firstQuartilePercentage === "" && (se.boxplot.firstQuartilePercentage = 0), se.boxplot.thirdQuartilePercentage === "" && (se.boxplot.thirdQuartilePercentage = 0);
          const At = Vt.q1, Xt = Vt.q3, Rt = Xt - At, Qt = At - (Xt - At) * 1.5, pn = Xt + (Xt - At) * 1.5, _t = Ke.filter((X) => X < Qt || X > pn);
          let x = Ze;
          x = x.filter((X) => !_t.includes(X));
          const D = fs(Ze) || 0, M = ds([D, At - 1.5 * Rt]);
          Wt.push({
            columnCategory: Ee,
            columnMax: fs([ds(Ze), At + 1.5 * Rt]),
            columnThirdQuartile: Number(Xt).toFixed(se.dataFormat.roundTo),
            columnMedian: Number(uv(Ze)).toFixed(se.dataFormat.roundTo),
            columnFirstQuartile: At.toFixed(se.dataFormat.roundTo),
            columnMin: M,
            columnTotal: Ze.reduce((X, me) => X + me, 0),
            columnSd: Number(ov(Ze)).toFixed(se.dataFormat.roundTo),
            columnMean: Number(sv(Ze)).toFixed(se.dataFormat.roundTo),
            columnIqr: Number(Rt).toFixed(se.dataFormat.roundTo),
            columnLowerBounds: M,
            columnUpperBounds: fs([ds(Ke), At + 1.5 * Rt]),
            columnOutliers: _t,
            values: Ze,
            nonOutlierValues: x
          });
        } catch (et) {
          console.error("COVE: ", et.message);
        }
      }), Sn = JSON.parse(JSON.stringify(Wt)), Sn.map((Ee) => (Ee.columnIqr = void 0, Ee.nonOutlierValues = void 0, Ee.columnLowerBounds = void 0, Ee.columnUpperBounds = void 0, null)), se.boxplot.allValues = tn, se.boxplot.categories = qt, se.boxplot.plots = Wt, se.boxplot.tableData = Sn;
    }
    se.visualizationType === "Combo" && se.series && (se.runtime.barSeriesKeys = [], se.runtime.lineSeriesKeys = [], se.runtime.areaSeriesKeys = [], se.runtime.forecastingSeriesKeys = [], se.series.forEach((at) => {
      at.type === "Area Chart" && se.runtime.areaSeriesKeys.push(at), at.type === "Forecasting" && se.runtime.forecastingSeriesKeys.push(at), (at.type === "Bar" || at.type === "Combo") && se.runtime.barSeriesKeys.push(at.dataKey), (at.type === "Line" || at.type === "dashed-sm" || at.type === "dashed-md" || at.type === "dashed-lg") && se.runtime.lineSeriesKeys.push(at.dataKey), at.type === "Combo" && (at.type = "Bar");
    })), se.visualizationType === "Forecasting" && se.series && (se.runtime.forecastingSeriesKeys = [], se.series.forEach((at) => {
      at.type === "Forecasting" && se.runtime.forecastingSeriesKeys.push(at);
    })), se.visualizationType === "Area Chart" && se.series && (se.runtime.areaSeriesKeys = [], se.series.forEach((at) => {
      se.runtime.areaSeriesKeys.push({ ...at, type: "Area Chart" });
    })), se.visualizationType === "Bar" && se.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(se.visualizationType) ? (se.runtime.xAxis = se.yAxis.yAxis ? se.yAxis.yAxis : se.yAxis, se.runtime.yAxis = se.xAxis.xAxis ? se.xAxis.xAxis : se.xAxis, se.runtime.yAxis.labelOffset *= -1, se.runtime.horizontal = !1, se.orientation = "horizontal", se.yAxis.type = se.yAxis.type === "categorical" ? "linear" : se.yAxis.type) : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(se.visualizationType) && !rt() ? (se.runtime.xAxis = se.xAxis, se.runtime.yAxis = se.yAxis, se.runtime.horizontal = !1, se.orientation = "vertical") : (se.runtime.xAxis = se.xAxis, se.runtime.yAxis = se.yAxis, se.runtime.horizontal = !1), se.runtime.uniqueId = Date.now(), se.runtime.editorErrorMessage = se.visualizationType === "Pie" && !se.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", se.runtime.editorErrorMessage = se.visualizationType === "Sankey" && !se.description ? "SUBTEXT/CITATION field is empty: A description of the Sankey Diagram data must be inputted." : "", (Yt = se.legend.seriesHighlight) != null && Yt.length && B((Zt = se.legend) == null ? void 0 : Zt.seriesHighlight), N(se);
  }, ot = (Te, _e) => {
    let se = y.visualizationType === "Bar" && y.visualizationSubType === "horizontal" ? y.xAxis.dataKey : y.yAxis.sortKey, it = parseFloat(Te[se]), ft = parseFloat(_e[se]);
    return it < ft ? y.sortData === "ascending" ? 1 : -1 : it > ft ? y.sortData === "ascending" ? -1 : 1 : 0;
  }, nt = new gg((Te) => {
    for (let _e of Te) {
      let { width: se, height: it } = _e.contentRect, ft = 30;
      se = r ? se - 350 : se;
      let Ct = vg(se);
      te(Ct), _e.target.dataset.lollipop === "true" && (se = se - 2.5), se = se - ft, ee([se, it]);
    }
  }), mt = ie.useCallback((Te) => {
    Te !== null && nt.observe(Te), U(Te);
  }, []), wt = (Te) => Object.keys(Te).length === 0;
  ie.useEffect(() => {
    ze();
  }, [(or = t == null ? void 0 : t.data) != null && or.length ? t.data : null]), ie.useEffect(() => {
    Ue();
  }, [JSON.stringify(y.filters)]), ie.useEffect(() => {
    G && !wt(y) && !q && (Og("cove_loaded", { config: y }), H(!0));
  }, [G, y]), ie.useEffect(() => {
    const Te = (_e) => {
      let se = [];
      se.push(_e.detail), re(se);
    };
    return Fg("cove_filterData", (_e) => Te(_e)), () => {
      Mg("cove_filterData", Te);
    };
  }, [y]), ie.useEffect(() => {
    if (ce && ce[0] && !ce[0].hasOwnProperty("active")) {
      let _e = { ...y };
      delete _e.filters, N(_e), J(Ni(ce, O));
    }
    if (ce && ce.length > 0 && ce.length > 0 && ce[0].hasOwnProperty("active")) {
      let Te = { ...y, filters: ce };
      N(Te), J(Ni(ce, O));
    }
  }, [ce]), ie.useEffect(() => {
    ["Bump Chart"].includes(y.visualizationType) && N({
      ...y,
      xAxis: {
        ...y.xAxis,
        type: "date-time"
      }
    });
  }, [y.visualizationType]), ie.useEffect(() => {
    var Te;
    if (C && y.xAxis && ((Te = y.runtime) != null && Te.seriesKeys)) {
      const _e = ["Paired Bar", "Deviation Bar"].includes(y.visualizationType) ? y.twoColor.palette : y.palette, se = { ...pr, ...ks };
      let it = y.customColors || se[_e], ft = y.runtime.seriesKeys.length, dt;
      for (; ft > it.length; )
        it = it.concat(it);
      it = it.slice(0, ft), dt = () => Bi({
        domain: y.runtime.seriesLabelsAll,
        range: it,
        unknown: null
      }), b(dt), k(!1);
    }
    y && C && y.sortData && C.sort(ot);
  }, [y, C]);
  const xt = (Te) => {
    if (j.length + 1 === y.runtime.seriesKeys.length && y.visualizationType !== "Forecasting") {
      Pt();
      return;
    }
    const _e = [...j];
    let se = Te.datum;
    y.runtime.seriesLabels && y.runtime.seriesKeys.forEach((it) => {
      y.runtime.seriesLabels[it] === Te.datum && (se = it);
    }), _e.indexOf(se) !== -1 ? _e.splice(_e.indexOf(se), 1) : _e.push(se), B(_e);
  }, Pt = () => {
    try {
      const Te = $e.current;
      if (!Te)
        throw new Nt("No legend available to set previous focus on.");
      Te.focus();
    } catch (Te) {
      console.error("COVE:", Te.message);
    }
    B([]);
  }, ln = y.orientation === "horizontal" ? "yAxis" : "xAxis", Gt = (Te, _e = !0) => {
    let se = cy(y.runtime[ln].dateParseFormat)(Te);
    return se || (_e && (y.runtime.editorErrorMessage = `Error parsing date "${Te}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, Ut = (Te, _e) => {
    var it, ft;
    let se = Ku(y.runtime[ln].dateDisplayFormat)(Te);
    if ((it = y.runtime[ln].dateDisplayFormat) != null && it.includes("%b.") && se.includes("May.") && (se = se.replace(/May\./g, "May")), y.xAxis.showYearsOnce && ((ft = y.runtime[ln].dateDisplayFormat) != null && ft.includes("%Y")) && _e) {
      const dt = Ku(y.runtime[ln].dateDisplayFormat)(_e), Ct = se.match(/\d{4}/), Yt = dt.match(/\d{4}/);
      Ct && Yt && Ct[0] === Yt[0] && (se = se.replace(Ct, ""));
    }
    return se;
  }, yt = (Te) => Ku(y.tooltips.dateDisplayFormat)(Te), Tt = (Te, _e, se = !1, it, ft, dt, { index: Ct, length: Yt } = { index: null, length: null }) => {
    if (isNaN(Te) || !Te)
      return Te;
    const Zt = Te < 0;
    (_e === void 0 || !_e) && (_e = "left"), Zt && (Te = Math.abs(Te));
    let {
      dataFormat: {
        commas: at,
        abbreviated: tn,
        roundTo: cn,
        prefix: qt,
        suffix: Sn,
        rightRoundTo: Wt,
        bottomRoundTo: Ee,
        rightPrefix: et,
        rightSuffix: Ze,
        bottomPrefix: Ke,
        bottomSuffix: Vt,
        bottomAbbreviated: At,
        onlyShowTopPrefixSuffix: Xt
      }
    } = y;
    String(Te).indexOf(",") !== -1 && (Te = Te.replaceAll(",", ""));
    let Rt = Te, Qt = {
      useGrouping: !!at
      // for old chart data table to work right cant just leave this to undefined
    };
    if (_e === "left" || _e === void 0) {
      let x;
      dt !== void 0 ? x = dt ? Number(dt) : 0 : x = cn ? Number(cn) : 0, Qt = {
        useGrouping: dt ? !0 : !!y.dataFormat.commas,
        minimumFractionDigits: x,
        maximumFractionDigits: x
      };
    }
    _e === "right" && (Qt = {
      useGrouping: !!y.dataFormat.rightCommas,
      minimumFractionDigits: Wt ? Number(Wt) : 0,
      maximumFractionDigits: Wt ? Number(Wt) : 0
    });
    const pn = () => y.forestPlot.type === "Logarithmic" && !Ee ? 2 : Number(Ee) ? Number(Ee) : 0;
    if (_e === "bottom" && (Qt = {
      useGrouping: !!y.dataFormat.bottomCommas,
      minimumFractionDigits: pn(),
      maximumFractionDigits: pn()
    }), Te = jp(Te), isNaN(Te))
      return y.runtime.editorErrorMessage = `Unable to parse number from data ${Rt}. Try reviewing your data and selections in the Data Series section.`, Rt;
    if (!y.dataFormat)
      return Te;
    if (y.dataCutoff) {
      let x = jp(y.dataCutoff);
      Te < x && (Te = x);
    }
    _e === "left" && at && tn && se || _e === "bottom" && at && tn && se ? Te = Te : Te = Te.toLocaleString("en-US", Qt);
    let _t = "";
    if (tn && _e === "left" && se && (Te = mm(parseFloat(Te))), At && _e === "bottom" && se && (Te = mm(parseFloat(Te))), it && _e === "left")
      _t = it + _t;
    else {
      const x = Xt && Yt - 1 !== Ct;
      qt && _e === "left" && !x && (_t += qt);
    }
    return et && _e === "right" && (_t += et), Ke && _e === "bottom" && (_t += Ke), _t += Te, ft && _e === "left" ? _t += ft : Sn && _e === "left" && !Xt && (_t += Sn), Ze && _e === "right" && (_t += Ze), Vt && _e === "bottom" && (_t += Vt), Zt && (_t = "-" + _t), String(_t);
  }, Dt = () => {
    if (y.visualizationType === "Sankey" || y.visualizationType === "Forecasting" || y.visualizationType === "Forest Plot")
      return !1;
    if (y.visualizationType === "Pie") {
      if ((y == null ? void 0 : y.yAxis.dataKey) === void 0)
        return !0;
    } else if (((y == null ? void 0 : y.series) === void 0 || !((y == null ? void 0 : y.series.length) > 0)) && !(y != null && y.dynamicSeries))
      return !0;
    return !y.xAxis.dataKey;
  }, nn = (Te, _e) => {
    if (Te === null || Te === "" || Te === void 0)
      return "";
    if (typeof Te == "string" && Te.length > 0 && y.legend.type === "equalnumber")
      return Te;
    let se = Te, it;
    if (Object.keys(y.columns).length > 0 && Object.keys(y.columns).forEach(function(ft) {
      var dt = y.columns[ft];
      dt.name === _e && (it = dt);
    }), it === void 0 && (it = y.type === "chart" ? y.dataFormat : y.primary, it.useCommas = it.commas, it.roundToPlace = it.roundTo ? it.roundTo : ""), it) {
      let ft = !1, dt = 0;
      Number(Te) && (it.roundToPlace >= 0 && (ft = it.roundToPlace ? it.roundToPlace !== "" || it.roundToPlace !== null : !1, dt = it.roundToPlace ? Number(it.roundToPlace) : 0, it.hasOwnProperty("roundToPlace") && ft && (se = Number(Te).toFixed(dt))), it.hasOwnProperty("useCommas") && it.useCommas === !0 && (se = Number(Te).toLocaleString("en-US", {
        style: "decimal",
        minimumFractionDigits: ft ? dt : 0,
        maximumFractionDigits: ft ? dt : 5
      }))), se = (it.prefix || "") + se + (it.suffix || "");
    }
    return se;
  }, yn = () => {
    const Te = (se) => {
      se && se.preventDefault();
      let it = { ...y };
      delete it.newViz, Ne(it);
    }, _e = {
      position: "relative",
      height: "100vh",
      width: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gridArea: "content"
    };
    return /* @__PURE__ */ n.createElement("section", { className: "waiting", style: _e }, /* @__PURE__ */ n.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ n.createElement("h3", null, "Finish Configuring"), /* @__PURE__ */ n.createElement("p", null, "Set all required options to the left and confirm below to display a preview of the chart."), /* @__PURE__ */ n.createElement(
      ws,
      {
        className: "btn",
        style: { margin: "1em auto" },
        disabled: Dt(),
        onClick: (se) => Te(se)
      },
      "I'm Done"
    )));
  }, Nt = () => {
    const Te = {
      position: "absolute",
      background: "white",
      zIndex: "999",
      height: "100vh",
      width: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gridArea: "content"
    };
    return /* @__PURE__ */ n.createElement("section", { className: "waiting", style: Te }, /* @__PURE__ */ n.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ n.createElement("h3", null, "Error With Configuration"), /* @__PURE__ */ n.createElement("p", null, y.runtime.editorErrorMessage)));
  }, un = (Te) => {
    try {
      if (!Te)
        throw new Nt("COVE: No rowObj in applyLegendToRow");
      if (y.type === "navigation") {
        let _e = pr[y.color] || pr.bluegreenreverse;
        return gm(_e[3]);
      }
      return gm();
    } catch (_e) {
      console.error("COVE: ", _e);
    }
  }, Kt = (Te) => {
    var _e;
    return Array.isArray(Te) ? y.visualizationType === "Forecasting" ? Te : (_e = y == null ? void 0 : y.xAxis) != null && _e.dataKey ? g.cleanData(Te, y.xAxis.dataKey) : Te : [];
  }, Fe = (Te) => Te;
  let bt = /* @__PURE__ */ n.createElement(Ug, null);
  const xn = (Te) => {
    if (!(!Te || !Te.toLowerCase))
      return Te.toLowerCase().replaceAll(/ /g, "-");
  }, Ot = () => {
    var se;
    const Te = (be == null ? void 0 : be.position) === "bottom" || ga(Z), _e = ["chart-container", "p-relative"];
    return be != null && be.position && (ga(Z) && (be == null ? void 0 : be.position) !== "top" ? _e.push("legend-bottom") : _e.push(`legend-${be.position}`)), be != null && be.hide && _e.push("legend-hidden"), Ve && _e.push(Ve), y.barHasBorder || _e.push("chart-bar--no-border"), (se = y.brush) != null && se.active && (v == null ? void 0 : v.type) === "dashboard" && (!Te || be.hide) && _e.push("dashboard-brush"), _e.push(...Oe), _e;
  }, Ln = () => {
    var se, it;
    const Te = ["subtext "], _e = (be == null ? void 0 : be.position) === "bottom" || ga(Z);
    return y.isResponsiveTicks && Te.push("subtext--responsive-ticks "), (se = y.brush) != null && se.active && !_e && Te.push("subtext--brush-active "), (it = y.brush) != null && it.active && y.legend.hide && Te.push("subtext--brush-active "), Te;
  };
  if (!A) {
    const Te = /* @__PURE__ */ n.createElement("a", { href: `#data-table-${y.dataKey}`, className: "margin-left-href" }, y.dataKey, " (Go to Table)");
    bt = /* @__PURE__ */ n.createElement(n.Fragment, null, r && /* @__PURE__ */ n.createElement(Fw, null), /* @__PURE__ */ n.createElement(mf.Responsive, { isEditor: r }, y.newViz && /* @__PURE__ */ n.createElement(yn, null), y.newViz === void 0 && r && y.runtime && ((Xn = y.runtime) == null ? void 0 : Xn.editorErrorMessage) && /* @__PURE__ */ n.createElement(Nt, null), !Dt() && !y.newViz && /* @__PURE__ */ n.createElement(
      "div",
      {
        className: `cdc-chart-inner-container cove-component__content type-${xn(
          y.visualizationType
        )}`,
        "aria-label": zf(y),
        tabIndex: 0
      },
      /* @__PURE__ */ n.createElement(
        Hg,
        {
          showTitle: y.showTitle,
          isDashboard: i,
          title: He,
          superTitle: y.superTitle,
          classes: ["chart-title", `${y.theme}`, "cove-component__header"],
          style: void 0
        }
      ),
      /* @__PURE__ */ n.createElement("div", { className: Ot().join(" ") }, (y == null ? void 0 : y.introText) && y.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement("section", { className: "introText " }, Mi(y.introText)), y.filters && !ce && y.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement(
        Wp,
        {
          config: y,
          setConfig: N,
          setFilteredData: J,
          filteredData: W,
          excludedData: O,
          filterData: Ni,
          dimensions: V
        }
      ), /* @__PURE__ */ n.createElement(zp, { skipId: Wu(y, Xe), skipMessage: "Skip Over Chart Container" }), ((Ht = y.annotations) == null ? void 0 : Ht.length) > 0 && /* @__PURE__ */ n.createElement(
        zp,
        {
          skipId: Wu(y, Xe),
          skipMessage: "Skip over annotations",
          key: "skip-annotations"
        }
      ), /* @__PURE__ */ n.createElement(Bw, null, /* @__PURE__ */ n.createElement(
        "div",
        {
          className: be.hide || ga(Z) || be.position === "bottom" || be.position === "top" || ve === "Sankey" ? "w-100" : "w-75"
        },
        !["Spark Line", "Line", "Sankey", "Pie", "Sankey"].includes(y.visualizationType) && /* @__PURE__ */ n.createElement("div", { ref: z, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Uo, null, (_e) => /* @__PURE__ */ n.createElement(df, { ref: E, parentWidth: _e.width, parentHeight: _e.height }))),
        y.visualizationType === "Pie" && /* @__PURE__ */ n.createElement(Uo, { className: "justify-content-center d-flex", style: { width: "100%" } }, (_e) => /* @__PURE__ */ n.createElement(BE, { ref: E, parentWidth: _e.width, parentHeight: _e.height })),
        y.visualizationType === "Line" && (rt() ? /* @__PURE__ */ n.createElement("div", { ref: z, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Uo, null, (_e) => /* @__PURE__ */ n.createElement(df, { ref: E, parentWidth: _e.width, parentHeight: _e.height }))) : /* @__PURE__ */ n.createElement("div", { ref: z, style: { width: "100%" } }, /* @__PURE__ */ n.createElement(Uo, null, (_e) => /* @__PURE__ */ n.createElement(df, { ref: E, parentWidth: _e.width, parentHeight: _e.height })))),
        y.visualizationType === "Spark Line" && /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
          Wp,
          {
            config: y,
            setConfig: N,
            setFilteredData: J,
            filteredData: W,
            excludedData: O,
            filterData: Ni,
            dimensions: V
          }
        ), (y == null ? void 0 : y.introText) && /* @__PURE__ */ n.createElement("section", { className: "introText", style: { padding: "0px 0 35px" } }, Mi(y.introText)), /* @__PURE__ */ n.createElement("div", { style: { height: "100px", width: "100%", ...Ge } }, /* @__PURE__ */ n.createElement(Uo, null, (_e) => /* @__PURE__ */ n.createElement(Mk, { width: _e.width, height: _e.height }))), Pe && /* @__PURE__ */ n.createElement("div", { className: "subtext", style: { padding: "35px 0 15px" } }, Mi(Pe))),
        y.visualizationType === "Sankey" && /* @__PURE__ */ n.createElement(Uo, { "aria-hidden": "true" }, (_e) => /* @__PURE__ */ n.createElement(pS, { runtime: y.runtime, width: _e.width, height: _e.height }))
      ), !y.legend.hide && y.visualizationType !== "Spark Line" && y.visualizationType !== "Sankey" && /* @__PURE__ */ n.createElement(nw, { ref: $e, skipId: Wu(y, Xe) })), i && y.table && y.table.show && y.table.showDataTableLink ? Te : s && s, Pe && y.visualizationType !== "Spark Line" && /* @__PURE__ */ n.createElement("div", { className: Ln().join("") }, Mi(Pe)), /* @__PURE__ */ n.createElement(zd.Section, { classes: ["download-buttons"] }, y.table.showDownloadImgButton && /* @__PURE__ */ n.createElement(
        zd.Button,
        {
          text: "Download Image",
          title: "Download Chart as Image",
          type: "image",
          state: y,
          elementToCapture: pe
        }
      ), y.table.showDownloadPdfButton && /* @__PURE__ */ n.createElement(
        zd.Button,
        {
          text: "Download PDF",
          title: "Download Chart as PDF",
          type: "pdf",
          state: y,
          elementToCapture: pe
        }
      )), (y.xAxis.dataKey && y.table.show && y.visualizationType !== "Spark Line" && y.visualizationType !== "Sankey" || y.visualizationType === "Sankey" && y.table.show) && /* @__PURE__ */ n.createElement(
        jg,
        {
          config: y,
          rawData: y.visualizationType === "Sankey" ? (Tn = (gn = y == null ? void 0 : y.data) == null ? void 0 : gn[0]) == null ? void 0 : Tn.tableData : y.table.customTableConfig ? Ni(y.filters, y.data) : y.data,
          runtimeData: y.visualizationType === "Sankey" ? (jn = (qn = y == null ? void 0 : y.data) == null ? void 0 : qn[0]) == null ? void 0 : jn.tableData : W || O,
          expandDataTable: y.table.expanded,
          columns: y.columns,
          displayDataAsText: nn,
          displayGeoName: Fe,
          applyLegendToRow: un,
          tableTitle: y.table.label,
          indexTitle: y.table.indexLabel,
          vizTitle: He,
          viewport: Z,
          tabbingId: Wu(y, Xe),
          colorScale: T
        }
      ), (($n = y == null ? void 0 : y.annotations) == null ? void 0 : $n.length) > 0 && /* @__PURE__ */ n.createElement(xp.Dropdown, null)),
      (y == null ? void 0 : y.footnotes) && /* @__PURE__ */ n.createElement("section", { className: "footnotes" }, Mi(y.footnotes))
    )));
  }
  const rn = {
    brushConfig: Be,
    capitalize: (Te) => Te.charAt(0).toUpperCase() + Te.slice(1),
    clean: Kt,
    colorPalettes: pr,
    colorScale: T,
    config: y,
    currentViewport: Z,
    dashboardConfig: v,
    debugSvg: a,
    dimensions: V,
    dynamicLegendItems: ke,
    excludedData: O,
    formatDate: Ut,
    formatNumber: Tt,
    formatTooltipsDate: yt,
    getXAxisData: (Te) => Dn(y.runtime.xAxis) ? Gt(Te[y.runtime.originalXAxis.dataKey]).getTime() : Te[y.runtime.originalXAxis.dataKey],
    getYAxisData: (Te, _e) => Te[_e],
    handleChartAriaLabels: zf,
    handleLineType: fg,
    highlight: xt,
    highlightReset: Pt,
    imageId: pe,
    isDashboard: i,
    isLegendBottom: (be == null ? void 0 : be.position) === "bottom" || ga(Z),
    isDebug: a,
    isDraggingAnnotation: oe,
    handleDragStateChange: Re,
    isEditor: r,
    isNumber: Zu,
    legend: be,
    legendRef: $e,
    lineOptions: zw,
    loading: A,
    missingRequiredSections: Dt,
    outerContainerRef: mt,
    parentRef: z,
    parseDate: Gt,
    rawData: jt.cloneDeep(C) ?? {},
    seriesHighlight: j,
    setBrushConfig: qe,
    setConfig: N,
    setDynamicLegendItems: De,
    setEditing: d,
    setFilteredData: J,
    setParentConfig: o,
    setSeriesHighlight: B,
    setSharedFilter: p,
    setSharedFilterValue: m,
    svgRef: E,
    tableData: W || O,
    // do not clean table data
    transformedData: Kt(W || O),
    // do this right before passing to components
    twoColorPalette: ks,
    unfilteredData: jt.cloneDeep(C),
    updateConfig: Ne
  };
  return /* @__PURE__ */ n.createElement(Et.Provider, { value: rn }, /* @__PURE__ */ n.createElement(
    mf.VisualizationWrapper,
    {
      config: y,
      isEditor: r,
      currentViewport: Z,
      ref: mt,
      imageId: pe,
      showEditorPanel: y == null ? void 0 : y.showEditorPanel
    },
    bt
  ));
};
export {
  mT as C,
  iw as D,
  pg as F,
  lw as V,
  aw as a,
  Nw as f
};
