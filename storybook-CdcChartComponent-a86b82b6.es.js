import { R as m, r as ue } from "./storybook-index-45401197.es.js";
import { v as Cp, b as bg, g as Eg, f as Sg } from "./storybook-getViewport-7dc50c16.es.js";
import { _ as ea, p as Ap, U as Ai, W as qr, X as It, Y as Lp, Z as Au, $ as Jn, t as Ic, a0 as el, a1 as Md, a2 as Np, a3 as qn, a4 as Pp, a5 as kg, a6 as wg, m as Dp, a7 as Sr, w as il, P as Tg, d as Rg, e as Jo, h as _p, g as Op, j as Cg, y as Ag, S as Lg, a8 as pr, v as ol, b as Lu, z as bm, a9 as Gc, s as Ng, k as Yf, K as Em, N as Sm, Q as Xc, O as km, H as Pg, C as Fp, q as Dg, M as wm, E as _g, r as Og, u as Tm, L as Fg, G as Mg, aa as Nu, a as zg, J as Bg, I as Mp, D as Ig, B as $g, V as Hg, A as Vg } from "./storybook-InputToggle-e5ab6790.es.js";
import { L as hf, u as Wg, p as jg, s as Ug, a as Kg, c as Yg } from "./storybook-coveUpdateWorker-e42c85d9.es.js";
import { B as Pu } from "./storybook-Button-63da743c.es.js";
import { a as En, b as Gf, t as Gg, c as os, L as zp, e as Bp, S as Ip, M as zd, D as Xg } from "./storybook-DataTable-fa1d7944.es.js";
import { H as Oi, T as qg } from "./storybook-index-3b47b3f7.es.js";
import { a as Va, E as Vr, b as mf, L as Zg } from "./storybook-viewports-5c5d7af1.es.js";
import { p as Qg, P as Me } from "./storybook-index-43433e35.es.js";
import { d as Jg } from "./storybook-debounce-cc216a80.es.js";
import { a as ev } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { _ as Je } from "./storybook-lodash-a4231e1c.es.js";
import { _ as ln } from "./storybook-extends-70f3d2a3.es.js";
import { s as fs, t as Rm, a as Cm, b as Am, B as Nr, d as As, c as Mn, C as tv } from "./storybook-linear-bc5fb9aa.es.js";
import { t as nv, u as $p, G as tt, c as Sn, q as Du, v as rv, w as Lm, x as Hp, y as av, z as iv, A as ov, B as lv } from "./storybook-linear-ef79b404.es.js";
import { R as sv } from "./storybook-index-633d712d.es.js";
import { T as ht } from "./storybook-Text-c19e6344.es.js";
import { t as Nm, m as Bd, f as Pm, d as Sc, a as kc, b as wc, n as Vp, o as cv, p as Wp, c as Dm, e as _m } from "./storybook-year-24bd1dc7.es.js";
import { e as Ua, a as Cn, b as An, c as Ln, d as Nn, A as Fi, D as Om } from "./storybook-DataTransform-12e90958.es.js";
import { a as Ge, S as Fm } from "./storybook-Icon-d8cd8abc.es.js";
import { B as jp } from "./storybook-BlurStrokeText-adc27352.es.js";
import { T as ie } from "./storybook-Tooltip-8bb9dfa2.es.js";
import { T as Ue, S as yt, C as Ze } from "./storybook-Inputs-6377cf32.es.js";
import { M as Up } from "./storybook-MultiSelect-fb96d51f.es.js";
import { I as Ka } from "./storybook-InputSelect-76dbb8cb.es.js";
import { A as Tc } from "./storybook-Accordion-aed5218d.es.js";
import { f as Uo, F as Kp, a as uv } from "./storybook-Filters-0b0ab6a2.es.js";
import { n as Yp } from "./storybook-numberFromString-24623c03.es.js";
const yf = (e) => {
  if (e.visualizationType === "Sankey" || e.visualizationType === "Forecasting" || e.visualizationType === "Forest Plot")
    return !1;
  if (e.visualizationType === "Pie") {
    if ((e == null ? void 0 : e.yAxis.dataKey) === void 0)
      return !0;
  } else if (((e == null ? void 0 : e.series) === void 0 || !((e == null ? void 0 : e.series.length) > 0)) && !(e != null && e.dynamicSeries))
    return !0;
  return !e.xAxis.dataKey;
}, dv = (e) => {
  const { updateConfig: t, config: n } = e, r = (i) => {
    i && i.preventDefault();
    let u = { ...n };
    delete u.newViz, t(u);
  }, a = {
    position: "relative",
    height: "100vh",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gridArea: "content"
  };
  return /* @__PURE__ */ m.createElement("section", { className: "waiting", style: a }, /* @__PURE__ */ m.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ m.createElement("h3", null, "Finish Configuring"), /* @__PURE__ */ m.createElement("p", null, "Set all required options to the left and confirm below to display a preview of the chart."), /* @__PURE__ */ m.createElement(
    Pu,
    {
      className: "btn btn-primary",
      style: { margin: "1em auto" },
      disabled: yf(n),
      onClick: (i) => r(i)
    },
    "I'm Done"
  )));
}, Id = ({ errorMessage: e }) => {
  const t = {
    position: "absolute",
    background: "white",
    zIndex: "999",
    height: "100vh",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gridArea: "content"
  };
  return /* @__PURE__ */ m.createElement("section", { className: "waiting", style: t }, /* @__PURE__ */ m.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ m.createElement("h3", null, "Error With Configuration"), /* @__PURE__ */ m.createElement("p", null, e)));
}, qc = Nm(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
qc.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Nm((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : qc);
qc.range;
class Gp extends Map {
  constructor(t, n = hv) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [r, a] of t)
        this.set(r, a);
  }
  get(t) {
    return super.get(Xp(this, t));
  }
  has(t) {
    return super.has(Xp(this, t));
  }
  set(t, n) {
    return super.set(fv(this, t), n);
  }
  delete(t) {
    return super.delete(pv(this, t));
  }
}
function Xp({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function fv({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function pv({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function hv(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function mv(e, t, n) {
  e = +e, t = +t, n = (a = arguments.length) < 2 ? (t = e, e = 0, 1) : a < 3 ? 1 : +n;
  for (var r = -1, a = Math.max(0, Math.ceil((t - e) / n)) | 0, i = new Array(a); ++r < a; )
    i[r] = e + r * n;
  return i;
}
function yv(e, t, n, r, a, i) {
  const u = [
    [fs, 1, Sc],
    [fs, 5, 5 * Sc],
    [fs, 15, 15 * Sc],
    [fs, 30, 30 * Sc],
    [i, 1, kc],
    [i, 5, 5 * kc],
    [i, 15, 15 * kc],
    [i, 30, 30 * kc],
    [a, 1, wc],
    [a, 3, 3 * wc],
    [a, 6, 6 * wc],
    [a, 12, 12 * wc],
    [r, 1, Vp],
    [r, 2, 2 * Vp],
    [n, 1, cv],
    [t, 1, Wp],
    [t, 3, 3 * Wp],
    [e, 1, Bd]
  ];
  function c(p, h, g) {
    const x = h < p;
    x && ([p, h] = [h, p]);
    const w = g && typeof g.range == "function" ? g : l(p, h, g), y = w ? w.range(p, +h + 1) : [];
    return x ? y.reverse() : y;
  }
  function l(p, h, g) {
    const x = Math.abs(h - p) / g, w = nv(([, , b]) => b).right(u, x);
    if (w === u.length)
      return e.every($p(p / Bd, h / Bd, g));
    if (w === 0)
      return qc.every(Math.max($p(p, h, g), 1));
    const [y, R] = u[x / u[w - 1][2] < u[w][2] / x ? w - 1 : w];
    return y.every(R);
  }
  return [c, l];
}
const [gv, vv] = yv(Pm, Am, _m, Dm, Cm, Rm), Xf = ue.createContext(() => {
}), mt = ue.createContext({}), xv = (e) => {
  const { children: t } = e, { config: n, currentViewport: r } = ue.useContext(mt), a = () => {
    let i = ["legend-wrapper", "d-flex", "flex-nowrap", "w-100"];
    const { legend: u } = n;
    return (u.position === "bottom" || u.position === "top" || Va(r)) && (i = i.filter((c) => c !== "flex-nowrap"), i.push("flex-wrap")), i.join(" ");
  };
  return /* @__PURE__ */ m.createElement("div", { className: a() }, ...t);
};
var zi = [], bv = function() {
  return zi.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Ev = function() {
  return zi.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, qp = "ResizeObserver loop completed with undelivered notifications.", Sv = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: qp
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = qp), window.dispatchEvent(e);
}, Ss;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Ss || (Ss = {}));
var Bi = function(e) {
  return Object.freeze(e);
}, Mm = function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Bi(this);
  }
  return e;
}(), zm = function() {
  function e(t, n, r, a) {
    return this.x = t, this.y = n, this.width = r, this.height = a, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Bi(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, a = t.top, i = t.right, u = t.bottom, c = t.left, l = t.width, p = t.height;
    return { x: n, y: r, top: a, right: i, bottom: u, left: c, width: l, height: p };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), qf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Bm = function(e) {
  if (qf(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var a = e, i = a.offsetWidth, u = a.offsetHeight;
  return !(i || u || e.getClientRects().length);
}, Zp = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, kv = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ps = typeof window < "u" ? window : {}, Rc = /* @__PURE__ */ new WeakMap(), Qp = /auto|scroll/, wv = /^tb|vertical/, Tv = /msie|trident/i.test(ps.navigator && ps.navigator.userAgent), Zr = function(e) {
  return parseFloat(e || "0");
}, rl = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Mm((n ? t : e) || 0, (n ? e : t) || 0);
}, Jp = Bi({
  devicePixelContentBoxSize: rl(),
  borderBoxSize: rl(),
  contentBoxSize: rl(),
  contentRect: new zm(0, 0, 0, 0)
}), Im = function(e, t) {
  if (t === void 0 && (t = !1), Rc.has(e) && !t)
    return Rc.get(e);
  if (Bm(e))
    return Rc.set(e, Jp), Jp;
  var n = getComputedStyle(e), r = qf(e) && e.ownerSVGElement && e.getBBox(), a = !Tv && n.boxSizing === "border-box", i = wv.test(n.writingMode || ""), u = !r && Qp.test(n.overflowY || ""), c = !r && Qp.test(n.overflowX || ""), l = r ? 0 : Zr(n.paddingTop), p = r ? 0 : Zr(n.paddingRight), h = r ? 0 : Zr(n.paddingBottom), g = r ? 0 : Zr(n.paddingLeft), x = r ? 0 : Zr(n.borderTopWidth), w = r ? 0 : Zr(n.borderRightWidth), y = r ? 0 : Zr(n.borderBottomWidth), R = r ? 0 : Zr(n.borderLeftWidth), b = g + p, v = l + h, A = R + w, N = x + y, L = c ? e.offsetHeight - N - e.clientHeight : 0, C = u ? e.offsetWidth - A - e.clientWidth : 0, z = a ? b + A : 0, W = a ? v + N : 0, q = r ? r.width : Zr(n.width) - z - C, ne = r ? r.height : Zr(n.height) - W - L, G = q + b + C + A, le = ne + v + L + N, K = Bi({
    devicePixelContentBoxSize: rl(Math.round(q * devicePixelRatio), Math.round(ne * devicePixelRatio), i),
    borderBoxSize: rl(G, le, i),
    contentBoxSize: rl(q, ne, i),
    contentRect: new zm(g, l, q, ne)
  });
  return Rc.set(e, K), K;
}, $m = function(e, t, n) {
  var r = Im(e, n), a = r.borderBoxSize, i = r.contentBoxSize, u = r.devicePixelContentBoxSize;
  switch (t) {
    case Ss.DEVICE_PIXEL_CONTENT_BOX:
      return u;
    case Ss.BORDER_BOX:
      return a;
    default:
      return i;
  }
}, Hm = function() {
  function e(t) {
    var n = Im(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Bi([n.borderBoxSize]), this.contentBoxSize = Bi([n.contentBoxSize]), this.devicePixelContentBoxSize = Bi([n.devicePixelContentBoxSize]);
  }
  return e;
}(), Vm = function(e) {
  if (Bm(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Rv = function() {
  var e = 1 / 0, t = [];
  zi.forEach(function(u) {
    if (u.activeTargets.length !== 0) {
      var c = [];
      u.activeTargets.forEach(function(p) {
        var h = new Hm(p.target), g = Vm(p.target);
        c.push(h), p.lastReportedSize = $m(p.target, p.observedBox), g < e && (e = g);
      }), t.push(function() {
        u.callback.call(u.observer, c, u.observer);
      }), u.activeTargets.splice(0, u.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var a = r[n];
    a();
  }
  return e;
}, eh = function(e) {
  zi.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(a) {
      a.isActive() && (Vm(a.target) > e ? n.activeTargets.push(a) : n.skippedTargets.push(a));
    });
  });
}, Cv = function() {
  var e = 0;
  for (eh(e); bv(); )
    e = Rv(), eh(e);
  return Ev() && Sv(), e > 0;
}, $d, Wm = [], Av = function() {
  return Wm.splice(0).forEach(function(e) {
    return e();
  });
}, Lv = function(e) {
  if (!$d) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return Av();
    }).observe(n, r), $d = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  Wm.push(e), $d();
}, Nv = function(e) {
  Lv(function() {
    requestAnimationFrame(e);
  });
}, $c = 0, Pv = function() {
  return !!$c;
}, Dv = 250, _v = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, th = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], nh = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Hd = !1, Ov = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Dv), !Hd) {
      Hd = !0;
      var r = nh(t);
      Nv(function() {
        var a = !1;
        try {
          a = Cv();
        } finally {
          if (Hd = !1, t = r - nh(), !Pv())
            return;
          a ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, _v);
    };
    document.body ? n() : ps.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), th.forEach(function(n) {
      return ps.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), th.forEach(function(n) {
      return ps.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), gf = new Ov(), rh = function(e) {
  !$c && e > 0 && gf.start(), $c += e, !$c && gf.stop();
}, Fv = function(e) {
  return !qf(e) && !kv(e) && getComputedStyle(e).display === "inline";
}, Mv = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Ss.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = $m(this.target, this.observedBox, !0);
    return Fv(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), zv = function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Cc = /* @__PURE__ */ new WeakMap(), ah = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Ac = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new zv(t, n);
    Cc.set(t, r);
  }, e.observe = function(t, n, r) {
    var a = Cc.get(t), i = a.observationTargets.length === 0;
    ah(a.observationTargets, n) < 0 && (i && zi.push(a), a.observationTargets.push(new Mv(n, r && r.box)), rh(1), gf.schedule());
  }, e.unobserve = function(t, n) {
    var r = Cc.get(t), a = ah(r.observationTargets, n), i = r.observationTargets.length === 1;
    a >= 0 && (i && zi.splice(zi.indexOf(r), 1), r.observationTargets.splice(a, 1), rh(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Cc.get(t);
    r.observationTargets.slice().forEach(function(a) {
      return n.unobserve(t, a.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), Bv = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Ac.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!Zp(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Ac.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!Zp(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Ac.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Ac.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const Iv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: Bv,
  ResizeObserverEntry: Hm,
  ResizeObserverSize: Mm
}, Symbol.toStringTag, { value: "Module" })), $v = /* @__PURE__ */ ev(Iv);
var Ko = Km, Ia = Um(Qg), Hv = Um(Jg), Yo = jv(ue), Vv = $v, Wv = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function jm(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (jm = function(a) {
    return a ? n : t;
  })(e);
}
function jv(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = jm(t);
  if (n && n.has(e))
    return n.get(e);
  var r = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var i in e)
    if (i !== "default" && Object.prototype.hasOwnProperty.call(e, i)) {
      var u = a ? Object.getOwnPropertyDescriptor(e, i) : null;
      u && (u.get || u.set) ? Object.defineProperty(r, i, u) : r[i] = e[i];
    }
  return r.default = e, n && n.set(e, r), r;
}
function Um(e) {
  return e && e.__esModule ? e : { default: e };
}
function Zc() {
  return Zc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Zc.apply(this, arguments);
}
function Uv(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var Kv = [];
function Km(e) {
  var t = e.className, n = e.children, r = e.debounceTime, a = r === void 0 ? 300 : r, i = e.ignoreDimensions, u = i === void 0 ? Kv : i, c = e.parentSizeStyles, l = c === void 0 ? {
    width: "100%",
    height: "100%"
  } : c, p = e.enableDebounceLeadingCall, h = p === void 0 ? !0 : p, g = Uv(e, Wv), x = (0, Yo.useRef)(null), w = (0, Yo.useRef)(0), y = (0, Yo.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), R = y[0], b = y[1], v = (0, Yo.useMemo)(function() {
    var A = Array.isArray(u) ? u : [u];
    return (0, Hv.default)(function(N) {
      b(function(L) {
        var C = Object.keys(L), z = C.filter(function(q) {
          return L[q] !== N[q];
        }), W = z.every(function(q) {
          return A.includes(q);
        });
        return W ? L : N;
      });
    }, a, {
      leading: h
    });
  }, [a, h, u]);
  return (0, Yo.useEffect)(function() {
    var A = new Vv.ResizeObserver(function(N) {
      N === void 0 && (N = []), N.forEach(function(L) {
        var C = L.contentRect, z = C.left, W = C.top, q = C.width, ne = C.height;
        w.current = window.requestAnimationFrame(function() {
          v({
            width: q,
            height: ne,
            top: W,
            left: z
          });
        });
      });
    });
    return x.current && A.observe(x.current), function() {
      window.cancelAnimationFrame(w.current), A.disconnect(), v != null && v.cancel && v.cancel();
    };
  }, [v]), /* @__PURE__ */ Yo.default.createElement("div", Zc({
    style: l,
    ref: x,
    className: t
  }, g), n(Zc({}, R, {
    ref: x.current,
    resize: v
  })));
}
Km.propTypes = {
  className: Ia.default.string,
  debounceTime: Ia.default.number,
  enableDebounceLeadingCall: Ia.default.bool,
  ignoreDimensions: Ia.default.oneOfType([Ia.default.any, Ia.default.arrayOf(Ia.default.any)]),
  children: Ia.default.func.isRequired
};
var Vd = /* @__PURE__ */ new Date(), Wd = /* @__PURE__ */ new Date();
function va(e, t, n, r) {
  function a(i) {
    return e(i = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+i)), i;
  }
  return a.floor = function(i) {
    return e(i = /* @__PURE__ */ new Date(+i)), i;
  }, a.ceil = function(i) {
    return e(i = new Date(i - 1)), t(i, 1), e(i), i;
  }, a.round = function(i) {
    var u = a(i), c = a.ceil(i);
    return i - u < c - i ? u : c;
  }, a.offset = function(i, u) {
    return t(i = /* @__PURE__ */ new Date(+i), u == null ? 1 : Math.floor(u)), i;
  }, a.range = function(i, u, c) {
    var l = [], p;
    if (i = a.ceil(i), c = c == null ? 1 : Math.floor(c), !(i < u) || !(c > 0))
      return l;
    do
      l.push(p = /* @__PURE__ */ new Date(+i)), t(i, c), e(i);
    while (p < i && i < u);
    return l;
  }, a.filter = function(i) {
    return va(function(u) {
      if (u >= u)
        for (; e(u), !i(u); )
          u.setTime(u - 1);
    }, function(u, c) {
      if (u >= u)
        if (c < 0)
          for (; ++c <= 0; )
            for (; t(u, -1), !i(u); )
              ;
        else
          for (; --c >= 0; )
            for (; t(u, 1), !i(u); )
              ;
    });
  }, n && (a.count = function(i, u) {
    return Vd.setTime(+i), Wd.setTime(+u), e(Vd), e(Wd), Math.floor(n(Vd, Wd));
  }, a.every = function(i) {
    return i = Math.floor(i), !isFinite(i) || !(i > 0) ? null : i > 1 ? a.filter(r ? function(u) {
      return r(u) % i === 0;
    } : function(u) {
      return a.count(0, u) % i === 0;
    }) : a;
  }), a;
}
const Yv = 1e3, Zf = Yv * 60, Gv = Zf * 60, Qf = Gv * 24, Ym = Qf * 7;
var Gm = va(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Zf) / Qf,
  (e) => e.getDate() - 1
);
const Xm = Gm;
Gm.range;
function ji(e) {
  return va(function(t) {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setDate(t.getDate() + n * 7);
  }, function(t, n) {
    return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Zf) / Ym;
  });
}
var qm = ji(0), Qc = ji(1), Xv = ji(2), qv = ji(3), ll = ji(4), Zv = ji(5), Qv = ji(6);
qm.range;
Qc.range;
Xv.range;
qv.range;
ll.range;
Zv.range;
Qv.range;
var Jf = va(function(e) {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setFullYear(e.getFullYear() + t);
}, function(e, t) {
  return t.getFullYear() - e.getFullYear();
}, function(e) {
  return e.getFullYear();
});
Jf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : va(function(t) {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setFullYear(t.getFullYear() + n * e);
  });
};
const ks = Jf;
Jf.range;
var Zm = va(function(e) {
  e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCDate(e.getUTCDate() + t);
}, function(e, t) {
  return (t - e) / Qf;
}, function(e) {
  return e.getUTCDate() - 1;
});
const Qm = Zm;
Zm.range;
function Ui(e) {
  return va(function(t) {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, function(t, n) {
    return (n - t) / Ym;
  });
}
var Jm = Ui(0), Jc = Ui(1), Jv = Ui(2), ex = Ui(3), sl = Ui(4), tx = Ui(5), nx = Ui(6);
Jm.range;
Jc.range;
Jv.range;
ex.range;
sl.range;
tx.range;
nx.range;
var ep = va(function(e) {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, function(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}, function(e) {
  return e.getUTCFullYear();
});
ep.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : va(function(t) {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setUTCFullYear(t.getUTCFullYear() + n * e);
  });
};
const ws = ep;
ep.range;
function ey(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function ih(e) {
  let t = e, n = e;
  e.length === 1 && (t = (u, c) => e(u) - c, n = rx(e));
  function r(u, c, l, p) {
    for (l == null && (l = 0), p == null && (p = u.length); l < p; ) {
      const h = l + p >>> 1;
      n(u[h], c) < 0 ? l = h + 1 : p = h;
    }
    return l;
  }
  function a(u, c, l, p) {
    for (l == null && (l = 0), p == null && (p = u.length); l < p; ) {
      const h = l + p >>> 1;
      n(u[h], c) > 0 ? p = h : l = h + 1;
    }
    return l;
  }
  function i(u, c, l, p) {
    l == null && (l = 0), p == null && (p = u.length);
    const h = r(u, c, l, p - 1);
    return h > l && t(u[h - 1], c) > -t(u[h], c) ? h - 1 : h;
  }
  return { left: r, center: i, right: a };
}
function rx(e) {
  return (t, n) => ey(e(t), n);
}
function* ax(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let r of e)
      (r = t(r, ++n, e)) != null && (r = +r) >= r && (yield r);
  }
}
function ix(e, t) {
  let n = 0, r, a = 0, i = 0;
  if (t === void 0)
    for (let u of e)
      u != null && (u = +u) >= u && (r = u - a, a += r / ++n, i += r * (u - a));
  else {
    let u = -1;
    for (let c of e)
      (c = t(c, ++u, e)) != null && (c = +c) >= c && (r = c - a, a += r / ++n, i += r * (c - a));
  }
  if (n > 1)
    return i / (n - 1);
}
function ox(e, t) {
  const n = ix(e, t);
  return n && Math.sqrt(n);
}
function eu(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let a of e)
      (a = t(a, ++r, e)) != null && (n < a || n === void 0 && a >= a) && (n = a);
  }
  return n;
}
function vf(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let a of e)
      (a = t(a, ++r, e)) != null && (n > a || n === void 0 && a >= a) && (n = a);
  }
  return n;
}
function ty(e, t, n = 0, r = e.length - 1, a = ey) {
  for (; r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1, p = t - n + 1, h = Math.log(l), g = 0.5 * Math.exp(2 * h / 3), x = 0.5 * Math.sqrt(h * g * (l - g) / l) * (p - l / 2 < 0 ? -1 : 1), w = Math.max(n, Math.floor(t - p * g / l + x)), y = Math.min(r, Math.floor(t + (l - p) * g / l + x));
      ty(e, t, w, y, a);
    }
    const i = e[t];
    let u = n, c = r;
    for (ls(e, n, t), a(e[r], i) > 0 && ls(e, n, r); u < c; ) {
      for (ls(e, u, c), ++u, --c; a(e[u], i) < 0; )
        ++u;
      for (; a(e[c], i) > 0; )
        --c;
    }
    a(e[n], i) === 0 ? ls(e, n, c) : (++c, ls(e, c, r)), c <= t && (n = c + 1), t <= c && (r = c - 1);
  }
  return e;
}
function ls(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function Ts(e, t, n) {
  if (e = Float64Array.from(ax(e, n)), !!(r = e.length)) {
    if ((t = +t) <= 0 || r < 2)
      return vf(e);
    if (t >= 1)
      return eu(e);
    var r, a = (r - 1) * t, i = Math.floor(a), u = eu(ty(e, i).subarray(0, i + 1)), c = vf(e.subarray(i + 1));
    return u + (c - u) * (a - i);
  }
}
function lx(e, t) {
  let n = 0, r = 0;
  if (t === void 0)
    for (let a of e)
      a != null && (a = +a) >= a && (++n, r += a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (i = +i) >= i && (++n, r += i);
  }
  if (n)
    return r / n;
}
function ny(e, t) {
  return Ts(e, 0.5, t);
}
function jd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Ud(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function ss(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function sx(e) {
  var t = e.dateTime, n = e.date, r = e.time, a = e.periods, i = e.days, u = e.shortDays, c = e.months, l = e.shortMonths, p = cs(a), h = us(a), g = cs(i), x = us(i), w = cs(u), y = us(u), R = cs(c), b = us(c), v = cs(l), A = us(l), N = {
    a: ee,
    A: Q,
    b: Z,
    B: Y,
    c: null,
    d: dh,
    e: dh,
    f: Px,
    g: Hx,
    G: Wx,
    H: Ax,
    I: Lx,
    j: Nx,
    L: ry,
    m: Dx,
    M: _x,
    p: te,
    q: $,
    Q: hh,
    s: mh,
    S: Ox,
    u: Fx,
    U: Mx,
    V: zx,
    w: Bx,
    W: Ix,
    x: null,
    X: null,
    y: $x,
    Y: Vx,
    Z: jx,
    "%": ph
  }, L = {
    a: ce,
    A: Se,
    b: be,
    B: ve,
    c: null,
    d: fh,
    e: fh,
    f: Gx,
    g: ab,
    G: ob,
    H: Ux,
    I: Kx,
    j: Yx,
    L: iy,
    m: Xx,
    M: qx,
    p: Pe,
    q: Ve,
    Q: hh,
    s: mh,
    S: Zx,
    u: Qx,
    U: Jx,
    V: eb,
    w: tb,
    W: nb,
    x: null,
    X: null,
    y: rb,
    Y: ib,
    Z: lb,
    "%": ph
  }, C = {
    a: G,
    A: le,
    b: K,
    B: re,
    c: B,
    d: ch,
    e: ch,
    f: wx,
    g: sh,
    G: lh,
    H: uh,
    I: uh,
    j: bx,
    L: kx,
    m: xx,
    M: Ex,
    p: ne,
    q: vx,
    Q: Rx,
    s: Cx,
    S: Sx,
    u: px,
    U: hx,
    V: mx,
    w: fx,
    W: yx,
    x: j,
    X: se,
    y: sh,
    Y: lh,
    Z: gx,
    "%": Tx
  };
  N.x = z(n, N), N.X = z(r, N), N.c = z(t, N), L.x = z(n, L), L.X = z(r, L), L.c = z(t, L);
  function z(we, me) {
    return function(Ce) {
      var fe = [], ze = -1, Ie = 0, Qe = we.length, He, Fe, qe;
      for (Ce instanceof Date || (Ce = /* @__PURE__ */ new Date(+Ce)); ++ze < Qe; )
        we.charCodeAt(ze) === 37 && (fe.push(we.slice(Ie, ze)), (Fe = oh[He = we.charAt(++ze)]) != null ? He = we.charAt(++ze) : Fe = He === "e" ? " " : "0", (qe = me[He]) && (He = qe(Ce, Fe)), fe.push(He), Ie = ze + 1);
      return fe.push(we.slice(Ie, ze)), fe.join("");
    };
  }
  function W(we, me) {
    return function(Ce) {
      var fe = ss(1900, void 0, 1), ze = q(fe, we, Ce += "", 0), Ie, Qe;
      if (ze != Ce.length)
        return null;
      if ("Q" in fe)
        return new Date(fe.Q);
      if ("s" in fe)
        return new Date(fe.s * 1e3 + ("L" in fe ? fe.L : 0));
      if (me && !("Z" in fe) && (fe.Z = 0), "p" in fe && (fe.H = fe.H % 12 + fe.p * 12), fe.m === void 0 && (fe.m = "q" in fe ? fe.q : 0), "V" in fe) {
        if (fe.V < 1 || fe.V > 53)
          return null;
        "w" in fe || (fe.w = 1), "Z" in fe ? (Ie = Ud(ss(fe.y, 0, 1)), Qe = Ie.getUTCDay(), Ie = Qe > 4 || Qe === 0 ? Jc.ceil(Ie) : Jc(Ie), Ie = Qm.offset(Ie, (fe.V - 1) * 7), fe.y = Ie.getUTCFullYear(), fe.m = Ie.getUTCMonth(), fe.d = Ie.getUTCDate() + (fe.w + 6) % 7) : (Ie = jd(ss(fe.y, 0, 1)), Qe = Ie.getDay(), Ie = Qe > 4 || Qe === 0 ? Qc.ceil(Ie) : Qc(Ie), Ie = Xm.offset(Ie, (fe.V - 1) * 7), fe.y = Ie.getFullYear(), fe.m = Ie.getMonth(), fe.d = Ie.getDate() + (fe.w + 6) % 7);
      } else
        ("W" in fe || "U" in fe) && ("w" in fe || (fe.w = "u" in fe ? fe.u % 7 : "W" in fe ? 1 : 0), Qe = "Z" in fe ? Ud(ss(fe.y, 0, 1)).getUTCDay() : jd(ss(fe.y, 0, 1)).getDay(), fe.m = 0, fe.d = "W" in fe ? (fe.w + 6) % 7 + fe.W * 7 - (Qe + 5) % 7 : fe.w + fe.U * 7 - (Qe + 6) % 7);
      return "Z" in fe ? (fe.H += fe.Z / 100 | 0, fe.M += fe.Z % 100, Ud(fe)) : jd(fe);
    };
  }
  function q(we, me, Ce, fe) {
    for (var ze = 0, Ie = me.length, Qe = Ce.length, He, Fe; ze < Ie; ) {
      if (fe >= Qe)
        return -1;
      if (He = me.charCodeAt(ze++), He === 37) {
        if (He = me.charAt(ze++), Fe = C[He in oh ? me.charAt(ze++) : He], !Fe || (fe = Fe(we, Ce, fe)) < 0)
          return -1;
      } else if (He != Ce.charCodeAt(fe++))
        return -1;
    }
    return fe;
  }
  function ne(we, me, Ce) {
    var fe = p.exec(me.slice(Ce));
    return fe ? (we.p = h.get(fe[0].toLowerCase()), Ce + fe[0].length) : -1;
  }
  function G(we, me, Ce) {
    var fe = w.exec(me.slice(Ce));
    return fe ? (we.w = y.get(fe[0].toLowerCase()), Ce + fe[0].length) : -1;
  }
  function le(we, me, Ce) {
    var fe = g.exec(me.slice(Ce));
    return fe ? (we.w = x.get(fe[0].toLowerCase()), Ce + fe[0].length) : -1;
  }
  function K(we, me, Ce) {
    var fe = v.exec(me.slice(Ce));
    return fe ? (we.m = A.get(fe[0].toLowerCase()), Ce + fe[0].length) : -1;
  }
  function re(we, me, Ce) {
    var fe = R.exec(me.slice(Ce));
    return fe ? (we.m = b.get(fe[0].toLowerCase()), Ce + fe[0].length) : -1;
  }
  function B(we, me, Ce) {
    return q(we, t, me, Ce);
  }
  function j(we, me, Ce) {
    return q(we, n, me, Ce);
  }
  function se(we, me, Ce) {
    return q(we, r, me, Ce);
  }
  function ee(we) {
    return u[we.getDay()];
  }
  function Q(we) {
    return i[we.getDay()];
  }
  function Z(we) {
    return l[we.getMonth()];
  }
  function Y(we) {
    return c[we.getMonth()];
  }
  function te(we) {
    return a[+(we.getHours() >= 12)];
  }
  function $(we) {
    return 1 + ~~(we.getMonth() / 3);
  }
  function ce(we) {
    return u[we.getUTCDay()];
  }
  function Se(we) {
    return i[we.getUTCDay()];
  }
  function be(we) {
    return l[we.getUTCMonth()];
  }
  function ve(we) {
    return c[we.getUTCMonth()];
  }
  function Pe(we) {
    return a[+(we.getUTCHours() >= 12)];
  }
  function Ve(we) {
    return 1 + ~~(we.getUTCMonth() / 3);
  }
  return {
    format: function(we) {
      var me = z(we += "", N);
      return me.toString = function() {
        return we;
      }, me;
    },
    parse: function(we) {
      var me = W(we += "", !1);
      return me.toString = function() {
        return we;
      }, me;
    },
    utcFormat: function(we) {
      var me = z(we += "", L);
      return me.toString = function() {
        return we;
      }, me;
    },
    utcParse: function(we) {
      var me = W(we += "", !0);
      return me.toString = function() {
        return we;
      }, me;
    }
  };
}
var oh = { "-": "", _: " ", 0: "0" }, $n = /^\s*\d+/, cx = /^%/, ux = /[\\^$*+?|[\]().{}]/g;
function Ut(e, t, n) {
  var r = e < 0 ? "-" : "", a = (r ? -e : e) + "", i = a.length;
  return r + (i < n ? new Array(n - i + 1).join(t) + a : a);
}
function dx(e) {
  return e.replace(ux, "\\$&");
}
function cs(e) {
  return new RegExp("^(?:" + e.map(dx).join("|") + ")", "i");
}
function us(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function fx(e, t, n) {
  var r = $n.exec(t.slice(n, n + 1));
  return r ? (e.w = +r[0], n + r[0].length) : -1;
}
function px(e, t, n) {
  var r = $n.exec(t.slice(n, n + 1));
  return r ? (e.u = +r[0], n + r[0].length) : -1;
}
function hx(e, t, n) {
  var r = $n.exec(t.slice(n, n + 2));
  return r ? (e.U = +r[0], n + r[0].length) : -1;
}
function mx(e, t, n) {
  var r = $n.exec(t.slice(n, n + 2));
  return r ? (e.V = +r[0], n + r[0].length) : -1;
}
function yx(e, t, n) {
  var r = $n.exec(t.slice(n, n + 2));
  return r ? (e.W = +r[0], n + r[0].length) : -1;
}
function lh(e, t, n) {
  var r = $n.exec(t.slice(n, n + 4));
  return r ? (e.y = +r[0], n + r[0].length) : -1;
}
function sh(e, t, n) {
  var r = $n.exec(t.slice(n, n + 2));
  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;
}
function gx(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;
}
function vx(e, t, n) {
  var r = $n.exec(t.slice(n, n + 1));
  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;
}
function xx(e, t, n) {
  var r = $n.exec(t.slice(n, n + 2));
  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;
}
function ch(e, t, n) {
  var r = $n.exec(t.slice(n, n + 2));
  return r ? (e.d = +r[0], n + r[0].length) : -1;
}
function bx(e, t, n) {
  var r = $n.exec(t.slice(n, n + 3));
  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;
}
function uh(e, t, n) {
  var r = $n.exec(t.slice(n, n + 2));
  return r ? (e.H = +r[0], n + r[0].length) : -1;
}
function Ex(e, t, n) {
  var r = $n.exec(t.slice(n, n + 2));
  return r ? (e.M = +r[0], n + r[0].length) : -1;
}
function Sx(e, t, n) {
  var r = $n.exec(t.slice(n, n + 2));
  return r ? (e.S = +r[0], n + r[0].length) : -1;
}
function kx(e, t, n) {
  var r = $n.exec(t.slice(n, n + 3));
  return r ? (e.L = +r[0], n + r[0].length) : -1;
}
function wx(e, t, n) {
  var r = $n.exec(t.slice(n, n + 6));
  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;
}
function Tx(e, t, n) {
  var r = cx.exec(t.slice(n, n + 1));
  return r ? n + r[0].length : -1;
}
function Rx(e, t, n) {
  var r = $n.exec(t.slice(n));
  return r ? (e.Q = +r[0], n + r[0].length) : -1;
}
function Cx(e, t, n) {
  var r = $n.exec(t.slice(n));
  return r ? (e.s = +r[0], n + r[0].length) : -1;
}
function dh(e, t) {
  return Ut(e.getDate(), t, 2);
}
function Ax(e, t) {
  return Ut(e.getHours(), t, 2);
}
function Lx(e, t) {
  return Ut(e.getHours() % 12 || 12, t, 2);
}
function Nx(e, t) {
  return Ut(1 + Xm.count(ks(e), e), t, 3);
}
function ry(e, t) {
  return Ut(e.getMilliseconds(), t, 3);
}
function Px(e, t) {
  return ry(e, t) + "000";
}
function Dx(e, t) {
  return Ut(e.getMonth() + 1, t, 2);
}
function _x(e, t) {
  return Ut(e.getMinutes(), t, 2);
}
function Ox(e, t) {
  return Ut(e.getSeconds(), t, 2);
}
function Fx(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function Mx(e, t) {
  return Ut(qm.count(ks(e) - 1, e), t, 2);
}
function ay(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? ll(e) : ll.ceil(e);
}
function zx(e, t) {
  return e = ay(e), Ut(ll.count(ks(e), e) + (ks(e).getDay() === 4), t, 2);
}
function Bx(e) {
  return e.getDay();
}
function Ix(e, t) {
  return Ut(Qc.count(ks(e) - 1, e), t, 2);
}
function $x(e, t) {
  return Ut(e.getFullYear() % 100, t, 2);
}
function Hx(e, t) {
  return e = ay(e), Ut(e.getFullYear() % 100, t, 2);
}
function Vx(e, t) {
  return Ut(e.getFullYear() % 1e4, t, 4);
}
function Wx(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? ll(e) : ll.ceil(e), Ut(e.getFullYear() % 1e4, t, 4);
}
function jx(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ut(t / 60 | 0, "0", 2) + Ut(t % 60, "0", 2);
}
function fh(e, t) {
  return Ut(e.getUTCDate(), t, 2);
}
function Ux(e, t) {
  return Ut(e.getUTCHours(), t, 2);
}
function Kx(e, t) {
  return Ut(e.getUTCHours() % 12 || 12, t, 2);
}
function Yx(e, t) {
  return Ut(1 + Qm.count(ws(e), e), t, 3);
}
function iy(e, t) {
  return Ut(e.getUTCMilliseconds(), t, 3);
}
function Gx(e, t) {
  return iy(e, t) + "000";
}
function Xx(e, t) {
  return Ut(e.getUTCMonth() + 1, t, 2);
}
function qx(e, t) {
  return Ut(e.getUTCMinutes(), t, 2);
}
function Zx(e, t) {
  return Ut(e.getUTCSeconds(), t, 2);
}
function Qx(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function Jx(e, t) {
  return Ut(Jm.count(ws(e) - 1, e), t, 2);
}
function oy(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? sl(e) : sl.ceil(e);
}
function eb(e, t) {
  return e = oy(e), Ut(sl.count(ws(e), e) + (ws(e).getUTCDay() === 4), t, 2);
}
function tb(e) {
  return e.getUTCDay();
}
function nb(e, t) {
  return Ut(Jc.count(ws(e) - 1, e), t, 2);
}
function rb(e, t) {
  return Ut(e.getUTCFullYear() % 100, t, 2);
}
function ab(e, t) {
  return e = oy(e), Ut(e.getUTCFullYear() % 100, t, 2);
}
function ib(e, t) {
  return Ut(e.getUTCFullYear() % 1e4, t, 4);
}
function ob(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? sl(e) : sl.ceil(e), Ut(e.getUTCFullYear() % 1e4, t, 4);
}
function lb() {
  return "+0000";
}
function ph() {
  return "%";
}
function hh(e) {
  return +e;
}
function mh(e) {
  return Math.floor(+e / 1e3);
}
var Go, Hc, ly;
sb({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function sb(e) {
  return Go = sx(e), Hc = Go.format, ly = Go.parse, Go.utcFormat, Go.utcParse, Go;
}
const _t = {
  arr: Array.isArray,
  obj: (e) => Object.prototype.toString.call(e) === "[object Object]",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0,
  nul: (e) => e === null,
  set: (e) => e instanceof Set,
  map: (e) => e instanceof Map,
  equ(e, t) {
    if (typeof e != typeof t)
      return !1;
    if (_t.str(e) || _t.num(e))
      return e === t;
    if (_t.obj(e) && _t.obj(t) && Object.keys(e).length + Object.keys(t).length === 0)
      return !0;
    let n;
    for (n in e)
      if (!(n in t))
        return !1;
    for (n in t)
      if (e[n] !== t[n])
        return !1;
    return _t.und(n) ? e === t : !0;
  }
};
function cb(e, t) {
  return t === void 0 && (t = !0), (n) => (_t.arr(n) ? n : Object.keys(n)).reduce((r, a) => {
    const i = t ? a[0].toLowerCase() + a.substring(1) : a;
    return r[i] = e(i), r;
  }, e);
}
function sy() {
  const e = ue.useState(!1), t = e[1];
  return ue.useCallback(() => t((r) => !r), []);
}
function Li(e, t) {
  return _t.und(e) || _t.nul(e) ? t : e;
}
function tl(e) {
  return _t.und(e) ? [] : _t.arr(e) ? e : [e];
}
function Br(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return _t.fun(e) ? e(...n) : e;
}
function ub(e) {
  return e.to, e.from, e.config, e.onStart, e.onRest, e.onFrame, e.children, e.reset, e.reverse, e.force, e.immediate, e.delay, e.attach, e.destroyed, e.interpolateTo, e.ref, e.lazy, ea(e, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
}
function Kd(e) {
  const t = ub(e);
  if (_t.und(t))
    return ln({
      to: t
    }, e);
  const n = Object.keys(e).reduce((r, a) => _t.und(t[a]) ? ln({}, r, {
    [a]: e[a]
  }) : r, {});
  return ln({
    to: t
  }, n);
}
function db(e, t) {
  return t && (_t.fun(t) ? t(e) : _t.obj(t) && (t.current = e)), e;
}
class Ir {
  constructor() {
    this.payload = void 0, this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(t) {
    this.children.length === 0 && this.attach(), this.children.push(t);
  }
  removeChild(t) {
    const n = this.children.indexOf(t);
    this.children.splice(n, 1), this.children.length === 0 && this.detach();
  }
}
class xf extends Ir {
  constructor() {
    super(...arguments), this.payload = [], this.attach = () => this.payload.forEach((t) => t instanceof Ir && t.addChild(this)), this.detach = () => this.payload.forEach((t) => t instanceof Ir && t.removeChild(this));
  }
}
class cy extends Ir {
  constructor() {
    super(...arguments), this.payload = {}, this.attach = () => Object.values(this.payload).forEach((t) => t instanceof Ir && t.addChild(this)), this.detach = () => Object.values(this.payload).forEach((t) => t instanceof Ir && t.removeChild(this));
  }
  getValue(t) {
    t === void 0 && (t = !1);
    const n = {};
    for (const r in this.payload) {
      const a = this.payload[r];
      t && !(a instanceof Ir) || (n[r] = a instanceof Ir ? a[t ? "getAnimatedValue" : "getValue"]() : a);
    }
    return n;
  }
  getAnimatedValue() {
    return this.getValue(!0);
  }
}
let tp;
function fb(e, t) {
  tp = {
    fn: e,
    transform: t
  };
}
let uy;
function pb(e) {
  uy = e;
}
let dy = (e) => typeof window < "u" ? window.requestAnimationFrame(e) : -1, tu;
function hb(e) {
  tu = e;
}
let fy = () => Date.now(), mb = (e) => e.current, py;
function yb(e) {
  py = e;
}
class gb extends cy {
  constructor(t, n) {
    super(), this.update = void 0, this.payload = t.style ? ln({}, t, {
      style: py(t.style)
    }) : t, this.update = n, this.attach();
  }
}
const vb = (e) => _t.fun(e) && !(e.prototype instanceof m.Component), xb = (e) => ue.forwardRef((n, r) => {
  const a = sy(), i = ue.useRef(!0), u = ue.useRef(null), c = ue.useRef(null), l = ue.useCallback((x) => {
    const w = u.current, y = () => {
      let R = !1;
      c.current && (R = tp.fn(c.current, u.current.getAnimatedValue())), (!c.current || R === !1) && a();
    };
    u.current = new gb(x, y), w && w.detach();
  }, []);
  ue.useEffect(() => () => {
    i.current = !1, u.current && u.current.detach();
  }, []), ue.useImperativeHandle(r, () => mb(c)), l(n);
  const p = u.current.getValue();
  p.scrollTop, p.scrollLeft;
  const h = ea(p, ["scrollTop", "scrollLeft"]), g = vb(e) ? void 0 : (x) => c.current = db(x, r);
  return m.createElement(e, ln({}, h, {
    ref: g
  }));
});
let hs = !1;
const Ii = /* @__PURE__ */ new Set(), hy = () => {
  if (!hs)
    return !1;
  let e = fy();
  for (let t of Ii) {
    let n = !1;
    for (let r = 0; r < t.configs.length; r++) {
      let a = t.configs[r], i, u;
      for (let c = 0; c < a.animatedValues.length; c++) {
        let l = a.animatedValues[c];
        if (l.done)
          continue;
        let p = a.fromValues[c], h = a.toValues[c], g = l.lastPosition, x = h instanceof Ir, w = Array.isArray(a.initialVelocity) ? a.initialVelocity[c] : a.initialVelocity;
        if (x && (h = h.getValue()), a.immediate) {
          l.setValue(h), l.done = !0;
          continue;
        }
        if (typeof p == "string" || typeof h == "string") {
          l.setValue(h), l.done = !0;
          continue;
        }
        if (a.duration !== void 0)
          g = p + a.easing((e - l.startTime) / a.duration) * (h - p), i = e >= l.startTime + a.duration;
        else if (a.decay)
          g = p + w / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (e - l.startTime))), i = Math.abs(l.lastPosition - g) < 0.1, i && (h = g);
        else {
          u = l.lastTime !== void 0 ? l.lastTime : e, w = l.lastVelocity !== void 0 ? l.lastVelocity : a.initialVelocity, e > u + 64 && (u = e);
          let y = Math.floor(e - u);
          for (let A = 0; A < y; ++A) {
            let N = -a.tension * (g - h), L = -a.friction * w, C = (N + L) / a.mass;
            w = w + C * 1 / 1e3, g = g + w * 1 / 1e3;
          }
          let R = a.clamp && a.tension !== 0 ? p < h ? g > h : g < h : !1, b = Math.abs(w) <= a.precision, v = a.tension !== 0 ? Math.abs(h - g) <= a.precision : !0;
          i = R || b && v, l.lastVelocity = w, l.lastTime = e;
        }
        x && !a.toValues[c].done && (i = !1), i ? (l.value !== h && (g = h), l.done = !0) : n = !0, l.setValue(g), l.lastPosition = g;
      }
      t.props.onFrame && (t.values[a.name] = a.interpolation.getValue());
    }
    t.props.onFrame && t.props.onFrame(t.values), n || (Ii.delete(t), t.stop(!0));
  }
  return Ii.size ? dy(hy) : hs = !1, hs;
}, bb = (e) => {
  Ii.has(e) || Ii.add(e), hs || (hs = !0, dy(hy));
}, Eb = (e) => {
  Ii.has(e) && Ii.delete(e);
};
function nu(e, t, n) {
  if (typeof e == "function")
    return e;
  if (Array.isArray(e))
    return nu({
      range: e,
      output: t,
      extrapolate: n
    });
  if (tu && typeof e.output[0] == "string")
    return tu(e);
  const r = e, a = r.output, i = r.range || [0, 1], u = r.extrapolateLeft || r.extrapolate || "extend", c = r.extrapolateRight || r.extrapolate || "extend", l = r.easing || ((p) => p);
  return (p) => {
    const h = kb(p, i);
    return Sb(p, i[h], i[h + 1], a[h], a[h + 1], l, u, c, r.map);
  };
}
function Sb(e, t, n, r, a, i, u, c, l) {
  let p = l ? l(e) : e;
  if (p < t) {
    if (u === "identity")
      return p;
    u === "clamp" && (p = t);
  }
  if (p > n) {
    if (c === "identity")
      return p;
    c === "clamp" && (p = n);
  }
  return r === a ? r : t === n ? e <= t ? r : a : (t === -1 / 0 ? p = -p : n === 1 / 0 ? p = p - t : p = (p - t) / (n - t), p = i(p), r === -1 / 0 ? p = -p : a === 1 / 0 ? p = p + r : p = p * (a - r) + r, p);
}
function kb(e, t) {
  for (var n = 1; n < t.length - 1 && !(t[n] >= e); ++n)
    ;
  return n - 1;
}
class cl extends xf {
  constructor(t, n, r, a) {
    super(), this.calc = void 0, this.payload = t instanceof xf && !(t instanceof cl) ? t.getPayload() : Array.isArray(t) ? t : [t], this.calc = nu(n, r, a);
  }
  getValue() {
    return this.calc(...this.payload.map((t) => t.getValue()));
  }
  updateConfig(t, n, r) {
    this.calc = nu(t, n, r);
  }
  interpolate(t, n, r) {
    return new cl(this, t, n, r);
  }
}
const wb = (e, t, n) => e && new cl(e, t, n);
function my(e, t) {
  "update" in e ? t.add(e) : e.getChildren().forEach((n) => my(n, t));
}
class bf extends Ir {
  constructor(t) {
    var n;
    super(), n = this, this.animatedStyles = /* @__PURE__ */ new Set(), this.value = void 0, this.startPosition = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.startTime = void 0, this.lastTime = void 0, this.done = !1, this.setValue = function(r, a) {
      a === void 0 && (a = !0), n.value = r, a && n.flush();
    }, this.value = t, this.startPosition = t, this.lastPosition = t;
  }
  flush() {
    this.animatedStyles.size === 0 && my(this, this.animatedStyles), this.animatedStyles.forEach((t) => t.update());
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  getValue() {
    return this.value;
  }
  interpolate(t, n, r) {
    return new cl(this, t, n, r);
  }
}
class Tb extends xf {
  constructor(t) {
    super(), this.payload = t.map((n) => new bf(n));
  }
  setValue(t, n) {
    n === void 0 && (n = !0), Array.isArray(t) ? t.length === this.payload.length && t.forEach((r, a) => this.payload[a].setValue(r, n)) : this.payload.forEach((r) => r.setValue(t, n));
  }
  getValue() {
    return this.payload.map((t) => t.getValue());
  }
  interpolate(t, n) {
    return new cl(this, t, n);
  }
}
let Rb = 0;
class Cb {
  constructor() {
    this.id = void 0, this.idle = !0, this.hasChanged = !1, this.guid = 0, this.local = 0, this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.listeners = [], this.queue = [], this.localQueue = void 0, this.getValues = () => this.interpolations, this.id = Rb++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */
  update(t) {
    if (!t)
      return this;
    const n = Kd(t), r = n.delay, a = r === void 0 ? 0 : r, i = n.to, u = ea(n, ["delay", "to"]);
    if (_t.arr(i) || _t.fun(i))
      this.queue.push(ln({}, u, {
        delay: a,
        to: i
      }));
    else if (i) {
      let c = {};
      Object.entries(i).forEach((l) => {
        let p = l[0], h = l[1];
        const g = ln({
          to: {
            [p]: h
          },
          delay: Br(a, p)
        }, u), x = c[g.delay] && c[g.delay].to;
        c[g.delay] = ln({}, c[g.delay], g, {
          to: ln({}, x, g.to)
        });
      }), this.queue = Object.values(c);
    }
    return this.queue = this.queue.sort((c, l) => c.delay - l.delay), this.diff(u), this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  start(t) {
    if (this.queue.length) {
      this.idle = !1, this.localQueue && this.localQueue.forEach((a) => {
        let i = a.from, u = i === void 0 ? {} : i, c = a.to, l = c === void 0 ? {} : c;
        _t.obj(u) && (this.merged = ln({}, u, this.merged)), _t.obj(l) && (this.merged = ln({}, this.merged, l));
      });
      const n = this.local = ++this.guid, r = this.localQueue = this.queue;
      this.queue = [], r.forEach((a, i) => {
        let u = a.delay, c = ea(a, ["delay"]);
        const l = (h) => {
          i === r.length - 1 && n === this.guid && h && (this.idle = !0, this.props.onRest && this.props.onRest(this.merged)), t && t();
        };
        let p = _t.arr(c.to) || _t.fun(c.to);
        u ? setTimeout(() => {
          n === this.guid && (p ? this.runAsync(c, l) : this.diff(c).start(l));
        }, u) : p ? this.runAsync(c, l) : this.diff(c).start(l);
      });
    } else
      _t.fun(t) && this.listeners.push(t), this.props.onStart && this.props.onStart(), bb(this);
    return this;
  }
  stop(t) {
    return this.listeners.forEach((n) => n(t)), this.listeners = [], this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  pause(t) {
    return this.stop(!0), t && Eb(this), this;
  }
  runAsync(t, n) {
    var r = this;
    t.delay;
    let a = ea(t, ["delay"]);
    const i = this.local;
    let u = Promise.resolve(void 0);
    if (_t.arr(a.to))
      for (let c = 0; c < a.to.length; c++) {
        const l = c, p = ln({}, a, Kd(a.to[l]));
        _t.arr(p.config) && (p.config = p.config[l]), u = u.then(() => {
          if (i === this.guid)
            return new Promise((h) => this.diff(p).start(h));
        });
      }
    else if (_t.fun(a.to)) {
      let c = 0, l;
      u = u.then(() => a.to(
        // next(props)
        (p) => {
          const h = ln({}, a, Kd(p));
          if (_t.arr(h.config) && (h.config = h.config[c]), c++, i === this.guid)
            return l = new Promise((g) => this.diff(h).start(g));
        },
        // cancel()
        function(p) {
          return p === void 0 && (p = !0), r.stop(p);
        }
      ).then(() => l));
    }
    u.then(n);
  }
  diff(t) {
    this.props = ln({}, this.props, t);
    let n = this.props, r = n.from, a = r === void 0 ? {} : r, i = n.to, u = i === void 0 ? {} : i, c = n.config, l = c === void 0 ? {} : c, p = n.reverse, h = n.attach, g = n.reset, x = n.immediate;
    if (p) {
      var w = [u, a];
      a = w[0], u = w[1];
    }
    this.merged = ln({}, a, this.merged, u), this.hasChanged = !1;
    let y = h && h(this);
    if (this.animations = Object.entries(this.merged).reduce((R, b) => {
      let v = b[0], A = b[1], N = R[v] || {};
      const L = _t.num(A), C = _t.str(A) && !A.startsWith("#") && !/\d/.test(A) && !uy[A], z = _t.arr(A), W = !L && !z && !C;
      let q = _t.und(a[v]) ? A : a[v], ne = L || z || C ? A : 1, G = Br(l, v);
      y && (ne = y.animations[v].parent);
      let le = N.parent, K = N.interpolation, re = tl(y ? ne.getPayload() : ne), B, j = A;
      W && (j = tu({
        range: [0, 1],
        output: [A, A]
      })(1));
      let se = K && K.getValue();
      const Q = !_t.und(le) && N.animatedValues.some(($) => !$.done), Z = !_t.equ(j, se), Y = !_t.equ(j, N.previous), te = !_t.equ(G, N.config);
      if (g || Y && Z || te) {
        if (L || C)
          le = K = N.parent || new bf(q);
        else if (z)
          le = K = N.parent || new Tb(q);
        else if (W) {
          let $ = N.interpolation && N.interpolation.calc(N.parent.value);
          $ = $ !== void 0 && !g ? $ : q, N.parent ? (le = N.parent, le.setValue(0, !1)) : le = new bf(0);
          const ce = {
            output: [$, A]
          };
          N.interpolation ? (K = N.interpolation, N.interpolation.updateConfig(ce)) : K = le.interpolate(ce);
        }
        return re = tl(y ? ne.getPayload() : ne), B = tl(le.getPayload()), g && !W && le.setValue(q, !1), this.hasChanged = !0, B.forEach(($) => {
          $.startPosition = $.value, $.lastPosition = $.value, $.lastVelocity = Q ? $.lastVelocity : void 0, $.lastTime = Q ? $.lastTime : void 0, $.startTime = fy(), $.done = !1, $.animatedStyles.clear();
        }), Br(x, v) && le.setValue(W ? ne : A, !1), ln({}, R, {
          [v]: ln({}, N, {
            name: v,
            parent: le,
            interpolation: K,
            animatedValues: B,
            toValues: re,
            previous: j,
            config: G,
            fromValues: tl(le.getValue()),
            immediate: Br(x, v),
            initialVelocity: Li(G.velocity, 0),
            clamp: Li(G.clamp, !1),
            precision: Li(G.precision, 0.01),
            tension: Li(G.tension, 170),
            friction: Li(G.friction, 26),
            mass: Li(G.mass, 1),
            duration: G.duration,
            easing: Li(G.easing, ($) => $),
            decay: G.decay
          })
        });
      } else
        return Z ? R : (W && (le.setValue(1, !1), K.updateConfig({
          output: [j, j]
        })), le.done = !0, this.hasChanged = !0, ln({}, R, {
          [v]: ln({}, R[v], {
            previous: j
          })
        }));
    }, this.animations), this.hasChanged) {
      this.configs = Object.values(this.animations), this.values = {}, this.interpolations = {};
      for (let R in this.animations)
        this.interpolations[R] = this.animations[R].interpolation, this.values[R] = this.animations[R].interpolation.getValue();
    }
    return this;
  }
  destroy() {
    this.stop(), this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.local = 0;
  }
}
let Ab = 0;
const Vc = "enter", Yd = "leave", Gd = "update", Lb = (e, t) => (typeof t == "function" ? e.map(t) : tl(t)).map(String), Ef = (e) => {
  let t = e.items, n = e.keys, r = n === void 0 ? (i) => i : n, a = ea(e, ["items", "keys"]);
  return t = tl(t !== void 0 ? t : null), ln({
    items: t,
    keys: Lb(t, r)
  }, a);
};
function Nb(e, t, n) {
  const r = ln({
    items: e,
    keys: t || ((A) => A)
  }, n), a = Ef(r), i = a.lazy, u = i === void 0 ? !1 : i;
  a.unique;
  const c = a.reset, l = c === void 0 ? !1 : c;
  a.enter, a.leave, a.update;
  const p = a.onDestroyed;
  a.keys, a.items;
  const h = a.onFrame, g = a.onRest, x = a.onStart, w = a.ref, y = ea(a, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]), R = sy(), b = ue.useRef(!1), v = ue.useRef({
    mounted: !1,
    first: !0,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!r.ref,
    instances: !b.current && /* @__PURE__ */ new Map(),
    forceUpdate: R
  });
  return ue.useImperativeHandle(r.ref, () => ({
    start: () => Promise.all(Array.from(v.current.instances).map((A) => {
      let N = A[1];
      return new Promise((L) => N.start(L));
    })),
    stop: (A) => Array.from(v.current.instances).forEach((N) => N[1].stop(A)),
    get controllers() {
      return Array.from(v.current.instances).map((A) => A[1]);
    }
  })), v.current = Pb(v.current, r), v.current.changed && v.current.transitions.forEach((A) => {
    const N = A.slot, L = A.from, C = A.to, z = A.config, W = A.trail, q = A.key, ne = A.item;
    v.current.instances.has(q) || v.current.instances.set(q, new Cb());
    const G = v.current.instances.get(q), le = ln({}, y, {
      to: C,
      from: L,
      config: z,
      ref: w,
      onRest: (K) => {
        v.current.mounted && (A.destroyed && (!w && !u && yh(v, q), p && p(ne)), !Array.from(v.current.instances).some((j) => !j[1].idle) && (w || u) && v.current.deleted.length > 0 && yh(v), g && g(ne, N, K));
      },
      onStart: x && (() => x(ne, N)),
      onFrame: h && ((K) => h(ne, N, K)),
      delay: W,
      reset: l && N === Vc
      // Update controller
    });
    G.update(le), v.current.paused || G.start();
  }), ue.useEffect(() => (v.current.mounted = b.current = !0, () => {
    v.current.mounted = b.current = !1, Array.from(v.current.instances).map((A) => A[1].destroy()), v.current.instances.clear();
  }), []), v.current.transitions.map((A) => {
    let N = A.item, L = A.slot, C = A.key;
    return {
      item: N,
      key: C,
      state: L,
      props: v.current.instances.get(C).getValues()
    };
  });
}
function yh(e, t) {
  const n = e.current.deleted;
  for (let r of n) {
    let a = r.key;
    const i = (u) => u.key !== a;
    (_t.und(t) || t === a) && (e.current.instances.delete(a), e.current.transitions = e.current.transitions.filter(i), e.current.deleted = e.current.deleted.filter(i));
  }
  e.current.forceUpdate();
}
function Pb(e, t) {
  let n = e.first, r = e.prevProps, a = ea(e, ["first", "prevProps"]), i = Ef(t), u = i.items, c = i.keys, l = i.initial, p = i.from, h = i.enter, g = i.leave, x = i.update, w = i.trail, y = w === void 0 ? 0 : w, R = i.unique, b = i.config, v = i.order, A = v === void 0 ? [Vc, Yd, Gd] : v, N = Ef(r), L = N.keys, C = N.items, z = ln({}, a.current), W = [...a.deleted], q = Object.keys(z), ne = new Set(q), G = new Set(c), le = c.filter((se) => !ne.has(se)), K = a.transitions.filter((se) => !se.destroyed && !G.has(se.originalKey)).map((se) => se.originalKey), re = c.filter((se) => ne.has(se)), B = -y;
  for (; A.length; )
    switch (A.shift()) {
      case Vc: {
        le.forEach((ee, Q) => {
          R && W.find(($) => $.originalKey === ee) && (W = W.filter(($) => $.originalKey !== ee));
          const Z = c.indexOf(ee), Y = u[Z], te = n && l !== void 0 ? "initial" : Vc;
          z[ee] = {
            slot: te,
            originalKey: ee,
            key: R ? String(ee) : Ab++,
            item: Y,
            trail: B = B + y,
            config: Br(b, Y, te),
            from: Br(n && l !== void 0 ? l || {} : p, Y),
            to: Br(h, Y)
          };
        });
        break;
      }
      case Yd: {
        K.forEach((ee) => {
          const Q = L.indexOf(ee), Z = C[Q], Y = Yd;
          W.unshift(ln({}, z[ee], {
            slot: Y,
            destroyed: !0,
            left: L[Math.max(0, Q - 1)],
            right: L[Math.min(L.length, Q + 1)],
            trail: B = B + y,
            config: Br(b, Z, Y),
            to: Br(g, Z)
          })), delete z[ee];
        });
        break;
      }
      case Gd: {
        re.forEach((ee) => {
          const Q = c.indexOf(ee), Z = u[Q], Y = Gd;
          z[ee] = ln({}, z[ee], {
            item: Z,
            slot: Y,
            trail: B = B + y,
            config: Br(b, Z, Y),
            to: Br(x, Z)
          });
        });
        break;
      }
    }
  let j = c.map((se) => z[se]);
  return W.forEach((se) => {
    let ee = se.left;
    se.right;
    let Q = ea(se, ["left", "right"]), Z;
    (Z = j.findIndex((Y) => Y.originalKey === ee)) !== -1 && (Z += 1), Z = Math.max(0, Z), j = [...j.slice(0, Z), Q, ...j.slice(Z)];
  }), ln({}, a, {
    changed: le.length || K.length || re.length,
    first: n && le.length === 0,
    transitions: j,
    current: z,
    deleted: W,
    prevProps: t
  });
}
class Db extends cy {
  constructor(t) {
    t === void 0 && (t = {}), super(), t.transform && !(t.transform instanceof Ir) && (t = tp.transform(t)), this.payload = t;
  }
}
const ru = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, $r = "[-+]?\\d*\\.?\\d+", au = $r + "%";
function _u() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const _b = new RegExp("rgb" + _u($r, $r, $r)), Ob = new RegExp("rgba" + _u($r, $r, $r, $r)), Fb = new RegExp("hsl" + _u($r, au, au)), Mb = new RegExp("hsla" + _u($r, au, au, $r)), zb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Bb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Ib = /^#([0-9a-fA-F]{6})$/, $b = /^#([0-9a-fA-F]{8})$/;
function Hb(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = Ib.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : ru.hasOwnProperty(e) ? ru[e] : (t = _b.exec(e)) ? (Xo(t[1]) << 24 | // r
  Xo(t[2]) << 16 | // g
  Xo(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = Ob.exec(e)) ? (Xo(t[1]) << 24 | // r
  Xo(t[2]) << 16 | // g
  Xo(t[3]) << 8 | // b
  xh(t[4])) >>> // a
  0 : (t = zb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = $b.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = Bb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = Fb.exec(e)) ? (gh(
    vh(t[1]),
    // h
    Lc(t[2]),
    // s
    Lc(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = Mb.exec(e)) ? (gh(
    vh(t[1]),
    // h
    Lc(t[2]),
    // s
    Lc(t[3])
    // l
  ) | xh(t[4])) >>> // a
  0 : null;
}
function Xd(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function gh(e, t, n) {
  const r = n < 0.5 ? n * (1 + t) : n + t - n * t, a = 2 * n - r, i = Xd(a, r, e + 1 / 3), u = Xd(a, r, e), c = Xd(a, r, e - 1 / 3);
  return Math.round(i * 255) << 24 | Math.round(u * 255) << 16 | Math.round(c * 255) << 8;
}
function Xo(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function vh(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function xh(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function Lc(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function bh(e) {
  let t = Hb(e);
  if (t === null)
    return e;
  t = t || 0;
  let n = (t & 4278190080) >>> 24, r = (t & 16711680) >>> 16, a = (t & 65280) >>> 8, i = (t & 255) / 255;
  return `rgba(${n}, ${r}, ${a}, ${i})`;
}
const Nc = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Vb = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Wb = new RegExp(`(${Object.keys(ru).join("|")})`, "g"), jb = (e) => {
  const t = e.output.map((a) => a.replace(Vb, bh)).map((a) => a.replace(Wb, bh)), n = t[0].match(Nc).map(() => []);
  t.forEach((a) => {
    a.match(Nc).forEach((i, u) => n[u].push(+i));
  });
  const r = t[0].match(Nc).map((a, i) => nu(ln({}, e, {
    output: n[i]
  })));
  return (a) => {
    let i = 0;
    return t[0].replace(Nc, () => r[i++](a)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (u, c, l, p, h) => `rgba(${Math.round(c)}, ${Math.round(l)}, ${Math.round(p)}, ${h})`);
  };
};
let ms = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const Ub = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), Kb = ["Webkit", "Ms", "Moz", "O"];
ms = Object.keys(ms).reduce((e, t) => (Kb.forEach((n) => e[Ub(n, t)] = e[t]), e), ms);
function Yb(e, t, n) {
  return t == null || typeof t == "boolean" || t === "" ? "" : !n && typeof t == "number" && t !== 0 && !(ms.hasOwnProperty(e) && ms[e]) ? t + "px" : ("" + t).trim();
}
const Eh = {};
yb((e) => new Db(e));
hb(jb);
pb(ru);
fb((e, t) => {
  if (e.nodeType && e.setAttribute !== void 0) {
    const a = t.style, i = t.children, u = t.scrollTop, c = t.scrollLeft, l = ea(t, ["style", "children", "scrollTop", "scrollLeft"]), p = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter";
    u !== void 0 && (e.scrollTop = u), c !== void 0 && (e.scrollLeft = c), i !== void 0 && (e.textContent = i);
    for (let h in a)
      if (a.hasOwnProperty(h)) {
        var n = h.indexOf("--") === 0, r = Yb(h, a[h], n);
        h === "float" && (h = "cssFloat"), n ? e.style.setProperty(h, r) : e.style[h] = r;
      }
    for (let h in l) {
      const g = p ? h : Eh[h] || (Eh[h] = h.replace(/([A-Z])/g, (x) => "-" + x.toLowerCase()));
      typeof e.getAttribute(g) < "u" && e.setAttribute(g, l[h]);
    }
    return;
  } else
    return !1;
}, (e) => e);
const Gb = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Xb = cb(xb, !1), Sh = Xb(Gb);
function qb(e) {
  return e.innerRadius;
}
function Zb(e) {
  return e.outerRadius;
}
function Qb(e) {
  return e.startAngle;
}
function Jb(e) {
  return e.endAngle;
}
function e0(e) {
  return e && e.padAngle;
}
function t0(e, t, n, r, a, i, u, c) {
  var l = n - e, p = r - t, h = u - a, g = c - i, x = g * l - h * p;
  if (!(x * x < Jn))
    return x = (h * (t - i) - g * (e - a)) / x, [e + x * l, t + x * p];
}
function Pc(e, t, n, r, a, i, u) {
  var c = e - n, l = t - r, p = (u ? i : -i) / el(c * c + l * l), h = p * l, g = -p * c, x = e + h, w = t + g, y = n + h, R = r + g, b = (x + y) / 2, v = (w + R) / 2, A = y - x, N = R - w, L = A * A + N * N, C = a - i, z = x * R - y * w, W = (N < 0 ? -1 : 1) * el(wg(0, C * C * L - z * z)), q = (z * N - A * W) / L, ne = (-z * A - N * W) / L, G = (z * N + A * W) / L, le = (-z * A + N * W) / L, K = q - b, re = ne - v, B = G - b, j = le - v;
  return K * K + re * re > B * B + j * j && (q = G, ne = le), {
    cx: q,
    cy: ne,
    x01: -h,
    y01: -g,
    x11: q * (a / C - 1),
    y11: ne * (a / C - 1)
  };
}
function n0() {
  var e = qb, t = Zb, n = It(0), r = null, a = Qb, i = Jb, u = e0, c = null;
  function l() {
    var p, h, g = +e.apply(this, arguments), x = +t.apply(this, arguments), w = a.apply(this, arguments) - Lp, y = i.apply(this, arguments) - Lp, R = Np(y - w), b = y > w;
    if (c || (c = p = Au()), x < g && (h = x, x = g, g = h), !(x > Jn))
      c.moveTo(0, 0);
    else if (R > Ic - Jn)
      c.moveTo(x * Ai(w), x * qr(w)), c.arc(0, 0, x, w, y, !b), g > Jn && (c.moveTo(g * Ai(y), g * qr(y)), c.arc(0, 0, g, y, w, b));
    else {
      var v = w, A = y, N = w, L = y, C = R, z = R, W = u.apply(this, arguments) / 2, q = W > Jn && (r ? +r.apply(this, arguments) : el(g * g + x * x)), ne = Md(Np(x - g) / 2, +n.apply(this, arguments)), G = ne, le = ne, K, re;
      if (q > Jn) {
        var B = Pp(q / g * qr(W)), j = Pp(q / x * qr(W));
        (C -= B * 2) > Jn ? (B *= b ? 1 : -1, N += B, L -= B) : (C = 0, N = L = (w + y) / 2), (z -= j * 2) > Jn ? (j *= b ? 1 : -1, v += j, A -= j) : (z = 0, v = A = (w + y) / 2);
      }
      var se = x * Ai(v), ee = x * qr(v), Q = g * Ai(L), Z = g * qr(L);
      if (ne > Jn) {
        var Y = x * Ai(A), te = x * qr(A), $ = g * Ai(N), ce = g * qr(N), Se;
        if (R < Ap && (Se = t0(se, ee, $, ce, Y, te, Q, Z))) {
          var be = se - Se[0], ve = ee - Se[1], Pe = Y - Se[0], Ve = te - Se[1], we = 1 / qr(kg((be * Pe + ve * Ve) / (el(be * be + ve * ve) * el(Pe * Pe + Ve * Ve))) / 2), me = el(Se[0] * Se[0] + Se[1] * Se[1]);
          G = Md(ne, (g - me) / (we - 1)), le = Md(ne, (x - me) / (we + 1));
        }
      }
      z > Jn ? le > Jn ? (K = Pc($, ce, se, ee, x, le, b), re = Pc(Y, te, Q, Z, x, le, b), c.moveTo(K.cx + K.x01, K.cy + K.y01), le < ne ? c.arc(K.cx, K.cy, le, qn(K.y01, K.x01), qn(re.y01, re.x01), !b) : (c.arc(K.cx, K.cy, le, qn(K.y01, K.x01), qn(K.y11, K.x11), !b), c.arc(0, 0, x, qn(K.cy + K.y11, K.cx + K.x11), qn(re.cy + re.y11, re.cx + re.x11), !b), c.arc(re.cx, re.cy, le, qn(re.y11, re.x11), qn(re.y01, re.x01), !b))) : (c.moveTo(se, ee), c.arc(0, 0, x, v, A, !b)) : c.moveTo(se, ee), !(g > Jn) || !(C > Jn) ? c.lineTo(Q, Z) : G > Jn ? (K = Pc(Q, Z, Y, te, g, -G, b), re = Pc(se, ee, $, ce, g, -G, b), c.lineTo(K.cx + K.x01, K.cy + K.y01), G < ne ? c.arc(K.cx, K.cy, G, qn(K.y01, K.x01), qn(re.y01, re.x01), !b) : (c.arc(K.cx, K.cy, G, qn(K.y01, K.x01), qn(K.y11, K.x11), !b), c.arc(0, 0, g, qn(K.cy + K.y11, K.cx + K.x11), qn(re.cy + re.y11, re.cx + re.x11), b), c.arc(re.cx, re.cy, G, qn(re.y11, re.x11), qn(re.y01, re.x01), !b))) : c.arc(0, 0, g, L, N, b);
    }
    if (c.closePath(), p)
      return c = null, p + "" || null;
  }
  return l.centroid = function() {
    var p = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, h = (+a.apply(this, arguments) + +i.apply(this, arguments)) / 2 - Ap / 2;
    return [Ai(h) * p, qr(h) * p];
  }, l.innerRadius = function(p) {
    return arguments.length ? (e = typeof p == "function" ? p : It(+p), l) : e;
  }, l.outerRadius = function(p) {
    return arguments.length ? (t = typeof p == "function" ? p : It(+p), l) : t;
  }, l.cornerRadius = function(p) {
    return arguments.length ? (n = typeof p == "function" ? p : It(+p), l) : n;
  }, l.padRadius = function(p) {
    return arguments.length ? (r = p == null ? null : typeof p == "function" ? p : It(+p), l) : r;
  }, l.startAngle = function(p) {
    return arguments.length ? (a = typeof p == "function" ? p : It(+p), l) : a;
  }, l.endAngle = function(p) {
    return arguments.length ? (i = typeof p == "function" ? p : It(+p), l) : i;
  }, l.padAngle = function(p) {
    return arguments.length ? (u = typeof p == "function" ? p : It(+p), l) : u;
  }, l.context = function(p) {
    return arguments.length ? (c = p ?? null, l) : c;
  }, l;
}
function yy(e) {
  this._context = e;
}
yy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Ou(e) {
  return new yy(e);
}
function np(e) {
  return e[0];
}
function rp(e) {
  return e[1];
}
function gy() {
  var e = np, t = rp, n = It(!0), r = null, a = Ou, i = null;
  function u(c) {
    var l, p = c.length, h, g = !1, x;
    for (r == null && (i = a(x = Au())), l = 0; l <= p; ++l)
      !(l < p && n(h = c[l], l, c)) === g && ((g = !g) ? i.lineStart() : i.lineEnd()), g && i.point(+e(h, l, c), +t(h, l, c));
    if (x)
      return i = null, x + "" || null;
  }
  return u.x = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : It(+c), u) : e;
  }, u.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : It(+c), u) : t;
  }, u.defined = function(c) {
    return arguments.length ? (n = typeof c == "function" ? c : It(!!c), u) : n;
  }, u.curve = function(c) {
    return arguments.length ? (a = c, r != null && (i = a(r)), u) : a;
  }, u.context = function(c) {
    return arguments.length ? (c == null ? r = i = null : i = a(r = c), u) : r;
  }, u;
}
function r0() {
  var e = np, t = null, n = It(0), r = rp, a = It(!0), i = null, u = Ou, c = null;
  function l(h) {
    var g, x, w, y = h.length, R, b = !1, v, A = new Array(y), N = new Array(y);
    for (i == null && (c = u(v = Au())), g = 0; g <= y; ++g) {
      if (!(g < y && a(R = h[g], g, h)) === b)
        if (b = !b)
          x = g, c.areaStart(), c.lineStart();
        else {
          for (c.lineEnd(), c.lineStart(), w = g - 1; w >= x; --w)
            c.point(A[w], N[w]);
          c.lineEnd(), c.areaEnd();
        }
      b && (A[g] = +e(R, g, h), N[g] = +n(R, g, h), c.point(t ? +t(R, g, h) : A[g], r ? +r(R, g, h) : N[g]));
    }
    if (v)
      return c = null, v + "" || null;
  }
  function p() {
    return gy().defined(a).curve(u).context(i);
  }
  return l.x = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : It(+h), t = null, l) : e;
  }, l.x0 = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : It(+h), l) : e;
  }, l.x1 = function(h) {
    return arguments.length ? (t = h == null ? null : typeof h == "function" ? h : It(+h), l) : t;
  }, l.y = function(h) {
    return arguments.length ? (n = typeof h == "function" ? h : It(+h), r = null, l) : n;
  }, l.y0 = function(h) {
    return arguments.length ? (n = typeof h == "function" ? h : It(+h), l) : n;
  }, l.y1 = function(h) {
    return arguments.length ? (r = h == null ? null : typeof h == "function" ? h : It(+h), l) : r;
  }, l.lineX0 = l.lineY0 = function() {
    return p().x(e).y(n);
  }, l.lineY1 = function() {
    return p().x(e).y(r);
  }, l.lineX1 = function() {
    return p().x(t).y(n);
  }, l.defined = function(h) {
    return arguments.length ? (a = typeof h == "function" ? h : It(!!h), l) : a;
  }, l.curve = function(h) {
    return arguments.length ? (u = h, i != null && (c = u(i)), l) : u;
  }, l.context = function(h) {
    return arguments.length ? (h == null ? i = c = null : c = u(i = h), l) : i;
  }, l;
}
function a0(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function i0(e) {
  return e;
}
function o0() {
  var e = i0, t = a0, n = null, r = It(0), a = It(Ic), i = It(0);
  function u(c) {
    var l, p = c.length, h, g, x = 0, w = new Array(p), y = new Array(p), R = +r.apply(this, arguments), b = Math.min(Ic, Math.max(-Ic, a.apply(this, arguments) - R)), v, A = Math.min(Math.abs(b) / p, i.apply(this, arguments)), N = A * (b < 0 ? -1 : 1), L;
    for (l = 0; l < p; ++l)
      (L = y[w[l] = l] = +e(c[l], l, c)) > 0 && (x += L);
    for (t != null ? w.sort(function(C, z) {
      return t(y[C], y[z]);
    }) : n != null && w.sort(function(C, z) {
      return n(c[C], c[z]);
    }), l = 0, g = x ? (b - p * N) / x : 0; l < p; ++l, R = v)
      h = w[l], L = y[h], v = R + (L > 0 ? L * g : 0) + N, y[h] = {
        data: c[h],
        index: l,
        value: L,
        startAngle: R,
        endAngle: v,
        padAngle: A
      };
    return y;
  }
  return u.value = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : It(+c), u) : e;
  }, u.sortValues = function(c) {
    return arguments.length ? (t = c, n = null, u) : t;
  }, u.sort = function(c) {
    return arguments.length ? (n = c, t = null, u) : n;
  }, u.startAngle = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : It(+c), u) : r;
  }, u.endAngle = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : It(+c), u) : a;
  }, u.padAngle = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : It(+c), u) : i;
  }, u;
}
var Sf = Array.prototype.slice;
function l0(e) {
  return e.source;
}
function s0(e) {
  return e.target;
}
function c0(e) {
  var t = l0, n = s0, r = np, a = rp, i = null;
  function u() {
    var c, l = Sf.call(arguments), p = t.apply(this, l), h = n.apply(this, l);
    if (i || (i = c = Au()), e(i, +r.apply(this, (l[0] = p, l)), +a.apply(this, l), +r.apply(this, (l[0] = h, l)), +a.apply(this, l)), c)
      return i = null, c + "" || null;
  }
  return u.source = function(c) {
    return arguments.length ? (t = c, u) : t;
  }, u.target = function(c) {
    return arguments.length ? (n = c, u) : n;
  }, u.x = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : It(+c), u) : r;
  }, u.y = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : It(+c), u) : a;
  }, u.context = function(c) {
    return arguments.length ? (i = c ?? null, u) : i;
  }, u;
}
function u0(e, t, n, r, a) {
  e.moveTo(t, n), e.bezierCurveTo(t = (t + r) / 2, n, t, a, r, a);
}
function d0() {
  return c0(u0);
}
const f0 = {
  draw: function(e, t) {
    var n = Math.sqrt(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
};
function Ya() {
}
function iu(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function Fu(e) {
  this._context = e;
}
Fu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        iu(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        iu(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function p0(e) {
  return new Fu(e);
}
function vy(e) {
  this._context = e;
}
vy.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        iu(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function h0(e) {
  return new vy(e);
}
function xy(e) {
  this._context = e;
}
xy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      default:
        iu(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function m0(e) {
  return new xy(e);
}
function by(e, t) {
  this._basis = new Fu(e), this._beta = t;
}
by.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var r = e[0], a = t[0], i = e[n] - r, u = t[n] - a, c = -1, l; ++c <= n; )
        l = c / n, this._basis.point(
          this._beta * e[c] + (1 - this._beta) * (r + l * i),
          this._beta * t[c] + (1 - this._beta) * (a + l * u)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const y0 = function e(t) {
  function n(r) {
    return t === 1 ? new Fu(r) : new by(r, t);
  }
  return n.beta = function(r) {
    return e(+r);
  }, n;
}(0.85);
function ou(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function ap(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
ap.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        ou(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        ou(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const g0 = function e(t) {
  function n(r) {
    return new ap(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function ip(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
ip.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        ou(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const v0 = function e(t) {
  function n(r) {
    return new ip(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function op(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
op.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        ou(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const x0 = function e(t) {
  function n(r) {
    return new op(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function lp(e, t, n) {
  var r = e._x1, a = e._y1, i = e._x2, u = e._y2;
  if (e._l01_a > Jn) {
    var c = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, l = 3 * e._l01_a * (e._l01_a + e._l12_a);
    r = (r * c - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, a = (a * c - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l;
  }
  if (e._l23_a > Jn) {
    var p = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, h = 3 * e._l23_a * (e._l23_a + e._l12_a);
    i = (i * p + e._x1 * e._l23_2a - t * e._l12_2a) / h, u = (u * p + e._y1 * e._l23_2a - n * e._l12_2a) / h;
  }
  e._context.bezierCurveTo(r, a, i, u, e._x2, e._y2);
}
function Ey(e, t) {
  this._context = e, this._alpha = t;
}
Ey.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        lp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const b0 = function e(t) {
  function n(r) {
    return t ? new Ey(r, t) : new ap(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Sy(e, t) {
  this._context = e, this._alpha = t;
}
Sy.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        lp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const E0 = function e(t) {
  function n(r) {
    return t ? new Sy(r, t) : new ip(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function ky(e, t) {
  this._context = e, this._alpha = t;
}
ky.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        lp(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const S0 = function e(t) {
  function n(r) {
    return t ? new ky(r, t) : new op(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function wy(e) {
  this._context = e;
}
wy.prototype = {
  areaStart: Ya,
  areaEnd: Ya,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function kf(e) {
  return new wy(e);
}
function kh(e) {
  return e < 0 ? -1 : 1;
}
function wh(e, t, n) {
  var r = e._x1 - e._x0, a = t - e._x1, i = (e._y1 - e._y0) / (r || a < 0 && -0), u = (n - e._y1) / (a || r < 0 && -0), c = (i * a + u * r) / (r + a);
  return (kh(i) + kh(u)) * Math.min(Math.abs(i), Math.abs(u), 0.5 * Math.abs(c)) || 0;
}
function Th(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function qd(e, t, n) {
  var r = e._x0, a = e._y0, i = e._x1, u = e._y1, c = (i - r) / 3;
  e._context.bezierCurveTo(r + c, a + c * t, i - c, u - c * n, i, u);
}
function lu(e) {
  this._context = e;
}
lu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        qd(this, this._t0, Th(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, qd(this, Th(this, n = wh(this, e, t)), n);
          break;
        default:
          qd(this, this._t0, n = wh(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function Ty(e) {
  this._context = new Ry(e);
}
(Ty.prototype = Object.create(lu.prototype)).point = function(e, t) {
  lu.prototype.point.call(this, t, e);
};
function Ry(e) {
  this._context = e;
}
Ry.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, a, i) {
    this._context.bezierCurveTo(t, e, r, n, i, a);
  }
};
function Wc(e) {
  return new lu(e);
}
function k0(e) {
  return new Ty(e);
}
function Cy(e) {
  this._context = e;
}
Cy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = Rh(e), a = Rh(t), i = 0, u = 1; u < n; ++i, ++u)
          this._context.bezierCurveTo(r[0][i], a[0][i], r[1][i], a[1][i], e[u], t[u]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Rh(e) {
  var t, n = e.length - 1, r, a = new Array(n), i = new Array(n), u = new Array(n);
  for (a[0] = 0, i[0] = 2, u[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    a[t] = 1, i[t] = 4, u[t] = 4 * e[t] + 2 * e[t + 1];
  for (a[n - 1] = 2, i[n - 1] = 7, u[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    r = a[t] / i[t - 1], i[t] -= r, u[t] -= r * u[t - 1];
  for (a[n - 1] = u[n - 1] / i[n - 1], t = n - 2; t >= 0; --t)
    a[t] = (u[t] - a[t + 1]) / i[t];
  for (i[n - 1] = (e[n] + a[n - 1]) / 2, t = 0; t < n - 1; ++t)
    i[t] = 2 * e[t + 1] - a[t + 1];
  return [a, i];
}
function w0(e) {
  return new Cy(e);
}
function Mu(e, t) {
  this._context = e, this._t = t;
}
Mu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function T0(e) {
  return new Mu(e, 0.5);
}
function R0(e) {
  return new Mu(e, 0);
}
function C0(e) {
  return new Mu(e, 1);
}
function ul(e, t) {
  if ((u = e.length) > 1)
    for (var n = 1, r, a, i = e[t[0]], u, c = i.length; n < u; ++n)
      for (a = i, i = e[t[n]], r = 0; r < c; ++r)
        i[r][1] += i[r][0] = isNaN(a[r][1]) ? a[r][0] : a[r][1];
}
function dl(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; )
    n[t] = t;
  return n;
}
function A0(e, t) {
  return e[t];
}
function sp() {
  var e = It([]), t = dl, n = ul, r = A0;
  function a(i) {
    var u = e.apply(this, arguments), c, l = i.length, p = u.length, h = new Array(p), g;
    for (c = 0; c < p; ++c) {
      for (var x = u[c], w = h[c] = new Array(l), y = 0, R; y < l; ++y)
        w[y] = R = [0, +r(i[y], x, y, i)], R.data = i[y];
      w.key = x;
    }
    for (c = 0, g = t(h); c < p; ++c)
      h[g[c]].index = c;
    return n(h, g), h;
  }
  return a.keys = function(i) {
    return arguments.length ? (e = typeof i == "function" ? i : It(Sf.call(i)), a) : e;
  }, a.value = function(i) {
    return arguments.length ? (r = typeof i == "function" ? i : It(+i), a) : r;
  }, a.order = function(i) {
    return arguments.length ? (t = i == null ? dl : typeof i == "function" ? i : It(Sf.call(i)), a) : t;
  }, a.offset = function(i) {
    return arguments.length ? (n = i ?? ul, a) : n;
  }, a;
}
function L0(e, t) {
  if ((r = e.length) > 0) {
    for (var n, r, a = 0, i = e[0].length, u; a < i; ++a) {
      for (u = n = 0; n < r; ++n)
        u += e[n][a][1] || 0;
      if (u)
        for (n = 0; n < r; ++n)
          e[n][a][1] /= u;
    }
    ul(e, t);
  }
}
function N0(e, t) {
  if ((l = e.length) > 0)
    for (var n, r = 0, a, i, u, c, l, p = e[t[0]].length; r < p; ++r)
      for (u = c = 0, n = 0; n < l; ++n)
        (i = (a = e[t[n]][r])[1] - a[0]) > 0 ? (a[0] = u, a[1] = u += i) : i < 0 ? (a[1] = c, a[0] = c += i) : (a[0] = 0, a[1] = i);
}
function P0(e, t) {
  if ((a = e.length) > 0) {
    for (var n = 0, r = e[t[0]], a, i = r.length; n < i; ++n) {
      for (var u = 0, c = 0; u < a; ++u)
        c += e[u][n][1] || 0;
      r[n][1] += r[n][0] = -c / 2;
    }
    ul(e, t);
  }
}
function D0(e, t) {
  if (!(!((u = e.length) > 0) || !((i = (a = e[t[0]]).length) > 0))) {
    for (var n = 0, r = 1, a, i, u; r < i; ++r) {
      for (var c = 0, l = 0, p = 0; c < u; ++c) {
        for (var h = e[t[c]], g = h[r][1] || 0, x = h[r - 1][1] || 0, w = (g - x) / 2, y = 0; y < c; ++y) {
          var R = e[t[y]], b = R[r][1] || 0, v = R[r - 1][1] || 0;
          w += b - v;
        }
        l += g, p += w * g;
      }
      a[r - 1][1] += a[r - 1][0] = n, l && (n -= p / l);
    }
    a[r - 1][1] += a[r - 1][0] = n, ul(e, t);
  }
}
function _0(e) {
  var t = e.map(O0);
  return dl(e).sort(function(n, r) {
    return t[n] - t[r];
  });
}
function O0(e) {
  for (var t = -1, n = 0, r = e.length, a, i = -1 / 0; ++t < r; )
    (a = +e[t][1]) > i && (i = a, n = t);
  return n;
}
function Ay(e) {
  var t = e.map(Ly);
  return dl(e).sort(function(n, r) {
    return t[n] - t[r];
  });
}
function Ly(e) {
  for (var t = 0, n = -1, r = e.length, a; ++n < r; )
    (a = +e[n][1]) && (t += a);
  return t;
}
function F0(e) {
  return Ay(e).reverse();
}
function M0(e) {
  var t = e.length, n, r, a = e.map(Ly), i = _0(e), u = 0, c = 0, l = [], p = [];
  for (n = 0; n < t; ++n)
    r = i[n], u < c ? (u += a[r], l.push(r)) : (c += a[r], p.push(r));
  return p.reverse().concat(l);
}
function z0(e) {
  return dl(e).reverse();
}
function mn(e, t) {
  e(t);
}
var Ch = {
  ascending: Ay,
  descending: F0,
  insideout: M0,
  none: dl,
  reverse: z0
};
function cp(e) {
  return e && Ch[e] || Ch.none;
}
var Ah = {
  expand: L0,
  diverging: N0,
  none: ul,
  silhouette: P0,
  wiggle: D0
};
function up(e) {
  return e && Ah[e] || Ah.none;
}
function B0(e) {
  var t = e === void 0 ? {} : e, n = t.innerRadius, r = t.outerRadius, a = t.cornerRadius, i = t.startAngle, u = t.endAngle, c = t.padAngle, l = t.padRadius, p = n0();
  return n != null && mn(p.innerRadius, n), r != null && mn(p.outerRadius, r), a != null && mn(p.cornerRadius, a), i != null && mn(p.startAngle, i), u != null && mn(p.endAngle, u), c != null && mn(p.padAngle, c), l != null && mn(p.padRadius, l), p;
}
function dp(e) {
  var t = e === void 0 ? {} : e, n = t.x, r = t.x0, a = t.x1, i = t.y, u = t.y0, c = t.y1, l = t.defined, p = t.curve, h = r0();
  return n && mn(h.x, n), r && mn(h.x0, r), a && mn(h.x1, a), i && mn(h.y, i), u && mn(h.y0, u), c && mn(h.y1, c), l && h.defined(l), p && h.curve(p), h;
}
function Ny(e) {
  var t = e === void 0 ? {} : e, n = t.x, r = t.y, a = t.defined, i = t.curve, u = gy();
  return n && mn(u.x, n), r && mn(u.y, r), a && u.defined(a), i && u.curve(i), u;
}
function I0(e) {
  var t = e === void 0 ? {} : e, n = t.startAngle, r = t.endAngle, a = t.padAngle, i = t.value, u = t.sort, c = t.sortValues, l = o0();
  return (u === null || u != null) && l.sort(u), (c === null || c != null) && l.sortValues(c), i != null && l.value(i), a != null && mn(l.padAngle, a), n != null && mn(l.startAngle, n), r != null && mn(l.endAngle, r), l;
}
function $0(e) {
  var t = e.keys, n = e.value, r = e.order, a = e.offset, i = sp();
  return t && i.keys(t), n && mn(i.value, n), r && i.order(cp(r)), a && i.offset(up(a)), i;
}
var H0 = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function wf() {
  return wf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, wf.apply(this, arguments);
}
function V0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function W0(e) {
  var t = e.className, n = e.top, r = e.left, a = e.data, i = a === void 0 ? [] : a, u = e.centroid, c = e.innerRadius, l = c === void 0 ? 0 : c, p = e.outerRadius, h = e.cornerRadius, g = e.startAngle, x = e.endAngle, w = e.padAngle, y = e.padRadius, R = e.pieSort, b = e.pieSortValues, v = e.pieValue, A = e.children, N = e.fill, L = N === void 0 ? "" : N, C = V0(e, H0), z = B0({
    innerRadius: l,
    outerRadius: p,
    cornerRadius: h,
    padRadius: y
  }), W = I0({
    startAngle: g,
    endAngle: x,
    padAngle: w,
    value: v,
    sort: R,
    sortValues: b
  }), q = W(i);
  return A ? /* @__PURE__ */ m.createElement(m.Fragment, null, A({
    arcs: q,
    path: z,
    pie: W
  })) : /* @__PURE__ */ m.createElement(tt, {
    className: "visx-pie-arcs-group",
    top: n,
    left: r
  }, q.map(function(ne, G) {
    return /* @__PURE__ */ m.createElement("g", {
      key: "pie-arc-" + G
    }, /* @__PURE__ */ m.createElement("path", wf({
      className: Sn("visx-pie-arc", t),
      d: z(ne) || "",
      fill: L == null || typeof L == "string" ? L : L(ne)
    }, C)), u == null ? void 0 : u(z.centroid(ne), ne));
  }));
}
var j0 = ["from", "to", "fill", "className", "innerRef"];
function Tf() {
  return Tf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Tf.apply(this, arguments);
}
function U0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function en(e) {
  var t = e.from, n = t === void 0 ? {
    x: 0,
    y: 0
  } : t, r = e.to, a = r === void 0 ? {
    x: 1,
    y: 1
  } : r, i = e.fill, u = i === void 0 ? "transparent" : i, c = e.className, l = e.innerRef, p = U0(e, j0), h = n.x === a.x || n.y === a.y;
  return /* @__PURE__ */ m.createElement("line", Tf({
    ref: l,
    className: Sn("visx-line", c),
    x1: n.x,
    y1: n.y,
    x2: a.x,
    y2: a.y,
    fill: u,
    shapeRendering: h ? "crispEdges" : "auto"
  }, p));
}
var K0 = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function Rf() {
  return Rf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Rf.apply(this, arguments);
}
function Y0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function Hr(e) {
  var t = e.children, n = e.data, r = n === void 0 ? [] : n, a = e.x, i = e.y, u = e.fill, c = u === void 0 ? "transparent" : u, l = e.className, p = e.curve, h = e.innerRef, g = e.defined, x = g === void 0 ? function() {
    return !0;
  } : g, w = Y0(e, K0), y = Ny({
    x: a,
    y: i,
    defined: x,
    curve: p
  });
  return t ? /* @__PURE__ */ m.createElement(m.Fragment, null, t({
    path: y
  })) : /* @__PURE__ */ m.createElement("path", Rf({
    ref: h,
    className: Sn("visx-linepath", l),
    d: y(r) || "",
    fill: c,
    strokeLinecap: "round"
  }, w));
}
var G0 = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function Cf() {
  return Cf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Cf.apply(this, arguments);
}
function X0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function q0(e) {
  var t = e.children, n = e.x, r = e.x0, a = e.x1, i = e.y, u = e.y0, c = e.y1, l = e.data, p = l === void 0 ? [] : l, h = e.defined, g = h === void 0 ? function() {
    return !0;
  } : h, x = e.className, w = e.curve, y = e.innerRef, R = X0(e, G0), b = dp({
    x: n,
    x0: r,
    x1: a,
    y: i,
    y0: u,
    y1: c,
    defined: g,
    curve: w
  });
  return t ? /* @__PURE__ */ m.createElement(m.Fragment, null, t({
    path: b
  })) : /* @__PURE__ */ m.createElement("path", Cf({
    ref: y,
    className: Sn("visx-area", x),
    d: b(p) || ""
  }, R));
}
var Z0 = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function Af() {
  return Af = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Af.apply(this, arguments);
}
function Q0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function Lf(e) {
  var t = e.x, n = e.x0, r = e.x1, a = e.y, i = e.y1, u = e.y0, c = e.yScale, l = e.data, p = l === void 0 ? [] : l, h = e.defined, g = h === void 0 ? function() {
    return !0;
  } : h, x = e.className, w = e.curve, y = e.innerRef, R = e.children, b = Q0(e, Z0), v = dp({
    x: t,
    x0: n,
    x1: r,
    defined: g,
    curve: w
  });
  return u == null ? v.y0(c.range()[0]) : mn(v.y0, u), a && !i && mn(v.y1, a), i && !a && mn(v.y1, i), R ? /* @__PURE__ */ m.createElement(m.Fragment, null, R({
    path: v
  })) : /* @__PURE__ */ m.createElement("path", Af({
    ref: y,
    className: Sn("visx-area-closed", x),
    d: v(p) || ""
  }, b));
}
var J0 = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function Nf() {
  return Nf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Nf.apply(this, arguments);
}
function eE(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function tE(e) {
  var t = e.className, n = e.top, r = e.left, a = e.keys, i = e.data, u = e.curve, c = e.defined, l = e.x, p = e.x0, h = e.x1, g = e.y0, x = e.y1, w = e.value, y = e.order, R = e.offset, b = e.color, v = e.children, A = eE(e, J0), N = $0({
    keys: a,
    value: w,
    order: y,
    offset: R
  }), L = dp({
    x: l,
    x0: p,
    x1: h,
    y0: g,
    y1: x,
    curve: u,
    defined: c
  }), C = N(i);
  return v ? /* @__PURE__ */ m.createElement(m.Fragment, null, v({
    stacks: C,
    path: L,
    stack: N
  })) : /* @__PURE__ */ m.createElement(tt, {
    top: n,
    left: r
  }, C.map(function(z, W) {
    return /* @__PURE__ */ m.createElement("path", Nf({
      className: Sn("visx-stack", t),
      key: "stack-" + W + "-" + (z.key || ""),
      d: L(z) || "",
      fill: b == null ? void 0 : b(z.key, W)
    }, A));
  }));
}
var nE = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function su() {
  return su = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, su.apply(this, arguments);
}
function rE(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function aE(e) {
  var t = e.className, n = e.top, r = e.left, a = e.keys, i = e.data, u = e.curve, c = e.defined, l = e.x, p = e.x0, h = e.x1, g = e.y0, x = e.y1, w = e.value, y = e.order, R = e.offset, b = e.color, v = e.children, A = rE(e, nE);
  return /* @__PURE__ */ m.createElement(tE, su({
    className: t,
    top: n,
    left: r,
    keys: a,
    data: i,
    curve: u,
    defined: c,
    x: l,
    x0: p,
    x1: h,
    y0: g,
    y1: x,
    value: w,
    order: y,
    offset: R,
    color: b
  }, A), v || function(N) {
    var L = N.stacks, C = N.path;
    return L.map(function(z, W) {
      return /* @__PURE__ */ m.createElement("path", su({
        className: Sn("visx-area-stack", t),
        key: "area-stack-" + W + "-" + (z.key || ""),
        d: C(z) || "",
        fill: b == null ? void 0 : b(z.key, W)
      }, A));
    });
  });
}
function fp(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), n = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / n.length;
}
var iE = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function Pf() {
  return Pf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Pf.apply(this, arguments);
}
function oE(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function Py(e) {
  var t = e.data, n = e.className, r = e.top, a = e.left, i = e.x0, u = e.x0Scale, c = e.x1Scale, l = e.yScale, p = e.color, h = e.keys, g = e.height, x = e.children, w = oE(e, iE), y = fp(c), R = t.map(function(b, v) {
    return {
      index: v,
      x0: u(i(b)),
      bars: h.map(function(A, N) {
        var L = b[A];
        return {
          index: N,
          key: A,
          value: L,
          width: y,
          x: c(A) || 0,
          y: l(L) || 0,
          color: p(A, N),
          height: g - (l(L) || 0)
        };
      })
    };
  });
  return x ? /* @__PURE__ */ m.createElement(m.Fragment, null, x(R)) : /* @__PURE__ */ m.createElement(tt, {
    className: Sn("visx-bar-group", n),
    top: r,
    left: a
  }, R.map(function(b) {
    return /* @__PURE__ */ m.createElement(tt, {
      key: "bar-group-" + b.index + "-" + b.x0,
      left: b.x0
    }, b.bars.map(function(v) {
      return /* @__PURE__ */ m.createElement(Nr, Pf({
        key: "bar-group-bar-" + b.index + "-" + v.index + "-" + v.value + "-" + v.key,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height,
        fill: v.color
      }, w));
    }));
  }));
}
function Dy(e) {
  return e == null ? void 0 : e[0];
}
function _y(e) {
  return e == null ? void 0 : e[1];
}
var lE = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function Df() {
  return Df = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Df.apply(this, arguments);
}
function sE(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function Oy(e) {
  var t = e.data, n = e.className, r = e.top, a = e.left, i = e.x, u = e.y0, c = u === void 0 ? Dy : u, l = e.y1, p = l === void 0 ? _y : l, h = e.xScale, g = e.yScale, x = e.color, w = e.keys, y = e.value, R = e.order, b = e.offset, v = e.children, A = sE(e, lE), N = sp();
  w && N.keys(w), y && mn(N.value, y), R && N.order(cp(R)), b && N.offset(up(b));
  var L = N(t), C = fp(h), z = L.map(function(W, q) {
    var ne = W.key;
    return {
      index: q,
      key: ne,
      bars: W.map(function(G, le) {
        var K = (g(c(G)) || 0) - (g(p(G)) || 0), re = g(p(G)), B = "bandwidth" in h ? h(i(G.data)) : Math.max((h(i(G.data)) || 0) - C / 2);
        return {
          bar: G,
          key: ne,
          index: le,
          height: K,
          width: C,
          x: B || 0,
          y: re || 0,
          color: x(W.key, le)
        };
      })
    };
  });
  return v ? /* @__PURE__ */ m.createElement(m.Fragment, null, v(z)) : /* @__PURE__ */ m.createElement(tt, {
    className: Sn("visx-bar-stack", n),
    top: r,
    left: a
  }, z.map(function(W) {
    return W.bars.map(function(q) {
      return /* @__PURE__ */ m.createElement(Nr, Df({
        key: "bar-stack-" + W.index + "-" + q.index,
        x: q.x,
        y: q.y,
        height: q.height,
        width: q.width,
        fill: q.color
      }, A));
    });
  }));
}
var cE = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function _f() {
  return _f = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, _f.apply(this, arguments);
}
function uE(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function dE(e) {
  var t = e.data, n = e.className, r = e.top, a = e.left, i = e.y, u = e.x0, c = u === void 0 ? Dy : u, l = e.x1, p = l === void 0 ? _y : l, h = e.xScale, g = e.yScale, x = e.color, w = e.keys, y = e.value, R = e.order, b = e.offset, v = e.children, A = uE(e, cE), N = sp();
  w && N.keys(w), y && mn(N.value, y), R && N.order(cp(R)), b && N.offset(up(b));
  var L = N(t), C = fp(g), z = L.map(function(W, q) {
    var ne = W.key;
    return {
      index: q,
      key: ne,
      bars: W.map(function(G, le) {
        var K = (h(p(G)) || 0) - (h(c(G)) || 0), re = h(c(G)), B = "bandwidth" in g ? g(i(G.data)) : Math.max((g(i(G.data)) || 0) - K / 2);
        return {
          bar: G,
          key: ne,
          index: le,
          height: C,
          width: K,
          x: re || 0,
          y: B || 0,
          color: x(W.key, le)
        };
      })
    };
  });
  return v ? /* @__PURE__ */ m.createElement(m.Fragment, null, v(z)) : /* @__PURE__ */ m.createElement(tt, {
    className: Sn("visx-bar-stack-horizontal", n),
    top: r,
    left: a
  }, z.map(function(W) {
    return W.bars.map(function(q) {
      return /* @__PURE__ */ m.createElement(Nr, _f({
        key: "bar-stack-" + W.index + "-" + q.index,
        x: q.x,
        y: q.y,
        height: q.height,
        width: q.width,
        fill: q.color
      }, A));
    });
  }));
}
var Lh = "http://www.w3.org/2000/svg";
function fE(e) {
  var t = document.getElementById(e);
  if (!t) {
    var n = document.createElementNS(Lh, "svg");
    n.setAttribute("aria-hidden", "true"), n.style.opacity = "0", n.style.width = "0", n.style.height = "0", n.style.position = "absolute", n.style.top = "-100%", n.style.left = "-100%", n.style.pointerEvents = "none", t = document.createElementNS(Lh, "path"), t.setAttribute("id", e), n.appendChild(t), document.body.appendChild(n);
  }
  return t;
}
var pE = "__visx_splitpath_svg_path_measurement_id", Nh = function() {
  return !0;
};
function hE(e) {
  var t = e.path, n = e.pointsInSegments, r = e.segmentation, a = r === void 0 ? "x" : r, i = e.sampleRate, u = i === void 0 ? 1 : i;
  try {
    var c = fE(pE);
    c.setAttribute("d", t);
    var l = c.getTotalLength(), p = n.length, h = n.map(function() {
      return [];
    });
    if (a === "x" || a === "y")
      for (var g = n.map(function(re) {
        var B;
        return (B = re.find(function(j) {
          return typeof j[a] == "number";
        })) == null ? void 0 : B[a];
      }), x = c.getPointAtLength(0), w = c.getPointAtLength(l), y = w[a] > x[a], R = y ? g.map(function(re) {
        return typeof re > "u" ? Nh : function(B) {
          return B >= re;
        };
      }) : g.map(function(re) {
        return typeof re > "u" ? Nh : function(B) {
          return B <= re;
        };
      }), b = 0, v = 0; v <= l; v += u) {
        for (var A = c.getPointAtLength(v), N = A[a]; b < p - 1 && R[b + 1](N); )
          b += 1;
        h[b].push(A);
      }
    else {
      var L = n.map(function(re) {
        return re.length;
      }), C = L.reduce(function(re, B) {
        return re + B;
      }, 0), z = l / Math.max(1, C - 1), W = L.slice(0, p - 1);
      W.unshift(0);
      for (var q = 2; q < p; q += 1)
        W[q] += W[q - 1];
      for (var ne = 0; ne < p; ne += 1)
        W[ne] *= z;
      for (var G = 0, le = 0; le <= l; le += u) {
        for (var K = c.getPointAtLength(le); G < p - 1 && le >= W[G + 1]; )
          G += 1;
        h[G].push(K);
      }
    }
    return h;
  } catch {
    return [];
  }
}
function Of() {
  return Of = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Of.apply(this, arguments);
}
var mE = function(t) {
  return t.x || 0;
}, yE = function(t) {
  return t.y || 0;
};
function Fy(e) {
  var t = e.children, n = e.className, r = e.curve, a = e.defined, i = e.segmentation, u = e.sampleRate, c = e.segments, l = e.x, p = e.y, h = e.styles, g = ue.useMemo(function() {
    var y = typeof l == "number" || typeof l > "u" ? function() {
      return l;
    } : l, R = typeof p == "number" || typeof p > "u" ? function() {
      return p;
    } : p;
    return c.map(function(b) {
      return b.map(function(v, A) {
        return {
          x: y(v, A, b),
          y: R(v, A, b)
        };
      });
    });
  }, [l, p, c]), x = ue.useMemo(function() {
    var y = Ny({
      x: l,
      y: p,
      defined: a,
      curve: r
    });
    return y(c.flat()) || "";
  }, [l, p, a, r, c]), w = ue.useMemo(function() {
    return hE({
      path: x,
      segmentation: i,
      pointsInSegments: g,
      sampleRate: u
    });
  }, [x, i, g, u]);
  return /* @__PURE__ */ m.createElement("g", null, w.map(function(y, R) {
    return t ? /* @__PURE__ */ m.createElement(m.Fragment, {
      key: R
    }, t({
      index: R,
      segment: y,
      styles: h[R] || h[R % h.length]
    })) : /* @__PURE__ */ m.createElement(Hr, Of({
      key: R,
      className: n,
      data: y,
      x: mE,
      y: yE
    }, h[R] || h[R % h.length]));
  }));
}
Fy.propTypes = {
  segments: Me.arrayOf(Me.array).isRequired,
  styles: Me.array.isRequired,
  children: Me.func,
  className: Me.string
};
var gE = ["tooltipOpen"];
function vE(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function cu() {
  return cu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, cu.apply(this, arguments);
}
function My(e) {
  var t = ue.useState(cu({
    tooltipOpen: !1
  }, e)), n = t[0], r = t[1], a = ue.useCallback(function(u) {
    return r(typeof u == "function" ? function(c) {
      c.tooltipOpen;
      var l = vE(c, gE);
      return cu({}, u(l), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: u.tooltipLeft,
      tooltipTop: u.tooltipTop,
      tooltipData: u.tooltipData
    });
  }, [r]), i = ue.useCallback(function() {
    return r({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [r]);
  return {
    tooltipOpen: n.tooltipOpen,
    tooltipLeft: n.tooltipLeft,
    tooltipTop: n.tooltipTop,
    tooltipData: n.tooltipData,
    updateTooltip: r,
    showTooltip: a,
    hideTooltip: i
  };
}
var xE = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function uu() {
  return uu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, uu.apply(this, arguments);
}
function bE(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var zy = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, pp = /* @__PURE__ */ m.forwardRef(function(e, t) {
  var n = e.className, r = e.top, a = e.left, i = e.offsetLeft, u = i === void 0 ? 10 : i, c = e.offsetTop, l = c === void 0 ? 10 : c, p = e.style, h = p === void 0 ? zy : p, g = e.children, x = e.unstyled, w = x === void 0 ? !1 : x, y = e.applyPositionStyle, R = y === void 0 ? !1 : y, b = bE(e, xE);
  return /* @__PURE__ */ m.createElement("div", uu({
    ref: t,
    className: Sn("visx-tooltip", n),
    style: uu({
      top: r == null || l == null ? r : r + l,
      left: a == null || u == null ? a : a + u
    }, R && {
      position: "absolute"
    }, !w && h)
  }, b), g);
});
pp.propTypes = {
  children: Me.node,
  className: Me.string,
  left: Me.number,
  offsetLeft: Me.number,
  offsetTop: Me.number,
  top: Me.number,
  applyPositionStyle: Me.bool,
  unstyled: Me.bool
};
pp.displayName = "Tooltip";
const EE = pp;
function Ff() {
  return Ff = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ff.apply(this, arguments);
}
function SE(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function kE(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Mf(e, t);
}
function Mf(e, t) {
  return Mf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, a) {
    return r.__proto__ = a, r;
  }, Mf(e, t);
}
var Ph = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function wE(e) {
  var t;
  return t = /* @__PURE__ */ function(n) {
    kE(r, n);
    function r(i) {
      var u;
      return u = n.call(this, i) || this, u.state = {
        rect: void 0,
        parentRect: void 0
      }, u.nodeRef = /* @__PURE__ */ m.createRef(), u.getRects = u.getRects.bind(SE(u)), u;
    }
    var a = r.prototype;
    return a.componentDidMount = function() {
      var u, c = this;
      this.node = (u = this.nodeRef) != null && u.current ? this.nodeRef.current : sv.findDOMNode(this), this.setState(function() {
        return c.getRects();
      });
    }, a.getRects = function() {
      if (!this.node)
        return this.state;
      var u = this.node, c = u.parentNode, l = u.getBoundingClientRect ? u.getBoundingClientRect() : Ph, p = c != null && c.getBoundingClientRect ? c.getBoundingClientRect() : Ph;
      return {
        rect: l,
        parentRect: p
      };
    }, a.render = function() {
      return /* @__PURE__ */ m.createElement(e, Ff({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, r;
  }(m.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var By = /* @__PURE__ */ ue.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), TE = By.Provider;
By.Consumer;
var RE = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function du() {
  return du = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, du.apply(this, arguments);
}
function CE(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function Iy(e) {
  var t = e.children;
  e.getRects;
  var n = e.left, r = n === void 0 ? 0 : n, a = e.offsetLeft, i = a === void 0 ? 10 : a, u = e.offsetTop, c = u === void 0 ? 10 : u, l = e.parentRect, p = e.rect, h = e.style, g = h === void 0 ? zy : h, x = e.top, w = x === void 0 ? 0 : x, y = e.unstyled, R = y === void 0 ? !1 : y, b = e.nodeRef, v = CE(e, RE), A, N = !1, L = !1;
  if (p && l) {
    var C = r, z = w;
    if (l.width) {
      var W = C + i + p.width - l.width, q = p.width - C - i;
      N = W > 0 && W > q;
    } else {
      var ne = C + i + p.width - window.innerWidth, G = p.width - C - i;
      N = ne > 0 && ne > G;
    }
    if (l.height) {
      var le = z + c + p.height - l.height, K = p.height - z - c;
      L = le > 0 && le > K;
    } else
      L = z + c + p.height > window.innerHeight;
    C = N ? C - p.width - i : C + i, z = L ? z - p.height - c : z + c, C = Math.round(C), z = Math.round(z), A = "translate(" + C + "px, " + z + "px)";
  }
  return /* @__PURE__ */ m.createElement(EE, du({
    ref: b,
    style: du({
      left: 0,
      top: 0,
      transform: A
    }, !R && g)
  }, v), /* @__PURE__ */ m.createElement(TE, {
    value: {
      isFlippedVertically: !L,
      isFlippedHorizontally: !N
    }
  }, t));
}
Iy.propTypes = {
  nodeRef: Me.oneOfType([Me.string, Me.func, Me.object])
};
const $y = wE(Iy), Hy = (e) => {
  const {
    tableData: t,
    config: n,
    formatNumber: r,
    capitalize: a,
    formatDate: i,
    formatTooltipsDate: u,
    parseDate: c,
    setSharedFilter: l,
    isDraggingAnnotation: p
  } = ue.useContext(mt), { xScale: h, yScale: g, showTooltip: x, hideTooltip: w } = e, { xAxis: y, visualizationType: R, orientation: b, yAxis: v, runtime: A } = n, N = (ee, Q) => {
    var ce;
    let Z = 0, Y = Number(g.invert(ee)), te = null, $ = null;
    for (let Se of (ce = n.runtime) == null ? void 0 : ce.seriesKeys)
      if (Q.hasOwnProperty(Se) && (Z += Number(Q[Se]), Z >= Y)) {
        $ = Q[Se], te = Se;
        break;
      }
    return [te, $];
  }, L = (ee, Q, Z, Y) => {
    const te = Z.general.showMissingDataLabel && (!Q || Q === "null"), $ = ee === Z.xAxis.dataKey ? Q : r(Q, Y(ee));
    return te ? "N/A" : $;
  }, C = (ee, Q) => {
    const { x: Z, y: Y } = Q, $ = {
      data: ee || {},
      dataXPosition: Z + 10,
      dataYPosition: Y
    };
    return {
      tooltipLeft: $.dataXPosition,
      tooltipTop: $.dataYPosition,
      tooltipData: $
    };
  }, z = (ee, Q) => {
    if (R === "Bump Chart" || (ee.stopPropagation(), p))
      return;
    const Z = Dp(ee), { x: Y, y: te } = Z, { data: $, arc: ce } = Q ?? {}, Se = ne(Y - Number(n.yAxis.size || 0)), be = t.filter((Ce) => Ce[y.dataKey] === G(te)), ve = b === "vertical" ? K(Se) : be, Pe = (Ce) => {
      const fe = n.runtime.series.filter((Ie) => Ie.dataKey === Ce)[0];
      return fe != null && fe.axis ? String(fe.axis).toLowerCase() : "left";
    }, we = (() => {
      var Qe, He, Fe, qe;
      const Ce = n.columns, fe = [], ze = [];
      for (const [We, je] of Object.entries(Ce)) {
        const Ke = {
          addColPrefix: n.columns[We].prefix,
          addColSuffix: n.columns[We].suffix,
          addColRoundTo: n.columns[We].roundToPlace ? n.columns[We].roundToPlace : "",
          addColCommas: n.columns[We].commas
        };
        let Te = null;
        n.visualizationType === "Pie" ? Te = ce == null ? void 0 : ce.data[je.name] : Te = (Qe = ve[0]) == null ? void 0 : Qe[je.name];
        const _e = Gf(Te, "left", !0, n, Ke);
        je.tooltips && fe.push([je.label, _e]);
      }
      const Ie = [];
      if (fe.forEach((We) => {
        Ie.push([We[0], We[1]]);
      }), R === "Pie") {
        const We = Number(n.dataFormat.roundTo) || 0, Te = ((ce.endAngle - ce.startAngle) * 180 / Math.PI / 360 * 100).toFixed(We);
        ze.push(
          // ignore
          [n.xAxis.dataKey, $],
          [n.runtime.yAxis.dataKey, r(ce == null ? void 0 : ce.data[n.runtime.yAxis.dataKey])],
          ["Percent", `${Te + "%"}`]
        );
      }
      if (R === "Forest Plot" && ze.push([n.xAxis.dataKey, G(te)]), R !== "Pie" && R !== "Forest Plot" && !n.tooltips.singleSeries && (ze.push(
        ...(Fe = (He = re()) == null ? void 0 : He.filter((We) => {
          var Ke, Te;
          return ((Ke = n.runtime.series) == null ? void 0 : Ke.find(
            (_e) => _e.dataKey === We && (_e == null ? void 0 : _e.tooltip) && !_e.dynamicCategory
          )) || ((Te = n.xAxis) == null ? void 0 : Te.dataKey) == We || R === "Forecasting";
        })) == null ? void 0 : Fe.flatMap((We) => {
          var _e;
          const je = (_e = ve[0]) == null ? void 0 : _e[We], Ke = L(We, je, n, Pe), Te = n.runtime.series.find(
            (at) => at.dataKey === We && at.name !== void 0
          );
          return (je == null || je === "" || Ke === "N/A") && n.general.hideNullValue ? [] : Te && Te.name === "" ? [["", Ke, Pe(We)]] : [[We, Ke, Pe(We)]];
        })
      ), (qe = n.runtime.series) == null || qe.forEach((We) => {
        if (We != null && We.dynamicCategory) {
          const je = We.dataKey, Ke = ve.find((at) => at[We.dynamicCategory] === je);
          if (!Ke)
            return;
          const Te = Ke[We.originalDataKey], _e = L(je, Te, n, Pe);
          ze.push([je, _e, Pe(je)]);
        }
      })), R !== "Pie" && R !== "Forest Plot" && n.tooltips.singleSeries) {
        const [We, je] = N(te, ve[0]);
        if (We && je) {
          ze.push([n.xAxis.dataKey, Se]);
          const Ke = L(We, je, n, Pe);
          ze.push([We, Ke]);
        }
      }
      return [...ze, ...Ie];
    })();
    if (!we)
      return;
    const me = C(we, Z);
    x(me);
  }, W = () => {
    n.visualizationType === "Area Chart" ? setTimeout(() => {
      w();
    }, 3e3) : w();
  }, q = (ee) => {
    if (n.xAxis.type === "categorical" || n.visualizationType === "Combo") {
      let Q = h.step();
      const Y = Math.floor(Number(ee) / Q);
      return h.domain()[Y - 1];
    }
    if (En(n.xAxis) && n.visualizationType !== "Combo") {
      const Q = ih(($) => c($[n.xAxis.dataKey])).left, Z = h.invert(h(ee)), Y = Q(n.data, Z, 1);
      return c(n.data[Y - 1][n.xAxis.dataKey]);
    }
  }, ne = (ee, Q = !1) => {
    if (R !== "Pie" && b !== "horizontal") {
      if (h.type === "point" || y.type === "continuous" || En(y)) {
        let Z = null, Y = Number.MAX_VALUE, te = ee;
        return t.forEach(($) => {
          const ce = En(y) ? h(c($[y.dataKey])) : h($[y.dataKey]);
          let Se = n.barHeight;
          const be = Math.abs(Number(ce - te + (Q ? Se * 2 : 0)));
          be <= Y && (Y = be, Z = (En(y), $[y.dataKey]));
        }), Z;
      }
      if (n.xAxis.type === "categorical" || R === "Combo" && b !== "horizontal" && R !== "Forest Plot") {
        let Y = (h.range()[1] - h.range()[0]) / (h.domain().length + 1);
        const $ = Math.floor((Number(ee) - Y / 2) / Y);
        return h.domain()[$];
      }
      if (En(y) && R !== "Combo" && b !== "horizontal") {
        const Z = ih((ce) => c(ce[n.xAxis.dataKey])).left, Y = h.invert(ee), te = Z(n.data, Y, 1);
        return c(n.data[te - 1][n.xAxis.dataKey]);
      }
    }
  }, G = (ee, Q) => {
    if (R === "Pie")
      return;
    let Z = Number.MAX_VALUE, Y = null;
    return t.forEach((te, $) => {
      const ce = g(R !== "Forest Plot" ? te[n.xAxis.dataKey] : $), Se = Math.abs(ce - ee);
      Se < Z && (Z = Se, Y = Q ? te[Q] : te[n.xAxis.dataKey]);
    }), Y;
  }, le = (ee) => {
    var Q, Z;
    try {
      if (n.visualizationType === "Bump Chart")
        return;
      const Y = Dp(ee), { x: te } = Y;
      if (!te)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let $ = ne(te, !0), ce = (Q = n.data) == null ? void 0 : Q.filter((Se) => Se[n.xAxis.dataKey] === $);
      if (!$)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (En(y) && $ && ($ = new Date($), $ = i($), ce = (Z = n.data) == null ? void 0 : Z.filter((Se) => i(new Date(Se[n.xAxis.dataKey])) === $)), !ce[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${$}`);
      l && (n != null && n.uid) && (ce != null && ce[0]) && l(n.uid, ce[0]);
    } catch (Y) {
      console.error(Y.message);
    }
  }, K = (ee) => {
    const Z = n.runtime.series.filter(
      ($) => R === "Pie" || $.tooltip === !0 && !$.dynamicCategory
    ).map(($) => $.dataKey);
    Z.push(n.xAxis.dataKey);
    const Y = Je.uniq(
      n.runtime.series.flatMap(($) => {
        if ($.dynamicCategory)
          return [$.dynamicCategory, $.originalDataKey];
      })
    );
    Z.push(...Y), n.visualizationType === "Forecasting" && n.runtime.series.map(($) => {
      $.confidenceIntervals.map((ce) => {
        ce.showInTooltip && (Z.push(ce.high), Z.push(ce.low));
      });
    });
    const te = Object.values(n.columns).map(($) => $.name);
    Z.push(...te, ...te);
    try {
      const $ = t.filter((Se) => Se[y.dataKey] === ee);
      return !$ || $.length === 0 ? [] : $.map((Se) => Je.pick(Se, Z));
    } catch ($) {
      console.error("COVE", $);
    }
  }, re = () => {
    var ee;
    try {
      let Q, Z = [], Y = [];
      if ((ee = n.runtime.series) == null || ee.forEach((te) => {
        te.type === "Forecasting" && (Z.push(te.stageColumn), te == null || te.confidenceIntervals.forEach(($) => {
          $.showInTooltip === !0 && (Y.push($.low), Y.push($.high));
        }));
      }), !n.dashboard)
        switch (R) {
          case "Combo":
            Q = [A.xAxis.dataKey, ...A == null ? void 0 : A.seriesKeys, ...Y];
            break;
          case "Forecasting":
            Q = [A.xAxis.dataKey, ...Z, ...Y];
            break;
          case "Line":
            Q = [A.xAxis.dataKey, ...A == null ? void 0 : A.seriesKeys];
            break;
          case "Area Chart":
            Q = [A.xAxis.dataKey, ...A == null ? void 0 : A.seriesKeys];
            break;
          case "Bar":
            Q = b === "vertical" ? [A.xAxis.dataKey, ...A == null ? void 0 : A.seriesKeys] : [A.yAxis.dataKey, ...A == null ? void 0 : A.seriesKeys];
            break;
          case "Pie":
            Q = [A.xAxis.dataKey, ...A == null ? void 0 : A.seriesKeys];
          default:
            throw new Error("No visualization type found in handleTooltipMouseOver");
        }
      return n.dashboard && (Q = [
        A.xAxis.dataKey,
        ...A == null ? void 0 : A.barSeriesKeys,
        ...A == null ? void 0 : A.lineSeriesKeys,
        ...Z,
        ...Y
      ]), Q;
    } catch (Q) {
      console.error("COVE", Q);
    }
  }, B = (ee) => {
    const { dataXPosition: Q, dataYPosition: Z } = ee;
    return {
      opacity: n.tooltips.opacity ? n.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${Q}px, ${Number(Z)}px)`
    };
  }, j = (ee) => {
    var Z, Y;
    let Q = n.runtime.series.filter((te) => te.dataKey === ee);
    return (Z = Q[0]) != null && Z.name ? (Y = Q[0]) == null ? void 0 : Y.name : ee;
  };
  return {
    getIncludedTooltipSeries: re,
    getXValueFromCoordinate: ne,
    getXValueFromCoordinateDate: q,
    getYScaleValues: K,
    handleTooltipClick: le,
    handleTooltipMouseOff: W,
    handleTooltipMouseOver: z,
    TooltipListItem: ({ item: ee }) => {
      var me;
      const [Q, Z] = ee, [Y, te, $] = Z;
      if (R === "Forest Plot")
        return Y === n.xAxis.dataKey ? /* @__PURE__ */ React.createElement("li", { className: "tooltip-heading" }, `${a(n.xAxis.dataKey ? `${n.xAxis.dataKey}: ` : "")} ${En(v) ? i(c(Y, !1)) : te}`) : /* @__PURE__ */ React.createElement("li", { className: "tooltip-body" }, `${j(Y)}: ${r(te, "left")}`);
      const ce = n.tooltips.dateDisplayFormat ? u(c(te, !1)) : i(c(te, !1));
      if (R === "Bar" && b === "horizontal" && Y === n.xAxis.dataKey)
        return /* @__PURE__ */ React.createElement("li", { className: "tooltip-heading" }, `${a(
          n.runtime.yAxis.label ? `${n.runtime.yAxis.label}: ` : ""
        )} ${n.xAxis.type === "date" ? ce : te}`);
      if (Y === n.xAxis.dataKey)
        return /* @__PURE__ */ React.createElement("li", { className: "tooltip-heading" }, `${a(
          n.runtime.xAxis.label ? `${n.runtime.xAxis.label}: ` : ""
        )} ${En(y) ? ce : te}`);
      const { label: Se, displayGray: be } = n.visualizationSubType !== "stacked" && n.general.showSuppressedSymbol && ((me = n.preliminaryData) == null ? void 0 : me.find(
        (Ce) => Ce.label && Ce.type === "suppression" && Ce.displayTooltip && te === Ce.value && (!Ce.column || Y === Ce.column)
      )) || {};
      let ve = Se || te;
      const Pe = be ? { color: "#8b8b8a" } : {};
      Q == 1 && n.dataFormat.onlyShowTopPrefixSuffix && (ve = `${n.dataFormat.prefix}${ve}${n.dataFormat.suffix}`);
      const Ve = j(Y), we = Ve ? `${Ve}: ${ve}` : ve;
      return /* @__PURE__ */ React.createElement("li", { style: Pe, className: "tooltip-body" }, we);
    },
    tooltipStyles: B
  };
};
function hp(e, { threshold: t = 0, root: n = null, rootMargin: r = "0%", freezeOnceVisible: a = !1 }) {
  const [i, u] = ue.useState(), c = (i == null ? void 0 : i.isIntersecting) && a, l = ([p]) => {
    u(p);
  };
  return ue.useEffect(() => {
    const p = e == null ? void 0 : e.current;
    if (!!!window.IntersectionObserver || c || !p)
      return;
    const g = { threshold: t, root: n, rootMargin: r }, x = new IntersectionObserver(l, g);
    return x.observe(p), () => x.disconnect();
  }, [e, t, n, r, c]), i;
}
const zf = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let n = "";
    return e.visualizationType && (n += `${e.visualizationType} chart`), e.title && e.visualizationType && (n += ` with the title: ${e.title}`), n;
  } catch (n) {
    console.error("COVE: ", n.message);
  }
}, Dh = Symbol("implicit");
function mp() {
  var e = new Gp(), t = [], n = [], r = Dh;
  function a(i) {
    let u = e.get(i);
    if (u === void 0) {
      if (r !== Dh)
        return r;
      e.set(i, u = t.push(i) - 1);
    }
    return n[u % n.length];
  }
  return a.domain = function(i) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new Gp();
    for (const u of i)
      e.has(u) || e.set(u, t.push(u) - 1);
    return a;
  }, a.range = function(i) {
    return arguments.length ? (n = Array.from(i), a) : n.slice();
  }, a.unknown = function(i) {
    return arguments.length ? (r = i, a) : r;
  }, a.copy = function() {
    return mp(t, n).unknown(r);
  }, Du.apply(a, arguments), a;
}
function yp() {
  var e = mp().unknown(void 0), t = e.domain, n = e.range, r = 0, a = 1, i, u, c = !1, l = 0, p = 0, h = 0.5;
  delete e.unknown;
  function g() {
    var x = t().length, w = a < r, y = w ? a : r, R = w ? r : a;
    i = (R - y) / Math.max(1, x - l + p * 2), c && (i = Math.floor(i)), y += (R - y - i * (x - l)) * h, u = i * (1 - l), c && (y = Math.round(y), u = Math.round(u));
    var b = mv(x).map(function(v) {
      return y + i * v;
    });
    return n(w ? b.reverse() : b);
  }
  return e.domain = function(x) {
    return arguments.length ? (t(x), g()) : t();
  }, e.range = function(x) {
    return arguments.length ? ([r, a] = x, r = +r, a = +a, g()) : [r, a];
  }, e.rangeRound = function(x) {
    return [r, a] = x, r = +r, a = +a, c = !0, g();
  }, e.bandwidth = function() {
    return u;
  }, e.step = function() {
    return i;
  }, e.round = function(x) {
    return arguments.length ? (c = !!x, g()) : c;
  }, e.padding = function(x) {
    return arguments.length ? (l = Math.min(1, p = +x), g()) : l;
  }, e.paddingInner = function(x) {
    return arguments.length ? (l = Math.min(1, x), g()) : l;
  }, e.paddingOuter = function(x) {
    return arguments.length ? (p = +x, g()) : p;
  }, e.align = function(x) {
    return arguments.length ? (h = Math.max(0, Math.min(1, x)), g()) : h;
  }, e.copy = function() {
    return yp(t(), [r, a]).round(c).paddingInner(l).paddingOuter(p).align(h);
  }, Du.apply(g(), arguments);
}
function Vy(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return Vy(t());
  }, e;
}
function AE() {
  return Vy(yp.apply(null, arguments).paddingInner(1));
}
function Wy(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, a = e[n], i = e[r], u;
  return i < a && (u = n, n = r, r = u, u = a, a = i, i = u), e[n] = t.floor(a), e[r] = t.ceil(i), e;
}
function _h(e) {
  return Math.log(e);
}
function Oh(e) {
  return Math.exp(e);
}
function LE(e) {
  return -Math.log(-e);
}
function NE(e) {
  return -Math.exp(-e);
}
function PE(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function DE(e) {
  return e === 10 ? PE : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function _E(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function Fh(e) {
  return (t, n) => -e(-t, n);
}
function OE(e) {
  const t = e(_h, Oh), n = t.domain;
  let r = 10, a, i;
  function u() {
    return a = _E(r), i = DE(r), n()[0] < 0 ? (a = Fh(a), i = Fh(i), e(LE, NE)) : e(_h, Oh), t;
  }
  return t.base = function(c) {
    return arguments.length ? (r = +c, u()) : r;
  }, t.domain = function(c) {
    return arguments.length ? (n(c), u()) : n();
  }, t.ticks = (c) => {
    const l = n();
    let p = l[0], h = l[l.length - 1];
    const g = h < p;
    g && ([p, h] = [h, p]);
    let x = a(p), w = a(h), y, R;
    const b = c == null ? 10 : +c;
    let v = [];
    if (!(r % 1) && w - x < b) {
      if (x = Math.floor(x), w = Math.ceil(w), p > 0) {
        for (; x <= w; ++x)
          for (y = 1; y < r; ++y)
            if (R = x < 0 ? y / i(-x) : y * i(x), !(R < p)) {
              if (R > h)
                break;
              v.push(R);
            }
      } else
        for (; x <= w; ++x)
          for (y = r - 1; y >= 1; --y)
            if (R = x > 0 ? y / i(-x) : y * i(x), !(R < p)) {
              if (R > h)
                break;
              v.push(R);
            }
      v.length * 2 < b && (v = Hp(p, h, b));
    } else
      v = Hp(x, w, Math.min(w - x, b)).map(i);
    return g ? v.reverse() : v;
  }, t.tickFormat = (c, l) => {
    if (c == null && (c = 10), l == null && (l = r === 10 ? "s" : ","), typeof l != "function" && (!(r % 1) && (l = av(l)).precision == null && (l.trim = !0), l = iv(l)), c === 1 / 0)
      return l;
    const p = Math.max(1, r * c / t.ticks().length);
    return (h) => {
      let g = h / i(Math.round(a(h)));
      return g * r < r - 0.5 && (g *= r), g <= p ? l(h) : "";
    };
  }, t.nice = () => n(Wy(n(), {
    floor: (c) => i(Math.floor(a(c))),
    ceil: (c) => i(Math.ceil(a(c)))
  })), t;
}
function jy() {
  const e = OE(rv()).domain([1, 10]);
  return e.copy = () => Lm(e, jy()).base(e.base()), Du.apply(e, arguments), e;
}
function FE(e) {
  return new Date(e);
}
function ME(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Uy(e, t, n, r, a, i, u, c, l, p) {
  var h = ov(), g = h.invert, x = h.domain, w = p(".%L"), y = p(":%S"), R = p("%I:%M"), b = p("%I %p"), v = p("%a %d"), A = p("%b %d"), N = p("%B"), L = p("%Y");
  function C(z) {
    return (l(z) < z ? w : c(z) < z ? y : u(z) < z ? R : i(z) < z ? b : r(z) < z ? a(z) < z ? v : A : n(z) < z ? N : L)(z);
  }
  return h.invert = function(z) {
    return new Date(g(z));
  }, h.domain = function(z) {
    return arguments.length ? x(Array.from(z, ME)) : x().map(FE);
  }, h.ticks = function(z) {
    var W = x();
    return e(W[0], W[W.length - 1], z ?? 10);
  }, h.tickFormat = function(z, W) {
    return W == null ? C : p(W);
  }, h.nice = function(z) {
    var W = x();
    return (!z || typeof z.range != "function") && (z = t(W[0], W[W.length - 1], z ?? 10)), z ? x(Wy(W, z)) : h;
  }, h.copy = function() {
    return Lm(h, Uy(e, t, n, r, a, i, u, c, l, p));
  }, h;
}
function Ky() {
  return Du.apply(Uy(gv, vv, Pm, Am, _m, Dm, Cm, Rm, fs, Gg).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var zE = As("domain", "range", "reverse", "align", "padding", "round");
function fu(e) {
  return zE(yp(), e);
}
var BE = As("domain", "range", "reverse", "align", "padding", "round");
function nl(e) {
  return BE(AE(), e);
}
var IE = As("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function $E(e) {
  return IE(Ky(), e);
}
var HE = As("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function pu(e) {
  return HE(jy(), e);
}
var VE = As("domain", "range", "reverse", "unknown");
function gp(e) {
  return VE(mp(), e);
}
function WE(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function Yy(e, t) {
  var n = e;
  return "ticks" in n ? n.ticks(t) : n.domain().filter(function(r, a, i) {
    return t == null || i.length <= t || a % Math.round((i.length - 1) / t) === 0;
  });
}
function jE(e) {
  return e == null ? void 0 : e.toString();
}
const Dc = ({ startAngle: e, endAngle: t }) => ({
  startAngle: e,
  endAngle: t
}), UE = (e) => {
  const {
    transformedData: t,
    config: n,
    colorScale: r,
    currentViewport: a,
    seriesHighlight: i,
    isDraggingAnnotation: u
  } = ue.useContext(mt), { tooltipData: c, showTooltip: l, hideTooltip: p, tooltipOpen: h, tooltipLeft: g, tooltipTop: x } = My(), { handleTooltipMouseOver: w, handleTooltipMouseOff: y, TooltipListItem: R } = Hy({
    xScale: !1,
    yScale: !1,
    showTooltip: l,
    hideTooltip: p
  }), [b, v] = ue.useState(void 0), [A, N] = ue.useState(!1), L = Object.values(n.columns).filter((Y) => Y.showInViz), C = L.length > 0, z = C ? "pivotColumn" : void 0, W = ue.useMemo(() => {
    if (C) {
      let Y = [];
      const te = n.yAxis.dataKey, $ = L.map((be) => be.name), ce = [te, ...$], Se = n.xAxis.dataKey;
      return t.forEach((be) => {
        ce.forEach((ve) => {
          const Pe = be[ve];
          Pe && Y.push({
            [z]: Pe,
            [Se]: `${be[Se]} - ${ve}`
          });
        });
      }), Y;
    }
    return t;
  }, [t, C]), q = ue.useMemo(() => {
    if (C) {
      const Y = {};
      W.forEach((ce) => {
        Y[ce[n.xAxis.dataKey]] || (Y[ce[n.xAxis.dataKey]] = !0);
      });
      const te = Object.entries(Y).length;
      let $ = n.customColors || Sr[n.palette];
      return $ = $.slice(0, te), gp({
        domain: Object.keys(Y),
        range: $,
        unknown: null
      });
    }
    return r;
  }, [r, C]), ne = ue.useRef(), G = hp(ne, {
    freezeOnceVisible: !1
  });
  ue.useEffect(() => {
    document.querySelector(".isEditor") && N((te) => !0);
  }), ue.useEffect(() => {
    G != null && G.isIntersecting && n.animate && !A && setTimeout(() => {
      N(!0);
    }, 500);
  }, [G == null ? void 0 : G.isIntersecting, n.animate]);
  const le = ({ arcs: Y, path: te, getKey: $ }) => {
    const ce = Nb(Y, $, {
      from: Dc,
      enter: Dc,
      update: Dc,
      leave: Dc
    });
    return ue.useEffect(() => {
      const Se = setTimeout(() => {
        p();
      }, 500);
      return () => {
        clearTimeout(Se);
      };
    }, [c]), /* @__PURE__ */ m.createElement(m.Fragment, null, ce.map(({ item: Se, props: be, key: ve }, Pe) => /* @__PURE__ */ m.createElement(
      tt,
      {
        className: Se.data[n.xAxis.dataKey],
        key: `${ve}-${Pe}`,
        style: {
          opacity: n.legend.behavior === "highlight" && i.length > 0 && i.indexOf(Se.data[n.runtime.xAxis.dataKey]) === -1 ? 0.5 : 1
        }
      },
      /* @__PURE__ */ m.createElement(
        Sh.path,
        {
          d: wb(
            [be.startAngle, be.endAngle],
            (Ve, we) => te({
              ...Se,
              startAngle: Ve,
              endAngle: we
            })
          ),
          fill: q(Se.data[n.runtime.xAxis.dataKey]),
          onMouseEnter: (Ve) => w(Ve, { data: Se.data[n.runtime.xAxis.dataKey], arc: Se }),
          onMouseLeave: (Ve) => y()
        }
      )
    )), ce.map(({ item: Se, key: be }, ve) => {
      const Pe = Number(n.dataFormat.roundTo) || 0, [Ve, we] = te.centroid(Se), me = Se.endAngle - Se.startAngle >= 0.1;
      let Ce = "#FFF";
      q(Se.data[n.runtime.xAxis.dataKey]) && (Ce = il(Ce, q(Se.data[n.runtime.xAxis.dataKey])));
      const Ie = ((Se.endAngle - Se.startAngle) * 180 / Math.PI / 360 * 100).toFixed(Pe);
      return /* @__PURE__ */ m.createElement(Sh.g, { key: `${be}${ve}` }, me && /* @__PURE__ */ m.createElement(
        ht,
        {
          style: { fill: Ce },
          x: Ve,
          y: we,
          dy: ".33em",
          textAnchor: "middle",
          pointerEvents: "none"
        },
        Ie + "%"
      ));
    }));
  };
  let K = e.parentWidth, re = e.parentWidth;
  n && n.legend && !n.legend.hide && a === "lg" && (re = Number(K) * 0.73);
  const B = n.heights.vertical, j = Math.min(re, B) / 2, se = B / 2, ee = e.parentWidth / 2, Q = n.pieType === "Donut" ? 75 : j;
  ue.useEffect(() => {
    if (i.length > 0 && n.legend.behavior !== "highlight") {
      let Y = [];
      W.forEach((te) => {
        i.indexOf(te[n.runtime.xAxis.dataKey]) !== -1 && Y.push(te);
      }), v(Y);
    } else
      v(void 0);
  }, [i]);
  const Z = () => {
    let Y = ["animated-pie", "group"];
    return (n.animate === !1 || A) && Y.push("animated"), Y.join(" ");
  };
  return /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(Vr, { component: "PieChart" }, /* @__PURE__ */ m.createElement(
    "svg",
    {
      width: j * 2,
      height: B,
      className: Z(),
      role: "img",
      "aria-label": zf(n)
    },
    /* @__PURE__ */ m.createElement(tt, { top: se, left: j }, /* @__PURE__ */ m.createElement(
      W0,
      {
        data: b || W,
        pieValue: (Y) => Y[z || n.runtime.yAxis.dataKey],
        pieSortValues: () => -1,
        innerRadius: j - Q,
        outerRadius: j
      },
      (Y) => /* @__PURE__ */ m.createElement(le, { ...Y, getKey: (te) => te.data[n.runtime.xAxis.dataKey] })
    ))
  ), /* @__PURE__ */ m.createElement("div", { ref: ne }), !u && c && Object.entries(c.data).length > 0 && h && l && c.dataYPosition && c.dataXPosition && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${n.tooltips.opacity / 100}) !important`), /* @__PURE__ */ m.createElement(
    $y,
    {
      key: Math.random(),
      className: "tooltip cdc-open-viz-module",
      left: g + ee - j,
      top: x
    },
    /* @__PURE__ */ m.createElement("ul", null, typeof c == "object" && Object.entries(c.data).map((Y, te) => /* @__PURE__ */ m.createElement(R, { item: Y, key: te })))
  ))));
};
function Ls(e) {
  return e.split("-")[1];
}
function vp(e) {
  return e === "y" ? "height" : "width";
}
function $i(e) {
  return e.split("-")[0];
}
function Ns(e) {
  return ["top", "bottom"].includes($i(e)) ? "x" : "y";
}
function Mh(e, t, n) {
  let { reference: r, floating: a } = e;
  const i = r.x + r.width / 2 - a.width / 2, u = r.y + r.height / 2 - a.height / 2, c = Ns(t), l = vp(c), p = r[l] / 2 - a[l] / 2, h = c === "x";
  let g;
  switch ($i(t)) {
    case "top":
      g = { x: i, y: r.y - a.height };
      break;
    case "bottom":
      g = { x: i, y: r.y + r.height };
      break;
    case "right":
      g = { x: r.x + r.width, y: u };
      break;
    case "left":
      g = { x: r.x - a.width, y: u };
      break;
    default:
      g = { x: r.x, y: r.y };
  }
  switch (Ls(t)) {
    case "start":
      g[c] -= p * (n && h ? -1 : 1);
      break;
    case "end":
      g[c] += p * (n && h ? -1 : 1);
  }
  return g;
}
function Gy(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function ys(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Xy(e, t) {
  var n;
  t === void 0 && (t = {});
  const { x: r, y: a, platform: i, rects: u, elements: c, strategy: l } = e, { boundary: p = "clippingAncestors", rootBoundary: h = "viewport", elementContext: g = "floating", altBoundary: x = !1, padding: w = 0 } = t, y = Gy(w), R = c[x ? g === "floating" ? "reference" : "floating" : g], b = ys(await i.getClippingRect({ element: (n = await (i.isElement == null ? void 0 : i.isElement(R))) == null || n ? R : R.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(c.floating)), boundary: p, rootBoundary: h, strategy: l })), v = g === "floating" ? { ...u.floating, x: r, y: a } : u.reference, A = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c.floating)), N = await (i.isElement == null ? void 0 : i.isElement(A)) && await (i.getScale == null ? void 0 : i.getScale(A)) || { x: 1, y: 1 }, L = ys(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: v, offsetParent: A, strategy: l }) : v);
  return { top: (b.top - L.top + y.top) / N.y, bottom: (L.bottom - b.bottom + y.bottom) / N.y, left: (b.left - L.left + y.left) / N.x, right: (L.right - b.right + y.right) / N.x };
}
const KE = Math.min, YE = Math.max;
function Bf(e, t, n) {
  return YE(e, KE(t, n));
}
["top", "right", "bottom", "left"].reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const GE = { left: "right", right: "left", bottom: "top", top: "bottom" };
function hu(e) {
  return e.replace(/left|right|bottom|top/g, (t) => GE[t]);
}
function XE(e, t, n) {
  n === void 0 && (n = !1);
  const r = Ls(e), a = Ns(e), i = vp(a);
  let u = a === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (u = hu(u)), { main: u, cross: hu(u) };
}
const qE = { start: "end", end: "start" };
function Zd(e) {
  return e.replace(/start|end/g, (t) => qE[t]);
}
const ZE = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var n;
    const { placement: r, middlewareData: a, rects: i, initialPlacement: u, platform: c, elements: l } = t, { mainAxis: p = !0, crossAxis: h = !0, fallbackPlacements: g, fallbackStrategy: x = "bestFit", fallbackAxisSideDirection: w = "none", flipAlignment: y = !0, ...R } = e, b = $i(r), v = $i(u) === u, A = await (c.isRTL == null ? void 0 : c.isRTL(l.floating)), N = g || (v || !y ? [hu(u)] : function(le) {
      const K = hu(le);
      return [Zd(le), K, Zd(K)];
    }(u));
    g || w === "none" || N.push(...function(le, K, re, B) {
      const j = Ls(le);
      let se = function(ee, Q, Z) {
        const Y = ["left", "right"], te = ["right", "left"], $ = ["top", "bottom"], ce = ["bottom", "top"];
        switch (ee) {
          case "top":
          case "bottom":
            return Z ? Q ? te : Y : Q ? Y : te;
          case "left":
          case "right":
            return Q ? $ : ce;
          default:
            return [];
        }
      }($i(le), re === "start", B);
      return j && (se = se.map((ee) => ee + "-" + j), K && (se = se.concat(se.map(Zd)))), se;
    }(u, y, w, A));
    const L = [u, ...N], C = await Xy(t, R), z = [];
    let W = ((n = a.flip) == null ? void 0 : n.overflows) || [];
    if (p && z.push(C[b]), h) {
      const { main: le, cross: K } = XE(r, i, A);
      z.push(C[le], C[K]);
    }
    if (W = [...W, { placement: r, overflows: z }], !z.every((le) => le <= 0)) {
      var q, ne;
      const le = (((q = a.flip) == null ? void 0 : q.index) || 0) + 1, K = L[le];
      if (K)
        return { data: { index: le, overflows: W }, reset: { placement: K } };
      let re = (ne = W.find((B) => B.overflows[0] <= 0)) == null ? void 0 : ne.placement;
      if (!re)
        switch (x) {
          case "bestFit": {
            var G;
            const B = (G = W.map((j) => [j.placement, j.overflows.filter((se) => se > 0).reduce((se, ee) => se + ee, 0)]).sort((j, se) => j[1] - se[1])[0]) == null ? void 0 : G[0];
            B && (re = B);
            break;
          }
          case "initialPlacement":
            re = u;
        }
      if (r !== re)
        return { reset: { placement: re } };
    }
    return {};
  } };
}, QE = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: n, y: r } = t, a = await async function(i, u) {
      const { placement: c, platform: l, elements: p } = i, h = await (l.isRTL == null ? void 0 : l.isRTL(p.floating)), g = $i(c), x = Ls(c), w = Ns(c) === "x", y = ["left", "top"].includes(g) ? -1 : 1, R = h && w ? -1 : 1, b = typeof u == "function" ? u(i) : u;
      let { mainAxis: v, crossAxis: A, alignmentAxis: N } = typeof b == "number" ? { mainAxis: b, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...b };
      return x && typeof N == "number" && (A = x === "end" ? -1 * N : N), w ? { x: A * R, y: v * y } : { x: v * y, y: A * R };
    }(t, e);
    return { x: n + a.x, y: r + a.y, data: a };
  } };
}, JE = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: n, y: r, placement: a } = t, { mainAxis: i = !0, crossAxis: u = !1, limiter: c = { fn: (b) => {
      let { x: v, y: A } = b;
      return { x: v, y: A };
    } }, ...l } = e, p = { x: n, y: r }, h = await Xy(t, l), g = Ns($i(a)), x = g === "x" ? "y" : "x";
    let w = p[g], y = p[x];
    if (i) {
      const b = g === "y" ? "bottom" : "right";
      w = Bf(w + h[g === "y" ? "top" : "left"], w, w - h[b]);
    }
    if (u) {
      const b = x === "y" ? "bottom" : "right";
      y = Bf(y + h[x === "y" ? "top" : "left"], y, y - h[b]);
    }
    const R = c.fn({ ...t, [g]: w, [x]: y });
    return { ...R, data: { x: R.x - n, y: R.y - r } };
  } };
};
function Lr(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function ta(e) {
  return Lr(e).getComputedStyle(e);
}
const zh = Math.min, gs = Math.max, mu = Math.round;
function qy(e) {
  const t = ta(e);
  let n = parseFloat(t.width), r = parseFloat(t.height);
  const a = e.offsetWidth, i = e.offsetHeight, u = mu(n) !== a || mu(r) !== i;
  return u && (n = a, r = i), { width: n, height: r, fallback: u };
}
function Ga(e) {
  return Qy(e) ? (e.nodeName || "").toLowerCase() : "";
}
let _c;
function Zy() {
  if (_c)
    return _c;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (_c = e.brands.map((t) => t.brand + "/" + t.version).join(" "), _c) : navigator.userAgent;
}
function na(e) {
  return e instanceof Lr(e).HTMLElement;
}
function Wa(e) {
  return e instanceof Lr(e).Element;
}
function Qy(e) {
  return e instanceof Lr(e).Node;
}
function Bh(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Lr(e).ShadowRoot || e instanceof ShadowRoot;
}
function zu(e) {
  const { overflow: t, overflowX: n, overflowY: r, display: a } = ta(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(a);
}
function eS(e) {
  return ["table", "td", "th"].includes(Ga(e));
}
function If(e) {
  const t = /firefox/i.test(Zy()), n = ta(e), r = n.backdropFilter || n.WebkitBackdropFilter;
  return n.transform !== "none" || n.perspective !== "none" || !!r && r !== "none" || t && n.willChange === "filter" || t && !!n.filter && n.filter !== "none" || ["transform", "perspective"].some((a) => n.willChange.includes(a)) || ["paint", "layout", "strict", "content"].some((a) => {
    const i = n.contain;
    return i != null && i.includes(a);
  });
}
function Jy() {
  return !/^((?!chrome|android).)*safari/i.test(Zy());
}
function xp(e) {
  return ["html", "body", "#document"].includes(Ga(e));
}
function eg(e) {
  return Wa(e) ? e : e.contextElement;
}
const tg = { x: 1, y: 1 };
function al(e) {
  const t = eg(e);
  if (!na(t))
    return tg;
  const n = t.getBoundingClientRect(), { width: r, height: a, fallback: i } = qy(t);
  let u = (i ? mu(n.width) : n.width) / r, c = (i ? mu(n.height) : n.height) / a;
  return u && Number.isFinite(u) || (u = 1), c && Number.isFinite(c) || (c = 1), { x: u, y: c };
}
function Rs(e, t, n, r) {
  var a, i;
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const u = e.getBoundingClientRect(), c = eg(e);
  let l = tg;
  t && (r ? Wa(r) && (l = al(r)) : l = al(e));
  const p = c ? Lr(c) : window, h = !Jy() && n;
  let g = (u.left + (h && ((a = p.visualViewport) == null ? void 0 : a.offsetLeft) || 0)) / l.x, x = (u.top + (h && ((i = p.visualViewport) == null ? void 0 : i.offsetTop) || 0)) / l.y, w = u.width / l.x, y = u.height / l.y;
  if (c) {
    const R = Lr(c), b = r && Wa(r) ? Lr(r) : r;
    let v = R.frameElement;
    for (; v && r && b !== R; ) {
      const A = al(v), N = v.getBoundingClientRect(), L = getComputedStyle(v);
      N.x += (v.clientLeft + parseFloat(L.paddingLeft)) * A.x, N.y += (v.clientTop + parseFloat(L.paddingTop)) * A.y, g *= A.x, x *= A.y, w *= A.x, y *= A.y, g += N.x, x += N.y, v = Lr(v).frameElement;
    }
  }
  return { width: w, height: y, top: x, right: g + w, bottom: x + y, left: g, x: g, y: x };
}
function ja(e) {
  return ((Qy(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function Bu(e) {
  return Wa(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function ng(e) {
  return Rs(ja(e)).left + Bu(e).scrollLeft;
}
function Cs(e) {
  if (Ga(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || Bh(e) && e.host || ja(e);
  return Bh(t) ? t.host : t;
}
function rg(e) {
  const t = Cs(e);
  return xp(t) ? t.ownerDocument.body : na(t) && zu(t) ? t : rg(t);
}
function ag(e, t) {
  var n;
  t === void 0 && (t = []);
  const r = rg(e), a = r === ((n = e.ownerDocument) == null ? void 0 : n.body), i = Lr(r);
  return a ? t.concat(i, i.visualViewport || [], zu(r) ? r : []) : t.concat(r, ag(r));
}
function Ih(e, t, n) {
  return t === "viewport" ? ys(function(r, a) {
    const i = Lr(r), u = ja(r), c = i.visualViewport;
    let l = u.clientWidth, p = u.clientHeight, h = 0, g = 0;
    if (c) {
      l = c.width, p = c.height;
      const x = Jy();
      (x || !x && a === "fixed") && (h = c.offsetLeft, g = c.offsetTop);
    }
    return { width: l, height: p, x: h, y: g };
  }(e, n)) : Wa(t) ? ys(function(r, a) {
    const i = Rs(r, !0, a === "fixed"), u = i.top + r.clientTop, c = i.left + r.clientLeft, l = na(r) ? al(r) : { x: 1, y: 1 };
    return { width: r.clientWidth * l.x, height: r.clientHeight * l.y, x: c * l.x, y: u * l.y };
  }(t, n)) : ys(function(r) {
    const a = ja(r), i = Bu(r), u = r.ownerDocument.body, c = gs(a.scrollWidth, a.clientWidth, u.scrollWidth, u.clientWidth), l = gs(a.scrollHeight, a.clientHeight, u.scrollHeight, u.clientHeight);
    let p = -i.scrollLeft + ng(r);
    const h = -i.scrollTop;
    return ta(u).direction === "rtl" && (p += gs(a.clientWidth, u.clientWidth) - c), { width: c, height: l, x: p, y: h };
  }(ja(e)));
}
function $h(e) {
  return na(e) && ta(e).position !== "fixed" ? e.offsetParent : null;
}
function Hh(e) {
  const t = Lr(e);
  let n = $h(e);
  for (; n && eS(n) && ta(n).position === "static"; )
    n = $h(n);
  return n && (Ga(n) === "html" || Ga(n) === "body" && ta(n).position === "static" && !If(n)) ? t : n || function(r) {
    let a = Cs(r);
    for (; na(a) && !xp(a); ) {
      if (If(a))
        return a;
      a = Cs(a);
    }
    return null;
  }(e) || t;
}
function tS(e, t, n) {
  const r = na(t), a = ja(t), i = Rs(e, !0, n === "fixed", t);
  let u = { scrollLeft: 0, scrollTop: 0 };
  const c = { x: 0, y: 0 };
  if (r || !r && n !== "fixed")
    if ((Ga(t) !== "body" || zu(a)) && (u = Bu(t)), na(t)) {
      const l = Rs(t, !0);
      c.x = l.x + t.clientLeft, c.y = l.y + t.clientTop;
    } else
      a && (c.x = ng(a));
  return { x: i.left + u.scrollLeft - c.x, y: i.top + u.scrollTop - c.y, width: i.width, height: i.height };
}
const nS = { getClippingRect: function(e) {
  let { element: t, boundary: n, rootBoundary: r, strategy: a } = e;
  const i = n === "clippingAncestors" ? function(p, h) {
    const g = h.get(p);
    if (g)
      return g;
    let x = ag(p).filter((b) => Wa(b) && Ga(b) !== "body"), w = null;
    const y = ta(p).position === "fixed";
    let R = y ? Cs(p) : p;
    for (; Wa(R) && !xp(R); ) {
      const b = ta(R), v = If(R);
      (y ? v || w : v || b.position !== "static" || !w || !["absolute", "fixed"].includes(w.position)) ? w = b : x = x.filter((A) => A !== R), R = Cs(R);
    }
    return h.set(p, x), x;
  }(t, this._c) : [].concat(n), u = [...i, r], c = u[0], l = u.reduce((p, h) => {
    const g = Ih(t, h, a);
    return p.top = gs(g.top, p.top), p.right = zh(g.right, p.right), p.bottom = zh(g.bottom, p.bottom), p.left = gs(g.left, p.left), p;
  }, Ih(t, c, a));
  return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: n, strategy: r } = e;
  const a = na(n), i = ja(n);
  if (n === i)
    return t;
  let u = { scrollLeft: 0, scrollTop: 0 }, c = { x: 1, y: 1 };
  const l = { x: 0, y: 0 };
  if ((a || !a && r !== "fixed") && ((Ga(n) !== "body" || zu(i)) && (u = Bu(n)), na(n))) {
    const p = Rs(n);
    c = al(n), l.x = p.x + n.clientLeft, l.y = p.y + n.clientTop;
  }
  return { width: t.width * c.x, height: t.height * c.y, x: t.x * c.x - u.scrollLeft * c.x + l.x, y: t.y * c.y - u.scrollTop * c.y + l.y };
}, isElement: Wa, getDimensions: function(e) {
  return na(e) ? qy(e) : e.getBoundingClientRect();
}, getOffsetParent: Hh, getDocumentElement: ja, getScale: al, async getElementRects(e) {
  let { reference: t, floating: n, strategy: r } = e;
  const a = this.getOffsetParent || Hh, i = this.getDimensions;
  return { reference: tS(t, await a(n), r), floating: { x: 0, y: 0, ...await i(n) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => ta(e).direction === "rtl" }, Vh = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), a = { platform: nS, ...n }, i = { ...a.platform, _c: r };
  return (async (u, c, l) => {
    const { placement: p = "bottom", strategy: h = "absolute", middleware: g = [], platform: x } = l, w = g.filter(Boolean), y = await (x.isRTL == null ? void 0 : x.isRTL(c));
    if (x == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), w.filter((C) => {
      let { name: z } = C;
      return z === "autoPlacement" || z === "flip";
    }).length > 1)
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    u && c || console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    let R = await x.getElementRects({ reference: u, floating: c, strategy: h }), { x: b, y: v } = Mh(R, p, y), A = p, N = {}, L = 0;
    for (let C = 0; C < w.length; C++) {
      const { name: z, fn: W } = w[C], { x: q, y: ne, data: G, reset: le } = await W({ x: b, y: v, initialPlacement: p, placement: A, strategy: h, middlewareData: N, rects: R, platform: x, elements: { reference: u, floating: c } });
      b = q ?? b, v = ne ?? v, N = { ...N, [z]: { ...N[z], ...G } }, L > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), le && L <= 50 && (L++, typeof le == "object" && (le.placement && (A = le.placement), le.rects && (R = le.rects === !0 ? await x.getElementRects({ reference: u, floating: c, strategy: h }) : le.rects), { x: b, y: v } = Mh(R, A, y)), C = -1);
    }
    return { x: b, y: v, placement: A, strategy: h, middlewareData: N };
  })(e, t, { ...a, platform: i });
};
var $a, Hi = { exports: {} }, Wh = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
$a = Wh, function() {
  var e = m, t = 60103, n = 60106;
  $a.Fragment = 60107;
  var r = 60108, a = 60114, i = 60109, u = 60110, c = 60112, l = 60113, p = 60120, h = 60115, g = 60116, x = 60121, w = 60122, y = 60117, R = 60129, b = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var v = Symbol.for;
    t = v("react.element"), n = v("react.portal"), $a.Fragment = v("react.fragment"), r = v("react.strict_mode"), a = v("react.profiler"), i = v("react.provider"), u = v("react.context"), c = v("react.forward_ref"), l = v("react.suspense"), p = v("react.suspense_list"), h = v("react.memo"), g = v("react.lazy"), x = v("react.block"), w = v("react.server.block"), y = v("react.fundamental"), v("react.scope"), v("react.opaque.id"), R = v("react.debug_trace_mode"), v("react.offscreen"), b = v("react.legacy_hidden");
  }
  var A = typeof Symbol == "function" && Symbol.iterator, N = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function L(me) {
    for (var Ce = arguments.length, fe = new Array(Ce > 1 ? Ce - 1 : 0), ze = 1; ze < Ce; ze++)
      fe[ze - 1] = arguments[ze];
    C("error", me, fe);
  }
  function C(me, Ce, fe) {
    var ze = N.ReactDebugCurrentFrame, Ie = "";
    if (ne) {
      var Qe = W(ne.type), He = ne._owner;
      Ie += function(qe, We, je) {
        var Ke = "";
        if (We) {
          var Te = We.fileName, _e = Te.replace(z, "");
          if (/^index\./.test(_e)) {
            var at = Te.match(z);
            if (at) {
              var ge = at[1];
              ge && (_e = ge.replace(z, "") + "/" + _e);
            }
          }
          Ke = " (at " + _e + ":" + We.lineNumber + ")";
        } else
          je && (Ke = " (created by " + je + ")");
        return `
    in ` + (qe || "Unknown") + Ke;
      }(Qe, ne._source, He && W(He.type));
    }
    (Ie += ze.getStackAddendum()) !== "" && (Ce += "%s", fe = fe.concat([Ie]));
    var Fe = fe.map(function(qe) {
      return "" + qe;
    });
    Fe.unshift("Warning: " + Ce), Function.prototype.apply.call(console[me], console, Fe);
  }
  var z = /^(.*)[\\\/]/;
  function W(me) {
    if (me == null)
      return null;
    if (typeof me.tag == "number" && L("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof me == "function")
      return me.displayName || me.name || null;
    if (typeof me == "string")
      return me;
    switch (me) {
      case $a.Fragment:
        return "Fragment";
      case n:
        return "Portal";
      case a:
        return "Profiler";
      case r:
        return "StrictMode";
      case l:
        return "Suspense";
      case p:
        return "SuspenseList";
    }
    if (typeof me == "object")
      switch (me.$$typeof) {
        case u:
          return "Context.Consumer";
        case i:
          return "Context.Provider";
        case c:
          return ze = me, Ie = me.render, Qe = "ForwardRef", He = Ie.displayName || Ie.name || "", ze.displayName || (He !== "" ? Qe + "(" + He + ")" : Qe);
        case h:
          return W(me.type);
        case x:
          return W(me.render);
        case g:
          var Ce = (fe = me)._status === 1 ? fe._result : null;
          if (Ce)
            return W(Ce);
      }
    var fe, ze, Ie, Qe, He;
    return null;
  }
  var q = {};
  N.ReactDebugCurrentFrame;
  var ne = null;
  function G(me) {
    ne = me;
  }
  var le, K, re, B = N.ReactCurrentOwner, j = Object.prototype.hasOwnProperty, se = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ee(me, Ce, fe, ze, Ie) {
    var Qe, He = {}, Fe = null, qe = null;
    for (Qe in fe !== void 0 && (Fe = "" + fe), function(Ke) {
      if (j.call(Ke, "key")) {
        var Te = Object.getOwnPropertyDescriptor(Ke, "key").get;
        if (Te && Te.isReactWarning)
          return !1;
      }
      return Ke.key !== void 0;
    }(Ce) && (Fe = "" + Ce.key), function(Ke) {
      if (j.call(Ke, "ref")) {
        var Te = Object.getOwnPropertyDescriptor(Ke, "ref").get;
        if (Te && Te.isReactWarning)
          return !1;
      }
      return Ke.ref !== void 0;
    }(Ce) && (qe = Ce.ref, function(Ke, Te) {
      if (typeof Ke.ref == "string" && B.current && Te && B.current.stateNode !== Te) {
        var _e = W(B.current.type);
        re[_e] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', W(B.current.type), Ke.ref), re[_e] = !0);
      }
    }(Ce, Ie)), Ce)
      j.call(Ce, Qe) && !se.hasOwnProperty(Qe) && (He[Qe] = Ce[Qe]);
    if (me && me.defaultProps) {
      var We = me.defaultProps;
      for (Qe in We)
        He[Qe] === void 0 && (He[Qe] = We[Qe]);
    }
    if (Fe || qe) {
      var je = typeof me == "function" ? me.displayName || me.name || "Unknown" : me;
      Fe && function(Ke, Te) {
        var _e = function() {
          le || (le = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Te));
        };
        _e.isReactWarning = !0, Object.defineProperty(Ke, "key", { get: _e, configurable: !0 });
      }(He, je), qe && function(Ke, Te) {
        var _e = function() {
          K || (K = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Te));
        };
        _e.isReactWarning = !0, Object.defineProperty(Ke, "ref", { get: _e, configurable: !0 });
      }(He, je);
    }
    return function(Ke, Te, _e, at, ge, ft, ot) {
      var it = { $$typeof: t, type: Ke, key: Te, ref: _e, props: ot, _owner: ft, _store: {} };
      return Object.defineProperty(it._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(it, "_self", { configurable: !1, enumerable: !1, writable: !1, value: at }), Object.defineProperty(it, "_source", { configurable: !1, enumerable: !1, writable: !1, value: ge }), Object.freeze && (Object.freeze(it.props), Object.freeze(it)), it;
    }(me, Fe, qe, Ie, ze, B.current, He);
  }
  re = {};
  var Q, Z = N.ReactCurrentOwner;
  function Y(me) {
    ne = me;
  }
  function te(me) {
    return typeof me == "object" && me !== null && me.$$typeof === t;
  }
  function $() {
    if (Z.current) {
      var me = W(Z.current.type);
      if (me)
        return `

Check the render method of \`` + me + "`.";
    }
    return "";
  }
  N.ReactDebugCurrentFrame, Q = !1;
  var ce = {};
  function Se(me, Ce) {
    if (me._store && !me._store.validated && me.key == null) {
      me._store.validated = !0;
      var fe = function(Ie) {
        var Qe = $();
        if (!Qe) {
          var He = typeof Ie == "string" ? Ie : Ie.displayName || Ie.name;
          He && (Qe = `

Check the top-level render call using <` + He + ">.");
        }
        return Qe;
      }(Ce);
      if (!ce[fe]) {
        ce[fe] = !0;
        var ze = "";
        me && me._owner && me._owner !== Z.current && (ze = " It was passed a child from " + W(me._owner.type) + "."), Y(me), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', fe, ze), Y(null);
      }
    }
  }
  function be(me, Ce) {
    if (typeof me == "object") {
      if (Array.isArray(me))
        for (var fe = 0; fe < me.length; fe++) {
          var ze = me[fe];
          te(ze) && Se(ze, Ce);
        }
      else if (te(me))
        me._store && (me._store.validated = !0);
      else if (me) {
        var Ie = function(Fe) {
          if (Fe === null || typeof Fe != "object")
            return null;
          var qe = A && Fe[A] || Fe["@@iterator"];
          return typeof qe == "function" ? qe : null;
        }(me);
        if (typeof Ie == "function" && Ie !== me.entries)
          for (var Qe, He = Ie.call(me); !(Qe = He.next()).done; )
            te(Qe.value) && Se(Qe.value, Ce);
      }
    }
  }
  function ve(me) {
    var Ce, fe = me.type;
    if (fe != null && typeof fe != "string") {
      if (typeof fe == "function")
        Ce = fe.propTypes;
      else {
        if (typeof fe != "object" || fe.$$typeof !== c && fe.$$typeof !== h)
          return;
        Ce = fe.propTypes;
      }
      if (Ce) {
        var ze = W(fe);
        (function(Ie, Qe, He, Fe, qe) {
          var We = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var je in Ie)
            if (We(Ie, je)) {
              var Ke = void 0;
              try {
                if (typeof Ie[je] != "function") {
                  var Te = Error((Fe || "React class") + ": " + He + " type `" + je + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ie[je] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Te.name = "Invariant Violation", Te;
                }
                Ke = Ie[je](Qe, je, Fe, He, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (_e) {
                Ke = _e;
              }
              !Ke || Ke instanceof Error || (G(qe), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Fe || "React class", He, je, typeof Ke), G(null)), Ke instanceof Error && !(Ke.message in q) && (q[Ke.message] = !0, G(qe), L("Failed %s type: %s", He, Ke.message), G(null));
            }
        })(Ce, me.props, "prop", ze, me);
      } else
        fe.PropTypes === void 0 || Q || (Q = !0, L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", W(fe) || "Unknown"));
      typeof fe.getDefaultProps != "function" || fe.getDefaultProps.isReactClassApproved || L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function Pe(me, Ce, fe, ze, Ie, Qe) {
    var He = function(_e) {
      return typeof _e == "string" || typeof _e == "function" || _e === $a.Fragment || _e === a || _e === R || _e === r || _e === l || _e === p || _e === b || typeof _e == "object" && _e !== null && (_e.$$typeof === g || _e.$$typeof === h || _e.$$typeof === i || _e.$$typeof === u || _e.$$typeof === c || _e.$$typeof === y || _e.$$typeof === x || _e[0] === w);
    }(me);
    if (!He) {
      var Fe = "";
      (me === void 0 || typeof me == "object" && me !== null && Object.keys(me).length === 0) && (Fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
      var qe, We = function(_e) {
        return _e !== void 0 ? `

Check your code at ` + _e.fileName.replace(/^.*[\\\/]/, "") + ":" + _e.lineNumber + "." : "";
      }(Ie);
      Fe += We || $(), me === null ? qe = "null" : Array.isArray(me) ? qe = "array" : me !== void 0 && me.$$typeof === t ? (qe = "<" + (W(me.type) || "Unknown") + " />", Fe = " Did you accidentally export a JSX literal instead of a component?") : qe = typeof me, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", qe, Fe);
    }
    var je = ee(me, Ce, fe, Ie, Qe);
    if (je == null)
      return je;
    if (He) {
      var Ke = Ce.children;
      if (Ke !== void 0)
        if (ze)
          if (Array.isArray(Ke)) {
            for (var Te = 0; Te < Ke.length; Te++)
              be(Ke[Te], me);
            Object.freeze && Object.freeze(Ke);
          } else
            L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          be(Ke, me);
    }
    return me === $a.Fragment ? function(_e) {
      for (var at = Object.keys(_e.props), ge = 0; ge < at.length; ge++) {
        var ft = at[ge];
        if (ft !== "children" && ft !== "key") {
          Y(_e), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ft), Y(null);
          break;
        }
      }
      _e.ref !== null && (Y(_e), L("Invalid attribute `ref` supplied to `React.Fragment`."), Y(null));
    }(je) : ve(je), je;
  }
  var Ve = function(me, Ce, fe) {
    return Pe(me, Ce, fe, !1);
  }, we = function(me, Ce, fe) {
    return Pe(me, Ce, fe, !0);
  };
  $a.jsx = Ve, $a.jsxs = we;
}(), Hi.exports = Wh;
var Qd, ig = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
Qd = ig, function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var n = [], r = 0; r < arguments.length; r++) {
      var a = arguments[r];
      if (a) {
        var i = typeof a;
        if (i === "string" || i === "number")
          n.push(a);
        else if (Array.isArray(a)) {
          if (a.length) {
            var u = t.apply(null, a);
            u && n.push(u);
          }
        } else if (i === "object") {
          if (a.toString !== Object.prototype.toString && !a.toString.toString().includes("[native code]")) {
            n.push(a.toString());
            continue;
          }
          for (var c in a)
            e.call(a, c) && a[c] && n.push(c);
        }
      }
    }
    return n.join(" ");
  }
  Qd.exports ? (t.default = t, Qd.exports = t) : window.classNames = t;
}();
var jh = ig.exports;
const Uh = (e, t, n) => {
  let r = null;
  return function(...a) {
    r && clearTimeout(r), r = setTimeout(() => {
      r = null, n || e.apply(this, a);
    }, t);
  };
}, rS = ({ content: e }) => Hi.exports.jsx("span", { dangerouslySetInnerHTML: { __html: e } }), aS = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} }, iS = ue.createContext({ getTooltipData: () => aS });
function og(e = "DEFAULT_TOOLTIP_ID") {
  return ue.useContext(iS).getTooltipData(e);
}
const Kh = async ({ elementReference: e = null, tooltipReference: t = null, tooltipArrowReference: n = null, place: r = "top", offset: a = 10, strategy: i = "absolute", middlewares: u = [QE(Number(a)), ZE(), JE({ padding: 5 })] }) => {
  if (!e)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  if (t === null)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  const c = u;
  return n ? (c.push({ name: "arrow", options: l = { element: n, padding: 5 }, async fn(p) {
    const { element: h, padding: g = 0 } = l || {}, { x, y: w, placement: y, rects: R, platform: b } = p;
    if (h == null)
      return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."), {};
    const v = Gy(g), A = { x, y: w }, N = Ns(y), L = vp(N), C = await b.getDimensions(h), z = N === "y" ? "top" : "left", W = N === "y" ? "bottom" : "right", q = R.reference[L] + R.reference[N] - A[N] - R.floating[L], ne = A[N] - R.reference[N], G = await (b.getOffsetParent == null ? void 0 : b.getOffsetParent(h));
    let le = G ? N === "y" ? G.clientHeight || 0 : G.clientWidth || 0 : 0;
    le === 0 && (le = R.floating[L]);
    const K = q / 2 - ne / 2, re = v[z], B = le - C[L] - v[W], j = le / 2 - C[L] / 2 + K, se = Bf(re, j, B), ee = Ls(y) != null && j != se && R.reference[L] / 2 - (j < re ? v[z] : v[W]) - C[L] / 2 < 0;
    return { [N]: A[N] - (ee ? j < re ? re - j : B - j : 0), data: { [N]: se, centerOffset: j - se } };
  } }), Vh(e, t, { placement: r, strategy: i, middleware: c }).then(({ x: p, y: h, placement: g, middlewareData: x }) => {
    var w, y;
    const R = { left: `${p}px`, top: `${h}px` }, { x: b, y: v } = (w = x.arrow) !== null && w !== void 0 ? w : { x: 0, y: 0 };
    return { tooltipStyles: R, tooltipArrowStyles: { left: b != null ? `${b}px` : "", top: v != null ? `${v}px` : "", right: "", bottom: "", [(y = { top: "bottom", right: "left", bottom: "top", left: "right" }[g.split("-")[0]]) !== null && y !== void 0 ? y : "bottom"]: "-4px" } };
  })) : Vh(e, t, { placement: "bottom", strategy: i, middleware: c }).then(({ x: p, y: h }) => ({ tooltipStyles: { left: `${p}px`, top: `${h}px` }, tooltipArrowStyles: {} }));
  var l;
};
var Ni = { tooltip: "styles-module_tooltip__mnnfp", fixed: "styles-module_fixed__7ciUi", arrow: "styles-module_arrow__K0L3T", "no-arrow": "styles-module_no-arrow__KcFZN", clickable: "styles-module_clickable__Bv9o7", show: "styles-module_show__2NboJ", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
const Yh = ({ id: e, className: t, classNameArrow: n, variant: r = "dark", anchorId: a, anchorSelect: i, place: u = "top", offset: c = 10, events: l = ["hover"], positionStrategy: p = "absolute", middlewares: h, wrapper: g, children: x = null, delayShow: w = 0, delayHide: y = 0, float: R = !1, noArrow: b = !1, clickable: v = !1, closeOnEsc: A = !1, style: N, position: L, afterShow: C, afterHide: z, content: W, html: q, isOpen: ne, setIsOpen: G, activeAnchor: le, setActiveAnchor: K }) => {
  const re = ue.useRef(null), B = ue.useRef(null), j = ue.useRef(null), se = ue.useRef(null), [ee, Q] = ue.useState({}), [Z, Y] = ue.useState({}), [te, $] = ue.useState(!1), [ce, Se] = ue.useState(!1), be = ue.useRef(!1), ve = ue.useRef(null), { anchorRefs: Pe, setActiveAnchor: Ve } = og(e), we = ue.useRef(!1), [me, Ce] = ue.useState([]), fe = ue.useRef(!1);
  ue.useLayoutEffect(() => (fe.current = !0, () => {
    fe.current = !1;
  }), []), ue.useEffect(() => {
    if (!te) {
      const ge = setTimeout(() => {
        Se(!1);
      }, 150);
      return () => {
        clearTimeout(ge);
      };
    }
    return () => null;
  }, [te]);
  const ze = (ge) => {
    fe.current && (ge && Se(!0), setTimeout(() => {
      fe.current && (G == null || G(ge), ne === void 0 && $(ge));
    }, 10));
  };
  ue.useEffect(() => {
    if (ne === void 0)
      return () => null;
    ne && Se(!0);
    const ge = setTimeout(() => {
      $(ne);
    }, 10);
    return () => {
      clearTimeout(ge);
    };
  }, [ne]), ue.useEffect(() => {
    te !== be.current && (be.current = te, te ? C == null || C() : z == null || z());
  }, [te]);
  const Ie = (ge = y) => {
    se.current && clearTimeout(se.current), se.current = setTimeout(() => {
      we.current || ze(!1);
    }, ge);
  }, Qe = (ge) => {
    var ft;
    if (!ge)
      return;
    w ? (j.current && clearTimeout(j.current), j.current = setTimeout(() => {
      ze(!0);
    }, w)) : ze(!0);
    const ot = (ft = ge.currentTarget) !== null && ft !== void 0 ? ft : ge.target;
    K(ot), Ve({ current: ot }), se.current && clearTimeout(se.current);
  }, He = () => {
    v ? Ie(y || 100) : y ? Ie() : ze(!1), j.current && clearTimeout(j.current);
  }, Fe = ({ x: ge, y: ft }) => {
    Kh({ place: u, offset: c, elementReference: { getBoundingClientRect: () => ({ x: ge, y: ft, width: 0, height: 0, top: ft, left: ge, right: ge, bottom: ft }) }, tooltipReference: re.current, tooltipArrowReference: B.current, strategy: p, middlewares: h }).then((ot) => {
      Object.keys(ot.tooltipStyles).length && Q(ot.tooltipStyles), Object.keys(ot.tooltipArrowStyles).length && Y(ot.tooltipArrowStyles);
    });
  }, qe = (ge) => {
    if (!ge)
      return;
    const ft = ge, ot = { x: ft.clientX, y: ft.clientY };
    Fe(ot), ve.current = ot;
  }, We = (ge) => {
    Qe(ge), y && Ie();
  }, je = (ge) => {
    const ft = document.querySelector(`[id='${a}']`);
    ft != null && ft.contains(ge.target) || me.some((ot) => ot.contains(ge.target)) || ze(!1);
  }, Ke = (ge) => {
    ge.key === "Escape" && ze(!1);
  }, Te = Uh(Qe, 50), _e = Uh(He, 50);
  ue.useEffect(() => {
    var ge, ft;
    const ot = new Set(Pe);
    me.forEach((Mt) => {
      ot.add({ current: Mt });
    });
    const it = document.querySelector(`[id='${a}']`);
    it && ot.add({ current: it }), A && window.addEventListener("keydown", Ke);
    const wt = [];
    l.find((Mt) => Mt === "click") && (window.addEventListener("click", je), wt.push({ event: "click", listener: We })), l.find((Mt) => Mt === "hover") && (wt.push({ event: "mouseenter", listener: Te }, { event: "mouseleave", listener: _e }, { event: "focus", listener: Te }, { event: "blur", listener: _e }), R && wt.push({ event: "mousemove", listener: qe }));
    const Wt = () => {
      we.current = !0;
    }, Kt = () => {
      we.current = !1, He();
    };
    return v && ((ge = re.current) === null || ge === void 0 || ge.addEventListener("mouseenter", Wt), (ft = re.current) === null || ft === void 0 || ft.addEventListener("mouseleave", Kt)), wt.forEach(({ event: Mt, listener: rn }) => {
      ot.forEach((Et) => {
        var Pt;
        (Pt = Et.current) === null || Pt === void 0 || Pt.addEventListener(Mt, rn);
      });
    }), () => {
      var Mt, rn;
      l.find((Et) => Et === "click") && window.removeEventListener("click", je), A && window.removeEventListener("keydown", Ke), v && ((Mt = re.current) === null || Mt === void 0 || Mt.removeEventListener("mouseenter", Wt), (rn = re.current) === null || rn === void 0 || rn.removeEventListener("mouseleave", Kt)), wt.forEach(({ event: Et, listener: Pt }) => {
        ot.forEach((Nt) => {
          var tn;
          (tn = Nt.current) === null || tn === void 0 || tn.removeEventListener(Et, Pt);
        });
      });
    };
  }, [ce, Pe, me, A, l]), ue.useEffect(() => {
    let ge = i ?? "";
    !ge && e && (ge = `[data-tooltip-id='${e}']`);
    const ft = new MutationObserver((ot) => {
      const it = [];
      ot.forEach((wt) => {
        if (wt.type === "attributes" && wt.attributeName === "data-tooltip-id" && wt.target.getAttribute("data-tooltip-id") === e && it.push(wt.target), wt.type === "childList" && (le && [...wt.removedNodes].some((Wt) => !!Wt.contains(le) && (Se(!1), ze(!1), K(null), !0)), ge))
          try {
            const Wt = [...wt.addedNodes].filter((Kt) => Kt.nodeType === 1);
            it.push(...Wt.filter((Kt) => Kt.matches(ge))), it.push(...Wt.flatMap((Kt) => [...Kt.querySelectorAll(ge)]));
          } catch {
          }
      }), it.length && Ce((wt) => [...wt, ...it]);
    });
    return ft.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"] }), () => {
      ft.disconnect();
    };
  }, [e, i, le]), ue.useEffect(() => {
    L ? Fe(L) : R ? ve.current && Fe(ve.current) : Kh({ place: u, offset: c, elementReference: le, tooltipReference: re.current, tooltipArrowReference: B.current, strategy: p, middlewares: h }).then((ge) => {
      fe.current && (Object.keys(ge.tooltipStyles).length && Q(ge.tooltipStyles), Object.keys(ge.tooltipArrowStyles).length && Y(ge.tooltipArrowStyles));
    });
  }, [te, le, W, q, u, c, p, L]), ue.useEffect(() => {
    var ge;
    const ft = document.querySelector(`[id='${a}']`), ot = [...me, ft];
    le && ot.includes(le) || K((ge = me[0]) !== null && ge !== void 0 ? ge : ft);
  }, [a, me, le]), ue.useEffect(() => () => {
    j.current && clearTimeout(j.current), se.current && clearTimeout(se.current);
  }, []), ue.useEffect(() => {
    let ge = i;
    if (!ge && e && (ge = `[data-tooltip-id='${e}']`), ge)
      try {
        const ft = Array.from(document.querySelectorAll(ge));
        Ce(ft);
      } catch {
        Ce([]);
      }
  }, [e, i]);
  const at = !!(q || W || x) && te && Object.keys(ee).length > 0;
  return ce ? Hi.exports.jsxs(g, { id: e, role: "tooltip", className: jh("react-tooltip", Ni.tooltip, Ni[r], t, { [Ni.show]: at, [Ni.fixed]: p === "fixed", [Ni.clickable]: v }), style: { ...N, ...ee }, ref: re, children: [q && Hi.exports.jsx(rS, { content: q }) || W || x, Hi.exports.jsx(g, { className: jh("react-tooltip-arrow", Ni.arrow, n, { [Ni["no-arrow"]]: b }), style: Z, ref: B })] }) : null;
}, yu = ({ id: e, anchorId: t, anchorSelect: n, content: r, html: a, className: i, classNameArrow: u, variant: c = "dark", place: l = "top", offset: p = 10, wrapper: h = "div", children: g = null, events: x = ["hover"], positionStrategy: w = "absolute", middlewares: y, delayShow: R = 0, delayHide: b = 0, float: v = !1, noArrow: A = !1, clickable: N = !1, closeOnEsc: L = !1, style: C, position: z, isOpen: W, setIsOpen: q, afterShow: ne, afterHide: G }) => {
  const [le, K] = ue.useState(r), [re, B] = ue.useState(a), [j, se] = ue.useState(l), [ee, Q] = ue.useState(c), [Z, Y] = ue.useState(p), [te, $] = ue.useState(R), [ce, Se] = ue.useState(b), [be, ve] = ue.useState(v), [Pe, Ve] = ue.useState(h), [we, me] = ue.useState(x), [Ce, fe] = ue.useState(w), [ze, Ie] = ue.useState(null), { anchorRefs: Qe, activeAnchor: He } = og(e), Fe = (je) => je == null ? void 0 : je.getAttributeNames().reduce((Ke, Te) => {
    var _e;
    return Te.startsWith("data-tooltip-") && (Ke[Te.replace(/^data-tooltip-/, "")] = (_e = je == null ? void 0 : je.getAttribute(Te)) !== null && _e !== void 0 ? _e : null), Ke;
  }, {}), qe = (je) => {
    const Ke = { place: (Te) => {
      var _e;
      se((_e = Te) !== null && _e !== void 0 ? _e : l);
    }, content: (Te) => {
      K(Te ?? r);
    }, html: (Te) => {
      B(Te ?? a);
    }, variant: (Te) => {
      var _e;
      Q((_e = Te) !== null && _e !== void 0 ? _e : c);
    }, offset: (Te) => {
      Y(Te === null ? p : Number(Te));
    }, wrapper: (Te) => {
      var _e;
      Ve((_e = Te) !== null && _e !== void 0 ? _e : h);
    }, events: (Te) => {
      const _e = Te == null ? void 0 : Te.split(" ");
      me(_e ?? x);
    }, "position-strategy": (Te) => {
      var _e;
      fe((_e = Te) !== null && _e !== void 0 ? _e : w);
    }, "delay-show": (Te) => {
      $(Te === null ? R : Number(Te));
    }, "delay-hide": (Te) => {
      Se(Te === null ? b : Number(Te));
    }, float: (Te) => {
      ve(Te === null ? v : !!Te);
    } };
    Object.values(Ke).forEach((Te) => Te(null)), Object.entries(je).forEach(([Te, _e]) => {
      var at;
      (at = Ke[Te]) === null || at === void 0 || at.call(Ke, _e);
    });
  };
  ue.useEffect(() => {
    K(r);
  }, [r]), ue.useEffect(() => {
    B(a);
  }, [a]), ue.useEffect(() => {
    se(l);
  }, [l]), ue.useEffect(() => {
    var je;
    const Ke = new Set(Qe);
    let Te = n;
    if (!Te && e && (Te = `[data-tooltip-id='${e}']`), Te)
      try {
        document.querySelectorAll(Te).forEach((ot) => {
          Ke.add({ current: ot });
        });
      } catch {
        console.warn(`[react-tooltip] "${n}" is not a valid CSS selector`);
      }
    const _e = document.querySelector(`[id='${t}']`);
    if (_e && Ke.add({ current: _e }), !Ke.size)
      return () => null;
    const at = (je = ze ?? _e) !== null && je !== void 0 ? je : He.current, ge = new MutationObserver((ot) => {
      ot.forEach((it) => {
        var wt;
        if (!at || it.type !== "attributes" || !(!((wt = it.attributeName) === null || wt === void 0) && wt.startsWith("data-tooltip-")))
          return;
        const Wt = Fe(at);
        qe(Wt);
      });
    }), ft = { attributes: !0, childList: !1, subtree: !1 };
    if (at) {
      const ot = Fe(at);
      qe(ot), ge.observe(at, ft);
    }
    return () => {
      ge.disconnect();
    };
  }, [Qe, He, ze, t, n]);
  const We = { id: e, anchorId: t, anchorSelect: n, className: i, classNameArrow: u, content: le, html: re, place: j, variant: ee, offset: Z, wrapper: Pe, events: we, positionStrategy: Ce, middlewares: y, delayShow: te, delayHide: ce, float: be, noArrow: A, clickable: N, closeOnEsc: L, style: C, position: z, isOpen: W, setIsOpen: q, afterShow: ne, afterHide: G, activeAnchor: ze, setActiveAnchor: (je) => Ie(je) };
  return g ? Hi.exports.jsx(Yh, { ...We, children: g }) : Hi.exports.jsx(Yh, { ...We });
};
function Gh(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let a of e)
      (a = t(a, ++r, e)) != null && (n < a || n === void 0 && a >= a) && (n = a);
  }
  return n;
}
function oS(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let a of e)
      (a = t(a, ++r, e)) != null && (n > a || n === void 0 && a >= a) && (n = a);
  }
  return n;
}
function Jd(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      (r = +r) && (n += r);
  else {
    let r = -1;
    for (let a of e)
      (a = +t(a, ++r, e)) && (n += a);
  }
  return n;
}
function lS(e) {
  return e.depth;
}
function sS(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function Oc(e) {
  return function() {
    return e;
  };
}
function Xh(e, t) {
  return gu(e.source, t.source) || e.index - t.index;
}
function qh(e, t) {
  return gu(e.target, t.target) || e.index - t.index;
}
function gu(e, t) {
  return e.y0 - t.y0;
}
function ef(e) {
  return e.value;
}
function cS(e) {
  return e.index;
}
function uS(e) {
  return e.nodes;
}
function dS(e) {
  return e.links;
}
function Zh(e, t) {
  const n = e.get(t);
  if (!n)
    throw new Error("missing: " + t);
  return n;
}
function Qh({ nodes: e }) {
  for (const t of e) {
    let n = t.y0, r = n;
    for (const a of t.sourceLinks)
      a.y0 = n + a.width / 2, n += a.width;
    for (const a of t.targetLinks)
      a.y1 = r + a.width / 2, r += a.width;
  }
}
function fS() {
  let e = 0, t = 0, n = 1, r = 1, a = 24, i = 8, u, c = cS, l = sS, p, h, g = uS, x = dS, w = 6;
  function y() {
    const j = { nodes: g.apply(null, arguments), links: x.apply(null, arguments) };
    return R(j), b(j), v(j), A(j), C(j), Qh(j), j;
  }
  y.update = function(j) {
    return Qh(j), j;
  }, y.nodeId = function(j) {
    return arguments.length ? (c = typeof j == "function" ? j : Oc(j), y) : c;
  }, y.nodeAlign = function(j) {
    return arguments.length ? (l = typeof j == "function" ? j : Oc(j), y) : l;
  }, y.nodeSort = function(j) {
    return arguments.length ? (p = j, y) : p;
  }, y.nodeWidth = function(j) {
    return arguments.length ? (a = +j, y) : a;
  }, y.nodePadding = function(j) {
    return arguments.length ? (i = u = +j, y) : i;
  }, y.nodes = function(j) {
    return arguments.length ? (g = typeof j == "function" ? j : Oc(j), y) : g;
  }, y.links = function(j) {
    return arguments.length ? (x = typeof j == "function" ? j : Oc(j), y) : x;
  }, y.linkSort = function(j) {
    return arguments.length ? (h = j, y) : h;
  }, y.size = function(j) {
    return arguments.length ? (e = t = 0, n = +j[0], r = +j[1], y) : [n - e, r - t];
  }, y.extent = function(j) {
    return arguments.length ? (e = +j[0][0], n = +j[1][0], t = +j[0][1], r = +j[1][1], y) : [[e, t], [n, r]];
  }, y.iterations = function(j) {
    return arguments.length ? (w = +j, y) : w;
  };
  function R({ nodes: j, links: se }) {
    for (const [Q, Z] of j.entries())
      Z.index = Q, Z.sourceLinks = [], Z.targetLinks = [];
    const ee = new Map(j.map((Q, Z) => [c(Q, Z, j), Q]));
    for (const [Q, Z] of se.entries()) {
      Z.index = Q;
      let { source: Y, target: te } = Z;
      typeof Y != "object" && (Y = Z.source = Zh(ee, Y)), typeof te != "object" && (te = Z.target = Zh(ee, te)), Y.sourceLinks.push(Z), te.targetLinks.push(Z);
    }
    if (h != null)
      for (const { sourceLinks: Q, targetLinks: Z } of j)
        Q.sort(h), Z.sort(h);
  }
  function b({ nodes: j }) {
    for (const se of j)
      se.value = se.fixedValue === void 0 ? Math.max(Jd(se.sourceLinks, ef), Jd(se.targetLinks, ef)) : se.fixedValue;
  }
  function v({ nodes: j }) {
    const se = j.length;
    let ee = new Set(j), Q = /* @__PURE__ */ new Set(), Z = 0;
    for (; ee.size; ) {
      for (const Y of ee) {
        Y.depth = Z;
        for (const { target: te } of Y.sourceLinks)
          Q.add(te);
      }
      if (++Z > se)
        throw new Error("circular link");
      ee = Q, Q = /* @__PURE__ */ new Set();
    }
  }
  function A({ nodes: j }) {
    const se = j.length;
    let ee = new Set(j), Q = /* @__PURE__ */ new Set(), Z = 0;
    for (; ee.size; ) {
      for (const Y of ee) {
        Y.height = Z;
        for (const { source: te } of Y.targetLinks)
          Q.add(te);
      }
      if (++Z > se)
        throw new Error("circular link");
      ee = Q, Q = /* @__PURE__ */ new Set();
    }
  }
  function N({ nodes: j }) {
    const se = Gh(j, (Z) => Z.depth) + 1, ee = (n - e - a) / (se - 1), Q = new Array(se);
    for (const Z of j) {
      const Y = Math.max(0, Math.min(se - 1, Math.floor(l.call(null, Z, se))));
      Z.layer = Y, Z.x0 = e + Y * ee, Z.x1 = Z.x0 + a, Q[Y] ? Q[Y].push(Z) : Q[Y] = [Z];
    }
    if (p)
      for (const Z of Q)
        Z.sort(p);
    return Q;
  }
  function L(j) {
    const se = oS(j, (ee) => (r - t - (ee.length - 1) * u) / Jd(ee, ef));
    for (const ee of j) {
      let Q = t;
      for (const Z of ee) {
        Z.y0 = Q, Z.y1 = Q + Z.value * se, Q = Z.y1 + u;
        for (const Y of Z.sourceLinks)
          Y.width = Y.value * se;
      }
      Q = (r - Q + u) / (ee.length + 1);
      for (let Z = 0; Z < ee.length; ++Z) {
        const Y = ee[Z];
        Y.y0 += Q * (Z + 1), Y.y1 += Q * (Z + 1);
      }
      K(ee);
    }
  }
  function C(j) {
    const se = N(j);
    u = Math.min(i, (r - t) / (Gh(se, (ee) => ee.length) - 1)), L(se);
    for (let ee = 0; ee < w; ++ee) {
      const Q = Math.pow(0.99, ee), Z = Math.max(1 - Q, (ee + 1) / w);
      W(se, Q, Z), z(se, Q, Z);
    }
  }
  function z(j, se, ee) {
    for (let Q = 1, Z = j.length; Q < Z; ++Q) {
      const Y = j[Q];
      for (const te of Y) {
        let $ = 0, ce = 0;
        for (const { source: be, value: ve } of te.targetLinks) {
          let Pe = ve * (te.layer - be.layer);
          $ += re(be, te) * Pe, ce += Pe;
        }
        if (!(ce > 0))
          continue;
        let Se = ($ / ce - te.y0) * se;
        te.y0 += Se, te.y1 += Se, le(te);
      }
      p === void 0 && Y.sort(gu), q(Y, ee);
    }
  }
  function W(j, se, ee) {
    for (let Q = j.length, Z = Q - 2; Z >= 0; --Z) {
      const Y = j[Z];
      for (const te of Y) {
        let $ = 0, ce = 0;
        for (const { target: be, value: ve } of te.sourceLinks) {
          let Pe = ve * (be.layer - te.layer);
          $ += B(te, be) * Pe, ce += Pe;
        }
        if (!(ce > 0))
          continue;
        let Se = ($ / ce - te.y0) * se;
        te.y0 += Se, te.y1 += Se, le(te);
      }
      p === void 0 && Y.sort(gu), q(Y, ee);
    }
  }
  function q(j, se) {
    const ee = j.length >> 1, Q = j[ee];
    G(j, Q.y0 - u, ee - 1, se), ne(j, Q.y1 + u, ee + 1, se), G(j, r, j.length - 1, se), ne(j, t, 0, se);
  }
  function ne(j, se, ee, Q) {
    for (; ee < j.length; ++ee) {
      const Z = j[ee], Y = (se - Z.y0) * Q;
      Y > 1e-6 && (Z.y0 += Y, Z.y1 += Y), se = Z.y1 + u;
    }
  }
  function G(j, se, ee, Q) {
    for (; ee >= 0; --ee) {
      const Z = j[ee], Y = (Z.y1 - se) * Q;
      Y > 1e-6 && (Z.y0 -= Y, Z.y1 -= Y), se = Z.y0 - u;
    }
  }
  function le({ sourceLinks: j, targetLinks: se }) {
    if (h === void 0) {
      for (const { source: { sourceLinks: ee } } of se)
        ee.sort(qh);
      for (const { target: { targetLinks: ee } } of j)
        ee.sort(Xh);
    }
  }
  function K(j) {
    if (h === void 0)
      for (const { sourceLinks: se, targetLinks: ee } of j)
        se.sort(qh), ee.sort(Xh);
  }
  function re(j, se) {
    let ee = j.y0 - (j.sourceLinks.length - 1) * u / 2;
    for (const { target: Q, width: Z } of j.sourceLinks) {
      if (Q === se)
        break;
      ee += Z + u;
    }
    for (const { source: Q, width: Z } of se.targetLinks) {
      if (Q === j)
        break;
      ee -= Z;
    }
    return ee;
  }
  function B(j, se) {
    let ee = se.y0 - (se.targetLinks.length - 1) * u / 2;
    for (const { source: Q, width: Z } of se.targetLinks) {
      if (Q === j)
        break;
      ee += Z + u;
    }
    for (const { target: Q, width: Z } of j.sourceLinks) {
      if (Q === se)
        break;
      ee -= Z;
    }
    return ee;
  }
  return y;
}
function pS(e) {
  return [e.source.x1, e.y0];
}
function hS(e) {
  return [e.target.x0, e.y1];
}
function mS() {
  return d0().source(pS).target(hS);
}
const yS = () => {
  const { config: e, handleChartTabbing: t, legendId: n } = ue.useContext(mt), [r, a] = ue.useState(!1), i = /* @__PURE__ */ React.createElement(React.Fragment, null, "For best viewing we recommend portrait mode. If you are unable to put your device in portrait mode, please review the ", /* @__PURE__ */ React.createElement("a", { href: `#${t(e, n)}` }, "data table"), " below.", " ", /* @__PURE__ */ React.createElement("a", { onClick: () => a(!1), href: "#!" }, "Close this alert"), " ", "to continue viewing the chart."), u = () => {
    a(!1);
  }, c = r ? /* @__PURE__ */ React.createElement("div", { className: "alert alert-warning alert-dismissible", role: "alert" }, /* @__PURE__ */ React.createElement("p", { style: { padding: "35px" } }, i), /* @__PURE__ */ React.createElement("button", { type: "button", className: "close", "data-dismiss": "alert", "aria-label": "Close", onClick: u }, /* @__PURE__ */ React.createElement("span", { "aria-hidden": "true" }, "×"))) : null;
  return ue.useEffect(() => {
    const l = () => {
      window.innerWidth < 768 && window.innerHeight > window.innerWidth ? a(!0) : a(!1);
    };
    return window.addEventListener("resize", l), l(), () => {
      window.removeEventListener("resize", l);
    };
  }, []), {
    setShowAlert: a,
    showAlert: r,
    handleCloseModal: u,
    alertMessage: i,
    alert: c
  };
};
var Xa = {}, Pi = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Jh;
function gS() {
  if (Jh)
    return Pi;
  Jh = 1;
  var e = ue;
  function t(E) {
    for (var _ = "https://reactjs.org/docs/error-decoder.html?invariant=" + E, D = 1; D < arguments.length; D++)
      _ += "&args[]=" + encodeURIComponent(arguments[D]);
    return "Minified React error #" + E + "; visit " + _ + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = Object.prototype.hasOwnProperty, r = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, a = {}, i = {};
  function u(E) {
    return n.call(i, E) ? !0 : n.call(a, E) ? !1 : r.test(E) ? i[E] = !0 : (a[E] = !0, !1);
  }
  function c(E, _, D, U, pe, O, I) {
    this.acceptsBooleans = _ === 2 || _ === 3 || _ === 4, this.attributeName = U, this.attributeNamespace = pe, this.mustUseProperty = D, this.propertyName = E, this.type = _, this.sanitizeURL = O, this.removeEmptyString = I;
  }
  var l = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(E) {
    l[E] = new c(E, 0, !1, E, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(E) {
    var _ = E[0];
    l[_] = new c(_, 1, !1, E[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(E) {
    l[E] = new c(E, 2, !1, E.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(E) {
    l[E] = new c(E, 2, !1, E, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(E) {
    l[E] = new c(E, 3, !1, E.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(E) {
    l[E] = new c(E, 3, !0, E, null, !1, !1);
  }), ["capture", "download"].forEach(function(E) {
    l[E] = new c(E, 4, !1, E, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(E) {
    l[E] = new c(E, 6, !1, E, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(E) {
    l[E] = new c(E, 5, !1, E.toLowerCase(), null, !1, !1);
  });
  var p = /[\-:]([a-z])/g;
  function h(E) {
    return E[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(E) {
    var _ = E.replace(
      p,
      h
    );
    l[_] = new c(_, 1, !1, E, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(E) {
    var _ = E.replace(p, h);
    l[_] = new c(_, 1, !1, E, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(E) {
    var _ = E.replace(p, h);
    l[_] = new c(_, 1, !1, E, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(E) {
    l[E] = new c(E, 1, !1, E.toLowerCase(), null, !1, !1);
  }), l.xlinkHref = new c("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(E) {
    l[E] = new c(E, 1, !1, E.toLowerCase(), null, !0, !0);
  });
  var g = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, x = ["Webkit", "ms", "Moz", "O"];
  Object.keys(g).forEach(function(E) {
    x.forEach(function(_) {
      _ = _ + E.charAt(0).toUpperCase() + E.substring(1), g[_] = g[E];
    });
  });
  var w = /["'&<>]/;
  function y(E) {
    if (typeof E == "boolean" || typeof E == "number")
      return "" + E;
    E = "" + E;
    var _ = w.exec(E);
    if (_) {
      var D = "", U, pe = 0;
      for (U = _.index; U < E.length; U++) {
        switch (E.charCodeAt(U)) {
          case 34:
            _ = "&quot;";
            break;
          case 38:
            _ = "&amp;";
            break;
          case 39:
            _ = "&#x27;";
            break;
          case 60:
            _ = "&lt;";
            break;
          case 62:
            _ = "&gt;";
            break;
          default:
            continue;
        }
        pe !== U && (D += E.substring(pe, U)), pe = U + 1, D += _;
      }
      E = pe !== U ? D + E.substring(pe, U) : D;
    }
    return E;
  }
  var R = /([A-Z])/g, b = /^ms-/, v = Array.isArray;
  function A(E, _) {
    return { insertionMode: E, selectedValue: _ };
  }
  function N(E, _, D) {
    switch (_) {
      case "select":
        return A(1, D.value != null ? D.value : D.defaultValue);
      case "svg":
        return A(2, null);
      case "math":
        return A(3, null);
      case "foreignObject":
        return A(1, null);
      case "table":
        return A(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return A(5, null);
      case "colgroup":
        return A(7, null);
      case "tr":
        return A(6, null);
    }
    return 4 <= E.insertionMode || E.insertionMode === 0 ? A(1, null) : E;
  }
  var L = /* @__PURE__ */ new Map();
  function C(E, _, D) {
    if (typeof D != "object")
      throw Error(t(62));
    _ = !0;
    for (var U in D)
      if (n.call(D, U)) {
        var pe = D[U];
        if (pe != null && typeof pe != "boolean" && pe !== "") {
          if (U.indexOf("--") === 0) {
            var O = y(U);
            pe = y(("" + pe).trim());
          } else {
            O = U;
            var I = L.get(O);
            I !== void 0 || (I = y(O.replace(R, "-$1").toLowerCase().replace(b, "-ms-")), L.set(O, I)), O = I, pe = typeof pe == "number" ? pe === 0 || n.call(g, U) ? "" + pe : pe + "px" : y(("" + pe).trim());
          }
          _ ? (_ = !1, E.push(' style="', O, ":", pe)) : E.push(";", O, ":", pe);
        }
      }
    _ || E.push('"');
  }
  function z(E, _, D, U) {
    switch (D) {
      case "style":
        C(E, _, U);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < D.length) || D[0] !== "o" && D[0] !== "O" || D[1] !== "n" && D[1] !== "N") {
      if (_ = l.hasOwnProperty(D) ? l[D] : null, _ !== null) {
        switch (typeof U) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!_.acceptsBooleans)
              return;
        }
        switch (D = _.attributeName, _.type) {
          case 3:
            U && E.push(" ", D, '=""');
            break;
          case 4:
            U === !0 ? E.push(" ", D, '=""') : U !== !1 && E.push(" ", D, '="', y(U), '"');
            break;
          case 5:
            isNaN(U) || E.push(" ", D, '="', y(U), '"');
            break;
          case 6:
            !isNaN(U) && 1 <= U && E.push(" ", D, '="', y(U), '"');
            break;
          default:
            _.sanitizeURL && (U = "" + U), E.push(" ", D, '="', y(U), '"');
        }
      } else if (u(D)) {
        switch (typeof U) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (_ = D.toLowerCase().slice(0, 5), _ !== "data-" && _ !== "aria-")
              return;
        }
        E.push(" ", D, '="', y(U), '"');
      }
    }
  }
  function W(E, _, D) {
    if (_ != null) {
      if (D != null)
        throw Error(t(60));
      if (typeof _ != "object" || !("__html" in _))
        throw Error(t(61));
      _ = _.__html, _ != null && E.push("" + _);
    }
  }
  function q(E) {
    var _ = "";
    return e.Children.forEach(E, function(D) {
      D != null && (_ += D);
    }), _;
  }
  function ne(E, _, D, U) {
    E.push(K(D));
    var pe = D = null, O;
    for (O in _)
      if (n.call(_, O)) {
        var I = _[O];
        if (I != null)
          switch (O) {
            case "children":
              D = I;
              break;
            case "dangerouslySetInnerHTML":
              pe = I;
              break;
            default:
              z(E, U, O, I);
          }
      }
    return E.push(">"), W(E, pe, D), typeof D == "string" ? (E.push(y(D)), null) : D;
  }
  var G = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, le = /* @__PURE__ */ new Map();
  function K(E) {
    var _ = le.get(E);
    if (_ === void 0) {
      if (!G.test(E))
        throw Error(t(65, E));
      _ = "<" + E, le.set(E, _);
    }
    return _;
  }
  function re(E, _, D, U, pe) {
    switch (_) {
      case "select":
        E.push(K("select"));
        var O = null, I = null;
        for (Xe in D)
          if (n.call(D, Xe)) {
            var J = D[Xe];
            if (J != null)
              switch (Xe) {
                case "children":
                  O = J;
                  break;
                case "dangerouslySetInnerHTML":
                  I = J;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  z(E, U, Xe, J);
              }
          }
        return E.push(">"), W(E, I, O), O;
      case "option":
        I = pe.selectedValue, E.push(K("option"));
        var xe = J = null, Be = null, Xe = null;
        for (O in D)
          if (n.call(D, O)) {
            var dt = D[O];
            if (dt != null)
              switch (O) {
                case "children":
                  J = dt;
                  break;
                case "selected":
                  Be = dt;
                  break;
                case "dangerouslySetInnerHTML":
                  Xe = dt;
                  break;
                case "value":
                  xe = dt;
                default:
                  z(E, U, O, dt);
              }
          }
        if (I != null)
          if (D = xe !== null ? "" + xe : q(J), v(I)) {
            for (U = 0; U < I.length; U++)
              if ("" + I[U] === D) {
                E.push(' selected=""');
                break;
              }
          } else
            "" + I === D && E.push(' selected=""');
        else
          Be && E.push(' selected=""');
        return E.push(">"), W(E, Xe, J), J;
      case "textarea":
        E.push(K("textarea")), Xe = I = O = null;
        for (J in D)
          if (n.call(D, J) && (xe = D[J], xe != null))
            switch (J) {
              case "children":
                Xe = xe;
                break;
              case "value":
                O = xe;
                break;
              case "defaultValue":
                I = xe;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                z(
                  E,
                  U,
                  J,
                  xe
                );
            }
        if (O === null && I !== null && (O = I), E.push(">"), Xe != null) {
          if (O != null)
            throw Error(t(92));
          if (v(Xe) && 1 < Xe.length)
            throw Error(t(93));
          O = "" + Xe;
        }
        return typeof O == "string" && O[0] === `
` && E.push(`
`), O !== null && E.push(y("" + O)), null;
      case "input":
        E.push(K("input")), xe = Xe = J = O = null;
        for (I in D)
          if (n.call(D, I) && (Be = D[I], Be != null))
            switch (I) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                xe = Be;
                break;
              case "defaultValue":
                J = Be;
                break;
              case "checked":
                Xe = Be;
                break;
              case "value":
                O = Be;
                break;
              default:
                z(E, U, I, Be);
            }
        return Xe !== null ? z(E, U, "checked", Xe) : xe !== null && z(E, U, "checked", xe), O !== null ? z(E, U, "value", O) : J !== null && z(E, U, "value", J), E.push("/>"), null;
      case "menuitem":
        E.push(K("menuitem"));
        for (var Vt in D)
          if (n.call(D, Vt) && (O = D[Vt], O != null))
            switch (Vt) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                z(E, U, Vt, O);
            }
        return E.push(">"), null;
      case "title":
        E.push(K("title")), O = null;
        for (dt in D)
          if (n.call(D, dt) && (I = D[dt], I != null))
            switch (dt) {
              case "children":
                O = I;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                z(E, U, dt, I);
            }
        return E.push(">"), O;
      case "listing":
      case "pre":
        E.push(K(_)), I = O = null;
        for (xe in D)
          if (n.call(D, xe) && (J = D[xe], J != null))
            switch (xe) {
              case "children":
                O = J;
                break;
              case "dangerouslySetInnerHTML":
                I = J;
                break;
              default:
                z(E, U, xe, J);
            }
        if (E.push(">"), I != null) {
          if (O != null)
            throw Error(t(60));
          if (typeof I != "object" || !("__html" in I))
            throw Error(t(61));
          D = I.__html, D != null && (typeof D == "string" && 0 < D.length && D[0] === `
` ? E.push(`
`, D) : E.push("" + D));
        }
        return typeof O == "string" && O[0] === `
` && E.push(`
`), O;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        E.push(K(_));
        for (var zt in D)
          if (n.call(D, zt) && (O = D[zt], O != null))
            switch (zt) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, _));
              default:
                z(E, U, zt, O);
            }
        return E.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return ne(
          E,
          D,
          _,
          U
        );
      case "html":
        return pe.insertionMode === 0 && E.push("<!DOCTYPE html>"), ne(E, D, _, U);
      default:
        if (_.indexOf("-") === -1 && typeof D.is != "string")
          return ne(E, D, _, U);
        E.push(K(_)), I = O = null;
        for (Be in D)
          if (n.call(D, Be) && (J = D[Be], J != null))
            switch (Be) {
              case "children":
                O = J;
                break;
              case "dangerouslySetInnerHTML":
                I = J;
                break;
              case "style":
                C(E, U, J);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                u(Be) && typeof J != "function" && typeof J != "symbol" && E.push(" ", Be, '="', y(J), '"');
            }
        return E.push(">"), W(E, I, O), O;
    }
  }
  function B(E, _, D) {
    if (E.push('<!--$?--><template id="'), D === null)
      throw Error(t(395));
    return E.push(D), E.push('"></template>');
  }
  function j(E, _, D, U) {
    switch (D.insertionMode) {
      case 0:
      case 1:
        return E.push('<div hidden id="'), E.push(_.segmentPrefix), _ = U.toString(16), E.push(_), E.push('">');
      case 2:
        return E.push('<svg aria-hidden="true" style="display:none" id="'), E.push(_.segmentPrefix), _ = U.toString(16), E.push(_), E.push('">');
      case 3:
        return E.push('<math aria-hidden="true" style="display:none" id="'), E.push(_.segmentPrefix), _ = U.toString(16), E.push(_), E.push('">');
      case 4:
        return E.push('<table hidden id="'), E.push(_.segmentPrefix), _ = U.toString(16), E.push(_), E.push('">');
      case 5:
        return E.push('<table hidden><tbody id="'), E.push(_.segmentPrefix), _ = U.toString(16), E.push(_), E.push('">');
      case 6:
        return E.push('<table hidden><tr id="'), E.push(_.segmentPrefix), _ = U.toString(16), E.push(_), E.push('">');
      case 7:
        return E.push('<table hidden><colgroup id="'), E.push(_.segmentPrefix), _ = U.toString(16), E.push(_), E.push('">');
      default:
        throw Error(t(397));
    }
  }
  function se(E, _) {
    switch (_.insertionMode) {
      case 0:
      case 1:
        return E.push("</div>");
      case 2:
        return E.push("</svg>");
      case 3:
        return E.push("</math>");
      case 4:
        return E.push("</table>");
      case 5:
        return E.push("</tbody></table>");
      case 6:
        return E.push("</tr></table>");
      case 7:
        return E.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var ee = /[<\u2028\u2029]/g;
  function Q(E) {
    return JSON.stringify(E).replace(ee, function(_) {
      switch (_) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function Z(E, _) {
    return _ = _ === void 0 ? "" : _, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: _ + "P:", segmentPrefix: _ + "S:", boundaryPrefix: _ + "B:", idPrefix: _, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: E };
  }
  function Y(E, _, D, U) {
    return D.generateStaticMarkup ? (E.push(y(_)), !1) : (_ === "" ? E = U : (U && E.push("<!-- -->"), E.push(y(_)), E = !0), E);
  }
  var te = Object.assign, $ = Symbol.for("react.element"), ce = Symbol.for("react.portal"), Se = Symbol.for("react.fragment"), be = Symbol.for("react.strict_mode"), ve = Symbol.for("react.profiler"), Pe = Symbol.for("react.provider"), Ve = Symbol.for("react.context"), we = Symbol.for("react.forward_ref"), me = Symbol.for("react.suspense"), Ce = Symbol.for("react.suspense_list"), fe = Symbol.for("react.memo"), ze = Symbol.for("react.lazy"), Ie = Symbol.for("react.scope"), Qe = Symbol.for("react.debug_trace_mode"), He = Symbol.for("react.legacy_hidden"), Fe = Symbol.for("react.default_value"), qe = Symbol.iterator;
  function We(E) {
    if (E == null)
      return null;
    if (typeof E == "function")
      return E.displayName || E.name || null;
    if (typeof E == "string")
      return E;
    switch (E) {
      case Se:
        return "Fragment";
      case ce:
        return "Portal";
      case ve:
        return "Profiler";
      case be:
        return "StrictMode";
      case me:
        return "Suspense";
      case Ce:
        return "SuspenseList";
    }
    if (typeof E == "object")
      switch (E.$$typeof) {
        case Ve:
          return (E.displayName || "Context") + ".Consumer";
        case Pe:
          return (E._context.displayName || "Context") + ".Provider";
        case we:
          var _ = E.render;
          return E = E.displayName, E || (E = _.displayName || _.name || "", E = E !== "" ? "ForwardRef(" + E + ")" : "ForwardRef"), E;
        case fe:
          return _ = E.displayName || null, _ !== null ? _ : We(E.type) || "Memo";
        case ze:
          _ = E._payload, E = E._init;
          try {
            return We(E(_));
          } catch {
          }
      }
    return null;
  }
  var je = {};
  function Ke(E, _) {
    if (E = E.contextTypes, !E)
      return je;
    var D = {}, U;
    for (U in E)
      D[U] = _[U];
    return D;
  }
  var Te = null;
  function _e(E, _) {
    if (E !== _) {
      E.context._currentValue2 = E.parentValue, E = E.parent;
      var D = _.parent;
      if (E === null) {
        if (D !== null)
          throw Error(t(401));
      } else {
        if (D === null)
          throw Error(t(401));
        _e(E, D);
      }
      _.context._currentValue2 = _.value;
    }
  }
  function at(E) {
    E.context._currentValue2 = E.parentValue, E = E.parent, E !== null && at(E);
  }
  function ge(E) {
    var _ = E.parent;
    _ !== null && ge(_), E.context._currentValue2 = E.value;
  }
  function ft(E, _) {
    if (E.context._currentValue2 = E.parentValue, E = E.parent, E === null)
      throw Error(t(402));
    E.depth === _.depth ? _e(E, _) : ft(E, _);
  }
  function ot(E, _) {
    var D = _.parent;
    if (D === null)
      throw Error(t(402));
    E.depth === D.depth ? _e(E, D) : ot(E, D), _.context._currentValue2 = _.value;
  }
  function it(E) {
    var _ = Te;
    _ !== E && (_ === null ? ge(E) : E === null ? at(_) : _.depth === E.depth ? _e(_, E) : _.depth > E.depth ? ft(_, E) : ot(_, E), Te = E);
  }
  var wt = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(E, _) {
    E = E._reactInternals, E.queue !== null && E.queue.push(_);
  }, enqueueReplaceState: function(E, _) {
    E = E._reactInternals, E.replace = !0, E.queue = [_];
  }, enqueueForceUpdate: function() {
  } };
  function Wt(E, _, D, U) {
    var pe = E.state !== void 0 ? E.state : null;
    E.updater = wt, E.props = D, E.state = pe;
    var O = { queue: [], replace: !1 };
    E._reactInternals = O;
    var I = _.contextType;
    if (E.context = typeof I == "object" && I !== null ? I._currentValue2 : U, I = _.getDerivedStateFromProps, typeof I == "function" && (I = I(D, pe), pe = I == null ? pe : te({}, pe, I), E.state = pe), typeof _.getDerivedStateFromProps != "function" && typeof E.getSnapshotBeforeUpdate != "function" && (typeof E.UNSAFE_componentWillMount == "function" || typeof E.componentWillMount == "function"))
      if (_ = E.state, typeof E.componentWillMount == "function" && E.componentWillMount(), typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount(), _ !== E.state && wt.enqueueReplaceState(E, E.state, null), O.queue !== null && 0 < O.queue.length)
        if (_ = O.queue, I = O.replace, O.queue = null, O.replace = !1, I && _.length === 1)
          E.state = _[0];
        else {
          for (O = I ? _[0] : E.state, pe = !0, I = I ? 1 : 0; I < _.length; I++) {
            var J = _[I];
            J = typeof J == "function" ? J.call(E, O, D, U) : J, J != null && (pe ? (pe = !1, O = te({}, O, J)) : te(O, J));
          }
          E.state = O;
        }
      else
        O.queue = null;
  }
  var Kt = { id: 1, overflow: "" };
  function Mt(E, _, D) {
    var U = E.id;
    E = E.overflow;
    var pe = 32 - rn(U) - 1;
    U &= ~(1 << pe), D += 1;
    var O = 32 - rn(_) + pe;
    if (30 < O) {
      var I = pe - pe % 5;
      return O = (U & (1 << I) - 1).toString(32), U >>= I, pe -= I, { id: 1 << 32 - rn(_) + pe | D << pe | U, overflow: O + E };
    }
    return { id: 1 << O | D << pe | U, overflow: E };
  }
  var rn = Math.clz32 ? Math.clz32 : Nt, Et = Math.log, Pt = Math.LN2;
  function Nt(E) {
    return E >>>= 0, E === 0 ? 32 : 31 - (Et(E) / Pt | 0) | 0;
  }
  function tn(E, _) {
    return E === _ && (E !== 0 || 1 / E === 1 / _) || E !== E && _ !== _;
  }
  var sn = typeof Object.is == "function" ? Object.is : tn, Ot = null, Ft = null, nn = null, et = null, ut = !1, Ne = !1, De = 0, Ee = null, pt = 0;
  function nt() {
    if (Ot === null)
      throw Error(t(321));
    return Ot;
  }
  function gt() {
    if (0 < pt)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function xt() {
    return et === null ? nn === null ? (ut = !1, nn = et = gt()) : (ut = !0, et = nn) : et.next === null ? (ut = !1, et = et.next = gt()) : (ut = !0, et = et.next), et;
  }
  function Yt() {
    Ft = Ot = null, Ne = !1, nn = null, pt = 0, et = Ee = null;
  }
  function lt(E, _) {
    return typeof _ == "function" ? _(E) : _;
  }
  function st(E, _, D) {
    if (Ot = nt(), et = xt(), ut) {
      var U = et.queue;
      if (_ = U.dispatch, Ee !== null && (D = Ee.get(U), D !== void 0)) {
        Ee.delete(U), U = et.memoizedState;
        do
          U = E(U, D.action), D = D.next;
        while (D !== null);
        return et.memoizedState = U, [U, _];
      }
      return [et.memoizedState, _];
    }
    return E = E === lt ? typeof _ == "function" ? _() : _ : D !== void 0 ? D(_) : _, et.memoizedState = E, E = et.queue = { last: null, dispatch: null }, E = E.dispatch = jt.bind(null, Ot, E), [et.memoizedState, E];
  }
  function $t(E, _) {
    if (Ot = nt(), et = xt(), _ = _ === void 0 ? null : _, et !== null) {
      var D = et.memoizedState;
      if (D !== null && _ !== null) {
        var U = D[1];
        e:
          if (U === null)
            U = !1;
          else {
            for (var pe = 0; pe < U.length && pe < _.length; pe++)
              if (!sn(_[pe], U[pe])) {
                U = !1;
                break e;
              }
            U = !0;
          }
        if (U)
          return D[0];
      }
    }
    return E = E(), et.memoizedState = [E, _], E;
  }
  function jt(E, _, D) {
    if (25 <= pt)
      throw Error(t(301));
    if (E === Ot)
      if (Ne = !0, E = { action: D, next: null }, Ee === null && (Ee = /* @__PURE__ */ new Map()), D = Ee.get(_), D === void 0)
        Ee.set(_, E);
      else {
        for (_ = D; _.next !== null; )
          _ = _.next;
        _.next = E;
      }
  }
  function Rt() {
    throw Error(t(394));
  }
  function St() {
  }
  var yn = { readContext: function(E) {
    return E._currentValue2;
  }, useContext: function(E) {
    return nt(), E._currentValue2;
  }, useMemo: $t, useReducer: st, useRef: function(E) {
    Ot = nt(), et = xt();
    var _ = et.memoizedState;
    return _ === null ? (E = { current: E }, et.memoizedState = E) : _;
  }, useState: function(E) {
    return st(lt, E);
  }, useInsertionEffect: St, useLayoutEffect: function() {
  }, useCallback: function(E, _) {
    return $t(function() {
      return E;
    }, _);
  }, useImperativeHandle: St, useEffect: St, useDebugValue: St, useDeferredValue: function(E) {
    return nt(), E;
  }, useTransition: function() {
    return nt(), [
      !1,
      Rt
    ];
  }, useId: function() {
    var E = Ft.treeContext, _ = E.overflow;
    E = E.id, E = (E & ~(1 << 32 - rn(E) - 1)).toString(32) + _;
    var D = vn;
    if (D === null)
      throw Error(t(404));
    return _ = De++, E = ":" + D.idPrefix + "R" + E, 0 < _ && (E += "H" + _.toString(32)), E + ":";
  }, useMutableSource: function(E, _) {
    return nt(), _(E._source);
  }, useSyncExternalStore: function(E, _, D) {
    if (D === void 0)
      throw Error(t(407));
    return D();
  } }, vn = null, wn = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function Pn(E) {
    return console.error(E), null;
  }
  function Tn() {
  }
  function er(E, _, D, U, pe, O, I, J, xe) {
    var Be = [], Xe = /* @__PURE__ */ new Set();
    return _ = { destination: null, responseState: _, progressiveChunkSize: U === void 0 ? 12800 : U, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Xe, pingedTasks: Be, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: pe === void 0 ? Pn : pe, onAllReady: O === void 0 ? Tn : O, onShellReady: I === void 0 ? Tn : I, onShellError: J === void 0 ? Tn : J, onFatalError: xe === void 0 ? Tn : xe }, D = xn(_, 0, null, D, !1, !1), D.parentFlushed = !0, E = Dn(_, E, null, D, Xe, je, null, Kt), Be.push(E), _;
  }
  function Dn(E, _, D, U, pe, O, I, J) {
    E.allPendingTasks++, D === null ? E.pendingRootTasks++ : D.pendingTasks++;
    var xe = { node: _, ping: function() {
      var Be = E.pingedTasks;
      Be.push(xe), Be.length === 1 && pn(E);
    }, blockedBoundary: D, blockedSegment: U, abortSet: pe, legacyContext: O, context: I, treeContext: J };
    return pe.add(xe), xe;
  }
  function xn(E, _, D, U, pe, O) {
    return { status: 0, id: -1, index: _, parentFlushed: !1, chunks: [], children: [], formatContext: U, boundary: D, lastPushedText: pe, textEmbedded: O };
  }
  function At(E, _) {
    if (E = E.onError(_), E != null && typeof E != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof E + '" instead');
    return E;
  }
  function Ht(E, _) {
    var D = E.onShellError;
    D(_), D = E.onFatalError, D(_), E.destination !== null ? (E.status = 2, E.destination.destroy(_)) : (E.status = 1, E.fatalError = _);
  }
  function bn(E, _, D, U, pe) {
    for (Ot = {}, Ft = _, De = 0, E = D(U, pe); Ne; )
      Ne = !1, De = 0, pt += 1, et = null, E = D(U, pe);
    return Yt(), E;
  }
  function Qt(E, _, D, U) {
    var pe = D.render(), O = U.childContextTypes;
    if (O != null) {
      var I = _.legacyContext;
      if (typeof D.getChildContext != "function")
        U = I;
      else {
        D = D.getChildContext();
        for (var J in D)
          if (!(J in O))
            throw Error(t(108, We(U) || "Unknown", J));
        U = te({}, I, D);
      }
      _.legacyContext = U, Lt(E, _, pe), _.legacyContext = I;
    } else
      Lt(E, _, pe);
  }
  function cn(E, _) {
    if (E && E.defaultProps) {
      _ = te({}, _), E = E.defaultProps;
      for (var D in E)
        _[D] === void 0 && (_[D] = E[D]);
      return _;
    }
    return _;
  }
  function kn(E, _, D, U, pe) {
    if (typeof D == "function")
      if (D.prototype && D.prototype.isReactComponent) {
        pe = Ke(D, _.legacyContext);
        var O = D.contextType;
        O = new D(U, typeof O == "object" && O !== null ? O._currentValue2 : pe), Wt(O, D, U, pe), Qt(E, _, O, D);
      } else {
        O = Ke(D, _.legacyContext), pe = bn(E, _, D, U, O);
        var I = De !== 0;
        if (typeof pe == "object" && pe !== null && typeof pe.render == "function" && pe.$$typeof === void 0)
          Wt(pe, D, U, O), Qt(E, _, pe, D);
        else if (I) {
          U = _.treeContext, _.treeContext = Mt(U, 1, 0);
          try {
            Lt(E, _, pe);
          } finally {
            _.treeContext = U;
          }
        } else
          Lt(E, _, pe);
      }
    else if (typeof D == "string") {
      switch (pe = _.blockedSegment, O = re(pe.chunks, D, U, E.responseState, pe.formatContext), pe.lastPushedText = !1, I = pe.formatContext, pe.formatContext = N(I, D, U), an(E, _, O), pe.formatContext = I, D) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          pe.chunks.push("</", D, ">");
      }
      pe.lastPushedText = !1;
    } else {
      switch (D) {
        case He:
        case Qe:
        case be:
        case ve:
        case Se:
          Lt(E, _, U.children);
          return;
        case Ce:
          Lt(E, _, U.children);
          return;
        case Ie:
          throw Error(t(343));
        case me:
          e: {
            D = _.blockedBoundary, pe = _.blockedSegment, O = U.fallback, U = U.children, I = /* @__PURE__ */ new Set();
            var J = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: I, errorDigest: null }, xe = xn(E, pe.chunks.length, J, pe.formatContext, !1, !1);
            pe.children.push(xe), pe.lastPushedText = !1;
            var Be = xn(E, 0, null, pe.formatContext, !1, !1);
            Be.parentFlushed = !0, _.blockedBoundary = J, _.blockedSegment = Be;
            try {
              if (an(
                E,
                _,
                U
              ), E.responseState.generateStaticMarkup || Be.lastPushedText && Be.textEmbedded && Be.chunks.push("<!-- -->"), Be.status = 1, _n(J, Be), J.pendingTasks === 0)
                break e;
            } catch (Xe) {
              Be.status = 4, J.forceClientRender = !0, J.errorDigest = At(E, Xe);
            } finally {
              _.blockedBoundary = D, _.blockedSegment = pe;
            }
            _ = Dn(E, O, D, xe, I, _.legacyContext, _.context, _.treeContext), E.pingedTasks.push(_);
          }
          return;
      }
      if (typeof D == "object" && D !== null)
        switch (D.$$typeof) {
          case we:
            if (U = bn(E, _, D.render, U, pe), De !== 0) {
              D = _.treeContext, _.treeContext = Mt(D, 1, 0);
              try {
                Lt(E, _, U);
              } finally {
                _.treeContext = D;
              }
            } else
              Lt(E, _, U);
            return;
          case fe:
            D = D.type, U = cn(D, U), kn(E, _, D, U, pe);
            return;
          case Pe:
            if (pe = U.children, D = D._context, U = U.value, O = D._currentValue2, D._currentValue2 = U, I = Te, Te = U = { parent: I, depth: I === null ? 0 : I.depth + 1, context: D, parentValue: O, value: U }, _.context = U, Lt(E, _, pe), E = Te, E === null)
              throw Error(t(403));
            U = E.parentValue, E.context._currentValue2 = U === Fe ? E.context._defaultValue : U, E = Te = E.parent, _.context = E;
            return;
          case Ve:
            U = U.children, U = U(D._currentValue2), Lt(E, _, U);
            return;
          case ze:
            pe = D._init, D = pe(D._payload), U = cn(D, U), kn(
              E,
              _,
              D,
              U,
              void 0
            );
            return;
        }
      throw Error(t(130, D == null ? D : typeof D, ""));
    }
  }
  function Lt(E, _, D) {
    if (_.node = D, typeof D == "object" && D !== null) {
      switch (D.$$typeof) {
        case $:
          kn(E, _, D.type, D.props, D.ref);
          return;
        case ce:
          throw Error(t(257));
        case ze:
          var U = D._init;
          D = U(D._payload), Lt(E, _, D);
          return;
      }
      if (v(D)) {
        gn(E, _, D);
        return;
      }
      if (D === null || typeof D != "object" ? U = null : (U = qe && D[qe] || D["@@iterator"], U = typeof U == "function" ? U : null), U && (U = U.call(D))) {
        if (D = U.next(), !D.done) {
          var pe = [];
          do
            pe.push(D.value), D = U.next();
          while (!D.done);
          gn(E, _, pe);
        }
        return;
      }
      throw E = Object.prototype.toString.call(D), Error(t(31, E === "[object Object]" ? "object with keys {" + Object.keys(D).join(", ") + "}" : E));
    }
    typeof D == "string" ? (U = _.blockedSegment, U.lastPushedText = Y(_.blockedSegment.chunks, D, E.responseState, U.lastPushedText)) : typeof D == "number" && (U = _.blockedSegment, U.lastPushedText = Y(_.blockedSegment.chunks, "" + D, E.responseState, U.lastPushedText));
  }
  function gn(E, _, D) {
    for (var U = D.length, pe = 0; pe < U; pe++) {
      var O = _.treeContext;
      _.treeContext = Mt(O, U, pe);
      try {
        an(E, _, D[pe]);
      } finally {
        _.treeContext = O;
      }
    }
  }
  function an(E, _, D) {
    var U = _.blockedSegment.formatContext, pe = _.legacyContext, O = _.context;
    try {
      return Lt(E, _, D);
    } catch (xe) {
      if (Yt(), typeof xe == "object" && xe !== null && typeof xe.then == "function") {
        D = xe;
        var I = _.blockedSegment, J = xn(E, I.chunks.length, null, I.formatContext, I.lastPushedText, !0);
        I.children.push(J), I.lastPushedText = !1, E = Dn(E, _.node, _.blockedBoundary, J, _.abortSet, _.legacyContext, _.context, _.treeContext).ping, D.then(E, E), _.blockedSegment.formatContext = U, _.legacyContext = pe, _.context = O, it(O);
      } else
        throw _.blockedSegment.formatContext = U, _.legacyContext = pe, _.context = O, it(O), xe;
    }
  }
  function un(E) {
    var _ = E.blockedBoundary;
    E = E.blockedSegment, E.status = 3, Rn(this, _, E);
  }
  function tr(E, _, D) {
    var U = E.blockedBoundary;
    E.blockedSegment.status = 3, U === null ? (_.allPendingTasks--, _.status !== 2 && (_.status = 2, _.destination !== null && _.destination.push(null))) : (U.pendingTasks--, U.forceClientRender || (U.forceClientRender = !0, E = D === void 0 ? Error(t(432)) : D, U.errorDigest = _.onError(E), U.parentFlushed && _.clientRenderedBoundaries.push(U)), U.fallbackAbortableTasks.forEach(function(pe) {
      return tr(pe, _, D);
    }), U.fallbackAbortableTasks.clear(), _.allPendingTasks--, _.allPendingTasks === 0 && (U = _.onAllReady, U()));
  }
  function _n(E, _) {
    if (_.chunks.length === 0 && _.children.length === 1 && _.children[0].boundary === null) {
      var D = _.children[0];
      D.id = _.id, D.parentFlushed = !0, D.status === 1 && _n(E, D);
    } else
      E.completedSegments.push(_);
  }
  function Rn(E, _, D) {
    if (_ === null) {
      if (D.parentFlushed) {
        if (E.completedRootSegment !== null)
          throw Error(t(389));
        E.completedRootSegment = D;
      }
      E.pendingRootTasks--, E.pendingRootTasks === 0 && (E.onShellError = Tn, _ = E.onShellReady, _());
    } else
      _.pendingTasks--, _.forceClientRender || (_.pendingTasks === 0 ? (D.parentFlushed && D.status === 1 && _n(_, D), _.parentFlushed && E.completedBoundaries.push(_), _.fallbackAbortableTasks.forEach(un, E), _.fallbackAbortableTasks.clear()) : D.parentFlushed && D.status === 1 && (_n(_, D), _.completedSegments.length === 1 && _.parentFlushed && E.partialBoundaries.push(_)));
    E.allPendingTasks--, E.allPendingTasks === 0 && (E = E.onAllReady, E());
  }
  function pn(E) {
    if (E.status !== 2) {
      var _ = Te, D = wn.current;
      wn.current = yn;
      var U = vn;
      vn = E.responseState;
      try {
        var pe = E.pingedTasks, O;
        for (O = 0; O < pe.length; O++) {
          var I = pe[O], J = E, xe = I.blockedSegment;
          if (xe.status === 0) {
            it(I.context);
            try {
              Lt(J, I, I.node), J.responseState.generateStaticMarkup || xe.lastPushedText && xe.textEmbedded && xe.chunks.push("<!-- -->"), I.abortSet.delete(I), xe.status = 1, Rn(J, I.blockedBoundary, xe);
            } catch (Xt) {
              if (Yt(), typeof Xt == "object" && Xt !== null && typeof Xt.then == "function") {
                var Be = I.ping;
                Xt.then(Be, Be);
              } else {
                I.abortSet.delete(I), xe.status = 4;
                var Xe = I.blockedBoundary, dt = Xt, Vt = At(J, dt);
                if (Xe === null ? Ht(J, dt) : (Xe.pendingTasks--, Xe.forceClientRender || (Xe.forceClientRender = !0, Xe.errorDigest = Vt, Xe.parentFlushed && J.clientRenderedBoundaries.push(Xe))), J.allPendingTasks--, J.allPendingTasks === 0) {
                  var zt = J.onAllReady;
                  zt();
                }
              }
            } finally {
            }
          }
        }
        pe.splice(0, O), E.destination !== null && Hn(E, E.destination);
      } catch (Xt) {
        At(E, Xt), Ht(E, Xt);
      } finally {
        vn = U, wn.current = D, D === yn && it(_);
      }
    }
  }
  function zn(E, _, D) {
    switch (D.parentFlushed = !0, D.status) {
      case 0:
        var U = D.id = E.nextSegmentId++;
        return D.lastPushedText = !1, D.textEmbedded = !1, E = E.responseState, _.push('<template id="'), _.push(E.placeholderPrefix), E = U.toString(16), _.push(E), _.push('"></template>');
      case 1:
        D.status = 2;
        var pe = !0;
        U = D.chunks;
        var O = 0;
        D = D.children;
        for (var I = 0; I < D.length; I++) {
          for (pe = D[I]; O < pe.index; O++)
            _.push(U[O]);
          pe = Bn(E, _, pe);
        }
        for (; O < U.length - 1; O++)
          _.push(U[O]);
        return O < U.length && (pe = _.push(U[O])), pe;
      default:
        throw Error(t(390));
    }
  }
  function Bn(E, _, D) {
    var U = D.boundary;
    if (U === null)
      return zn(E, _, D);
    if (U.parentFlushed = !0, U.forceClientRender)
      return E.responseState.generateStaticMarkup || (U = U.errorDigest, _.push("<!--$!-->"), _.push("<template"), U && (_.push(' data-dgst="'), U = y(U), _.push(U), _.push('"')), _.push("></template>")), zn(E, _, D), E = E.responseState.generateStaticMarkup ? !0 : _.push("<!--/$-->"), E;
    if (0 < U.pendingTasks) {
      U.rootSegmentID = E.nextSegmentId++, 0 < U.completedSegments.length && E.partialBoundaries.push(U);
      var pe = E.responseState, O = pe.nextSuspenseID++;
      return pe = pe.boundaryPrefix + O.toString(16), U = U.id = pe, B(_, E.responseState, U), zn(E, _, D), _.push("<!--/$-->");
    }
    if (U.byteSize > E.progressiveChunkSize)
      return U.rootSegmentID = E.nextSegmentId++, E.completedBoundaries.push(U), B(_, E.responseState, U.id), zn(E, _, D), _.push("<!--/$-->");
    if (E.responseState.generateStaticMarkup || _.push("<!--$-->"), D = U.completedSegments, D.length !== 1)
      throw Error(t(391));
    return Bn(E, _, D[0]), E = E.responseState.generateStaticMarkup ? !0 : _.push("<!--/$-->"), E;
  }
  function nr(E, _, D) {
    return j(_, E.responseState, D.formatContext, D.id), Bn(E, _, D), se(_, D.formatContext);
  }
  function hr(E, _, D) {
    for (var U = D.completedSegments, pe = 0; pe < U.length; pe++)
      rr(E, _, D, U[pe]);
    if (U.length = 0, E = E.responseState, U = D.id, D = D.rootSegmentID, _.push(E.startInlineScript), E.sentCompleteBoundaryFunction ? _.push('$RC("') : (E.sentCompleteBoundaryFunction = !0, _.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), U === null)
      throw Error(t(395));
    return D = D.toString(16), _.push(U), _.push('","'), _.push(E.segmentPrefix), _.push(D), _.push('")<\/script>');
  }
  function rr(E, _, D, U) {
    if (U.status === 2)
      return !0;
    var pe = U.id;
    if (pe === -1) {
      if ((U.id = D.rootSegmentID) === -1)
        throw Error(t(392));
      return nr(E, _, U);
    }
    return nr(E, _, U), E = E.responseState, _.push(E.startInlineScript), E.sentCompleteSegmentFunction ? _.push('$RS("') : (E.sentCompleteSegmentFunction = !0, _.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), _.push(E.segmentPrefix), pe = pe.toString(16), _.push(pe), _.push('","'), _.push(E.placeholderPrefix), _.push(pe), _.push('")<\/script>');
  }
  function Hn(E, _) {
    try {
      var D = E.completedRootSegment;
      if (D !== null && E.pendingRootTasks === 0) {
        Bn(E, _, D), E.completedRootSegment = null;
        var U = E.responseState.bootstrapChunks;
        for (D = 0; D < U.length - 1; D++)
          _.push(U[D]);
        D < U.length && _.push(U[D]);
      }
      var pe = E.clientRenderedBoundaries, O;
      for (O = 0; O < pe.length; O++) {
        var I = pe[O];
        U = _;
        var J = E.responseState, xe = I.id, Be = I.errorDigest, Xe = I.errorMessage, dt = I.errorComponentStack;
        if (U.push(J.startInlineScript), J.sentClientRenderFunction ? U.push('$RX("') : (J.sentClientRenderFunction = !0, U.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), xe === null)
          throw Error(t(395));
        if (U.push(xe), U.push('"'), Be || Xe || dt) {
          U.push(",");
          var Vt = Q(Be || "");
          U.push(Vt);
        }
        if (Xe || dt) {
          U.push(",");
          var zt = Q(Xe || "");
          U.push(zt);
        }
        if (dt) {
          U.push(",");
          var Xt = Q(dt);
          U.push(Xt);
        }
        if (!U.push(")<\/script>")) {
          E.destination = null, O++, pe.splice(0, O);
          return;
        }
      }
      pe.splice(0, O);
      var qt = E.completedBoundaries;
      for (O = 0; O < qt.length; O++)
        if (!hr(E, _, qt[O])) {
          E.destination = null, O++, qt.splice(0, O);
          return;
        }
      qt.splice(0, O);
      var Zt = E.partialBoundaries;
      for (O = 0; O < Zt.length; O++) {
        var In = Zt[O];
        e: {
          pe = E, I = _;
          var Gn = In.completedSegments;
          for (J = 0; J < Gn.length; J++)
            if (!rr(pe, I, In, Gn[J])) {
              J++, Gn.splice(0, J);
              var Xn = !1;
              break e;
            }
          Gn.splice(0, J), Xn = !0;
        }
        if (!Xn) {
          E.destination = null, O++, Zt.splice(0, O);
          return;
        }
      }
      Zt.splice(0, O);
      var Vn = E.completedBoundaries;
      for (O = 0; O < Vn.length; O++)
        if (!hr(E, _, Vn[O])) {
          E.destination = null, O++, Vn.splice(0, O);
          return;
        }
      Vn.splice(0, O);
    } finally {
      E.allPendingTasks === 0 && E.pingedTasks.length === 0 && E.clientRenderedBoundaries.length === 0 && E.completedBoundaries.length === 0 && _.push(null);
    }
  }
  function ar(E, _) {
    try {
      var D = E.abortableTasks;
      D.forEach(function(U) {
        return tr(U, E, _);
      }), D.clear(), E.destination !== null && Hn(E, E.destination);
    } catch (U) {
      At(E, U), Ht(E, U);
    }
  }
  function Kn() {
  }
  function Yn(E, _, D, U) {
    var pe = !1, O = null, I = "", J = { push: function(Be) {
      return Be !== null && (I += Be), !0;
    }, destroy: function(Be) {
      pe = !0, O = Be;
    } }, xe = !1;
    if (E = er(E, Z(D, _ ? _.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, Kn, void 0, function() {
      xe = !0;
    }, void 0, void 0), pn(E), ar(E, U), E.status === 1)
      E.status = 2, J.destroy(E.fatalError);
    else if (E.status !== 2 && E.destination === null) {
      E.destination = J;
      try {
        Hn(E, J);
      } catch (Be) {
        At(E, Be), Ht(E, Be);
      }
    }
    if (pe)
      throw O;
    if (!xe)
      throw Error(t(426));
    return I;
  }
  return Pi.renderToNodeStream = function() {
    throw Error(t(207));
  }, Pi.renderToStaticMarkup = function(E, _) {
    return Yn(E, _, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Pi.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, Pi.renderToString = function(E, _) {
    return Yn(E, _, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Pi.version = "18.2.0", Pi;
}
var Fc = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var em;
function vS() {
  if (em)
    return Fc;
  em = 1;
  var e = ue;
  function t(S) {
    for (var F = "https://reactjs.org/docs/error-decoder.html?invariant=" + S, V = 1; V < arguments.length; V++)
      F += "&args[]=" + encodeURIComponent(arguments[V]);
    return "Minified React error #" + S + "; visit " + F + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = null, r = 0;
  function a(S, F) {
    if (F.length !== 0)
      if (512 < F.length)
        0 < r && (S.enqueue(new Uint8Array(n.buffer, 0, r)), n = new Uint8Array(512), r = 0), S.enqueue(F);
      else {
        var V = n.length - r;
        V < F.length && (V === 0 ? S.enqueue(n) : (n.set(F.subarray(0, V), r), S.enqueue(n), F = F.subarray(V)), n = new Uint8Array(512), r = 0), n.set(F, r), r += F.length;
      }
  }
  function i(S, F) {
    return a(S, F), !0;
  }
  function u(S) {
    n && 0 < r && (S.enqueue(new Uint8Array(n.buffer, 0, r)), n = null, r = 0);
  }
  var c = new TextEncoder();
  function l(S) {
    return c.encode(S);
  }
  function p(S) {
    return c.encode(S);
  }
  function h(S, F) {
    typeof S.error == "function" ? S.error(F) : S.close();
  }
  var g = Object.prototype.hasOwnProperty, x = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, w = {}, y = {};
  function R(S) {
    return g.call(y, S) ? !0 : g.call(w, S) ? !1 : x.test(S) ? y[S] = !0 : (w[S] = !0, !1);
  }
  function b(S, F, V, ae, Re, ke, Oe) {
    this.acceptsBooleans = F === 2 || F === 3 || F === 4, this.attributeName = ae, this.attributeNamespace = Re, this.mustUseProperty = V, this.propertyName = S, this.type = F, this.sanitizeURL = ke, this.removeEmptyString = Oe;
  }
  var v = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(S) {
    v[S] = new b(S, 0, !1, S, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(S) {
    var F = S[0];
    v[F] = new b(F, 1, !1, S[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(S) {
    v[S] = new b(S, 2, !1, S.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(S) {
    v[S] = new b(S, 2, !1, S, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(S) {
    v[S] = new b(S, 3, !1, S.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(S) {
    v[S] = new b(S, 3, !0, S, null, !1, !1);
  }), ["capture", "download"].forEach(function(S) {
    v[S] = new b(S, 4, !1, S, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(S) {
    v[S] = new b(S, 6, !1, S, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(S) {
    v[S] = new b(S, 5, !1, S.toLowerCase(), null, !1, !1);
  });
  var A = /[\-:]([a-z])/g;
  function N(S) {
    return S[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(S) {
    var F = S.replace(
      A,
      N
    );
    v[F] = new b(F, 1, !1, S, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(S) {
    var F = S.replace(A, N);
    v[F] = new b(F, 1, !1, S, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(S) {
    var F = S.replace(A, N);
    v[F] = new b(F, 1, !1, S, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(S) {
    v[S] = new b(S, 1, !1, S.toLowerCase(), null, !1, !1);
  }), v.xlinkHref = new b("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(S) {
    v[S] = new b(S, 1, !1, S.toLowerCase(), null, !0, !0);
  });
  var L = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, C = ["Webkit", "ms", "Moz", "O"];
  Object.keys(L).forEach(function(S) {
    C.forEach(function(F) {
      F = F + S.charAt(0).toUpperCase() + S.substring(1), L[F] = L[S];
    });
  });
  var z = /["'&<>]/;
  function W(S) {
    if (typeof S == "boolean" || typeof S == "number")
      return "" + S;
    S = "" + S;
    var F = z.exec(S);
    if (F) {
      var V = "", ae, Re = 0;
      for (ae = F.index; ae < S.length; ae++) {
        switch (S.charCodeAt(ae)) {
          case 34:
            F = "&quot;";
            break;
          case 38:
            F = "&amp;";
            break;
          case 39:
            F = "&#x27;";
            break;
          case 60:
            F = "&lt;";
            break;
          case 62:
            F = "&gt;";
            break;
          default:
            continue;
        }
        Re !== ae && (V += S.substring(Re, ae)), Re = ae + 1, V += F;
      }
      S = Re !== ae ? V + S.substring(Re, ae) : V;
    }
    return S;
  }
  var q = /([A-Z])/g, ne = /^ms-/, G = Array.isArray, le = p("<script>"), K = p("<\/script>"), re = p('<script src="'), B = p('<script type="module" src="'), j = p('" async=""><\/script>'), se = /(<\/|<)(s)(cript)/gi;
  function ee(S, F, V, ae) {
    return "" + F + (V === "s" ? "\\u0073" : "\\u0053") + ae;
  }
  function Q(S, F, V, ae, Re) {
    S = S === void 0 ? "" : S, F = F === void 0 ? le : p('<script nonce="' + W(F) + '">');
    var ke = [];
    if (V !== void 0 && ke.push(F, l(("" + V).replace(se, ee)), K), ae !== void 0)
      for (V = 0; V < ae.length; V++)
        ke.push(re, l(W(ae[V])), j);
    if (Re !== void 0)
      for (ae = 0; ae < Re.length; ae++)
        ke.push(B, l(W(Re[ae])), j);
    return { bootstrapChunks: ke, startInlineScript: F, placeholderPrefix: p(S + "P:"), segmentPrefix: p(S + "S:"), boundaryPrefix: S + "B:", idPrefix: S, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function Z(S, F) {
    return { insertionMode: S, selectedValue: F };
  }
  function Y(S) {
    return Z(S === "http://www.w3.org/2000/svg" ? 2 : S === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function te(S, F, V) {
    switch (F) {
      case "select":
        return Z(1, V.value != null ? V.value : V.defaultValue);
      case "svg":
        return Z(2, null);
      case "math":
        return Z(3, null);
      case "foreignObject":
        return Z(1, null);
      case "table":
        return Z(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return Z(5, null);
      case "colgroup":
        return Z(7, null);
      case "tr":
        return Z(6, null);
    }
    return 4 <= S.insertionMode || S.insertionMode === 0 ? Z(1, null) : S;
  }
  var $ = p("<!-- -->");
  function ce(S, F, V, ae) {
    return F === "" ? ae : (ae && S.push($), S.push(l(W(F))), !0);
  }
  var Se = /* @__PURE__ */ new Map(), be = p(' style="'), ve = p(":"), Pe = p(";");
  function Ve(S, F, V) {
    if (typeof V != "object")
      throw Error(t(62));
    F = !0;
    for (var ae in V)
      if (g.call(V, ae)) {
        var Re = V[ae];
        if (Re != null && typeof Re != "boolean" && Re !== "") {
          if (ae.indexOf("--") === 0) {
            var ke = l(W(ae));
            Re = l(W(("" + Re).trim()));
          } else {
            ke = ae;
            var Oe = Se.get(ke);
            Oe !== void 0 || (Oe = p(W(ke.replace(q, "-$1").toLowerCase().replace(ne, "-ms-"))), Se.set(ke, Oe)), ke = Oe, Re = typeof Re == "number" ? Re === 0 || g.call(L, ae) ? l("" + Re) : l(Re + "px") : l(W(("" + Re).trim()));
          }
          F ? (F = !1, S.push(be, ke, ve, Re)) : S.push(Pe, ke, ve, Re);
        }
      }
    F || S.push(Ce);
  }
  var we = p(" "), me = p('="'), Ce = p('"'), fe = p('=""');
  function ze(S, F, V, ae) {
    switch (V) {
      case "style":
        Ve(S, F, ae);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < V.length) || V[0] !== "o" && V[0] !== "O" || V[1] !== "n" && V[1] !== "N") {
      if (F = v.hasOwnProperty(V) ? v[V] : null, F !== null) {
        switch (typeof ae) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!F.acceptsBooleans)
              return;
        }
        switch (V = l(F.attributeName), F.type) {
          case 3:
            ae && S.push(we, V, fe);
            break;
          case 4:
            ae === !0 ? S.push(we, V, fe) : ae !== !1 && S.push(we, V, me, l(W(ae)), Ce);
            break;
          case 5:
            isNaN(ae) || S.push(we, V, me, l(W(ae)), Ce);
            break;
          case 6:
            !isNaN(ae) && 1 <= ae && S.push(we, V, me, l(W(ae)), Ce);
            break;
          default:
            F.sanitizeURL && (ae = "" + ae), S.push(we, V, me, l(W(ae)), Ce);
        }
      } else if (R(V)) {
        switch (typeof ae) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (F = V.toLowerCase().slice(0, 5), F !== "data-" && F !== "aria-")
              return;
        }
        S.push(we, l(V), me, l(W(ae)), Ce);
      }
    }
  }
  var Ie = p(">"), Qe = p("/>");
  function He(S, F, V) {
    if (F != null) {
      if (V != null)
        throw Error(t(60));
      if (typeof F != "object" || !("__html" in F))
        throw Error(t(61));
      F = F.__html, F != null && S.push(l("" + F));
    }
  }
  function Fe(S) {
    var F = "";
    return e.Children.forEach(S, function(V) {
      V != null && (F += V);
    }), F;
  }
  var qe = p(' selected=""');
  function We(S, F, V, ae) {
    S.push(_e(V));
    var Re = V = null, ke;
    for (ke in F)
      if (g.call(F, ke)) {
        var Oe = F[ke];
        if (Oe != null)
          switch (ke) {
            case "children":
              V = Oe;
              break;
            case "dangerouslySetInnerHTML":
              Re = Oe;
              break;
            default:
              ze(S, ae, ke, Oe);
          }
      }
    return S.push(Ie), He(S, Re, V), typeof V == "string" ? (S.push(l(W(V))), null) : V;
  }
  var je = p(`
`), Ke = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Te = /* @__PURE__ */ new Map();
  function _e(S) {
    var F = Te.get(S);
    if (F === void 0) {
      if (!Ke.test(S))
        throw Error(t(65, S));
      F = p("<" + S), Te.set(S, F);
    }
    return F;
  }
  var at = p("<!DOCTYPE html>");
  function ge(S, F, V, ae, Re) {
    switch (F) {
      case "select":
        S.push(_e("select"));
        var ke = null, Oe = null;
        for (kt in V)
          if (g.call(V, kt)) {
            var Ye = V[kt];
            if (Ye != null)
              switch (kt) {
                case "children":
                  ke = Ye;
                  break;
                case "dangerouslySetInnerHTML":
                  Oe = Ye;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  ze(S, ae, kt, Ye);
              }
          }
        return S.push(Ie), He(S, Oe, ke), ke;
      case "option":
        Oe = Re.selectedValue, S.push(_e("option"));
        var vt = Ye = null, Tt = null, kt = null;
        for (ke in V)
          if (g.call(V, ke)) {
            var Jt = V[ke];
            if (Jt != null)
              switch (ke) {
                case "children":
                  Ye = Jt;
                  break;
                case "selected":
                  Tt = Jt;
                  break;
                case "dangerouslySetInnerHTML":
                  kt = Jt;
                  break;
                case "value":
                  vt = Jt;
                default:
                  ze(S, ae, ke, Jt);
              }
          }
        if (Oe != null)
          if (V = vt !== null ? "" + vt : Fe(Ye), G(Oe)) {
            for (ae = 0; ae < Oe.length; ae++)
              if ("" + Oe[ae] === V) {
                S.push(qe);
                break;
              }
          } else
            "" + Oe === V && S.push(qe);
        else
          Tt && S.push(qe);
        return S.push(Ie), He(S, kt, Ye), Ye;
      case "textarea":
        S.push(_e("textarea")), kt = Oe = ke = null;
        for (Ye in V)
          if (g.call(V, Ye) && (vt = V[Ye], vt != null))
            switch (Ye) {
              case "children":
                kt = vt;
                break;
              case "value":
                ke = vt;
                break;
              case "defaultValue":
                Oe = vt;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                ze(S, ae, Ye, vt);
            }
        if (ke === null && Oe !== null && (ke = Oe), S.push(Ie), kt != null) {
          if (ke != null)
            throw Error(t(92));
          if (G(kt) && 1 < kt.length)
            throw Error(t(93));
          ke = "" + kt;
        }
        return typeof ke == "string" && ke[0] === `
` && S.push(je), ke !== null && S.push(l(W("" + ke))), null;
      case "input":
        S.push(_e("input")), vt = kt = Ye = ke = null;
        for (Oe in V)
          if (g.call(V, Oe) && (Tt = V[Oe], Tt != null))
            switch (Oe) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                vt = Tt;
                break;
              case "defaultValue":
                Ye = Tt;
                break;
              case "checked":
                kt = Tt;
                break;
              case "value":
                ke = Tt;
                break;
              default:
                ze(S, ae, Oe, Tt);
            }
        return kt !== null ? ze(
          S,
          ae,
          "checked",
          kt
        ) : vt !== null && ze(S, ae, "checked", vt), ke !== null ? ze(S, ae, "value", ke) : Ye !== null && ze(S, ae, "value", Ye), S.push(Qe), null;
      case "menuitem":
        S.push(_e("menuitem"));
        for (var Un in V)
          if (g.call(V, Un) && (ke = V[Un], ke != null))
            switch (Un) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                ze(S, ae, Un, ke);
            }
        return S.push(Ie), null;
      case "title":
        S.push(_e("title")), ke = null;
        for (Jt in V)
          if (g.call(V, Jt) && (Oe = V[Jt], Oe != null))
            switch (Jt) {
              case "children":
                ke = Oe;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                ze(S, ae, Jt, Oe);
            }
        return S.push(Ie), ke;
      case "listing":
      case "pre":
        S.push(_e(F)), Oe = ke = null;
        for (vt in V)
          if (g.call(V, vt) && (Ye = V[vt], Ye != null))
            switch (vt) {
              case "children":
                ke = Ye;
                break;
              case "dangerouslySetInnerHTML":
                Oe = Ye;
                break;
              default:
                ze(S, ae, vt, Ye);
            }
        if (S.push(Ie), Oe != null) {
          if (ke != null)
            throw Error(t(60));
          if (typeof Oe != "object" || !("__html" in Oe))
            throw Error(t(61));
          V = Oe.__html, V != null && (typeof V == "string" && 0 < V.length && V[0] === `
` ? S.push(je, l(V)) : S.push(l("" + V)));
        }
        return typeof ke == "string" && ke[0] === `
` && S.push(je), ke;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        S.push(_e(F));
        for (var lr in V)
          if (g.call(V, lr) && (ke = V[lr], ke != null))
            switch (lr) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, F));
              default:
                ze(S, ae, lr, ke);
            }
        return S.push(Qe), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return We(S, V, F, ae);
      case "html":
        return Re.insertionMode === 0 && S.push(at), We(S, V, F, ae);
      default:
        if (F.indexOf("-") === -1 && typeof V.is != "string")
          return We(S, V, F, ae);
        S.push(_e(F)), Oe = ke = null;
        for (Tt in V)
          if (g.call(V, Tt) && (Ye = V[Tt], Ye != null))
            switch (Tt) {
              case "children":
                ke = Ye;
                break;
              case "dangerouslySetInnerHTML":
                Oe = Ye;
                break;
              case "style":
                Ve(S, ae, Ye);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                R(Tt) && typeof Ye != "function" && typeof Ye != "symbol" && S.push(we, l(Tt), me, l(W(Ye)), Ce);
            }
        return S.push(Ie), He(S, Oe, ke), ke;
    }
  }
  var ft = p("</"), ot = p(">"), it = p('<template id="'), wt = p('"></template>'), Wt = p("<!--$-->"), Kt = p('<!--$?--><template id="'), Mt = p('"></template>'), rn = p("<!--$!-->"), Et = p("<!--/$-->"), Pt = p("<template"), Nt = p('"'), tn = p(' data-dgst="');
  p(' data-msg="'), p(' data-stck="');
  var sn = p("></template>");
  function Ot(S, F, V) {
    if (a(S, Kt), V === null)
      throw Error(t(395));
    return a(S, V), i(S, Mt);
  }
  var Ft = p('<div hidden id="'), nn = p('">'), et = p("</div>"), ut = p('<svg aria-hidden="true" style="display:none" id="'), Ne = p('">'), De = p("</svg>"), Ee = p('<math aria-hidden="true" style="display:none" id="'), pt = p('">'), nt = p("</math>"), gt = p('<table hidden id="'), xt = p('">'), Yt = p("</table>"), lt = p('<table hidden><tbody id="'), st = p('">'), $t = p("</tbody></table>"), jt = p('<table hidden><tr id="'), Rt = p('">'), St = p("</tr></table>"), yn = p('<table hidden><colgroup id="'), vn = p('">'), wn = p("</colgroup></table>");
  function Pn(S, F, V, ae) {
    switch (V.insertionMode) {
      case 0:
      case 1:
        return a(S, Ft), a(S, F.segmentPrefix), a(S, l(ae.toString(16))), i(S, nn);
      case 2:
        return a(S, ut), a(S, F.segmentPrefix), a(S, l(ae.toString(16))), i(S, Ne);
      case 3:
        return a(S, Ee), a(S, F.segmentPrefix), a(S, l(ae.toString(16))), i(S, pt);
      case 4:
        return a(S, gt), a(S, F.segmentPrefix), a(S, l(ae.toString(16))), i(S, xt);
      case 5:
        return a(S, lt), a(S, F.segmentPrefix), a(S, l(ae.toString(16))), i(S, st);
      case 6:
        return a(S, jt), a(S, F.segmentPrefix), a(S, l(ae.toString(16))), i(S, Rt);
      case 7:
        return a(
          S,
          yn
        ), a(S, F.segmentPrefix), a(S, l(ae.toString(16))), i(S, vn);
      default:
        throw Error(t(397));
    }
  }
  function Tn(S, F) {
    switch (F.insertionMode) {
      case 0:
      case 1:
        return i(S, et);
      case 2:
        return i(S, De);
      case 3:
        return i(S, nt);
      case 4:
        return i(S, Yt);
      case 5:
        return i(S, $t);
      case 6:
        return i(S, St);
      case 7:
        return i(S, wn);
      default:
        throw Error(t(397));
    }
  }
  var er = p('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Dn = p('$RS("'), xn = p('","'), At = p('")<\/script>'), Ht = p('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), bn = p('$RC("'), Qt = p('","'), cn = p('")<\/script>'), kn = p('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Lt = p('$RX("'), gn = p('"'), an = p(")<\/script>"), un = p(","), tr = /[<\u2028\u2029]/g;
  function _n(S) {
    return JSON.stringify(S).replace(tr, function(F) {
      switch (F) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var Rn = Object.assign, pn = Symbol.for("react.element"), zn = Symbol.for("react.portal"), Bn = Symbol.for("react.fragment"), nr = Symbol.for("react.strict_mode"), hr = Symbol.for("react.profiler"), rr = Symbol.for("react.provider"), Hn = Symbol.for("react.context"), ar = Symbol.for("react.forward_ref"), Kn = Symbol.for("react.suspense"), Yn = Symbol.for("react.suspense_list"), E = Symbol.for("react.memo"), _ = Symbol.for("react.lazy"), D = Symbol.for("react.scope"), U = Symbol.for("react.debug_trace_mode"), pe = Symbol.for("react.legacy_hidden"), O = Symbol.for("react.default_value"), I = Symbol.iterator;
  function J(S) {
    if (S == null)
      return null;
    if (typeof S == "function")
      return S.displayName || S.name || null;
    if (typeof S == "string")
      return S;
    switch (S) {
      case Bn:
        return "Fragment";
      case zn:
        return "Portal";
      case hr:
        return "Profiler";
      case nr:
        return "StrictMode";
      case Kn:
        return "Suspense";
      case Yn:
        return "SuspenseList";
    }
    if (typeof S == "object")
      switch (S.$$typeof) {
        case Hn:
          return (S.displayName || "Context") + ".Consumer";
        case rr:
          return (S._context.displayName || "Context") + ".Provider";
        case ar:
          var F = S.render;
          return S = S.displayName, S || (S = F.displayName || F.name || "", S = S !== "" ? "ForwardRef(" + S + ")" : "ForwardRef"), S;
        case E:
          return F = S.displayName || null, F !== null ? F : J(S.type) || "Memo";
        case _:
          F = S._payload, S = S._init;
          try {
            return J(S(F));
          } catch {
          }
      }
    return null;
  }
  var xe = {};
  function Be(S, F) {
    if (S = S.contextTypes, !S)
      return xe;
    var V = {}, ae;
    for (ae in S)
      V[ae] = F[ae];
    return V;
  }
  var Xe = null;
  function dt(S, F) {
    if (S !== F) {
      S.context._currentValue = S.parentValue, S = S.parent;
      var V = F.parent;
      if (S === null) {
        if (V !== null)
          throw Error(t(401));
      } else {
        if (V === null)
          throw Error(t(401));
        dt(S, V);
      }
      F.context._currentValue = F.value;
    }
  }
  function Vt(S) {
    S.context._currentValue = S.parentValue, S = S.parent, S !== null && Vt(S);
  }
  function zt(S) {
    var F = S.parent;
    F !== null && zt(F), S.context._currentValue = S.value;
  }
  function Xt(S, F) {
    if (S.context._currentValue = S.parentValue, S = S.parent, S === null)
      throw Error(t(402));
    S.depth === F.depth ? dt(S, F) : Xt(S, F);
  }
  function qt(S, F) {
    var V = F.parent;
    if (V === null)
      throw Error(t(402));
    S.depth === V.depth ? dt(S, V) : qt(S, V), F.context._currentValue = F.value;
  }
  function Zt(S) {
    var F = Xe;
    F !== S && (F === null ? zt(S) : S === null ? Vt(F) : F.depth === S.depth ? dt(F, S) : F.depth > S.depth ? Xt(F, S) : qt(F, S), Xe = S);
  }
  var In = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(S, F) {
    S = S._reactInternals, S.queue !== null && S.queue.push(F);
  }, enqueueReplaceState: function(S, F) {
    S = S._reactInternals, S.replace = !0, S.queue = [F];
  }, enqueueForceUpdate: function() {
  } };
  function Gn(S, F, V, ae) {
    var Re = S.state !== void 0 ? S.state : null;
    S.updater = In, S.props = V, S.state = Re;
    var ke = { queue: [], replace: !1 };
    S._reactInternals = ke;
    var Oe = F.contextType;
    if (S.context = typeof Oe == "object" && Oe !== null ? Oe._currentValue : ae, Oe = F.getDerivedStateFromProps, typeof Oe == "function" && (Oe = Oe(V, Re), Re = Oe == null ? Re : Rn({}, Re, Oe), S.state = Re), typeof F.getDerivedStateFromProps != "function" && typeof S.getSnapshotBeforeUpdate != "function" && (typeof S.UNSAFE_componentWillMount == "function" || typeof S.componentWillMount == "function"))
      if (F = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), F !== S.state && In.enqueueReplaceState(S, S.state, null), ke.queue !== null && 0 < ke.queue.length)
        if (F = ke.queue, Oe = ke.replace, ke.queue = null, ke.replace = !1, Oe && F.length === 1)
          S.state = F[0];
        else {
          for (ke = Oe ? F[0] : S.state, Re = !0, Oe = Oe ? 1 : 0; Oe < F.length; Oe++) {
            var Ye = F[Oe];
            Ye = typeof Ye == "function" ? Ye.call(S, ke, V, ae) : Ye, Ye != null && (Re ? (Re = !1, ke = Rn({}, ke, Ye)) : Rn(ke, Ye));
          }
          S.state = ke;
        }
      else
        ke.queue = null;
  }
  var Xn = { id: 1, overflow: "" };
  function Vn(S, F, V) {
    var ae = S.id;
    S = S.overflow;
    var Re = 32 - Er(ae) - 1;
    ae &= ~(1 << Re), V += 1;
    var ke = 32 - Er(F) + Re;
    if (30 < ke) {
      var Oe = Re - Re % 5;
      return ke = (ae & (1 << Oe) - 1).toString(32), ae >>= Oe, Re -= Oe, { id: 1 << 32 - Er(F) + Re | V << Re | ae, overflow: ke + S };
    }
    return { id: 1 << ke | V << Re | ae, overflow: S };
  }
  var Er = Math.clz32 ? Math.clz32 : dn, xa = Math.log, Ct = Math.LN2;
  function dn(S) {
    return S >>>= 0, S === 0 ? 32 : 31 - (xa(S) / Ct | 0) | 0;
  }
  function ra(S, F) {
    return S === F && (S !== 0 || 1 / S === 1 / F) || S !== S && F !== F;
  }
  var Pr = typeof Object.is == "function" ? Object.is : ra, ir = null, Dr = null, Wr = null, Bt = null, mr = !1, Wn = !1, _r = 0, kr = null, ba = 0;
  function wr() {
    if (ir === null)
      throw Error(t(321));
    return ir;
  }
  function or() {
    if (0 < ba)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function qa() {
    return Bt === null ? Wr === null ? (mr = !1, Wr = Bt = or()) : (mr = !0, Bt = Wr) : Bt.next === null ? (mr = !1, Bt = Bt.next = or()) : (mr = !0, Bt = Bt.next), Bt;
  }
  function Za() {
    Dr = ir = null, Wn = !1, Wr = null, ba = 0, Bt = kr = null;
  }
  function Yi(S, F) {
    return typeof F == "function" ? F(S) : F;
  }
  function Gi(S, F, V) {
    if (ir = wr(), Bt = qa(), mr) {
      var ae = Bt.queue;
      if (F = ae.dispatch, kr !== null && (V = kr.get(ae), V !== void 0)) {
        kr.delete(ae), ae = Bt.memoizedState;
        do
          ae = S(ae, V.action), V = V.next;
        while (V !== null);
        return Bt.memoizedState = ae, [ae, F];
      }
      return [Bt.memoizedState, F];
    }
    return S = S === Yi ? typeof F == "function" ? F() : F : V !== void 0 ? V(F) : F, Bt.memoizedState = S, S = Bt.queue = { last: null, dispatch: null }, S = S.dispatch = fl.bind(null, ir, S), [Bt.memoizedState, S];
  }
  function Xi(S, F) {
    if (ir = wr(), Bt = qa(), F = F === void 0 ? null : F, Bt !== null) {
      var V = Bt.memoizedState;
      if (V !== null && F !== null) {
        var ae = V[1];
        e:
          if (ae === null)
            ae = !1;
          else {
            for (var Re = 0; Re < ae.length && Re < F.length; Re++)
              if (!Pr(F[Re], ae[Re])) {
                ae = !1;
                break e;
              }
            ae = !0;
          }
        if (ae)
          return V[0];
      }
    }
    return S = S(), Bt.memoizedState = [S, F], S;
  }
  function fl(S, F, V) {
    if (25 <= ba)
      throw Error(t(301));
    if (S === ir)
      if (Wn = !0, S = { action: V, next: null }, kr === null && (kr = /* @__PURE__ */ new Map()), V = kr.get(F), V === void 0)
        kr.set(F, S);
      else {
        for (F = V; F.next !== null; )
          F = F.next;
        F.next = S;
      }
  }
  function pl() {
    throw Error(t(394));
  }
  function Ea() {
  }
  var Sa = { readContext: function(S) {
    return S._currentValue;
  }, useContext: function(S) {
    return wr(), S._currentValue;
  }, useMemo: Xi, useReducer: Gi, useRef: function(S) {
    ir = wr(), Bt = qa();
    var F = Bt.memoizedState;
    return F === null ? (S = { current: S }, Bt.memoizedState = S) : F;
  }, useState: function(S) {
    return Gi(Yi, S);
  }, useInsertionEffect: Ea, useLayoutEffect: function() {
  }, useCallback: function(S, F) {
    return Xi(function() {
      return S;
    }, F);
  }, useImperativeHandle: Ea, useEffect: Ea, useDebugValue: Ea, useDeferredValue: function(S) {
    return wr(), S;
  }, useTransition: function() {
    return wr(), [!1, pl];
  }, useId: function() {
    var S = Dr.treeContext, F = S.overflow;
    S = S.id, S = (S & ~(1 << 32 - Er(S) - 1)).toString(32) + F;
    var V = ka;
    if (V === null)
      throw Error(t(404));
    return F = _r++, S = ":" + V.idPrefix + "R" + S, 0 < F && (S += "H" + F.toString(32)), S + ":";
  }, useMutableSource: function(S, F) {
    return wr(), F(S._source);
  }, useSyncExternalStore: function(S, F, V) {
    if (V === void 0)
      throw Error(t(407));
    return V();
  } }, ka = null, aa = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function hl(S) {
    return console.error(S), null;
  }
  function ia() {
  }
  function Qa(S, F, V, ae, Re, ke, Oe, Ye, vt) {
    var Tt = [], kt = /* @__PURE__ */ new Set();
    return F = { destination: null, responseState: F, progressiveChunkSize: ae === void 0 ? 12800 : ae, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: kt, pingedTasks: Tt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Re === void 0 ? hl : Re, onAllReady: ke === void 0 ? ia : ke, onShellReady: Oe === void 0 ? ia : Oe, onShellError: Ye === void 0 ? ia : Ye, onFatalError: vt === void 0 ? ia : vt }, V = jr(F, 0, null, V, !1, !1), V.parentFlushed = !0, S = Ja(F, S, null, V, kt, xe, null, Xn), Tt.push(S), F;
  }
  function Ja(S, F, V, ae, Re, ke, Oe, Ye) {
    S.allPendingTasks++, V === null ? S.pendingRootTasks++ : V.pendingTasks++;
    var vt = { node: F, ping: function() {
      var Tt = S.pingedTasks;
      Tt.push(vt), Tt.length === 1 && to(S);
    }, blockedBoundary: V, blockedSegment: ae, abortSet: Re, legacyContext: ke, context: Oe, treeContext: Ye };
    return Re.add(vt), vt;
  }
  function jr(S, F, V, ae, Re, ke) {
    return { status: 0, id: -1, index: F, parentFlushed: !1, chunks: [], children: [], formatContext: ae, boundary: V, lastPushedText: Re, textEmbedded: ke };
  }
  function Ur(S, F) {
    if (S = S.onError(F), S != null && typeof S != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof S + '" instead');
    return S;
  }
  function wa(S, F) {
    var V = S.onShellError;
    V(F), V = S.onFatalError, V(F), S.destination !== null ? (S.status = 2, h(S.destination, F)) : (S.status = 1, S.fatalError = F);
  }
  function qi(S, F, V, ae, Re) {
    for (ir = {}, Dr = F, _r = 0, S = V(ae, Re); Wn; )
      Wn = !1, _r = 0, ba += 1, Bt = null, S = V(ae, Re);
    return Za(), S;
  }
  function ei(S, F, V, ae) {
    var Re = V.render(), ke = ae.childContextTypes;
    if (ke != null) {
      var Oe = F.legacyContext;
      if (typeof V.getChildContext != "function")
        ae = Oe;
      else {
        V = V.getChildContext();
        for (var Ye in V)
          if (!(Ye in ke))
            throw Error(t(108, J(ae) || "Unknown", Ye));
        ae = Rn({}, Oe, V);
      }
      F.legacyContext = ae, jn(S, F, Re), F.legacyContext = Oe;
    } else
      jn(S, F, Re);
  }
  function Zi(S, F) {
    if (S && S.defaultProps) {
      F = Rn({}, F), S = S.defaultProps;
      for (var V in S)
        F[V] === void 0 && (F[V] = S[V]);
      return F;
    }
    return F;
  }
  function Ta(S, F, V, ae, Re) {
    if (typeof V == "function")
      if (V.prototype && V.prototype.isReactComponent) {
        Re = Be(V, F.legacyContext);
        var ke = V.contextType;
        ke = new V(ae, typeof ke == "object" && ke !== null ? ke._currentValue : Re), Gn(ke, V, ae, Re), ei(S, F, ke, V);
      } else {
        ke = Be(V, F.legacyContext), Re = qi(S, F, V, ae, ke);
        var Oe = _r !== 0;
        if (typeof Re == "object" && Re !== null && typeof Re.render == "function" && Re.$$typeof === void 0)
          Gn(Re, V, ae, ke), ei(S, F, Re, V);
        else if (Oe) {
          ae = F.treeContext, F.treeContext = Vn(ae, 1, 0);
          try {
            jn(S, F, Re);
          } finally {
            F.treeContext = ae;
          }
        } else
          jn(S, F, Re);
      }
    else if (typeof V == "string") {
      switch (Re = F.blockedSegment, ke = ge(Re.chunks, V, ae, S.responseState, Re.formatContext), Re.lastPushedText = !1, Oe = Re.formatContext, Re.formatContext = te(Oe, V, ae), Ra(S, F, ke), Re.formatContext = Oe, V) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Re.chunks.push(ft, l(V), ot);
      }
      Re.lastPushedText = !1;
    } else {
      switch (V) {
        case pe:
        case U:
        case nr:
        case hr:
        case Bn:
          jn(S, F, ae.children);
          return;
        case Yn:
          jn(S, F, ae.children);
          return;
        case D:
          throw Error(t(343));
        case Kn:
          e: {
            V = F.blockedBoundary, Re = F.blockedSegment, ke = ae.fallback, ae = ae.children, Oe = /* @__PURE__ */ new Set();
            var Ye = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Oe, errorDigest: null }, vt = jr(S, Re.chunks.length, Ye, Re.formatContext, !1, !1);
            Re.children.push(vt), Re.lastPushedText = !1;
            var Tt = jr(S, 0, null, Re.formatContext, !1, !1);
            Tt.parentFlushed = !0, F.blockedBoundary = Ye, F.blockedSegment = Tt;
            try {
              if (Ra(
                S,
                F,
                ae
              ), Tt.lastPushedText && Tt.textEmbedded && Tt.chunks.push($), Tt.status = 1, Ca(Ye, Tt), Ye.pendingTasks === 0)
                break e;
            } catch (kt) {
              Tt.status = 4, Ye.forceClientRender = !0, Ye.errorDigest = Ur(S, kt);
            } finally {
              F.blockedBoundary = V, F.blockedSegment = Re;
            }
            F = Ja(S, ke, V, vt, Oe, F.legacyContext, F.context, F.treeContext), S.pingedTasks.push(F);
          }
          return;
      }
      if (typeof V == "object" && V !== null)
        switch (V.$$typeof) {
          case ar:
            if (ae = qi(S, F, V.render, ae, Re), _r !== 0) {
              V = F.treeContext, F.treeContext = Vn(V, 1, 0);
              try {
                jn(S, F, ae);
              } finally {
                F.treeContext = V;
              }
            } else
              jn(S, F, ae);
            return;
          case E:
            V = V.type, ae = Zi(V, ae), Ta(S, F, V, ae, Re);
            return;
          case rr:
            if (Re = ae.children, V = V._context, ae = ae.value, ke = V._currentValue, V._currentValue = ae, Oe = Xe, Xe = ae = { parent: Oe, depth: Oe === null ? 0 : Oe.depth + 1, context: V, parentValue: ke, value: ae }, F.context = ae, jn(S, F, Re), S = Xe, S === null)
              throw Error(t(403));
            ae = S.parentValue, S.context._currentValue = ae === O ? S.context._defaultValue : ae, S = Xe = S.parent, F.context = S;
            return;
          case Hn:
            ae = ae.children, ae = ae(V._currentValue), jn(S, F, ae);
            return;
          case _:
            Re = V._init, V = Re(V._payload), ae = Zi(V, ae), Ta(S, F, V, ae, void 0);
            return;
        }
      throw Error(t(
        130,
        V == null ? V : typeof V,
        ""
      ));
    }
  }
  function jn(S, F, V) {
    if (F.node = V, typeof V == "object" && V !== null) {
      switch (V.$$typeof) {
        case pn:
          Ta(S, F, V.type, V.props, V.ref);
          return;
        case zn:
          throw Error(t(257));
        case _:
          var ae = V._init;
          V = ae(V._payload), jn(S, F, V);
          return;
      }
      if (G(V)) {
        Qi(S, F, V);
        return;
      }
      if (V === null || typeof V != "object" ? ae = null : (ae = I && V[I] || V["@@iterator"], ae = typeof ae == "function" ? ae : null), ae && (ae = ae.call(V))) {
        if (V = ae.next(), !V.done) {
          var Re = [];
          do
            Re.push(V.value), V = ae.next();
          while (!V.done);
          Qi(S, F, Re);
        }
        return;
      }
      throw S = Object.prototype.toString.call(V), Error(t(31, S === "[object Object]" ? "object with keys {" + Object.keys(V).join(", ") + "}" : S));
    }
    typeof V == "string" ? (ae = F.blockedSegment, ae.lastPushedText = ce(F.blockedSegment.chunks, V, S.responseState, ae.lastPushedText)) : typeof V == "number" && (ae = F.blockedSegment, ae.lastPushedText = ce(F.blockedSegment.chunks, "" + V, S.responseState, ae.lastPushedText));
  }
  function Qi(S, F, V) {
    for (var ae = V.length, Re = 0; Re < ae; Re++) {
      var ke = F.treeContext;
      F.treeContext = Vn(ke, ae, Re);
      try {
        Ra(S, F, V[Re]);
      } finally {
        F.treeContext = ke;
      }
    }
  }
  function Ra(S, F, V) {
    var ae = F.blockedSegment.formatContext, Re = F.legacyContext, ke = F.context;
    try {
      return jn(S, F, V);
    } catch (vt) {
      if (Za(), typeof vt == "object" && vt !== null && typeof vt.then == "function") {
        V = vt;
        var Oe = F.blockedSegment, Ye = jr(S, Oe.chunks.length, null, Oe.formatContext, Oe.lastPushedText, !0);
        Oe.children.push(Ye), Oe.lastPushedText = !1, S = Ja(S, F.node, F.blockedBoundary, Ye, F.abortSet, F.legacyContext, F.context, F.treeContext).ping, V.then(S, S), F.blockedSegment.formatContext = ae, F.legacyContext = Re, F.context = ke, Zt(ke);
      } else
        throw F.blockedSegment.formatContext = ae, F.legacyContext = Re, F.context = ke, Zt(ke), vt;
    }
  }
  function ml(S) {
    var F = S.blockedBoundary;
    S = S.blockedSegment, S.status = 3, eo(this, F, S);
  }
  function Ji(S, F, V) {
    var ae = S.blockedBoundary;
    S.blockedSegment.status = 3, ae === null ? (F.allPendingTasks--, F.status !== 2 && (F.status = 2, F.destination !== null && F.destination.close())) : (ae.pendingTasks--, ae.forceClientRender || (ae.forceClientRender = !0, S = V === void 0 ? Error(t(432)) : V, ae.errorDigest = F.onError(S), ae.parentFlushed && F.clientRenderedBoundaries.push(ae)), ae.fallbackAbortableTasks.forEach(function(Re) {
      return Ji(Re, F, V);
    }), ae.fallbackAbortableTasks.clear(), F.allPendingTasks--, F.allPendingTasks === 0 && (ae = F.onAllReady, ae()));
  }
  function Ca(S, F) {
    if (F.chunks.length === 0 && F.children.length === 1 && F.children[0].boundary === null) {
      var V = F.children[0];
      V.id = F.id, V.parentFlushed = !0, V.status === 1 && Ca(S, V);
    } else
      S.completedSegments.push(F);
  }
  function eo(S, F, V) {
    if (F === null) {
      if (V.parentFlushed) {
        if (S.completedRootSegment !== null)
          throw Error(t(389));
        S.completedRootSegment = V;
      }
      S.pendingRootTasks--, S.pendingRootTasks === 0 && (S.onShellError = ia, F = S.onShellReady, F());
    } else
      F.pendingTasks--, F.forceClientRender || (F.pendingTasks === 0 ? (V.parentFlushed && V.status === 1 && Ca(F, V), F.parentFlushed && S.completedBoundaries.push(F), F.fallbackAbortableTasks.forEach(ml, S), F.fallbackAbortableTasks.clear()) : V.parentFlushed && V.status === 1 && (Ca(F, V), F.completedSegments.length === 1 && F.parentFlushed && S.partialBoundaries.push(F)));
    S.allPendingTasks--, S.allPendingTasks === 0 && (S = S.onAllReady, S());
  }
  function to(S) {
    if (S.status !== 2) {
      var F = Xe, V = aa.current;
      aa.current = Sa;
      var ae = ka;
      ka = S.responseState;
      try {
        var Re = S.pingedTasks, ke;
        for (ke = 0; ke < Re.length; ke++) {
          var Oe = Re[ke], Ye = S, vt = Oe.blockedSegment;
          if (vt.status === 0) {
            Zt(Oe.context);
            try {
              jn(Ye, Oe, Oe.node), vt.lastPushedText && vt.textEmbedded && vt.chunks.push($), Oe.abortSet.delete(Oe), vt.status = 1, eo(Ye, Oe.blockedBoundary, vt);
            } catch (sr) {
              if (Za(), typeof sr == "object" && sr !== null && typeof sr.then == "function") {
                var Tt = Oe.ping;
                sr.then(Tt, Tt);
              } else {
                Oe.abortSet.delete(Oe), vt.status = 4;
                var kt = Oe.blockedBoundary, Jt = sr, Un = Ur(Ye, Jt);
                if (kt === null ? wa(Ye, Jt) : (kt.pendingTasks--, kt.forceClientRender || (kt.forceClientRender = !0, kt.errorDigest = Un, kt.parentFlushed && Ye.clientRenderedBoundaries.push(kt))), Ye.allPendingTasks--, Ye.allPendingTasks === 0) {
                  var lr = Ye.onAllReady;
                  lr();
                }
              }
            } finally {
            }
          }
        }
        Re.splice(0, ke), S.destination !== null && ti(S, S.destination);
      } catch (sr) {
        Ur(S, sr), wa(S, sr);
      } finally {
        ka = ae, aa.current = V, V === Sa && Zt(F);
      }
    }
  }
  function Aa(S, F, V) {
    switch (V.parentFlushed = !0, V.status) {
      case 0:
        var ae = V.id = S.nextSegmentId++;
        return V.lastPushedText = !1, V.textEmbedded = !1, S = S.responseState, a(F, it), a(F, S.placeholderPrefix), S = l(ae.toString(16)), a(F, S), i(F, wt);
      case 1:
        V.status = 2;
        var Re = !0;
        ae = V.chunks;
        var ke = 0;
        V = V.children;
        for (var Oe = 0; Oe < V.length; Oe++) {
          for (Re = V[Oe]; ke < Re.index; ke++)
            a(F, ae[ke]);
          Re = La(S, F, Re);
        }
        for (; ke < ae.length - 1; ke++)
          a(F, ae[ke]);
        return ke < ae.length && (Re = i(F, ae[ke])), Re;
      default:
        throw Error(t(390));
    }
  }
  function La(S, F, V) {
    var ae = V.boundary;
    if (ae === null)
      return Aa(S, F, V);
    if (ae.parentFlushed = !0, ae.forceClientRender)
      ae = ae.errorDigest, i(F, rn), a(F, Pt), ae && (a(F, tn), a(F, l(W(ae))), a(F, Nt)), i(F, sn), Aa(S, F, V);
    else if (0 < ae.pendingTasks) {
      ae.rootSegmentID = S.nextSegmentId++, 0 < ae.completedSegments.length && S.partialBoundaries.push(ae);
      var Re = S.responseState, ke = Re.nextSuspenseID++;
      Re = p(Re.boundaryPrefix + ke.toString(16)), ae = ae.id = Re, Ot(F, S.responseState, ae), Aa(S, F, V);
    } else if (ae.byteSize > S.progressiveChunkSize)
      ae.rootSegmentID = S.nextSegmentId++, S.completedBoundaries.push(ae), Ot(F, S.responseState, ae.id), Aa(S, F, V);
    else {
      if (i(F, Wt), V = ae.completedSegments, V.length !== 1)
        throw Error(t(391));
      La(S, F, V[0]);
    }
    return i(F, Et);
  }
  function no(S, F, V) {
    return Pn(F, S.responseState, V.formatContext, V.id), La(S, F, V), Tn(F, V.formatContext);
  }
  function ro(S, F, V) {
    for (var ae = V.completedSegments, Re = 0; Re < ae.length; Re++)
      ao(S, F, V, ae[Re]);
    if (ae.length = 0, S = S.responseState, ae = V.id, V = V.rootSegmentID, a(F, S.startInlineScript), S.sentCompleteBoundaryFunction ? a(F, bn) : (S.sentCompleteBoundaryFunction = !0, a(F, Ht)), ae === null)
      throw Error(t(395));
    return V = l(V.toString(16)), a(F, ae), a(F, Qt), a(F, S.segmentPrefix), a(F, V), i(F, cn);
  }
  function ao(S, F, V, ae) {
    if (ae.status === 2)
      return !0;
    var Re = ae.id;
    if (Re === -1) {
      if ((ae.id = V.rootSegmentID) === -1)
        throw Error(t(392));
      return no(S, F, ae);
    }
    return no(S, F, ae), S = S.responseState, a(F, S.startInlineScript), S.sentCompleteSegmentFunction ? a(F, Dn) : (S.sentCompleteSegmentFunction = !0, a(F, er)), a(F, S.segmentPrefix), Re = l(Re.toString(16)), a(F, Re), a(F, xn), a(F, S.placeholderPrefix), a(F, Re), i(F, At);
  }
  function ti(S, F) {
    n = new Uint8Array(512), r = 0;
    try {
      var V = S.completedRootSegment;
      if (V !== null && S.pendingRootTasks === 0) {
        La(S, F, V), S.completedRootSegment = null;
        var ae = S.responseState.bootstrapChunks;
        for (V = 0; V < ae.length - 1; V++)
          a(F, ae[V]);
        V < ae.length && i(F, ae[V]);
      }
      var Re = S.clientRenderedBoundaries, ke;
      for (ke = 0; ke < Re.length; ke++) {
        var Oe = Re[ke];
        ae = F;
        var Ye = S.responseState, vt = Oe.id, Tt = Oe.errorDigest, kt = Oe.errorMessage, Jt = Oe.errorComponentStack;
        if (a(ae, Ye.startInlineScript), Ye.sentClientRenderFunction ? a(ae, Lt) : (Ye.sentClientRenderFunction = !0, a(
          ae,
          kn
        )), vt === null)
          throw Error(t(395));
        a(ae, vt), a(ae, gn), (Tt || kt || Jt) && (a(ae, un), a(ae, l(_n(Tt || "")))), (kt || Jt) && (a(ae, un), a(ae, l(_n(kt || "")))), Jt && (a(ae, un), a(ae, l(_n(Jt)))), i(ae, an);
      }
      Re.splice(0, ke);
      var Un = S.completedBoundaries;
      for (ke = 0; ke < Un.length; ke++)
        ro(S, F, Un[ke]);
      Un.splice(0, ke), u(F), n = new Uint8Array(512), r = 0;
      var lr = S.partialBoundaries;
      for (ke = 0; ke < lr.length; ke++) {
        var sr = lr[ke];
        e: {
          Re = S, Oe = F;
          var Na = sr.completedSegments;
          for (Ye = 0; Ye < Na.length; Ye++)
            if (!ao(
              Re,
              Oe,
              sr,
              Na[Ye]
            )) {
              Ye++, Na.splice(0, Ye);
              var oo = !1;
              break e;
            }
          Na.splice(0, Ye), oo = !0;
        }
        if (!oo) {
          S.destination = null, ke++, lr.splice(0, ke);
          return;
        }
      }
      lr.splice(0, ke);
      var ni = S.completedBoundaries;
      for (ke = 0; ke < ni.length; ke++)
        ro(S, F, ni[ke]);
      ni.splice(0, ke);
    } finally {
      u(F), S.allPendingTasks === 0 && S.pingedTasks.length === 0 && S.clientRenderedBoundaries.length === 0 && S.completedBoundaries.length === 0 && F.close();
    }
  }
  function io(S, F) {
    try {
      var V = S.abortableTasks;
      V.forEach(function(ae) {
        return Ji(ae, S, F);
      }), V.clear(), S.destination !== null && ti(S, S.destination);
    } catch (ae) {
      Ur(S, ae), wa(S, ae);
    }
  }
  return Fc.renderToReadableStream = function(S, F) {
    return new Promise(function(V, ae) {
      var Re, ke, Oe = new Promise(function(kt, Jt) {
        ke = kt, Re = Jt;
      }), Ye = Qa(S, Q(F ? F.identifierPrefix : void 0, F ? F.nonce : void 0, F ? F.bootstrapScriptContent : void 0, F ? F.bootstrapScripts : void 0, F ? F.bootstrapModules : void 0), Y(F ? F.namespaceURI : void 0), F ? F.progressiveChunkSize : void 0, F ? F.onError : void 0, ke, function() {
        var kt = new ReadableStream({ type: "bytes", pull: function(Jt) {
          if (Ye.status === 1)
            Ye.status = 2, h(Jt, Ye.fatalError);
          else if (Ye.status !== 2 && Ye.destination === null) {
            Ye.destination = Jt;
            try {
              ti(Ye, Jt);
            } catch (Un) {
              Ur(Ye, Un), wa(Ye, Un);
            }
          }
        }, cancel: function() {
          io(Ye);
        } }, { highWaterMark: 0 });
        kt.allReady = Oe, V(kt);
      }, function(kt) {
        Oe.catch(function() {
        }), ae(kt);
      }, Re);
      if (F && F.signal) {
        var vt = F.signal, Tt = function() {
          io(Ye, vt.reason), vt.removeEventListener("abort", Tt);
        };
        vt.addEventListener("abort", Tt);
      }
      to(Ye);
    });
  }, Fc.version = "18.2.0", Fc;
}
var Di = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tm;
function xS() {
  return tm || (tm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ue, t = "18.2.0", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(o) {
      {
        for (var d = arguments.length, k = new Array(d > 1 ? d - 1 : 0), P = 1; P < d; P++)
          k[P - 1] = arguments[P];
        i("warn", o, k);
      }
    }
    function a(o) {
      {
        for (var d = arguments.length, k = new Array(d > 1 ? d - 1 : 0), P = 1; P < d; P++)
          k[P - 1] = arguments[P];
        i("error", o, k);
      }
    }
    function i(o, d, k) {
      {
        var P = n.ReactDebugCurrentFrame, H = P.getStackAddendum();
        H !== "" && (d += "%s", k = k.concat([H]));
        var oe = k.map(function(he) {
          return String(he);
        });
        oe.unshift("Warning: " + d), Function.prototype.apply.call(console[o], console, oe);
      }
    }
    function u(o) {
      o();
    }
    function c(o) {
    }
    function l(o, d) {
      p(o, d);
    }
    function p(o, d) {
      return o.push(d);
    }
    function h(o) {
    }
    function g(o) {
      o.push(null);
    }
    function x(o) {
      return o;
    }
    function w(o) {
      return o;
    }
    function y(o, d) {
      o.destroy(d);
    }
    function R(o) {
      {
        var d = typeof Symbol == "function" && Symbol.toStringTag, k = d && o[Symbol.toStringTag] || o.constructor.name || "Object";
        return k;
      }
    }
    function b(o) {
      try {
        return v(o), !1;
      } catch {
        return !0;
      }
    }
    function v(o) {
      return "" + o;
    }
    function A(o, d) {
      if (b(o))
        return a("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", d, R(o)), v(o);
    }
    function N(o, d) {
      if (b(o))
        return a("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", d, R(o)), v(o);
    }
    function L(o) {
      if (b(o))
        return a("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", R(o)), v(o);
    }
    var C = Object.prototype.hasOwnProperty, z = 0, W = 1, q = 2, ne = 3, G = 4, le = 5, K = 6, re = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", B = re + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", j = new RegExp("^[" + re + "][" + B + "]*$"), se = {}, ee = {};
    function Q(o) {
      return C.call(ee, o) ? !0 : C.call(se, o) ? !1 : j.test(o) ? (ee[o] = !0, !0) : (se[o] = !0, a("Invalid attribute name: `%s`", o), !1);
    }
    function Z(o, d, k, P) {
      if (k !== null && k.type === z)
        return !1;
      switch (typeof d) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (P)
            return !1;
          if (k !== null)
            return !k.acceptsBooleans;
          var H = o.toLowerCase().slice(0, 5);
          return H !== "data-" && H !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Y(o) {
      return $.hasOwnProperty(o) ? $[o] : null;
    }
    function te(o, d, k, P, H, oe, he) {
      this.acceptsBooleans = d === q || d === ne || d === G, this.attributeName = P, this.attributeNamespace = H, this.mustUseProperty = k, this.propertyName = o, this.type = d, this.sanitizeURL = oe, this.removeEmptyString = he;
    }
    var $ = {}, ce = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ce.forEach(function(o) {
      $[o] = new te(
        o,
        z,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(o) {
      var d = o[0], k = o[1];
      $[d] = new te(
        d,
        W,
        !1,
        // mustUseProperty
        k,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(o) {
      $[o] = new te(
        o,
        q,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(o) {
      $[o] = new te(
        o,
        q,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(o) {
      $[o] = new te(
        o,
        ne,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      $[o] = new te(
        o,
        ne,
        !0,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      $[o] = new te(
        o,
        G,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      $[o] = new te(
        o,
        K,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(o) {
      $[o] = new te(
        o,
        le,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Se = /[\-\:]([a-z])/g, be = function(o) {
      return o[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var d = o.replace(Se, be);
      $[d] = new te(
        d,
        W,
        !1,
        // mustUseProperty
        o,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var d = o.replace(Se, be);
      $[d] = new te(
        d,
        W,
        !1,
        // mustUseProperty
        o,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var d = o.replace(Se, be);
      $[d] = new te(
        d,
        W,
        !1,
        // mustUseProperty
        o,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(o) {
      $[o] = new te(
        o,
        W,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ve = "xlinkHref";
    $[ve] = new te(
      "xlinkHref",
      W,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(o) {
      $[o] = new te(
        o,
        W,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Pe = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ve(o, d) {
      return o + d.charAt(0).toUpperCase() + d.substring(1);
    }
    var we = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Pe).forEach(function(o) {
      we.forEach(function(d) {
        Pe[Ve(d, o)] = Pe[o];
      });
    });
    var me = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Ce(o, d) {
      me[d.type] || d.onChange || d.onInput || d.readOnly || d.disabled || d.value == null || a("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), d.onChange || d.readOnly || d.disabled || d.checked == null || a("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function fe(o, d) {
      if (o.indexOf("-") === -1)
        return typeof d.is == "string";
      switch (o) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ze = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ie = {}, Qe = new RegExp("^(aria)-[" + B + "]*$"), He = new RegExp("^(aria)[A-Z][" + B + "]*$");
    function Fe(o, d) {
      {
        if (C.call(Ie, d) && Ie[d])
          return !0;
        if (He.test(d)) {
          var k = "aria-" + d.slice(4).toLowerCase(), P = ze.hasOwnProperty(k) ? k : null;
          if (P == null)
            return a("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", d), Ie[d] = !0, !0;
          if (d !== P)
            return a("Invalid ARIA attribute `%s`. Did you mean `%s`?", d, P), Ie[d] = !0, !0;
        }
        if (Qe.test(d)) {
          var H = d.toLowerCase(), oe = ze.hasOwnProperty(H) ? H : null;
          if (oe == null)
            return Ie[d] = !0, !1;
          if (d !== oe)
            return a("Unknown ARIA attribute `%s`. Did you mean `%s`?", d, oe), Ie[d] = !0, !0;
        }
      }
      return !0;
    }
    function qe(o, d) {
      {
        var k = [];
        for (var P in d) {
          var H = Fe(o, P);
          H || k.push(P);
        }
        var oe = k.map(function(he) {
          return "`" + he + "`";
        }).join(", ");
        k.length === 1 ? a("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", oe, o) : k.length > 1 && a("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", oe, o);
      }
    }
    function We(o, d) {
      fe(o, d) || qe(o, d);
    }
    var je = !1;
    function Ke(o, d) {
      {
        if (o !== "input" && o !== "textarea" && o !== "select")
          return;
        d != null && d.value === null && !je && (je = !0, o === "select" && d.multiple ? a("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", o) : a("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", o));
      }
    }
    var Te = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, _e = function() {
    };
    {
      var at = {}, ge = /^on./, ft = /^on[^A-Z]/, ot = new RegExp("^(aria)-[" + B + "]*$"), it = new RegExp("^(aria)[A-Z][" + B + "]*$");
      _e = function(o, d, k, P) {
        if (C.call(at, d) && at[d])
          return !0;
        var H = d.toLowerCase();
        if (H === "onfocusin" || H === "onfocusout")
          return a("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), at[d] = !0, !0;
        if (P != null) {
          var oe = P.registrationNameDependencies, he = P.possibleRegistrationNames;
          if (oe.hasOwnProperty(d))
            return !0;
          var Ae = he.hasOwnProperty(H) ? he[H] : null;
          if (Ae != null)
            return a("Invalid event handler property `%s`. Did you mean `%s`?", d, Ae), at[d] = !0, !0;
          if (ge.test(d))
            return a("Unknown event handler property `%s`. It will be ignored.", d), at[d] = !0, !0;
        } else if (ge.test(d))
          return ft.test(d) && a("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", d), at[d] = !0, !0;
        if (ot.test(d) || it.test(d))
          return !0;
        if (H === "innerhtml")
          return a("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), at[d] = !0, !0;
        if (H === "aria")
          return a("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), at[d] = !0, !0;
        if (H === "is" && k !== null && k !== void 0 && typeof k != "string")
          return a("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof k), at[d] = !0, !0;
        if (typeof k == "number" && isNaN(k))
          return a("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", d), at[d] = !0, !0;
        var $e = Y(d), rt = $e !== null && $e.type === z;
        if (Te.hasOwnProperty(H)) {
          var ct = Te[H];
          if (ct !== d)
            return a("Invalid DOM property `%s`. Did you mean `%s`?", d, ct), at[d] = !0, !0;
        } else if (!rt && d !== H)
          return a("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", d, H), at[d] = !0, !0;
        return typeof k == "boolean" && Z(d, k, $e, !1) ? (k ? a('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', k, d, d, k, d) : a('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', k, d, d, k, d, d, d), at[d] = !0, !0) : rt ? !0 : Z(d, k, $e, !1) ? (at[d] = !0, !1) : ((k === "false" || k === "true") && $e !== null && $e.type === ne && (a("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", k, d, k === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', d, k), at[d] = !0), !0);
      };
    }
    var wt = function(o, d, k) {
      {
        var P = [];
        for (var H in d) {
          var oe = _e(o, H, d[H], k);
          oe || P.push(H);
        }
        var he = P.map(function(Ae) {
          return "`" + Ae + "`";
        }).join(", ");
        P.length === 1 ? a("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, o) : P.length > 1 && a("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, o);
      }
    };
    function Wt(o, d, k) {
      fe(o, d) || wt(o, d, k);
    }
    var Kt = function() {
    };
    {
      var Mt = /^(?:webkit|moz|o)[A-Z]/, rn = /^-ms-/, Et = /-(.)/g, Pt = /;\s*$/, Nt = {}, tn = {}, sn = !1, Ot = !1, Ft = function(o) {
        return o.replace(Et, function(d, k) {
          return k.toUpperCase();
        });
      }, nn = function(o) {
        Nt.hasOwnProperty(o) && Nt[o] || (Nt[o] = !0, a(
          "Unsupported style property %s. Did you mean %s?",
          o,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Ft(o.replace(rn, "ms-"))
        ));
      }, et = function(o) {
        Nt.hasOwnProperty(o) && Nt[o] || (Nt[o] = !0, a("Unsupported vendor-prefixed style property %s. Did you mean %s?", o, o.charAt(0).toUpperCase() + o.slice(1)));
      }, ut = function(o, d) {
        tn.hasOwnProperty(d) && tn[d] || (tn[d] = !0, a(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, o, d.replace(Pt, "")));
      }, Ne = function(o, d) {
        sn || (sn = !0, a("`NaN` is an invalid value for the `%s` css style property.", o));
      }, De = function(o, d) {
        Ot || (Ot = !0, a("`Infinity` is an invalid value for the `%s` css style property.", o));
      };
      Kt = function(o, d) {
        o.indexOf("-") > -1 ? nn(o) : Mt.test(o) ? et(o) : Pt.test(d) && ut(o, d), typeof d == "number" && (isNaN(d) ? Ne(o, d) : isFinite(d) || De(o, d));
      };
    }
    var Ee = Kt, pt = /["'&<>]/;
    function nt(o) {
      L(o);
      var d = "" + o, k = pt.exec(d);
      if (!k)
        return d;
      var P, H = "", oe, he = 0;
      for (oe = k.index; oe < d.length; oe++) {
        switch (d.charCodeAt(oe)) {
          case 34:
            P = "&quot;";
            break;
          case 38:
            P = "&amp;";
            break;
          case 39:
            P = "&#x27;";
            break;
          case 60:
            P = "&lt;";
            break;
          case 62:
            P = "&gt;";
            break;
          default:
            continue;
        }
        he !== oe && (H += d.substring(he, oe)), he = oe + 1, H += P;
      }
      return he !== oe ? H + d.substring(he, oe) : H;
    }
    function gt(o) {
      return typeof o == "boolean" || typeof o == "number" ? "" + o : nt(o);
    }
    var xt = /([A-Z])/g, Yt = /^ms-/;
    function lt(o) {
      return o.replace(xt, "-$1").toLowerCase().replace(Yt, "-ms-");
    }
    var st = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, $t = !1;
    function jt(o) {
      !$t && st.test(o) && ($t = !0, a("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(o)));
    }
    var Rt = Array.isArray;
    function St(o) {
      return Rt(o);
    }
    var yn = "<script>", vn = "<\/script>", wn = '<script src="', Pn = '<script type="module" src="', Tn = '" async=""><\/script>';
    function er(o) {
      return L(o), ("" + o).replace(Dn, xn);
    }
    var Dn = /(<\/|<)(s)(cript)/gi, xn = function(o, d, k, P) {
      return "" + d + (k === "s" ? "\\u0073" : "\\u0053") + P;
    };
    function At(o, d, k, P, H) {
      var oe = o === void 0 ? "" : o, he = d === void 0 ? yn : '<script nonce="' + gt(d) + '">', Ae = [];
      if (k !== void 0 && Ae.push(he, er(k), vn), P !== void 0)
        for (var $e = 0; $e < P.length; $e++)
          Ae.push(wn, gt(P[$e]), Tn);
      if (H !== void 0)
        for (var rt = 0; rt < H.length; rt++)
          Ae.push(Pn, gt(H[rt]), Tn);
      return {
        bootstrapChunks: Ae,
        startInlineScript: he,
        placeholderPrefix: oe + "P:",
        segmentPrefix: oe + "S:",
        boundaryPrefix: oe + "B:",
        idPrefix: oe,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var Ht = 0, bn = 1, Qt = 2, cn = 3, kn = 4, Lt = 5, gn = 6, an = 7;
    function un(o, d) {
      return {
        insertionMode: o,
        selectedValue: d
      };
    }
    function tr(o, d, k) {
      switch (d) {
        case "select":
          return un(bn, k.value != null ? k.value : k.defaultValue);
        case "svg":
          return un(Qt, null);
        case "math":
          return un(cn, null);
        case "foreignObject":
          return un(bn, null);
        case "table":
          return un(kn, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return un(Lt, null);
        case "colgroup":
          return un(an, null);
        case "tr":
          return un(gn, null);
      }
      return o.insertionMode >= kn || o.insertionMode === Ht ? un(bn, null) : o;
    }
    var _n = null;
    function Rn(o) {
      var d = o.nextSuspenseID++;
      return o.boundaryPrefix + d.toString(16);
    }
    function pn(o, d, k) {
      var P = o.idPrefix, H = ":" + P + "R" + d;
      return k > 0 && (H += "H" + k.toString(32)), H + ":";
    }
    function zn(o) {
      return gt(o);
    }
    var Bn = "<!-- -->";
    function nr(o, d, k, P) {
      return d === "" ? P : (P && o.push(Bn), o.push(zn(d)), !0);
    }
    function hr(o, d, k, P) {
      k && P && o.push(Bn);
    }
    var rr = /* @__PURE__ */ new Map();
    function Hn(o) {
      var d = rr.get(o);
      if (d !== void 0)
        return d;
      var k = gt(lt(o));
      return rr.set(o, k), k;
    }
    var ar = ' style="', Kn = ":", Yn = ";";
    function E(o, d, k) {
      if (typeof k != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var P = !0;
      for (var H in k)
        if (C.call(k, H)) {
          var oe = k[H];
          if (!(oe == null || typeof oe == "boolean" || oe === "")) {
            var he = void 0, Ae = void 0, $e = H.indexOf("--") === 0;
            $e ? (he = gt(H), N(oe, H), Ae = gt(("" + oe).trim())) : (Ee(H, oe), he = Hn(H), typeof oe == "number" ? oe !== 0 && !C.call(Pe, H) ? Ae = oe + "px" : Ae = "" + oe : (N(oe, H), Ae = gt(("" + oe).trim()))), P ? (P = !1, o.push(ar, he, Kn, Ae)) : o.push(Yn, he, Kn, Ae);
          }
        }
      P || o.push(U);
    }
    var _ = " ", D = '="', U = '"', pe = '=""';
    function O(o, d, k, P) {
      switch (k) {
        case "style": {
          E(o, d, P);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(k.length > 2 && (k[0] === "o" || k[0] === "O") && (k[1] === "n" || k[1] === "N"))
      ) {
        var H = Y(k);
        if (H !== null) {
          switch (typeof P) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!H.acceptsBooleans)
                return;
          }
          var oe = H.attributeName, he = oe;
          switch (H.type) {
            case ne:
              P && o.push(_, he, pe);
              return;
            case G:
              P === !0 ? o.push(_, he, pe) : P === !1 || o.push(_, he, D, gt(P), U);
              return;
            case le:
              isNaN(P) || o.push(_, he, D, gt(P), U);
              break;
            case K:
              !isNaN(P) && P >= 1 && o.push(_, he, D, gt(P), U);
              break;
            default:
              H.sanitizeURL && (A(P, oe), P = "" + P, jt(P)), o.push(_, he, D, gt(P), U);
          }
        } else if (Q(k)) {
          switch (typeof P) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Ae = k.toLowerCase().slice(0, 5);
              if (Ae !== "data-" && Ae !== "aria-")
                return;
            }
          }
          o.push(_, k, D, gt(P), U);
        }
      }
    }
    var I = ">", J = "/>";
    function xe(o, d, k) {
      if (d != null) {
        if (k != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof d != "object" || !("__html" in d))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var P = d.__html;
        P != null && (L(P), o.push("" + P));
      }
    }
    var Be = !1, Xe = !1, dt = !1, Vt = !1, zt = !1, Xt = !1, qt = !1;
    function Zt(o, d) {
      {
        var k = o[d];
        if (k != null) {
          var P = St(k);
          o.multiple && !P ? a("The `%s` prop supplied to <select> must be an array if `multiple` is true.", d) : !o.multiple && P && a("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", d);
        }
      }
    }
    function In(o, d, k) {
      Ce("select", d), Zt(d, "value"), Zt(d, "defaultValue"), d.value !== void 0 && d.defaultValue !== void 0 && !dt && (a("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), dt = !0), o.push(Wn("select"));
      var P = null, H = null;
      for (var oe in d)
        if (C.call(d, oe)) {
          var he = d[oe];
          if (he == null)
            continue;
          switch (oe) {
            case "children":
              P = he;
              break;
            case "dangerouslySetInnerHTML":
              H = he;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              O(o, k, oe, he);
              break;
          }
        }
      return o.push(I), xe(o, H, P), P;
    }
    function Gn(o) {
      var d = "";
      return e.Children.forEach(o, function(k) {
        k != null && (d += k, !zt && typeof k != "string" && typeof k != "number" && (zt = !0, a("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), d;
    }
    var Xn = ' selected=""';
    function Vn(o, d, k, P) {
      var H = P.selectedValue;
      o.push(Wn("option"));
      var oe = null, he = null, Ae = null, $e = null;
      for (var rt in d)
        if (C.call(d, rt)) {
          var ct = d[rt];
          if (ct == null)
            continue;
          switch (rt) {
            case "children":
              oe = ct;
              break;
            case "selected":
              Ae = ct, qt || (a("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), qt = !0);
              break;
            case "dangerouslySetInnerHTML":
              $e = ct;
              break;
            case "value":
              he = ct;
            default:
              O(o, k, rt, ct);
              break;
          }
        }
      if (H != null) {
        var bt;
        if (he !== null ? (A(he, "value"), bt = "" + he) : ($e !== null && (Xt || (Xt = !0, a("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), bt = Gn(oe)), St(H))
          for (var on = 0; on < H.length; on++) {
            A(H[on], "value");
            var Fn = "" + H[on];
            if (Fn === bt) {
              o.push(Xn);
              break;
            }
          }
        else
          A(H, "select.value"), "" + H === bt && o.push(Xn);
      } else
        Ae && o.push(Xn);
      return o.push(I), xe(o, $e, oe), oe;
    }
    function Er(o, d, k) {
      Ce("input", d), d.checked !== void 0 && d.defaultChecked !== void 0 && !Xe && (a("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", d.type), Xe = !0), d.value !== void 0 && d.defaultValue !== void 0 && !Be && (a("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", d.type), Be = !0), o.push(Wn("input"));
      var P = null, H = null, oe = null, he = null;
      for (var Ae in d)
        if (C.call(d, Ae)) {
          var $e = d[Ae];
          if ($e == null)
            continue;
          switch (Ae) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              he = $e;
              break;
            case "defaultValue":
              H = $e;
              break;
            case "checked":
              oe = $e;
              break;
            case "value":
              P = $e;
              break;
            default:
              O(o, k, Ae, $e);
              break;
          }
        }
      return oe !== null ? O(o, k, "checked", oe) : he !== null && O(o, k, "checked", he), P !== null ? O(o, k, "value", P) : H !== null && O(o, k, "value", H), o.push(J), null;
    }
    function xa(o, d, k) {
      Ce("textarea", d), d.value !== void 0 && d.defaultValue !== void 0 && !Vt && (a("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Vt = !0), o.push(Wn("textarea"));
      var P = null, H = null, oe = null;
      for (var he in d)
        if (C.call(d, he)) {
          var Ae = d[he];
          if (Ae == null)
            continue;
          switch (he) {
            case "children":
              oe = Ae;
              break;
            case "value":
              P = Ae;
              break;
            case "defaultValue":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              O(o, k, he, Ae);
              break;
          }
        }
      if (P === null && H !== null && (P = H), o.push(I), oe != null) {
        if (a("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), P != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (St(oe)) {
          if (oe.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          L(oe[0]), P = "" + oe[0];
        }
        L(oe), P = "" + oe;
      }
      return typeof P == "string" && P[0] === `
` && o.push(Dr), P !== null && (A(P, "value"), o.push(zn("" + P))), null;
    }
    function Ct(o, d, k, P) {
      o.push(Wn(k));
      for (var H in d)
        if (C.call(d, H)) {
          var oe = d[H];
          if (oe == null)
            continue;
          switch (H) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(k + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              O(o, P, H, oe);
              break;
          }
        }
      return o.push(J), null;
    }
    function dn(o, d, k) {
      o.push(Wn("menuitem"));
      for (var P in d)
        if (C.call(d, P)) {
          var H = d[P];
          if (H == null)
            continue;
          switch (P) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              O(o, k, P, H);
              break;
          }
        }
      return o.push(I), null;
    }
    function ra(o, d, k) {
      o.push(Wn("title"));
      var P = null;
      for (var H in d)
        if (C.call(d, H)) {
          var oe = d[H];
          if (oe == null)
            continue;
          switch (H) {
            case "children":
              P = oe;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              O(o, k, H, oe);
              break;
          }
        }
      o.push(I);
      {
        var he = Array.isArray(P) && P.length < 2 ? P[0] || null : P;
        Array.isArray(P) && P.length > 1 ? a("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && he.$$typeof != null ? a("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && typeof he != "string" && typeof he != "number" && a("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return P;
    }
    function Pr(o, d, k, P) {
      o.push(Wn(k));
      var H = null, oe = null;
      for (var he in d)
        if (C.call(d, he)) {
          var Ae = d[he];
          if (Ae == null)
            continue;
          switch (he) {
            case "children":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              oe = Ae;
              break;
            default:
              O(o, P, he, Ae);
              break;
          }
        }
      return o.push(I), xe(o, oe, H), typeof H == "string" ? (o.push(zn(H)), null) : H;
    }
    function ir(o, d, k, P) {
      o.push(Wn(k));
      var H = null, oe = null;
      for (var he in d)
        if (C.call(d, he)) {
          var Ae = d[he];
          if (Ae == null)
            continue;
          switch (he) {
            case "children":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              oe = Ae;
              break;
            case "style":
              E(o, P, Ae);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              Q(he) && typeof Ae != "function" && typeof Ae != "symbol" && o.push(_, he, D, gt(Ae), U);
              break;
          }
        }
      return o.push(I), xe(o, oe, H), H;
    }
    var Dr = `
`;
    function Wr(o, d, k, P) {
      o.push(Wn(k));
      var H = null, oe = null;
      for (var he in d)
        if (C.call(d, he)) {
          var Ae = d[he];
          if (Ae == null)
            continue;
          switch (he) {
            case "children":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              oe = Ae;
              break;
            default:
              O(o, P, he, Ae);
              break;
          }
        }
      if (o.push(I), oe != null) {
        if (H != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof oe != "object" || !("__html" in oe))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var $e = oe.__html;
        $e != null && (typeof $e == "string" && $e.length > 0 && $e[0] === `
` ? o.push(Dr, $e) : (L($e), o.push("" + $e)));
      }
      return typeof H == "string" && H[0] === `
` && o.push(Dr), H;
    }
    var Bt = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, mr = /* @__PURE__ */ new Map();
    function Wn(o) {
      var d = mr.get(o);
      if (d === void 0) {
        if (!Bt.test(o))
          throw new Error("Invalid tag: " + o);
        d = "<" + o, mr.set(o, d);
      }
      return d;
    }
    var _r = "<!DOCTYPE html>";
    function kr(o, d, k, P, H) {
      switch (We(d, k), Ke(d, k), Wt(d, k, null), !k.suppressContentEditableWarning && k.contentEditable && k.children != null && a("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), H.insertionMode !== Qt && H.insertionMode !== cn && d.indexOf("-") === -1 && typeof k.is != "string" && d.toLowerCase() !== d && a("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", d), d) {
        case "select":
          return In(o, k, P);
        case "option":
          return Vn(o, k, P, H);
        case "textarea":
          return xa(o, k, P);
        case "input":
          return Er(o, k, P);
        case "menuitem":
          return dn(o, k, P);
        case "title":
          return ra(o, k, P);
        case "listing":
        case "pre":
          return Wr(o, k, d, P);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Ct(o, k, d, P);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Pr(o, k, d, P);
        case "html":
          return H.insertionMode === Ht && o.push(_r), Pr(o, k, d, P);
        default:
          return d.indexOf("-") === -1 && typeof k.is != "string" ? Pr(o, k, d, P) : ir(o, k, d, P);
      }
    }
    var ba = "</", wr = ">";
    function or(o, d, k) {
      switch (d) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          o.push(ba, d, wr);
      }
    }
    function qa(o, d) {
      for (var k = d.bootstrapChunks, P = 0; P < k.length - 1; P++)
        l(o, k[P]);
      return P < k.length ? p(o, k[P]) : !0;
    }
    var Za = '<template id="', Yi = '"></template>';
    function Gi(o, d, k) {
      l(o, Za), l(o, d.placeholderPrefix);
      var P = k.toString(16);
      return l(o, P), p(o, Yi);
    }
    var Xi = "<!--$-->", fl = '<!--$?--><template id="', pl = '"></template>', Ea = "<!--$!-->", Sa = "<!--/$-->", ka = "<template", aa = '"', hl = ' data-dgst="', ia = ' data-msg="', Qa = ' data-stck="', Ja = "></template>";
    function jr(o, d) {
      return p(o, Xi);
    }
    function Ur(o, d, k) {
      if (l(o, fl), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return l(o, k), p(o, pl);
    }
    function wa(o, d, k, P, H) {
      var oe;
      return oe = p(o, Ea), l(o, ka), k && (l(o, hl), l(o, gt(k)), l(o, aa)), P && (l(o, ia), l(o, gt(P)), l(o, aa)), H && (l(o, Qa), l(o, gt(H)), l(o, aa)), oe = p(o, Ja), oe;
    }
    function qi(o, d) {
      return p(o, Sa);
    }
    function ei(o, d) {
      return p(o, Sa);
    }
    function Zi(o, d) {
      return p(o, Sa);
    }
    var Ta = '<div hidden id="', jn = '">', Qi = "</div>", Ra = '<svg aria-hidden="true" style="display:none" id="', ml = '">', Ji = "</svg>", Ca = '<math aria-hidden="true" style="display:none" id="', eo = '">', to = "</math>", Aa = '<table hidden id="', La = '">', no = "</table>", ro = '<table hidden><tbody id="', ao = '">', ti = "</tbody></table>", io = '<table hidden><tr id="', S = '">', F = "</tr></table>", V = '<table hidden><colgroup id="', ae = '">', Re = "</colgroup></table>";
    function ke(o, d, k, P) {
      switch (k.insertionMode) {
        case Ht:
        case bn:
          return l(o, Ta), l(o, d.segmentPrefix), l(o, P.toString(16)), p(o, jn);
        case Qt:
          return l(o, Ra), l(o, d.segmentPrefix), l(o, P.toString(16)), p(o, ml);
        case cn:
          return l(o, Ca), l(o, d.segmentPrefix), l(o, P.toString(16)), p(o, eo);
        case kn:
          return l(o, Aa), l(o, d.segmentPrefix), l(o, P.toString(16)), p(o, La);
        case Lt:
          return l(o, ro), l(o, d.segmentPrefix), l(o, P.toString(16)), p(o, ao);
        case gn:
          return l(o, io), l(o, d.segmentPrefix), l(o, P.toString(16)), p(o, S);
        case an:
          return l(o, V), l(o, d.segmentPrefix), l(o, P.toString(16)), p(o, ae);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Oe(o, d) {
      switch (d.insertionMode) {
        case Ht:
        case bn:
          return p(o, Qi);
        case Qt:
          return p(o, Ji);
        case cn:
          return p(o, to);
        case kn:
          return p(o, no);
        case Lt:
          return p(o, ti);
        case gn:
          return p(o, F);
        case an:
          return p(o, Re);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Ye = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", vt = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Tt = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', kt = Ye + ';$RS("', Jt = '$RS("', Un = '","', lr = '")<\/script>';
    function sr(o, d, k) {
      l(o, d.startInlineScript), d.sentCompleteSegmentFunction ? l(o, Jt) : (d.sentCompleteSegmentFunction = !0, l(o, kt)), l(o, d.segmentPrefix);
      var P = k.toString(16);
      return l(o, P), l(o, Un), l(o, d.placeholderPrefix), l(o, P), p(o, lr);
    }
    var Na = vt + ';$RC("', oo = '$RC("', ni = '","', Wu = '")<\/script>';
    function ju(o, d, k, P) {
      if (l(o, d.startInlineScript), d.sentCompleteBoundaryFunction ? l(o, oo) : (d.sentCompleteBoundaryFunction = !0, l(o, Na)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var H = P.toString(16);
      return l(o, k), l(o, ni), l(o, d.segmentPrefix), l(o, H), p(o, Wu);
    }
    var Uu = Tt + ';$RX("', Ku = '$RX("', Yu = '"', Gu = ")<\/script>", yl = ",";
    function Xu(o, d, k, P, H, oe) {
      if (l(o, d.startInlineScript), d.sentClientRenderFunction ? l(o, Ku) : (d.sentClientRenderFunction = !0, l(o, Uu)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return l(o, k), l(o, Yu), (P || H || oe) && (l(o, yl), l(o, gl(P || ""))), (H || oe) && (l(o, yl), l(o, gl(H || ""))), oe && (l(o, yl), l(o, gl(oe))), p(o, Gu);
    }
    var qu = /[<\u2028\u2029]/g;
    function gl(o) {
      var d = JSON.stringify(o);
      return d.replace(qu, function(k) {
        switch (k) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Zu(o, d) {
      var k = At(d, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: k.bootstrapChunks,
        startInlineScript: k.startInlineScript,
        placeholderPrefix: k.placeholderPrefix,
        segmentPrefix: k.segmentPrefix,
        boundaryPrefix: k.boundaryPrefix,
        idPrefix: k.idPrefix,
        nextSuspenseID: k.nextSuspenseID,
        sentCompleteSegmentFunction: k.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: k.sentCompleteBoundaryFunction,
        sentClientRenderFunction: k.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: o
      };
    }
    function vl() {
      return {
        insertionMode: bn,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function Os(o, d, k, P) {
      return k.generateStaticMarkup ? (o.push(gt(d)), !1) : nr(o, d, k, P);
    }
    function Fs(o, d, k, P) {
      if (!d.generateStaticMarkup)
        return hr(o, d, k, P);
    }
    function xl(o, d) {
      return d.generateStaticMarkup ? !0 : jr(o);
    }
    function yr(o, d, k, P, H) {
      return d.generateStaticMarkup ? !0 : wa(o, d, k, P, H);
    }
    function Qu(o, d) {
      return d.generateStaticMarkup ? !0 : qi(o);
    }
    function Ms(o, d) {
      return d.generateStaticMarkup ? !0 : Zi(o);
    }
    var cr = Object.assign, zs = Symbol.for("react.element"), bl = Symbol.for("react.portal"), lo = Symbol.for("react.fragment"), so = Symbol.for("react.strict_mode"), co = Symbol.for("react.profiler"), ri = Symbol.for("react.provider"), ai = Symbol.for("react.context"), ii = Symbol.for("react.forward_ref"), Pa = Symbol.for("react.suspense"), El = Symbol.for("react.suspense_list"), Sl = Symbol.for("react.memo"), uo = Symbol.for("react.lazy"), Ju = Symbol.for("react.scope"), Bs = Symbol.for("react.debug_trace_mode"), ed = Symbol.for("react.legacy_hidden"), td = Symbol.for("react.default_value"), Is = Symbol.iterator, $s = "@@iterator";
    function hn(o) {
      if (o === null || typeof o != "object")
        return null;
      var d = Is && o[Is] || o[$s];
      return typeof d == "function" ? d : null;
    }
    function oi(o, d, k) {
      var P = o.displayName;
      if (P)
        return P;
      var H = d.displayName || d.name || "";
      return H !== "" ? k + "(" + H + ")" : k;
    }
    function kl(o) {
      return o.displayName || "Context";
    }
    function fn(o) {
      if (o == null)
        return null;
      if (typeof o.tag == "number" && a("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof o == "function")
        return o.displayName || o.name || null;
      if (typeof o == "string")
        return o;
      switch (o) {
        case lo:
          return "Fragment";
        case bl:
          return "Portal";
        case co:
          return "Profiler";
        case so:
          return "StrictMode";
        case Pa:
          return "Suspense";
        case El:
          return "SuspenseList";
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case ai:
            var d = o;
            return kl(d) + ".Consumer";
          case ri:
            var k = o;
            return kl(k._context) + ".Provider";
          case ii:
            return oi(o, o.render, "ForwardRef");
          case Sl:
            var P = o.displayName || null;
            return P !== null ? P : fn(o.type) || "Memo";
          case uo: {
            var H = o, oe = H._payload, he = H._init;
            try {
              return fn(he(oe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Da = 0, wl, Tl, Rl, Cl, Al, Hs, Vs;
    function fo() {
    }
    fo.__reactDisabledLog = !0;
    function Ll() {
      {
        if (Da === 0) {
          wl = console.log, Tl = console.info, Rl = console.warn, Cl = console.error, Al = console.group, Hs = console.groupCollapsed, Vs = console.groupEnd;
          var o = {
            configurable: !0,
            enumerable: !0,
            value: fo,
            writable: !0
          };
          Object.defineProperties(console, {
            info: o,
            log: o,
            warn: o,
            error: o,
            group: o,
            groupCollapsed: o,
            groupEnd: o
          });
        }
        Da++;
      }
    }
    function li() {
      {
        if (Da--, Da === 0) {
          var o = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: cr({}, o, {
              value: wl
            }),
            info: cr({}, o, {
              value: Tl
            }),
            warn: cr({}, o, {
              value: Rl
            }),
            error: cr({}, o, {
              value: Cl
            }),
            group: cr({}, o, {
              value: Al
            }),
            groupCollapsed: cr({}, o, {
              value: Hs
            }),
            groupEnd: cr({}, o, {
              value: Vs
            })
          });
        }
        Da < 0 && a("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var si = n.ReactCurrentDispatcher, _a;
    function ci(o, d, k) {
      {
        if (_a === void 0)
          try {
            throw Error();
          } catch (H) {
            var P = H.stack.trim().match(/\n( *(at )?)/);
            _a = P && P[1] || "";
          }
        return `
` + _a + o;
      }
    }
    var ui = !1, po;
    {
      var Ws = typeof WeakMap == "function" ? WeakMap : Map;
      po = new Ws();
    }
    function Nl(o, d) {
      if (!o || ui)
        return "";
      {
        var k = po.get(o);
        if (k !== void 0)
          return k;
      }
      var P;
      ui = !0;
      var H = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var oe;
      oe = si.current, si.current = null, Ll();
      try {
        if (d) {
          var he = function() {
            throw Error();
          };
          if (Object.defineProperty(he.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(he, []);
            } catch (br) {
              P = br;
            }
            Reflect.construct(o, [], he);
          } else {
            try {
              he.call();
            } catch (br) {
              P = br;
            }
            o.call(he.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (br) {
            P = br;
          }
          o();
        }
      } catch (br) {
        if (br && P && typeof br.stack == "string") {
          for (var Ae = br.stack.split(`
`), $e = P.stack.split(`
`), rt = Ae.length - 1, ct = $e.length - 1; rt >= 1 && ct >= 0 && Ae[rt] !== $e[ct]; )
            ct--;
          for (; rt >= 1 && ct >= 0; rt--, ct--)
            if (Ae[rt] !== $e[ct]) {
              if (rt !== 1 || ct !== 1)
                do
                  if (rt--, ct--, ct < 0 || Ae[rt] !== $e[ct]) {
                    var bt = `
` + Ae[rt].replace(" at new ", " at ");
                    return o.displayName && bt.includes("<anonymous>") && (bt = bt.replace("<anonymous>", o.displayName)), typeof o == "function" && po.set(o, bt), bt;
                  }
                while (rt >= 1 && ct >= 0);
              break;
            }
        }
      } finally {
        ui = !1, si.current = oe, li(), Error.prepareStackTrace = H;
      }
      var on = o ? o.displayName || o.name : "", Fn = on ? ci(on) : "";
      return typeof o == "function" && po.set(o, Fn), Fn;
    }
    function Pl(o, d, k) {
      return Nl(o, !0);
    }
    function Dl(o, d, k) {
      return Nl(o, !1);
    }
    function js(o) {
      var d = o.prototype;
      return !!(d && d.isReactComponent);
    }
    function Oa(o, d, k) {
      if (o == null)
        return "";
      if (typeof o == "function")
        return Nl(o, js(o));
      if (typeof o == "string")
        return ci(o);
      switch (o) {
        case Pa:
          return ci("Suspense");
        case El:
          return ci("SuspenseList");
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case ii:
            return Dl(o.render);
          case Sl:
            return Oa(o.type, d, k);
          case uo: {
            var P = o, H = P._payload, oe = P._init;
            try {
              return Oa(oe(H), d, k);
            } catch {
            }
          }
        }
      return "";
    }
    var _l = {}, ho = n.ReactDebugCurrentFrame;
    function oa(o) {
      if (o) {
        var d = o._owner, k = Oa(o.type, o._source, d ? d.type : null);
        ho.setExtraStackFrame(k);
      } else
        ho.setExtraStackFrame(null);
    }
    function Ol(o, d, k, P, H) {
      {
        var oe = Function.call.bind(C);
        for (var he in o)
          if (oe(o, he)) {
            var Ae = void 0;
            try {
              if (typeof o[he] != "function") {
                var $e = Error((P || "React class") + ": " + k + " type `" + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[he] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw $e.name = "Invariant Violation", $e;
              }
              Ae = o[he](d, he, P, k, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (rt) {
              Ae = rt;
            }
            Ae && !(Ae instanceof Error) && (oa(H), a("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", P || "React class", k, he, typeof Ae), oa(null)), Ae instanceof Error && !(Ae.message in _l) && (_l[Ae.message] = !0, oa(H), a("Failed %s type: %s", k, Ae.message), oa(null));
          }
      }
    }
    var Fl;
    Fl = {};
    var Kr = {};
    Object.freeze(Kr);
    function Us(o, d) {
      {
        var k = o.contextTypes;
        if (!k)
          return Kr;
        var P = {};
        for (var H in k)
          P[H] = d[H];
        {
          var oe = fn(o) || "Unknown";
          Ol(k, P, "context", oe);
        }
        return P;
      }
    }
    function la(o, d, k, P) {
      {
        if (typeof o.getChildContext != "function") {
          {
            var H = fn(d) || "Unknown";
            Fl[H] || (Fl[H] = !0, a("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", H, H));
          }
          return k;
        }
        var oe = o.getChildContext();
        for (var he in oe)
          if (!(he in P))
            throw new Error((fn(d) || "Unknown") + '.getChildContext(): key "' + he + '" is not defined in childContextTypes.');
        {
          var Ae = fn(d) || "Unknown";
          Ol(P, oe, "child context", Ae);
        }
        return cr({}, k, oe);
      }
    }
    var sa;
    sa = {};
    var Ml = null, Tr = null;
    function mo(o) {
      o.context._currentValue2 = o.parentValue;
    }
    function yo(o) {
      o.context._currentValue2 = o.value;
    }
    function di(o, d) {
      if (o !== d) {
        mo(o);
        var k = o.parent, P = d.parent;
        if (k === null) {
          if (P !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (P === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          di(k, P);
        }
        yo(d);
      }
    }
    function zl(o) {
      mo(o);
      var d = o.parent;
      d !== null && zl(d);
    }
    function fi(o) {
      var d = o.parent;
      d !== null && fi(d), yo(o);
    }
    function Ks(o, d) {
      mo(o);
      var k = o.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      k.depth === d.depth ? di(k, d) : Ks(k, d);
    }
    function Ys(o, d) {
      var k = d.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      o.depth === k.depth ? di(o, k) : Ys(o, k), yo(d);
    }
    function go(o) {
      var d = Tr, k = o;
      d !== k && (d === null ? fi(k) : k === null ? zl(d) : d.depth === k.depth ? di(d, k) : d.depth > k.depth ? Ks(d, k) : Ys(d, k), Tr = k);
    }
    function pi(o, d) {
      var k;
      k = o._currentValue2, o._currentValue2 = d, o._currentRenderer2 !== void 0 && o._currentRenderer2 !== null && o._currentRenderer2 !== sa && a("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), o._currentRenderer2 = sa;
      var P = Tr, H = {
        parent: P,
        depth: P === null ? 0 : P.depth + 1,
        context: o,
        parentValue: k,
        value: d
      };
      return Tr = H, H;
    }
    function Bl(o) {
      var d = Tr;
      if (d === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      d.context !== o && a("The parent context is not the expected context. This is probably a bug in React.");
      {
        var k = d.parentValue;
        k === td ? d.context._currentValue2 = d.context._defaultValue : d.context._currentValue2 = k, o._currentRenderer2 !== void 0 && o._currentRenderer2 !== null && o._currentRenderer2 !== sa && a("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), o._currentRenderer2 = sa;
      }
      return Tr = d.parent;
    }
    function nd() {
      return Tr;
    }
    function Fa(o) {
      var d = o._currentValue2;
      return d;
    }
    function vo(o) {
      return o._reactInternals;
    }
    function Il(o, d) {
      o._reactInternals = d;
    }
    var xo = {}, bo = {}, hi, Eo, Ma, mi, So, za, ko, wo, To;
    {
      hi = /* @__PURE__ */ new Set(), Eo = /* @__PURE__ */ new Set(), Ma = /* @__PURE__ */ new Set(), ko = /* @__PURE__ */ new Set(), mi = /* @__PURE__ */ new Set(), wo = /* @__PURE__ */ new Set(), To = /* @__PURE__ */ new Set();
      var Gs = /* @__PURE__ */ new Set();
      za = function(o, d) {
        if (!(o === null || typeof o == "function")) {
          var k = d + "_" + o;
          Gs.has(k) || (Gs.add(k), a("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d, o));
        }
      }, So = function(o, d) {
        if (d === void 0) {
          var k = fn(o) || "Component";
          mi.has(k) || (mi.add(k), a("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", k));
        }
      };
    }
    function Xs(o, d) {
      {
        var k = o.constructor, P = k && fn(k) || "ReactClass", H = P + "." + d;
        if (xo[H])
          return;
        a(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, d, d, P), xo[H] = !0;
      }
    }
    var qs = {
      isMounted: function(o) {
        return !1;
      },
      enqueueSetState: function(o, d, k) {
        var P = vo(o);
        P.queue === null ? Xs(o, "setState") : (P.queue.push(d), k != null && za(k, "setState"));
      },
      enqueueReplaceState: function(o, d, k) {
        var P = vo(o);
        P.replace = !0, P.queue = [d], k != null && za(k, "setState");
      },
      enqueueForceUpdate: function(o, d) {
        var k = vo(o);
        k.queue === null ? Xs(o, "forceUpdate") : d != null && za(d, "setState");
      }
    };
    function rd(o, d, k, P, H) {
      var oe = k(H, P);
      So(d, oe);
      var he = oe == null ? P : cr({}, P, oe);
      return he;
    }
    function ad(o, d, k) {
      var P = Kr, H = o.contextType;
      if ("contextType" in o) {
        var oe = (
          // Allow null for conditional declaration
          H === null || H !== void 0 && H.$$typeof === ai && H._context === void 0
        );
        if (!oe && !To.has(o)) {
          To.add(o);
          var he = "";
          H === void 0 ? he = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof H != "object" ? he = " However, it is set to a " + typeof H + "." : H.$$typeof === ri ? he = " Did you accidentally pass the Context.Provider instead?" : H._context !== void 0 ? he = " Did you accidentally pass the Context.Consumer instead?" : he = " However, it is set to an object with keys {" + Object.keys(H).join(", ") + "}.", a("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", fn(o) || "Component", he);
        }
      }
      typeof H == "object" && H !== null ? P = Fa(H) : P = k;
      var Ae = new o(d, P);
      {
        if (typeof o.getDerivedStateFromProps == "function" && (Ae.state === null || Ae.state === void 0)) {
          var $e = fn(o) || "Component";
          hi.has($e) || (hi.add($e), a("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", $e, Ae.state === null ? "null" : "undefined", $e));
        }
        if (typeof o.getDerivedStateFromProps == "function" || typeof Ae.getSnapshotBeforeUpdate == "function") {
          var rt = null, ct = null, bt = null;
          if (typeof Ae.componentWillMount == "function" && Ae.componentWillMount.__suppressDeprecationWarning !== !0 ? rt = "componentWillMount" : typeof Ae.UNSAFE_componentWillMount == "function" && (rt = "UNSAFE_componentWillMount"), typeof Ae.componentWillReceiveProps == "function" && Ae.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? ct = "componentWillReceiveProps" : typeof Ae.UNSAFE_componentWillReceiveProps == "function" && (ct = "UNSAFE_componentWillReceiveProps"), typeof Ae.componentWillUpdate == "function" && Ae.componentWillUpdate.__suppressDeprecationWarning !== !0 ? bt = "componentWillUpdate" : typeof Ae.UNSAFE_componentWillUpdate == "function" && (bt = "UNSAFE_componentWillUpdate"), rt !== null || ct !== null || bt !== null) {
            var on = fn(o) || "Component", Fn = typeof o.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Ma.has(on) || (Ma.add(on), a(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, on, Fn, rt !== null ? `
  ` + rt : "", ct !== null ? `
  ` + ct : "", bt !== null ? `
  ` + bt : ""));
          }
        }
      }
      return Ae;
    }
    function Zs(o, d, k) {
      {
        var P = fn(d) || "Component", H = o.render;
        H || (d.prototype && typeof d.prototype.render == "function" ? a("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", P) : a("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", P)), o.getInitialState && !o.getInitialState.isReactClassApproved && !o.state && a("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", P), o.getDefaultProps && !o.getDefaultProps.isReactClassApproved && a("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", P), o.propTypes && a("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", P), o.contextType && a("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", P), o.contextTypes && a("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", P), d.contextType && d.contextTypes && !wo.has(d) && (wo.add(d), a("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", P)), typeof o.componentShouldUpdate == "function" && a("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", P), d.prototype && d.prototype.isPureReactComponent && typeof o.shouldComponentUpdate < "u" && a("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", fn(d) || "A pure component"), typeof o.componentDidUnmount == "function" && a("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", P), typeof o.componentDidReceiveProps == "function" && a("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", P), typeof o.componentWillRecieveProps == "function" && a("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", P), typeof o.UNSAFE_componentWillRecieveProps == "function" && a("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", P);
        var oe = o.props !== k;
        o.props !== void 0 && oe && a("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", P, P), o.defaultProps && a("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", P, P), typeof o.getSnapshotBeforeUpdate == "function" && typeof o.componentDidUpdate != "function" && !Eo.has(d) && (Eo.add(d), a("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", fn(d))), typeof o.getDerivedStateFromProps == "function" && a("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", P), typeof o.getDerivedStateFromError == "function" && a("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", P), typeof d.getSnapshotBeforeUpdate == "function" && a("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", P);
        var he = o.state;
        he && (typeof he != "object" || St(he)) && a("%s.state: must be set to an object or null", P), typeof o.getChildContext == "function" && typeof d.childContextTypes != "object" && a("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", P);
      }
    }
    function id(o, d) {
      var k = d.state;
      if (typeof d.componentWillMount == "function") {
        if (d.componentWillMount.__suppressDeprecationWarning !== !0) {
          var P = fn(o) || "Unknown";
          bo[P] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            P
          ), bo[P] = !0);
        }
        d.componentWillMount();
      }
      typeof d.UNSAFE_componentWillMount == "function" && d.UNSAFE_componentWillMount(), k !== d.state && (a("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", fn(o) || "Component"), qs.enqueueReplaceState(d, d.state, null));
    }
    function od(o, d, k, P) {
      if (o.queue !== null && o.queue.length > 0) {
        var H = o.queue, oe = o.replace;
        if (o.queue = null, o.replace = !1, oe && H.length === 1)
          d.state = H[0];
        else {
          for (var he = oe ? H[0] : d.state, Ae = !0, $e = oe ? 1 : 0; $e < H.length; $e++) {
            var rt = H[$e], ct = typeof rt == "function" ? rt.call(d, he, k, P) : rt;
            ct != null && (Ae ? (Ae = !1, he = cr({}, he, ct)) : cr(he, ct));
          }
          d.state = he;
        }
      } else
        o.queue = null;
    }
    function Ro(o, d, k, P) {
      Zs(o, d, k);
      var H = o.state !== void 0 ? o.state : null;
      o.updater = qs, o.props = k, o.state = H;
      var oe = {
        queue: [],
        replace: !1
      };
      Il(o, oe);
      var he = d.contextType;
      if (typeof he == "object" && he !== null ? o.context = Fa(he) : o.context = P, o.state === k) {
        var Ae = fn(d) || "Component";
        ko.has(Ae) || (ko.add(Ae), a("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Ae));
      }
      var $e = d.getDerivedStateFromProps;
      typeof $e == "function" && (o.state = rd(o, d, $e, H, k)), typeof d.getDerivedStateFromProps != "function" && typeof o.getSnapshotBeforeUpdate != "function" && (typeof o.UNSAFE_componentWillMount == "function" || typeof o.componentWillMount == "function") && (id(d, o), od(oe, o, k, P));
    }
    var Co = {
      id: 1,
      overflow: ""
    };
    function ld(o) {
      var d = o.overflow, k = o.id, P = k & ~sd(k);
      return P.toString(32) + d;
    }
    function $l(o, d, k) {
      var P = o.id, H = o.overflow, oe = Ao(P) - 1, he = P & ~(1 << oe), Ae = k + 1, $e = Ao(d) + oe;
      if ($e > 30) {
        var rt = oe - oe % 5, ct = (1 << rt) - 1, bt = (he & ct).toString(32), on = he >> rt, Fn = oe - rt, br = Ao(d) + Fn, xc = Ae << Fn, bc = xc | on, Ec = bt + H;
        return {
          id: 1 << br | bc,
          overflow: Ec
        };
      } else {
        var jo = Ae << oe, vg = jo | he, xg = H;
        return {
          id: 1 << $e | vg,
          overflow: xg
        };
      }
    }
    function Ao(o) {
      return 32 - cd(o);
    }
    function sd(o) {
      return 1 << Ao(o) - 1;
    }
    var cd = Math.clz32 ? Math.clz32 : Or, ud = Math.log, dd = Math.LN2;
    function Or(o) {
      var d = o >>> 0;
      return d === 0 ? 32 : 31 - (ud(d) / dd | 0) | 0;
    }
    function Hl(o, d) {
      return o === d && (o !== 0 || 1 / o === 1 / d) || o !== o && d !== d;
    }
    var Lo = typeof Object.is == "function" ? Object.is : Hl, Dt = null, ca = null, ua = null, Gt = null, gr = !1, da = !1, No = 0, On = null, Fr = 0, fa = 25, Rr = !1, pa;
    function Mr() {
      if (Dt === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Rr && a("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Dt;
    }
    function fd(o, d) {
      if (d === null)
        return a("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", pa), !1;
      o.length !== d.length && a(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, pa, "[" + o.join(", ") + "]", "[" + d.join(", ") + "]");
      for (var k = 0; k < d.length && k < o.length; k++)
        if (!Lo(o[k], d[k]))
          return !1;
      return !0;
    }
    function Qs() {
      if (Fr > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Po() {
      return Gt === null ? ua === null ? (gr = !1, ua = Gt = Qs()) : (gr = !0, Gt = ua) : Gt.next === null ? (gr = !1, Gt = Gt.next = Qs()) : (gr = !0, Gt = Gt.next), Gt;
    }
    function Vl(o, d) {
      Dt = d, ca = o, Rr = !1, No = 0;
    }
    function pd(o, d, k, P) {
      for (; da; )
        da = !1, No = 0, Fr += 1, Gt = null, k = o(d, P);
      return yi(), k;
    }
    function Js() {
      var o = No !== 0;
      return o;
    }
    function yi() {
      Rr = !1, Dt = null, ca = null, da = !1, ua = null, Fr = 0, On = null, Gt = null;
    }
    function hd(o) {
      return Rr && a("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Fa(o);
    }
    function ec(o) {
      return pa = "useContext", Mr(), Fa(o);
    }
    function Do(o, d) {
      return typeof d == "function" ? d(o) : d;
    }
    function md(o) {
      return pa = "useState", tc(
        Do,
        // useReducer has a special case to support lazy useState initializers
        o
      );
    }
    function tc(o, d, k) {
      if (o !== Do && (pa = "useReducer"), Dt = Mr(), Gt = Po(), gr) {
        var P = Gt.queue, H = P.dispatch;
        if (On !== null) {
          var oe = On.get(P);
          if (oe !== void 0) {
            On.delete(P);
            var he = Gt.memoizedState, Ae = oe;
            do {
              var $e = Ae.action;
              Rr = !0, he = o(he, $e), Rr = !1, Ae = Ae.next;
            } while (Ae !== null);
            return Gt.memoizedState = he, [he, H];
          }
        }
        return [Gt.memoizedState, H];
      } else {
        Rr = !0;
        var rt;
        o === Do ? rt = typeof d == "function" ? d() : d : rt = k !== void 0 ? k(d) : d, Rr = !1, Gt.memoizedState = rt;
        var ct = Gt.queue = {
          last: null,
          dispatch: null
        }, bt = ct.dispatch = vd.bind(null, Dt, ct);
        return [Gt.memoizedState, bt];
      }
    }
    function nc(o, d) {
      Dt = Mr(), Gt = Po();
      var k = d === void 0 ? null : d;
      if (Gt !== null) {
        var P = Gt.memoizedState;
        if (P !== null && k !== null) {
          var H = P[1];
          if (fd(k, H))
            return P[0];
        }
      }
      Rr = !0;
      var oe = o();
      return Rr = !1, Gt.memoizedState = [oe, k], oe;
    }
    function yd(o) {
      Dt = Mr(), Gt = Po();
      var d = Gt.memoizedState;
      if (d === null) {
        var k = {
          current: o
        };
        return Object.seal(k), Gt.memoizedState = k, k;
      } else
        return d;
    }
    function gd(o, d) {
      pa = "useLayoutEffect", a("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function vd(o, d, k) {
      if (Fr >= fa)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (o === Dt) {
        da = !0;
        var P = {
          action: k,
          next: null
        };
        On === null && (On = /* @__PURE__ */ new Map());
        var H = On.get(d);
        if (H === void 0)
          On.set(d, P);
        else {
          for (var oe = H; oe.next !== null; )
            oe = oe.next;
          oe.next = P;
        }
      }
    }
    function xd(o, d) {
      return nc(function() {
        return o;
      }, d);
    }
    function bd(o, d, k) {
      return Mr(), d(o._source);
    }
    function Ed(o, d, k) {
      if (k === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return k();
    }
    function Sd(o) {
      return Mr(), o;
    }
    function _o() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function rc() {
      return Mr(), [!1, _o];
    }
    function Wl() {
      var o = ca, d = ld(o.treeContext), k = vi;
      if (k === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var P = No++;
      return pn(k, d, P);
    }
    function gi() {
    }
    var ac = {
      readContext: hd,
      useContext: ec,
      useMemo: nc,
      useReducer: tc,
      useRef: yd,
      useState: md,
      useInsertionEffect: gi,
      useLayoutEffect: gd,
      useCallback: xd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: gi,
      // Effects are not run in the server environment.
      useEffect: gi,
      // Debugging effect
      useDebugValue: gi,
      useDeferredValue: Sd,
      useTransition: rc,
      useId: Wl,
      // Subscriptions are not setup in a server environment.
      useMutableSource: bd,
      useSyncExternalStore: Ed
    }, vi = null;
    function Oo(o) {
      vi = o;
    }
    function jl(o) {
      try {
        var d = "", k = o;
        do {
          switch (k.tag) {
            case 0:
              d += ci(k.type, null, null);
              break;
            case 1:
              d += Dl(k.type, null, null);
              break;
            case 2:
              d += Pl(k.type, null, null);
              break;
          }
          k = k.parent;
        } while (k);
        return d;
      } catch (P) {
        return `
Error generating stack: ` + P.message + `
` + P.stack;
      }
    }
    var Yr = n.ReactCurrentDispatcher, Fo = n.ReactDebugCurrentFrame, Mo = 0, ha = 1, ic = 2, Ul = 3, ma = 4, kd = 0, oc = 1, Cr = 2, wd = 12800;
    function Td(o) {
      return console.error(o), null;
    }
    function xi() {
    }
    function Kl(o, d, k, P, H, oe, he, Ae, $e) {
      var rt = [], ct = /* @__PURE__ */ new Set(), bt = {
        destination: null,
        responseState: d,
        progressiveChunkSize: P === void 0 ? wd : P,
        status: kd,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: ct,
        pingedTasks: rt,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: H === void 0 ? Td : H,
        onAllReady: oe === void 0 ? xi : oe,
        onShellReady: he === void 0 ? xi : he,
        onShellError: Ae === void 0 ? xi : Ae,
        onFatalError: $e === void 0 ? xi : $e
      }, on = Gr(
        bt,
        0,
        null,
        k,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      on.parentFlushed = !0;
      var Fn = bi(bt, o, null, on, ct, Kr, Ml, Co);
      return rt.push(Fn), bt;
    }
    function zo(o, d) {
      var k = o.pingedTasks;
      k.push(d), k.length === 1 && u(function() {
        return gc(o);
      });
    }
    function zr(o, d) {
      return {
        id: _n,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: d,
        errorDigest: null
      };
    }
    function bi(o, d, k, P, H, oe, he, Ae) {
      o.allPendingTasks++, k === null ? o.pendingRootTasks++ : k.pendingTasks++;
      var $e = {
        node: d,
        ping: function() {
          return zo(o, $e);
        },
        blockedBoundary: k,
        blockedSegment: P,
        abortSet: H,
        legacyContext: oe,
        context: he,
        treeContext: Ae
      };
      return $e.componentStack = null, H.add($e), $e;
    }
    function Gr(o, d, k, P, H, oe) {
      return {
        status: Mo,
        id: -1,
        // lazily assigned later
        index: d,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: P,
        boundary: k,
        lastPushedText: H,
        textEmbedded: oe
      };
    }
    var Ar = null;
    function Yl() {
      return Ar === null || Ar.componentStack === null ? "" : jl(Ar.componentStack);
    }
    function vr(o, d) {
      o.componentStack = {
        tag: 0,
        parent: o.componentStack,
        type: d
      };
    }
    function Ba(o, d) {
      o.componentStack = {
        tag: 1,
        parent: o.componentStack,
        type: d
      };
    }
    function Gl(o, d) {
      o.componentStack = {
        tag: 2,
        parent: o.componentStack,
        type: d
      };
    }
    function xr(o) {
      o.componentStack === null ? a("Unexpectedly popped too many stack frames. This is a bug in React.") : o.componentStack = o.componentStack.parent;
    }
    var Xr = null;
    function Xl(o, d) {
      {
        var k;
        typeof d == "string" ? k = d : d && typeof d.message == "string" ? k = d.message : k = String(d);
        var P = Xr || Yl();
        Xr = null, o.errorMessage = k, o.errorComponentStack = P;
      }
    }
    function Ei(o, d) {
      var k = o.onError(d);
      if (k != null && typeof k != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof k + '" instead');
      return k;
    }
    function Bo(o, d) {
      var k = o.onShellError;
      k(d);
      var P = o.onFatalError;
      P(d), o.destination !== null ? (o.status = Cr, y(o.destination, d)) : (o.status = oc, o.fatalError = d);
    }
    function lc(o, d, k) {
      vr(d, "Suspense");
      var P = d.blockedBoundary, H = d.blockedSegment, oe = k.fallback, he = k.children, Ae = /* @__PURE__ */ new Set(), $e = zr(o, Ae), rt = H.chunks.length, ct = Gr(
        o,
        rt,
        $e,
        H.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      H.children.push(ct), H.lastPushedText = !1;
      var bt = Gr(
        o,
        0,
        null,
        H.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      bt.parentFlushed = !0, d.blockedBoundary = $e, d.blockedSegment = bt;
      try {
        if (Io(o, d, he), Fs(bt.chunks, o.responseState, bt.lastPushedText, bt.textEmbedded), bt.status = ha, wi($e, bt), $e.pendingTasks === 0) {
          xr(d);
          return;
        }
      } catch (Fn) {
        bt.status = ma, $e.forceClientRender = !0, $e.errorDigest = Ei(o, Fn), Xl($e, Fn);
      } finally {
        d.blockedBoundary = P, d.blockedSegment = H;
      }
      var on = bi(o, oe, P, ct, Ae, d.legacyContext, d.context, d.treeContext);
      on.componentStack = d.componentStack, o.pingedTasks.push(on), xr(d);
    }
    function sc(o, d, k, P) {
      vr(d, k);
      var H = d.blockedSegment, oe = kr(H.chunks, k, P, o.responseState, H.formatContext);
      H.lastPushedText = !1;
      var he = H.formatContext;
      H.formatContext = tr(he, k, P), Io(o, d, oe), H.formatContext = he, or(H.chunks, k), H.lastPushedText = !1, xr(d);
    }
    function Rd(o) {
      return o.prototype && o.prototype.isReactComponent;
    }
    function ql(o, d, k, P, H) {
      var oe = {};
      Vl(d, oe);
      var he = k(P, H);
      return pd(k, P, he, H);
    }
    function Si(o, d, k, P, H) {
      var oe = k.render();
      k.props !== H && (es || a("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", fn(P) || "a component"), es = !0);
      {
        var he = P.childContextTypes;
        if (he != null) {
          var Ae = d.legacyContext, $e = la(k, P, Ae, he);
          d.legacyContext = $e, dr(o, d, oe), d.legacyContext = Ae;
          return;
        }
      }
      dr(o, d, oe);
    }
    function cc(o, d, k, P) {
      Gl(d, k);
      var H = Us(k, d.legacyContext), oe = ad(k, P, H);
      Ro(oe, k, P, H), Si(o, d, oe, k, P), xr(d);
    }
    var Zl = {}, ki = {}, Ql = {}, Jl = {}, es = !1, uc = !1, dc = !1, ts = !1;
    function Cd(o, d, k, P) {
      var H;
      if (H = Us(k, d.legacyContext), Ba(d, k), k.prototype && typeof k.prototype.render == "function") {
        var oe = fn(k) || "Unknown";
        Zl[oe] || (a("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", oe, oe), Zl[oe] = !0);
      }
      var he = ql(o, d, k, P, H), Ae = Js();
      if (typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0) {
        var $e = fn(k) || "Unknown";
        ki[$e] || (a("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", $e, $e, $e), ki[$e] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0
      ) {
        {
          var rt = fn(k) || "Unknown";
          ki[rt] || (a("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", rt, rt, rt), ki[rt] = !0);
        }
        Ro(he, k, P, H), Si(o, d, he, k, P);
      } else if (Ad(k), Ae) {
        var ct = d.treeContext, bt = 1, on = 0;
        d.treeContext = $l(ct, bt, on);
        try {
          dr(o, d, he);
        } finally {
          d.treeContext = ct;
        }
      } else
        dr(o, d, he);
      xr(d);
    }
    function Ad(o) {
      {
        if (o && o.childContextTypes && a("%s(...): childContextTypes cannot be defined on a function component.", o.displayName || o.name || "Component"), typeof o.getDerivedStateFromProps == "function") {
          var d = fn(o) || "Unknown";
          Jl[d] || (a("%s: Function components do not support getDerivedStateFromProps.", d), Jl[d] = !0);
        }
        if (typeof o.contextType == "object" && o.contextType !== null) {
          var k = fn(o) || "Unknown";
          Ql[k] || (a("%s: Function components do not support contextType.", k), Ql[k] = !0);
        }
      }
    }
    function fc(o, d) {
      if (o && o.defaultProps) {
        var k = cr({}, d), P = o.defaultProps;
        for (var H in P)
          k[H] === void 0 && (k[H] = P[H]);
        return k;
      }
      return d;
    }
    function Ld(o, d, k, P, H) {
      Ba(d, k.render);
      var oe = ql(o, d, k.render, P, H), he = Js();
      if (he) {
        var Ae = d.treeContext, $e = 1, rt = 0;
        d.treeContext = $l(Ae, $e, rt);
        try {
          dr(o, d, oe);
        } finally {
          d.treeContext = Ae;
        }
      } else
        dr(o, d, oe);
      xr(d);
    }
    function Nd(o, d, k, P, H) {
      var oe = k.type, he = fc(oe, P);
      rs(o, d, oe, he, H);
    }
    function ns(o, d, k, P) {
      k._context === void 0 ? k !== k.Consumer && (ts || (ts = !0, a("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : k = k._context;
      var H = P.children;
      typeof H != "function" && a("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var oe = Fa(k), he = H(oe);
      dr(o, d, he);
    }
    function Pd(o, d, k, P) {
      var H = k._context, oe = P.value, he = P.children, Ae;
      Ae = d.context, d.context = pi(H, oe), dr(o, d, he), d.context = Bl(H), Ae !== d.context && a("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function ur(o, d, k, P, H) {
      vr(d, "Lazy");
      var oe = k._payload, he = k._init, Ae = he(oe), $e = fc(Ae, P);
      rs(o, d, Ae, $e, H), xr(d);
    }
    function rs(o, d, k, P, H) {
      if (typeof k == "function")
        if (Rd(k)) {
          cc(o, d, k, P);
          return;
        } else {
          Cd(o, d, k, P);
          return;
        }
      if (typeof k == "string") {
        sc(o, d, k, P);
        return;
      }
      switch (k) {
        case ed:
        case Bs:
        case so:
        case co:
        case lo: {
          dr(o, d, P.children);
          return;
        }
        case El: {
          vr(d, "SuspenseList"), dr(o, d, P.children), xr(d);
          return;
        }
        case Ju:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Pa: {
          lc(o, d, P);
          return;
        }
      }
      if (typeof k == "object" && k !== null)
        switch (k.$$typeof) {
          case ii: {
            Ld(o, d, k, P, H);
            return;
          }
          case Sl: {
            Nd(o, d, k, P, H);
            return;
          }
          case ri: {
            Pd(o, d, k, P);
            return;
          }
          case ai: {
            ns(o, d, k, P);
            return;
          }
          case uo: {
            ur(o, d, k, P);
            return;
          }
        }
      var oe = "";
      throw (k === void 0 || typeof k == "object" && k !== null && Object.keys(k).length === 0) && (oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (k == null ? k : typeof k) + "." + oe));
    }
    function pc(o, d) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      o[Symbol.toStringTag] === "Generator" && (uc || a("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), uc = !0), o.entries === d && (dc || a("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), dc = !0);
    }
    function dr(o, d, k) {
      try {
        return as(o, d, k);
      } catch (P) {
        throw typeof P == "object" && P !== null && typeof P.then == "function" || (Xr = Xr !== null ? Xr : Yl()), P;
      }
    }
    function as(o, d, k) {
      if (d.node = k, typeof k == "object" && k !== null) {
        switch (k.$$typeof) {
          case zs: {
            var P = k, H = P.type, oe = P.props, he = P.ref;
            rs(o, d, H, oe, he);
            return;
          }
          case bl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case uo: {
            var Ae = k, $e = Ae._payload, rt = Ae._init, ct;
            try {
              ct = rt($e);
            } catch (jo) {
              throw typeof jo == "object" && jo !== null && typeof jo.then == "function" && vr(d, "Lazy"), jo;
            }
            dr(o, d, ct);
            return;
          }
        }
        if (St(k)) {
          hc(o, d, k);
          return;
        }
        var bt = hn(k);
        if (bt) {
          pc(k, bt);
          var on = bt.call(k);
          if (on) {
            var Fn = on.next();
            if (!Fn.done) {
              var br = [];
              do
                br.push(Fn.value), Fn = on.next();
              while (!Fn.done);
              hc(o, d, br);
              return;
            }
            return;
          }
        }
        var xc = Object.prototype.toString.call(k);
        throw new Error("Objects are not valid as a React child (found: " + (xc === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : xc) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof k == "string") {
        var bc = d.blockedSegment;
        bc.lastPushedText = Os(d.blockedSegment.chunks, k, o.responseState, bc.lastPushedText);
        return;
      }
      if (typeof k == "number") {
        var Ec = d.blockedSegment;
        Ec.lastPushedText = Os(d.blockedSegment.chunks, "" + k, o.responseState, Ec.lastPushedText);
        return;
      }
      typeof k == "function" && a("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function hc(o, d, k) {
      for (var P = k.length, H = 0; H < P; H++) {
        var oe = d.treeContext;
        d.treeContext = $l(oe, P, H);
        try {
          Io(o, d, k[H]);
        } finally {
          d.treeContext = oe;
        }
      }
    }
    function Dd(o, d, k) {
      var P = d.blockedSegment, H = P.chunks.length, oe = Gr(
        o,
        H,
        null,
        P.formatContext,
        // Adopt the parent segment's leading text embed
        P.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      P.children.push(oe), P.lastPushedText = !1;
      var he = bi(o, d.node, d.blockedBoundary, oe, d.abortSet, d.legacyContext, d.context, d.treeContext);
      d.componentStack !== null && (he.componentStack = d.componentStack.parent);
      var Ae = he.ping;
      k.then(Ae, Ae);
    }
    function Io(o, d, k) {
      var P = d.blockedSegment.formatContext, H = d.legacyContext, oe = d.context, he = null;
      he = d.componentStack;
      try {
        return dr(o, d, k);
      } catch (Ae) {
        if (yi(), typeof Ae == "object" && Ae !== null && typeof Ae.then == "function") {
          Dd(o, d, Ae), d.blockedSegment.formatContext = P, d.legacyContext = H, d.context = oe, go(oe), d.componentStack = he;
          return;
        } else
          throw d.blockedSegment.formatContext = P, d.legacyContext = H, d.context = oe, go(oe), d.componentStack = he, Ae;
      }
    }
    function $o(o, d, k, P) {
      var H = Ei(o, P);
      if (d === null ? Bo(o, P) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = H, Xl(d, P), d.parentFlushed && o.clientRenderedBoundaries.push(d))), o.allPendingTasks--, o.allPendingTasks === 0) {
        var oe = o.onAllReady;
        oe();
      }
    }
    function mc(o) {
      var d = this, k = o.blockedBoundary, P = o.blockedSegment;
      P.status = Ul, Ti(d, k, P);
    }
    function yc(o, d, k) {
      var P = o.blockedBoundary, H = o.blockedSegment;
      if (H.status = Ul, P === null)
        d.allPendingTasks--, d.status !== Cr && (d.status = Cr, d.destination !== null && g(d.destination));
      else {
        if (P.pendingTasks--, !P.forceClientRender) {
          P.forceClientRender = !0;
          var oe = k === void 0 ? new Error("The render was aborted by the server without a reason.") : k;
          P.errorDigest = d.onError(oe);
          {
            var he = "The server did not finish this Suspense boundary: ";
            oe && typeof oe.message == "string" ? oe = he + oe.message : oe = he + String(oe);
            var Ae = Ar;
            Ar = o;
            try {
              Xl(P, oe);
            } finally {
              Ar = Ae;
            }
          }
          P.parentFlushed && d.clientRenderedBoundaries.push(P);
        }
        if (P.fallbackAbortableTasks.forEach(function(rt) {
          return yc(rt, d, k);
        }), P.fallbackAbortableTasks.clear(), d.allPendingTasks--, d.allPendingTasks === 0) {
          var $e = d.onAllReady;
          $e();
        }
      }
    }
    function wi(o, d) {
      if (d.chunks.length === 0 && d.children.length === 1 && d.children[0].boundary === null) {
        var k = d.children[0];
        k.id = d.id, k.parentFlushed = !0, k.status === ha && wi(o, k);
      } else {
        var P = o.completedSegments;
        P.push(d);
      }
    }
    function Ti(o, d, k) {
      if (d === null) {
        if (k.parentFlushed) {
          if (o.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          o.completedRootSegment = k;
        }
        if (o.pendingRootTasks--, o.pendingRootTasks === 0) {
          o.onShellError = xi;
          var P = o.onShellReady;
          P();
        }
      } else if (d.pendingTasks--, !d.forceClientRender) {
        if (d.pendingTasks === 0)
          k.parentFlushed && k.status === ha && wi(d, k), d.parentFlushed && o.completedBoundaries.push(d), d.fallbackAbortableTasks.forEach(mc, o), d.fallbackAbortableTasks.clear();
        else if (k.parentFlushed && k.status === ha) {
          wi(d, k);
          var H = d.completedSegments;
          H.length === 1 && d.parentFlushed && o.partialBoundaries.push(d);
        }
      }
      if (o.allPendingTasks--, o.allPendingTasks === 0) {
        var oe = o.onAllReady;
        oe();
      }
    }
    function Ho(o, d) {
      var k = d.blockedSegment;
      if (k.status === Mo) {
        go(d.context);
        var P = null;
        P = Ar, Ar = d;
        try {
          dr(o, d, d.node), Fs(k.chunks, o.responseState, k.lastPushedText, k.textEmbedded), d.abortSet.delete(d), k.status = ha, Ti(o, d.blockedBoundary, k);
        } catch (oe) {
          if (yi(), typeof oe == "object" && oe !== null && typeof oe.then == "function") {
            var H = d.ping;
            oe.then(H, H);
          } else
            d.abortSet.delete(d), k.status = ma, $o(o, d.blockedBoundary, k, oe);
        } finally {
          Ar = P;
        }
      }
    }
    function gc(o) {
      if (o.status !== Cr) {
        var d = nd(), k = Yr.current;
        Yr.current = ac;
        var P;
        P = Fo.getCurrentStack, Fo.getCurrentStack = Yl;
        var H = vi;
        Oo(o.responseState);
        try {
          var oe = o.pingedTasks, he;
          for (he = 0; he < oe.length; he++) {
            var Ae = oe[he];
            Ho(o, Ae);
          }
          oe.splice(0, he), o.destination !== null && Wo(o, o.destination);
        } catch ($e) {
          Ei(o, $e), Bo(o, $e);
        } finally {
          Oo(H), Yr.current = k, Fo.getCurrentStack = P, k === ac && go(d);
        }
      }
    }
    function Ri(o, d, k) {
      switch (k.parentFlushed = !0, k.status) {
        case Mo: {
          var P = k.id = o.nextSegmentId++;
          return k.lastPushedText = !1, k.textEmbedded = !1, Gi(d, o.responseState, P);
        }
        case ha: {
          k.status = ic;
          for (var H = !0, oe = k.chunks, he = 0, Ae = k.children, $e = 0; $e < Ae.length; $e++) {
            for (var rt = Ae[$e]; he < rt.index; he++)
              l(d, oe[he]);
            H = Ci(o, d, rt);
          }
          for (; he < oe.length - 1; he++)
            l(d, oe[he]);
          return he < oe.length && (H = p(d, oe[he])), H;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ci(o, d, k) {
      var P = k.boundary;
      if (P === null)
        return Ri(o, d, k);
      if (P.parentFlushed = !0, P.forceClientRender)
        return yr(d, o.responseState, P.errorDigest, P.errorMessage, P.errorComponentStack), Ri(o, d, k), Ms(d, o.responseState);
      if (P.pendingTasks > 0) {
        P.rootSegmentID = o.nextSegmentId++, P.completedSegments.length > 0 && o.partialBoundaries.push(P);
        var H = P.id = Rn(o.responseState);
        return Ur(d, o.responseState, H), Ri(o, d, k), ei(d, o.responseState);
      } else {
        if (P.byteSize > o.progressiveChunkSize)
          return P.rootSegmentID = o.nextSegmentId++, o.completedBoundaries.push(P), Ur(d, o.responseState, P.id), Ri(o, d, k), ei(d, o.responseState);
        xl(d, o.responseState);
        var oe = P.completedSegments;
        if (oe.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var he = oe[0];
        return Ci(o, d, he), Qu(d, o.responseState);
      }
    }
    function _d(o, d, k) {
      return Xu(d, o.responseState, k.id, k.errorDigest, k.errorMessage, k.errorComponentStack);
    }
    function is(o, d, k) {
      return ke(d, o.responseState, k.formatContext, k.id), Ci(o, d, k), Oe(d, k.formatContext);
    }
    function Vo(o, d, k) {
      for (var P = k.completedSegments, H = 0; H < P.length; H++) {
        var oe = P[H];
        vc(o, d, k, oe);
      }
      return P.length = 0, ju(d, o.responseState, k.id, k.rootSegmentID);
    }
    function Od(o, d, k) {
      for (var P = k.completedSegments, H = 0; H < P.length; H++) {
        var oe = P[H];
        if (!vc(o, d, k, oe))
          return H++, P.splice(0, H), !1;
      }
      return P.splice(0, H), !0;
    }
    function vc(o, d, k, P) {
      if (P.status === ic)
        return !0;
      var H = P.id;
      if (H === -1) {
        var oe = P.id = k.rootSegmentID;
        if (oe === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return is(o, d, P);
      } else
        return is(o, d, P), sr(d, o.responseState, H);
    }
    function Wo(o, d) {
      try {
        var k = o.completedRootSegment;
        k !== null && o.pendingRootTasks === 0 && (Ci(o, d, k), o.completedRootSegment = null, qa(d, o.responseState));
        var P = o.clientRenderedBoundaries, H;
        for (H = 0; H < P.length; H++) {
          var oe = P[H];
          if (!_d(o, d, oe)) {
            o.destination = null, H++, P.splice(0, H);
            return;
          }
        }
        P.splice(0, H);
        var he = o.completedBoundaries;
        for (H = 0; H < he.length; H++) {
          var Ae = he[H];
          if (!Vo(o, d, Ae)) {
            o.destination = null, H++, he.splice(0, H);
            return;
          }
        }
        he.splice(0, H);
        var $e = o.partialBoundaries;
        for (H = 0; H < $e.length; H++) {
          var rt = $e[H];
          if (!Od(o, d, rt)) {
            o.destination = null, H++, $e.splice(0, H);
            return;
          }
        }
        $e.splice(0, H);
        var ct = o.completedBoundaries;
        for (H = 0; H < ct.length; H++) {
          var bt = ct[H];
          if (!Vo(o, d, bt)) {
            o.destination = null, H++, ct.splice(0, H);
            return;
          }
        }
        ct.splice(0, H);
      } finally {
        o.allPendingTasks === 0 && o.pingedTasks.length === 0 && o.clientRenderedBoundaries.length === 0 && o.completedBoundaries.length === 0 && (o.abortableTasks.size !== 0 && a("There was still abortable task at the root when we closed. This is a bug in React."), g(d));
      }
    }
    function Fd(o) {
      u(function() {
        return gc(o);
      });
    }
    function s(o, d) {
      if (o.status === oc) {
        o.status = Cr, y(d, o.fatalError);
        return;
      }
      if (o.status !== Cr && o.destination === null) {
        o.destination = d;
        try {
          Wo(o, d);
        } catch (k) {
          Ei(o, k), Bo(o, k);
        }
      }
    }
    function f(o, d) {
      try {
        var k = o.abortableTasks;
        k.forEach(function(P) {
          return yc(P, o, d);
        }), k.clear(), o.destination !== null && Wo(o, o.destination);
      } catch (P) {
        Ei(o, P), Bo(o, P);
      }
    }
    function T() {
    }
    function M(o, d, k, P) {
      var H = !1, oe = null, he = "", Ae = {
        push: function(bt) {
          return bt !== null && (he += bt), !0;
        },
        destroy: function(bt) {
          H = !0, oe = bt;
        }
      }, $e = !1;
      function rt() {
        $e = !0;
      }
      var ct = Kl(o, Zu(k, d ? d.identifierPrefix : void 0), vl(), 1 / 0, T, void 0, rt, void 0, void 0);
      if (Fd(ct), f(ct, P), s(ct, Ae), H)
        throw oe;
      if (!$e)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return he;
    }
    function X(o, d) {
      return M(o, d, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function de(o, d) {
      return M(o, d, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function ye() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Le() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Di.renderToNodeStream = ye, Di.renderToStaticMarkup = de, Di.renderToStaticNodeStream = Le, Di.renderToString = X, Di.version = t;
  }()), Di;
}
var Mc = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nm;
function bS() {
  return nm || (nm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ue, t = "18.2.0", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(s) {
      {
        for (var f = arguments.length, T = new Array(f > 1 ? f - 1 : 0), M = 1; M < f; M++)
          T[M - 1] = arguments[M];
        i("warn", s, T);
      }
    }
    function a(s) {
      {
        for (var f = arguments.length, T = new Array(f > 1 ? f - 1 : 0), M = 1; M < f; M++)
          T[M - 1] = arguments[M];
        i("error", s, T);
      }
    }
    function i(s, f, T) {
      {
        var M = n.ReactDebugCurrentFrame, X = M.getStackAddendum();
        X !== "" && (f += "%s", T = T.concat([X]));
        var de = T.map(function(ye) {
          return String(ye);
        });
        de.unshift("Warning: " + f), Function.prototype.apply.call(console[s], console, de);
      }
    }
    function u(s) {
      s();
    }
    var c = 512, l = null, p = 0;
    function h(s) {
      l = new Uint8Array(c), p = 0;
    }
    function g(s, f) {
      if (f.length !== 0) {
        if (f.length > c) {
          p > 0 && (s.enqueue(new Uint8Array(l.buffer, 0, p)), l = new Uint8Array(c), p = 0), s.enqueue(f);
          return;
        }
        var T = f, M = l.length - p;
        M < T.length && (M === 0 ? s.enqueue(l) : (l.set(T.subarray(0, M), p), s.enqueue(l), T = T.subarray(M)), l = new Uint8Array(c), p = 0), l.set(T, p), p += T.length;
      }
    }
    function x(s, f) {
      return g(s, f), !0;
    }
    function w(s) {
      l && p > 0 && (s.enqueue(new Uint8Array(l.buffer, 0, p)), l = null, p = 0);
    }
    function y(s) {
      s.close();
    }
    var R = new TextEncoder();
    function b(s) {
      return R.encode(s);
    }
    function v(s) {
      return R.encode(s);
    }
    function A(s, f) {
      typeof s.error == "function" ? s.error(f) : s.close();
    }
    function N(s) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, T = f && s[Symbol.toStringTag] || s.constructor.name || "Object";
        return T;
      }
    }
    function L(s) {
      try {
        return C(s), !1;
      } catch {
        return !0;
      }
    }
    function C(s) {
      return "" + s;
    }
    function z(s, f) {
      if (L(s))
        return a("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", f, N(s)), C(s);
    }
    function W(s, f) {
      if (L(s))
        return a("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", f, N(s)), C(s);
    }
    function q(s) {
      if (L(s))
        return a("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", N(s)), C(s);
    }
    var ne = Object.prototype.hasOwnProperty, G = 0, le = 1, K = 2, re = 3, B = 4, j = 5, se = 6, ee = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Q = ee + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Z = new RegExp("^[" + ee + "][" + Q + "]*$"), Y = {}, te = {};
    function $(s) {
      return ne.call(te, s) ? !0 : ne.call(Y, s) ? !1 : Z.test(s) ? (te[s] = !0, !0) : (Y[s] = !0, a("Invalid attribute name: `%s`", s), !1);
    }
    function ce(s, f, T, M) {
      if (T !== null && T.type === G)
        return !1;
      switch (typeof f) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (M)
            return !1;
          if (T !== null)
            return !T.acceptsBooleans;
          var X = s.toLowerCase().slice(0, 5);
          return X !== "data-" && X !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Se(s) {
      return ve.hasOwnProperty(s) ? ve[s] : null;
    }
    function be(s, f, T, M, X, de, ye) {
      this.acceptsBooleans = f === K || f === re || f === B, this.attributeName = M, this.attributeNamespace = X, this.mustUseProperty = T, this.propertyName = s, this.type = f, this.sanitizeURL = de, this.removeEmptyString = ye;
    }
    var ve = {}, Pe = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Pe.forEach(function(s) {
      ve[s] = new be(
        s,
        G,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(s) {
      var f = s[0], T = s[1];
      ve[f] = new be(
        f,
        le,
        !1,
        // mustUseProperty
        T,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
      ve[s] = new be(
        s,
        K,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
      ve[s] = new be(
        s,
        K,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(s) {
      ve[s] = new be(
        s,
        re,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      ve[s] = new be(
        s,
        re,
        !0,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      ve[s] = new be(
        s,
        B,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      ve[s] = new be(
        s,
        se,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(s) {
      ve[s] = new be(
        s,
        j,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Ve = /[\-\:]([a-z])/g, we = function(s) {
      return s[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var f = s.replace(Ve, we);
      ve[f] = new be(
        f,
        le,
        !1,
        // mustUseProperty
        s,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var f = s.replace(Ve, we);
      ve[f] = new be(
        f,
        le,
        !1,
        // mustUseProperty
        s,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var f = s.replace(Ve, we);
      ve[f] = new be(
        f,
        le,
        !1,
        // mustUseProperty
        s,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(s) {
      ve[s] = new be(
        s,
        le,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var me = "xlinkHref";
    ve[me] = new be(
      "xlinkHref",
      le,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(s) {
      ve[s] = new be(
        s,
        le,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ce = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function fe(s, f) {
      return s + f.charAt(0).toUpperCase() + f.substring(1);
    }
    var ze = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Ce).forEach(function(s) {
      ze.forEach(function(f) {
        Ce[fe(f, s)] = Ce[s];
      });
    });
    var Ie = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Qe(s, f) {
      Ie[f.type] || f.onChange || f.onInput || f.readOnly || f.disabled || f.value == null || a("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), f.onChange || f.readOnly || f.disabled || f.checked == null || a("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function He(s, f) {
      if (s.indexOf("-") === -1)
        return typeof f.is == "string";
      switch (s) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Fe = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, qe = {}, We = new RegExp("^(aria)-[" + Q + "]*$"), je = new RegExp("^(aria)[A-Z][" + Q + "]*$");
    function Ke(s, f) {
      {
        if (ne.call(qe, f) && qe[f])
          return !0;
        if (je.test(f)) {
          var T = "aria-" + f.slice(4).toLowerCase(), M = Fe.hasOwnProperty(T) ? T : null;
          if (M == null)
            return a("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", f), qe[f] = !0, !0;
          if (f !== M)
            return a("Invalid ARIA attribute `%s`. Did you mean `%s`?", f, M), qe[f] = !0, !0;
        }
        if (We.test(f)) {
          var X = f.toLowerCase(), de = Fe.hasOwnProperty(X) ? X : null;
          if (de == null)
            return qe[f] = !0, !1;
          if (f !== de)
            return a("Unknown ARIA attribute `%s`. Did you mean `%s`?", f, de), qe[f] = !0, !0;
        }
      }
      return !0;
    }
    function Te(s, f) {
      {
        var T = [];
        for (var M in f) {
          var X = Ke(s, M);
          X || T.push(M);
        }
        var de = T.map(function(ye) {
          return "`" + ye + "`";
        }).join(", ");
        T.length === 1 ? a("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", de, s) : T.length > 1 && a("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", de, s);
      }
    }
    function _e(s, f) {
      He(s, f) || Te(s, f);
    }
    var at = !1;
    function ge(s, f) {
      {
        if (s !== "input" && s !== "textarea" && s !== "select")
          return;
        f != null && f.value === null && !at && (at = !0, s === "select" && f.multiple ? a("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", s) : a("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", s));
      }
    }
    var ft = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, ot = function() {
    };
    {
      var it = {}, wt = /^on./, Wt = /^on[^A-Z]/, Kt = new RegExp("^(aria)-[" + Q + "]*$"), Mt = new RegExp("^(aria)[A-Z][" + Q + "]*$");
      ot = function(s, f, T, M) {
        if (ne.call(it, f) && it[f])
          return !0;
        var X = f.toLowerCase();
        if (X === "onfocusin" || X === "onfocusout")
          return a("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), it[f] = !0, !0;
        if (M != null) {
          var de = M.registrationNameDependencies, ye = M.possibleRegistrationNames;
          if (de.hasOwnProperty(f))
            return !0;
          var Le = ye.hasOwnProperty(X) ? ye[X] : null;
          if (Le != null)
            return a("Invalid event handler property `%s`. Did you mean `%s`?", f, Le), it[f] = !0, !0;
          if (wt.test(f))
            return a("Unknown event handler property `%s`. It will be ignored.", f), it[f] = !0, !0;
        } else if (wt.test(f))
          return Wt.test(f) && a("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", f), it[f] = !0, !0;
        if (Kt.test(f) || Mt.test(f))
          return !0;
        if (X === "innerhtml")
          return a("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), it[f] = !0, !0;
        if (X === "aria")
          return a("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), it[f] = !0, !0;
        if (X === "is" && T !== null && T !== void 0 && typeof T != "string")
          return a("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof T), it[f] = !0, !0;
        if (typeof T == "number" && isNaN(T))
          return a("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", f), it[f] = !0, !0;
        var o = Se(f), d = o !== null && o.type === G;
        if (ft.hasOwnProperty(X)) {
          var k = ft[X];
          if (k !== f)
            return a("Invalid DOM property `%s`. Did you mean `%s`?", f, k), it[f] = !0, !0;
        } else if (!d && f !== X)
          return a("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", f, X), it[f] = !0, !0;
        return typeof T == "boolean" && ce(f, T, o, !1) ? (T ? a('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', T, f, f, T, f) : a('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', T, f, f, T, f, f, f), it[f] = !0, !0) : d ? !0 : ce(f, T, o, !1) ? (it[f] = !0, !1) : ((T === "false" || T === "true") && o !== null && o.type === re && (a("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", T, f, T === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', f, T), it[f] = !0), !0);
      };
    }
    var rn = function(s, f, T) {
      {
        var M = [];
        for (var X in f) {
          var de = ot(s, X, f[X], T);
          de || M.push(X);
        }
        var ye = M.map(function(Le) {
          return "`" + Le + "`";
        }).join(", ");
        M.length === 1 ? a("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", ye, s) : M.length > 1 && a("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", ye, s);
      }
    };
    function Et(s, f, T) {
      He(s, f) || rn(s, f, T);
    }
    var Pt = function() {
    };
    {
      var Nt = /^(?:webkit|moz|o)[A-Z]/, tn = /^-ms-/, sn = /-(.)/g, Ot = /;\s*$/, Ft = {}, nn = {}, et = !1, ut = !1, Ne = function(s) {
        return s.replace(sn, function(f, T) {
          return T.toUpperCase();
        });
      }, De = function(s) {
        Ft.hasOwnProperty(s) && Ft[s] || (Ft[s] = !0, a(
          "Unsupported style property %s. Did you mean %s?",
          s,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Ne(s.replace(tn, "ms-"))
        ));
      }, Ee = function(s) {
        Ft.hasOwnProperty(s) && Ft[s] || (Ft[s] = !0, a("Unsupported vendor-prefixed style property %s. Did you mean %s?", s, s.charAt(0).toUpperCase() + s.slice(1)));
      }, pt = function(s, f) {
        nn.hasOwnProperty(f) && nn[f] || (nn[f] = !0, a(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, s, f.replace(Ot, "")));
      }, nt = function(s, f) {
        et || (et = !0, a("`NaN` is an invalid value for the `%s` css style property.", s));
      }, gt = function(s, f) {
        ut || (ut = !0, a("`Infinity` is an invalid value for the `%s` css style property.", s));
      };
      Pt = function(s, f) {
        s.indexOf("-") > -1 ? De(s) : Nt.test(s) ? Ee(s) : Ot.test(f) && pt(s, f), typeof f == "number" && (isNaN(f) ? nt(s, f) : isFinite(f) || gt(s, f));
      };
    }
    var xt = Pt, Yt = /["'&<>]/;
    function lt(s) {
      q(s);
      var f = "" + s, T = Yt.exec(f);
      if (!T)
        return f;
      var M, X = "", de, ye = 0;
      for (de = T.index; de < f.length; de++) {
        switch (f.charCodeAt(de)) {
          case 34:
            M = "&quot;";
            break;
          case 38:
            M = "&amp;";
            break;
          case 39:
            M = "&#x27;";
            break;
          case 60:
            M = "&lt;";
            break;
          case 62:
            M = "&gt;";
            break;
          default:
            continue;
        }
        ye !== de && (X += f.substring(ye, de)), ye = de + 1, X += M;
      }
      return ye !== de ? X + f.substring(ye, de) : X;
    }
    function st(s) {
      return typeof s == "boolean" || typeof s == "number" ? "" + s : lt(s);
    }
    var $t = /([A-Z])/g, jt = /^ms-/;
    function Rt(s) {
      return s.replace($t, "-$1").toLowerCase().replace(jt, "-ms-");
    }
    var St = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, yn = !1;
    function vn(s) {
      !yn && St.test(s) && (yn = !0, a("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(s)));
    }
    var wn = Array.isArray;
    function Pn(s) {
      return wn(s);
    }
    var Tn = v("<script>"), er = v("<\/script>"), Dn = v('<script src="'), xn = v('<script type="module" src="'), At = v('" async=""><\/script>');
    function Ht(s) {
      return q(s), ("" + s).replace(bn, Qt);
    }
    var bn = /(<\/|<)(s)(cript)/gi, Qt = function(s, f, T, M) {
      return "" + f + (T === "s" ? "\\u0073" : "\\u0053") + M;
    };
    function cn(s, f, T, M, X) {
      var de = s === void 0 ? "" : s, ye = f === void 0 ? Tn : v('<script nonce="' + st(f) + '">'), Le = [];
      if (T !== void 0 && Le.push(ye, b(Ht(T)), er), M !== void 0)
        for (var o = 0; o < M.length; o++)
          Le.push(Dn, b(st(M[o])), At);
      if (X !== void 0)
        for (var d = 0; d < X.length; d++)
          Le.push(xn, b(st(X[d])), At);
      return {
        bootstrapChunks: Le,
        startInlineScript: ye,
        placeholderPrefix: v(de + "P:"),
        segmentPrefix: v(de + "S:"),
        boundaryPrefix: de + "B:",
        idPrefix: de,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var kn = 0, Lt = 1, gn = 2, an = 3, un = 4, tr = 5, _n = 6, Rn = 7;
    function pn(s, f) {
      return {
        insertionMode: s,
        selectedValue: f
      };
    }
    function zn(s) {
      var f = s === "http://www.w3.org/2000/svg" ? gn : s === "http://www.w3.org/1998/Math/MathML" ? an : kn;
      return pn(f, null);
    }
    function Bn(s, f, T) {
      switch (f) {
        case "select":
          return pn(Lt, T.value != null ? T.value : T.defaultValue);
        case "svg":
          return pn(gn, null);
        case "math":
          return pn(an, null);
        case "foreignObject":
          return pn(Lt, null);
        case "table":
          return pn(un, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return pn(tr, null);
        case "colgroup":
          return pn(Rn, null);
        case "tr":
          return pn(_n, null);
      }
      return s.insertionMode >= un || s.insertionMode === kn ? pn(Lt, null) : s;
    }
    var nr = null;
    function hr(s) {
      var f = s.nextSuspenseID++;
      return v(s.boundaryPrefix + f.toString(16));
    }
    function rr(s, f, T) {
      var M = s.idPrefix, X = ":" + M + "R" + f;
      return T > 0 && (X += "H" + T.toString(32)), X + ":";
    }
    function Hn(s) {
      return st(s);
    }
    var ar = v("<!-- -->");
    function Kn(s, f, T, M) {
      return f === "" ? M : (M && s.push(ar), s.push(b(Hn(f))), !0);
    }
    function Yn(s, f, T, M) {
      T && M && s.push(ar);
    }
    var E = /* @__PURE__ */ new Map();
    function _(s) {
      var f = E.get(s);
      if (f !== void 0)
        return f;
      var T = v(st(Rt(s)));
      return E.set(s, T), T;
    }
    var D = v(' style="'), U = v(":"), pe = v(";");
    function O(s, f, T) {
      if (typeof T != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var M = !0;
      for (var X in T)
        if (ne.call(T, X)) {
          var de = T[X];
          if (!(de == null || typeof de == "boolean" || de === "")) {
            var ye = void 0, Le = void 0, o = X.indexOf("--") === 0;
            o ? (ye = b(st(X)), W(de, X), Le = b(st(("" + de).trim()))) : (xt(X, de), ye = _(X), typeof de == "number" ? de !== 0 && !ne.call(Ce, X) ? Le = b(de + "px") : Le = b("" + de) : (W(de, X), Le = b(st(("" + de).trim())))), M ? (M = !1, s.push(D, ye, U, Le)) : s.push(pe, ye, U, Le);
          }
        }
      M || s.push(xe);
    }
    var I = v(" "), J = v('="'), xe = v('"'), Be = v('=""');
    function Xe(s, f, T, M) {
      switch (T) {
        case "style": {
          O(s, f, M);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(T.length > 2 && (T[0] === "o" || T[0] === "O") && (T[1] === "n" || T[1] === "N"))
      ) {
        var X = Se(T);
        if (X !== null) {
          switch (typeof M) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!X.acceptsBooleans)
                return;
          }
          var de = X.attributeName, ye = b(de);
          switch (X.type) {
            case re:
              M && s.push(I, ye, Be);
              return;
            case B:
              M === !0 ? s.push(I, ye, Be) : M === !1 || s.push(I, ye, J, b(st(M)), xe);
              return;
            case j:
              isNaN(M) || s.push(I, ye, J, b(st(M)), xe);
              break;
            case se:
              !isNaN(M) && M >= 1 && s.push(I, ye, J, b(st(M)), xe);
              break;
            default:
              X.sanitizeURL && (z(M, de), M = "" + M, vn(M)), s.push(I, ye, J, b(st(M)), xe);
          }
        } else if ($(T)) {
          switch (typeof M) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Le = T.toLowerCase().slice(0, 5);
              if (Le !== "data-" && Le !== "aria-")
                return;
            }
          }
          s.push(I, b(T), J, b(st(M)), xe);
        }
      }
    }
    var dt = v(">"), Vt = v("/>");
    function zt(s, f, T) {
      if (f != null) {
        if (T != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof f != "object" || !("__html" in f))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var M = f.__html;
        M != null && (q(M), s.push(b("" + M)));
      }
    }
    var Xt = !1, qt = !1, Zt = !1, In = !1, Gn = !1, Xn = !1, Vn = !1;
    function Er(s, f) {
      {
        var T = s[f];
        if (T != null) {
          var M = Pn(T);
          s.multiple && !M ? a("The `%s` prop supplied to <select> must be an array if `multiple` is true.", f) : !s.multiple && M && a("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", f);
        }
      }
    }
    function xa(s, f, T) {
      Qe("select", f), Er(f, "value"), Er(f, "defaultValue"), f.value !== void 0 && f.defaultValue !== void 0 && !Zt && (a("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Zt = !0), s.push(or("select"));
      var M = null, X = null;
      for (var de in f)
        if (ne.call(f, de)) {
          var ye = f[de];
          if (ye == null)
            continue;
          switch (de) {
            case "children":
              M = ye;
              break;
            case "dangerouslySetInnerHTML":
              X = ye;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              Xe(s, T, de, ye);
              break;
          }
        }
      return s.push(dt), zt(s, X, M), M;
    }
    function Ct(s) {
      var f = "";
      return e.Children.forEach(s, function(T) {
        T != null && (f += T, !Gn && typeof T != "string" && typeof T != "number" && (Gn = !0, a("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), f;
    }
    var dn = v(' selected=""');
    function ra(s, f, T, M) {
      var X = M.selectedValue;
      s.push(or("option"));
      var de = null, ye = null, Le = null, o = null;
      for (var d in f)
        if (ne.call(f, d)) {
          var k = f[d];
          if (k == null)
            continue;
          switch (d) {
            case "children":
              de = k;
              break;
            case "selected":
              Le = k, Vn || (a("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Vn = !0);
              break;
            case "dangerouslySetInnerHTML":
              o = k;
              break;
            case "value":
              ye = k;
            default:
              Xe(s, T, d, k);
              break;
          }
        }
      if (X != null) {
        var P;
        if (ye !== null ? (z(ye, "value"), P = "" + ye) : (o !== null && (Xn || (Xn = !0, a("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), P = Ct(de)), Pn(X))
          for (var H = 0; H < X.length; H++) {
            z(X[H], "value");
            var oe = "" + X[H];
            if (oe === P) {
              s.push(dn);
              break;
            }
          }
        else
          z(X, "select.value"), "" + X === P && s.push(dn);
      } else
        Le && s.push(dn);
      return s.push(dt), zt(s, o, de), de;
    }
    function Pr(s, f, T) {
      Qe("input", f), f.checked !== void 0 && f.defaultChecked !== void 0 && !qt && (a("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), qt = !0), f.value !== void 0 && f.defaultValue !== void 0 && !Xt && (a("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), Xt = !0), s.push(or("input"));
      var M = null, X = null, de = null, ye = null;
      for (var Le in f)
        if (ne.call(f, Le)) {
          var o = f[Le];
          if (o == null)
            continue;
          switch (Le) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              ye = o;
              break;
            case "defaultValue":
              X = o;
              break;
            case "checked":
              de = o;
              break;
            case "value":
              M = o;
              break;
            default:
              Xe(s, T, Le, o);
              break;
          }
        }
      return de !== null ? Xe(s, T, "checked", de) : ye !== null && Xe(s, T, "checked", ye), M !== null ? Xe(s, T, "value", M) : X !== null && Xe(s, T, "value", X), s.push(Vt), null;
    }
    function ir(s, f, T) {
      Qe("textarea", f), f.value !== void 0 && f.defaultValue !== void 0 && !In && (a("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), In = !0), s.push(or("textarea"));
      var M = null, X = null, de = null;
      for (var ye in f)
        if (ne.call(f, ye)) {
          var Le = f[ye];
          if (Le == null)
            continue;
          switch (ye) {
            case "children":
              de = Le;
              break;
            case "value":
              M = Le;
              break;
            case "defaultValue":
              X = Le;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              Xe(s, T, ye, Le);
              break;
          }
        }
      if (M === null && X !== null && (M = X), s.push(dt), de != null) {
        if (a("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), M != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (Pn(de)) {
          if (de.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          q(de[0]), M = "" + de[0];
        }
        q(de), M = "" + de;
      }
      return typeof M == "string" && M[0] === `
` && s.push(_r), M !== null && (z(M, "value"), s.push(b(Hn("" + M)))), null;
    }
    function Dr(s, f, T, M) {
      s.push(or(T));
      for (var X in f)
        if (ne.call(f, X)) {
          var de = f[X];
          if (de == null)
            continue;
          switch (X) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(T + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              Xe(s, M, X, de);
              break;
          }
        }
      return s.push(Vt), null;
    }
    function Wr(s, f, T) {
      s.push(or("menuitem"));
      for (var M in f)
        if (ne.call(f, M)) {
          var X = f[M];
          if (X == null)
            continue;
          switch (M) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              Xe(s, T, M, X);
              break;
          }
        }
      return s.push(dt), null;
    }
    function Bt(s, f, T) {
      s.push(or("title"));
      var M = null;
      for (var X in f)
        if (ne.call(f, X)) {
          var de = f[X];
          if (de == null)
            continue;
          switch (X) {
            case "children":
              M = de;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              Xe(s, T, X, de);
              break;
          }
        }
      s.push(dt);
      {
        var ye = Array.isArray(M) && M.length < 2 ? M[0] || null : M;
        Array.isArray(M) && M.length > 1 ? a("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : ye != null && ye.$$typeof != null ? a("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : ye != null && typeof ye != "string" && typeof ye != "number" && a("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return M;
    }
    function mr(s, f, T, M) {
      s.push(or(T));
      var X = null, de = null;
      for (var ye in f)
        if (ne.call(f, ye)) {
          var Le = f[ye];
          if (Le == null)
            continue;
          switch (ye) {
            case "children":
              X = Le;
              break;
            case "dangerouslySetInnerHTML":
              de = Le;
              break;
            default:
              Xe(s, M, ye, Le);
              break;
          }
        }
      return s.push(dt), zt(s, de, X), typeof X == "string" ? (s.push(b(Hn(X))), null) : X;
    }
    function Wn(s, f, T, M) {
      s.push(or(T));
      var X = null, de = null;
      for (var ye in f)
        if (ne.call(f, ye)) {
          var Le = f[ye];
          if (Le == null)
            continue;
          switch (ye) {
            case "children":
              X = Le;
              break;
            case "dangerouslySetInnerHTML":
              de = Le;
              break;
            case "style":
              O(s, M, Le);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              $(ye) && typeof Le != "function" && typeof Le != "symbol" && s.push(I, b(ye), J, b(st(Le)), xe);
              break;
          }
        }
      return s.push(dt), zt(s, de, X), X;
    }
    var _r = v(`
`);
    function kr(s, f, T, M) {
      s.push(or(T));
      var X = null, de = null;
      for (var ye in f)
        if (ne.call(f, ye)) {
          var Le = f[ye];
          if (Le == null)
            continue;
          switch (ye) {
            case "children":
              X = Le;
              break;
            case "dangerouslySetInnerHTML":
              de = Le;
              break;
            default:
              Xe(s, M, ye, Le);
              break;
          }
        }
      if (s.push(dt), de != null) {
        if (X != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof de != "object" || !("__html" in de))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var o = de.__html;
        o != null && (typeof o == "string" && o.length > 0 && o[0] === `
` ? s.push(_r, b(o)) : (q(o), s.push(b("" + o))));
      }
      return typeof X == "string" && X[0] === `
` && s.push(_r), X;
    }
    var ba = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, wr = /* @__PURE__ */ new Map();
    function or(s) {
      var f = wr.get(s);
      if (f === void 0) {
        if (!ba.test(s))
          throw new Error("Invalid tag: " + s);
        f = v("<" + s), wr.set(s, f);
      }
      return f;
    }
    var qa = v("<!DOCTYPE html>");
    function Za(s, f, T, M, X) {
      switch (_e(f, T), ge(f, T), Et(f, T, null), !T.suppressContentEditableWarning && T.contentEditable && T.children != null && a("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), X.insertionMode !== gn && X.insertionMode !== an && f.indexOf("-") === -1 && typeof T.is != "string" && f.toLowerCase() !== f && a("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", f), f) {
        case "select":
          return xa(s, T, M);
        case "option":
          return ra(s, T, M, X);
        case "textarea":
          return ir(s, T, M);
        case "input":
          return Pr(s, T, M);
        case "menuitem":
          return Wr(s, T, M);
        case "title":
          return Bt(s, T, M);
        case "listing":
        case "pre":
          return kr(s, T, f, M);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Dr(s, T, f, M);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return mr(s, T, f, M);
        case "html":
          return X.insertionMode === kn && s.push(qa), mr(s, T, f, M);
        default:
          return f.indexOf("-") === -1 && typeof T.is != "string" ? mr(s, T, f, M) : Wn(s, T, f, M);
      }
    }
    var Yi = v("</"), Gi = v(">");
    function Xi(s, f, T) {
      switch (f) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          s.push(Yi, b(f), Gi);
      }
    }
    function fl(s, f) {
      for (var T = f.bootstrapChunks, M = 0; M < T.length - 1; M++)
        g(s, T[M]);
      return M < T.length ? x(s, T[M]) : !0;
    }
    var pl = v('<template id="'), Ea = v('"></template>');
    function Sa(s, f, T) {
      g(s, pl), g(s, f.placeholderPrefix);
      var M = b(T.toString(16));
      return g(s, M), x(s, Ea);
    }
    var ka = v("<!--$-->"), aa = v('<!--$?--><template id="'), hl = v('"></template>'), ia = v("<!--$!-->"), Qa = v("<!--/$-->"), Ja = v("<template"), jr = v('"'), Ur = v(' data-dgst="'), wa = v(' data-msg="'), qi = v(' data-stck="'), ei = v("></template>");
    function Zi(s, f) {
      return x(s, ka);
    }
    function Ta(s, f, T) {
      if (g(s, aa), T === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(s, T), x(s, hl);
    }
    function jn(s, f, T, M, X) {
      var de;
      return de = x(s, ia), g(s, Ja), T && (g(s, Ur), g(s, b(st(T))), g(s, jr)), M && (g(s, wa), g(s, b(st(M))), g(s, jr)), X && (g(s, qi), g(s, b(st(X))), g(s, jr)), de = x(s, ei), de;
    }
    function Qi(s, f) {
      return x(s, Qa);
    }
    function Ra(s, f) {
      return x(s, Qa);
    }
    function ml(s, f) {
      return x(s, Qa);
    }
    var Ji = v('<div hidden id="'), Ca = v('">'), eo = v("</div>"), to = v('<svg aria-hidden="true" style="display:none" id="'), Aa = v('">'), La = v("</svg>"), no = v('<math aria-hidden="true" style="display:none" id="'), ro = v('">'), ao = v("</math>"), ti = v('<table hidden id="'), io = v('">'), S = v("</table>"), F = v('<table hidden><tbody id="'), V = v('">'), ae = v("</tbody></table>"), Re = v('<table hidden><tr id="'), ke = v('">'), Oe = v("</tr></table>"), Ye = v('<table hidden><colgroup id="'), vt = v('">'), Tt = v("</colgroup></table>");
    function kt(s, f, T, M) {
      switch (T.insertionMode) {
        case kn:
        case Lt:
          return g(s, Ji), g(s, f.segmentPrefix), g(s, b(M.toString(16))), x(s, Ca);
        case gn:
          return g(s, to), g(s, f.segmentPrefix), g(s, b(M.toString(16))), x(s, Aa);
        case an:
          return g(s, no), g(s, f.segmentPrefix), g(s, b(M.toString(16))), x(s, ro);
        case un:
          return g(s, ti), g(s, f.segmentPrefix), g(s, b(M.toString(16))), x(s, io);
        case tr:
          return g(s, F), g(s, f.segmentPrefix), g(s, b(M.toString(16))), x(s, V);
        case _n:
          return g(s, Re), g(s, f.segmentPrefix), g(s, b(M.toString(16))), x(s, ke);
        case Rn:
          return g(s, Ye), g(s, f.segmentPrefix), g(s, b(M.toString(16))), x(s, vt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Jt(s, f) {
      switch (f.insertionMode) {
        case kn:
        case Lt:
          return x(s, eo);
        case gn:
          return x(s, La);
        case an:
          return x(s, ao);
        case un:
          return x(s, S);
        case tr:
          return x(s, ae);
        case _n:
          return x(s, Oe);
        case Rn:
          return x(s, Tt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Un = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", lr = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', sr = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Na = v(Un + ';$RS("'), oo = v('$RS("'), ni = v('","'), Wu = v('")<\/script>');
    function ju(s, f, T) {
      g(s, f.startInlineScript), f.sentCompleteSegmentFunction ? g(s, oo) : (f.sentCompleteSegmentFunction = !0, g(s, Na)), g(s, f.segmentPrefix);
      var M = b(T.toString(16));
      return g(s, M), g(s, ni), g(s, f.placeholderPrefix), g(s, M), x(s, Wu);
    }
    var Uu = v(lr + ';$RC("'), Ku = v('$RC("'), Yu = v('","'), Gu = v('")<\/script>');
    function yl(s, f, T, M) {
      if (g(s, f.startInlineScript), f.sentCompleteBoundaryFunction ? g(s, Ku) : (f.sentCompleteBoundaryFunction = !0, g(s, Uu)), T === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var X = b(M.toString(16));
      return g(s, T), g(s, Yu), g(s, f.segmentPrefix), g(s, X), x(s, Gu);
    }
    var Xu = v(sr + ';$RX("'), qu = v('$RX("'), gl = v('"'), Zu = v(")<\/script>"), vl = v(",");
    function Os(s, f, T, M, X, de) {
      if (g(s, f.startInlineScript), f.sentClientRenderFunction ? g(s, qu) : (f.sentClientRenderFunction = !0, g(s, Xu)), T === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(s, T), g(s, gl), (M || X || de) && (g(s, vl), g(s, b(xl(M || "")))), (X || de) && (g(s, vl), g(s, b(xl(X || "")))), de && (g(s, vl), g(s, b(xl(de)))), x(s, Zu);
    }
    var Fs = /[<\u2028\u2029]/g;
    function xl(s) {
      var f = JSON.stringify(s);
      return f.replace(Fs, function(T) {
        switch (T) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var yr = Object.assign, Qu = Symbol.for("react.element"), Ms = Symbol.for("react.portal"), cr = Symbol.for("react.fragment"), zs = Symbol.for("react.strict_mode"), bl = Symbol.for("react.profiler"), lo = Symbol.for("react.provider"), so = Symbol.for("react.context"), co = Symbol.for("react.forward_ref"), ri = Symbol.for("react.suspense"), ai = Symbol.for("react.suspense_list"), ii = Symbol.for("react.memo"), Pa = Symbol.for("react.lazy"), El = Symbol.for("react.scope"), Sl = Symbol.for("react.debug_trace_mode"), uo = Symbol.for("react.legacy_hidden"), Ju = Symbol.for("react.default_value"), Bs = Symbol.iterator, ed = "@@iterator";
    function td(s) {
      if (s === null || typeof s != "object")
        return null;
      var f = Bs && s[Bs] || s[ed];
      return typeof f == "function" ? f : null;
    }
    function Is(s, f, T) {
      var M = s.displayName;
      if (M)
        return M;
      var X = f.displayName || f.name || "";
      return X !== "" ? T + "(" + X + ")" : T;
    }
    function $s(s) {
      return s.displayName || "Context";
    }
    function hn(s) {
      if (s == null)
        return null;
      if (typeof s.tag == "number" && a("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof s == "function")
        return s.displayName || s.name || null;
      if (typeof s == "string")
        return s;
      switch (s) {
        case cr:
          return "Fragment";
        case Ms:
          return "Portal";
        case bl:
          return "Profiler";
        case zs:
          return "StrictMode";
        case ri:
          return "Suspense";
        case ai:
          return "SuspenseList";
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case so:
            var f = s;
            return $s(f) + ".Consumer";
          case lo:
            var T = s;
            return $s(T._context) + ".Provider";
          case co:
            return Is(s, s.render, "ForwardRef");
          case ii:
            var M = s.displayName || null;
            return M !== null ? M : hn(s.type) || "Memo";
          case Pa: {
            var X = s, de = X._payload, ye = X._init;
            try {
              return hn(ye(de));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var oi = 0, kl, fn, Da, wl, Tl, Rl, Cl;
    function Al() {
    }
    Al.__reactDisabledLog = !0;
    function Hs() {
      {
        if (oi === 0) {
          kl = console.log, fn = console.info, Da = console.warn, wl = console.error, Tl = console.group, Rl = console.groupCollapsed, Cl = console.groupEnd;
          var s = {
            configurable: !0,
            enumerable: !0,
            value: Al,
            writable: !0
          };
          Object.defineProperties(console, {
            info: s,
            log: s,
            warn: s,
            error: s,
            group: s,
            groupCollapsed: s,
            groupEnd: s
          });
        }
        oi++;
      }
    }
    function Vs() {
      {
        if (oi--, oi === 0) {
          var s = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: yr({}, s, {
              value: kl
            }),
            info: yr({}, s, {
              value: fn
            }),
            warn: yr({}, s, {
              value: Da
            }),
            error: yr({}, s, {
              value: wl
            }),
            group: yr({}, s, {
              value: Tl
            }),
            groupCollapsed: yr({}, s, {
              value: Rl
            }),
            groupEnd: yr({}, s, {
              value: Cl
            })
          });
        }
        oi < 0 && a("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var fo = n.ReactCurrentDispatcher, Ll;
    function li(s, f, T) {
      {
        if (Ll === void 0)
          try {
            throw Error();
          } catch (X) {
            var M = X.stack.trim().match(/\n( *(at )?)/);
            Ll = M && M[1] || "";
          }
        return `
` + Ll + s;
      }
    }
    var si = !1, _a;
    {
      var ci = typeof WeakMap == "function" ? WeakMap : Map;
      _a = new ci();
    }
    function ui(s, f) {
      if (!s || si)
        return "";
      {
        var T = _a.get(s);
        if (T !== void 0)
          return T;
      }
      var M;
      si = !0;
      var X = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var de;
      de = fo.current, fo.current = null, Hs();
      try {
        if (f) {
          var ye = function() {
            throw Error();
          };
          if (Object.defineProperty(ye.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ye, []);
            } catch (he) {
              M = he;
            }
            Reflect.construct(s, [], ye);
          } else {
            try {
              ye.call();
            } catch (he) {
              M = he;
            }
            s.call(ye.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (he) {
            M = he;
          }
          s();
        }
      } catch (he) {
        if (he && M && typeof he.stack == "string") {
          for (var Le = he.stack.split(`
`), o = M.stack.split(`
`), d = Le.length - 1, k = o.length - 1; d >= 1 && k >= 0 && Le[d] !== o[k]; )
            k--;
          for (; d >= 1 && k >= 0; d--, k--)
            if (Le[d] !== o[k]) {
              if (d !== 1 || k !== 1)
                do
                  if (d--, k--, k < 0 || Le[d] !== o[k]) {
                    var P = `
` + Le[d].replace(" at new ", " at ");
                    return s.displayName && P.includes("<anonymous>") && (P = P.replace("<anonymous>", s.displayName)), typeof s == "function" && _a.set(s, P), P;
                  }
                while (d >= 1 && k >= 0);
              break;
            }
        }
      } finally {
        si = !1, fo.current = de, Vs(), Error.prepareStackTrace = X;
      }
      var H = s ? s.displayName || s.name : "", oe = H ? li(H) : "";
      return typeof s == "function" && _a.set(s, oe), oe;
    }
    function po(s, f, T) {
      return ui(s, !0);
    }
    function Ws(s, f, T) {
      return ui(s, !1);
    }
    function Nl(s) {
      var f = s.prototype;
      return !!(f && f.isReactComponent);
    }
    function Pl(s, f, T) {
      if (s == null)
        return "";
      if (typeof s == "function")
        return ui(s, Nl(s));
      if (typeof s == "string")
        return li(s);
      switch (s) {
        case ri:
          return li("Suspense");
        case ai:
          return li("SuspenseList");
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case co:
            return Ws(s.render);
          case ii:
            return Pl(s.type, f, T);
          case Pa: {
            var M = s, X = M._payload, de = M._init;
            try {
              return Pl(de(X), f, T);
            } catch {
            }
          }
        }
      return "";
    }
    var Dl = {}, js = n.ReactDebugCurrentFrame;
    function Oa(s) {
      if (s) {
        var f = s._owner, T = Pl(s.type, s._source, f ? f.type : null);
        js.setExtraStackFrame(T);
      } else
        js.setExtraStackFrame(null);
    }
    function _l(s, f, T, M, X) {
      {
        var de = Function.call.bind(ne);
        for (var ye in s)
          if (de(s, ye)) {
            var Le = void 0;
            try {
              if (typeof s[ye] != "function") {
                var o = Error((M || "React class") + ": " + T + " type `" + ye + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[ye] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw o.name = "Invariant Violation", o;
              }
              Le = s[ye](f, ye, M, T, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (d) {
              Le = d;
            }
            Le && !(Le instanceof Error) && (Oa(X), a("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", M || "React class", T, ye, typeof Le), Oa(null)), Le instanceof Error && !(Le.message in Dl) && (Dl[Le.message] = !0, Oa(X), a("Failed %s type: %s", T, Le.message), Oa(null));
          }
      }
    }
    var ho;
    ho = {};
    var oa = {};
    Object.freeze(oa);
    function Ol(s, f) {
      {
        var T = s.contextTypes;
        if (!T)
          return oa;
        var M = {};
        for (var X in T)
          M[X] = f[X];
        {
          var de = hn(s) || "Unknown";
          _l(T, M, "context", de);
        }
        return M;
      }
    }
    function Fl(s, f, T, M) {
      {
        if (typeof s.getChildContext != "function") {
          {
            var X = hn(f) || "Unknown";
            ho[X] || (ho[X] = !0, a("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", X, X));
          }
          return T;
        }
        var de = s.getChildContext();
        for (var ye in de)
          if (!(ye in M))
            throw new Error((hn(f) || "Unknown") + '.getChildContext(): key "' + ye + '" is not defined in childContextTypes.');
        {
          var Le = hn(f) || "Unknown";
          _l(M, de, "child context", Le);
        }
        return yr({}, T, de);
      }
    }
    var Kr;
    Kr = {};
    var Us = null, la = null;
    function sa(s) {
      s.context._currentValue = s.parentValue;
    }
    function Ml(s) {
      s.context._currentValue = s.value;
    }
    function Tr(s, f) {
      if (s !== f) {
        sa(s);
        var T = s.parent, M = f.parent;
        if (T === null) {
          if (M !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (M === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          Tr(T, M);
        }
        Ml(f);
      }
    }
    function mo(s) {
      sa(s);
      var f = s.parent;
      f !== null && mo(f);
    }
    function yo(s) {
      var f = s.parent;
      f !== null && yo(f), Ml(s);
    }
    function di(s, f) {
      sa(s);
      var T = s.parent;
      if (T === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      T.depth === f.depth ? Tr(T, f) : di(T, f);
    }
    function zl(s, f) {
      var T = f.parent;
      if (T === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      s.depth === T.depth ? Tr(s, T) : zl(s, T), Ml(f);
    }
    function fi(s) {
      var f = la, T = s;
      f !== T && (f === null ? yo(T) : T === null ? mo(f) : f.depth === T.depth ? Tr(f, T) : f.depth > T.depth ? di(f, T) : zl(f, T), la = T);
    }
    function Ks(s, f) {
      var T;
      T = s._currentValue, s._currentValue = f, s._currentRenderer !== void 0 && s._currentRenderer !== null && s._currentRenderer !== Kr && a("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer = Kr;
      var M = la, X = {
        parent: M,
        depth: M === null ? 0 : M.depth + 1,
        context: s,
        parentValue: T,
        value: f
      };
      return la = X, X;
    }
    function Ys(s) {
      var f = la;
      if (f === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      f.context !== s && a("The parent context is not the expected context. This is probably a bug in React.");
      {
        var T = f.parentValue;
        T === Ju ? f.context._currentValue = f.context._defaultValue : f.context._currentValue = T, s._currentRenderer !== void 0 && s._currentRenderer !== null && s._currentRenderer !== Kr && a("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer = Kr;
      }
      return la = f.parent;
    }
    function go() {
      return la;
    }
    function pi(s) {
      var f = s._currentValue;
      return f;
    }
    function Bl(s) {
      return s._reactInternals;
    }
    function nd(s, f) {
      s._reactInternals = f;
    }
    var Fa = {}, vo = {}, Il, xo, bo, hi, Eo, Ma, mi, So, za;
    {
      Il = /* @__PURE__ */ new Set(), xo = /* @__PURE__ */ new Set(), bo = /* @__PURE__ */ new Set(), mi = /* @__PURE__ */ new Set(), hi = /* @__PURE__ */ new Set(), So = /* @__PURE__ */ new Set(), za = /* @__PURE__ */ new Set();
      var ko = /* @__PURE__ */ new Set();
      Ma = function(s, f) {
        if (!(s === null || typeof s == "function")) {
          var T = f + "_" + s;
          ko.has(T) || (ko.add(T), a("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, s));
        }
      }, Eo = function(s, f) {
        if (f === void 0) {
          var T = hn(s) || "Component";
          hi.has(T) || (hi.add(T), a("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", T));
        }
      };
    }
    function wo(s, f) {
      {
        var T = s.constructor, M = T && hn(T) || "ReactClass", X = M + "." + f;
        if (Fa[X])
          return;
        a(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, f, f, M), Fa[X] = !0;
      }
    }
    var To = {
      isMounted: function(s) {
        return !1;
      },
      enqueueSetState: function(s, f, T) {
        var M = Bl(s);
        M.queue === null ? wo(s, "setState") : (M.queue.push(f), T != null && Ma(T, "setState"));
      },
      enqueueReplaceState: function(s, f, T) {
        var M = Bl(s);
        M.replace = !0, M.queue = [f], T != null && Ma(T, "setState");
      },
      enqueueForceUpdate: function(s, f) {
        var T = Bl(s);
        T.queue === null ? wo(s, "forceUpdate") : f != null && Ma(f, "setState");
      }
    };
    function Gs(s, f, T, M, X) {
      var de = T(X, M);
      Eo(f, de);
      var ye = de == null ? M : yr({}, M, de);
      return ye;
    }
    function Xs(s, f, T) {
      var M = oa, X = s.contextType;
      if ("contextType" in s) {
        var de = (
          // Allow null for conditional declaration
          X === null || X !== void 0 && X.$$typeof === so && X._context === void 0
        );
        if (!de && !za.has(s)) {
          za.add(s);
          var ye = "";
          X === void 0 ? ye = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof X != "object" ? ye = " However, it is set to a " + typeof X + "." : X.$$typeof === lo ? ye = " Did you accidentally pass the Context.Provider instead?" : X._context !== void 0 ? ye = " Did you accidentally pass the Context.Consumer instead?" : ye = " However, it is set to an object with keys {" + Object.keys(X).join(", ") + "}.", a("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", hn(s) || "Component", ye);
        }
      }
      typeof X == "object" && X !== null ? M = pi(X) : M = T;
      var Le = new s(f, M);
      {
        if (typeof s.getDerivedStateFromProps == "function" && (Le.state === null || Le.state === void 0)) {
          var o = hn(s) || "Component";
          Il.has(o) || (Il.add(o), a("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", o, Le.state === null ? "null" : "undefined", o));
        }
        if (typeof s.getDerivedStateFromProps == "function" || typeof Le.getSnapshotBeforeUpdate == "function") {
          var d = null, k = null, P = null;
          if (typeof Le.componentWillMount == "function" && Le.componentWillMount.__suppressDeprecationWarning !== !0 ? d = "componentWillMount" : typeof Le.UNSAFE_componentWillMount == "function" && (d = "UNSAFE_componentWillMount"), typeof Le.componentWillReceiveProps == "function" && Le.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? k = "componentWillReceiveProps" : typeof Le.UNSAFE_componentWillReceiveProps == "function" && (k = "UNSAFE_componentWillReceiveProps"), typeof Le.componentWillUpdate == "function" && Le.componentWillUpdate.__suppressDeprecationWarning !== !0 ? P = "componentWillUpdate" : typeof Le.UNSAFE_componentWillUpdate == "function" && (P = "UNSAFE_componentWillUpdate"), d !== null || k !== null || P !== null) {
            var H = hn(s) || "Component", oe = typeof s.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            bo.has(H) || (bo.add(H), a(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, H, oe, d !== null ? `
  ` + d : "", k !== null ? `
  ` + k : "", P !== null ? `
  ` + P : ""));
          }
        }
      }
      return Le;
    }
    function qs(s, f, T) {
      {
        var M = hn(f) || "Component", X = s.render;
        X || (f.prototype && typeof f.prototype.render == "function" ? a("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", M) : a("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", M)), s.getInitialState && !s.getInitialState.isReactClassApproved && !s.state && a("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", M), s.getDefaultProps && !s.getDefaultProps.isReactClassApproved && a("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", M), s.propTypes && a("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", M), s.contextType && a("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", M), s.contextTypes && a("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", M), f.contextType && f.contextTypes && !So.has(f) && (So.add(f), a("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", M)), typeof s.componentShouldUpdate == "function" && a("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", M), f.prototype && f.prototype.isPureReactComponent && typeof s.shouldComponentUpdate < "u" && a("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", hn(f) || "A pure component"), typeof s.componentDidUnmount == "function" && a("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", M), typeof s.componentDidReceiveProps == "function" && a("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", M), typeof s.componentWillRecieveProps == "function" && a("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", M), typeof s.UNSAFE_componentWillRecieveProps == "function" && a("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", M);
        var de = s.props !== T;
        s.props !== void 0 && de && a("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", M, M), s.defaultProps && a("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", M, M), typeof s.getSnapshotBeforeUpdate == "function" && typeof s.componentDidUpdate != "function" && !xo.has(f) && (xo.add(f), a("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", hn(f))), typeof s.getDerivedStateFromProps == "function" && a("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", M), typeof s.getDerivedStateFromError == "function" && a("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", M), typeof f.getSnapshotBeforeUpdate == "function" && a("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", M);
        var ye = s.state;
        ye && (typeof ye != "object" || Pn(ye)) && a("%s.state: must be set to an object or null", M), typeof s.getChildContext == "function" && typeof f.childContextTypes != "object" && a("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", M);
      }
    }
    function rd(s, f) {
      var T = f.state;
      if (typeof f.componentWillMount == "function") {
        if (f.componentWillMount.__suppressDeprecationWarning !== !0) {
          var M = hn(s) || "Unknown";
          vo[M] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            M
          ), vo[M] = !0);
        }
        f.componentWillMount();
      }
      typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), T !== f.state && (a("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", hn(s) || "Component"), To.enqueueReplaceState(f, f.state, null));
    }
    function ad(s, f, T, M) {
      if (s.queue !== null && s.queue.length > 0) {
        var X = s.queue, de = s.replace;
        if (s.queue = null, s.replace = !1, de && X.length === 1)
          f.state = X[0];
        else {
          for (var ye = de ? X[0] : f.state, Le = !0, o = de ? 1 : 0; o < X.length; o++) {
            var d = X[o], k = typeof d == "function" ? d.call(f, ye, T, M) : d;
            k != null && (Le ? (Le = !1, ye = yr({}, ye, k)) : yr(ye, k));
          }
          f.state = ye;
        }
      } else
        s.queue = null;
    }
    function Zs(s, f, T, M) {
      qs(s, f, T);
      var X = s.state !== void 0 ? s.state : null;
      s.updater = To, s.props = T, s.state = X;
      var de = {
        queue: [],
        replace: !1
      };
      nd(s, de);
      var ye = f.contextType;
      if (typeof ye == "object" && ye !== null ? s.context = pi(ye) : s.context = M, s.state === T) {
        var Le = hn(f) || "Component";
        mi.has(Le) || (mi.add(Le), a("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Le));
      }
      var o = f.getDerivedStateFromProps;
      typeof o == "function" && (s.state = Gs(s, f, o, X, T)), typeof f.getDerivedStateFromProps != "function" && typeof s.getSnapshotBeforeUpdate != "function" && (typeof s.UNSAFE_componentWillMount == "function" || typeof s.componentWillMount == "function") && (rd(f, s), ad(de, s, T, M));
    }
    var id = {
      id: 1,
      overflow: ""
    };
    function od(s) {
      var f = s.overflow, T = s.id, M = T & ~ld(T);
      return M.toString(32) + f;
    }
    function Ro(s, f, T) {
      var M = s.id, X = s.overflow, de = Co(M) - 1, ye = M & ~(1 << de), Le = T + 1, o = Co(f) + de;
      if (o > 30) {
        var d = de - de % 5, k = (1 << d) - 1, P = (ye & k).toString(32), H = ye >> d, oe = de - d, he = Co(f) + oe, Ae = Le << oe, $e = Ae | H, rt = P + X;
        return {
          id: 1 << he | $e,
          overflow: rt
        };
      } else {
        var ct = Le << de, bt = ct | ye, on = X;
        return {
          id: 1 << o | bt,
          overflow: on
        };
      }
    }
    function Co(s) {
      return 32 - $l(s);
    }
    function ld(s) {
      return 1 << Co(s) - 1;
    }
    var $l = Math.clz32 ? Math.clz32 : cd, Ao = Math.log, sd = Math.LN2;
    function cd(s) {
      var f = s >>> 0;
      return f === 0 ? 32 : 31 - (Ao(f) / sd | 0) | 0;
    }
    function ud(s, f) {
      return s === f && (s !== 0 || 1 / s === 1 / f) || s !== s && f !== f;
    }
    var dd = typeof Object.is == "function" ? Object.is : ud, Or = null, Hl = null, Lo = null, Dt = null, ca = !1, ua = !1, Gt = 0, gr = null, da = 0, No = 25, On = !1, Fr;
    function fa() {
      if (Or === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return On && a("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Or;
    }
    function Rr(s, f) {
      if (f === null)
        return a("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Fr), !1;
      s.length !== f.length && a(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Fr, "[" + s.join(", ") + "]", "[" + f.join(", ") + "]");
      for (var T = 0; T < f.length && T < s.length; T++)
        if (!dd(s[T], f[T]))
          return !1;
      return !0;
    }
    function pa() {
      if (da > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Mr() {
      return Dt === null ? Lo === null ? (ca = !1, Lo = Dt = pa()) : (ca = !0, Dt = Lo) : Dt.next === null ? (ca = !1, Dt = Dt.next = pa()) : (ca = !0, Dt = Dt.next), Dt;
    }
    function fd(s, f) {
      Or = f, Hl = s, On = !1, Gt = 0;
    }
    function Qs(s, f, T, M) {
      for (; ua; )
        ua = !1, Gt = 0, da += 1, Dt = null, T = s(f, M);
      return Vl(), T;
    }
    function Po() {
      var s = Gt !== 0;
      return s;
    }
    function Vl() {
      On = !1, Or = null, Hl = null, ua = !1, Lo = null, da = 0, gr = null, Dt = null;
    }
    function pd(s) {
      return On && a("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), pi(s);
    }
    function Js(s) {
      return Fr = "useContext", fa(), pi(s);
    }
    function yi(s, f) {
      return typeof f == "function" ? f(s) : f;
    }
    function hd(s) {
      return Fr = "useState", ec(
        yi,
        // useReducer has a special case to support lazy useState initializers
        s
      );
    }
    function ec(s, f, T) {
      if (s !== yi && (Fr = "useReducer"), Or = fa(), Dt = Mr(), ca) {
        var M = Dt.queue, X = M.dispatch;
        if (gr !== null) {
          var de = gr.get(M);
          if (de !== void 0) {
            gr.delete(M);
            var ye = Dt.memoizedState, Le = de;
            do {
              var o = Le.action;
              On = !0, ye = s(ye, o), On = !1, Le = Le.next;
            } while (Le !== null);
            return Dt.memoizedState = ye, [ye, X];
          }
        }
        return [Dt.memoizedState, X];
      } else {
        On = !0;
        var d;
        s === yi ? d = typeof f == "function" ? f() : f : d = T !== void 0 ? T(f) : f, On = !1, Dt.memoizedState = d;
        var k = Dt.queue = {
          last: null,
          dispatch: null
        }, P = k.dispatch = nc.bind(null, Or, k);
        return [Dt.memoizedState, P];
      }
    }
    function Do(s, f) {
      Or = fa(), Dt = Mr();
      var T = f === void 0 ? null : f;
      if (Dt !== null) {
        var M = Dt.memoizedState;
        if (M !== null && T !== null) {
          var X = M[1];
          if (Rr(T, X))
            return M[0];
        }
      }
      On = !0;
      var de = s();
      return On = !1, Dt.memoizedState = [de, T], de;
    }
    function md(s) {
      Or = fa(), Dt = Mr();
      var f = Dt.memoizedState;
      if (f === null) {
        var T = {
          current: s
        };
        return Object.seal(T), Dt.memoizedState = T, T;
      } else
        return f;
    }
    function tc(s, f) {
      Fr = "useLayoutEffect", a("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function nc(s, f, T) {
      if (da >= No)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (s === Or) {
        ua = !0;
        var M = {
          action: T,
          next: null
        };
        gr === null && (gr = /* @__PURE__ */ new Map());
        var X = gr.get(f);
        if (X === void 0)
          gr.set(f, M);
        else {
          for (var de = X; de.next !== null; )
            de = de.next;
          de.next = M;
        }
      }
    }
    function yd(s, f) {
      return Do(function() {
        return s;
      }, f);
    }
    function gd(s, f, T) {
      return fa(), f(s._source);
    }
    function vd(s, f, T) {
      if (T === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return T();
    }
    function xd(s) {
      return fa(), s;
    }
    function bd() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function Ed() {
      return fa(), [!1, bd];
    }
    function Sd() {
      var s = Hl, f = od(s.treeContext), T = Wl;
      if (T === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var M = Gt++;
      return rr(T, f, M);
    }
    function _o() {
    }
    var rc = {
      readContext: pd,
      useContext: Js,
      useMemo: Do,
      useReducer: ec,
      useRef: md,
      useState: hd,
      useInsertionEffect: _o,
      useLayoutEffect: tc,
      useCallback: yd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: _o,
      // Effects are not run in the server environment.
      useEffect: _o,
      // Debugging effect
      useDebugValue: _o,
      useDeferredValue: xd,
      useTransition: Ed,
      useId: Sd,
      // Subscriptions are not setup in a server environment.
      useMutableSource: gd,
      useSyncExternalStore: vd
    }, Wl = null;
    function gi(s) {
      Wl = s;
    }
    function ac(s) {
      try {
        var f = "", T = s;
        do {
          switch (T.tag) {
            case 0:
              f += li(T.type, null, null);
              break;
            case 1:
              f += Ws(T.type, null, null);
              break;
            case 2:
              f += po(T.type, null, null);
              break;
          }
          T = T.parent;
        } while (T);
        return f;
      } catch (M) {
        return `
Error generating stack: ` + M.message + `
` + M.stack;
      }
    }
    var vi = n.ReactCurrentDispatcher, Oo = n.ReactDebugCurrentFrame, jl = 0, Yr = 1, Fo = 2, Mo = 3, ha = 4, ic = 0, Ul = 1, ma = 2, kd = 12800;
    function oc(s) {
      return console.error(s), null;
    }
    function Cr() {
    }
    function wd(s, f, T, M, X, de, ye, Le, o) {
      var d = [], k = /* @__PURE__ */ new Set(), P = {
        destination: null,
        responseState: f,
        progressiveChunkSize: M === void 0 ? kd : M,
        status: ic,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: k,
        pingedTasks: d,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: X === void 0 ? oc : X,
        onAllReady: de === void 0 ? Cr : de,
        onShellReady: ye === void 0 ? Cr : ye,
        onShellError: Le === void 0 ? Cr : Le,
        onFatalError: o === void 0 ? Cr : o
      }, H = zo(
        P,
        0,
        null,
        T,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      H.parentFlushed = !0;
      var oe = Kl(P, s, null, H, k, oa, Us, id);
      return d.push(oe), P;
    }
    function Td(s, f) {
      var T = s.pingedTasks;
      T.push(f), T.length === 1 && u(function() {
        return wi(s);
      });
    }
    function xi(s, f) {
      return {
        id: nr,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: f,
        errorDigest: null
      };
    }
    function Kl(s, f, T, M, X, de, ye, Le) {
      s.allPendingTasks++, T === null ? s.pendingRootTasks++ : T.pendingTasks++;
      var o = {
        node: f,
        ping: function() {
          return Td(s, o);
        },
        blockedBoundary: T,
        blockedSegment: M,
        abortSet: X,
        legacyContext: de,
        context: ye,
        treeContext: Le
      };
      return o.componentStack = null, X.add(o), o;
    }
    function zo(s, f, T, M, X, de) {
      return {
        status: jl,
        id: -1,
        // lazily assigned later
        index: f,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: M,
        boundary: T,
        lastPushedText: X,
        textEmbedded: de
      };
    }
    var zr = null;
    function bi() {
      return zr === null || zr.componentStack === null ? "" : ac(zr.componentStack);
    }
    function Gr(s, f) {
      s.componentStack = {
        tag: 0,
        parent: s.componentStack,
        type: f
      };
    }
    function Ar(s, f) {
      s.componentStack = {
        tag: 1,
        parent: s.componentStack,
        type: f
      };
    }
    function Yl(s, f) {
      s.componentStack = {
        tag: 2,
        parent: s.componentStack,
        type: f
      };
    }
    function vr(s) {
      s.componentStack === null ? a("Unexpectedly popped too many stack frames. This is a bug in React.") : s.componentStack = s.componentStack.parent;
    }
    var Ba = null;
    function Gl(s, f) {
      {
        var T;
        typeof f == "string" ? T = f : f && typeof f.message == "string" ? T = f.message : T = String(f);
        var M = Ba || bi();
        Ba = null, s.errorMessage = T, s.errorComponentStack = M;
      }
    }
    function xr(s, f) {
      var T = s.onError(f);
      if (T != null && typeof T != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof T + '" instead');
      return T;
    }
    function Xr(s, f) {
      var T = s.onShellError;
      T(f);
      var M = s.onFatalError;
      M(f), s.destination !== null ? (s.status = ma, A(s.destination, f)) : (s.status = Ul, s.fatalError = f);
    }
    function Xl(s, f, T) {
      Gr(f, "Suspense");
      var M = f.blockedBoundary, X = f.blockedSegment, de = T.fallback, ye = T.children, Le = /* @__PURE__ */ new Set(), o = xi(s, Le), d = X.chunks.length, k = zo(
        s,
        d,
        o,
        X.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      X.children.push(k), X.lastPushedText = !1;
      var P = zo(
        s,
        0,
        null,
        X.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      P.parentFlushed = !0, f.blockedBoundary = o, f.blockedSegment = P;
      try {
        if (as(s, f, ye), Yn(P.chunks, s.responseState, P.lastPushedText, P.textEmbedded), P.status = Yr, $o(o, P), o.pendingTasks === 0) {
          vr(f);
          return;
        }
      } catch (oe) {
        P.status = ha, o.forceClientRender = !0, o.errorDigest = xr(s, oe), Gl(o, oe);
      } finally {
        f.blockedBoundary = M, f.blockedSegment = X;
      }
      var H = Kl(s, de, M, k, Le, f.legacyContext, f.context, f.treeContext);
      H.componentStack = f.componentStack, s.pingedTasks.push(H), vr(f);
    }
    function Ei(s, f, T, M) {
      Gr(f, T);
      var X = f.blockedSegment, de = Za(X.chunks, T, M, s.responseState, X.formatContext);
      X.lastPushedText = !1;
      var ye = X.formatContext;
      X.formatContext = Bn(ye, T, M), as(s, f, de), X.formatContext = ye, Xi(X.chunks, T), X.lastPushedText = !1, vr(f);
    }
    function Bo(s) {
      return s.prototype && s.prototype.isReactComponent;
    }
    function lc(s, f, T, M, X) {
      var de = {};
      fd(f, de);
      var ye = T(M, X);
      return Qs(T, M, ye, X);
    }
    function sc(s, f, T, M, X) {
      var de = T.render();
      T.props !== X && (ki || a("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", hn(M) || "a component"), ki = !0);
      {
        var ye = M.childContextTypes;
        if (ye != null) {
          var Le = f.legacyContext, o = Fl(T, M, Le, ye);
          f.legacyContext = o, ur(s, f, de), f.legacyContext = Le;
          return;
        }
      }
      ur(s, f, de);
    }
    function Rd(s, f, T, M) {
      Yl(f, T);
      var X = Ol(T, f.legacyContext), de = Xs(T, M, X);
      Zs(de, T, M, X), sc(s, f, de, T, M), vr(f);
    }
    var ql = {}, Si = {}, cc = {}, Zl = {}, ki = !1, Ql = !1, Jl = !1, es = !1;
    function uc(s, f, T, M) {
      var X;
      if (X = Ol(T, f.legacyContext), Ar(f, T), T.prototype && typeof T.prototype.render == "function") {
        var de = hn(T) || "Unknown";
        ql[de] || (a("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", de, de), ql[de] = !0);
      }
      var ye = lc(s, f, T, M, X), Le = Po();
      if (typeof ye == "object" && ye !== null && typeof ye.render == "function" && ye.$$typeof === void 0) {
        var o = hn(T) || "Unknown";
        Si[o] || (a("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", o, o, o), Si[o] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof ye == "object" && ye !== null && typeof ye.render == "function" && ye.$$typeof === void 0
      ) {
        {
          var d = hn(T) || "Unknown";
          Si[d] || (a("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", d, d, d), Si[d] = !0);
        }
        Zs(ye, T, M, X), sc(s, f, ye, T, M);
      } else if (dc(T), Le) {
        var k = f.treeContext, P = 1, H = 0;
        f.treeContext = Ro(k, P, H);
        try {
          ur(s, f, ye);
        } finally {
          f.treeContext = k;
        }
      } else
        ur(s, f, ye);
      vr(f);
    }
    function dc(s) {
      {
        if (s && s.childContextTypes && a("%s(...): childContextTypes cannot be defined on a function component.", s.displayName || s.name || "Component"), typeof s.getDerivedStateFromProps == "function") {
          var f = hn(s) || "Unknown";
          Zl[f] || (a("%s: Function components do not support getDerivedStateFromProps.", f), Zl[f] = !0);
        }
        if (typeof s.contextType == "object" && s.contextType !== null) {
          var T = hn(s) || "Unknown";
          cc[T] || (a("%s: Function components do not support contextType.", T), cc[T] = !0);
        }
      }
    }
    function ts(s, f) {
      if (s && s.defaultProps) {
        var T = yr({}, f), M = s.defaultProps;
        for (var X in M)
          T[X] === void 0 && (T[X] = M[X]);
        return T;
      }
      return f;
    }
    function Cd(s, f, T, M, X) {
      Ar(f, T.render);
      var de = lc(s, f, T.render, M, X), ye = Po();
      if (ye) {
        var Le = f.treeContext, o = 1, d = 0;
        f.treeContext = Ro(Le, o, d);
        try {
          ur(s, f, de);
        } finally {
          f.treeContext = Le;
        }
      } else
        ur(s, f, de);
      vr(f);
    }
    function Ad(s, f, T, M, X) {
      var de = T.type, ye = ts(de, M);
      ns(s, f, de, ye, X);
    }
    function fc(s, f, T, M) {
      T._context === void 0 ? T !== T.Consumer && (es || (es = !0, a("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : T = T._context;
      var X = M.children;
      typeof X != "function" && a("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var de = pi(T), ye = X(de);
      ur(s, f, ye);
    }
    function Ld(s, f, T, M) {
      var X = T._context, de = M.value, ye = M.children, Le;
      Le = f.context, f.context = Ks(X, de), ur(s, f, ye), f.context = Ys(X), Le !== f.context && a("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function Nd(s, f, T, M, X) {
      Gr(f, "Lazy");
      var de = T._payload, ye = T._init, Le = ye(de), o = ts(Le, M);
      ns(s, f, Le, o, X), vr(f);
    }
    function ns(s, f, T, M, X) {
      if (typeof T == "function")
        if (Bo(T)) {
          Rd(s, f, T, M);
          return;
        } else {
          uc(s, f, T, M);
          return;
        }
      if (typeof T == "string") {
        Ei(s, f, T, M);
        return;
      }
      switch (T) {
        case uo:
        case Sl:
        case zs:
        case bl:
        case cr: {
          ur(s, f, M.children);
          return;
        }
        case ai: {
          Gr(f, "SuspenseList"), ur(s, f, M.children), vr(f);
          return;
        }
        case El:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case ri: {
          Xl(s, f, M);
          return;
        }
      }
      if (typeof T == "object" && T !== null)
        switch (T.$$typeof) {
          case co: {
            Cd(s, f, T, M, X);
            return;
          }
          case ii: {
            Ad(s, f, T, M, X);
            return;
          }
          case lo: {
            Ld(s, f, T, M);
            return;
          }
          case so: {
            fc(s, f, T, M);
            return;
          }
          case Pa: {
            Nd(s, f, T, M);
            return;
          }
        }
      var de = "";
      throw (T === void 0 || typeof T == "object" && T !== null && Object.keys(T).length === 0) && (de += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (T == null ? T : typeof T) + "." + de));
    }
    function Pd(s, f) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      s[Symbol.toStringTag] === "Generator" && (Ql || a("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Ql = !0), s.entries === f && (Jl || a("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Jl = !0);
    }
    function ur(s, f, T) {
      try {
        return rs(s, f, T);
      } catch (M) {
        throw typeof M == "object" && M !== null && typeof M.then == "function" || (Ba = Ba !== null ? Ba : bi()), M;
      }
    }
    function rs(s, f, T) {
      if (f.node = T, typeof T == "object" && T !== null) {
        switch (T.$$typeof) {
          case Qu: {
            var M = T, X = M.type, de = M.props, ye = M.ref;
            ns(s, f, X, de, ye);
            return;
          }
          case Ms:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Pa: {
            var Le = T, o = Le._payload, d = Le._init, k;
            try {
              k = d(o);
            } catch (ct) {
              throw typeof ct == "object" && ct !== null && typeof ct.then == "function" && Gr(f, "Lazy"), ct;
            }
            ur(s, f, k);
            return;
          }
        }
        if (Pn(T)) {
          pc(s, f, T);
          return;
        }
        var P = td(T);
        if (P) {
          Pd(T, P);
          var H = P.call(T);
          if (H) {
            var oe = H.next();
            if (!oe.done) {
              var he = [];
              do
                he.push(oe.value), oe = H.next();
              while (!oe.done);
              pc(s, f, he);
              return;
            }
            return;
          }
        }
        var Ae = Object.prototype.toString.call(T);
        throw new Error("Objects are not valid as a React child (found: " + (Ae === "[object Object]" ? "object with keys {" + Object.keys(T).join(", ") + "}" : Ae) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof T == "string") {
        var $e = f.blockedSegment;
        $e.lastPushedText = Kn(f.blockedSegment.chunks, T, s.responseState, $e.lastPushedText);
        return;
      }
      if (typeof T == "number") {
        var rt = f.blockedSegment;
        rt.lastPushedText = Kn(f.blockedSegment.chunks, "" + T, s.responseState, rt.lastPushedText);
        return;
      }
      typeof T == "function" && a("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function pc(s, f, T) {
      for (var M = T.length, X = 0; X < M; X++) {
        var de = f.treeContext;
        f.treeContext = Ro(de, M, X);
        try {
          as(s, f, T[X]);
        } finally {
          f.treeContext = de;
        }
      }
    }
    function dr(s, f, T) {
      var M = f.blockedSegment, X = M.chunks.length, de = zo(
        s,
        X,
        null,
        M.formatContext,
        // Adopt the parent segment's leading text embed
        M.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      M.children.push(de), M.lastPushedText = !1;
      var ye = Kl(s, f.node, f.blockedBoundary, de, f.abortSet, f.legacyContext, f.context, f.treeContext);
      f.componentStack !== null && (ye.componentStack = f.componentStack.parent);
      var Le = ye.ping;
      T.then(Le, Le);
    }
    function as(s, f, T) {
      var M = f.blockedSegment.formatContext, X = f.legacyContext, de = f.context, ye = null;
      ye = f.componentStack;
      try {
        return ur(s, f, T);
      } catch (Le) {
        if (Vl(), typeof Le == "object" && Le !== null && typeof Le.then == "function") {
          dr(s, f, Le), f.blockedSegment.formatContext = M, f.legacyContext = X, f.context = de, fi(de), f.componentStack = ye;
          return;
        } else
          throw f.blockedSegment.formatContext = M, f.legacyContext = X, f.context = de, fi(de), f.componentStack = ye, Le;
      }
    }
    function hc(s, f, T, M) {
      var X = xr(s, M);
      if (f === null ? Xr(s, M) : (f.pendingTasks--, f.forceClientRender || (f.forceClientRender = !0, f.errorDigest = X, Gl(f, M), f.parentFlushed && s.clientRenderedBoundaries.push(f))), s.allPendingTasks--, s.allPendingTasks === 0) {
        var de = s.onAllReady;
        de();
      }
    }
    function Dd(s) {
      var f = this, T = s.blockedBoundary, M = s.blockedSegment;
      M.status = Mo, mc(f, T, M);
    }
    function Io(s, f, T) {
      var M = s.blockedBoundary, X = s.blockedSegment;
      if (X.status = Mo, M === null)
        f.allPendingTasks--, f.status !== ma && (f.status = ma, f.destination !== null && y(f.destination));
      else {
        if (M.pendingTasks--, !M.forceClientRender) {
          M.forceClientRender = !0;
          var de = T === void 0 ? new Error("The render was aborted by the server without a reason.") : T;
          M.errorDigest = f.onError(de);
          {
            var ye = "The server did not finish this Suspense boundary: ";
            de && typeof de.message == "string" ? de = ye + de.message : de = ye + String(de);
            var Le = zr;
            zr = s;
            try {
              Gl(M, de);
            } finally {
              zr = Le;
            }
          }
          M.parentFlushed && f.clientRenderedBoundaries.push(M);
        }
        if (M.fallbackAbortableTasks.forEach(function(d) {
          return Io(d, f, T);
        }), M.fallbackAbortableTasks.clear(), f.allPendingTasks--, f.allPendingTasks === 0) {
          var o = f.onAllReady;
          o();
        }
      }
    }
    function $o(s, f) {
      if (f.chunks.length === 0 && f.children.length === 1 && f.children[0].boundary === null) {
        var T = f.children[0];
        T.id = f.id, T.parentFlushed = !0, T.status === Yr && $o(s, T);
      } else {
        var M = s.completedSegments;
        M.push(f);
      }
    }
    function mc(s, f, T) {
      if (f === null) {
        if (T.parentFlushed) {
          if (s.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          s.completedRootSegment = T;
        }
        if (s.pendingRootTasks--, s.pendingRootTasks === 0) {
          s.onShellError = Cr;
          var M = s.onShellReady;
          M();
        }
      } else if (f.pendingTasks--, !f.forceClientRender) {
        if (f.pendingTasks === 0)
          T.parentFlushed && T.status === Yr && $o(f, T), f.parentFlushed && s.completedBoundaries.push(f), f.fallbackAbortableTasks.forEach(Dd, s), f.fallbackAbortableTasks.clear();
        else if (T.parentFlushed && T.status === Yr) {
          $o(f, T);
          var X = f.completedSegments;
          X.length === 1 && f.parentFlushed && s.partialBoundaries.push(f);
        }
      }
      if (s.allPendingTasks--, s.allPendingTasks === 0) {
        var de = s.onAllReady;
        de();
      }
    }
    function yc(s, f) {
      var T = f.blockedSegment;
      if (T.status === jl) {
        fi(f.context);
        var M = null;
        M = zr, zr = f;
        try {
          ur(s, f, f.node), Yn(T.chunks, s.responseState, T.lastPushedText, T.textEmbedded), f.abortSet.delete(f), T.status = Yr, mc(s, f.blockedBoundary, T);
        } catch (de) {
          if (Vl(), typeof de == "object" && de !== null && typeof de.then == "function") {
            var X = f.ping;
            de.then(X, X);
          } else
            f.abortSet.delete(f), T.status = ha, hc(s, f.blockedBoundary, T, de);
        } finally {
          zr = M;
        }
      }
    }
    function wi(s) {
      if (s.status !== ma) {
        var f = go(), T = vi.current;
        vi.current = rc;
        var M;
        M = Oo.getCurrentStack, Oo.getCurrentStack = bi;
        var X = Wl;
        gi(s.responseState);
        try {
          var de = s.pingedTasks, ye;
          for (ye = 0; ye < de.length; ye++) {
            var Le = de[ye];
            yc(s, Le);
          }
          de.splice(0, ye), s.destination !== null && Vo(s, s.destination);
        } catch (o) {
          xr(s, o), Xr(s, o);
        } finally {
          gi(X), vi.current = T, Oo.getCurrentStack = M, T === rc && fi(f);
        }
      }
    }
    function Ti(s, f, T) {
      switch (T.parentFlushed = !0, T.status) {
        case jl: {
          var M = T.id = s.nextSegmentId++;
          return T.lastPushedText = !1, T.textEmbedded = !1, Sa(f, s.responseState, M);
        }
        case Yr: {
          T.status = Fo;
          for (var X = !0, de = T.chunks, ye = 0, Le = T.children, o = 0; o < Le.length; o++) {
            for (var d = Le[o]; ye < d.index; ye++)
              g(f, de[ye]);
            X = Ho(s, f, d);
          }
          for (; ye < de.length - 1; ye++)
            g(f, de[ye]);
          return ye < de.length && (X = x(f, de[ye])), X;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ho(s, f, T) {
      var M = T.boundary;
      if (M === null)
        return Ti(s, f, T);
      if (M.parentFlushed = !0, M.forceClientRender)
        return jn(f, s.responseState, M.errorDigest, M.errorMessage, M.errorComponentStack), Ti(s, f, T), ml(f, s.responseState);
      if (M.pendingTasks > 0) {
        M.rootSegmentID = s.nextSegmentId++, M.completedSegments.length > 0 && s.partialBoundaries.push(M);
        var X = M.id = hr(s.responseState);
        return Ta(f, s.responseState, X), Ti(s, f, T), Ra(f, s.responseState);
      } else {
        if (M.byteSize > s.progressiveChunkSize)
          return M.rootSegmentID = s.nextSegmentId++, s.completedBoundaries.push(M), Ta(f, s.responseState, M.id), Ti(s, f, T), Ra(f, s.responseState);
        Zi(f, s.responseState);
        var de = M.completedSegments;
        if (de.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var ye = de[0];
        return Ho(s, f, ye), Qi(f, s.responseState);
      }
    }
    function gc(s, f, T) {
      return Os(f, s.responseState, T.id, T.errorDigest, T.errorMessage, T.errorComponentStack);
    }
    function Ri(s, f, T) {
      return kt(f, s.responseState, T.formatContext, T.id), Ho(s, f, T), Jt(f, T.formatContext);
    }
    function Ci(s, f, T) {
      for (var M = T.completedSegments, X = 0; X < M.length; X++) {
        var de = M[X];
        is(s, f, T, de);
      }
      return M.length = 0, yl(f, s.responseState, T.id, T.rootSegmentID);
    }
    function _d(s, f, T) {
      for (var M = T.completedSegments, X = 0; X < M.length; X++) {
        var de = M[X];
        if (!is(s, f, T, de))
          return X++, M.splice(0, X), !1;
      }
      return M.splice(0, X), !0;
    }
    function is(s, f, T, M) {
      if (M.status === Fo)
        return !0;
      var X = M.id;
      if (X === -1) {
        var de = M.id = T.rootSegmentID;
        if (de === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Ri(s, f, M);
      } else
        return Ri(s, f, M), ju(f, s.responseState, X);
    }
    function Vo(s, f) {
      h();
      try {
        var T = s.completedRootSegment;
        T !== null && s.pendingRootTasks === 0 && (Ho(s, f, T), s.completedRootSegment = null, fl(f, s.responseState));
        var M = s.clientRenderedBoundaries, X;
        for (X = 0; X < M.length; X++) {
          var de = M[X];
          gc(s, f, de);
        }
        M.splice(0, X);
        var ye = s.completedBoundaries;
        for (X = 0; X < ye.length; X++) {
          var Le = ye[X];
          Ci(s, f, Le);
        }
        ye.splice(0, X), w(f), h(f);
        var o = s.partialBoundaries;
        for (X = 0; X < o.length; X++) {
          var d = o[X];
          if (!_d(s, f, d)) {
            s.destination = null, X++, o.splice(0, X);
            return;
          }
        }
        o.splice(0, X);
        var k = s.completedBoundaries;
        for (X = 0; X < k.length; X++) {
          var P = k[X];
          Ci(s, f, P);
        }
        k.splice(0, X);
      } finally {
        w(f), s.allPendingTasks === 0 && s.pingedTasks.length === 0 && s.clientRenderedBoundaries.length === 0 && s.completedBoundaries.length === 0 && (s.abortableTasks.size !== 0 && a("There was still abortable task at the root when we closed. This is a bug in React."), y(f));
      }
    }
    function Od(s) {
      u(function() {
        return wi(s);
      });
    }
    function vc(s, f) {
      if (s.status === Ul) {
        s.status = ma, A(f, s.fatalError);
        return;
      }
      if (s.status !== ma && s.destination === null) {
        s.destination = f;
        try {
          Vo(s, f);
        } catch (T) {
          xr(s, T), Xr(s, T);
        }
      }
    }
    function Wo(s, f) {
      try {
        var T = s.abortableTasks;
        T.forEach(function(M) {
          return Io(M, s, f);
        }), T.clear(), s.destination !== null && Vo(s, s.destination);
      } catch (M) {
        xr(s, M), Xr(s, M);
      }
    }
    function Fd(s, f) {
      return new Promise(function(T, M) {
        var X, de, ye = new Promise(function(H, oe) {
          de = H, X = oe;
        });
        function Le() {
          var H = new ReadableStream(
            {
              type: "bytes",
              pull: function(oe) {
                vc(d, oe);
              },
              cancel: function(oe) {
                Wo(d);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          H.allReady = ye, T(H);
        }
        function o(H) {
          ye.catch(function() {
          }), M(H);
        }
        var d = wd(s, cn(f ? f.identifierPrefix : void 0, f ? f.nonce : void 0, f ? f.bootstrapScriptContent : void 0, f ? f.bootstrapScripts : void 0, f ? f.bootstrapModules : void 0), zn(f ? f.namespaceURI : void 0), f ? f.progressiveChunkSize : void 0, f ? f.onError : void 0, de, Le, o, X);
        if (f && f.signal) {
          var k = f.signal, P = function() {
            Wo(d, k.reason), k.removeEventListener("abort", P);
          };
          k.addEventListener("abort", P);
        }
        Od(d);
      });
    }
    Mc.renderToReadableStream = Fd, Mc.version = t;
  }()), Mc;
}
var Wi, $f;
process.env.NODE_ENV === "production" ? (Wi = gS(), $f = vS()) : (Wi = xS(), $f = bS());
Xa.version = Wi.version;
Xa.renderToString = Wi.renderToString;
Xa.renderToStaticMarkup = Wi.renderToStaticMarkup;
Xa.renderToNodeStream = Wi.renderToNodeStream;
Xa.renderToStaticNodeStream = Wi.renderToStaticNodeStream;
Xa.renderToReadableStream = $f.renderToReadableStream;
const rm = ({ columnData: e }) => /* @__PURE__ */ React.createElement("ul", null, e == null ? void 0 : e.map((t, n) => /* @__PURE__ */ React.createElement("li", { key: n }, t.label, ": ", t.value, " (", t.additional_info, "%)"))), ES = (e, t) => {
  var h, g, x, w, y, R;
  const n = `${(((h = e == null ? void 0 : e.tooltips) == null ? void 0 : h.find((b) => b.node === t)) || {}).value}`, r = `${(((g = e == null ? void 0 : e.tooltips) == null ? void 0 : g.find((b) => b.node === t)) || {}).summary}`, a = (((x = e == null ? void 0 : e.tooltips) == null ? void 0 : x.find((b) => b.node === t)) || {}).column1Label, i = (((w = e == null ? void 0 : e.tooltips) == null ? void 0 : w.find((b) => b.node === t)) || {}).column2Label, u = (((y = e == null ? void 0 : e.tooltips) == null ? void 0 : y.find((b) => b.node === t)) || {}).column1, c = (((R = e == null ? void 0 : e.tooltips) == null ? void 0 : R.find((b) => b.node === t)) || {}).column2, l = Xa.renderToString(/* @__PURE__ */ React.createElement(rm, { columnData: u })), p = Xa.renderToString(/* @__PURE__ */ React.createElement(rm, { columnData: c }));
  return `<div class="sankey-chart__tooltip">
    <span class="sankey-chart__tooltip--tooltip-header">${t}</span>
    <span class="sankey-chart__tooltip--tooltip-header">${n}</span>
    <div class="divider"></div>
    <span><strong>Summary: </strong>${r}</span>
    <div class="divider"></div>
    <div class="sankey-chart__tooltip--info-section">
      <div>
        <span><strong>${a}</strong></span>
        ${l}
      </div>
      <div>
        <span><strong>${i}</strong></span>
        ${p}
      </div>
    </div>
  </div>
`;
}, SS = ({ width: e, height: t, runtime: n }) => {
  var K, re;
  const { config: r } = ue.useContext(mt), { sankey: a } = r, [i, u] = ue.useState(0), [c, l] = ue.useState(""), { showAlert: p, alert: h } = yS(), g = ue.useRef([]), x = (B) => {
    const j = c;
    j && l(""), j !== B && l(B);
  };
  if (ue.useEffect(() => {
    var j;
    let B = 0;
    (j = g == null ? void 0 : g.current) == null || j.map((se) => {
      const ee = se == null ? void 0 : se.getBoundingClientRect().width;
      ee > B && (B = ee);
    }), u(B);
  }, [g, a, window.innerWidth]), r.visualizationType !== "Sankey")
    return;
  const w = r == null ? void 0 : r.data[0], y = Array.from(new Set((K = w == null ? void 0 : w.links) == null ? void 0 : K.flatMap((B) => [B.source, B.target]))), R = {
    nodes: y.map((B) => ({ id: B })),
    links: (re = w == null ? void 0 : w.links) == null ? void 0 : re.map((B) => ({
      source: y.findIndex((j) => j === B.source),
      target: y.findIndex((j) => j === B.target),
      value: B.value
    }))
  };
  let b = 5;
  const v = 50, A = fS().nodeWidth(a.nodeSize.nodeWidth).nodePadding(a.nodePadding).iterations(a.iterations).nodeAlign(lS).extent([
    [a.margin.margin_x, Number(a.margin.margin_y)],
    [e - b - i, r.heights.vertical - v]
  ]), { links: N } = A(R), L = (B) => {
    var Z;
    let j = 30, se = 0, ee = "node-value--storynode", Q = !0;
    return (Z = w == null ? void 0 : w.storyNodeText) != null && Z.every((Y) => Y.StoryNode !== B) && (Q = !1, se = 10, j = 8, ee = "node-value"), { textPositionHorizontal: j, textPositionVertical: se, classStyle: ee, storyNodes: Q };
  }, C = (B) => {
    if (!(R != null && R.nodes))
      return { sourceNodes: [], activeLinks: [] };
    const j = R.nodes.find((Q) => Q.id === B), se = [], ee = [];
    return j && (N.forEach((Q) => {
      const Z = Q.target, Y = Q.source;
      Z.id === B && se.push(Y.id);
    }), se.forEach((Q) => {
      N.forEach((Z) => {
        const Y = Z.target, te = Z.source;
        Y.id === c && te.id === Q && ee.push(Z);
      });
    })), { sourceNodes: se, activeLinks: ee };
  }, z = ES(w, c), W = R.nodes.map((B, j) => {
    var be, ve;
    let { textPositionHorizontal: se, textPositionVertical: ee, classStyle: Q, storyNodes: Z } = L(B.id), { sourceNodes: Y } = C(c), te = a.opacity.nodeOpacityDefault, $ = a.nodeColor.default;
    c !== B.id && c !== "" && !Y.includes(B.id) && ($ = a.nodeColor.inactive, te = a.opacity.nodeOpacityInactive);
    const ce = A.nodeWidth(), Se = () => Math.sqrt(
      Math.pow(N[0].target.x0 - N[0].source.x1, 2) + Math.pow(N[0].target.y0 - N[0].source.y1, 2)
    ) - i;
    return /* @__PURE__ */ React.createElement(tt, { className: "", key: j }, /* @__PURE__ */ React.createElement(
      "rect",
      {
        height: B.y1 - B.y0 + 2,
        width: ce,
        x: B.x0,
        y: B.y0 - 1,
        fill: $,
        fillOpacity: te,
        rx: a.rxValue,
        "data-tooltip-html": w.tooltips && r.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
        onClick: () => x(B.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), Z ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      ht,
      {
        width: Se(),
        x: B.x0 + se,
        textAnchor: R.nodes.length - 1 === j ? "end" : "start",
        verticalAnchor: "end",
        y: (B.y1 + B.y0) / 2 - 30,
        fill: a.nodeFontColor,
        fontWeight: "bold",
        className: "node-text",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.id),
        "data-tooltip-html": w.tooltips && r.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      (((be = w == null ? void 0 : w.storyNodeText) == null ? void 0 : be.find((Pe) => Pe.StoryNode === B.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ React.createElement(
      ht,
      {
        width: Se(),
        verticalAnchor: "middle",
        className: Q,
        x: B.x0 + se,
        y: (B.y1 + B.y0 + 25) / 2,
        fill: a.storyNodeFontColor || a.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.id),
        "data-tooltip-html": w.tooltips && r.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      typeof B.value == "number" ? B.value.toLocaleString() : B.value
    ), /* @__PURE__ */ React.createElement(
      ht,
      {
        width: Se(),
        x: B.x0 + se,
        y: (B.y1 + B.y0) / 2 + 50,
        fill: a.nodeFontColor,
        fontWeight: "bold",
        textAnchor: R.nodes.length === j ? "end" : "start",
        className: "node-text",
        verticalAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.id),
        "data-tooltip-html": w.tooltips && r.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      (((ve = w == null ? void 0 : w.storyNodeText) == null ? void 0 : ve.find((Pe) => Pe.StoryNode === B.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      ht,
      {
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.id),
        "data-tooltip-html": w.tooltips && r.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
        x: B.x0 + se,
        y: (B.y1 + B.y0) / 2 + ee,
        dominantBaseline: "text-before-edge",
        fill: a.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start"
      },
      B.id
    ), /* @__PURE__ */ React.createElement(
      "text",
      {
        x: B.x0 + se,
        y: (B.y1 + B.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: a.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.id),
        "data-tooltip-html": w.tooltips && r.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      /* @__PURE__ */ React.createElement("tspan", { className: Q }, a.nodeValueStyle.textBefore + (typeof B.value == "number" ? B.value.toLocaleString() : B.value) + a.nodeValueStyle.textAfter)
    )));
  }), q = N.map((B, j) => {
    const ee = mS()(B);
    let Q = a.opacity.LinkOpacityDefault, Z = a.linkColor.default, { activeLinks: Y } = C(c);
    return !Y.includes(B) && c !== "" && (Z = a.linkColor.inactive, Q = a.opacity.LinkOpacityInactive), /* @__PURE__ */ React.createElement(
      "path",
      {
        key: j,
        d: ee,
        stroke: Z,
        fill: "none",
        strokeOpacity: Q,
        strokeWidth: B.width + 2,
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(B.target.id || null),
        "data-tooltip-html": w.tooltips && r.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      }
    );
  }), ne = R.nodes.reduce((B, j) => Math.max(B, j.depth), -1), le = R.nodes.filter((B) => B.depth === ne).map((B, j) => {
    var ce, Se;
    let { textPositionHorizontal: se, textPositionVertical: ee, classStyle: Q, storyNodes: Z } = L(B.id), { sourceNodes: Y } = C(c), te = a.opacity.nodeOpacityDefault, $ = a.nodeColor.default;
    return c !== B.id && c !== "" && !Y.includes(B.id) && ($ = a.nodeColor.inactive, te = a.opacity.nodeOpacityInactive), /* @__PURE__ */ React.createElement(tt, { className: "", key: j, innerRef: (be) => g.current[j] = be }, /* @__PURE__ */ React.createElement(
      "rect",
      {
        height: B.y1 - B.y0 + 2,
        width: A.nodeWidth(),
        x: B.x0,
        y: B.y0 - 1,
        fill: $,
        fillOpacity: te,
        rx: a.rxValue,
        "data-tooltip-html": w.tooltips && r.enableTooltips && c !== "" ? z : null,
        "data-tooltip-id": "tooltip",
        onClick: () => x(B.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), Z ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      ht,
      {
        x: B.x0 + se,
        textAnchor: R.nodes.length - 1 === j ? "end" : "start",
        verticalAnchor: "end",
        y: (B.y1 + B.y0) / 2 - 30,
        fill: a.nodeFontColor,
        fontWeight: "bold",
        style: { pointerEvents: "none" },
        className: "node-text"
      },
      (((ce = w == null ? void 0 : w.storyNodeText) == null ? void 0 : ce.find((be) => be.StoryNode === B.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ React.createElement(
      ht,
      {
        verticalAnchor: "end",
        className: Q,
        x: B.x0 + se,
        y: (B.y1 + B.y0 + 25) / 2,
        fill: a.storyNodeFontColor || a.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      typeof B.value == "number" ? B.value.toLocaleString() : B.value
    ), /* @__PURE__ */ React.createElement(
      ht,
      {
        x: B.x0 + se,
        y: (B.y1 + B.y0) / 2 + 50,
        fill: a.nodeFontColor,
        fontWeight: "bold",
        textAnchor: R.nodes.length === j ? "end" : "start",
        style: { pointerEvents: "none" },
        className: "node-text",
        verticalAnchor: "end"
      },
      (((Se = w == null ? void 0 : w.storyNodeText) == null ? void 0 : Se.find((be) => be.StoryNode === B.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      "text",
      {
        x: B.x0 + se,
        y: (B.y1 + B.y0) / 2 + ee,
        dominantBaseline: "text-before-edge",
        fill: a.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ React.createElement("tspan", { id: B.id, className: "node-id" }, B.id)
    ), /* @__PURE__ */ React.createElement(
      "text",
      {
        x: B.x0 + se,
        y: (B.y1 + B.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: a.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ React.createElement("tspan", { onClick: () => x(B.id), className: Q }, a.nodeValueStyle.textBefore + (typeof B.value == "number" ? B.value.toLocaleString() : B.value) + a.nodeValueStyle.textAfter)
    )));
  });
  return p ? h : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: "sankey-chart" }, /* @__PURE__ */ React.createElement(
    "svg",
    {
      className: "sankey-chart__diagram",
      width: e,
      height: Number(r.heights.vertical),
      style: { overflow: "visible" }
    },
    /* @__PURE__ */ React.createElement(tt, { className: "links" }, q),
    /* @__PURE__ */ React.createElement(tt, { className: "nodes" }, W),
    /* @__PURE__ */ React.createElement(tt, { className: "finalNodes", style: { display: "none" } }, le)
  ), /* @__PURE__ */ React.createElement(
    yu,
    {
      id: `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
      afterHide: () => l(""),
      events: ["click"],
      place: "bottom",
      style: {
        backgroundColor: "rgba(238, 238, 238, 1)",
        color: "black",
        boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)"
      }
    }
  )));
};
var kS = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const fr = kS;
function wS(e) {
  var t = e.labelOffset, n = e.labelProps, r = e.orientation, a = e.range, i = e.tickLabelFontSize, u = e.tickLength, c = r === fr.left || r === fr.top ? -1 : 1, l, p, h;
  if (r === fr.top || r === fr.bottom) {
    var g = r === fr.bottom && typeof n.fontSize == "number" ? n.fontSize : 0;
    l = (Number(a[0]) + Number(a[a.length - 1])) / 2, p = c * (u + t + i + g);
  } else
    l = c * ((Number(a[0]) + Number(a[a.length - 1])) / 2), p = -(u + t), h = "rotate(" + c * 90 + ")";
  return {
    x: l,
    y: p,
    transform: h
  };
}
function vs() {
  return vs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, vs.apply(this, arguments);
}
function TS(e) {
  var t = e.hideTicks, n = e.horizontal, r = e.orientation, a = e.tickClassName, i = e.tickComponent, u = e.tickLabelProps, c = e.tickStroke, l = c === void 0 ? "#222" : c, p = e.tickTransform, h = e.ticks, g = e.strokeWidth, x = e.tickLineProps;
  return h.map(function(w) {
    var y, R = w.value, b = w.index, v = w.from, A = w.to, N = w.formattedValue, L = (y = u[b]) != null ? y : {}, C = Math.max(10, typeof L.fontSize == "number" && L.fontSize || 0), z = A.y + (n && r !== fr.top ? C : 0);
    return /* @__PURE__ */ m.createElement(tt, {
      key: "visx-tick-" + R + "-" + b,
      className: Sn("visx-axis-tick", a),
      transform: p
    }, !t && /* @__PURE__ */ m.createElement(en, vs({
      from: v,
      to: A,
      stroke: l,
      strokeWidth: g,
      strokeLinecap: "square"
    }, x)), i ? i(vs({}, L, {
      x: A.x,
      y: z,
      formattedValue: N
    })) : /* @__PURE__ */ m.createElement(ht, vs({
      x: A.x,
      y: z
    }, L), N));
  });
}
function vu() {
  return vu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, vu.apply(this, arguments);
}
var am = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function RS(e) {
  var t = e.axisFromPoint, n = e.axisLineClassName, r = e.axisToPoint, a = e.hideAxisLine, i = e.hideTicks, u = e.horizontal, c = e.label, l = c === void 0 ? "" : c, p = e.labelClassName, h = e.labelOffset, g = h === void 0 ? 14 : h, x = e.labelProps, w = x === void 0 ? am : x, y = e.orientation, R = y === void 0 ? fr.bottom : y, b = e.scale, v = e.stroke, A = v === void 0 ? "#222" : v, N = e.strokeDasharray, L = e.strokeWidth, C = L === void 0 ? 1 : L, z = e.tickClassName, W = e.tickComponent, q = e.tickLineProps, ne = e.tickLabelProps, G = e.tickLength, le = G === void 0 ? 8 : G, K = e.tickStroke, re = K === void 0 ? "#222" : K, B = e.tickTransform, j = e.ticks, se = e.ticksComponent, ee = se === void 0 ? TS : se, Q = vu({}, am, typeof ne == "object" ? ne : null), Z = j.map(function(te) {
    var $ = te.value, ce = te.index;
    return typeof ne == "function" ? ne($, ce, j) : Q;
  }), Y = Math.max.apply(Math, [10].concat(Z.map(function(te) {
    return typeof te.fontSize == "number" ? te.fontSize : 0;
  })));
  return /* @__PURE__ */ m.createElement(m.Fragment, null, ee({
    hideTicks: i,
    horizontal: u,
    orientation: R,
    scale: b,
    tickClassName: z,
    tickComponent: W,
    tickLabelProps: Z,
    tickStroke: re,
    tickTransform: B,
    ticks: j,
    strokeWidth: C,
    tickLineProps: q
  }), !a && /* @__PURE__ */ m.createElement(en, {
    className: Sn("visx-axis-line", n),
    from: t,
    to: r,
    stroke: A,
    strokeWidth: C,
    strokeDasharray: N
  }), l && /* @__PURE__ */ m.createElement(ht, vu({
    className: Sn("visx-axis-label", p)
  }, wS({
    labelOffset: g,
    labelProps: w,
    orientation: R,
    range: b.range(),
    tickLabelFontSize: Y,
    tickLength: le
  }), w), l));
}
function CS(e, t) {
  t === void 0 && (t = "center");
  var n = e;
  if (t !== "start" && "bandwidth" in n) {
    var r = n.bandwidth();
    return t === "center" && (r /= 2), n.round() && (r = Math.round(r)), function(a) {
      var i = n(a);
      return typeof i == "number" ? i + r : i;
    };
  }
  return e;
}
function AS(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : jE;
}
function zc(e, t) {
  var n = e.x, r = e.y;
  return new Tg(t ? {
    x: n,
    y: r
  } : {
    x: r,
    y: n
  });
}
function Hf() {
  return Hf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Hf.apply(this, arguments);
}
var tf = 0;
function LS(e) {
  return e === void 0 && (e = tf), typeof e == "number" ? {
    start: e,
    end: e
  } : Hf({
    start: tf,
    end: tf
  }, e);
}
var NS = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Vf() {
  return Vf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Vf.apply(this, arguments);
}
function PS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function Iu(e) {
  var t = e.children, n = t === void 0 ? RS : t, r = e.axisClassName, a = e.hideAxisLine, i = a === void 0 ? !1 : a, u = e.hideTicks, c = u === void 0 ? !1 : u, l = e.hideZero, p = l === void 0 ? !1 : l, h = e.innerRef, g = e.left, x = g === void 0 ? 0 : g, w = e.numTicks, y = w === void 0 ? 10 : w, R = e.orientation, b = R === void 0 ? fr.bottom : R, v = e.rangePadding, A = v === void 0 ? 0 : v, N = e.scale, L = e.tickFormat, C = e.tickLength, z = C === void 0 ? 8 : C, W = e.tickValues, q = e.top, ne = q === void 0 ? 0 : q, G = PS(e, NS), le = L ?? AS(N), K = b === fr.left, re = b === fr.top, B = re || b === fr.bottom, j = CS(N), se = K || re ? -1 : 1, ee = N.range(), Q = LS(A), Z = zc({
    x: Number(ee[0]) + 0.5 - Q.start,
    y: 0
  }, B), Y = zc({
    x: Number(ee[ee.length - 1]) + 0.5 + Q.end,
    y: 0
  }, B), te = (W ?? Yy(N, y)).filter(function(ce) {
    return !p || ce !== 0 && ce !== "0";
  }).map(function(ce, Se) {
    return {
      value: ce,
      index: Se
    };
  }), $ = te.map(function(ce) {
    var Se = ce.value, be = ce.index, ve = WE(j(Se));
    return {
      value: Se,
      index: be,
      from: zc({
        x: ve,
        y: 0
      }, B),
      to: zc({
        x: ve,
        y: z * se
      }, B),
      formattedValue: le(Se, be, te)
    };
  });
  return /* @__PURE__ */ m.createElement(tt, {
    className: Sn("visx-axis", r),
    innerRef: h,
    top: ne,
    left: x
  }, n(Vf({}, G, {
    axisFromPoint: Z,
    axisToPoint: Y,
    hideAxisLine: i,
    hideTicks: c,
    hideZero: p,
    horizontal: B,
    numTicks: y,
    orientation: b,
    rangePadding: A,
    scale: N,
    tickFormat: le,
    tickLength: z,
    tickPosition: j,
    tickSign: se,
    ticks: $
  })));
}
var DS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function xu() {
  return xu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, xu.apply(this, arguments);
}
function _S(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var OS = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function im(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 36 : n, a = e.tickLength, i = a === void 0 ? 8 : a, u = e.tickLabelProps, c = _S(e, DS), l = typeof u == "function" ? u : xu({}, OS, u);
  return /* @__PURE__ */ m.createElement(Iu, xu({
    axisClassName: Sn("visx-axis-left", t),
    labelOffset: r,
    orientation: fr.left,
    tickLabelProps: l,
    tickLength: i
  }, c));
}
var FS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function bu() {
  return bu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, bu.apply(this, arguments);
}
function MS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var zS = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function BS(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 36 : n, a = e.tickLength, i = a === void 0 ? 8 : a, u = e.tickLabelProps, c = MS(e, FS), l = typeof u == "function" ? u : bu({}, zS, u);
  return /* @__PURE__ */ m.createElement(Iu, bu({
    axisClassName: Sn("visx-axis-right", t),
    labelOffset: r,
    orientation: fr.right,
    tickLabelProps: l,
    tickLength: i
  }, c));
}
var IS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Eu() {
  return Eu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Eu.apply(this, arguments);
}
function $S(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var HS = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function VS(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 8 : n, a = e.tickLength, i = a === void 0 ? 8 : a, u = e.tickLabelProps, c = $S(e, IS), l = typeof u == "function" ? u : Eu({}, HS, u);
  return /* @__PURE__ */ m.createElement(Iu, Eu({
    axisClassName: Sn("visx-axis-top", t),
    labelOffset: r,
    orientation: fr.top,
    tickLabelProps: l,
    tickLength: i
  }, c));
}
var WS = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Su() {
  return Su = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Su.apply(this, arguments);
}
function jS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var US = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function jc(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 8 : n, a = e.tickLength, i = a === void 0 ? 8 : a, u = e.tickLabelProps, c = jS(e, WS), l = typeof u == "function" ? u : Su({}, US, u);
  return /* @__PURE__ */ m.createElement(Iu, Su({
    axisClassName: Sn("visx-axis-bottom", t),
    labelOffset: r,
    orientation: fr.bottom,
    tickLabelProps: l,
    tickLength: i
  }, c));
}
const nf = (e) => () => e;
function KS(e, {
  sourceEvent: t,
  target: n,
  selection: r,
  mode: a,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    selection: { value: r, enumerable: !0, configurable: !0 },
    mode: { value: a, enumerable: !0, configurable: !0 },
    _: { value: i }
  });
}
function YS(e) {
  e.stopImmediatePropagation();
}
function rf(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var om = { name: "drag" }, af = { name: "space" }, qo = { name: "handle" }, Zo = { name: "center" };
const { abs: lm, max: Zn, min: Qn } = Math;
function sm(e) {
  return [+e[0], +e[1]];
}
function cm(e) {
  return [sm(e[0]), sm(e[1])];
}
var Uc = {
  name: "x",
  handles: ["w", "e"].map(ku),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, of = {
  name: "y",
  handles: ["n", "s"].map(ku),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, ya = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, um = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, dm = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, GS = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, XS = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function ku(e) {
  return { type: e };
}
function qS(e) {
  return !e.ctrlKey && !e.button;
}
function ZS() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function QS() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function lf(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function JS(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function ek() {
  return tk(Uc);
}
function tk(e) {
  var t = ZS, n = qS, r = QS, a = !0, i = Rg("start", "brush", "end"), u = 6, c;
  function l(b) {
    var v = b.property("__brush", R).selectAll(".overlay").data([ku("overlay")]);
    v.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", ya.overlay).merge(v).each(function() {
      var N = lf(this).extent;
      Jo(this).attr("x", N[0][0]).attr("y", N[0][1]).attr("width", N[1][0] - N[0][0]).attr("height", N[1][1] - N[0][1]);
    }), b.selectAll(".selection").data([ku("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", ya.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var A = b.selectAll(".handle").data(e.handles, function(N) {
      return N.type;
    });
    A.exit().remove(), A.enter().append("rect").attr("class", function(N) {
      return "handle handle--" + N.type;
    }).attr("cursor", function(N) {
      return ya[N.type];
    }), b.each(p).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", x).filter(r).on("touchstart.brush", x).on("touchmove.brush", w).on("touchend.brush touchcancel.brush", y).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  l.move = function(b, v, A) {
    b.tween ? b.on("start.brush", function(N) {
      h(this, arguments).beforestart().start(N);
    }).on("interrupt.brush end.brush", function(N) {
      h(this, arguments).end(N);
    }).tween("brush", function() {
      var N = this, L = N.__brush, C = h(N, arguments), z = L.selection, W = e.input(typeof v == "function" ? v.apply(this, arguments) : v, L.extent), q = lv(z, W);
      function ne(G) {
        L.selection = G === 1 && W === null ? null : q(G), p.call(N), C.brush();
      }
      return z !== null && W !== null ? ne : ne(1);
    }) : b.each(function() {
      var N = this, L = arguments, C = N.__brush, z = e.input(typeof v == "function" ? v.apply(N, L) : v, C.extent), W = h(N, L).beforestart();
      _p(N), C.selection = z === null ? null : z, p.call(N), W.start(A).brush(A).end(A);
    });
  }, l.clear = function(b, v) {
    l.move(b, null, v);
  };
  function p() {
    var b = Jo(this), v = lf(this).selection;
    v ? (b.selectAll(".selection").style("display", null).attr("x", v[0][0]).attr("y", v[0][1]).attr("width", v[1][0] - v[0][0]).attr("height", v[1][1] - v[0][1]), b.selectAll(".handle").style("display", null).attr("x", function(A) {
      return A.type[A.type.length - 1] === "e" ? v[1][0] - u / 2 : v[0][0] - u / 2;
    }).attr("y", function(A) {
      return A.type[0] === "s" ? v[1][1] - u / 2 : v[0][1] - u / 2;
    }).attr("width", function(A) {
      return A.type === "n" || A.type === "s" ? v[1][0] - v[0][0] + u : u;
    }).attr("height", function(A) {
      return A.type === "e" || A.type === "w" ? v[1][1] - v[0][1] + u : u;
    })) : b.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function h(b, v, A) {
    var N = b.__brush.emitter;
    return N && (!A || !N.clean) ? N : new g(b, v, A);
  }
  function g(b, v, A) {
    this.that = b, this.args = v, this.state = b.__brush, this.active = 0, this.clean = A;
  }
  g.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(b, v) {
      return this.starting ? (this.starting = !1, this.emit("start", b, v)) : this.emit("brush", b), this;
    },
    brush: function(b, v) {
      return this.emit("brush", b, v), this;
    },
    end: function(b, v) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", b, v)), this;
    },
    emit: function(b, v, A) {
      var N = Jo(this.that).datum();
      i.call(
        b,
        this.that,
        new KS(b, {
          sourceEvent: v,
          target: l,
          selection: e.output(this.state.selection),
          mode: A,
          dispatch: i
        }),
        N
      );
    }
  };
  function x(b) {
    if (c && !b.touches || !n.apply(this, arguments))
      return;
    var v = this, A = b.target.__data__.type, N = (a && b.metaKey ? A = "overlay" : A) === "selection" ? om : a && b.altKey ? Zo : qo, L = e === of ? null : GS[A], C = e === Uc ? null : XS[A], z = lf(v), W = z.extent, q = z.selection, ne = W[0][0], G, le, K = W[0][1], re, B, j = W[1][0], se, ee, Q = W[1][1], Z, Y, te = 0, $ = 0, ce, Se = L && C && a && b.shiftKey, be, ve, Pe = Array.from(b.touches || [b], (Fe) => {
      const qe = Fe.identifier;
      return Fe = Op(Fe, v), Fe.point0 = Fe.slice(), Fe.identifier = qe, Fe;
    });
    _p(v);
    var Ve = h(v, arguments, !0).beforestart();
    if (A === "overlay") {
      q && (ce = !0);
      const Fe = [Pe[0], Pe[1] || Pe[0]];
      z.selection = q = [[
        G = e === of ? ne : Qn(Fe[0][0], Fe[1][0]),
        re = e === Uc ? K : Qn(Fe[0][1], Fe[1][1])
      ], [
        se = e === of ? j : Zn(Fe[0][0], Fe[1][0]),
        Z = e === Uc ? Q : Zn(Fe[0][1], Fe[1][1])
      ]], Pe.length > 1 && ze(b);
    } else
      G = q[0][0], re = q[0][1], se = q[1][0], Z = q[1][1];
    le = G, B = re, ee = se, Y = Z;
    var we = Jo(v).attr("pointer-events", "none"), me = we.selectAll(".overlay").attr("cursor", ya[A]);
    if (b.touches)
      Ve.moved = fe, Ve.ended = Ie;
    else {
      var Ce = Jo(b.view).on("mousemove.brush", fe, !0).on("mouseup.brush", Ie, !0);
      a && Ce.on("keydown.brush", Qe, !0).on("keyup.brush", He, !0), Cg(b.view);
    }
    p.call(v), Ve.start(b, N.name);
    function fe(Fe) {
      for (const qe of Fe.changedTouches || [Fe])
        for (const We of Pe)
          We.identifier === qe.identifier && (We.cur = Op(qe, v));
      if (Se && !be && !ve && Pe.length === 1) {
        const qe = Pe[0];
        lm(qe.cur[0] - qe[0]) > lm(qe.cur[1] - qe[1]) ? ve = !0 : be = !0;
      }
      for (const qe of Pe)
        qe.cur && (qe[0] = qe.cur[0], qe[1] = qe.cur[1]);
      ce = !0, rf(Fe), ze(Fe);
    }
    function ze(Fe) {
      const qe = Pe[0], We = qe.point0;
      var je;
      switch (te = qe[0] - We[0], $ = qe[1] - We[1], N) {
        case af:
        case om: {
          L && (te = Zn(ne - G, Qn(j - se, te)), le = G + te, ee = se + te), C && ($ = Zn(K - re, Qn(Q - Z, $)), B = re + $, Y = Z + $);
          break;
        }
        case qo: {
          Pe[1] ? (L && (le = Zn(ne, Qn(j, Pe[0][0])), ee = Zn(ne, Qn(j, Pe[1][0])), L = 1), C && (B = Zn(K, Qn(Q, Pe[0][1])), Y = Zn(K, Qn(Q, Pe[1][1])), C = 1)) : (L < 0 ? (te = Zn(ne - G, Qn(j - G, te)), le = G + te, ee = se) : L > 0 && (te = Zn(ne - se, Qn(j - se, te)), le = G, ee = se + te), C < 0 ? ($ = Zn(K - re, Qn(Q - re, $)), B = re + $, Y = Z) : C > 0 && ($ = Zn(K - Z, Qn(Q - Z, $)), B = re, Y = Z + $));
          break;
        }
        case Zo: {
          L && (le = Zn(ne, Qn(j, G - te * L)), ee = Zn(ne, Qn(j, se + te * L))), C && (B = Zn(K, Qn(Q, re - $ * C)), Y = Zn(K, Qn(Q, Z + $ * C)));
          break;
        }
      }
      ee < le && (L *= -1, je = G, G = se, se = je, je = le, le = ee, ee = je, A in um && me.attr("cursor", ya[A = um[A]])), Y < B && (C *= -1, je = re, re = Z, Z = je, je = B, B = Y, Y = je, A in dm && me.attr("cursor", ya[A = dm[A]])), z.selection && (q = z.selection), be && (le = q[0][0], ee = q[1][0]), ve && (B = q[0][1], Y = q[1][1]), (q[0][0] !== le || q[0][1] !== B || q[1][0] !== ee || q[1][1] !== Y) && (z.selection = [[le, B], [ee, Y]], p.call(v), Ve.brush(Fe, N.name));
    }
    function Ie(Fe) {
      if (YS(Fe), Fe.touches) {
        if (Fe.touches.length)
          return;
        c && clearTimeout(c), c = setTimeout(function() {
          c = null;
        }, 500);
      } else
        Ag(Fe.view, ce), Ce.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      we.attr("pointer-events", "all"), me.attr("cursor", ya.overlay), z.selection && (q = z.selection), JS(q) && (z.selection = null, p.call(v)), Ve.end(Fe, N.name);
    }
    function Qe(Fe) {
      switch (Fe.keyCode) {
        case 16: {
          Se = L && C;
          break;
        }
        case 18: {
          N === qo && (L && (se = ee - te * L, G = le + te * L), C && (Z = Y - $ * C, re = B + $ * C), N = Zo, ze(Fe));
          break;
        }
        case 32: {
          (N === qo || N === Zo) && (L < 0 ? se = ee - te : L > 0 && (G = le - te), C < 0 ? Z = Y - $ : C > 0 && (re = B - $), N = af, me.attr("cursor", ya.selection), ze(Fe));
          break;
        }
        default:
          return;
      }
      rf(Fe);
    }
    function He(Fe) {
      switch (Fe.keyCode) {
        case 16: {
          Se && (be = ve = Se = !1, ze(Fe));
          break;
        }
        case 18: {
          N === Zo && (L < 0 ? se = ee : L > 0 && (G = le), C < 0 ? Z = Y : C > 0 && (re = B), N = qo, ze(Fe));
          break;
        }
        case 32: {
          N === af && (Fe.altKey ? (L && (se = ee - te * L, G = le + te * L), C && (Z = Y - $ * C, re = B + $ * C), N = Zo) : (L < 0 ? se = ee : L > 0 && (G = le), C < 0 ? Z = Y : C > 0 && (re = B), N = qo), me.attr("cursor", ya[A]), ze(Fe));
          break;
        }
        default:
          return;
      }
      rf(Fe);
    }
  }
  function w(b) {
    h(this, arguments).moved(b);
  }
  function y(b) {
    h(this, arguments).ended(b);
  }
  function R() {
    var b = this.__brush || { selection: null };
    return b.extent = cm(t.apply(this, arguments)), b.dim = e, b;
  }
  return l.extent = function(b) {
    return arguments.length ? (t = typeof b == "function" ? b : nf(cm(b)), l) : t;
  }, l.filter = function(b) {
    return arguments.length ? (n = typeof b == "function" ? b : nf(!!b), l) : n;
  }, l.touchable = function(b) {
    return arguments.length ? (r = typeof b == "function" ? b : nf(!!b), l) : r;
  }, l.handleSize = function(b) {
    return arguments.length ? (u = +b, l) : u;
  }, l.keyModifiers = function(b) {
    return arguments.length ? (a = !!b, l) : a;
  }, l.on = function() {
    var b = i.on.apply(i, arguments);
    return b === i ? l : b;
  }, l;
}
const nk = ({ xMax: e, yMax: t }) => {
  var B, j;
  const { tableData: n, config: r, dashboardConfig: a, formatDate: i, parseDate: u } = ue.useContext(mt), c = ue.useContext(Xf), [l, p] = ue.useState({ isBrushing: !1, selection: [] }), [h, g] = ue.useState(0), x = ((B = a == null ? void 0 : a.dashboard) == null ? void 0 : B.sharedFilters) ?? [], w = (x == null ? void 0 : x.length) > 0, [y, R] = ue.useState(!1), b = ue.useRef(), v = 25, A = 15, N = Lg(n, (se) => new Date(se[r.runtime.originalXAxis.dataKey])), L = Ky().domain(N).range([0, e]), z = pr("Drag edges to focus on a specific segment ", `normal ${16 / 1.1}px sans-serif`), W = 50, q = 1.5, ne = () => (a == null ? void 0 : a.type) === "dashboard" ? Number(t) + r.xAxis.axisBBox + v * q + W : Number(t) + r.xAxis.axisBBox + v * q, G = () => {
    l.selection[0] === 0 && e === l.selection[1] && R(!0);
  }, le = () => {
    (l.selection[0] !== 0 || l.selection[1] !== e) && R(!1), R(!1);
  }, K = (se, ee, Q, Z) => {
    const Y = pr(Q, `normal ${14.545454545454545}px sans-serif`), te = ee[0] < Y ? 0 : -Y, $ = e - ee[1] < Y ? -Y : 0;
    return se.selectAll(".handle--custom").data([{ side: "left" }, { side: "right" }]).join((ce) => {
      const Se = ce.append("g").attr("class", "handle--custom");
      return Se.append("text").attr("x", (be) => be.side === "left" ? te : $).attr("y", 30).text((be) => be.side === "left" ? Q : Z).attr("font-size", "13px"), Se;
    }).attr("display", "block").attr("transform", ee === null ? null : (ce, Se) => `translate(${ee[Se]},10)`);
  }, re = () => {
    const se = Jo(b.current).attr("overflow", "visible");
    se.append("rect").attr("fill", "#949494").attr("stroke", "#c5c5c5").attr("stroke-width", 2).attr("ry", A).attr("rx", A).attr("height", v).attr("width", e);
    const ee = (te) => {
      const $ = te == null ? void 0 : te.selection;
      let ce = te.type === "brush" && $ && $.length > 0;
      const [Se, be] = $.map((He) => L.invert(He)), ve = Je.filter(n, (He) => {
        const Fe = new Date(He[r.xAxis.dataKey]);
        return Fe && !isNaN(Fe.getTime()) && Fe >= Se && Fe <= be;
      }), Pe = r.xAxis.sortByRecentDate, Ve = Je.sortBy(ve, (He) => new Date(He[r.xAxis.dataKey])), we = Pe ? Ve.reverse() : Ve, me = Je.get(Je.first(we), r.xAxis.dataKey, ""), Ce = Je.get(Je.last(we), r.xAxis.dataKey, "");
      se.selectAll(".handle--custom").remove();
      const fe = (He) => He ? i(u(He)) : "", ze = fe(me), Ie = fe(Ce);
      se.call(K, $, ze, Ie);
      const Qe = {
        active: r.brush.active,
        isBrushing: ce,
        data: we
      };
      c({ type: "SET_BRUSH_CONFIG", payload: Qe }), p({
        isBrushing: !0,
        selection: $
      });
    }, Q = ek().extent([
      [0, 0],
      [e, 25]
    ]).on("start brush end", ee), Z = [0, e];
    let Y = se.append("g").call(Q).call(Q.move, Z);
    Y.select(".overlay").style("pointer-events", "none"), Y.selectAll(".selection").attr("fill", "#474747").attr("fill-opacity", 1).attr("rx", A).attr("ry", A);
  };
  return ue.useEffect(() => {
    var Q, Z, Y;
    const se = (Q = r.filters) == null ? void 0 : Q.some((te) => te.active), ee = (Z = r.exclusions) == null ? void 0 : Z.active;
    return (se || ee || w) && ((Y = r.brush) != null && Y.active) && g((te) => te + 1), c({ type: "SET_BRUSH_CONFIG", payload: { ...r.brush, data: n } }), () => c({ type: "SET_BRUSH_CONFIG", payload: { ...r.brush, data: [] } });
  }, [r.filters, r.exclusions, (j = r.brush) == null ? void 0 : j.active, w]), ue.useEffect(() => {
    let se = null;
    const ee = () => {
      e > 0 ? re() : (clearTimeout(se), se = setTimeout(ee, 500));
    };
    return ee(), () => {
      se && clearTimeout(se);
    };
  }, [e]), ue.useEffect(() => {
    h && re();
  }, [h]), l.isBrushing || re(), /* @__PURE__ */ React.createElement(
    tt,
    {
      onMouseLeave: le,
      onMouseOver: G,
      className: "brush-container",
      left: Number(r.runtime.yAxis.size),
      top: ne()
    },
    /* @__PURE__ */ React.createElement(
      ht,
      {
        pointerEvents: "visiblePainted",
        display: y ? "block" : "none",
        fontSize: 16,
        x: (Number(e) - Number(z)) / 2,
        y: -10
      },
      "Drag edges to focus on a specific segment"
    ),
    /* @__PURE__ */ React.createElement("svg", { width: "100%", height: v * 3, ref: b })
  );
}, Mi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: p0,
  curveBasisClosed: h0,
  curveBasisOpen: m0,
  curveBundle: y0,
  curveCardinal: g0,
  curveCardinalClosed: v0,
  curveCardinalOpen: x0,
  curveCatmullRom: b0,
  curveCatmullRomClosed: E0,
  curveCatmullRomOpen: S0,
  curveLinear: Ou,
  curveLinearClosed: kf,
  curveMonotoneX: Wc,
  curveMonotoneY: k0,
  curveNatural: w0,
  curveStep: T0,
  curveStepAfter: C0,
  curveStepBefore: R0
}, Symbol.toStringTag, { value: "Module" })), rk = (e) => {
  var z, W;
  const { xScale: t, yScale: n, yMax: r, xMax: a, handleTooltipMouseOver: i, handleTooltipMouseOff: u, isDebug: c, children: l } = e;
  let { transformedData: p, config: h, handleLineType: g, parseDate: x, formatDate: w, formatNumber: y, seriesHighlight: R, colorScale: b, rawData: v, brushConfig: A } = ue.useContext(mt);
  const N = (z = h.brush) != null && z.active && ((W = A.data) != null && W.length) ? A.data : p;
  if (!N)
    return;
  const L = (q) => (En(h.xAxis) ? t(x(q[h.xAxis.dataKey], !1)) : t(q[h.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), C = (q, ne, G = void 0) => n(q[G.dataKey]);
  return N && /* @__PURE__ */ m.createElement("svg", null, /* @__PURE__ */ m.createElement(Vr, { component: "AreaChart" }, /* @__PURE__ */ m.createElement(tt, { className: "area-chart", key: "area-wrapper", left: Number(h.yAxis.size) }, (h.runtime.areaSeriesKeys || h.series).map((q, ne) => {
    let G = N.map((B) => ({
      [h.xAxis.dataKey]: B[h.xAxis.dataKey],
      [q.dataKey]: B[q.dataKey]
    })), le = Mi[q.lineType], K = h.legend.behavior === "highlight" && R.length > 0 && R.indexOf(q.dataKey) === -1, re = h.legend.behavior === "highlight" || R.length === 0 || R.indexOf(q.dataKey) !== -1;
    return /* @__PURE__ */ m.createElement(m.Fragment, { key: ne }, /* @__PURE__ */ m.createElement(
      Hr,
      {
        data: G,
        x: (B) => L(B),
        y: (B) => C(B, ne, q),
        stroke: re ? b ? b(h.runtime.seriesLabels ? h.runtime.seriesLabels[q.dataKey] : q.dataKey) : "#000" : "transparent",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        curve: le,
        strokeDasharray: q.type ? g(q.type) : 0
      }
    ), /* @__PURE__ */ m.createElement(
      Lf,
      {
        key: "area-chart",
        fill: re ? b ? b(h.runtime.seriesLabels ? h.runtime.seriesLabels[q.dataKey] : q.dataKey) : "#000" : "transparent",
        fillOpacity: K ? 0.25 : 0.5,
        data: G,
        x: (B) => L(B),
        y: (B) => C(B, ne, q),
        yScale: n,
        curve: le,
        strokeDasharray: q.type ? g(q.type) : 0
      }
    ));
  }), /* @__PURE__ */ m.createElement(Nr, { width: Number(a), height: Number(r), fill: "transparent", fillOpacity: 0.05, onMouseMove: (q) => i(q, v), onMouseLeave: u }))));
}, ak = ue.memo(rk), ik = ({ xScale: e, yScale: t, yMax: n, xMax: r, handleTooltipMouseOver: a, handleTooltipMouseOff: i, isDebug: u }) => {
  var R, b;
  let { transformedData: c, config: l, seriesHighlight: p, colorScale: h, rawData: g } = ue.useContext(mt);
  const x = (R = l.brush) != null && R.active && ((b = l.brush.data) != null && b.length) ? l.brush.data : c;
  if (!x)
    return;
  const w = (v) => {
    if (l.xAxis.type === "categorical")
      return e(v);
    if (En(l.xAxis)) {
      let A = new Date(v);
      return e(A);
    }
  }, y = 2;
  return x && /* @__PURE__ */ m.createElement("svg", { height: Number(n) }, /* @__PURE__ */ m.createElement(Vr, { component: "AreaChartStacked" }, /* @__PURE__ */ m.createElement(
    tt,
    {
      className: "area-chart",
      key: "area-wrapper",
      left: Number(l.yAxis.size) + y / 2,
      height: Number(n),
      style: { overflow: "hidden" }
    },
    /* @__PURE__ */ m.createElement(
      aE,
      {
        data: x,
        keys: l.runtime.areaSeriesKeys.map((v) => v.dataKey) || l.series.map((v) => v.dataKey),
        x0: (v) => w(v.data[l.xAxis.dataKey]),
        y0: (v) => Number(t(v[0])),
        y1: (v) => Number(t(v[1])),
        curve: Mi[ol[l.stackedAreaChartLineType]]
      },
      ({ stacks: v, path: A }) => v.map((N, L) => {
        let C = l.legend.behavior === "highlight" && p.length > 0 && p.indexOf(N.key) === -1, z = l.legend.behavior === "highlight" || p.length === 0 || p.indexOf(N.key) !== -1;
        return (
          // prettier-ignore
          /* @__PURE__ */ m.createElement(
            "path",
            {
              key: N.key,
              d: A(N) || "",
              strokeWidth: 2,
              stroke: z ? h ? h(l.runtime.seriesLabels ? l.runtime.seriesLabels[N.key] : N.key) : "#000" : "transparent",
              fillOpacity: C ? 0.2 : 1,
              fill: z ? h ? h(l.runtime.seriesLabels ? l.runtime.seriesLabels[N.key] : N.key) : "#000" : "transparent"
            }
          )
        );
      })
    ),
    /* @__PURE__ */ m.createElement(Nr, { width: Number(r), height: Number(n), fill: "transparent", onMouseMove: (v) => a(v, g), onMouseLeave: i })
  )));
}, ok = ue.memo(ik), $u = () => {
  const { config: e, colorPalettes: t, tableData: n, updateConfig: r, parseDate: a, formatDate: i, setSeriesHighlight: u, seriesHighlight: c } = ue.useContext(mt), l = ue.useContext(Xf), { orientation: p } = e, [h, g] = ue.useState(null), x = p === "horizontal", w = 1, y = e.lollipopSize === "large" ? 7 : e.lollipopSize === "medium" ? 6 : 5, R = e.lollipopSize === "large" ? 14 : e.lollipopSize === "medium" ? 12 : 10, b = e.yAxis.labelPlacement === "Below Bar", v = e.yAxis.displayNumbersOnBar, A = e.orientation === "horizontal" ? "yAxis" : "xAxis", N = e.barStyle === "rounded", L = e.visualizationSubType === "stacked", C = e.tipRounding, z = e.roundingStyle === "standard" ? "8px" : e.roundingStyle === "shallow" ? "5px" : e.roundingStyle === "finger" ? "15px" : "0px", W = e.runtime.seriesKeys.length, q = Object.keys(e.runtime.seriesLabels).length > 1, G = e.visualizationType === "Bar" && e.legend.behavior === "isolate" && e.legend.axisAlign && (c != null && c.length) ? c : e.runtime.barSeriesKeys || e.runtime.seriesKeys;
  return ue.useEffect(() => {
    p === "horizontal" && !e.yAxis.labelPlacement && r({
      ...e,
      yAxis: {
        ...e.yAxis,
        labelPlacement: "Below Bar"
      }
    });
  }, [e, r]), ue.useEffect(() => {
    e.isLollipopChart === !1 && e.barHeight < 25 && r({ ...e, barHeight: 25 });
  }, [e.isLollipopChart]), ue.useEffect(() => {
    e.visualizationSubType === "horizontal" && r({
      ...e,
      orientation: "horizontal"
    });
  }, []), ue.useEffect(() => {
    e.barStyle === "lollipop" && !e.isLollipopChart && r({ ...e, isLollipopChart: !0 }), (N || e.barStyle === "flat") && r({ ...e, isLollipopChart: !1 });
  }, [e.barStyle]), {
    isHorizontal: x,
    barBorderWidth: w,
    lollipopBarWidth: y,
    lollipopShapeSize: R,
    isLabelBelowBar: b,
    displayNumbersOnBar: v,
    shouldSuppress: (Y) => {
      var te;
      return (te = e.preliminaryData) == null ? void 0 : te.some(($) => {
        const ce = $.column ? $.column === Y.key : !0, Se = String(Y.value) === String($.value) && $.value !== "";
        return ce && Se && $.symbol && $.type === "suppression";
      });
    },
    section: A,
    isRounded: N,
    isStacked: L,
    tipRounding: C,
    radius: z,
    stackCount: W,
    barStackedSeriesKeys: G,
    hasMultipleSeries: q,
    applyRadius: (Y) => {
      if (Y == null || !N)
        return {};
      let te = {};
      return (L && Y + 1 === W || !L) && (te = x ? { borderRadius: `0 ${z}  ${z}  0` } : { borderRadius: `${z} ${z} 0 0` }), !L && Y === -1 && (te = x ? { borderRadius: `${z} 0  0 ${z} ` } : { borderRadius: ` 0  0 ${z} ${z}` }), C === "full" && L && Y === 0 && W > 1 && (te = x ? { borderRadius: `${z} 0 0 ${z}` } : { borderRadius: `0 0 ${z} ${z}` }), C === "full" && (L && Y === 0 && W === 1 || !L) && (te = { borderRadius: z }), te;
    },
    updateBars: (Y) => {
      if (e.visualizationType !== "Bar" && !x)
        return Y;
      const te = [...Y];
      let $;
      const ce = {
        stacked: e.barHeight,
        lollipop: y
      };
      L ? $ = ce.stacked : $ = ce[e.isLollipopChart ? "lollipop" : "stacked"] * W;
      const Se = b ? Lu * 1.2 : 0;
      let be = Number(e.barSpace), ve = te.length * ($ + Se + be);
      return x && (e.heights.horizontal = ve), te.map((Pe, Ve) => {
        let we = 0;
        return Pe.index !== 0 && (we = ($ + be + Se) * Ve), { ...Pe, y: we, height: $ };
      });
    },
    assignColorsToValues: (Y, te, $) => {
      if (!e.legend.colorCode && e.series.length > 1)
        return $;
      const ce = e.customColors ?? t[e.palette], Se = n.map((Ve) => Ve[e.legend.colorCode]);
      let be = /* @__PURE__ */ new Map(), ve = [];
      for (let Ve = 0; Ve < Se.length; Ve++)
        be.has(Se[Ve]) || be.set(Se[Ve], ce[be.size % ce.length]), ve.push(be.get(Se[Ve]));
      for (; ve.length < Y; )
        ve = ve.concat(ve);
      return ve[te];
    },
    getHighlightedBarColorByValue: (Y) => {
      const te = e == null ? void 0 : e.highlightedBarValues.find(($) => {
        if ($.value)
          return e.xAxis.type === "date" ? i(a($.value)) === Y : $.value === Y;
      });
      return te != null && te.color ? te.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (Y) => {
      const te = e == null ? void 0 : e.highlightedBarValues.filter(($) => {
        if ($.value)
          return e.xAxis.type === "date" ? i(a($.value)) === Y : $.value === Y;
      })[0];
      return te != null && te.color ? te : !1;
    },
    getAdditionalColumn: (Y, te) => {
      var Pe, Ve;
      if (!te)
        return "";
      const $ = e.columns, ce = [];
      let Se = "";
      const be = (Ve = (Pe = e.runtime) == null ? void 0 : Pe.series) == null ? void 0 : Ve.find((we) => we == null ? void 0 : we.dynamicCategory), ve = n.find((we) => {
        const me = be ? we[be.dynamicCategory] === Y : !0;
        return we[e.xAxis.dataKey] === te && me;
      }) || {};
      return Object.keys($).forEach((we) => {
        if (Y && e.columns[we].series && e.columns[we].series !== Y)
          return;
        const me = {
          addColPrefix: e.columns[we].prefix,
          addColSuffix: e.columns[we].suffix,
          addColRoundTo: e.columns[we].roundToPlace ? e.columns[we].roundToPlace : "",
          addColCommas: e.columns[we].commas
        }, Ce = Gf(
          ve[e.columns[we].name],
          "left",
          !0,
          e,
          me
        );
        e.columns[we].tooltips && ce.push([e.columns[we].label, Ce]);
      }), ce.forEach((we) => {
        Se += `${we[0]} : ${we[1]} <br/>`;
      }), Se;
    },
    hoveredBar: h,
    setHoveredBar: g,
    onMouseOverBar: (Y, te) => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && te && l({ type: "SET_SERIES_HIGHLIGHT", payload: [te] }), g(Y);
    },
    onMouseLeaveBar: () => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && l({ type: "SET_SERIES_HIGHLIGHT", payload: [] });
    }
  };
}, Ps = ue.createContext(null), bp = ({
  xScale: e,
  barWidth: t = 0,
  totalBarsInGroup: n = 1,
  yMax: r,
  handleTooltipMouseOff: a,
  handleTooltipMouseOver: i,
  handleTooltipClick: u,
  tooltipData: c,
  showTooltip: l,
  hideTooltip: p
}) => {
  const { parseDate: h, config: g } = ue.useContext(mt), { runtime: x, regions: w, visualizationType: y, orientation: R, xAxis: b } = g, v = e.domain(), A = (C) => {
    let z;
    if (!(C != null && C.fromType) || C.fromType === "Fixed") {
      const W = new Date(C.from), q = h(os(g.xAxis.dateParseFormat, W)).getTime();
      z = e(q), y === "Bar" && b.type === "date-time" && (z = z - t * n / 2);
    }
    if (C.fromType === "Previous Days") {
      const W = Number(C.from) || 0;
      v.map((le) => os(g.xAxis.dateParseFormat, new Date(le)));
      const q = C.toType === "Last Date" ? new Date(v[v.length - 1]).getTime() : new Date(C.to), ne = g.xAxis.type === "categorical" ? os(g.xAxis.dateParseFormat, q) : os(g.xAxis.dateParseFormat, q), G = new Date(ne);
      if (z = new Date(G.setDate(G.getDate() - Number(W))), b.type === "date") {
        z = new Date(os(b.dateParseFormat, z)).getTime();
        let le = v[0], K = Math.abs(z - le);
        for (let re = 1; re < v.length; re++) {
          const B = Math.abs(z - v[re]);
          B < K && (K = B, le = v[re]);
        }
        z = le;
      }
      if (b.type === "categorical") {
        let le = v[0], K = Math.abs(new Date(z).getTime() - new Date(le).getTime());
        for (let re = 1; re < v.length; re++) {
          const B = Math.abs(new Date(z).getTime() - new Date(v[re]).getTime());
          B < K && (K = B, le = v[re]);
        }
        z = le;
      }
      z = e(z);
    }
    if (b.type === "categorical" && C.fromType !== "Previous Days" && (z = e(C.from)), y === "Line" || y === "Area Chart") {
      let W = Number(g.yAxis.size);
      e.bandwidth && (W += e.bandwidth() / 2), z = z + W;
    }
    return y === "Bar" && g.xAxis.type === "date-time" && C.fromType === "Previous Days" && (z = z - t * n / 2), z;
  }, N = (C) => {
    let z;
    if (b.type === "categorical" && (z = e(C.to)), En(b) && ((!(C != null && C.toType) || C.toType === "Fixed") && (z = e(h(C.to).getTime())), (y === "Bar" || g.visualizationType === "Combo") && (z = C.toType !== "Last Date" ? e(h(C.to).getTime()) + t * n : z)), C.toType === "Last Date") {
      const W = v[v.length - 1];
      z = Number(
        e(W) + ((y === "Bar" || y === "Combo") && g.xAxis.type === "date" ? t * n : 0)
      );
    }
    if (y === "Line" || y === "Area Chart") {
      let W = Number(g.yAxis.size);
      e.bandwidth && (W += e.bandwidth() / 2), z = z + W;
    }
    return y === "Bar" && g.xAxis.type === "date-time" && C.toType !== "Last Date" && (z = z - t * n / 2), (y === "Bar" || y === "Combo") && b.type === "categorical" && (z = z + (y === "Bar" || y === "Combo" ? t * n : 0)), z;
  }, L = (C, z) => C - z;
  if (w && R === "vertical")
    return w.map((C) => {
      const z = A(C), W = N(C), q = L(W, z);
      if (!z || !W)
        return null;
      const ne = () => /* @__PURE__ */ m.createElement("rect", { x: z, y: 0, width: q, height: r, fill: C.background, opacity: 0.3 });
      return /* @__PURE__ */ m.createElement(
        tt,
        {
          height: 100,
          fill: "red",
          className: "regions regions-group--line zzz",
          key: C.label,
          onMouseMove: i,
          onMouseLeave: a,
          handleTooltipClick: u,
          tooltipData: JSON.stringify(c),
          showTooltip: l
        },
        /* @__PURE__ */ m.createElement(ne, null),
        /* @__PURE__ */ m.createElement(ht, { x: z + q / 2, y: 5, fill: C.color, verticalAnchor: "start", textAnchor: "middle" }, C.label)
      );
    });
};
function Ds(e) {
  var $, ce;
  const { config: t, index: n, id: r, className: a, background: i, borderColor: u, borderWidth: c, width: l, height: p, x: h, y: g, onMouseOver: x, onMouseLeave: w, onClick: y, tooltipHtml: R, tooltipId: b, styleOverrides: v, seriesHighlight: A, type: N } = e, L = Math.max(0, l), C = Math.max(0, p), z = t.orientation === "horizontal", W = t.barStyle === "rounded", q = t.visualizationSubType === "stacked", ne = t.tipRounding, G = t.visualizationType === "Combo" && ((ce = ($ = t.runtime) == null ? void 0 : $.barSeriesKeys) == null ? void 0 : ce.length), le = t.runtime.seriesKeys.length, K = t.visualizationType === "Bar" && t.legend.axisAlign && (A != null && A.length) ? A == null ? void 0 : A.length : 0, re = G || K || le;
  let B = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  (B > L / 2 || B > C / 2) && (B = Math.min(L / 2, C / 2));
  const j = () => `M${h},${g + C}
      L${h},${g + B}
      Q${h},${g} ${h + B},${g}
      L${h + L - B},${g}
      Q${h + L},${g} ${h + L},${g + B}
      L${h + L},${g + C}
      L${h},${g + C}`, se = () => `M${h},${g + C}
      L${h},${g}
      L${h + L - B},${g}
      Q${h + L},${g} ${h + L},${g + B}
      L${h + L},${g + C - B}
      Q${h + L},${g + C} ${h + L - B},${g + C}
      L${h},${g + C}`, ee = () => `M${h + B},${g + C}
      Q${h},${g + C} ${h},${g + C - B}
      L${h},${g}
      L${h + L},${g}
      L${h + L},${g + C - B}
      Q${h + L},${g + C} ${h + L - B},${g + C}
      L${h + B},${g + C}`, Q = () => `M${h + B},${g + C}
      Q${h},${g + C} ${h},${g + C - B}
      L${h},${g + B}
      Q${h},${g} ${h + B},${g}
      L${h + L},${g}
      L${h + L},${g + C}
      L${h + B},${g + C}`, Z = () => `M${h + B},${g + C}
      Q${h},${g + C} ${h},${g + C - B}
      L${h},${g + B}
      Q${h},${g} ${h + B},${g}
      L${h + L - B},${g}
      Q${h + L},${g} ${h + L},${g + B}
      L${h + L},${g + C - B}
      Q${h + L},${g + C} ${h + L - B},${g + C}
      L${h + B},${g + C}`, Y = () => `M${h},${g}
      L${h + L},${g}
      L${h + L},${g + C}
      L${h},${g + C}
      L${h},${g}`;
  let te;
  return n == null || !W || N == "axisBar" ? te = Y() : (te = Y(), (q && n + 1 === re || !q) && (te = z ? se() : j()), !q && n === -1 && (te = z ? Q() : ee()), ne === "full" && q && n === 0 && re > 1 && (te = z ? Q() : ee()), ne === "full" && (q && n === 0 && re === 1 || !q) && (te = Z())), /* @__PURE__ */ React.createElement(
    "path",
    {
      id: r,
      className: a,
      d: te,
      fill: i,
      stroke: u,
      strokeWidth: c,
      onMouseOver: x,
      onMouseLeave: w,
      onClick: y,
      "data-tooltip-html": R,
      "data-tooltip-id": b,
      style: {
        transition: "all 0.2s linear",
        ...v
      }
    }
  );
}
const lk = () => {
  var le, K;
  const [e, t] = ue.useState(0), { xScale: n, yScale: r, seriesScale: a, xMax: i, yMax: u } = ue.useContext(Ps), { transformedData: c, colorScale: l, seriesHighlight: p, config: h, formatNumber: g, formatDate: x, parseDate: w, setSharedFilter: y } = ue.useContext(mt), {
    isHorizontal: R,
    barBorderWidth: b,
    applyRadius: v,
    hoveredBar: A,
    getAdditionalColumn: N,
    onMouseLeaveBar: L,
    onMouseOverBar: C,
    barStackedSeriesKeys: z
  } = $u(), { orientation: W } = h, q = (le = h.brush) != null && le.active && ((K = h.brush.data) != null && K.length) ? h.brush.data : c, ne = h.runtime.xAxis.type === "date-time" || h.runtime.xAxis.type === "date", G = h.runtime.xAxis.type === "date-time";
  return h.visualizationSubType === "stacked" && !R && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
    Oy,
    {
      data: q,
      keys: z,
      x: (re) => re[h.runtime.xAxis.dataKey],
      xScale: n,
      yScale: r,
      color: l
    },
    (re) => re.reverse().map(
      (B) => B.bars.map((j) => {
        let se = h.legend.behavior === "highlight" && p.length > 0 && p.indexOf(j.key) === -1, ee = h.legend.behavior === "highlight" || p.length === 0 || p.indexOf(j.key) !== -1, Q = ne ? a.range()[1] - a.range()[0] : i / B.bars.length;
        h.runtime.xAxis.type !== "date" && (Q = h.barThickness * Q);
        const Z = j.bar.data[h.runtime.xAxis.dataKey], Y = ne ? x(w(Z)) : Z, te = g(j.bar ? j.bar.data[j.key] : 0, "left");
        if (!te)
          return;
        const $ = n(ne ? w(Z) : Z) - (G ? Q / 2 : 0), ce = h.runtime.xAxis.label ? `${h.runtime.xAxis.label}: ${Y}` : Y, Se = N(A), be = `${h.runtime.seriesLabels[j.key]}: ${te}`, ve = `<ul>
                  <li class="tooltip-heading"">${ce}</li>
                  <li class="tooltip-body ">${be}</li>
                  <li class="tooltip-body ">${Se}</li>
                    </li></ul>`;
        return t(Q), /* @__PURE__ */ m.createElement(tt, { key: `${B.index}--${j.index}--${W}` }, /* @__PURE__ */ m.createElement(
          tt,
          {
            key: `bar-stack-${B.index}-${j.index}`,
            id: `barStack${B.index}-${j.index}`,
            className: "stack vertical"
          },
          Ds({
            config: h,
            seriesHighlight: p,
            index: B.index,
            background: l(h.runtime.seriesLabels[j.key]),
            borderColor: "#333",
            borderStyle: "solid",
            borderWidth: `${h.barHasBorder === "true" ? b : 0}px`,
            width: Q,
            height: j.height,
            x: $,
            y: j.y,
            onMouseOver: () => C(Y, j.key),
            onMouseLeave: L,
            tooltipHtml: ve,
            tooltipId: `cdc-open-viz-tooltip-${h.runtime.uniqueId}`,
            onClick: (Pe) => {
              Pe.preventDefault(), y && (j[h.xAxis.dataKey] = Y, y(h.uid, j));
            },
            styleOverrides: {
              animationDelay: `${B.index * 0.5}s`,
              transformOrigin: `${Q / 2}px ${j.y + j.height}px`,
              opacity: se ? 0.2 : 1,
              display: ee ? "block" : "none"
            }
          })
        ));
      })
    )
  ), /* @__PURE__ */ m.createElement(bp, { xScale: n, yMax: u, barWidth: e, totalBarsInGroup: 1 }));
}, sk = () => {
  const { yMax: e, yScale: t, xScale: n } = ue.useContext(Ps), {
    animatedChart: r,
    colorScale: a,
    config: i,
    formatDate: u,
    formatNumber: c,
    parseDate: l,
    seriesHighlight: p,
    setSharedFilter: h,
    transformedData: g
  } = ue.useContext(mt), { barBorderWidth: x, displayNumbersOnBar: w, getAdditionalColumn: y, hoveredBar: R, isHorizontal: b, isLabelBelowBar: v, onMouseLeaveBar: A, onMouseOverBar: N, updateBars: L, barStackedSeriesKeys: C } = $u(), { orientation: z, visualizationSubType: W } = i;
  return i.visualizationSubType === "stacked" && b && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
    dE,
    {
      data: g,
      keys: C,
      height: e,
      y: (q) => q[i.runtime.yAxis.dataKey],
      xScale: n,
      yScale: t,
      color: a,
      offset: "none"
    },
    (q) => q.map(
      (ne) => L(ne.bars).map((G, le) => {
        const K = i.legend.behavior === "highlight" && p.length > 0 && p.indexOf(G.key) === -1, re = i.legend.behavior === "highlight" || p.length === 0 || p.indexOf(G.key) !== -1;
        i.barHeight = Number(i.barHeight);
        let B = a(i.runtime.seriesLabels[G.key]), j = il("#000", B);
        bm("#000", B) < 7 && (j = "#fff");
        const Q = c(g[G.index][G.key], "left"), Z = i.runtime.yAxis.type === "date" ? u(l(g[G.index][i.runtime.originalXAxis.dataKey])) : g[G.index][i.runtime.originalXAxis.dataKey], Y = i.runtime.yAxis.label ? `${i.runtime.yAxis.label}: ${Z}` : Z, te = pr(Q), $ = y(R), ce = `${i.runtime.seriesLabels[G.key]}: ${Q}`, Se = `<ul>
                  <li class="tooltip-heading"">${Y}</li>
                  <li class="tooltip-body ">${ce}</li>
                  <li class="tooltip-body ">${$}</li>
                    </li></ul>`;
        return /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(tt, { key: le, id: `barStack${ne.index}-${G.index}`, className: "stack horizontal" }, Ds({
          config: i,
          seriesHighlight: p,
          index: ne.index,
          className: `animated-chart group ${r ? "animated" : ""}`,
          background: a(i.runtime.seriesLabels[G.key]),
          borderColor: "#333",
          borderStyle: "solid",
          borderWidth: `${i.barHasBorder === "true" ? x : 0}px`,
          width: G.width,
          height: G.height,
          x: G.x,
          y: G.y,
          onMouseOver: () => N(Z, G.key),
          onMouseLeave: A,
          tooltipHtml: Se,
          tooltipId: `cdc-open-viz-tooltip-${i.runtime.uniqueId}`,
          onClick: (be) => {
            be.preventDefault(), h && (G[i.xAxis.dataKey] = Q, h(i.uid, G));
          },
          styleOverrides: {
            animationDelay: `${ne.index * 0.5}s`,
            transformOrigin: `${G.x}px 0`,
            opacity: K ? 0.2 : 1,
            display: re ? "block" : "none"
          }
        }), z === "horizontal" && W === "stacked" && v && ne.index === 0 && !i.yAxis.hideLabel && /* @__PURE__ */ m.createElement(
          ht,
          {
            x: `${G.x + (i.isLollipopChart ? 15 : 5)}`,
            y: G.y + G.height * 1.2,
            fill: "#000000",
            textAnchor: "start",
            verticalAnchor: "start"
          },
          Z
        ), w && te < G.width && /* @__PURE__ */ m.createElement(
          ht,
          {
            display: re ? "block" : "none",
            x: G.x + ne.bars[G.index].width / 2,
            y: G.y + G.height / 2,
            fill: j,
            textAnchor: "middle",
            verticalAnchor: "middle"
          },
          Q
        )));
      })
    )
  ));
}, Hu = (e, t) => {
  var R;
  const { formatDate: n, parseDate: r } = ue.useContext(mt);
  let a = [], i = "", u = [], c = [];
  ((R = e.series) == null ? void 0 : R.length) > 0 && e.data ? (a = e.series[0], i = e.series[0].dataKey, u = e.highlightedBarValues, c = e.data.map((b) => b[e.xAxis.dataKey])) : (a = [], i = "", u = [], c = []);
  const l = (b, v) => {
    const A = [...e.highlightedBarValues];
    A[v].borderWidth = b.target.value, t({
      ...e,
      highlightedBarValues: A
    });
  }, p = (b, v) => {
    b.preventDefault();
    const A = [...e.highlightedBarValues];
    A[v].value = b.target.value, A[v].dataKey = i, t({
      ...e,
      highlightedBarValues: A
    });
  }, h = (b, v) => {
    b.preventDefault();
    const A = [...e.highlightedBarValues];
    A.push({ dataKey: i }), t({
      ...e,
      highlightedBarValues: A
    });
  }, g = (b, v) => {
    b.preventDefault();
    const A = [...e.highlightedBarValues];
    A.splice(v, 1), t({
      ...e,
      highlightedBarValues: A
    });
  }, x = (b, v) => {
    const A = [...e.highlightedBarValues];
    A[v].color = b.target.value, t({
      ...e
    });
  }, w = (b, v) => {
    const A = [...e.highlightedBarValues];
    A[v].legendLabel = b.target.value, t({
      ...e,
      copyOfHighlightedBarValues: A
    });
  }, y = () => {
  };
  return y.checkFontColor = (b, v, A) => {
    if (e.xAxis.type === "date") {
      if (y.formatDates(v).includes(b))
        return "#000";
    } else if (v.includes(b))
      return "#000";
    return A;
  }, y.formatDates = (b) => b.map((v) => v ? n(r(v)) : !1), y.findDuplicates = (b) => {
    const v = {};
    return b == null ? void 0 : b.filter((N) => {
      const { legendLabel: L } = N;
      return v[L] ? !1 : (v[L] = !0, !0);
    });
  }, {
    HighLightedBarUtils: y,
    highlightedSeries: a,
    highlightedSeriesKey: i,
    highlightedBarValues: u,
    highlightedSeriesValues: c,
    handleUpdateHighlightedBar: p,
    handleAddNewHighlightedBar: h,
    handleRemoveHighlightedBar: g,
    handleUpdateHighlightedBarColor: x,
    handleHighlightedBarLegendLabel: w,
    handleUpdateHighlightedBorderWidth: l
  };
};
function Vi(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
const lg = ({
  bar: e,
  defaultBarHeight: t,
  defaultBarWidth: n,
  config: r,
  barWidth: a,
  isVertical: i
}) => {
  let c = t, l = n, p = "", h = !1, g = !1, x = !1;
  const w = r.general.showSuppressedSymbol;
  if (r.preliminaryData.forEach((b) => {
    (!b.column || b.column === e.key) && b.type === "suppression" && b.value && String(b.value) === String(e.value) && (!b.hideBarSymbol && w ? (c = a > 10 ? 3 : 0, l = 3, h = !0) : (c = 0, l = 0, h = !0));
  }), !h && !Vi(e.value) && r.general.showMissingDataLabel) {
    const b = pr(p, `normal ${a / 2}px sans-serif`), v = Number(b) < a && a > 10;
    g = !0, c = v ? 3 : 0, l = 3;
  }
  if (!h && e.value === "0" && r.general.showZeroValueData) {
    const b = pr("0", `normal ${a / 2}px sans-serif`), v = Number(b) < a && a > 10;
    x = !0, c = v ? 3 : 0, l = 3;
  }
  return { barWidthHorizontal: l, barHeight: c, isSuppressed: h, showMissingDataLabel: g, getBarY: (b, v) => h || g || x ? r.isLollipopChart ? v - 3 * 2 : v - 3 : b, getAbsentDataLabel: (b) => {
    let v = "";
    String(b) === "0" && (v = ""), h && (v = ""), g && (v = "N/A"), x && (v = "0");
    const A = pr(p, `normal ${a / 2}px sans-serif`), N = Number(A) < a && a > 10;
    return r.isLollipopChart || N && i ? v : i ? "" : v;
  } };
}, xs = (e) => e == null ? void 0 : /^0(\.0)?$/.test(e.toString()), sg = (e, t, n) => {
  const r = e.series.find((l) => l.dynamicCategory);
  if (!r)
    return t;
  const { dynamicCategory: a, dataKey: i } = r, u = e.runtime.originalXAxis.dataKey, c = Je.groupBy(t, u);
  return Object.values(c).map((l) => l.reduce((p, h) => {
    const g = h[i], x = h[a];
    if (n) {
      const { lower: w, upper: y } = e.confidenceKeys;
      p.CI || (p.CI = {});
      const R = h[w], b = h[y];
      p.CI[x] = { lower: R, upper: b };
    }
    return p[x] = g, p[u] = h[u], p.dynamicData = !0, p;
  }, {}));
}, ck = () => {
  const { xScale: e, yScale: t, xMax: n, yMax: r, seriesScale: a, convertLineToBarGraph: i } = ue.useContext(Ps), [u, c] = ue.useState(0), [l, p] = ue.useState(0), {
    // prettier-ignore
    assignColorsToValues: h,
    barBorderWidth: g,
    getAdditionalColumn: x,
    getHighlightedBarByValue: w,
    getHighlightedBarColorByValue: y,
    lollipopBarWidth: R,
    lollipopShapeSize: b,
    onMouseLeaveBar: v,
    onMouseOverBar: A,
    section: N
  } = $u(), { colorScale: L, config: C, dashboardConfig: z, tableData: W, formatDate: q, formatNumber: ne, parseDate: G, seriesHighlight: le, setSharedFilter: K, transformedData: re, brushConfig: B } = ue.useContext(mt), { HighLightedBarUtils: j } = Hu(C), se = document.documentElement, ee = getComputedStyle(se).getPropertyValue("--cool-gray-90");
  let Q = re;
  C.preliminaryData.some(($) => $.value && $.type === "suppression") && (Q = W), B.data.length && (Q = B.data);
  const Y = Object.keys(C.confidenceKeys).length > 0, te = sg(C, Q, Y);
  return C.visualizationSubType !== "stacked" && (C.visualizationType === "Bar" || C.visualizationType === "Combo" || i) && C.orientation === "vertical" && /* @__PURE__ */ m.createElement(tt, null, /* @__PURE__ */ m.createElement(
    Py,
    {
      data: te,
      keys: C.runtime.barSeriesKeys || C.runtime.seriesKeys,
      height: r,
      x0: ($) => {
        const ce = $[C.runtime.originalXAxis.dataKey];
        return En(C.runtime.xAxis) ? G(ce) : ce;
      },
      x0Scale: e,
      x1Scale: a,
      yScale: t,
      color: () => ""
    },
    ($) => $.map((ce, Se) => /* @__PURE__ */ m.createElement(
      tt,
      {
        className: `bar-group-${ce.index}-${ce.x0}--${Se} ${C.orientation}`,
        key: `bar-group-${ce.index}-${ce.x0}--${Se}`,
        id: `bar-group-${ce.index}-${ce.x0}--${Se}`,
        left: ce.x0
      },
      ce.bars.map((be, ve) => {
        var Ee, pt;
        const Pe = te[ce.index], Ve = Pe[C.runtime.originalXAxis.dataKey], we = C.yAxis.type === "logarithmic" ? 0.1 : 0;
        let me = C.highlightedBarValues.map((nt) => nt.value).filter((nt) => nt !== void 0);
        me = C.xAxis.type === "date" ? j.formatDates(me) : me;
        const Ce = C.legend.behavior === "highlight" && le.length > 0 && le.indexOf(be.key) === -1, fe = C.legend.behavior === "highlight" || le.length === 0 || le.indexOf(be.key) !== -1;
        let ze = a.range()[1] - a.range()[0];
        const Ie = Math.abs(t(be.value) - t(we)), Qe = be.value >= 0 && Vi(be.value) ? be.y : t(0);
        let He = C.isLollipopChart ? R : a.bandwidth(), Fe = be.x + (C.isLollipopChart ? (ze / ce.bars.length - R) / 2 : 0) - (C.xAxis.type === "date-time" ? ze / 2 : 0);
        c(He), p(ce.bars.length);
        const qe = ne(/[a-zA-Z]/.test(String(be.value)) ? "" : be.value, "left"), We = C.runtime[N].type === "date" ? q(G(Ve)) : Ve, je = be.value < 0 ? -1 : ve, Ke = x(be.key, Ve);
        let Te = C.runtime.xAxis.label ? `${C.runtime.xAxis.label}: ${We}` : We;
        const _e = `${C.runtime.seriesLabels[be.key]}: ${qe}`, at = `<ul>
                  <li class="tooltip-heading">${Te}</li>
                  <li class="tooltip-body ">${_e}</li>
                  ${Ke ? '<li class="tooltip-body ">' + Ke + "</li>" : ""}
                    </li></ul>`;
        let ge = "#000000";
        ge = j.checkFontColor(qe, me, ge);
        const ft = C.isLollipopChart && C.lollipopColorStyle === "regular", ot = C.isLollipopChart && C.lollipopColorStyle === "two-tone", it = me == null ? void 0 : me.includes(We), wt = y(We), Wt = w(We), Kt = it ? wt : C.barHasBorder === "true" ? "#000" : "transparent", Mt = it ? Wt.borderWidth : C.isLollipopChart ? 0 : C.barHasBorder === "true" ? g : 0, { barHeight: rn, isSuppressed: Et, getBarY: Pt, getAbsentDataLabel: Nt } = lg({
          bar: be,
          defaultBarHeight: Ie,
          config: C,
          barWidth: He,
          isVertical: !0
        }), tn = Nt(qe), sn = Et || !C.labels ? "" : qe, Ot = Pt(Qe, t(we)), Ft = xs(be.value) ? "none" : "block", nn = (nt, gt) => {
          var lt;
          let xt = nt, Yt = gt || "#f2f2f2";
          if (z && ((lt = z.dashboard.sharedFilters) == null ? void 0 : lt.length) !== 0) {
            const { sharedFilters: st } = z.dashboard;
            return xt = st ? st.map(($t) => $t.setBy === C.uid ? $t.resetLabel === $t.active || $t.active === re[ce.index][C.xAxis.dataKey] ? L(C.runtime.seriesLabels[be.key]) : Yt : L(C.runtime.seriesLabels[be.key]))[0] : L(C.runtime.seriesLabels[be.key]), ft && (xt = nt), it && (xt = "transparent"), C.legend.colorCode && (xt = h($.length, ce.index, nt)), ot && (xt = Ua(nt).brighten(1)), xt;
          }
          return ot && (xt = Ua(nt).brighten(1)), C.legend.colorCode && (xt = h($.length, ce.index, nt)), it && (xt = "transparent"), xt;
        }, et = 5, ut = Fe + (C.xAxis.type !== "date-time" ? He / 2 : 0), Ne = t(
          Pe.dynamicData && ((Ee = Pe == null ? void 0 : Pe.CI) != null && Ee[be.key]) ? Pe.CI[be.key].upper : Pe[C.confidenceKeys.upper]
        ), De = t(
          Pe.dynamicData && ((pt = Pe == null ? void 0 : Pe.CI) != null && pt[be.key]) ? Pe.CI[be.key].lower : Pe[C.confidenceKeys.lower]
        );
        return /* @__PURE__ */ m.createElement(tt, { key: `${ce.index}--${ve}` }, /* @__PURE__ */ m.createElement(tt, { key: `bar-sub-group-${ce.index}-${ce.x0}-${Ot}--${ve}` }, Ds({
          config: C,
          index: je,
          id: `barGroup${ce.index}`,
          background: nn(L(C.runtime.seriesLabels[be.key])),
          borderColor: Kt,
          borderStyle: "solid",
          borderWidth: `${Mt}px`,
          width: He,
          height: rn,
          x: Fe,
          y: Ot,
          onMouseOver: () => A(We, be.key),
          onMouseLeave: v,
          tooltipHtml: at,
          tooltipId: `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
          onClick: (nt) => {
            nt.preventDefault(), K && (be[C.xAxis.dataKey] = We, K(C.uid, be));
          },
          styleOverrides: {
            transformOrigin: `0 ${Ot + rn}px`,
            opacity: Ce ? 0.2 : 1,
            display: fe ? "block" : "none",
            cursor: z ? "pointer" : "default"
          }
        }), C.preliminaryData.map((nt, gt) => {
          const xt = !nt.column || nt.column === be.key;
          if (!(String(nt.value) === String(be.value) && nt.value !== "" && xt) || He < 10 || !C.general.showSuppressedSymbol || nt.hideBarSymbol)
            return;
          const st = String(nt.symbol).includes("Asterisk"), $t = st ? -5 : -8, jt = st ? "middle" : "end", Rt = nt.symbol === "Asterisk" ? He * 1.2 : nt.symbol === "Double Asterisk" ? He : He / 1.5, St = nt.displayGray ? "#8b8b8a" : "#000";
          return /* @__PURE__ */ m.createElement(
            ht,
            {
              key: gt,
              dy: $t,
              display: fe ? "block" : "none",
              opacity: Ce ? 0.5 : 1,
              x: Fe + He / 2,
              y: Ot,
              verticalAnchor: jt,
              fill: St,
              textAnchor: "middle",
              fontSize: `${Rt}px`
            },
            nt.iconCode
          );
        }), /* @__PURE__ */ m.createElement(
          ht,
          {
            display: fe ? "block" : "none",
            opacity: Ce ? 0.5 : 1,
            x: Fe + He / 2,
            y: Ot - 5,
            fill: ge,
            textAnchor: "middle"
          },
          xs(be.value) ? "" : sn
        ), /* @__PURE__ */ m.createElement(
          ht,
          {
            display: fe ? "block" : "none",
            opacity: Ce ? 0.5 : 1,
            x: Fe + He / 2,
            y: Ot - 5,
            fill: ge,
            textAnchor: "middle",
            fontSize: C.isLollipopChart ? null : He / 2
          },
          tn
        ), C.isLollipopChart && C.lollipopShape === "circle" && /* @__PURE__ */ m.createElement(
          "circle",
          {
            display: Ft,
            cx: Fe + b / 3.5,
            cy: be.y,
            r: b / 2,
            fill: nn(L(C.runtime.seriesLabels[be.key])),
            key: `circle--${be.index}`,
            "data-tooltip-html": at,
            "data-tooltip-id": `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
            style: { filter: "unset", opacity: 1 }
          }
        ), C.isLollipopChart && C.lollipopShape === "square" && /* @__PURE__ */ m.createElement(
          "rect",
          {
            display: Ft,
            x: Fe - R / 2,
            y: be.y,
            width: b,
            height: b,
            fill: nn(L(C.runtime.seriesLabels[be.key])),
            key: `circle--${be.index}`,
            "data-tooltip-html": at,
            "data-tooltip-id": `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
            style: { opacity: 1, filter: "unset" }
          },
          /* @__PURE__ */ m.createElement("animate", { attributeName: "height", values: `0, ${b}`, dur: "2.5s" })
        ), Y && be.value !== void 0 && Pe && /* @__PURE__ */ m.createElement(
          "path",
          {
            key: `confidence-interval-v-${Pe[C.runtime.originalXAxis.dataKey]}`,
            stroke: ee,
            strokeWidth: "px",
            d: `M${ut - et} ${Ne}
                                L${ut + et} ${Ne}
                                M${ut} ${Ne}
                                L${ut} ${De}
                                M${ut - et} ${De}
                                L${ut + et} ${De}`
          }
        )));
      })
    ))
  ), /* @__PURE__ */ m.createElement(bp, { xScale: e, yMax: r, barWidth: u, totalBarsInGroup: l }));
}, uk = () => {
  var Q;
  const { xScale: e, yScale: t, yMax: n, seriesScale: r } = ue.useContext(Ps), {
    transformedData: a,
    tableData: i,
    colorScale: u,
    seriesHighlight: c,
    config: l,
    formatNumber: p,
    formatDate: h,
    parseDate: g,
    setSharedFilter: x,
    isNumber: w
  } = ue.useContext(mt), {
    isHorizontal: y,
    barBorderWidth: R,
    updateBars: b,
    assignColorsToValues: v,
    section: A,
    isLabelBelowBar: N,
    displayNumbersOnBar: L,
    lollipopBarWidth: C,
    lollipopShapeSize: z,
    getHighlightedBarColorByValue: W,
    getHighlightedBarByValue: q,
    getAdditionalColumn: ne,
    hoveredBar: G,
    onMouseLeaveBar: le,
    onMouseOverBar: K
  } = $u(), { HighLightedBarUtils: re } = Hu(l), B = Object.keys(l.confidenceKeys).length > 0, j = sg(l, a, B), se = document.documentElement, ee = getComputedStyle(se).getPropertyValue("--cool-gray-90");
  return l.visualizationSubType !== "stacked" && l.visualizationType === "Bar" && l.orientation === "horizontal" && /* @__PURE__ */ m.createElement(tt, null, /* @__PURE__ */ m.createElement(
    Py,
    {
      data: (Q = l.preliminaryData) != null && Q.some((Z) => Z.value && Z.type === "suppression") ? i : j,
      keys: l.runtime.barSeriesKeys || l.runtime.seriesKeys,
      height: n,
      x0: (Z) => Z[l.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: r,
      yScale: e,
      color: () => ""
    },
    (Z) => b(Z).map((Y, te) => /* @__PURE__ */ m.createElement(
      tt,
      {
        className: `bar-group-${Y.index}-${Y.x0}--${te} ${l.orientation}`,
        key: `bar-group-${Y.index}-${Y.x0}--${te}`,
        id: `bar-group-${Y.index}-${Y.x0}--${te}`,
        top: Y.y
      },
      Y.bars.map(($, ce) => {
        var Yt;
        const Se = j[Y.index], be = Se[l.runtime.originalXAxis.dataKey], ve = l.yAxis.type === "logarithmic" ? 0.1 : 0;
        let Pe = l.highlightedBarValues.map((lt) => lt.value).filter((lt) => lt !== void 0);
        Pe = l.xAxis.type === "date" ? re.formatDates(Pe) : Pe;
        let Ve = l.legend.behavior === "highlight" && c.length > 0 && c.indexOf($.key) === -1, we = l.legend.behavior === "highlight" || c.length === 0 || c.indexOf($.key) !== -1, me = l.barHeight, Ce = parseInt(l.isLollipopChart ? C : me);
        isNaN(Ce) && (Ce = 25);
        let fe = $.value >= 0 && w($.value) ? $.y : t(ve);
        const ze = Math.abs(e($.value) - e(ve)), Ie = $.value >= 0 && w($.value), {
          barWidthHorizontal: Qe,
          isSuppressed: He,
          getAbsentDataLabel: Fe
        } = lg({ bar: $, defaultBarWidth: ze, config: l, isNumber: w, isVertical: !1 }), qe = $.value < 0 ? Math.abs(e($.value)) : e(ve), We = p($.value, "left"), je = l.runtime[A].type === "date" ? h(g(be)) : be, Ke = Ie ? "above" : "below", Te = Fe(We), _e = l.yAxis.displayNumbersOnBar ? We : "", at = pr(_e), ge = Number(at) < ze - 5;
        let ft = ge ? "end" : "start", ot = "start", it = ge ? -5 : 5, wt = 10;
        Ke === "below" && (ft = ge ? "start" : "end", it = ge ? 5 : -5, l.isLollipopChart && (ot = "end", wt = -10));
        const Wt = $.value < 0 ? -1 : ce;
        let Kt = l.runtime.yAxis.label ? `${l.runtime.yAxis.label}: ${je}` : je;
        const Mt = ne(G), rn = `${l.runtime.seriesLabels[$.key]}: ${We}`, Et = `<ul>
                  <li class="tooltip-heading"">${Kt}</li>
                  <li class="tooltip-body ">${rn}</li>
                  <li class="tooltip-body ">${Mt}</li>
                    </li></ul>`;
        let Pt = "#000000";
        Pt = re.checkFontColor(We, Pe, Pt);
        let Nt = l.runtime.seriesLabels && l.runtime.seriesLabels[$.key] ? u(l.runtime.seriesLabels[$.key]) : u($.key);
        l.series.find((lt) => lt.dynamicCategory) || (Nt = v(Z.length, Y.index, Nt));
        const sn = l.isLollipopChart && l.lollipopColorStyle === "regular", Ot = l.isLollipopChart && l.lollipopColorStyle === "two-tone", Ft = Pe == null ? void 0 : Pe.includes(je), nn = W(je), et = q(je), ut = Ft ? nn : l.barHasBorder === "true" ? "#000" : "transparent", Ne = Ft ? et.borderWidth : l.isLollipopChart ? 0 : l.barHasBorder === "true" ? R : 0, De = xs($.value) ? "none" : "block";
        Nt && Pt && ge && (Pt = il("#000", Nt), bm("#000", Nt) < 7 && (Pt = "#fff"));
        const Ee = () => sn ? Nt : Ot ? Ua(Nt).brighten(1) : Ft ? "transparent" : Nt, pt = 5, nt = me * $.index + me / 2, [gt, xt] = ["upper", "lower"].map((lt) => {
          if (!B)
            return;
          if (Se.dynamicData) {
            const $t = Se.CI[$.key];
            if (!$t)
              return;
            const jt = $t[lt];
            return e(jt);
          }
          const st = Se[l.confidenceKeys[lt]];
          return e(st);
        });
        return /* @__PURE__ */ m.createElement(tt, { key: `${Y.index}--${ce}` }, /* @__PURE__ */ m.createElement(tt, { key: `bar-sub-group-${Y.index}-${Y.x0}-${fe}--${ce}` }, Ds({
          config: l,
          index: Wt,
          id: `barGroup${Y.index}`,
          background: Ee(),
          borderColor: ut,
          borderStyle: "solid",
          borderWidth: `${Ne}px`,
          width: Qe,
          height: Ce,
          x: qe,
          y: me * $.index,
          onMouseOver: () => K(je, $.key),
          onMouseLeave: le,
          tooltipHtml: Et,
          tooltipId: `cdc-open-viz-tooltip-${l.runtime.uniqueId}`,
          onClick: (lt) => {
            lt.preventDefault(), x && ($[l.xAxis.dataKey] = We, x(l.uid, $));
          },
          styleOverrides: {
            transformOrigin: `0 ${fe + me}px`,
            opacity: Ve ? 0.2 : 1,
            display: we ? "block" : "none"
          }
        }), (Yt = l.preliminaryData) == null ? void 0 : Yt.map((lt, st) => {
          const $t = !lt.column || lt.column === $.key;
          if (!(String(lt.value) === String($.value) && lt.value !== "" && $t) || lt.hideBarSymbol || !l.general.showSuppressedSymbol)
            return;
          const yn = String(lt.symbol).includes("Asterisk") ? "middle" : "end", vn = lt.symbol === "Asterisk" ? me * 1.2 : lt.symbol === "Double Asterisk" ? me : me / 1.5, wn = lt.displayGray ? "#8b8b8a" : "#000";
          return /* @__PURE__ */ m.createElement(
            ht,
            {
              key: st,
              fontSize: vn,
              display: we ? "block" : "none",
              opacity: Ve ? 0.5 : 1,
              x: qe,
              y: l.barHeight / 2 + l.barHeight * $.index,
              fill: wn,
              dy: l.barHeight / 5,
              dx: 10,
              textAnchor: "start",
              verticalAnchor: yn
            },
            lt.iconCode
          );
        }), !l.isLollipopChart && /* @__PURE__ */ m.createElement(
          ht,
          {
            display: we ? "block" : "none",
            x: $.y,
            opacity: Ve ? 0.5 : 1,
            y: l.barHeight / 2 + l.barHeight * $.index,
            fill: Pt,
            dx: it,
            verticalAnchor: "middle",
            textAnchor: ft
          },
          xs($.value) ? "" : _e
        ), /* @__PURE__ */ m.createElement(
          ht,
          {
            display: we ? "block" : "none",
            x: $.y,
            opacity: Ve ? 0.5 : 1,
            y: l.barHeight / 2 + l.barHeight * $.index,
            fill: Pt,
            dx: Te === "N/A" ? 20 : it,
            dy: l.isLollipopChart ? -10 : 0,
            verticalAnchor: "middle",
            textAnchor: Te === "N/A" ? "middle" : ft
          },
          Te
        ), l.isLollipopChart && /* @__PURE__ */ m.createElement(
          ht,
          {
            display: we ? "block" : "none",
            x: $.y,
            y: 0,
            fill: "#000000",
            dx: wt,
            textAnchor: ot,
            verticalAnchor: "middle",
            fontWeight: "normal"
          },
          xs($.value) ? "" : _e
        ), N && !l.yAxis.hideLabel && /* @__PURE__ */ m.createElement(
          ht,
          {
            x: l.yAxis.hideAxis ? 0 : 5,
            y: Y.height,
            dy: 4,
            verticalAnchor: "start",
            textAnchor: "start"
          },
          l.runtime.yAxis.type === "date" ? h(g(be)) : y ? be : p(be)
        ), l.isLollipopChart && l.lollipopShape === "circle" && /* @__PURE__ */ m.createElement(
          "circle",
          {
            display: De,
            cx: $.y,
            cy: me * $.index + C / 2,
            r: z / 2,
            fill: Nt,
            key: `circle--${$.index}`,
            "data-tooltip-html": Et,
            "data-tooltip-id": `cdc-open-viz-tooltip-${l.runtime.uniqueId}`,
            style: { filter: "unset", opacity: 1 }
          }
        ), l.isLollipopChart && l.lollipopShape === "square" && /* @__PURE__ */ m.createElement(
          "rect",
          {
            display: De,
            x: $.y > 10 ? $.y - z / 2 : 0,
            y: 0 - C / 2,
            width: z,
            height: z,
            fill: Nt,
            key: `circle--${$.index}`,
            "data-tooltip-html": Et,
            "data-tooltip-id": `cdc-open-viz-tooltip-${l.runtime.uniqueId}`,
            style: { opacity: 1, filter: "unset" }
          },
          /* @__PURE__ */ m.createElement("animate", { attributeName: "height", values: `0, ${z}`, dur: "2.5s" })
        ), B && /* @__PURE__ */ m.createElement(
          "path",
          {
            key: `confidence-interval-h-${nt}-${Se[l.runtime.originalXAxis.dataKey]}`,
            stroke: ee,
            strokeWidth: "px",
            d: `
                                M${xt} ${nt - pt}
                                L${xt} ${nt + pt}
                                M${xt} ${nt}
                                L${gt} ${nt}
                                M${gt} ${nt - pt}
                                L${gt} ${nt + pt} `
          }
        )));
      })
    ))
  ));
}, Bc = {
  Vertical: ck,
  Horizontal: uk,
  StackedVertical: lk,
  StackedHorizontal: sk
}, dk = ({
  xScale: e,
  yScale: t,
  seriesScale: n,
  xMax: r,
  yMax: a,
  handleTooltipMouseOver: i,
  handleTooltipMouseOff: u,
  handleTooltipClick: c
}) => {
  const { transformedData: l, config: p, convertLineToBarGraph: h } = ue.useContext(mt), g = {
    xScale: e,
    yScale: t,
    xMax: r,
    yMax: a,
    seriesScale: n,
    convertLineToBarGraph: h
  };
  return /* @__PURE__ */ m.createElement(Vr, { component: "BarChart" }, /* @__PURE__ */ m.createElement(Ps.Provider, { value: g }, /* @__PURE__ */ m.createElement(tt, { left: parseFloat(p.runtime.yAxis.size) }, /* @__PURE__ */ m.createElement(Bc.StackedVertical, null), /* @__PURE__ */ m.createElement(Bc.StackedHorizontal, null), /* @__PURE__ */ m.createElement(Bc.Vertical, null), /* @__PURE__ */ m.createElement(Bc.Horizontal, null), /* @__PURE__ */ m.createElement(
    Nr,
    {
      key: "bars",
      display: p.tooltips.singleSeries ? "none" : "block",
      width: Number(r),
      height: Number(a),
      fill: "transparent",
      fillOpacity: 0.05,
      onMouseMove: (x) => i(x, l),
      onMouseOut: u,
      onClick: (x) => c(x, l)
    }
  ))));
};
function Ha() {
  return Ha = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ha.apply(this, arguments);
}
function _i(e) {
  var t = e.x1, n = e.x2, r = e.y1, a = e.y2;
  return {
    x1: r,
    x2: a,
    y1: t,
    y2: n
  };
}
function cg(e) {
  var t = e.left, n = t === void 0 ? 0 : t, r = e.top, a = r === void 0 ? 0 : r, i = e.className, u = e.max, c = e.min, l = e.firstQuartile, p = e.thirdQuartile, h = e.median, g = e.boxWidth, x = g === void 0 ? 10 : g, w = e.fill, y = e.fillOpacity, R = e.stroke, b = e.strokeWidth, v = e.rx, A = v === void 0 ? 2 : v, N = e.ry, L = N === void 0 ? 2 : N, C = e.valueScale, z = e.outliers, W = z === void 0 ? [] : z, q = e.horizontal, ne = e.medianProps, G = ne === void 0 ? {} : ne, le = e.maxProps, K = le === void 0 ? {} : le, re = e.minProps, B = re === void 0 ? {} : re, j = e.boxProps, se = j === void 0 ? {} : j, ee = e.outlierProps, Q = ee === void 0 ? {} : ee, Z = e.container, Y = Z === void 0 ? !1 : Z, te = e.containerProps, $ = te === void 0 ? {} : te, ce = e.children, Se = q ? a : n, be = Se + (x || 0) / 2, ve = C.range(), Pe = C(c ?? 0), Ve = C(l ?? 0), we = C(h ?? 0), me = C(p ?? 0), Ce = C(u ?? 0), fe = {
    valueRange: ve,
    center: be,
    offset: Se,
    boxWidth: x,
    max: {
      x1: be - (x || 0) / 4,
      x2: be + (x || 0) / 4,
      y1: Ce,
      y2: Ce
    },
    maxToThird: {
      x1: be,
      x2: be,
      y1: Ce,
      y2: me
    },
    median: {
      x1: Se,
      x2: Se + (x || 0),
      y1: we,
      y2: we
    },
    minToFirst: {
      x1: be,
      x2: be,
      y1: Ve,
      y2: Pe
    },
    min: {
      x1: be - (x || 0) / 4,
      x2: be + (x || 0) / 4,
      y1: Pe,
      y2: Pe
    },
    box: {
      x1: Se,
      x2: x || 0,
      y1: me,
      y2: Math.abs(me - Ve)
    },
    container: {
      x1: Se,
      x2: x || 0,
      y1: Math.min.apply(Math, ve),
      y2: Math.abs(ve[0] - ve[1])
    }
  };
  return q && (fe.max = _i(fe.max), fe.maxToThird = _i(fe.maxToThird), fe.box.y1 = Ve, fe.box = _i(fe.box), fe.median = _i(fe.median), fe.minToFirst = _i(fe.minToFirst), fe.min = _i(fe.min), fe.container = _i(fe.container), fe.container.y1 = Math.min.apply(Math, ve)), ce ? /* @__PURE__ */ m.createElement(m.Fragment, null, ce(fe)) : /* @__PURE__ */ m.createElement(tt, {
    className: Sn("visx-boxplot", i)
  }, W.map(function(ze, Ie) {
    var Qe = q ? C(ze) : be, He = q ? be : C(ze);
    return /* @__PURE__ */ m.createElement("circle", Ha({
      key: "visx-boxplot-outlier-" + Ie,
      className: "visx-boxplot-outlier",
      cx: Qe,
      cy: He,
      r: 4,
      stroke: R,
      strokeWidth: b,
      fill: w,
      fillOpacity: y
    }, Q));
  }), /* @__PURE__ */ m.createElement("line", Ha({
    className: "visx-boxplot-max",
    x1: fe.max.x1,
    y1: fe.max.y1,
    x2: fe.max.x2,
    y2: fe.max.y2,
    stroke: R,
    strokeWidth: b
  }, K)), /* @__PURE__ */ m.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: fe.maxToThird.x1,
    y1: fe.maxToThird.y1,
    x2: fe.maxToThird.x2,
    y2: fe.maxToThird.y2,
    stroke: R,
    strokeWidth: b
  }), /* @__PURE__ */ m.createElement("rect", Ha({
    className: "visx-boxplot-box",
    x: fe.box.x1,
    y: fe.box.y1,
    width: fe.box.x2,
    height: fe.box.y2,
    stroke: R,
    strokeWidth: b,
    fill: w,
    fillOpacity: y,
    rx: A,
    ry: L
  }, se)), /* @__PURE__ */ m.createElement("line", Ha({
    className: "visx-boxplot-median",
    x1: fe.median.x1,
    y1: fe.median.y1,
    x2: fe.median.x2,
    y2: fe.median.y2,
    stroke: R,
    strokeWidth: b
  }, G)), /* @__PURE__ */ m.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: fe.minToFirst.x1,
    y1: fe.minToFirst.y1,
    x2: fe.minToFirst.x2,
    y2: fe.minToFirst.y2,
    stroke: R,
    strokeWidth: b
  }), /* @__PURE__ */ m.createElement("line", Ha({
    className: "visx-boxplot-min",
    x1: fe.min.x1,
    y1: fe.min.y1,
    x2: fe.min.x2,
    y2: fe.min.y2,
    stroke: R,
    strokeWidth: b
  }, B)), Y && /* @__PURE__ */ m.createElement("rect", Ha({
    x: fe.container.x1,
    y: fe.container.y1,
    width: fe.container.x2,
    height: fe.container.y2,
    fillOpacity: "0"
  }, $)));
}
cg.propTypes = {
  max: Me.number,
  min: Me.number,
  firstQuartile: Me.number,
  thirdQuartile: Me.number,
  median: Me.number,
  boxWidth: Me.number,
  fill: Me.string,
  fillOpacity: Me.oneOfType([Me.number, Me.string]),
  stroke: Me.string,
  strokeWidth: Me.oneOfType([Me.number, Me.string]),
  rx: Me.number,
  ry: Me.number,
  outliers: Me.arrayOf(Me.number),
  container: Me.bool,
  children: Me.func
};
const fk = (e, t, n, r, a, i, u, c, l) => `
    <div class="p-2  text-red" style="max-width: 300px; word-wrap: break-word; opacity:0.7; background: rgba(255, 255, 255, 0.9)">
      <div class="fw-bold" style="color: ${l};">
        ${c ? `${c} : ${t}` : t}
      </div>
      <div class="" style="background: ${l}; height: 2px;"></div>
        <strong>Key:</strong> ${n}<br/>
        <strong>${e.labels.q1}:</strong> ${r}<br/>
        <strong>${e.labels.q3}:</strong> ${a}<br/>
        <strong>${e.labels.iqr}:</strong> ${u}<br/>
        <strong>${e.labels.median}:</strong> ${i}
    </div>
  `, pk = (e) => {
  if (!e || e.length === 0)
    return {};
  const t = Je.sortBy(e), n = Ts(t, 0.25) ?? 0, r = Ts(t, 0.75) ?? 0, a = r - n, i = n - 1.5 * a, u = r + 1.5 * a, c = t.filter((l) => l >= i && l <= u);
  return {
    min: vf(c),
    // Smallest non-outlier value
    max: eu(c),
    // Largest non-outlier value
    median: ny(t),
    // Median of all values
    firstQuartile: n,
    thirdQuartile: r,
    iqr: a
  };
}, hk = (e, t, n) => {
  const r = t.series.map((u) => u == null ? void 0 : u.dataKey), a = {}, i = n.filter((u) => u[t.xAxis.dataKey] === e);
  return r.forEach((u) => {
    a[u] = i.map((c) => c[u]);
  }), a;
}, mk = (e, t, n) => {
  const r = n - t, a = t - 1.5 * r, i = n + 1.5 * r;
  return e.filter((u) => u < a || u > i);
}, yk = (e, t, n) => {
  const r = n - t, a = t - 1.5 * r, i = n + 1.5 * r;
  return e.filter((u) => u >= a && u <= i);
}, gk = (e, t) => {
  const n = e.map((i) => i[t.xAxis.dataKey]), r = [], a = Je.uniq(n);
  return a && a.length > 0 && a.forEach((i) => {
    const u = hk(i, t, e), c = {}, l = {}, p = {}, h = {}, g = {}, x = {}, w = {}, y = {};
    Object.keys(u).forEach((R) => {
      const b = u[R], { firstQuartile: v, thirdQuartile: A, min: N, max: L, median: C, iqr: z } = pk(b);
      c[R] = mk(b, v, A).map(Number), l[R] = yk(b, v, A).map(Number), p[R] = C, h[R] = N, g[R] = L, x[R] = v, w[R] = A, y[R] = z;
    }), r.push({
      columnCategory: i,
      keyValues: u,
      columnOutliers: c,
      columnNonOutliers: l,
      min: h,
      max: g,
      q1: x,
      q3: w,
      median: p,
      iqr: y
    });
  }), r;
}, vk = ({ xScale: e, yScale: t, seriesScale: n }) => {
  const { config: r, colorScale: a, seriesHighlight: i, transformedData: u } = ue.useContext(mt), { boxplot: c } = r, l = `cdc-open-viz-tooltip-${r.runtime.uniqueId}`, p = e.bandwidth(), g = getComputedStyle(document.body).getPropertyValue("--cool-gray-90").trim(), x = Math.min(40, p);
  Je.get(Sr, [r.palette, 0], "#000");
  const w = gk(u, r);
  return /* @__PURE__ */ m.createElement(Vr, { component: "BoxPlot" }, /* @__PURE__ */ m.createElement(tt, { left: Number(r.yAxis.size), className: "boxplot", key: "boxplot-group" }, w.map((y, R) => {
    const b = p - x, v = 4;
    return /* @__PURE__ */ m.createElement(
      tt,
      {
        key: `boxplotplot-${y.columnCategory}`,
        left: e(y.columnCategory) + (e.bandwidth() - n.bandwidth()) / 2
      },
      r.series.map((A, N) => {
        const L = r.legend.behavior === "highlight" && i.length > 0 && i.indexOf(A.dataKey) === -1, C = r.legend.behavior === "highlight" || i.length === 0 || i.indexOf(A.dataKey) !== -1, z = L ? 0.3 : 0.5;
        return /* @__PURE__ */ m.createElement(tt, { key: `boxplotplot-${A.dataKey}-${N}` }, c.plotNonOutlierValues && y.columnNonOutliers[A.dataKey].map((W, q) => /* @__PURE__ */ m.createElement(
          "circle",
          {
            display: C ? "block" : "none",
            cx: n(A.dataKey) + n.bandwidth() / 2,
            cy: t(W),
            r: v,
            opacity: z,
            fill: g,
            style: { stroke: g },
            key: `boxplot-${R}--circle-${q}`
          }
        )), C && /* @__PURE__ */ m.createElement(
          cg,
          {
            display: C ? "block" : "none",
            "data-left": e(y.columnCategory) + r.yAxis.size + b / 2 + 0.5,
            key: `box-plot-${R}-${A}`,
            min: Number(y.min[A.dataKey]),
            max: Number(y.max[A.dataKey]),
            left: n(A.dataKey),
            firstQuartile: y.q1[A.dataKey],
            thirdQuartile: y.q3[A.dataKey],
            median: y.median[A.dataKey],
            boxWidth: n.bandwidth(),
            fill: a(A.dataKey),
            fillOpacity: 1,
            stroke: g,
            valueScale: t,
            outliers: c.plotOutlierValues ? Je.map(y.columnOutliers[A.dataKey], (W) => W) : [],
            outlierProps: {
              style: {
                fill: g,
                opacity: z,
                stroke: g
              }
            },
            medianProps: {
              style: {
                opacity: z,
                stroke: g
              }
            },
            boxProps: {
              style: {
                stroke: g,
                strokeWidth: c.borders === "true" ? 1.5 : 0,
                opacity: z
              }
            },
            maxProps: {
              style: {
                opacity: z,
                stroke: g
              }
            },
            container: !0,
            containerProps: {
              "data-tooltip-html": fk(
                c,
                y.columnCategory,
                A.dataKey,
                Je.round(y.q1[A.dataKey], r.dataFormat.roundTo),
                Je.round(y.q3[A.dataKey], r.dataFormat.roundTo),
                Je.round(y.median[A.dataKey], r.dataFormat.roundTo),
                Je.round(y.iqr[A.dataKey], r.dataFormat.roundTo),
                r.xAxis.label,
                g
              ),
              "data-tooltip-id": l,
              tabIndex: -1
            }
          }
        ));
      })
    );
  })));
}, xk = ({ xScale: e, yScale: t }) => {
  const {
    transformedData: n,
    config: r,
    tableData: a,
    formatNumber: i,
    seriesHighlight: u,
    colorPalettes: c
  } = ue.useContext(mt), l = 4.5, p = Object.keys(r.runtime.seriesLabels).length > 1, h = Object.entries(r.columns).filter(([x, w]) => w.tooltips).map(([x, w]) => [
    w.label || w.name,
    w.name,
    {
      addColPrefix: w.prefix,
      addColSuffix: w.suffix,
      addColRoundTo: w.roundToPlace,
      addColCommas: w.commas
    }
  ]), g = (x, w, y) => `<div>
    ${r.legend.showLegendValuesTooltip && r.runtime.seriesLabels && p ? `${r.runtime.seriesLabels[w] || ""}<br/>` : ""}
    ${r.xAxis.label}: ${i(x[r.xAxis.dataKey], "bottom")} <br/>
    ${r.yAxis.label}: ${i(x[w], "left")}<br/>
   ${h.map(
    ([R, b, v]) => `${R} : ${Gf(a[y][b], "left", !1, r, v)}<br/>`
  ).join("")}
</div>`;
  return /* @__PURE__ */ m.createElement(tt, { className: "scatter-plot", left: r.yAxis.size }, n.map((x, w) => r.runtime.seriesKeys.map((y, R) => {
    const b = r.legend.behavior === "highlight" && u.length > 0 && u.indexOf(y) === -1, v = r.legend.behavior === "highlight" || u.length === 0 || u.indexOf(y) !== -1, A = r != null && r.customColors ? r.customColors[R] : r.palette ? c[r.palette][R] : "#000";
    let N = {
      filter: "unset",
      opacity: 1,
      stroke: v ? "black" : ""
    };
    return /* @__PURE__ */ m.createElement(
      "circle",
      {
        key: `${w}-${R}`,
        r: l,
        cx: e(x[r.xAxis.dataKey]),
        cy: t(x[y]),
        fill: v ? A : "transparent",
        fillOpacity: b ? 0.25 : 1,
        style: N,
        "data-tooltip-html": g(x, y, w),
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
        tabIndex: -1
      }
    );
  })));
};
function bk({ height: e, xScale: t }) {
  const {
    transformedData: n,
    config: r,
    formatNumber: a,
    twoColorPalette: i,
    updateConfig: u,
    parseDate: c,
    formatDate: l,
    currentViewport: p
  } = ue.useContext(mt), { barStyle: h, tipRounding: g, roundingStyle: x, twoColor: w } = r, y = ue.useRef([]), [R, b] = ue.useState(window.innerWidth), v = x === "standard" ? "8px" : x === "shallow" ? "5px" : x === "finger" ? "15px" : "0px";
  r.barStyle;
  const A = Number(r.xAxis.target), N = r.series[0].dataKey, L = Number(t.domain()[1]), z = n.some((ee) => ee[N] < 0) || A > 0 || t.domain()[0] < 0, W = r.barHasBorder === "true" ? 1 : 0, q = r.lollipopSize === "large" ? 7 : r.lollipopSize === "medium" ? 6 : 5, ne = r.lollipopSize === "large" ? 14 : r.lollipopSize === "medium" ? 12 : 10, G = Math.max(t(0), Math.min(t(A), t(L))), le = (ee) => {
    if (ee == null || h !== "rounded")
      return;
    let Q = {};
    return ee === "left" && (Q = { borderRadius: `${v} 0 0 ${v}` }), ee === "right" && (Q = { borderRadius: `0 ${v} ${v} 0` }), g === "full" && (Q = { borderRadius: v }), Q;
  }, K = {
    calculate: function() {
      const Q = n[0][N] < A ? "left" : "right", Z = `${r.xAxis.targetLabel} ${a(r.xAxis.target || 0, "left")}`, Y = pr(Z, "bold");
      let te = r.isLollipopChart ? q / 2 : Number(r.barHeight) / 2, $ = 0, ce = 0, Se = !1;
      Q === "right" && ($ = -10, Se = Y - $ < G, ce = G - Y), Q === "left" && ($ = 10, Se = t(L) - G > Y + $, ce = G), this.text = Z, this.y = te, this.x = ce, this.padding = $, this.showLabel = r.xAxis.showTargetLabel ? Se : !1;
    }
  };
  K.calculate();
  const re = ue.useRef(null), B = hp(re, {});
  ue.useEffect(() => {
    const ee = () => {
      var Q;
      b(window.innerWidth), (Q = y.current) == null || Q.forEach((Z) => {
        !Z || !Z.style || (Z.style.transition = "none", Z.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", ee), () => {
      window.removeEventListener("resize", ee);
    };
  }, []);
  const [j, se] = ue.useState(!1);
  return ue.useEffect(() => {
    B != null && B.isIntersecting && setTimeout(() => {
      se(!0);
    }, 100);
  }, [B == null ? void 0 : B.isIntersecting, r.animate]), ue.useEffect(() => {
    var ee;
    (ee = y.current) == null || ee.forEach((Q, Z) => {
      if (!(!Q || !Q.style)) {
        if (r.animate) {
          const Y = A / L * 100;
          Q.style.opacity = "0", Q.style.transform = `translate(${Y / 1.07}%) scale(0, 1)`, setTimeout(() => {
            Q.style.opacity = "1", Q.style.transform = "translate(0) scale(1)", Q.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          Q.style.transition = "none", Q.style.opacity = "0";
        r.animate || (Q.style.transition = "none", Q.style.opacity = "1");
      }
    });
  }, [r.animate, r, j]), /* @__PURE__ */ React.createElement(Vr, { component: "Deviation Bar" }, /* @__PURE__ */ React.createElement(tt, { left: Number(r.xAxis.size) }, n.map((ee, Q) => {
    const Z = Number(ee[N]), Y = r.isLollipopChart ? q : Number(r.barHeight), te = Number(r.barSpace), $ = Math.abs(t(Z) - G), ce = t(Z), Se = Z > A ? G : ce, be = Z < A ? "left" : "right";
    let ve = 0;
    ve = Q !== 0 ? (te + Y + W) * Q : ve;
    const Pe = (te + Y + W) * n.length;
    r.heights.horizontal = Pe;
    const we = pr(a(Z, "left")) < $ - 6, me = ce, Ce = ve + Y / 2, fe = ce, ze = ve + Y / 2, Ie = ce, Qe = ve - Y / 2, He = le(be), [Fe, qe] = i[w.palette], We = { left: Fe, right: qe }, je = il("#000", We[be]);
    let Ke = Ek(r.isLollipopChart, we, ne, je);
    const Te = a(Z, "left"), _e = r.runtime.yAxis.type === "date" ? l(c(n[Q][r.runtime.originalXAxis.dataKey])) : n[Q][r.runtime.originalXAxis.dataKey];
    let at = r.runtime.yAxis.label ? `${r.runtime.yAxis.label}: ${_e}` : _e, ge = r.runtime.xAxis.label ? `${r.runtime.xAxis.label}: ${Te}` : Te;
    const ft = `<div>
          ${at}<br />
          ${ge}
            </div>`;
    return /* @__PURE__ */ React.createElement(tt, { key: `deviation-bar-${r.orientation}-${N}-${Q}` }, /* @__PURE__ */ React.createElement(
      "foreignObject",
      {
        ref: (ot) => {
          y.current[Q] = ot;
        },
        x: Se,
        y: ve,
        width: $,
        height: Y,
        "data-tooltip-html": ft,
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
        tabIndex: -1
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          style: {
            width: $,
            height: Y,
            border: `${W}px solid #333`,
            backgroundColor: We[be],
            ...He
          }
        }
      )
    ), r.yAxis.displayNumbersOnBar && /* @__PURE__ */ React.createElement(ht, { verticalAnchor: "middle", x: me, y: Ce, ...Ke[be] }, a(ee[N], "left")), r.isLollipopChart && r.lollipopShape === "circle" && /* @__PURE__ */ React.createElement(
      "circle",
      {
        cx: fe,
        cy: ze,
        r: ne / 2,
        fill: We[be],
        style: { filter: "unset", opacity: 1 }
      }
    ), r.isLollipopChart && r.lollipopShape === "square" && /* @__PURE__ */ React.createElement(
      "rect",
      {
        x: Ie,
        y: Qe,
        width: ne,
        height: ne,
        fill: We[be],
        style: { opacity: 1, filter: "unset" }
      }
    ));
  }), K.showLabel && /* @__PURE__ */ React.createElement(ht, { fontWeight: "bold", dx: K.padding, verticalAnchor: "middle", x: K.x, y: K.y }, K.text), z && /* @__PURE__ */ React.createElement(en, { from: { x: G, y: 0 }, to: { x: G, y: e }, stroke: "#333", strokeWidth: 2 })), /* @__PURE__ */ React.createElement("foreignObject", { y: e / 2, ref: re }));
}
function Ek(e, t, n, r) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: n + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -n,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? r : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? r : "#000000"
    }
  };
}
const Sk = ({ xScale: e, yScale: t, height: n, width: r, handleTooltipMouseOver: a, handleTooltipMouseOff: i }) => {
  var y;
  const { transformedData: u, rawData: c, config: l, seriesHighlight: p } = ue.useContext(mt), { xAxis: h, yAxis: g, legend: x, runtime: w } = l;
  return u && /* @__PURE__ */ m.createElement(Vr, { component: "ForecastingChart" }, /* @__PURE__ */ m.createElement(tt, { className: "forecasting-items", key: "forecasting-items-wrapper", left: Number(g.size) }, (y = w.forecastingSeriesKeys) == null ? void 0 : y.map((R, b) => !R || !R.stages ? !1 : R.stages.map((v, A) => {
    var W;
    const { behavior: N } = x, L = c.filter((q) => q[R.stageColumn] === v.key);
    let C = N === "highlight" && p.length > 0 && p.indexOf(v.key) === -1, z = N === "highlight" || p.length === 0 || p.indexOf(v.key) !== -1;
    return /* @__PURE__ */ m.createElement(tt, { className: `forecasting-areas-combo-${b}`, key: `forecasting-areas--stage-${v.key.replaceAll(" ", "-")}-${b}` }, (W = R.confidenceIntervals) == null ? void 0 : W.map((q, ne) => {
      const G = Gc[v.color] || Sr[v.color] || !1, le = () => z && G[2] ? G[2] : "transparent", K = () => z && G[1] ? G[1] : "transparent";
      if (!(q.high === "" || q.low === ""))
        return /* @__PURE__ */ m.createElement(tt, { key: `forecasting-areas--stage-${v.key.replaceAll(" ", "-")}--group-${A}-${ne}` }, /* @__PURE__ */ m.createElement(
          q0,
          {
            curve: Wc,
            data: L,
            fill: le(),
            opacity: C ? 0.1 : 0.5,
            x: (re) => e(Date.parse(re[h.dataKey])),
            y0: (re) => t(re[q.low]),
            y1: (re) => t(re[q.high])
          }
        ), ne === 0 && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(Hr, { data: L, x: (re) => Number(e(Date.parse(re[h.dataKey]))), y: (re) => Number(t(re[q.high])), curve: Wc, stroke: K(), strokeWidth: 1, strokeOpacity: 1 }), /* @__PURE__ */ m.createElement(Hr, { data: L, x: (re) => Number(e(Date.parse(re[h.dataKey]))), y: (re) => Number(t(re[q.low])), curve: Wc, stroke: K(), strokeWidth: 1, strokeOpacity: 1 })));
    }));
  })), /* @__PURE__ */ m.createElement(tt, { key: "tooltip-hover-section" }, /* @__PURE__ */ m.createElement(Nr, { key: "bars", width: Number(r), height: Number(n), fill: "transparent", fillOpacity: 0.05, onMouseMove: (R) => a(R, u), onMouseOut: i }))));
};
function Vu(e, t) {
  const n = e.series.every(({ type: w }) => w === "Bar"), r = e.series.every(({ type: w }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(w)), a = (w) => (y) => w.reduce((R, b) => isNaN(Number(y[b])) ? R : R + Number(y[b]), 0), i = (w) => {
    const y = e.runtime.series.find((R) => R.dataKey === w);
    return y != null && y.dynamicCategory ? y.originalDataKey : w;
  }, u = () => {
    let w = Math.max(
      ...t == null ? void 0 : t.map(
        (y) => Math.max(
          ...e.runtime.seriesKeys.map((R) => {
            const b = i(R);
            return Vi(y[b]) ? Number(p(y[b])) : 0;
          })
        )
      )
    );
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && n) && e.visualizationSubType === "stacked") {
      const y = t.map(a(e.runtime.seriesKeys)).filter((R) => !isNaN(R));
      w = Math.max(...y);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const y = t.map(a(e.runtime.seriesKeys));
      w = Math.max(...y);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (w = Math.max(
      ...t.map((y) => Vi(y[e.series.dataKey]) ? Number(p(y[e.series.dataKey])) : 0)
    )), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !n && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const y = t.map(a(e.runtime.barSeriesKeys)), R = Math.max(
        ...t.map((v) => Math.max(...e.runtime.lineSeriesKeys.map((A) => Number(p(v[A])))))
      ), b = Math.max(...y);
      w = Math.max(b, R);
    }
    return w;
  }, c = () => {
    const w = Math.min(
      ...t.map(
        (y) => Math.min(
          ...e.runtime.seriesKeys.map((R) => {
            const b = i(R);
            return Vi(y[b]) ? Number(p(y[b])) : 1 / 0;
          })
        )
      )
    );
    return String(w);
  }, l = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((w) => t.some((y) => y[i(w)] >= 0)) : !1, p = (w) => w === null || w === "" ? "" : typeof w == "string" ? w.replace(/[,$]/g, "") : w, h = Number(u()), g = Number(c()), x = l();
  return { minValue: g, maxValue: h, existPositiveValue: x, isAllLine: r };
}
function Ep({ config: e, yMax: t = 0, data: n = [], updateConfig: r }) {
  var x, w, y, R;
  const a = e.visualizationType === "Combo" && e.orientation === "vertical", i = e.series && e.series.filter((b) => b.axis === "Right").map((b) => b.dataKey);
  let { minValue: u } = Vu(e, n);
  const c = (b) => {
    if (!b)
      return [0];
    let v = [];
    return b.map((A, N) => v = [...v, ...n.map((L) => Number(L[A]))]), v;
  };
  let l = Math.max.apply(null, c(i));
  e.yAxis.rightMax > l && (l = e.yAxis.rightMax), e.yAxis.rightMin < u && (u = e.yAxis.rightMin);
  const p = ((w = (x = e.runtime) == null ? void 0 : x.barSeriesKeys) == null ? void 0 : w.length) > 0, h = ((R = (y = e.runtime) == null ? void 0 : y.lineSeriesKeys) == null ? void 0 : R.length) > 0;
  return (p || h) && u > 0 && (u = 0), { yScaleRight: Mn({
    domain: [u, l],
    range: [t, 0]
  }), hasRightAxis: a };
}
const kk = (e) => {
  const { preliminaryData: t, data: n, stroke: r, strokeWidth: a, handleLineType: i, lineType: u, seriesKey: c } = e, l = t.filter(
    (x) => x.seriesKey && x.column && x.value && x.type && x.style && x.type === "effect"
  ), p = (x) => l.find(
    (w) => w.seriesKey === c && x[w.column] === w.value && w.type === "effect" && w.style !== "Open Circles"
  );
  let h = [];
  const g = (x) => ({
    stroke: r,
    strokeWidth: a,
    strokeDasharray: x
  });
  return n.forEach((x, w) => {
    let y = p(x), R = g(i(y ? y.style : u));
    h.push(R), y && w > 0 && (h[w - 1] = g(i(y.style)));
  }), h;
}, wk = (e, t, n) => {
  const r = e == null ? void 0 : e.filter((i) => i.style.includes("Circles") && i.type === "effect").map((i) => ({
    column: i.column,
    value: i.value,
    seriesKey: i.seriesKey,
    circleSize: i.circleSize,
    style: i.style
  })), a = [];
  return t.forEach((i) => {
    r.forEach((u) => {
      if (i[u.column] === u.value && u.seriesKey === n && i[n] && u.style === "Open Circles") {
        const c = {
          data: i,
          size: u.circleSize,
          isFilled: !1
        };
        a.push(c);
      }
      if ((!u.value || i[u.column] === u.value) && u.seriesKey === n && i[n] && u.style === "Filled Circles") {
        const c = {
          data: i,
          size: u.circleSize,
          isFilled: !0
        };
        a.push(c);
      }
    });
  }), a;
}, wu = (e) => !isNaN(parseFloat(e)) && isFinite(e), Tk = (e, t, n) => {
  let r = "0";
  const a = {
    data: { 0: [] },
    style: ""
  };
  if (!e.length)
    return a;
  const i = e[0], u = (l) => {
    if (!(l.type === "effect" || l.hideLineStyle))
      return l.type == "suppression" && l.value === i[t] && (!l.column || l.column === t);
  }, c = n.find(u);
  if (c && c.style) {
    const l = { ...i, [t]: 0 };
    a.data[r].push(l), a.style = c.style;
    let p = 1;
    for (; p < e.length && !wu(e[p][t]); )
      p++;
    p < e.length && a.data[r].push(e[p]);
  } else
    a.data[r].push(i);
  return a;
}, Rk = (e, t, n) => {
  let r = "0";
  const a = {
    data: { 0: [] },
    style: ""
  };
  let i = -1;
  return n == null || n.forEach((u) => {
    if (u.type !== "effect" && e[e.length - 1][t] === u.value && u.style && (!u.column || u.column === t) && u.type == "suppression" && !u.hideLineStyle) {
      const c = e.length - 1, l = { ...e[c], [t]: 0 };
      a.data[r].push(l);
      let p = c - 1;
      for (; p >= 0 && !wu(e[p][t]); )
        p--;
      p >= 0 && i !== p && (a.data[r].push(e[p]), i = p), a.style = u.style;
    }
  }), a;
};
function Ck(e, t, n) {
  let r = {
    data: {},
    style: ""
  }, a = 1;
  return e.forEach((i, u) => {
    n.forEach((c) => {
      const l = c.value;
      if (i[t] === l) {
        let p = null, h = null;
        for (let g = u - 1; g >= 0; g--)
          if (wu(e[g][t])) {
            p = e[g];
            break;
          }
        for (let g = u + 1; g < e.length; g++)
          if (wu(e[g][t])) {
            h = e[g];
            break;
          }
        p && h && (r.style = c.style, r.data[a++] = [p, h]);
      }
    });
  }), r;
}
const Ak = (e, t, n, r) => {
  const a = Tk(e, t, n), i = Rk(e, t, n), u = Ck(e, t, n);
  return [a, u, i];
};
var Lk = ["children", "className", "top", "left", "size"];
function Wf() {
  return Wf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Wf.apply(this, arguments);
}
function Nk(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function Sp(e) {
  var t = e.children, n = e.className, r = e.top, a = e.left, i = e.size, u = Nk(e, Lk), c = Ng();
  return c.type(f0), (typeof i == "number" || i) && c.size(i), t ? /* @__PURE__ */ m.createElement(m.Fragment, null, t({
    path: c
  })) : /* @__PURE__ */ m.createElement(Yf, {
    top: r,
    left: a
  }, /* @__PURE__ */ m.createElement("path", Wf({
    className: Sn("visx-glyph-cross", n),
    d: c() || ""
  }, u)));
}
Sp.propTypes = {
  children: Me.func,
  className: Me.string,
  top: Me.number,
  left: Me.number,
  size: Me.oneOfType([Me.number, Me.func])
};
const Pk = [
  Em,
  Sm,
  Xc,
  km,
  Xc,
  Sp,
  ({ fill: e }) => /* @__PURE__ */ m.createElement(Yf, null, /* @__PURE__ */ m.createElement(ht, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle" }, "⬟"))
], sf = (e) => {
  var ne, G, le, K, re, B, j;
  const {
    config: t,
    d: n,
    tableData: r,
    displayArea: a,
    seriesKey: i,
    tooltipData: u,
    xScale: c,
    yScale: l,
    colorScale: p,
    parseDate: h,
    yScaleRight: g,
    data: x,
    circleData: w,
    dataIndex: y,
    mode: R,
    seriesIndex: b
  } = e, { lineDatapointStyle: v, visual: A } = t, N = (ne = t == null ? void 0 : t.series.filter((se) => se.dataKey === i)) == null ? void 0 : ne[0], L = Pk[t.visual.lineDatapointSymbol === "standard" && b < A.maximumShapeAmount ? b : 0], C = b === 4, z = (se, ee) => `translate(${ee}, ${se})${C ? " rotate(180)" : ""}`, W = (se, ee, Q, Z, Y) => {
    const te = Q.runtime.seriesLabels || [], $ = Q.runtime.seriesLabelsAll || [];
    let ce = se ? ee(te[Z] || $[b]) : " transparent";
    return Q.lineDatapointColor === "Lighter than Line" && ce !== "transparent" && ce && (ce = Ua(ce).brighten(1)), ce;
  }, q = (se) => (t.xAxis.type === "categorical" ? c(se) : c(h(se))) + (c.bandwidth ? c.bandwidth() / 2 : 0);
  if (R === "ALWAYS_SHOW_POINTS" && v !== "hidden" && v === "always show") {
    if ((w == null ? void 0 : w.some(
      (Z) => Z[t.xAxis.dataKey] === n[t.xAxis.dataKey] && Z[i] === n[i]
    )) || !N || A.maximumShapeAmount === b && A.lineDatapointSymbol === "standard")
      return /* @__PURE__ */ m.createElement(m.Fragment, null);
    const ee = q(n[t.xAxis.dataKey]), Q = N.axis === "Right" ? g(n[N.dataKey]) : l(n[N.dataKey]);
    return /* @__PURE__ */ m.createElement("g", { transform: z(Q, ee) }, /* @__PURE__ */ m.createElement(
      L,
      {
        opacity: n[i] ? 1 : 0,
        fillOpacity: 1,
        fill: W(a, p, t, i),
        style: { filter: "unset", opacity: 1 }
      }
    ));
  }
  if (R === "HOVER_POINTS" && v === "hover") {
    if (!u || !i || !u.data)
      return;
    let se = (le = (G = u == null ? void 0 : u.data) == null ? void 0 : G[0]) == null ? void 0 : le[1];
    if (!se)
      return;
    let ee, Q = u.data.filter((ce) => ce[0] === i), Z = (K = Q == null ? void 0 : Q[0]) == null ? void 0 : K[0], Y = (re = Q == null ? void 0 : Q[0]) == null ? void 0 : re[2];
    const te = t.runtime.series.find((ce) => ce.dynamicCategory), $ = (te == null ? void 0 : te.originalDataKey) ?? i;
    return Z ? (ee = (B = r == null ? void 0 : r.find((ce) => {
      const Se = te == null ? void 0 : te.dynamicCategory;
      return ce[t.xAxis.dataKey] === se ? Se ? ce[Se] === Z : !0 : !1;
    })) == null ? void 0 : B[$], u == null ? void 0 : u.data.map((ce, Se) => {
      if (isNaN(ee))
        return /* @__PURE__ */ m.createElement(m.Fragment, null);
      if ((w == null ? void 0 : w.some((Ve) => Ve[t.xAxis.dataKey] === se)) || !ee || A.maximumShapeAmount === b && A.lineDatapointSymbol === "standard")
        return /* @__PURE__ */ m.createElement(m.Fragment, null);
      const ve = Y === "right" ? g(ee) : l(ee), Pe = q(se);
      return /* @__PURE__ */ m.createElement("g", { transform: z(ve, Pe) }, /* @__PURE__ */ m.createElement(
        L,
        {
          size: 55,
          opacity: 1,
          fillOpacity: 1,
          fill: W(a, p, t, Z),
          style: { filter: "unset", opacity: 1 }
        }
      ));
    })) : void 0;
  }
  if (R === "ISOLATED_POINTS" && ((ee, Q) => {
    const Z = x[ee], Y = x[ee - 1] || {}, te = x[ee + 1] || {};
    if (w.some((ve) => (ve == null ? void 0 : ve.data[Q]) === Z[Q]))
      return !1;
    const ce = ee === 0 && !te[Q], Se = ee === x.length - 1 && !Y[Q], be = ee > 0 && ee < x.length - 1 && Z[Q] && !Y[Q] && !te[Q];
    return ce || Se || be;
  })(y, i)) {
    const ee = (N == null ? void 0 : N.axis) === "Right" ? g(n[N == null ? void 0 : N.dataKey]) : l(n[N == null ? void 0 : N.dataKey]), Q = q(n[(j = t.xAxis) == null ? void 0 : j.dataKey]), Z = p(t.runtime.seriesLabelsAll[b]);
    return /* @__PURE__ */ m.createElement("g", { transform: z(ee, Q) }, /* @__PURE__ */ m.createElement(L, { size: 124, stroke: Z, fill: Z }));
  }
  return null;
}, Dk = (e) => {
  var h, g;
  const { config: t, xScale: n, yScale: r, parseDate: a } = e;
  if (!((h = t == null ? void 0 : t.runtime) != null && h.series))
    return;
  const i = (x) => {
    if (t.xAxis.type === "date")
      return a(x).getTime();
    if (t.xAxis.type === "date-time")
      return new Date(x);
    if (t.xAxis.type === "categorical")
      return x;
  }, u = (x) => n.bandwidth ? n.bandwidth() / 2 + Number(x) : Number(x), c = (x) => {
    var w;
    return (w = Object.values(t.columns)) == null ? void 0 : w.filter((y) => y.tooltips).map((y) => `
        <li className='tooltip-body'>
          <strong>${y.label || y.name}</strong>: ${x[y.name]}
        </li>`).join(" ");
  }, l = (x) => `<ul> ${c(x)} </ul>`, p = (g = t.runtime) == null ? void 0 : g.series.map((x) => t.data.map((w, y) => {
    let R = w[x.dataKey], b = w[t.xAxis.dataKey];
    return /* @__PURE__ */ m.createElement(m.Fragment, { key: `bump-circle-${R}-${y}` }, /* @__PURE__ */ m.createElement(tt, { left: Number(t.runtime.yAxis.size) }, R && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
      "circle",
      {
        key: `bump-circle-${R}-${y}`,
        "data-tooltip-html": l(w),
        "data-tooltip-id": "bump-chart",
        r: 10,
        cx: Number(u(n(i(b)))),
        cy: Number(r(R)),
        stroke: "#CACACA",
        strokeWidth: 1,
        fill: "#E5E4E2"
      }
    ), R.toString().length === 2 ? (
      // prettier-ignore
      /* @__PURE__ */ m.createElement(
        "text",
        {
          x: Number(u(n(i(b)))) - 7,
          y: Number(r(R)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        R
      )
    ) : (
      // prettier-ignore
      /* @__PURE__ */ m.createElement(
        "text",
        {
          x: Number(u(n(i(b)))) - 4,
          y: Number(r(R)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        R
      )
    ))));
  }));
  return /* @__PURE__ */ m.createElement(m.Fragment, null, p);
}, fm = (e) => {
  var re;
  const {
    getXAxisData: t,
    getYAxisData: n,
    handleTooltipClick: r,
    handleTooltipMouseOff: a,
    handleTooltipMouseOver: i,
    tooltipData: u,
    xMax: c,
    xScale: l,
    yMax: p,
    yScale: h
  } = e, { colorScale: g, config: x, formatNumber: w, handleLineType: y, parseDate: R, seriesHighlight: b, tableData: v, transformedData: A, updateConfig: N, brushConfig: L, clean: C } = ue.useContext(mt), { yScaleRight: z } = Ep({ config: x, yMax: p, data: A, updateConfig: N });
  if (!i)
    return;
  const { lineDatapointStyle: W, showLineSeriesLabels: q, legend: ne } = x;
  let G = A, le = v;
  L.data.length > 0 && ((re = x.brush) != null && re.active) && (G = C(L.data), le = C(L.data));
  const K = (B) => l(t(B)) + (l.bandwidth ? l.bandwidth() / 2 : 0);
  return /* @__PURE__ */ m.createElement(Vr, { component: "LineChart" }, /* @__PURE__ */ m.createElement(tt, { left: Number(x.runtime.yAxis.size) }, " ", (x.runtime.lineSeriesKeys || x.runtime.seriesKeys).map((B, j) => {
    var be;
    const se = x.runtime.series.find((ve) => ve.dataKey === B), ee = se.type, Q = se.axis || "left", Z = ne.behavior === "highlight" || b.length === 0 || b.indexOf(B) !== -1, Y = Ak(
      v,
      B,
      x.preliminaryData,
      x.xAxis.dataKey
    ), te = ((be = x == null ? void 0 : x.preliminaryData) == null ? void 0 : be.filter((ve) => ve.style && !ve.style.includes("Circles")).length) > 0, $ = se.dynamicCategory ? G.filter((ve) => ve[se.dynamicCategory] === B) : G, ce = se.dynamicCategory ? se.originalDataKey : B, Se = wk(x == null ? void 0 : x.preliminaryData, le, ce);
    return /* @__PURE__ */ m.createElement(
      tt,
      {
        key: `series-${B}-${j}`,
        opacity: ne.behavior === "highlight" && b.length > 0 && b.indexOf(B) === -1 ? 0.5 : 1,
        display: ne.behavior === "highlight" || b.length === 0 && !ne.dynamicLegend || b.indexOf(B) !== -1 ? "block" : "none"
      },
      /* @__PURE__ */ m.createElement(
        Nr,
        {
          key: "bars",
          width: Number(c),
          height: Number(p),
          fill: "transparent",
          fillOpacity: 0.05,
          onMouseMove: (ve) => i(ve, v),
          onMouseOut: a,
          onClick: (ve) => r(ve, G)
        }
      ),
      $.map((ve, Pe) => Vi(ve[ce]) && /* @__PURE__ */ m.createElement(m.Fragment, { key: `series-${B}-point-${Pe}` }, x.labels && /* @__PURE__ */ m.createElement(
        ht,
        {
          x: K(ve),
          y: Q === "Right" ? z(n(ve, ce)) : h(n(ve, ce)),
          fill: "#000",
          textAnchor: "middle"
        },
        w(ve[ce], "left")
      ), W === "always show" && /* @__PURE__ */ m.createElement(
        sf,
        {
          mode: "ALWAYS_SHOW_POINTS",
          dataIndex: Pe,
          circleData: Se,
          tableData: v,
          data: $,
          d: ve,
          config: x,
          seriesKey: ce,
          displayArea: Z,
          tooltipData: u,
          xScale: l,
          yScale: h,
          colorScale: g,
          parseDate: R,
          yScaleRight: z,
          seriesAxis: Q,
          seriesIndex: j,
          key: `line-circle--${Pe}`
        }
      ), /* @__PURE__ */ m.createElement(
        sf,
        {
          mode: "ISOLATED_POINTS",
          seriesIndex: j,
          dataIndex: Pe,
          tableData: v,
          circleData: Se,
          data: $,
          d: ve,
          config: x,
          seriesKey: ce,
          displayArea: Z,
          tooltipData: u,
          xScale: l,
          yScale: h,
          colorScale: g,
          parseDate: R,
          yScaleRight: z,
          seriesAxis: Q,
          key: `isolated-circle-${Pe}`
        }
      ))),
      /* @__PURE__ */ m.createElement(m.Fragment, null, W === "hover" && /* @__PURE__ */ m.createElement(
        sf,
        {
          seriesIndex: j,
          tableData: v,
          dataIndex: 0,
          mode: "HOVER_POINTS",
          circleData: Se,
          data: $,
          config: x,
          seriesKey: B,
          displayArea: Z,
          tooltipData: u,
          xScale: l,
          yScale: h,
          colorScale: g,
          parseDate: R,
          yScaleRight: z,
          seriesAxis: Q
        }
      )),
      te ? /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
        Fy,
        {
          curve: Mi[se.lineType],
          segments: $.map((ve) => [ve]),
          segmentation: "x",
          x: (ve) => K(ve),
          y: (ve) => Q === "Right" ? z(n(ve, ce)) : h(Number(n(ve, ce))),
          styles: kk({
            preliminaryData: x.preliminaryData,
            data: le,
            stroke: g(x.runtime.seriesLabels[B]),
            strokeWidth: se.weight || 2,
            handleLineType: y,
            lineType: ee,
            seriesKey: B
          }),
          defined: (ve, Pe) => ve[B] !== "" && ve[B] !== null && ve[B] !== void 0
        }
      ), Y.map((ve, Pe) => Object.entries(ve.data).map(([Ve, we]) => {
        var me;
        return /* @__PURE__ */ m.createElement(
          Hr,
          {
            key: Pe,
            data: we,
            x: (Ce) => K(Ce),
            y: (Ce) => Q === "Right" ? z(n(Ce, B)) : h(Number(n(Ce, B))),
            stroke: g(x.runtime.seriesLabels[B]),
            strokeWidth: ((me = se[0]) == null ? void 0 : me.weight) || 2,
            strokeOpacity: 1,
            shapeRendering: "geometricPrecision",
            strokeDasharray: y(ve.style),
            defined: (Ce, fe) => Ce[B] !== "" && Ce[B] !== null && Ce[B] !== void 0
          }
        );
      }))) : /* @__PURE__ */ m.createElement(m.Fragment, null, x.confidenceKeys && x.series.map((ve, Pe) => ve.dynamicCategory ? [...new Set(G.map((we) => we[ve.dynamicCategory]))].map((we, me) => {
        const Ce = G.filter((fe) => fe[ve.dynamicCategory] === we);
        return /* @__PURE__ */ m.createElement(
          Lf,
          {
            key: `area-closed-${Pe}-${me}`,
            data: Ce,
            x: (fe) => K(fe),
            y0: (fe) => h(fe[x.confidenceKeys.lower]),
            y1: (fe) => h(fe[x.confidenceKeys.upper]),
            opacity: 0.5,
            fill: g(we),
            yScale: h,
            curve: Mi[ve.lineType]
          }
        );
      }) : /* @__PURE__ */ m.createElement(
        Lf,
        {
          key: `area-closed-${Pe}`,
          data: G,
          x: (Ve) => K(Ve),
          y0: (Ve) => h(Ve[x.confidenceKeys.lower]),
          y1: (Ve) => h(Ve[x.confidenceKeys.upper]),
          opacity: 0.5,
          fill: g(
            x.runtime.seriesLabels ? x.runtime.seriesLabels[ve.dataKey] : ve.dataKey
          ),
          yScale: h,
          curve: Mi[ve.lineType]
        }
      )), /* @__PURE__ */ m.createElement(
        Hr,
        {
          curve: Mi[se.lineType],
          data: x.visualizationType == "Bump Chart" ? $ : x.xAxis.type === "date-time" || x.xAxis.type === "date" ? $.sort((ve, Pe) => {
            let Ve = t(ve), we = t(Pe);
            return Ve < we ? -1 : we < Ve ? 1 : 0;
          }) : $,
          x: (ve) => K(ve),
          y: (ve) => Q === "Right" ? z(n(ve, ce)) : h(Number(n(ve, ce))),
          stroke: g(x.runtime.seriesLabels[B]),
          strokeWidth: se.weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: ee ? y(ee) : 0,
          defined: (ve, Pe) => ve[ce] !== "" && ve[ce] !== null && ve[ce] !== void 0
        }
      )),
      Se.map((ve, Pe) => /* @__PURE__ */ m.createElement(
        "circle",
        {
          key: Pe,
          cx: K(ve.data),
          cy: Q === "Right" ? z(n(ve.data, ce)) : h(Number(n(ve.data, ce))),
          r: ve.size,
          strokeWidth: se.weight || 2,
          stroke: g ? g(x.runtime.seriesLabels[B]) : "#000",
          fill: ve.isFilled ? g ? g(x.runtime.seriesLabels[B]) : "#000" : "#fff"
        }
      )),
      x.animate && /* @__PURE__ */ m.createElement(
        Hr,
        {
          className: "animation",
          curve: Mi[se.lineType],
          data: $,
          x: (ve) => K(ve),
          y: (ve) => Q === "Right" ? z(n(ve, ce)) : h(Number(n(ve, ce))),
          stroke: "#fff",
          strokeWidth: 3,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: ee ? y(ee) : 0,
          defined: (ve, Pe) => ve[B] !== "" && ve[B] !== null && ve[B] !== void 0
        }
      ),
      q && (x.runtime.lineSeriesKeys || x.runtime.seriesKeys).map((ve) => {
        let Pe;
        for (let Ve = $.length - 1; Ve >= 0; Ve--)
          if ($[Ve][ve]) {
            Pe = $[Ve];
            break;
          }
        return Pe ? /* @__PURE__ */ m.createElement(
          ht,
          {
            x: K(Pe) + 5,
            y: h(n(Pe, ve)),
            alignmentBaseline: "middle",
            fill: x.colorMatchLineSeriesLabels && g ? g(x.runtime.seriesLabels[ve] || ve) : "black"
          },
          x.runtime.seriesLabels[ve] || ve
        ) : /* @__PURE__ */ m.createElement(m.Fragment, null);
      })
    );
  }), x.legend.dynamicLegend && b.length === 0 && /* @__PURE__ */ m.createElement(ht, { x: c / 2, y: p / 2, fill: "black", textAnchor: "middle", color: "black" }, x.legend.dynamicLegendChartMessage)), x.visualizationType === "Bump Chart" && /* @__PURE__ */ m.createElement(Dk, { config: x, xScale: l, yScale: h }));
}, _k = ({
  xScale: e,
  yScale: t,
  config: n,
  height: r,
  width: a,
  handleTooltipMouseOff: i,
  handleTooltipMouseOver: u,
  forestPlotRightLabelRef: c
}) => {
  const { rawData: l, updateConfig: p } = ue.useContext(mt), { forestPlot: h } = n, g = n.xAxis.tickWidthMax + 10, [x, w] = ue.useState(!1);
  ue.useEffect(() => {
    try {
      const L = ["estimateField", "lower", "upper", "estimateRadius"], C = n, z = 10;
      for (let W = 0; W < z; W++)
        L.forEach((q) => {
          var ne;
          n.forestPlot[q] && n.forestPlot[q] !== ((ne = C.columns[n.forestPlot[`additionalColumn${W}`]]) == null ? void 0 : ne.name) && (delete C.columns[`additionalColumn${W}`], C.columns[n.forestPlot[q]] = {}, C.columns[n.forestPlot[q]].dataKey = C.forestPlot[q], C.columns[n.forestPlot[q]].name = C.forestPlot[q], C.columns[n.forestPlot[q]].dataTable = !0, C.columns[n.forestPlot[q]].tooltips = !0, C.columns[n.forestPlot[q]].label = C.forestPlot[q]);
        });
      n.forestPlot.radius.scalingColumn && (C.columns[n.forestPlot.radius.scalingColumn] = {}, C.columns[n.forestPlot.radius.scalingColumn].dataKey = C.forestPlot.radius.scalingColumn, C.columns[n.forestPlot.radius.scalingColumn].name = C.forestPlot.radius.scalingColumn, C.columns[n.forestPlot.radius.scalingColumn].label = C.forestPlot.radius.scalingColumn, C.columns[n.forestPlot.radius.scalingColumn].dataTable = !0, C.columns[n.forestPlot.radius.scalingColumn].tooltips = !0), C.table.showVertical && (C.table.indexLabel = n.xAxis.dataKey), p(C);
    } catch (L) {
      console.log(L.message);
    }
  }, []), ue.useEffect(() => {
    !x && n.forestPlot.type === "Logarithmic" && (p({
      ...n,
      dataFormat: {
        ...n.dataFormat,
        roundTo: 2
      }
    }), w(!0));
  }, [n.forestPlot.type]);
  const y = n.data.find((L) => L[n.xAxis.dataKey] === n.forestPlot.pooledResult.column), R = y ? [
    { x: e(y[n.forestPlot.lower]), y: r - Number(n.forestPlot.rowHeight) },
    {
      x: e(y[n.forestPlot.estimateField]),
      y: r - h.pooledResult.diamondHeight - Number(n.forestPlot.rowHeight)
    },
    { x: e(y[n.forestPlot.upper]), y: r - Number(n.forestPlot.rowHeight) },
    {
      x: e(y[n.forestPlot.estimateField]),
      y: r + h.pooledResult.diamondHeight - Number(n.forestPlot.rowHeight)
    },
    { x: e(y[n.forestPlot.lower]), y: r - Number(n.forestPlot.rowHeight) }
  ] : [], b = n.forestPlot.rowHeight, v = [
    { x: 0, y: b },
    { x: a, y: b }
  ], A = [
    { x: 0, y: r },
    { x: a, y: r }
  ], N = Object.entries(n.columns).map((L) => L[1]).filter((L) => L.forestPlot === !0);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(tt, { width: a }, h.title && /* @__PURE__ */ React.createElement(
    ht,
    {
      className: "forest-plot--title",
      x: h.type === "Linear" ? e(0) : e(1),
      y: 0,
      textAnchor: "middle",
      verticalAnchor: "start",
      fill: "black"
    },
    h.title
  ), h.lineOfNoEffect.show && h.type === "Linear" && /* @__PURE__ */ React.createElement(
    en,
    {
      from: { x: e(0), y: 0 + b },
      to: { x: e(0), y: r },
      className: "forestplot__line-of-no-effect",
      stroke: h.regression.baseLineColor || "black"
    }
  ), h.lineOfNoEffect.show && h.type === "Logarithmic" && /* @__PURE__ */ React.createElement(
    en,
    {
      from: { x: e(1), y: 0 + b },
      to: { x: e(1), y: r },
      className: "forestplot__line-of-no-effect",
      stroke: h.regression.baseLineColor || "black"
    }
  ), l.map((L, C) => {
    const z = Mn({
      domain: l.map((K) => K[h.radius.scalingColumn]),
      range: [h.radius.min, h.radius.max]
    }), W = h.radius.scalingColumn !== "" ? z(l[C][h.radius.scalingColumn]) : 4, q = h.colors.shape ? h.colors.shape : "black", ne = h.colors.line ? h.colors.line : "black", G = 4;
    return L[n.xAxis.dataKey] === h.pooledResult.column ? /* @__PURE__ */ React.createElement(
      Hr,
      {
        data: R,
        x: (K) => K.x,
        y: (K) => K.y - Lu / 2,
        stroke: "black",
        strokeWidth: 2,
        fill: "black",
        curve: kf
      }
    ) : /* @__PURE__ */ React.createElement(tt, null, /* @__PURE__ */ React.createElement(
      "path",
      {
        stroke: ne,
        strokeWidth: 1,
        className: "lower-ci",
        d: `
                    M${e(L[h.lower])} ${t(C) - Number(G)}
                    L${e(L[h.lower])} ${t(C) + Number(G)}
                `
      }
    ), /* @__PURE__ */ React.createElement(
      "path",
      {
        stroke: ne,
        strokeWidth: 1,
        className: "upper-ci",
        d: `
                    M${e(L[h.upper])} ${t(C) - Number(G)}
                    L${e(L[h.upper])} ${t(C) + Number(G)}
                `
      }
    ), /* @__PURE__ */ React.createElement(
      "line",
      {
        stroke: ne,
        className: `line-${L[n.yAxis.dataKey]}`,
        key: C,
        x1: e(L[h.lower]),
        x2: e(L[h.upper]),
        y1: t(C),
        y2: t(C)
      }
    ), h.shape === "circle" && /* @__PURE__ */ React.createElement(
      tv,
      {
        className: "forest-plot--circle",
        cx: e(Number(L[h.estimateField])),
        cy: t(C),
        r: h.radius.scalingColumn !== "" ? z(l[C][h.radius.scalingColumn]) : 4,
        fill: q,
        style: { opacity: 1, filter: "unset" }
      }
    ), h.shape === "square" && /* @__PURE__ */ React.createElement(
      "rect",
      {
        className: "forest-plot--square",
        x: e(Number(L[h.estimateField])),
        y: t(C) - W / 2,
        width: W,
        height: W,
        fill: q,
        style: { opacity: 1, filter: "unset" }
      }
    ), h.shape === "text" && /* @__PURE__ */ React.createElement(
      ht,
      {
        className: "forest-plot--text",
        x: e(Number(L[h.estimateField])),
        y: t(C),
        textAnchor: "middle",
        verticalAnchor: "middle",
        fill: q
      },
      L[h.estimateField]
    ));
  }), R && h.regression.showDiamond && /* @__PURE__ */ React.createElement(
    Hr,
    {
      data: R,
      x: (L) => L.x,
      y: (L) => L.y,
      stroke: "black",
      strokeWidth: 2,
      fill: h.regression.baseLineColor,
      curve: kf
    }
  ), h.regression.description && /* @__PURE__ */ React.createElement(
    ht,
    {
      x: 0 - Number(n.xAxis.size),
      width: a,
      y: r - n.forestPlot.rowHeight - Number(h.rowHeight) / 3,
      verticalAnchor: "start",
      textAnchor: "start",
      style: { fontWeight: "bold", fontSize: 12 }
    },
    h.regression.description
  ), /* @__PURE__ */ React.createElement(
    Nr,
    {
      key: "forest-plot-tooltip-area",
      className: "forest-plot-tooltip-area",
      width: a,
      height: r,
      fill: "transparent",
      fillOpacity: 0.5,
      onMouseMove: (L) => u(L, l),
      onMouseOut: i
    }
  )), /* @__PURE__ */ React.createElement(
    en,
    {
      from: v[0],
      to: v[1],
      style: { stroke: "black", strokeWidth: 2 },
      className: "forestplot__top-line"
    }
  ), /* @__PURE__ */ React.createElement(
    en,
    {
      from: A[0],
      to: A[1],
      style: { stroke: "black", strokeWidth: 2 },
      className: "forestplot__bottom-line"
    }
  ), N.map((L) => l.map((C, z) => /* @__PURE__ */ React.createElement(
    ht,
    {
      className: `${C[L.name]}`,
      x: L.forestPlotAlignRight ? a : L.forestPlotStartingPoint,
      y: t(z),
      textAnchor: L.forestPlotAlignRight ? "end" : "start",
      verticalAnchor: "middle",
      fill: "black"
    },
    C[L.name]
  ))), !h.hideDateCategoryCol && l.map((L, C) => /* @__PURE__ */ React.createElement(
    ht,
    {
      className: `${L[n.xAxis.dataKey]}`,
      x: 0,
      y: t(C),
      textAnchor: "start",
      verticalAnchor: "middle",
      fill: "black"
    },
    L[n.xAxis.dataKey]
  )), !h.hideDateCategoryCol && n.xAxis.dataKey && /* @__PURE__ */ React.createElement(ht, { className: n.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fill: "black" }, n.xAxis.dataKey), N.map((L) => /* @__PURE__ */ React.createElement(
    ht,
    {
      className: `${L.label}`,
      x: L.forestPlotAlignRight ? a : L.forestPlotStartingPoint,
      y: 0,
      textAnchor: L.forestPlotAlignRight ? "end" : "start",
      verticalAnchor: "start",
      fill: "black"
    },
    L.label
  )), h.leftLabel && /* @__PURE__ */ React.createElement(
    ht,
    {
      className: "forest-plot__left-label",
      x: h.type === "Linear" ? e(0) - 25 : e(1) - 25,
      y: r + g,
      textAnchor: "end",
      verticalAnchor: "start"
    },
    h.leftLabel
  ), h.rightLabel && /* @__PURE__ */ React.createElement(
    ht,
    {
      innerRef: c,
      className: "forest-plot__right-label",
      x: h.type === "Linear" ? e(0) + 25 : e(1) + 25,
      y: r + g,
      textAnchor: "start",
      verticalAnchor: "start"
    },
    h.rightLabel
  ));
}, Ok = ({ width: e, height: t, originalWidth: n }) => {
  var v, A, N;
  const { config: r, colorScale: a, transformedData: i, formatNumber: u, seriesHighlight: c } = ue.useContext(mt);
  if (!r || ((v = r == null ? void 0 : r.series) == null ? void 0 : v.length) < 2)
    return;
  const l = r.barHasBorder === "true" ? 1 : 0, p = e / 2, h = 1.02, g = {
    parentKey: (A = r.dataDescription) == null ? void 0 : A.seriesKey,
    dataKey: r.series[0].dataKey,
    dataKeyLabel: r.runtime.seriesLabels[r.series[0].dataKey] || r.series[0].dataKey,
    color: a(r.runtime.seriesLabels[r.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      i.map((L) => L[r.series[0].dataKey])
    ),
    labelColor: ""
  }, x = {
    parentKey: (N = r.dataDescription) == null ? void 0 : N.seriesKey,
    dataKey: r.series[1].dataKey,
    dataKeyLabel: r.runtime.seriesLabels[r.series[1].dataKey] || r.series[1].dataKey,
    color: a(r.runtime.seriesLabels[r.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      i.map((L) => L[r.series[1].dataKey])
    ),
    labelColor: ""
  }, w = Mn({
    domain: [0, Math.max(g.max * h, x.max * 1.1)],
    range: [0, p]
  });
  g.labelColor = g.color ? il("#000", g.color) : "#000", x.labelColor = x.color ? il("#000", x.color) : "#000";
  const y = r.yAxis.label ? `${r.yAxis.label}: ` : "", R = (L) => {
    var C;
    return `<p>
				${(C = r.dataDescription) == null ? void 0 : C.seriesKey}: ${g.dataKeyLabel}<br/>
				${r.xAxis.dataKey}: ${L[r.xAxis.dataKey]}<br/>
				${y}${u(L[g.dataKey], "left")}
			</p>`;
  }, b = (L) => {
    var C;
    return `<p>
				${(C = r.dataDescription) == null ? void 0 : C.seriesKey}: ${x.dataKeyLabel}<br/>
				${r.xAxis.dataKey}: ${L[r.xAxis.dataKey]}<br/>
				${y}${u(L[x.dataKey], "left")}
			</p>`;
  };
  return e > 0 && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("style", null, `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				`), /* @__PURE__ */ m.createElement(
    "svg",
    {
      id: "cdc-visualization__paired-bar-chart",
      width: n,
      height: t,
      viewBox: `0 0 ${e + Number(r.runtime.yAxis.size)} ${t}`,
      role: "img",
      tabIndex: 0
    },
    /* @__PURE__ */ m.createElement("title", null, `Paired bar chart graphic with the title ${r.title ? r.title : "No Title Found"}`),
    /* @__PURE__ */ m.createElement(tt, { top: 0, left: Number(r.xAxis.size) }, i.filter((L) => r.series[0].dataKey === g.dataKey).map((L, C) => {
      var B, j;
      let z = r.legend.behavior === "highlight" && c.length > 0 && c.indexOf(r.series[0].dataKey) === -1, W = r.legend.behavior === "highlight" || c.length === 0 || c.indexOf(r.series[0].dataKey) !== -1, q = w(L[r.series[0].dataKey]), ne = Number(r.barHeight) ? Number(r.barHeight) : 25, G = 0;
      G = C !== 0 ? (Number(r.barSpace) + ne + l) * C : G;
      const le = (Number(r.barSpace) + ne + l) * i.length;
      r.heights.horizontal = le;
      const re = pr(u(L[g.dataKey], "left")) < q - 5;
      return /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(tt, { key: `group-${g.dataKey}-${L[r.xAxis.dataKey]}`, className: "horizontal" }, /* @__PURE__ */ m.createElement(
        Nr,
        {
          id: `bar-${g.dataKey}-${L[(B = r.dataDescription) == null ? void 0 : B.xKey]}`,
          className: "bar group-1",
          key: `bar-${g.dataKey}-${L[(j = r.dataDescription) == null ? void 0 : j.xKey]}`,
          x: p - q,
          y: G,
          width: w(L[r.series[0].dataKey]),
          height: ne,
          fill: g.color,
          "data-tooltip-html": R(L),
          "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
          stroke: "#333",
          strokeWidth: l,
          opacity: z ? 0.5 : 1,
          display: W ? "block" : "none",
          tabIndex: -1
        }
      ), r.yAxis.displayNumbersOnBar && W && /* @__PURE__ */ m.createElement(
        ht,
        {
          textAnchor: re ? "start" : "end",
          dx: re ? 5 : -5,
          verticalAnchor: "middle",
          x: p - q,
          y: G + r.barHeight / 2,
          fill: re ? g.labelColor : "#000"
        },
        u(L[g.dataKey], "left")
      )));
    }), i.filter((L) => r.series[1].dataKey === x.dataKey).map((L, C) => {
      var B, j, se;
      let z = w(L[r.series[1].dataKey]), W = r.legend.behavior === "highlight" && c.length > 0 && c.indexOf(r.series[1].dataKey) === -1, q = r.legend.behavior === "highlight" || c.length === 0 || c.indexOf(r.series[1].dataKey) !== -1, ne = r.barHeight ? Number(r.barHeight) : 25, G = 0;
      G = C !== 0 ? (Number(r.barSpace) + ne + l) * C : G;
      const le = (Number(r.barSpace) + ne + l) * i.length;
      r.heights.horizontal = le;
      const re = pr(u(L[x.dataKey], "left")) < z - 5;
      return /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("style", null, `
                      .bar-${x.dataKey}-${L[r.xAxis.dataKey]} {
                          transform-origin: ${p}px ${G}px
                      }
							      `), /* @__PURE__ */ m.createElement(tt, { key: `group-${x.dataKey}-${L[(B = r.dataDescription) == null ? void 0 : B.xKey]}`, className: "horizontal" }, /* @__PURE__ */ m.createElement(
        Nr,
        {
          id: `bar-${x.dataKey}-${L[(j = r.dataDescription) == null ? void 0 : j.xKey]}`,
          className: "bar group-2",
          key: `bar-${x.dataKey}-${L[(se = r.dataDescription) == null ? void 0 : se.xKey]}`,
          x: p,
          y: G,
          width: w(L[r.series[1].dataKey]),
          height: ne,
          fill: x.color,
          "data-tooltip-html": b(L),
          "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
          strokeWidth: l,
          stroke: "#333",
          opacity: W ? 0.5 : 1,
          display: q ? "block" : "none",
          tabIndex: -1
        }
      ), r.yAxis.displayNumbersOnBar && q && /* @__PURE__ */ m.createElement(
        ht,
        {
          textAnchor: re ? "end" : "start",
          dx: re ? -5 : 5,
          verticalAnchor: "middle",
          x: p + z,
          y: G + r.barHeight / 2,
          fill: re ? x.labelColor : "#000"
        },
        u(L[x.dataKey], "left")
      )));
    }))
  ));
}, Fk = ({ yMax: e, leftSize: t, max: n, xMax: r }) => {
  var b;
  const { config: a } = ue.useContext(mt), { orientation: i } = a, u = (v, A = "#f1f1f1") => {
    try {
      return Ua(v).hex();
    } catch {
      return A;
    }
  }, c = (b = a.yAxis) == null ? void 0 : b.categories, h = ((v) => {
    const A = Object.keys(v), N = A[A.length - 1];
    if (v[N] === "") {
      const L = A.slice(0, -1).reduce((z, W) => {
        const q = Number(v[W]);
        return z + (isNaN(q) ? 0 : q);
      }, 0), C = n - L;
      v[N] = C;
    }
    return [v];
  })(((v) => [...v].reduce((N, L) => (N[L.label] = L.height, N), {}))(c)), g = 0, x = fu({
    domain: [g],
    padding: 0,
    range: [0, t]
  }), w = Mn({
    domain: [0, n],
    range: [e, 0],
    clamp: !0
  }), y = gp({
    domain: c.map((v) => v == null ? void 0 : v.label),
    range: c.map((v) => {
      var A;
      return u((A = v == null ? void 0 : v.color) == null ? void 0 : A.trim());
    })
  }), R = Object.keys(h[0]);
  return /* @__PURE__ */ m.createElement(tt, { left: t - x.bandwidth(), top: 0 }, /* @__PURE__ */ m.createElement(
    Oy,
    {
      data: h,
      keys: R,
      x: () => x(g),
      xScale: x,
      yScale: w,
      color: y
    },
    (v) => v.map(
      (A) => A.bars.map((N) => {
        const L = a.yAxis.categories.length - 1 === A.index, C = Lu / 1.3, z = Ua(N.color).luminance() < 0.4 ? "#fff" : "#000", W = pr(N.key, `${C}px`), q = Number(W) < N.width && N.height > C, ne = `<ul>
              <li class="tooltip-heading""> Label : ${N.key}  </li>
                    </li></ul>`;
        return /* @__PURE__ */ m.createElement(tt, { key: `${A.index}--${N.index}--${i}` }, /* @__PURE__ */ m.createElement(
          tt,
          {
            key: `bar-stack-${A.index}-${N.index}`,
            id: `barStack${A.index}-${N.index}`,
            className: "stack vertical"
          },
          Ds({
            type: "axisBar",
            config: a,
            index: A.index,
            background: y(N.key),
            borderColor: "#333",
            borderStyle: "solid",
            borderWidth: 0,
            width: x.bandwidth(),
            height: N.height,
            x: N.x,
            y: N.y,
            tooltipHtml: ne,
            tooltipId: `cdc-open-viz-tooltip-${a.runtime.uniqueId}`
          }),
          /* @__PURE__ */ m.createElement(
            ht,
            {
              display: q ? "block" : "none",
              key: `text-${A.index}-${N.index}`,
              x: N.x + x.bandwidth() / 2,
              y: N.y + N.height / 2,
              fill: z,
              textAnchor: "middle",
              verticalAnchor: "middle",
              style: { fontSize: C }
            },
            N.key
          ),
          a.runtime.yAxis.gridLines && /* @__PURE__ */ m.createElement(
            en,
            {
              from: { x: N.x + x.bandwidth(), y: N.y },
              to: { x: r + x.bandwidth(), y: N.y },
              stroke: "#d6d6d6"
            }
          ),
          !L && /* @__PURE__ */ m.createElement("rect", { x: N.x, y: N.y, width: N.width, height: 1, fill: "#fff" }),
          /* @__PURE__ */ m.createElement("rect", { x: N.x + N.width, y: 0, width: 1, height: e, fill: "#000" })
        ));
      })
    )
  ));
};
function Mk({ orientation: e, heights: t, visualizationType: n }, r) {
  const i = e === "vertical" || n === "Forest Plot", c = (t == null ? void 0 : t.mobileVertical) && mf(r) ? "mobileVertical" : "vertical";
  return i ? c : "horizontal";
}
function zk({ heights: e, orientation: t, visualizationType: n }, r) {
  if (!e)
    return 0;
  const a = Mk({ orientation: t, heights: e, visualizationType: n }, r), i = Number(e == null ? void 0 : e[a]);
  return isNaN(i) ? 0 : i;
}
const ug = ({ config: e, minValue: t, maxValue: n, existPositiveValue: r, data: a, isAllLine: i, tableData: u }) => {
  let c = 0, l = 0, p = 0, h = 0;
  const { convertLineToBarGraph: g } = ue.useContext(mt);
  if (!a)
    return { min: c, max: l };
  const { visualizationType: x, series: w } = e, { max: y, min: R } = e.runtime.yAxis, b = e.yAxis.enablePadding ? 1 + e.yAxis.scalePadding / 100 : 1, v = e.yAxis.type === "logarithmic", A = r ? Number(y) >= n : Number(y) >= 0, N = v ? Number(R) >= 0 : Number(R) <= 0 && t >= 0 || Number(R) <= t && t < 0;
  c = R && N ? Number(R) : t, l = y && A ? Number(y) : Number.MIN_VALUE;
  const { lower: L, upper: C } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (L && C && e.visualizationType === "Bar") {
    const z = c < 0 ? 1.1 : 0, W = Math.max(...a.flatMap((ne) => [ne[C], ne[L]])) * b, q = Math.min(...a.flatMap((ne) => [ne[C], ne[L]])) * b * z;
    l = l > W ? l : W, c = c < q ? c : q;
  }
  if (e.series.filter((z) => (z == null ? void 0 : z.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: z }
    } = e;
    if ((z == null ? void 0 : z.length) > 0) {
      let W = [];
      z.forEach((le) => {
        var K;
        (K = le.confidenceIntervals) == null || K.map((re) => {
          W.push(re.high), W.push(re.low);
        });
      });
      const q = a.map((le) => W.map((K) => le[K])), ne = Math.max.apply(
        null,
        q.map((le) => le[0])
      ), G = Math.min.apply(
        null,
        q.map((le) => le[1])
      );
      ne > l && (l = ne), G < c && (c = G);
    }
  }
  if (x === "Combo")
    try {
      if (!a)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let z = w.filter((ne) => ne.axis === "Left"), W = w.filter((ne) => ne.axis === "Right");
      const q = (ne, G, le, K = "left") => {
        let re = 0;
        return (G.map((j) => j.dataKey) || []).forEach((j) => {
          let se = G.find((Z) => Z.dataKey === j), ee = ne.map((Z) => Z[j]), Q = Math.max.apply(null, ee);
          e.visualizationSubType === "stacked" && K === "left" && se.type === "Bar" && (re += Q), Q > le && (le = Q), le < re && (le = re);
        }), le;
      };
      p = q(a, z, p, "left"), h = q(a, W, h, "right"), p < Number(y) && (p = Number(y));
    } catch (z) {
      console.error(z.message);
    }
  if ((x === "Bar" || g || x === "Combo" && !i) && c > 0 && (c = 0), (e.visualizationType === "Bar" || g || e.visualizationType === "Combo" && !i) && c < 0 && (c = c * 1.1), e.visualizationType === "Combo" && i && ((R == null || R === "") && c > 0 && (c = 0), R)) {
    const z = v ? Number(R) >= 0 && Number(R) < t : Number(R) < t;
    c = Number(R) && z ? Number(R) : t;
  }
  if (e.visualizationType === "Deviation Bar" && c > 0) {
    const z = Number(R) < Math.min(t, Number(e.xAxis.target));
    c = Number(R) && z ? Number(R) : 0;
  }
  if (e.visualizationType === "Line" && !g) {
    const z = v ? Number(R) >= 0 && Number(R) < t : Number(R) < t, W = u == null ? void 0 : u.some((ne, G) => {
      var le;
      return (le = e.preliminaryData) == null ? void 0 : le.some((K) => {
        var se;
        if (K.type !== "suppression" || !K.style)
          return !1;
        const re = Je.pick(ne, (se = e.runtime) == null ? void 0 : se.seriesKeys), B = Je.values(re).includes(K.value);
        return (K.column ? ne[K.column] === K.value : B) && (G === 0 || G === u.length - 1);
      });
    });
    let q = e.yAxis.type === "categorical";
    c = R !== "" && z ? Number(R) : W || q ? 0 : t;
  }
  if (l === Number.MIN_VALUE && (l = r ? n : 0), e.runtime.yAxis.paddingPercent) {
    let z = (l - c) * e.runtime.yAxis.paddingPercent;
    c -= z, l += z;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const z = a.map((q) => q[e.series[0].dataKey]), W = Math.max(...z).toString().length;
    switch (!0) {
      case (W > 8 && W <= 12):
        l = l * 1.3;
        break;
      case (W > 4 && W <= 7):
        l = l * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (c < 0 ? (l *= 1 + e.yAxis.scalePadding * 2 / 100, c *= 1 + e.yAxis.scalePadding * 2 / 100) : l *= 1 + e.yAxis.scalePadding / 100), e.visualizationType === "Area Chart" && e.visualizationSubType === "stacked" && (c = 0), e.visualizationType === "Scatter Plot" && (l = l * 1.1), { min: c, max: l, leftMax: p, rightMax: h };
}, Qr = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, Bk = (e) => {
  let { xAxisDataMapped: t, xMax: n, yMax: r, min: a, max: i, config: u, data: c } = e;
  const { rawData: l, dimensions: p } = ue.useContext(mt), [h] = p, g = u.runtime.barSeriesKeys || u.runtime.seriesKeys, x = u.runtime.xAxis.type, w = u.orientation === "horizontal", { visualizationType: y, xAxis: R, forestPlot: b } = u;
  let v = null, A = null, N = null, L = null, C = null, z = null, W = Mn({
    domain: [0, 100],
    range: [0, n]
  });
  if (w && (v = Wk({ min: a * 1.03, ...e }), v.type = u.yAxis.type === "logarithmic" ? Qr.LOG : Qr.LINEAR, A = Uk(x, t), A.rangeRound([0, r]), C = Kk(g, [0, r])), w || (v = Qo(t, [0, n], 1 - u.barThickness), A = jk(e), C = Qo(g, [0, v.bandwidth()], 0)), u.xAxis.type === "date" && !w) {
    const q = pm(t, u.xAxis.sortByRecentDate);
    v = Qo(q, [0, n], 1 - u.barThickness);
  }
  if (R.type === "date-time" || R.type === "continuous") {
    let q = Math.min(...t.map(Number)), ne = Math.max(...t.map(Number));
    q -= (u.xAxis.padding ? u.xAxis.padding * 0.01 : 0) * (ne - q), ne += y === "Line" ? 0 : (u.xAxis.padding ? u.xAxis.padding * 0.01 : 0) * (ne - q);
    const G = u.xAxis.sortByRecentDate ? [n, 0] : [0, n];
    v = $E({
      domain: [q, ne],
      range: G
    }), v.type = Qr.TIME;
    let le = Number.MAX_VALUE, K = pm(t, u.xAxis.sortByRecentDate);
    for (let re = 0; re < K.length - 1; re++) {
      let B = v(K[re + 1]) - v(K[re]);
      B < le && (le = B);
    }
    (t.length === 1 || le > n / 4) && (le = n / 4), C = Qo(g, [0, (u.barThickness || 1) * le], 0);
  }
  if (u.visualizationType === "Deviation Bar") {
    const q = u.isLollipopChart ? 1.05 : 1.03;
    A = fu({
      domain: t,
      range: [0, r]
    }), v = Mn({
      domain: [a * q, Math.max(Number(R.target), i)],
      range: [0, n],
      round: !0,
      nice: !0
    }), v.type = Qr.LINEAR;
  }
  if (u.visualizationType === "Scatter Plot") {
    if (R.type === "continuous") {
      let q = R.min ? R.min : Math.min.apply(null, v.domain()), ne = R.max ? R.max : Math.max.apply(null, v.domain());
      v = Mn({
        domain: [q, ne],
        range: [0, n]
      }), v.type = Qr.LINEAR;
    }
    if (R.type === "categorical") {
      const q = t.map((ne) => {
        const G = String(ne), le = parseFloat(G);
        return isNaN(le) ? G : Math.round(le).toString();
      });
      v = Qo(q, [0, n], 1 - u.barThickness);
    }
  }
  if (y === "Box Plot") {
    const q = [];
    if (u.boxplot.plots.map((j) => j.columnOutliers.map((se) => q.push(se))) && !u.boxplot.hideOutliers) {
      let j = Math.min(...q), se = Math.max(...q);
      j < a && (a = j), se > i && (i = se);
    }
    let G = Math.min(...u.boxplot.plots.map((j) => j.columnLowerBounds)), le = Math.max(...u.boxplot.plots.map((j) => j.columnUpperBounds));
    G < a && (a = G), le > i && (i = le);
    const K = Je.uniq(c.map((j) => j[u.xAxis.dataKey])), re = [0, u.barThickness * 100 || 1], B = Je.map(u.series, "dataKey");
    A = Mn({
      range: [r, 0],
      round: !0,
      domain: [a, i]
    }), v = fu({
      range: [0, n],
      domain: K
    }), v.type = Qr.BAND, C = Qo(B, re);
  }
  if (y === "Paired Bar") {
    let ne = Math.max.apply(
      Math,
      c.map((le) => {
        var K;
        return le[(K = u.series[0]) == null ? void 0 : K.dataKey];
      })
    ), G = Math.max.apply(
      Math,
      c.map((le) => {
        var K;
        return le[(K = u.series[1]) == null ? void 0 : K.dataKey];
      })
    );
    L = Mn({
      domain: [0, Math.max(ne, G) * 1.02],
      range: [n / 2, 0]
    }), N = Mn({
      domain: L.domain(),
      range: [n / 2, n],
      nice: !0
    });
  }
  if (y === "Forest Plot") {
    const q = () => b.regression.showDiamond || b.regression.description ? [0 + b.rowHeight * 2, r - b.rowHeight] : [0 + b.rowHeight * 2, r];
    A = Mn({
      domain: [0, l.length],
      range: q()
    });
    const ne = 5, G = Number(b.leftWidthOffset) / 100 * n, le = Number(b.rightWidthOffset) / 100 * n, K = Number(b.rightWidthOffsetMobile) / 100 * n, re = Number(b.leftWidthOffsetMobile) / 100 * n;
    if (h > 480) {
      if (b.type === "Linear" && (v = Mn({
        domain: [
          Math.min(...c.map((B) => parseFloat(B[b.lower]))) - ne,
          Math.max(...c.map((B) => parseFloat(B[b.upper]))) + ne
        ],
        range: [G, Number(h) - le]
      }), v.type = Qr.LINEAR), b.type === "Logarithmic") {
        let B = Math.max(...c.map((se) => parseFloat(se[b.upper]))), j = Math.min(...c.map((se) => parseFloat(se[b.lower])));
        v = pu({
          domain: [j, B],
          range: [G, n - le],
          nice: !0
        }), v.type = Qr.LOG;
      }
    } else if (b.type === "Linear" && (v = Mn({
      domain: [
        Math.min(...c.map((B) => parseFloat(B[b.lower]))) - ne,
        Math.max(...c.map((B) => parseFloat(B[b.upper]))) + ne
      ],
      range: [re, n - K],
      type: Qr.LINEAR
    })), b.type === "Logarithmic") {
      let B = Math.max(...c.map((se) => parseFloat(se[b.upper]))), j = Math.min(...c.map((se) => parseFloat(se[b.lower])));
      v = pu({
        domain: [j, B],
        range: [G, n - le],
        nice: !0,
        base: B > 1 ? 10 : 2,
        round: !1,
        type: Qr.LOG
      });
    }
  }
  return { xScale: v, yScale: A, seriesScale: C, g1xScale: L, g2xScale: N, xScaleNoPadding: z, xScaleAnnotation: W };
}, Ik = (e) => {
  const t = new Date(e);
  return new Date(t.getFullYear(), t.getMonth(), 1).getTime();
}, $k = (e) => (e.includes("%b") || e.includes("%B") || e.includes("%m") || e.includes("%-m") || e.includes("%_m")) && !e.includes("%d") && !e.includes("%-d") && !e.includes("%_d") && !e.includes("%e"), Hk = (e, t, n, r) => {
  const a = t.domain();
  if (t.type === "time") {
    const i = e[e.length - 1], u = e[0], c = (i - u) / (n - 1);
    let l = [];
    for (let p = i; p >= u; p -= c)
      l.push(p);
    return l[l.length - 1] !== u && l.push(u), l.reverse(), $k(r.xAxis.dateDisplayFormat) && (l = l.map((p) => Ik(p))), l;
  }
  if (a.length > 2) {
    const i = n || 1, u = [];
    for (let c = a.length; c > 0; c -= i) {
      const l = Math.max(Math.round(c) - 1, 0);
      u.push(a[l]);
    }
    return u.reverse(), u;
  }
}, Vk = (e, t, n, r) => {
  let a = t.ticks;
  const i = Yy(t.scale, t.numTicks);
  if (i.length < n.length) {
    let u = 0;
    const c = n.indexOf(i[i.length - 1]);
    c < n.length - 1 && (u = e.xAxis.sortByRecentDate ? n.indexOf(i[0]) * -1 : n.length - 1 - c), a = i.map((l) => t.ticks[t.ticks.findIndex((p) => p.value === l) + u]);
  }
  return a.forEach((u, c) => {
    u.formattedValue = r(u.value, c, a);
  }), a;
}, Wk = ({ min: e, max: t, xMax: n, config: r }) => {
  const a = r.yAxis.type === "logarithmic";
  return e = a && e >= 0 && e < 1 ? e + 0.1 : e, (a ? pu : Mn)({
    domain: [e, t],
    range: [0, n],
    nice: a,
    zero: a
  });
}, jk = ({ min: e, max: t, yMax: n, config: r, leftMax: a }) => {
  const i = r.yAxis.type === "logarithmic";
  e = i && e >= 0 && e < 1 ? e + 0.1 : e;
  const u = i ? pu : Mn;
  r.visualizationType === "Combo" && (t = a);
  const c = r.visualizationType === "Bump Chart" ? [1, t] : [e, t], l = r.visualizationType === "Bump Chart" ? [30, n] : [n, 0];
  return u({
    domain: c,
    range: l,
    nice: i,
    zero: i
  });
}, Uk = (e, t) => e === "date" ? Mn({
  domain: [Math.min(...t), Math.max(...t)]
}) : nl({ domain: t, padding: 0.5 }), Kk = (e, t, n = 0) => nl({
  domain: e,
  range: t,
  padding: n
}), Qo = (e, t, n = 0) => fu({
  domain: e,
  range: t,
  padding: n
}), pm = (e, t) => !e || e.length === 0 ? [] : e.length === 1 ? e : t ? e.sort((n, r) => Number(r) - Number(n)) : e.sort((n, r) => Number(n) - Number(r));
function Yk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const _s = () => {
  const { config: e } = ue.useContext(mt), { visualizationType: t, series: n, orientation: r, visualizationSubType: a } = e, i = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Bump Chart",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], u = [
    "theme-blue",
    "theme-purple",
    "theme-brown",
    "theme-teal",
    "theme-pink",
    "theme-orange",
    "theme-slate",
    "theme-indigo",
    "theme-cyan",
    "theme-green",
    "theme-amber"
  ], c = () => !["Forest Plot", "Sankey"].includes(t), l = () => !!["Scatter Plot"].includes(t), p = () => !!["Scatter Plot"].includes(t), h = () => !["Spark Line"].includes(t), g = () => !["Spark Line"].includes(t), x = () => ![
    "Area Chart",
    "Box Plot",
    "Pie",
    "Scatter Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), w = () => ![
    "Area Chart",
    "Scatter Plot",
    "Box Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), y = () => {
    switch (t) {
      case "Box Plot":
        return !0;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, R = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), b = () => !!["Bar", "Combo", "Line"].includes(e.visualizationType), v = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, A = () => {
    if ((t === "Bar" || "Combo") && a === "regular")
      return !0;
  }, N = () => e.xAxis.type === "categorical" ? !1 : ["Line", "Bar", "Area Chart", "Combo"].includes(t) && r === "vertical", L = () => ["Box Plot", "Scatter Plot", "Pie", "Line"].includes(t) ? !1 : n == null ? void 0 : n.some(
    (_e) => _e.type === "Bar" || _e.type === "Paired Bar" || _e.type === "Deviation Bar"
  ), C = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, z = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: i,
    headerColors: u,
    visCanAnimate: w,
    visHasAnchors: v,
    visHasBarBorders: L,
    visHasDataCutoff: C,
    visHasLabelOnData: x,
    visHasDataSuppression: A,
    visHasLegend: y,
    visHasLegendAxisAlign: () => t === "Bar" && a === "stacked" && e.legend.behavior === "isolate",
    visHasLegendColorCategory: () => {
      var Te;
      return t === "Bar" && a === "regular" && ((Te = e.series) == null ? void 0 : Te.length) === 1;
    },
    visHasBrushChart: N,
    visHasNumbersOnBars: R,
    visHasaAdditionalLabelsOnBars: b,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : r === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsMobileChartHeight: () => !!["Bar", "Line", "Combo", "Area Chart"].includes(t),
    visSupportsDateCategoryAxis: c,
    visSupportsDateCategoryAxisMin: l,
    visSupportsDateCategoryAxisMax: p,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line", "Bump Chart"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !(["Spark Line", "Sankey", "Bump Chart"].includes(t) || e.orientation !== "horizontal"),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: g,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => !!["Line", "Bar", "Combo"].includes(t),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: h,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: z,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const Te = ["Forest Plot"];
      return !(r === "horizontal" || Te.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot", "Bump Chart"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (e.yAxis.type === "categorical" || ["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t) || t === "Bar" && e.tooltips.singleSeries)
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t),
    visSupportsDynamicSeries: () => t === "Line" || t === "Bar" || t === "Scatter Plot" || t === "Area Chart",
    visSupportsYPadding: () => {
      var Te;
      return !e.dataFormat.onlyShowTopPrefixSuffix || !((Te = e.dataFormat.suffix) != null && Te.includes(" "));
    },
    visHasSingleSeriesTooltip: () => t === "Bar" || t === "Line" || t === "Area Chart" && a === "stacked",
    visHasCategoricalAxis: () => {
      if ((t === "Line" || t === "Bar" || t === "Combo" || t === "Area Chart") && e.yAxis.type === "categorical" && r === "vertical")
        return !0;
    }
  };
}, Gk = ({ data: e, xScale: t, yScale: n, config: r, xMax: a, annotationSeriesKey: i }, u) => {
  const { xAxis: c, visualizationType: l, orientation: p } = r, h = (b, v, A, N, L) => {
    let C = [];
    r.xAxis.type === "date-time" && (v = new Date(v), A = new Date(A), N = N.map((q) => new Date(q)), C = L.ticks().map((q) => new Date(q)));
    const z = (b - v) / (A - v), W = Math.round(z * (N.length - 1));
    return r.xAxis.type === "date-time" ? C[W] : N[W];
  }, x = ((b, v = !1) => {
    if (l !== "Pie" && p !== "horizontal") {
      if (r.xAxis.type === "date-time") {
        const A = new Date(t.invert(b)), N = r.data.map((z) => new Date(z[r.xAxis.dataKey]).getTime());
        let L = 1 / 0, C = null;
        return N.forEach((z) => {
          const W = Math.abs(A.getTime() - z);
          W < L && (L = W, C = z);
        }), new Date(C).getTime();
      }
      if (r.xAxis.type === "categorical" || l === "Combo" && p !== "horizontal" && l !== "Forest Plot") {
        const N = (t.range()[1] - t.range()[0]) / (t.domain().length + 1), C = Math.floor((Number(b) - N / 2) / N);
        return t.domain()[C];
      }
      if (r.xAxis.type === "date") {
        const A = h(b, 0, a, t.domain(), t);
        let N = null, L = Number.MAX_VALUE;
        return t.domain().forEach((C) => {
          const z = Math.abs(A - C);
          z < L && (L = z, N = C);
        }), N;
      }
      return b;
    }
  })(u - Number(r.yAxis.size || 0));
  let w = [];
  if (!x)
    return { x: 0, y: 0 };
  c.type === "categorical" && (w = r.data.filter((b) => b[r.xAxis.dataKey] === x)), (c.type === "date" || c.type === "date-time") && (w = r.data.filter((b) => new Date(b[r.xAxis.dataKey]).getTime() === x));
  const y = w[0][i];
  return { x, y };
}, Xk = (e, t, n) => {
  const { connectionLocation: r } = e;
  return r === "right" ? "end" : r === "left" ? "start" : r === "bottom" || r === "top" || t(e.xKey) + e.dx < n.yAxis.size ? "middle" : null;
}, qk = (e, t, n) => {
  const { connectionLocation: r } = e;
  return r === "top" ? "start" : r === "bottom" ? "end" : r === "right" || r === "left" ? "middle" : t(e.xKey) + e.dx < n.yAxis.size ? "end" : null;
};
const Zk = ({ xScale: e, yScale: t, xScaleAnnotation: n, xMax: r, svgRef: a, onDragStateChange: i }) => {
  const { config: u, dimensions: c, isEditor: l, updateConfig: p, colorScale: h } = ue.useContext(mt), { annotations: g } = u, [x] = c, w = l ? _g : Og;
  return g && g.map((y, R) => {
    var N;
    const b = y.text || "", v = n(y.x), A = () => ({
      __html: Tm.sanitize(b)
    });
    return /* @__PURE__ */ React.createElement(
      w,
      {
        width: 200,
        height: x,
        dx: y.dx,
        dy: y.dy,
        x: v,
        y: y.y,
        canEditLabel: y.edit.label || !1,
        canEditSubject: y.edit.subject && y.connectionType !== "none" || !1,
        onDragStart: () => i(!0),
        onDragEnd: (L) => {
          i(!1);
          let C = [...g];
          if (y.x === n.invert(L.x) && y.y === L.y)
            C[R] = { ...C[R], dx: L.dx, dy: L.dy };
          else if (y.snapToNearestPoint) {
            let z = Gk(
              {
                data: u.data,
                xScale: e,
                yScale: t,
                config: u,
                xMax: r - u.yAxis.size / 2,
                annotationSeriesKey: y.seriesKey
              },
              L.x
            );
            C[R] = {
              ...C[R],
              x: n.invert(e(z.x)),
              y: t(z.y)
            };
          } else
            C[R] = {
              ...C[R],
              x: n.invert(L.x),
              y: L.y
            };
          p({
            ...u,
            annotations: C
          });
        }
      },
      /* @__PURE__ */ React.createElement(
        Pg,
        {
          className: "annotation__desktop-label",
          showAnchorLine: !1,
          horizontalAnchor: Xk(y, e, u),
          verticalAnchor: qk(y, e, u)
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            style: {
              borderRadius: 5,
              // Optional: set border radius
              backgroundColor: `rgba(255, 255, 255, ${y != null && y.opacity ? Number(y == null ? void 0 : y.opacity) / 100 : 1})`,
              padding: "10px",
              width: "auto",
              display: u.general.showAnnotationDropdown ? "inline-flex" : "flex",
              justifyContent: "start",
              flexDirection: "row"
            },
            tabIndex: 0,
            "aria-label": `Annotation text that reads: ${y.text}`
          },
          ((N = u == null ? void 0 : u.general) == null ? void 0 : N.showAnnotationDropdown) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", { className: "annotation__has-dropdown-number", style: { margin: "2px 6px" } }, R + 1)),
          /* @__PURE__ */ React.createElement("div", { dangerouslySetInnerHTML: A() })
        )
      ),
      y.connectionType === "line" && /* @__PURE__ */ React.createElement(Fp, { type: "line", pathProps: { markerStart: `url(#marker-start--${R})` } }),
      y.connectionType === "elbow" && /* @__PURE__ */ React.createElement(Fp, { type: "elbow", pathProps: { markerStart: `url(#marker-start--${R})` } }),
      y.connectionType === "curve" && /* @__PURE__ */ React.createElement(
        Hr,
        {
          d: `M ${v},${y.y}
                      Q ${v + y.dx / 2}, ${y.y + y.dy / 2 + Number(y == null ? void 0 : y.bezier) || 0} ${v + y.dx},${y.y + y.dy}`,
          stroke: "black",
          strokeWidth: "2",
          fill: "none",
          "marker-start": `url(#marker-start--${R})`
        }
      ),
      y.marker === "circle" && /* @__PURE__ */ React.createElement(
        Dg,
        {
          id: `marker-start--${R}`,
          className: "circle-subject",
          stroke: h(y.seriesKey),
          radius: 8
        }
      ),
      y.marker === "arrow" && /* @__PURE__ */ React.createElement(
        wm,
        {
          fill: "black",
          id: `marker-start--${R}`,
          x: v,
          y: y.y,
          stroke: "#333",
          markerWidth: 10,
          size: 10,
          strokeWidth: 1,
          orient: "auto-start-reverse",
          markerUnits: "userSpaceOnUse"
        }
      ),
      /* @__PURE__ */ React.createElement(
        "circle",
        {
          fill: "white",
          cx: v + y.dx,
          cy: y.y + y.dy,
          r: 16,
          className: "annotation__mobile-label annotation__mobile-label-circle",
          stroke: h(y.seriesKey)
        }
      ),
      /* @__PURE__ */ React.createElement(
        "text",
        {
          height: 16,
          x: v + y.dx,
          y: y.y + y.dy,
          className: "annotation__mobile-label",
          alignmentBaseline: "middle",
          textAnchor: "middle"
        },
        R + 1
      )
    );
  });
};
const Qk = ({ useBootstrapVisibilityClasses: e = !0 }) => {
  const { config: t } = ue.useContext(mt), n = t.annotations || [], r = () => {
    const i = ["annotation-list"];
    return e && i.push("d-block", "d-md-none"), i.join(" ");
  }, a = n.map((i, u) => {
    const c = i.text || "", l = () => ({
      __html: Tm.sanitize(c)
    });
    return /* @__PURE__ */ m.createElement("li", { key: "annotation-li-item__annotationIndex" }, /* @__PURE__ */ m.createElement("div", { className: "annotation__title-wrapper" }, /* @__PURE__ */ m.createElement("div", { className: "annotation__title-circle" }, u + 1), /* @__PURE__ */ m.createElement("p", { className: "annotation__subtext", dangerouslySetInnerHTML: l() })));
  });
  return /* @__PURE__ */ m.createElement("ul", { className: r() }, a);
};
const Jk = () => {
  var l;
  const { currentViewport: e, config: t } = ue.useContext(mt), [n, r] = ue.useState(!1), a = ["sm", "xs", "xxs"].includes(e) ? "13px" : `${Lu}px`;
  ue.useContext(mt);
  const i = {
    maxHeight: t.table.limitHeight && `${t.table.height}px`,
    OverflowY: "scroll"
  }, u = () => {
    const p = ["data-table-heading", "annotation__dropdown-list", "p-3"];
    return n || p.push("collapsed"), p.join(" ");
  }, c = () => {
    const p = ["data-table-container", e, "d-block", "d-lg-none", "w-100"];
    return t.general.showAnnotationDropdown && (p.push("d-lg-block"), p.splice(p.indexOf("d-lg-none"), 1)), p.join(" ");
  };
  return /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("section", { className: c() }, /* @__PURE__ */ m.createElement(
    "div",
    {
      style: { fontSize: a },
      role: "button",
      className: u(),
      onClick: () => {
        r(!n);
      },
      tabIndex: 0,
      onKeyDown: (p) => {
        p.keyCode === 13 && r(!n);
      }
    },
    /* @__PURE__ */ m.createElement(Ge, { display: n ? "minus" : "plus", base: !0 }),
    t.general.annotationDropdownText === "" ? "Annotations" : (l = t == null ? void 0 : t.general) == null ? void 0 : l.annotationDropdownText
  ), n && /* @__PURE__ */ m.createElement("div", { className: "table-container annotation-dropdown__panel", style: i }, /* @__PURE__ */ m.createElement(kp.List, { useBootstrapVisibilityClasses: !1 }))));
}, kp = {
  Draggable: Zk,
  // Mobile auto display
  List: Qk,
  // Desktop Accessible Option
  Dropdown: Jk
}, ew = ({ axis: e, max: t, runtime: n, currentViewport: r, isHorizontal: a, data: i, config: u, min: c }) => {
  let { numTicks: l } = n[e];
  n[e].viewportNumTicks && n[e].viewportNumTicks[r] && (l = n[e].viewportNumTicks[r]);
  let p;
  return e === "yAxis" && (p = a && !l ? i.length : a && l ? l : !a && !l ? void 0 : !a && l && l, p === void 0 && !u.dataFormat.roundTo && (Number(t) <= 3 ? p = 2 : p = 4), Number(p) > Number(t) && !a && (p = Number(c) < 0 ? Math.round(t) * 2 : Math.round(t))), e === "xAxis" && (p = a && !l ? void 0 : a && l ? l : !a && !l ? void 0 : !a && l && l, a && p === void 0 && !u.dataFormat.roundTo && (t <= 3 ? p = 2 : p = 4), u.visualizationType === "Forest Plot" && (p = u.yAxis.numTicks !== "" ? u.yAxis.numTicks : 4)), p;
}, cf = 9, uf = 4.5, df = 8, tw = 1e3 * 60 * 60 * 24 * 30, nw = 16, rw = 13, aw = 18, iw = 14, ow = 4.5, ff = ue.forwardRef(({ parentHeight: e, parentWidth: t }, n) => {
  var ar, Kn, Yn, E, _;
  const {
    brushConfig: r,
    colorScale: a,
    config: i,
    convertLineToBarGraph: u,
    currentViewport: c,
    dimensions: l,
    formatDate: p,
    formatNumber: h,
    handleChartAriaLabels: g,
    handleLineType: x,
    handleDragStateChange: w,
    isDraggingAnnotation: y,
    legendRef: R,
    parseDate: b,
    parentRef: v,
    tableData: A,
    transformedData: N,
    updateConfig: L,
    seriesHighlight: C
  } = ue.useContext(mt), {
    heights: z,
    visualizationType: W,
    visualizationSubType: q,
    orientation: ne,
    xAxis: G,
    yAxis: le,
    runtime: K,
    legend: re,
    forestPlot: B,
    brush: j,
    dataFormat: se,
    debugSvg: ee
  } = i, { suffix: Q, onlyShowTopPrefixSuffix: Z } = se, { labelsAboveGridlines: Y, hideAxis: te } = i.yAxis, { minValue: $, maxValue: ce, existPositiveValue: Se, isAllLine: be } = Vu(i, N), { visSupportsReactTooltip: ve } = _s(), { hasTopAxis: Pe } = Yk(i), [Ve, we] = ue.useState(!1), [me, Ce] = ue.useState({ x: 0, y: 0 }), [fe, ze] = ue.useState(0), [Ie, Qe] = ue.useState(0), He = ue.useRef(null), Fe = ue.useRef(null), qe = ue.useRef(null), We = ue.useRef(null), je = ue.useRef(), Ke = ue.useRef([]), Te = ue.useRef(null), _e = ue.useRef(ce), at = hp(je, {
    freezeOnceVisible: !1
  }), ge = !0, ft = ne === "horizontal" || i.visualizationType === "Forest Plot", ot = i.yAxis.type === "logarithmic", it = W === "Forest Plot", wt = i.xAxis.type === "date-time", Wt = !Q.includes(" "), Kt = Z && !Wt, Mt = Number(ne === "horizontal" ? i.xAxis.size : i.yAxis.size), rn = isNaN(parseInt(`${K.yAxis.labelOffset}`)) ? 0 : parseInt(`${K.yAxis.labelOffset}`), Et = mf(c) ? rw : nw, Pt = mf(c) ? iw : aw, Nt = `normal ${Et}px Nunito, sans-serif`, tn = it ? i.data.length * i.forestPlot.rowHeight : 0, sn = ue.useMemo(
    () => zk(i, c),
    [i, c, e, (ar = i.heights) == null ? void 0 : ar.vertical, (Kn = i.heights) == null ? void 0 : Kn.horizontal]
  ), Ot = ue.useMemo(() => sn + tn, [sn, tn]), Ft = ue.useMemo(() => {
    var J;
    const D = l[0], U = re == null ? void 0 : re.hide, pe = ["bottom", "top"].includes((J = i.legend) == null ? void 0 : J.position), O = Va(c);
    if (!(!it && !U && !pe && !O))
      return D;
    if (R.current) {
      const xe = getComputedStyle(R.current);
      return D - R.current.getBoundingClientRect().width - parseInt(xe.marginLeft) - parseInt(xe.marginRight);
    }
    return D * 0.73;
  }, [l[0], i.legend, c, R.current]), nn = ue.useMemo(() => {
    var U;
    return Ke.current = (U = Ke.current) == null ? void 0 : U.filter((pe) => pe), Ke.current.length ? Math.max(...Ke.current.map((pe) => pe.getBBox().height)) + uf + df : void 0;
  }, [l[0], i.xAxis, Ke.current, i.xAxis.tickRotation]), et = Ft - K.yAxis.size - (W === "Combo" ? i.yAxis.rightAxisSize : 0), ut = sn + tn, Ne = i.filters && i.filters.values.length === 0 && N.length === 0, De = (D) => En(i.runtime.xAxis) ? b(D[i.runtime.originalXAxis.dataKey]).getTime() : D[i.runtime.originalXAxis.dataKey], Ee = (D, U) => D[U], pt = i.brush.active && ((Yn = r.data) != null && Yn.length) ? r.data.map((D) => De(D)) : N.map((D) => De(D)), nt = i.orientation === "horizontal" || i.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", gt = {
    data: N,
    tableData: A,
    config: {
      ...i,
      yAxis: {
        ...i.yAxis,
        scalePadding: Kt ? Ie : i.yAxis.scalePadding,
        enablePadding: Kt || i.yAxis.enablePadding
      }
    },
    minValue: $,
    maxValue: ce,
    isAllLine: be,
    existPositiveValue: Se,
    xAxisDataMapped: pt,
    xMax: et,
    yMax: ut
  }, { min: xt, max: Yt, leftMax: lt, rightMax: st } = ug(gt), { yScaleRight: $t, hasRightAxis: jt } = Ep({ config: i, yMax: ut, data: N, updateConfig: L }), { xScale: Rt, yScale: St, seriesScale: yn, g1xScale: vn, g2xScale: wn, xScaleNoPadding: Pn, xScaleAnnotation: Tn } = Bk({
    ...gt,
    min: xt,
    max: Yt,
    leftMax: lt,
    rightMax: st,
    dimensions: l,
    xMax: t - Number(i.orientation === "horizontal" ? i.xAxis.size : i.yAxis.size)
  }), [er, Dn] = ["yAxis", "xAxis"].map(
    (D) => ew({ axis: D, max: Yt, runtime: K, currentViewport: c, isHorizontal: ft, data: N, config: i, min: xt })
  ), xn = it ? i.data.length : er, { tooltipData: At, showTooltip: Ht, hideTooltip: bn, tooltipOpen: Qt, tooltipLeft: cn, tooltipTop: kn } = My(), {
    handleTooltipMouseOver: Lt,
    handleTooltipClick: gn,
    handleTooltipMouseOff: an,
    TooltipListItem: un,
    getXValueFromCoordinate: tr
  } = Hy({
    xScale: Rt,
    yScale: St,
    showTooltip: Ht,
    hideTooltip: bn
  }), { dataKey: _n } = K.xAxis, Rn = N.length && wt ? [0, N.length - 1].map((D) => b(N[D][_n])).reduce((D, U) => Math.abs(D - U)) / tw : 0, pn = wt && Rn > Dn, zn = (D, U, pe) => {
    if (ot && D === 0.1 && (D = 0), !(i.data && !i.data[U] && W === "Forest Plot"))
      return i.visualizationType === "Forest Plot" ? i.data[U][i.xAxis.dataKey] : En(K.yAxis) ? p(b(D)) : ne === "vertical" && Yt - xt < 3 ? h(D, "left", ge, !1, !1, "1", { index: U, length: pe.length }) : ne === "vertical" ? h(D, "left", ge, !1, !1, void 0, { index: U, length: pe.length }) : D;
  }, Bn = (D, U, pe) => (ot && D === 0.1 && (D = 0), En(K.xAxis) && i.visualizationType !== "Forest Plot" ? p(D, U, pe) : ne === "horizontal" && i.visualizationType !== "Forest Plot" ? h(D, "left", ge) : i.xAxis.type === "continuous" && i.visualizationType !== "Forest Plot" ? h(D, "bottom", ge) : i.visualizationType === "Forest Plot" ? h(
    D,
    "left",
    i.dataFormat.abbreviated,
    i.runtime.xAxis.prefix,
    i.runtime.xAxis.suffix,
    Number(i.dataFormat.roundTo)
  ) : D), nr = () => {
    const { visualizationType: D } = i;
    return D === "Combo" && K.forecastingSeriesKeys > 0 || D === "Area Chart" || D === "Line" || D === "Bar";
  }, hr = () => {
    let D = i.xAxis.manualStep;
    return i.xAxis.viewportStepCount && i.xAxis.viewportStepCount[c] && (D = i.xAxis.viewportStepCount[c]), D;
  }, rr = (D) => {
    const U = D.currentTarget.getBoundingClientRect(), pe = D.clientX - U.left, O = D.clientY - U.top;
    Ce({
      x: pe,
      y: O
    });
  };
  ue.useEffect(() => {
    document.querySelector(".isEditor") && we((U) => !0);
  }), ue.useEffect(() => {
    (at == null ? void 0 : at.isIntersecting) === !0 && i.animate && setTimeout(() => {
      we((D) => !0);
    }, 500);
  }, [at == null ? void 0 : at.isIntersecting, i.animate]), ue.useEffect(() => {
    const D = qe.current;
    if (!D && !fe)
      return;
    if (!D)
      return ze(0);
    const U = D.getBBox().width;
    ze(U);
  }, [i.dataFormat.suffix, i.dataFormat.onlyShowTopPrefixSuffix]), ue.useEffect(() => {
    if (!it || G.hideLabel)
      return;
    const D = Fe.current;
    if (!D)
      return;
    const U = ut + Number(i.xAxis.axisPadding), O = D.getBBox().y - U + D.getBBox().height + cf;
    Te.current && Te.current.setAttribute("y", O);
  }, [(E = i == null ? void 0 : i.data) == null ? void 0 : E.length, tn]), ue.useEffect(() => {
    if (!He.current)
      return;
    const D = He.current.getBBox().height, U = W === "Forest Plot", pe = We.current && le.labelsAboveGridlines, O = j != null && j.active ? (j == null ? void 0 : j.height) + (j == null ? void 0 : j.height) : 0, I = U ? i.data.length * B.rowHeight : 0, J = pe ? We.current.getBBox().height : 0, xe = D + O + I + J, Be = sn + xe;
    if (!v.current || (v.current.style.height = `${Be}px`, !J))
      return;
    const Xe = n.current;
    if (!Xe)
      return;
    const dt = v.current.getBoundingClientRect().width;
    if (Xe.setAttribute("viewBox", `0 ${-J} ${dt} ${Be}`), !R.current)
      return;
    const Vt = (re == null ? void 0 : re.position) !== "top" && (re == null ? void 0 : re.position) !== "bottom" && !Va(c);
    R.current.style.transform = Vt ? `translateY(${J}px)` : "none";
  }, [He.current, i, nn, j, c, We.current, sn]), ue.useEffect(() => {
    _e.current !== ce && (_e.current = ce, Ie && Qe(0));
  }, [ce]), ue.useEffect(() => {
    if (ne === "horizontal" || !Kt)
      return;
    const D = 0.025, pe = Math.max(...St.ticks(xn)) - ce * D;
    if (!(ce > pe))
      return;
    const I = St.ticks(xn), J = I.length === 1 ? I[0] : I[1] - I[0], xe = Math.max(...St.ticks(xn)) + J, Be = $ < 0 ? ce / 2 : ce, Xe = (xe - ce) / Be, dt = Xe > D ? Xe : Xe + J / Be;
    Qe(dt * 100 + 0.1);
  }, [ce, Kt, St, xn]);
  const Hn = () => {
    const D = nn + cf, U = (pe, O) => {
      if (!pe.length)
        return !1;
      const I = pe.filter((qt) => qt.index !== 0), J = I == null ? void 0 : I.length, xe = O.range()[0] || et / 2, Be = I.map(
        (qt) => pr(h(qt.value, "left"), Nt)
      ), Xe = 100, dt = Be.reduce((qt, Zt) => qt + Zt, Xe), Vt = (xe - dt) / J;
      let zt = [0];
      for (let qt = 1; qt < Be.length; qt++)
        zt[qt] = zt[qt - 1] + Be[qt - 1] + Vt;
      let Xt = !1;
      return Be.forEach((qt, Zt) => {
        if (zt[Zt] + Be[Zt] > zt[Zt + 1]) {
          Xt = !0;
          return;
        }
      }), Xt;
    };
    return /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
      jc,
      {
        top: ut,
        left: Number(K.yAxis.size),
        label: K.xAxis.label,
        tickFormat: En(K.xAxis) ? p : h,
        scale: vn,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: K.xAxis.numTicks || void 0
      },
      (pe) => /* @__PURE__ */ m.createElement(tt, { className: "bottom-axis" }, pe.ticks.map((O, I) => {
        const J = U(pe.ticks, vn), xe = Number(i.xAxis.maxTickRotation) || 90, Be = i.isResponsiveTicks && J, Xe = O.index !== 0 && (Be ? xe : Number(i.yAxis.tickRotation)), dt = Xe && O.index !== 0 ? "end" : "middle";
        return /* @__PURE__ */ m.createElement(tt, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !K.yAxis.hideTicks && /* @__PURE__ */ m.createElement(en, { from: O.from, to: O.to, stroke: "#333" }), !K.yAxis.hideLabel && /* @__PURE__ */ m.createElement(
          ht,
          {
            innerRef: (Vt) => Ke.current[I] = Vt,
            x: O.to.x,
            y: O.to.y,
            angle: -Xe,
            verticalAnchor: Xe ? "middle" : "start",
            textAnchor: dt,
            fontSize: Et
          },
          h(O.value, "left")
        ));
      }), !K.yAxis.hideAxis && /* @__PURE__ */ m.createElement(en, { from: pe.axisFromPoint, to: pe.axisToPoint, stroke: "#333" }))
    ), /* @__PURE__ */ m.createElement(
      jc,
      {
        innerRef: He,
        top: ut,
        left: Number(K.yAxis.size),
        label: K.xAxis.label,
        tickFormat: En(K.xAxis) ? p : K.xAxis.dataKey !== "Year" ? h : (pe) => pe,
        scale: wn,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: K.xAxis.numTicks || void 0
      },
      (pe) => /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(tt, { className: "bottom-axis" }, pe.ticks.map((O, I) => {
        const J = U(pe.ticks, wn), xe = Number(i.xAxis.maxTickRotation) || 90, Be = i.isResponsiveTicks && J, Xe = O.index !== 0 && (Be ? xe : Number(i.yAxis.tickRotation)), dt = Xe && O.index !== 0 ? "end" : "middle";
        return I ? /* @__PURE__ */ m.createElement(tt, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !K.yAxis.hideTicks && /* @__PURE__ */ m.createElement(en, { from: O.from, to: O.to, stroke: "#333" }), !K.yAxis.hideLabel && /* @__PURE__ */ m.createElement(
          ht,
          {
            x: O.to.x,
            y: O.to.y + uf,
            angle: -Xe,
            verticalAnchor: Xe ? "middle" : "start",
            textAnchor: dt,
            fontSize: Et
          },
          h(O.value, "left")
        )) : /* @__PURE__ */ m.createElement(m.Fragment, null);
      }), !K.yAxis.hideAxis && /* @__PURE__ */ m.createElement(en, { from: pe.axisFromPoint, to: pe.axisToPoint, stroke: "#333" })), /* @__PURE__ */ m.createElement(tt, null, /* @__PURE__ */ m.createElement(
        ht,
        {
          className: "x-axis-title-label",
          x: et / 2,
          y: D,
          stroke: "#333",
          textAnchor: "middle",
          verticalAnchor: "start",
          fontSize: Pt
        },
        K.xAxis.label
      )))
    ));
  };
  return isNaN(Ft) ? /* @__PURE__ */ m.createElement(m.Fragment, null) : /* @__PURE__ */ m.createElement(Vr, { component: "LinearChart" }, /* @__PURE__ */ m.createElement(
    "div",
    {
      style: { width: `${t}px`, overflow: "visible", position: "relative" },
      className: "tooltip-boundary"
    },
    /* @__PURE__ */ m.createElement(
      "svg",
      {
        ref: n,
        onMouseMove: rr,
        width: t,
        height: Ne ? 1 : e,
        className: `linear ${i.animate ? "animated" : ""} ${Ve && i.animate ? "animate" : ""} ${ee && "debug"} ${y && "dragging-annotation"}`,
        role: "img",
        "aria-label": g(i),
        style: { overflow: "visible" }
      },
      !y && /* @__PURE__ */ m.createElement(Nr, { width: t, height: sn, fill: "transparent" }),
      " ",
      !["Spark Line", "Forest Plot"].includes(W) && i.yAxis.type !== "categorical" && /* @__PURE__ */ m.createElement(
        im,
        {
          scale: St,
          left: Number(K.yAxis.size) - i.yAxis.axisPadding,
          numTicks: xn
        },
        (D) => {
          const U = i.orientation === "horizontal" ? (D.axisToPoint.y - D.axisFromPoint.y) / 2 : (D.axisFromPoint.y - D.axisToPoint.y) / 2;
          return /* @__PURE__ */ m.createElement(tt, { className: "left-axis" }, D.ticks.map((pe, O) => {
            const I = String(pe.value).startsWith("1") || pe.value === 0.1 ? "block" : "none", J = pe.index === 0 && pe.value === 0 && i.xAxis.hideAxis;
            return /* @__PURE__ */ m.createElement(tt, { key: `vx-tick-${pe.value}-${O}`, className: "vx-axis-tick" }, K.yAxis.gridLines && !J ? /* @__PURE__ */ m.createElement(
              en,
              {
                key: `${pe.value}--hide-hideGridLines`,
                display: (ot && I).toString(),
                from: { x: pe.from.x + et, y: pe.from.y },
                to: pe.from,
                stroke: "#d6d6d6"
              }
            ) : "");
          }), /* @__PURE__ */ m.createElement(
            ht,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${-1 * K.yAxis.size + rn}, ${U}) rotate(-90)`,
              fontWeight: "bold",
              fill: i.yAxis.labelColor,
              fontSize: Pt
            },
            D.label
          ));
        }
      ),
      W === "Paired Bar" && Hn(),
      W === "Deviation Bar" && ((_ = i.runtime.series) == null ? void 0 : _.length) === 1 && /* @__PURE__ */ m.createElement(bk, { animatedChart: Ve, xScale: Rt, yScale: St, width: et, height: ut }),
      W === "Paired Bar" && /* @__PURE__ */ m.createElement(Ok, { originalWidth: Ft, width: et, height: ut }),
      W === "Scatter Plot" && /* @__PURE__ */ m.createElement(
        xk,
        {
          xScale: Rt,
          yScale: St,
          getXAxisData: De,
          getYAxisData: Ee,
          xMax: et,
          yMax: ut,
          handleTooltipMouseOver: Lt,
          handleTooltipMouseOff: an,
          handleTooltipClick: gn,
          tooltipData: At,
          showTooltip: Ht
        }
      ),
      W === "Box Plot" && /* @__PURE__ */ m.createElement(
        vk,
        {
          seriesScale: yn,
          xMax: et,
          yMax: ut,
          min: xt,
          max: Yt,
          xScale: Rt,
          yScale: St
        }
      ),
      (W === "Area Chart" && i.visualizationSubType === "regular" || W === "Combo") && /* @__PURE__ */ m.createElement(
        ak,
        {
          xScale: Rt,
          yScale: St,
          yMax: ut,
          xMax: et,
          chartRef: n,
          width: et,
          height: ut,
          handleTooltipMouseOver: Lt,
          handleTooltipMouseOff: an,
          tooltipData: At,
          showTooltip: Ht
        }
      ),
      (W === "Area Chart" && i.visualizationSubType === "stacked" || W === "Combo") && /* @__PURE__ */ m.createElement(
        ok,
        {
          xScale: Rt,
          yScale: St,
          yMax: ut,
          xMax: et,
          chartRef: n,
          width: et,
          height: ut,
          handleTooltipMouseOver: Lt,
          handleTooltipMouseOff: an,
          tooltipData: At,
          showTooltip: Ht
        }
      ),
      (W === "Bar" || W === "Combo" || u) && /* @__PURE__ */ m.createElement(
        dk,
        {
          xScale: Rt,
          yScale: St,
          seriesScale: yn,
          xMax: et,
          yMax: ut,
          getXAxisData: De,
          getYAxisData: Ee,
          animatedChart: Ve,
          visible: Ve,
          handleTooltipMouseOver: Lt,
          handleTooltipMouseOff: an,
          handleTooltipClick: gn,
          tooltipData: At,
          showTooltip: Ht,
          chartRef: n
        }
      ),
      (W === "Line" && !u || W === "Combo" || W === "Bump Chart") && /* @__PURE__ */ m.createElement(
        fm,
        {
          xScale: Rt,
          yScale: St,
          getXAxisData: De,
          getYAxisData: Ee,
          xMax: et,
          yMax: ut,
          seriesStyle: i.runtime.series,
          handleTooltipMouseOver: Lt,
          handleTooltipMouseOff: an,
          handleTooltipClick: gn,
          tooltipData: At,
          showTooltip: Ht,
          chartRef: n
        }
      ),
      (W === "Forecasting" || W === "Combo") && /* @__PURE__ */ m.createElement(
        Sk,
        {
          showTooltip: Ht,
          tooltipData: At,
          xScale: Rt,
          yScale: St,
          width: et,
          le: !0,
          height: ut,
          xScaleNoPadding: Pn,
          chartRef: n,
          getXValueFromCoordinate: tr,
          handleTooltipMouseOver: Lt,
          handleTooltipMouseOff: an,
          isBrush: !1
        }
      ),
      W === "Forest Plot" && /* @__PURE__ */ m.createElement(
        _k,
        {
          xScale: Rt,
          yScale: St,
          seriesScale: yn,
          width: Ft,
          height: Ot,
          getXAxisData: De,
          getYAxisData: Ee,
          animatedChart: Ve,
          visible: Ve,
          handleTooltipMouseOver: Lt,
          handleTooltipMouseOff: an,
          handleTooltipClick: gn,
          tooltipData: At,
          showTooltip: Ht,
          chartRef: n,
          config: i,
          forestPlotRightLabelRef: Fe
        }
      ),
      i.brush.active && i.xAxis.type !== "categorical" && /* @__PURE__ */ m.createElement(nk, { xMax: et, yMax: ut }),
      !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(
        W
      ) && !u && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
        fm,
        {
          xScale: Rt,
          yScale: St,
          getXAxisData: De,
          getYAxisData: Ee,
          xMax: et,
          yMax: ut,
          seriesStyle: i.runtime.series
        }
      )),
      i.yAxis.anchors && i.yAxis.anchors.map((D, U) => {
        let pe = St(D.value), O = 0;
        if (D.value && (i.yAxis.labelPlacement === "Below Bar" ? O = -6.5 + Number(i.series.length * i.barHeight) / i.series.length : O = 8, !!pe))
          return (
            // prettier-ignore
            /* @__PURE__ */ m.createElement(
              en,
              {
                key: `yAxis-${D.value}--${U}`,
                strokeDasharray: x(D.lineStyle),
                stroke: D.color ? D.color : "rgba(0,0,0,1)",
                className: "anchor-y",
                from: { x: 0 + Mt, y: pe - O },
                to: { x: Ft - i.yAxis.rightAxisSize, y: pe - O }
              }
            )
          );
      }),
      i.xAxis.anchors && i.xAxis.anchors.map((D, U) => {
        let pe = G;
        ne === "horizontal" && (pe = le);
        let I = (() => {
          let J;
          return J = En(pe) ? Rt(b(D.value, !1)) : Rt(D.value), (i.xAxis.type === "categorical" || i.xAxis.type === "date") && (J = J ? J + (pe.type === "categorical" || pe.type === "date" ? Rt.bandwidth() : 0) / 2 : 0), J;
        })();
        if (I)
          return (
            // prettier-ignore
            /* @__PURE__ */ m.createElement(
              en,
              {
                key: `xAxis-${D.value}--${U}`,
                strokeDasharray: x(D.lineStyle),
                stroke: D.color ? D.color : "rgba(0,0,0,1)",
                fill: D.color ? D.color : "rgba(0,0,0,1)",
                className: "anchor-x",
                from: { x: Number(I) + Number(Mt), y: 0 },
                to: { x: Number(I) + Number(Mt), y: ut }
              }
            )
          );
      }),
      i.visualizationType !== "Bar" && i.visualizationType !== "Combo" && /* @__PURE__ */ m.createElement(
        bp,
        {
          xScale: Rt,
          handleTooltipClick: gn,
          handleTooltipMouseOff: an,
          handleTooltipMouseOver: Lt,
          showTooltip: Ht,
          hideTooltip: bn,
          tooltipData: At,
          yMax: ut,
          width: Ft
        }
      ),
      nr && Ht && At && i.visual.verticalHoverLine && /* @__PURE__ */ m.createElement(tt, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ m.createElement(
        en,
        {
          from: { x: At.dataXPosition - 10, y: 0 },
          to: { x: At.dataXPosition - 10, y: ut },
          stroke: "black",
          strokeWidth: 1,
          pointerEvents: "none",
          strokeDasharray: "5,5",
          className: "vertical-tooltip-line"
        }
      )),
      nr && Ht && At && i.visual.horizontalHoverLine && /* @__PURE__ */ m.createElement(
        tt,
        {
          key: "tooltipLine-horizontal",
          className: "horizontal-tooltip-line",
          left: i.yAxis.size ? i.yAxis.size : 0
        },
        /* @__PURE__ */ m.createElement(
          en,
          {
            from: { x: 0, y: At.dataYPosition },
            to: { x: et, y: At.dataYPosition },
            stroke: "black",
            strokeWidth: 1,
            pointerEvents: "none",
            strokeDasharray: "5,5",
            className: "horizontal-tooltip-line"
          }
        )
      ),
      Ne && /* @__PURE__ */ m.createElement(
        ht,
        {
          x: Number(i.yAxis.size) + Number(et / 2),
          y: sn / 2 - (i.xAxis.padding || 0) / 2,
          textAnchor: "middle"
        },
        i.chartMessage.noData
      ),
      (i.visualizationType === "Bar" || u) && i.tooltips.singleSeries && i.visual.horizontalHoverLine && /* @__PURE__ */ m.createElement(
        tt,
        {
          key: "tooltipLine-horizontal",
          className: "horizontal-tooltip-line",
          left: i.yAxis.size ? i.yAxis.size : 0
        },
        /* @__PURE__ */ m.createElement(
          en,
          {
            from: { x: 0, y: me.y },
            to: { x: et, y: me.y },
            stroke: "black",
            strokeWidth: 1,
            pointerEvents: "none",
            strokeDasharray: "5,5",
            className: "horizontal-tooltip-line"
          }
        )
      ),
      (i.visualizationType === "Bar" || u) && i.tooltips.singleSeries && i.visual.verticalHoverLine && /* @__PURE__ */ m.createElement(tt, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ m.createElement(
        en,
        {
          from: { x: me.x, y: 0 },
          to: { x: me.x, y: ut },
          stroke: "black",
          strokeWidth: 1,
          pointerEvents: "none",
          strokeDasharray: "5,5",
          className: "vertical-tooltip-line"
        }
      )),
      /* @__PURE__ */ m.createElement(tt, { left: Number(i.runtime.yAxis.size) }, /* @__PURE__ */ m.createElement(
        kp.Draggable,
        {
          xScale: Rt,
          yScale: St,
          xScaleAnnotation: Tn,
          xMax: et,
          svgRef: n,
          onDragStateChange: w
        }
      )),
      !["Spark Line", "Forest Plot"].includes(W) && i.yAxis.type !== "categorical" && /* @__PURE__ */ m.createElement(
        im,
        {
          scale: St,
          tickLength: ot ? 6 : 8,
          left: Number(K.yAxis.size) - i.yAxis.axisPadding,
          label: K.yAxis.label || K.yAxis.label,
          stroke: "#333",
          tickFormat: zn,
          numTicks: xn
        },
        (D) => {
          const U = i.orientation === "horizontal" ? (D.axisToPoint.y - D.axisFromPoint.y) / 2 : (D.axisFromPoint.y - D.axisToPoint.y) / 2, pe = ut / D.ticks.length / 2 - ut / D.ticks.length * (1 - i.barThickness) + 5;
          return /* @__PURE__ */ m.createElement(tt, { className: "left-axis" }, !i.yAxis.hideAxis && /* @__PURE__ */ m.createElement(
            en,
            {
              from: D.axisFromPoint,
              to: K.horizontal ? {
                x: 0,
                y: i.visualizationType === "Forest Plot" ? e : Number(z.horizontal)
              } : D.axisToPoint,
              stroke: "#000"
            }
          ), St.domain()[0] < 0 && /* @__PURE__ */ m.createElement(
            en,
            {
              from: { x: D.axisFromPoint.x, y: St(0) },
              to: { x: et, y: St(0) },
              stroke: "#333"
            }
          ), W === "Bar" && ne === "horizontal" && Rt.domain()[0] < 0 && /* @__PURE__ */ m.createElement(
            en,
            {
              from: { x: Rt(0), y: 0 },
              to: { x: Rt(0), y: ut },
              stroke: "#333",
              strokeWidth: 2
            }
          ), D.ticks.map((O, I) => {
            const J = D.ticks[0].to.y, xe = 15, Be = String(O.value).startsWith("1") || O.value === 0.1 ? "block" : "none", Xe = Be === "block" ? 7 : 0, dt = { x: O.to.x - Xe, y: O.to.y }, Vt = D.ticks.length - 1 === I, zt = Vt && Z && Q && !Wt, qt = Y ? te ? -8 : -12 : ow, Zt = Y ? 4 : 0, In = O.to.x - qt, Gn = O.to.y - Zt, Xn = Y ? "end" : "middle", Vn = Z && Y && Q && Vt;
            return /* @__PURE__ */ m.createElement(tt, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !K.yAxis.hideTicks && !Y && !zt && /* @__PURE__ */ m.createElement(
              en,
              {
                key: `${O.value}--hide-hideTicks`,
                from: O.from,
                to: ot ? dt : O.to,
                stroke: i.yAxis.tickColor,
                display: ne === "horizontal" ? "none" : "block",
                fontSize: Et
              }
            ), ne === "horizontal" && q !== "stacked" && i.yAxis.labelPlacement === "On Date/Category Axis" && !i.yAxis.hideLabel && /* @__PURE__ */ m.createElement(
              ht,
              {
                transform: `translate(${O.to.x - 5}, ${i.isLollipopChart ? O.to.y - J : O.to.y - J + (Number(i.barHeight * i.runtime.series.length) - xe) / 2}) rotate(-${i.runtime.horizontal && i.runtime.yAxis.tickRotation || 0})`,
                verticalAnchor: "start",
                textAnchor: "end",
                fontSize: Et
              },
              O.formattedValue
            ), ne === "horizontal" && q === "stacked" && i.yAxis.labelPlacement === "On Date/Category Axis" && !i.yAxis.hideLabel && /* @__PURE__ */ m.createElement(
              ht,
              {
                transform: `translate(${O.to.x - 5}, ${O.to.y - J + (Number(i.barHeight) - xe) / 2}) rotate(-${K.horizontal ? K.yAxis.tickRotation : 0})`,
                verticalAnchor: "start",
                textAnchor: "end",
                fontSize: Et
              },
              O.formattedValue
            ), ne === "horizontal" && W === "Paired Bar" && !i.yAxis.hideLabel && /* @__PURE__ */ m.createElement(
              ht,
              {
                transform: `translate(${O.to.x - 5}, ${O.to.y - J + Number(i.barHeight) / 2}) rotate(-${K.horizontal ? K.yAxis.tickRotation : 0})`,
                textAnchor: "end",
                verticalAnchor: "middle",
                fontSize: Et
              },
              O.formattedValue
            ), ne === "horizontal" && W === "Deviation Bar" && !i.yAxis.hideLabel && /* @__PURE__ */ m.createElement(
              ht,
              {
                transform: `translate(${O.to.x - 5}, ${i.isLollipopChart ? O.to.y - J + 2 : O.to.y - J + Number(i.barHeight) / 2}) rotate(-${K.horizontal ? K.yAxis.tickRotation : 0})`,
                textAnchor: "end",
                verticalAnchor: "middle",
                fontSize: Et
              },
              O.formattedValue
            ), ne === "vertical" && W === "Bump Chart" && !i.yAxis.hideLabel && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
              ht,
              {
                display: i.useLogScale ? Be : "block",
                dx: i.useLogScale ? -6 : 0,
                x: i.runtime.horizontal ? O.from.x + 2 : O.to.x - 8.5,
                y: O.to.y - 13 + (i.runtime.horizontal ? pe : 0),
                angle: -Number(i.yAxis.tickRotation) || 0,
                verticalAnchor: i.runtime.horizontal ? "start" : "middle",
                textAnchor: i.runtime.horizontal ? "start" : "end",
                fill: i.yAxis.tickLabelColor,
                fontSize: Et
              },
              i.runtime.seriesLabelsAll[O.formattedValue - 1]
            ), (C.length === 0 || C.includes(
              i.runtime.seriesLabelsAll[O.formattedValue - 1]
            )) && /* @__PURE__ */ m.createElement(
              "rect",
              {
                x: 0 - Number(i.yAxis.size),
                y: O.to.y - 8 + (i.runtime.horizontal ? pe : 7),
                width: Number(i.yAxis.size) + Rt(Rt.domain()[0]),
                height: "2",
                fill: a(i.runtime.seriesLabelsAll[O.formattedValue - 1])
              }
            )), ne === "vertical" && W !== "Paired Bar" && W !== "Bump Chart" && !i.yAxis.hideLabel && /* @__PURE__ */ m.createElement(m.Fragment, null, Z && Vt && !Y && /* @__PURE__ */ m.createElement(
              jp,
              {
                innerRef: qe,
                display: ot ? Be : "block",
                dx: ot ? -6 : 0,
                x: In,
                y: Gn,
                angle: -Number(i.yAxis.tickRotation) || 0,
                verticalAnchor: Xn,
                textAnchor: Wt ? "end" : "start",
                fill: i.yAxis.tickLabelColor,
                stroke: "#fff",
                paintOrder: "stroke",
                strokeLinejoin: "round",
                style: { whiteSpace: "pre-wrap" },
                fontSize: Et
              },
              Q
            ), /* @__PURE__ */ m.createElement(
              jp,
              {
                innerRef: (Er) => Vt && (We.current = Er),
                display: ot ? Be : "block",
                dx: ot ? -6 : 0,
                x: Wt ? In - fe : In,
                y: Gn + (i.runtime.horizontal ? pe : 0),
                angle: -Number(i.yAxis.tickRotation) || 0,
                verticalAnchor: i.runtime.horizontal ? "start" : Xn,
                textAnchor: i.runtime.horizontal || Y ? "start" : "end",
                fill: i.yAxis.tickLabelColor,
                stroke: "#fff",
                disableStroke: !Y,
                strokeLinejoin: "round",
                paintOrder: "stroke",
                style: { whiteSpace: "pre-wrap" },
                fontSize: Et
              },
              `${O.formattedValue}${Vn ? Q : ""}`
            )));
          }), /* @__PURE__ */ m.createElement(
            ht,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${-1 * K.yAxis.size + rn}, ${U}) rotate(-90)`,
              fontWeight: "bold",
              fill: i.yAxis.labelColor,
              fontSize: Pt
            },
            D.label
          ));
        }
      ),
      i.yAxis.type === "categorical" && i.orientation === "vertical" && /* @__PURE__ */ m.createElement(
        Fk,
        {
          max: Yt,
          maxValue: ce,
          height: sn,
          xMax: et,
          yMax: ut,
          leftSize: Number(K.yAxis.size) - i.yAxis.axisPadding
        }
      ),
      jt && /* @__PURE__ */ m.createElement(
        BS,
        {
          scale: $t,
          left: Number(Ft - i.yAxis.rightAxisSize),
          label: i.yAxis.rightLabel,
          tickFormat: (D) => h(D, "right"),
          numTicks: K.yAxis.rightNumTicks || void 0,
          labelOffset: 45
        },
        (D) => {
          const U = i.orientation === "horizontal" ? (D.axisToPoint.y - D.axisFromPoint.y) / 2 : (D.axisFromPoint.y - D.axisToPoint.y) / 2, pe = ut / D.ticks.length / 2 - ut / D.ticks.length * (1 - i.barThickness) + 5;
          return /* @__PURE__ */ m.createElement(tt, { className: "right-axis" }, D.ticks.map((O, I) => /* @__PURE__ */ m.createElement(tt, { key: `vx-tick-${O.value}-${I}`, className: "vx-axis-tick" }, !K.yAxis.rightHideTicks && /* @__PURE__ */ m.createElement(
            en,
            {
              from: O.from,
              to: O.to,
              display: K.horizontal ? "none" : "block",
              stroke: i.yAxis.rightAxisTickColor
            }
          ), K.yAxis.rightGridLines ? /* @__PURE__ */ m.createElement(en, { from: { x: O.from.x + et, y: O.from.y }, to: O.from, stroke: "#d6d6d6" }) : "", !i.yAxis.rightHideLabel && /* @__PURE__ */ m.createElement(
            ht,
            {
              x: O.to.x,
              y: O.to.y + (K.horizontal ? pe : 0),
              verticalAnchor: K.horizontal ? "start" : "middle",
              textAnchor: "start",
              fill: i.yAxis.rightAxisTickLabelColor,
              fontSize: Et
            },
            O.formattedValue
          ))), !i.yAxis.rightHideAxis && /* @__PURE__ */ m.createElement(en, { from: D.axisFromPoint, to: D.axisToPoint, stroke: "#333" }), /* @__PURE__ */ m.createElement(
            ht,
            {
              className: "y-label",
              textAnchor: "middle",
              verticalAnchor: "start",
              transform: `translate(${i.yAxis.rightLabelOffsetSize ? i.yAxis.rightLabelOffsetSize : 0}, ${U}) rotate(-90)`,
              fontWeight: "bold",
              fill: i.yAxis.rightAxisLabelColor,
              fontSize: Pt
            },
            D.label
          ));
        }
      ),
      Pe && i.topAxis.hasLine && /* @__PURE__ */ m.createElement(
        VS,
        {
          stroke: "#333",
          left: Number(K.yAxis.size),
          scale: Rt,
          hideTicks: !0,
          hideZero: !0,
          tickLabelProps: () => ({
            fill: "transparent"
          })
        }
      ),
      W !== "Paired Bar" && W !== "Spark Line" && /* @__PURE__ */ m.createElement(
        jc,
        {
          innerRef: He,
          top: K.horizontal && i.visualizationType !== "Forest Plot" ? Number(z.horizontal) + Number(i.xAxis.axisPadding) : i.visualizationType === "Forest Plot" ? ut + Number(i.xAxis.axisPadding) : ut,
          left: i.visualizationType !== "Forest Plot" ? Number(K.yAxis.size) : 0,
          label: i[nt].label,
          tickFormat: Bn,
          scale: Rt,
          stroke: "#333",
          numTicks: pn ? Rn : Dn,
          tickStroke: "#333",
          tickValues: i.runtime.xAxis.manual ? Hk(pt, Rt, wt ? Dn : hr(), i) : i.runtime.xAxis.type === "date" ? pt : void 0
        },
        (D) => {
          var xa;
          const U = i.series.some((Ct) => Ct.dynamicCategory);
          i.runtime.xAxis.type === "date" && !i.runtime.xAxis.manual && !U && (D.ticks = Vk(i, D, pt, p));
          const pe = pn && Rt.ticks(Dn).map(
            (Ct) => D.ticks.findIndex(
              (dn) => (typeof dn.value == "number" ? dn.value : dn.value.getTime()) === Ct.getTime()
            )
          ).slice(0, 2).reduce((Ct, dn) => dn - Ct), O = pn ? [...D.ticks].reverse().filter((Ct, dn) => dn % pe === 0).reverse().map((Ct, dn, ra) => ({
            ...Ct,
            // reformat in case showYearsOnce, since first month of year may have changed
            formattedValue: Bn(Ct.value, dn, ra)
          })) : D.ticks, I = nn + cf, J = (Ct) => /\s/.test(Ct), xe = O.some((Ct) => J(Ct.value)), Be = Math.max(
            ...O.map((Ct) => pr(Ct.formattedValue, Nt))
          ), Xe = xe ? 180 : 100, dt = O.map((Ct) => pr(Ct.formattedValue, Nt)), Vt = dt.reduce((Ct, dn) => Ct + dn, Xe), zt = (et - Vt) / (O.length - 1);
          let Xt = [0];
          for (let Ct = 1; Ct < dt.length; Ct++)
            Xt[Ct] = Xt[Ct - 1] + dt[Ct - 1] + zt;
          const qt = (xa = He == null ? void 0 : He.current) == null ? void 0 : xa.getBBox().height;
          i.xAxis.axisBBox = qt;
          let Zt = !1;
          dt.forEach((Ct, dn) => {
            if (Xt[dn] + dt[dn] > Xt[dn + 1]) {
              Zt = !0;
              return;
            }
          }), i.xAxis.showYearsOnce && (Zt = !0);
          const In = dt[dt.length - 1], Xn = Xt[Xt.length - 1] + In + In / 2, Vn = et - In;
          Xn > Vn && (Zt = !0);
          const Er = Zt && i.isResponsiveTicks ? Be + df + 20 : 0;
          return i.dynamicMarginTop = Er, i.xAxis.tickWidthMax = Be, /* @__PURE__ */ m.createElement(tt, { className: "bottom-axis", width: l[0] }, O.map((Ct, dn, ra) => {
            const Pr = String(Ct.value).startsWith("1") || Ct.value === 0.1 ? "block" : "none", ir = Pr === "block" ? 16 : df, Dr = { x: Ct.to.x, y: ir }, Wr = 100 / ra.length;
            i.yAxis.tickRotation = i.isResponsiveTicks && i.orientation === "horizontal" ? 0 : i.yAxis.tickRotation, i.xAxis.tickRotation = i.isResponsiveTicks && i.orientation === "vertical" ? 0 : i.xAxis.tickRotation;
            const Bt = i.isResponsiveTicks && Zt ? -Number(i.xAxis.maxTickRotation) || -90 : -Number(i.runtime.xAxis.tickRotation);
            return /* @__PURE__ */ m.createElement(tt, { key: `vx-tick-${Ct.value}-${dn}`, className: "vx-axis-tick" }, !i.xAxis.hideTicks && /* @__PURE__ */ m.createElement(
              en,
              {
                from: Ct.from,
                to: ne === "horizontal" && ot ? Dr : Ct.to,
                stroke: i.xAxis.tickColor,
                strokeWidth: Pr === "block" && ot ? 1.3 : 1
              }
            ), !i.xAxis.hideLabel && /* @__PURE__ */ m.createElement(
              ht,
              {
                innerRef: (mr) => Ke.current[dn] = mr,
                dy: i.orientation === "horizontal" && ot ? 8 : 0,
                display: i.orientation === "horizontal" && ot ? Pr : "block",
                x: Ct.to.x,
                y: Ct.to.y + uf,
                angle: Bt,
                verticalAnchor: Bt < -50 ? "middle" : "start",
                textAnchor: Bt ? "end" : "middle",
                width: Zt && !i.isResponsiveTicks && !Number(i[nt].tickRotation) ? Wr : void 0,
                fill: i.xAxis.tickLabelColor,
                fontSize: Et
              },
              Ct.formattedValue
            ));
          }), !i.xAxis.hideAxis && /* @__PURE__ */ m.createElement(en, { from: D.axisFromPoint, to: D.axisToPoint, stroke: "#333" }), /* @__PURE__ */ m.createElement(
            ht,
            {
              innerRef: Te,
              className: "x-axis-title-label",
              x: et / 2,
              y: it ? 0 : I,
              textAnchor: "middle",
              verticalAnchor: "start",
              fontWeight: "bold",
              fill: i.xAxis.labelColor,
              fontSize: Pt
            },
            D.label
          ));
        }
      )
    ),
    !y && At && Object.entries(At.data).length > 0 && Qt && Ht && At.dataYPosition && At.dataXPosition && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${i.tooltips.opacity / 100}) !important;`), /* @__PURE__ */ m.createElement("style", null, ".tooltip {max-width:300px} !important; word-wrap: break-word; "), /* @__PURE__ */ m.createElement(
      $y,
      {
        key: Math.random(),
        className: "tooltip cdc-open-viz-module",
        left: cn,
        top: kn
      },
      /* @__PURE__ */ m.createElement("ul", null, typeof At == "object" && Object.entries(At.data).filter(([D, U]) => Array.isArray(U) && !U.includes(void 0)).map((D, U) => /* @__PURE__ */ m.createElement(un, { item: D, key: U })))
    )),
    i.visualizationType === "Bump Chart" && /* @__PURE__ */ m.createElement(
      yu,
      {
        id: "bump-chart",
        variant: "light",
        arrowColor: "rgba(0,0,0,0)",
        className: "tooltip",
        style: { background: `rgba(255,255,255, ${i.tooltips.opacity / 100})`, color: "black" }
      }
    ),
    ve() && !y && /* @__PURE__ */ m.createElement(
      yu,
      {
        id: `cdc-open-viz-tooltip-${K.uniqueId}`,
        variant: "light",
        arrowColor: "rgba(0,0,0,0)",
        className: "tooltip",
        style: { background: `rgba(255,255,255, ${i.tooltips.opacity / 100})`, color: "black" }
      }
    ),
    /* @__PURE__ */ m.createElement("div", { className: "animation-trigger", ref: je })
  ));
});
const lw = (e) => {
  var le;
  const { width: t, height: n } = e, { transformedData: r, config: a, parseDate: i, formatDate: u, seriesHighlight: c, formatNumber: l, colorScale: p, handleChartAriaLabels: h } = ue.useContext(mt);
  let g = Number(t);
  const { minValue: x, maxValue: w } = Vu(a, r), y = { top: 5, right: 10, bottom: 10, left: 10 }, R = Number(n), b = g - a.runtime.yAxis.size, v = R - y.top - 20, A = (K) => a.runtime.xAxis.type === "date" ? i(K[a.runtime.originalXAxis.dataKey]).getTime() : K[a.runtime.originalXAxis.dataKey], N = (K, re) => K[re];
  let L, C;
  const { max: z, min: W } = a.runtime.yAxis, q = Number(z) >= Number(w), ne = Number(W) <= Number(x);
  if (r) {
    let K = Number(W && ne ? W : x), re = Number(z && q ? z : Number.MIN_VALUE);
    if (re === Number.MIN_VALUE && (re = w), a.runtime.yAxis.paddingPercent) {
      let j = (re - K) * a.runtime.yAxis.paddingPercent;
      K -= j, re += j;
    }
    let B = r.map((j) => A(j));
    a.runtime.horizontal ? (L = Mn({
      domain: [K, re],
      range: [0, b]
    }), C = a.runtime.xAxis.type === "date" ? Mn({ domain: [Math.min(...B), Math.max(...B)] }) : nl({ domain: B, padding: 0.5 }), nl({
      domain: a.runtime.barSeriesKeys || a.runtime.seriesKeys,
      range: [0, v]
    }), C.rangeRound([0, v])) : (K = K < 0 ? K * 1.11 : K, C = Mn({
      domain: [K, re],
      range: [v - y.bottom, y.top]
    }), L = nl({
      domain: B,
      range: [y.left, g - y.right]
    }), nl({
      domain: a.runtime.barSeriesKeys || a.runtime.seriesKeys,
      range: [0, b]
    }));
  }
  const G = [L.domain()[0], L.domain()[L.domain().length - 1]];
  return /* @__PURE__ */ m.createElement(Vr, { component: "SparkLine" }, /* @__PURE__ */ m.createElement("svg", { role: "img", "aria-label": h(a), width: t, height: 100, className: "sparkline", tabIndex: 0 }, /* @__PURE__ */ m.createElement("title", null, `Spark line graphic with the title ${a.title ? a.title : "No Title Found"}`), ((le = a.runtime.lineSeriesKeys) == null ? void 0 : le.length) > 0 ? a.runtime.lineSeriesKeys : a.runtime.seriesKeys.map((K, re) => /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
    tt,
    {
      style: { width: g },
      className: "sparkline-group",
      key: `series-${K}`,
      opacity: a.legend.behavior === "highlight" && c.length > 0 && c.indexOf(K) === -1 ? 0.5 : 1,
      display: a.legend.behavior === "highlight" || c.length === 0 || c.indexOf(K) !== -1 ? "block" : "none"
    },
    a.labels && r.map((B, j) => /* @__PURE__ */ m.createElement(tt, { key: `series-${K}-point-${j}` }, /* @__PURE__ */ m.createElement(ht, { x: L(A(B)), y: C(N(B, K)), fill: p ? p(a.runtime.seriesLabels ? a.runtime.seriesLabels[K] : K) : "#000", textAnchor: "middle" }, l(B[K])))),
    /* @__PURE__ */ m.createElement(
      Hr,
      {
        curve: Ou,
        data: r,
        x: (B) => L(A(B)),
        y: (B) => C(N(B, K)),
        stroke: p ? p(a.runtime.seriesLabels ? a.runtime.seriesLabels[K] : K) : "#000",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        markerEnd: `url(#arrow--${re})`
      }
    ),
    /* @__PURE__ */ m.createElement(wm, { id: `arrow--${re}`, refX: 2, size: 6, markerEnd: `url(#arrow--${re})`, strokeOpacity: 1, fillOpacity: 1, fill: p ? p(a.runtime.seriesLabels ? a.runtime.seriesLabels[K] : K) : "#000" })
  ), /* @__PURE__ */ m.createElement(
    jc,
    {
      top: v + y.top,
      hideAxisLine: !0,
      hideTicks: !0,
      scale: L,
      tickValues: G,
      tickFormat: (B) => a.xAxis.type === "date" ? u(B) : null,
      stroke: "black",
      tickStroke: "black",
      tickLabelProps: () => ({
        fill: "black",
        fontSize: 11,
        textAnchor: "middle"
      })
    }
  )))));
};
var sw = ["flexDirection", "alignItems", "margin", "display", "children"];
function jf() {
  return jf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, jf.apply(this, arguments);
}
function cw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function Tu(e) {
  var t = e.flexDirection, n = t === void 0 ? "row" : t, r = e.alignItems, a = r === void 0 ? "center" : r, i = e.margin, u = i === void 0 ? "0" : i, c = e.display, l = c === void 0 ? "flex" : c, p = e.children, h = cw(e, sw);
  return /* @__PURE__ */ m.createElement("div", jf({
    className: "visx-legend-item",
    style: {
      display: l,
      alignItems: a,
      flexDirection: n,
      margin: u
    }
  }, h), p);
}
Tu.propTypes = {
  alignItems: Me.string,
  margin: Me.oneOfType([Me.string, Me.number]),
  children: Me.node,
  display: Me.string
};
var uw = ["flex", "label", "margin", "align", "children"];
function Uf() {
  return Uf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Uf.apply(this, arguments);
}
function dw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function Ru(e) {
  var t = e.flex, n = t === void 0 ? "1" : t, r = e.label, a = e.margin, i = a === void 0 ? "5px 0" : a, u = e.align, c = u === void 0 ? "left" : u, l = e.children, p = dw(e, uw);
  return /* @__PURE__ */ m.createElement("div", Uf({
    className: "visx-legend-label",
    style: {
      justifyContent: c,
      display: "flex",
      flex: n,
      margin: i
    }
  }, p), l || r);
}
Ru.propTypes = {
  align: Me.string,
  label: Me.node,
  flex: Me.oneOfType([Me.string, Me.number]),
  margin: Me.oneOfType([Me.string, Me.number]),
  children: Me.node
};
function Kf() {
  return Kf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Kf.apply(this, arguments);
}
function wp(e) {
  var t = e.fill, n = e.width, r = e.height, a = e.style;
  return /* @__PURE__ */ m.createElement("div", {
    style: Kf({
      width: n,
      height: r,
      background: t
    }, a)
  });
}
wp.propTypes = {
  fill: Me.string,
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function dg(e) {
  var t = e.fill, n = e.width, r = e.height, a = e.style, i = typeof n == "string" || typeof n > "u" ? 0 : n, u = typeof r == "string" || typeof r > "u" ? 0 : r, c = Math.max(i, u), l = c / 2;
  return /* @__PURE__ */ m.createElement("svg", {
    width: c,
    height: c
  }, /* @__PURE__ */ m.createElement(tt, {
    top: l,
    left: l
  }, /* @__PURE__ */ m.createElement("circle", {
    r: l,
    fill: t,
    style: a
  })));
}
dg.propTypes = {
  fill: Me.string,
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function fg(e) {
  var t = e.fill, n = e.width, r = e.height, a = e.style, i = typeof r == "string" || typeof r > "u" ? 0 : r, u = typeof (a == null ? void 0 : a.strokeWidth) == "number" ? a == null ? void 0 : a.strokeWidth : 2;
  return /* @__PURE__ */ m.createElement("svg", {
    width: n,
    height: r
  }, /* @__PURE__ */ m.createElement(tt, {
    top: i / 2 - u / 2
  }, /* @__PURE__ */ m.createElement("line", {
    x1: 0,
    x2: n,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: u,
    style: a
  })));
}
fg.propTypes = {
  fill: Me.string,
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function bs() {
  return bs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, bs.apply(this, arguments);
}
var pf = function() {
};
function fw(e) {
  var t = e.shape, n = t === void 0 ? "rect" : t, r = e.fill, a = r === void 0 ? pf : r, i = e.size, u = i === void 0 ? pf : i, c = e.width, l = e.height, p = e.label, h = e.item, g = e.itemIndex, x = e.shapeStyle, w = x === void 0 ? pf : x, y = {
    width: c,
    height: l,
    item: h,
    itemIndex: g,
    label: p,
    fill: a(bs({}, p)),
    size: u(bs({}, p)),
    style: w(bs({}, p))
  };
  return typeof n == "string" ? n === "circle" ? /* @__PURE__ */ m.createElement(dg, y) : n === "line" ? /* @__PURE__ */ m.createElement(fg, y) : /* @__PURE__ */ m.createElement(wp, y) : /* @__PURE__ */ m.isValidElement(n) ? /* @__PURE__ */ m.cloneElement(n, y) : n ? /* @__PURE__ */ m.createElement(n, y) : null;
}
function Cu() {
  return Cu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Cu.apply(this, arguments);
}
function pg(e) {
  var t = e.shape, n = t === void 0 ? wp : t, r = e.width, a = e.height, i = e.margin, u = e.label, c = e.item, l = e.itemIndex, p = e.fill, h = e.size, g = e.shapeStyle;
  return /* @__PURE__ */ m.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: h ? h(Cu({}, u)) : r,
      height: h ? h(Cu({}, u)) : a,
      margin: i
    }
  }, fw({
    shape: n,
    item: c,
    itemIndex: l,
    label: u,
    width: r,
    height: a,
    fill: p,
    shapeStyle: g
  }));
}
pg.propTypes = {
  itemIndex: Me.number.isRequired,
  margin: Me.oneOfType([Me.string, Me.number]),
  width: Me.oneOfType([Me.string, Me.number]),
  height: Me.oneOfType([Me.string, Me.number])
};
function hg(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function hm(e) {
  return String(hg(e));
}
function pw(e) {
  var t = e.scale, n = e.labelFormat;
  return function(r, a) {
    return {
      datum: r,
      index: a,
      text: "" + n(r, a),
      value: t(r)
    };
  };
}
var hw = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function Es() {
  return Es = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Es.apply(this, arguments);
}
function mw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, i;
  for (i = 0; i < r.length; i++)
    a = r[i], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var yw = {
  display: "flex"
};
function mg(e) {
  var t = e.className, n = e.style, r = n === void 0 ? yw : n, a = e.scale, i = e.shape, u = e.domain, c = e.fill, l = c === void 0 ? hm : c, p = e.size, h = p === void 0 ? hm : p, g = e.labelFormat, x = g === void 0 ? hg : g, w = e.labelTransform, y = w === void 0 ? pw : w, R = e.shapeWidth, b = R === void 0 ? 15 : R, v = e.shapeHeight, A = v === void 0 ? 15 : v, N = e.shapeMargin, L = N === void 0 ? "2px 4px 2px 0" : N, C = e.shapeStyle, z = e.labelAlign, W = z === void 0 ? "left" : z, q = e.labelFlex, ne = q === void 0 ? "1" : q, G = e.labelMargin, le = G === void 0 ? "0 4px" : G, K = e.itemMargin, re = K === void 0 ? "0" : K, B = e.direction, j = B === void 0 ? "column" : B, se = e.itemDirection, ee = se === void 0 ? "row" : se, Q = e.legendLabelProps, Z = e.children, Y = mw(e, hw), te = u || ("domain" in a ? a.domain() : []), $ = y({
    scale: a,
    labelFormat: x
  }), ce = te.map($);
  return Z ? /* @__PURE__ */ m.createElement(m.Fragment, null, Z(ce)) : /* @__PURE__ */ m.createElement("div", {
    className: Sn("visx-legend", t),
    style: Es({}, r, {
      flexDirection: j
    })
  }, ce.map(function(Se, be) {
    return /* @__PURE__ */ m.createElement(Tu, Es({
      key: "legend-" + Se.text + "-" + be,
      margin: re,
      flexDirection: ee
    }, Y), /* @__PURE__ */ m.createElement(pg, {
      shape: i,
      height: A,
      width: b,
      margin: L,
      item: te[be],
      itemIndex: be,
      label: Se,
      fill: l,
      size: h,
      shapeStyle: C
    }), /* @__PURE__ */ m.createElement(Ru, Es({
      label: Se.text,
      flex: ne,
      margin: le,
      align: W
    }, Q)));
  }));
}
mg.propTypes = {
  children: Me.func,
  className: Me.string,
  domain: Me.array,
  shapeWidth: Me.oneOfType([Me.string, Me.number]),
  shapeHeight: Me.oneOfType([Me.string, Me.number]),
  shapeMargin: Me.oneOfType([Me.string, Me.number]),
  labelAlign: Me.string,
  labelFlex: Me.oneOfType([Me.string, Me.number]),
  labelMargin: Me.oneOfType([Me.string, Me.number]),
  itemMargin: Me.oneOfType([Me.string, Me.number]),
  fill: Me.func,
  size: Me.func,
  shapeStyle: Me.func
};
function gw(e) {
  return /* @__PURE__ */ m.createElement(mg, e);
}
const vw = (e) => {
  const { position: t, singleRow: n, verticalSorted: r, hideBorder: a } = e.legend, i = {
    left: "left",
    right: "right",
    bottom: "bottom",
    top: "top"
  }, u = {
    bottom: n ? ["single-row", "bottom"] : ["double-column", "bottom"],
    top: n ? ["single-row", "top"] : ["double-column", "top"]
  }, c = ["legend-container", i[t]].filter(Boolean), l = ["legend-container__inner", ...u[t] || []];
  ["bottom", "top"].includes(t) && r && l.push("vertical-sorted");
  const p = (["right", "left"].includes(t) || !t) && a.side, h = ["top", "bottom"].includes(t) && a.topBottom;
  return p || h ? c.push("border-0", "p-0") : c.push("p-3"), {
    containerClasses: c,
    innerClasses: l
  };
}, xw = (e, t, n) => {
  const a = t([{ datum: "", index: 0, text: "", value: "" }]), i = e.legend.colorCode ? a.map((c) => c == null ? void 0 : c.value) : (n == null ? void 0 : n.range()) ?? [], u = e.legend.colorCode ? a.map((c) => (c == null ? void 0 : c.text) || (c == null ? void 0 : c.datum)) : (n == null ? void 0 : n.domain()) ?? [];
  return { colors: i, labels: u };
}, bw = (e, t) => e && t.legend.hide || !e ? "0px" : e && t.brush.active && !t.legend.hide ? `${27 + t.brush.height + 25}px` : "27px", Ew = (e, t) => {
  var i, u, c;
  const n = ((i = t.legend) == null ? void 0 : i.position) === "top" && !t.legend.hide, r = !t.legend.hideSuppressionLink && t.visualizationSubType !== "stacked" && ((u = t.preliminaryData) == null ? void 0 : u.some((l) => l.label && l.type === "suppression" && l.value && ((l == null ? void 0 : l.style) || l.symbol)));
  let a = 0;
  return n && (a = 27), n && ((c = t.dataFormat) != null && c.onlyShowTopPrefixSuffix) && (a += 9), e && (a += 9), r && (a += 40), `${a}px`;
}, Sw = ({ config: e, isLegendBottom: t }) => {
  const { preliminaryData: n, visualizationType: r, visualizationSubType: a, legend: i } = e, u = () => (n == null ? void 0 : n.some((w) => w.label && w.type === "effect" && w.style !== "Filled Circles")) && ["Line", "Combo"].includes(r), c = () => !i.hideSuppressedLabels && (n == null ? void 0 : n.some(
    (w) => w.label && w.displayLegend && w.type === "suppression" && w.value && ((w == null ? void 0 : w.style) || w.symbol)
  )) && (r === "Bar" && a === "regular" || r === "Line" || r === "Combo"), l = () => n == null ? void 0 : n.map(
    (w, y) => w.label && w.type === "effect" && w.style && /* @__PURE__ */ m.createElement("div", { key: y, className: "legend-preliminary" }, /* @__PURE__ */ m.createElement("span", { className: w.symbol }, w.lineCode), /* @__PURE__ */ m.createElement("p", null, w.label))
  ), p = (w) => {
    w.preventDefault();
  }, h = () => {
    const w = (y) => y ? {
      color: "#777772"
    } : null;
    return n == null ? void 0 : n.map((y, R) => {
      if (!y.displayLegend || y.type !== "suppression")
        return null;
      const b = "legend-preliminary", v = R + r;
      return r === "Bar" ? /* @__PURE__ */ m.createElement("div", { style: w(y.displayGray), key: v, className: `${b} ${y.symbol}` }, /* @__PURE__ */ m.createElement("span", { className: y.symbol }, y.iconCode), /* @__PURE__ */ m.createElement("p", { className: y.type }, y.label)) : r === "Line" ? /* @__PURE__ */ m.createElement("div", { style: w(y.displayGray), key: v, className: b }, /* @__PURE__ */ m.createElement("span", null, y.lineCode), /* @__PURE__ */ m.createElement("p", { className: y.type }, y.label)) : r === "Combo" ? /* @__PURE__ */ m.createElement(m.Fragment, null, y.symbol && y.iconCode && /* @__PURE__ */ m.createElement("div", { style: w(y.displayGray), key: v, className: `${b} ${y.symbol}` }, /* @__PURE__ */ m.createElement("span", { className: y.symbol }, y.iconCode), /* @__PURE__ */ m.createElement("p", { className: y.type }, y.label)), y.style && y.lineCode && /* @__PURE__ */ m.createElement("div", { style: w(y.displayGray), key: v, className: b }, /* @__PURE__ */ m.createElement("span", null, y.lineCode), /* @__PURE__ */ m.createElement("p", null, y.label))) : null;
    });
  }, g = () => i.singleRow && t ? "legend-container__inner bottom single-row" : "", x = () => !e.legend.hideSuppressionLink && e.visualizationSubType !== "stacked" && (n == null ? void 0 : n.some((w) => w.label && w.type === "suppression" && w.value && ((w == null ? void 0 : w.style) || w.symbol)));
  return /* @__PURE__ */ m.createElement(m.Fragment, null, u() && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("hr", null), /* @__PURE__ */ m.createElement("div", { className: g() }, l())), c() && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("hr", null), /* @__PURE__ */ m.createElement("div", { className: g() }, h())), x() && /* @__PURE__ */ m.createElement("div", { className: "legend-container__outer definition-link" }, /* @__PURE__ */ m.createElement(Ge, { alt: "info-icon", display: "info" }), /* @__PURE__ */ m.createElement("p", null, "This chart contains", /* @__PURE__ */ m.createElement(
    "a",
    {
      onClick: p,
      "data-tooltip-content": "Data is suppressed to maintain statistical reliability. This occurs when the number of respondents or reported values does not meet the minimum reporting threshold.",
      "data-tooltip-id": "my-tooltip",
      href: "no-router-link"
    },
    "suppressed data"
  ))), /* @__PURE__ */ m.createElement(
    yu,
    {
      id: "my-tooltip",
      variant: "light",
      style: { background: `rgba(255,255,255, ${e.tooltips.opacity / 100})`, color: "black", maxWidth: "100%" }
    }
  ));
}, yg = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, kw = [
  Em,
  Sm,
  Xc,
  km,
  Xc,
  Sp,
  ({ fill: e }) => /* @__PURE__ */ m.createElement(Yf, null, /* @__PURE__ */ m.createElement(ht, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle" }, "⬟"))
], ww = (e) => {
  var c;
  const { config: t, label: n, index: r } = e, a = r === 4, i = kw[t.visual.lineDatapointSymbol === "standard" && r < t.visual.maximumShapeAmount ? r : 0], u = `translate(15, 3) ${a ? "rotate(180)" : ""}`;
  return /* @__PURE__ */ m.createElement("svg", { width: 30, height: 10, style: { overflow: "visible" }, className: "me-2" }, /* @__PURE__ */ m.createElement(
    en,
    {
      from: { x: 0, y: 3 },
      to: { x: 30, y: 3 },
      stroke: n.value,
      strokeWidth: 2,
      strokeDasharray: yg(((c = t.series[r]) == null ? void 0 : c.type) || "")
    }
  ), /* @__PURE__ */ m.createElement("g", { display: t.legend.hasShape ? "block" : "none", transform: u }, /* @__PURE__ */ m.createElement(i, { fillOpacity: 1, fill: n.value })));
}, Tw = 36, Rw = ue.forwardRef(
  ({
    config: e,
    colorScale: t,
    seriesHighlight: n,
    highlight: r,
    handleShowAll: a,
    currentViewport: i,
    formatLabels: u,
    skipId: c = "legend",
    dimensions: l
  }, p) => {
    const { innerClasses: h, containerClasses: g } = vw(e), { runtime: x, legend: w } = e, y = (w == null ? void 0 : w.position) === "bottom" || Va(i) && !w.hide && (w == null ? void 0 : w.position) !== "top", R = {
      marginBottom: Ew(y, e),
      marginTop: bw(y, e)
    }, { HighLightedBarUtils: b } = Hu(e);
    let v = b.findDuplicates(e.highlightedBarValues);
    return w ? /* @__PURE__ */ m.createElement(
      "aside",
      {
        ref: p,
        style: R,
        id: c || "legend",
        className: g.join(" "),
        role: "region",
        "aria-label": "legend",
        tabIndex: 0
      },
      (w.label || w.description) && /* @__PURE__ */ m.createElement("div", { className: w.description ? "mb-3" : "mb-2" }, w.label && /* @__PURE__ */ m.createElement("h3", { className: "fw-bold" }, Oi(w.label)), w.description && /* @__PURE__ */ m.createElement("p", { className: "mt-2" }, Oi(w.description))),
      /* @__PURE__ */ m.createElement(
        Fg,
        {
          config: e,
          ...xw(e, u, t),
          dimensions: l,
          parentPaddingToSubtract: w.hideBorder ? 0 : Tw
        }
      ),
      /* @__PURE__ */ m.createElement(gw, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0" }, (A) => /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("div", { className: h.join(" ") }, u(A).map((N, L) => {
        var W, q;
        let C = ["legend-item", `legend-text--${N.text.replace(" ", "").toLowerCase()}`], z = N.datum;
        if (e.exclusions.active && ((W = e.exclusions.keys) != null && W.includes(z)))
          return null;
        if (x.seriesLabels) {
          let ne = e.runtime.seriesLabelsAll.indexOf(z);
          z = e.runtime.seriesKeys[ne], ((q = x == null ? void 0 : x.forecastingSeriesKeys) == null ? void 0 : q.length) > 0 && (z = N.text);
        }
        return n.length && (n.includes(z) ? C.push("highlighted") : C.push("inactive")), e.legend.style === "gradient" ? /* @__PURE__ */ m.createElement(m.Fragment, null) : /* @__PURE__ */ m.createElement(
          Tu,
          {
            className: C.join(" "),
            tabIndex: 0,
            key: `legend-quantile-${L}`,
            onKeyDown: (ne) => {
              ne.key === "Enter" && (ne.preventDefault(), r(N));
            },
            onClick: (ne) => {
              ne.preventDefault(), r(N);
            },
            role: "button"
          },
          /* @__PURE__ */ m.createElement(m.Fragment, null, e.visualizationType === "Line" && e.legend.style === "lines" ? /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(ww, { index: L, label: N, config: e })) : /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
            zp,
            {
              shape: e.legend.style === "boxes" ? "square" : "circle",
              fill: N.value
            }
          ))),
          /* @__PURE__ */ m.createElement(Ru, { align: "left", className: "m-0" }, N.text)
        );
      }), v.map((N, L) => {
        let C = "legend-item", z = N.legendLabel;
        return z ? (n.length > 0 && n.includes(z) === !1 && (C += " inactive"), /* @__PURE__ */ m.createElement(
          Tu,
          {
            className: C,
            tabIndex: 0,
            key: `legend-quantile-${L}`,
            onKeyDown: (W) => {
              W.key === "Enter" && (W.preventDefault(), r(N.legendLabel));
            },
            onClick: (W) => {
              W.preventDefault(), r(N.legendLabel);
            }
          },
          /* @__PURE__ */ m.createElement(
            zp,
            {
              shape: e.legend.style === "boxes" ? "square" : "circle",
              style: { borderRadius: "0px" },
              fill: "transparent",
              borderColor: N.color ? N.color : "rgba(255, 102, 1)"
            }
          ),
          " ",
          /* @__PURE__ */ m.createElement(Ru, { align: "left" }, N.legendLabel ? N.legendLabel : N.value)
        )) : !1;
      })), /* @__PURE__ */ m.createElement(Sw, { config: e, isLegendBottom: y }))),
      n.length > 0 && /* @__PURE__ */ m.createElement(Pu, { onClick: (A) => a(A), style: { marginTop: "1rem" } }, "Show All")
    ) : null;
  }
);
function Cw(e) {
  return Mg({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" } }] })(e);
}
const Aw = (e, t, n, r) => (a) => {
  var w, y, R, b, v;
  const { visualizationType: i, visualizationSubType: u, series: c, runtime: l, legend: p } = e, h = (A) => p.verticalSorted ? Je.sortBy(Je.cloneDeep(A), (N) => {
    var C;
    const L = (C = N.datum) == null ? void 0 : C.match(/-?\d+(\.\d+)?/);
    return L ? parseFloat(L[0]) : Number.MAX_SAFE_INTEGER;
  }) : A, g = (A) => e.legend.reverseLabelOrder ? h(A).reverse() : h(A), x = (w = e.legend) == null ? void 0 : w.colorCode;
  if (i === "Deviation Bar") {
    const [A, N] = Nu[e.twoColor.palette], L = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: A
    }, C = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: N
    };
    return g([L, C]);
  }
  if (i === "Bar" && u === "regular" && x && (c == null ? void 0 : c.length) === 1) {
    let A = Sr[e.palette];
    for (; t.length > A.length; )
      A = A.concat(A);
    A = A.slice(0, n.length);
    const N = /* @__PURE__ */ new Set();
    t.forEach((C) => N.add(C[x]));
    const L = Array.from(N).map((C, z) => ({
      datum: C,
      index: z,
      text: C,
      value: A[z]
    }));
    return g(L);
  }
  if (((y = l == null ? void 0 : l.forecastingSeriesKeys) == null ? void 0 : y.length) > 0) {
    let A = [];
    return (b = (R = e.runtime) == null ? void 0 : R.forecastingSeriesKeys) == null || b.map((N, L) => {
      var C;
      return (C = N == null ? void 0 : N.stages) == null ? void 0 : C.map((z, W) => {
        var G, le, K, re;
        let q = (G = Gc[z.color]) != null && G[2] ? (le = Gc[z.color]) == null ? void 0 : le[2] : (K = Sr[z.color]) != null && K[2] ? (re = Sr[z.color]) == null ? void 0 : re[2] : "#ccc";
        const ne = {
          datum: z.key,
          index: W,
          text: z.key,
          value: q
        };
        A.push(ne);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((N, L) => {
      let C = Sr[e.palette][L] ? Sr[e.palette][L] : "#ccc";
      const z = {
        datum: N,
        index: L,
        text: N,
        value: C
      };
      A.push(z);
    }), g(A);
  }
  if (e.series.some((A) => A.name)) {
    const A = Array.from(new Set(e.series.map((N) => N.name || N.dataKey))).map((N, L) => ({
      datum: N,
      index: L,
      text: N,
      value: r(N)
    }));
    return g(A);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const A = a.length - 1;
    let N = [];
    return (v = e.suppressedData) == null || v.forEach(({ label: L, icon: C }, z) => {
      if (L && C) {
        const W = {
          datum: L,
          index: A + z,
          text: L,
          icon: /* @__PURE__ */ React.createElement(Cw, { color: "#000", size: 15 })
        };
        N.push(W);
      }
    }), [...a, ...N];
  }
  return g(a);
}, Lw = ue.forwardRef((e, t) => {
  const {
    // prettier-ignore
    config: n,
    colorScale: r,
    seriesHighlight: a,
    highlight: i,
    tableData: u,
    handleShowAll: c,
    transformedData: l,
    currentViewport: p,
    dimensions: h,
    getTextWidth: g
  } = ue.useContext(mt);
  if (!n.legend)
    return null;
  const x = Aw(n, u, l, r);
  return /* @__PURE__ */ React.createElement(ue.Fragment, null, /* @__PURE__ */ React.createElement(
    Rw,
    {
      getTextWidth: g,
      dimensions: h,
      ref: t,
      skipId: e.skipId || "legend",
      config: n,
      colorScale: r,
      seriesHighlight: a,
      highlight: i,
      handleShowAll: c,
      currentViewport: p,
      formatLabels: x
    }
  ));
}), Kc = {
  annotations: [],
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "true",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    annotationDropdownText: "Annotations",
    showDownloadButton: !1,
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0,
    showZeroValueData: !0,
    hideNullValue: !0
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !1,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: [],
    shoMissingDataLabel: !0,
    showMissingDataLine: !0,
    categories: []
  },
  boxplot: {
    plots: [],
    borders: "true",
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      count: "Count",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 0,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0,
    padding: 5,
    showYearsOnce: !1,
    sortByRecentDate: !1
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    showDownloadLinkBelow: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: "",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    label: "",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    hideSuppressionLink: !1,
    seriesHighlight: [],
    style: "circles",
    subStyle: "linear blocks",
    shape: "circle",
    tickRotation: "",
    hideBorder: {
      side: !1,
      topBottom: !0
    },
    position: "right"
  },
  brush: {
    height: 45,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  filters: [],
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1,
    lineDatapointSymbol: "none",
    maximumShapeAmount: 7
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, Nw = ({
  config: e,
  deleteColumn: t,
  updateField: n,
  colKey: r,
  controls: a
}) => {
  var g, x, w, y;
  const [i, u] = a, c = (R, b) => {
    if (R === "dataTable" && b === !0) {
      const v = Je.cloneDeep(e.columns);
      v[r] = { ...v[r], dataTable: b }, n(null, null, "columns", v);
    } else
      n("columns", r, R, b);
  }, l = (R) => {
    const b = Je.cloneDeep(e.columns), A = { ...e.columns[r], name: R, label: R };
    if (A.dataTable === void 0 && (A.dataTable = !0), R !== r) {
      b[R] = A, delete b[r];
      const N = { ...Je.cloneDeep(i), [R]: !0 };
      delete N[r], u(N);
    }
    n(null, null, "columns", b);
  }, p = () => {
    var A;
    const R = e.data.flatMap((N) => Object.keys(N).map((L) => L)), b = Object.values(e.columns).map((N) => N.name), v = Je.uniq(R).filter((N) => !(e.table.groupBy === N || b.includes(N)));
    return (A = e.columns[r]) != null && A.name && v.push(e.columns[r].name), v;
  }, h = (g = e.columns[r]) == null ? void 0 : g.name;
  return /* @__PURE__ */ m.createElement(
    zg,
    {
      fieldName: h,
      fieldKey: r,
      fieldType: "Column",
      controls: a,
      deleteField: () => t(r)
    },
    /* @__PURE__ */ m.createElement(
      yt,
      {
        label: "Column",
        value: (x = e.columns[r]) == null ? void 0 : x.name,
        fieldName: "name",
        section: "columns",
        initial: "-Select-",
        options: p(),
        updateField: (R, b, v, A) => l(A)
      }
    ),
    e.type !== "table" && /* @__PURE__ */ m.createElement(
      yt,
      {
        label: "Associate to Series",
        value: (w = e.columns[r]) == null ? void 0 : w.series,
        fieldName: "series",
        section: "columns",
        initial: "Select series",
        options: ((y = e.series) == null ? void 0 : y.map((R) => R.dataKey)) || [],
        updateField: (R, b, v, A) => c("series", A)
      }
    ),
    /* @__PURE__ */ m.createElement(
      Ue,
      {
        value: e.columns[r].label,
        section: "columns",
        subsection: r,
        fieldName: "label",
        label: "Label",
        updateField: n
      }
    ),
    /* @__PURE__ */ m.createElement("ul", { className: "column-edit" }, /* @__PURE__ */ m.createElement("li", { className: "three-col" }, /* @__PURE__ */ m.createElement(
      Ue,
      {
        value: e.columns[r].prefix,
        section: "columns",
        subsection: r,
        fieldName: "prefix",
        label: "Prefix",
        updateField: n
      }
    ), /* @__PURE__ */ m.createElement(
      Ue,
      {
        value: e.columns[r].suffix,
        section: "columns",
        subsection: r,
        fieldName: "suffix",
        label: "Suffix",
        updateField: n
      }
    ), /* @__PURE__ */ m.createElement(
      Ue,
      {
        type: "number",
        value: e.columns[r].roundToPlace,
        section: "columns",
        subsection: r,
        fieldName: "roundToPlace",
        label: "Round",
        updateField: n
      }
    )), /* @__PURE__ */ m.createElement("li", null, /* @__PURE__ */ m.createElement("label", { className: "checkbox" }, /* @__PURE__ */ m.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[r].commas,
        onChange: (R) => {
          c("commas", R.target.checked);
        }
      }
    ), /* @__PURE__ */ m.createElement("span", { className: "edit-label" }, "Add Commas to Numbers"))), /* @__PURE__ */ m.createElement("li", null, e.table.showVertical && /* @__PURE__ */ m.createElement("label", { className: "checkbox" }, /* @__PURE__ */ m.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[r].dataTable ?? !0,
        onChange: (R) => {
          c("dataTable", R.target.checked);
        }
      }
    ), /* @__PURE__ */ m.createElement("span", { className: "edit-label" }, "Show in Data Table"))), e.visualizationType === "Pie" && /* @__PURE__ */ m.createElement("li", null, /* @__PURE__ */ m.createElement("label", { className: "checkbox" }, /* @__PURE__ */ m.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[r].showInViz,
        onChange: (R) => {
          c("showInViz", R.target.checked);
        }
      }
    ), /* @__PURE__ */ m.createElement("span", { className: "edit-label" }, "Show in Visualization"))), e.type !== "table" && /* @__PURE__ */ m.createElement("li", null, /* @__PURE__ */ m.createElement("label", { className: "checkbox" }, /* @__PURE__ */ m.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[r].tooltips || !1,
        onChange: (R) => {
          n("columns", r, "tooltips", R.target.checked);
        }
      }
    ), /* @__PURE__ */ m.createElement("span", { className: "edit-label" }, "Show in tooltip"))), e.visualizationType === "Forest Plot" && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("li", null, /* @__PURE__ */ m.createElement("label", { className: "checkbox" }, /* @__PURE__ */ m.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[r].forestPlot || !1,
        onChange: (R) => {
          c("forestPlot", R.target.checked);
        }
      }
    ), /* @__PURE__ */ m.createElement("span", { className: "edit-label" }, "Show in Forest Plot"))), /* @__PURE__ */ m.createElement("li", null, /* @__PURE__ */ m.createElement("label", { className: "checkbox" }, /* @__PURE__ */ m.createElement(
      "input",
      {
        type: "checkbox",
        checked: e.columns[r].forestPlotAlignRight || !1,
        onChange: (R) => {
          c("forestPlotAlignRight", R.target.checked);
        }
      }
    ), /* @__PURE__ */ m.createElement("span", { className: "edit-label" }, "Align Right"))), !e.columns[r].forestPlotAlignRight && /* @__PURE__ */ m.createElement("li", null, /* @__PURE__ */ m.createElement("label", { className: "text" }, /* @__PURE__ */ m.createElement("span", { className: "edit-label" }, "Forest Plot Starting Point"), /* @__PURE__ */ m.createElement(
      "input",
      {
        type: "number",
        value: e.columns[r].forestPlotStartingPoint || 0,
        onChange: (R) => {
          c("forestPlotStartingPoint", R.target.value);
        }
      }
    ))))),
    /* @__PURE__ */ m.createElement("label", null, /* @__PURE__ */ m.createElement("span", { className: "edit-label column-heading" }, "Order"), /* @__PURE__ */ m.createElement(
      "input",
      {
        onWheel: (R) => R.currentTarget.blur(),
        type: "number",
        min: "1",
        value: e.columns[r].order,
        onChange: (R) => n("columns", r, "order", parseInt(R.target.value))
      }
    ))
  );
}, Pw = ({ config: e, updateField: t, deleteColumn: n }) => {
  var u;
  const r = ue.useState({}), a = Object.keys(e.columns), i = (c) => {
    const l = `additionalColumn${c}`, p = {
      label: "New Column",
      dataTable: !0,
      tooltips: !1,
      prefix: "",
      suffix: "",
      forestPlot: !1,
      startingPoint: "0",
      forestPlotAlignRight: !1,
      roundToPlace: 0,
      commas: !1,
      showInViz: !1,
      forestPlotStartingPoint: 0
    }, [h, g] = r;
    g({ ...h, [l]: !0 }), t("columns", null, l, p);
  };
  return /* @__PURE__ */ m.createElement(m.Fragment, null, e.type !== "navigation" && /* @__PURE__ */ m.createElement("fieldset", null, /* @__PURE__ */ m.createElement("label", null, /* @__PURE__ */ m.createElement("span", { className: "edit-label" }, "Configurations", /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "You can specify additional columns to display in tooltips and / or the supporting data table."))))), a.map((c, l) => /* @__PURE__ */ m.createElement(
    Nw,
    {
      key: c + l,
      controls: r,
      config: e,
      deleteColumn: n,
      updateField: t,
      colKey: c
    }
  )), /* @__PURE__ */ m.createElement(
    "button",
    {
      className: "btn btn-primary",
      onClick: (c) => {
        c.preventDefault(), i(a.length + 1);
      }
    },
    "Add Configuration"
  )), ((u = e.legend) == null ? void 0 : u.type) === "category" && /* @__PURE__ */ m.createElement("fieldset", null, /* @__PURE__ */ m.createElement("label", null, /* @__PURE__ */ m.createElement("span", { className: "edit-label" }, "Additional Category", /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "You can provide additional categories to ensure they appear in the legend"))))), e.legend.additionalCategories && e.legend.additionalCategories.map((c, l) => /* @__PURE__ */ m.createElement("fieldset", { className: "edit-block", key: c }, /* @__PURE__ */ m.createElement(
    "button",
    {
      className: "remove-column",
      onClick: (p) => {
        p.preventDefault();
        const h = [...e.legend.additionalCategories];
        h.splice(l, 1), t("legend", null, "additionalCategories", h);
      }
    },
    "Remove"
  ), /* @__PURE__ */ m.createElement(
    Ue,
    {
      value: c,
      label: "Category",
      section: "legend",
      subsection: null,
      fieldName: "additionalCategories",
      updateField: (p, h, g, x) => {
        const w = [...e.legend.additionalCategories];
        w[l] = x, t(p, h, g, w);
      }
    }
  ))), /* @__PURE__ */ m.createElement(
    "button",
    {
      className: "btn btn-primary full-width",
      onClick: (c) => {
        c.preventDefault();
        const l = [...e.legend.additionalCategories || []];
        l.push(""), t("legend", null, "additionalCategories", l);
      }
    },
    "Add Category"
  )));
}, mm = "-Select-", Dw = ({ config: e, updateField: t, isDashboard: n, columns: r }) => {
  var p, h, g, x, w, y, R;
  const a = ((p = e.dataKey) == null ? void 0 : p.includes("http://")) || ((h = e == null ? void 0 : e.dataKey) == null ? void 0 : h.includes("https://")), i = ue.useMemo(() => Object.keys(e.columns).map((b) => [b, e.columns[b].dataTable]).filter(([b, v]) => !v).map(([b]) => b), [e.columns]), u = ue.useMemo(() => {
    const b = e.data.flatMap(Object.keys);
    return Je.uniq(b).filter((A) => !0);
  }, [e.data]), c = (b) => {
    b === mm && (b = void 0), t("table", null, "groupBy", b);
  }, l = (b, v, A, N) => {
    const L = Je.cloneDeep(e.columns), C = [];
    for (let z in L) {
      const W = L[z];
      C.push(W.name), N.includes(W.name) ? L[z].dataTable = !1 : L[z].dataTable = !0;
    }
    N.forEach((z) => {
      C.includes(z) || (L[z] = { name: z, dataTable: !1 });
    }), t(null, null, "columns", L);
  };
  return /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
    Ue,
    {
      value: e.table.label,
      updateField: t,
      section: "table",
      fieldName: "label",
      id: "tableLabel",
      label: "Data Table Title",
      placeholder: "Data Table",
      tooltip: /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "Label is required for Data Table for 508 Compliance")))
    }
  ), e.type !== "table" ? /* @__PURE__ */ m.createElement(
    Ze,
    {
      value: e.table.show,
      fieldName: "show",
      label: "Show Data Table",
      section: "table",
      updateField: t,
      className: "column-heading",
      tooltip: /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(
        Ge,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "Hiding the data table may affect accessibility. An alternate form of accessing visualization data is a 508 requirement.")))
    }
  ) : /* @__PURE__ */ m.createElement(
    Ze,
    {
      value: (g = e.general) == null ? void 0 : g.showDownloadButton,
      fieldName: "showDownloadButton",
      label: "Show Download CSV link",
      section: "general",
      updateField: t,
      className: "column-heading"
    }
  ), e.visualizationType !== "Box Plot" && e.type !== "table" && /* @__PURE__ */ m.createElement(
    Ze,
    {
      value: e.table.showVertical,
      fieldName: "showVertical",
      label: "Show Vertical Data",
      section: "table",
      updateField: t,
      className: "column-heading",
      tooltip: /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(
        Ge,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "This will draw the data table with vertical data instead of horizontal.")))
    }
  ), e.type !== "table" && /* @__PURE__ */ m.createElement(
    Ue,
    {
      value: e.table.indexLabel,
      section: "table",
      fieldName: "indexLabel",
      label: "Index Column Header",
      updateField: t,
      tooltip: /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "To comply with 508 standards, if the first column in the data table has no header, enter a brief one here.")))
    }
  ), /* @__PURE__ */ m.createElement(
    Ue,
    {
      value: e.table.caption,
      updateField: t,
      section: "table",
      type: "textarea",
      fieldName: "caption",
      label: "Screen Reader Description",
      placeholder: " Data table",
      tooltip: /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "Enter a description of the data table to be read by screen readers.")))
    }
  ), /* @__PURE__ */ m.createElement(
    Ze,
    {
      value: e.table.limitHeight,
      section: "table",
      fieldName: "limitHeight",
      label: " Limit Table Height",
      updateField: t
    }
  ), e.table.limitHeight && /* @__PURE__ */ m.createElement(
    Ue,
    {
      value: e.table.height,
      section: "table",
      fieldName: "height",
      label: "Data Table Height",
      type: "number",
      min: 0,
      max: 500,
      placeholder: "Height(px)",
      updateField: t
    }
  ), (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ m.createElement("label", null, /* @__PURE__ */ m.createElement("span", { className: "edit-label column-heading mt-1" }, "Exclude Columns "), /* @__PURE__ */ m.createElement(
    Up,
    {
      key: i.join("") + "excluded",
      options: r.map((b) => ({ label: b, value: b })),
      selected: i,
      label: "Exclude Columns",
      fieldName: "dataTable",
      section: "columns",
      updateField: l
    }
  )), /* @__PURE__ */ m.createElement(
    Ze,
    {
      value: e.table.collapsible,
      fieldName: "collapsible",
      label: " Collapsible",
      section: "table",
      updateField: t
    }
  ), e.table.collapsible !== !1 && /* @__PURE__ */ m.createElement(
    Ze,
    {
      value: e.table.expanded,
      fieldName: "expanded",
      label: " Expanded by Default",
      section: "table",
      updateField: t
    }
  ), n && e.type !== "table" && /* @__PURE__ */ m.createElement(
    Ze,
    {
      value: e.table.showDataTableLink,
      fieldName: "showDataTableLink",
      label: "Show Data Table Name & Link",
      section: "table",
      updateField: t
    }
  ), a && /* @__PURE__ */ m.createElement(
    Ze,
    {
      value: e.table.showDownloadUrl,
      fieldName: "showDownloadUrl",
      label: "Show URL to Automatically Updated Data",
      section: "table",
      updateField: t
    }
  ), e.type !== "table" && /* @__PURE__ */ m.createElement(
    Ze,
    {
      value: e.table.showDownloadImgButton,
      fieldName: "showDownloadImgButton",
      label: "Display Image Button",
      section: "table",
      updateField: t
    }
  ), /* @__PURE__ */ m.createElement(
    Ze,
    {
      value: e.table.showDownloadLinkBelow,
      fieldName: "showDownloadLinkBelow",
      label: "Show Download Link Below Table",
      section: "table",
      updateField: t
    }
  ), /* @__PURE__ */ m.createElement("label", null, /* @__PURE__ */ m.createElement("span", { className: "edit-label column-heading" }, "Table Cell Min Width"), /* @__PURE__ */ m.createElement(
    "input",
    {
      type: "number",
      value: e.table.cellMinWidth ? e.table.cellMinWidth : 0,
      onChange: (b) => t("table", null, "cellMinWidth", b.target.value)
    }
  )), (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ m.createElement(
    yt,
    {
      value: e.table.groupBy,
      fieldName: "groupBy",
      section: "table",
      label: "Group By",
      updateField: (b, v, A, N) => c(N),
      initial: mm,
      options: u.filter(
        (b) => {
          var v, A;
          return b !== ((v = e.table.pivot) == null ? void 0 : v.columnName) && !(((A = e.table.pivot) == null ? void 0 : A.valueColumns) || []).includes(b);
        }
      ),
      tooltip: /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "Choose a column to use for grouping data rows. The selected column will not be shown in the data table. You will only be able to choose a column which does not have a column configuration.")))
    }
  ), /* @__PURE__ */ m.createElement(
    yt,
    {
      label: "Pivot Column",
      tooltip: /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "Select a Column whos data values will be pivoted to Column Values."))),
      value: (x = e.table.pivot) == null ? void 0 : x.columnName,
      options: u.filter(
        (b) => {
          var v;
          return b !== e.table.groupBy && !(((v = e.table.pivot) == null ? void 0 : v.valueColumns) || []).includes(b);
        }
      ),
      initial: "-Select-",
      section: "table",
      subsection: "pivot",
      fieldName: "columnName",
      updateField: t
    }
  ), ((w = e.table.pivot) == null ? void 0 : w.columnName) && /* @__PURE__ */ m.createElement("label", null, /* @__PURE__ */ m.createElement("span", { className: "edit-label column-heading mt-1" }, "Pivot Value Column(s)", /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "The column(s) whos values will be pivoted under the column selected as the Filter.")))), /* @__PURE__ */ m.createElement(
    Up,
    {
      key: (y = e.table.pivot) == null ? void 0 : y.columnName,
      options: u.filter((b) => {
        var v;
        return b !== ((v = e.table.pivot) == null ? void 0 : v.columnName) && b !== e.table.groupBy;
      }).map((b) => ({ label: b, value: b })),
      selected: (R = e.table.pivot) == null ? void 0 : R.valueColumns,
      label: "Pivot Value Column(s) ",
      section: "table",
      subsection: "pivot",
      fieldName: "valueColumns",
      updateField: t
    }
  )));
}, Yc = (e) => /* @__PURE__ */ ue.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ ue.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), _w = ({ name: e }) => {
  var c, l, p, h, g;
  const { config: t, rawData: n, updateConfig: r } = ue.useContext(mt);
  if (t.visualizationType !== "Forest Plot")
    return;
  const a = (x) => {
    x.orientation === "horizontal" && (x.labels = !1), x.table.show === void 0 && (x.table.show = !isDashboard), x.visualizationType === "Combo" && (x.orientation = "vertical");
  }, i = (x = !0) => {
    let w = {};
    return n.forEach((y) => {
      Object.keys(y).forEach((R) => w[R] = !0);
    }), x && Object.keys(w).forEach((y) => {
      (t.series && t.series.filter((R) => R.dataKey === y).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(y)) && delete w[y];
    }), Object.keys(w);
  }, u = (x, w, y, R) => {
    if (x === "boxplot" && w === "legend") {
      r({
        ...t,
        [x]: {
          ...t[x],
          [w]: {
            ...t.boxplot[w],
            [y]: R
          }
        }
      });
      return;
    }
    if (x === "boxplot" && w === "labels") {
      r({
        ...t,
        [x]: {
          ...t[x],
          [w]: {
            ...t.boxplot[w],
            [y]: R
          }
        }
      });
      return;
    }
    if (x === "forestPlot" && w) {
      let N = {
        ...t,
        [x]: {
          ...t[x],
          [w]: {
            ...t.forestPlot[w],
            [y]: R
          }
        }
      };
      r(N);
      return;
    }
    if (x === "columns" && w !== "" && y !== "") {
      r({
        ...t,
        [x]: {
          ...t[x],
          [w]: {
            ...t[x][w],
            [y]: R
          }
        }
      });
      return;
    }
    if (x === null && w === null) {
      let N = { ...t, [y]: R };
      a(N), r(N);
      return;
    }
    const b = Array.isArray(t[x]);
    let v = b ? [...t[x], R] : { ...t[x], [y]: R };
    w !== null && (b ? (v = [...t[x]], v[w] = { ...v[w], [y]: R }) : typeof R == "string" ? v[w] = R : v = { ...t[x], [w]: { ...t[x][w], [y]: R } });
    let A = { ...t, [x]: v };
    a(A), r(A);
  };
  return /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, e, (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ React.createElement(Yc, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Study Column",
      initial: "Select",
      required: !0,
      updateField: u,
      options: i(!1),
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  ), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.forestPlot.type,
      label: "Forest Plot Type",
      initial: "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            type: x.target.value
          }
        }), x.target.value = "";
      },
      options: ["Linear", "Logarithmic"],
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1.")))
    }
  ), /* @__PURE__ */ React.createElement(Ue, { type: "text", value: ((c = t.forestPlot) == null ? void 0 : c.title) || "", updateField: u, section: "forestPlot", fieldName: "title", label: "Plot Title" }), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("hr", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("h4", null, "Column Settings"), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.forestPlot.estimateField,
      label: "Point Estimate Column",
      initial: t.forestPlot.estimateField || "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            estimateField: x.target.value
          }
        }), x.target.value = "";
      },
      options: i(!1)
    }
  ), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.forestPlot.shape,
      label: "Point Estimate Shape",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            shape: x.target.value
          }
        }), x.target.value = "";
      },
      options: ["text", "circle", "square"]
    }
  ), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.forestPlot.lower,
      label: "Lower CI Column",
      required: !0,
      initial: t.forestPlot.lower || "Select",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            lower: x.target.value
          }
        }), x.target.value = "";
      },
      options: i(!1)
    }
  ), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.forestPlot.upper,
      label: "Upper CI Column",
      initial: t.forestPlot.upper || "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            upper: x.target.value
          }
        }), x.target.value = "";
      },
      options: i(!1)
    }
  ), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Pooled Result Column", /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "text",
      value: t.forestPlot.pooledResult.column || "",
      label: "Pooled Result Row",
      onChange: (x) => {
        r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            pooledResult: {
              ...t.forestPlot.pooledResult,
              column: x.target.value
            }
          }
        }), x.target.value = "";
      }
    }
  ))), /* @__PURE__ */ React.createElement(Ze, { value: ((p = (l = t.forestPlot) == null ? void 0 : l.lineOfNoEffect) == null ? void 0 : p.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: u }), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("hr", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("h4", null, "Width Settings"), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left (%)"), /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffset || 0,
      onChange: (x) => {
        r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffset: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left Mobile(%)"), /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffsetMobile || 0,
      onChange: (x) => {
        r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffsetMobile: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right (%)"), /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffset || 0,
      onChange: (x) => {
        r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffset: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right Mobile(%)"), /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffsetMobile || 0,
      onChange: (x) => {
        r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffsetMobile: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ React.createElement(Ue, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: u, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("hr", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("h4", null, "Labels Settings"), /* @__PURE__ */ React.createElement(Ue, { type: "text", value: ((h = t.forestPlot) == null ? void 0 : h.leftLabel) || "", updateField: u, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }), /* @__PURE__ */ React.createElement(Ue, { type: "text", value: ((g = t.forestPlot) == null ? void 0 : g.rightLabel) || "", updateField: u, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("hr", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.forestPlot.radius.scalingColumn,
      label: "Weight Column",
      initial: "Select",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              scalingColumn: x.target.value
            }
          }
        }), x.target.value = "";
      },
      options: i(!1)
    }
  ), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Radius Minimum Size"), /* @__PURE__ */ React.createElement(
    "input",
    {
      min: 3,
      max: 6,
      value: t.forestPlot.radius.min || 3,
      onChange: (x) => {
        r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              min: Number(x.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Radius Maximum Size"), /* @__PURE__ */ React.createElement(
    "input",
    {
      min: 7,
      max: 10,
      value: t.forestPlot.radius.max,
      onChange: (x) => {
        r({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              max: Number(x.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  ))));
}, Ki = m.createContext({}), Ow = (e) => {
  const { updateConfig: t, config: n, rawData: r } = ue.useContext(mt), { getColumns: a, selectComponent: i } = e, u = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], c = (l, p, h) => {
    let g = [...n.series];
    if (g[l][h] = p, h === "type" && p === "Bar" && (g[l].axis = "Left"), g[l].type === "Forecasting") {
      let x = Array.from(new Set(r.map((y) => y[g[l].dataKey]))), w = [];
      x.forEach((y) => {
        w.push({ key: y });
      }), g[l].stages = w, g[l].stageColumn = g[l].dataKey;
    }
    t({ ...n, series: g });
  };
  return /* @__PURE__ */ m.createElement(Ki.Provider, { value: { updateSeries: c, supportedRightAxisTypes: u, getColumns: a, selectComponent: i } }, e.children);
}, Fw = (e) => {
  const { config: t, updateConfig: n } = ue.useContext(mt), { series: r, index: a } = e;
  if (!(() => {
    let l = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart", "Bump Chart"].some((h) => h.includes(r.type)) && (l = !0), l;
  })())
    return;
  const u = (l, p) => {
    let h = [...t.series];
    h[l].lineType = p, n({ ...t, series: h });
  };
  let c = [];
  return Object.keys(ol).map((l) => c.push(ol[l])), /* @__PURE__ */ m.createElement(
    Ka,
    {
      initial: "Select an option",
      value: r.lineType ? r.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (l) => {
        u(a, l.target.value);
      },
      options: c
    }
  );
}, Mw = (e) => {
  const { config: t } = ue.useContext(mt), { updateSeries: n } = ue.useContext(Ki), { index: r, series: a } = e, i = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line" || t.visualizationType === "Bump Chart")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo", "Bump Chart"].includes(t.visualizationType))
    return /* @__PURE__ */ m.createElement(
      Ka,
      {
        initial: "Select an option",
        value: a.type,
        label: "Series Type",
        onChange: (u) => {
          n(r, u.target.value, "type");
        },
        options: i()
      }
    );
}, zw = (e) => {
  const { config: t, updateConfig: n, rawData: r } = ue.useContext(mt), { updateSeries: a, getColumns: i } = ue.useContext(Ki), { index: u, series: c } = e;
  return /* @__PURE__ */ m.createElement(
    Ka,
    {
      initial: "Select an option",
      value: c.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (l) => {
        let p = [], h = new Set(r == null ? void 0 : r.map((x) => x[l.target.value]));
        h = Array.from(h), h = h.filter((x) => x !== void 0), h.forEach((x) => p.push({ key: x }));
        const g = [...t.series];
        g[u] = { ...g[u], stages: p, stageColumn: l.target.value }, n({
          ...t,
          series: g
        });
      },
      options: i(!1)
    }
  );
}, Bw = (e) => {
  const { config: t, rawData: n } = ue.useContext(mt), { updateSeries: r } = ue.useContext(Ki), { index: a, series: i } = e;
  if (i.type !== "Forecasting" || !n || !i.stageColumn)
    return;
  let u = new Set(n.map((c) => c[i.stageColumn]));
  return u = Array.from(u), u = u.filter((c) => c !== void 0), /* @__PURE__ */ m.createElement(
    Ka,
    {
      initial: "Select an option",
      value: i.stageItem,
      label: "Forecasting Item Column",
      onChange: (c) => {
        r(a, c.target.value, "stageItem");
      },
      options: u
    }
  );
}, Iw = (e) => {
  const { config: t } = ue.useContext(mt), { updateSeries: n, supportedRightAxisTypes: r } = ue.useContext(Ki), { index: a, series: i } = e;
  if (!(t.visualizationType !== "Combo" || !i) && r.includes(i.type))
    return /* @__PURE__ */ m.createElement(
      Ka,
      {
        initial: "Select an option",
        value: i.axis ? i.axis : "Left",
        label: "Series Axis",
        onChange: (u) => {
          n(a, u.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, $w = (e) => {
  var i;
  const { config: t, updateConfig: n } = ue.useContext(mt), { index: r, series: a } = e;
  if (a.type === "Forecasting" && a)
    return (i = a == null ? void 0 : a.stages) == null ? void 0 : i.map((u, c) => {
      var l, p, h, g;
      return /* @__PURE__ */ m.createElement(
        Ka,
        {
          key: `${u}--${c}`,
          initial: "Select an option",
          value: (p = (l = t.series) == null ? void 0 : l[r].stages) != null && p[c].color ? (g = (h = t.series) == null ? void 0 : h[r].stages) == null ? void 0 : g[c].color : "Select",
          label: `${u.key} Series Color`,
          onChange: (x) => {
            const w = [...t.series], y = w[r].stages;
            y[c].color = x.target.value, w[r] = { ...w[r], stages: y }, n({
              ...t,
              series: w
            });
          },
          options: Object.keys(Gc)
        }
      );
    });
}, Hw = (e) => {
  var u;
  const { config: t, updateConfig: n } = ue.useContext(mt), { series: r, index: a } = e, { getColumns: i } = ue.useContext(Ki);
  if (r.type === "Forecasting")
    return /* @__PURE__ */ m.createElement("div", { className: "edit-block" }, /* @__PURE__ */ m.createElement("span", { className: "edit-label column-heading" }, "Confidence Interval Groups"), /* @__PURE__ */ m.createElement("fieldset", null, /* @__PURE__ */ m.createElement(Fi, { allowZeroExpanded: !0 }, (u = r == null ? void 0 : r.confidenceIntervals) == null ? void 0 : u.map((c, l) => {
      const p = c.showInTooltip ? c.showInTooltip : !1, h = (g, x, w) => {
        g.preventDefault();
        let y = [...t.series];
        y[x].confidenceIntervals[w].showInTooltip = !p, n({
          ...t,
          series: y
        });
      };
      return /* @__PURE__ */ m.createElement(Cn, { className: "series-item series-item--chart", key: `${l}` }, /* @__PURE__ */ m.createElement(An, { className: "series-item__title" }, /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(Ln, { className: "accordion__button accordion__button" }, "Group ", l + 1, /* @__PURE__ */ m.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (g) => {
            g.preventDefault();
            const x = [...t.series[a].confidenceIntervals];
            x.splice(l, 1);
            const w = [...t.series];
            w[a] = { ...w[a], confidenceIntervals: [...x] }, n({
              ...t,
              series: w
            });
          }
        },
        "Remove"
      )))), /* @__PURE__ */ m.createElement(Nn, null, /* @__PURE__ */ m.createElement("div", { className: "input-group" }, /* @__PURE__ */ m.createElement("label", { htmlFor: "showInTooltip" }, "Show In Tooltip"), /* @__PURE__ */ m.createElement(
        "div",
        {
          className: "cove-input__checkbox--small",
          onClick: (g) => h(g, a, l)
        },
        /* @__PURE__ */ m.createElement(
          "div",
          {
            className: "cove-input__checkbox-box custom-color",
            style: { backgroundColor: "" }
          },
          p && /* @__PURE__ */ m.createElement(Fm, { className: "", style: { fill: "#025eaa" } })
        ),
        /* @__PURE__ */ m.createElement(
          "input",
          {
            className: "cove-input--hidden",
            type: "checkbox",
            name: "showInTooltip",
            checked: p || !1,
            readOnly: !0
          }
        )
      )), /* @__PURE__ */ m.createElement(
        Ka,
        {
          initial: "Select an option",
          value: t.series[a].confidenceIntervals[l].low ? t.series[a].confidenceIntervals[l].low : "Select",
          label: "Low Confidence Interval",
          onChange: (g) => {
            const x = [...t.series[a].confidenceIntervals];
            x[l].low = g.target.value;
            const w = [...t.series];
            w[a] = { ...w[a], confidenceIntervals: x }, n({
              ...t,
              series: w
            });
          },
          options: i()
        }
      ), /* @__PURE__ */ m.createElement(
        Ka,
        {
          initial: "Select an option",
          value: t.series[a].confidenceIntervals[l].high ? t.series[a].confidenceIntervals[l].high : "Select",
          label: "High Confidence Interval",
          onChange: (g) => {
            const x = [...t.series[a].confidenceIntervals];
            x[l].high = g.target.value;
            const w = [...t.series];
            w[a] = { ...w[a], confidenceIntervals: x }, n({
              ...t,
              series: w
            });
          },
          options: i()
        }
      )));
    })), /* @__PURE__ */ m.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (c) => {
          c.preventDefault();
          let l = null;
          t.series[a].confidenceIntervals ? l = [...t.series[a].confidenceIntervals] : l = [];
          const p = [...t.series];
          p[a] = {
            ...p[a],
            confidenceIntervals: [...l, { high: "", low: "" }]
          }, n({
            ...t,
            series: p
          });
        }
      },
      "Add Confidence Interval Group"
    )));
}, Vw = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: a } = ue.useContext(mt);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const u = (c, l, p, h) => {
    let g = [...r.series], x = { ...r.runtime.seriesLabels };
    g[c].weight = l && Math.max(Number(p), Math.min(Number(h), Number(l))), x[g[c].dataKey] = g[c].weight ? g[c].weight : g[c].dataKey;
    const w = {
      ...r,
      series: g,
      runtime: {
        ...r.runtime,
        seriesLabels: x
      }
    };
    a(w);
  };
  return /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("label", { htmlFor: "series-weight" }, "Line Weight"), /* @__PURE__ */ m.createElement(
    "input",
    {
      type: "number",
      key: `series-weight-${n}`,
      value: t.weight ? t.weight : "",
      min: "1",
      max: "9",
      onChange: (c) => {
        u(n, c.target.value, c.target.min, c.target.max);
      }
    }
  ));
}, Ww = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: a } = ue.useContext(mt);
  if (![
    "Bump Chart",
    "Bar",
    "Line",
    "Area Chart",
    "Combo",
    "Deviation",
    "Paired",
    "Scatter",
    "dashed-sm",
    "dashed-md",
    "dashed-lg"
  ].includes(t.type))
    return;
  const u = (l, p) => {
    let h = [...r.series], g = { ...r.runtime.seriesLabels };
    h[l].name = p, g[h[l].dataKey] = h[l].name ? h[l].name : h[l].dataKey;
    let x = {
      ...r,
      series: h,
      runtime: {
        ...r.runtime,
        seriesLabels: g
      }
    };
    a(x);
  }, c = t.name !== void 0 && t.name !== t.dataKey ? t.name : t.dataKey;
  return /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("label", { htmlFor: "series-name" }, "Series Name"), /* @__PURE__ */ m.createElement(
    "input",
    {
      type: "text",
      key: `series-name-${n}`,
      value: c,
      onChange: (l) => {
        u(n, l.target.value);
      }
    }
  ));
}, jw = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: a } = ue.useContext(mt);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(r.visualizationType))
    return;
  const i = (u) => {
    let c = [...r.series];
    c[u].tooltip && c[u].tooltip, c[u].tooltip = !c[u].tooltip, a({
      ...r,
      series: c
    });
  };
  return /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("div", { className: "input-group" }, /* @__PURE__ */ m.createElement("label", { htmlFor: `series-tooltip--${n}` }, "Show In Tooltip"), /* @__PURE__ */ m.createElement("div", { className: "cove-input__checkbox--small", onClick: (u) => i(n) }, /* @__PURE__ */ m.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, t.tooltip && /* @__PURE__ */ m.createElement(Fm, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ m.createElement(
    "input",
    {
      className: "cove-input--hidden",
      type: "checkbox",
      name: `series-tooltip--${n}`,
      checked: t.tooltip ? t.tooltip : !1,
      readOnly: !0
    }
  ))));
}, Uw = (e) => {
  const { config: t, updateConfig: n } = ue.useContext(mt), { series: r, index: a } = e, i = (c) => {
    let l = [...t.series], p = -1;
    for (let h = 0; h < l.length; h++)
      if (l[h].dataKey === c) {
        p = h;
        break;
      }
    if (p !== -1) {
      l.splice(p, 1);
      let h = { ...t, series: l };
      l.length === 0 && delete h.series, n(h);
    }
    t.visualizationType === "Paired Bar" && n({
      ...t,
      series: []
    });
  }, u = (c, l, p) => {
    c.preventDefault(), i(l.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ m.createElement("button", { className: "series-list__remove", onClick: (c) => u(c, r) }, "Remove");
}, gg = (e) => {
  const { config: t } = ue.useContext(mt), { updateSeries: n, getColumns: r } = ue.useContext(Ki), { series: a, getItemStyle: i, sortableItemStyles: u, chartsWithOptions: c, index: l } = e, p = ["Bar", "Line"].includes(t.visualizationType) && t.visualizationSubType !== "Stacked" && !t.series.find((h) => h.dynamicCategory && h.dataKey !== a.dataKey);
  return /* @__PURE__ */ m.createElement(Bg, { key: a.dataKey, draggableId: `draggableFilter-${a.dataKey}`, index: l }, (h, g) => /* @__PURE__ */ m.createElement(
    "div",
    {
      key: l,
      className: g.isDragging ? "currently-dragging" : "",
      style: i(g.isDragging, h.draggableProps.style, u),
      ref: h.innerRef,
      ...h.draggableProps,
      ...h.dragHandleProps
    },
    /* @__PURE__ */ m.createElement(Fi, { allowZeroExpanded: !0 }, /* @__PURE__ */ m.createElement(Cn, { className: "series-item series-item--chart" }, /* @__PURE__ */ m.createElement(An, { className: "series-item__title" }, /* @__PURE__ */ m.createElement(
      Ln,
      {
        className: c.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow"
      },
      /* @__PURE__ */ m.createElement(Ge, { display: "move", size: 15, style: { cursor: "default" } }),
      a.dataKey,
      /* @__PURE__ */ m.createElement(Jr.Button.Remove, { series: a, index: l })
    )), c.includes(t.visualizationType) && /* @__PURE__ */ m.createElement(Nn, null, /* @__PURE__ */ m.createElement(Jr.Input.Name, { series: a, index: l }), p && /* @__PURE__ */ m.createElement(
      yt,
      {
        label: "Dynamic Category",
        value: a.dynamicCategory,
        options: ["- Select - ", ...r().filter((x) => a.dataKey !== x)],
        updateField: (x, w, y, R) => {
          R === "- Select -" && (R = ""), n(l, R, "dynamicCategory");
        },
        tooltip: /* @__PURE__ */ m.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ m.createElement(ie.Target, null, /* @__PURE__ */ m.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ m.createElement(ie.Content, null, /* @__PURE__ */ m.createElement("p", null, "This field is Optional. If you have a dynamic data series you can select the category field here. You can only add one dynamic category per visualization.")))
      }
    ), /* @__PURE__ */ m.createElement(Jr.Input.Weight, { series: a, index: l }), /* @__PURE__ */ m.createElement(Jr.Dropdown.SeriesType, { series: a, index: l }), /* @__PURE__ */ m.createElement(Jr.Dropdown.AxisPosition, { series: a, index: l }), /* @__PURE__ */ m.createElement(Jr.Dropdown.LineType, { series: a, index: l }), /* @__PURE__ */ m.createElement(Jr.Dropdown.ForecastingColor, { series: a, index: l }), /* @__PURE__ */ m.createElement(Jr.Dropdown.ConfidenceInterval, { series: a, index: l }), /* @__PURE__ */ m.createElement(Jr.Checkbox.DisplayInTooltip, { series: a, index: l }))))
  ));
}, Kw = (e) => {
  const { series: t, getItemStyle: n, sortableItemStyles: r, chartsWithOptions: a } = e;
  return t.map((i, u) => /* @__PURE__ */ m.createElement(
    gg,
    {
      getItemStyle: n,
      sortableItemStyles: r,
      chartsWithOptions: a,
      series: i,
      index: u,
      key: `series-list-${u}`
    }
  ));
}, Jr = {
  Wrapper: Ow,
  Dropdown: {
    SeriesType: Mw,
    AxisPosition: Iw,
    ConfidenceInterval: Hw,
    LineType: Fw,
    ForecastingStage: zw,
    ForecastingColumn: Bw,
    ForecastingColor: $w
  },
  Input: {
    Name: Ww,
    Weight: Vw
  },
  Checkbox: {
    DisplayInTooltip: jw
  },
  Button: {
    Remove: Uw
  },
  Item: gg,
  List: Kw
}, Yw = ue.memo(({ config: e, updateConfig: t }) => {
  let n = (l, p, h) => {
    let g = [];
    e.regions && (g = [...e.regions]), g[h][l] = p, t({ ...e, regions: g });
  }, r = (l, p, h, g, x) => n(h, g, x), a = (l) => {
    let p = [];
    e.regions && (p = [...e.regions]), p.splice(l, 1), t({ ...e, regions: p });
  }, i = () => {
    let l = [];
    e.regions && (l = [...e.regions]), l.push({}), t({ ...e, regions: l });
  };
  const u = ["Fixed", "Previous Days"], c = ["Last Date", "Fixed"];
  return /* @__PURE__ */ React.createElement(React.Fragment, null, e.regions && e.regions.map(({ label: l, color: p, from: h, to: g, background: x, range: w = "Custom" }, y) => {
    var R;
    return /* @__PURE__ */ React.createElement("div", { className: "edit-block", key: `region-${y}` }, /* @__PURE__ */ React.createElement(
      "button",
      {
        type: "button",
        className: "btn btn-danger remove-column",
        onClick: (b) => {
          b.preventDefault(), a(y);
        }
      },
      "Remove"
    ), /* @__PURE__ */ React.createElement(Ue, { value: l, label: "Region Label", fieldName: "label", i: y, updateField: r }), /* @__PURE__ */ React.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: p,
        label: "Text Color",
        fieldName: "color",
        updateField: (b, v, A, N) => n(A, N, y)
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: x,
        label: "Background",
        fieldName: "background",
        updateField: (b, v, A, N) => n(A, N, y)
      }
    )), /* @__PURE__ */ React.createElement(
      yt,
      {
        value: e.regions[y].fromType ?? "Fixed",
        label: "Minimum Region Type",
        initial: "Select",
        required: !0,
        onChange: (b) => {
          if (b.target.value !== "" && b.target.value !== "Select") {
            const v = [...e.regions];
            v[y].fromType = b.target.value, t({
              ...e,
              regions: v
            });
          }
          b.target.value = "";
        },
        options: u
      }
    ), (e.regions[y].fromType === "Fixed" || e.regions[y].fromType === "Previous Days" || !e.regions[y].fromType) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: h,
        label: e.regions[y].fromType === "Fixed" || !((R = e.regions[y]) != null && R.fromType) ? "From Value" : "Previous Number of Days",
        fieldName: "from",
        updateField: (b, v, A, N) => n(A, N, y),
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value.")))
      }
    )), /* @__PURE__ */ React.createElement(
      yt,
      {
        value: e.regions[y].toType ?? "Fixed",
        label: "Maximum Region Type",
        initial: "Select",
        required: !0,
        onChange: (b) => {
          if (b.target.value !== "" && b.target.value !== "Select") {
            const v = [...e.regions];
            v[y].toType = b.target.value, t({
              ...e,
              regions: v
            });
          }
          b.target.value = "";
        },
        options: c
      }
    ), (e.regions[y].toType === "Fixed" || !e.regions[y].toType) && /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: g,
        label: "To Value",
        fieldName: "to",
        updateField: (b, v, A, N) => n(A, N, y)
      }
    ));
  }), !e.regions && /* @__PURE__ */ React.createElement("p", { style: { textAlign: "center" } }, "There are currently no regions."), /* @__PURE__ */ React.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-primary full-width",
      onClick: (l) => {
        l.preventDefault(), i();
      }
    },
    "Add Region"
  ));
}), Gw = ({ name: e }) => {
  const { visSupportsRegions: t } = _s(), { config: n, updateConfig: r } = ue.useContext(mt);
  return t() ? /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, e)), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement(Yw, { config: n, updateConfig: r }))) : null;
}, Tp = ue.createContext(null), Rp = () => {
  const e = ue.useContext(Tp);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, Xw = (e) => {
  const { config: t } = ue.useContext(mt), { updateField: n } = Rp(), {
    enabledChartTypes: r,
    visHasNumbersOnBars: a,
    visHasaAdditionalLabelsOnBars: i,
    visHasLabelOnData: u,
    visSupportsChartHeight: c,
    visSupportsMobileChartHeight: l,
    visSupportsSuperTitle: p,
    visSupportsFootnotes: h
  } = _s(), { visualizationType: g, visualizationSubType: x, barStyle: w } = t, y = () => (g === "Bar" || g === "Deviation Bar") && x !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ React.createElement(Cn, null, " ", /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, "General")), /* @__PURE__ */ React.createElement(Nn, null, (t == null ? void 0 : t.visualizationType) !== "Sankey" && /* @__PURE__ */ React.createElement(
    yt,
    {
      value: g,
      fieldName: "visualizationType",
      label: "Chart Type",
      updateField: n,
      options: r
    }
  ), c() && t.orientation === "vertical" && /* @__PURE__ */ React.createElement("div", { className: l() ? "two-col-inputs" : "" }, /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "number",
      value: t.heights.vertical,
      section: "heights",
      fieldName: "vertical",
      label: "Chart Height",
      updateField: n,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, "˝", /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "For some visualization types, such as the Sankey diagram, it may be necessary to adjust the chart height for optimal display.")))
    }
  ), l() && t.orientation === "vertical" && /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "number",
      value: t.heights.mobileVertical,
      section: "heights",
      fieldName: "mobileVertical",
      label: "Mobile Height",
      updateField: n,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "If the chart height is not optimized for mobile, you can adjust the height for better display. Not setting a value will default to the chart height.")))
    }
  )), (g === "Bar" || g === "Combo" || g === "Area Chart") && /* @__PURE__ */ React.createElement(
    yt,
    {
      value: x || "Regular",
      fieldName: "visualizationSubType",
      label: "Chart Subtype",
      updateField: n,
      options: ["regular", "stacked"]
    }
  ), g === "Area Chart" && x === "stacked" && /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.stackedAreaChartLineType || "Linear",
      fieldName: "stackedAreaChartLineType",
      label: "Stacked Area Chart Line Type",
      updateField: n,
      options: Object.keys(ol)
    }
  ), g === "Bar" && /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.orientation || "vertical",
      fieldName: "orientation",
      label: "Orientation",
      updateField: n,
      options: ["vertical", "horizontal"]
    }
  ), g === "Deviation Bar" && /* @__PURE__ */ React.createElement(yt, { label: "Orientation", options: ["horizontal"] }), (g === "Bar" || g === "Deviation Bar") && /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.isLollipopChart ? "lollipop" : w || "flat",
      fieldName: "barStyle",
      label: "bar style",
      updateField: n,
      options: y(),
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Consider using the 'Flat' bar style when presenting data that includes '0' values.")))
    }
  ), (g === "Bar" || g === "Deviation Bar") && w === "rounded" && /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.tipRounding || "top",
      fieldName: "tipRounding",
      label: "tip rounding",
      updateField: n,
      options: ["top", "full"]
    }
  ), (g === "Bar" || g === "Deviation Bar") && w === "rounded" && /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.roundingStyle || "standard",
      fieldName: "roundingStyle",
      label: "rounding style",
      updateField: n,
      options: ["standard", "shallow", "finger"]
    }
  ), g === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.yAxis.labelPlacement || "Below Bar",
      section: "yAxis",
      fieldName: "labelPlacement",
      label: "Label Placement",
      updateField: n,
      options: ["Below Bar", "On Date/Category Axis"]
    }
  ), a() ? /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.yAxis.displayNumbersOnBar,
      section: "yAxis",
      fieldName: "displayNumbersOnBar",
      label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar",
      updateField: n
    }
  ) : u() && /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.labels,
      fieldName: "labels",
      label: "Display label on data",
      updateField: n,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Recommended set to display for Section 508 compliance."), /* @__PURE__ */ React.createElement("hr", null), /* @__PURE__ */ React.createElement("p", null, "Selecting this option will ", /* @__PURE__ */ React.createElement("i", null, " not "), ' hide the display of "zero value", "suppressed data", or "missing data" indicators on the chart (if applicable).')))
    }
  ), i() && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    Ze,
    {
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, 'Selecting this option will display a thin line slightly above the Date/Category Axis to indicate "zero value" where zero values are indicated in the Data Series.'))),
      value: t.general.showZeroValueData,
      section: "general",
      fieldName: "showZeroValueData",
      label: 'Display "Zero Data" Label',
      updateField: n
    }
  ), /* @__PURE__ */ React.createElement(
    Ze,
    {
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, t.visualizationSubType === "stacked" && /* @__PURE__ */ React.createElement("p", null, "We do not recommend using stacked vertical/horizontal bar charts for missing data. If you choose to proceed, selecting this option will display 'N/A' in the tooltip hover and data table (e.g. nothing will display in chart)."), t.visualizationSubType !== "stacked" && /* @__PURE__ */ React.createElement("p", null, "Selecting this option will display 'N/A' on the Date/Category Axis, in the tooltip hover, and in the data table to indicate missing or undefined data values."))),
      value: t.general.showMissingDataLabel,
      section: "general",
      fieldName: "showMissingDataLabel",
      label: 'Display "Missing Data" Label',
      updateField: n
    }
  ), /* @__PURE__ */ React.createElement(
    Ze,
    {
      display: t.visualizationType === "Bar" || t.visualizationType === "Combo",
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Selecting 'Remove Null Values' will hide the 'N/A' (no data indicator) when you hover over the chart."))),
      value: t.general.hideNullValue,
      section: "general",
      fieldName: "hideNullValue",
      label: 'Remove "Null" Values From Hover',
      updateField: n
    }
  ), /* @__PURE__ */ React.createElement(
    Ze,
    {
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, t.visualizationSubType !== "stacked" && /* @__PURE__ */ React.createElement("p", null, "Selecting this option will show the ", /* @__PURE__ */ React.createElement("i", null, "suppression indicator "), " on the Date/Category axis, within tooltips, and in the data table where suppressed data values appear in the Data Series."), t.visualizationSubType === "stacked" && /* @__PURE__ */ React.createElement("p", null, "We do not recommend using stacked vertical/horizontal bar charts for suppressed data. If you choose to proceed, selecting this option will display the 'suppressed data symbol' in the tooltip hover and data table (e.g., nothing will display in the chart)."))),
      value: t.general.showSuppressedSymbol,
      section: "general",
      fieldName: "showSuppressedSymbol",
      label: 'Display "suppressed data" label',
      updateField: n
    }
  )), g === "Pie" && /* @__PURE__ */ React.createElement(yt, { fieldName: "pieType", label: "Pie Chart Type", updateField: n, options: ["Regular", "Donut"] }), g === "Line" && /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.allowLineToBarGraph,
      fieldName: "allowLineToBarGraph",
      label: "Convert to Bar Graph",
      updateField: n,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Switch to bar graph when less than 3 data points available.")))
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      value: t.title || "Chart Title",
      fieldName: "title",
      id: "title",
      label: "Title",
      placeholder: "Chart Title",
      updateField: n,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Title is required to set the name of the download file but can be hidden using the option below.")))
    }
  ), /* @__PURE__ */ React.createElement(Ze, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: n }), p() && /* @__PURE__ */ React.createElement(
    Ue,
    {
      value: t.superTitle,
      updateField: n,
      fieldName: "superTitle",
      label: "Super Title",
      placeholder: "Super Title",
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Super Title")))
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "textarea",
      value: t.introText,
      updateField: n,
      fieldName: "introText",
      label: "Message",
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Intro Text")))
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "textarea",
      value: t.description,
      fieldName: "description",
      label: "Subtext/Citation",
      updateField: n,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub.")))
    }
  ), h() && /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "textarea",
      value: t.footnotes,
      updateField: n,
      fieldName: "footnotes",
      label: "Footnotes",
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data.")))
    }
  )));
}, qw = (e) => {
  const { config: t } = ue.useContext(mt), { boxplot: n } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: r } = Rp();
  return /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, e.name)), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement("h4", { style: { fontSize: "18px" } }, "Labels for 5-Number Summary"), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "text",
      value: n.labels.maximum,
      fieldName: "maximum",
      section: "boxplot",
      subsection: "labels",
      label: "Maximum",
      updateField: r,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Highest value, excluding outliers")))
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "text",
      value: n.labels.q3,
      fieldName: "q3",
      section: "boxplot",
      subsection: "labels",
      label: "Upper Quartile",
      updateField: r,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Represented by top line of box. 25% of data are higher.")))
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "text",
      value: n.labels.median,
      fieldName: "median",
      section: "boxplot",
      subsection: "labels",
      label: "Median",
      updateField: r,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Middle data point. Half of data are higher value.")))
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "text",
      value: n.labels.q1,
      fieldName: "q1",
      section: "boxplot",
      subsection: "labels",
      label: "Lower Quartile",
      updateField: r,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Represented by bottom line of box. 25% of data are lower.")))
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "text",
      value: n.labels.minimum,
      fieldName: "minimum",
      section: "boxplot",
      subsection: "labels",
      label: "Minimum",
      updateField: r,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Lowest value, excluding outliers")))
    }
  ), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("h4", { style: { fontSize: "18px" } }, "Labels for Additional Measures"), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "text",
      value: n.labels.iqr,
      fieldName: "iqr",
      section: "boxplot",
      subsection: "labels",
      label: "Interquartile Range",
      updateField: r
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "text",
      value: n.labels.count,
      fieldName: "count",
      section: "boxplot",
      subsection: "labels",
      label: "Count",
      updateField: r
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "text",
      value: n.labels.mean,
      fieldName: "mean",
      section: "boxplot",
      subsection: "labels",
      label: "Mean",
      updateField: r
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "text",
      value: n.labels.outliers,
      fieldName: "outliers",
      section: "boxplot",
      subsection: "labels",
      label: "Outliers",
      updateField: r
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "text",
      value: n.labels.values,
      fieldName: "values",
      section: "boxplot",
      subsection: "labels",
      label: "Values",
      updateField: r
    }
  )));
}, Zw = (e, t) => {
  let n = [], r = [], a = [];
  const i = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const u = e.twoColor.isPaletteReversed;
    n = Object.keys(Nu).filter(
      (c) => u ? c.endsWith("reverse") : !c.endsWith("reverse")
    );
  } else {
    const u = [], c = [];
    for (const l in Sr) {
      const p = l.startsWith("sequential"), h = l.startsWith("qualitative"), g = l.startsWith("colorblindsafe"), x = l.endsWith("reverse");
      p && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && u.push(l), h && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && c.push(l), g && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && i.push(l);
    }
    r = u, a = c;
  }
  return ue.useEffect(() => {
    let u = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (u = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (u = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: u } });
  }, [e.twoColor.isPaletteReversed]), ue.useEffect(() => {
    let u = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (u = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (u = e.palette.slice(0, -7)), t({ ...e, palette: u });
  }, [e.isPaletteReversed]), { twoColorPalettes: n, sequential: r, nonSequential: a, accessibleColors: i };
}, Qw = (e) => {
  var ne;
  const { config: t, updateConfig: n, colorPalettes: r, twoColorPalette: a } = ue.useContext(mt), { visual: i } = t, { setLollipopShape: u, updateField: c } = Rp(), {
    visHasBarBorders: l,
    visCanAnimate: p,
    visSupportsNonSequentialPallete: h,
    headerColors: g,
    visSupportsTooltipOpacity: x,
    visSupportsTooltipLines: w,
    visSupportsBarSpace: y,
    visSupportsBarThickness: R,
    visHasDataCutoff: b,
    visSupportsSequentialPallete: v,
    visSupportsReverseColorPalette: A,
    visHasSingleSeriesTooltip: N
  } = _s(), { twoColorPalettes: L, sequential: C, nonSequential: z, accessibleColors: W } = Zw(t, n), q = (G, le) => {
    if (console.log("value", le), G === "storyNodeFontColor") {
      n({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: le
        }
      });
      return;
    } else
      n({
        ...t,
        sankey: {
          ...t.sankey,
          [G]: {
            ...t.sankey[G],
            default: le
          }
        }
      });
  };
  return /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, "Visual")), /* @__PURE__ */ React.createElement(Nn, null, (t.barStyle === "lollipop" || t.isLollipopChart) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("fieldset", { className: "header" }, /* @__PURE__ */ React.createElement("legend", { className: "edit-label" }, "Lollipop Shape"), /* @__PURE__ */ React.createElement(
    "div",
    {
      onChange: (G) => {
        u(G.target.value);
      }
    },
    /* @__PURE__ */ React.createElement("label", { className: "radio-label" }, /* @__PURE__ */ React.createElement("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }), "Circle"),
    /* @__PURE__ */ React.createElement("label", { className: "radio-label" }, /* @__PURE__ */ React.createElement("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }), "Square")
  )), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone",
      fieldName: "lollipopColorStyle",
      label: "Lollipop Color Style",
      updateField: c,
      options: ["regular", "two-tone"]
    }
  ), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.lollipopSize ? t.lollipopSize : "small",
      fieldName: "lollipopSize",
      label: "Lollipop Size",
      updateField: c,
      options: ["small", "medium", "large"]
    }
  )), t.visualizationType === "Box Plot" && /* @__PURE__ */ React.createElement("fieldset", { className: "fieldset fieldset--boxplot" }, /* @__PURE__ */ React.createElement("legend", { className: "" }, "Box Plot Settings"), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.boxplot.borders,
      fieldName: "borders",
      section: "boxplot",
      label: "Box Plot Borders",
      updateField: c,
      options: ["true", "false"]
    }
  ), /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.boxplot.plotOutlierValues,
      fieldName: "plotOutlierValues",
      section: "boxplot",
      label: "Plot Outliers",
      updateField: c
    }
  ), /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.boxplot.plotNonOutlierValues,
      fieldName: "plotNonOutlierValues",
      section: "boxplot",
      label: "Plot non-outlier values",
      updateField: c
    }
  )), l() && /* @__PURE__ */ React.createElement(
    yt,
    {
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
        Ge,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Recommended set to display for Section 508 compliance."))),
      value: t.barHasBorder,
      fieldName: "barHasBorder",
      label: "Bar Borders",
      updateField: c,
      options: ["true", "false"]
    }
  ), p() && /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.animate,
      fieldName: "animate",
      label: "Animate Visualization",
      updateField: c
    }
  ), (((ne = t.series) == null ? void 0 : ne.some(
    (G) => G.type === "Line" || G.type === "dashed-lg" || G.type === "dashed-sm" || G.type === "dashed-md"
  )) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    yt,
    {
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
        Ge,
        {
          display: "question",
          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
        }
      )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Shapes will appear in the following order: circle, square, triangle, diamond, and inverted triangle. Use with a maximum of 5 data points."))),
      value: t.visual.lineDatapointSymbol,
      section: "visual",
      fieldName: "lineDatapointSymbol",
      label: "Line Datapoint Symbols",
      updateField: c,
      options: ["none", "standard"]
    }
  ), t.series.length > t.visual.maximumShapeAmount && t.visual.lineDatapointSymbol === "standard" && /* @__PURE__ */ React.createElement("small", { className: "text-danger" }, "Standard only supports up to 7 data points"), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.lineDatapointStyle,
      fieldName: "lineDatapointStyle",
      label: "Line Datapoint Style",
      updateField: c,
      options: ["hidden", "hover", "always show"]
    }
  ), /* @__PURE__ */ React.createElement(
    yt,
    {
      value: t.lineDatapointColor,
      fieldName: "lineDatapointColor",
      label: "Line Datapoint Color",
      updateField: c,
      options: ["Same as Line", "Lighter than Line"]
    }
  )), /* @__PURE__ */ React.createElement("label", { className: "header" }, /* @__PURE__ */ React.createElement("span", { className: "edit-label" }, "Header Theme"), /* @__PURE__ */ React.createElement("ul", { className: "color-palette" }, g.map((G) => /* @__PURE__ */ React.createElement(
    "button",
    {
      title: G,
      key: G,
      onClick: (le) => {
        le.preventDefault(), n({ ...t, theme: G });
      },
      className: t.theme === G ? "selected " + G : G
    }
  )))), (h() || h()) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label" }, "Chart Color Palette")), A() && /* @__PURE__ */ React.createElement(
    Mp,
    {
      fieldName: "isPaletteReversed",
      size: "small",
      label: "Use selected palette in reverse order",
      updateField: c,
      value: t.isPaletteReversed
    }
  ), v() && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", null, "Sequential"), /* @__PURE__ */ React.createElement("ul", { className: "color-palette" }, C.map((G) => {
    const le = {
      backgroundColor: r[G][2]
    }, K = {
      backgroundColor: r[G][3]
    }, re = {
      backgroundColor: r[G][5]
    };
    return /* @__PURE__ */ React.createElement(
      "button",
      {
        title: G,
        key: G,
        onClick: (B) => {
          B.preventDefault(), n({ ...t, palette: G });
        },
        className: t.palette === G ? "selected" : ""
      },
      /* @__PURE__ */ React.createElement("span", { style: le }),
      /* @__PURE__ */ React.createElement("span", { style: K }),
      /* @__PURE__ */ React.createElement("span", { style: re })
    );
  }))), h() && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", null, "Non-Sequential"), /* @__PURE__ */ React.createElement("ul", { className: "color-palette" }, z.map((G) => {
    const le = {
      backgroundColor: r[G][2]
    }, K = {
      backgroundColor: r[G][4]
    }, re = {
      backgroundColor: r[G][6]
    };
    return /* @__PURE__ */ React.createElement(
      "button",
      {
        title: G,
        key: G,
        onClick: (B) => {
          B.preventDefault(), n({ ...t, palette: G });
        },
        className: t.palette === G ? "selected" : ""
      },
      /* @__PURE__ */ React.createElement("span", { style: le }),
      /* @__PURE__ */ React.createElement("span", { style: K }),
      /* @__PURE__ */ React.createElement("span", { style: re })
    );
  })), /* @__PURE__ */ React.createElement("span", null, "Colorblind Safe"), /* @__PURE__ */ React.createElement("ul", { className: "color-palette" }, W.map((G) => {
    const le = {
      backgroundColor: r[G][2]
    }, K = {
      backgroundColor: r[G][3]
    }, re = {
      backgroundColor: r[G][5]
    };
    return /* @__PURE__ */ React.createElement(
      "button",
      {
        title: G,
        key: G,
        onClick: (B) => {
          B.preventDefault(), n({ ...t, palette: G });
        },
        className: t.palette === G ? "selected" : ""
      },
      /* @__PURE__ */ React.createElement("span", { style: le }),
      /* @__PURE__ */ React.createElement("span", { style: K }),
      /* @__PURE__ */ React.createElement("span", { style: re })
    );
  })))), t.visualizationType === "Sankey" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.nodeColor.default,
      id: "storyNodeColor",
      name: "storyNodeColor",
      onChange: (G) => q("nodeColor", G.target.value)
    }
  ), /* @__PURE__ */ React.createElement("label", { htmlFor: "storyNodeColor" }, "Story Node Color")), /* @__PURE__ */ React.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.storyNodeFontColor || "red",
      id: "storyNodeFontColor",
      name: "storyNodeFontColor",
      onChange: (G) => q("storyNodeFontColor", G.target.value)
    }
  ), /* @__PURE__ */ React.createElement("label", { htmlFor: "storyNodeFontColor" }, "Story Node Font Color")), /* @__PURE__ */ React.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "color",
      value: t.sankey.linkColor.default,
      id: "linkColor",
      name: "linkColor",
      onChange: (G) => q("linkColor", G.target.value)
    }
  ), /* @__PURE__ */ React.createElement("label", { htmlFor: "linkColor" }, "Link Color"))), (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    Mp,
    {
      section: "twoColor",
      fieldName: "isPaletteReversed",
      size: "small",
      label: "Use selected palette in reverse order",
      updateField: c,
      value: t.twoColor.isPaletteReversed
    }
  ), /* @__PURE__ */ React.createElement("ul", { className: "color-palette" }, L.map((G) => {
    const le = {
      backgroundColor: a[G][0]
    }, K = {
      backgroundColor: a[G][1]
    };
    return /* @__PURE__ */ React.createElement(
      "button",
      {
        title: G,
        key: G,
        onClick: (re) => {
          re.preventDefault(), n({ ...t, twoColor: { ...t.twoColor, palette: G } });
        },
        className: t.twoColor.palette === G ? "selected" : ""
      },
      /* @__PURE__ */ React.createElement("span", { className: "two-color", style: le }),
      /* @__PURE__ */ React.createElement("span", { className: "two-color", style: K })
    );
  }))), b() && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    Ue,
    {
      value: t.dataCutoff,
      type: "number",
      fieldName: "dataCutoff",
      className: "number-narrow",
      label: "Data Cutoff",
      updateField: c,
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.')))
    }
  )), R() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "number",
      value: t.barHeight || "25",
      fieldName: "barHeight",
      label: " Bar Thickness",
      updateField: c,
      min: 15
    }
  ), (t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ React.createElement(
    Ue,
    {
      value: t.barThickness,
      type: "number",
      fieldName: "barThickness",
      label: "Bar Thickness",
      updateField: c
    }
  ), y() && /* @__PURE__ */ React.createElement(
    Ue,
    {
      type: "number",
      value: t.barSpace || "15",
      fieldName: "barSpace",
      label: "Bar Space",
      updateField: c,
      min: 0
    }
  ), (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.topAxis.hasLine,
      section: "topAxis",
      fieldName: "hasLine",
      label: "Add Top Axis Line",
      updateField: c
    }
  ), t.visualizationType === "Spark Line" && /* @__PURE__ */ React.createElement("div", { className: "cove-accordion__panel-section checkbox-group" }, /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: i == null ? void 0 : i.border,
      section: "visual",
      fieldName: "border",
      label: "Show Border",
      updateField: c
    }
  ), /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: i == null ? void 0 : i.borderColorTheme,
      section: "visual",
      fieldName: "borderColorTheme",
      label: "Use Border Color Theme",
      updateField: c
    }
  ), /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: i == null ? void 0 : i.accent,
      section: "visual",
      fieldName: "accent",
      label: "Use Accent Style",
      updateField: c
    }
  ), /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: i == null ? void 0 : i.background,
      section: "visual",
      fieldName: "background",
      label: "Use Theme Background Color",
      updateField: c
    }
  ), /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: i == null ? void 0 : i.hideBackgroundColor,
      section: "visual",
      fieldName: "hideBackgroundColor",
      label: "Hide Background Color",
      updateField: c
    }
  )), (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.showLineSeriesLabels,
      fieldName: "showLineSeriesLabels",
      label: "Append Series Name to End of Line Charts",
      updateField: c
    }
  ), (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.colorMatchLineSeriesLabels,
      fieldName: "colorMatchLineSeriesLabels",
      label: "Match Series Color to Name at End of Line Charts",
      updateField: c
    }
  ), w() && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: i.verticalHoverLine,
      fieldName: "verticalHoverLine",
      section: "visual",
      label: "Vertical Hover Line",
      updateField: c
    }
  ), /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: i.horizontalHoverLine,
      fieldName: "horizontalHoverLine",
      section: "visual",
      label: "Horizontal Hover Line",
      updateField: c
    }
  )), x() && /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Tooltip Opacity"), /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "number",
      value: t.tooltips.opacity ? t.tooltips.opacity : 100,
      onChange: (G) => n({
        ...t,
        tooltips: {
          ...t.tooltips,
          opacity: G.target.value
        }
      })
    }
  )), N() && /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.tooltips.singleSeries,
      fieldName: "singleSeries",
      section: "tooltips",
      label: "SHOW HOVER FOR SINGLE DATA SERIES",
      updateField: c
    }
  ), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "No Data Message"), /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "text",
      value: t.chartMessage.noData ? t.chartMessage.noData : "",
      onChange: (G) => n({
        ...t,
        chartMessage: {
          ...t.chartMessage,
          noData: G.target.value
        }
      })
    }
  ))));
}, Jw = (e) => {
  var l, p, h, g, x;
  const { config: t, updateConfig: n } = ue.useContext(mt), r = (l = t.data) == null ? void 0 : l[0], { updateField: a } = ue.useContext(Tp);
  if (t.visualizationType !== "Sankey")
    return;
  const i = (w, y, R) => {
    let b = [];
    r != null && r.storyNodeText && (b = [...r == null ? void 0 : r.storyNodeText]), b[R][w] = y, n({
      ...t,
      sankey: {
        ...t.sankey,
        data: {
          ...t.sankey.data,
          storyNodeText: b
        }
      }
    });
  }, u = () => {
    const w = r;
    w.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), n({
      ...t,
      sankey: {
        ...t.sankey,
        data: [{ ...w }]
      }
    });
  }, c = (w) => {
    const y = r;
    y.storyNodeText.splice(w, 1), n({ ...t, sankey: { ...t.sankey, data: { ...y } } });
  };
  return /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, "Sankey Settings")), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement("p", null, "Node stories can provide additional details to support public health messaging. COVE can display a maximum of 3 node stories."), (r == null ? void 0 : r.storyNodeText) && (r == null ? void 0 : r.storyNodeText.map(({ StoryNode: w, segmentTextBefore: y, segmentTextAfter: R }, b) => /* @__PURE__ */ React.createElement(
    "div",
    {
      key: b,
      style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" }
    },
    /* @__PURE__ */ React.createElement("label", null, "Story Node Text", /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: w,
        fieldName: "StoryNode",
        label: "StoryNode",
        onChange: (v) => i("StoryNode", v.target.value, b)
      }
    )),
    /* @__PURE__ */ React.createElement("label", null, "Story Text Before", /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: y,
        fieldName: "segmentTextBefore",
        label: "Segment Text Before",
        onChange: (v) => i("segmentTextBefore", v.target.value, b)
      }
    )),
    /* @__PURE__ */ React.createElement("label", null, "Story Text After", /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: R,
        fieldName: "segmentTextAfter",
        label: "Segment Text After",
        onChange: (v) => i("segmentTextAfter", v.target.value, b)
      }
    )),
    /* @__PURE__ */ React.createElement(Pu, { onClick: (v) => c(b), className: "btn btn-danger full-width" }, "Remove Story Node")
  ))), ((p = r == null ? void 0 : r.storyNodeText) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ React.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-primary full-width",
      onClick: (w) => {
        w.preventDefault(), u();
      }
    },
    "Add StoryNode"
  ), ((x = (g = (h = t.data) == null ? void 0 : h[0]) == null ? void 0 : g.tooltips) == null ? void 0 : x.length) > 0 && /* @__PURE__ */ React.createElement(
    Ze,
    {
      value: t.enableTooltips,
      fieldName: "enableTooltips",
      label: "Enable Tooltips",
      updateField: a
    }
  )));
};
const eT = (e) => {
  var c, l, p;
  const { updateConfig: t, config: n, svgRef: r } = ue.useContext(mt), a = (h, g, x) => {
    var b;
    const w = (b = document.querySelector(".chart-container  > svg")) == null ? void 0 : b.getBoundingClientRect(), y = [w == null ? void 0 : w.width, w == null ? void 0 : w.height], R = [...n == null ? void 0 : n.annotations];
    R[x][g] = h, R[x].savedDimensions = y, t({
      ...n,
      annotations: R
    });
  }, i = () => {
    var w, y, R, b, v, A, N, L, C, z;
    const h = [
      ((R = (y = (w = r == null ? void 0 : r.current) == null ? void 0 : w.width) == null ? void 0 : y.baseVal) == null ? void 0 : R.value) || ((b = r == null ? void 0 : r.current) == null ? void 0 : b.width),
      ((N = (A = (v = r == null ? void 0 : r.current) == null ? void 0 : v.height) == null ? void 0 : A.baseVal) == null ? void 0 : N.value) || ((L = r == null ? void 0 : r.current) == null ? void 0 : L.height)
    ], g = {
      text: "New Annotation",
      snapToNearestPoint: !1,
      fontSize: 16,
      bezier: 10,
      show: {
        desktop: !0,
        tablet: !0,
        mobile: !0
      },
      connectorType: "line",
      colors: {
        label: "black",
        connector: "black",
        marker: "black"
      },
      selected: !0,
      anchor: {
        vertical: !1,
        horizontal: !1
      },
      marker: "arrow",
      edit: {
        subject: !0,
        label: !0
      },
      seriesKey: "",
      x: 50,
      y: Number((h == null ? void 0 : h[1]) / 2),
      xKey: n.xAxis.type === "date" ? new Date((z = (C = n == null ? void 0 : n.data) == null ? void 0 : C[0]) == null ? void 0 : z[n.xAxis.dataKey]).getTime() : n.xAxis.type === "categorical" ? "1/15/2016" : "",
      yKey: "",
      dx: 20,
      dy: -20,
      opacity: "100",
      savedDimensions: h,
      connectionType: "line"
    }, x = Array.isArray(n.annotations) ? n.annotations : [];
    t({
      ...n,
      annotations: [...x, g]
    });
  }, u = (h) => {
    const g = n.annotations.filter((x, w) => w !== h);
    t({
      ...n,
      annotations: g
    });
  };
  return /* @__PURE__ */ m.createElement(Tc, { key: e.name }, /* @__PURE__ */ m.createElement(Tc.Section, { title: e.name, key: e.name }, /* @__PURE__ */ m.createElement("label", { key: "key-1" }, "Show Annotation Dropdown", /* @__PURE__ */ m.createElement(
    "input",
    {
      type: "checkbox",
      checked: ((c = n == null ? void 0 : n.general) == null ? void 0 : c.showAnnotationDropdown) || !1,
      onChange: (h) => {
        t({
          ...n,
          general: {
            ...n.general,
            showAnnotationDropdown: h.target.checked
          }
        });
      }
    }
  )), n.general.showAnnotationDropdown && /* @__PURE__ */ m.createElement("label", { key: "key-2" }, "Annotation Dropdown Title:", /* @__PURE__ */ m.createElement(
    "input",
    {
      type: "text",
      style: { marginBottom: "10px" },
      value: (l = n == null ? void 0 : n.general) == null ? void 0 : l.annotationDropdownText,
      onChange: (h) => {
        t({
          ...n,
          general: {
            ...n.general,
            annotationDropdownText: h.target.value
          }
        });
      }
    }
  )), (n == null ? void 0 : n.annotations) && (n == null ? void 0 : n.annotations.map((h, g) => {
    var x, w, y, R, b, v, A, N;
    return /* @__PURE__ */ m.createElement(Tc, { key: g }, /* @__PURE__ */ m.createElement(
      Tc.Section,
      {
        title: h.text ? h.text.substring(0, 15) + "..." : `Annotation ${g + 1}`
      },
      /* @__PURE__ */ m.createElement("div", { className: "annotation-group" }, /* @__PURE__ */ m.createElement("label", null, "Annotation Text:", /* @__PURE__ */ m.createElement(
        "textarea",
        {
          rows: 5,
          value: h.text,
          onChange: (L) => a(L.target.value, "text", g)
        }
      )), /* @__PURE__ */ m.createElement("label", null, "Opacity", /* @__PURE__ */ m.createElement("br", null), /* @__PURE__ */ m.createElement(
        "input",
        {
          type: "range",
          onChange: (L) => {
            const C = Je.cloneDeep(n == null ? void 0 : n.annotations);
            C[g].opacity = L.target.value, t({
              ...n,
              annotations: C
            });
          },
          value: ((w = (x = n == null ? void 0 : n.annotations) == null ? void 0 : x[g]) == null ? void 0 : w.opacity) || "100"
        }
      )), /* @__PURE__ */ m.createElement("label", null, "Edit Subject", /* @__PURE__ */ m.createElement(
        "input",
        {
          type: "checkbox",
          checked: ((R = (y = n == null ? void 0 : n.annotations[g]) == null ? void 0 : y.edit) == null ? void 0 : R.subject) || !1,
          onChange: (L) => {
            const C = Je.cloneDeep(n == null ? void 0 : n.annotations);
            C[g].edit.subject = L.target.checked, t({
              ...n,
              annotations: C
            });
          }
        }
      )), /* @__PURE__ */ m.createElement("label", null, "Edit Label", /* @__PURE__ */ m.createElement(
        "input",
        {
          type: "checkbox",
          checked: ((v = (b = n == null ? void 0 : n.annotations[g]) == null ? void 0 : b.edit) == null ? void 0 : v.label) || !1,
          onChange: (L) => {
            const C = Je.cloneDeep(n == null ? void 0 : n.annotations);
            C[g].edit.label = L.target.checked, t({
              ...n,
              annotations: C
            });
          }
        }
      )), /* @__PURE__ */ m.createElement("label", null, "Connection Type:", /* @__PURE__ */ m.createElement(
        "select",
        {
          key: "annotation-connection-type",
          onChange: (L) => {
            const C = Je.cloneDeep(n == null ? void 0 : n.annotations);
            C[g].connectionType = L.target.value, t({
              ...n,
              annotations: C
            });
          },
          value: (A = n == null ? void 0 : n.annotations[g]) == null ? void 0 : A.connectionType
        },
        /* @__PURE__ */ m.createElement("option", { key: "select", value: "select" }, "Select"),
        ["curve", "line", "elbow", "none"].map((L, C) => /* @__PURE__ */ m.createElement("option", { key: L, value: L }, L))
      )), h.connectionType === "curve" && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement("label", null, "Curve Control", /* @__PURE__ */ m.createElement(
        "input",
        {
          type: "range",
          min: "-20",
          max: "20",
          value: ((N = n == null ? void 0 : n.annotations[g]) == null ? void 0 : N.bezier) || 0,
          onChange: (L) => {
            const C = Je.cloneDeep(n == null ? void 0 : n.annotations);
            C[g].bezier = L.target.value, t({
              ...n,
              annotations: C
            });
          }
        }
      ))), /* @__PURE__ */ m.createElement("label", null, "Marker", /* @__PURE__ */ m.createElement(
        "select",
        {
          key: "annotation-marker",
          value: h.marker,
          onChange: (L) => {
            const C = Je.cloneDeep(n == null ? void 0 : n.annotations);
            C[g].marker = L.target.value, t({
              ...n,
              annotations: C
            });
          }
        },
        ["arrow", "circle"].map((L, C) => /* @__PURE__ */ m.createElement("option", { key: `col-${C}` }, L))
      )), /* @__PURE__ */ m.createElement(Pu, { className: "btn btn-danger full-width", onClick: () => u(g) }, "Delete Annotation"))
    ));
  })), ((p = n == null ? void 0 : n.annotations) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ m.createElement("button", { onClick: i, className: "btn btn-primary mt-2 full-width" }, "Add Annotation")));
}, ga = {
  ForestPlot: _w,
  Series: Jr,
  Regions: Gw,
  General: Xw,
  BoxPlot: qw,
  Visual: Qw,
  Sankey: Jw,
  Annotate: eT
};
const tT = new Om(), ym = (e, t) => {
  for (let n = 0; n < e.length; n++) {
    let r = Object.keys(e[n]), a = !0;
    for (let i = 0; i < r.length; i++)
      if (e[n][r[i]] !== t[r[i]]) {
        a = !1;
        break;
      }
    if (a)
      return n;
  }
  return -1;
}, nT = (e, t, n) => {
  var a;
  const r = Je.cloneDeep(e);
  if (r.rankByValue = t, e.rankByValue && !t) {
    const i = (a = e == null ? void 0 : e.xAxis) != null && a.dataKey ? tT.cleanData(e.data, e.xAxis.dataKey) : e.data, u = n.sort((c, l) => {
      const p = ym(i, c), h = ym(i, l);
      return p - h;
    });
    return [r, u];
  }
  return [r];
}, rT = ({ config: e, updateConfig: t, data: n }) => {
  var b, v, A;
  const r = e.visualizationType === "Combo", a = ((b = e.runtime.lineSeriesKeys) == null ? void 0 : b.length) > 0, i = ((v = e.runtime.barSeriesKeys) == null ? void 0 : v.length) > 0, u = r && a, c = r && i, l = () => Je.uniq(Je.flatMap(n, Je.keys)), p = () => e.visualizationType === "Line" || u ? ["effect", "suppression"] : ["suppression"], h = {
    "Dashed Small": "- - -",
    "Dashed Medium": "– –",
    "Dashed Large": "— –",
    "Open Circles": "◯",
    "Filled Circles": ""
  }, g = (N) => {
    const L = Object.keys(h);
    return N === "suppression" ? L.slice(0, -2) : L;
  }, x = () => {
    if (e.visualizationType === "Bar" || c)
      return Object.keys(Bp);
  };
  let w = (N) => {
    let L = [];
    e.preliminaryData && (L = [...e.preliminaryData]), L.splice(N, 1), t({ ...e, preliminaryData: L });
  }, y = () => {
    const N = e.visualizationType === "Line" ? "effect" : "suppression";
    let L = e.preliminaryData ? [...e.preliminaryData] : [];
    const C = {
      type: N,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: "",
      hideBarSymbol: !1,
      hideLineStyle: !1,
      circleSize: 6,
      displayGray: !0
    };
    L.push(C), t({ ...e, preliminaryData: L });
  }, R = (N, L, C) => {
    let z = [];
    e.preliminaryData && (z = [...e.preliminaryData]), z[C][N] = L, N === "symbol" && (z[C].iconCode = Bp[L]), N === "style" && (z[C].lineCode = h[L]), t({ ...e, preliminaryData: z });
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, e.preliminaryData && ((A = e.preliminaryData) == null ? void 0 : A.map(
    ({
      displayGray: N,
      circleSize: L,
      column: C,
      displayLegend: z,
      displayTable: W,
      displayTooltip: q,
      label: ne,
      seriesKey: G,
      style: le,
      symbol: K,
      type: re,
      value: B,
      hideBarSymbol: j,
      hideLineStyle: se
    }, ee) => {
      var Q, Z;
      return /* @__PURE__ */ React.createElement("div", { key: `preliminaryData-${ee}`, className: "edit-block" }, /* @__PURE__ */ React.createElement("p", null, " ", re === "suppression" ? "Suppressed" : "Effect", " Data"), /* @__PURE__ */ React.createElement(
        "button",
        {
          type: "button",
          className: "btn btn-danger",
          onClick: (Y) => {
            Y.preventDefault(), w(ee);
          }
        },
        "Remove"
      ), /* @__PURE__ */ React.createElement(
        yt,
        {
          value: re,
          initial: e.visualizationType == "Bar" ? "" : "Select",
          fieldName: "type",
          label: "Type",
          updateField: (Y, te, $, ce) => R($, ce, ee),
          options: p()
        }
      ), re === "suppression" ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
        yt,
        {
          tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, " ", 'Without a selected "Data Series", the suppression symbol will be applied for all series in the current dataset visualization. However, choosing a specific "data series" will isolate the suppression to that series.'))),
          value: C,
          initial: "Select",
          fieldName: "column",
          label: "Add Data Series",
          updateField: (Y, te, $, ce) => R($, ce, ee),
          options: (Q = e.runtime) == null ? void 0 : Q.seriesKeys
        }
      ), /* @__PURE__ */ React.createElement(
        Ue,
        {
          value: B,
          fieldName: "value",
          label: "Suppressed Data  Value",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      ), (u || e.visualizationType === "Line") && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
        yt,
        {
          tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "The recommended approach for presenting data is to include a footnote indicating any data suppression."))),
          value: le,
          initial: "Select",
          fieldName: "style",
          label: "suppression line style",
          updateField: (Y, te, $, ce) => R($, ce, ee),
          options: g(re)
        }
      ), /* @__PURE__ */ React.createElement(
        Ze,
        {
          value: se,
          fieldName: "hideLineStyle",
          label: "Hide Suppressed line Style",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      )), (c || e.visualizationType === "Bar") && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
        yt,
        {
          tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "A symbol is ", /* @__PURE__ */ React.createElement("i", null, "required"), ' to indicate suppressed data. We suggest "double asterisks." If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'))),
          value: K,
          initial: "Select",
          fieldName: "symbol",
          label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
          updateField: (Y, te, $, ce) => R($, ce, ee),
          options: x()
        }
      ), /* @__PURE__ */ React.createElement(
        Ze,
        {
          value: j,
          fieldName: "hideBarSymbol",
          label: "Hide Suppressed Bar Symbol  ",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      )), /* @__PURE__ */ React.createElement(
        Ue,
        {
          tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "This label will display in the tooltip and legend."))),
          value: ne || "Suppressed",
          fieldName: "label",
          label: "Suppressed Data Label",
          placeholder: "",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      ), /* @__PURE__ */ React.createElement(
        Ze,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, 'Deselecting the "Display In Tooltips" option prevents suppressed values from appearing in tooltips.'))),
          value: q,
          fieldName: "displayTooltip",
          label: "Display in tooltips",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      ), /* @__PURE__ */ React.createElement(
        Ze,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.'))),
          value: z,
          fieldName: "displayLegend",
          label: "Display in legend",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      ), /* @__PURE__ */ React.createElement(
        Ze,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.'))),
          value: W,
          fieldName: "displayTable",
          label: "Display in table",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      ), /* @__PURE__ */ React.createElement(
        Ze,
        {
          display: e.visualizationSubType === "regular",
          tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Selecting this option will apply to chart, tooltip hover, legend, and data table."))),
          value: N,
          fieldName: "displayGray",
          label: "Highlight Suppressed Data In Gray",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      )) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
        yt,
        {
          value: G,
          initial: "Select",
          fieldName: "seriesKey",
          label: "ASSOCIATE TO SERIES",
          updateField: (Y, te, $, ce) => R($, ce, ee),
          options: e.runtime.lineSeriesKeys ?? ((Z = e.runtime) == null ? void 0 : Z.seriesKeys)
        }
      ), /* @__PURE__ */ React.createElement(
        yt,
        {
          value: C,
          initial: "Select",
          fieldName: "column",
          label: "COLUMN WITH CONFIGURATION VALUE",
          updateField: (Y, te, $, ce) => R($, ce, ee),
          options: l()
        }
      ), /* @__PURE__ */ React.createElement(
        Ue,
        {
          tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "If 'Filled Circles' is selected as the style, this field is optional, and the style 'Filled Circles' will apply to all points within the associated series data."))),
          value: B,
          fieldName: "value",
          label: "VALUE TO TRIGGER",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      ), /* @__PURE__ */ React.createElement(
        yt,
        {
          value: le,
          initial: "Select",
          fieldName: "style",
          label: "Style",
          updateField: (Y, te, $, ce) => R($, ce, ee),
          options: g(re)
        }
      ), le.includes("Circles") && /* @__PURE__ */ React.createElement(
        Ue,
        {
          className: "number-narrow",
          type: "number",
          value: L,
          fieldName: "circleSize",
          label: "circle size",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      ), le !== "Filled Circles" && /* @__PURE__ */ React.createElement(
        Ue,
        {
          value: ne,
          fieldName: "label",
          label: "Label",
          placeholder: "",
          updateField: (Y, te, $, ce) => R($, ce, ee)
        }
      )));
    }
  )), /* @__PURE__ */ React.createElement("button", { type: "button", onClick: y, className: "btn btn-primary full-width" }, e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line"));
}, aT = ({ config: e, updateConfig: t, display: n }) => {
  var p, h, g, x;
  const r = (p = e == null ? void 0 : e.yAxis) == null ? void 0 : p.maxValue, a = ((g = (h = e == null ? void 0 : e.yAxis) == null ? void 0 : h.categories) == null ? void 0 : g.reduce((w, y) => w + (parseFloat(y.height) || 0), 0)) || 0, i = (w) => {
    let y = [];
    e.yAxis.categories && (y = [...e.yAxis.categories]), y.splice(w, 1), t({ ...e, yAxis: { ...e.yAxis, categories: y } });
  }, u = () => {
    var b, v;
    const w = (v = (b = e.yAxis) == null ? void 0 : b.categories) == null ? void 0 : v.length, y = 0.4;
    return Ua("#ddd").darken(y * w).hex();
  }, c = () => {
    const w = e.yAxis.categories ? [...e.yAxis.categories] : [], y = {
      label: "Label " + Number(w.length + 1),
      height: "",
      color: u()
    };
    w.push(y), t({ ...e, yAxis: { ...e.yAxis, categories: w } });
  }, l = (w, y, R) => {
    let b = [];
    e.yAxis.categories && (b = [...e.yAxis.categories]), b[R][w] = y, t({ ...e, yAxis: { ...e.yAxis, categories: b } });
  };
  return n ? /* @__PURE__ */ React.createElement(React.Fragment, null, e.yAxis.type === "categorical" && ((x = e.yAxis.categories) == null ? void 0 : x.map(({ label: w, color: y, height: R }, b) => /* @__PURE__ */ React.createElement("div", { key: `preliminaryData-${b}`, className: "edit-block" }, /* @__PURE__ */ React.createElement("p", null, "Axis Category ", b + 1), /* @__PURE__ */ React.createElement(
    "button",
    {
      type: "button",
      className: "btn btn-danger",
      onClick: (v) => {
        v.preventDefault(), i(b);
      }
    },
    "Remove"
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, " ", "Category Height will be ignored for the last category. The last category will fill the rest of the axis height."))),
      type: "number",
      value: R,
      fieldName: "height",
      label: "Category Height",
      updateField: (v, A, N, L) => l(N, L, b)
    }
  ), Number(a) > Number(r) && e.yAxis.categories.length - 1 === b && /* @__PURE__ */ React.createElement("span", { style: { color: "red", display: "block", fontSize: "15px" } }, "Update Max value to show all categories"), /* @__PURE__ */ React.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ React.createElement(
    Ue,
    {
      value: y,
      fieldName: "color",
      label: "Color",
      updateField: (v, A, N, L) => l(N, L, b)
    }
  ), /* @__PURE__ */ React.createElement(
    Ue,
    {
      value: w,
      fieldName: "label",
      label: "Label",
      updateField: (v, A, N, L) => l(N, L, b)
    }
  ))))), /* @__PURE__ */ React.createElement("button", { type: "button", onClick: c, className: "btn btn-primary full-width" }, "Add Axis Category")) : /* @__PURE__ */ React.createElement(React.Fragment, null);
}, iT = () => {
  var cn, kn, Lt, gn, an, un, tr, _n, Rn, pn, zn, Bn, nr, hr, rr, Hn, ar, Kn, Yn, E, _, D, U, pe;
  const {
    config: e,
    updateConfig: t,
    tableData: n,
    transformedData: r,
    isLoading: a,
    colorScale: i,
    colorPalettes: u,
    twoColorPalette: c,
    unfilteredData: l,
    excludedData: p,
    isDashboard: h,
    setParentConfig: g,
    missingRequiredSections: x,
    isDebug: w,
    setFilteredData: y,
    lineOptions: R,
    rawData: b,
    highlight: v,
    handleShowAll: A,
    dimensions: N
  } = ue.useContext(mt), { minValue: L, maxValue: C, existPositiveValue: z, isAllLine: W } = Vu(e, l), q = { data: r, config: e }, { leftMax: ne, rightMax: G } = ug(q), {
    visHasAnchors: le,
    visHasBrushChart: K,
    visHasCategoricalAxis: re,
    visHasLegend: B,
    visHasLegendAxisAlign: j,
    visHasLegendColorCategory: se,
    visHasSelectableLegendValues: ee,
    visSupportsDateCategoryAxis: Q,
    visSupportsDateCategoryAxisLabel: Z,
    visSupportsDateCategoryAxisLine: Y,
    visSupportsDateCategoryAxisMax: te,
    visSupportsDateCategoryAxisMin: $,
    visSupportsDateCategoryAxisPadding: ce,
    visSupportsDateCategoryAxisTicks: Se,
    visSupportsDateCategoryHeight: be,
    visSupportsDateCategoryNumTicks: ve,
    visSupportsDateCategoryTickRotation: Pe,
    visSupportsDynamicSeries: Ve,
    visSupportsFilters: we,
    visSupportsLeftValueAxis: me,
    visSupportsPreliminaryData: Ce,
    visSupportsRankByValue: fe,
    visSupportsResponsiveTicks: ze,
    visSupportsValueAxisGridLines: Ie,
    visSupportsValueAxisLabels: Qe,
    visSupportsValueAxisLine: He,
    visSupportsValueAxisMax: Fe,
    visSupportsValueAxisMin: qe,
    visSupportsValueAxisTicks: We,
    visSupportsYPadding: je
  } = _s();
  ue.useEffect(() => {
    let O = [];
    e.series && (O = e.series.map((I) => ({
      ...I,
      type: e.visualizationType === "Combo" ? "Bar" : e.visualizationType ? e.visualizationType : "Bar",
      axis: "Left"
    }))), t({
      ...e,
      series: O
    });
  }, [e.visualizationType]), ue.useEffect(() => {
    e.visualizationType === "Scatter Plot" && t({
      ...e,
      xAxis: {
        ...e.xAxis,
        type: "continuous"
      }
    });
  }, []), ue.useEffect(() => {
    e.visualizationType !== "Bar" && t({ ...e, tooltips: { ...e.tooltips, singleSeries: !1 } });
  }, [e.visualizationType]);
  const { hasRightAxis: Ke } = Ep({ config: e, yMax: e.yAxis.size, data: e.data, updateConfig: t }), Te = (O, I) => ({
    ...I
  }), _e = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, at = (O) => {
    O.orientation === "horizontal" && (O.labels = !1), O.table.show === void 0 && (O.table.show = !h), O.visualizationType === "Combo" && (O.orientation = "vertical"), En(O.xAxis) && !O.xAxis.padding && (O.xAxis.padding = 0), O.visualizationType === "Line" && (O.visualizationSubType = "regular", O.barStyle = "flat", O.isLollipopChart = !1);
  }, ge = (O, I, J, xe) => {
    if (w && console.log(
      "#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue",
      O,
      I,
      J,
      xe
    ), O === "boxplot" && (I === "legend" || I === "labels")) {
      t({
        ...e,
        [O]: {
          ...e[O],
          [I]: {
            ...e.boxplot[I],
            [J]: xe
          }
        }
      });
      return;
    }
    const Be = (zt) => zt === 0 ? !0 : !!zt;
    if (O === "columns" && Be(I) && Be(J)) {
      t({
        ...e,
        columns: {
          ...e.columns,
          [I]: {
            ...e.columns[I],
            [J]: xe
          }
        }
      });
      return;
    }
    if (O === null && I === null) {
      Be(J) || console.error("fieldName is required");
      let zt = { ...e, [J]: xe };
      at(zt), t(zt);
      return;
    }
    const Xe = Array.isArray(e[O]);
    let dt = Xe ? [...e[O], xe] : { ...e[O], [J]: xe };
    Be(I) && (Xe ? (dt = [...e[O]], dt[I] = { ...dt[I], [J]: xe }) : typeof xe == "string" ? dt[I] = xe : Be(J) && (dt = { ...e[O], [I]: { ...e[O][I], [J]: xe } }));
    let Vt = { ...e, [O]: dt };
    at(Vt), t(Vt);
  }, [ft, ot] = ue.useState(!0), [it, wt] = ue.useState(!1);
  if (a)
    return null;
  const Wt = (O) => {
    t({
      ...e,
      lollipopShape: O
    });
  }, Kt = (O) => {
    let I = e.series ? [...e.series] : [], J = Array.from(new Set(r.map((Be) => Be[O]))), xe = [];
    J.forEach((Be) => {
      xe.push({ key: Be });
    }), e.visualizationType === "Forecasting" ? I.push({
      dataKey: O,
      type: e.visualizationType,
      stages: xe,
      stageColumn: O,
      axis: "Left",
      tooltip: !0
    }) : I.push({ dataKey: O, type: e.visualizationType, axis: "Left", tooltip: !0 }), t({ ...e, series: I });
  }, Mt = (O) => {
    let I = [...e.exclusions.keys];
    I.push(O);
    let J = { ...e.exclusions, keys: I };
    t({ ...e, exclusions: J });
  }, rn = (O) => {
    let I = -1, J = [...e.exclusions.keys];
    for (let xe = 0; xe < J.length; xe++)
      if (J[xe] === O) {
        I = xe;
        break;
      }
    if (I !== -1) {
      J.splice(I, 1);
      let xe = { ...e.exclusions, keys: J }, Be = { ...e, exclusions: xe };
      J.length === 0 && delete Be.exclusions.keys, t(Be);
    }
  }, Et = (O = !0) => {
    let I = {};
    if (l.forEach((J) => {
      Object.keys(J).forEach((xe) => I[xe] = !0);
    }), O) {
      const { lower: J, upper: xe } = e.confidenceKeys || {};
      Object.keys(I).forEach((Be) => {
        (e.series && e.series.filter((Xe) => Xe.dataKey === Be).length > 0 || e.confidenceKeys && Object.keys(e.confidenceKeys).includes(Be) && (J && xe || J || xe) && Be !== J && Be !== xe) && delete I[Be];
      });
    }
    return Object.keys(I);
  }, Pt = (O) => {
    const I = [];
    switch (O) {
      case "style":
        I.push("circles", "boxes"), e.visualizationType === "Bar" && (!["right", "left"].includes(e.legend.position) || !e.legend.position) && I.push("gradient"), e.visualizationType === "Line" && I.push("lines");
        break;
      case "subStyle":
        e.visualizationType === "Bar" ? I.push("linear blocks") : I.push("linear blocks", "smooth");
        break;
    }
    return I;
  }, Nt = (O) => {
    if (!O)
      return [];
    const I = /* @__PURE__ */ new Set();
    for (let J = 0; J < O.length; J++)
      for (const [xe] of Object.entries(O[J]))
        I.add(xe);
    return Array.from(I);
  }, tn = (O, I = !1) => {
    let J = [];
    return p.forEach((xe) => {
      J.push(xe[O]);
    }), I ? [...new Set(J)] : J;
  }, sn = () => {
    ot(!ft), t({
      ...e,
      showEditorPanel: !ft
    });
  }, Ot = () => {
    let O = JSON.parse(JSON.stringify(e));
    return x(e) === !1 && delete O.newViz, delete O.runtime, O;
  };
  ue.useEffect(() => {
    if (g) {
      const O = Ot();
      g(O);
    }
  }, [e]), ue.useEffect(() => {
    const O = e.xAxis.anchors.length > 0 ? e.xAxis.anchors : [], I = e.yAxis.anchors.length > 0 ? e.yAxis.anchors : [];
    t({
      ...e,
      xAxis: {
        ...e.xAxis,
        anchors: I
      },
      yAxis: {
        ...e.yAxis,
        anchors: O
      }
    });
  }, [e.orientation]), ue.useEffect(() => {
    e.visualizationType === "Paired Bar" && t({
      ...e,
      orientation: "horizontal"
    });
  }, []), ue.useEffect(() => {
    e.orientation === "horizontal" && t({
      ...e,
      lollipopShape: e.lollipopShape
    });
  }, [e.isLollipopChart, e.lollipopShape]), ue.useEffect(() => {
    e.visualizationType === "Deviation Bar" && t({ ...e, orientation: "horizontal" });
  }, [e.visualizationType]);
  const Ft = ue.useCallback(() => {
    const O = [...e.exclusions.keys];
    return /* @__PURE__ */ React.createElement("ul", { className: "series-list" }, O.map((I, J) => /* @__PURE__ */ React.createElement("li", { key: I }, /* @__PURE__ */ React.createElement("div", { className: "series-list__name", "data-title": I }, /* @__PURE__ */ React.createElement("div", { className: "series-list__name--text" }, I)), /* @__PURE__ */ React.createElement("button", { className: "series-list__remove", onClick: () => rn(I) }, "×"))));
  }, [e]), nn = (O, I) => {
    let J = e.series, [xe] = J.splice(O, 1);
    J.splice(I, 0, xe), t({ ...e, series: J });
  };
  e.isLollipopChart && ((cn = e == null ? void 0 : e.series) == null ? void 0 : cn.length) > 1 && (e.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), e.visualizationType === "Paired Bar" && ((kn = e == null ? void 0 : e.series) == null ? void 0 : kn.length) !== 2 && (e.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), e.visualizationType === "Deviation Bar" && ((Lt = e == null ? void 0 : e.series) == null ? void 0 : Lt.length) !== 1 && (e.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), e.isLollipopChart && ((gn = e == null ? void 0 : e.series) == null ? void 0 : gn.length) === 0 && (e.runtime.editorErrorMessage = "Add a data series");
  const et = e.orientation === "horizontal" ? "xAxis" : "yAxis", [ut, Ne] = ue.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), De = () => {
    const O = e[et].max, I = e[et].rightMax;
    let J = "", xe = "";
    if (e.visualizationType !== "Combo")
      switch (!0) {
        case (O && parseFloat(O) < parseFloat(C) && z):
          J = "Max value must be more than " + C;
          break;
        case (O && parseFloat(O) < 0 && !z):
          J = "Value must be more than or equal to 0";
          break;
        default:
          J = "";
      }
    if (e.visualizationType === "Combo")
      switch (!0) {
        case (O && parseFloat(O) < ne):
          J = "Max value must be more than " + ne;
          break;
        case (I && parseFloat(I) < G):
          xe = "Max value must be more than " + G;
          break;
        case (O && parseFloat(O) < 0 && !z):
          J = "Value must be more than or equal to 0";
          break;
        default:
          J = "";
      }
    Ne((Be) => ({ ...Be, maxMsg: J, rightMaxMessage: xe }));
  }, Ee = () => {
    const O = parseFloat(e[et].min);
    let I = Number(L), J = "";
    switch (!0) {
      case (e.useLogScale && ["Line", "Combo", "Bar"].includes(e.visualizationType) && O < 0):
        J = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((e.visualizationType === "Line" || e.visualizationType === "Spark Line") && O > I):
        J = "Value should not exceed " + L;
        break;
      case (e.visualizationType === "Combo" && W && O > I):
        J = "Value should not exceed " + L;
        break;
      case ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && !W) && I > 0 && O > 0):
        J = e.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (e.visualizationType === "Deviation Bar" && O >= Math.min(I, e.xAxis.target)):
        J = "Value must be less than " + Math.min(I, e.xAxis.target);
        break;
      case (e.visualizationType !== "Deviation Bar" && O && I < 0 && O > I):
        J = "Value should not exceed " + L;
        break;
      default:
        J = "";
    }
    Ne((xe) => ({ ...xe, minMsg: J }));
  };
  ue.useEffect(() => {
    Ee(), De();
  }, [L, C, e]);
  const pt = ((an = e == null ? void 0 : e.dataKey) == null ? void 0 : an.includes("http://")) || ((un = e == null ? void 0 : e.dataKey) == null ? void 0 : un.includes("https://")), nt = () => {
    var O, I;
    if (w !== void 0 && w && !((O = e == null ? void 0 : e.xAxis) != null && O.dataKey)) {
      let J = Et(!1);
      if (J.includes("Date"))
        return "Date";
      if (J.includes("Race"))
        return "Race";
      if (J.includes("Month"))
        return "Month";
    }
    return ((I = e == null ? void 0 : e.xAxis) == null ? void 0 : I.dataKey) || "";
  }, gt = () => {
    if (w !== void 0 && w && Et(!1).length > 0) {
      let O = Et(!1).filter((I) => I !== nt());
      if (O.length > 0)
        return O[0];
    }
    return "";
  };
  if (w && !e.xAxis.dataKey && (e.xAxis.dataKey = nt()), w && ((tr = e == null ? void 0 : e.series) == null ? void 0 : tr.length) === 0) {
    let O = gt();
    O !== "" && Kt(O), w && console.log("### COVE DEBUG: Chart: Setting default datacol=", O);
  }
  const xt = [
    "Bump Chart",
    "Area Chart",
    "Combo",
    "Line",
    "Bar",
    "Forecasting",
    "Scatter Plot",
    "Paired Bar",
    "Deviation Bar"
  ], Yt = [
    /* @__PURE__ */ React.createElement("option", { value: "", key: "Select Option" }, "- Select Option -")
  ];
  if (e.data && e.series) {
    Object.keys(((_n = e.data) == null ? void 0 : _n[0]) || []).map((I) => {
      const J = e == null ? void 0 : e.series.some((xe) => xe.dataKey === I);
      if (I !== e.xAxis.dataKey && !J)
        return Yt.push(
          /* @__PURE__ */ React.createElement("option", { value: I, key: I }, I)
        );
    });
    let O = {};
    e.data.forEach((I) => {
      Object.keys(I).forEach((J) => {
        O[J] = O[J] || [];
        const xe = typeof I[J] == "number" ? I[J].toString() : I[J];
        O[J].indexOf(xe) === -1 && O[J].push(xe);
      });
    });
  }
  if (!e.data && r) {
    if (!r[0])
      return;
    Object.keys(r[0]).map((I) => {
      const J = r.some((xe) => xe.dataKey === I);
      if (I !== e.xAxis.dataKey && !J)
        return Yt.push(
          /* @__PURE__ */ React.createElement("option", { value: I, key: I }, I)
        );
    });
    let O = {};
    r.forEach((I) => {
      Object.keys(I).forEach((J) => {
        O[J] = O[J] || [];
        const xe = typeof I[J] == "number" ? I[J].toString() : I[J];
        O[J].indexOf(xe) === -1 && O[J].push(xe);
      });
    });
  }
  const lt = (O) => {
    const I = Je.cloneDeep(e.columns);
    delete I[O], t({
      ...e,
      columns: I
    });
  }, st = async (O, I, J) => {
    switch (I) {
      case "name":
        t({
          ...e,
          columns: {
            ...e.columns,
            [O]: {
              ...e.columns[O],
              [I]: J
            }
          }
        });
        break;
      default:
        t({
          ...e,
          columns: {
            ...e.columns,
            [O]: {
              ...e.columns[O],
              [I]: J
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: $t,
    highlightedSeriesValues: jt,
    handleUpdateHighlightedBar: Rt,
    handleAddNewHighlightedBar: St,
    handleRemoveHighlightedBar: yn,
    handleUpdateHighlightedBarColor: vn,
    handleHighlightedBarLegendLabel: wn,
    handleUpdateHighlightedBorderWidth: Pn
  } = Hu(e, t), Tn = e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1, er = () => {
    const O = r.map((I) => I[e.legend.colorCode]);
    return Tn ? O : Et(!1).filter((I) => I !== e.xAxis.dataKey);
  }, Dn = (O) => {
    t({ ...e, legend: { ...e.legend, seriesHighlight: O } });
  }, xn = (O, I, J) => {
    var Xe;
    const xe = { ...e[O], [I]: J }, Be = { ...e, [O]: xe };
    J === "highlight" && ((Xe = e.legend.seriesHighlight) != null && Xe.length) && (Be.legend.seriesHighlight.length = 0), t(Be);
  }, At = (O, I, J) => {
    const xe = { ...e.xAxis[O] };
    xe[I] = J;
    const Be = { ...e, xAxis: { ...e.xAxis, [O]: xe } };
    t(Be);
  }, Ht = ![void 0, "- Select - "].includes((pn = (Rn = e.series) == null ? void 0 : Rn[0]) == null ? void 0 : pn.dynamicCategory), bn = ((zn = e.series) == null ? void 0 : zn.length) > 1, Qt = {
    addNewExclusion: Mt,
    data: r,
    editColumn: st,
    getColumns: Et,
    getDataValueOptions: Nt,
    getDataValues: tn,
    getItemStyle: Te,
    handleSeriesChange: nn,
    handleAddNewHighlightedBar: St,
    setCategoryAxis: nt,
    updateField: ge,
    warningMsg: ut,
    highlightedBarValues: $t,
    handleHighlightedBarLegendLabel: wn,
    handleUpdateHighlightedBar: Rt,
    handleRemoveHighlightedBar: yn,
    isPaletteReversed: e.isPaletteReversed,
    highlightedSeriesValues: jt,
    handleUpdateHighlightedBorderWidth: Pn,
    handleUpdateHighlightedBarColor: vn,
    setLollipopShape: Wt
  };
  return /* @__PURE__ */ React.createElement(Tp.Provider, { value: Qt }, /* @__PURE__ */ React.createElement(Vr, { component: "EditorPanel" }, /* @__PURE__ */ React.createElement(
    hf.Sidebar,
    {
      displayPanel: ft,
      isDashboard: h,
      title: "Configure Chart",
      onBackClick: sn
    },
    /* @__PURE__ */ React.createElement(Fi, { allowZeroExpanded: !0 }, /* @__PURE__ */ React.createElement(ga.General, { name: "General" }), /* @__PURE__ */ React.createElement(ga.ForestPlot, { name: "Forest Plot Settings" }), /* @__PURE__ */ React.createElement(ga.Sankey, { name: "Sankey" }), e.visualizationType !== "Pie" && e.visualizationType !== "Forest Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, "Data Series", " ", (!e.series || e.series.length === 0 || e.visualizationType === "Paired Bar" && e.series.length < 2) && !e.dynamicSeries && /* @__PURE__ */ React.createElement(Yc, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ React.createElement(Nn, null, e.dynamicSeries && e.visualizationType === "Line" && /* @__PURE__ */ React.createElement(
      yt,
      {
        fieldName: "dynamicSeriesType",
        value: e.dynamicSeriesType,
        label: "Series Type",
        initial: "Select",
        updateField: ge,
        options: ["Line", "dashed-sm", "dashed-md", "dashed-lg"]
      }
    ), e.dynamicSeries && e.visualizationType === "Line" && e.dynamicSeriesType === "Line" && /* @__PURE__ */ React.createElement(
      yt,
      {
        fieldName: "dynamicSeriesLineType",
        value: e.dynamicSeriesLineType ? e.dynamicSeriesLineType : "curveLinear",
        label: "Line Type",
        initial: "Select",
        updateField: ge,
        options: Object.keys(ol).map((O) => ol[O])
      }
    ), (!Ve() || !e.dynamicSeries) && /* @__PURE__ */ React.createElement(React.Fragment, null, (!e.series || e.series.length === 0) && !e.dynamicSeries && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ React.createElement("p", { className: "warning" }, "At least one series is required"), (!e.series || e.series.length === 0 || e.series.length < 2) && e.visualizationType === "Paired Bar" && /* @__PURE__ */ React.createElement("p", { className: "warning" }, "Select two data series for paired bar chart (e.g., Male and Female)."), /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      yt,
      {
        fieldName: "visualizationType",
        label: "Add Data Series",
        initial: "Select",
        onChange: (O) => {
          O.target.value !== "" && O.target.value !== "Select" && Kt(O.target.value), O.target.value = "";
        },
        options: Et()
      }
    ), e.series && e.series.length !== 0 && /* @__PURE__ */ React.createElement(ga.Series.Wrapper, { getColumns: Et }, /* @__PURE__ */ React.createElement("fieldset", null, /* @__PURE__ */ React.createElement("legend", { className: "edit-label float-left" }, "Displaying"), /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "A data series is a set of related data points plotted in a chart and typically represented in the chart legend.")))), /* @__PURE__ */ React.createElement(
      Ig,
      {
        onDragEnd: ({ source: O, destination: I }) => nn(O.index, I.index)
      },
      /* @__PURE__ */ React.createElement($g, { droppableId: "filter_order" }, (O) => /* @__PURE__ */ React.createElement("ul", { ...O.droppableProps, className: "series-list", ref: O.innerRef }, /* @__PURE__ */ React.createElement(
        ga.Series.List,
        {
          series: e.series,
          getItemStyle: Te,
          sortableItemStyles: _e,
          chartsWithOptions: xt
        }
      ), O.placeholder))
    ))), (e.series && e.series.length && e.visualizationType === "Bar" || e.series && e.series.length <= 1 && e.visualizationType === "Line") && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", { className: "divider-heading" }, "Confidence Keys"), /* @__PURE__ */ React.createElement(
      yt,
      {
        value: e.confidenceKeys.upper || "",
        section: "confidenceKeys",
        fieldName: "upper",
        label: "Upper",
        updateField: ge,
        initial: "Select",
        options: Et()
      }
    ), /* @__PURE__ */ React.createElement(
      yt,
      {
        value: e.confidenceKeys.lower || "",
        section: "confidenceKeys",
        fieldName: "lower",
        label: "Lower",
        updateField: ge,
        initial: "Select",
        options: Et()
      }
    )), fe() && e.series && e.series.length === 1 && /* @__PURE__ */ React.createElement(
      yt,
      {
        value: e.rankByValue,
        fieldName: "rankByValue",
        label: "Rank by Value",
        initial: "Select",
        updateField: (O, I, J, xe) => {
          const [Be, Xe] = nT(e, xe, r);
          t(Be, Xe);
        },
        options: ["asc", "desc"]
      }
    ), Ce() && /* @__PURE__ */ React.createElement(rT, { config: e, updateConfig: t, data: r })))), /* @__PURE__ */ React.createElement(ga.BoxPlot, { name: "Measures" }), me() && /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, e.visualizationType === "Pie" ? "Data Format" : e.orientation === "vertical" ? "Left Value Axis" : "Value Axis", e.visualizationType === "Pie" && !e.yAxis.dataKey && /* @__PURE__ */ React.createElement(Yc, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ React.createElement(Nn, null, e.visualizationType === "Pie" && /* @__PURE__ */ React.createElement(
      yt,
      {
        value: e.yAxis.dataKey || "",
        section: "yAxis",
        fieldName: "dataKey",
        label: "Data Column",
        initial: "Select",
        required: !0,
        updateField: ge,
        options: Et(!1),
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Select the source data to be visually represented.")))
      }
    ), e.visualizationType !== "Pie" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label" }, "Axis Type", /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, "Select 'Numeric (Linear Scale)' for uniform scaling, 'Numeric (Logarithmic Scale)' for exponential data, or 'Categorical' for discrete categories."))), /* @__PURE__ */ React.createElement(
      "select",
      {
        value: e.yAxis.type,
        onChange: (O) => t({
          ...e,
          yAxis: {
            ...e.yAxis,
            type: O.target.value
          }
        })
      },
      /* @__PURE__ */ React.createElement("option", { value: "linear" }, "Numeric (Linear Scale)"),
      e.visualizationSubType !== "stacked" && /* @__PURE__ */ React.createElement("option", { value: "logarithmic" }, "Numeric (Logarithmic Scale)"),
      e.orientation !== "horizontal" && /* @__PURE__ */ React.createElement("option", { value: "categorical" }, "Categorical")
    )), /* @__PURE__ */ React.createElement(
      aT,
      {
        config: e,
        updateConfig: t,
        data: r,
        display: re()
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        display: !re(),
        value: e.yAxis.label,
        section: "yAxis",
        fieldName: "label",
        label: "Label",
        updateField: ge,
        maxLength: 35,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "35 character limit")))
      }
    ), e.runtime.seriesKeys && e.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(e.visualizationType) && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.isLegendValue,
        fieldName: "isLegendValue",
        label: "Use Legend Value in Hover",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        display: !re(),
        value: e.yAxis.numTicks,
        placeholder: "Auto",
        type: "number",
        section: "yAxis",
        fieldName: "numTicks",
        label: "Number of ticks",
        className: "number-narrow",
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used."))),
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.yAxis.size,
        type: "number",
        section: "yAxis",
        fieldName: "size",
        label: e.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, `Increase the size if elements in the ${e.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.`)))
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        display: !re(),
        value: e.yAxis.labelOffset,
        section: "yAxis",
        fieldName: "labelOffset",
        label: "Label offset",
        type: "number",
        className: "number-narrow",
        updateField: ge
      }
    ), e.orientation === "horizontal" && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.isResponsiveTicks,
        fieldName: "isResponsiveTicks",
        label: "Use Responsive Ticks",
        updateField: ge
      }
    ), (e.orientation === "vertical" || !e.isResponsiveTicks) && /* @__PURE__ */ React.createElement(
      Ue,
      {
        display: !re(),
        value: e.yAxis.tickRotation || 0,
        type: "number",
        min: 0,
        section: "yAxis",
        fieldName: "tickRotation",
        label: "Tick rotation (Degrees)",
        className: "number-narrow",
        updateField: ge
      }
    ), e.isResponsiveTicks && e.orientation === "horizontal" && /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.maxTickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "maxTickRotation",
        label: "Max Tick Rotation",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
      }
    ), Ie() && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.yAxis.gridLines,
        section: "yAxis",
        fieldName: "gridLines",
        label: "Show Gridlines",
        updateField: ge
      }
    ), Ie() && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.yAxis.labelsAboveGridlines,
        section: "yAxis",
        fieldName: "labelsAboveGridlines",
        label: "Tick labels above gridlines",
        updateField: ge,
        disabled: !e.yAxis.gridLines,
        title: e.yAxis.gridLines ? "" : "Show gridlines to enable"
      }
    ), je() && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.yAxis.enablePadding,
        section: "yAxis",
        fieldName: "enablePadding",
        label: "Add Padding to Value Axis Scale",
        updateField: ge
      }
    ), e.yAxis.enablePadding && je() && /* @__PURE__ */ React.createElement(
      Ue,
      {
        type: "number",
        section: "yAxis",
        fieldName: "scalePadding",
        label: "Padding Percentage",
        className: "number-narrow",
        updateField: ge,
        value: e.yAxis.scalePadding
      }
    )), /* @__PURE__ */ React.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.dataFormat.commas,
        section: "dataFormat",
        fieldName: "commas",
        label: "Add commas",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Selecting this option will add commas to the left value axis, tooltip hover, and data table.")))
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: !re(),
        value: e.dataFormat.abbreviated,
        section: "dataFormat",
        fieldName: "abbreviated",
        label: "Abbreviate Axis Values",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.dataFormat.roundTo ? e.dataFormat.roundTo : 0,
        type: "number",
        section: "dataFormat",
        fieldName: "roundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: ge,
        min: 0
      }
    ), " ", /* @__PURE__ */ React.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.dataFormat.prefix,
        section: "dataFormat",
        fieldName: "prefix",
        label: "Prefix",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ React.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ React.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.dataFormat.suffix,
        section: "dataFormat",
        fieldName: "suffix",
        label: "Suffix",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ React.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ React.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    )), e.orientation === "horizontal" ? (
      // horizontal - x is vertical y is horizontal
      /* @__PURE__ */ React.createElement(React.Fragment, null, He() && /* @__PURE__ */ React.createElement(
        Ze,
        {
          value: e.xAxis.hideAxis,
          section: "xAxis",
          fieldName: "hideAxis",
          label: "Hide Axis",
          updateField: ge
        }
      ), Qe() && /* @__PURE__ */ React.createElement(
        Ze,
        {
          value: e.xAxis.hideLabel,
          section: "xAxis",
          fieldName: "hideLabel",
          label: "Hide Tick Labels",
          updateField: ge
        }
      ), We() && /* @__PURE__ */ React.createElement(
        Ze,
        {
          value: e.xAxis.hideTicks,
          section: "xAxis",
          fieldName: "hideTicks",
          label: "Hide Ticks",
          updateField: ge
        }
      ), Fe() && /* @__PURE__ */ React.createElement(
        Ue,
        {
          value: e.xAxis.max,
          section: "xAxis",
          fieldName: "max",
          label: "max value",
          type: "number",
          placeholder: "Auto",
          updateField: ge
        }
      ), /* @__PURE__ */ React.createElement("span", { style: { color: "red", display: "block" } }, ut.maxMsg), qe() && /* @__PURE__ */ React.createElement(
        Ue,
        {
          value: e.xAxis.min,
          section: "xAxis",
          fieldName: "min",
          type: "number",
          label: "min value",
          placeholder: "Auto",
          updateField: ge
        }
      ), /* @__PURE__ */ React.createElement("span", { style: { color: "red", display: "block" } }, ut.minMsg), e.visualizationType === "Deviation Bar" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
        Ue,
        {
          value: e.xAxis.target,
          section: "xAxis",
          fieldName: "target",
          type: "number",
          label: "Deviation point",
          placeholder: "Auto",
          updateField: ge
        }
      ), /* @__PURE__ */ React.createElement(
        Ue,
        {
          value: e.xAxis.targetLabel || "Target",
          section: "xAxis",
          fieldName: "targetLabel",
          type: "text",
          label: "Deviation point Label",
          updateField: ge
        }
      ), /* @__PURE__ */ React.createElement(
        Ze,
        {
          value: e.xAxis.showTargetLabel,
          section: "xAxis",
          fieldName: "showTargetLabel",
          label: "Show Deviation point label",
          updateField: ge
        }
      )))
    ) : e.visualizationType !== "Pie" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: !re(),
        value: e.dataFormat.onlyShowTopPrefixSuffix,
        section: "dataFormat",
        fieldName: "onlyShowTopPrefixSuffix",
        label: "Only Show Top Prefix/Suffix",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: !re(),
        value: e.yAxis.hideAxis,
        section: "yAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: !re(),
        value: e.yAxis.hideLabel,
        section: "yAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: !re(),
        value: e.yAxis.hideTicks,
        section: "yAxis",
        fieldName: "hideTicks",
        label: "Hide Ticks",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.yAxis.max,
        section: "yAxis",
        fieldName: "max",
        type: "number",
        label: "left axis max value",
        placeholder: "Auto",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement("span", { style: { color: "red", display: "block" } }, ut.maxMsg), e.visualizationType !== "Area Chart" && e.visualizationSubType !== "stacked" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.yAxis.min,
        section: "yAxis",
        fieldName: "min",
        type: "number",
        label: "left axis min value",
        placeholder: "Auto",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement("span", { style: { color: "red", display: "block" } }, ut.minMsg))), le() && e.orientation !== "horizontal" && /* @__PURE__ */ React.createElement("div", { className: "edit-block" }, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ React.createElement(Fi, { allowZeroExpanded: !0 }, (nr = (Bn = e.yAxis) == null ? void 0 : Bn.anchors) == null ? void 0 : nr.map((O, I) => /* @__PURE__ */ React.createElement(Cn, { className: "series-item series-item--chart", key: `yaxis-anchors-2-${I}` }, /* @__PURE__ */ React.createElement(An, { className: "series-item__title" }, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Ln, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ React.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (J) => {
          J.preventDefault();
          const xe = [...e.yAxis.anchors];
          xe.splice(I, 1), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: xe
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", null, "Anchor Value"), /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: e.yAxis.anchors[I].value ? e.yAxis.anchors[I].value : "",
        onChange: (J) => {
          J.preventDefault();
          const xe = [...e.yAxis.anchors];
          xe[I].value = J.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: xe
            }
          });
        }
      }
    )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", null, "Anchor Color"), /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: e.yAxis.anchors[I].color ? e.yAxis.anchors[I].color : "",
        onChange: (J) => {
          J.preventDefault();
          const xe = [...e.yAxis.anchors];
          xe[I].color = J.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: xe
            }
          });
        }
      }
    )), /* @__PURE__ */ React.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ React.createElement(
      "select",
      {
        value: e.yAxis.anchors[I].lineStyle || "",
        onChange: (J) => {
          const xe = [...e.yAxis.anchors];
          xe[I].lineStyle = J.target.value, t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: xe
            }
          });
        }
      },
      /* @__PURE__ */ React.createElement("option", null, "Select"),
      R.map((J) => /* @__PURE__ */ React.createElement("option", { key: J.key }, J.value))
    )))))), /* @__PURE__ */ React.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.yAxis.anchors];
          I.push({}), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )), le() && e.orientation === "horizontal" && /* @__PURE__ */ React.createElement("div", { className: "edit-block" }, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ React.createElement(Fi, { allowZeroExpanded: !0 }, (rr = (hr = e.xAxis) == null ? void 0 : hr.anchors) == null ? void 0 : rr.map((O, I) => /* @__PURE__ */ React.createElement(Cn, { className: "series-item series-item--chart", key: `xaxis-anchors-${I}` }, /* @__PURE__ */ React.createElement(An, { className: "series-item__title" }, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Ln, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ React.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (J) => {
          J.preventDefault();
          const xe = [...e.xAxis.anchors];
          xe.splice(I, 1), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: xe
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", null, "Anchor Value"), /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].value ? e.xAxis.anchors[I].value : "",
        onChange: (J) => {
          J.preventDefault();
          const xe = [...e.xAxis.anchors];
          xe[I].value = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: xe
            }
          });
        }
      }
    )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", null, "Anchor Color"), /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].color ? e.xAxis.anchors[I].color : "",
        onChange: (J) => {
          J.preventDefault();
          const xe = [...e.xAxis.anchors];
          xe[I].color = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: xe
            }
          });
        }
      }
    )), /* @__PURE__ */ React.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ React.createElement(
      "select",
      {
        value: e.xAxis.anchors[I].lineStyle || "",
        onChange: (J) => {
          const xe = [...e.xAxis.anchors];
          xe[I].lineStyle = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: xe
            }
          });
        }
      },
      /* @__PURE__ */ React.createElement("option", null, "Select"),
      R.map((J) => /* @__PURE__ */ React.createElement("option", { key: J.key }, J.value))
    )))))), /* @__PURE__ */ React.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.xAxis.anchors];
          I.push({}), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )))), Ke && /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, "Right Value Axis")), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.yAxis.rightLabel,
        section: "yAxis",
        fieldName: "rightLabel",
        label: "Label",
        updateField: ge,
        maxLength: 35,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "35 character limit")))
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.yAxis.rightNumTicks,
        placeholder: "Auto",
        type: "number",
        section: "yAxis",
        fieldName: "rightNumTicks",
        label: "Number of ticks",
        className: "number-narrow",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.yAxis.rightAxisSize,
        type: "number",
        section: "yAxis",
        fieldName: "rightAxisSize",
        label: "Size (Width)",
        className: "number-narrow",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.yAxis.rightLabelOffsetSize,
        type: "number",
        section: "yAxis",
        fieldName: "rightLabelOffsetSize",
        label: "Label Offset",
        className: "number-narrow",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.dataFormat.rightCommas,
        section: "dataFormat",
        fieldName: "rightCommas",
        label: "Add commas",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.dataFormat.rightRoundTo,
        type: "number",
        section: "dataFormat",
        fieldName: "rightRoundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: ge,
        min: 0
      }
    ), /* @__PURE__ */ React.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.dataFormat.rightPrefix,
        section: "dataFormat",
        fieldName: "rightPrefix",
        label: "Prefix",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ React.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ React.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.dataFormat.rightSuffix,
        section: "dataFormat",
        fieldName: "rightSuffix",
        label: "Suffix",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ React.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ React.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    )), /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.yAxis.rightHideAxis,
        section: "yAxis",
        fieldName: "rightHideAxis",
        label: "Hide Axis",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.yAxis.rightHideLabel,
        section: "yAxis",
        fieldName: "rightHideLabel",
        label: "Hide Tick Labels",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.yAxis.rightHideTicks,
        section: "yAxis",
        fieldName: "rightHideTicks",
        label: "Hide Ticks",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.yAxis.max,
        section: "yAxis",
        fieldName: "rightMax",
        type: "number",
        label: "right axis max value",
        placeholder: "Auto",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement("span", { style: { color: "red", display: "block" } }, ut.rightMaxMessage), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.yAxis.min,
        section: "yAxis",
        fieldName: "rightMin",
        type: "number",
        label: "right axis min value",
        placeholder: "Auto",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement("span", { style: { color: "red", display: "block" } }, ut.minMsg))), Q() && /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, e.visualizationType === "Pie" ? "Segments" : "Date/Category Axis", !e.xAxis.dataKey && /* @__PURE__ */ React.createElement(Yc, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ React.createElement(Nn, null, e.visualizationType !== "Pie" && /* @__PURE__ */ React.createElement(React.Fragment, null, e.visualizationType !== "Forest Plot" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label" }, "Data Scaling Type", /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, "Linear scales are employed for quantitative data, while time scales are used for time-series data."))), /* @__PURE__ */ React.createElement(
      "select",
      {
        value: e.xAxis.type,
        onChange: (O) => t({
          ...e,
          xAxis: {
            ...e.xAxis,
            type: O.target.value
          }
        })
      },
      e.visualizationType !== "Bump Chart" && /* @__PURE__ */ React.createElement("option", { value: "categorical" }, "Categorical (Linear Scale)"),
      e.visualizationType !== "Bump Chart" && /* @__PURE__ */ React.createElement("option", { value: "date" }, "Date (Linear Scale)"),
      /* @__PURE__ */ React.createElement("option", { value: "date-time" }, "Date (Date Time Scale)"),
      e.visualizationType === "Scatter Plot" && /* @__PURE__ */ React.createElement("option", { value: "continuous" }, "Continuous")
    )), /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.xAxis.manual,
        section: "xAxis",
        fieldName: "manual",
        label: "Manual Ticks",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: e.xAxis.type !== "categorical",
        value: e.xAxis.sortByRecentDate,
        section: "xAxis",
        fieldName: "sortByRecentDate",
        label: "Show dates newest to oldest",
        updateField: ge
      }
    ), ce() && /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.padding,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "padding",
        label: "Padding (Percent)",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified.")))
      }
    )), /* @__PURE__ */ React.createElement(
      yt,
      {
        value: e.xAxis.dataKey || nt() || "",
        section: "xAxis",
        fieldName: "dataKey",
        label: "Data Key",
        initial: "Select",
        required: !0,
        updateField: ge,
        options: Et(!1),
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
      }
    )), e.visualizationType === "Pie" && /* @__PURE__ */ React.createElement(
      yt,
      {
        value: e.xAxis.dataKey || "",
        section: "xAxis",
        fieldName: "dataKey",
        label: "Segment Labels",
        initial: "Select",
        required: !0,
        updateField: ge,
        options: Et(!1),
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."')))
      }
    ), e.visualizationType !== "Pie" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.label,
        section: "xAxis",
        fieldName: "label",
        label: "Label",
        updateField: ge,
        maxLength: 35,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "35 character limit")))
      }
    ), e.xAxis.type === "continuous" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.dataFormat.bottomPrefix,
        section: "dataFormat",
        fieldName: "bottomPrefix",
        label: "Prefix",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.dataFormat.bottomSuffix,
        section: "dataFormat",
        fieldName: "bottomSuffix",
        label: "Suffix",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.dataFormat.bottomAbbreviated,
        section: "dataFormat",
        fieldName: "bottomAbbreviated",
        label: "Abbreviate Axis Values",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
      }
    )), En(e.xAxis) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" } }, "Format how charts should parse and display your dates using", " ", /* @__PURE__ */ React.createElement("a", { href: "https://d3js.org/d3-time-format#locale_format", target: "_blank", rel: "noreferrer" }, "these guidelines"), "."), /* @__PURE__ */ React.createElement(
      Ue,
      {
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed.", " "))),
        value: e.xAxis.dateParseFormat,
        section: "xAxis",
        fieldName: "dateParseFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "Date Parse Format",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, " ", "Adjusts the date display format on the axis for clear, visual date representation."))),
        value: e.xAxis.dateDisplayFormat,
        section: "xAxis",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "AXIS DATE DISPLAY FORMAT",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format.", " "))),
        value: e.table.dateDisplayFormat,
        section: "table",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "DATA TABLE DATE DISPLAY FORMAT",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format.", " "))),
        value: e.tooltips.dateDisplayFormat,
        section: "tooltips",
        fieldName: "dateDisplayFormat",
        placeholder: "Ex. %Y-%m-%d",
        label: "HOVER DATE DISPLAY FORMAT",
        updateField: ge
      }
    )), /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.exclusions.active,
        section: "exclusions",
        fieldName: "active",
        label: e.xAxis.type === "date" || e.xAxis.type === "date-time" ? "Limit by start and/or end dates" : "Exclude one or more values",
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "When this option is checked, you can select source-file values for exclusion from the date/category axis.", " "))),
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.xAxis.showYearsOnce,
        section: "xAxis",
        fieldName: "showYearsOnce",
        label: "Show years once",
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "When this option is checked and the date format for the axis includes years, each year will only be shown once in the axis."))),
        updateField: ge
      }
    ), K() && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: (Hn = e.brush) == null ? void 0 : Hn.active,
        section: "brush",
        fieldName: "active",
        label: "Brush Slider ",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Use the brush slider to narrow down your data view to specific values along the axis. This tool is useful for examining detailed data segments within the larger dataset.", " ")))
      }
    ), e.exclusions.active && /* @__PURE__ */ React.createElement(React.Fragment, null, e.xAxis.type === "categorical" && /* @__PURE__ */ React.createElement(React.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("fieldset", null, /* @__PURE__ */ React.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ React.createElement(Ft, null)), /* @__PURE__ */ React.createElement(
      yt,
      {
        fieldName: "visualizationType",
        label: "Add Exclusion",
        initial: "Select",
        onChange: (O) => {
          O.target.value !== "" && O.target.value !== "Select" && Mt(O.target.value), O.target.value = "";
        },
        options: tn(e.xAxis.dataKey, !0)
      }
    )), e.xAxis.type === "date" || e.xAxis.type === "date-time" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Ue,
      {
        type: "date",
        section: "exclusions",
        fieldName: "dateStart",
        label: "Start Date",
        updateField: ge,
        value: e.exclusions.dateStart || ""
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        type: "date",
        section: "exclusions",
        fieldName: "dateEnd",
        label: "End Date",
        updateField: ge,
        value: e.exclusions.dateEnd || ""
      }
    ))), ve() && e.xAxis.type !== "date-time" && e.xAxis.manual && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.manualStep,
        placeholder: "Auto",
        type: "number",
        min: 1,
        section: "xAxis",
        fieldName: "manualStep",
        label: "Step count",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc.")))
      }
    ), /* @__PURE__ */ React.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement(
      "button",
      {
        onClick: () => wt(!it),
        className: "edit-label"
      },
      "Step Count: viewport overrides",
      " ",
      /* @__PURE__ */ React.createElement("span", { style: { transform: `rotate(${it ? "90deg" : "0deg"})` } }, ">")
    )), it && /* @__PURE__ */ React.createElement("div", { className: "edit-block" }, Object.keys(Cp).map((O) => /* @__PURE__ */ React.createElement(
      Ue,
      {
        key: `viewport-step-count-input-${O}`,
        value: e.xAxis.viewportStepCount ? e.xAxis.viewportStepCount[O] : void 0,
        placeholder: "Auto",
        type: "number",
        label: O,
        className: "number-narrow",
        updateField: (I, J, xe, Be) => At("viewportStepCount", O, Be)
      }
    ))))), ve() && (e.xAxis.type === "date-time" || !e.xAxis.manual) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.numTicks,
        placeholder: "Auto",
        type: "number",
        min: 1,
        section: "xAxis",
        fieldName: "numTicks",
        label: "Number of ticks",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.')))
      }
    ), /* @__PURE__ */ React.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement(
      "button",
      {
        onClick: () => wt(!it),
        className: "edit-label"
      },
      "Number of ticks: viewport overrides",
      " ",
      /* @__PURE__ */ React.createElement("span", { style: { transform: `rotate(${it ? "90deg" : "0deg"})` } }, ">")
    )), it && /* @__PURE__ */ React.createElement("div", { className: "edit-block" }, Object.keys(Cp).map((O) => /* @__PURE__ */ React.createElement(
      Ue,
      {
        key: `viewport-num-ticks-input-${O}`,
        value: e.xAxis.viewportNumTicks ? e.xAxis.viewportNumTicks[O] : void 0,
        placeholder: "Auto",
        type: "number",
        label: O,
        className: "number-narrow",
        updateField: (I, J, xe, Be) => At("viewportNumTicks", O, Be)
      }
    ))))), be() && /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.size,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "size",
        label: e.orientation === "horizontal" ? "Size (Width)" : "Size (Height)",
        className: "number-narrow",
        updateField: ge
      }
    ), e.orientation === "horizontal" && /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.labelOffset,
        section: "xAxis",
        fieldName: "labelOffset",
        label: "Label offset",
        type: "number",
        className: "number-narrow",
        updateField: ge
      }
    ), (e.xAxis.type === "continuous" || e.forestPlot.type === "Logarithmic") && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.dataFormat.bottomCommas,
        section: "dataFormat",
        fieldName: "bottomCommas",
        label: "Add commas",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.dataFormat.bottomRoundTo,
        type: "number",
        section: "dataFormat",
        fieldName: "bottomRoundTo",
        label: "Round to decimal point",
        className: "number-narrow",
        updateField: ge,
        min: 0
      }
    )), ze() && e.orientation === "vertical" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.isResponsiveTicks,
        fieldName: "isResponsiveTicks",
        label: "Use Responsive Ticks",
        updateField: ge
      }
    ), (e.orientation === "horizontal" || !e.isResponsiveTicks) && Pe() && /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.tickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "tickRotation",
        label: "Tick rotation (Degrees)",
        className: "number-narrow",
        updateField: ge
      }
    ), e.orientation === "vertical" && e.isResponsiveTicks && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.maxTickRotation,
        type: "number",
        min: 0,
        section: "xAxis",
        fieldName: "maxTickRotation",
        label: "Max Tick Rotation",
        className: "number-narrow",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
      }
    ), e.orientation === "horizontal" ? /* @__PURE__ */ React.createElement(React.Fragment, null, Y() && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.yAxis.hideAxis,
        section: "yAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: ge
      }
    ), Z() && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.yAxis.hideLabel,
        section: "yAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: ge
      }
    )) : /* @__PURE__ */ React.createElement(React.Fragment, null, Y() && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.xAxis.hideAxis,
        section: "xAxis",
        fieldName: "hideAxis",
        label: "Hide Axis",
        updateField: ge
      }
    ), Z() && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.xAxis.hideLabel,
        section: "xAxis",
        fieldName: "hideLabel",
        label: "Hide Tick Labels",
        updateField: ge
      }
    ), Se() && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.xAxis.hideTicks,
        section: "xAxis",
        fieldName: "hideTicks",
        label: "Hide Ticks",
        updateField: ge
      }
    )), ((ar = e.series) == null ? void 0 : ar.length) === 1 && e.visualizationType === "Bar" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("label", { htmlFor: "barHighlight" }, "Bar Highlighting"), e.series.length === 1 && $t.map((O, I) => /* @__PURE__ */ React.createElement("fieldset", null, /* @__PURE__ */ React.createElement("div", { className: "edit-block", key: `highlighted-bar-${I}` }, /* @__PURE__ */ React.createElement("button", { className: "btn btn-danger", onClick: (J) => yn(J, I) }, "Remove"), /* @__PURE__ */ React.createElement("p", null, "Highlighted Bar ", I + 1), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Value"), /* @__PURE__ */ React.createElement(
      "select",
      {
        value: e.highlightedBarValues[I].value,
        onChange: (J) => Rt(J, I)
      },
      /* @__PURE__ */ React.createElement("option", { value: "" }, "- Select Value -"),
      jt && [...new Set(jt)].sort().map((J) => /* @__PURE__ */ React.createElement("option", { key: `special-class-value-option-${I}-${J}` }, J))
    )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Color"), /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: e.highlightedBarValues[I].color ? e.highlightedBarValues[I].color : "",
        onChange: (J) => vn(J, I)
      }
    )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Border Width"), /* @__PURE__ */ React.createElement(
      "input",
      {
        max: "5",
        min: "0",
        type: "number",
        value: e.highlightedBarValues[I].borderWidth ? e.highlightedBarValues[I].borderWidth : "",
        onChange: (J) => Pn(J, I)
      }
    )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Legend Label"), /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: e.highlightedBarValues[I].legendLabel ? e.highlightedBarValues[I].legendLabel : "",
        onChange: (J) => wn(J, I)
      }
    ))))), /* @__PURE__ */ React.createElement("button", { className: "btn btn-primary full-width", onClick: (O) => St(O) }, "Add Highlighted Bar"))), e.visualizationType === "Pie" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.exclusions.active,
        section: "exclusions",
        fieldName: "active",
        label: "Exclude one or more values",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "When this option is checked, you can select values for exclusion from the pie segments.")))
      }
    ), e.exclusions.active && /* @__PURE__ */ React.createElement(React.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("fieldset", null, /* @__PURE__ */ React.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ React.createElement(Ft, null)), /* @__PURE__ */ React.createElement(
      yt,
      {
        fieldName: "visualizationType",
        label: "Add Exclusion",
        initial: "Select",
        onChange: (O) => {
          O.target.value !== "" && O.target.value !== "Select" && Mt(O.target.value), O.target.value = "";
        },
        options: tn(e.xAxis.dataKey, !0)
      }
    ))), $() && /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.min,
        section: "xAxis",
        fieldName: "min",
        type: "number",
        label: "min value",
        placeholder: "Auto",
        updateField: ge
      }
    ), te() && /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.xAxis.max,
        section: "xAxis",
        fieldName: "max",
        type: "number",
        label: "max value",
        placeholder: "Auto",
        updateField: ge
      }
    ), le() && e.orientation !== "horizontal" && /* @__PURE__ */ React.createElement("div", { className: "edit-block" }, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ React.createElement(Fi, { allowZeroExpanded: !0 }, (Yn = (Kn = e.xAxis) == null ? void 0 : Kn.anchors) == null ? void 0 : Yn.map((O, I) => /* @__PURE__ */ React.createElement(Cn, { className: "series-item series-item--chart", key: `xaxis-anchors-2-${I}` }, /* @__PURE__ */ React.createElement(An, { className: "series-item__title" }, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Ln, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ React.createElement(
      "button",
      {
        className: "series-list__remove",
        onClick: (J) => {
          J.preventDefault();
          const xe = [...e.xAxis.anchors];
          xe.splice(I, 1), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: xe
            }
          });
        }
      },
      "Remove"
    )))), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", null, "Anchor Value"), /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].value ? e.xAxis.anchors[I].value : "",
        onChange: (J) => {
          J.preventDefault();
          const xe = [...e.xAxis.anchors];
          xe[I].value = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: xe
            }
          });
        }
      }
    )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", null, "Anchor Color"), /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "text",
        value: e.xAxis.anchors[I].color ? e.xAxis.anchors[I].color : "",
        onChange: (J) => {
          J.preventDefault();
          const xe = [...e.xAxis.anchors];
          xe[I].color = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: xe
            }
          });
        }
      }
    )), /* @__PURE__ */ React.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ React.createElement(
      "select",
      {
        value: e.xAxis.anchors[I].lineStyle || "",
        onChange: (J) => {
          const xe = [...e.xAxis.anchors];
          xe[I].lineStyle = J.target.value, t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: xe
            }
          });
        }
      },
      /* @__PURE__ */ React.createElement("option", null, "Select"),
      R.map((J) => /* @__PURE__ */ React.createElement("option", { key: J.key }, J.value))
    )))))), /* @__PURE__ */ React.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.xAxis.anchors];
          I.push({}), t({
            ...e,
            xAxis: {
              ...e.xAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )), le() && e.orientation === "horizontal" && /* @__PURE__ */ React.createElement("div", { className: "edit-block" }, /* @__PURE__ */ React.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ React.createElement(Fi, { allowZeroExpanded: !0 }, (_ = (E = e.yAxis) == null ? void 0 : E.anchors) == null ? void 0 : _.map((O, I) => /* @__PURE__ */ React.createElement(
      Cn,
      {
        className: "series-item series-item--chart",
        key: `accordion-yaxis-anchors-${I}`
      },
      /* @__PURE__ */ React.createElement(An, { className: "series-item__title" }, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Ln, { className: "accordion__button accordion__button" }, "Anchor ", I + 1, /* @__PURE__ */ React.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (J) => {
            J.preventDefault();
            const xe = [...e.yAxis.anchors];
            xe.splice(I, 1), t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: xe
              }
            });
          }
        },
        "Remove"
      )))),
      /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", null, "Anchor Value"), /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ React.createElement(
        "input",
        {
          type: "text",
          value: e.yAxis.anchors[I].value ? e.yAxis.anchors[I].value : "",
          onChange: (J) => {
            J.preventDefault();
            const xe = [...e.yAxis.anchors];
            xe[I].value = J.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: xe
              }
            });
          }
        }
      )), /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", null, "Anchor Color"), /* @__PURE__ */ React.createElement(
        "input",
        {
          type: "text",
          value: e.yAxis.anchors[I].color ? e.yAxis.anchors[I].color : "",
          onChange: (J) => {
            J.preventDefault();
            const xe = [...e.yAxis.anchors];
            xe[I].color = J.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: xe
              }
            });
          }
        }
      )), /* @__PURE__ */ React.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ React.createElement(
        "select",
        {
          value: e.yAxis.anchors[I].lineStyle || "",
          onChange: (J) => {
            const xe = [...e.yAxis.anchors];
            xe[I].lineStyle = J.target.value, t({
              ...e,
              yAxis: {
                ...e.yAxis,
                anchors: xe
              }
            });
          }
        },
        /* @__PURE__ */ React.createElement("option", null, "Select"),
        R.map((J) => /* @__PURE__ */ React.createElement("option", { key: J.key }, J.value))
      )))
    ))), /* @__PURE__ */ React.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = [...e.yAxis.anchors];
          I.push({}), t({
            ...e,
            yAxis: {
              ...e.yAxis,
              anchors: I
            }
          });
        }
      },
      "Add Anchor"
    )))), /* @__PURE__ */ React.createElement(ga.Regions, { name: "Regions" }), e.visualizationType !== "Box Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, "Columns")), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement(Pw, { config: e, updateField: ge, deleteColumn: lt }), " ")), B() && /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, "Legend")), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement(
      yt,
      {
        value: (D = e.legend) == null ? void 0 : D.position,
        section: "legend",
        fieldName: "position",
        label: "Position",
        updateField: ge,
        options: ["right", "left", "bottom", "top"]
      }
    ), (e.legend.position === "left" || e.legend.position === "right" || !e.legend.position) && e.legend.style === "gradient" && /* @__PURE__ */ React.createElement("span", { style: { color: "red", fontSize: "14px" } }, "Position must be set to top or bottom to use gradient style."), /* @__PURE__ */ React.createElement(
      yt,
      {
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "If using gradient style, limit the legend to five items for better mobile visibility, and position the legend at the top or bottom."))),
        display: !e.legend.hide,
        value: e.legend.style,
        section: "legend",
        fieldName: "style",
        label: "Legend Style",
        updateField: ge,
        options: Pt("style")
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Choose option Shapes in Line Datapoint Symbols to display."))),
        display: !e.legend.hide && e.legend.style === "lines",
        value: e.legend.hasShape,
        section: "legend",
        fieldName: "hasShape",
        label: "Shapes",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      yt,
      {
        display: !e.legend.hide && e.legend.style === "gradient",
        value: e.legend.subStyle,
        section: "legend",
        fieldName: "subStyle",
        label: "Gradient Style",
        updateField: ge,
        options: Pt("subStyle")
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        display: e.legend.style === "gradient" && !e.legend.hide,
        className: "number-narrow",
        type: "number",
        value: e.legend.tickRotation,
        section: "legend",
        fieldName: "tickRotation",
        label: "Tick Rotation (Degrees)",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: (U = e.preliminaryData) == null ? void 0 : U.some((O) => O.label && O.type === "suppression" && O.value),
        value: e.legend.hideSuppressedLabels,
        section: "legend",
        fieldName: "hideSuppressedLabels",
        label: "Hide Suppressed Labels",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.`)))
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: (pe = e.preliminaryData) == null ? void 0 : pe.some((O) => O.label && O.type === "suppression" && O.value),
        value: e.legend.hideSuppressionLink,
        section: "legend",
        fieldName: "hideSuppressionLink",
        label: "Hide Suppression Definition Link",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Selecting this option will hide the suppression definition link from display.")))
      }
    ), /* @__PURE__ */ React.createElement(
      yt,
      {
        display: Ht || bn,
        value: e.legend.behavior,
        section: "legend",
        fieldName: "behavior",
        label: "Legend Behavior (When clicked)",
        updateField: (...[O, , I, J]) => xn(O, I, J),
        options: ["highlight", "isolate"]
      }
    ), /* @__PURE__ */ React.createElement(
      yt,
      {
        display: se(),
        value: e.legend.colorCode,
        section: "legend",
        fieldName: "colorCode",
        label: "Color code by category",
        initial: "Select",
        updateField: ge,
        options: Nt(r)
      }
    ), j() && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.legend.axisAlign,
        fieldName: "axisAlign",
        section: "legend",
        label: "Align to Axis on Isolate",
        updateField: ge
      }
    ), e.legend.behavior === "highlight" && e.tooltips.singleSeries && /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: e.legend.highlightOnHover,
        section: "legend",
        fieldName: "highlightOnHover",
        label: "HIGHLIGHT DATA SERIES ON HOVER",
        updateField: ge
      }
    ), ee && e.legend.behavior === "isolate" && !Tn && /* @__PURE__ */ React.createElement("fieldset", { className: "primary-fieldset edit-block", key: "additional-highlight-values" }, /* @__PURE__ */ React.createElement("label", null, /* @__PURE__ */ React.createElement("span", { className: "edit-label" }, "Isolate Data Series", /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(Ge, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend."))))), e.legend.seriesHighlight && e.legend.seriesHighlight.map((O, I) => /* @__PURE__ */ React.createElement("fieldset", { className: "edit-block", key: `${O}-${I}` }, /* @__PURE__ */ React.createElement(
      "button",
      {
        className: "btn btn-danger",
        onClick: (J) => {
          J.preventDefault();
          const xe = [...e.legend.seriesHighlight];
          xe.splice(I, 1), ge("legend", null, "seriesHighlight", xe), xe.length || A();
        }
      },
      "Remove"
    ), /* @__PURE__ */ React.createElement(
      yt,
      {
        value: e.legend.seriesHighlight[I],
        fieldName: "seriesHighlight",
        label: "Isolate Value",
        onChange: (J) => {
          const xe = [...e.legend.seriesHighlight];
          xe.includes(J.target.value) || (xe[I] = J.target.value, Dn([...xe]));
        },
        options: er()
      }
    ))), /* @__PURE__ */ React.createElement(
      "button",
      {
        className: "btn btn-primary full-width",
        onClick: (O) => {
          O.preventDefault();
          const I = er(), J = [...e.legend.seriesHighlight];
          if (J.length < I.length) {
            const [Be] = I.filter((Xe) => !J.includes(Xe));
            J.push(Be), Dn([...J]);
          }
        }
      },
      "Add Isolate Value"
    )), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: !e.legend.hide && e.legend.style !== "gradient",
        value: e.legend.reverseLabelOrder,
        section: "legend",
        fieldName: "reverseLabelOrder",
        label: "Reverse Labels",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: !e.legend.hide,
        value: ["left", "right"].includes(e.legend.position) ? e.legend.hideBorder.side : e.legend.hideBorder.topBottom,
        section: "legend",
        subsection: "hideBorder",
        fieldName: ["left", "right"].includes(e.legend.position) ? "side" : "topBottom",
        label: "Hide Legend Box",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "Default option for top and bottom legends is ‘No Box.’.")))
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: !e.legend.hide && !["left", "right"].includes(e.legend.position) && e.legend.style !== "gradient",
        value: e.legend.singleRow,
        section: "legend",
        fieldName: "singleRow",
        label: "Single Row Legend",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        display: ["bottom", "top"].includes(e.legend.position) && !e.legend.hide && e.legend.style !== "gradient" && !e.legend.singleRow && !e.legend.singleRow,
        value: e.legend.verticalSorted,
        section: "legend",
        fieldName: "verticalSorted",
        label: "Vertical sorted Legend",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ze,
      {
        value: !!e.legend.hide,
        section: "legend",
        fieldName: "hide",
        label: "Hide Legend",
        updateField: ge,
        tooltip: /* @__PURE__ */ React.createElement(ie, { style: { textTransform: "none" } }, /* @__PURE__ */ React.createElement(ie.Target, null, /* @__PURE__ */ React.createElement(
          Ge,
          {
            display: "question",
            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
          }
        )), /* @__PURE__ */ React.createElement(ie.Content, null, /* @__PURE__ */ React.createElement("p", null, "With a single-series chart, consider hiding the legend to reduce visual clutter.")))
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        value: e.legend.label,
        section: "legend",
        fieldName: "label",
        label: "Title",
        updateField: ge
      }
    ), /* @__PURE__ */ React.createElement(
      Ue,
      {
        type: "textarea",
        value: e.legend.description,
        updateField: ge,
        section: "legend",
        fieldName: "description",
        label: "Legend Description"
      }
    ))), we() && /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, "Filters")), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement(Hg, { config: e, updateField: ge, rawData: b }))), /* @__PURE__ */ React.createElement(ga.Visual, { name: "Visual" }), e.visualizationType !== "Spark Line" && /* @__PURE__ */ React.createElement(Cn, null, /* @__PURE__ */ React.createElement(An, null, /* @__PURE__ */ React.createElement(Ln, null, "Data Table")), /* @__PURE__ */ React.createElement(Nn, null, /* @__PURE__ */ React.createElement(
      Dw,
      {
        config: e,
        columns: Object.keys(r[0] || {}),
        updateField: ge,
        isDashboard: h,
        isLoadedFromUrl: pt
      }
    ), " ")), /* @__PURE__ */ React.createElement(ga.Annotate, { name: "Text Annotations" })),
    e.type !== "Spark Line" && /* @__PURE__ */ React.createElement(Vg, { loadConfig: t, config: e, convertStateToConfig: Ot })
  )));
}, gm = (e) => {
  let t = "", n = Math.abs(e);
  return n >= 1e9 ? (t = "B", e = e / 1e9) : n >= 1e6 ? (t = "M", e = e / 1e6) : n >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, ds = (e, t) => {
  var n;
  return e ? (n = e.legend) != null && n.hide ? e != null && e.title ? `dataTableSection__${e.title.replace(/\s/g, "")}` : "dataTableSection" : t : "dataTableSection";
}, oT = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], vm = (e) => typeof e == "string" ? parseFloat(e.replace(/,/g, "")) : Number(e), lT = (e, t) => {
  if (t.rankByValue) {
    const n = t.series[0].dataKey, r = e.sort((a, i) => vm(a[n]) - vm(i[n]));
    return t.rankByValue === "asc" ? r : r.reverse();
  }
  return e;
}, xm = (e = "#000000", t = !1) => {
  let n = Ua(e), r = t ? n.brighten(0.5).hex() : n.saturate(1.3).hex();
  return [e, r, n.darken(0.3).hex()];
}, sT = ue.createContext({ displayName: "ConfigContext", setTempConfig: () => {
} }), UT = ue.createContext(() => {
}), cT = (e, t) => {
  const { allowLineToBarGraph: n, formattedData: r, series: a, visualizationType: i, xAxis: u } = e;
  if (!n)
    return !1;
  const c = i === "Line" && (t == null ? void 0 : t.length) < 3, p = (a == null ? void 0 : a.some((h) => h.dynamicCategory)) && Je.uniq(r == null ? void 0 : r.map((h) => h[u.dataKey])).length <= 2;
  return c || p;
}, uT = (e, t) => {
  const n = t, r = Je.uniq(Je.map(n, e.xAxis.dataKey)), a = Je.map(e.series, "dataKey"), i = [];
  r.forEach((c) => {
    a.forEach((l) => {
      try {
        if (!c)
          throw new Error("No groups resolved in box plots");
        const { count: p, sortedData: h } = Je.chain(n).filter((v) => v[e.xAxis.dataKey] === c).thru((v) => ({
          count: v.length,
          sortedData: Je.map(v, (A) => Number(A[l])).sort()
        })).value();
        if (!h)
          throw new Error("boxplots dont have data yet");
        if (!i)
          throw new Error("boxplots dont have plots yet");
        const g = Ts(h, 0.25), x = Ts(h, 0.75), w = x - g, y = g - 1.5 * w, R = x + 1.5 * w, b = h.filter((v) => v >= y && v <= R);
        i.push({
          columnCategory: c,
          columnMax: eu(b),
          columnThirdQuartile: Je.round(x, e.dataFormat.roundTo),
          columnMedian: Number(ny(h)).toFixed(e.dataFormat.roundTo),
          columnFirstQuartile: Je.round(g, e.dataFormat.roundTo),
          columnMin: Je.min(b),
          columnCount: p,
          columnSd: Number(ox(h)).toFixed(e.dataFormat.roundTo),
          columnMean: Number(lx(h)).toFixed(e.dataFormat.roundTo),
          columnIqr: Je.round(w, e.dataFormat.roundTo),
          values: h,
          columnLowerBounds: y,
          columnUpperBounds: R,
          columnOutliers: Je.filter(h, (v) => v < y || v > R),
          columnNonOutliers: Je.filter(h, (v) => v >= y && v <= R)
        });
      } catch (p) {
        console.error("COVE: ", p.message);
      }
    });
  });
  const u = a.length > 1 ? Je.flatMap(r, (c) => Je.map(a, (l) => `${Je.capitalize(l)} - ${Je.capitalize(c)}`)) : r;
  return [i, u];
}, dT = (e) => {
  if (e.visualizationType !== "Combo" || !e.series)
    return;
  const t = {
    barSeriesKeys: [],
    lineSeriesKeys: [],
    areaSeriesKeys: [],
    forecastingSeriesKeys: []
  }, n = /* @__PURE__ */ new Map([
    ["Area Chart", "areaSeriesKeys"],
    ["Forecasting", "forecastingSeriesKeys"],
    ["Bar", "barSeriesKeys"],
    ["Combo", "barSeriesKeys"],
    ["Line", "lineSeriesKeys"],
    ["dashed-sm", "lineSeriesKeys"],
    ["dashed-md", "lineSeriesKeys"],
    ["dashed-lg", "lineSeriesKeys"]
  ]);
  return e.series.forEach((r) => {
    const a = n.get(r.type);
    if (a) {
      const i = a === "barSeriesKeys" || a === "lineSeriesKeys" ? r.dataKey : r;
      t[a].push(i);
    }
    r.type === "Combo" && (r.type = "Bar");
  }), { ...e.runtime, ...t };
}, fT = (e, t) => {
  var r;
  let n = t;
  if (e.exclusions && e.exclusions.active)
    if (e.xAxis.type === "categorical" && ((r = e.exclusions.keys) == null ? void 0 : r.length) > 0)
      n = t.filter((a) => !e.exclusions.keys.includes(a[e.xAxis.dataKey]));
    else if (En(e.xAxis) && (e.exclusions.dateStart || e.exclusions.dateEnd) && e.xAxis.dateParseFormat) {
      const a = (p) => new Date(p).getTime();
      let i = a(e.exclusions.dateStart), u = a(e.exclusions.dateEnd) + 86399999, c = typeof i !== void 0 && isNaN(i) === !1, l = typeof u !== void 0 && isNaN(u) === !1;
      c && l ? n = t.filter(
        (p) => a(p[e.xAxis.dataKey]) >= i && a(p[e.xAxis.dataKey]) <= u
      ) : c ? n = t.filter((p) => a(p[e.xAxis.dataKey]) >= i) : l && (n = t.filter((p) => a(p[e.xAxis.dataKey]) <= u));
    } else
      n = t;
  return n;
}, pT = (e) => {
  const t = ["Paired Bar", "Deviation Bar"].includes(e.visualizationType) ? e.twoColor.palette : e.palette, n = { ...Sr, ...Nu };
  let r = e.customColors || n[t], a = e.runtime.seriesKeys.length;
  for (; a > r.length; )
    r = r.concat(r);
  return r = r.slice(0, a), gp({
    domain: e.runtime.seriesLabelsAll,
    range: r,
    unknown: null
  });
};
const hT = (e) => {
  var t, n, r;
  return {
    isLoading: !0,
    config: Kc,
    stateData: Je.cloneDeep(e == null ? void 0 : e.data) || [],
    colorScale: null,
    excludedData: void 0,
    filteredData: void 0,
    seriesHighlight: e && ((n = (t = e == null ? void 0 : e.legend) == null ? void 0 : t.seriesHighlight) != null && n.length) ? [...(r = e == null ? void 0 : e.legend) == null ? void 0 : r.seriesHighlight] : [],
    currentViewport: "lg",
    dimensions: [0, 0],
    container: null,
    coveLoadedEventRan: !1,
    isDraggingAnnotation: !1,
    imageId: `cove-${Math.random().toString(16).slice(-4)}`,
    brushConfig: {
      data: [],
      isActive: !1,
      isBrushing: !1
    }
  };
}, mT = (e, t) => {
  switch (t.type) {
    case "SET_LOADING":
      return { ...e, isLoading: t.payload };
    case "SET_CONFIG":
      return { ...e, config: t.payload };
    case "UPDATE_CONFIG":
      return { ...e, config: t.payload };
    case "SET_COLOR_SCALE":
      return { ...e, colorScale: t.payload };
    case "SET_STATE_DATA":
      return { ...e, stateData: t.payload };
    case "SET_EXCLUDED_DATA":
      return { ...e, excludedData: t.payload };
    case "SET_FILTERED_DATA":
      return { ...e, filteredData: t.payload };
    case "SET_SERIES_HIGHLIGHT":
      return { ...e, seriesHighlight: t.payload };
    case "SET_VIEWPORT":
      return { ...e, currentViewpsort: t.payload };
    case "SET_DIMENSIONS":
      return { ...e, dimensions: t.payload };
    case "SET_CONTAINER":
      return { ...e, container: t.payload };
    case "SET_LOADED_EVENT":
      return { ...e, coveLoadedEventRan: t.payload };
    case "SET_DRAG_ANNOTATIONS":
      return { ...e, isDraggingAnnotation: t.payload };
    case "SET_BRUSH_CONFIG":
      return { ...e, brushConfig: t.payload };
  }
}, yT = ({
  config: e,
  isEditor: t = !1,
  isDebug: n = !1,
  isDashboard: r = !1,
  setConfig: a,
  setEditing: i,
  link: u,
  setSharedFilter: c,
  setSharedFilterValue: l,
  dashboardConfig: p
}) => {
  var Nt, tn, sn, Ot, Ft, nn, et, ut;
  const h = new Om(), g = hT(e), [x, w] = ue.useReducer(mT, g), {
    config: y,
    stateData: R,
    excludedData: b,
    filteredData: v,
    currentViewport: A,
    isLoading: N,
    dimensions: L,
    container: C,
    coveLoadedEventRan: z,
    imageId: W,
    seriesHighlight: q,
    colorScale: ne,
    brushConfig: G
  } = x, { description: le, visualizationType: K } = y, re = ue.useRef(null), B = ue.useContext(sT), [j, se] = ue.useState(), ee = (Ne) => {
    w({ type: "SET_CONFIG", payload: Ne }), t && !r && B.setTempConfig(Ne);
  }, Q = (Ne) => {
    w({ type: "SET_FILTERED_DATA", payload: Ne });
  }, Z = ue.useRef(null), Y = ue.useRef(null), te = (Ne) => {
    w({ type: "SET_DRAG_ANNOTATIONS", payload: Ne });
  };
  n && console.log("Chart config, isEditor", y, t);
  let { legend: $, title: ce } = y;
  t && (!ce || ce === "") && (ce = "Chart Title"), y.table && (!((Nt = y.table) != null && Nt.label) || ((tn = y.table) == null ? void 0 : tn.label) === "") && (y.table.label = "Data Table");
  const { lineDatapointClass: Se, contentClasses: be, sparkLineStyles: ve } = Wg(y), Pe = ue.useId(), we = (y.xAxis || y.yAxis) && ["date-time", "date"].includes((y.xAxis || y.yAxis).type) && y.xAxis.dataKey, me = cT(y, v), Ce = async (Ne) => {
    let De = Je.defaultsDeep(Ne, Kc);
    return Je.defaultsDeep(De, {
      table: { showVertical: !1 }
    }), Je.set(De, "table.show", Je.get(De, "table.show", !r)), Je.forEach(De.series, (Ee) => {
      Je.defaults(Ee, {
        tooltip: !0,
        axis: "Left"
      });
    }), De.visualizationType === "Bump Chart" && De.xAxis.type, { ...Yg(De) };
  }, fe = (Ne, De) => {
    var xt, Yt;
    const Ee = Je.cloneDeep(Ne);
    let pt = De || R;
    pt = lT(pt, Ee), Object.keys(Kc).forEach((lt) => {
      Ee[lt] && typeof Ee[lt] == "object" && !Array.isArray(Ee[lt]) && (Ee[lt] = { ...Kc[lt], ...Ee[lt] });
    });
    const nt = fT(Ee, De || R);
    w({ type: "SET_EXCLUDED_DATA", payload: nt });
    let gt = [];
    if (Ee.filters) {
      const lt = uv(Ee.filters, nt);
      gt = Uo(lt, nt), w({ type: "SET_FILTERED_DATA", payload: gt });
    }
    if (Ee.xAxis.type === "date-time" && y.orientation === "horizontal" && (Ee.xAxis.type = "date"), Ee.runtime = {}, Ee.runtime.series = Je.cloneDeep(Ee.series), Ee.runtime.seriesLabels = {}, Ee.runtime.seriesLabelsAll = [], Ee.runtime.originalXAxis = Ee.xAxis, Ee.visualizationType === "Pie")
      Ee.runtime.seriesKeys = (De || pt).map((lt) => lt[Ee.xAxis.dataKey]), Ee.runtime.seriesLabelsAll = Ee.runtime.seriesKeys;
    else {
      const lt = De || Ee.formattedData || Ee.data;
      Ee.runtime.seriesKeys = (Ee.runtime.series || []).flatMap((st) => {
        if (st.dynamicCategory) {
          Je.remove(Ee.runtime.seriesLabelsAll, (jt) => jt === st.dataKey), Je.remove(Ee.runtime.series, (jt) => jt.dataKey === st.dataKey);
          const $t = Je.uniq(lt.map((jt) => jt[st.dynamicCategory]));
          return $t.forEach((jt) => {
            Ee.runtime.seriesLabels[jt] = jt, Ee.runtime.seriesLabelsAll.push(jt), Ee.runtime.series.push({
              dataKey: jt,
              type: st.type,
              lineType: st.lineType,
              originalDataKey: st.dataKey,
              dynamicCategory: st.dynamicCategory,
              tooltip: !0
            });
          }), $t;
        } else
          return Ee.runtime.seriesLabels[st.dataKey] = st.name || st.label || st.dataKey, Ee.runtime.seriesLabelsAll.push(st.name || st.dataKey), [st.dataKey];
      });
    }
    if (Ee.visualizationType === "Box Plot" && Ee.series) {
      const [lt, st] = uT(Ee, R);
      Ee.boxplot.categories = st, Ee.boxplot.plots = lt;
    }
    Ee.visualizationType === "Combo" && Ee.series && (Ee.runtime = dT(Ee)), Ee.visualizationType === "Forecasting" && Ee.series && (Ee.runtime.forecastingSeriesKeys = [], Ee.series.forEach((lt) => {
      lt.type === "Forecasting" && Ee.runtime.forecastingSeriesKeys.push(lt);
    })), Ee.visualizationType === "Area Chart" && Ee.series && (Ee.runtime.areaSeriesKeys = [], Ee.series.forEach((lt) => {
      Ee.runtime.areaSeriesKeys.push({ ...lt, type: "Area Chart" });
    })), Ee.visualizationType === "Bar" && Ee.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(Ee.visualizationType) ? (Ee.runtime.xAxis = Ee.yAxis.yAxis ? Ee.yAxis.yAxis : Ee.yAxis, Ee.runtime.yAxis = Ee.xAxis.xAxis ? Ee.xAxis.xAxis : Ee.xAxis, Ee.runtime.yAxis.labelOffset *= -1, Ee.runtime.horizontal = !1, Ee.orientation = "horizontal", Ee.yAxis.type = Ee.yAxis.type === "categorical" ? "linear" : Ee.yAxis.type) : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(Ee.visualizationType) && !me ? (Ee.runtime.xAxis = Ee.xAxis, Ee.runtime.yAxis = Ee.yAxis, Ee.runtime.horizontal = !1, Ee.orientation = "vertical") : (Ee.runtime.xAxis = Ee.xAxis, Ee.runtime.yAxis = Ee.yAxis, Ee.runtime.horizontal = !1), Ee.runtime.uniqueId = Date.now(), Ee.runtime.editorErrorMessage = Ee.visualizationType === "Pie" && !Ee.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", Ee.runtime.editorErrorMessage = "", (xt = Ee.legend.seriesHighlight) != null && xt.length && w({ type: "SET_SERIES_HIGHLIGHT", payload: (Yt = Ee.legend) == null ? void 0 : Yt.seriesHighlight }), ee(Ee);
  }, ze = (Ne, De) => {
    let Ee = y.visualizationType === "Bar" && y.visualizationSubType === "horizontal" ? y.xAxis.dataKey : y.yAxis.sortKey, pt = parseFloat(Ne[Ee]), nt = parseFloat(De[Ee]);
    return pt < nt ? y.sortData === "ascending" ? 1 : -1 : pt > nt ? y.sortData === "ascending" ? -1 : 1 : 0;
  }, Ie = new bg((Ne) => {
    for (let De of Ne) {
      let { width: Ee, height: pt } = De.contentRect;
      const nt = 15;
      Ee = t ? Ee - 350 : Ee;
      const xt = Eg(Ee);
      w({ type: "SET_VIEWPORT", payload: xt }), De.target.dataset.lollipop === "true" && (Ee = Ee - 2.5), Ee = Ee - nt, w({ type: "SET_DIMENSIONS", payload: [Ee, pt] });
    }
  }), Qe = ue.useCallback((Ne) => {
    Ne !== null && Ie.observe(Ne), w({ type: "SET_CONTAINER", payload: Ne });
  }, []), He = async (Ne) => {
    try {
      const De = Ne.filters ? Ne.filters.filter((Ee) => Ee.type === "url").length > 0 : !1;
      if (Ne.dataUrl && !De) {
        Ne.dataUrl && (Ne.dataUrl = `${Ne.dataUrl}`);
        let Ee = await Sg(Ne.dataUrl, "Chart");
        Ee && Ne.dataDescription && (Ee = h.autoStandardize(Ee), Ee = h.developerStandardize(Ee, Ne.dataDescription)), Ee && (Ne.data = Ee);
      } else
        Ne.formattedData ? Ne.data = Ne.formattedData : Ne.dataDescription && (Ne.data = h.autoStandardize(Ne.data), Ne.data = h.developerStandardize(Ne.data, Ne.dataDescription));
    } catch (De) {
      console.log("Error on prepareData function ", De);
    }
    return Ne;
  };
  ue.useEffect(() => {
    (async () => {
      try {
        if (e) {
          const De = await Ce(e);
          let Ee = await He(De);
          w({ type: "SET_STATE_DATA", payload: Ee.data }), w({ type: "SET_EXCLUDED_DATA", payload: Ee.data }), fe(De, Ee.data);
        }
      } catch {
        console.error("Could not Load!");
      }
    })();
  }, [(sn = e == null ? void 0 : e.data) != null && sn.length ? e.data : null]), ue.useEffect(() => {
    C && !Je.isEmpty(y) && !z && (jg("cove_loaded", { config: y }), w({ type: "SET_LOADED_EVENT", payload: !0 }));
  }, [C, y]), ue.useEffect(() => {
    const Ne = (De) => {
      let Ee = [];
      Ee.push(De.detail), se(Ee);
    };
    return Ug("cove_filterData", (De) => Ne(De)), () => {
      Kg("cove_filterData", Ne);
    };
  }, [y]), ue.useEffect(() => {
    if (j && j[0] && !j[0].hasOwnProperty("active")) {
      let De = { ...y };
      delete De.filters, ee(De), w({ type: "SET_FILTERED_DATA", payload: Uo(j, b) });
    }
    if (j && j.length > 0 && j.length > 0 && j[0].hasOwnProperty("active")) {
      let Ne = { ...y, filters: j };
      ee(Ne), w({ type: "SET_FILTERED_DATA", payload: Uo(j, b) });
    }
  }, [j]), ue.useEffect(() => {
    var Ne;
    if (R && y.xAxis && ((Ne = y.runtime) != null && Ne.seriesKeys)) {
      const De = pT(y);
      w({ type: "SET_COLOR_SCALE", payload: De }), w({ type: "SET_LOADING", payload: !1 });
    }
    y && R && y.sortData && R.sort(ze);
  }, [y, R]);
  const Fe = (Ne) => {
    if (q.length + 1 === y.runtime.seriesKeys.length && y.visualizationType !== "Forecasting")
      return qe();
    const De = Je.findKey(y.runtime.seriesLabels, (pt) => pt === Ne.datum) || Ne.datum, Ee = Je.xor(q, [De]);
    w({ type: "SET_SERIES_HIGHLIGHT", payload: Ee });
  }, qe = () => {
    try {
      const Ne = Z.current;
      if (!Ne)
        throw new Id("No legend available to set previous focus on.");
      Ne.focus();
    } catch (Ne) {
      console.error("COVE:", Ne.message);
    }
    w({ type: "SET_SERIES_HIGHLIGHT", payload: [] });
  }, We = y.orientation === "horizontal" ? "yAxis" : "xAxis", je = (Ne, De = !0) => {
    let Ee = ly(y.runtime[We].dateParseFormat)(Ne);
    return Ee || (De && (y.runtime.editorErrorMessage = `Error parsing date "${Ne}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, Ke = (Ne, De, Ee) => {
    var nt, gt;
    let pt = Hc(y.runtime[We].dateDisplayFormat)(Ne);
    if ((nt = y.runtime[We].dateDisplayFormat) != null && nt.includes("%b.") && pt.includes("May.") && (pt = pt.replace(/May\./g, "May")), y.xAxis.showYearsOnce && ((gt = y.runtime[We].dateDisplayFormat) != null && gt.includes("%Y")) && Ee) {
      const xt = Ee[De - 1] ? Ee[De - 1].value : null, Yt = Hc(y.runtime[We].dateDisplayFormat)(xt), lt = pt.match(/\d{4}/), st = Yt.match(/\d{4}/);
      lt && st && lt[0] === st[0] && (pt = pt.replace(lt, ""));
    }
    return pt;
  }, Te = (Ne) => Hc(y.tooltips.dateDisplayFormat)(Ne), _e = (Ne, De, Ee = !1, pt, nt, gt, { index: xt, length: Yt } = { index: null, length: null }) => {
    if (isNaN(Ne) || !Ne)
      return Ne;
    const lt = Ne < 0;
    (De === void 0 || !De) && (De = "left"), lt && (Ne = Math.abs(Ne));
    let {
      dataFormat: {
        commas: st,
        abbreviated: $t,
        roundTo: jt,
        prefix: Rt,
        suffix: St,
        rightRoundTo: yn,
        bottomRoundTo: vn,
        rightPrefix: wn,
        rightSuffix: Pn,
        bottomPrefix: Tn,
        bottomSuffix: er,
        bottomAbbreviated: Dn,
        onlyShowTopPrefixSuffix: xn
      }
    } = y;
    String(Ne).indexOf(",") !== -1 && (Ne = Ne.replaceAll(",", ""));
    let At = Ne, Ht = {
      useGrouping: !!st
      // for old chart data table to work right cant just leave this to undefined
    };
    if (De === "left" || De === void 0) {
      let cn;
      gt !== void 0 ? cn = gt ? Number(gt) : 0 : cn = jt ? Number(jt) : 0, Ht = {
        useGrouping: gt ? !0 : !!y.dataFormat.commas,
        minimumFractionDigits: cn,
        maximumFractionDigits: cn
      };
    }
    De === "right" && (Ht = {
      useGrouping: !!y.dataFormat.rightCommas,
      minimumFractionDigits: yn ? Number(yn) : 0,
      maximumFractionDigits: yn ? Number(yn) : 0
    });
    const bn = () => y.forestPlot.type === "Logarithmic" && !vn ? 2 : Number(vn) ? Number(vn) : 0;
    if (De === "bottom" && (Ht = {
      useGrouping: !!y.dataFormat.bottomCommas,
      minimumFractionDigits: bn(),
      maximumFractionDigits: bn()
    }), Ne = Yp(Ne), isNaN(Ne))
      return y.runtime.editorErrorMessage = `Unable to parse number from data ${At}. Try reviewing your data and selections in the Data Series section.`, At;
    if (!y.dataFormat)
      return Ne;
    if (y.dataCutoff) {
      let cn = Yp(y.dataCutoff);
      Ne < cn && (Ne = cn);
    }
    De === "left" && st && $t && Ee || De === "bottom" && st && $t && Ee ? Ne = Ne : Ne = Ne.toLocaleString("en-US", Ht);
    let Qt = "";
    if ($t && De === "left" && Ee && (Ne = gm(parseFloat(Ne))), Dn && De === "bottom" && Ee && (Ne = gm(parseFloat(Ne))), pt && De === "left")
      Qt = pt + Qt;
    else {
      const cn = xn && Yt - 1 !== xt;
      Rt && De === "left" && !cn && (Qt += Rt);
    }
    return wn && De === "right" && (Qt += wn), Tn && De === "bottom" && (Qt += Tn), Qt += Ne, nt && De === "left" ? Qt += nt : St && De === "left" && !xn && (Qt += St), Pn && De === "right" && (Qt += Pn), er && De === "bottom" && (Qt += er), lt && (Qt = "-" + Qt), String(Qt);
  }, at = (Ne) => {
    try {
      if (!Ne)
        throw new Id("COVE: No rowObj in applyLegendToRow");
      if (y.type === "navigation") {
        let De = Sr[y.color] || Sr.bluegreenreverse;
        return xm(De[3]);
      }
      return xm();
    } catch (De) {
      console.error("COVE: ", De);
    }
  }, ge = (Ne) => {
    var pt;
    if (!Array.isArray(Ne))
      return [];
    if (y.visualizationType === "Forecasting")
      return Ne;
    const De = y.series.map((nt) => nt.dataKey), Ee = y.xAxis.dataKey;
    return (pt = y == null ? void 0 : y.xAxis) != null && pt.dataKey ? h.cleanData(Ne, Ee, De) : Ne;
  }, ft = () => {
    var pt, nt, gt;
    if (K === "Sankey")
      return (nt = (pt = y == null ? void 0 : y.data) == null ? void 0 : pt[0]) == null ? void 0 : nt.tableData;
    const Ne = v || b, De = y.series.find((xt) => !!xt.dynamicCategory);
    if (!De)
      return Ne;
    const Ee = Object.values(y.columns).filter((xt) => xt.dataTable).map((xt) => xt.name).concat([De.dynamicCategory, De.dataKey]);
    return (gt = y.xAxis) != null && gt.dataKey && Ee.push(y.xAxis.dataKey), Ne.map((xt) => Je.pick(xt, Ee));
  }, ot = (Ne) => {
    const De = Je.cloneDeep(Ne), Ee = De.series.find((pt) => !!pt.dynamicCategory);
    if (Ee) {
      const pt = { columnName: Ee.dynamicCategory, valueColumns: [Ee.dataKey] };
      De.table.pivot = pt;
    }
    return De;
  };
  let it = /* @__PURE__ */ m.createElement(Zg, null);
  const wt = (Ne) => {
    if (Je.isString(Ne))
      return Je.kebabCase(Ne);
  }, Wt = () => {
    var Ee;
    const Ne = ($ == null ? void 0 : $.position) === "bottom" || Va(A), De = ["chart-container", "p-relative"];
    return $ != null && $.position && (Va(A) && ($ == null ? void 0 : $.position) !== "top" ? De.push("legend-bottom") : De.push(`legend-${$.position}`)), $ != null && $.hide && De.push("legend-hidden"), Se && De.push(Se), y.barHasBorder || De.push("chart-bar--no-border"), (Ee = y.brush) != null && Ee.active && (p == null ? void 0 : p.type) === "dashboard" && (!Ne || $.hide) && De.push("dashboard-brush"), De.push(...be), De;
  }, Kt = () => {
    var Ee, pt;
    const Ne = ["subtext mt-4"], De = ($ == null ? void 0 : $.position) === "bottom" || Va(A);
    return y.isResponsiveTicks && Ne.push("subtext--responsive-ticks "), (Ee = y.brush) != null && Ee.active && !De && Ne.push("subtext--brush-active "), (pt = y.brush) != null && pt.active && y.legend.hide && Ne.push("subtext--brush-active "), Ne;
  };
  if (!N) {
    const Ne = /* @__PURE__ */ m.createElement("a", { href: `#data-table-${y.dataKey}`, className: "margin-left-href" }, y.dataKey, " (Go to Table)");
    it = /* @__PURE__ */ m.createElement(m.Fragment, null, t && /* @__PURE__ */ m.createElement(iT, null), /* @__PURE__ */ m.createElement(hf.Responsive, { isEditor: t }, y.newViz && /* @__PURE__ */ m.createElement(dv, { updateConfig: fe, config: y }), y.newViz === void 0 && t && y.runtime && ((Ot = y.runtime) == null ? void 0 : Ot.editorErrorMessage) && /* @__PURE__ */ m.createElement(Id, { errorMessage: y.runtime.editorErrorMessage }), !yf(y) && !y.newViz && /* @__PURE__ */ m.createElement(
      "div",
      {
        className: `cdc-chart-inner-container cove-component__content type-${wt(
          y.visualizationType
        )}`,
        "aria-label": zf(y),
        tabIndex: 0
      },
      /* @__PURE__ */ m.createElement(
        qg,
        {
          showTitle: y.showTitle,
          isDashboard: r,
          title: ce,
          superTitle: y.superTitle,
          classes: ["chart-title", `${y.theme}`, "cove-component__header", "mb-3"],
          style: void 0
        }
      ),
      /* @__PURE__ */ m.createElement("div", { className: Wt().join(" ") }, (y == null ? void 0 : y.introText) && y.visualizationType !== "Spark Line" && /* @__PURE__ */ m.createElement("section", { className: "introText mb-4" }, Oi(y.introText)), y.filters && !j && y.visualizationType !== "Spark Line" && /* @__PURE__ */ m.createElement(
        Kp,
        {
          config: y,
          setConfig: ee,
          setFilteredData: Q,
          filteredData: v,
          excludedData: b,
          filterData: Uo,
          dimensions: L
        }
      ), /* @__PURE__ */ m.createElement(Ip, { skipId: ds(y, Pe), skipMessage: "Skip Over Chart Container" }), ((Ft = y.annotations) == null ? void 0 : Ft.length) > 0 && /* @__PURE__ */ m.createElement(
        Ip,
        {
          skipId: ds(y, Pe),
          skipMessage: "Skip over annotations",
          key: "skip-annotations"
        }
      ), /* @__PURE__ */ m.createElement(xv, null, /* @__PURE__ */ m.createElement(
        "div",
        {
          className: $.hide || Va(A) || $.position === "bottom" || $.position === "top" || K === "Sankey" ? "w-100" : "w-75"
        },
        !["Spark Line", "Line", "Sankey", "Pie", "Sankey"].includes(y.visualizationType) && /* @__PURE__ */ m.createElement("div", { ref: Y, style: { width: "100%" } }, /* @__PURE__ */ m.createElement(Ko, null, (De) => /* @__PURE__ */ m.createElement(ff, { ref: re, parentWidth: De.width, parentHeight: De.height }))),
        y.visualizationType === "Pie" && /* @__PURE__ */ m.createElement(Ko, { className: "justify-content-center d-flex", style: { width: "100%" } }, (De) => /* @__PURE__ */ m.createElement(UE, { ref: re, parentWidth: De.width, parentHeight: De.height })),
        y.visualizationType === "Line" && (me ? /* @__PURE__ */ m.createElement("div", { ref: Y, style: { width: "100%" } }, /* @__PURE__ */ m.createElement(Ko, null, (De) => /* @__PURE__ */ m.createElement(ff, { ref: re, parentWidth: De.width, parentHeight: De.height }))) : /* @__PURE__ */ m.createElement("div", { ref: Y, style: { width: "100%" } }, /* @__PURE__ */ m.createElement(Ko, null, (De) => /* @__PURE__ */ m.createElement(ff, { ref: re, parentWidth: De.width, parentHeight: De.height })))),
        y.visualizationType === "Spark Line" && /* @__PURE__ */ m.createElement(m.Fragment, null, /* @__PURE__ */ m.createElement(
          Kp,
          {
            config: y,
            setConfig: ee,
            setFilteredData: Q,
            filteredData: v,
            excludedData: b,
            filterData: Uo,
            dimensions: L
          }
        ), (y == null ? void 0 : y.introText) && /* @__PURE__ */ m.createElement("section", { className: "introText mb-4", style: { padding: "0px 0 35px" } }, Oi(y.introText)), /* @__PURE__ */ m.createElement("div", { style: { height: "100px", width: "100%", ...ve } }, /* @__PURE__ */ m.createElement(Ko, null, (De) => /* @__PURE__ */ m.createElement(lw, { width: De.width, height: De.height }))), le && /* @__PURE__ */ m.createElement("div", { className: "subtext", style: { padding: "35px 0 15px" } }, Oi(le))),
        y.visualizationType === "Sankey" && /* @__PURE__ */ m.createElement(Ko, { "aria-hidden": "true" }, (De) => /* @__PURE__ */ m.createElement(SS, { runtime: y.runtime, width: De.width, height: De.height }))
      ), !y.legend.hide && y.visualizationType !== "Spark Line" && y.visualizationType !== "Sankey" && /* @__PURE__ */ m.createElement(Lw, { ref: Z, skipId: ds(y, Pe) })), r && y.table && y.table.show && y.table.showDataTableLink ? Ne : u && u, y.description && y.visualizationType !== "Spark Line" && /* @__PURE__ */ m.createElement("div", { className: Kt().join(" ") }, Oi(y.description)), /* @__PURE__ */ m.createElement(zd.Section, { classes: ["download-buttons"] }, y.table.showDownloadImgButton && /* @__PURE__ */ m.createElement(
        zd.Button,
        {
          text: "Download Image",
          title: "Download Chart as Image",
          type: "image",
          state: y,
          elementToCapture: W
        }
      ), y.table.showDownloadPdfButton && /* @__PURE__ */ m.createElement(
        zd.Button,
        {
          text: "Download PDF",
          title: "Download Chart as PDF",
          type: "pdf",
          state: y,
          elementToCapture: W
        }
      )), (y.xAxis.dataKey && y.table.show && y.visualizationType !== "Spark Line" && y.visualizationType !== "Sankey" || y.visualizationType === "Sankey" && y.table.show) && /* @__PURE__ */ m.createElement(
        Xg,
        {
          key: we,
          config: ot(y),
          rawData: y.visualizationType === "Sankey" ? (et = (nn = y == null ? void 0 : y.data) == null ? void 0 : nn[0]) == null ? void 0 : et.tableData : y.table.customTableConfig ? Uo(y.filters, y.data) : y.data,
          runtimeData: ft(),
          expandDataTable: y.table.expanded,
          columns: y.columns,
          defaultSortBy: we,
          displayGeoName: (De) => De,
          applyLegendToRow: at,
          tableTitle: y.table.label,
          indexTitle: y.table.indexLabel,
          vizTitle: ce,
          viewport: A,
          tabbingId: ds(y, Pe),
          colorScale: ne
        }
      ), ((ut = y == null ? void 0 : y.annotations) == null ? void 0 : ut.length) > 0 && /* @__PURE__ */ m.createElement(kp.Dropdown, null), (y == null ? void 0 : y.footnotes) && /* @__PURE__ */ m.createElement("section", { className: "footnotes pt-2 mt-4" }, Oi(y.footnotes)))
    )));
  }
  const Pt = {
    ...x,
    brushConfig: G,
    capitalize: (Ne) => Ne.charAt(0).toUpperCase() + Ne.slice(1),
    convertLineToBarGraph: me,
    clean: ge,
    colorPalettes: Sr,
    dashboardConfig: p,
    debugSvg: n,
    formatDate: Ke,
    formatNumber: _e,
    formatTooltipsDate: Te,
    getXAxisData: (Ne) => En(y.runtime.xAxis) ? je(Ne[y.runtime.originalXAxis.dataKey]).getTime() : Ne[y.runtime.originalXAxis.dataKey],
    getYAxisData: (Ne, De) => Ne[De],
    handleChartAriaLabels: zf,
    handleLineType: yg,
    handleChartTabbing: ds,
    highlight: Fe,
    handleShowAll: qe,
    isDashboard: r,
    isDebug: n,
    handleDragStateChange: te,
    isEditor: t,
    isNumber: Vi,
    legend: $,
    legendId: Pe,
    legendRef: Z,
    lineOptions: oT,
    missingRequiredSections: yf,
    outerContainerRef: Qe,
    parentRef: Y,
    parseDate: je,
    rawData: Je.cloneDeep(R) ?? {},
    setConfig: ee,
    setEditing: i,
    setParentConfig: a,
    setSharedFilter: c,
    setSharedFilterValue: l,
    svgRef: re,
    tableData: v || b,
    transformedData: ge(v || b),
    twoColorPalette: Nu,
    unfilteredData: Je.cloneDeep(R),
    updateConfig: fe
  };
  return /* @__PURE__ */ m.createElement(mt.Provider, { value: Pt }, /* @__PURE__ */ m.createElement(Xf.Provider, { value: w }, /* @__PURE__ */ m.createElement(
    hf.VisualizationWrapper,
    {
      config: y,
      isEditor: t,
      currentViewport: A,
      ref: Qe,
      imageId: W,
      showEditorPanel: y == null ? void 0 : y.showEditorPanel
    },
    it
  )));
}, KT = yT;
export {
  KT as C,
  Dw as D,
  UT as E,
  sT as a,
  Pw as b
};
