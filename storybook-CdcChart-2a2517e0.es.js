import { r as le, R as r } from "./storybook-index-45401197.es.js";
import { v as fp, a as Qy, i as pp, b as hp, g as Jy } from "./storybook-isSolr-cb863e7a.es.js";
import { _ as qr, P as eg, D as tg, C as ng, A as rg, d as wi, F as mp, g as ag } from "./storybook-Filters-46e2d309.es.js";
import { L as of, a as ig } from "./storybook-coveUpdateWorker-e9c9259f.es.js";
import { B as bs } from "./storybook-Button-d74e310e.es.js";
import { p as og, P as Ye } from "./storybook-index-43433e35.es.js";
import { d as lg } from "./storybook-debounce-cc216a80.es.js";
import { a as sg } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { P as yp } from "./storybook-papaparse.min-b07ddc33.es.js";
import { H as Ni, T as ug } from "./storybook-index-e5bf02db.es.js";
import { _ as dn } from "./storybook-extends-70f3d2a3.es.js";
import { p as gp, q as Ti, r as Ur, c as Ht, u as vp, a as Ac, v as er, t as Hu, w as Yo, x as Nd, z as xp, B as Zn, D as bp, F as cg, J as dg, l as Sp, G as fg, K as Ss, L as cr, N as qu, j as Qo, T as xt, P as pg, d as Ko, b as Ep, e as hg, y as mg, i as Gu, o as yg, H as gg, C as kp, g as vg, M as am, E as xg, A as bg, h as im, I as wp } from "./storybook-InputToggle-e4d0e3a3.es.js";
import { t as Sg, a as Cn, b as Mf, L as Tp, c as ns, g as Ci, f as om, S as Cp, M as _d, D as Eg } from "./storybook-DataTable-e5f45b44.es.js";
import { E as $r, L as kg } from "./storybook-Loading-f180d060.es.js";
import { b as Lc, t as wg, e as lm, f as Ap, g as Tg, h as Cg, j as Ag, k as Lp, m as Lg, G as rt, c as An, o as Pg } from "./storybook-Group-ce878ea9.es.js";
import { s as ls, t as sm, a as um, b as cm, d as As, B as Ar, c as In, C as Rg } from "./storybook-Circle-134742d0.es.js";
import { R as Dg } from "./storybook-index-633d712d.es.js";
import { d as Ng, a as Pp } from "./storybook-transform-e0776740.es.js";
import { c as Ba } from "./storybook-chroma-b564050a.es.js";
import { _ as vr } from "./storybook-lodash-c15d8e1c.es.js";
import { t as dm, m as Od, f as fm, d as Eu, a as ku, b as wu, n as Rp, o as _g, p as Dp, c as pm, e as hm } from "./storybook-year-24bd1dc7.es.js";
import { I as st, S as mm } from "./storybook-Icon-9a8d8f01.es.js";
import { a as Nn, b as _n, c as On, d as Fn, A as _i, D as Og } from "./storybook-DataTransform-1390427f.es.js";
import { C as Fg, V as Mg, a as Np } from "./storybook-footnoteSymbols-22cecfbd.es.js";
import { D as zg } from "./storybook-DataTableEditor-60ca74da.es.js";
import { T as me } from "./storybook-Tooltip-edc0f7ab.es.js";
import { S as Pt, T as Je, C as ct } from "./storybook-Inputs-88e145b4.es.js";
import { I as Ia } from "./storybook-InputSelect-20478396.es.js";
import { A as Tu } from "./storybook-Accordion-a22107f6.es.js";
import { u as $g, p as Bg, s as Ig, a as Hg } from "./storybook-useDataVizClasses-707a8d8e.es.js";
import { n as _p } from "./storybook-numberFromString-24623c03.es.js";
import { c as Op } from "./storybook-cacheBustingString-7a3dd9ba.es.js";
function ym(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Fp(e) {
  let t = e, n = e;
  e.length === 1 && (t = (c, f) => e(c) - f, n = Wg(e));
  function a(c, f, u, m) {
    for (u == null && (u = 0), m == null && (m = c.length); u < m; ) {
      const y = u + m >>> 1;
      n(c[y], f) < 0 ? u = y + 1 : m = y;
    }
    return u;
  }
  function i(c, f, u, m) {
    for (u == null && (u = 0), m == null && (m = c.length); u < m; ) {
      const y = u + m >>> 1;
      n(c[y], f) > 0 ? m = y : u = y + 1;
    }
    return u;
  }
  function l(c, f, u, m) {
    u == null && (u = 0), m == null && (m = c.length);
    const y = a(c, f, u, m - 1);
    return y > u && t(c[y - 1], f) > -t(c[y], f) ? y - 1 : y;
  }
  return { left: a, center: l, right: i };
}
function Wg(e) {
  return (t, n) => ym(e(t), n);
}
function* Vg(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let a of e)
      (a = t(a, ++n, e)) != null && (a = +a) >= a && (yield a);
  }
}
function jg(e, t) {
  let n = 0, a, i = 0, l = 0;
  if (t === void 0)
    for (let c of e)
      c != null && (c = +c) >= c && (a = c - i, i += a / ++n, l += a * (c - i));
  else {
    let c = -1;
    for (let f of e)
      (f = t(f, ++c, e)) != null && (f = +f) >= f && (a = f - i, i += a / ++n, l += a * (f - i));
  }
  if (n > 1)
    return l / (n - 1);
}
function Ug(e, t) {
  const n = jg(e, t);
  return n && Math.sqrt(n);
}
function ss(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n < a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function us(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n > a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function gm(e, t, n = 0, a = e.length - 1, i = ym) {
  for (; a > n; ) {
    if (a - n > 600) {
      const u = a - n + 1, m = t - n + 1, y = Math.log(u), v = 0.5 * Math.exp(2 * y / 3), x = 0.5 * Math.sqrt(y * v * (u - v) / u) * (m - u / 2 < 0 ? -1 : 1), A = Math.max(n, Math.floor(t - m * v / u + x)), T = Math.min(a, Math.floor(t + (u - m) * v / u + x));
      gm(e, t, A, T, i);
    }
    const l = e[t];
    let c = n, f = a;
    for (rs(e, n, t), i(e[a], l) > 0 && rs(e, n, a); c < f; ) {
      for (rs(e, c, f), ++c, --f; i(e[c], l) < 0; )
        ++c;
      for (; i(e[f], l) > 0; )
        --f;
    }
    i(e[n], l) === 0 ? rs(e, n, f) : (++f, rs(e, f, a)), f <= t && (n = f + 1), t <= f && (a = f - 1);
  }
  return e;
}
function rs(e, t, n) {
  const a = e[t];
  e[t] = e[n], e[n] = a;
}
function Kg(e, t, n) {
  if (e = Float64Array.from(Vg(e, n)), !!(a = e.length)) {
    if ((t = +t) <= 0 || a < 2)
      return us(e);
    if (t >= 1)
      return ss(e);
    var a, i = (a - 1) * t, l = Math.floor(i), c = ss(gm(e, l).subarray(0, l + 1)), f = us(e.subarray(l + 1));
    return c + (f - c) * (i - l);
  }
}
function Yg(e, t) {
  let n = 0, a = 0;
  if (t === void 0)
    for (let i of e)
      i != null && (i = +i) >= i && (++n, a += i);
  else {
    let i = -1;
    for (let l of e)
      (l = t(l, ++i, e)) != null && (l = +l) >= l && (++n, a += l);
  }
  if (n)
    return a / n;
}
function Xg(e, t) {
  return Kg(e, 0.5, t);
}
class Mp extends Map {
  constructor(t, n = Zg) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [a, i] of t)
        this.set(a, i);
  }
  get(t) {
    return super.get(zp(this, t));
  }
  has(t) {
    return super.has(zp(this, t));
  }
  set(t, n) {
    return super.set(qg(this, t), n);
  }
  delete(t) {
    return super.delete(Gg(this, t));
  }
}
function zp({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : n;
}
function qg({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : (e.set(a, n), n);
}
function Gg({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) && (n = e.get(a), e.delete(a)), n;
}
function Zg(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function Qg(e, t, n) {
  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
  for (var a = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, l = new Array(i); ++a < i; )
    l[a] = e + a * n;
  return l;
}
const $p = Symbol("implicit");
function zf() {
  var e = new Mp(), t = [], n = [], a = $p;
  function i(l) {
    let c = e.get(l);
    if (c === void 0) {
      if (a !== $p)
        return a;
      e.set(l, c = t.push(l) - 1);
    }
    return n[c % n.length];
  }
  return i.domain = function(l) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new Mp();
    for (const c of l)
      e.has(c) || e.set(c, t.push(c) - 1);
    return i;
  }, i.range = function(l) {
    return arguments.length ? (n = Array.from(l), i) : n.slice();
  }, i.unknown = function(l) {
    return arguments.length ? (a = l, i) : a;
  }, i.copy = function() {
    return zf(t, n).unknown(a);
  }, Lc.apply(i, arguments), i;
}
function $f() {
  var e = zf().unknown(void 0), t = e.domain, n = e.range, a = 0, i = 1, l, c, f = !1, u = 0, m = 0, y = 0.5;
  delete e.unknown;
  function v() {
    var x = t().length, A = i < a, T = A ? i : a, M = A ? a : i;
    l = (M - T) / Math.max(1, x - u + m * 2), f && (l = Math.floor(l)), T += (M - T - l * (x - u)) * y, c = l * (1 - u), f && (T = Math.round(T), c = Math.round(c));
    var E = Qg(x).map(function(p) {
      return T + l * p;
    });
    return n(A ? E.reverse() : E);
  }
  return e.domain = function(x) {
    return arguments.length ? (t(x), v()) : t();
  }, e.range = function(x) {
    return arguments.length ? ([a, i] = x, a = +a, i = +i, v()) : [a, i];
  }, e.rangeRound = function(x) {
    return [a, i] = x, a = +a, i = +i, f = !0, v();
  }, e.bandwidth = function() {
    return c;
  }, e.step = function() {
    return l;
  }, e.round = function(x) {
    return arguments.length ? (f = !!x, v()) : f;
  }, e.padding = function(x) {
    return arguments.length ? (u = Math.min(1, m = +x), v()) : u;
  }, e.paddingInner = function(x) {
    return arguments.length ? (u = Math.min(1, x), v()) : u;
  }, e.paddingOuter = function(x) {
    return arguments.length ? (m = +x, v()) : m;
  }, e.align = function(x) {
    return arguments.length ? (y = Math.max(0, Math.min(1, x)), v()) : y;
  }, e.copy = function() {
    return $f(t(), [a, i]).round(f).paddingInner(u).paddingOuter(m).align(y);
  }, Lc.apply(v(), arguments);
}
function vm(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return vm(t());
  }, e;
}
function Jg() {
  return vm($f.apply(null, arguments).paddingInner(1));
}
function xm(e, t) {
  e = e.slice();
  var n = 0, a = e.length - 1, i = e[n], l = e[a], c;
  return l < i && (c = n, n = a, a = c, c = i, i = l, l = c), e[n] = t.floor(i), e[a] = t.ceil(l), e;
}
function Bp(e) {
  return Math.log(e);
}
function Ip(e) {
  return Math.exp(e);
}
function ev(e) {
  return -Math.log(-e);
}
function tv(e) {
  return -Math.exp(-e);
}
function nv(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function rv(e) {
  return e === 10 ? nv : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function av(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function Hp(e) {
  return (t, n) => -e(-t, n);
}
function iv(e) {
  const t = e(Bp, Ip), n = t.domain;
  let a = 10, i, l;
  function c() {
    return i = av(a), l = rv(a), n()[0] < 0 ? (i = Hp(i), l = Hp(l), e(ev, tv)) : e(Bp, Ip), t;
  }
  return t.base = function(f) {
    return arguments.length ? (a = +f, c()) : a;
  }, t.domain = function(f) {
    return arguments.length ? (n(f), c()) : n();
  }, t.ticks = (f) => {
    const u = n();
    let m = u[0], y = u[u.length - 1];
    const v = y < m;
    v && ([m, y] = [y, m]);
    let x = i(m), A = i(y), T, M;
    const E = f == null ? 10 : +f;
    let p = [];
    if (!(a % 1) && A - x < E) {
      if (x = Math.floor(x), A = Math.ceil(A), m > 0) {
        for (; x <= A; ++x)
          for (T = 1; T < a; ++T)
            if (M = x < 0 ? T / l(-x) : T * l(x), !(M < m)) {
              if (M > y)
                break;
              p.push(M);
            }
      } else
        for (; x <= A; ++x)
          for (T = a - 1; T >= 1; --T)
            if (M = x > 0 ? T / l(-x) : T * l(x), !(M < m)) {
              if (M > y)
                break;
              p.push(M);
            }
      p.length * 2 < E && (p = Ap(m, y, E));
    } else
      p = Ap(x, A, Math.min(A - x, E)).map(l);
    return v ? p.reverse() : p;
  }, t.tickFormat = (f, u) => {
    if (f == null && (f = 10), u == null && (u = a === 10 ? "s" : ","), typeof u != "function" && (!(a % 1) && (u = Tg(u)).precision == null && (u.trim = !0), u = Cg(u)), f === 1 / 0)
      return u;
    const m = Math.max(1, a * f / t.ticks().length);
    return (y) => {
      let v = y / l(Math.round(i(y)));
      return v * a < a - 0.5 && (v *= a), v <= m ? u(y) : "";
    };
  }, t.nice = () => n(xm(n(), {
    floor: (f) => l(Math.floor(i(f))),
    ceil: (f) => l(Math.ceil(i(f)))
  })), t;
}
function bm() {
  const e = iv(wg()).domain([1, 10]);
  return e.copy = () => lm(e, bm()).base(e.base()), Lc.apply(e, arguments), e;
}
const Zu = dm(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Zu.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? dm((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : Zu);
Zu.range;
function ov(e, t, n, a, i, l) {
  const c = [
    [ls, 1, Eu],
    [ls, 5, 5 * Eu],
    [ls, 15, 15 * Eu],
    [ls, 30, 30 * Eu],
    [l, 1, ku],
    [l, 5, 5 * ku],
    [l, 15, 15 * ku],
    [l, 30, 30 * ku],
    [i, 1, wu],
    [i, 3, 3 * wu],
    [i, 6, 6 * wu],
    [i, 12, 12 * wu],
    [a, 1, Rp],
    [a, 2, 2 * Rp],
    [n, 1, _g],
    [t, 1, Dp],
    [t, 3, 3 * Dp],
    [e, 1, Od]
  ];
  function f(m, y, v) {
    const x = y < m;
    x && ([m, y] = [y, m]);
    const A = v && typeof v.range == "function" ? v : u(m, y, v), T = A ? A.range(m, +y + 1) : [];
    return x ? T.reverse() : T;
  }
  function u(m, y, v) {
    const x = Math.abs(y - m) / v, A = Ag(([, , E]) => E).right(c, x);
    if (A === c.length)
      return e.every(Lp(m / Od, y / Od, v));
    if (A === 0)
      return Zu.every(Math.max(Lp(m, y, v), 1));
    const [T, M] = c[x / c[A - 1][2] < c[A][2] / x ? A - 1 : A];
    return T.every(M);
  }
  return [f, u];
}
const [lv, sv] = ov(fm, cm, hm, pm, um, sm);
function uv(e) {
  return new Date(e);
}
function cv(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Sm(e, t, n, a, i, l, c, f, u, m) {
  var y = Lg(), v = y.invert, x = y.domain, A = m(".%L"), T = m(":%S"), M = m("%I:%M"), E = m("%I %p"), p = m("%a %d"), C = m("%b %d"), _ = m("%B"), w = m("%Y");
  function R(P) {
    return (u(P) < P ? A : f(P) < P ? T : c(P) < P ? M : l(P) < P ? E : a(P) < P ? i(P) < P ? p : C : n(P) < P ? _ : w)(P);
  }
  return y.invert = function(P) {
    return new Date(v(P));
  }, y.domain = function(P) {
    return arguments.length ? x(Array.from(P, cv)) : x().map(uv);
  }, y.ticks = function(P) {
    var z = x();
    return e(z[0], z[z.length - 1], P ?? 10);
  }, y.tickFormat = function(P, z) {
    return z == null ? R : m(z);
  }, y.nice = function(P) {
    var z = x();
    return (!P || typeof P.range != "function") && (P = t(z[0], z[z.length - 1], P ?? 10)), P ? x(xm(z, P)) : y;
  }, y.copy = function() {
    return lm(y, Sm(e, t, n, a, i, l, c, f, u, m));
  }, y;
}
function dv() {
  return Lc.apply(Sm(lv, sv, fm, cm, hm, pm, um, sm, ls, Sg).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var fv = As("domain", "range", "reverse", "align", "padding", "round");
function Qu(e) {
  return fv($f(), e);
}
var pv = As("domain", "range", "reverse", "align", "padding", "round");
function Xo(e) {
  return pv(Jg(), e);
}
var hv = As("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function Wp(e) {
  return hv(dv(), e);
}
var mv = As("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function Ju(e) {
  return mv(bm(), e);
}
var yv = As("domain", "range", "reverse", "unknown");
function Oi(e) {
  return yv(zf(), e);
}
function gv(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function vv(e, t) {
  var n = e;
  return "ticks" in n ? n.ticks(t) : n.domain().filter(function(a, i, l) {
    return t == null || l.length <= t || i % Math.round((l.length - 1) / t) === 0;
  });
}
function xv(e) {
  return e == null ? void 0 : e.toString();
}
var Fi = [], bv = function() {
  return Fi.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Sv = function() {
  return Fi.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, Vp = "ResizeObserver loop completed with undelivered notifications.", Ev = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: Vp
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = Vp), window.dispatchEvent(e);
}, Es;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Es || (Es = {}));
var Mi = function(e) {
  return Object.freeze(e);
}, Em = function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Mi(this);
  }
  return e;
}(), km = function() {
  function e(t, n, a, i) {
    return this.x = t, this.y = n, this.width = a, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Mi(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, a = t.y, i = t.top, l = t.right, c = t.bottom, f = t.left, u = t.width, m = t.height;
    return { x: n, y: a, top: i, right: l, bottom: c, left: f, width: u, height: m };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Bf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, wm = function(e) {
  if (Bf(e)) {
    var t = e.getBBox(), n = t.width, a = t.height;
    return !n && !a;
  }
  var i = e, l = i.offsetWidth, c = i.offsetHeight;
  return !(l || c || e.getClientRects().length);
}, jp = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, kv = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, cs = typeof window < "u" ? window : {}, Cu = /* @__PURE__ */ new WeakMap(), Up = /auto|scroll/, wv = /^tb|vertical/, Tv = /msie|trident/i.test(cs.navigator && cs.navigator.userAgent), Kr = function(e) {
  return parseFloat(e || "0");
}, Go = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Em((n ? t : e) || 0, (n ? e : t) || 0);
}, Kp = Mi({
  devicePixelContentBoxSize: Go(),
  borderBoxSize: Go(),
  contentBoxSize: Go(),
  contentRect: new km(0, 0, 0, 0)
}), Tm = function(e, t) {
  if (t === void 0 && (t = !1), Cu.has(e) && !t)
    return Cu.get(e);
  if (wm(e))
    return Cu.set(e, Kp), Kp;
  var n = getComputedStyle(e), a = Bf(e) && e.ownerSVGElement && e.getBBox(), i = !Tv && n.boxSizing === "border-box", l = wv.test(n.writingMode || ""), c = !a && Up.test(n.overflowY || ""), f = !a && Up.test(n.overflowX || ""), u = a ? 0 : Kr(n.paddingTop), m = a ? 0 : Kr(n.paddingRight), y = a ? 0 : Kr(n.paddingBottom), v = a ? 0 : Kr(n.paddingLeft), x = a ? 0 : Kr(n.borderTopWidth), A = a ? 0 : Kr(n.borderRightWidth), T = a ? 0 : Kr(n.borderBottomWidth), M = a ? 0 : Kr(n.borderLeftWidth), E = v + m, p = u + y, C = M + A, _ = x + T, w = f ? e.offsetHeight - _ - e.clientHeight : 0, R = c ? e.offsetWidth - C - e.clientWidth : 0, P = i ? E + C : 0, z = i ? p + _ : 0, q = a ? a.width : Kr(n.width) - P - R, V = a ? a.height : Kr(n.height) - z - w, G = q + E + R + C, ee = V + p + w + _, W = Mi({
    devicePixelContentBoxSize: Go(Math.round(q * devicePixelRatio), Math.round(V * devicePixelRatio), l),
    borderBoxSize: Go(G, ee, l),
    contentBoxSize: Go(q, V, l),
    contentRect: new km(v, u, q, V)
  });
  return Cu.set(e, W), W;
}, Cm = function(e, t, n) {
  var a = Tm(e, n), i = a.borderBoxSize, l = a.contentBoxSize, c = a.devicePixelContentBoxSize;
  switch (t) {
    case Es.DEVICE_PIXEL_CONTENT_BOX:
      return c;
    case Es.BORDER_BOX:
      return i;
    default:
      return l;
  }
}, Am = function() {
  function e(t) {
    var n = Tm(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Mi([n.borderBoxSize]), this.contentBoxSize = Mi([n.contentBoxSize]), this.devicePixelContentBoxSize = Mi([n.devicePixelContentBoxSize]);
  }
  return e;
}(), Lm = function(e) {
  if (wm(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Cv = function() {
  var e = 1 / 0, t = [];
  Fi.forEach(function(c) {
    if (c.activeTargets.length !== 0) {
      var f = [];
      c.activeTargets.forEach(function(m) {
        var y = new Am(m.target), v = Lm(m.target);
        f.push(y), m.lastReportedSize = Cm(m.target, m.observedBox), v < e && (e = v);
      }), t.push(function() {
        c.callback.call(c.observer, f, c.observer);
      }), c.activeTargets.splice(0, c.activeTargets.length);
    }
  });
  for (var n = 0, a = t; n < a.length; n++) {
    var i = a[n];
    i();
  }
  return e;
}, Yp = function(e) {
  Fi.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(i) {
      i.isActive() && (Lm(i.target) > e ? n.activeTargets.push(i) : n.skippedTargets.push(i));
    });
  });
}, Av = function() {
  var e = 0;
  for (Yp(e); bv(); )
    e = Cv(), Yp(e);
  return Sv() && Ev(), e > 0;
}, Fd, Pm = [], Lv = function() {
  return Pm.splice(0).forEach(function(e) {
    return e();
  });
}, Pv = function(e) {
  if (!Fd) {
    var t = 0, n = document.createTextNode(""), a = { characterData: !0 };
    new MutationObserver(function() {
      return Lv();
    }).observe(n, a), Fd = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  Pm.push(e), Fd();
}, Rv = function(e) {
  Pv(function() {
    requestAnimationFrame(e);
  });
}, Wu = 0, Dv = function() {
  return !!Wu;
}, Nv = 250, _v = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, Xp = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], qp = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Md = !1, Ov = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Nv), !Md) {
      Md = !0;
      var a = qp(t);
      Rv(function() {
        var i = !1;
        try {
          i = Av();
        } finally {
          if (Md = !1, t = a - qp(), !Dv())
            return;
          i ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, _v);
    };
    document.body ? n() : cs.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), Xp.forEach(function(n) {
      return cs.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), Xp.forEach(function(n) {
      return cs.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), lf = new Ov(), Gp = function(e) {
  !Wu && e > 0 && lf.start(), Wu += e, !Wu && lf.stop();
}, Fv = function(e) {
  return !Bf(e) && !kv(e) && getComputedStyle(e).display === "inline";
}, Mv = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Es.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Cm(this.target, this.observedBox, !0);
    return Fv(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), zv = function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Au = /* @__PURE__ */ new WeakMap(), Zp = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Lu = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var a = new zv(t, n);
    Au.set(t, a);
  }, e.observe = function(t, n, a) {
    var i = Au.get(t), l = i.observationTargets.length === 0;
    Zp(i.observationTargets, n) < 0 && (l && Fi.push(i), i.observationTargets.push(new Mv(n, a && a.box)), Gp(1), lf.schedule());
  }, e.unobserve = function(t, n) {
    var a = Au.get(t), i = Zp(a.observationTargets, n), l = a.observationTargets.length === 1;
    i >= 0 && (l && Fi.splice(Fi.indexOf(a), 1), a.observationTargets.splice(i, 1), Gp(-1));
  }, e.disconnect = function(t) {
    var n = this, a = Au.get(t);
    a.observationTargets.slice().forEach(function(i) {
      return n.unobserve(t, i.target);
    }), a.activeTargets.splice(0, a.activeTargets.length);
  }, e;
}(), $v = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Lu.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!jp(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Lu.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!jp(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Lu.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Lu.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const Bv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: $v,
  ResizeObserverEntry: Am,
  ResizeObserverSize: Em
}, Symbol.toStringTag, { value: "Module" })), Iv = /* @__PURE__ */ sg(Bv);
var Qp = Nm, Oa = Dm(og), Hv = Dm(lg), Ho = jv(le), Wv = Iv, Vv = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function Rm(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (Rm = function(i) {
    return i ? n : t;
  })(e);
}
function jv(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = Rm(t);
  if (n && n.has(e))
    return n.get(e);
  var a = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var l in e)
    if (l !== "default" && Object.prototype.hasOwnProperty.call(e, l)) {
      var c = i ? Object.getOwnPropertyDescriptor(e, l) : null;
      c && (c.get || c.set) ? Object.defineProperty(a, l, c) : a[l] = e[l];
    }
  return a.default = e, n && n.set(e, a), a;
}
function Dm(e) {
  return e && e.__esModule ? e : { default: e };
}
function ec() {
  return ec = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, ec.apply(this, arguments);
}
function Uv(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var Kv = [];
function Nm(e) {
  var t = e.className, n = e.children, a = e.debounceTime, i = a === void 0 ? 300 : a, l = e.ignoreDimensions, c = l === void 0 ? Kv : l, f = e.parentSizeStyles, u = f === void 0 ? {
    width: "100%",
    height: "100%"
  } : f, m = e.enableDebounceLeadingCall, y = m === void 0 ? !0 : m, v = Uv(e, Vv), x = (0, Ho.useRef)(null), A = (0, Ho.useRef)(0), T = (0, Ho.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), M = T[0], E = T[1], p = (0, Ho.useMemo)(function() {
    var C = Array.isArray(c) ? c : [c];
    return (0, Hv.default)(function(_) {
      E(function(w) {
        var R = Object.keys(w), P = R.filter(function(q) {
          return w[q] !== _[q];
        }), z = P.every(function(q) {
          return C.includes(q);
        });
        return z ? w : _;
      });
    }, i, {
      leading: y
    });
  }, [i, y, c]);
  return (0, Ho.useEffect)(function() {
    var C = new Wv.ResizeObserver(function(_) {
      _ === void 0 && (_ = []), _.forEach(function(w) {
        var R = w.contentRect, P = R.left, z = R.top, q = R.width, V = R.height;
        A.current = window.requestAnimationFrame(function() {
          p({
            width: q,
            height: V,
            top: z,
            left: P
          });
        });
      });
    });
    return x.current && C.observe(x.current), function() {
      window.cancelAnimationFrame(A.current), C.disconnect(), p != null && p.cancel && p.cancel();
    };
  }, [p]), /* @__PURE__ */ Ho.default.createElement("div", ec({
    style: u,
    ref: x,
    className: t
  }, v), n(ec({}, M, {
    ref: x.current,
    resize: p
  })));
}
Nm.propTypes = {
  className: Oa.default.string,
  debounceTime: Oa.default.number,
  enableDebounceLeadingCall: Oa.default.bool,
  ignoreDimensions: Oa.default.oneOfType([Oa.default.any, Oa.default.arrayOf(Oa.default.any)]),
  children: Oa.default.func.isRequired
};
var zd = /* @__PURE__ */ new Date(), $d = /* @__PURE__ */ new Date();
function pa(e, t, n, a) {
  function i(l) {
    return e(l = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+l)), l;
  }
  return i.floor = function(l) {
    return e(l = /* @__PURE__ */ new Date(+l)), l;
  }, i.ceil = function(l) {
    return e(l = new Date(l - 1)), t(l, 1), e(l), l;
  }, i.round = function(l) {
    var c = i(l), f = i.ceil(l);
    return l - c < f - l ? c : f;
  }, i.offset = function(l, c) {
    return t(l = /* @__PURE__ */ new Date(+l), c == null ? 1 : Math.floor(c)), l;
  }, i.range = function(l, c, f) {
    var u = [], m;
    if (l = i.ceil(l), f = f == null ? 1 : Math.floor(f), !(l < c) || !(f > 0))
      return u;
    do
      u.push(m = /* @__PURE__ */ new Date(+l)), t(l, f), e(l);
    while (m < l && l < c);
    return u;
  }, i.filter = function(l) {
    return pa(function(c) {
      if (c >= c)
        for (; e(c), !l(c); )
          c.setTime(c - 1);
    }, function(c, f) {
      if (c >= c)
        if (f < 0)
          for (; ++f <= 0; )
            for (; t(c, -1), !l(c); )
              ;
        else
          for (; --f >= 0; )
            for (; t(c, 1), !l(c); )
              ;
    });
  }, n && (i.count = function(l, c) {
    return zd.setTime(+l), $d.setTime(+c), e(zd), e($d), Math.floor(n(zd, $d));
  }, i.every = function(l) {
    return l = Math.floor(l), !isFinite(l) || !(l > 0) ? null : l > 1 ? i.filter(a ? function(c) {
      return a(c) % l === 0;
    } : function(c) {
      return i.count(0, c) % l === 0;
    }) : i;
  }), i;
}
const Yv = 1e3, If = Yv * 60, Xv = If * 60, Hf = Xv * 24, _m = Hf * 7;
var Om = pa(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * If) / Hf,
  (e) => e.getDate() - 1
);
const Fm = Om;
Om.range;
function Hi(e) {
  return pa(function(t) {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setDate(t.getDate() + n * 7);
  }, function(t, n) {
    return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * If) / _m;
  });
}
var Mm = Hi(0), tc = Hi(1), qv = Hi(2), Gv = Hi(3), Jo = Hi(4), Zv = Hi(5), Qv = Hi(6);
Mm.range;
tc.range;
qv.range;
Gv.range;
Jo.range;
Zv.range;
Qv.range;
var Wf = pa(function(e) {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setFullYear(e.getFullYear() + t);
}, function(e, t) {
  return t.getFullYear() - e.getFullYear();
}, function(e) {
  return e.getFullYear();
});
Wf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : pa(function(t) {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setFullYear(t.getFullYear() + n * e);
  });
};
const ks = Wf;
Wf.range;
var zm = pa(function(e) {
  e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCDate(e.getUTCDate() + t);
}, function(e, t) {
  return (t - e) / Hf;
}, function(e) {
  return e.getUTCDate() - 1;
});
const $m = zm;
zm.range;
function Wi(e) {
  return pa(function(t) {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, function(t, n) {
    return (n - t) / _m;
  });
}
var Bm = Wi(0), nc = Wi(1), Jv = Wi(2), ex = Wi(3), el = Wi(4), tx = Wi(5), nx = Wi(6);
Bm.range;
nc.range;
Jv.range;
ex.range;
el.range;
tx.range;
nx.range;
var Vf = pa(function(e) {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, function(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}, function(e) {
  return e.getUTCFullYear();
});
Vf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : pa(function(t) {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setUTCFullYear(t.getUTCFullYear() + n * e);
  });
};
const ws = Vf;
Vf.range;
function Bd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Id(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function as(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function rx(e) {
  var t = e.dateTime, n = e.date, a = e.time, i = e.periods, l = e.days, c = e.shortDays, f = e.months, u = e.shortMonths, m = is(i), y = os(i), v = is(l), x = os(l), A = is(c), T = os(c), M = is(f), E = os(f), p = is(u), C = os(u), _ = {
    a: re,
    A: ae,
    b: K,
    B: U,
    c: null,
    d: ah,
    e: ah,
    f: Cx,
    g: Mx,
    G: $x,
    H: kx,
    I: wx,
    j: Tx,
    L: Im,
    m: Ax,
    M: Lx,
    p: X,
    q: H,
    Q: lh,
    s: sh,
    S: Px,
    u: Rx,
    U: Dx,
    V: Nx,
    w: _x,
    W: Ox,
    x: null,
    X: null,
    y: Fx,
    Y: zx,
    Z: Bx,
    "%": oh
  }, w = {
    a: Te,
    A: be,
    b: ce,
    B: Re,
    c: null,
    d: ih,
    e: ih,
    f: Vx,
    g: Jx,
    G: tb,
    H: Ix,
    I: Hx,
    j: Wx,
    L: Wm,
    m: jx,
    M: Ux,
    p: He,
    q: Ge,
    Q: lh,
    s: sh,
    S: Kx,
    u: Yx,
    U: Xx,
    V: qx,
    w: Gx,
    W: Zx,
    x: null,
    X: null,
    y: Qx,
    Y: eb,
    Z: nb,
    "%": oh
  }, R = {
    a: G,
    A: ee,
    b: W,
    B: Q,
    c: j,
    d: nh,
    e: nh,
    f: xx,
    g: th,
    G: eh,
    H: rh,
    I: rh,
    j: mx,
    L: vx,
    m: hx,
    M: yx,
    p: V,
    q: px,
    Q: Sx,
    s: Ex,
    S: gx,
    u: sx,
    U: ux,
    V: cx,
    w: lx,
    W: dx,
    x: te,
    X: se,
    y: th,
    Y: eh,
    Z: fx,
    "%": bx
  };
  _.x = P(n, _), _.X = P(a, _), _.c = P(t, _), w.x = P(n, w), w.X = P(a, w), w.c = P(t, w);
  function P(Ne, ye) {
    return function(Oe) {
      var ue = [], ie = -1, Ce = 0, $e = Ne.length, Ve, Ee, Ue;
      for (Oe instanceof Date || (Oe = /* @__PURE__ */ new Date(+Oe)); ++ie < $e; )
        Ne.charCodeAt(ie) === 37 && (ue.push(Ne.slice(Ce, ie)), (Ee = Jp[Ve = Ne.charAt(++ie)]) != null ? Ve = Ne.charAt(++ie) : Ee = Ve === "e" ? " " : "0", (Ue = ye[Ve]) && (Ve = Ue(Oe, Ee)), ue.push(Ve), Ce = ie + 1);
      return ue.push(Ne.slice(Ce, ie)), ue.join("");
    };
  }
  function z(Ne, ye) {
    return function(Oe) {
      var ue = as(1900, void 0, 1), ie = q(ue, Ne, Oe += "", 0), Ce, $e;
      if (ie != Oe.length)
        return null;
      if ("Q" in ue)
        return new Date(ue.Q);
      if ("s" in ue)
        return new Date(ue.s * 1e3 + ("L" in ue ? ue.L : 0));
      if (ye && !("Z" in ue) && (ue.Z = 0), "p" in ue && (ue.H = ue.H % 12 + ue.p * 12), ue.m === void 0 && (ue.m = "q" in ue ? ue.q : 0), "V" in ue) {
        if (ue.V < 1 || ue.V > 53)
          return null;
        "w" in ue || (ue.w = 1), "Z" in ue ? (Ce = Id(as(ue.y, 0, 1)), $e = Ce.getUTCDay(), Ce = $e > 4 || $e === 0 ? nc.ceil(Ce) : nc(Ce), Ce = $m.offset(Ce, (ue.V - 1) * 7), ue.y = Ce.getUTCFullYear(), ue.m = Ce.getUTCMonth(), ue.d = Ce.getUTCDate() + (ue.w + 6) % 7) : (Ce = Bd(as(ue.y, 0, 1)), $e = Ce.getDay(), Ce = $e > 4 || $e === 0 ? tc.ceil(Ce) : tc(Ce), Ce = Fm.offset(Ce, (ue.V - 1) * 7), ue.y = Ce.getFullYear(), ue.m = Ce.getMonth(), ue.d = Ce.getDate() + (ue.w + 6) % 7);
      } else
        ("W" in ue || "U" in ue) && ("w" in ue || (ue.w = "u" in ue ? ue.u % 7 : "W" in ue ? 1 : 0), $e = "Z" in ue ? Id(as(ue.y, 0, 1)).getUTCDay() : Bd(as(ue.y, 0, 1)).getDay(), ue.m = 0, ue.d = "W" in ue ? (ue.w + 6) % 7 + ue.W * 7 - ($e + 5) % 7 : ue.w + ue.U * 7 - ($e + 6) % 7);
      return "Z" in ue ? (ue.H += ue.Z / 100 | 0, ue.M += ue.Z % 100, Id(ue)) : Bd(ue);
    };
  }
  function q(Ne, ye, Oe, ue) {
    for (var ie = 0, Ce = ye.length, $e = Oe.length, Ve, Ee; ie < Ce; ) {
      if (ue >= $e)
        return -1;
      if (Ve = ye.charCodeAt(ie++), Ve === 37) {
        if (Ve = ye.charAt(ie++), Ee = R[Ve in Jp ? ye.charAt(ie++) : Ve], !Ee || (ue = Ee(Ne, Oe, ue)) < 0)
          return -1;
      } else if (Ve != Oe.charCodeAt(ue++))
        return -1;
    }
    return ue;
  }
  function V(Ne, ye, Oe) {
    var ue = m.exec(ye.slice(Oe));
    return ue ? (Ne.p = y.get(ue[0].toLowerCase()), Oe + ue[0].length) : -1;
  }
  function G(Ne, ye, Oe) {
    var ue = A.exec(ye.slice(Oe));
    return ue ? (Ne.w = T.get(ue[0].toLowerCase()), Oe + ue[0].length) : -1;
  }
  function ee(Ne, ye, Oe) {
    var ue = v.exec(ye.slice(Oe));
    return ue ? (Ne.w = x.get(ue[0].toLowerCase()), Oe + ue[0].length) : -1;
  }
  function W(Ne, ye, Oe) {
    var ue = p.exec(ye.slice(Oe));
    return ue ? (Ne.m = C.get(ue[0].toLowerCase()), Oe + ue[0].length) : -1;
  }
  function Q(Ne, ye, Oe) {
    var ue = M.exec(ye.slice(Oe));
    return ue ? (Ne.m = E.get(ue[0].toLowerCase()), Oe + ue[0].length) : -1;
  }
  function j(Ne, ye, Oe) {
    return q(Ne, t, ye, Oe);
  }
  function te(Ne, ye, Oe) {
    return q(Ne, n, ye, Oe);
  }
  function se(Ne, ye, Oe) {
    return q(Ne, a, ye, Oe);
  }
  function re(Ne) {
    return c[Ne.getDay()];
  }
  function ae(Ne) {
    return l[Ne.getDay()];
  }
  function K(Ne) {
    return u[Ne.getMonth()];
  }
  function U(Ne) {
    return f[Ne.getMonth()];
  }
  function X(Ne) {
    return i[+(Ne.getHours() >= 12)];
  }
  function H(Ne) {
    return 1 + ~~(Ne.getMonth() / 3);
  }
  function Te(Ne) {
    return c[Ne.getUTCDay()];
  }
  function be(Ne) {
    return l[Ne.getUTCDay()];
  }
  function ce(Ne) {
    return u[Ne.getUTCMonth()];
  }
  function Re(Ne) {
    return f[Ne.getUTCMonth()];
  }
  function He(Ne) {
    return i[+(Ne.getUTCHours() >= 12)];
  }
  function Ge(Ne) {
    return 1 + ~~(Ne.getUTCMonth() / 3);
  }
  return {
    format: function(Ne) {
      var ye = P(Ne += "", _);
      return ye.toString = function() {
        return Ne;
      }, ye;
    },
    parse: function(Ne) {
      var ye = z(Ne += "", !1);
      return ye.toString = function() {
        return Ne;
      }, ye;
    },
    utcFormat: function(Ne) {
      var ye = P(Ne += "", w);
      return ye.toString = function() {
        return Ne;
      }, ye;
    },
    utcParse: function(Ne) {
      var ye = z(Ne += "", !0);
      return ye.toString = function() {
        return Ne;
      }, ye;
    }
  };
}
var Jp = { "-": "", _: " ", 0: "0" }, Un = /^\s*\d+/, ax = /^%/, ix = /[\\^$*+?|[\]().{}]/g;
function Xt(e, t, n) {
  var a = e < 0 ? "-" : "", i = (a ? -e : e) + "", l = i.length;
  return a + (l < n ? new Array(n - l + 1).join(t) + i : i);
}
function ox(e) {
  return e.replace(ix, "\\$&");
}
function is(e) {
  return new RegExp("^(?:" + e.map(ox).join("|") + ")", "i");
}
function os(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function lx(e, t, n) {
  var a = Un.exec(t.slice(n, n + 1));
  return a ? (e.w = +a[0], n + a[0].length) : -1;
}
function sx(e, t, n) {
  var a = Un.exec(t.slice(n, n + 1));
  return a ? (e.u = +a[0], n + a[0].length) : -1;
}
function ux(e, t, n) {
  var a = Un.exec(t.slice(n, n + 2));
  return a ? (e.U = +a[0], n + a[0].length) : -1;
}
function cx(e, t, n) {
  var a = Un.exec(t.slice(n, n + 2));
  return a ? (e.V = +a[0], n + a[0].length) : -1;
}
function dx(e, t, n) {
  var a = Un.exec(t.slice(n, n + 2));
  return a ? (e.W = +a[0], n + a[0].length) : -1;
}
function eh(e, t, n) {
  var a = Un.exec(t.slice(n, n + 4));
  return a ? (e.y = +a[0], n + a[0].length) : -1;
}
function th(e, t, n) {
  var a = Un.exec(t.slice(n, n + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), n + a[0].length) : -1;
}
function fx(e, t, n) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), n + a[0].length) : -1;
}
function px(e, t, n) {
  var a = Un.exec(t.slice(n, n + 1));
  return a ? (e.q = a[0] * 3 - 3, n + a[0].length) : -1;
}
function hx(e, t, n) {
  var a = Un.exec(t.slice(n, n + 2));
  return a ? (e.m = a[0] - 1, n + a[0].length) : -1;
}
function nh(e, t, n) {
  var a = Un.exec(t.slice(n, n + 2));
  return a ? (e.d = +a[0], n + a[0].length) : -1;
}
function mx(e, t, n) {
  var a = Un.exec(t.slice(n, n + 3));
  return a ? (e.m = 0, e.d = +a[0], n + a[0].length) : -1;
}
function rh(e, t, n) {
  var a = Un.exec(t.slice(n, n + 2));
  return a ? (e.H = +a[0], n + a[0].length) : -1;
}
function yx(e, t, n) {
  var a = Un.exec(t.slice(n, n + 2));
  return a ? (e.M = +a[0], n + a[0].length) : -1;
}
function gx(e, t, n) {
  var a = Un.exec(t.slice(n, n + 2));
  return a ? (e.S = +a[0], n + a[0].length) : -1;
}
function vx(e, t, n) {
  var a = Un.exec(t.slice(n, n + 3));
  return a ? (e.L = +a[0], n + a[0].length) : -1;
}
function xx(e, t, n) {
  var a = Un.exec(t.slice(n, n + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), n + a[0].length) : -1;
}
function bx(e, t, n) {
  var a = ax.exec(t.slice(n, n + 1));
  return a ? n + a[0].length : -1;
}
function Sx(e, t, n) {
  var a = Un.exec(t.slice(n));
  return a ? (e.Q = +a[0], n + a[0].length) : -1;
}
function Ex(e, t, n) {
  var a = Un.exec(t.slice(n));
  return a ? (e.s = +a[0], n + a[0].length) : -1;
}
function ah(e, t) {
  return Xt(e.getDate(), t, 2);
}
function kx(e, t) {
  return Xt(e.getHours(), t, 2);
}
function wx(e, t) {
  return Xt(e.getHours() % 12 || 12, t, 2);
}
function Tx(e, t) {
  return Xt(1 + Fm.count(ks(e), e), t, 3);
}
function Im(e, t) {
  return Xt(e.getMilliseconds(), t, 3);
}
function Cx(e, t) {
  return Im(e, t) + "000";
}
function Ax(e, t) {
  return Xt(e.getMonth() + 1, t, 2);
}
function Lx(e, t) {
  return Xt(e.getMinutes(), t, 2);
}
function Px(e, t) {
  return Xt(e.getSeconds(), t, 2);
}
function Rx(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function Dx(e, t) {
  return Xt(Mm.count(ks(e) - 1, e), t, 2);
}
function Hm(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Jo(e) : Jo.ceil(e);
}
function Nx(e, t) {
  return e = Hm(e), Xt(Jo.count(ks(e), e) + (ks(e).getDay() === 4), t, 2);
}
function _x(e) {
  return e.getDay();
}
function Ox(e, t) {
  return Xt(tc.count(ks(e) - 1, e), t, 2);
}
function Fx(e, t) {
  return Xt(e.getFullYear() % 100, t, 2);
}
function Mx(e, t) {
  return e = Hm(e), Xt(e.getFullYear() % 100, t, 2);
}
function zx(e, t) {
  return Xt(e.getFullYear() % 1e4, t, 4);
}
function $x(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? Jo(e) : Jo.ceil(e), Xt(e.getFullYear() % 1e4, t, 4);
}
function Bx(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Xt(t / 60 | 0, "0", 2) + Xt(t % 60, "0", 2);
}
function ih(e, t) {
  return Xt(e.getUTCDate(), t, 2);
}
function Ix(e, t) {
  return Xt(e.getUTCHours(), t, 2);
}
function Hx(e, t) {
  return Xt(e.getUTCHours() % 12 || 12, t, 2);
}
function Wx(e, t) {
  return Xt(1 + $m.count(ws(e), e), t, 3);
}
function Wm(e, t) {
  return Xt(e.getUTCMilliseconds(), t, 3);
}
function Vx(e, t) {
  return Wm(e, t) + "000";
}
function jx(e, t) {
  return Xt(e.getUTCMonth() + 1, t, 2);
}
function Ux(e, t) {
  return Xt(e.getUTCMinutes(), t, 2);
}
function Kx(e, t) {
  return Xt(e.getUTCSeconds(), t, 2);
}
function Yx(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function Xx(e, t) {
  return Xt(Bm.count(ws(e) - 1, e), t, 2);
}
function Vm(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? el(e) : el.ceil(e);
}
function qx(e, t) {
  return e = Vm(e), Xt(el.count(ws(e), e) + (ws(e).getUTCDay() === 4), t, 2);
}
function Gx(e) {
  return e.getUTCDay();
}
function Zx(e, t) {
  return Xt(nc.count(ws(e) - 1, e), t, 2);
}
function Qx(e, t) {
  return Xt(e.getUTCFullYear() % 100, t, 2);
}
function Jx(e, t) {
  return e = Vm(e), Xt(e.getUTCFullYear() % 100, t, 2);
}
function eb(e, t) {
  return Xt(e.getUTCFullYear() % 1e4, t, 4);
}
function tb(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? el(e) : el.ceil(e), Xt(e.getUTCFullYear() % 1e4, t, 4);
}
function nb() {
  return "+0000";
}
function oh() {
  return "%";
}
function lh(e) {
  return +e;
}
function sh(e) {
  return Math.floor(+e / 1e3);
}
var Wo, sf, jm;
rb({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function rb(e) {
  return Wo = rx(e), sf = Wo.format, jm = Wo.parse, Wo.utcFormat, Wo.utcParse, Wo;
}
const bt = le.createContext({}), It = {
  arr: Array.isArray,
  obj: (e) => Object.prototype.toString.call(e) === "[object Object]",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0,
  nul: (e) => e === null,
  set: (e) => e instanceof Set,
  map: (e) => e instanceof Map,
  equ(e, t) {
    if (typeof e != typeof t)
      return !1;
    if (It.str(e) || It.num(e))
      return e === t;
    if (It.obj(e) && It.obj(t) && Object.keys(e).length + Object.keys(t).length === 0)
      return !0;
    let n;
    for (n in e)
      if (!(n in t))
        return !1;
    for (n in t)
      if (e[n] !== t[n])
        return !1;
    return It.und(n) ? e === t : !0;
  }
};
function ab(e, t) {
  return t === void 0 && (t = !0), (n) => (It.arr(n) ? n : Object.keys(n)).reduce((a, i) => {
    const l = t ? i[0].toLowerCase() + i.substring(1) : i;
    return a[l] = e(l), a;
  }, e);
}
function Um() {
  const e = le.useState(!1), t = e[1];
  return le.useCallback(() => t((a) => !a), []);
}
function Ai(e, t) {
  return It.und(e) || It.nul(e) ? t : e;
}
function qo(e) {
  return It.und(e) ? [] : It.arr(e) ? e : [e];
}
function Or(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    n[a - 1] = arguments[a];
  return It.fun(e) ? e(...n) : e;
}
function ib(e) {
  return e.to, e.from, e.config, e.onStart, e.onRest, e.onFrame, e.children, e.reset, e.reverse, e.force, e.immediate, e.delay, e.attach, e.destroyed, e.interpolateTo, e.ref, e.lazy, qr(e, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
}
function Hd(e) {
  const t = ib(e);
  if (It.und(t))
    return dn({
      to: t
    }, e);
  const n = Object.keys(e).reduce((a, i) => It.und(t[i]) ? dn({}, a, {
    [i]: e[i]
  }) : a, {});
  return dn({
    to: t
  }, n);
}
function ob(e, t) {
  return t && (It.fun(t) ? t(e) : It.obj(t) && (t.current = e)), e;
}
class Fr {
  constructor() {
    this.payload = void 0, this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(t) {
    this.children.length === 0 && this.attach(), this.children.push(t);
  }
  removeChild(t) {
    const n = this.children.indexOf(t);
    this.children.splice(n, 1), this.children.length === 0 && this.detach();
  }
}
class uf extends Fr {
  constructor() {
    super(...arguments), this.payload = [], this.attach = () => this.payload.forEach((t) => t instanceof Fr && t.addChild(this)), this.detach = () => this.payload.forEach((t) => t instanceof Fr && t.removeChild(this));
  }
}
class Km extends Fr {
  constructor() {
    super(...arguments), this.payload = {}, this.attach = () => Object.values(this.payload).forEach((t) => t instanceof Fr && t.addChild(this)), this.detach = () => Object.values(this.payload).forEach((t) => t instanceof Fr && t.removeChild(this));
  }
  getValue(t) {
    t === void 0 && (t = !1);
    const n = {};
    for (const a in this.payload) {
      const i = this.payload[a];
      t && !(i instanceof Fr) || (n[a] = i instanceof Fr ? i[t ? "getAnimatedValue" : "getValue"]() : i);
    }
    return n;
  }
  getAnimatedValue() {
    return this.getValue(!0);
  }
}
let jf;
function lb(e, t) {
  jf = {
    fn: e,
    transform: t
  };
}
let Ym;
function sb(e) {
  Ym = e;
}
let Xm = (e) => typeof window < "u" ? window.requestAnimationFrame(e) : -1, rc;
function ub(e) {
  rc = e;
}
let qm = () => Date.now(), cb = (e) => e.current, Gm;
function db(e) {
  Gm = e;
}
class fb extends Km {
  constructor(t, n) {
    super(), this.update = void 0, this.payload = t.style ? dn({}, t, {
      style: Gm(t.style)
    }) : t, this.update = n, this.attach();
  }
}
const pb = (e) => It.fun(e) && !(e.prototype instanceof r.Component), hb = (e) => le.forwardRef((n, a) => {
  const i = Um(), l = le.useRef(!0), c = le.useRef(null), f = le.useRef(null), u = le.useCallback((x) => {
    const A = c.current, T = () => {
      let M = !1;
      f.current && (M = jf.fn(f.current, c.current.getAnimatedValue())), (!f.current || M === !1) && i();
    };
    c.current = new fb(x, T), A && A.detach();
  }, []);
  le.useEffect(() => () => {
    l.current = !1, c.current && c.current.detach();
  }, []), le.useImperativeHandle(a, () => cb(f)), u(n);
  const m = c.current.getValue();
  m.scrollTop, m.scrollLeft;
  const y = qr(m, ["scrollTop", "scrollLeft"]), v = pb(e) ? void 0 : (x) => f.current = ob(x, a);
  return r.createElement(e, dn({}, y, {
    ref: v
  }));
});
let ds = !1;
const zi = /* @__PURE__ */ new Set(), Zm = () => {
  if (!ds)
    return !1;
  let e = qm();
  for (let t of zi) {
    let n = !1;
    for (let a = 0; a < t.configs.length; a++) {
      let i = t.configs[a], l, c;
      for (let f = 0; f < i.animatedValues.length; f++) {
        let u = i.animatedValues[f];
        if (u.done)
          continue;
        let m = i.fromValues[f], y = i.toValues[f], v = u.lastPosition, x = y instanceof Fr, A = Array.isArray(i.initialVelocity) ? i.initialVelocity[f] : i.initialVelocity;
        if (x && (y = y.getValue()), i.immediate) {
          u.setValue(y), u.done = !0;
          continue;
        }
        if (typeof m == "string" || typeof y == "string") {
          u.setValue(y), u.done = !0;
          continue;
        }
        if (i.duration !== void 0)
          v = m + i.easing((e - u.startTime) / i.duration) * (y - m), l = e >= u.startTime + i.duration;
        else if (i.decay)
          v = m + A / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (e - u.startTime))), l = Math.abs(u.lastPosition - v) < 0.1, l && (y = v);
        else {
          c = u.lastTime !== void 0 ? u.lastTime : e, A = u.lastVelocity !== void 0 ? u.lastVelocity : i.initialVelocity, e > c + 64 && (c = e);
          let T = Math.floor(e - c);
          for (let C = 0; C < T; ++C) {
            let _ = -i.tension * (v - y), w = -i.friction * A, R = (_ + w) / i.mass;
            A = A + R * 1 / 1e3, v = v + A * 1 / 1e3;
          }
          let M = i.clamp && i.tension !== 0 ? m < y ? v > y : v < y : !1, E = Math.abs(A) <= i.precision, p = i.tension !== 0 ? Math.abs(y - v) <= i.precision : !0;
          l = M || E && p, u.lastVelocity = A, u.lastTime = e;
        }
        x && !i.toValues[f].done && (l = !1), l ? (u.value !== y && (v = y), u.done = !0) : n = !0, u.setValue(v), u.lastPosition = v;
      }
      t.props.onFrame && (t.values[i.name] = i.interpolation.getValue());
    }
    t.props.onFrame && t.props.onFrame(t.values), n || (zi.delete(t), t.stop(!0));
  }
  return zi.size ? Xm(Zm) : ds = !1, ds;
}, mb = (e) => {
  zi.has(e) || zi.add(e), ds || (ds = !0, Xm(Zm));
}, yb = (e) => {
  zi.has(e) && zi.delete(e);
};
function ac(e, t, n) {
  if (typeof e == "function")
    return e;
  if (Array.isArray(e))
    return ac({
      range: e,
      output: t,
      extrapolate: n
    });
  if (rc && typeof e.output[0] == "string")
    return rc(e);
  const a = e, i = a.output, l = a.range || [0, 1], c = a.extrapolateLeft || a.extrapolate || "extend", f = a.extrapolateRight || a.extrapolate || "extend", u = a.easing || ((m) => m);
  return (m) => {
    const y = vb(m, l);
    return gb(m, l[y], l[y + 1], i[y], i[y + 1], u, c, f, a.map);
  };
}
function gb(e, t, n, a, i, l, c, f, u) {
  let m = u ? u(e) : e;
  if (m < t) {
    if (c === "identity")
      return m;
    c === "clamp" && (m = t);
  }
  if (m > n) {
    if (f === "identity")
      return m;
    f === "clamp" && (m = n);
  }
  return a === i ? a : t === n ? e <= t ? a : i : (t === -1 / 0 ? m = -m : n === 1 / 0 ? m = m - t : m = (m - t) / (n - t), m = l(m), a === -1 / 0 ? m = -m : i === 1 / 0 ? m = m + a : m = m * (i - a) + a, m);
}
function vb(e, t) {
  for (var n = 1; n < t.length - 1 && !(t[n] >= e); ++n)
    ;
  return n - 1;
}
class tl extends uf {
  constructor(t, n, a, i) {
    super(), this.calc = void 0, this.payload = t instanceof uf && !(t instanceof tl) ? t.getPayload() : Array.isArray(t) ? t : [t], this.calc = ac(n, a, i);
  }
  getValue() {
    return this.calc(...this.payload.map((t) => t.getValue()));
  }
  updateConfig(t, n, a) {
    this.calc = ac(t, n, a);
  }
  interpolate(t, n, a) {
    return new tl(this, t, n, a);
  }
}
const xb = (e, t, n) => e && new tl(e, t, n);
function Qm(e, t) {
  "update" in e ? t.add(e) : e.getChildren().forEach((n) => Qm(n, t));
}
class cf extends Fr {
  constructor(t) {
    var n;
    super(), n = this, this.animatedStyles = /* @__PURE__ */ new Set(), this.value = void 0, this.startPosition = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.startTime = void 0, this.lastTime = void 0, this.done = !1, this.setValue = function(a, i) {
      i === void 0 && (i = !0), n.value = a, i && n.flush();
    }, this.value = t, this.startPosition = t, this.lastPosition = t;
  }
  flush() {
    this.animatedStyles.size === 0 && Qm(this, this.animatedStyles), this.animatedStyles.forEach((t) => t.update());
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  getValue() {
    return this.value;
  }
  interpolate(t, n, a) {
    return new tl(this, t, n, a);
  }
}
class bb extends uf {
  constructor(t) {
    super(), this.payload = t.map((n) => new cf(n));
  }
  setValue(t, n) {
    n === void 0 && (n = !0), Array.isArray(t) ? t.length === this.payload.length && t.forEach((a, i) => this.payload[i].setValue(a, n)) : this.payload.forEach((a) => a.setValue(t, n));
  }
  getValue() {
    return this.payload.map((t) => t.getValue());
  }
  interpolate(t, n) {
    return new tl(this, t, n);
  }
}
let Sb = 0;
class Eb {
  constructor() {
    this.id = void 0, this.idle = !0, this.hasChanged = !1, this.guid = 0, this.local = 0, this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.listeners = [], this.queue = [], this.localQueue = void 0, this.getValues = () => this.interpolations, this.id = Sb++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */
  update(t) {
    if (!t)
      return this;
    const n = Hd(t), a = n.delay, i = a === void 0 ? 0 : a, l = n.to, c = qr(n, ["delay", "to"]);
    if (It.arr(l) || It.fun(l))
      this.queue.push(dn({}, c, {
        delay: i,
        to: l
      }));
    else if (l) {
      let f = {};
      Object.entries(l).forEach((u) => {
        let m = u[0], y = u[1];
        const v = dn({
          to: {
            [m]: y
          },
          delay: Or(i, m)
        }, c), x = f[v.delay] && f[v.delay].to;
        f[v.delay] = dn({}, f[v.delay], v, {
          to: dn({}, x, v.to)
        });
      }), this.queue = Object.values(f);
    }
    return this.queue = this.queue.sort((f, u) => f.delay - u.delay), this.diff(c), this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  start(t) {
    if (this.queue.length) {
      this.idle = !1, this.localQueue && this.localQueue.forEach((i) => {
        let l = i.from, c = l === void 0 ? {} : l, f = i.to, u = f === void 0 ? {} : f;
        It.obj(c) && (this.merged = dn({}, c, this.merged)), It.obj(u) && (this.merged = dn({}, this.merged, u));
      });
      const n = this.local = ++this.guid, a = this.localQueue = this.queue;
      this.queue = [], a.forEach((i, l) => {
        let c = i.delay, f = qr(i, ["delay"]);
        const u = (y) => {
          l === a.length - 1 && n === this.guid && y && (this.idle = !0, this.props.onRest && this.props.onRest(this.merged)), t && t();
        };
        let m = It.arr(f.to) || It.fun(f.to);
        c ? setTimeout(() => {
          n === this.guid && (m ? this.runAsync(f, u) : this.diff(f).start(u));
        }, c) : m ? this.runAsync(f, u) : this.diff(f).start(u);
      });
    } else
      It.fun(t) && this.listeners.push(t), this.props.onStart && this.props.onStart(), mb(this);
    return this;
  }
  stop(t) {
    return this.listeners.forEach((n) => n(t)), this.listeners = [], this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  pause(t) {
    return this.stop(!0), t && yb(this), this;
  }
  runAsync(t, n) {
    var a = this;
    t.delay;
    let i = qr(t, ["delay"]);
    const l = this.local;
    let c = Promise.resolve(void 0);
    if (It.arr(i.to))
      for (let f = 0; f < i.to.length; f++) {
        const u = f, m = dn({}, i, Hd(i.to[u]));
        It.arr(m.config) && (m.config = m.config[u]), c = c.then(() => {
          if (l === this.guid)
            return new Promise((y) => this.diff(m).start(y));
        });
      }
    else if (It.fun(i.to)) {
      let f = 0, u;
      c = c.then(() => i.to(
        // next(props)
        (m) => {
          const y = dn({}, i, Hd(m));
          if (It.arr(y.config) && (y.config = y.config[f]), f++, l === this.guid)
            return u = new Promise((v) => this.diff(y).start(v));
        },
        // cancel()
        function(m) {
          return m === void 0 && (m = !0), a.stop(m);
        }
      ).then(() => u));
    }
    c.then(n);
  }
  diff(t) {
    this.props = dn({}, this.props, t);
    let n = this.props, a = n.from, i = a === void 0 ? {} : a, l = n.to, c = l === void 0 ? {} : l, f = n.config, u = f === void 0 ? {} : f, m = n.reverse, y = n.attach, v = n.reset, x = n.immediate;
    if (m) {
      var A = [c, i];
      i = A[0], c = A[1];
    }
    this.merged = dn({}, i, this.merged, c), this.hasChanged = !1;
    let T = y && y(this);
    if (this.animations = Object.entries(this.merged).reduce((M, E) => {
      let p = E[0], C = E[1], _ = M[p] || {};
      const w = It.num(C), R = It.str(C) && !C.startsWith("#") && !/\d/.test(C) && !Ym[C], P = It.arr(C), z = !w && !P && !R;
      let q = It.und(i[p]) ? C : i[p], V = w || P || R ? C : 1, G = Or(u, p);
      T && (V = T.animations[p].parent);
      let ee = _.parent, W = _.interpolation, Q = qo(T ? V.getPayload() : V), j, te = C;
      z && (te = rc({
        range: [0, 1],
        output: [C, C]
      })(1));
      let se = W && W.getValue();
      const ae = !It.und(ee) && _.animatedValues.some((H) => !H.done), K = !It.equ(te, se), U = !It.equ(te, _.previous), X = !It.equ(G, _.config);
      if (v || U && K || X) {
        if (w || R)
          ee = W = _.parent || new cf(q);
        else if (P)
          ee = W = _.parent || new bb(q);
        else if (z) {
          let H = _.interpolation && _.interpolation.calc(_.parent.value);
          H = H !== void 0 && !v ? H : q, _.parent ? (ee = _.parent, ee.setValue(0, !1)) : ee = new cf(0);
          const Te = {
            output: [H, C]
          };
          _.interpolation ? (W = _.interpolation, _.interpolation.updateConfig(Te)) : W = ee.interpolate(Te);
        }
        return Q = qo(T ? V.getPayload() : V), j = qo(ee.getPayload()), v && !z && ee.setValue(q, !1), this.hasChanged = !0, j.forEach((H) => {
          H.startPosition = H.value, H.lastPosition = H.value, H.lastVelocity = ae ? H.lastVelocity : void 0, H.lastTime = ae ? H.lastTime : void 0, H.startTime = qm(), H.done = !1, H.animatedStyles.clear();
        }), Or(x, p) && ee.setValue(z ? V : C, !1), dn({}, M, {
          [p]: dn({}, _, {
            name: p,
            parent: ee,
            interpolation: W,
            animatedValues: j,
            toValues: Q,
            previous: te,
            config: G,
            fromValues: qo(ee.getValue()),
            immediate: Or(x, p),
            initialVelocity: Ai(G.velocity, 0),
            clamp: Ai(G.clamp, !1),
            precision: Ai(G.precision, 0.01),
            tension: Ai(G.tension, 170),
            friction: Ai(G.friction, 26),
            mass: Ai(G.mass, 1),
            duration: G.duration,
            easing: Ai(G.easing, (H) => H),
            decay: G.decay
          })
        });
      } else
        return K ? M : (z && (ee.setValue(1, !1), W.updateConfig({
          output: [te, te]
        })), ee.done = !0, this.hasChanged = !0, dn({}, M, {
          [p]: dn({}, M[p], {
            previous: te
          })
        }));
    }, this.animations), this.hasChanged) {
      this.configs = Object.values(this.animations), this.values = {}, this.interpolations = {};
      for (let M in this.animations)
        this.interpolations[M] = this.animations[M].interpolation, this.values[M] = this.animations[M].interpolation.getValue();
    }
    return this;
  }
  destroy() {
    this.stop(), this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.local = 0;
  }
}
let kb = 0;
const Vu = "enter", Wd = "leave", Vd = "update", wb = (e, t) => (typeof t == "function" ? e.map(t) : qo(t)).map(String), df = (e) => {
  let t = e.items, n = e.keys, a = n === void 0 ? (l) => l : n, i = qr(e, ["items", "keys"]);
  return t = qo(t !== void 0 ? t : null), dn({
    items: t,
    keys: wb(t, a)
  }, i);
};
function Tb(e, t, n) {
  const a = dn({
    items: e,
    keys: t || ((C) => C)
  }, n), i = df(a), l = i.lazy, c = l === void 0 ? !1 : l;
  i.unique;
  const f = i.reset, u = f === void 0 ? !1 : f;
  i.enter, i.leave, i.update;
  const m = i.onDestroyed;
  i.keys, i.items;
  const y = i.onFrame, v = i.onRest, x = i.onStart, A = i.ref, T = qr(i, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]), M = Um(), E = le.useRef(!1), p = le.useRef({
    mounted: !1,
    first: !0,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!a.ref,
    instances: !E.current && /* @__PURE__ */ new Map(),
    forceUpdate: M
  });
  return le.useImperativeHandle(a.ref, () => ({
    start: () => Promise.all(Array.from(p.current.instances).map((C) => {
      let _ = C[1];
      return new Promise((w) => _.start(w));
    })),
    stop: (C) => Array.from(p.current.instances).forEach((_) => _[1].stop(C)),
    get controllers() {
      return Array.from(p.current.instances).map((C) => C[1]);
    }
  })), p.current = Cb(p.current, a), p.current.changed && p.current.transitions.forEach((C) => {
    const _ = C.slot, w = C.from, R = C.to, P = C.config, z = C.trail, q = C.key, V = C.item;
    p.current.instances.has(q) || p.current.instances.set(q, new Eb());
    const G = p.current.instances.get(q), ee = dn({}, T, {
      to: R,
      from: w,
      config: P,
      ref: A,
      onRest: (W) => {
        p.current.mounted && (C.destroyed && (!A && !c && uh(p, q), m && m(V)), !Array.from(p.current.instances).some((te) => !te[1].idle) && (A || c) && p.current.deleted.length > 0 && uh(p), v && v(V, _, W));
      },
      onStart: x && (() => x(V, _)),
      onFrame: y && ((W) => y(V, _, W)),
      delay: z,
      reset: u && _ === Vu
      // Update controller
    });
    G.update(ee), p.current.paused || G.start();
  }), le.useEffect(() => (p.current.mounted = E.current = !0, () => {
    p.current.mounted = E.current = !1, Array.from(p.current.instances).map((C) => C[1].destroy()), p.current.instances.clear();
  }), []), p.current.transitions.map((C) => {
    let _ = C.item, w = C.slot, R = C.key;
    return {
      item: _,
      key: R,
      state: w,
      props: p.current.instances.get(R).getValues()
    };
  });
}
function uh(e, t) {
  const n = e.current.deleted;
  for (let a of n) {
    let i = a.key;
    const l = (c) => c.key !== i;
    (It.und(t) || t === i) && (e.current.instances.delete(i), e.current.transitions = e.current.transitions.filter(l), e.current.deleted = e.current.deleted.filter(l));
  }
  e.current.forceUpdate();
}
function Cb(e, t) {
  let n = e.first, a = e.prevProps, i = qr(e, ["first", "prevProps"]), l = df(t), c = l.items, f = l.keys, u = l.initial, m = l.from, y = l.enter, v = l.leave, x = l.update, A = l.trail, T = A === void 0 ? 0 : A, M = l.unique, E = l.config, p = l.order, C = p === void 0 ? [Vu, Wd, Vd] : p, _ = df(a), w = _.keys, R = _.items, P = dn({}, i.current), z = [...i.deleted], q = Object.keys(P), V = new Set(q), G = new Set(f), ee = f.filter((se) => !V.has(se)), W = i.transitions.filter((se) => !se.destroyed && !G.has(se.originalKey)).map((se) => se.originalKey), Q = f.filter((se) => V.has(se)), j = -T;
  for (; C.length; )
    switch (C.shift()) {
      case Vu: {
        ee.forEach((re, ae) => {
          M && z.find((H) => H.originalKey === re) && (z = z.filter((H) => H.originalKey !== re));
          const K = f.indexOf(re), U = c[K], X = n && u !== void 0 ? "initial" : Vu;
          P[re] = {
            slot: X,
            originalKey: re,
            key: M ? String(re) : kb++,
            item: U,
            trail: j = j + T,
            config: Or(E, U, X),
            from: Or(n && u !== void 0 ? u || {} : m, U),
            to: Or(y, U)
          };
        });
        break;
      }
      case Wd: {
        W.forEach((re) => {
          const ae = w.indexOf(re), K = R[ae], U = Wd;
          z.unshift(dn({}, P[re], {
            slot: U,
            destroyed: !0,
            left: w[Math.max(0, ae - 1)],
            right: w[Math.min(w.length, ae + 1)],
            trail: j = j + T,
            config: Or(E, K, U),
            to: Or(v, K)
          })), delete P[re];
        });
        break;
      }
      case Vd: {
        Q.forEach((re) => {
          const ae = f.indexOf(re), K = c[ae], U = Vd;
          P[re] = dn({}, P[re], {
            item: K,
            slot: U,
            trail: j = j + T,
            config: Or(E, K, U),
            to: Or(x, K)
          });
        });
        break;
      }
    }
  let te = f.map((se) => P[se]);
  return z.forEach((se) => {
    let re = se.left;
    se.right;
    let ae = qr(se, ["left", "right"]), K;
    (K = te.findIndex((U) => U.originalKey === re)) !== -1 && (K += 1), K = Math.max(0, K), te = [...te.slice(0, K), ae, ...te.slice(K)];
  }), dn({}, i, {
    changed: ee.length || W.length || Q.length,
    first: n && ee.length === 0,
    transitions: te,
    current: P,
    deleted: z,
    prevProps: t
  });
}
class Ab extends Km {
  constructor(t) {
    t === void 0 && (t = {}), super(), t.transform && !(t.transform instanceof Fr) && (t = jf.transform(t)), this.payload = t;
  }
}
const ic = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, Mr = "[-+]?\\d*\\.?\\d+", oc = Mr + "%";
function Pc() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const Lb = new RegExp("rgb" + Pc(Mr, Mr, Mr)), Pb = new RegExp("rgba" + Pc(Mr, Mr, Mr, Mr)), Rb = new RegExp("hsl" + Pc(Mr, oc, oc)), Db = new RegExp("hsla" + Pc(Mr, oc, oc, Mr)), Nb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, _b = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Ob = /^#([0-9a-fA-F]{6})$/, Fb = /^#([0-9a-fA-F]{8})$/;
function Mb(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = Ob.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : ic.hasOwnProperty(e) ? ic[e] : (t = Lb.exec(e)) ? (Vo(t[1]) << 24 | // r
  Vo(t[2]) << 16 | // g
  Vo(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = Pb.exec(e)) ? (Vo(t[1]) << 24 | // r
  Vo(t[2]) << 16 | // g
  Vo(t[3]) << 8 | // b
  fh(t[4])) >>> // a
  0 : (t = Nb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = Fb.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = _b.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = Rb.exec(e)) ? (ch(
    dh(t[1]),
    // h
    Pu(t[2]),
    // s
    Pu(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = Db.exec(e)) ? (ch(
    dh(t[1]),
    // h
    Pu(t[2]),
    // s
    Pu(t[3])
    // l
  ) | fh(t[4])) >>> // a
  0 : null;
}
function jd(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function ch(e, t, n) {
  const a = n < 0.5 ? n * (1 + t) : n + t - n * t, i = 2 * n - a, l = jd(i, a, e + 1 / 3), c = jd(i, a, e), f = jd(i, a, e - 1 / 3);
  return Math.round(l * 255) << 24 | Math.round(c * 255) << 16 | Math.round(f * 255) << 8;
}
function Vo(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function dh(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function fh(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function Pu(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function ph(e) {
  let t = Mb(e);
  if (t === null)
    return e;
  t = t || 0;
  let n = (t & 4278190080) >>> 24, a = (t & 16711680) >>> 16, i = (t & 65280) >>> 8, l = (t & 255) / 255;
  return `rgba(${n}, ${a}, ${i}, ${l})`;
}
const Ru = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, zb = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, $b = new RegExp(`(${Object.keys(ic).join("|")})`, "g"), Bb = (e) => {
  const t = e.output.map((i) => i.replace(zb, ph)).map((i) => i.replace($b, ph)), n = t[0].match(Ru).map(() => []);
  t.forEach((i) => {
    i.match(Ru).forEach((l, c) => n[c].push(+l));
  });
  const a = t[0].match(Ru).map((i, l) => ac(dn({}, e, {
    output: n[l]
  })));
  return (i) => {
    let l = 0;
    return t[0].replace(Ru, () => a[l++](i)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (c, f, u, m, y) => `rgba(${Math.round(f)}, ${Math.round(u)}, ${Math.round(m)}, ${y})`);
  };
};
let fs = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const Ib = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), Hb = ["Webkit", "Ms", "Moz", "O"];
fs = Object.keys(fs).reduce((e, t) => (Hb.forEach((n) => e[Ib(n, t)] = e[t]), e), fs);
function Wb(e, t, n) {
  return t == null || typeof t == "boolean" || t === "" ? "" : !n && typeof t == "number" && t !== 0 && !(fs.hasOwnProperty(e) && fs[e]) ? t + "px" : ("" + t).trim();
}
const hh = {};
db((e) => new Ab(e));
ub(Bb);
sb(ic);
lb((e, t) => {
  if (e.nodeType && e.setAttribute !== void 0) {
    const i = t.style, l = t.children, c = t.scrollTop, f = t.scrollLeft, u = qr(t, ["style", "children", "scrollTop", "scrollLeft"]), m = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter";
    c !== void 0 && (e.scrollTop = c), f !== void 0 && (e.scrollLeft = f), l !== void 0 && (e.textContent = l);
    for (let y in i)
      if (i.hasOwnProperty(y)) {
        var n = y.indexOf("--") === 0, a = Wb(y, i[y], n);
        y === "float" && (y = "cssFloat"), n ? e.style.setProperty(y, a) : e.style[y] = a;
      }
    for (let y in u) {
      const v = m ? y : hh[y] || (hh[y] = y.replace(/([A-Z])/g, (x) => "-" + x.toLowerCase()));
      typeof e.getAttribute(v) < "u" && e.setAttribute(v, u[y]);
    }
    return;
  } else
    return !1;
}, (e) => e);
const Vb = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], jb = ab(hb, !1), mh = jb(Vb);
function Ub(e) {
  return e.innerRadius;
}
function Kb(e) {
  return e.outerRadius;
}
function Yb(e) {
  return e.startAngle;
}
function Xb(e) {
  return e.endAngle;
}
function qb(e) {
  return e && e.padAngle;
}
function Gb(e, t, n, a, i, l, c, f) {
  var u = n - e, m = a - t, y = c - i, v = f - l, x = v * u - y * m;
  if (!(x * x < er))
    return x = (y * (t - l) - v * (e - i)) / x, [e + x * u, t + x * m];
}
function Du(e, t, n, a, i, l, c) {
  var f = e - n, u = t - a, m = (c ? l : -l) / Yo(f * f + u * u), y = m * u, v = -m * f, x = e + y, A = t + v, T = n + y, M = a + v, E = (x + T) / 2, p = (A + M) / 2, C = T - x, _ = M - A, w = C * C + _ * _, R = i - l, P = x * M - T * A, z = (_ < 0 ? -1 : 1) * Yo(dg(0, R * R * w - P * P)), q = (P * _ - C * z) / w, V = (-P * C - _ * z) / w, G = (P * _ + C * z) / w, ee = (-P * C + _ * z) / w, W = q - E, Q = V - p, j = G - E, te = ee - p;
  return W * W + Q * Q > j * j + te * te && (q = G, V = ee), {
    cx: q,
    cy: V,
    x01: -y,
    y01: -v,
    x11: q * (i / R - 1),
    y11: V * (i / R - 1)
  };
}
function Zb() {
  var e = Ub, t = Kb, n = Ht(0), a = null, i = Yb, l = Xb, c = qb, f = null;
  function u() {
    var m, y, v = +e.apply(this, arguments), x = +t.apply(this, arguments), A = i.apply(this, arguments) - vp, T = l.apply(this, arguments) - vp, M = xp(T - A), E = T > A;
    if (f || (f = m = Ac()), x < v && (y = x, x = v, v = y), !(x > er))
      f.moveTo(0, 0);
    else if (M > Hu - er)
      f.moveTo(x * Ti(A), x * Ur(A)), f.arc(0, 0, x, A, T, !E), v > er && (f.moveTo(v * Ti(T), v * Ur(T)), f.arc(0, 0, v, T, A, E));
    else {
      var p = A, C = T, _ = A, w = T, R = M, P = M, z = c.apply(this, arguments) / 2, q = z > er && (a ? +a.apply(this, arguments) : Yo(v * v + x * x)), V = Nd(xp(x - v) / 2, +n.apply(this, arguments)), G = V, ee = V, W, Q;
      if (q > er) {
        var j = bp(q / v * Ur(z)), te = bp(q / x * Ur(z));
        (R -= j * 2) > er ? (j *= E ? 1 : -1, _ += j, w -= j) : (R = 0, _ = w = (A + T) / 2), (P -= te * 2) > er ? (te *= E ? 1 : -1, p += te, C -= te) : (P = 0, p = C = (A + T) / 2);
      }
      var se = x * Ti(p), re = x * Ur(p), ae = v * Ti(w), K = v * Ur(w);
      if (V > er) {
        var U = x * Ti(C), X = x * Ur(C), H = v * Ti(_), Te = v * Ur(_), be;
        if (M < gp && (be = Gb(se, re, H, Te, U, X, ae, K))) {
          var ce = se - be[0], Re = re - be[1], He = U - be[0], Ge = X - be[1], Ne = 1 / Ur(cg((ce * He + Re * Ge) / (Yo(ce * ce + Re * Re) * Yo(He * He + Ge * Ge))) / 2), ye = Yo(be[0] * be[0] + be[1] * be[1]);
          G = Nd(V, (v - ye) / (Ne - 1)), ee = Nd(V, (x - ye) / (Ne + 1));
        }
      }
      P > er ? ee > er ? (W = Du(H, Te, se, re, x, ee, E), Q = Du(U, X, ae, K, x, ee, E), f.moveTo(W.cx + W.x01, W.cy + W.y01), ee < V ? f.arc(W.cx, W.cy, ee, Zn(W.y01, W.x01), Zn(Q.y01, Q.x01), !E) : (f.arc(W.cx, W.cy, ee, Zn(W.y01, W.x01), Zn(W.y11, W.x11), !E), f.arc(0, 0, x, Zn(W.cy + W.y11, W.cx + W.x11), Zn(Q.cy + Q.y11, Q.cx + Q.x11), !E), f.arc(Q.cx, Q.cy, ee, Zn(Q.y11, Q.x11), Zn(Q.y01, Q.x01), !E))) : (f.moveTo(se, re), f.arc(0, 0, x, p, C, !E)) : f.moveTo(se, re), !(v > er) || !(R > er) ? f.lineTo(ae, K) : G > er ? (W = Du(ae, K, U, X, v, -G, E), Q = Du(se, re, H, Te, v, -G, E), f.lineTo(W.cx + W.x01, W.cy + W.y01), G < V ? f.arc(W.cx, W.cy, G, Zn(W.y01, W.x01), Zn(Q.y01, Q.x01), !E) : (f.arc(W.cx, W.cy, G, Zn(W.y01, W.x01), Zn(W.y11, W.x11), !E), f.arc(0, 0, v, Zn(W.cy + W.y11, W.cx + W.x11), Zn(Q.cy + Q.y11, Q.cx + Q.x11), E), f.arc(Q.cx, Q.cy, G, Zn(Q.y11, Q.x11), Zn(Q.y01, Q.x01), !E))) : f.arc(0, 0, v, w, _, E);
    }
    if (f.closePath(), m)
      return f = null, m + "" || null;
  }
  return u.centroid = function() {
    var m = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, y = (+i.apply(this, arguments) + +l.apply(this, arguments)) / 2 - gp / 2;
    return [Ti(y) * m, Ur(y) * m];
  }, u.innerRadius = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Ht(+m), u) : e;
  }, u.outerRadius = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : Ht(+m), u) : t;
  }, u.cornerRadius = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Ht(+m), u) : n;
  }, u.padRadius = function(m) {
    return arguments.length ? (a = m == null ? null : typeof m == "function" ? m : Ht(+m), u) : a;
  }, u.startAngle = function(m) {
    return arguments.length ? (i = typeof m == "function" ? m : Ht(+m), u) : i;
  }, u.endAngle = function(m) {
    return arguments.length ? (l = typeof m == "function" ? m : Ht(+m), u) : l;
  }, u.padAngle = function(m) {
    return arguments.length ? (c = typeof m == "function" ? m : Ht(+m), u) : c;
  }, u.context = function(m) {
    return arguments.length ? (f = m ?? null, u) : f;
  }, u;
}
function Jm(e) {
  this._context = e;
}
Jm.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Rc(e) {
  return new Jm(e);
}
function Uf(e) {
  return e[0];
}
function Kf(e) {
  return e[1];
}
function ey() {
  var e = Uf, t = Kf, n = Ht(!0), a = null, i = Rc, l = null;
  function c(f) {
    var u, m = f.length, y, v = !1, x;
    for (a == null && (l = i(x = Ac())), u = 0; u <= m; ++u)
      !(u < m && n(y = f[u], u, f)) === v && ((v = !v) ? l.lineStart() : l.lineEnd()), v && l.point(+e(y, u, f), +t(y, u, f));
    if (x)
      return l = null, x + "" || null;
  }
  return c.x = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : Ht(+f), c) : e;
  }, c.y = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : Ht(+f), c) : t;
  }, c.defined = function(f) {
    return arguments.length ? (n = typeof f == "function" ? f : Ht(!!f), c) : n;
  }, c.curve = function(f) {
    return arguments.length ? (i = f, a != null && (l = i(a)), c) : i;
  }, c.context = function(f) {
    return arguments.length ? (f == null ? a = l = null : l = i(a = f), c) : a;
  }, c;
}
function Qb() {
  var e = Uf, t = null, n = Ht(0), a = Kf, i = Ht(!0), l = null, c = Rc, f = null;
  function u(y) {
    var v, x, A, T = y.length, M, E = !1, p, C = new Array(T), _ = new Array(T);
    for (l == null && (f = c(p = Ac())), v = 0; v <= T; ++v) {
      if (!(v < T && i(M = y[v], v, y)) === E)
        if (E = !E)
          x = v, f.areaStart(), f.lineStart();
        else {
          for (f.lineEnd(), f.lineStart(), A = v - 1; A >= x; --A)
            f.point(C[A], _[A]);
          f.lineEnd(), f.areaEnd();
        }
      E && (C[v] = +e(M, v, y), _[v] = +n(M, v, y), f.point(t ? +t(M, v, y) : C[v], a ? +a(M, v, y) : _[v]));
    }
    if (p)
      return f = null, p + "" || null;
  }
  function m() {
    return ey().defined(i).curve(c).context(l);
  }
  return u.x = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : Ht(+y), t = null, u) : e;
  }, u.x0 = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : Ht(+y), u) : e;
  }, u.x1 = function(y) {
    return arguments.length ? (t = y == null ? null : typeof y == "function" ? y : Ht(+y), u) : t;
  }, u.y = function(y) {
    return arguments.length ? (n = typeof y == "function" ? y : Ht(+y), a = null, u) : n;
  }, u.y0 = function(y) {
    return arguments.length ? (n = typeof y == "function" ? y : Ht(+y), u) : n;
  }, u.y1 = function(y) {
    return arguments.length ? (a = y == null ? null : typeof y == "function" ? y : Ht(+y), u) : a;
  }, u.lineX0 = u.lineY0 = function() {
    return m().x(e).y(n);
  }, u.lineY1 = function() {
    return m().x(e).y(a);
  }, u.lineX1 = function() {
    return m().x(t).y(n);
  }, u.defined = function(y) {
    return arguments.length ? (i = typeof y == "function" ? y : Ht(!!y), u) : i;
  }, u.curve = function(y) {
    return arguments.length ? (c = y, l != null && (f = c(l)), u) : c;
  }, u.context = function(y) {
    return arguments.length ? (y == null ? l = f = null : f = c(l = y), u) : l;
  }, u;
}
function Jb(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function e0(e) {
  return e;
}
function t0() {
  var e = e0, t = Jb, n = null, a = Ht(0), i = Ht(Hu), l = Ht(0);
  function c(f) {
    var u, m = f.length, y, v, x = 0, A = new Array(m), T = new Array(m), M = +a.apply(this, arguments), E = Math.min(Hu, Math.max(-Hu, i.apply(this, arguments) - M)), p, C = Math.min(Math.abs(E) / m, l.apply(this, arguments)), _ = C * (E < 0 ? -1 : 1), w;
    for (u = 0; u < m; ++u)
      (w = T[A[u] = u] = +e(f[u], u, f)) > 0 && (x += w);
    for (t != null ? A.sort(function(R, P) {
      return t(T[R], T[P]);
    }) : n != null && A.sort(function(R, P) {
      return n(f[R], f[P]);
    }), u = 0, v = x ? (E - m * _) / x : 0; u < m; ++u, M = p)
      y = A[u], w = T[y], p = M + (w > 0 ? w * v : 0) + _, T[y] = {
        data: f[y],
        index: u,
        value: w,
        startAngle: M,
        endAngle: p,
        padAngle: C
      };
    return T;
  }
  return c.value = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : Ht(+f), c) : e;
  }, c.sortValues = function(f) {
    return arguments.length ? (t = f, n = null, c) : t;
  }, c.sort = function(f) {
    return arguments.length ? (n = f, t = null, c) : n;
  }, c.startAngle = function(f) {
    return arguments.length ? (a = typeof f == "function" ? f : Ht(+f), c) : a;
  }, c.endAngle = function(f) {
    return arguments.length ? (i = typeof f == "function" ? f : Ht(+f), c) : i;
  }, c.padAngle = function(f) {
    return arguments.length ? (l = typeof f == "function" ? f : Ht(+f), c) : l;
  }, c;
}
var ff = Array.prototype.slice;
function n0(e) {
  return e.source;
}
function r0(e) {
  return e.target;
}
function a0(e) {
  var t = n0, n = r0, a = Uf, i = Kf, l = null;
  function c() {
    var f, u = ff.call(arguments), m = t.apply(this, u), y = n.apply(this, u);
    if (l || (l = f = Ac()), e(l, +a.apply(this, (u[0] = m, u)), +i.apply(this, u), +a.apply(this, (u[0] = y, u)), +i.apply(this, u)), f)
      return l = null, f + "" || null;
  }
  return c.source = function(f) {
    return arguments.length ? (t = f, c) : t;
  }, c.target = function(f) {
    return arguments.length ? (n = f, c) : n;
  }, c.x = function(f) {
    return arguments.length ? (a = typeof f == "function" ? f : Ht(+f), c) : a;
  }, c.y = function(f) {
    return arguments.length ? (i = typeof f == "function" ? f : Ht(+f), c) : i;
  }, c.context = function(f) {
    return arguments.length ? (l = f ?? null, c) : l;
  }, c;
}
function i0(e, t, n, a, i) {
  e.moveTo(t, n), e.bezierCurveTo(t = (t + a) / 2, n, t, i, a, i);
}
function o0() {
  return a0(i0);
}
function Ha() {
}
function lc(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function Dc(e) {
  this._context = e;
}
Dc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        lc(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        lc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function l0(e) {
  return new Dc(e);
}
function ty(e) {
  this._context = e;
}
ty.prototype = {
  areaStart: Ha,
  areaEnd: Ha,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        lc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function s0(e) {
  return new ty(e);
}
function ny(e) {
  this._context = e;
}
ny.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, a = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, a) : this._context.moveTo(n, a);
        break;
      case 3:
        this._point = 4;
      default:
        lc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function u0(e) {
  return new ny(e);
}
function ry(e, t) {
  this._basis = new Dc(e), this._beta = t;
}
ry.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var a = e[0], i = t[0], l = e[n] - a, c = t[n] - i, f = -1, u; ++f <= n; )
        u = f / n, this._basis.point(
          this._beta * e[f] + (1 - this._beta) * (a + u * l),
          this._beta * t[f] + (1 - this._beta) * (i + u * c)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const c0 = function e(t) {
  function n(a) {
    return t === 1 ? new Dc(a) : new ry(a, t);
  }
  return n.beta = function(a) {
    return e(+a);
  }, n;
}(0.85);
function sc(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function Yf(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Yf.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        sc(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        sc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const d0 = function e(t) {
  function n(a) {
    return new Yf(a, t);
  }
  return n.tension = function(a) {
    return e(+a);
  }, n;
}(0);
function Xf(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Xf.prototype = {
  areaStart: Ha,
  areaEnd: Ha,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        sc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const f0 = function e(t) {
  function n(a) {
    return new Xf(a, t);
  }
  return n.tension = function(a) {
    return e(+a);
  }, n;
}(0);
function qf(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
qf.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        sc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const p0 = function e(t) {
  function n(a) {
    return new qf(a, t);
  }
  return n.tension = function(a) {
    return e(+a);
  }, n;
}(0);
function Gf(e, t, n) {
  var a = e._x1, i = e._y1, l = e._x2, c = e._y2;
  if (e._l01_a > er) {
    var f = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, u = 3 * e._l01_a * (e._l01_a + e._l12_a);
    a = (a * f - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / u, i = (i * f - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / u;
  }
  if (e._l23_a > er) {
    var m = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, y = 3 * e._l23_a * (e._l23_a + e._l12_a);
    l = (l * m + e._x1 * e._l23_2a - t * e._l12_2a) / y, c = (c * m + e._y1 * e._l23_2a - n * e._l12_2a) / y;
  }
  e._context.bezierCurveTo(a, i, l, c, e._x2, e._y2);
}
function ay(e, t) {
  this._context = e, this._alpha = t;
}
ay.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        Gf(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const h0 = function e(t) {
  function n(a) {
    return t ? new ay(a, t) : new Yf(a, 0);
  }
  return n.alpha = function(a) {
    return e(+a);
  }, n;
}(0.5);
function iy(e, t) {
  this._context = e, this._alpha = t;
}
iy.prototype = {
  areaStart: Ha,
  areaEnd: Ha,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        Gf(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const m0 = function e(t) {
  function n(a) {
    return t ? new iy(a, t) : new Xf(a, 0);
  }
  return n.alpha = function(a) {
    return e(+a);
  }, n;
}(0.5);
function oy(e, t) {
  this._context = e, this._alpha = t;
}
oy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        Gf(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const y0 = function e(t) {
  function n(a) {
    return t ? new oy(a, t) : new qf(a, 0);
  }
  return n.alpha = function(a) {
    return e(+a);
  }, n;
}(0.5);
function ly(e) {
  this._context = e;
}
ly.prototype = {
  areaStart: Ha,
  areaEnd: Ha,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function pf(e) {
  return new ly(e);
}
function yh(e) {
  return e < 0 ? -1 : 1;
}
function gh(e, t, n) {
  var a = e._x1 - e._x0, i = t - e._x1, l = (e._y1 - e._y0) / (a || i < 0 && -0), c = (n - e._y1) / (i || a < 0 && -0), f = (l * i + c * a) / (a + i);
  return (yh(l) + yh(c)) * Math.min(Math.abs(l), Math.abs(c), 0.5 * Math.abs(f)) || 0;
}
function vh(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function Ud(e, t, n) {
  var a = e._x0, i = e._y0, l = e._x1, c = e._y1, f = (l - a) / 3;
  e._context.bezierCurveTo(a + f, i + f * t, l - f, c - f * n, l, c);
}
function uc(e) {
  this._context = e;
}
uc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Ud(this, this._t0, vh(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Ud(this, vh(this, n = gh(this, e, t)), n);
          break;
        default:
          Ud(this, this._t0, n = gh(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function sy(e) {
  this._context = new uy(e);
}
(sy.prototype = Object.create(uc.prototype)).point = function(e, t) {
  uc.prototype.point.call(this, t, e);
};
function uy(e) {
  this._context = e;
}
uy.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, a, i, l) {
    this._context.bezierCurveTo(t, e, a, n, l, i);
  }
};
function ju(e) {
  return new uc(e);
}
function g0(e) {
  return new sy(e);
}
function cy(e) {
  this._context = e;
}
cy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var a = xh(e), i = xh(t), l = 0, c = 1; c < n; ++l, ++c)
          this._context.bezierCurveTo(a[0][l], i[0][l], a[1][l], i[1][l], e[c], t[c]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function xh(e) {
  var t, n = e.length - 1, a, i = new Array(n), l = new Array(n), c = new Array(n);
  for (i[0] = 0, l[0] = 2, c[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    i[t] = 1, l[t] = 4, c[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, l[n - 1] = 7, c[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    a = i[t] / l[t - 1], l[t] -= a, c[t] -= a * c[t - 1];
  for (i[n - 1] = c[n - 1] / l[n - 1], t = n - 2; t >= 0; --t)
    i[t] = (c[t] - i[t + 1]) / l[t];
  for (l[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)
    l[t] = 2 * e[t + 1] - i[t + 1];
  return [i, l];
}
function v0(e) {
  return new cy(e);
}
function Nc(e, t) {
  this._context = e, this._t = t;
}
Nc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function x0(e) {
  return new Nc(e, 0.5);
}
function b0(e) {
  return new Nc(e, 0);
}
function S0(e) {
  return new Nc(e, 1);
}
function nl(e, t) {
  if ((c = e.length) > 1)
    for (var n = 1, a, i, l = e[t[0]], c, f = l.length; n < c; ++n)
      for (i = l, l = e[t[n]], a = 0; a < f; ++a)
        l[a][1] += l[a][0] = isNaN(i[a][1]) ? i[a][0] : i[a][1];
}
function rl(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; )
    n[t] = t;
  return n;
}
function E0(e, t) {
  return e[t];
}
function Zf() {
  var e = Ht([]), t = rl, n = nl, a = E0;
  function i(l) {
    var c = e.apply(this, arguments), f, u = l.length, m = c.length, y = new Array(m), v;
    for (f = 0; f < m; ++f) {
      for (var x = c[f], A = y[f] = new Array(u), T = 0, M; T < u; ++T)
        A[T] = M = [0, +a(l[T], x, T, l)], M.data = l[T];
      A.key = x;
    }
    for (f = 0, v = t(y); f < m; ++f)
      y[v[f]].index = f;
    return n(y, v), y;
  }
  return i.keys = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : Ht(ff.call(l)), i) : e;
  }, i.value = function(l) {
    return arguments.length ? (a = typeof l == "function" ? l : Ht(+l), i) : a;
  }, i.order = function(l) {
    return arguments.length ? (t = l == null ? rl : typeof l == "function" ? l : Ht(ff.call(l)), i) : t;
  }, i.offset = function(l) {
    return arguments.length ? (n = l ?? nl, i) : n;
  }, i;
}
function k0(e, t) {
  if ((a = e.length) > 0) {
    for (var n, a, i = 0, l = e[0].length, c; i < l; ++i) {
      for (c = n = 0; n < a; ++n)
        c += e[n][i][1] || 0;
      if (c)
        for (n = 0; n < a; ++n)
          e[n][i][1] /= c;
    }
    nl(e, t);
  }
}
function w0(e, t) {
  if ((u = e.length) > 0)
    for (var n, a = 0, i, l, c, f, u, m = e[t[0]].length; a < m; ++a)
      for (c = f = 0, n = 0; n < u; ++n)
        (l = (i = e[t[n]][a])[1] - i[0]) > 0 ? (i[0] = c, i[1] = c += l) : l < 0 ? (i[1] = f, i[0] = f += l) : (i[0] = 0, i[1] = l);
}
function T0(e, t) {
  if ((i = e.length) > 0) {
    for (var n = 0, a = e[t[0]], i, l = a.length; n < l; ++n) {
      for (var c = 0, f = 0; c < i; ++c)
        f += e[c][n][1] || 0;
      a[n][1] += a[n][0] = -f / 2;
    }
    nl(e, t);
  }
}
function C0(e, t) {
  if (!(!((c = e.length) > 0) || !((l = (i = e[t[0]]).length) > 0))) {
    for (var n = 0, a = 1, i, l, c; a < l; ++a) {
      for (var f = 0, u = 0, m = 0; f < c; ++f) {
        for (var y = e[t[f]], v = y[a][1] || 0, x = y[a - 1][1] || 0, A = (v - x) / 2, T = 0; T < f; ++T) {
          var M = e[t[T]], E = M[a][1] || 0, p = M[a - 1][1] || 0;
          A += E - p;
        }
        u += v, m += A * v;
      }
      i[a - 1][1] += i[a - 1][0] = n, u && (n -= m / u);
    }
    i[a - 1][1] += i[a - 1][0] = n, nl(e, t);
  }
}
function A0(e) {
  var t = e.map(L0);
  return rl(e).sort(function(n, a) {
    return t[n] - t[a];
  });
}
function L0(e) {
  for (var t = -1, n = 0, a = e.length, i, l = -1 / 0; ++t < a; )
    (i = +e[t][1]) > l && (l = i, n = t);
  return n;
}
function dy(e) {
  var t = e.map(fy);
  return rl(e).sort(function(n, a) {
    return t[n] - t[a];
  });
}
function fy(e) {
  for (var t = 0, n = -1, a = e.length, i; ++n < a; )
    (i = +e[n][1]) && (t += i);
  return t;
}
function P0(e) {
  return dy(e).reverse();
}
function R0(e) {
  var t = e.length, n, a, i = e.map(fy), l = A0(e), c = 0, f = 0, u = [], m = [];
  for (n = 0; n < t; ++n)
    a = l[n], c < f ? (c += i[a], u.push(a)) : (f += i[a], m.push(a));
  return m.reverse().concat(u);
}
function D0(e) {
  return rl(e).reverse();
}
function Sn(e, t) {
  e(t);
}
var bh = {
  ascending: dy,
  descending: P0,
  insideout: R0,
  none: rl,
  reverse: D0
};
function Qf(e) {
  return e && bh[e] || bh.none;
}
var Sh = {
  expand: k0,
  diverging: w0,
  none: nl,
  silhouette: T0,
  wiggle: C0
};
function Jf(e) {
  return e && Sh[e] || Sh.none;
}
function N0(e) {
  var t = e === void 0 ? {} : e, n = t.innerRadius, a = t.outerRadius, i = t.cornerRadius, l = t.startAngle, c = t.endAngle, f = t.padAngle, u = t.padRadius, m = Zb();
  return n != null && Sn(m.innerRadius, n), a != null && Sn(m.outerRadius, a), i != null && Sn(m.cornerRadius, i), l != null && Sn(m.startAngle, l), c != null && Sn(m.endAngle, c), f != null && Sn(m.padAngle, f), u != null && Sn(m.padRadius, u), m;
}
function ep(e) {
  var t = e === void 0 ? {} : e, n = t.x, a = t.x0, i = t.x1, l = t.y, c = t.y0, f = t.y1, u = t.defined, m = t.curve, y = Qb();
  return n && Sn(y.x, n), a && Sn(y.x0, a), i && Sn(y.x1, i), l && Sn(y.y, l), c && Sn(y.y0, c), f && Sn(y.y1, f), u && y.defined(u), m && y.curve(m), y;
}
function py(e) {
  var t = e === void 0 ? {} : e, n = t.x, a = t.y, i = t.defined, l = t.curve, c = ey();
  return n && Sn(c.x, n), a && Sn(c.y, a), i && c.defined(i), l && c.curve(l), c;
}
function _0(e) {
  var t = e === void 0 ? {} : e, n = t.startAngle, a = t.endAngle, i = t.padAngle, l = t.value, c = t.sort, f = t.sortValues, u = t0();
  return (c === null || c != null) && u.sort(c), (f === null || f != null) && u.sortValues(f), l != null && u.value(l), i != null && Sn(u.padAngle, i), n != null && Sn(u.startAngle, n), a != null && Sn(u.endAngle, a), u;
}
function O0(e) {
  var t = e.keys, n = e.value, a = e.order, i = e.offset, l = Zf();
  return t && l.keys(t), n && Sn(l.value, n), a && l.order(Qf(a)), i && l.offset(Jf(i)), l;
}
var F0 = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function hf() {
  return hf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, hf.apply(this, arguments);
}
function M0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function z0(e) {
  var t = e.className, n = e.top, a = e.left, i = e.data, l = i === void 0 ? [] : i, c = e.centroid, f = e.innerRadius, u = f === void 0 ? 0 : f, m = e.outerRadius, y = e.cornerRadius, v = e.startAngle, x = e.endAngle, A = e.padAngle, T = e.padRadius, M = e.pieSort, E = e.pieSortValues, p = e.pieValue, C = e.children, _ = e.fill, w = _ === void 0 ? "" : _, R = M0(e, F0), P = N0({
    innerRadius: u,
    outerRadius: m,
    cornerRadius: y,
    padRadius: T
  }), z = _0({
    startAngle: v,
    endAngle: x,
    padAngle: A,
    value: p,
    sort: M,
    sortValues: E
  }), q = z(l);
  return C ? /* @__PURE__ */ r.createElement(r.Fragment, null, C({
    arcs: q,
    path: P,
    pie: z
  })) : /* @__PURE__ */ r.createElement(rt, {
    className: "visx-pie-arcs-group",
    top: n,
    left: a
  }, q.map(function(V, G) {
    return /* @__PURE__ */ r.createElement("g", {
      key: "pie-arc-" + G
    }, /* @__PURE__ */ r.createElement("path", hf({
      className: An("visx-pie-arc", t),
      d: P(V) || "",
      fill: w == null || typeof w == "string" ? w : w(V)
    }, R)), c == null ? void 0 : c(P.centroid(V), V));
  }));
}
var $0 = ["from", "to", "fill", "className", "innerRef"];
function mf() {
  return mf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, mf.apply(this, arguments);
}
function B0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function en(e) {
  var t = e.from, n = t === void 0 ? {
    x: 0,
    y: 0
  } : t, a = e.to, i = a === void 0 ? {
    x: 1,
    y: 1
  } : a, l = e.fill, c = l === void 0 ? "transparent" : l, f = e.className, u = e.innerRef, m = B0(e, $0), y = n.x === i.x || n.y === i.y;
  return /* @__PURE__ */ r.createElement("line", mf({
    ref: u,
    className: An("visx-line", f),
    x1: n.x,
    y1: n.y,
    x2: i.x,
    y2: i.y,
    fill: c,
    shapeRendering: y ? "crispEdges" : "auto"
  }, m));
}
var I0 = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function yf() {
  return yf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, yf.apply(this, arguments);
}
function H0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function zr(e) {
  var t = e.children, n = e.data, a = n === void 0 ? [] : n, i = e.x, l = e.y, c = e.fill, f = c === void 0 ? "transparent" : c, u = e.className, m = e.curve, y = e.innerRef, v = e.defined, x = v === void 0 ? function() {
    return !0;
  } : v, A = H0(e, I0), T = py({
    x: i,
    y: l,
    defined: x,
    curve: m
  });
  return t ? /* @__PURE__ */ r.createElement(r.Fragment, null, t({
    path: T
  })) : /* @__PURE__ */ r.createElement("path", yf({
    ref: y,
    className: An("visx-linepath", u),
    d: T(a) || "",
    fill: f,
    strokeLinecap: "round"
  }, A));
}
var W0 = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function gf() {
  return gf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, gf.apply(this, arguments);
}
function V0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function j0(e) {
  var t = e.children, n = e.x, a = e.x0, i = e.x1, l = e.y, c = e.y0, f = e.y1, u = e.data, m = u === void 0 ? [] : u, y = e.defined, v = y === void 0 ? function() {
    return !0;
  } : y, x = e.className, A = e.curve, T = e.innerRef, M = V0(e, W0), E = ep({
    x: n,
    x0: a,
    x1: i,
    y: l,
    y0: c,
    y1: f,
    defined: v,
    curve: A
  });
  return t ? /* @__PURE__ */ r.createElement(r.Fragment, null, t({
    path: E
  })) : /* @__PURE__ */ r.createElement("path", gf({
    ref: T,
    className: An("visx-area", x),
    d: E(m) || ""
  }, M));
}
var U0 = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function vf() {
  return vf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, vf.apply(this, arguments);
}
function K0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Y0(e) {
  var t = e.x, n = e.x0, a = e.x1, i = e.y, l = e.y1, c = e.y0, f = e.yScale, u = e.data, m = u === void 0 ? [] : u, y = e.defined, v = y === void 0 ? function() {
    return !0;
  } : y, x = e.className, A = e.curve, T = e.innerRef, M = e.children, E = K0(e, U0), p = ep({
    x: t,
    x0: n,
    x1: a,
    defined: v,
    curve: A
  });
  return c == null ? p.y0(f.range()[0]) : Sn(p.y0, c), i && !l && Sn(p.y1, i), l && !i && Sn(p.y1, l), M ? /* @__PURE__ */ r.createElement(r.Fragment, null, M({
    path: p
  })) : /* @__PURE__ */ r.createElement("path", vf({
    ref: T,
    className: An("visx-area-closed", x),
    d: p(m) || ""
  }, E));
}
var X0 = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function xf() {
  return xf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, xf.apply(this, arguments);
}
function q0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function G0(e) {
  var t = e.className, n = e.top, a = e.left, i = e.keys, l = e.data, c = e.curve, f = e.defined, u = e.x, m = e.x0, y = e.x1, v = e.y0, x = e.y1, A = e.value, T = e.order, M = e.offset, E = e.color, p = e.children, C = q0(e, X0), _ = O0({
    keys: i,
    value: A,
    order: T,
    offset: M
  }), w = ep({
    x: u,
    x0: m,
    x1: y,
    y0: v,
    y1: x,
    curve: c,
    defined: f
  }), R = _(l);
  return p ? /* @__PURE__ */ r.createElement(r.Fragment, null, p({
    stacks: R,
    path: w,
    stack: _
  })) : /* @__PURE__ */ r.createElement(rt, {
    top: n,
    left: a
  }, R.map(function(P, z) {
    return /* @__PURE__ */ r.createElement("path", xf({
      className: An("visx-stack", t),
      key: "stack-" + z + "-" + (P.key || ""),
      d: w(P) || "",
      fill: E == null ? void 0 : E(P.key, z)
    }, C));
  }));
}
var Z0 = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function cc() {
  return cc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, cc.apply(this, arguments);
}
function Q0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function J0(e) {
  var t = e.className, n = e.top, a = e.left, i = e.keys, l = e.data, c = e.curve, f = e.defined, u = e.x, m = e.x0, y = e.x1, v = e.y0, x = e.y1, A = e.value, T = e.order, M = e.offset, E = e.color, p = e.children, C = Q0(e, Z0);
  return /* @__PURE__ */ r.createElement(G0, cc({
    className: t,
    top: n,
    left: a,
    keys: i,
    data: l,
    curve: c,
    defined: f,
    x: u,
    x0: m,
    x1: y,
    y0: v,
    y1: x,
    value: A,
    order: T,
    offset: M,
    color: E
  }, C), p || function(_) {
    var w = _.stacks, R = _.path;
    return w.map(function(P, z) {
      return /* @__PURE__ */ r.createElement("path", cc({
        className: An("visx-area-stack", t),
        key: "area-stack-" + z + "-" + (P.key || ""),
        d: R(P) || "",
        fill: E == null ? void 0 : E(P.key, z)
      }, C));
    });
  });
}
function tp(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), n = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / n.length;
}
var eS = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function bf() {
  return bf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, bf.apply(this, arguments);
}
function tS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function hy(e) {
  var t = e.data, n = e.className, a = e.top, i = e.left, l = e.x0, c = e.x0Scale, f = e.x1Scale, u = e.yScale, m = e.color, y = e.keys, v = e.height, x = e.children, A = tS(e, eS), T = tp(f), M = t.map(function(E, p) {
    return {
      index: p,
      x0: c(l(E)),
      bars: y.map(function(C, _) {
        var w = E[C];
        return {
          index: _,
          key: C,
          value: w,
          width: T,
          x: f(C) || 0,
          y: u(w) || 0,
          color: m(C, _),
          height: v - (u(w) || 0)
        };
      })
    };
  });
  return x ? /* @__PURE__ */ r.createElement(r.Fragment, null, x(M)) : /* @__PURE__ */ r.createElement(rt, {
    className: An("visx-bar-group", n),
    top: a,
    left: i
  }, M.map(function(E) {
    return /* @__PURE__ */ r.createElement(rt, {
      key: "bar-group-" + E.index + "-" + E.x0,
      left: E.x0
    }, E.bars.map(function(p) {
      return /* @__PURE__ */ r.createElement(Ar, bf({
        key: "bar-group-bar-" + E.index + "-" + p.index + "-" + p.value + "-" + p.key,
        x: p.x,
        y: p.y,
        width: p.width,
        height: p.height,
        fill: p.color
      }, A));
    }));
  }));
}
function my(e) {
  return e == null ? void 0 : e[0];
}
function yy(e) {
  return e == null ? void 0 : e[1];
}
var nS = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function Sf() {
  return Sf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Sf.apply(this, arguments);
}
function rS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function gy(e) {
  var t = e.data, n = e.className, a = e.top, i = e.left, l = e.x, c = e.y0, f = c === void 0 ? my : c, u = e.y1, m = u === void 0 ? yy : u, y = e.xScale, v = e.yScale, x = e.color, A = e.keys, T = e.value, M = e.order, E = e.offset, p = e.children, C = rS(e, nS), _ = Zf();
  A && _.keys(A), T && Sn(_.value, T), M && _.order(Qf(M)), E && _.offset(Jf(E));
  var w = _(t), R = tp(y), P = w.map(function(z, q) {
    var V = z.key;
    return {
      index: q,
      key: V,
      bars: z.map(function(G, ee) {
        var W = (v(f(G)) || 0) - (v(m(G)) || 0), Q = v(m(G)), j = "bandwidth" in y ? y(l(G.data)) : Math.max((y(l(G.data)) || 0) - R / 2);
        return {
          bar: G,
          key: V,
          index: ee,
          height: W,
          width: R,
          x: j || 0,
          y: Q || 0,
          color: x(z.key, ee)
        };
      })
    };
  });
  return p ? /* @__PURE__ */ r.createElement(r.Fragment, null, p(P)) : /* @__PURE__ */ r.createElement(rt, {
    className: An("visx-bar-stack", n),
    top: a,
    left: i
  }, P.map(function(z) {
    return z.bars.map(function(q) {
      return /* @__PURE__ */ r.createElement(Ar, Sf({
        key: "bar-stack-" + z.index + "-" + q.index,
        x: q.x,
        y: q.y,
        height: q.height,
        width: q.width,
        fill: q.color
      }, C));
    });
  }));
}
var aS = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function Ef() {
  return Ef = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Ef.apply(this, arguments);
}
function iS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function oS(e) {
  var t = e.data, n = e.className, a = e.top, i = e.left, l = e.y, c = e.x0, f = c === void 0 ? my : c, u = e.x1, m = u === void 0 ? yy : u, y = e.xScale, v = e.yScale, x = e.color, A = e.keys, T = e.value, M = e.order, E = e.offset, p = e.children, C = iS(e, aS), _ = Zf();
  A && _.keys(A), T && Sn(_.value, T), M && _.order(Qf(M)), E && _.offset(Jf(E));
  var w = _(t), R = tp(v), P = w.map(function(z, q) {
    var V = z.key;
    return {
      index: q,
      key: V,
      bars: z.map(function(G, ee) {
        var W = (y(m(G)) || 0) - (y(f(G)) || 0), Q = y(f(G)), j = "bandwidth" in v ? v(l(G.data)) : Math.max((v(l(G.data)) || 0) - W / 2);
        return {
          bar: G,
          key: V,
          index: ee,
          height: R,
          width: W,
          x: Q || 0,
          y: j || 0,
          color: x(z.key, ee)
        };
      })
    };
  });
  return p ? /* @__PURE__ */ r.createElement(r.Fragment, null, p(P)) : /* @__PURE__ */ r.createElement(rt, {
    className: An("visx-bar-stack-horizontal", n),
    top: a,
    left: i
  }, P.map(function(z) {
    return z.bars.map(function(q) {
      return /* @__PURE__ */ r.createElement(Ar, Ef({
        key: "bar-stack-" + z.index + "-" + q.index,
        x: q.x,
        y: q.y,
        height: q.height,
        width: q.width,
        fill: q.color
      }, C));
    });
  }));
}
var Eh = "http://www.w3.org/2000/svg";
function lS(e) {
  var t = document.getElementById(e);
  if (!t) {
    var n = document.createElementNS(Eh, "svg");
    n.setAttribute("aria-hidden", "true"), n.style.opacity = "0", n.style.width = "0", n.style.height = "0", n.style.position = "absolute", n.style.top = "-100%", n.style.left = "-100%", n.style.pointerEvents = "none", t = document.createElementNS(Eh, "path"), t.setAttribute("id", e), n.appendChild(t), document.body.appendChild(n);
  }
  return t;
}
var sS = "__visx_splitpath_svg_path_measurement_id", kh = function() {
  return !0;
};
function uS(e) {
  var t = e.path, n = e.pointsInSegments, a = e.segmentation, i = a === void 0 ? "x" : a, l = e.sampleRate, c = l === void 0 ? 1 : l;
  try {
    var f = lS(sS);
    f.setAttribute("d", t);
    var u = f.getTotalLength(), m = n.length, y = n.map(function() {
      return [];
    });
    if (i === "x" || i === "y")
      for (var v = n.map(function(Q) {
        var j;
        return (j = Q.find(function(te) {
          return typeof te[i] == "number";
        })) == null ? void 0 : j[i];
      }), x = f.getPointAtLength(0), A = f.getPointAtLength(u), T = A[i] > x[i], M = T ? v.map(function(Q) {
        return typeof Q > "u" ? kh : function(j) {
          return j >= Q;
        };
      }) : v.map(function(Q) {
        return typeof Q > "u" ? kh : function(j) {
          return j <= Q;
        };
      }), E = 0, p = 0; p <= u; p += c) {
        for (var C = f.getPointAtLength(p), _ = C[i]; E < m - 1 && M[E + 1](_); )
          E += 1;
        y[E].push(C);
      }
    else {
      var w = n.map(function(Q) {
        return Q.length;
      }), R = w.reduce(function(Q, j) {
        return Q + j;
      }, 0), P = u / Math.max(1, R - 1), z = w.slice(0, m - 1);
      z.unshift(0);
      for (var q = 2; q < m; q += 1)
        z[q] += z[q - 1];
      for (var V = 0; V < m; V += 1)
        z[V] *= P;
      for (var G = 0, ee = 0; ee <= u; ee += c) {
        for (var W = f.getPointAtLength(ee); G < m - 1 && ee >= z[G + 1]; )
          G += 1;
        y[G].push(W);
      }
    }
    return y;
  } catch {
    return [];
  }
}
function kf() {
  return kf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, kf.apply(this, arguments);
}
var cS = function(t) {
  return t.x || 0;
}, dS = function(t) {
  return t.y || 0;
};
function vy(e) {
  var t = e.children, n = e.className, a = e.curve, i = e.defined, l = e.segmentation, c = e.sampleRate, f = e.segments, u = e.x, m = e.y, y = e.styles, v = le.useMemo(function() {
    var T = typeof u == "number" || typeof u > "u" ? function() {
      return u;
    } : u, M = typeof m == "number" || typeof m > "u" ? function() {
      return m;
    } : m;
    return f.map(function(E) {
      return E.map(function(p, C) {
        return {
          x: T(p, C, E),
          y: M(p, C, E)
        };
      });
    });
  }, [u, m, f]), x = le.useMemo(function() {
    var T = py({
      x: u,
      y: m,
      defined: i,
      curve: a
    });
    return T(f.flat()) || "";
  }, [u, m, i, a, f]), A = le.useMemo(function() {
    return uS({
      path: x,
      segmentation: l,
      pointsInSegments: v,
      sampleRate: c
    });
  }, [x, l, v, c]);
  return /* @__PURE__ */ r.createElement("g", null, A.map(function(T, M) {
    return t ? /* @__PURE__ */ r.createElement(r.Fragment, {
      key: M
    }, t({
      index: M,
      segment: T,
      styles: y[M] || y[M % y.length]
    })) : /* @__PURE__ */ r.createElement(zr, kf({
      key: M,
      className: n,
      data: T,
      x: cS,
      y: dS
    }, y[M] || y[M % y.length]));
  }));
}
vy.propTypes = {
  segments: Ye.arrayOf(Ye.array).isRequired,
  styles: Ye.array.isRequired,
  children: Ye.func,
  className: Ye.string
};
var fS = ["tooltipOpen"];
function pS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function dc() {
  return dc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, dc.apply(this, arguments);
}
function xy(e) {
  var t = le.useState(dc({
    tooltipOpen: !1
  }, e)), n = t[0], a = t[1], i = le.useCallback(function(c) {
    return a(typeof c == "function" ? function(f) {
      f.tooltipOpen;
      var u = pS(f, fS);
      return dc({}, c(u), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: c.tooltipLeft,
      tooltipTop: c.tooltipTop,
      tooltipData: c.tooltipData
    });
  }, [a]), l = le.useCallback(function() {
    return a({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [a]);
  return {
    tooltipOpen: n.tooltipOpen,
    tooltipLeft: n.tooltipLeft,
    tooltipTop: n.tooltipTop,
    tooltipData: n.tooltipData,
    updateTooltip: a,
    showTooltip: i,
    hideTooltip: l
  };
}
var hS = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function fc() {
  return fc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, fc.apply(this, arguments);
}
function mS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var by = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, np = /* @__PURE__ */ r.forwardRef(function(e, t) {
  var n = e.className, a = e.top, i = e.left, l = e.offsetLeft, c = l === void 0 ? 10 : l, f = e.offsetTop, u = f === void 0 ? 10 : f, m = e.style, y = m === void 0 ? by : m, v = e.children, x = e.unstyled, A = x === void 0 ? !1 : x, T = e.applyPositionStyle, M = T === void 0 ? !1 : T, E = mS(e, hS);
  return /* @__PURE__ */ r.createElement("div", fc({
    ref: t,
    className: An("visx-tooltip", n),
    style: fc({
      top: a == null || u == null ? a : a + u,
      left: i == null || c == null ? i : i + c
    }, M && {
      position: "absolute"
    }, !A && y)
  }, E), v);
});
np.propTypes = {
  children: Ye.node,
  className: Ye.string,
  left: Ye.number,
  offsetLeft: Ye.number,
  offsetTop: Ye.number,
  top: Ye.number,
  applyPositionStyle: Ye.bool,
  unstyled: Ye.bool
};
np.displayName = "Tooltip";
const yS = np;
function wf() {
  return wf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, wf.apply(this, arguments);
}
function gS(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function vS(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Tf(e, t);
}
function Tf(e, t) {
  return Tf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, i) {
    return a.__proto__ = i, a;
  }, Tf(e, t);
}
var wh = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function xS(e) {
  var t;
  return t = /* @__PURE__ */ function(n) {
    vS(a, n);
    function a(l) {
      var c;
      return c = n.call(this, l) || this, c.state = {
        rect: void 0,
        parentRect: void 0
      }, c.nodeRef = /* @__PURE__ */ r.createRef(), c.getRects = c.getRects.bind(gS(c)), c;
    }
    var i = a.prototype;
    return i.componentDidMount = function() {
      var c, f = this;
      this.node = (c = this.nodeRef) != null && c.current ? this.nodeRef.current : Dg.findDOMNode(this), this.setState(function() {
        return f.getRects();
      });
    }, i.getRects = function() {
      if (!this.node)
        return this.state;
      var c = this.node, f = c.parentNode, u = c.getBoundingClientRect ? c.getBoundingClientRect() : wh, m = f != null && f.getBoundingClientRect ? f.getBoundingClientRect() : wh;
      return {
        rect: u,
        parentRect: m
      };
    }, i.render = function() {
      return /* @__PURE__ */ r.createElement(e, wf({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, a;
  }(r.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var Sy = /* @__PURE__ */ le.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), bS = Sy.Provider;
Sy.Consumer;
var SS = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function pc() {
  return pc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, pc.apply(this, arguments);
}
function ES(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Ey(e) {
  var t = e.children;
  e.getRects;
  var n = e.left, a = n === void 0 ? 0 : n, i = e.offsetLeft, l = i === void 0 ? 10 : i, c = e.offsetTop, f = c === void 0 ? 10 : c, u = e.parentRect, m = e.rect, y = e.style, v = y === void 0 ? by : y, x = e.top, A = x === void 0 ? 0 : x, T = e.unstyled, M = T === void 0 ? !1 : T, E = e.nodeRef, p = ES(e, SS), C, _ = !1, w = !1;
  if (m && u) {
    var R = a, P = A;
    if (u.width) {
      var z = R + l + m.width - u.width, q = m.width - R - l;
      _ = z > 0 && z > q;
    } else {
      var V = R + l + m.width - window.innerWidth, G = m.width - R - l;
      _ = V > 0 && V > G;
    }
    if (u.height) {
      var ee = P + f + m.height - u.height, W = m.height - P - f;
      w = ee > 0 && ee > W;
    } else
      w = P + f + m.height > window.innerHeight;
    R = _ ? R - m.width - l : R + l, P = w ? P - m.height - f : P + f, R = Math.round(R), P = Math.round(P), C = "translate(" + R + "px, " + P + "px)";
  }
  return /* @__PURE__ */ r.createElement(yS, pc({
    ref: E,
    style: pc({
      left: 0,
      top: 0,
      transform: C
    }, !M && v)
  }, p), /* @__PURE__ */ r.createElement(bS, {
    value: {
      isFlippedVertically: !w,
      isFlippedHorizontally: !_
    }
  }, t));
}
Ey.propTypes = {
  nodeRef: Ye.oneOfType([Ye.string, Ye.func, Ye.object])
};
const ky = xS(Ey), wy = (e) => {
  const { tableData: t, config: n, formatNumber: a, capitalize: i, formatDate: l, formatTooltipsDate: c, parseDate: f, setSharedFilter: u, isDraggingAnnotation: m } = le.useContext(bt), { xScale: y, yScale: v, showTooltip: x, hideTooltip: A } = e, { xAxis: T, visualizationType: M, orientation: E, yAxis: p, runtime: C } = n, _ = (re, ae) => {
    var Te;
    let K = 0, U = Number(v.invert(re)), X = null, H = null;
    for (let be of (Te = n.runtime) == null ? void 0 : Te.seriesKeys)
      if (ae.hasOwnProperty(be) && (K += Number(ae[be]), K >= U)) {
        H = ae[be], X = be;
        break;
      }
    return [X, H];
  }, w = (re, ae, K, U) => {
    var be;
    const X = K.general.showMissingDataLabel && (!ae || ae === "null");
    let H = re === K.xAxis.dataKey ? ae : a(ae, U(re));
    H = X ? "N/A" : H;
    const Te = (be = K.preliminaryData) == null ? void 0 : be.find((ce) => ce.label && ce.type === "suppression" && ce.displayTooltip && ae === ce.value && (!ce.column || re === ce.column));
    return Te && (H = Te.label), H;
  }, R = (re, ae) => {
    const { x: K, y: U } = ae, H = {
      data: re || {},
      dataXPosition: K + 10,
      dataYPosition: U
    };
    return {
      tooltipLeft: H.dataXPosition,
      tooltipTop: H.dataYPosition,
      tooltipData: H
    };
  }, P = (re, ae) => {
    if (M === "Bump Chart" || (re.stopPropagation(), m))
      return;
    const K = Sp(re), { x: U, y: X } = K, { data: H, arc: Te } = ae ?? {}, be = V(U - Number(n.yAxis.size || 0)), ce = M !== "Pie" ? n.runtime.series.filter((Ce) => Ce.tooltip === !0).map((Ce) => Ce.dataKey) : n.runtime.series.map((Ce) => Ce.dataKey);
    ce.push(n.xAxis.dataKey), n.visualizationType === "Forecasting" && n.runtime.series.map((Ce) => {
      Ce.confidenceIntervals.map(($e) => {
        $e.showInTooltip && (ce.push($e.high), ce.push($e.low));
      });
    });
    function Re(Ce) {
      let $e = [];
      for (let Ve in Ce)
        Ce.hasOwnProperty(Ve) && $e.push(Ce[Ve].name);
      return $e;
    }
    ce.push(...Re(n.columns)), ce.push(...Re(n.columns));
    const He = W(be, ce), Ge = t.filter((Ce) => Ce[T.dataKey] === G(X)), Ne = E === "vertical" ? He : Ge, ye = (Ce) => {
      const $e = n.runtime.series.filter((Ee) => Ee.dataKey === Ce)[0];
      return $e != null && $e.axis ? String($e.axis).toLowerCase() : "left";
    }, ue = (() => {
      var Ue, ft, Qe;
      const Ce = n.columns, $e = [], Ve = [];
      for (const [We, Ie] of Object.entries(Ce)) {
        const Me = {
          addColPrefix: n.columns[We].prefix,
          addColSuffix: n.columns[We].suffix,
          addColRoundTo: n.columns[We].roundToPlace ? n.columns[We].roundToPlace : "",
          addColCommas: n.columns[We].commas
        };
        let tt = null;
        n.visualizationType === "Pie" ? tt = Te == null ? void 0 : Te.data[Ie.name] : tt = (Ue = Ne[0]) == null ? void 0 : Ue[Ie.name];
        const Ze = Mf(tt, "left", !0, n, Me);
        Ie.tooltips && $e.push([Ie.label, Ze]);
      }
      const Ee = [];
      if ($e.forEach((We) => {
        Ee.push([We[0], We[1]]);
      }), M === "Pie" && Ve.push(
        // ignore
        [n.xAxis.dataKey, H],
        [n.runtime.yAxis.dataKey, a(Te == null ? void 0 : Te.data[n.runtime.yAxis.dataKey])],
        ["Percent", `${Math.round(((Te == null ? void 0 : Te.endAngle) - (Te == null ? void 0 : Te.startAngle)) * 180 / Math.PI / 360 * 100) + "%"}`]
      ), M === "Forest Plot" && Ve.push([n.xAxis.dataKey, G(X)]), M !== "Pie" && M !== "Forest Plot" && !n.tooltips.singleSeries && Ve.push(
        ...(Qe = (ft = Q()) == null ? void 0 : ft.filter((We) => {
          var Ie, Me;
          return ((Ie = n.runtime.series) == null ? void 0 : Ie.find((tt) => tt.dataKey === We && (tt == null ? void 0 : tt.tooltip))) || ((Me = n.xAxis) == null ? void 0 : Me.dataKey) == We || M === "Forecasting";
        })) == null ? void 0 : Qe.flatMap((We) => {
          var tt;
          const Ie = (tt = Ne[0]) == null ? void 0 : tt[We], Me = w(We, Ie, n, ye);
          return [[We, Me, ye(We)]];
        })
      ), M !== "Pie" && M !== "Forest Plot" && n.tooltips.singleSeries) {
        const [We, Ie] = _(X, Ne[0]);
        if (We && Ie) {
          Ve.push([n.xAxis.dataKey, be]);
          const Me = w(We, Ie, n, ye);
          Ve.push([We, Me]);
        }
      }
      return [...Ve, ...Ee];
    })();
    if (!ue)
      return;
    const ie = R(ue, K);
    x(ie);
  }, z = () => {
    n.visualizationType === "Area Chart" ? setTimeout(() => {
      A();
    }, 3e3) : A();
  }, q = (re) => {
    if (n.xAxis.type === "categorical" || n.visualizationType === "Combo") {
      let ae = y.step();
      const U = Math.floor(Number(re) / ae);
      return y.domain()[U - 1];
    }
    if (Cn(n.xAxis) && n.visualizationType !== "Combo") {
      const ae = Fp((H) => f(H[n.xAxis.dataKey])).left, K = y.invert(y(re)), U = ae(n.data, K, 1);
      return f(n.data[U - 1][n.xAxis.dataKey]);
    }
  }, V = (re, ae = !1) => {
    if (M !== "Pie" && E !== "horizontal") {
      if (y.type === "point" || T.type === "continuous" || Cn(T)) {
        let K = null, U = Number.MAX_VALUE, X = re;
        return t.forEach((H) => {
          const Te = Cn(T) ? y(f(H[T.dataKey])) : y(H[T.dataKey]);
          let be = n.barHeight;
          const ce = Math.abs(Number(Te - X + (ae ? be * 2 : 0)));
          ce <= U && (U = ce, K = (Cn(T), H[T.dataKey]));
        }), K;
      }
      if (n.xAxis.type === "categorical" || M === "Combo" && E !== "horizontal" && M !== "Forest Plot") {
        let U = (y.range()[1] - y.range()[0]) / (y.domain().length + 1);
        const H = Math.floor((Number(re) - U / 2) / U);
        return y.domain()[H];
      }
      if (Cn(T) && M !== "Combo" && E !== "horizontal") {
        const K = Fp((Te) => f(Te[n.xAxis.dataKey])).left, U = y.invert(re), X = K(n.data, U, 1);
        return f(n.data[X - 1][n.xAxis.dataKey]);
      }
    }
  }, G = (re, ae) => {
    if (M === "Pie")
      return;
    let K = Number.MAX_VALUE, U = null;
    return t.forEach((X, H) => {
      const Te = v(M !== "Forest Plot" ? X[n.xAxis.dataKey] : H), be = Math.abs(Te - re);
      be < K && (K = be, U = ae ? X[ae] : X[n.xAxis.dataKey]);
    }), U;
  }, ee = (re) => {
    var ae, K;
    try {
      if (n.visualizationType === "Bump Chart")
        return;
      const U = Sp(re), { x: X } = U;
      if (!X)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let H = V(X, !0), Te = (ae = n.data) == null ? void 0 : ae.filter((be) => be[n.xAxis.dataKey] === H);
      if (!H)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (Cn(T) && H && (H = new Date(H), H = l(H), Te = (K = n.data) == null ? void 0 : K.filter((be) => l(new Date(be[n.xAxis.dataKey])) === H)), !Te[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${H}`);
      u && (n != null && n.uid) && (Te != null && Te[0]) && u(n.uid, Te[0]);
    } catch (U) {
      console.error(U.message);
    }
  }, W = (re, ae) => {
    try {
      let K;
      return T.type === "categorical" ? K = t.filter((X) => X[T.dataKey] === re) : K = t.filter((X) => X[T.dataKey] === re), !K || K.length === 0 ? [] : K.map((X) => Object.fromEntries(Object.entries(X).filter(([H, Te]) => ae.includes(H))));
    } catch (K) {
      console.error("COVE", K);
    }
  }, Q = () => {
    var re;
    try {
      let ae, K = [], U = [];
      if ((re = n.runtime.series) == null || re.forEach((X) => {
        X.type === "Forecasting" && (K.push(X.stageColumn), X == null || X.confidenceIntervals.forEach((H) => {
          H.showInTooltip === !0 && (U.push(H.low), U.push(H.high));
        }));
      }), !n.dashboard)
        switch (M) {
          case "Combo":
            ae = [C.xAxis.dataKey, ...C == null ? void 0 : C.seriesKeys, ...U];
            break;
          case "Forecasting":
            ae = [C.xAxis.dataKey, ...K, ...U];
            break;
          case "Line":
            ae = [C.xAxis.dataKey, ...C == null ? void 0 : C.seriesKeys];
            break;
          case "Area Chart":
            ae = [C.xAxis.dataKey, ...C == null ? void 0 : C.seriesKeys];
            break;
          case "Bar":
            ae = E === "vertical" ? [C.xAxis.dataKey, ...C == null ? void 0 : C.seriesKeys] : [C.yAxis.dataKey, ...C == null ? void 0 : C.seriesKeys];
            break;
          case "Pie":
            ae = [C.xAxis.dataKey, ...C == null ? void 0 : C.seriesKeys];
          default:
            throw new Error("No visualization type found in handleTooltipMouseOver");
        }
      return n.dashboard && (ae = [C.xAxis.dataKey, ...C == null ? void 0 : C.barSeriesKeys, ...C == null ? void 0 : C.lineSeriesKeys, ...K, ...U]), ae;
    } catch (ae) {
      console.error("COVE", ae);
    }
  }, j = (re) => {
    const { dataXPosition: ae, dataYPosition: K } = re;
    return {
      opacity: n.tooltips.opacity ? n.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${ae}px, ${Number(K)}px)`
    };
  }, te = (re) => {
    var K, U;
    let ae = n.runtime.series.filter((X) => X.dataKey === re);
    return (K = ae[0]) != null && K.name ? (U = ae[0]) == null ? void 0 : U.name : re;
  };
  return {
    getIncludedTooltipSeries: Q,
    getXValueFromCoordinate: V,
    getXValueFromCoordinateDate: q,
    getYScaleValues: W,
    handleTooltipClick: ee,
    handleTooltipMouseOff: z,
    handleTooltipMouseOver: P,
    TooltipListItem: ({ item: re }) => {
      const [ae, K] = re, [U, X, H] = K;
      if (M === "Forest Plot")
        return U === n.xAxis.dataKey ? /* @__PURE__ */ r.createElement("li", { className: "tooltip-heading" }, `${i(n.xAxis.dataKey ? `${n.xAxis.dataKey}: ` : "")} ${Cn(p) ? l(f(U, !1)) : X}`) : /* @__PURE__ */ r.createElement("li", { className: "tooltip-body" }, `${te(U)}: ${a(X, "left")}`);
      const Te = n.tooltips.dateDisplayFormat ? c(f(X, !1)) : l(f(X, !1));
      return M === "Bar" && E === "horizontal" && U === n.xAxis.dataKey ? /* @__PURE__ */ r.createElement("li", { className: "tooltip-heading" }, `${i(n.runtime.yAxis.label ? `${n.runtime.yAxis.label}: ` : "")} ${n.xAxis.type === "date" ? Te : X}`) : U === n.xAxis.dataKey ? /* @__PURE__ */ r.createElement("li", { className: "tooltip-heading" }, `${i(n.runtime.xAxis.label ? `${n.runtime.xAxis.label}: ` : "")} ${Cn(T) ? Te : X}`) : /* @__PURE__ */ r.createElement("li", { className: "tooltip-body" }, `${te(U)}: ${X}`);
    },
    tooltipStyles: j
  };
};
function rp(e, { threshold: t = 0, root: n = null, rootMargin: a = "0%", freezeOnceVisible: i = !1 }) {
  const [l, c] = le.useState(), f = (l == null ? void 0 : l.isIntersecting) && i, u = ([m]) => {
    c(m);
  };
  return le.useEffect(() => {
    setTimeout(() => {
      const m = e == null ? void 0 : e.current;
      if (!!!window.IntersectionObserver || f || !m)
        return;
      const v = { threshold: t, root: n, rootMargin: a }, x = new IntersectionObserver(u, v);
      return x.observe(m), () => x.disconnect();
    }, 500);
  }, [e, t, n, a, f]), l;
}
const Cf = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let n = "";
    return e.visualizationType && (n += `${e.visualizationType} chart`), e.title && e.visualizationType && (n += ` with the title: ${e.title}`), n;
  } catch (n) {
    console.error("COVE: ", n.message);
  }
};
var kS = ["flexDirection", "alignItems", "margin", "display", "children"];
function Af() {
  return Af = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Af.apply(this, arguments);
}
function wS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function hc(e) {
  var t = e.flexDirection, n = t === void 0 ? "row" : t, a = e.alignItems, i = a === void 0 ? "center" : a, l = e.margin, c = l === void 0 ? "0" : l, f = e.display, u = f === void 0 ? "flex" : f, m = e.children, y = wS(e, kS);
  return /* @__PURE__ */ r.createElement("div", Af({
    className: "visx-legend-item",
    style: {
      display: u,
      alignItems: i,
      flexDirection: n,
      margin: c
    }
  }, y), m);
}
hc.propTypes = {
  alignItems: Ye.string,
  margin: Ye.oneOfType([Ye.string, Ye.number]),
  children: Ye.node,
  display: Ye.string
};
var TS = ["flex", "label", "margin", "align", "children"];
function Lf() {
  return Lf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Lf.apply(this, arguments);
}
function CS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function mc(e) {
  var t = e.flex, n = t === void 0 ? "1" : t, a = e.label, i = e.margin, l = i === void 0 ? "5px 0" : i, c = e.align, f = c === void 0 ? "left" : c, u = e.children, m = CS(e, TS);
  return /* @__PURE__ */ r.createElement("div", Lf({
    className: "visx-legend-label",
    style: {
      justifyContent: f,
      display: "flex",
      flex: n,
      margin: l
    }
  }, m), u || a);
}
mc.propTypes = {
  align: Ye.string,
  label: Ye.node,
  flex: Ye.oneOfType([Ye.string, Ye.number]),
  margin: Ye.oneOfType([Ye.string, Ye.number]),
  children: Ye.node
};
function Pf() {
  return Pf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Pf.apply(this, arguments);
}
function ap(e) {
  var t = e.fill, n = e.width, a = e.height, i = e.style;
  return /* @__PURE__ */ r.createElement("div", {
    style: Pf({
      width: n,
      height: a,
      background: t
    }, i)
  });
}
ap.propTypes = {
  fill: Ye.string,
  width: Ye.oneOfType([Ye.string, Ye.number]),
  height: Ye.oneOfType([Ye.string, Ye.number])
};
function Ty(e) {
  var t = e.fill, n = e.width, a = e.height, i = e.style, l = typeof n == "string" || typeof n > "u" ? 0 : n, c = typeof a == "string" || typeof a > "u" ? 0 : a, f = Math.max(l, c), u = f / 2;
  return /* @__PURE__ */ r.createElement("svg", {
    width: f,
    height: f
  }, /* @__PURE__ */ r.createElement(rt, {
    top: u,
    left: u
  }, /* @__PURE__ */ r.createElement("circle", {
    r: u,
    fill: t,
    style: i
  })));
}
Ty.propTypes = {
  fill: Ye.string,
  width: Ye.oneOfType([Ye.string, Ye.number]),
  height: Ye.oneOfType([Ye.string, Ye.number])
};
function Cy(e) {
  var t = e.fill, n = e.width, a = e.height, i = e.style, l = typeof a == "string" || typeof a > "u" ? 0 : a, c = typeof (i == null ? void 0 : i.strokeWidth) == "number" ? i == null ? void 0 : i.strokeWidth : 2;
  return /* @__PURE__ */ r.createElement("svg", {
    width: n,
    height: a
  }, /* @__PURE__ */ r.createElement(rt, {
    top: l / 2 - c / 2
  }, /* @__PURE__ */ r.createElement("line", {
    x1: 0,
    x2: n,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: c,
    style: i
  })));
}
Cy.propTypes = {
  fill: Ye.string,
  width: Ye.oneOfType([Ye.string, Ye.number]),
  height: Ye.oneOfType([Ye.string, Ye.number])
};
function ps() {
  return ps = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, ps.apply(this, arguments);
}
var Kd = function() {
};
function AS(e) {
  var t = e.shape, n = t === void 0 ? "rect" : t, a = e.fill, i = a === void 0 ? Kd : a, l = e.size, c = l === void 0 ? Kd : l, f = e.width, u = e.height, m = e.label, y = e.item, v = e.itemIndex, x = e.shapeStyle, A = x === void 0 ? Kd : x, T = {
    width: f,
    height: u,
    item: y,
    itemIndex: v,
    label: m,
    fill: i(ps({}, m)),
    size: c(ps({}, m)),
    style: A(ps({}, m))
  };
  return typeof n == "string" ? n === "circle" ? /* @__PURE__ */ r.createElement(Ty, T) : n === "line" ? /* @__PURE__ */ r.createElement(Cy, T) : /* @__PURE__ */ r.createElement(ap, T) : /* @__PURE__ */ r.isValidElement(n) ? /* @__PURE__ */ r.cloneElement(n, T) : n ? /* @__PURE__ */ r.createElement(n, T) : null;
}
function yc() {
  return yc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, yc.apply(this, arguments);
}
function Ay(e) {
  var t = e.shape, n = t === void 0 ? ap : t, a = e.width, i = e.height, l = e.margin, c = e.label, f = e.item, u = e.itemIndex, m = e.fill, y = e.size, v = e.shapeStyle;
  return /* @__PURE__ */ r.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: y ? y(yc({}, c)) : a,
      height: y ? y(yc({}, c)) : i,
      margin: l
    }
  }, AS({
    shape: n,
    item: f,
    itemIndex: u,
    label: c,
    width: a,
    height: i,
    fill: m,
    shapeStyle: v
  }));
}
Ay.propTypes = {
  itemIndex: Ye.number.isRequired,
  margin: Ye.oneOfType([Ye.string, Ye.number]),
  width: Ye.oneOfType([Ye.string, Ye.number]),
  height: Ye.oneOfType([Ye.string, Ye.number])
};
function Ly(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function Th(e) {
  return String(Ly(e));
}
function LS(e) {
  var t = e.scale, n = e.labelFormat;
  return function(a, i) {
    return {
      datum: a,
      index: i,
      text: "" + n(a, i),
      value: t(a)
    };
  };
}
var PS = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function hs() {
  return hs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, hs.apply(this, arguments);
}
function RS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var DS = {
  display: "flex"
};
function Py(e) {
  var t = e.className, n = e.style, a = n === void 0 ? DS : n, i = e.scale, l = e.shape, c = e.domain, f = e.fill, u = f === void 0 ? Th : f, m = e.size, y = m === void 0 ? Th : m, v = e.labelFormat, x = v === void 0 ? Ly : v, A = e.labelTransform, T = A === void 0 ? LS : A, M = e.shapeWidth, E = M === void 0 ? 15 : M, p = e.shapeHeight, C = p === void 0 ? 15 : p, _ = e.shapeMargin, w = _ === void 0 ? "2px 4px 2px 0" : _, R = e.shapeStyle, P = e.labelAlign, z = P === void 0 ? "left" : P, q = e.labelFlex, V = q === void 0 ? "1" : q, G = e.labelMargin, ee = G === void 0 ? "0 4px" : G, W = e.itemMargin, Q = W === void 0 ? "0" : W, j = e.direction, te = j === void 0 ? "column" : j, se = e.itemDirection, re = se === void 0 ? "row" : se, ae = e.legendLabelProps, K = e.children, U = RS(e, PS), X = c || ("domain" in i ? i.domain() : []), H = T({
    scale: i,
    labelFormat: x
  }), Te = X.map(H);
  return K ? /* @__PURE__ */ r.createElement(r.Fragment, null, K(Te)) : /* @__PURE__ */ r.createElement("div", {
    className: An("visx-legend", t),
    style: hs({}, a, {
      flexDirection: te
    })
  }, Te.map(function(be, ce) {
    return /* @__PURE__ */ r.createElement(hc, hs({
      key: "legend-" + be.text + "-" + ce,
      margin: Q,
      flexDirection: re
    }, U), /* @__PURE__ */ r.createElement(Ay, {
      shape: l,
      height: C,
      width: E,
      margin: w,
      item: X[ce],
      itemIndex: ce,
      label: be,
      fill: u,
      size: y,
      shapeStyle: R
    }), /* @__PURE__ */ r.createElement(mc, hs({
      label: be.text,
      flex: V,
      margin: ee,
      align: z
    }, ae)));
  }));
}
Py.propTypes = {
  children: Ye.func,
  className: Ye.string,
  domain: Ye.array,
  shapeWidth: Ye.oneOfType([Ye.string, Ye.number]),
  shapeHeight: Ye.oneOfType([Ye.string, Ye.number]),
  shapeMargin: Ye.oneOfType([Ye.string, Ye.number]),
  labelAlign: Ye.string,
  labelFlex: Ye.oneOfType([Ye.string, Ye.number]),
  labelMargin: Ye.oneOfType([Ye.string, Ye.number]),
  itemMargin: Ye.oneOfType([Ye.string, Ye.number]),
  fill: Ye.func,
  size: Ye.func,
  shapeStyle: Ye.func
};
function NS(e) {
  return /* @__PURE__ */ r.createElement(Py, e);
}
function _S(e) {
  let t = ["legend-container"], n = ["legend-container__inner"];
  return e.legend.position === "left" && t.push("left"), e.legend.position === "bottom" && (t.push("bottom"), n.push("bottom")), e.legend.position === "bottom" && e.legend.singleRow && n.push("single-row"), e.legend.reverseLabelOrder && (n.push("d-flex"), n.push("flex-column-reverse")), e.legend.position === "bottom" && e.legend.verticalSorted && n.push("vertical-sorted"), {
    containerClasses: t,
    innerClasses: n
  };
}
const _c = (e, t) => {
  var M;
  const { formatDate: n, parseDate: a } = le.useContext(bt);
  let i = [], l = "", c = [], f = [];
  ((M = e.series) == null ? void 0 : M.length) > 0 && e.data ? (i = e.series[0], l = e.series[0].dataKey, c = e.highlightedBarValues, f = e.data.map((E) => E[e.xAxis.dataKey])) : (i = [], l = "", c = [], f = []);
  const u = (E, p) => {
    const C = [...e.highlightedBarValues];
    C[p].borderWidth = E.target.value, t({
      ...e,
      highlightedBarValues: C
    });
  }, m = (E, p) => {
    E.preventDefault();
    const C = [...e.highlightedBarValues];
    C[p].value = E.target.value, C[p].dataKey = l, t({
      ...e,
      highlightedBarValues: C
    });
  }, y = (E, p) => {
    E.preventDefault();
    const C = [...e.highlightedBarValues];
    C.push({ dataKey: l }), t({
      ...e,
      highlightedBarValues: C
    });
  }, v = (E, p) => {
    E.preventDefault();
    const C = [...e.highlightedBarValues];
    C.splice(p, 1), t({
      ...e,
      highlightedBarValues: C
    });
  }, x = (E, p) => {
    const C = [...e.highlightedBarValues];
    C[p].color = E.target.value, t({
      ...e
    });
  }, A = (E, p) => {
    const C = [...e.highlightedBarValues];
    C[p].legendLabel = E.target.value, t({
      ...e,
      copyOfHighlightedBarValues: C
    });
  }, T = () => {
  };
  return T.checkFontColor = (E, p, C) => {
    if (e.xAxis.type === "date") {
      if (T.formatDates(p).includes(E))
        return "#000";
    } else if (p.includes(E))
      return "#000";
    return C;
  }, T.formatDates = (E) => E.map((p) => p ? n(a(p)) : !1), T.findDuplicates = (E) => {
    const p = {};
    return E == null ? void 0 : E.filter((_) => {
      const { legendLabel: w } = _;
      return p[w] ? !1 : (p[w] = !0, !0);
    });
  }, {
    HighLightedBarUtils: T,
    highlightedSeries: i,
    highlightedSeriesKey: l,
    highlightedBarValues: c,
    highlightedSeriesValues: f,
    handleUpdateHighlightedBar: m,
    handleAddNewHighlightedBar: y,
    handleRemoveHighlightedBar: v,
    handleUpdateHighlightedBarColor: x,
    handleHighlightedBarLegendLabel: A,
    handleUpdateHighlightedBorderWidth: u
  };
}, Ry = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, OS = (e, t) => e ? t ? "35px" : "15px" : "0px", Dy = le.forwardRef(({ config: e, colorScale: t, seriesHighlight: n, highlight: a, highlightReset: i, currentViewport: l, formatLabels: c, skipId: f = "legend" }, u) => {
  const { innerClasses: m, containerClasses: y } = _S(e), { runtime: v, legend: x } = e;
  if (!x)
    return null;
  const A = (x == null ? void 0 : x.position) === "bottom" || ["sm", "xs", "xxs"].includes(l) && !x.hide, T = {
    marginBottom: A ? "15px" : "0px",
    marginTop: A && e.orientation === "horizontal" ? `${e.yAxis.label && e.isResponsiveTicks ? e.dynamicMarginTop : e.runtime.xAxis.size}px` : OS(A, e.brush.active)
  }, { HighLightedBarUtils: M } = _c(e);
  let E = M.findDuplicates(e.highlightedBarValues);
  return /* @__PURE__ */ r.createElement("aside", { ref: u, style: T, id: f || "legend", className: y.join(" "), role: "region", "aria-label": "legend", tabIndex: 0 }, x.label && /* @__PURE__ */ r.createElement("h3", null, Ni(x.label)), x.description && /* @__PURE__ */ r.createElement("p", null, Ni(x.description)), /* @__PURE__ */ r.createElement(NS, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0" }, (p) => {
    var C, _, w, R;
    return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("div", { className: m.join(" ") }, c(p).map((P, z) => {
      var G, ee, W, Q;
      let q = ["legend-item", `legend-text--${P.text.replace(" ", "").toLowerCase()}`], V = P.datum;
      if (e.exclusions.active && ((G = e.exclusions.keys) != null && G.includes(V)))
        return null;
      if (v.seriesLabels) {
        let j = e.runtime.seriesLabelsAll.indexOf(V);
        V = e.runtime.seriesKeys[j], ((ee = v == null ? void 0 : v.forecastingSeriesKeys) == null ? void 0 : ee.length) > 0 && (V = P.text);
      }
      return n.length > 0 && n.includes(V) === !1 && q.push("inactive"), /* @__PURE__ */ r.createElement(
        hc,
        {
          className: q.join(" "),
          tabIndex: 0,
          key: `legend-quantile-${z}`,
          onKeyDown: (j) => {
            j.key === "Enter" && (j.preventDefault(), a(P));
          },
          onClick: (j) => {
            j.preventDefault(), a(P);
          },
          role: "button"
        },
        /* @__PURE__ */ r.createElement("div", null, e.visualizationType === "Line" && e.legend.lineMode ? /* @__PURE__ */ r.createElement("svg", { width: 40, height: 20 }, /* @__PURE__ */ r.createElement(en, { from: { x: 10, y: 10 }, to: { x: 40, y: 10 }, stroke: P.value, strokeWidth: 2, strokeDasharray: Ry((W = e.series[z]) != null && W.type ? (Q = e.series[z]) == null ? void 0 : Q.type : "") })) : /* @__PURE__ */ r.createElement("div", { style: { display: "flex", flexDirection: "column" } }, /* @__PURE__ */ r.createElement(Tp, { viewport: l, margin: "0", fill: P.value, display: !0 }))),
        /* @__PURE__ */ r.createElement(mc, { align: "left", margin: "0 0 0 4px" }, P.text)
      );
    }), E.map((P, z) => {
      let q = "legend-item", V = P.legendLabel;
      return V ? (n.length > 0 && n.includes(V) === !1 && (q += " inactive"), /* @__PURE__ */ r.createElement(
        hc,
        {
          className: q,
          tabIndex: 0,
          key: `legend-quantile-${z}`,
          onKeyDown: (G) => {
            G.key === "Enter" && (G.preventDefault(), a(P.legendLabel));
          },
          onClick: (G) => {
            G.preventDefault(), a(P.legendLabel);
          }
        },
        /* @__PURE__ */ r.createElement(Tp, { fill: "transparent", borderColor: P.color ? P.color : "rgba(255, 102, 1)" }),
        " ",
        /* @__PURE__ */ r.createElement(mc, { align: "left", margin: "0 0 0 4px" }, P.legendLabel ? P.legendLabel : P.value)
      )) : !1;
    })), /* @__PURE__ */ r.createElement(r.Fragment, null, ((C = e == null ? void 0 : e.preliminaryData) == null ? void 0 : C.some((P) => P.label && P.type === "effect" && P.style === "Open Circles")) && ["Line", "Combo"].includes(e.visualizationType) && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("hr", null), /* @__PURE__ */ r.createElement("div", { className: e.legend.singleRow && A ? "legend-container__inner bottom single-row" : "" }, (_ = e == null ? void 0 : e.preliminaryData) == null ? void 0 : _.map((P, z) => /* @__PURE__ */ r.createElement(r.Fragment, null, P.label && P.type === "effect" && P.style && /* @__PURE__ */ r.createElement("div", { key: z, className: "legend-preliminary" }, /* @__PURE__ */ r.createElement("span", { className: P.symbol }, P.lineCode), /* @__PURE__ */ r.createElement("p", null, " ", P.label)))))), !e.legend.hideSuppressedLabels && ((w = e == null ? void 0 : e.preliminaryData) == null ? void 0 : w.some((P) => P.label && P.displayLegend && P.type === "suppression" && P.value && ((P == null ? void 0 : P.style) || P.symbol))) && (e.visualizationType === "Bar" && e.visualizationSubType === "regular" || e.visualizationType === "Line" || e.visualizationType === "Combo") && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("hr", null), /* @__PURE__ */ r.createElement("div", { className: e.legend.singleRow && A ? "legend-container__inner bottom single-row" : "" }, (R = e == null ? void 0 : e.preliminaryData) == null ? void 0 : R.map(
      (P, z) => P.displayLegend && P.type === "suppression" && /* @__PURE__ */ r.createElement(r.Fragment, null, e.visualizationType === "Bar" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("div", { key: z + "Bar", className: `legend-preliminary ${P.symbol}` }, /* @__PURE__ */ r.createElement("span", { className: P.symbol }, P.iconCode), /* @__PURE__ */ r.createElement("p", { className: P.type }, P.label))), e.visualizationType === "Line" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("div", { key: z + "Line", className: "legend-preliminary " }, /* @__PURE__ */ r.createElement("span", null, P.lineCode), /* @__PURE__ */ r.createElement("p", { className: P.type }, P.label))), e.visualizationType === "Combo" && /* @__PURE__ */ r.createElement(r.Fragment, null, P.symbol && P.iconCode && /* @__PURE__ */ r.createElement("div", { key: z + "Combo", className: `legend-preliminary ${P.symbol}` }, /* @__PURE__ */ r.createElement("span", { className: P.symbol }, P.iconCode), /* @__PURE__ */ r.createElement("p", { className: P.type }, P.label)), P.style && P.lineCode && /* @__PURE__ */ r.createElement("div", { key: z + "Combo", className: "legend-preliminary" }, /* @__PURE__ */ r.createElement("span", null, P.lineCode), /* @__PURE__ */ r.createElement("p", null, P.label))))
    )))));
  }), n.length > 0 && /* @__PURE__ */ r.createElement(bs, { onClick: (p) => i(p), style: { marginTop: "1rem" } }, "Reset"));
});
function FS(e) {
  return fg({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" } }] })(e);
}
const Ny = (e, t, n, a) => (i) => {
  var x, A, T, M, E;
  const { visualizationType: l, visualizationSubType: c, series: f, runtime: u } = e, m = (p) => {
    var C;
    return e.legend.reverseLabelOrder && ((C = e.legend) == null ? void 0 : C.position) === "bottom" ? p.reverse() : p;
  }, y = (x = e.legend) == null ? void 0 : x.colorCode;
  if (l === "Deviation Bar") {
    const [p, C] = Ss[e.twoColor.palette], _ = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: p
    }, w = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: C
    };
    return m([_, w]);
  }
  if (l === "Bar" && c === "regular" && y && (f == null ? void 0 : f.length) === 1) {
    let p = cr[e.palette];
    for (; t.length > p.length; )
      p = p.concat(p);
    p = p.slice(0, n.length);
    const C = /* @__PURE__ */ new Set();
    t.forEach((w) => C.add(w[y]));
    const _ = Array.from(C).map((w, R) => ({
      datum: w,
      index: R,
      text: w,
      value: p[R]
    }));
    return m(_);
  }
  if (((A = u == null ? void 0 : u.forecastingSeriesKeys) == null ? void 0 : A.length) > 0) {
    let p = [];
    return (M = (T = e.runtime) == null ? void 0 : T.forecastingSeriesKeys) == null || M.map((C, _) => {
      var w;
      return (w = C == null ? void 0 : C.stages) == null ? void 0 : w.map((R, P) => {
        var V, G, ee, W;
        let z = (V = qu[R.color]) != null && V[2] ? (G = qu[R.color]) == null ? void 0 : G[2] : (ee = cr[R.color]) != null && ee[2] ? (W = cr[R.color]) == null ? void 0 : W[2] : "#ccc";
        const q = {
          datum: R.key,
          index: P,
          text: R.key,
          value: z
        };
        p.push(q);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((C, _) => {
      let w = cr[e.palette][_] ? cr[e.palette][_] : "#ccc";
      const R = {
        datum: C,
        index: _,
        text: C,
        value: w
      };
      p.push(R);
    }), m(p);
  }
  if (e.series.filter((p) => !!p.name).length > 0) {
    const p = /* @__PURE__ */ new Set();
    e.series.forEach((_) => {
      p.add(_.name || _.dataKey);
    });
    const C = Array.from(p).map((_, w) => ({
      datum: _,
      index: w,
      text: _,
      value: a(_)
    }));
    return m(C);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const p = i.length - 1;
    let C = [];
    return (E = e.suppressedData) == null || E.forEach(({ label: _, icon: w }, R) => {
      if (_ && w) {
        const P = {
          datum: _,
          index: p + R,
          text: _,
          icon: /* @__PURE__ */ r.createElement(FS, { color: "#000", size: 15 })
        };
        C.push(P);
      }
    }), [...i, ...C];
  }
  return m(i);
}, Nu = ({ startAngle: e, endAngle: t }) => ({
  startAngle: e,
  endAngle: t
}), MS = (e) => {
  const { transformedData: t, config: n, colorScale: a, currentViewport: i, dimensions: l, highlight: c, highlightReset: f, seriesHighlight: u, isDraggingAnnotation: m } = le.useContext(bt), { tooltipData: y, showTooltip: v, hideTooltip: x, tooltipOpen: A, tooltipLeft: T, tooltipTop: M } = xy(), { handleTooltipMouseOver: E, handleTooltipMouseOff: p, TooltipListItem: C } = wy({
    xScale: !1,
    yScale: !1,
    showTooltip: v,
    hideTooltip: x
  }), [_, w] = le.useState(void 0), [R, P] = le.useState(!1), z = Object.values(n.columns).filter((X) => X.showInViz), q = z.length > 0, V = q ? "pivotColumn" : void 0, G = le.useMemo(() => {
    if (q) {
      let X = [];
      const H = n.yAxis.dataKey, Te = z.map((Re) => Re.name), be = [H, ...Te], ce = n.xAxis.dataKey;
      return t.forEach((Re) => {
        be.forEach((He) => {
          const Ge = Re[He];
          Ge && X.push({
            [V]: Ge,
            [ce]: `${Re[ce]} - ${He}`
          });
        });
      }), X;
    }
    return t;
  }, [t, q]), ee = le.useMemo(() => {
    if (q) {
      const X = {};
      G.forEach((be) => {
        X[be[n.xAxis.dataKey]] || (X[be[n.xAxis.dataKey]] = !0);
      });
      const H = Object.entries(X).length;
      let Te = n.customColors || cr[n.palette];
      return Te = Te.slice(0, H), Oi({
        domain: Object.keys(X),
        range: Te,
        unknown: null
      });
    }
    return a;
  }, [a, q]), W = le.useRef(), Q = rp(W, {
    freezeOnceVisible: !1
  });
  le.useEffect(() => {
    document.querySelector(".isEditor") && P((H) => !0);
  }), le.useEffect(() => {
    Q != null && Q.isIntersecting && n.animate && !R && setTimeout(() => {
      P(!0);
    }, 500);
  }, [Q == null ? void 0 : Q.isIntersecting, n.animate]);
  const j = ({ arcs: X, path: H, getKey: Te }) => {
    const be = Tb(X, Te, {
      from: Nu,
      enter: Nu,
      update: Nu,
      leave: Nu
    });
    return le.useEffect(() => {
      const ce = setTimeout(() => {
        x();
      }, 500);
      return () => {
        clearTimeout(ce);
      };
    }, [y]), /* @__PURE__ */ r.createElement(r.Fragment, null, be.map(({ item: ce, props: Re, key: He }, Ge) => /* @__PURE__ */ r.createElement(rt, { className: ce.data[n.xAxis.dataKey], key: `${He}-${Ge}`, style: { opacity: n.legend.behavior === "highlight" && u.length > 0 && u.indexOf(ce.data[n.runtime.xAxis.dataKey]) === -1 ? 0.5 : 1 } }, /* @__PURE__ */ r.createElement(
      mh.path,
      {
        d: xb(
          [Re.startAngle, Re.endAngle],
          (Ne, ye) => H({
            ...ce,
            startAngle: Ne,
            endAngle: ye
          })
        ),
        fill: ee(ce.data[n.runtime.xAxis.dataKey]),
        onMouseEnter: (Ne) => E(Ne, { data: ce.data[n.runtime.xAxis.dataKey], arc: ce }),
        onMouseLeave: (Ne) => p()
      }
    ))), be.map(({ item: ce, key: Re }, He) => {
      const [Ge, Ne] = H.centroid(ce), ye = ce.endAngle - ce.startAngle >= 0.1;
      let Oe = "#FFF";
      return ee(ce.data[n.runtime.xAxis.dataKey]) && (Oe = Qo(Oe, ee(ce.data[n.runtime.xAxis.dataKey]))), /* @__PURE__ */ r.createElement(mh.g, { key: `${Re}${He}` }, ye && /* @__PURE__ */ r.createElement(xt, { style: { fill: Oe }, x: Ge, y: Ne, dy: ".33em", textAnchor: "middle", pointerEvents: "none" }, Math.round((ce.endAngle - ce.startAngle) * 180 / Math.PI / 360 * 100) + "%"));
    }));
  };
  let [te] = l;
  n && n.legend && !n.legend.hide && i === "lg" && (te = te * 0.73);
  const se = n.heights.vertical, re = Math.min(te, se) / 2, ae = se / 2, K = n.pieType === "Donut" ? 75 : re;
  le.useEffect(() => {
    if (u.length > 0 && n.legend.behavior !== "highlight") {
      let X = [];
      G.forEach((H) => {
        u.indexOf(H[n.runtime.xAxis.dataKey]) !== -1 && X.push(H);
      }), w(X);
    } else
      w(void 0);
  }, [u]);
  const U = Ny(n, [], G, ee);
  return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement($r, { component: "PieChart" }, /* @__PURE__ */ r.createElement("svg", { width: re * 2, height: se, className: `animated-pie group ${n.animate === !1 || R ? "animated" : ""}`, role: "img", "aria-label": Cf(n) }, /* @__PURE__ */ r.createElement(rt, { top: ae, left: re }, /* @__PURE__ */ r.createElement(
    z0,
    {
      data: _ || G,
      pieValue: (X) => X[V || n.runtime.yAxis.dataKey],
      pieSortValues: () => -1,
      innerRadius: re - K,
      outerRadius: re
    },
    (X) => /* @__PURE__ */ r.createElement(j, { ...X, getKey: (H) => H.data[n.runtime.xAxis.dataKey] })
  ))), /* @__PURE__ */ r.createElement("div", { ref: W }), !m && y && Object.entries(y.data).length > 0 && A && v && y.dataYPosition && y.dataXPosition && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${n.tooltips.opacity / 100}) !important`), /* @__PURE__ */ r.createElement(ky, { key: Math.random(), className: "tooltip cdc-open-viz-module", left: T, top: M }, /* @__PURE__ */ r.createElement("ul", null, typeof y == "object" && Object.entries(y.data).map((X, H) => /* @__PURE__ */ r.createElement(C, { item: X, key: H })))))), /* @__PURE__ */ r.createElement(Dy, { config: n, colorScale: ee, seriesHighlight: u, highlight: c, highlightReset: f, currentViewport: i, formatLabels: U }));
};
function Ls(e) {
  return e.split("-")[1];
}
function ip(e) {
  return e === "y" ? "height" : "width";
}
function $i(e) {
  return e.split("-")[0];
}
function Ps(e) {
  return ["top", "bottom"].includes($i(e)) ? "x" : "y";
}
function Ch(e, t, n) {
  let { reference: a, floating: i } = e;
  const l = a.x + a.width / 2 - i.width / 2, c = a.y + a.height / 2 - i.height / 2, f = Ps(t), u = ip(f), m = a[u] / 2 - i[u] / 2, y = f === "x";
  let v;
  switch ($i(t)) {
    case "top":
      v = { x: l, y: a.y - i.height };
      break;
    case "bottom":
      v = { x: l, y: a.y + a.height };
      break;
    case "right":
      v = { x: a.x + a.width, y: c };
      break;
    case "left":
      v = { x: a.x - i.width, y: c };
      break;
    default:
      v = { x: a.x, y: a.y };
  }
  switch (Ls(t)) {
    case "start":
      v[f] -= m * (n && y ? -1 : 1);
      break;
    case "end":
      v[f] += m * (n && y ? -1 : 1);
  }
  return v;
}
function _y(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function ms(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Oy(e, t) {
  var n;
  t === void 0 && (t = {});
  const { x: a, y: i, platform: l, rects: c, elements: f, strategy: u } = e, { boundary: m = "clippingAncestors", rootBoundary: y = "viewport", elementContext: v = "floating", altBoundary: x = !1, padding: A = 0 } = t, T = _y(A), M = f[x ? v === "floating" ? "reference" : "floating" : v], E = ms(await l.getClippingRect({ element: (n = await (l.isElement == null ? void 0 : l.isElement(M))) == null || n ? M : M.contextElement || await (l.getDocumentElement == null ? void 0 : l.getDocumentElement(f.floating)), boundary: m, rootBoundary: y, strategy: u })), p = v === "floating" ? { ...c.floating, x: a, y: i } : c.reference, C = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(f.floating)), _ = await (l.isElement == null ? void 0 : l.isElement(C)) && await (l.getScale == null ? void 0 : l.getScale(C)) || { x: 1, y: 1 }, w = ms(l.convertOffsetParentRelativeRectToViewportRelativeRect ? await l.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: p, offsetParent: C, strategy: u }) : p);
  return { top: (E.top - w.top + T.top) / _.y, bottom: (w.bottom - E.bottom + T.bottom) / _.y, left: (E.left - w.left + T.left) / _.x, right: (w.right - E.right + T.right) / _.x };
}
const zS = Math.min, $S = Math.max;
function Rf(e, t, n) {
  return $S(e, zS(t, n));
}
["top", "right", "bottom", "left"].reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const BS = { left: "right", right: "left", bottom: "top", top: "bottom" };
function gc(e) {
  return e.replace(/left|right|bottom|top/g, (t) => BS[t]);
}
function IS(e, t, n) {
  n === void 0 && (n = !1);
  const a = Ls(e), i = Ps(e), l = ip(i);
  let c = i === "x" ? a === (n ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[l] > t.floating[l] && (c = gc(c)), { main: c, cross: gc(c) };
}
const HS = { start: "end", end: "start" };
function Yd(e) {
  return e.replace(/start|end/g, (t) => HS[t]);
}
const WS = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var n;
    const { placement: a, middlewareData: i, rects: l, initialPlacement: c, platform: f, elements: u } = t, { mainAxis: m = !0, crossAxis: y = !0, fallbackPlacements: v, fallbackStrategy: x = "bestFit", fallbackAxisSideDirection: A = "none", flipAlignment: T = !0, ...M } = e, E = $i(a), p = $i(c) === c, C = await (f.isRTL == null ? void 0 : f.isRTL(u.floating)), _ = v || (p || !T ? [gc(c)] : function(ee) {
      const W = gc(ee);
      return [Yd(ee), W, Yd(W)];
    }(c));
    v || A === "none" || _.push(...function(ee, W, Q, j) {
      const te = Ls(ee);
      let se = function(re, ae, K) {
        const U = ["left", "right"], X = ["right", "left"], H = ["top", "bottom"], Te = ["bottom", "top"];
        switch (re) {
          case "top":
          case "bottom":
            return K ? ae ? X : U : ae ? U : X;
          case "left":
          case "right":
            return ae ? H : Te;
          default:
            return [];
        }
      }($i(ee), Q === "start", j);
      return te && (se = se.map((re) => re + "-" + te), W && (se = se.concat(se.map(Yd)))), se;
    }(c, T, A, C));
    const w = [c, ..._], R = await Oy(t, M), P = [];
    let z = ((n = i.flip) == null ? void 0 : n.overflows) || [];
    if (m && P.push(R[E]), y) {
      const { main: ee, cross: W } = IS(a, l, C);
      P.push(R[ee], R[W]);
    }
    if (z = [...z, { placement: a, overflows: P }], !P.every((ee) => ee <= 0)) {
      var q, V;
      const ee = (((q = i.flip) == null ? void 0 : q.index) || 0) + 1, W = w[ee];
      if (W)
        return { data: { index: ee, overflows: z }, reset: { placement: W } };
      let Q = (V = z.find((j) => j.overflows[0] <= 0)) == null ? void 0 : V.placement;
      if (!Q)
        switch (x) {
          case "bestFit": {
            var G;
            const j = (G = z.map((te) => [te.placement, te.overflows.filter((se) => se > 0).reduce((se, re) => se + re, 0)]).sort((te, se) => te[1] - se[1])[0]) == null ? void 0 : G[0];
            j && (Q = j);
            break;
          }
          case "initialPlacement":
            Q = c;
        }
      if (a !== Q)
        return { reset: { placement: Q } };
    }
    return {};
  } };
}, VS = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: n, y: a } = t, i = await async function(l, c) {
      const { placement: f, platform: u, elements: m } = l, y = await (u.isRTL == null ? void 0 : u.isRTL(m.floating)), v = $i(f), x = Ls(f), A = Ps(f) === "x", T = ["left", "top"].includes(v) ? -1 : 1, M = y && A ? -1 : 1, E = typeof c == "function" ? c(l) : c;
      let { mainAxis: p, crossAxis: C, alignmentAxis: _ } = typeof E == "number" ? { mainAxis: E, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...E };
      return x && typeof _ == "number" && (C = x === "end" ? -1 * _ : _), A ? { x: C * M, y: p * T } : { x: p * T, y: C * M };
    }(t, e);
    return { x: n + i.x, y: a + i.y, data: i };
  } };
}, jS = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: n, y: a, placement: i } = t, { mainAxis: l = !0, crossAxis: c = !1, limiter: f = { fn: (E) => {
      let { x: p, y: C } = E;
      return { x: p, y: C };
    } }, ...u } = e, m = { x: n, y: a }, y = await Oy(t, u), v = Ps($i(i)), x = v === "x" ? "y" : "x";
    let A = m[v], T = m[x];
    if (l) {
      const E = v === "y" ? "bottom" : "right";
      A = Rf(A + y[v === "y" ? "top" : "left"], A, A - y[E]);
    }
    if (c) {
      const E = x === "y" ? "bottom" : "right";
      T = Rf(T + y[x === "y" ? "top" : "left"], T, T - y[E]);
    }
    const M = f.fn({ ...t, [v]: A, [x]: T });
    return { ...M, data: { x: M.x - n, y: M.y - a } };
  } };
};
function Cr(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Gr(e) {
  return Cr(e).getComputedStyle(e);
}
const Ah = Math.min, ys = Math.max, vc = Math.round;
function Fy(e) {
  const t = Gr(e);
  let n = parseFloat(t.width), a = parseFloat(t.height);
  const i = e.offsetWidth, l = e.offsetHeight, c = vc(n) !== i || vc(a) !== l;
  return c && (n = i, a = l), { width: n, height: a, fallback: c };
}
function Wa(e) {
  return zy(e) ? (e.nodeName || "").toLowerCase() : "";
}
let _u;
function My() {
  if (_u)
    return _u;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (_u = e.brands.map((t) => t.brand + "/" + t.version).join(" "), _u) : navigator.userAgent;
}
function Zr(e) {
  return e instanceof Cr(e).HTMLElement;
}
function za(e) {
  return e instanceof Cr(e).Element;
}
function zy(e) {
  return e instanceof Cr(e).Node;
}
function Lh(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Cr(e).ShadowRoot || e instanceof ShadowRoot;
}
function Oc(e) {
  const { overflow: t, overflowX: n, overflowY: a, display: i } = Gr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + n) && !["inline", "contents"].includes(i);
}
function US(e) {
  return ["table", "td", "th"].includes(Wa(e));
}
function Df(e) {
  const t = /firefox/i.test(My()), n = Gr(e), a = n.backdropFilter || n.WebkitBackdropFilter;
  return n.transform !== "none" || n.perspective !== "none" || !!a && a !== "none" || t && n.willChange === "filter" || t && !!n.filter && n.filter !== "none" || ["transform", "perspective"].some((i) => n.willChange.includes(i)) || ["paint", "layout", "strict", "content"].some((i) => {
    const l = n.contain;
    return l != null && l.includes(i);
  });
}
function $y() {
  return !/^((?!chrome|android).)*safari/i.test(My());
}
function op(e) {
  return ["html", "body", "#document"].includes(Wa(e));
}
function By(e) {
  return za(e) ? e : e.contextElement;
}
const Iy = { x: 1, y: 1 };
function Zo(e) {
  const t = By(e);
  if (!Zr(t))
    return Iy;
  const n = t.getBoundingClientRect(), { width: a, height: i, fallback: l } = Fy(t);
  let c = (l ? vc(n.width) : n.width) / a, f = (l ? vc(n.height) : n.height) / i;
  return c && Number.isFinite(c) || (c = 1), f && Number.isFinite(f) || (f = 1), { x: c, y: f };
}
function Ts(e, t, n, a) {
  var i, l;
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const c = e.getBoundingClientRect(), f = By(e);
  let u = Iy;
  t && (a ? za(a) && (u = Zo(a)) : u = Zo(e));
  const m = f ? Cr(f) : window, y = !$y() && n;
  let v = (c.left + (y && ((i = m.visualViewport) == null ? void 0 : i.offsetLeft) || 0)) / u.x, x = (c.top + (y && ((l = m.visualViewport) == null ? void 0 : l.offsetTop) || 0)) / u.y, A = c.width / u.x, T = c.height / u.y;
  if (f) {
    const M = Cr(f), E = a && za(a) ? Cr(a) : a;
    let p = M.frameElement;
    for (; p && a && E !== M; ) {
      const C = Zo(p), _ = p.getBoundingClientRect(), w = getComputedStyle(p);
      _.x += (p.clientLeft + parseFloat(w.paddingLeft)) * C.x, _.y += (p.clientTop + parseFloat(w.paddingTop)) * C.y, v *= C.x, x *= C.y, A *= C.x, T *= C.y, v += _.x, x += _.y, p = Cr(p).frameElement;
    }
  }
  return { width: A, height: T, top: x, right: v + A, bottom: x + T, left: v, x: v, y: x };
}
function $a(e) {
  return ((zy(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function Fc(e) {
  return za(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function Hy(e) {
  return Ts($a(e)).left + Fc(e).scrollLeft;
}
function Cs(e) {
  if (Wa(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || Lh(e) && e.host || $a(e);
  return Lh(t) ? t.host : t;
}
function Wy(e) {
  const t = Cs(e);
  return op(t) ? t.ownerDocument.body : Zr(t) && Oc(t) ? t : Wy(t);
}
function Vy(e, t) {
  var n;
  t === void 0 && (t = []);
  const a = Wy(e), i = a === ((n = e.ownerDocument) == null ? void 0 : n.body), l = Cr(a);
  return i ? t.concat(l, l.visualViewport || [], Oc(a) ? a : []) : t.concat(a, Vy(a));
}
function Ph(e, t, n) {
  return t === "viewport" ? ms(function(a, i) {
    const l = Cr(a), c = $a(a), f = l.visualViewport;
    let u = c.clientWidth, m = c.clientHeight, y = 0, v = 0;
    if (f) {
      u = f.width, m = f.height;
      const x = $y();
      (x || !x && i === "fixed") && (y = f.offsetLeft, v = f.offsetTop);
    }
    return { width: u, height: m, x: y, y: v };
  }(e, n)) : za(t) ? ms(function(a, i) {
    const l = Ts(a, !0, i === "fixed"), c = l.top + a.clientTop, f = l.left + a.clientLeft, u = Zr(a) ? Zo(a) : { x: 1, y: 1 };
    return { width: a.clientWidth * u.x, height: a.clientHeight * u.y, x: f * u.x, y: c * u.y };
  }(t, n)) : ms(function(a) {
    const i = $a(a), l = Fc(a), c = a.ownerDocument.body, f = ys(i.scrollWidth, i.clientWidth, c.scrollWidth, c.clientWidth), u = ys(i.scrollHeight, i.clientHeight, c.scrollHeight, c.clientHeight);
    let m = -l.scrollLeft + Hy(a);
    const y = -l.scrollTop;
    return Gr(c).direction === "rtl" && (m += ys(i.clientWidth, c.clientWidth) - f), { width: f, height: u, x: m, y };
  }($a(e)));
}
function Rh(e) {
  return Zr(e) && Gr(e).position !== "fixed" ? e.offsetParent : null;
}
function Dh(e) {
  const t = Cr(e);
  let n = Rh(e);
  for (; n && US(n) && Gr(n).position === "static"; )
    n = Rh(n);
  return n && (Wa(n) === "html" || Wa(n) === "body" && Gr(n).position === "static" && !Df(n)) ? t : n || function(a) {
    let i = Cs(a);
    for (; Zr(i) && !op(i); ) {
      if (Df(i))
        return i;
      i = Cs(i);
    }
    return null;
  }(e) || t;
}
function KS(e, t, n) {
  const a = Zr(t), i = $a(t), l = Ts(e, !0, n === "fixed", t);
  let c = { scrollLeft: 0, scrollTop: 0 };
  const f = { x: 0, y: 0 };
  if (a || !a && n !== "fixed")
    if ((Wa(t) !== "body" || Oc(i)) && (c = Fc(t)), Zr(t)) {
      const u = Ts(t, !0);
      f.x = u.x + t.clientLeft, f.y = u.y + t.clientTop;
    } else
      i && (f.x = Hy(i));
  return { x: l.left + c.scrollLeft - f.x, y: l.top + c.scrollTop - f.y, width: l.width, height: l.height };
}
const YS = { getClippingRect: function(e) {
  let { element: t, boundary: n, rootBoundary: a, strategy: i } = e;
  const l = n === "clippingAncestors" ? function(m, y) {
    const v = y.get(m);
    if (v)
      return v;
    let x = Vy(m).filter((E) => za(E) && Wa(E) !== "body"), A = null;
    const T = Gr(m).position === "fixed";
    let M = T ? Cs(m) : m;
    for (; za(M) && !op(M); ) {
      const E = Gr(M), p = Df(M);
      (T ? p || A : p || E.position !== "static" || !A || !["absolute", "fixed"].includes(A.position)) ? A = E : x = x.filter((C) => C !== M), M = Cs(M);
    }
    return y.set(m, x), x;
  }(t, this._c) : [].concat(n), c = [...l, a], f = c[0], u = c.reduce((m, y) => {
    const v = Ph(t, y, i);
    return m.top = ys(v.top, m.top), m.right = Ah(v.right, m.right), m.bottom = Ah(v.bottom, m.bottom), m.left = ys(v.left, m.left), m;
  }, Ph(t, f, i));
  return { width: u.right - u.left, height: u.bottom - u.top, x: u.left, y: u.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: n, strategy: a } = e;
  const i = Zr(n), l = $a(n);
  if (n === l)
    return t;
  let c = { scrollLeft: 0, scrollTop: 0 }, f = { x: 1, y: 1 };
  const u = { x: 0, y: 0 };
  if ((i || !i && a !== "fixed") && ((Wa(n) !== "body" || Oc(l)) && (c = Fc(n)), Zr(n))) {
    const m = Ts(n);
    f = Zo(n), u.x = m.x + n.clientLeft, u.y = m.y + n.clientTop;
  }
  return { width: t.width * f.x, height: t.height * f.y, x: t.x * f.x - c.scrollLeft * f.x + u.x, y: t.y * f.y - c.scrollTop * f.y + u.y };
}, isElement: za, getDimensions: function(e) {
  return Zr(e) ? Fy(e) : e.getBoundingClientRect();
}, getOffsetParent: Dh, getDocumentElement: $a, getScale: Zo, async getElementRects(e) {
  let { reference: t, floating: n, strategy: a } = e;
  const i = this.getOffsetParent || Dh, l = this.getDimensions;
  return { reference: KS(t, await i(n), a), floating: { x: 0, y: 0, ...await l(n) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => Gr(e).direction === "rtl" }, Nh = (e, t, n) => {
  const a = /* @__PURE__ */ new Map(), i = { platform: YS, ...n }, l = { ...i.platform, _c: a };
  return (async (c, f, u) => {
    const { placement: m = "bottom", strategy: y = "absolute", middleware: v = [], platform: x } = u, A = v.filter(Boolean), T = await (x.isRTL == null ? void 0 : x.isRTL(f));
    if (x == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), A.filter((R) => {
      let { name: P } = R;
      return P === "autoPlacement" || P === "flip";
    }).length > 1)
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    c && f || console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    let M = await x.getElementRects({ reference: c, floating: f, strategy: y }), { x: E, y: p } = Ch(M, m, T), C = m, _ = {}, w = 0;
    for (let R = 0; R < A.length; R++) {
      const { name: P, fn: z } = A[R], { x: q, y: V, data: G, reset: ee } = await z({ x: E, y: p, initialPlacement: m, placement: C, strategy: y, middlewareData: _, rects: M, platform: x, elements: { reference: c, floating: f } });
      E = q ?? E, p = V ?? p, _ = { ..._, [P]: { ..._[P], ...G } }, w > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), ee && w <= 50 && (w++, typeof ee == "object" && (ee.placement && (C = ee.placement), ee.rects && (M = ee.rects === !0 ? await x.getElementRects({ reference: c, floating: f, strategy: y }) : ee.rects), { x: E, y: p } = Ch(M, C, T)), R = -1);
    }
    return { x: E, y: p, placement: C, strategy: y, middlewareData: _ };
  })(e, t, { ...i, platform: l });
};
var Fa, Bi = { exports: {} }, _h = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Fa = _h, function() {
  var e = r, t = 60103, n = 60106;
  Fa.Fragment = 60107;
  var a = 60108, i = 60114, l = 60109, c = 60110, f = 60112, u = 60113, m = 60120, y = 60115, v = 60116, x = 60121, A = 60122, T = 60117, M = 60129, E = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var p = Symbol.for;
    t = p("react.element"), n = p("react.portal"), Fa.Fragment = p("react.fragment"), a = p("react.strict_mode"), i = p("react.profiler"), l = p("react.provider"), c = p("react.context"), f = p("react.forward_ref"), u = p("react.suspense"), m = p("react.suspense_list"), y = p("react.memo"), v = p("react.lazy"), x = p("react.block"), A = p("react.server.block"), T = p("react.fundamental"), p("react.scope"), p("react.opaque.id"), M = p("react.debug_trace_mode"), p("react.offscreen"), E = p("react.legacy_hidden");
  }
  var C = typeof Symbol == "function" && Symbol.iterator, _ = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function w(ye) {
    for (var Oe = arguments.length, ue = new Array(Oe > 1 ? Oe - 1 : 0), ie = 1; ie < Oe; ie++)
      ue[ie - 1] = arguments[ie];
    R("error", ye, ue);
  }
  function R(ye, Oe, ue) {
    var ie = _.ReactDebugCurrentFrame, Ce = "";
    if (V) {
      var $e = z(V.type), Ve = V._owner;
      Ce += function(Ue, ft, Qe) {
        var We = "";
        if (ft) {
          var Ie = ft.fileName, Me = Ie.replace(P, "");
          if (/^index\./.test(Me)) {
            var tt = Ie.match(P);
            if (tt) {
              var Ze = tt[1];
              Ze && (Me = Ze.replace(P, "") + "/" + Me);
            }
          }
          We = " (at " + Me + ":" + ft.lineNumber + ")";
        } else
          Qe && (We = " (created by " + Qe + ")");
        return `
    in ` + (Ue || "Unknown") + We;
      }($e, V._source, Ve && z(Ve.type));
    }
    (Ce += ie.getStackAddendum()) !== "" && (Oe += "%s", ue = ue.concat([Ce]));
    var Ee = ue.map(function(Ue) {
      return "" + Ue;
    });
    Ee.unshift("Warning: " + Oe), Function.prototype.apply.call(console[ye], console, Ee);
  }
  var P = /^(.*)[\\\/]/;
  function z(ye) {
    if (ye == null)
      return null;
    if (typeof ye.tag == "number" && w("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof ye == "function")
      return ye.displayName || ye.name || null;
    if (typeof ye == "string")
      return ye;
    switch (ye) {
      case Fa.Fragment:
        return "Fragment";
      case n:
        return "Portal";
      case i:
        return "Profiler";
      case a:
        return "StrictMode";
      case u:
        return "Suspense";
      case m:
        return "SuspenseList";
    }
    if (typeof ye == "object")
      switch (ye.$$typeof) {
        case c:
          return "Context.Consumer";
        case l:
          return "Context.Provider";
        case f:
          return ie = ye, Ce = ye.render, $e = "ForwardRef", Ve = Ce.displayName || Ce.name || "", ie.displayName || (Ve !== "" ? $e + "(" + Ve + ")" : $e);
        case y:
          return z(ye.type);
        case x:
          return z(ye.render);
        case v:
          var Oe = (ue = ye)._status === 1 ? ue._result : null;
          if (Oe)
            return z(Oe);
      }
    var ue, ie, Ce, $e, Ve;
    return null;
  }
  var q = {};
  _.ReactDebugCurrentFrame;
  var V = null;
  function G(ye) {
    V = ye;
  }
  var ee, W, Q, j = _.ReactCurrentOwner, te = Object.prototype.hasOwnProperty, se = { key: !0, ref: !0, __self: !0, __source: !0 };
  function re(ye, Oe, ue, ie, Ce) {
    var $e, Ve = {}, Ee = null, Ue = null;
    for ($e in ue !== void 0 && (Ee = "" + ue), function(We) {
      if (te.call(We, "key")) {
        var Ie = Object.getOwnPropertyDescriptor(We, "key").get;
        if (Ie && Ie.isReactWarning)
          return !1;
      }
      return We.key !== void 0;
    }(Oe) && (Ee = "" + Oe.key), function(We) {
      if (te.call(We, "ref")) {
        var Ie = Object.getOwnPropertyDescriptor(We, "ref").get;
        if (Ie && Ie.isReactWarning)
          return !1;
      }
      return We.ref !== void 0;
    }(Oe) && (Ue = Oe.ref, function(We, Ie) {
      if (typeof We.ref == "string" && j.current && Ie && j.current.stateNode !== Ie) {
        var Me = z(j.current.type);
        Q[Me] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', z(j.current.type), We.ref), Q[Me] = !0);
      }
    }(Oe, Ce)), Oe)
      te.call(Oe, $e) && !se.hasOwnProperty($e) && (Ve[$e] = Oe[$e]);
    if (ye && ye.defaultProps) {
      var ft = ye.defaultProps;
      for ($e in ft)
        Ve[$e] === void 0 && (Ve[$e] = ft[$e]);
    }
    if (Ee || Ue) {
      var Qe = typeof ye == "function" ? ye.displayName || ye.name || "Unknown" : ye;
      Ee && function(We, Ie) {
        var Me = function() {
          ee || (ee = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ie));
        };
        Me.isReactWarning = !0, Object.defineProperty(We, "key", { get: Me, configurable: !0 });
      }(Ve, Qe), Ue && function(We, Ie) {
        var Me = function() {
          W || (W = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ie));
        };
        Me.isReactWarning = !0, Object.defineProperty(We, "ref", { get: Me, configurable: !0 });
      }(Ve, Qe);
    }
    return function(We, Ie, Me, tt, Ze, et, at) {
      var gt = { $$typeof: t, type: We, key: Ie, ref: Me, props: at, _owner: et, _store: {} };
      return Object.defineProperty(gt._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(gt, "_self", { configurable: !1, enumerable: !1, writable: !1, value: tt }), Object.defineProperty(gt, "_source", { configurable: !1, enumerable: !1, writable: !1, value: Ze }), Object.freeze && (Object.freeze(gt.props), Object.freeze(gt)), gt;
    }(ye, Ee, Ue, Ce, ie, j.current, Ve);
  }
  Q = {};
  var ae, K = _.ReactCurrentOwner;
  function U(ye) {
    V = ye;
  }
  function X(ye) {
    return typeof ye == "object" && ye !== null && ye.$$typeof === t;
  }
  function H() {
    if (K.current) {
      var ye = z(K.current.type);
      if (ye)
        return `

Check the render method of \`` + ye + "`.";
    }
    return "";
  }
  _.ReactDebugCurrentFrame, ae = !1;
  var Te = {};
  function be(ye, Oe) {
    if (ye._store && !ye._store.validated && ye.key == null) {
      ye._store.validated = !0;
      var ue = function(Ce) {
        var $e = H();
        if (!$e) {
          var Ve = typeof Ce == "string" ? Ce : Ce.displayName || Ce.name;
          Ve && ($e = `

Check the top-level render call using <` + Ve + ">.");
        }
        return $e;
      }(Oe);
      if (!Te[ue]) {
        Te[ue] = !0;
        var ie = "";
        ye && ye._owner && ye._owner !== K.current && (ie = " It was passed a child from " + z(ye._owner.type) + "."), U(ye), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ue, ie), U(null);
      }
    }
  }
  function ce(ye, Oe) {
    if (typeof ye == "object") {
      if (Array.isArray(ye))
        for (var ue = 0; ue < ye.length; ue++) {
          var ie = ye[ue];
          X(ie) && be(ie, Oe);
        }
      else if (X(ye))
        ye._store && (ye._store.validated = !0);
      else if (ye) {
        var Ce = function(Ee) {
          if (Ee === null || typeof Ee != "object")
            return null;
          var Ue = C && Ee[C] || Ee["@@iterator"];
          return typeof Ue == "function" ? Ue : null;
        }(ye);
        if (typeof Ce == "function" && Ce !== ye.entries)
          for (var $e, Ve = Ce.call(ye); !($e = Ve.next()).done; )
            X($e.value) && be($e.value, Oe);
      }
    }
  }
  function Re(ye) {
    var Oe, ue = ye.type;
    if (ue != null && typeof ue != "string") {
      if (typeof ue == "function")
        Oe = ue.propTypes;
      else {
        if (typeof ue != "object" || ue.$$typeof !== f && ue.$$typeof !== y)
          return;
        Oe = ue.propTypes;
      }
      if (Oe) {
        var ie = z(ue);
        (function(Ce, $e, Ve, Ee, Ue) {
          var ft = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var Qe in Ce)
            if (ft(Ce, Qe)) {
              var We = void 0;
              try {
                if (typeof Ce[Qe] != "function") {
                  var Ie = Error((Ee || "React class") + ": " + Ve + " type `" + Qe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ce[Qe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Ie.name = "Invariant Violation", Ie;
                }
                We = Ce[Qe]($e, Qe, Ee, Ve, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Me) {
                We = Me;
              }
              !We || We instanceof Error || (G(Ue), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ee || "React class", Ve, Qe, typeof We), G(null)), We instanceof Error && !(We.message in q) && (q[We.message] = !0, G(Ue), w("Failed %s type: %s", Ve, We.message), G(null));
            }
        })(Oe, ye.props, "prop", ie, ye);
      } else
        ue.PropTypes === void 0 || ae || (ae = !0, w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", z(ue) || "Unknown"));
      typeof ue.getDefaultProps != "function" || ue.getDefaultProps.isReactClassApproved || w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function He(ye, Oe, ue, ie, Ce, $e) {
    var Ve = function(Me) {
      return typeof Me == "string" || typeof Me == "function" || Me === Fa.Fragment || Me === i || Me === M || Me === a || Me === u || Me === m || Me === E || typeof Me == "object" && Me !== null && (Me.$$typeof === v || Me.$$typeof === y || Me.$$typeof === l || Me.$$typeof === c || Me.$$typeof === f || Me.$$typeof === T || Me.$$typeof === x || Me[0] === A);
    }(ye);
    if (!Ve) {
      var Ee = "";
      (ye === void 0 || typeof ye == "object" && ye !== null && Object.keys(ye).length === 0) && (Ee += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
      var Ue, ft = function(Me) {
        return Me !== void 0 ? `

Check your code at ` + Me.fileName.replace(/^.*[\\\/]/, "") + ":" + Me.lineNumber + "." : "";
      }(Ce);
      Ee += ft || H(), ye === null ? Ue = "null" : Array.isArray(ye) ? Ue = "array" : ye !== void 0 && ye.$$typeof === t ? (Ue = "<" + (z(ye.type) || "Unknown") + " />", Ee = " Did you accidentally export a JSX literal instead of a component?") : Ue = typeof ye, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ue, Ee);
    }
    var Qe = re(ye, Oe, ue, Ce, $e);
    if (Qe == null)
      return Qe;
    if (Ve) {
      var We = Oe.children;
      if (We !== void 0)
        if (ie)
          if (Array.isArray(We)) {
            for (var Ie = 0; Ie < We.length; Ie++)
              ce(We[Ie], ye);
            Object.freeze && Object.freeze(We);
          } else
            w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          ce(We, ye);
    }
    return ye === Fa.Fragment ? function(Me) {
      for (var tt = Object.keys(Me.props), Ze = 0; Ze < tt.length; Ze++) {
        var et = tt[Ze];
        if (et !== "children" && et !== "key") {
          U(Me), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", et), U(null);
          break;
        }
      }
      Me.ref !== null && (U(Me), w("Invalid attribute `ref` supplied to `React.Fragment`."), U(null));
    }(Qe) : Re(Qe), Qe;
  }
  var Ge = function(ye, Oe, ue) {
    return He(ye, Oe, ue, !1);
  }, Ne = function(ye, Oe, ue) {
    return He(ye, Oe, ue, !0);
  };
  Fa.jsx = Ge, Fa.jsxs = Ne;
}(), Bi.exports = _h;
var Xd, jy = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
Xd = jy, function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var n = [], a = 0; a < arguments.length; a++) {
      var i = arguments[a];
      if (i) {
        var l = typeof i;
        if (l === "string" || l === "number")
          n.push(i);
        else if (Array.isArray(i)) {
          if (i.length) {
            var c = t.apply(null, i);
            c && n.push(c);
          }
        } else if (l === "object") {
          if (i.toString !== Object.prototype.toString && !i.toString.toString().includes("[native code]")) {
            n.push(i.toString());
            continue;
          }
          for (var f in i)
            e.call(i, f) && i[f] && n.push(f);
        }
      }
    }
    return n.join(" ");
  }
  Xd.exports ? (t.default = t, Xd.exports = t) : window.classNames = t;
}();
var Oh = jy.exports;
const Fh = (e, t, n) => {
  let a = null;
  return function(...i) {
    a && clearTimeout(a), a = setTimeout(() => {
      a = null, n || e.apply(this, i);
    }, t);
  };
}, XS = ({ content: e }) => Bi.exports.jsx("span", { dangerouslySetInnerHTML: { __html: e } }), qS = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} }, GS = le.createContext({ getTooltipData: () => qS });
function Uy(e = "DEFAULT_TOOLTIP_ID") {
  return le.useContext(GS).getTooltipData(e);
}
const Mh = async ({ elementReference: e = null, tooltipReference: t = null, tooltipArrowReference: n = null, place: a = "top", offset: i = 10, strategy: l = "absolute", middlewares: c = [VS(Number(i)), WS(), jS({ padding: 5 })] }) => {
  if (!e)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  if (t === null)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  const f = c;
  return n ? (f.push({ name: "arrow", options: u = { element: n, padding: 5 }, async fn(m) {
    const { element: y, padding: v = 0 } = u || {}, { x, y: A, placement: T, rects: M, platform: E } = m;
    if (y == null)
      return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."), {};
    const p = _y(v), C = { x, y: A }, _ = Ps(T), w = ip(_), R = await E.getDimensions(y), P = _ === "y" ? "top" : "left", z = _ === "y" ? "bottom" : "right", q = M.reference[w] + M.reference[_] - C[_] - M.floating[w], V = C[_] - M.reference[_], G = await (E.getOffsetParent == null ? void 0 : E.getOffsetParent(y));
    let ee = G ? _ === "y" ? G.clientHeight || 0 : G.clientWidth || 0 : 0;
    ee === 0 && (ee = M.floating[w]);
    const W = q / 2 - V / 2, Q = p[P], j = ee - R[w] - p[z], te = ee / 2 - R[w] / 2 + W, se = Rf(Q, te, j), re = Ls(T) != null && te != se && M.reference[w] / 2 - (te < Q ? p[P] : p[z]) - R[w] / 2 < 0;
    return { [_]: C[_] - (re ? te < Q ? Q - te : j - te : 0), data: { [_]: se, centerOffset: te - se } };
  } }), Nh(e, t, { placement: a, strategy: l, middleware: f }).then(({ x: m, y, placement: v, middlewareData: x }) => {
    var A, T;
    const M = { left: `${m}px`, top: `${y}px` }, { x: E, y: p } = (A = x.arrow) !== null && A !== void 0 ? A : { x: 0, y: 0 };
    return { tooltipStyles: M, tooltipArrowStyles: { left: E != null ? `${E}px` : "", top: p != null ? `${p}px` : "", right: "", bottom: "", [(T = { top: "bottom", right: "left", bottom: "top", left: "right" }[v.split("-")[0]]) !== null && T !== void 0 ? T : "bottom"]: "-4px" } };
  })) : Nh(e, t, { placement: "bottom", strategy: l, middleware: f }).then(({ x: m, y }) => ({ tooltipStyles: { left: `${m}px`, top: `${y}px` }, tooltipArrowStyles: {} }));
  var u;
};
var Li = { tooltip: "styles-module_tooltip__mnnfp", fixed: "styles-module_fixed__7ciUi", arrow: "styles-module_arrow__K0L3T", "no-arrow": "styles-module_no-arrow__KcFZN", clickable: "styles-module_clickable__Bv9o7", show: "styles-module_show__2NboJ", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
const zh = ({ id: e, className: t, classNameArrow: n, variant: a = "dark", anchorId: i, anchorSelect: l, place: c = "top", offset: f = 10, events: u = ["hover"], positionStrategy: m = "absolute", middlewares: y, wrapper: v, children: x = null, delayShow: A = 0, delayHide: T = 0, float: M = !1, noArrow: E = !1, clickable: p = !1, closeOnEsc: C = !1, style: _, position: w, afterShow: R, afterHide: P, content: z, html: q, isOpen: V, setIsOpen: G, activeAnchor: ee, setActiveAnchor: W }) => {
  const Q = le.useRef(null), j = le.useRef(null), te = le.useRef(null), se = le.useRef(null), [re, ae] = le.useState({}), [K, U] = le.useState({}), [X, H] = le.useState(!1), [Te, be] = le.useState(!1), ce = le.useRef(!1), Re = le.useRef(null), { anchorRefs: He, setActiveAnchor: Ge } = Uy(e), Ne = le.useRef(!1), [ye, Oe] = le.useState([]), ue = le.useRef(!1);
  le.useLayoutEffect(() => (ue.current = !0, () => {
    ue.current = !1;
  }), []), le.useEffect(() => {
    if (!X) {
      const Ze = setTimeout(() => {
        be(!1);
      }, 150);
      return () => {
        clearTimeout(Ze);
      };
    }
    return () => null;
  }, [X]);
  const ie = (Ze) => {
    ue.current && (Ze && be(!0), setTimeout(() => {
      ue.current && (G == null || G(Ze), V === void 0 && H(Ze));
    }, 10));
  };
  le.useEffect(() => {
    if (V === void 0)
      return () => null;
    V && be(!0);
    const Ze = setTimeout(() => {
      H(V);
    }, 10);
    return () => {
      clearTimeout(Ze);
    };
  }, [V]), le.useEffect(() => {
    X !== ce.current && (ce.current = X, X ? R == null || R() : P == null || P());
  }, [X]);
  const Ce = (Ze = T) => {
    se.current && clearTimeout(se.current), se.current = setTimeout(() => {
      Ne.current || ie(!1);
    }, Ze);
  }, $e = (Ze) => {
    var et;
    if (!Ze)
      return;
    A ? (te.current && clearTimeout(te.current), te.current = setTimeout(() => {
      ie(!0);
    }, A)) : ie(!0);
    const at = (et = Ze.currentTarget) !== null && et !== void 0 ? et : Ze.target;
    W(at), Ge({ current: at }), se.current && clearTimeout(se.current);
  }, Ve = () => {
    p ? Ce(T || 100) : T ? Ce() : ie(!1), te.current && clearTimeout(te.current);
  }, Ee = ({ x: Ze, y: et }) => {
    Mh({ place: c, offset: f, elementReference: { getBoundingClientRect: () => ({ x: Ze, y: et, width: 0, height: 0, top: et, left: Ze, right: Ze, bottom: et }) }, tooltipReference: Q.current, tooltipArrowReference: j.current, strategy: m, middlewares: y }).then((at) => {
      Object.keys(at.tooltipStyles).length && ae(at.tooltipStyles), Object.keys(at.tooltipArrowStyles).length && U(at.tooltipArrowStyles);
    });
  }, Ue = (Ze) => {
    if (!Ze)
      return;
    const et = Ze, at = { x: et.clientX, y: et.clientY };
    Ee(at), Re.current = at;
  }, ft = (Ze) => {
    $e(Ze), T && Ce();
  }, Qe = (Ze) => {
    const et = document.querySelector(`[id='${i}']`);
    et != null && et.contains(Ze.target) || ye.some((at) => at.contains(Ze.target)) || ie(!1);
  }, We = (Ze) => {
    Ze.key === "Escape" && ie(!1);
  }, Ie = Fh($e, 50), Me = Fh(Ve, 50);
  le.useEffect(() => {
    var Ze, et;
    const at = new Set(He);
    ye.forEach((Wt) => {
      at.add({ current: Wt });
    });
    const gt = document.querySelector(`[id='${i}']`);
    gt && at.add({ current: gt }), C && window.addEventListener("keydown", We);
    const Ot = [];
    u.find((Wt) => Wt === "click") && (window.addEventListener("click", Qe), Ot.push({ event: "click", listener: ft })), u.find((Wt) => Wt === "hover") && (Ot.push({ event: "mouseenter", listener: Ie }, { event: "mouseleave", listener: Me }, { event: "focus", listener: Ie }, { event: "blur", listener: Me }), M && Ot.push({ event: "mousemove", listener: Ue }));
    const Kt = () => {
      Ne.current = !0;
    }, on = () => {
      Ne.current = !1, Ve();
    };
    return p && ((Ze = Q.current) === null || Ze === void 0 || Ze.addEventListener("mouseenter", Kt), (et = Q.current) === null || et === void 0 || et.addEventListener("mouseleave", on)), Ot.forEach(({ event: Wt, listener: Zt }) => {
      at.forEach((zt) => {
        var fn;
        (fn = zt.current) === null || fn === void 0 || fn.addEventListener(Wt, Zt);
      });
    }), () => {
      var Wt, Zt;
      u.find((zt) => zt === "click") && window.removeEventListener("click", Qe), C && window.removeEventListener("keydown", We), p && ((Wt = Q.current) === null || Wt === void 0 || Wt.removeEventListener("mouseenter", Kt), (Zt = Q.current) === null || Zt === void 0 || Zt.removeEventListener("mouseleave", on)), Ot.forEach(({ event: zt, listener: fn }) => {
        at.forEach((Yt) => {
          var tn;
          (tn = Yt.current) === null || tn === void 0 || tn.removeEventListener(zt, fn);
        });
      });
    };
  }, [Te, He, ye, C, u]), le.useEffect(() => {
    let Ze = l ?? "";
    !Ze && e && (Ze = `[data-tooltip-id='${e}']`);
    const et = new MutationObserver((at) => {
      const gt = [];
      at.forEach((Ot) => {
        if (Ot.type === "attributes" && Ot.attributeName === "data-tooltip-id" && Ot.target.getAttribute("data-tooltip-id") === e && gt.push(Ot.target), Ot.type === "childList" && (ee && [...Ot.removedNodes].some((Kt) => !!Kt.contains(ee) && (be(!1), ie(!1), W(null), !0)), Ze))
          try {
            const Kt = [...Ot.addedNodes].filter((on) => on.nodeType === 1);
            gt.push(...Kt.filter((on) => on.matches(Ze))), gt.push(...Kt.flatMap((on) => [...on.querySelectorAll(Ze)]));
          } catch {
          }
      }), gt.length && Oe((Ot) => [...Ot, ...gt]);
    });
    return et.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"] }), () => {
      et.disconnect();
    };
  }, [e, l, ee]), le.useEffect(() => {
    w ? Ee(w) : M ? Re.current && Ee(Re.current) : Mh({ place: c, offset: f, elementReference: ee, tooltipReference: Q.current, tooltipArrowReference: j.current, strategy: m, middlewares: y }).then((Ze) => {
      ue.current && (Object.keys(Ze.tooltipStyles).length && ae(Ze.tooltipStyles), Object.keys(Ze.tooltipArrowStyles).length && U(Ze.tooltipArrowStyles));
    });
  }, [X, ee, z, q, c, f, m, w]), le.useEffect(() => {
    var Ze;
    const et = document.querySelector(`[id='${i}']`), at = [...ye, et];
    ee && at.includes(ee) || W((Ze = ye[0]) !== null && Ze !== void 0 ? Ze : et);
  }, [i, ye, ee]), le.useEffect(() => () => {
    te.current && clearTimeout(te.current), se.current && clearTimeout(se.current);
  }, []), le.useEffect(() => {
    let Ze = l;
    if (!Ze && e && (Ze = `[data-tooltip-id='${e}']`), Ze)
      try {
        const et = Array.from(document.querySelectorAll(Ze));
        Oe(et);
      } catch {
        Oe([]);
      }
  }, [e, l]);
  const tt = !!(q || z || x) && X && Object.keys(re).length > 0;
  return Te ? Bi.exports.jsxs(v, { id: e, role: "tooltip", className: Oh("react-tooltip", Li.tooltip, Li[a], t, { [Li.show]: tt, [Li.fixed]: m === "fixed", [Li.clickable]: p }), style: { ..._, ...re }, ref: Q, children: [q && Bi.exports.jsx(XS, { content: q }) || z || x, Bi.exports.jsx(v, { className: Oh("react-tooltip-arrow", Li.arrow, n, { [Li["no-arrow"]]: E }), style: K, ref: j })] }) : null;
}, Nf = ({ id: e, anchorId: t, anchorSelect: n, content: a, html: i, className: l, classNameArrow: c, variant: f = "dark", place: u = "top", offset: m = 10, wrapper: y = "div", children: v = null, events: x = ["hover"], positionStrategy: A = "absolute", middlewares: T, delayShow: M = 0, delayHide: E = 0, float: p = !1, noArrow: C = !1, clickable: _ = !1, closeOnEsc: w = !1, style: R, position: P, isOpen: z, setIsOpen: q, afterShow: V, afterHide: G }) => {
  const [ee, W] = le.useState(a), [Q, j] = le.useState(i), [te, se] = le.useState(u), [re, ae] = le.useState(f), [K, U] = le.useState(m), [X, H] = le.useState(M), [Te, be] = le.useState(E), [ce, Re] = le.useState(p), [He, Ge] = le.useState(y), [Ne, ye] = le.useState(x), [Oe, ue] = le.useState(A), [ie, Ce] = le.useState(null), { anchorRefs: $e, activeAnchor: Ve } = Uy(e), Ee = (Qe) => Qe == null ? void 0 : Qe.getAttributeNames().reduce((We, Ie) => {
    var Me;
    return Ie.startsWith("data-tooltip-") && (We[Ie.replace(/^data-tooltip-/, "")] = (Me = Qe == null ? void 0 : Qe.getAttribute(Ie)) !== null && Me !== void 0 ? Me : null), We;
  }, {}), Ue = (Qe) => {
    const We = { place: (Ie) => {
      var Me;
      se((Me = Ie) !== null && Me !== void 0 ? Me : u);
    }, content: (Ie) => {
      W(Ie ?? a);
    }, html: (Ie) => {
      j(Ie ?? i);
    }, variant: (Ie) => {
      var Me;
      ae((Me = Ie) !== null && Me !== void 0 ? Me : f);
    }, offset: (Ie) => {
      U(Ie === null ? m : Number(Ie));
    }, wrapper: (Ie) => {
      var Me;
      Ge((Me = Ie) !== null && Me !== void 0 ? Me : y);
    }, events: (Ie) => {
      const Me = Ie == null ? void 0 : Ie.split(" ");
      ye(Me ?? x);
    }, "position-strategy": (Ie) => {
      var Me;
      ue((Me = Ie) !== null && Me !== void 0 ? Me : A);
    }, "delay-show": (Ie) => {
      H(Ie === null ? M : Number(Ie));
    }, "delay-hide": (Ie) => {
      be(Ie === null ? E : Number(Ie));
    }, float: (Ie) => {
      Re(Ie === null ? p : !!Ie);
    } };
    Object.values(We).forEach((Ie) => Ie(null)), Object.entries(Qe).forEach(([Ie, Me]) => {
      var tt;
      (tt = We[Ie]) === null || tt === void 0 || tt.call(We, Me);
    });
  };
  le.useEffect(() => {
    W(a);
  }, [a]), le.useEffect(() => {
    j(i);
  }, [i]), le.useEffect(() => {
    se(u);
  }, [u]), le.useEffect(() => {
    var Qe;
    const We = new Set($e);
    let Ie = n;
    if (!Ie && e && (Ie = `[data-tooltip-id='${e}']`), Ie)
      try {
        document.querySelectorAll(Ie).forEach((at) => {
          We.add({ current: at });
        });
      } catch {
        console.warn(`[react-tooltip] "${n}" is not a valid CSS selector`);
      }
    const Me = document.querySelector(`[id='${t}']`);
    if (Me && We.add({ current: Me }), !We.size)
      return () => null;
    const tt = (Qe = ie ?? Me) !== null && Qe !== void 0 ? Qe : Ve.current, Ze = new MutationObserver((at) => {
      at.forEach((gt) => {
        var Ot;
        if (!tt || gt.type !== "attributes" || !(!((Ot = gt.attributeName) === null || Ot === void 0) && Ot.startsWith("data-tooltip-")))
          return;
        const Kt = Ee(tt);
        Ue(Kt);
      });
    }), et = { attributes: !0, childList: !1, subtree: !1 };
    if (tt) {
      const at = Ee(tt);
      Ue(at), Ze.observe(tt, et);
    }
    return () => {
      Ze.disconnect();
    };
  }, [$e, Ve, ie, t, n]);
  const ft = { id: e, anchorId: t, anchorSelect: n, className: l, classNameArrow: c, content: ee, html: Q, place: te, variant: re, offset: K, wrapper: He, events: Ne, positionStrategy: Oe, middlewares: T, delayShow: X, delayHide: Te, float: ce, noArrow: C, clickable: _, closeOnEsc: w, style: R, position: P, isOpen: z, setIsOpen: q, afterShow: V, afterHide: G, activeAnchor: ie, setActiveAnchor: (Qe) => Ce(Qe) };
  return v ? Bi.exports.jsx(zh, { ...ft, children: v }) : Bi.exports.jsx(zh, { ...ft });
};
function $h(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n < a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function ZS(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n > a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let i of e)
      (i = t(i, ++a, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function qd(e, t) {
  let n = 0;
  if (t === void 0)
    for (let a of e)
      (a = +a) && (n += a);
  else {
    let a = -1;
    for (let i of e)
      (i = +t(i, ++a, e)) && (n += i);
  }
  return n;
}
function QS(e) {
  return e.depth;
}
function JS(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function Ou(e) {
  return function() {
    return e;
  };
}
function Bh(e, t) {
  return xc(e.source, t.source) || e.index - t.index;
}
function Ih(e, t) {
  return xc(e.target, t.target) || e.index - t.index;
}
function xc(e, t) {
  return e.y0 - t.y0;
}
function Gd(e) {
  return e.value;
}
function eE(e) {
  return e.index;
}
function tE(e) {
  return e.nodes;
}
function nE(e) {
  return e.links;
}
function Hh(e, t) {
  const n = e.get(t);
  if (!n)
    throw new Error("missing: " + t);
  return n;
}
function Wh({ nodes: e }) {
  for (const t of e) {
    let n = t.y0, a = n;
    for (const i of t.sourceLinks)
      i.y0 = n + i.width / 2, n += i.width;
    for (const i of t.targetLinks)
      i.y1 = a + i.width / 2, a += i.width;
  }
}
function rE() {
  let e = 0, t = 0, n = 1, a = 1, i = 24, l = 8, c, f = eE, u = JS, m, y, v = tE, x = nE, A = 6;
  function T() {
    const te = { nodes: v.apply(null, arguments), links: x.apply(null, arguments) };
    return M(te), E(te), p(te), C(te), R(te), Wh(te), te;
  }
  T.update = function(te) {
    return Wh(te), te;
  }, T.nodeId = function(te) {
    return arguments.length ? (f = typeof te == "function" ? te : Ou(te), T) : f;
  }, T.nodeAlign = function(te) {
    return arguments.length ? (u = typeof te == "function" ? te : Ou(te), T) : u;
  }, T.nodeSort = function(te) {
    return arguments.length ? (m = te, T) : m;
  }, T.nodeWidth = function(te) {
    return arguments.length ? (i = +te, T) : i;
  }, T.nodePadding = function(te) {
    return arguments.length ? (l = c = +te, T) : l;
  }, T.nodes = function(te) {
    return arguments.length ? (v = typeof te == "function" ? te : Ou(te), T) : v;
  }, T.links = function(te) {
    return arguments.length ? (x = typeof te == "function" ? te : Ou(te), T) : x;
  }, T.linkSort = function(te) {
    return arguments.length ? (y = te, T) : y;
  }, T.size = function(te) {
    return arguments.length ? (e = t = 0, n = +te[0], a = +te[1], T) : [n - e, a - t];
  }, T.extent = function(te) {
    return arguments.length ? (e = +te[0][0], n = +te[1][0], t = +te[0][1], a = +te[1][1], T) : [[e, t], [n, a]];
  }, T.iterations = function(te) {
    return arguments.length ? (A = +te, T) : A;
  };
  function M({ nodes: te, links: se }) {
    for (const [ae, K] of te.entries())
      K.index = ae, K.sourceLinks = [], K.targetLinks = [];
    const re = new Map(te.map((ae, K) => [f(ae, K, te), ae]));
    for (const [ae, K] of se.entries()) {
      K.index = ae;
      let { source: U, target: X } = K;
      typeof U != "object" && (U = K.source = Hh(re, U)), typeof X != "object" && (X = K.target = Hh(re, X)), U.sourceLinks.push(K), X.targetLinks.push(K);
    }
    if (y != null)
      for (const { sourceLinks: ae, targetLinks: K } of te)
        ae.sort(y), K.sort(y);
  }
  function E({ nodes: te }) {
    for (const se of te)
      se.value = se.fixedValue === void 0 ? Math.max(qd(se.sourceLinks, Gd), qd(se.targetLinks, Gd)) : se.fixedValue;
  }
  function p({ nodes: te }) {
    const se = te.length;
    let re = new Set(te), ae = /* @__PURE__ */ new Set(), K = 0;
    for (; re.size; ) {
      for (const U of re) {
        U.depth = K;
        for (const { target: X } of U.sourceLinks)
          ae.add(X);
      }
      if (++K > se)
        throw new Error("circular link");
      re = ae, ae = /* @__PURE__ */ new Set();
    }
  }
  function C({ nodes: te }) {
    const se = te.length;
    let re = new Set(te), ae = /* @__PURE__ */ new Set(), K = 0;
    for (; re.size; ) {
      for (const U of re) {
        U.height = K;
        for (const { source: X } of U.targetLinks)
          ae.add(X);
      }
      if (++K > se)
        throw new Error("circular link");
      re = ae, ae = /* @__PURE__ */ new Set();
    }
  }
  function _({ nodes: te }) {
    const se = $h(te, (K) => K.depth) + 1, re = (n - e - i) / (se - 1), ae = new Array(se);
    for (const K of te) {
      const U = Math.max(0, Math.min(se - 1, Math.floor(u.call(null, K, se))));
      K.layer = U, K.x0 = e + U * re, K.x1 = K.x0 + i, ae[U] ? ae[U].push(K) : ae[U] = [K];
    }
    if (m)
      for (const K of ae)
        K.sort(m);
    return ae;
  }
  function w(te) {
    const se = ZS(te, (re) => (a - t - (re.length - 1) * c) / qd(re, Gd));
    for (const re of te) {
      let ae = t;
      for (const K of re) {
        K.y0 = ae, K.y1 = ae + K.value * se, ae = K.y1 + c;
        for (const U of K.sourceLinks)
          U.width = U.value * se;
      }
      ae = (a - ae + c) / (re.length + 1);
      for (let K = 0; K < re.length; ++K) {
        const U = re[K];
        U.y0 += ae * (K + 1), U.y1 += ae * (K + 1);
      }
      W(re);
    }
  }
  function R(te) {
    const se = _(te);
    c = Math.min(l, (a - t) / ($h(se, (re) => re.length) - 1)), w(se);
    for (let re = 0; re < A; ++re) {
      const ae = Math.pow(0.99, re), K = Math.max(1 - ae, (re + 1) / A);
      z(se, ae, K), P(se, ae, K);
    }
  }
  function P(te, se, re) {
    for (let ae = 1, K = te.length; ae < K; ++ae) {
      const U = te[ae];
      for (const X of U) {
        let H = 0, Te = 0;
        for (const { source: ce, value: Re } of X.targetLinks) {
          let He = Re * (X.layer - ce.layer);
          H += Q(ce, X) * He, Te += He;
        }
        if (!(Te > 0))
          continue;
        let be = (H / Te - X.y0) * se;
        X.y0 += be, X.y1 += be, ee(X);
      }
      m === void 0 && U.sort(xc), q(U, re);
    }
  }
  function z(te, se, re) {
    for (let ae = te.length, K = ae - 2; K >= 0; --K) {
      const U = te[K];
      for (const X of U) {
        let H = 0, Te = 0;
        for (const { target: ce, value: Re } of X.sourceLinks) {
          let He = Re * (ce.layer - X.layer);
          H += j(X, ce) * He, Te += He;
        }
        if (!(Te > 0))
          continue;
        let be = (H / Te - X.y0) * se;
        X.y0 += be, X.y1 += be, ee(X);
      }
      m === void 0 && U.sort(xc), q(U, re);
    }
  }
  function q(te, se) {
    const re = te.length >> 1, ae = te[re];
    G(te, ae.y0 - c, re - 1, se), V(te, ae.y1 + c, re + 1, se), G(te, a, te.length - 1, se), V(te, t, 0, se);
  }
  function V(te, se, re, ae) {
    for (; re < te.length; ++re) {
      const K = te[re], U = (se - K.y0) * ae;
      U > 1e-6 && (K.y0 += U, K.y1 += U), se = K.y1 + c;
    }
  }
  function G(te, se, re, ae) {
    for (; re >= 0; --re) {
      const K = te[re], U = (K.y1 - se) * ae;
      U > 1e-6 && (K.y0 -= U, K.y1 -= U), se = K.y0 - c;
    }
  }
  function ee({ sourceLinks: te, targetLinks: se }) {
    if (y === void 0) {
      for (const { source: { sourceLinks: re } } of se)
        re.sort(Ih);
      for (const { target: { targetLinks: re } } of te)
        re.sort(Bh);
    }
  }
  function W(te) {
    if (y === void 0)
      for (const { sourceLinks: se, targetLinks: re } of te)
        se.sort(Ih), re.sort(Bh);
  }
  function Q(te, se) {
    let re = te.y0 - (te.sourceLinks.length - 1) * c / 2;
    for (const { target: ae, width: K } of te.sourceLinks) {
      if (ae === se)
        break;
      re += K + c;
    }
    for (const { source: ae, width: K } of se.targetLinks) {
      if (ae === te)
        break;
      re -= K;
    }
    return re;
  }
  function j(te, se) {
    let re = se.y0 - (se.targetLinks.length - 1) * c / 2;
    for (const { source: ae, width: K } of se.targetLinks) {
      if (ae === te)
        break;
      re += K + c;
    }
    for (const { target: ae, width: K } of te.sourceLinks) {
      if (ae === se)
        break;
      re -= K;
    }
    return re;
  }
  return T;
}
function aE(e) {
  return [e.source.x1, e.y0];
}
function iE(e) {
  return [e.target.x0, e.y1];
}
function oE() {
  return o0().source(aE).target(iE);
}
var Va = {}, Pi = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Vh;
function lE() {
  if (Vh)
    return Pi;
  Vh = 1;
  var e = le;
  function t(g) {
    for (var D = "https://reactjs.org/docs/error-decoder.html?invariant=" + g, B = 1; B < arguments.length; B++)
      D += "&args[]=" + encodeURIComponent(arguments[B]);
    return "Minified React error #" + g + "; visit " + D + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = Object.prototype.hasOwnProperty, a = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, i = {}, l = {};
  function c(g) {
    return n.call(l, g) ? !0 : n.call(i, g) ? !1 : a.test(g) ? l[g] = !0 : (i[g] = !0, !1);
  }
  function f(g, D, B, Z, Se, ve, De) {
    this.acceptsBooleans = D === 2 || D === 3 || D === 4, this.attributeName = Z, this.attributeNamespace = Se, this.mustUseProperty = B, this.propertyName = g, this.type = D, this.sanitizeURL = ve, this.removeEmptyString = De;
  }
  var u = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(g) {
    u[g] = new f(g, 0, !1, g, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(g) {
    var D = g[0];
    u[D] = new f(D, 1, !1, g[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(g) {
    u[g] = new f(g, 2, !1, g.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(g) {
    u[g] = new f(g, 2, !1, g, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(g) {
    u[g] = new f(g, 3, !1, g.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(g) {
    u[g] = new f(g, 3, !0, g, null, !1, !1);
  }), ["capture", "download"].forEach(function(g) {
    u[g] = new f(g, 4, !1, g, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(g) {
    u[g] = new f(g, 6, !1, g, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(g) {
    u[g] = new f(g, 5, !1, g.toLowerCase(), null, !1, !1);
  });
  var m = /[\-:]([a-z])/g;
  function y(g) {
    return g[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(g) {
    var D = g.replace(
      m,
      y
    );
    u[D] = new f(D, 1, !1, g, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(g) {
    var D = g.replace(m, y);
    u[D] = new f(D, 1, !1, g, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(g) {
    var D = g.replace(m, y);
    u[D] = new f(D, 1, !1, g, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(g) {
    u[g] = new f(g, 1, !1, g.toLowerCase(), null, !1, !1);
  }), u.xlinkHref = new f("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(g) {
    u[g] = new f(g, 1, !1, g.toLowerCase(), null, !0, !0);
  });
  var v = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, x = ["Webkit", "ms", "Moz", "O"];
  Object.keys(v).forEach(function(g) {
    x.forEach(function(D) {
      D = D + g.charAt(0).toUpperCase() + g.substring(1), v[D] = v[g];
    });
  });
  var A = /["'&<>]/;
  function T(g) {
    if (typeof g == "boolean" || typeof g == "number")
      return "" + g;
    g = "" + g;
    var D = A.exec(g);
    if (D) {
      var B = "", Z, Se = 0;
      for (Z = D.index; Z < g.length; Z++) {
        switch (g.charCodeAt(Z)) {
          case 34:
            D = "&quot;";
            break;
          case 38:
            D = "&amp;";
            break;
          case 39:
            D = "&#x27;";
            break;
          case 60:
            D = "&lt;";
            break;
          case 62:
            D = "&gt;";
            break;
          default:
            continue;
        }
        Se !== Z && (B += g.substring(Se, Z)), Se = Z + 1, B += D;
      }
      g = Se !== Z ? B + g.substring(Se, Z) : B;
    }
    return g;
  }
  var M = /([A-Z])/g, E = /^ms-/, p = Array.isArray;
  function C(g, D) {
    return { insertionMode: g, selectedValue: D };
  }
  function _(g, D, B) {
    switch (D) {
      case "select":
        return C(1, B.value != null ? B.value : B.defaultValue);
      case "svg":
        return C(2, null);
      case "math":
        return C(3, null);
      case "foreignObject":
        return C(1, null);
      case "table":
        return C(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return C(5, null);
      case "colgroup":
        return C(7, null);
      case "tr":
        return C(6, null);
    }
    return 4 <= g.insertionMode || g.insertionMode === 0 ? C(1, null) : g;
  }
  var w = /* @__PURE__ */ new Map();
  function R(g, D, B) {
    if (typeof B != "object")
      throw Error(t(62));
    D = !0;
    for (var Z in B)
      if (n.call(B, Z)) {
        var Se = B[Z];
        if (Se != null && typeof Se != "boolean" && Se !== "") {
          if (Z.indexOf("--") === 0) {
            var ve = T(Z);
            Se = T(("" + Se).trim());
          } else {
            ve = Z;
            var De = w.get(ve);
            De !== void 0 || (De = T(ve.replace(M, "-$1").toLowerCase().replace(E, "-ms-")), w.set(ve, De)), ve = De, Se = typeof Se == "number" ? Se === 0 || n.call(v, Z) ? "" + Se : Se + "px" : T(("" + Se).trim());
          }
          D ? (D = !1, g.push(' style="', ve, ":", Se)) : g.push(";", ve, ":", Se);
        }
      }
    D || g.push('"');
  }
  function P(g, D, B, Z) {
    switch (B) {
      case "style":
        R(g, D, Z);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < B.length) || B[0] !== "o" && B[0] !== "O" || B[1] !== "n" && B[1] !== "N") {
      if (D = u.hasOwnProperty(B) ? u[B] : null, D !== null) {
        switch (typeof Z) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!D.acceptsBooleans)
              return;
        }
        switch (B = D.attributeName, D.type) {
          case 3:
            Z && g.push(" ", B, '=""');
            break;
          case 4:
            Z === !0 ? g.push(" ", B, '=""') : Z !== !1 && g.push(" ", B, '="', T(Z), '"');
            break;
          case 5:
            isNaN(Z) || g.push(" ", B, '="', T(Z), '"');
            break;
          case 6:
            !isNaN(Z) && 1 <= Z && g.push(" ", B, '="', T(Z), '"');
            break;
          default:
            D.sanitizeURL && (Z = "" + Z), g.push(" ", B, '="', T(Z), '"');
        }
      } else if (c(B)) {
        switch (typeof Z) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (D = B.toLowerCase().slice(0, 5), D !== "data-" && D !== "aria-")
              return;
        }
        g.push(" ", B, '="', T(Z), '"');
      }
    }
  }
  function z(g, D, B) {
    if (D != null) {
      if (B != null)
        throw Error(t(60));
      if (typeof D != "object" || !("__html" in D))
        throw Error(t(61));
      D = D.__html, D != null && g.push("" + D);
    }
  }
  function q(g) {
    var D = "";
    return e.Children.forEach(g, function(B) {
      B != null && (D += B);
    }), D;
  }
  function V(g, D, B, Z) {
    g.push(W(B));
    var Se = B = null, ve;
    for (ve in D)
      if (n.call(D, ve)) {
        var De = D[ve];
        if (De != null)
          switch (ve) {
            case "children":
              B = De;
              break;
            case "dangerouslySetInnerHTML":
              Se = De;
              break;
            default:
              P(g, Z, ve, De);
          }
      }
    return g.push(">"), z(g, Se, B), typeof B == "string" ? (g.push(T(B)), null) : B;
  }
  var G = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, ee = /* @__PURE__ */ new Map();
  function W(g) {
    var D = ee.get(g);
    if (D === void 0) {
      if (!G.test(g))
        throw Error(t(65, g));
      D = "<" + g, ee.set(g, D);
    }
    return D;
  }
  function Q(g, D, B, Z, Se) {
    switch (D) {
      case "select":
        g.push(W("select"));
        var ve = null, De = null;
        for (pt in B)
          if (n.call(B, pt)) {
            var Xe = B[pt];
            if (Xe != null)
              switch (pt) {
                case "children":
                  ve = Xe;
                  break;
                case "dangerouslySetInnerHTML":
                  De = Xe;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  P(g, Z, pt, Xe);
              }
          }
        return g.push(">"), z(g, De, ve), ve;
      case "option":
        De = Se.selectedValue, g.push(W("option"));
        var ut = Xe = null, vt = null, pt = null;
        for (ve in B)
          if (n.call(B, ve)) {
            var Mt = B[ve];
            if (Mt != null)
              switch (ve) {
                case "children":
                  Xe = Mt;
                  break;
                case "selected":
                  vt = Mt;
                  break;
                case "dangerouslySetInnerHTML":
                  pt = Mt;
                  break;
                case "value":
                  ut = Mt;
                default:
                  P(g, Z, ve, Mt);
              }
          }
        if (De != null)
          if (B = ut !== null ? "" + ut : q(Xe), p(De)) {
            for (Z = 0; Z < De.length; Z++)
              if ("" + De[Z] === B) {
                g.push(' selected=""');
                break;
              }
          } else
            "" + De === B && g.push(' selected=""');
        else
          vt && g.push(' selected=""');
        return g.push(">"), z(g, pt, Xe), Xe;
      case "textarea":
        g.push(W("textarea")), pt = De = ve = null;
        for (Xe in B)
          if (n.call(B, Xe) && (ut = B[Xe], ut != null))
            switch (Xe) {
              case "children":
                pt = ut;
                break;
              case "value":
                ve = ut;
                break;
              case "defaultValue":
                De = ut;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                P(
                  g,
                  Z,
                  Xe,
                  ut
                );
            }
        if (ve === null && De !== null && (ve = De), g.push(">"), pt != null) {
          if (ve != null)
            throw Error(t(92));
          if (p(pt) && 1 < pt.length)
            throw Error(t(93));
          ve = "" + pt;
        }
        return typeof ve == "string" && ve[0] === `
` && g.push(`
`), ve !== null && g.push(T("" + ve)), null;
      case "input":
        g.push(W("input")), ut = pt = Xe = ve = null;
        for (De in B)
          if (n.call(B, De) && (vt = B[De], vt != null))
            switch (De) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                ut = vt;
                break;
              case "defaultValue":
                Xe = vt;
                break;
              case "checked":
                pt = vt;
                break;
              case "value":
                ve = vt;
                break;
              default:
                P(g, Z, De, vt);
            }
        return pt !== null ? P(g, Z, "checked", pt) : ut !== null && P(g, Z, "checked", ut), ve !== null ? P(g, Z, "value", ve) : Xe !== null && P(g, Z, "value", Xe), g.push("/>"), null;
      case "menuitem":
        g.push(W("menuitem"));
        for (var Dn in B)
          if (n.call(B, Dn) && (ve = B[Dn], ve != null))
            switch (Dn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                P(g, Z, Dn, ve);
            }
        return g.push(">"), null;
      case "title":
        g.push(W("title")), ve = null;
        for (Mt in B)
          if (n.call(B, Mt) && (De = B[Mt], De != null))
            switch (Mt) {
              case "children":
                ve = De;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                P(g, Z, Mt, De);
            }
        return g.push(">"), ve;
      case "listing":
      case "pre":
        g.push(W(D)), De = ve = null;
        for (ut in B)
          if (n.call(B, ut) && (Xe = B[ut], Xe != null))
            switch (ut) {
              case "children":
                ve = Xe;
                break;
              case "dangerouslySetInnerHTML":
                De = Xe;
                break;
              default:
                P(g, Z, ut, Xe);
            }
        if (g.push(">"), De != null) {
          if (ve != null)
            throw Error(t(60));
          if (typeof De != "object" || !("__html" in De))
            throw Error(t(61));
          B = De.__html, B != null && (typeof B == "string" && 0 < B.length && B[0] === `
` ? g.push(`
`, B) : g.push("" + B));
        }
        return typeof ve == "string" && ve[0] === `
` && g.push(`
`), ve;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        g.push(W(D));
        for (var pe in B)
          if (n.call(B, pe) && (ve = B[pe], ve != null))
            switch (pe) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, D));
              default:
                P(g, Z, pe, ve);
            }
        return g.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return V(
          g,
          B,
          D,
          Z
        );
      case "html":
        return Se.insertionMode === 0 && g.push("<!DOCTYPE html>"), V(g, B, D, Z);
      default:
        if (D.indexOf("-") === -1 && typeof B.is != "string")
          return V(g, B, D, Z);
        g.push(W(D)), De = ve = null;
        for (vt in B)
          if (n.call(B, vt) && (Xe = B[vt], Xe != null))
            switch (vt) {
              case "children":
                ve = Xe;
                break;
              case "dangerouslySetInnerHTML":
                De = Xe;
                break;
              case "style":
                R(g, Z, Xe);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                c(vt) && typeof Xe != "function" && typeof Xe != "symbol" && g.push(" ", vt, '="', T(Xe), '"');
            }
        return g.push(">"), z(g, De, ve), ve;
    }
  }
  function j(g, D, B) {
    if (g.push('<!--$?--><template id="'), B === null)
      throw Error(t(395));
    return g.push(B), g.push('"></template>');
  }
  function te(g, D, B, Z) {
    switch (B.insertionMode) {
      case 0:
      case 1:
        return g.push('<div hidden id="'), g.push(D.segmentPrefix), D = Z.toString(16), g.push(D), g.push('">');
      case 2:
        return g.push('<svg aria-hidden="true" style="display:none" id="'), g.push(D.segmentPrefix), D = Z.toString(16), g.push(D), g.push('">');
      case 3:
        return g.push('<math aria-hidden="true" style="display:none" id="'), g.push(D.segmentPrefix), D = Z.toString(16), g.push(D), g.push('">');
      case 4:
        return g.push('<table hidden id="'), g.push(D.segmentPrefix), D = Z.toString(16), g.push(D), g.push('">');
      case 5:
        return g.push('<table hidden><tbody id="'), g.push(D.segmentPrefix), D = Z.toString(16), g.push(D), g.push('">');
      case 6:
        return g.push('<table hidden><tr id="'), g.push(D.segmentPrefix), D = Z.toString(16), g.push(D), g.push('">');
      case 7:
        return g.push('<table hidden><colgroup id="'), g.push(D.segmentPrefix), D = Z.toString(16), g.push(D), g.push('">');
      default:
        throw Error(t(397));
    }
  }
  function se(g, D) {
    switch (D.insertionMode) {
      case 0:
      case 1:
        return g.push("</div>");
      case 2:
        return g.push("</svg>");
      case 3:
        return g.push("</math>");
      case 4:
        return g.push("</table>");
      case 5:
        return g.push("</tbody></table>");
      case 6:
        return g.push("</tr></table>");
      case 7:
        return g.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var re = /[<\u2028\u2029]/g;
  function ae(g) {
    return JSON.stringify(g).replace(re, function(D) {
      switch (D) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function K(g, D) {
    return D = D === void 0 ? "" : D, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: D + "P:", segmentPrefix: D + "S:", boundaryPrefix: D + "B:", idPrefix: D, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: g };
  }
  function U(g, D, B, Z) {
    return B.generateStaticMarkup ? (g.push(T(D)), !1) : (D === "" ? g = Z : (Z && g.push("<!-- -->"), g.push(T(D)), g = !0), g);
  }
  var X = Object.assign, H = Symbol.for("react.element"), Te = Symbol.for("react.portal"), be = Symbol.for("react.fragment"), ce = Symbol.for("react.strict_mode"), Re = Symbol.for("react.profiler"), He = Symbol.for("react.provider"), Ge = Symbol.for("react.context"), Ne = Symbol.for("react.forward_ref"), ye = Symbol.for("react.suspense"), Oe = Symbol.for("react.suspense_list"), ue = Symbol.for("react.memo"), ie = Symbol.for("react.lazy"), Ce = Symbol.for("react.scope"), $e = Symbol.for("react.debug_trace_mode"), Ve = Symbol.for("react.legacy_hidden"), Ee = Symbol.for("react.default_value"), Ue = Symbol.iterator;
  function ft(g) {
    if (g == null)
      return null;
    if (typeof g == "function")
      return g.displayName || g.name || null;
    if (typeof g == "string")
      return g;
    switch (g) {
      case be:
        return "Fragment";
      case Te:
        return "Portal";
      case Re:
        return "Profiler";
      case ce:
        return "StrictMode";
      case ye:
        return "Suspense";
      case Oe:
        return "SuspenseList";
    }
    if (typeof g == "object")
      switch (g.$$typeof) {
        case Ge:
          return (g.displayName || "Context") + ".Consumer";
        case He:
          return (g._context.displayName || "Context") + ".Provider";
        case Ne:
          var D = g.render;
          return g = g.displayName, g || (g = D.displayName || D.name || "", g = g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef"), g;
        case ue:
          return D = g.displayName || null, D !== null ? D : ft(g.type) || "Memo";
        case ie:
          D = g._payload, g = g._init;
          try {
            return ft(g(D));
          } catch {
          }
      }
    return null;
  }
  var Qe = {};
  function We(g, D) {
    if (g = g.contextTypes, !g)
      return Qe;
    var B = {}, Z;
    for (Z in g)
      B[Z] = D[Z];
    return B;
  }
  var Ie = null;
  function Me(g, D) {
    if (g !== D) {
      g.context._currentValue2 = g.parentValue, g = g.parent;
      var B = D.parent;
      if (g === null) {
        if (B !== null)
          throw Error(t(401));
      } else {
        if (B === null)
          throw Error(t(401));
        Me(g, B);
      }
      D.context._currentValue2 = D.value;
    }
  }
  function tt(g) {
    g.context._currentValue2 = g.parentValue, g = g.parent, g !== null && tt(g);
  }
  function Ze(g) {
    var D = g.parent;
    D !== null && Ze(D), g.context._currentValue2 = g.value;
  }
  function et(g, D) {
    if (g.context._currentValue2 = g.parentValue, g = g.parent, g === null)
      throw Error(t(402));
    g.depth === D.depth ? Me(g, D) : et(g, D);
  }
  function at(g, D) {
    var B = D.parent;
    if (B === null)
      throw Error(t(402));
    g.depth === B.depth ? Me(g, B) : at(g, B), D.context._currentValue2 = D.value;
  }
  function gt(g) {
    var D = Ie;
    D !== g && (D === null ? Ze(g) : g === null ? tt(D) : D.depth === g.depth ? Me(D, g) : D.depth > g.depth ? et(D, g) : at(D, g), Ie = g);
  }
  var Ot = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(g, D) {
    g = g._reactInternals, g.queue !== null && g.queue.push(D);
  }, enqueueReplaceState: function(g, D) {
    g = g._reactInternals, g.replace = !0, g.queue = [D];
  }, enqueueForceUpdate: function() {
  } };
  function Kt(g, D, B, Z) {
    var Se = g.state !== void 0 ? g.state : null;
    g.updater = Ot, g.props = B, g.state = Se;
    var ve = { queue: [], replace: !1 };
    g._reactInternals = ve;
    var De = D.contextType;
    if (g.context = typeof De == "object" && De !== null ? De._currentValue2 : Z, De = D.getDerivedStateFromProps, typeof De == "function" && (De = De(B, Se), Se = De == null ? Se : X({}, Se, De), g.state = Se), typeof D.getDerivedStateFromProps != "function" && typeof g.getSnapshotBeforeUpdate != "function" && (typeof g.UNSAFE_componentWillMount == "function" || typeof g.componentWillMount == "function"))
      if (D = g.state, typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(), D !== g.state && Ot.enqueueReplaceState(g, g.state, null), ve.queue !== null && 0 < ve.queue.length)
        if (D = ve.queue, De = ve.replace, ve.queue = null, ve.replace = !1, De && D.length === 1)
          g.state = D[0];
        else {
          for (ve = De ? D[0] : g.state, Se = !0, De = De ? 1 : 0; De < D.length; De++) {
            var Xe = D[De];
            Xe = typeof Xe == "function" ? Xe.call(g, ve, B, Z) : Xe, Xe != null && (Se ? (Se = !1, ve = X({}, ve, Xe)) : X(ve, Xe));
          }
          g.state = ve;
        }
      else
        ve.queue = null;
  }
  var on = { id: 1, overflow: "" };
  function Wt(g, D, B) {
    var Z = g.id;
    g = g.overflow;
    var Se = 32 - Zt(Z) - 1;
    Z &= ~(1 << Se), B += 1;
    var ve = 32 - Zt(D) + Se;
    if (30 < ve) {
      var De = Se - Se % 5;
      return ve = (Z & (1 << De) - 1).toString(32), Z >>= De, Se -= De, { id: 1 << 32 - Zt(D) + Se | B << Se | Z, overflow: ve + g };
    }
    return { id: 1 << ve | B << Se | Z, overflow: g };
  }
  var Zt = Math.clz32 ? Math.clz32 : Yt, zt = Math.log, fn = Math.LN2;
  function Yt(g) {
    return g >>>= 0, g === 0 ? 32 : 31 - (zt(g) / fn | 0) | 0;
  }
  function tn(g, D) {
    return g === D && (g !== 0 || 1 / g === 1 / D) || g !== g && D !== D;
  }
  var kn = typeof Object.is == "function" ? Object.is : tn, ot = null, _e = null, $t = null, Lt = null, nn = !1, un = !1, At = 0, rn = null, ln = 0;
  function Ln() {
    if (ot === null)
      throw Error(t(321));
    return ot;
  }
  function qt() {
    if (0 < ln)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function mn() {
    return Lt === null ? $t === null ? (nn = !1, $t = Lt = qt()) : (nn = !0, Lt = $t) : Lt.next === null ? (nn = !1, Lt = Lt.next = qt()) : (nn = !0, Lt = Lt.next), Lt;
  }
  function Hn() {
    _e = ot = null, un = !1, $t = null, ln = 0, Lt = rn = null;
  }
  function Pn(g, D) {
    return typeof D == "function" ? D(g) : D;
  }
  function Vt(g, D, B) {
    if (ot = Ln(), Lt = mn(), nn) {
      var Z = Lt.queue;
      if (D = Z.dispatch, rn !== null && (B = rn.get(Z), B !== void 0)) {
        rn.delete(Z), Z = Lt.memoizedState;
        do
          Z = g(Z, B.action), B = B.next;
        while (B !== null);
        return Lt.memoizedState = Z, [Z, D];
      }
      return [Lt.memoizedState, D];
    }
    return g = g === Pn ? typeof D == "function" ? D() : D : B !== void 0 ? B(D) : D, Lt.memoizedState = g, g = Lt.queue = { last: null, dispatch: null }, g = g.dispatch = tr.bind(null, ot, g), [Lt.memoizedState, g];
  }
  function wn(g, D) {
    if (ot = Ln(), Lt = mn(), D = D === void 0 ? null : D, Lt !== null) {
      var B = Lt.memoizedState;
      if (B !== null && D !== null) {
        var Z = B[1];
        e:
          if (Z === null)
            Z = !1;
          else {
            for (var Se = 0; Se < Z.length && Se < D.length; Se++)
              if (!kn(D[Se], Z[Se])) {
                Z = !1;
                break e;
              }
            Z = !0;
          }
        if (Z)
          return B[0];
      }
    }
    return g = g(), Lt.memoizedState = [g, D], g;
  }
  function tr(g, D, B) {
    if (25 <= ln)
      throw Error(t(301));
    if (g === ot)
      if (un = !0, g = { action: B, next: null }, rn === null && (rn = /* @__PURE__ */ new Map()), B = rn.get(D), B === void 0)
        rn.set(D, g);
      else {
        for (D = B; D.next !== null; )
          D = D.next;
        D.next = g;
      }
  }
  function nr() {
    throw Error(t(394));
  }
  function En() {
  }
  var Tn = { readContext: function(g) {
    return g._currentValue2;
  }, useContext: function(g) {
    return Ln(), g._currentValue2;
  }, useMemo: wn, useReducer: Vt, useRef: function(g) {
    ot = Ln(), Lt = mn();
    var D = Lt.memoizedState;
    return D === null ? (g = { current: g }, Lt.memoizedState = g) : D;
  }, useState: function(g) {
    return Vt(Pn, g);
  }, useInsertionEffect: En, useLayoutEffect: function() {
  }, useCallback: function(g, D) {
    return wn(function() {
      return g;
    }, D);
  }, useImperativeHandle: En, useEffect: En, useDebugValue: En, useDeferredValue: function(g) {
    return Ln(), g;
  }, useTransition: function() {
    return Ln(), [
      !1,
      nr
    ];
  }, useId: function() {
    var g = _e.treeContext, D = g.overflow;
    g = g.id, g = (g & ~(1 << 32 - Zt(g) - 1)).toString(32) + D;
    var B = Mn;
    if (B === null)
      throw Error(t(404));
    return D = At++, g = ":" + B.idPrefix + "R" + g, 0 < D && (g += "H" + D.toString(32)), g + ":";
  }, useMutableSource: function(g, D) {
    return Ln(), D(g._source);
  }, useSyncExternalStore: function(g, D, B) {
    if (B === void 0)
      throw Error(t(407));
    return B();
  } }, Mn = null, Kn = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function zn(g) {
    return console.error(g), null;
  }
  function Rn() {
  }
  function Wn(g, D, B, Z, Se, ve, De, Xe, ut) {
    var vt = [], pt = /* @__PURE__ */ new Set();
    return D = { destination: null, responseState: D, progressiveChunkSize: Z === void 0 ? 12800 : Z, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: pt, pingedTasks: vt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Se === void 0 ? zn : Se, onAllReady: ve === void 0 ? Rn : ve, onShellReady: De === void 0 ? Rn : De, onShellError: Xe === void 0 ? Rn : Xe, onFatalError: ut === void 0 ? Rn : ut }, B = Ae(D, 0, null, B, !1, !1), B.parentFlushed = !0, g = F(D, g, null, B, pt, Qe, null, on), vt.push(g), D;
  }
  function F(g, D, B, Z, Se, ve, De, Xe) {
    g.allPendingTasks++, B === null ? g.pendingRootTasks++ : B.pendingTasks++;
    var ut = { node: D, ping: function() {
      var vt = g.pingedTasks;
      vt.push(ut), vt.length === 1 && Ft(g);
    }, blockedBoundary: B, blockedSegment: Z, abortSet: Se, legacyContext: ve, context: De, treeContext: Xe };
    return Se.add(ut), ut;
  }
  function Ae(g, D, B, Z, Se, ve) {
    return { status: 0, id: -1, index: D, parentFlushed: !1, chunks: [], children: [], formatContext: Z, boundary: B, lastPushedText: Se, textEmbedded: ve };
  }
  function ze(g, D) {
    if (g = g.onError(D), g != null && typeof g != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof g + '" instead');
    return g;
  }
  function xe(g, D) {
    var B = g.onShellError;
    B(D), B = g.onFatalError, B(D), g.destination !== null ? (g.status = 2, g.destination.destroy(D)) : (g.status = 1, g.fatalError = D);
  }
  function lt(g, D, B, Z, Se) {
    for (ot = {}, _e = D, At = 0, g = B(Z, Se); un; )
      un = !1, At = 0, ln += 1, Lt = null, g = B(Z, Se);
    return Hn(), g;
  }
  function nt(g, D, B, Z) {
    var Se = B.render(), ve = Z.childContextTypes;
    if (ve != null) {
      var De = D.legacyContext;
      if (typeof B.getChildContext != "function")
        Z = De;
      else {
        B = B.getChildContext();
        for (var Xe in B)
          if (!(Xe in ve))
            throw Error(t(108, ft(Z) || "Unknown", Xe));
        Z = X({}, De, B);
      }
      D.legacyContext = Z, je(g, D, Se), D.legacyContext = De;
    } else
      je(g, D, Se);
  }
  function mt(g, D) {
    if (g && g.defaultProps) {
      D = X({}, D), g = g.defaultProps;
      for (var B in g)
        D[B] === void 0 && (D[B] = g[B]);
      return D;
    }
    return D;
  }
  function ht(g, D, B, Z, Se) {
    if (typeof B == "function")
      if (B.prototype && B.prototype.isReactComponent) {
        Se = We(B, D.legacyContext);
        var ve = B.contextType;
        ve = new B(Z, typeof ve == "object" && ve !== null ? ve._currentValue2 : Se), Kt(ve, B, Z, Se), nt(g, D, ve, B);
      } else {
        ve = We(B, D.legacyContext), Se = lt(g, D, B, Z, ve);
        var De = At !== 0;
        if (typeof Se == "object" && Se !== null && typeof Se.render == "function" && Se.$$typeof === void 0)
          Kt(Se, B, Z, ve), nt(g, D, Se, B);
        else if (De) {
          Z = D.treeContext, D.treeContext = Wt(Z, 1, 0);
          try {
            je(g, D, Se);
          } finally {
            D.treeContext = Z;
          }
        } else
          je(g, D, Se);
      }
    else if (typeof B == "string") {
      switch (Se = D.blockedSegment, ve = Q(Se.chunks, B, Z, g.responseState, Se.formatContext), Se.lastPushedText = !1, De = Se.formatContext, Se.formatContext = _(De, B, Z), Tt(g, D, ve), Se.formatContext = De, B) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Se.chunks.push("</", B, ">");
      }
      Se.lastPushedText = !1;
    } else {
      switch (B) {
        case Ve:
        case $e:
        case ce:
        case Re:
        case be:
          je(g, D, Z.children);
          return;
        case Oe:
          je(g, D, Z.children);
          return;
        case Ce:
          throw Error(t(343));
        case ye:
          e: {
            B = D.blockedBoundary, Se = D.blockedSegment, ve = Z.fallback, Z = Z.children, De = /* @__PURE__ */ new Set();
            var Xe = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: De, errorDigest: null }, ut = Ae(g, Se.chunks.length, Xe, Se.formatContext, !1, !1);
            Se.children.push(ut), Se.lastPushedText = !1;
            var vt = Ae(g, 0, null, Se.formatContext, !1, !1);
            vt.parentFlushed = !0, D.blockedBoundary = Xe, D.blockedSegment = vt;
            try {
              if (Tt(
                g,
                D,
                Z
              ), g.responseState.generateStaticMarkup || vt.lastPushedText && vt.textEmbedded && vt.chunks.push("<!-- -->"), vt.status = 1, wt(Xe, vt), Xe.pendingTasks === 0)
                break e;
            } catch (pt) {
              vt.status = 4, Xe.forceClientRender = !0, Xe.errorDigest = ze(g, pt);
            } finally {
              D.blockedBoundary = B, D.blockedSegment = Se;
            }
            D = F(g, ve, B, ut, De, D.legacyContext, D.context, D.treeContext), g.pingedTasks.push(D);
          }
          return;
      }
      if (typeof B == "object" && B !== null)
        switch (B.$$typeof) {
          case Ne:
            if (Z = lt(g, D, B.render, Z, Se), At !== 0) {
              B = D.treeContext, D.treeContext = Wt(B, 1, 0);
              try {
                je(g, D, Z);
              } finally {
                D.treeContext = B;
              }
            } else
              je(g, D, Z);
            return;
          case ue:
            B = B.type, Z = mt(B, Z), ht(g, D, B, Z, Se);
            return;
          case He:
            if (Se = Z.children, B = B._context, Z = Z.value, ve = B._currentValue2, B._currentValue2 = Z, De = Ie, Ie = Z = { parent: De, depth: De === null ? 0 : De.depth + 1, context: B, parentValue: ve, value: Z }, D.context = Z, je(g, D, Se), g = Ie, g === null)
              throw Error(t(403));
            Z = g.parentValue, g.context._currentValue2 = Z === Ee ? g.context._defaultValue : Z, g = Ie = g.parent, D.context = g;
            return;
          case Ge:
            Z = Z.children, Z = Z(B._currentValue2), je(g, D, Z);
            return;
          case ie:
            Se = B._init, B = Se(B._payload), Z = mt(B, Z), ht(
              g,
              D,
              B,
              Z,
              void 0
            );
            return;
        }
      throw Error(t(130, B == null ? B : typeof B, ""));
    }
  }
  function je(g, D, B) {
    if (D.node = B, typeof B == "object" && B !== null) {
      switch (B.$$typeof) {
        case H:
          ht(g, D, B.type, B.props, B.ref);
          return;
        case Te:
          throw Error(t(257));
        case ie:
          var Z = B._init;
          B = Z(B._payload), je(g, D, B);
          return;
      }
      if (p(B)) {
        yt(g, D, B);
        return;
      }
      if (B === null || typeof B != "object" ? Z = null : (Z = Ue && B[Ue] || B["@@iterator"], Z = typeof Z == "function" ? Z : null), Z && (Z = Z.call(B))) {
        if (B = Z.next(), !B.done) {
          var Se = [];
          do
            Se.push(B.value), B = Z.next();
          while (!B.done);
          yt(g, D, Se);
        }
        return;
      }
      throw g = Object.prototype.toString.call(B), Error(t(31, g === "[object Object]" ? "object with keys {" + Object.keys(B).join(", ") + "}" : g));
    }
    typeof B == "string" ? (Z = D.blockedSegment, Z.lastPushedText = U(D.blockedSegment.chunks, B, g.responseState, Z.lastPushedText)) : typeof B == "number" && (Z = D.blockedSegment, Z.lastPushedText = U(D.blockedSegment.chunks, "" + B, g.responseState, Z.lastPushedText));
  }
  function yt(g, D, B) {
    for (var Z = B.length, Se = 0; Se < Z; Se++) {
      var ve = D.treeContext;
      D.treeContext = Wt(ve, Z, Se);
      try {
        Tt(g, D, B[Se]);
      } finally {
        D.treeContext = ve;
      }
    }
  }
  function Tt(g, D, B) {
    var Z = D.blockedSegment.formatContext, Se = D.legacyContext, ve = D.context;
    try {
      return je(g, D, B);
    } catch (ut) {
      if (Hn(), typeof ut == "object" && ut !== null && typeof ut.then == "function") {
        B = ut;
        var De = D.blockedSegment, Xe = Ae(g, De.chunks.length, null, De.formatContext, De.lastPushedText, !0);
        De.children.push(Xe), De.lastPushedText = !1, g = F(g, D.node, D.blockedBoundary, Xe, D.abortSet, D.legacyContext, D.context, D.treeContext).ping, B.then(g, g), D.blockedSegment.formatContext = Z, D.legacyContext = Se, D.context = ve, gt(ve);
      } else
        throw D.blockedSegment.formatContext = Z, D.legacyContext = Se, D.context = ve, gt(ve), ut;
    }
  }
  function Rt(g) {
    var D = g.blockedBoundary;
    g = g.blockedSegment, g.status = 3, kt(this, D, g);
  }
  function jt(g, D, B) {
    var Z = g.blockedBoundary;
    g.blockedSegment.status = 3, Z === null ? (D.allPendingTasks--, D.status !== 2 && (D.status = 2, D.destination !== null && D.destination.push(null))) : (Z.pendingTasks--, Z.forceClientRender || (Z.forceClientRender = !0, g = B === void 0 ? Error(t(432)) : B, Z.errorDigest = D.onError(g), Z.parentFlushed && D.clientRenderedBoundaries.push(Z)), Z.fallbackAbortableTasks.forEach(function(Se) {
      return jt(Se, D, B);
    }), Z.fallbackAbortableTasks.clear(), D.allPendingTasks--, D.allPendingTasks === 0 && (Z = D.onAllReady, Z()));
  }
  function wt(g, D) {
    if (D.chunks.length === 0 && D.children.length === 1 && D.children[0].boundary === null) {
      var B = D.children[0];
      B.id = D.id, B.parentFlushed = !0, B.status === 1 && wt(g, B);
    } else
      g.completedSegments.push(D);
  }
  function kt(g, D, B) {
    if (D === null) {
      if (B.parentFlushed) {
        if (g.completedRootSegment !== null)
          throw Error(t(389));
        g.completedRootSegment = B;
      }
      g.pendingRootTasks--, g.pendingRootTasks === 0 && (g.onShellError = Rn, D = g.onShellReady, D());
    } else
      D.pendingTasks--, D.forceClientRender || (D.pendingTasks === 0 ? (B.parentFlushed && B.status === 1 && wt(D, B), D.parentFlushed && g.completedBoundaries.push(D), D.fallbackAbortableTasks.forEach(Rt, g), D.fallbackAbortableTasks.clear()) : B.parentFlushed && B.status === 1 && (wt(D, B), D.completedSegments.length === 1 && D.parentFlushed && g.partialBoundaries.push(D)));
    g.allPendingTasks--, g.allPendingTasks === 0 && (g = g.onAllReady, g());
  }
  function Ft(g) {
    if (g.status !== 2) {
      var D = Ie, B = Kn.current;
      Kn.current = Tn;
      var Z = Mn;
      Mn = g.responseState;
      try {
        var Se = g.pingedTasks, ve;
        for (ve = 0; ve < Se.length; ve++) {
          var De = Se[ve], Xe = g, ut = De.blockedSegment;
          if (ut.status === 0) {
            gt(De.context);
            try {
              je(Xe, De, De.node), Xe.responseState.generateStaticMarkup || ut.lastPushedText && ut.textEmbedded && ut.chunks.push("<!-- -->"), De.abortSet.delete(De), ut.status = 1, kt(Xe, De.blockedBoundary, ut);
            } catch (de) {
              if (Hn(), typeof de == "object" && de !== null && typeof de.then == "function") {
                var vt = De.ping;
                de.then(vt, vt);
              } else {
                De.abortSet.delete(De), ut.status = 4;
                var pt = De.blockedBoundary, Mt = de, Dn = ze(Xe, Mt);
                if (pt === null ? xe(Xe, Mt) : (pt.pendingTasks--, pt.forceClientRender || (pt.forceClientRender = !0, pt.errorDigest = Dn, pt.parentFlushed && Xe.clientRenderedBoundaries.push(pt))), Xe.allPendingTasks--, Xe.allPendingTasks === 0) {
                  var pe = Xe.onAllReady;
                  pe();
                }
              }
            } finally {
            }
          }
        }
        Se.splice(0, ve), g.destination !== null && yn(g, g.destination);
      } catch (de) {
        ze(g, de), xe(g, de);
      } finally {
        Mn = Z, Kn.current = B, B === Tn && gt(D);
      }
    }
  }
  function Ut(g, D, B) {
    switch (B.parentFlushed = !0, B.status) {
      case 0:
        var Z = B.id = g.nextSegmentId++;
        return B.lastPushedText = !1, B.textEmbedded = !1, g = g.responseState, D.push('<template id="'), D.push(g.placeholderPrefix), g = Z.toString(16), D.push(g), D.push('"></template>');
      case 1:
        B.status = 2;
        var Se = !0;
        Z = B.chunks;
        var ve = 0;
        B = B.children;
        for (var De = 0; De < B.length; De++) {
          for (Se = B[De]; ve < Se.index; ve++)
            D.push(Z[ve]);
          Se = Et(g, D, Se);
        }
        for (; ve < Z.length - 1; ve++)
          D.push(Z[ve]);
        return ve < Z.length && (Se = D.push(Z[ve])), Se;
      default:
        throw Error(t(390));
    }
  }
  function Et(g, D, B) {
    var Z = B.boundary;
    if (Z === null)
      return Ut(g, D, B);
    if (Z.parentFlushed = !0, Z.forceClientRender)
      return g.responseState.generateStaticMarkup || (Z = Z.errorDigest, D.push("<!--$!-->"), D.push("<template"), Z && (D.push(' data-dgst="'), Z = T(Z), D.push(Z), D.push('"')), D.push("></template>")), Ut(g, D, B), g = g.responseState.generateStaticMarkup ? !0 : D.push("<!--/$-->"), g;
    if (0 < Z.pendingTasks) {
      Z.rootSegmentID = g.nextSegmentId++, 0 < Z.completedSegments.length && g.partialBoundaries.push(Z);
      var Se = g.responseState, ve = Se.nextSuspenseID++;
      return Se = Se.boundaryPrefix + ve.toString(16), Z = Z.id = Se, j(D, g.responseState, Z), Ut(g, D, B), D.push("<!--/$-->");
    }
    if (Z.byteSize > g.progressiveChunkSize)
      return Z.rootSegmentID = g.nextSegmentId++, g.completedBoundaries.push(Z), j(D, g.responseState, Z.id), Ut(g, D, B), D.push("<!--/$-->");
    if (g.responseState.generateStaticMarkup || D.push("<!--$-->"), B = Z.completedSegments, B.length !== 1)
      throw Error(t(391));
    return Et(g, D, B[0]), g = g.responseState.generateStaticMarkup ? !0 : D.push("<!--/$-->"), g;
  }
  function xn(g, D, B) {
    return te(D, g.responseState, B.formatContext, B.id), Et(g, D, B), se(D, B.formatContext);
  }
  function pn(g, D, B) {
    for (var Z = B.completedSegments, Se = 0; Se < Z.length; Se++)
      sn(g, D, B, Z[Se]);
    if (Z.length = 0, g = g.responseState, Z = B.id, B = B.rootSegmentID, D.push(g.startInlineScript), g.sentCompleteBoundaryFunction ? D.push('$RC("') : (g.sentCompleteBoundaryFunction = !0, D.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), Z === null)
      throw Error(t(395));
    return B = B.toString(16), D.push(Z), D.push('","'), D.push(g.segmentPrefix), D.push(B), D.push('")<\/script>');
  }
  function sn(g, D, B, Z) {
    if (Z.status === 2)
      return !0;
    var Se = Z.id;
    if (Se === -1) {
      if ((Z.id = B.rootSegmentID) === -1)
        throw Error(t(392));
      return xn(g, D, Z);
    }
    return xn(g, D, Z), g = g.responseState, D.push(g.startInlineScript), g.sentCompleteSegmentFunction ? D.push('$RS("') : (g.sentCompleteSegmentFunction = !0, D.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), D.push(g.segmentPrefix), Se = Se.toString(16), D.push(Se), D.push('","'), D.push(g.placeholderPrefix), D.push(Se), D.push('")<\/script>');
  }
  function yn(g, D) {
    try {
      var B = g.completedRootSegment;
      if (B !== null && g.pendingRootTasks === 0) {
        Et(g, D, B), g.completedRootSegment = null;
        var Z = g.responseState.bootstrapChunks;
        for (B = 0; B < Z.length - 1; B++)
          D.push(Z[B]);
        B < Z.length && D.push(Z[B]);
      }
      var Se = g.clientRenderedBoundaries, ve;
      for (ve = 0; ve < Se.length; ve++) {
        var De = Se[ve];
        Z = D;
        var Xe = g.responseState, ut = De.id, vt = De.errorDigest, pt = De.errorMessage, Mt = De.errorComponentStack;
        if (Z.push(Xe.startInlineScript), Xe.sentClientRenderFunction ? Z.push('$RX("') : (Xe.sentClientRenderFunction = !0, Z.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), ut === null)
          throw Error(t(395));
        if (Z.push(ut), Z.push('"'), vt || pt || Mt) {
          Z.push(",");
          var Dn = ae(vt || "");
          Z.push(Dn);
        }
        if (pt || Mt) {
          Z.push(",");
          var pe = ae(pt || "");
          Z.push(pe);
        }
        if (Mt) {
          Z.push(",");
          var de = ae(Mt);
          Z.push(de);
        }
        if (!Z.push(")<\/script>")) {
          g.destination = null, ve++, Se.splice(0, ve);
          return;
        }
      }
      Se.splice(0, ve);
      var ge = g.completedBoundaries;
      for (ve = 0; ve < ge.length; ve++)
        if (!pn(g, D, ge[ve])) {
          g.destination = null, ve++, ge.splice(0, ve);
          return;
        }
      ge.splice(0, ve);
      var Fe = g.partialBoundaries;
      for (ve = 0; ve < Fe.length; ve++) {
        var Nt = Fe[ve];
        e: {
          Se = g, De = D;
          var bn = Nt.completedSegments;
          for (Xe = 0; Xe < bn.length; Xe++)
            if (!sn(Se, De, Nt, bn[Xe])) {
              Xe++, bn.splice(0, Xe);
              var jn = !1;
              break e;
            }
          bn.splice(0, Xe), jn = !0;
        }
        if (!jn) {
          g.destination = null, ve++, Fe.splice(0, ve);
          return;
        }
      }
      Fe.splice(0, ve);
      var Gn = g.completedBoundaries;
      for (ve = 0; ve < Gn.length; ve++)
        if (!pn(g, D, Gn[ve])) {
          g.destination = null, ve++, Gn.splice(0, ve);
          return;
        }
      Gn.splice(0, ve);
    } finally {
      g.allPendingTasks === 0 && g.pingedTasks.length === 0 && g.clientRenderedBoundaries.length === 0 && g.completedBoundaries.length === 0 && D.push(null);
    }
  }
  function Qt(g, D) {
    try {
      var B = g.abortableTasks;
      B.forEach(function(Z) {
        return jt(Z, g, D);
      }), B.clear(), g.destination !== null && yn(g, g.destination);
    } catch (Z) {
      ze(g, Z), xe(g, Z);
    }
  }
  function gn() {
  }
  function Vn(g, D, B, Z) {
    var Se = !1, ve = null, De = "", Xe = { push: function(vt) {
      return vt !== null && (De += vt), !0;
    }, destroy: function(vt) {
      Se = !0, ve = vt;
    } }, ut = !1;
    if (g = Wn(g, K(B, D ? D.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, gn, void 0, function() {
      ut = !0;
    }, void 0, void 0), Ft(g), Qt(g, Z), g.status === 1)
      g.status = 2, Xe.destroy(g.fatalError);
    else if (g.status !== 2 && g.destination === null) {
      g.destination = Xe;
      try {
        yn(g, Xe);
      } catch (vt) {
        ze(g, vt), xe(g, vt);
      }
    }
    if (Se)
      throw ve;
    if (!ut)
      throw Error(t(426));
    return De;
  }
  return Pi.renderToNodeStream = function() {
    throw Error(t(207));
  }, Pi.renderToStaticMarkup = function(g, D) {
    return Vn(g, D, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Pi.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, Pi.renderToString = function(g, D) {
    return Vn(g, D, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Pi.version = "18.2.0", Pi;
}
var Fu = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jh;
function sE() {
  if (jh)
    return Fu;
  jh = 1;
  var e = le;
  function t(b) {
    for (var N = "https://reactjs.org/docs/error-decoder.html?invariant=" + b, I = 1; I < arguments.length; I++)
      N += "&args[]=" + encodeURIComponent(arguments[I]);
    return "Minified React error #" + b + "; visit " + N + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = null, a = 0;
  function i(b, N) {
    if (N.length !== 0)
      if (512 < N.length)
        0 < a && (b.enqueue(new Uint8Array(n.buffer, 0, a)), n = new Uint8Array(512), a = 0), b.enqueue(N);
      else {
        var I = n.length - a;
        I < N.length && (I === 0 ? b.enqueue(n) : (n.set(N.subarray(0, I), a), b.enqueue(n), N = N.subarray(I)), n = new Uint8Array(512), a = 0), n.set(N, a), a += N.length;
      }
  }
  function l(b, N) {
    return i(b, N), !0;
  }
  function c(b) {
    n && 0 < a && (b.enqueue(new Uint8Array(n.buffer, 0, a)), n = null, a = 0);
  }
  var f = new TextEncoder();
  function u(b) {
    return f.encode(b);
  }
  function m(b) {
    return f.encode(b);
  }
  function y(b, N) {
    typeof b.error == "function" ? b.error(N) : b.close();
  }
  var v = Object.prototype.hasOwnProperty, x = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, A = {}, T = {};
  function M(b) {
    return v.call(T, b) ? !0 : v.call(A, b) ? !1 : x.test(b) ? T[b] = !0 : (A[b] = !0, !1);
  }
  function E(b, N, I, J, we, ke, Be) {
    this.acceptsBooleans = N === 2 || N === 3 || N === 4, this.attributeName = J, this.attributeNamespace = we, this.mustUseProperty = I, this.propertyName = b, this.type = N, this.sanitizeURL = ke, this.removeEmptyString = Be;
  }
  var p = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(b) {
    p[b] = new E(b, 0, !1, b, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(b) {
    var N = b[0];
    p[N] = new E(N, 1, !1, b[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(b) {
    p[b] = new E(b, 2, !1, b.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(b) {
    p[b] = new E(b, 2, !1, b, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(b) {
    p[b] = new E(b, 3, !1, b.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(b) {
    p[b] = new E(b, 3, !0, b, null, !1, !1);
  }), ["capture", "download"].forEach(function(b) {
    p[b] = new E(b, 4, !1, b, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(b) {
    p[b] = new E(b, 6, !1, b, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(b) {
    p[b] = new E(b, 5, !1, b.toLowerCase(), null, !1, !1);
  });
  var C = /[\-:]([a-z])/g;
  function _(b) {
    return b[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(b) {
    var N = b.replace(
      C,
      _
    );
    p[N] = new E(N, 1, !1, b, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(b) {
    var N = b.replace(C, _);
    p[N] = new E(N, 1, !1, b, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(b) {
    var N = b.replace(C, _);
    p[N] = new E(N, 1, !1, b, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(b) {
    p[b] = new E(b, 1, !1, b.toLowerCase(), null, !1, !1);
  }), p.xlinkHref = new E("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(b) {
    p[b] = new E(b, 1, !1, b.toLowerCase(), null, !0, !0);
  });
  var w = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, R = ["Webkit", "ms", "Moz", "O"];
  Object.keys(w).forEach(function(b) {
    R.forEach(function(N) {
      N = N + b.charAt(0).toUpperCase() + b.substring(1), w[N] = w[b];
    });
  });
  var P = /["'&<>]/;
  function z(b) {
    if (typeof b == "boolean" || typeof b == "number")
      return "" + b;
    b = "" + b;
    var N = P.exec(b);
    if (N) {
      var I = "", J, we = 0;
      for (J = N.index; J < b.length; J++) {
        switch (b.charCodeAt(J)) {
          case 34:
            N = "&quot;";
            break;
          case 38:
            N = "&amp;";
            break;
          case 39:
            N = "&#x27;";
            break;
          case 60:
            N = "&lt;";
            break;
          case 62:
            N = "&gt;";
            break;
          default:
            continue;
        }
        we !== J && (I += b.substring(we, J)), we = J + 1, I += N;
      }
      b = we !== J ? I + b.substring(we, J) : I;
    }
    return b;
  }
  var q = /([A-Z])/g, V = /^ms-/, G = Array.isArray, ee = m("<script>"), W = m("<\/script>"), Q = m('<script src="'), j = m('<script type="module" src="'), te = m('" async=""><\/script>'), se = /(<\/|<)(s)(cript)/gi;
  function re(b, N, I, J) {
    return "" + N + (I === "s" ? "\\u0073" : "\\u0053") + J;
  }
  function ae(b, N, I, J, we) {
    b = b === void 0 ? "" : b, N = N === void 0 ? ee : m('<script nonce="' + z(N) + '">');
    var ke = [];
    if (I !== void 0 && ke.push(N, u(("" + I).replace(se, re)), W), J !== void 0)
      for (I = 0; I < J.length; I++)
        ke.push(Q, u(z(J[I])), te);
    if (we !== void 0)
      for (J = 0; J < we.length; J++)
        ke.push(j, u(z(we[J])), te);
    return { bootstrapChunks: ke, startInlineScript: N, placeholderPrefix: m(b + "P:"), segmentPrefix: m(b + "S:"), boundaryPrefix: b + "B:", idPrefix: b, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function K(b, N) {
    return { insertionMode: b, selectedValue: N };
  }
  function U(b) {
    return K(b === "http://www.w3.org/2000/svg" ? 2 : b === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function X(b, N, I) {
    switch (N) {
      case "select":
        return K(1, I.value != null ? I.value : I.defaultValue);
      case "svg":
        return K(2, null);
      case "math":
        return K(3, null);
      case "foreignObject":
        return K(1, null);
      case "table":
        return K(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return K(5, null);
      case "colgroup":
        return K(7, null);
      case "tr":
        return K(6, null);
    }
    return 4 <= b.insertionMode || b.insertionMode === 0 ? K(1, null) : b;
  }
  var H = m("<!-- -->");
  function Te(b, N, I, J) {
    return N === "" ? J : (J && b.push(H), b.push(u(z(N))), !0);
  }
  var be = /* @__PURE__ */ new Map(), ce = m(' style="'), Re = m(":"), He = m(";");
  function Ge(b, N, I) {
    if (typeof I != "object")
      throw Error(t(62));
    N = !0;
    for (var J in I)
      if (v.call(I, J)) {
        var we = I[J];
        if (we != null && typeof we != "boolean" && we !== "") {
          if (J.indexOf("--") === 0) {
            var ke = u(z(J));
            we = u(z(("" + we).trim()));
          } else {
            ke = J;
            var Be = be.get(ke);
            Be !== void 0 || (Be = m(z(ke.replace(q, "-$1").toLowerCase().replace(V, "-ms-"))), be.set(ke, Be)), ke = Be, we = typeof we == "number" ? we === 0 || v.call(w, J) ? u("" + we) : u(we + "px") : u(z(("" + we).trim()));
          }
          N ? (N = !1, b.push(ce, ke, Re, we)) : b.push(He, ke, Re, we);
        }
      }
    N || b.push(Oe);
  }
  var Ne = m(" "), ye = m('="'), Oe = m('"'), ue = m('=""');
  function ie(b, N, I, J) {
    switch (I) {
      case "style":
        Ge(b, N, J);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < I.length) || I[0] !== "o" && I[0] !== "O" || I[1] !== "n" && I[1] !== "N") {
      if (N = p.hasOwnProperty(I) ? p[I] : null, N !== null) {
        switch (typeof J) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!N.acceptsBooleans)
              return;
        }
        switch (I = u(N.attributeName), N.type) {
          case 3:
            J && b.push(Ne, I, ue);
            break;
          case 4:
            J === !0 ? b.push(Ne, I, ue) : J !== !1 && b.push(Ne, I, ye, u(z(J)), Oe);
            break;
          case 5:
            isNaN(J) || b.push(Ne, I, ye, u(z(J)), Oe);
            break;
          case 6:
            !isNaN(J) && 1 <= J && b.push(Ne, I, ye, u(z(J)), Oe);
            break;
          default:
            N.sanitizeURL && (J = "" + J), b.push(Ne, I, ye, u(z(J)), Oe);
        }
      } else if (M(I)) {
        switch (typeof J) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (N = I.toLowerCase().slice(0, 5), N !== "data-" && N !== "aria-")
              return;
        }
        b.push(Ne, u(I), ye, u(z(J)), Oe);
      }
    }
  }
  var Ce = m(">"), $e = m("/>");
  function Ve(b, N, I) {
    if (N != null) {
      if (I != null)
        throw Error(t(60));
      if (typeof N != "object" || !("__html" in N))
        throw Error(t(61));
      N = N.__html, N != null && b.push(u("" + N));
    }
  }
  function Ee(b) {
    var N = "";
    return e.Children.forEach(b, function(I) {
      I != null && (N += I);
    }), N;
  }
  var Ue = m(' selected=""');
  function ft(b, N, I, J) {
    b.push(Me(I));
    var we = I = null, ke;
    for (ke in N)
      if (v.call(N, ke)) {
        var Be = N[ke];
        if (Be != null)
          switch (ke) {
            case "children":
              I = Be;
              break;
            case "dangerouslySetInnerHTML":
              we = Be;
              break;
            default:
              ie(b, J, ke, Be);
          }
      }
    return b.push(Ce), Ve(b, we, I), typeof I == "string" ? (b.push(u(z(I))), null) : I;
  }
  var Qe = m(`
`), We = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Ie = /* @__PURE__ */ new Map();
  function Me(b) {
    var N = Ie.get(b);
    if (N === void 0) {
      if (!We.test(b))
        throw Error(t(65, b));
      N = m("<" + b), Ie.set(b, N);
    }
    return N;
  }
  var tt = m("<!DOCTYPE html>");
  function Ze(b, N, I, J, we) {
    switch (N) {
      case "select":
        b.push(Me("select"));
        var ke = null, Be = null;
        for (Dt in I)
          if (v.call(I, Dt)) {
            var qe = I[Dt];
            if (qe != null)
              switch (Dt) {
                case "children":
                  ke = qe;
                  break;
                case "dangerouslySetInnerHTML":
                  Be = qe;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  ie(b, J, Dt, qe);
              }
          }
        return b.push(Ce), Ve(b, Be, ke), ke;
      case "option":
        Be = we.selectedValue, b.push(Me("option"));
        var St = qe = null, _t = null, Dt = null;
        for (ke in I)
          if (v.call(I, ke)) {
            var an = I[ke];
            if (an != null)
              switch (ke) {
                case "children":
                  qe = an;
                  break;
                case "selected":
                  _t = an;
                  break;
                case "dangerouslySetInnerHTML":
                  Dt = an;
                  break;
                case "value":
                  St = an;
                default:
                  ie(b, J, ke, an);
              }
          }
        if (Be != null)
          if (I = St !== null ? "" + St : Ee(qe), G(Be)) {
            for (J = 0; J < Be.length; J++)
              if ("" + Be[J] === I) {
                b.push(Ue);
                break;
              }
          } else
            "" + Be === I && b.push(Ue);
        else
          _t && b.push(Ue);
        return b.push(Ce), Ve(b, Dt, qe), qe;
      case "textarea":
        b.push(Me("textarea")), Dt = Be = ke = null;
        for (qe in I)
          if (v.call(I, qe) && (St = I[qe], St != null))
            switch (qe) {
              case "children":
                Dt = St;
                break;
              case "value":
                ke = St;
                break;
              case "defaultValue":
                Be = St;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                ie(b, J, qe, St);
            }
        if (ke === null && Be !== null && (ke = Be), b.push(Ce), Dt != null) {
          if (ke != null)
            throw Error(t(92));
          if (G(Dt) && 1 < Dt.length)
            throw Error(t(93));
          ke = "" + Dt;
        }
        return typeof ke == "string" && ke[0] === `
` && b.push(Qe), ke !== null && b.push(u(z("" + ke))), null;
      case "input":
        b.push(Me("input")), St = Dt = qe = ke = null;
        for (Be in I)
          if (v.call(I, Be) && (_t = I[Be], _t != null))
            switch (Be) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                St = _t;
                break;
              case "defaultValue":
                qe = _t;
                break;
              case "checked":
                Dt = _t;
                break;
              case "value":
                ke = _t;
                break;
              default:
                ie(b, J, Be, _t);
            }
        return Dt !== null ? ie(
          b,
          J,
          "checked",
          Dt
        ) : St !== null && ie(b, J, "checked", St), ke !== null ? ie(b, J, "value", ke) : qe !== null && ie(b, J, "value", qe), b.push($e), null;
      case "menuitem":
        b.push(Me("menuitem"));
        for (var qn in I)
          if (v.call(I, qn) && (ke = I[qn], ke != null))
            switch (qn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                ie(b, J, qn, ke);
            }
        return b.push(Ce), null;
      case "title":
        b.push(Me("title")), ke = null;
        for (an in I)
          if (v.call(I, an) && (Be = I[an], Be != null))
            switch (an) {
              case "children":
                ke = Be;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                ie(b, J, an, Be);
            }
        return b.push(Ce), ke;
      case "listing":
      case "pre":
        b.push(Me(N)), Be = ke = null;
        for (St in I)
          if (v.call(I, St) && (qe = I[St], qe != null))
            switch (St) {
              case "children":
                ke = qe;
                break;
              case "dangerouslySetInnerHTML":
                Be = qe;
                break;
              default:
                ie(b, J, St, qe);
            }
        if (b.push(Ce), Be != null) {
          if (ke != null)
            throw Error(t(60));
          if (typeof Be != "object" || !("__html" in Be))
            throw Error(t(61));
          I = Be.__html, I != null && (typeof I == "string" && 0 < I.length && I[0] === `
` ? b.push(Qe, u(I)) : b.push(u("" + I)));
        }
        return typeof ke == "string" && ke[0] === `
` && b.push(Qe), ke;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        b.push(Me(N));
        for (var ir in I)
          if (v.call(I, ir) && (ke = I[ir], ke != null))
            switch (ir) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, N));
              default:
                ie(b, J, ir, ke);
            }
        return b.push($e), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return ft(b, I, N, J);
      case "html":
        return we.insertionMode === 0 && b.push(tt), ft(b, I, N, J);
      default:
        if (N.indexOf("-") === -1 && typeof I.is != "string")
          return ft(b, I, N, J);
        b.push(Me(N)), Be = ke = null;
        for (_t in I)
          if (v.call(I, _t) && (qe = I[_t], qe != null))
            switch (_t) {
              case "children":
                ke = qe;
                break;
              case "dangerouslySetInnerHTML":
                Be = qe;
                break;
              case "style":
                Ge(b, J, qe);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                M(_t) && typeof qe != "function" && typeof qe != "symbol" && b.push(Ne, u(_t), ye, u(z(qe)), Oe);
            }
        return b.push(Ce), Ve(b, Be, ke), ke;
    }
  }
  var et = m("</"), at = m(">"), gt = m('<template id="'), Ot = m('"></template>'), Kt = m("<!--$-->"), on = m('<!--$?--><template id="'), Wt = m('"></template>'), Zt = m("<!--$!-->"), zt = m("<!--/$-->"), fn = m("<template"), Yt = m('"'), tn = m(' data-dgst="');
  m(' data-msg="'), m(' data-stck="');
  var kn = m("></template>");
  function ot(b, N, I) {
    if (i(b, on), I === null)
      throw Error(t(395));
    return i(b, I), l(b, Wt);
  }
  var _e = m('<div hidden id="'), $t = m('">'), Lt = m("</div>"), nn = m('<svg aria-hidden="true" style="display:none" id="'), un = m('">'), At = m("</svg>"), rn = m('<math aria-hidden="true" style="display:none" id="'), ln = m('">'), Ln = m("</math>"), qt = m('<table hidden id="'), mn = m('">'), Hn = m("</table>"), Pn = m('<table hidden><tbody id="'), Vt = m('">'), wn = m("</tbody></table>"), tr = m('<table hidden><tr id="'), nr = m('">'), En = m("</tr></table>"), Tn = m('<table hidden><colgroup id="'), Mn = m('">'), Kn = m("</colgroup></table>");
  function zn(b, N, I, J) {
    switch (I.insertionMode) {
      case 0:
      case 1:
        return i(b, _e), i(b, N.segmentPrefix), i(b, u(J.toString(16))), l(b, $t);
      case 2:
        return i(b, nn), i(b, N.segmentPrefix), i(b, u(J.toString(16))), l(b, un);
      case 3:
        return i(b, rn), i(b, N.segmentPrefix), i(b, u(J.toString(16))), l(b, ln);
      case 4:
        return i(b, qt), i(b, N.segmentPrefix), i(b, u(J.toString(16))), l(b, mn);
      case 5:
        return i(b, Pn), i(b, N.segmentPrefix), i(b, u(J.toString(16))), l(b, Vt);
      case 6:
        return i(b, tr), i(b, N.segmentPrefix), i(b, u(J.toString(16))), l(b, nr);
      case 7:
        return i(
          b,
          Tn
        ), i(b, N.segmentPrefix), i(b, u(J.toString(16))), l(b, Mn);
      default:
        throw Error(t(397));
    }
  }
  function Rn(b, N) {
    switch (N.insertionMode) {
      case 0:
      case 1:
        return l(b, Lt);
      case 2:
        return l(b, At);
      case 3:
        return l(b, Ln);
      case 4:
        return l(b, Hn);
      case 5:
        return l(b, wn);
      case 6:
        return l(b, En);
      case 7:
        return l(b, Kn);
      default:
        throw Error(t(397));
    }
  }
  var Wn = m('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), F = m('$RS("'), Ae = m('","'), ze = m('")<\/script>'), xe = m('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), lt = m('$RC("'), nt = m('","'), mt = m('")<\/script>'), ht = m('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), je = m('$RX("'), yt = m('"'), Tt = m(")<\/script>"), Rt = m(","), jt = /[<\u2028\u2029]/g;
  function wt(b) {
    return JSON.stringify(b).replace(jt, function(N) {
      switch (N) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var kt = Object.assign, Ft = Symbol.for("react.element"), Ut = Symbol.for("react.portal"), Et = Symbol.for("react.fragment"), xn = Symbol.for("react.strict_mode"), pn = Symbol.for("react.profiler"), sn = Symbol.for("react.provider"), yn = Symbol.for("react.context"), Qt = Symbol.for("react.forward_ref"), gn = Symbol.for("react.suspense"), Vn = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), D = Symbol.for("react.lazy"), B = Symbol.for("react.scope"), Z = Symbol.for("react.debug_trace_mode"), Se = Symbol.for("react.legacy_hidden"), ve = Symbol.for("react.default_value"), De = Symbol.iterator;
  function Xe(b) {
    if (b == null)
      return null;
    if (typeof b == "function")
      return b.displayName || b.name || null;
    if (typeof b == "string")
      return b;
    switch (b) {
      case Et:
        return "Fragment";
      case Ut:
        return "Portal";
      case pn:
        return "Profiler";
      case xn:
        return "StrictMode";
      case gn:
        return "Suspense";
      case Vn:
        return "SuspenseList";
    }
    if (typeof b == "object")
      switch (b.$$typeof) {
        case yn:
          return (b.displayName || "Context") + ".Consumer";
        case sn:
          return (b._context.displayName || "Context") + ".Provider";
        case Qt:
          var N = b.render;
          return b = b.displayName, b || (b = N.displayName || N.name || "", b = b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef"), b;
        case g:
          return N = b.displayName || null, N !== null ? N : Xe(b.type) || "Memo";
        case D:
          N = b._payload, b = b._init;
          try {
            return Xe(b(N));
          } catch {
          }
      }
    return null;
  }
  var ut = {};
  function vt(b, N) {
    if (b = b.contextTypes, !b)
      return ut;
    var I = {}, J;
    for (J in b)
      I[J] = N[J];
    return I;
  }
  var pt = null;
  function Mt(b, N) {
    if (b !== N) {
      b.context._currentValue = b.parentValue, b = b.parent;
      var I = N.parent;
      if (b === null) {
        if (I !== null)
          throw Error(t(401));
      } else {
        if (I === null)
          throw Error(t(401));
        Mt(b, I);
      }
      N.context._currentValue = N.value;
    }
  }
  function Dn(b) {
    b.context._currentValue = b.parentValue, b = b.parent, b !== null && Dn(b);
  }
  function pe(b) {
    var N = b.parent;
    N !== null && pe(N), b.context._currentValue = b.value;
  }
  function de(b, N) {
    if (b.context._currentValue = b.parentValue, b = b.parent, b === null)
      throw Error(t(402));
    b.depth === N.depth ? Mt(b, N) : de(b, N);
  }
  function ge(b, N) {
    var I = N.parent;
    if (I === null)
      throw Error(t(402));
    b.depth === I.depth ? Mt(b, I) : ge(b, I), N.context._currentValue = N.value;
  }
  function Fe(b) {
    var N = pt;
    N !== b && (N === null ? pe(b) : b === null ? Dn(N) : N.depth === b.depth ? Mt(N, b) : N.depth > b.depth ? de(N, b) : ge(N, b), pt = b);
  }
  var Nt = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(b, N) {
    b = b._reactInternals, b.queue !== null && b.queue.push(N);
  }, enqueueReplaceState: function(b, N) {
    b = b._reactInternals, b.replace = !0, b.queue = [N];
  }, enqueueForceUpdate: function() {
  } };
  function bn(b, N, I, J) {
    var we = b.state !== void 0 ? b.state : null;
    b.updater = Nt, b.props = I, b.state = we;
    var ke = { queue: [], replace: !1 };
    b._reactInternals = ke;
    var Be = N.contextType;
    if (b.context = typeof Be == "object" && Be !== null ? Be._currentValue : J, Be = N.getDerivedStateFromProps, typeof Be == "function" && (Be = Be(I, we), we = Be == null ? we : kt({}, we, Be), b.state = we), typeof N.getDerivedStateFromProps != "function" && typeof b.getSnapshotBeforeUpdate != "function" && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function"))
      if (N = b.state, typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(), N !== b.state && Nt.enqueueReplaceState(b, b.state, null), ke.queue !== null && 0 < ke.queue.length)
        if (N = ke.queue, Be = ke.replace, ke.queue = null, ke.replace = !1, Be && N.length === 1)
          b.state = N[0];
        else {
          for (ke = Be ? N[0] : b.state, we = !0, Be = Be ? 1 : 0; Be < N.length; Be++) {
            var qe = N[Be];
            qe = typeof qe == "function" ? qe.call(b, ke, I, J) : qe, qe != null && (we ? (we = !1, ke = kt({}, ke, qe)) : kt(ke, qe));
          }
          b.state = ke;
        }
      else
        ke.queue = null;
  }
  var jn = { id: 1, overflow: "" };
  function Gn(b, N, I) {
    var J = b.id;
    b = b.overflow;
    var we = 32 - rr(J) - 1;
    J &= ~(1 << we), I += 1;
    var ke = 32 - rr(N) + we;
    if (30 < ke) {
      var Be = we - we % 5;
      return ke = (J & (1 << Be) - 1).toString(32), J >>= Be, we -= Be, { id: 1 << 32 - rr(N) + we | I << we | J, overflow: ke + b };
    }
    return { id: 1 << ke | I << we | J, overflow: b };
  }
  var rr = Math.clz32 ? Math.clz32 : ja, il = Math.log, ol = Math.LN2;
  function ja(b) {
    return b >>>= 0, b === 0 ? 32 : 31 - (il(b) / ol | 0) | 0;
  }
  function ll(b, N) {
    return b === N && (b !== 0 || 1 / b === 1 / N) || b !== b && N !== N;
  }
  var Ua = typeof Object.is == "function" ? Object.is : ll, gr = null, Qr = null, ha = null, Jt = null, xr = !1, Yn = !1, Lr = 0, br = null, ma = 0;
  function Sr() {
    if (gr === null)
      throw Error(t(321));
    return gr;
  }
  function ar() {
    if (0 < ma)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function Ka() {
    return Jt === null ? ha === null ? (xr = !1, ha = Jt = ar()) : (xr = !0, Jt = ha) : Jt.next === null ? (xr = !1, Jt = Jt.next = ar()) : (xr = !0, Jt = Jt.next), Jt;
  }
  function Ya() {
    Qr = gr = null, Yn = !1, ha = null, ma = 0, Jt = br = null;
  }
  function Vi(b, N) {
    return typeof N == "function" ? N(b) : N;
  }
  function ji(b, N, I) {
    if (gr = Sr(), Jt = Ka(), xr) {
      var J = Jt.queue;
      if (N = J.dispatch, br !== null && (I = br.get(J), I !== void 0)) {
        br.delete(J), J = Jt.memoizedState;
        do
          J = b(J, I.action), I = I.next;
        while (I !== null);
        return Jt.memoizedState = J, [J, N];
      }
      return [Jt.memoizedState, N];
    }
    return b = b === Vi ? typeof N == "function" ? N() : N : I !== void 0 ? I(N) : N, Jt.memoizedState = b, b = Jt.queue = { last: null, dispatch: null }, b = b.dispatch = sl.bind(null, gr, b), [Jt.memoizedState, b];
  }
  function Ui(b, N) {
    if (gr = Sr(), Jt = Ka(), N = N === void 0 ? null : N, Jt !== null) {
      var I = Jt.memoizedState;
      if (I !== null && N !== null) {
        var J = I[1];
        e:
          if (J === null)
            J = !1;
          else {
            for (var we = 0; we < J.length && we < N.length; we++)
              if (!Ua(N[we], J[we])) {
                J = !1;
                break e;
              }
            J = !0;
          }
        if (J)
          return I[0];
      }
    }
    return b = b(), Jt.memoizedState = [b, N], b;
  }
  function sl(b, N, I) {
    if (25 <= ma)
      throw Error(t(301));
    if (b === gr)
      if (Yn = !0, b = { action: I, next: null }, br === null && (br = /* @__PURE__ */ new Map()), I = br.get(N), I === void 0)
        br.set(N, b);
      else {
        for (N = I; N.next !== null; )
          N = N.next;
        N.next = b;
      }
  }
  function ul() {
    throw Error(t(394));
  }
  function ya() {
  }
  var ga = { readContext: function(b) {
    return b._currentValue;
  }, useContext: function(b) {
    return Sr(), b._currentValue;
  }, useMemo: Ui, useReducer: ji, useRef: function(b) {
    gr = Sr(), Jt = Ka();
    var N = Jt.memoizedState;
    return N === null ? (b = { current: b }, Jt.memoizedState = b) : N;
  }, useState: function(b) {
    return ji(Vi, b);
  }, useInsertionEffect: ya, useLayoutEffect: function() {
  }, useCallback: function(b, N) {
    return Ui(function() {
      return b;
    }, N);
  }, useImperativeHandle: ya, useEffect: ya, useDebugValue: ya, useDeferredValue: function(b) {
    return Sr(), b;
  }, useTransition: function() {
    return Sr(), [!1, ul];
  }, useId: function() {
    var b = Qr.treeContext, N = b.overflow;
    b = b.id, b = (b & ~(1 << 32 - rr(b) - 1)).toString(32) + N;
    var I = va;
    if (I === null)
      throw Error(t(404));
    return N = Lr++, b = ":" + I.idPrefix + "R" + b, 0 < N && (b += "H" + N.toString(32)), b + ":";
  }, useMutableSource: function(b, N) {
    return Sr(), N(b._source);
  }, useSyncExternalStore: function(b, N, I) {
    if (I === void 0)
      throw Error(t(407));
    return I();
  } }, va = null, Jr = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function cl(b) {
    return console.error(b), null;
  }
  function ea() {
  }
  function Xa(b, N, I, J, we, ke, Be, qe, St) {
    var _t = [], Dt = /* @__PURE__ */ new Set();
    return N = { destination: null, responseState: N, progressiveChunkSize: J === void 0 ? 12800 : J, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Dt, pingedTasks: _t, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: we === void 0 ? cl : we, onAllReady: ke === void 0 ? ea : ke, onShellReady: Be === void 0 ? ea : Be, onShellError: qe === void 0 ? ea : qe, onFatalError: St === void 0 ? ea : St }, I = Br(N, 0, null, I, !1, !1), I.parentFlushed = !0, b = qa(N, b, null, I, Dt, ut, null, jn), _t.push(b), N;
  }
  function qa(b, N, I, J, we, ke, Be, qe) {
    b.allPendingTasks++, I === null ? b.pendingRootTasks++ : I.pendingTasks++;
    var St = { node: N, ping: function() {
      var _t = b.pingedTasks;
      _t.push(St), _t.length === 1 && Zi(b);
    }, blockedBoundary: I, blockedSegment: J, abortSet: we, legacyContext: ke, context: Be, treeContext: qe };
    return we.add(St), St;
  }
  function Br(b, N, I, J, we, ke) {
    return { status: 0, id: -1, index: N, parentFlushed: !1, chunks: [], children: [], formatContext: J, boundary: I, lastPushedText: we, textEmbedded: ke };
  }
  function Ir(b, N) {
    if (b = b.onError(N), b != null && typeof b != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof b + '" instead');
    return b;
  }
  function xa(b, N) {
    var I = b.onShellError;
    I(N), I = b.onFatalError, I(N), b.destination !== null ? (b.status = 2, y(b.destination, N)) : (b.status = 1, b.fatalError = N);
  }
  function Ki(b, N, I, J, we) {
    for (gr = {}, Qr = N, Lr = 0, b = I(J, we); Yn; )
      Yn = !1, Lr = 0, ma += 1, Jt = null, b = I(J, we);
    return Ya(), b;
  }
  function Ga(b, N, I, J) {
    var we = I.render(), ke = J.childContextTypes;
    if (ke != null) {
      var Be = N.legacyContext;
      if (typeof I.getChildContext != "function")
        J = Be;
      else {
        I = I.getChildContext();
        for (var qe in I)
          if (!(qe in ke))
            throw Error(t(108, Xe(J) || "Unknown", qe));
        J = kt({}, Be, I);
      }
      N.legacyContext = J, Xn(b, N, we), N.legacyContext = Be;
    } else
      Xn(b, N, we);
  }
  function Yi(b, N) {
    if (b && b.defaultProps) {
      N = kt({}, N), b = b.defaultProps;
      for (var I in b)
        N[I] === void 0 && (N[I] = b[I]);
      return N;
    }
    return N;
  }
  function ba(b, N, I, J, we) {
    if (typeof I == "function")
      if (I.prototype && I.prototype.isReactComponent) {
        we = vt(I, N.legacyContext);
        var ke = I.contextType;
        ke = new I(J, typeof ke == "object" && ke !== null ? ke._currentValue : we), bn(ke, I, J, we), Ga(b, N, ke, I);
      } else {
        ke = vt(I, N.legacyContext), we = Ki(b, N, I, J, ke);
        var Be = Lr !== 0;
        if (typeof we == "object" && we !== null && typeof we.render == "function" && we.$$typeof === void 0)
          bn(we, I, J, ke), Ga(b, N, we, I);
        else if (Be) {
          J = N.treeContext, N.treeContext = Gn(J, 1, 0);
          try {
            Xn(b, N, we);
          } finally {
            N.treeContext = J;
          }
        } else
          Xn(b, N, we);
      }
    else if (typeof I == "string") {
      switch (we = N.blockedSegment, ke = Ze(we.chunks, I, J, b.responseState, we.formatContext), we.lastPushedText = !1, Be = we.formatContext, we.formatContext = X(Be, I, J), Sa(b, N, ke), we.formatContext = Be, I) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          we.chunks.push(et, u(I), at);
      }
      we.lastPushedText = !1;
    } else {
      switch (I) {
        case Se:
        case Z:
        case xn:
        case pn:
        case Et:
          Xn(b, N, J.children);
          return;
        case Vn:
          Xn(b, N, J.children);
          return;
        case B:
          throw Error(t(343));
        case gn:
          e: {
            I = N.blockedBoundary, we = N.blockedSegment, ke = J.fallback, J = J.children, Be = /* @__PURE__ */ new Set();
            var qe = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Be, errorDigest: null }, St = Br(b, we.chunks.length, qe, we.formatContext, !1, !1);
            we.children.push(St), we.lastPushedText = !1;
            var _t = Br(b, 0, null, we.formatContext, !1, !1);
            _t.parentFlushed = !0, N.blockedBoundary = qe, N.blockedSegment = _t;
            try {
              if (Sa(
                b,
                N,
                J
              ), _t.lastPushedText && _t.textEmbedded && _t.chunks.push(H), _t.status = 1, Ea(qe, _t), qe.pendingTasks === 0)
                break e;
            } catch (Dt) {
              _t.status = 4, qe.forceClientRender = !0, qe.errorDigest = Ir(b, Dt);
            } finally {
              N.blockedBoundary = I, N.blockedSegment = we;
            }
            N = qa(b, ke, I, St, Be, N.legacyContext, N.context, N.treeContext), b.pingedTasks.push(N);
          }
          return;
      }
      if (typeof I == "object" && I !== null)
        switch (I.$$typeof) {
          case Qt:
            if (J = Ki(b, N, I.render, J, we), Lr !== 0) {
              I = N.treeContext, N.treeContext = Gn(I, 1, 0);
              try {
                Xn(b, N, J);
              } finally {
                N.treeContext = I;
              }
            } else
              Xn(b, N, J);
            return;
          case g:
            I = I.type, J = Yi(I, J), ba(b, N, I, J, we);
            return;
          case sn:
            if (we = J.children, I = I._context, J = J.value, ke = I._currentValue, I._currentValue = J, Be = pt, pt = J = { parent: Be, depth: Be === null ? 0 : Be.depth + 1, context: I, parentValue: ke, value: J }, N.context = J, Xn(b, N, we), b = pt, b === null)
              throw Error(t(403));
            J = b.parentValue, b.context._currentValue = J === ve ? b.context._defaultValue : J, b = pt = b.parent, N.context = b;
            return;
          case yn:
            J = J.children, J = J(I._currentValue), Xn(b, N, J);
            return;
          case D:
            we = I._init, I = we(I._payload), J = Yi(I, J), ba(b, N, I, J, void 0);
            return;
        }
      throw Error(t(
        130,
        I == null ? I : typeof I,
        ""
      ));
    }
  }
  function Xn(b, N, I) {
    if (N.node = I, typeof I == "object" && I !== null) {
      switch (I.$$typeof) {
        case Ft:
          ba(b, N, I.type, I.props, I.ref);
          return;
        case Ut:
          throw Error(t(257));
        case D:
          var J = I._init;
          I = J(I._payload), Xn(b, N, I);
          return;
      }
      if (G(I)) {
        Xi(b, N, I);
        return;
      }
      if (I === null || typeof I != "object" ? J = null : (J = De && I[De] || I["@@iterator"], J = typeof J == "function" ? J : null), J && (J = J.call(I))) {
        if (I = J.next(), !I.done) {
          var we = [];
          do
            we.push(I.value), I = J.next();
          while (!I.done);
          Xi(b, N, we);
        }
        return;
      }
      throw b = Object.prototype.toString.call(I), Error(t(31, b === "[object Object]" ? "object with keys {" + Object.keys(I).join(", ") + "}" : b));
    }
    typeof I == "string" ? (J = N.blockedSegment, J.lastPushedText = Te(N.blockedSegment.chunks, I, b.responseState, J.lastPushedText)) : typeof I == "number" && (J = N.blockedSegment, J.lastPushedText = Te(N.blockedSegment.chunks, "" + I, b.responseState, J.lastPushedText));
  }
  function Xi(b, N, I) {
    for (var J = I.length, we = 0; we < J; we++) {
      var ke = N.treeContext;
      N.treeContext = Gn(ke, J, we);
      try {
        Sa(b, N, I[we]);
      } finally {
        N.treeContext = ke;
      }
    }
  }
  function Sa(b, N, I) {
    var J = N.blockedSegment.formatContext, we = N.legacyContext, ke = N.context;
    try {
      return Xn(b, N, I);
    } catch (St) {
      if (Ya(), typeof St == "object" && St !== null && typeof St.then == "function") {
        I = St;
        var Be = N.blockedSegment, qe = Br(b, Be.chunks.length, null, Be.formatContext, Be.lastPushedText, !0);
        Be.children.push(qe), Be.lastPushedText = !1, b = qa(b, N.node, N.blockedBoundary, qe, N.abortSet, N.legacyContext, N.context, N.treeContext).ping, I.then(b, b), N.blockedSegment.formatContext = J, N.legacyContext = we, N.context = ke, Fe(ke);
      } else
        throw N.blockedSegment.formatContext = J, N.legacyContext = we, N.context = ke, Fe(ke), St;
    }
  }
  function dl(b) {
    var N = b.blockedBoundary;
    b = b.blockedSegment, b.status = 3, Gi(this, N, b);
  }
  function qi(b, N, I) {
    var J = b.blockedBoundary;
    b.blockedSegment.status = 3, J === null ? (N.allPendingTasks--, N.status !== 2 && (N.status = 2, N.destination !== null && N.destination.close())) : (J.pendingTasks--, J.forceClientRender || (J.forceClientRender = !0, b = I === void 0 ? Error(t(432)) : I, J.errorDigest = N.onError(b), J.parentFlushed && N.clientRenderedBoundaries.push(J)), J.fallbackAbortableTasks.forEach(function(we) {
      return qi(we, N, I);
    }), J.fallbackAbortableTasks.clear(), N.allPendingTasks--, N.allPendingTasks === 0 && (J = N.onAllReady, J()));
  }
  function Ea(b, N) {
    if (N.chunks.length === 0 && N.children.length === 1 && N.children[0].boundary === null) {
      var I = N.children[0];
      I.id = N.id, I.parentFlushed = !0, I.status === 1 && Ea(b, I);
    } else
      b.completedSegments.push(N);
  }
  function Gi(b, N, I) {
    if (N === null) {
      if (I.parentFlushed) {
        if (b.completedRootSegment !== null)
          throw Error(t(389));
        b.completedRootSegment = I;
      }
      b.pendingRootTasks--, b.pendingRootTasks === 0 && (b.onShellError = ea, N = b.onShellReady, N());
    } else
      N.pendingTasks--, N.forceClientRender || (N.pendingTasks === 0 ? (I.parentFlushed && I.status === 1 && Ea(N, I), N.parentFlushed && b.completedBoundaries.push(N), N.fallbackAbortableTasks.forEach(dl, b), N.fallbackAbortableTasks.clear()) : I.parentFlushed && I.status === 1 && (Ea(N, I), N.completedSegments.length === 1 && N.parentFlushed && b.partialBoundaries.push(N)));
    b.allPendingTasks--, b.allPendingTasks === 0 && (b = b.onAllReady, b());
  }
  function Zi(b) {
    if (b.status !== 2) {
      var N = pt, I = Jr.current;
      Jr.current = ga;
      var J = va;
      va = b.responseState;
      try {
        var we = b.pingedTasks, ke;
        for (ke = 0; ke < we.length; ke++) {
          var Be = we[ke], qe = b, St = Be.blockedSegment;
          if (St.status === 0) {
            Fe(Be.context);
            try {
              Xn(qe, Be, Be.node), St.lastPushedText && St.textEmbedded && St.chunks.push(H), Be.abortSet.delete(Be), St.status = 1, Gi(qe, Be.blockedBoundary, St);
            } catch (or) {
              if (Ya(), typeof or == "object" && or !== null && typeof or.then == "function") {
                var _t = Be.ping;
                or.then(_t, _t);
              } else {
                Be.abortSet.delete(Be), St.status = 4;
                var Dt = Be.blockedBoundary, an = or, qn = Ir(qe, an);
                if (Dt === null ? xa(qe, an) : (Dt.pendingTasks--, Dt.forceClientRender || (Dt.forceClientRender = !0, Dt.errorDigest = qn, Dt.parentFlushed && qe.clientRenderedBoundaries.push(Dt))), qe.allPendingTasks--, qe.allPendingTasks === 0) {
                  var ir = qe.onAllReady;
                  ir();
                }
              }
            } finally {
            }
          }
        }
        we.splice(0, ke), b.destination !== null && Za(b, b.destination);
      } catch (or) {
        Ir(b, or), xa(b, or);
      } finally {
        va = J, Jr.current = I, I === ga && Fe(N);
      }
    }
  }
  function ka(b, N, I) {
    switch (I.parentFlushed = !0, I.status) {
      case 0:
        var J = I.id = b.nextSegmentId++;
        return I.lastPushedText = !1, I.textEmbedded = !1, b = b.responseState, i(N, gt), i(N, b.placeholderPrefix), b = u(J.toString(16)), i(N, b), l(N, Ot);
      case 1:
        I.status = 2;
        var we = !0;
        J = I.chunks;
        var ke = 0;
        I = I.children;
        for (var Be = 0; Be < I.length; Be++) {
          for (we = I[Be]; ke < we.index; ke++)
            i(N, J[ke]);
          we = wa(b, N, we);
        }
        for (; ke < J.length - 1; ke++)
          i(N, J[ke]);
        return ke < J.length && (we = l(N, J[ke])), we;
      default:
        throw Error(t(390));
    }
  }
  function wa(b, N, I) {
    var J = I.boundary;
    if (J === null)
      return ka(b, N, I);
    if (J.parentFlushed = !0, J.forceClientRender)
      J = J.errorDigest, l(N, Zt), i(N, fn), J && (i(N, tn), i(N, u(z(J))), i(N, Yt)), l(N, kn), ka(b, N, I);
    else if (0 < J.pendingTasks) {
      J.rootSegmentID = b.nextSegmentId++, 0 < J.completedSegments.length && b.partialBoundaries.push(J);
      var we = b.responseState, ke = we.nextSuspenseID++;
      we = m(we.boundaryPrefix + ke.toString(16)), J = J.id = we, ot(N, b.responseState, J), ka(b, N, I);
    } else if (J.byteSize > b.progressiveChunkSize)
      J.rootSegmentID = b.nextSegmentId++, b.completedBoundaries.push(J), ot(N, b.responseState, J.id), ka(b, N, I);
    else {
      if (l(N, Kt), I = J.completedSegments, I.length !== 1)
        throw Error(t(391));
      wa(b, N, I[0]);
    }
    return l(N, zt);
  }
  function Qi(b, N, I) {
    return zn(N, b.responseState, I.formatContext, I.id), wa(b, N, I), Rn(N, I.formatContext);
  }
  function Ji(b, N, I) {
    for (var J = I.completedSegments, we = 0; we < J.length; we++)
      eo(b, N, I, J[we]);
    if (J.length = 0, b = b.responseState, J = I.id, I = I.rootSegmentID, i(N, b.startInlineScript), b.sentCompleteBoundaryFunction ? i(N, lt) : (b.sentCompleteBoundaryFunction = !0, i(N, xe)), J === null)
      throw Error(t(395));
    return I = u(I.toString(16)), i(N, J), i(N, nt), i(N, b.segmentPrefix), i(N, I), l(N, mt);
  }
  function eo(b, N, I, J) {
    if (J.status === 2)
      return !0;
    var we = J.id;
    if (we === -1) {
      if ((J.id = I.rootSegmentID) === -1)
        throw Error(t(392));
      return Qi(b, N, J);
    }
    return Qi(b, N, J), b = b.responseState, i(N, b.startInlineScript), b.sentCompleteSegmentFunction ? i(N, F) : (b.sentCompleteSegmentFunction = !0, i(N, Wn)), i(N, b.segmentPrefix), we = u(we.toString(16)), i(N, we), i(N, Ae), i(N, b.placeholderPrefix), i(N, we), l(N, ze);
  }
  function Za(b, N) {
    n = new Uint8Array(512), a = 0;
    try {
      var I = b.completedRootSegment;
      if (I !== null && b.pendingRootTasks === 0) {
        wa(b, N, I), b.completedRootSegment = null;
        var J = b.responseState.bootstrapChunks;
        for (I = 0; I < J.length - 1; I++)
          i(N, J[I]);
        I < J.length && l(N, J[I]);
      }
      var we = b.clientRenderedBoundaries, ke;
      for (ke = 0; ke < we.length; ke++) {
        var Be = we[ke];
        J = N;
        var qe = b.responseState, St = Be.id, _t = Be.errorDigest, Dt = Be.errorMessage, an = Be.errorComponentStack;
        if (i(J, qe.startInlineScript), qe.sentClientRenderFunction ? i(J, je) : (qe.sentClientRenderFunction = !0, i(
          J,
          ht
        )), St === null)
          throw Error(t(395));
        i(J, St), i(J, yt), (_t || Dt || an) && (i(J, Rt), i(J, u(wt(_t || "")))), (Dt || an) && (i(J, Rt), i(J, u(wt(Dt || "")))), an && (i(J, Rt), i(J, u(wt(an)))), l(J, Tt);
      }
      we.splice(0, ke);
      var qn = b.completedBoundaries;
      for (ke = 0; ke < qn.length; ke++)
        Ji(b, N, qn[ke]);
      qn.splice(0, ke), c(N), n = new Uint8Array(512), a = 0;
      var ir = b.partialBoundaries;
      for (ke = 0; ke < ir.length; ke++) {
        var or = ir[ke];
        e: {
          we = b, Be = N;
          var Ta = or.completedSegments;
          for (qe = 0; qe < Ta.length; qe++)
            if (!eo(
              we,
              Be,
              or,
              Ta[qe]
            )) {
              qe++, Ta.splice(0, qe);
              var no = !1;
              break e;
            }
          Ta.splice(0, qe), no = !0;
        }
        if (!no) {
          b.destination = null, ke++, ir.splice(0, ke);
          return;
        }
      }
      ir.splice(0, ke);
      var Qa = b.completedBoundaries;
      for (ke = 0; ke < Qa.length; ke++)
        Ji(b, N, Qa[ke]);
      Qa.splice(0, ke);
    } finally {
      c(N), b.allPendingTasks === 0 && b.pingedTasks.length === 0 && b.clientRenderedBoundaries.length === 0 && b.completedBoundaries.length === 0 && N.close();
    }
  }
  function to(b, N) {
    try {
      var I = b.abortableTasks;
      I.forEach(function(J) {
        return qi(J, b, N);
      }), I.clear(), b.destination !== null && Za(b, b.destination);
    } catch (J) {
      Ir(b, J), xa(b, J);
    }
  }
  return Fu.renderToReadableStream = function(b, N) {
    return new Promise(function(I, J) {
      var we, ke, Be = new Promise(function(Dt, an) {
        ke = Dt, we = an;
      }), qe = Xa(b, ae(N ? N.identifierPrefix : void 0, N ? N.nonce : void 0, N ? N.bootstrapScriptContent : void 0, N ? N.bootstrapScripts : void 0, N ? N.bootstrapModules : void 0), U(N ? N.namespaceURI : void 0), N ? N.progressiveChunkSize : void 0, N ? N.onError : void 0, ke, function() {
        var Dt = new ReadableStream({ type: "bytes", pull: function(an) {
          if (qe.status === 1)
            qe.status = 2, y(an, qe.fatalError);
          else if (qe.status !== 2 && qe.destination === null) {
            qe.destination = an;
            try {
              Za(qe, an);
            } catch (qn) {
              Ir(qe, qn), xa(qe, qn);
            }
          }
        }, cancel: function() {
          to(qe);
        } }, { highWaterMark: 0 });
        Dt.allReady = Be, I(Dt);
      }, function(Dt) {
        Be.catch(function() {
        }), J(Dt);
      }, we);
      if (N && N.signal) {
        var St = N.signal, _t = function() {
          to(qe, St.reason), St.removeEventListener("abort", _t);
        };
        St.addEventListener("abort", _t);
      }
      Zi(qe);
    });
  }, Fu.version = "18.2.0", Fu;
}
var Ri = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Uh;
function uE() {
  return Uh || (Uh = 1, process.env.NODE_ENV !== "production" && function() {
    var e = le, t = "18.2.0", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(o) {
      {
        for (var d = arguments.length, S = new Array(d > 1 ? d - 1 : 0), L = 1; L < d; L++)
          S[L - 1] = arguments[L];
        l("warn", o, S);
      }
    }
    function i(o) {
      {
        for (var d = arguments.length, S = new Array(d > 1 ? d - 1 : 0), L = 1; L < d; L++)
          S[L - 1] = arguments[L];
        l("error", o, S);
      }
    }
    function l(o, d, S) {
      {
        var L = n.ReactDebugCurrentFrame, $ = L.getStackAddendum();
        $ !== "" && (d += "%s", S = S.concat([$]));
        var ne = S.map(function(fe) {
          return String(fe);
        });
        ne.unshift("Warning: " + d), Function.prototype.apply.call(console[o], console, ne);
      }
    }
    function c(o) {
      o();
    }
    function f(o) {
    }
    function u(o, d) {
      m(o, d);
    }
    function m(o, d) {
      return o.push(d);
    }
    function y(o) {
    }
    function v(o) {
      o.push(null);
    }
    function x(o) {
      return o;
    }
    function A(o) {
      return o;
    }
    function T(o, d) {
      o.destroy(d);
    }
    function M(o) {
      {
        var d = typeof Symbol == "function" && Symbol.toStringTag, S = d && o[Symbol.toStringTag] || o.constructor.name || "Object";
        return S;
      }
    }
    function E(o) {
      try {
        return p(o), !1;
      } catch {
        return !0;
      }
    }
    function p(o) {
      return "" + o;
    }
    function C(o, d) {
      if (E(o))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", d, M(o)), p(o);
    }
    function _(o, d) {
      if (E(o))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", d, M(o)), p(o);
    }
    function w(o) {
      if (E(o))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", M(o)), p(o);
    }
    var R = Object.prototype.hasOwnProperty, P = 0, z = 1, q = 2, V = 3, G = 4, ee = 5, W = 6, Q = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", j = Q + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", te = new RegExp("^[" + Q + "][" + j + "]*$"), se = {}, re = {};
    function ae(o) {
      return R.call(re, o) ? !0 : R.call(se, o) ? !1 : te.test(o) ? (re[o] = !0, !0) : (se[o] = !0, i("Invalid attribute name: `%s`", o), !1);
    }
    function K(o, d, S, L) {
      if (S !== null && S.type === P)
        return !1;
      switch (typeof d) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (L)
            return !1;
          if (S !== null)
            return !S.acceptsBooleans;
          var $ = o.toLowerCase().slice(0, 5);
          return $ !== "data-" && $ !== "aria-";
        }
        default:
          return !1;
      }
    }
    function U(o) {
      return H.hasOwnProperty(o) ? H[o] : null;
    }
    function X(o, d, S, L, $, ne, fe) {
      this.acceptsBooleans = d === q || d === V || d === G, this.attributeName = L, this.attributeNamespace = $, this.mustUseProperty = S, this.propertyName = o, this.type = d, this.sanitizeURL = ne, this.removeEmptyString = fe;
    }
    var H = {}, Te = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Te.forEach(function(o) {
      H[o] = new X(
        o,
        P,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(o) {
      var d = o[0], S = o[1];
      H[d] = new X(
        d,
        z,
        !1,
        // mustUseProperty
        S,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(o) {
      H[o] = new X(
        o,
        q,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(o) {
      H[o] = new X(
        o,
        q,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(o) {
      H[o] = new X(
        o,
        V,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      H[o] = new X(
        o,
        V,
        !0,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      H[o] = new X(
        o,
        G,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      H[o] = new X(
        o,
        W,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(o) {
      H[o] = new X(
        o,
        ee,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var be = /[\-\:]([a-z])/g, ce = function(o) {
      return o[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var d = o.replace(be, ce);
      H[d] = new X(
        d,
        z,
        !1,
        // mustUseProperty
        o,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var d = o.replace(be, ce);
      H[d] = new X(
        d,
        z,
        !1,
        // mustUseProperty
        o,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var d = o.replace(be, ce);
      H[d] = new X(
        d,
        z,
        !1,
        // mustUseProperty
        o,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(o) {
      H[o] = new X(
        o,
        z,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Re = "xlinkHref";
    H[Re] = new X(
      "xlinkHref",
      z,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(o) {
      H[o] = new X(
        o,
        z,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var He = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ge(o, d) {
      return o + d.charAt(0).toUpperCase() + d.substring(1);
    }
    var Ne = ["Webkit", "ms", "Moz", "O"];
    Object.keys(He).forEach(function(o) {
      Ne.forEach(function(d) {
        He[Ge(d, o)] = He[o];
      });
    });
    var ye = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Oe(o, d) {
      ye[d.type] || d.onChange || d.onInput || d.readOnly || d.disabled || d.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), d.onChange || d.readOnly || d.disabled || d.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function ue(o, d) {
      if (o.indexOf("-") === -1)
        return typeof d.is == "string";
      switch (o) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ie = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ce = {}, $e = new RegExp("^(aria)-[" + j + "]*$"), Ve = new RegExp("^(aria)[A-Z][" + j + "]*$");
    function Ee(o, d) {
      {
        if (R.call(Ce, d) && Ce[d])
          return !0;
        if (Ve.test(d)) {
          var S = "aria-" + d.slice(4).toLowerCase(), L = ie.hasOwnProperty(S) ? S : null;
          if (L == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", d), Ce[d] = !0, !0;
          if (d !== L)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", d, L), Ce[d] = !0, !0;
        }
        if ($e.test(d)) {
          var $ = d.toLowerCase(), ne = ie.hasOwnProperty($) ? $ : null;
          if (ne == null)
            return Ce[d] = !0, !1;
          if (d !== ne)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", d, ne), Ce[d] = !0, !0;
        }
      }
      return !0;
    }
    function Ue(o, d) {
      {
        var S = [];
        for (var L in d) {
          var $ = Ee(o, L);
          $ || S.push(L);
        }
        var ne = S.map(function(fe) {
          return "`" + fe + "`";
        }).join(", ");
        S.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ne, o) : S.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ne, o);
      }
    }
    function ft(o, d) {
      ue(o, d) || Ue(o, d);
    }
    var Qe = !1;
    function We(o, d) {
      {
        if (o !== "input" && o !== "textarea" && o !== "select")
          return;
        d != null && d.value === null && !Qe && (Qe = !0, o === "select" && d.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", o) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", o));
      }
    }
    var Ie = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Me = function() {
    };
    {
      var tt = {}, Ze = /^on./, et = /^on[^A-Z]/, at = new RegExp("^(aria)-[" + j + "]*$"), gt = new RegExp("^(aria)[A-Z][" + j + "]*$");
      Me = function(o, d, S, L) {
        if (R.call(tt, d) && tt[d])
          return !0;
        var $ = d.toLowerCase();
        if ($ === "onfocusin" || $ === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), tt[d] = !0, !0;
        if (L != null) {
          var ne = L.registrationNameDependencies, fe = L.possibleRegistrationNames;
          if (ne.hasOwnProperty(d))
            return !0;
          var Le = fe.hasOwnProperty($) ? fe[$] : null;
          if (Le != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", d, Le), tt[d] = !0, !0;
          if (Ze.test(d))
            return i("Unknown event handler property `%s`. It will be ignored.", d), tt[d] = !0, !0;
        } else if (Ze.test(d))
          return et.test(d) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", d), tt[d] = !0, !0;
        if (at.test(d) || gt.test(d))
          return !0;
        if ($ === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), tt[d] = !0, !0;
        if ($ === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), tt[d] = !0, !0;
        if ($ === "is" && S !== null && S !== void 0 && typeof S != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof S), tt[d] = !0, !0;
        if (typeof S == "number" && isNaN(S))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", d), tt[d] = !0, !0;
        var Ke = U(d), it = Ke !== null && Ke.type === P;
        if (Ie.hasOwnProperty($)) {
          var dt = Ie[$];
          if (dt !== d)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", d, dt), tt[d] = !0, !0;
        } else if (!it && d !== $)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", d, $), tt[d] = !0, !0;
        return typeof S == "boolean" && K(d, S, Ke, !1) ? (S ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', S, d, d, S, d) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', S, d, d, S, d, d, d), tt[d] = !0, !0) : it ? !0 : K(d, S, Ke, !1) ? (tt[d] = !0, !1) : ((S === "false" || S === "true") && Ke !== null && Ke.type === V && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", S, d, S === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', d, S), tt[d] = !0), !0);
      };
    }
    var Ot = function(o, d, S) {
      {
        var L = [];
        for (var $ in d) {
          var ne = Me(o, $, d[$], S);
          ne || L.push($);
        }
        var fe = L.map(function(Le) {
          return "`" + Le + "`";
        }).join(", ");
        L.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", fe, o) : L.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", fe, o);
      }
    };
    function Kt(o, d, S) {
      ue(o, d) || Ot(o, d, S);
    }
    var on = function() {
    };
    {
      var Wt = /^(?:webkit|moz|o)[A-Z]/, Zt = /^-ms-/, zt = /-(.)/g, fn = /;\s*$/, Yt = {}, tn = {}, kn = !1, ot = !1, _e = function(o) {
        return o.replace(zt, function(d, S) {
          return S.toUpperCase();
        });
      }, $t = function(o) {
        Yt.hasOwnProperty(o) && Yt[o] || (Yt[o] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          o,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          _e(o.replace(Zt, "ms-"))
        ));
      }, Lt = function(o) {
        Yt.hasOwnProperty(o) && Yt[o] || (Yt[o] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", o, o.charAt(0).toUpperCase() + o.slice(1)));
      }, nn = function(o, d) {
        tn.hasOwnProperty(d) && tn[d] || (tn[d] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, o, d.replace(fn, "")));
      }, un = function(o, d) {
        kn || (kn = !0, i("`NaN` is an invalid value for the `%s` css style property.", o));
      }, At = function(o, d) {
        ot || (ot = !0, i("`Infinity` is an invalid value for the `%s` css style property.", o));
      };
      on = function(o, d) {
        o.indexOf("-") > -1 ? $t(o) : Wt.test(o) ? Lt(o) : fn.test(d) && nn(o, d), typeof d == "number" && (isNaN(d) ? un(o, d) : isFinite(d) || At(o, d));
      };
    }
    var rn = on, ln = /["'&<>]/;
    function Ln(o) {
      w(o);
      var d = "" + o, S = ln.exec(d);
      if (!S)
        return d;
      var L, $ = "", ne, fe = 0;
      for (ne = S.index; ne < d.length; ne++) {
        switch (d.charCodeAt(ne)) {
          case 34:
            L = "&quot;";
            break;
          case 38:
            L = "&amp;";
            break;
          case 39:
            L = "&#x27;";
            break;
          case 60:
            L = "&lt;";
            break;
          case 62:
            L = "&gt;";
            break;
          default:
            continue;
        }
        fe !== ne && ($ += d.substring(fe, ne)), fe = ne + 1, $ += L;
      }
      return fe !== ne ? $ + d.substring(fe, ne) : $;
    }
    function qt(o) {
      return typeof o == "boolean" || typeof o == "number" ? "" + o : Ln(o);
    }
    var mn = /([A-Z])/g, Hn = /^ms-/;
    function Pn(o) {
      return o.replace(mn, "-$1").toLowerCase().replace(Hn, "-ms-");
    }
    var Vt = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, wn = !1;
    function tr(o) {
      !wn && Vt.test(o) && (wn = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(o)));
    }
    var nr = Array.isArray;
    function En(o) {
      return nr(o);
    }
    var Tn = "<script>", Mn = "<\/script>", Kn = '<script src="', zn = '<script type="module" src="', Rn = '" async=""><\/script>';
    function Wn(o) {
      return w(o), ("" + o).replace(F, Ae);
    }
    var F = /(<\/|<)(s)(cript)/gi, Ae = function(o, d, S, L) {
      return "" + d + (S === "s" ? "\\u0073" : "\\u0053") + L;
    };
    function ze(o, d, S, L, $) {
      var ne = o === void 0 ? "" : o, fe = d === void 0 ? Tn : '<script nonce="' + qt(d) + '">', Le = [];
      if (S !== void 0 && Le.push(fe, Wn(S), Mn), L !== void 0)
        for (var Ke = 0; Ke < L.length; Ke++)
          Le.push(Kn, qt(L[Ke]), Rn);
      if ($ !== void 0)
        for (var it = 0; it < $.length; it++)
          Le.push(zn, qt($[it]), Rn);
      return {
        bootstrapChunks: Le,
        startInlineScript: fe,
        placeholderPrefix: ne + "P:",
        segmentPrefix: ne + "S:",
        boundaryPrefix: ne + "B:",
        idPrefix: ne,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var xe = 0, lt = 1, nt = 2, mt = 3, ht = 4, je = 5, yt = 6, Tt = 7;
    function Rt(o, d) {
      return {
        insertionMode: o,
        selectedValue: d
      };
    }
    function jt(o, d, S) {
      switch (d) {
        case "select":
          return Rt(lt, S.value != null ? S.value : S.defaultValue);
        case "svg":
          return Rt(nt, null);
        case "math":
          return Rt(mt, null);
        case "foreignObject":
          return Rt(lt, null);
        case "table":
          return Rt(ht, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return Rt(je, null);
        case "colgroup":
          return Rt(Tt, null);
        case "tr":
          return Rt(yt, null);
      }
      return o.insertionMode >= ht || o.insertionMode === xe ? Rt(lt, null) : o;
    }
    var wt = null;
    function kt(o) {
      var d = o.nextSuspenseID++;
      return o.boundaryPrefix + d.toString(16);
    }
    function Ft(o, d, S) {
      var L = o.idPrefix, $ = ":" + L + "R" + d;
      return S > 0 && ($ += "H" + S.toString(32)), $ + ":";
    }
    function Ut(o) {
      return qt(o);
    }
    var Et = "<!-- -->";
    function xn(o, d, S, L) {
      return d === "" ? L : (L && o.push(Et), o.push(Ut(d)), !0);
    }
    function pn(o, d, S, L) {
      S && L && o.push(Et);
    }
    var sn = /* @__PURE__ */ new Map();
    function yn(o) {
      var d = sn.get(o);
      if (d !== void 0)
        return d;
      var S = qt(Pn(o));
      return sn.set(o, S), S;
    }
    var Qt = ' style="', gn = ":", Vn = ";";
    function g(o, d, S) {
      if (typeof S != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var L = !0;
      for (var $ in S)
        if (R.call(S, $)) {
          var ne = S[$];
          if (!(ne == null || typeof ne == "boolean" || ne === "")) {
            var fe = void 0, Le = void 0, Ke = $.indexOf("--") === 0;
            Ke ? (fe = qt($), _(ne, $), Le = qt(("" + ne).trim())) : (rn($, ne), fe = yn($), typeof ne == "number" ? ne !== 0 && !R.call(He, $) ? Le = ne + "px" : Le = "" + ne : (_(ne, $), Le = qt(("" + ne).trim()))), L ? (L = !1, o.push(Qt, fe, gn, Le)) : o.push(Vn, fe, gn, Le);
          }
        }
      L || o.push(Z);
    }
    var D = " ", B = '="', Z = '"', Se = '=""';
    function ve(o, d, S, L) {
      switch (S) {
        case "style": {
          g(o, d, L);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(S.length > 2 && (S[0] === "o" || S[0] === "O") && (S[1] === "n" || S[1] === "N"))
      ) {
        var $ = U(S);
        if ($ !== null) {
          switch (typeof L) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!$.acceptsBooleans)
                return;
          }
          var ne = $.attributeName, fe = ne;
          switch ($.type) {
            case V:
              L && o.push(D, fe, Se);
              return;
            case G:
              L === !0 ? o.push(D, fe, Se) : L === !1 || o.push(D, fe, B, qt(L), Z);
              return;
            case ee:
              isNaN(L) || o.push(D, fe, B, qt(L), Z);
              break;
            case W:
              !isNaN(L) && L >= 1 && o.push(D, fe, B, qt(L), Z);
              break;
            default:
              $.sanitizeURL && (C(L, ne), L = "" + L, tr(L)), o.push(D, fe, B, qt(L), Z);
          }
        } else if (ae(S)) {
          switch (typeof L) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Le = S.toLowerCase().slice(0, 5);
              if (Le !== "data-" && Le !== "aria-")
                return;
            }
          }
          o.push(D, S, B, qt(L), Z);
        }
      }
    }
    var De = ">", Xe = "/>";
    function ut(o, d, S) {
      if (d != null) {
        if (S != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof d != "object" || !("__html" in d))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var L = d.__html;
        L != null && (w(L), o.push("" + L));
      }
    }
    var vt = !1, pt = !1, Mt = !1, Dn = !1, pe = !1, de = !1, ge = !1;
    function Fe(o, d) {
      {
        var S = o[d];
        if (S != null) {
          var L = En(S);
          o.multiple && !L ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", d) : !o.multiple && L && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", d);
        }
      }
    }
    function Nt(o, d, S) {
      Oe("select", d), Fe(d, "value"), Fe(d, "defaultValue"), d.value !== void 0 && d.defaultValue !== void 0 && !Mt && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Mt = !0), o.push(Yn("select"));
      var L = null, $ = null;
      for (var ne in d)
        if (R.call(d, ne)) {
          var fe = d[ne];
          if (fe == null)
            continue;
          switch (ne) {
            case "children":
              L = fe;
              break;
            case "dangerouslySetInnerHTML":
              $ = fe;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              ve(o, S, ne, fe);
              break;
          }
        }
      return o.push(De), ut(o, $, L), L;
    }
    function bn(o) {
      var d = "";
      return e.Children.forEach(o, function(S) {
        S != null && (d += S, !pe && typeof S != "string" && typeof S != "number" && (pe = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), d;
    }
    var jn = ' selected=""';
    function Gn(o, d, S, L) {
      var $ = L.selectedValue;
      o.push(Yn("option"));
      var ne = null, fe = null, Le = null, Ke = null;
      for (var it in d)
        if (R.call(d, it)) {
          var dt = d[it];
          if (dt == null)
            continue;
          switch (it) {
            case "children":
              ne = dt;
              break;
            case "selected":
              Le = dt, ge || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), ge = !0);
              break;
            case "dangerouslySetInnerHTML":
              Ke = dt;
              break;
            case "value":
              fe = dt;
            default:
              ve(o, S, it, dt);
              break;
          }
        }
      if ($ != null) {
        var Ct;
        if (fe !== null ? (C(fe, "value"), Ct = "" + fe) : (Ke !== null && (de || (de = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), Ct = bn(ne)), En($))
          for (var cn = 0; cn < $.length; cn++) {
            C($[cn], "value");
            var Bn = "" + $[cn];
            if (Bn === Ct) {
              o.push(jn);
              break;
            }
          }
        else
          C($, "select.value"), "" + $ === Ct && o.push(jn);
      } else
        Le && o.push(jn);
      return o.push(De), ut(o, Ke, ne), ne;
    }
    function rr(o, d, S) {
      Oe("input", d), d.checked !== void 0 && d.defaultChecked !== void 0 && !pt && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", d.type), pt = !0), d.value !== void 0 && d.defaultValue !== void 0 && !vt && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", d.type), vt = !0), o.push(Yn("input"));
      var L = null, $ = null, ne = null, fe = null;
      for (var Le in d)
        if (R.call(d, Le)) {
          var Ke = d[Le];
          if (Ke == null)
            continue;
          switch (Le) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              fe = Ke;
              break;
            case "defaultValue":
              $ = Ke;
              break;
            case "checked":
              ne = Ke;
              break;
            case "value":
              L = Ke;
              break;
            default:
              ve(o, S, Le, Ke);
              break;
          }
        }
      return ne !== null ? ve(o, S, "checked", ne) : fe !== null && ve(o, S, "checked", fe), L !== null ? ve(o, S, "value", L) : $ !== null && ve(o, S, "value", $), o.push(Xe), null;
    }
    function il(o, d, S) {
      Oe("textarea", d), d.value !== void 0 && d.defaultValue !== void 0 && !Dn && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Dn = !0), o.push(Yn("textarea"));
      var L = null, $ = null, ne = null;
      for (var fe in d)
        if (R.call(d, fe)) {
          var Le = d[fe];
          if (Le == null)
            continue;
          switch (fe) {
            case "children":
              ne = Le;
              break;
            case "value":
              L = Le;
              break;
            case "defaultValue":
              $ = Le;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              ve(o, S, fe, Le);
              break;
          }
        }
      if (L === null && $ !== null && (L = $), o.push(De), ne != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), L != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (En(ne)) {
          if (ne.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          w(ne[0]), L = "" + ne[0];
        }
        w(ne), L = "" + ne;
      }
      return typeof L == "string" && L[0] === `
` && o.push(Qr), L !== null && (C(L, "value"), o.push(Ut("" + L))), null;
    }
    function ol(o, d, S, L) {
      o.push(Yn(S));
      for (var $ in d)
        if (R.call(d, $)) {
          var ne = d[$];
          if (ne == null)
            continue;
          switch ($) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(S + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              ve(o, L, $, ne);
              break;
          }
        }
      return o.push(Xe), null;
    }
    function ja(o, d, S) {
      o.push(Yn("menuitem"));
      for (var L in d)
        if (R.call(d, L)) {
          var $ = d[L];
          if ($ == null)
            continue;
          switch (L) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              ve(o, S, L, $);
              break;
          }
        }
      return o.push(De), null;
    }
    function ll(o, d, S) {
      o.push(Yn("title"));
      var L = null;
      for (var $ in d)
        if (R.call(d, $)) {
          var ne = d[$];
          if (ne == null)
            continue;
          switch ($) {
            case "children":
              L = ne;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              ve(o, S, $, ne);
              break;
          }
        }
      o.push(De);
      {
        var fe = Array.isArray(L) && L.length < 2 ? L[0] || null : L;
        Array.isArray(L) && L.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : fe != null && fe.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : fe != null && typeof fe != "string" && typeof fe != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return L;
    }
    function Ua(o, d, S, L) {
      o.push(Yn(S));
      var $ = null, ne = null;
      for (var fe in d)
        if (R.call(d, fe)) {
          var Le = d[fe];
          if (Le == null)
            continue;
          switch (fe) {
            case "children":
              $ = Le;
              break;
            case "dangerouslySetInnerHTML":
              ne = Le;
              break;
            default:
              ve(o, L, fe, Le);
              break;
          }
        }
      return o.push(De), ut(o, ne, $), typeof $ == "string" ? (o.push(Ut($)), null) : $;
    }
    function gr(o, d, S, L) {
      o.push(Yn(S));
      var $ = null, ne = null;
      for (var fe in d)
        if (R.call(d, fe)) {
          var Le = d[fe];
          if (Le == null)
            continue;
          switch (fe) {
            case "children":
              $ = Le;
              break;
            case "dangerouslySetInnerHTML":
              ne = Le;
              break;
            case "style":
              g(o, L, Le);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              ae(fe) && typeof Le != "function" && typeof Le != "symbol" && o.push(D, fe, B, qt(Le), Z);
              break;
          }
        }
      return o.push(De), ut(o, ne, $), $;
    }
    var Qr = `
`;
    function ha(o, d, S, L) {
      o.push(Yn(S));
      var $ = null, ne = null;
      for (var fe in d)
        if (R.call(d, fe)) {
          var Le = d[fe];
          if (Le == null)
            continue;
          switch (fe) {
            case "children":
              $ = Le;
              break;
            case "dangerouslySetInnerHTML":
              ne = Le;
              break;
            default:
              ve(o, L, fe, Le);
              break;
          }
        }
      if (o.push(De), ne != null) {
        if ($ != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof ne != "object" || !("__html" in ne))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var Ke = ne.__html;
        Ke != null && (typeof Ke == "string" && Ke.length > 0 && Ke[0] === `
` ? o.push(Qr, Ke) : (w(Ke), o.push("" + Ke)));
      }
      return typeof $ == "string" && $[0] === `
` && o.push(Qr), $;
    }
    var Jt = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, xr = /* @__PURE__ */ new Map();
    function Yn(o) {
      var d = xr.get(o);
      if (d === void 0) {
        if (!Jt.test(o))
          throw new Error("Invalid tag: " + o);
        d = "<" + o, xr.set(o, d);
      }
      return d;
    }
    var Lr = "<!DOCTYPE html>";
    function br(o, d, S, L, $) {
      switch (ft(d, S), We(d, S), Kt(d, S, null), !S.suppressContentEditableWarning && S.contentEditable && S.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), $.insertionMode !== nt && $.insertionMode !== mt && d.indexOf("-") === -1 && typeof S.is != "string" && d.toLowerCase() !== d && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", d), d) {
        case "select":
          return Nt(o, S, L);
        case "option":
          return Gn(o, S, L, $);
        case "textarea":
          return il(o, S, L);
        case "input":
          return rr(o, S, L);
        case "menuitem":
          return ja(o, S, L);
        case "title":
          return ll(o, S, L);
        case "listing":
        case "pre":
          return ha(o, S, d, L);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return ol(o, S, d, L);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Ua(o, S, d, L);
        case "html":
          return $.insertionMode === xe && o.push(Lr), Ua(o, S, d, L);
        default:
          return d.indexOf("-") === -1 && typeof S.is != "string" ? Ua(o, S, d, L) : gr(o, S, d, L);
      }
    }
    var ma = "</", Sr = ">";
    function ar(o, d, S) {
      switch (d) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          o.push(ma, d, Sr);
      }
    }
    function Ka(o, d) {
      for (var S = d.bootstrapChunks, L = 0; L < S.length - 1; L++)
        u(o, S[L]);
      return L < S.length ? m(o, S[L]) : !0;
    }
    var Ya = '<template id="', Vi = '"></template>';
    function ji(o, d, S) {
      u(o, Ya), u(o, d.placeholderPrefix);
      var L = S.toString(16);
      return u(o, L), m(o, Vi);
    }
    var Ui = "<!--$-->", sl = '<!--$?--><template id="', ul = '"></template>', ya = "<!--$!-->", ga = "<!--/$-->", va = "<template", Jr = '"', cl = ' data-dgst="', ea = ' data-msg="', Xa = ' data-stck="', qa = "></template>";
    function Br(o, d) {
      return m(o, Ui);
    }
    function Ir(o, d, S) {
      if (u(o, sl), S === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return u(o, S), m(o, ul);
    }
    function xa(o, d, S, L, $) {
      var ne;
      return ne = m(o, ya), u(o, va), S && (u(o, cl), u(o, qt(S)), u(o, Jr)), L && (u(o, ea), u(o, qt(L)), u(o, Jr)), $ && (u(o, Xa), u(o, qt($)), u(o, Jr)), ne = m(o, qa), ne;
    }
    function Ki(o, d) {
      return m(o, ga);
    }
    function Ga(o, d) {
      return m(o, ga);
    }
    function Yi(o, d) {
      return m(o, ga);
    }
    var ba = '<div hidden id="', Xn = '">', Xi = "</div>", Sa = '<svg aria-hidden="true" style="display:none" id="', dl = '">', qi = "</svg>", Ea = '<math aria-hidden="true" style="display:none" id="', Gi = '">', Zi = "</math>", ka = '<table hidden id="', wa = '">', Qi = "</table>", Ji = '<table hidden><tbody id="', eo = '">', Za = "</tbody></table>", to = '<table hidden><tr id="', b = '">', N = "</tr></table>", I = '<table hidden><colgroup id="', J = '">', we = "</colgroup></table>";
    function ke(o, d, S, L) {
      switch (S.insertionMode) {
        case xe:
        case lt:
          return u(o, ba), u(o, d.segmentPrefix), u(o, L.toString(16)), m(o, Xn);
        case nt:
          return u(o, Sa), u(o, d.segmentPrefix), u(o, L.toString(16)), m(o, dl);
        case mt:
          return u(o, Ea), u(o, d.segmentPrefix), u(o, L.toString(16)), m(o, Gi);
        case ht:
          return u(o, ka), u(o, d.segmentPrefix), u(o, L.toString(16)), m(o, wa);
        case je:
          return u(o, Ji), u(o, d.segmentPrefix), u(o, L.toString(16)), m(o, eo);
        case yt:
          return u(o, to), u(o, d.segmentPrefix), u(o, L.toString(16)), m(o, b);
        case Tt:
          return u(o, I), u(o, d.segmentPrefix), u(o, L.toString(16)), m(o, J);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Be(o, d) {
      switch (d.insertionMode) {
        case xe:
        case lt:
          return m(o, Xi);
        case nt:
          return m(o, qi);
        case mt:
          return m(o, Zi);
        case ht:
          return m(o, Qi);
        case je:
          return m(o, Za);
        case yt:
          return m(o, N);
        case Tt:
          return m(o, we);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var qe = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", St = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', _t = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Dt = qe + ';$RS("', an = '$RS("', qn = '","', ir = '")<\/script>';
    function or(o, d, S) {
      u(o, d.startInlineScript), d.sentCompleteSegmentFunction ? u(o, an) : (d.sentCompleteSegmentFunction = !0, u(o, Dt)), u(o, d.segmentPrefix);
      var L = S.toString(16);
      return u(o, L), u(o, qn), u(o, d.placeholderPrefix), u(o, L), m(o, ir);
    }
    var Ta = St + ';$RC("', no = '$RC("', Qa = '","', Bc = '")<\/script>';
    function Ic(o, d, S, L) {
      if (u(o, d.startInlineScript), d.sentCompleteBoundaryFunction ? u(o, no) : (d.sentCompleteBoundaryFunction = !0, u(o, Ta)), S === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var $ = L.toString(16);
      return u(o, S), u(o, Qa), u(o, d.segmentPrefix), u(o, $), m(o, Bc);
    }
    var Hc = _t + ';$RX("', Wc = '$RX("', Vc = '"', jc = ")<\/script>", fl = ",";
    function Uc(o, d, S, L, $, ne) {
      if (u(o, d.startInlineScript), d.sentClientRenderFunction ? u(o, Wc) : (d.sentClientRenderFunction = !0, u(o, Hc)), S === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return u(o, S), u(o, Vc), (L || $ || ne) && (u(o, fl), u(o, pl(L || ""))), ($ || ne) && (u(o, fl), u(o, pl($ || ""))), ne && (u(o, fl), u(o, pl(ne))), m(o, jc);
    }
    var Kc = /[<\u2028\u2029]/g;
    function pl(o) {
      var d = JSON.stringify(o);
      return d.replace(Kc, function(S) {
        switch (S) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Yc(o, d) {
      var S = ze(d, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: S.bootstrapChunks,
        startInlineScript: S.startInlineScript,
        placeholderPrefix: S.placeholderPrefix,
        segmentPrefix: S.segmentPrefix,
        boundaryPrefix: S.boundaryPrefix,
        idPrefix: S.idPrefix,
        nextSuspenseID: S.nextSuspenseID,
        sentCompleteSegmentFunction: S.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: S.sentCompleteBoundaryFunction,
        sentClientRenderFunction: S.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: o
      };
    }
    function hl() {
      return {
        insertionMode: lt,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function Os(o, d, S, L) {
      return S.generateStaticMarkup ? (o.push(qt(d)), !1) : xn(o, d, S, L);
    }
    function Fs(o, d, S, L) {
      if (!d.generateStaticMarkup)
        return pn(o, d, S, L);
    }
    function ml(o, d) {
      return d.generateStaticMarkup ? !0 : Br(o);
    }
    function fr(o, d, S, L, $) {
      return d.generateStaticMarkup ? !0 : xa(o, d, S, L, $);
    }
    function Xc(o, d) {
      return d.generateStaticMarkup ? !0 : Ki(o);
    }
    function Ms(o, d) {
      return d.generateStaticMarkup ? !0 : Yi(o);
    }
    var lr = Object.assign, zs = Symbol.for("react.element"), yl = Symbol.for("react.portal"), ro = Symbol.for("react.fragment"), ao = Symbol.for("react.strict_mode"), io = Symbol.for("react.profiler"), Ja = Symbol.for("react.provider"), ei = Symbol.for("react.context"), ti = Symbol.for("react.forward_ref"), Ca = Symbol.for("react.suspense"), gl = Symbol.for("react.suspense_list"), vl = Symbol.for("react.memo"), oo = Symbol.for("react.lazy"), qc = Symbol.for("react.scope"), $s = Symbol.for("react.debug_trace_mode"), Gc = Symbol.for("react.legacy_hidden"), Zc = Symbol.for("react.default_value"), Bs = Symbol.iterator, Is = "@@iterator";
    function vn(o) {
      if (o === null || typeof o != "object")
        return null;
      var d = Bs && o[Bs] || o[Is];
      return typeof d == "function" ? d : null;
    }
    function ni(o, d, S) {
      var L = o.displayName;
      if (L)
        return L;
      var $ = d.displayName || d.name || "";
      return $ !== "" ? S + "(" + $ + ")" : S;
    }
    function xl(o) {
      return o.displayName || "Context";
    }
    function hn(o) {
      if (o == null)
        return null;
      if (typeof o.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof o == "function")
        return o.displayName || o.name || null;
      if (typeof o == "string")
        return o;
      switch (o) {
        case ro:
          return "Fragment";
        case yl:
          return "Portal";
        case io:
          return "Profiler";
        case ao:
          return "StrictMode";
        case Ca:
          return "Suspense";
        case gl:
          return "SuspenseList";
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case ei:
            var d = o;
            return xl(d) + ".Consumer";
          case Ja:
            var S = o;
            return xl(S._context) + ".Provider";
          case ti:
            return ni(o, o.render, "ForwardRef");
          case vl:
            var L = o.displayName || null;
            return L !== null ? L : hn(o.type) || "Memo";
          case oo: {
            var $ = o, ne = $._payload, fe = $._init;
            try {
              return hn(fe(ne));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Aa = 0, bl, Sl, El, kl, wl, Hs, Ws;
    function lo() {
    }
    lo.__reactDisabledLog = !0;
    function Tl() {
      {
        if (Aa === 0) {
          bl = console.log, Sl = console.info, El = console.warn, kl = console.error, wl = console.group, Hs = console.groupCollapsed, Ws = console.groupEnd;
          var o = {
            configurable: !0,
            enumerable: !0,
            value: lo,
            writable: !0
          };
          Object.defineProperties(console, {
            info: o,
            log: o,
            warn: o,
            error: o,
            group: o,
            groupCollapsed: o,
            groupEnd: o
          });
        }
        Aa++;
      }
    }
    function ri() {
      {
        if (Aa--, Aa === 0) {
          var o = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: lr({}, o, {
              value: bl
            }),
            info: lr({}, o, {
              value: Sl
            }),
            warn: lr({}, o, {
              value: El
            }),
            error: lr({}, o, {
              value: kl
            }),
            group: lr({}, o, {
              value: wl
            }),
            groupCollapsed: lr({}, o, {
              value: Hs
            }),
            groupEnd: lr({}, o, {
              value: Ws
            })
          });
        }
        Aa < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ai = n.ReactCurrentDispatcher, La;
    function ii(o, d, S) {
      {
        if (La === void 0)
          try {
            throw Error();
          } catch ($) {
            var L = $.stack.trim().match(/\n( *(at )?)/);
            La = L && L[1] || "";
          }
        return `
` + La + o;
      }
    }
    var oi = !1, so;
    {
      var Vs = typeof WeakMap == "function" ? WeakMap : Map;
      so = new Vs();
    }
    function Cl(o, d) {
      if (!o || oi)
        return "";
      {
        var S = so.get(o);
        if (S !== void 0)
          return S;
      }
      var L;
      oi = !0;
      var $ = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ne;
      ne = ai.current, ai.current = null, Tl();
      try {
        if (d) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (yr) {
              L = yr;
            }
            Reflect.construct(o, [], fe);
          } else {
            try {
              fe.call();
            } catch (yr) {
              L = yr;
            }
            o.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (yr) {
            L = yr;
          }
          o();
        }
      } catch (yr) {
        if (yr && L && typeof yr.stack == "string") {
          for (var Le = yr.stack.split(`
`), Ke = L.stack.split(`
`), it = Le.length - 1, dt = Ke.length - 1; it >= 1 && dt >= 0 && Le[it] !== Ke[dt]; )
            dt--;
          for (; it >= 1 && dt >= 0; it--, dt--)
            if (Le[it] !== Ke[dt]) {
              if (it !== 1 || dt !== 1)
                do
                  if (it--, dt--, dt < 0 || Le[it] !== Ke[dt]) {
                    var Ct = `
` + Le[it].replace(" at new ", " at ");
                    return o.displayName && Ct.includes("<anonymous>") && (Ct = Ct.replace("<anonymous>", o.displayName)), typeof o == "function" && so.set(o, Ct), Ct;
                  }
                while (it >= 1 && dt >= 0);
              break;
            }
        }
      } finally {
        oi = !1, ai.current = ne, ri(), Error.prepareStackTrace = $;
      }
      var cn = o ? o.displayName || o.name : "", Bn = cn ? ii(cn) : "";
      return typeof o == "function" && so.set(o, Bn), Bn;
    }
    function Al(o, d, S) {
      return Cl(o, !0);
    }
    function Ll(o, d, S) {
      return Cl(o, !1);
    }
    function js(o) {
      var d = o.prototype;
      return !!(d && d.isReactComponent);
    }
    function Pa(o, d, S) {
      if (o == null)
        return "";
      if (typeof o == "function")
        return Cl(o, js(o));
      if (typeof o == "string")
        return ii(o);
      switch (o) {
        case Ca:
          return ii("Suspense");
        case gl:
          return ii("SuspenseList");
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case ti:
            return Ll(o.render);
          case vl:
            return Pa(o.type, d, S);
          case oo: {
            var L = o, $ = L._payload, ne = L._init;
            try {
              return Pa(ne($), d, S);
            } catch {
            }
          }
        }
      return "";
    }
    var Pl = {}, uo = n.ReactDebugCurrentFrame;
    function ta(o) {
      if (o) {
        var d = o._owner, S = Pa(o.type, o._source, d ? d.type : null);
        uo.setExtraStackFrame(S);
      } else
        uo.setExtraStackFrame(null);
    }
    function Rl(o, d, S, L, $) {
      {
        var ne = Function.call.bind(R);
        for (var fe in o)
          if (ne(o, fe)) {
            var Le = void 0;
            try {
              if (typeof o[fe] != "function") {
                var Ke = Error((L || "React class") + ": " + S + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ke.name = "Invariant Violation", Ke;
              }
              Le = o[fe](d, fe, L, S, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (it) {
              Le = it;
            }
            Le && !(Le instanceof Error) && (ta($), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", L || "React class", S, fe, typeof Le), ta(null)), Le instanceof Error && !(Le.message in Pl) && (Pl[Le.message] = !0, ta($), i("Failed %s type: %s", S, Le.message), ta(null));
          }
      }
    }
    var Dl;
    Dl = {};
    var Hr = {};
    Object.freeze(Hr);
    function Us(o, d) {
      {
        var S = o.contextTypes;
        if (!S)
          return Hr;
        var L = {};
        for (var $ in S)
          L[$] = d[$];
        {
          var ne = hn(o) || "Unknown";
          Rl(S, L, "context", ne);
        }
        return L;
      }
    }
    function na(o, d, S, L) {
      {
        if (typeof o.getChildContext != "function") {
          {
            var $ = hn(d) || "Unknown";
            Dl[$] || (Dl[$] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", $, $));
          }
          return S;
        }
        var ne = o.getChildContext();
        for (var fe in ne)
          if (!(fe in L))
            throw new Error((hn(d) || "Unknown") + '.getChildContext(): key "' + fe + '" is not defined in childContextTypes.');
        {
          var Le = hn(d) || "Unknown";
          Rl(L, ne, "child context", Le);
        }
        return lr({}, S, ne);
      }
    }
    var ra;
    ra = {};
    var Nl = null, Er = null;
    function co(o) {
      o.context._currentValue2 = o.parentValue;
    }
    function fo(o) {
      o.context._currentValue2 = o.value;
    }
    function li(o, d) {
      if (o !== d) {
        co(o);
        var S = o.parent, L = d.parent;
        if (S === null) {
          if (L !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (L === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          li(S, L);
        }
        fo(d);
      }
    }
    function _l(o) {
      co(o);
      var d = o.parent;
      d !== null && _l(d);
    }
    function si(o) {
      var d = o.parent;
      d !== null && si(d), fo(o);
    }
    function Ks(o, d) {
      co(o);
      var S = o.parent;
      if (S === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      S.depth === d.depth ? li(S, d) : Ks(S, d);
    }
    function Ys(o, d) {
      var S = d.parent;
      if (S === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      o.depth === S.depth ? li(o, S) : Ys(o, S), fo(d);
    }
    function po(o) {
      var d = Er, S = o;
      d !== S && (d === null ? si(S) : S === null ? _l(d) : d.depth === S.depth ? li(d, S) : d.depth > S.depth ? Ks(d, S) : Ys(d, S), Er = S);
    }
    function ui(o, d) {
      var S;
      S = o._currentValue2, o._currentValue2 = d, o._currentRenderer2 !== void 0 && o._currentRenderer2 !== null && o._currentRenderer2 !== ra && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), o._currentRenderer2 = ra;
      var L = Er, $ = {
        parent: L,
        depth: L === null ? 0 : L.depth + 1,
        context: o,
        parentValue: S,
        value: d
      };
      return Er = $, $;
    }
    function Ol(o) {
      var d = Er;
      if (d === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      d.context !== o && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var S = d.parentValue;
        S === Zc ? d.context._currentValue2 = d.context._defaultValue : d.context._currentValue2 = S, o._currentRenderer2 !== void 0 && o._currentRenderer2 !== null && o._currentRenderer2 !== ra && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), o._currentRenderer2 = ra;
      }
      return Er = d.parent;
    }
    function Qc() {
      return Er;
    }
    function Ra(o) {
      var d = o._currentValue2;
      return d;
    }
    function ho(o) {
      return o._reactInternals;
    }
    function Fl(o, d) {
      o._reactInternals = d;
    }
    var mo = {}, yo = {}, ci, go, Da, di, vo, Na, xo, bo, So;
    {
      ci = /* @__PURE__ */ new Set(), go = /* @__PURE__ */ new Set(), Da = /* @__PURE__ */ new Set(), xo = /* @__PURE__ */ new Set(), di = /* @__PURE__ */ new Set(), bo = /* @__PURE__ */ new Set(), So = /* @__PURE__ */ new Set();
      var Xs = /* @__PURE__ */ new Set();
      Na = function(o, d) {
        if (!(o === null || typeof o == "function")) {
          var S = d + "_" + o;
          Xs.has(S) || (Xs.add(S), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d, o));
        }
      }, vo = function(o, d) {
        if (d === void 0) {
          var S = hn(o) || "Component";
          di.has(S) || (di.add(S), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", S));
        }
      };
    }
    function qs(o, d) {
      {
        var S = o.constructor, L = S && hn(S) || "ReactClass", $ = L + "." + d;
        if (mo[$])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, d, d, L), mo[$] = !0;
      }
    }
    var Gs = {
      isMounted: function(o) {
        return !1;
      },
      enqueueSetState: function(o, d, S) {
        var L = ho(o);
        L.queue === null ? qs(o, "setState") : (L.queue.push(d), S != null && Na(S, "setState"));
      },
      enqueueReplaceState: function(o, d, S) {
        var L = ho(o);
        L.replace = !0, L.queue = [d], S != null && Na(S, "setState");
      },
      enqueueForceUpdate: function(o, d) {
        var S = ho(o);
        S.queue === null ? qs(o, "forceUpdate") : d != null && Na(d, "setState");
      }
    };
    function Jc(o, d, S, L, $) {
      var ne = S($, L);
      vo(d, ne);
      var fe = ne == null ? L : lr({}, L, ne);
      return fe;
    }
    function ed(o, d, S) {
      var L = Hr, $ = o.contextType;
      if ("contextType" in o) {
        var ne = (
          // Allow null for conditional declaration
          $ === null || $ !== void 0 && $.$$typeof === ei && $._context === void 0
        );
        if (!ne && !So.has(o)) {
          So.add(o);
          var fe = "";
          $ === void 0 ? fe = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof $ != "object" ? fe = " However, it is set to a " + typeof $ + "." : $.$$typeof === Ja ? fe = " Did you accidentally pass the Context.Provider instead?" : $._context !== void 0 ? fe = " Did you accidentally pass the Context.Consumer instead?" : fe = " However, it is set to an object with keys {" + Object.keys($).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", hn(o) || "Component", fe);
        }
      }
      typeof $ == "object" && $ !== null ? L = Ra($) : L = S;
      var Le = new o(d, L);
      {
        if (typeof o.getDerivedStateFromProps == "function" && (Le.state === null || Le.state === void 0)) {
          var Ke = hn(o) || "Component";
          ci.has(Ke) || (ci.add(Ke), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Ke, Le.state === null ? "null" : "undefined", Ke));
        }
        if (typeof o.getDerivedStateFromProps == "function" || typeof Le.getSnapshotBeforeUpdate == "function") {
          var it = null, dt = null, Ct = null;
          if (typeof Le.componentWillMount == "function" && Le.componentWillMount.__suppressDeprecationWarning !== !0 ? it = "componentWillMount" : typeof Le.UNSAFE_componentWillMount == "function" && (it = "UNSAFE_componentWillMount"), typeof Le.componentWillReceiveProps == "function" && Le.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? dt = "componentWillReceiveProps" : typeof Le.UNSAFE_componentWillReceiveProps == "function" && (dt = "UNSAFE_componentWillReceiveProps"), typeof Le.componentWillUpdate == "function" && Le.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Ct = "componentWillUpdate" : typeof Le.UNSAFE_componentWillUpdate == "function" && (Ct = "UNSAFE_componentWillUpdate"), it !== null || dt !== null || Ct !== null) {
            var cn = hn(o) || "Component", Bn = typeof o.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Da.has(cn) || (Da.add(cn), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, cn, Bn, it !== null ? `
  ` + it : "", dt !== null ? `
  ` + dt : "", Ct !== null ? `
  ` + Ct : ""));
          }
        }
      }
      return Le;
    }
    function Zs(o, d, S) {
      {
        var L = hn(d) || "Component", $ = o.render;
        $ || (d.prototype && typeof d.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", L) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", L)), o.getInitialState && !o.getInitialState.isReactClassApproved && !o.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", L), o.getDefaultProps && !o.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", L), o.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", L), o.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", L), o.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", L), d.contextType && d.contextTypes && !bo.has(d) && (bo.add(d), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", L)), typeof o.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", L), d.prototype && d.prototype.isPureReactComponent && typeof o.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", hn(d) || "A pure component"), typeof o.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", L), typeof o.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", L), typeof o.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", L), typeof o.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", L);
        var ne = o.props !== S;
        o.props !== void 0 && ne && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", L, L), o.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", L, L), typeof o.getSnapshotBeforeUpdate == "function" && typeof o.componentDidUpdate != "function" && !go.has(d) && (go.add(d), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", hn(d))), typeof o.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", L), typeof o.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", L), typeof d.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", L);
        var fe = o.state;
        fe && (typeof fe != "object" || En(fe)) && i("%s.state: must be set to an object or null", L), typeof o.getChildContext == "function" && typeof d.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", L);
      }
    }
    function td(o, d) {
      var S = d.state;
      if (typeof d.componentWillMount == "function") {
        if (d.componentWillMount.__suppressDeprecationWarning !== !0) {
          var L = hn(o) || "Unknown";
          yo[L] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            L
          ), yo[L] = !0);
        }
        d.componentWillMount();
      }
      typeof d.UNSAFE_componentWillMount == "function" && d.UNSAFE_componentWillMount(), S !== d.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", hn(o) || "Component"), Gs.enqueueReplaceState(d, d.state, null));
    }
    function nd(o, d, S, L) {
      if (o.queue !== null && o.queue.length > 0) {
        var $ = o.queue, ne = o.replace;
        if (o.queue = null, o.replace = !1, ne && $.length === 1)
          d.state = $[0];
        else {
          for (var fe = ne ? $[0] : d.state, Le = !0, Ke = ne ? 1 : 0; Ke < $.length; Ke++) {
            var it = $[Ke], dt = typeof it == "function" ? it.call(d, fe, S, L) : it;
            dt != null && (Le ? (Le = !1, fe = lr({}, fe, dt)) : lr(fe, dt));
          }
          d.state = fe;
        }
      } else
        o.queue = null;
    }
    function Eo(o, d, S, L) {
      Zs(o, d, S);
      var $ = o.state !== void 0 ? o.state : null;
      o.updater = Gs, o.props = S, o.state = $;
      var ne = {
        queue: [],
        replace: !1
      };
      Fl(o, ne);
      var fe = d.contextType;
      if (typeof fe == "object" && fe !== null ? o.context = Ra(fe) : o.context = L, o.state === S) {
        var Le = hn(d) || "Component";
        xo.has(Le) || (xo.add(Le), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Le));
      }
      var Ke = d.getDerivedStateFromProps;
      typeof Ke == "function" && (o.state = Jc(o, d, Ke, $, S)), typeof d.getDerivedStateFromProps != "function" && typeof o.getSnapshotBeforeUpdate != "function" && (typeof o.UNSAFE_componentWillMount == "function" || typeof o.componentWillMount == "function") && (td(d, o), nd(ne, o, S, L));
    }
    var ko = {
      id: 1,
      overflow: ""
    };
    function rd(o) {
      var d = o.overflow, S = o.id, L = S & ~ad(S);
      return L.toString(32) + d;
    }
    function Ml(o, d, S) {
      var L = o.id, $ = o.overflow, ne = wo(L) - 1, fe = L & ~(1 << ne), Le = S + 1, Ke = wo(d) + ne;
      if (Ke > 30) {
        var it = ne - ne % 5, dt = (1 << it) - 1, Ct = (fe & dt).toString(32), cn = fe >> it, Bn = ne - it, yr = wo(d) + Bn, xu = Le << Bn, bu = xu | cn, Su = Ct + $;
        return {
          id: 1 << yr | bu,
          overflow: Su
        };
      } else {
        var Io = Le << ne, Gy = Io | fe, Zy = $;
        return {
          id: 1 << Ke | Gy,
          overflow: Zy
        };
      }
    }
    function wo(o) {
      return 32 - id(o);
    }
    function ad(o) {
      return 1 << wo(o) - 1;
    }
    var id = Math.clz32 ? Math.clz32 : Pr, od = Math.log, ld = Math.LN2;
    function Pr(o) {
      var d = o >>> 0;
      return d === 0 ? 32 : 31 - (od(d) / ld | 0) | 0;
    }
    function zl(o, d) {
      return o === d && (o !== 0 || 1 / o === 1 / d) || o !== o && d !== d;
    }
    var To = typeof Object.is == "function" ? Object.is : zl, Bt = null, aa = null, ia = null, Gt = null, pr = !1, oa = !1, Co = 0, $n = null, Rr = 0, la = 25, kr = !1, sa;
    function Dr() {
      if (Bt === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return kr && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Bt;
    }
    function sd(o, d) {
      if (d === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", sa), !1;
      o.length !== d.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, sa, "[" + o.join(", ") + "]", "[" + d.join(", ") + "]");
      for (var S = 0; S < d.length && S < o.length; S++)
        if (!To(o[S], d[S]))
          return !1;
      return !0;
    }
    function Qs() {
      if (Rr > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Ao() {
      return Gt === null ? ia === null ? (pr = !1, ia = Gt = Qs()) : (pr = !0, Gt = ia) : Gt.next === null ? (pr = !1, Gt = Gt.next = Qs()) : (pr = !0, Gt = Gt.next), Gt;
    }
    function $l(o, d) {
      Bt = d, aa = o, kr = !1, Co = 0;
    }
    function ud(o, d, S, L) {
      for (; oa; )
        oa = !1, Co = 0, Rr += 1, Gt = null, S = o(d, L);
      return fi(), S;
    }
    function Js() {
      var o = Co !== 0;
      return o;
    }
    function fi() {
      kr = !1, Bt = null, aa = null, oa = !1, ia = null, Rr = 0, $n = null, Gt = null;
    }
    function cd(o) {
      return kr && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Ra(o);
    }
    function eu(o) {
      return sa = "useContext", Dr(), Ra(o);
    }
    function Lo(o, d) {
      return typeof d == "function" ? d(o) : d;
    }
    function dd(o) {
      return sa = "useState", tu(
        Lo,
        // useReducer has a special case to support lazy useState initializers
        o
      );
    }
    function tu(o, d, S) {
      if (o !== Lo && (sa = "useReducer"), Bt = Dr(), Gt = Ao(), pr) {
        var L = Gt.queue, $ = L.dispatch;
        if ($n !== null) {
          var ne = $n.get(L);
          if (ne !== void 0) {
            $n.delete(L);
            var fe = Gt.memoizedState, Le = ne;
            do {
              var Ke = Le.action;
              kr = !0, fe = o(fe, Ke), kr = !1, Le = Le.next;
            } while (Le !== null);
            return Gt.memoizedState = fe, [fe, $];
          }
        }
        return [Gt.memoizedState, $];
      } else {
        kr = !0;
        var it;
        o === Lo ? it = typeof d == "function" ? d() : d : it = S !== void 0 ? S(d) : d, kr = !1, Gt.memoizedState = it;
        var dt = Gt.queue = {
          last: null,
          dispatch: null
        }, Ct = dt.dispatch = hd.bind(null, Bt, dt);
        return [Gt.memoizedState, Ct];
      }
    }
    function nu(o, d) {
      Bt = Dr(), Gt = Ao();
      var S = d === void 0 ? null : d;
      if (Gt !== null) {
        var L = Gt.memoizedState;
        if (L !== null && S !== null) {
          var $ = L[1];
          if (sd(S, $))
            return L[0];
        }
      }
      kr = !0;
      var ne = o();
      return kr = !1, Gt.memoizedState = [ne, S], ne;
    }
    function fd(o) {
      Bt = Dr(), Gt = Ao();
      var d = Gt.memoizedState;
      if (d === null) {
        var S = {
          current: o
        };
        return Object.seal(S), Gt.memoizedState = S, S;
      } else
        return d;
    }
    function pd(o, d) {
      sa = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function hd(o, d, S) {
      if (Rr >= la)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (o === Bt) {
        oa = !0;
        var L = {
          action: S,
          next: null
        };
        $n === null && ($n = /* @__PURE__ */ new Map());
        var $ = $n.get(d);
        if ($ === void 0)
          $n.set(d, L);
        else {
          for (var ne = $; ne.next !== null; )
            ne = ne.next;
          ne.next = L;
        }
      }
    }
    function md(o, d) {
      return nu(function() {
        return o;
      }, d);
    }
    function yd(o, d, S) {
      return Dr(), d(o._source);
    }
    function gd(o, d, S) {
      if (S === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return S();
    }
    function vd(o) {
      return Dr(), o;
    }
    function Po() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function ru() {
      return Dr(), [!1, Po];
    }
    function Bl() {
      var o = aa, d = rd(o.treeContext), S = hi;
      if (S === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var L = Co++;
      return Ft(S, d, L);
    }
    function pi() {
    }
    var au = {
      readContext: cd,
      useContext: eu,
      useMemo: nu,
      useReducer: tu,
      useRef: fd,
      useState: dd,
      useInsertionEffect: pi,
      useLayoutEffect: pd,
      useCallback: md,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: pi,
      // Effects are not run in the server environment.
      useEffect: pi,
      // Debugging effect
      useDebugValue: pi,
      useDeferredValue: vd,
      useTransition: ru,
      useId: Bl,
      // Subscriptions are not setup in a server environment.
      useMutableSource: yd,
      useSyncExternalStore: gd
    }, hi = null;
    function Ro(o) {
      hi = o;
    }
    function Il(o) {
      try {
        var d = "", S = o;
        do {
          switch (S.tag) {
            case 0:
              d += ii(S.type, null, null);
              break;
            case 1:
              d += Ll(S.type, null, null);
              break;
            case 2:
              d += Al(S.type, null, null);
              break;
          }
          S = S.parent;
        } while (S);
        return d;
      } catch (L) {
        return `
Error generating stack: ` + L.message + `
` + L.stack;
      }
    }
    var Wr = n.ReactCurrentDispatcher, Do = n.ReactDebugCurrentFrame, No = 0, ua = 1, iu = 2, Hl = 3, ca = 4, xd = 0, ou = 1, wr = 2, bd = 12800;
    function Sd(o) {
      return console.error(o), null;
    }
    function mi() {
    }
    function Wl(o, d, S, L, $, ne, fe, Le, Ke) {
      var it = [], dt = /* @__PURE__ */ new Set(), Ct = {
        destination: null,
        responseState: d,
        progressiveChunkSize: L === void 0 ? bd : L,
        status: xd,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: dt,
        pingedTasks: it,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: $ === void 0 ? Sd : $,
        onAllReady: ne === void 0 ? mi : ne,
        onShellReady: fe === void 0 ? mi : fe,
        onShellError: Le === void 0 ? mi : Le,
        onFatalError: Ke === void 0 ? mi : Ke
      }, cn = Vr(
        Ct,
        0,
        null,
        S,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      cn.parentFlushed = !0;
      var Bn = yi(Ct, o, null, cn, dt, Hr, Nl, ko);
      return it.push(Bn), Ct;
    }
    function _o(o, d) {
      var S = o.pingedTasks;
      S.push(d), S.length === 1 && c(function() {
        return gu(o);
      });
    }
    function Nr(o, d) {
      return {
        id: wt,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: d,
        errorDigest: null
      };
    }
    function yi(o, d, S, L, $, ne, fe, Le) {
      o.allPendingTasks++, S === null ? o.pendingRootTasks++ : S.pendingTasks++;
      var Ke = {
        node: d,
        ping: function() {
          return _o(o, Ke);
        },
        blockedBoundary: S,
        blockedSegment: L,
        abortSet: $,
        legacyContext: ne,
        context: fe,
        treeContext: Le
      };
      return Ke.componentStack = null, $.add(Ke), Ke;
    }
    function Vr(o, d, S, L, $, ne) {
      return {
        status: No,
        id: -1,
        // lazily assigned later
        index: d,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: L,
        boundary: S,
        lastPushedText: $,
        textEmbedded: ne
      };
    }
    var Tr = null;
    function Vl() {
      return Tr === null || Tr.componentStack === null ? "" : Il(Tr.componentStack);
    }
    function hr(o, d) {
      o.componentStack = {
        tag: 0,
        parent: o.componentStack,
        type: d
      };
    }
    function _a(o, d) {
      o.componentStack = {
        tag: 1,
        parent: o.componentStack,
        type: d
      };
    }
    function jl(o, d) {
      o.componentStack = {
        tag: 2,
        parent: o.componentStack,
        type: d
      };
    }
    function mr(o) {
      o.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : o.componentStack = o.componentStack.parent;
    }
    var jr = null;
    function Ul(o, d) {
      {
        var S;
        typeof d == "string" ? S = d : d && typeof d.message == "string" ? S = d.message : S = String(d);
        var L = jr || Vl();
        jr = null, o.errorMessage = S, o.errorComponentStack = L;
      }
    }
    function gi(o, d) {
      var S = o.onError(d);
      if (S != null && typeof S != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof S + '" instead');
      return S;
    }
    function Oo(o, d) {
      var S = o.onShellError;
      S(d);
      var L = o.onFatalError;
      L(d), o.destination !== null ? (o.status = wr, T(o.destination, d)) : (o.status = ou, o.fatalError = d);
    }
    function lu(o, d, S) {
      hr(d, "Suspense");
      var L = d.blockedBoundary, $ = d.blockedSegment, ne = S.fallback, fe = S.children, Le = /* @__PURE__ */ new Set(), Ke = Nr(o, Le), it = $.chunks.length, dt = Vr(
        o,
        it,
        Ke,
        $.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      $.children.push(dt), $.lastPushedText = !1;
      var Ct = Vr(
        o,
        0,
        null,
        $.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      Ct.parentFlushed = !0, d.blockedBoundary = Ke, d.blockedSegment = Ct;
      try {
        if (Fo(o, d, fe), Fs(Ct.chunks, o.responseState, Ct.lastPushedText, Ct.textEmbedded), Ct.status = ua, bi(Ke, Ct), Ke.pendingTasks === 0) {
          mr(d);
          return;
        }
      } catch (Bn) {
        Ct.status = ca, Ke.forceClientRender = !0, Ke.errorDigest = gi(o, Bn), Ul(Ke, Bn);
      } finally {
        d.blockedBoundary = L, d.blockedSegment = $;
      }
      var cn = yi(o, ne, L, dt, Le, d.legacyContext, d.context, d.treeContext);
      cn.componentStack = d.componentStack, o.pingedTasks.push(cn), mr(d);
    }
    function su(o, d, S, L) {
      hr(d, S);
      var $ = d.blockedSegment, ne = br($.chunks, S, L, o.responseState, $.formatContext);
      $.lastPushedText = !1;
      var fe = $.formatContext;
      $.formatContext = jt(fe, S, L), Fo(o, d, ne), $.formatContext = fe, ar($.chunks, S), $.lastPushedText = !1, mr(d);
    }
    function Ed(o) {
      return o.prototype && o.prototype.isReactComponent;
    }
    function Kl(o, d, S, L, $) {
      var ne = {};
      $l(d, ne);
      var fe = S(L, $);
      return ud(S, L, fe, $);
    }
    function vi(o, d, S, L, $) {
      var ne = S.render();
      S.props !== $ && (Gl || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", hn(L) || "a component"), Gl = !0);
      {
        var fe = L.childContextTypes;
        if (fe != null) {
          var Le = d.legacyContext, Ke = na(S, L, Le, fe);
          d.legacyContext = Ke, ur(o, d, ne), d.legacyContext = Le;
          return;
        }
      }
      ur(o, d, ne);
    }
    function uu(o, d, S, L) {
      jl(d, S);
      var $ = Us(S, d.legacyContext), ne = ed(S, L, $);
      Eo(ne, S, L, $), vi(o, d, ne, S, L), mr(d);
    }
    var Yl = {}, xi = {}, Xl = {}, ql = {}, Gl = !1, cu = !1, du = !1, Zl = !1;
    function kd(o, d, S, L) {
      var $;
      if ($ = Us(S, d.legacyContext), _a(d, S), S.prototype && typeof S.prototype.render == "function") {
        var ne = hn(S) || "Unknown";
        Yl[ne] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", ne, ne), Yl[ne] = !0);
      }
      var fe = Kl(o, d, S, L, $), Le = Js();
      if (typeof fe == "object" && fe !== null && typeof fe.render == "function" && fe.$$typeof === void 0) {
        var Ke = hn(S) || "Unknown";
        xi[Ke] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ke, Ke, Ke), xi[Ke] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof fe == "object" && fe !== null && typeof fe.render == "function" && fe.$$typeof === void 0
      ) {
        {
          var it = hn(S) || "Unknown";
          xi[it] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", it, it, it), xi[it] = !0);
        }
        Eo(fe, S, L, $), vi(o, d, fe, S, L);
      } else if (wd(S), Le) {
        var dt = d.treeContext, Ct = 1, cn = 0;
        d.treeContext = Ml(dt, Ct, cn);
        try {
          ur(o, d, fe);
        } finally {
          d.treeContext = dt;
        }
      } else
        ur(o, d, fe);
      mr(d);
    }
    function wd(o) {
      {
        if (o && o.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", o.displayName || o.name || "Component"), typeof o.getDerivedStateFromProps == "function") {
          var d = hn(o) || "Unknown";
          ql[d] || (i("%s: Function components do not support getDerivedStateFromProps.", d), ql[d] = !0);
        }
        if (typeof o.contextType == "object" && o.contextType !== null) {
          var S = hn(o) || "Unknown";
          Xl[S] || (i("%s: Function components do not support contextType.", S), Xl[S] = !0);
        }
      }
    }
    function fu(o, d) {
      if (o && o.defaultProps) {
        var S = lr({}, d), L = o.defaultProps;
        for (var $ in L)
          S[$] === void 0 && (S[$] = L[$]);
        return S;
      }
      return d;
    }
    function Td(o, d, S, L, $) {
      _a(d, S.render);
      var ne = Kl(o, d, S.render, L, $), fe = Js();
      if (fe) {
        var Le = d.treeContext, Ke = 1, it = 0;
        d.treeContext = Ml(Le, Ke, it);
        try {
          ur(o, d, ne);
        } finally {
          d.treeContext = Le;
        }
      } else
        ur(o, d, ne);
      mr(d);
    }
    function Cd(o, d, S, L, $) {
      var ne = S.type, fe = fu(ne, L);
      Jl(o, d, ne, fe, $);
    }
    function Ql(o, d, S, L) {
      S._context === void 0 ? S !== S.Consumer && (Zl || (Zl = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : S = S._context;
      var $ = L.children;
      typeof $ != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var ne = Ra(S), fe = $(ne);
      ur(o, d, fe);
    }
    function Ad(o, d, S, L) {
      var $ = S._context, ne = L.value, fe = L.children, Le;
      Le = d.context, d.context = ui($, ne), ur(o, d, fe), d.context = Ol($), Le !== d.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function sr(o, d, S, L, $) {
      hr(d, "Lazy");
      var ne = S._payload, fe = S._init, Le = fe(ne), Ke = fu(Le, L);
      Jl(o, d, Le, Ke, $), mr(d);
    }
    function Jl(o, d, S, L, $) {
      if (typeof S == "function")
        if (Ed(S)) {
          uu(o, d, S, L);
          return;
        } else {
          kd(o, d, S, L);
          return;
        }
      if (typeof S == "string") {
        su(o, d, S, L);
        return;
      }
      switch (S) {
        case Gc:
        case $s:
        case ao:
        case io:
        case ro: {
          ur(o, d, L.children);
          return;
        }
        case gl: {
          hr(d, "SuspenseList"), ur(o, d, L.children), mr(d);
          return;
        }
        case qc:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Ca: {
          lu(o, d, L);
          return;
        }
      }
      if (typeof S == "object" && S !== null)
        switch (S.$$typeof) {
          case ti: {
            Td(o, d, S, L, $);
            return;
          }
          case vl: {
            Cd(o, d, S, L, $);
            return;
          }
          case Ja: {
            Ad(o, d, S, L);
            return;
          }
          case ei: {
            Ql(o, d, S, L);
            return;
          }
          case oo: {
            sr(o, d, S, L);
            return;
          }
        }
      var ne = "";
      throw (S === void 0 || typeof S == "object" && S !== null && Object.keys(S).length === 0) && (ne += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (S == null ? S : typeof S) + "." + ne));
    }
    function pu(o, d) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      o[Symbol.toStringTag] === "Generator" && (cu || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), cu = !0), o.entries === d && (du || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), du = !0);
    }
    function ur(o, d, S) {
      try {
        return es(o, d, S);
      } catch (L) {
        throw typeof L == "object" && L !== null && typeof L.then == "function" || (jr = jr !== null ? jr : Vl()), L;
      }
    }
    function es(o, d, S) {
      if (d.node = S, typeof S == "object" && S !== null) {
        switch (S.$$typeof) {
          case zs: {
            var L = S, $ = L.type, ne = L.props, fe = L.ref;
            Jl(o, d, $, ne, fe);
            return;
          }
          case yl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case oo: {
            var Le = S, Ke = Le._payload, it = Le._init, dt;
            try {
              dt = it(Ke);
            } catch (Io) {
              throw typeof Io == "object" && Io !== null && typeof Io.then == "function" && hr(d, "Lazy"), Io;
            }
            ur(o, d, dt);
            return;
          }
        }
        if (En(S)) {
          hu(o, d, S);
          return;
        }
        var Ct = vn(S);
        if (Ct) {
          pu(S, Ct);
          var cn = Ct.call(S);
          if (cn) {
            var Bn = cn.next();
            if (!Bn.done) {
              var yr = [];
              do
                yr.push(Bn.value), Bn = cn.next();
              while (!Bn.done);
              hu(o, d, yr);
              return;
            }
            return;
          }
        }
        var xu = Object.prototype.toString.call(S);
        throw new Error("Objects are not valid as a React child (found: " + (xu === "[object Object]" ? "object with keys {" + Object.keys(S).join(", ") + "}" : xu) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof S == "string") {
        var bu = d.blockedSegment;
        bu.lastPushedText = Os(d.blockedSegment.chunks, S, o.responseState, bu.lastPushedText);
        return;
      }
      if (typeof S == "number") {
        var Su = d.blockedSegment;
        Su.lastPushedText = Os(d.blockedSegment.chunks, "" + S, o.responseState, Su.lastPushedText);
        return;
      }
      typeof S == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function hu(o, d, S) {
      for (var L = S.length, $ = 0; $ < L; $++) {
        var ne = d.treeContext;
        d.treeContext = Ml(ne, L, $);
        try {
          Fo(o, d, S[$]);
        } finally {
          d.treeContext = ne;
        }
      }
    }
    function Ld(o, d, S) {
      var L = d.blockedSegment, $ = L.chunks.length, ne = Vr(
        o,
        $,
        null,
        L.formatContext,
        // Adopt the parent segment's leading text embed
        L.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      L.children.push(ne), L.lastPushedText = !1;
      var fe = yi(o, d.node, d.blockedBoundary, ne, d.abortSet, d.legacyContext, d.context, d.treeContext);
      d.componentStack !== null && (fe.componentStack = d.componentStack.parent);
      var Le = fe.ping;
      S.then(Le, Le);
    }
    function Fo(o, d, S) {
      var L = d.blockedSegment.formatContext, $ = d.legacyContext, ne = d.context, fe = null;
      fe = d.componentStack;
      try {
        return ur(o, d, S);
      } catch (Le) {
        if (fi(), typeof Le == "object" && Le !== null && typeof Le.then == "function") {
          Ld(o, d, Le), d.blockedSegment.formatContext = L, d.legacyContext = $, d.context = ne, po(ne), d.componentStack = fe;
          return;
        } else
          throw d.blockedSegment.formatContext = L, d.legacyContext = $, d.context = ne, po(ne), d.componentStack = fe, Le;
      }
    }
    function Mo(o, d, S, L) {
      var $ = gi(o, L);
      if (d === null ? Oo(o, L) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = $, Ul(d, L), d.parentFlushed && o.clientRenderedBoundaries.push(d))), o.allPendingTasks--, o.allPendingTasks === 0) {
        var ne = o.onAllReady;
        ne();
      }
    }
    function mu(o) {
      var d = this, S = o.blockedBoundary, L = o.blockedSegment;
      L.status = Hl, Si(d, S, L);
    }
    function yu(o, d, S) {
      var L = o.blockedBoundary, $ = o.blockedSegment;
      if ($.status = Hl, L === null)
        d.allPendingTasks--, d.status !== wr && (d.status = wr, d.destination !== null && v(d.destination));
      else {
        if (L.pendingTasks--, !L.forceClientRender) {
          L.forceClientRender = !0;
          var ne = S === void 0 ? new Error("The render was aborted by the server without a reason.") : S;
          L.errorDigest = d.onError(ne);
          {
            var fe = "The server did not finish this Suspense boundary: ";
            ne && typeof ne.message == "string" ? ne = fe + ne.message : ne = fe + String(ne);
            var Le = Tr;
            Tr = o;
            try {
              Ul(L, ne);
            } finally {
              Tr = Le;
            }
          }
          L.parentFlushed && d.clientRenderedBoundaries.push(L);
        }
        if (L.fallbackAbortableTasks.forEach(function(it) {
          return yu(it, d, S);
        }), L.fallbackAbortableTasks.clear(), d.allPendingTasks--, d.allPendingTasks === 0) {
          var Ke = d.onAllReady;
          Ke();
        }
      }
    }
    function bi(o, d) {
      if (d.chunks.length === 0 && d.children.length === 1 && d.children[0].boundary === null) {
        var S = d.children[0];
        S.id = d.id, S.parentFlushed = !0, S.status === ua && bi(o, S);
      } else {
        var L = o.completedSegments;
        L.push(d);
      }
    }
    function Si(o, d, S) {
      if (d === null) {
        if (S.parentFlushed) {
          if (o.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          o.completedRootSegment = S;
        }
        if (o.pendingRootTasks--, o.pendingRootTasks === 0) {
          o.onShellError = mi;
          var L = o.onShellReady;
          L();
        }
      } else if (d.pendingTasks--, !d.forceClientRender) {
        if (d.pendingTasks === 0)
          S.parentFlushed && S.status === ua && bi(d, S), d.parentFlushed && o.completedBoundaries.push(d), d.fallbackAbortableTasks.forEach(mu, o), d.fallbackAbortableTasks.clear();
        else if (S.parentFlushed && S.status === ua) {
          bi(d, S);
          var $ = d.completedSegments;
          $.length === 1 && d.parentFlushed && o.partialBoundaries.push(d);
        }
      }
      if (o.allPendingTasks--, o.allPendingTasks === 0) {
        var ne = o.onAllReady;
        ne();
      }
    }
    function zo(o, d) {
      var S = d.blockedSegment;
      if (S.status === No) {
        po(d.context);
        var L = null;
        L = Tr, Tr = d;
        try {
          ur(o, d, d.node), Fs(S.chunks, o.responseState, S.lastPushedText, S.textEmbedded), d.abortSet.delete(d), S.status = ua, Si(o, d.blockedBoundary, S);
        } catch (ne) {
          if (fi(), typeof ne == "object" && ne !== null && typeof ne.then == "function") {
            var $ = d.ping;
            ne.then($, $);
          } else
            d.abortSet.delete(d), S.status = ca, Mo(o, d.blockedBoundary, S, ne);
        } finally {
          Tr = L;
        }
      }
    }
    function gu(o) {
      if (o.status !== wr) {
        var d = Qc(), S = Wr.current;
        Wr.current = au;
        var L;
        L = Do.getCurrentStack, Do.getCurrentStack = Vl;
        var $ = hi;
        Ro(o.responseState);
        try {
          var ne = o.pingedTasks, fe;
          for (fe = 0; fe < ne.length; fe++) {
            var Le = ne[fe];
            zo(o, Le);
          }
          ne.splice(0, fe), o.destination !== null && Bo(o, o.destination);
        } catch (Ke) {
          gi(o, Ke), Oo(o, Ke);
        } finally {
          Ro($), Wr.current = S, Do.getCurrentStack = L, S === au && po(d);
        }
      }
    }
    function Ei(o, d, S) {
      switch (S.parentFlushed = !0, S.status) {
        case No: {
          var L = S.id = o.nextSegmentId++;
          return S.lastPushedText = !1, S.textEmbedded = !1, ji(d, o.responseState, L);
        }
        case ua: {
          S.status = iu;
          for (var $ = !0, ne = S.chunks, fe = 0, Le = S.children, Ke = 0; Ke < Le.length; Ke++) {
            for (var it = Le[Ke]; fe < it.index; fe++)
              u(d, ne[fe]);
            $ = ki(o, d, it);
          }
          for (; fe < ne.length - 1; fe++)
            u(d, ne[fe]);
          return fe < ne.length && ($ = m(d, ne[fe])), $;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function ki(o, d, S) {
      var L = S.boundary;
      if (L === null)
        return Ei(o, d, S);
      if (L.parentFlushed = !0, L.forceClientRender)
        return fr(d, o.responseState, L.errorDigest, L.errorMessage, L.errorComponentStack), Ei(o, d, S), Ms(d, o.responseState);
      if (L.pendingTasks > 0) {
        L.rootSegmentID = o.nextSegmentId++, L.completedSegments.length > 0 && o.partialBoundaries.push(L);
        var $ = L.id = kt(o.responseState);
        return Ir(d, o.responseState, $), Ei(o, d, S), Ga(d, o.responseState);
      } else {
        if (L.byteSize > o.progressiveChunkSize)
          return L.rootSegmentID = o.nextSegmentId++, o.completedBoundaries.push(L), Ir(d, o.responseState, L.id), Ei(o, d, S), Ga(d, o.responseState);
        ml(d, o.responseState);
        var ne = L.completedSegments;
        if (ne.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var fe = ne[0];
        return ki(o, d, fe), Xc(d, o.responseState);
      }
    }
    function Pd(o, d, S) {
      return Uc(d, o.responseState, S.id, S.errorDigest, S.errorMessage, S.errorComponentStack);
    }
    function ts(o, d, S) {
      return ke(d, o.responseState, S.formatContext, S.id), ki(o, d, S), Be(d, S.formatContext);
    }
    function $o(o, d, S) {
      for (var L = S.completedSegments, $ = 0; $ < L.length; $++) {
        var ne = L[$];
        vu(o, d, S, ne);
      }
      return L.length = 0, Ic(d, o.responseState, S.id, S.rootSegmentID);
    }
    function Rd(o, d, S) {
      for (var L = S.completedSegments, $ = 0; $ < L.length; $++) {
        var ne = L[$];
        if (!vu(o, d, S, ne))
          return $++, L.splice(0, $), !1;
      }
      return L.splice(0, $), !0;
    }
    function vu(o, d, S, L) {
      if (L.status === iu)
        return !0;
      var $ = L.id;
      if ($ === -1) {
        var ne = L.id = S.rootSegmentID;
        if (ne === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return ts(o, d, L);
      } else
        return ts(o, d, L), or(d, o.responseState, $);
    }
    function Bo(o, d) {
      try {
        var S = o.completedRootSegment;
        S !== null && o.pendingRootTasks === 0 && (ki(o, d, S), o.completedRootSegment = null, Ka(d, o.responseState));
        var L = o.clientRenderedBoundaries, $;
        for ($ = 0; $ < L.length; $++) {
          var ne = L[$];
          if (!Pd(o, d, ne)) {
            o.destination = null, $++, L.splice(0, $);
            return;
          }
        }
        L.splice(0, $);
        var fe = o.completedBoundaries;
        for ($ = 0; $ < fe.length; $++) {
          var Le = fe[$];
          if (!$o(o, d, Le)) {
            o.destination = null, $++, fe.splice(0, $);
            return;
          }
        }
        fe.splice(0, $);
        var Ke = o.partialBoundaries;
        for ($ = 0; $ < Ke.length; $++) {
          var it = Ke[$];
          if (!Rd(o, d, it)) {
            o.destination = null, $++, Ke.splice(0, $);
            return;
          }
        }
        Ke.splice(0, $);
        var dt = o.completedBoundaries;
        for ($ = 0; $ < dt.length; $++) {
          var Ct = dt[$];
          if (!$o(o, d, Ct)) {
            o.destination = null, $++, dt.splice(0, $);
            return;
          }
        }
        dt.splice(0, $);
      } finally {
        o.allPendingTasks === 0 && o.pingedTasks.length === 0 && o.clientRenderedBoundaries.length === 0 && o.completedBoundaries.length === 0 && (o.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), v(d));
      }
    }
    function Dd(o) {
      c(function() {
        return gu(o);
      });
    }
    function s(o, d) {
      if (o.status === ou) {
        o.status = wr, T(d, o.fatalError);
        return;
      }
      if (o.status !== wr && o.destination === null) {
        o.destination = d;
        try {
          Bo(o, d);
        } catch (S) {
          gi(o, S), Oo(o, S);
        }
      }
    }
    function h(o, d) {
      try {
        var S = o.abortableTasks;
        S.forEach(function(L) {
          return yu(L, o, d);
        }), S.clear(), o.destination !== null && Bo(o, o.destination);
      } catch (L) {
        gi(o, L), Oo(o, L);
      }
    }
    function k() {
    }
    function O(o, d, S, L) {
      var $ = !1, ne = null, fe = "", Le = {
        push: function(Ct) {
          return Ct !== null && (fe += Ct), !0;
        },
        destroy: function(Ct) {
          $ = !0, ne = Ct;
        }
      }, Ke = !1;
      function it() {
        Ke = !0;
      }
      var dt = Wl(o, Yc(S, d ? d.identifierPrefix : void 0), hl(), 1 / 0, k, void 0, it, void 0, void 0);
      if (Dd(dt), h(dt, L), s(dt, Le), $)
        throw ne;
      if (!Ke)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return fe;
    }
    function Y(o, d) {
      return O(o, d, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function oe(o, d) {
      return O(o, d, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function he() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Pe() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Ri.renderToNodeStream = he, Ri.renderToStaticMarkup = oe, Ri.renderToStaticNodeStream = Pe, Ri.renderToString = Y, Ri.version = t;
  }()), Ri;
}
var Mu = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Kh;
function cE() {
  return Kh || (Kh = 1, process.env.NODE_ENV !== "production" && function() {
    var e = le, t = "18.2.0", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(s) {
      {
        for (var h = arguments.length, k = new Array(h > 1 ? h - 1 : 0), O = 1; O < h; O++)
          k[O - 1] = arguments[O];
        l("warn", s, k);
      }
    }
    function i(s) {
      {
        for (var h = arguments.length, k = new Array(h > 1 ? h - 1 : 0), O = 1; O < h; O++)
          k[O - 1] = arguments[O];
        l("error", s, k);
      }
    }
    function l(s, h, k) {
      {
        var O = n.ReactDebugCurrentFrame, Y = O.getStackAddendum();
        Y !== "" && (h += "%s", k = k.concat([Y]));
        var oe = k.map(function(he) {
          return String(he);
        });
        oe.unshift("Warning: " + h), Function.prototype.apply.call(console[s], console, oe);
      }
    }
    function c(s) {
      s();
    }
    var f = 512, u = null, m = 0;
    function y(s) {
      u = new Uint8Array(f), m = 0;
    }
    function v(s, h) {
      if (h.length !== 0) {
        if (h.length > f) {
          m > 0 && (s.enqueue(new Uint8Array(u.buffer, 0, m)), u = new Uint8Array(f), m = 0), s.enqueue(h);
          return;
        }
        var k = h, O = u.length - m;
        O < k.length && (O === 0 ? s.enqueue(u) : (u.set(k.subarray(0, O), m), s.enqueue(u), k = k.subarray(O)), u = new Uint8Array(f), m = 0), u.set(k, m), m += k.length;
      }
    }
    function x(s, h) {
      return v(s, h), !0;
    }
    function A(s) {
      u && m > 0 && (s.enqueue(new Uint8Array(u.buffer, 0, m)), u = null, m = 0);
    }
    function T(s) {
      s.close();
    }
    var M = new TextEncoder();
    function E(s) {
      return M.encode(s);
    }
    function p(s) {
      return M.encode(s);
    }
    function C(s, h) {
      typeof s.error == "function" ? s.error(h) : s.close();
    }
    function _(s) {
      {
        var h = typeof Symbol == "function" && Symbol.toStringTag, k = h && s[Symbol.toStringTag] || s.constructor.name || "Object";
        return k;
      }
    }
    function w(s) {
      try {
        return R(s), !1;
      } catch {
        return !0;
      }
    }
    function R(s) {
      return "" + s;
    }
    function P(s, h) {
      if (w(s))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", h, _(s)), R(s);
    }
    function z(s, h) {
      if (w(s))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", h, _(s)), R(s);
    }
    function q(s) {
      if (w(s))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", _(s)), R(s);
    }
    var V = Object.prototype.hasOwnProperty, G = 0, ee = 1, W = 2, Q = 3, j = 4, te = 5, se = 6, re = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ae = re + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", K = new RegExp("^[" + re + "][" + ae + "]*$"), U = {}, X = {};
    function H(s) {
      return V.call(X, s) ? !0 : V.call(U, s) ? !1 : K.test(s) ? (X[s] = !0, !0) : (U[s] = !0, i("Invalid attribute name: `%s`", s), !1);
    }
    function Te(s, h, k, O) {
      if (k !== null && k.type === G)
        return !1;
      switch (typeof h) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (O)
            return !1;
          if (k !== null)
            return !k.acceptsBooleans;
          var Y = s.toLowerCase().slice(0, 5);
          return Y !== "data-" && Y !== "aria-";
        }
        default:
          return !1;
      }
    }
    function be(s) {
      return Re.hasOwnProperty(s) ? Re[s] : null;
    }
    function ce(s, h, k, O, Y, oe, he) {
      this.acceptsBooleans = h === W || h === Q || h === j, this.attributeName = O, this.attributeNamespace = Y, this.mustUseProperty = k, this.propertyName = s, this.type = h, this.sanitizeURL = oe, this.removeEmptyString = he;
    }
    var Re = {}, He = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    He.forEach(function(s) {
      Re[s] = new ce(
        s,
        G,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(s) {
      var h = s[0], k = s[1];
      Re[h] = new ce(
        h,
        ee,
        !1,
        // mustUseProperty
        k,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
      Re[s] = new ce(
        s,
        W,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
      Re[s] = new ce(
        s,
        W,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(s) {
      Re[s] = new ce(
        s,
        Q,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      Re[s] = new ce(
        s,
        Q,
        !0,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      Re[s] = new ce(
        s,
        j,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      Re[s] = new ce(
        s,
        se,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(s) {
      Re[s] = new ce(
        s,
        te,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Ge = /[\-\:]([a-z])/g, Ne = function(s) {
      return s[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var h = s.replace(Ge, Ne);
      Re[h] = new ce(
        h,
        ee,
        !1,
        // mustUseProperty
        s,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var h = s.replace(Ge, Ne);
      Re[h] = new ce(
        h,
        ee,
        !1,
        // mustUseProperty
        s,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var h = s.replace(Ge, Ne);
      Re[h] = new ce(
        h,
        ee,
        !1,
        // mustUseProperty
        s,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(s) {
      Re[s] = new ce(
        s,
        ee,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ye = "xlinkHref";
    Re[ye] = new ce(
      "xlinkHref",
      ee,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(s) {
      Re[s] = new ce(
        s,
        ee,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Oe = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function ue(s, h) {
      return s + h.charAt(0).toUpperCase() + h.substring(1);
    }
    var ie = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Oe).forEach(function(s) {
      ie.forEach(function(h) {
        Oe[ue(h, s)] = Oe[s];
      });
    });
    var Ce = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function $e(s, h) {
      Ce[h.type] || h.onChange || h.onInput || h.readOnly || h.disabled || h.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), h.onChange || h.readOnly || h.disabled || h.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ve(s, h) {
      if (s.indexOf("-") === -1)
        return typeof h.is == "string";
      switch (s) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Ee = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ue = {}, ft = new RegExp("^(aria)-[" + ae + "]*$"), Qe = new RegExp("^(aria)[A-Z][" + ae + "]*$");
    function We(s, h) {
      {
        if (V.call(Ue, h) && Ue[h])
          return !0;
        if (Qe.test(h)) {
          var k = "aria-" + h.slice(4).toLowerCase(), O = Ee.hasOwnProperty(k) ? k : null;
          if (O == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", h), Ue[h] = !0, !0;
          if (h !== O)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", h, O), Ue[h] = !0, !0;
        }
        if (ft.test(h)) {
          var Y = h.toLowerCase(), oe = Ee.hasOwnProperty(Y) ? Y : null;
          if (oe == null)
            return Ue[h] = !0, !1;
          if (h !== oe)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", h, oe), Ue[h] = !0, !0;
        }
      }
      return !0;
    }
    function Ie(s, h) {
      {
        var k = [];
        for (var O in h) {
          var Y = We(s, O);
          Y || k.push(O);
        }
        var oe = k.map(function(he) {
          return "`" + he + "`";
        }).join(", ");
        k.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", oe, s) : k.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", oe, s);
      }
    }
    function Me(s, h) {
      Ve(s, h) || Ie(s, h);
    }
    var tt = !1;
    function Ze(s, h) {
      {
        if (s !== "input" && s !== "textarea" && s !== "select")
          return;
        h != null && h.value === null && !tt && (tt = !0, s === "select" && h.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", s) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", s));
      }
    }
    var et = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, at = function() {
    };
    {
      var gt = {}, Ot = /^on./, Kt = /^on[^A-Z]/, on = new RegExp("^(aria)-[" + ae + "]*$"), Wt = new RegExp("^(aria)[A-Z][" + ae + "]*$");
      at = function(s, h, k, O) {
        if (V.call(gt, h) && gt[h])
          return !0;
        var Y = h.toLowerCase();
        if (Y === "onfocusin" || Y === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), gt[h] = !0, !0;
        if (O != null) {
          var oe = O.registrationNameDependencies, he = O.possibleRegistrationNames;
          if (oe.hasOwnProperty(h))
            return !0;
          var Pe = he.hasOwnProperty(Y) ? he[Y] : null;
          if (Pe != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", h, Pe), gt[h] = !0, !0;
          if (Ot.test(h))
            return i("Unknown event handler property `%s`. It will be ignored.", h), gt[h] = !0, !0;
        } else if (Ot.test(h))
          return Kt.test(h) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", h), gt[h] = !0, !0;
        if (on.test(h) || Wt.test(h))
          return !0;
        if (Y === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), gt[h] = !0, !0;
        if (Y === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), gt[h] = !0, !0;
        if (Y === "is" && k !== null && k !== void 0 && typeof k != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof k), gt[h] = !0, !0;
        if (typeof k == "number" && isNaN(k))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", h), gt[h] = !0, !0;
        var o = be(h), d = o !== null && o.type === G;
        if (et.hasOwnProperty(Y)) {
          var S = et[Y];
          if (S !== h)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", h, S), gt[h] = !0, !0;
        } else if (!d && h !== Y)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", h, Y), gt[h] = !0, !0;
        return typeof k == "boolean" && Te(h, k, o, !1) ? (k ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', k, h, h, k, h) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', k, h, h, k, h, h, h), gt[h] = !0, !0) : d ? !0 : Te(h, k, o, !1) ? (gt[h] = !0, !1) : ((k === "false" || k === "true") && o !== null && o.type === Q && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", k, h, k === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', h, k), gt[h] = !0), !0);
      };
    }
    var Zt = function(s, h, k) {
      {
        var O = [];
        for (var Y in h) {
          var oe = at(s, Y, h[Y], k);
          oe || O.push(Y);
        }
        var he = O.map(function(Pe) {
          return "`" + Pe + "`";
        }).join(", ");
        O.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, s) : O.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", he, s);
      }
    };
    function zt(s, h, k) {
      Ve(s, h) || Zt(s, h, k);
    }
    var fn = function() {
    };
    {
      var Yt = /^(?:webkit|moz|o)[A-Z]/, tn = /^-ms-/, kn = /-(.)/g, ot = /;\s*$/, _e = {}, $t = {}, Lt = !1, nn = !1, un = function(s) {
        return s.replace(kn, function(h, k) {
          return k.toUpperCase();
        });
      }, At = function(s) {
        _e.hasOwnProperty(s) && _e[s] || (_e[s] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          s,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          un(s.replace(tn, "ms-"))
        ));
      }, rn = function(s) {
        _e.hasOwnProperty(s) && _e[s] || (_e[s] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", s, s.charAt(0).toUpperCase() + s.slice(1)));
      }, ln = function(s, h) {
        $t.hasOwnProperty(h) && $t[h] || ($t[h] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, s, h.replace(ot, "")));
      }, Ln = function(s, h) {
        Lt || (Lt = !0, i("`NaN` is an invalid value for the `%s` css style property.", s));
      }, qt = function(s, h) {
        nn || (nn = !0, i("`Infinity` is an invalid value for the `%s` css style property.", s));
      };
      fn = function(s, h) {
        s.indexOf("-") > -1 ? At(s) : Yt.test(s) ? rn(s) : ot.test(h) && ln(s, h), typeof h == "number" && (isNaN(h) ? Ln(s, h) : isFinite(h) || qt(s, h));
      };
    }
    var mn = fn, Hn = /["'&<>]/;
    function Pn(s) {
      q(s);
      var h = "" + s, k = Hn.exec(h);
      if (!k)
        return h;
      var O, Y = "", oe, he = 0;
      for (oe = k.index; oe < h.length; oe++) {
        switch (h.charCodeAt(oe)) {
          case 34:
            O = "&quot;";
            break;
          case 38:
            O = "&amp;";
            break;
          case 39:
            O = "&#x27;";
            break;
          case 60:
            O = "&lt;";
            break;
          case 62:
            O = "&gt;";
            break;
          default:
            continue;
        }
        he !== oe && (Y += h.substring(he, oe)), he = oe + 1, Y += O;
      }
      return he !== oe ? Y + h.substring(he, oe) : Y;
    }
    function Vt(s) {
      return typeof s == "boolean" || typeof s == "number" ? "" + s : Pn(s);
    }
    var wn = /([A-Z])/g, tr = /^ms-/;
    function nr(s) {
      return s.replace(wn, "-$1").toLowerCase().replace(tr, "-ms-");
    }
    var En = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Tn = !1;
    function Mn(s) {
      !Tn && En.test(s) && (Tn = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(s)));
    }
    var Kn = Array.isArray;
    function zn(s) {
      return Kn(s);
    }
    var Rn = p("<script>"), Wn = p("<\/script>"), F = p('<script src="'), Ae = p('<script type="module" src="'), ze = p('" async=""><\/script>');
    function xe(s) {
      return q(s), ("" + s).replace(lt, nt);
    }
    var lt = /(<\/|<)(s)(cript)/gi, nt = function(s, h, k, O) {
      return "" + h + (k === "s" ? "\\u0073" : "\\u0053") + O;
    };
    function mt(s, h, k, O, Y) {
      var oe = s === void 0 ? "" : s, he = h === void 0 ? Rn : p('<script nonce="' + Vt(h) + '">'), Pe = [];
      if (k !== void 0 && Pe.push(he, E(xe(k)), Wn), O !== void 0)
        for (var o = 0; o < O.length; o++)
          Pe.push(F, E(Vt(O[o])), ze);
      if (Y !== void 0)
        for (var d = 0; d < Y.length; d++)
          Pe.push(Ae, E(Vt(Y[d])), ze);
      return {
        bootstrapChunks: Pe,
        startInlineScript: he,
        placeholderPrefix: p(oe + "P:"),
        segmentPrefix: p(oe + "S:"),
        boundaryPrefix: oe + "B:",
        idPrefix: oe,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var ht = 0, je = 1, yt = 2, Tt = 3, Rt = 4, jt = 5, wt = 6, kt = 7;
    function Ft(s, h) {
      return {
        insertionMode: s,
        selectedValue: h
      };
    }
    function Ut(s) {
      var h = s === "http://www.w3.org/2000/svg" ? yt : s === "http://www.w3.org/1998/Math/MathML" ? Tt : ht;
      return Ft(h, null);
    }
    function Et(s, h, k) {
      switch (h) {
        case "select":
          return Ft(je, k.value != null ? k.value : k.defaultValue);
        case "svg":
          return Ft(yt, null);
        case "math":
          return Ft(Tt, null);
        case "foreignObject":
          return Ft(je, null);
        case "table":
          return Ft(Rt, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return Ft(jt, null);
        case "colgroup":
          return Ft(kt, null);
        case "tr":
          return Ft(wt, null);
      }
      return s.insertionMode >= Rt || s.insertionMode === ht ? Ft(je, null) : s;
    }
    var xn = null;
    function pn(s) {
      var h = s.nextSuspenseID++;
      return p(s.boundaryPrefix + h.toString(16));
    }
    function sn(s, h, k) {
      var O = s.idPrefix, Y = ":" + O + "R" + h;
      return k > 0 && (Y += "H" + k.toString(32)), Y + ":";
    }
    function yn(s) {
      return Vt(s);
    }
    var Qt = p("<!-- -->");
    function gn(s, h, k, O) {
      return h === "" ? O : (O && s.push(Qt), s.push(E(yn(h))), !0);
    }
    function Vn(s, h, k, O) {
      k && O && s.push(Qt);
    }
    var g = /* @__PURE__ */ new Map();
    function D(s) {
      var h = g.get(s);
      if (h !== void 0)
        return h;
      var k = p(Vt(nr(s)));
      return g.set(s, k), k;
    }
    var B = p(' style="'), Z = p(":"), Se = p(";");
    function ve(s, h, k) {
      if (typeof k != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var O = !0;
      for (var Y in k)
        if (V.call(k, Y)) {
          var oe = k[Y];
          if (!(oe == null || typeof oe == "boolean" || oe === "")) {
            var he = void 0, Pe = void 0, o = Y.indexOf("--") === 0;
            o ? (he = E(Vt(Y)), z(oe, Y), Pe = E(Vt(("" + oe).trim()))) : (mn(Y, oe), he = D(Y), typeof oe == "number" ? oe !== 0 && !V.call(Oe, Y) ? Pe = E(oe + "px") : Pe = E("" + oe) : (z(oe, Y), Pe = E(Vt(("" + oe).trim())))), O ? (O = !1, s.push(B, he, Z, Pe)) : s.push(Se, he, Z, Pe);
          }
        }
      O || s.push(ut);
    }
    var De = p(" "), Xe = p('="'), ut = p('"'), vt = p('=""');
    function pt(s, h, k, O) {
      switch (k) {
        case "style": {
          ve(s, h, O);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(k.length > 2 && (k[0] === "o" || k[0] === "O") && (k[1] === "n" || k[1] === "N"))
      ) {
        var Y = be(k);
        if (Y !== null) {
          switch (typeof O) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!Y.acceptsBooleans)
                return;
          }
          var oe = Y.attributeName, he = E(oe);
          switch (Y.type) {
            case Q:
              O && s.push(De, he, vt);
              return;
            case j:
              O === !0 ? s.push(De, he, vt) : O === !1 || s.push(De, he, Xe, E(Vt(O)), ut);
              return;
            case te:
              isNaN(O) || s.push(De, he, Xe, E(Vt(O)), ut);
              break;
            case se:
              !isNaN(O) && O >= 1 && s.push(De, he, Xe, E(Vt(O)), ut);
              break;
            default:
              Y.sanitizeURL && (P(O, oe), O = "" + O, Mn(O)), s.push(De, he, Xe, E(Vt(O)), ut);
          }
        } else if (H(k)) {
          switch (typeof O) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Pe = k.toLowerCase().slice(0, 5);
              if (Pe !== "data-" && Pe !== "aria-")
                return;
            }
          }
          s.push(De, E(k), Xe, E(Vt(O)), ut);
        }
      }
    }
    var Mt = p(">"), Dn = p("/>");
    function pe(s, h, k) {
      if (h != null) {
        if (k != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof h != "object" || !("__html" in h))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var O = h.__html;
        O != null && (q(O), s.push(E("" + O)));
      }
    }
    var de = !1, ge = !1, Fe = !1, Nt = !1, bn = !1, jn = !1, Gn = !1;
    function rr(s, h) {
      {
        var k = s[h];
        if (k != null) {
          var O = zn(k);
          s.multiple && !O ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", h) : !s.multiple && O && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", h);
        }
      }
    }
    function il(s, h, k) {
      $e("select", h), rr(h, "value"), rr(h, "defaultValue"), h.value !== void 0 && h.defaultValue !== void 0 && !Fe && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Fe = !0), s.push(ar("select"));
      var O = null, Y = null;
      for (var oe in h)
        if (V.call(h, oe)) {
          var he = h[oe];
          if (he == null)
            continue;
          switch (oe) {
            case "children":
              O = he;
              break;
            case "dangerouslySetInnerHTML":
              Y = he;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              pt(s, k, oe, he);
              break;
          }
        }
      return s.push(Mt), pe(s, Y, O), O;
    }
    function ol(s) {
      var h = "";
      return e.Children.forEach(s, function(k) {
        k != null && (h += k, !bn && typeof k != "string" && typeof k != "number" && (bn = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), h;
    }
    var ja = p(' selected=""');
    function ll(s, h, k, O) {
      var Y = O.selectedValue;
      s.push(ar("option"));
      var oe = null, he = null, Pe = null, o = null;
      for (var d in h)
        if (V.call(h, d)) {
          var S = h[d];
          if (S == null)
            continue;
          switch (d) {
            case "children":
              oe = S;
              break;
            case "selected":
              Pe = S, Gn || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Gn = !0);
              break;
            case "dangerouslySetInnerHTML":
              o = S;
              break;
            case "value":
              he = S;
            default:
              pt(s, k, d, S);
              break;
          }
        }
      if (Y != null) {
        var L;
        if (he !== null ? (P(he, "value"), L = "" + he) : (o !== null && (jn || (jn = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), L = ol(oe)), zn(Y))
          for (var $ = 0; $ < Y.length; $++) {
            P(Y[$], "value");
            var ne = "" + Y[$];
            if (ne === L) {
              s.push(ja);
              break;
            }
          }
        else
          P(Y, "select.value"), "" + Y === L && s.push(ja);
      } else
        Pe && s.push(ja);
      return s.push(Mt), pe(s, o, oe), oe;
    }
    function Ua(s, h, k) {
      $e("input", h), h.checked !== void 0 && h.defaultChecked !== void 0 && !ge && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), ge = !0), h.value !== void 0 && h.defaultValue !== void 0 && !de && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), de = !0), s.push(ar("input"));
      var O = null, Y = null, oe = null, he = null;
      for (var Pe in h)
        if (V.call(h, Pe)) {
          var o = h[Pe];
          if (o == null)
            continue;
          switch (Pe) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              he = o;
              break;
            case "defaultValue":
              Y = o;
              break;
            case "checked":
              oe = o;
              break;
            case "value":
              O = o;
              break;
            default:
              pt(s, k, Pe, o);
              break;
          }
        }
      return oe !== null ? pt(s, k, "checked", oe) : he !== null && pt(s, k, "checked", he), O !== null ? pt(s, k, "value", O) : Y !== null && pt(s, k, "value", Y), s.push(Dn), null;
    }
    function gr(s, h, k) {
      $e("textarea", h), h.value !== void 0 && h.defaultValue !== void 0 && !Nt && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Nt = !0), s.push(ar("textarea"));
      var O = null, Y = null, oe = null;
      for (var he in h)
        if (V.call(h, he)) {
          var Pe = h[he];
          if (Pe == null)
            continue;
          switch (he) {
            case "children":
              oe = Pe;
              break;
            case "value":
              O = Pe;
              break;
            case "defaultValue":
              Y = Pe;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              pt(s, k, he, Pe);
              break;
          }
        }
      if (O === null && Y !== null && (O = Y), s.push(Mt), oe != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), O != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (zn(oe)) {
          if (oe.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          q(oe[0]), O = "" + oe[0];
        }
        q(oe), O = "" + oe;
      }
      return typeof O == "string" && O[0] === `
` && s.push(Lr), O !== null && (P(O, "value"), s.push(E(yn("" + O)))), null;
    }
    function Qr(s, h, k, O) {
      s.push(ar(k));
      for (var Y in h)
        if (V.call(h, Y)) {
          var oe = h[Y];
          if (oe == null)
            continue;
          switch (Y) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(k + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              pt(s, O, Y, oe);
              break;
          }
        }
      return s.push(Dn), null;
    }
    function ha(s, h, k) {
      s.push(ar("menuitem"));
      for (var O in h)
        if (V.call(h, O)) {
          var Y = h[O];
          if (Y == null)
            continue;
          switch (O) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              pt(s, k, O, Y);
              break;
          }
        }
      return s.push(Mt), null;
    }
    function Jt(s, h, k) {
      s.push(ar("title"));
      var O = null;
      for (var Y in h)
        if (V.call(h, Y)) {
          var oe = h[Y];
          if (oe == null)
            continue;
          switch (Y) {
            case "children":
              O = oe;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              pt(s, k, Y, oe);
              break;
          }
        }
      s.push(Mt);
      {
        var he = Array.isArray(O) && O.length < 2 ? O[0] || null : O;
        Array.isArray(O) && O.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && he.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : he != null && typeof he != "string" && typeof he != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return O;
    }
    function xr(s, h, k, O) {
      s.push(ar(k));
      var Y = null, oe = null;
      for (var he in h)
        if (V.call(h, he)) {
          var Pe = h[he];
          if (Pe == null)
            continue;
          switch (he) {
            case "children":
              Y = Pe;
              break;
            case "dangerouslySetInnerHTML":
              oe = Pe;
              break;
            default:
              pt(s, O, he, Pe);
              break;
          }
        }
      return s.push(Mt), pe(s, oe, Y), typeof Y == "string" ? (s.push(E(yn(Y))), null) : Y;
    }
    function Yn(s, h, k, O) {
      s.push(ar(k));
      var Y = null, oe = null;
      for (var he in h)
        if (V.call(h, he)) {
          var Pe = h[he];
          if (Pe == null)
            continue;
          switch (he) {
            case "children":
              Y = Pe;
              break;
            case "dangerouslySetInnerHTML":
              oe = Pe;
              break;
            case "style":
              ve(s, O, Pe);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              H(he) && typeof Pe != "function" && typeof Pe != "symbol" && s.push(De, E(he), Xe, E(Vt(Pe)), ut);
              break;
          }
        }
      return s.push(Mt), pe(s, oe, Y), Y;
    }
    var Lr = p(`
`);
    function br(s, h, k, O) {
      s.push(ar(k));
      var Y = null, oe = null;
      for (var he in h)
        if (V.call(h, he)) {
          var Pe = h[he];
          if (Pe == null)
            continue;
          switch (he) {
            case "children":
              Y = Pe;
              break;
            case "dangerouslySetInnerHTML":
              oe = Pe;
              break;
            default:
              pt(s, O, he, Pe);
              break;
          }
        }
      if (s.push(Mt), oe != null) {
        if (Y != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof oe != "object" || !("__html" in oe))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var o = oe.__html;
        o != null && (typeof o == "string" && o.length > 0 && o[0] === `
` ? s.push(Lr, E(o)) : (q(o), s.push(E("" + o))));
      }
      return typeof Y == "string" && Y[0] === `
` && s.push(Lr), Y;
    }
    var ma = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Sr = /* @__PURE__ */ new Map();
    function ar(s) {
      var h = Sr.get(s);
      if (h === void 0) {
        if (!ma.test(s))
          throw new Error("Invalid tag: " + s);
        h = p("<" + s), Sr.set(s, h);
      }
      return h;
    }
    var Ka = p("<!DOCTYPE html>");
    function Ya(s, h, k, O, Y) {
      switch (Me(h, k), Ze(h, k), zt(h, k, null), !k.suppressContentEditableWarning && k.contentEditable && k.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), Y.insertionMode !== yt && Y.insertionMode !== Tt && h.indexOf("-") === -1 && typeof k.is != "string" && h.toLowerCase() !== h && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", h), h) {
        case "select":
          return il(s, k, O);
        case "option":
          return ll(s, k, O, Y);
        case "textarea":
          return gr(s, k, O);
        case "input":
          return Ua(s, k, O);
        case "menuitem":
          return ha(s, k, O);
        case "title":
          return Jt(s, k, O);
        case "listing":
        case "pre":
          return br(s, k, h, O);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Qr(s, k, h, O);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return xr(s, k, h, O);
        case "html":
          return Y.insertionMode === ht && s.push(Ka), xr(s, k, h, O);
        default:
          return h.indexOf("-") === -1 && typeof k.is != "string" ? xr(s, k, h, O) : Yn(s, k, h, O);
      }
    }
    var Vi = p("</"), ji = p(">");
    function Ui(s, h, k) {
      switch (h) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          s.push(Vi, E(h), ji);
      }
    }
    function sl(s, h) {
      for (var k = h.bootstrapChunks, O = 0; O < k.length - 1; O++)
        v(s, k[O]);
      return O < k.length ? x(s, k[O]) : !0;
    }
    var ul = p('<template id="'), ya = p('"></template>');
    function ga(s, h, k) {
      v(s, ul), v(s, h.placeholderPrefix);
      var O = E(k.toString(16));
      return v(s, O), x(s, ya);
    }
    var va = p("<!--$-->"), Jr = p('<!--$?--><template id="'), cl = p('"></template>'), ea = p("<!--$!-->"), Xa = p("<!--/$-->"), qa = p("<template"), Br = p('"'), Ir = p(' data-dgst="'), xa = p(' data-msg="'), Ki = p(' data-stck="'), Ga = p("></template>");
    function Yi(s, h) {
      return x(s, va);
    }
    function ba(s, h, k) {
      if (v(s, Jr), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return v(s, k), x(s, cl);
    }
    function Xn(s, h, k, O, Y) {
      var oe;
      return oe = x(s, ea), v(s, qa), k && (v(s, Ir), v(s, E(Vt(k))), v(s, Br)), O && (v(s, xa), v(s, E(Vt(O))), v(s, Br)), Y && (v(s, Ki), v(s, E(Vt(Y))), v(s, Br)), oe = x(s, Ga), oe;
    }
    function Xi(s, h) {
      return x(s, Xa);
    }
    function Sa(s, h) {
      return x(s, Xa);
    }
    function dl(s, h) {
      return x(s, Xa);
    }
    var qi = p('<div hidden id="'), Ea = p('">'), Gi = p("</div>"), Zi = p('<svg aria-hidden="true" style="display:none" id="'), ka = p('">'), wa = p("</svg>"), Qi = p('<math aria-hidden="true" style="display:none" id="'), Ji = p('">'), eo = p("</math>"), Za = p('<table hidden id="'), to = p('">'), b = p("</table>"), N = p('<table hidden><tbody id="'), I = p('">'), J = p("</tbody></table>"), we = p('<table hidden><tr id="'), ke = p('">'), Be = p("</tr></table>"), qe = p('<table hidden><colgroup id="'), St = p('">'), _t = p("</colgroup></table>");
    function Dt(s, h, k, O) {
      switch (k.insertionMode) {
        case ht:
        case je:
          return v(s, qi), v(s, h.segmentPrefix), v(s, E(O.toString(16))), x(s, Ea);
        case yt:
          return v(s, Zi), v(s, h.segmentPrefix), v(s, E(O.toString(16))), x(s, ka);
        case Tt:
          return v(s, Qi), v(s, h.segmentPrefix), v(s, E(O.toString(16))), x(s, Ji);
        case Rt:
          return v(s, Za), v(s, h.segmentPrefix), v(s, E(O.toString(16))), x(s, to);
        case jt:
          return v(s, N), v(s, h.segmentPrefix), v(s, E(O.toString(16))), x(s, I);
        case wt:
          return v(s, we), v(s, h.segmentPrefix), v(s, E(O.toString(16))), x(s, ke);
        case kt:
          return v(s, qe), v(s, h.segmentPrefix), v(s, E(O.toString(16))), x(s, St);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function an(s, h) {
      switch (h.insertionMode) {
        case ht:
        case je:
          return x(s, Gi);
        case yt:
          return x(s, wa);
        case Tt:
          return x(s, eo);
        case Rt:
          return x(s, b);
        case jt:
          return x(s, J);
        case wt:
          return x(s, Be);
        case kt:
          return x(s, _t);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var qn = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", ir = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', or = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Ta = p(qn + ';$RS("'), no = p('$RS("'), Qa = p('","'), Bc = p('")<\/script>');
    function Ic(s, h, k) {
      v(s, h.startInlineScript), h.sentCompleteSegmentFunction ? v(s, no) : (h.sentCompleteSegmentFunction = !0, v(s, Ta)), v(s, h.segmentPrefix);
      var O = E(k.toString(16));
      return v(s, O), v(s, Qa), v(s, h.placeholderPrefix), v(s, O), x(s, Bc);
    }
    var Hc = p(ir + ';$RC("'), Wc = p('$RC("'), Vc = p('","'), jc = p('")<\/script>');
    function fl(s, h, k, O) {
      if (v(s, h.startInlineScript), h.sentCompleteBoundaryFunction ? v(s, Wc) : (h.sentCompleteBoundaryFunction = !0, v(s, Hc)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var Y = E(O.toString(16));
      return v(s, k), v(s, Vc), v(s, h.segmentPrefix), v(s, Y), x(s, jc);
    }
    var Uc = p(or + ';$RX("'), Kc = p('$RX("'), pl = p('"'), Yc = p(")<\/script>"), hl = p(",");
    function Os(s, h, k, O, Y, oe) {
      if (v(s, h.startInlineScript), h.sentClientRenderFunction ? v(s, Kc) : (h.sentClientRenderFunction = !0, v(s, Uc)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return v(s, k), v(s, pl), (O || Y || oe) && (v(s, hl), v(s, E(ml(O || "")))), (Y || oe) && (v(s, hl), v(s, E(ml(Y || "")))), oe && (v(s, hl), v(s, E(ml(oe)))), x(s, Yc);
    }
    var Fs = /[<\u2028\u2029]/g;
    function ml(s) {
      var h = JSON.stringify(s);
      return h.replace(Fs, function(k) {
        switch (k) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var fr = Object.assign, Xc = Symbol.for("react.element"), Ms = Symbol.for("react.portal"), lr = Symbol.for("react.fragment"), zs = Symbol.for("react.strict_mode"), yl = Symbol.for("react.profiler"), ro = Symbol.for("react.provider"), ao = Symbol.for("react.context"), io = Symbol.for("react.forward_ref"), Ja = Symbol.for("react.suspense"), ei = Symbol.for("react.suspense_list"), ti = Symbol.for("react.memo"), Ca = Symbol.for("react.lazy"), gl = Symbol.for("react.scope"), vl = Symbol.for("react.debug_trace_mode"), oo = Symbol.for("react.legacy_hidden"), qc = Symbol.for("react.default_value"), $s = Symbol.iterator, Gc = "@@iterator";
    function Zc(s) {
      if (s === null || typeof s != "object")
        return null;
      var h = $s && s[$s] || s[Gc];
      return typeof h == "function" ? h : null;
    }
    function Bs(s, h, k) {
      var O = s.displayName;
      if (O)
        return O;
      var Y = h.displayName || h.name || "";
      return Y !== "" ? k + "(" + Y + ")" : k;
    }
    function Is(s) {
      return s.displayName || "Context";
    }
    function vn(s) {
      if (s == null)
        return null;
      if (typeof s.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof s == "function")
        return s.displayName || s.name || null;
      if (typeof s == "string")
        return s;
      switch (s) {
        case lr:
          return "Fragment";
        case Ms:
          return "Portal";
        case yl:
          return "Profiler";
        case zs:
          return "StrictMode";
        case Ja:
          return "Suspense";
        case ei:
          return "SuspenseList";
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case ao:
            var h = s;
            return Is(h) + ".Consumer";
          case ro:
            var k = s;
            return Is(k._context) + ".Provider";
          case io:
            return Bs(s, s.render, "ForwardRef");
          case ti:
            var O = s.displayName || null;
            return O !== null ? O : vn(s.type) || "Memo";
          case Ca: {
            var Y = s, oe = Y._payload, he = Y._init;
            try {
              return vn(he(oe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ni = 0, xl, hn, Aa, bl, Sl, El, kl;
    function wl() {
    }
    wl.__reactDisabledLog = !0;
    function Hs() {
      {
        if (ni === 0) {
          xl = console.log, hn = console.info, Aa = console.warn, bl = console.error, Sl = console.group, El = console.groupCollapsed, kl = console.groupEnd;
          var s = {
            configurable: !0,
            enumerable: !0,
            value: wl,
            writable: !0
          };
          Object.defineProperties(console, {
            info: s,
            log: s,
            warn: s,
            error: s,
            group: s,
            groupCollapsed: s,
            groupEnd: s
          });
        }
        ni++;
      }
    }
    function Ws() {
      {
        if (ni--, ni === 0) {
          var s = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: fr({}, s, {
              value: xl
            }),
            info: fr({}, s, {
              value: hn
            }),
            warn: fr({}, s, {
              value: Aa
            }),
            error: fr({}, s, {
              value: bl
            }),
            group: fr({}, s, {
              value: Sl
            }),
            groupCollapsed: fr({}, s, {
              value: El
            }),
            groupEnd: fr({}, s, {
              value: kl
            })
          });
        }
        ni < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var lo = n.ReactCurrentDispatcher, Tl;
    function ri(s, h, k) {
      {
        if (Tl === void 0)
          try {
            throw Error();
          } catch (Y) {
            var O = Y.stack.trim().match(/\n( *(at )?)/);
            Tl = O && O[1] || "";
          }
        return `
` + Tl + s;
      }
    }
    var ai = !1, La;
    {
      var ii = typeof WeakMap == "function" ? WeakMap : Map;
      La = new ii();
    }
    function oi(s, h) {
      if (!s || ai)
        return "";
      {
        var k = La.get(s);
        if (k !== void 0)
          return k;
      }
      var O;
      ai = !0;
      var Y = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var oe;
      oe = lo.current, lo.current = null, Hs();
      try {
        if (h) {
          var he = function() {
            throw Error();
          };
          if (Object.defineProperty(he.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(he, []);
            } catch (fe) {
              O = fe;
            }
            Reflect.construct(s, [], he);
          } else {
            try {
              he.call();
            } catch (fe) {
              O = fe;
            }
            s.call(he.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (fe) {
            O = fe;
          }
          s();
        }
      } catch (fe) {
        if (fe && O && typeof fe.stack == "string") {
          for (var Pe = fe.stack.split(`
`), o = O.stack.split(`
`), d = Pe.length - 1, S = o.length - 1; d >= 1 && S >= 0 && Pe[d] !== o[S]; )
            S--;
          for (; d >= 1 && S >= 0; d--, S--)
            if (Pe[d] !== o[S]) {
              if (d !== 1 || S !== 1)
                do
                  if (d--, S--, S < 0 || Pe[d] !== o[S]) {
                    var L = `
` + Pe[d].replace(" at new ", " at ");
                    return s.displayName && L.includes("<anonymous>") && (L = L.replace("<anonymous>", s.displayName)), typeof s == "function" && La.set(s, L), L;
                  }
                while (d >= 1 && S >= 0);
              break;
            }
        }
      } finally {
        ai = !1, lo.current = oe, Ws(), Error.prepareStackTrace = Y;
      }
      var $ = s ? s.displayName || s.name : "", ne = $ ? ri($) : "";
      return typeof s == "function" && La.set(s, ne), ne;
    }
    function so(s, h, k) {
      return oi(s, !0);
    }
    function Vs(s, h, k) {
      return oi(s, !1);
    }
    function Cl(s) {
      var h = s.prototype;
      return !!(h && h.isReactComponent);
    }
    function Al(s, h, k) {
      if (s == null)
        return "";
      if (typeof s == "function")
        return oi(s, Cl(s));
      if (typeof s == "string")
        return ri(s);
      switch (s) {
        case Ja:
          return ri("Suspense");
        case ei:
          return ri("SuspenseList");
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case io:
            return Vs(s.render);
          case ti:
            return Al(s.type, h, k);
          case Ca: {
            var O = s, Y = O._payload, oe = O._init;
            try {
              return Al(oe(Y), h, k);
            } catch {
            }
          }
        }
      return "";
    }
    var Ll = {}, js = n.ReactDebugCurrentFrame;
    function Pa(s) {
      if (s) {
        var h = s._owner, k = Al(s.type, s._source, h ? h.type : null);
        js.setExtraStackFrame(k);
      } else
        js.setExtraStackFrame(null);
    }
    function Pl(s, h, k, O, Y) {
      {
        var oe = Function.call.bind(V);
        for (var he in s)
          if (oe(s, he)) {
            var Pe = void 0;
            try {
              if (typeof s[he] != "function") {
                var o = Error((O || "React class") + ": " + k + " type `" + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[he] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw o.name = "Invariant Violation", o;
              }
              Pe = s[he](h, he, O, k, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (d) {
              Pe = d;
            }
            Pe && !(Pe instanceof Error) && (Pa(Y), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", O || "React class", k, he, typeof Pe), Pa(null)), Pe instanceof Error && !(Pe.message in Ll) && (Ll[Pe.message] = !0, Pa(Y), i("Failed %s type: %s", k, Pe.message), Pa(null));
          }
      }
    }
    var uo;
    uo = {};
    var ta = {};
    Object.freeze(ta);
    function Rl(s, h) {
      {
        var k = s.contextTypes;
        if (!k)
          return ta;
        var O = {};
        for (var Y in k)
          O[Y] = h[Y];
        {
          var oe = vn(s) || "Unknown";
          Pl(k, O, "context", oe);
        }
        return O;
      }
    }
    function Dl(s, h, k, O) {
      {
        if (typeof s.getChildContext != "function") {
          {
            var Y = vn(h) || "Unknown";
            uo[Y] || (uo[Y] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", Y, Y));
          }
          return k;
        }
        var oe = s.getChildContext();
        for (var he in oe)
          if (!(he in O))
            throw new Error((vn(h) || "Unknown") + '.getChildContext(): key "' + he + '" is not defined in childContextTypes.');
        {
          var Pe = vn(h) || "Unknown";
          Pl(O, oe, "child context", Pe);
        }
        return fr({}, k, oe);
      }
    }
    var Hr;
    Hr = {};
    var Us = null, na = null;
    function ra(s) {
      s.context._currentValue = s.parentValue;
    }
    function Nl(s) {
      s.context._currentValue = s.value;
    }
    function Er(s, h) {
      if (s !== h) {
        ra(s);
        var k = s.parent, O = h.parent;
        if (k === null) {
          if (O !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (O === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          Er(k, O);
        }
        Nl(h);
      }
    }
    function co(s) {
      ra(s);
      var h = s.parent;
      h !== null && co(h);
    }
    function fo(s) {
      var h = s.parent;
      h !== null && fo(h), Nl(s);
    }
    function li(s, h) {
      ra(s);
      var k = s.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      k.depth === h.depth ? Er(k, h) : li(k, h);
    }
    function _l(s, h) {
      var k = h.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      s.depth === k.depth ? Er(s, k) : _l(s, k), Nl(h);
    }
    function si(s) {
      var h = na, k = s;
      h !== k && (h === null ? fo(k) : k === null ? co(h) : h.depth === k.depth ? Er(h, k) : h.depth > k.depth ? li(h, k) : _l(h, k), na = k);
    }
    function Ks(s, h) {
      var k;
      k = s._currentValue, s._currentValue = h, s._currentRenderer !== void 0 && s._currentRenderer !== null && s._currentRenderer !== Hr && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer = Hr;
      var O = na, Y = {
        parent: O,
        depth: O === null ? 0 : O.depth + 1,
        context: s,
        parentValue: k,
        value: h
      };
      return na = Y, Y;
    }
    function Ys(s) {
      var h = na;
      if (h === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      h.context !== s && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var k = h.parentValue;
        k === qc ? h.context._currentValue = h.context._defaultValue : h.context._currentValue = k, s._currentRenderer !== void 0 && s._currentRenderer !== null && s._currentRenderer !== Hr && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer = Hr;
      }
      return na = h.parent;
    }
    function po() {
      return na;
    }
    function ui(s) {
      var h = s._currentValue;
      return h;
    }
    function Ol(s) {
      return s._reactInternals;
    }
    function Qc(s, h) {
      s._reactInternals = h;
    }
    var Ra = {}, ho = {}, Fl, mo, yo, ci, go, Da, di, vo, Na;
    {
      Fl = /* @__PURE__ */ new Set(), mo = /* @__PURE__ */ new Set(), yo = /* @__PURE__ */ new Set(), di = /* @__PURE__ */ new Set(), ci = /* @__PURE__ */ new Set(), vo = /* @__PURE__ */ new Set(), Na = /* @__PURE__ */ new Set();
      var xo = /* @__PURE__ */ new Set();
      Da = function(s, h) {
        if (!(s === null || typeof s == "function")) {
          var k = h + "_" + s;
          xo.has(k) || (xo.add(k), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", h, s));
        }
      }, go = function(s, h) {
        if (h === void 0) {
          var k = vn(s) || "Component";
          ci.has(k) || (ci.add(k), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", k));
        }
      };
    }
    function bo(s, h) {
      {
        var k = s.constructor, O = k && vn(k) || "ReactClass", Y = O + "." + h;
        if (Ra[Y])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, h, h, O), Ra[Y] = !0;
      }
    }
    var So = {
      isMounted: function(s) {
        return !1;
      },
      enqueueSetState: function(s, h, k) {
        var O = Ol(s);
        O.queue === null ? bo(s, "setState") : (O.queue.push(h), k != null && Da(k, "setState"));
      },
      enqueueReplaceState: function(s, h, k) {
        var O = Ol(s);
        O.replace = !0, O.queue = [h], k != null && Da(k, "setState");
      },
      enqueueForceUpdate: function(s, h) {
        var k = Ol(s);
        k.queue === null ? bo(s, "forceUpdate") : h != null && Da(h, "setState");
      }
    };
    function Xs(s, h, k, O, Y) {
      var oe = k(Y, O);
      go(h, oe);
      var he = oe == null ? O : fr({}, O, oe);
      return he;
    }
    function qs(s, h, k) {
      var O = ta, Y = s.contextType;
      if ("contextType" in s) {
        var oe = (
          // Allow null for conditional declaration
          Y === null || Y !== void 0 && Y.$$typeof === ao && Y._context === void 0
        );
        if (!oe && !Na.has(s)) {
          Na.add(s);
          var he = "";
          Y === void 0 ? he = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof Y != "object" ? he = " However, it is set to a " + typeof Y + "." : Y.$$typeof === ro ? he = " Did you accidentally pass the Context.Provider instead?" : Y._context !== void 0 ? he = " Did you accidentally pass the Context.Consumer instead?" : he = " However, it is set to an object with keys {" + Object.keys(Y).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", vn(s) || "Component", he);
        }
      }
      typeof Y == "object" && Y !== null ? O = ui(Y) : O = k;
      var Pe = new s(h, O);
      {
        if (typeof s.getDerivedStateFromProps == "function" && (Pe.state === null || Pe.state === void 0)) {
          var o = vn(s) || "Component";
          Fl.has(o) || (Fl.add(o), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", o, Pe.state === null ? "null" : "undefined", o));
        }
        if (typeof s.getDerivedStateFromProps == "function" || typeof Pe.getSnapshotBeforeUpdate == "function") {
          var d = null, S = null, L = null;
          if (typeof Pe.componentWillMount == "function" && Pe.componentWillMount.__suppressDeprecationWarning !== !0 ? d = "componentWillMount" : typeof Pe.UNSAFE_componentWillMount == "function" && (d = "UNSAFE_componentWillMount"), typeof Pe.componentWillReceiveProps == "function" && Pe.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? S = "componentWillReceiveProps" : typeof Pe.UNSAFE_componentWillReceiveProps == "function" && (S = "UNSAFE_componentWillReceiveProps"), typeof Pe.componentWillUpdate == "function" && Pe.componentWillUpdate.__suppressDeprecationWarning !== !0 ? L = "componentWillUpdate" : typeof Pe.UNSAFE_componentWillUpdate == "function" && (L = "UNSAFE_componentWillUpdate"), d !== null || S !== null || L !== null) {
            var $ = vn(s) || "Component", ne = typeof s.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            yo.has($) || (yo.add($), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, $, ne, d !== null ? `
  ` + d : "", S !== null ? `
  ` + S : "", L !== null ? `
  ` + L : ""));
          }
        }
      }
      return Pe;
    }
    function Gs(s, h, k) {
      {
        var O = vn(h) || "Component", Y = s.render;
        Y || (h.prototype && typeof h.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", O) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", O)), s.getInitialState && !s.getInitialState.isReactClassApproved && !s.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", O), s.getDefaultProps && !s.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", O), s.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", O), s.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", O), s.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", O), h.contextType && h.contextTypes && !vo.has(h) && (vo.add(h), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", O)), typeof s.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", O), h.prototype && h.prototype.isPureReactComponent && typeof s.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", vn(h) || "A pure component"), typeof s.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", O), typeof s.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", O), typeof s.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", O), typeof s.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", O);
        var oe = s.props !== k;
        s.props !== void 0 && oe && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", O, O), s.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", O, O), typeof s.getSnapshotBeforeUpdate == "function" && typeof s.componentDidUpdate != "function" && !mo.has(h) && (mo.add(h), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", vn(h))), typeof s.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", O), typeof s.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", O), typeof h.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", O);
        var he = s.state;
        he && (typeof he != "object" || zn(he)) && i("%s.state: must be set to an object or null", O), typeof s.getChildContext == "function" && typeof h.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", O);
      }
    }
    function Jc(s, h) {
      var k = h.state;
      if (typeof h.componentWillMount == "function") {
        if (h.componentWillMount.__suppressDeprecationWarning !== !0) {
          var O = vn(s) || "Unknown";
          ho[O] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            O
          ), ho[O] = !0);
        }
        h.componentWillMount();
      }
      typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(), k !== h.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", vn(s) || "Component"), So.enqueueReplaceState(h, h.state, null));
    }
    function ed(s, h, k, O) {
      if (s.queue !== null && s.queue.length > 0) {
        var Y = s.queue, oe = s.replace;
        if (s.queue = null, s.replace = !1, oe && Y.length === 1)
          h.state = Y[0];
        else {
          for (var he = oe ? Y[0] : h.state, Pe = !0, o = oe ? 1 : 0; o < Y.length; o++) {
            var d = Y[o], S = typeof d == "function" ? d.call(h, he, k, O) : d;
            S != null && (Pe ? (Pe = !1, he = fr({}, he, S)) : fr(he, S));
          }
          h.state = he;
        }
      } else
        s.queue = null;
    }
    function Zs(s, h, k, O) {
      Gs(s, h, k);
      var Y = s.state !== void 0 ? s.state : null;
      s.updater = So, s.props = k, s.state = Y;
      var oe = {
        queue: [],
        replace: !1
      };
      Qc(s, oe);
      var he = h.contextType;
      if (typeof he == "object" && he !== null ? s.context = ui(he) : s.context = O, s.state === k) {
        var Pe = vn(h) || "Component";
        di.has(Pe) || (di.add(Pe), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Pe));
      }
      var o = h.getDerivedStateFromProps;
      typeof o == "function" && (s.state = Xs(s, h, o, Y, k)), typeof h.getDerivedStateFromProps != "function" && typeof s.getSnapshotBeforeUpdate != "function" && (typeof s.UNSAFE_componentWillMount == "function" || typeof s.componentWillMount == "function") && (Jc(h, s), ed(oe, s, k, O));
    }
    var td = {
      id: 1,
      overflow: ""
    };
    function nd(s) {
      var h = s.overflow, k = s.id, O = k & ~rd(k);
      return O.toString(32) + h;
    }
    function Eo(s, h, k) {
      var O = s.id, Y = s.overflow, oe = ko(O) - 1, he = O & ~(1 << oe), Pe = k + 1, o = ko(h) + oe;
      if (o > 30) {
        var d = oe - oe % 5, S = (1 << d) - 1, L = (he & S).toString(32), $ = he >> d, ne = oe - d, fe = ko(h) + ne, Le = Pe << ne, Ke = Le | $, it = L + Y;
        return {
          id: 1 << fe | Ke,
          overflow: it
        };
      } else {
        var dt = Pe << oe, Ct = dt | he, cn = Y;
        return {
          id: 1 << o | Ct,
          overflow: cn
        };
      }
    }
    function ko(s) {
      return 32 - Ml(s);
    }
    function rd(s) {
      return 1 << ko(s) - 1;
    }
    var Ml = Math.clz32 ? Math.clz32 : id, wo = Math.log, ad = Math.LN2;
    function id(s) {
      var h = s >>> 0;
      return h === 0 ? 32 : 31 - (wo(h) / ad | 0) | 0;
    }
    function od(s, h) {
      return s === h && (s !== 0 || 1 / s === 1 / h) || s !== s && h !== h;
    }
    var ld = typeof Object.is == "function" ? Object.is : od, Pr = null, zl = null, To = null, Bt = null, aa = !1, ia = !1, Gt = 0, pr = null, oa = 0, Co = 25, $n = !1, Rr;
    function la() {
      if (Pr === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return $n && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Pr;
    }
    function kr(s, h) {
      if (h === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Rr), !1;
      s.length !== h.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Rr, "[" + s.join(", ") + "]", "[" + h.join(", ") + "]");
      for (var k = 0; k < h.length && k < s.length; k++)
        if (!ld(s[k], h[k]))
          return !1;
      return !0;
    }
    function sa() {
      if (oa > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Dr() {
      return Bt === null ? To === null ? (aa = !1, To = Bt = sa()) : (aa = !0, Bt = To) : Bt.next === null ? (aa = !1, Bt = Bt.next = sa()) : (aa = !0, Bt = Bt.next), Bt;
    }
    function sd(s, h) {
      Pr = h, zl = s, $n = !1, Gt = 0;
    }
    function Qs(s, h, k, O) {
      for (; ia; )
        ia = !1, Gt = 0, oa += 1, Bt = null, k = s(h, O);
      return $l(), k;
    }
    function Ao() {
      var s = Gt !== 0;
      return s;
    }
    function $l() {
      $n = !1, Pr = null, zl = null, ia = !1, To = null, oa = 0, pr = null, Bt = null;
    }
    function ud(s) {
      return $n && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), ui(s);
    }
    function Js(s) {
      return Rr = "useContext", la(), ui(s);
    }
    function fi(s, h) {
      return typeof h == "function" ? h(s) : h;
    }
    function cd(s) {
      return Rr = "useState", eu(
        fi,
        // useReducer has a special case to support lazy useState initializers
        s
      );
    }
    function eu(s, h, k) {
      if (s !== fi && (Rr = "useReducer"), Pr = la(), Bt = Dr(), aa) {
        var O = Bt.queue, Y = O.dispatch;
        if (pr !== null) {
          var oe = pr.get(O);
          if (oe !== void 0) {
            pr.delete(O);
            var he = Bt.memoizedState, Pe = oe;
            do {
              var o = Pe.action;
              $n = !0, he = s(he, o), $n = !1, Pe = Pe.next;
            } while (Pe !== null);
            return Bt.memoizedState = he, [he, Y];
          }
        }
        return [Bt.memoizedState, Y];
      } else {
        $n = !0;
        var d;
        s === fi ? d = typeof h == "function" ? h() : h : d = k !== void 0 ? k(h) : h, $n = !1, Bt.memoizedState = d;
        var S = Bt.queue = {
          last: null,
          dispatch: null
        }, L = S.dispatch = nu.bind(null, Pr, S);
        return [Bt.memoizedState, L];
      }
    }
    function Lo(s, h) {
      Pr = la(), Bt = Dr();
      var k = h === void 0 ? null : h;
      if (Bt !== null) {
        var O = Bt.memoizedState;
        if (O !== null && k !== null) {
          var Y = O[1];
          if (kr(k, Y))
            return O[0];
        }
      }
      $n = !0;
      var oe = s();
      return $n = !1, Bt.memoizedState = [oe, k], oe;
    }
    function dd(s) {
      Pr = la(), Bt = Dr();
      var h = Bt.memoizedState;
      if (h === null) {
        var k = {
          current: s
        };
        return Object.seal(k), Bt.memoizedState = k, k;
      } else
        return h;
    }
    function tu(s, h) {
      Rr = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function nu(s, h, k) {
      if (oa >= Co)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (s === Pr) {
        ia = !0;
        var O = {
          action: k,
          next: null
        };
        pr === null && (pr = /* @__PURE__ */ new Map());
        var Y = pr.get(h);
        if (Y === void 0)
          pr.set(h, O);
        else {
          for (var oe = Y; oe.next !== null; )
            oe = oe.next;
          oe.next = O;
        }
      }
    }
    function fd(s, h) {
      return Lo(function() {
        return s;
      }, h);
    }
    function pd(s, h, k) {
      return la(), h(s._source);
    }
    function hd(s, h, k) {
      if (k === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return k();
    }
    function md(s) {
      return la(), s;
    }
    function yd() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function gd() {
      return la(), [!1, yd];
    }
    function vd() {
      var s = zl, h = nd(s.treeContext), k = Bl;
      if (k === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var O = Gt++;
      return sn(k, h, O);
    }
    function Po() {
    }
    var ru = {
      readContext: ud,
      useContext: Js,
      useMemo: Lo,
      useReducer: eu,
      useRef: dd,
      useState: cd,
      useInsertionEffect: Po,
      useLayoutEffect: tu,
      useCallback: fd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: Po,
      // Effects are not run in the server environment.
      useEffect: Po,
      // Debugging effect
      useDebugValue: Po,
      useDeferredValue: md,
      useTransition: gd,
      useId: vd,
      // Subscriptions are not setup in a server environment.
      useMutableSource: pd,
      useSyncExternalStore: hd
    }, Bl = null;
    function pi(s) {
      Bl = s;
    }
    function au(s) {
      try {
        var h = "", k = s;
        do {
          switch (k.tag) {
            case 0:
              h += ri(k.type, null, null);
              break;
            case 1:
              h += Vs(k.type, null, null);
              break;
            case 2:
              h += so(k.type, null, null);
              break;
          }
          k = k.parent;
        } while (k);
        return h;
      } catch (O) {
        return `
Error generating stack: ` + O.message + `
` + O.stack;
      }
    }
    var hi = n.ReactCurrentDispatcher, Ro = n.ReactDebugCurrentFrame, Il = 0, Wr = 1, Do = 2, No = 3, ua = 4, iu = 0, Hl = 1, ca = 2, xd = 12800;
    function ou(s) {
      return console.error(s), null;
    }
    function wr() {
    }
    function bd(s, h, k, O, Y, oe, he, Pe, o) {
      var d = [], S = /* @__PURE__ */ new Set(), L = {
        destination: null,
        responseState: h,
        progressiveChunkSize: O === void 0 ? xd : O,
        status: iu,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: S,
        pingedTasks: d,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: Y === void 0 ? ou : Y,
        onAllReady: oe === void 0 ? wr : oe,
        onShellReady: he === void 0 ? wr : he,
        onShellError: Pe === void 0 ? wr : Pe,
        onFatalError: o === void 0 ? wr : o
      }, $ = _o(
        L,
        0,
        null,
        k,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      $.parentFlushed = !0;
      var ne = Wl(L, s, null, $, S, ta, Us, td);
      return d.push(ne), L;
    }
    function Sd(s, h) {
      var k = s.pingedTasks;
      k.push(h), k.length === 1 && c(function() {
        return bi(s);
      });
    }
    function mi(s, h) {
      return {
        id: xn,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: h,
        errorDigest: null
      };
    }
    function Wl(s, h, k, O, Y, oe, he, Pe) {
      s.allPendingTasks++, k === null ? s.pendingRootTasks++ : k.pendingTasks++;
      var o = {
        node: h,
        ping: function() {
          return Sd(s, o);
        },
        blockedBoundary: k,
        blockedSegment: O,
        abortSet: Y,
        legacyContext: oe,
        context: he,
        treeContext: Pe
      };
      return o.componentStack = null, Y.add(o), o;
    }
    function _o(s, h, k, O, Y, oe) {
      return {
        status: Il,
        id: -1,
        // lazily assigned later
        index: h,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: O,
        boundary: k,
        lastPushedText: Y,
        textEmbedded: oe
      };
    }
    var Nr = null;
    function yi() {
      return Nr === null || Nr.componentStack === null ? "" : au(Nr.componentStack);
    }
    function Vr(s, h) {
      s.componentStack = {
        tag: 0,
        parent: s.componentStack,
        type: h
      };
    }
    function Tr(s, h) {
      s.componentStack = {
        tag: 1,
        parent: s.componentStack,
        type: h
      };
    }
    function Vl(s, h) {
      s.componentStack = {
        tag: 2,
        parent: s.componentStack,
        type: h
      };
    }
    function hr(s) {
      s.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : s.componentStack = s.componentStack.parent;
    }
    var _a = null;
    function jl(s, h) {
      {
        var k;
        typeof h == "string" ? k = h : h && typeof h.message == "string" ? k = h.message : k = String(h);
        var O = _a || yi();
        _a = null, s.errorMessage = k, s.errorComponentStack = O;
      }
    }
    function mr(s, h) {
      var k = s.onError(h);
      if (k != null && typeof k != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof k + '" instead');
      return k;
    }
    function jr(s, h) {
      var k = s.onShellError;
      k(h);
      var O = s.onFatalError;
      O(h), s.destination !== null ? (s.status = ca, C(s.destination, h)) : (s.status = Hl, s.fatalError = h);
    }
    function Ul(s, h, k) {
      Vr(h, "Suspense");
      var O = h.blockedBoundary, Y = h.blockedSegment, oe = k.fallback, he = k.children, Pe = /* @__PURE__ */ new Set(), o = mi(s, Pe), d = Y.chunks.length, S = _o(
        s,
        d,
        o,
        Y.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      Y.children.push(S), Y.lastPushedText = !1;
      var L = _o(
        s,
        0,
        null,
        Y.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      L.parentFlushed = !0, h.blockedBoundary = o, h.blockedSegment = L;
      try {
        if (es(s, h, he), Vn(L.chunks, s.responseState, L.lastPushedText, L.textEmbedded), L.status = Wr, Mo(o, L), o.pendingTasks === 0) {
          hr(h);
          return;
        }
      } catch (ne) {
        L.status = ua, o.forceClientRender = !0, o.errorDigest = mr(s, ne), jl(o, ne);
      } finally {
        h.blockedBoundary = O, h.blockedSegment = Y;
      }
      var $ = Wl(s, oe, O, S, Pe, h.legacyContext, h.context, h.treeContext);
      $.componentStack = h.componentStack, s.pingedTasks.push($), hr(h);
    }
    function gi(s, h, k, O) {
      Vr(h, k);
      var Y = h.blockedSegment, oe = Ya(Y.chunks, k, O, s.responseState, Y.formatContext);
      Y.lastPushedText = !1;
      var he = Y.formatContext;
      Y.formatContext = Et(he, k, O), es(s, h, oe), Y.formatContext = he, Ui(Y.chunks, k), Y.lastPushedText = !1, hr(h);
    }
    function Oo(s) {
      return s.prototype && s.prototype.isReactComponent;
    }
    function lu(s, h, k, O, Y) {
      var oe = {};
      sd(h, oe);
      var he = k(O, Y);
      return Qs(k, O, he, Y);
    }
    function su(s, h, k, O, Y) {
      var oe = k.render();
      k.props !== Y && (xi || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", vn(O) || "a component"), xi = !0);
      {
        var he = O.childContextTypes;
        if (he != null) {
          var Pe = h.legacyContext, o = Dl(k, O, Pe, he);
          h.legacyContext = o, sr(s, h, oe), h.legacyContext = Pe;
          return;
        }
      }
      sr(s, h, oe);
    }
    function Ed(s, h, k, O) {
      Vl(h, k);
      var Y = Rl(k, h.legacyContext), oe = qs(k, O, Y);
      Zs(oe, k, O, Y), su(s, h, oe, k, O), hr(h);
    }
    var Kl = {}, vi = {}, uu = {}, Yl = {}, xi = !1, Xl = !1, ql = !1, Gl = !1;
    function cu(s, h, k, O) {
      var Y;
      if (Y = Rl(k, h.legacyContext), Tr(h, k), k.prototype && typeof k.prototype.render == "function") {
        var oe = vn(k) || "Unknown";
        Kl[oe] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", oe, oe), Kl[oe] = !0);
      }
      var he = lu(s, h, k, O, Y), Pe = Ao();
      if (typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0) {
        var o = vn(k) || "Unknown";
        vi[o] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", o, o, o), vi[o] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0
      ) {
        {
          var d = vn(k) || "Unknown";
          vi[d] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", d, d, d), vi[d] = !0);
        }
        Zs(he, k, O, Y), su(s, h, he, k, O);
      } else if (du(k), Pe) {
        var S = h.treeContext, L = 1, $ = 0;
        h.treeContext = Eo(S, L, $);
        try {
          sr(s, h, he);
        } finally {
          h.treeContext = S;
        }
      } else
        sr(s, h, he);
      hr(h);
    }
    function du(s) {
      {
        if (s && s.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", s.displayName || s.name || "Component"), typeof s.getDerivedStateFromProps == "function") {
          var h = vn(s) || "Unknown";
          Yl[h] || (i("%s: Function components do not support getDerivedStateFromProps.", h), Yl[h] = !0);
        }
        if (typeof s.contextType == "object" && s.contextType !== null) {
          var k = vn(s) || "Unknown";
          uu[k] || (i("%s: Function components do not support contextType.", k), uu[k] = !0);
        }
      }
    }
    function Zl(s, h) {
      if (s && s.defaultProps) {
        var k = fr({}, h), O = s.defaultProps;
        for (var Y in O)
          k[Y] === void 0 && (k[Y] = O[Y]);
        return k;
      }
      return h;
    }
    function kd(s, h, k, O, Y) {
      Tr(h, k.render);
      var oe = lu(s, h, k.render, O, Y), he = Ao();
      if (he) {
        var Pe = h.treeContext, o = 1, d = 0;
        h.treeContext = Eo(Pe, o, d);
        try {
          sr(s, h, oe);
        } finally {
          h.treeContext = Pe;
        }
      } else
        sr(s, h, oe);
      hr(h);
    }
    function wd(s, h, k, O, Y) {
      var oe = k.type, he = Zl(oe, O);
      Ql(s, h, oe, he, Y);
    }
    function fu(s, h, k, O) {
      k._context === void 0 ? k !== k.Consumer && (Gl || (Gl = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : k = k._context;
      var Y = O.children;
      typeof Y != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var oe = ui(k), he = Y(oe);
      sr(s, h, he);
    }
    function Td(s, h, k, O) {
      var Y = k._context, oe = O.value, he = O.children, Pe;
      Pe = h.context, h.context = Ks(Y, oe), sr(s, h, he), h.context = Ys(Y), Pe !== h.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function Cd(s, h, k, O, Y) {
      Vr(h, "Lazy");
      var oe = k._payload, he = k._init, Pe = he(oe), o = Zl(Pe, O);
      Ql(s, h, Pe, o, Y), hr(h);
    }
    function Ql(s, h, k, O, Y) {
      if (typeof k == "function")
        if (Oo(k)) {
          Ed(s, h, k, O);
          return;
        } else {
          cu(s, h, k, O);
          return;
        }
      if (typeof k == "string") {
        gi(s, h, k, O);
        return;
      }
      switch (k) {
        case oo:
        case vl:
        case zs:
        case yl:
        case lr: {
          sr(s, h, O.children);
          return;
        }
        case ei: {
          Vr(h, "SuspenseList"), sr(s, h, O.children), hr(h);
          return;
        }
        case gl:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Ja: {
          Ul(s, h, O);
          return;
        }
      }
      if (typeof k == "object" && k !== null)
        switch (k.$$typeof) {
          case io: {
            kd(s, h, k, O, Y);
            return;
          }
          case ti: {
            wd(s, h, k, O, Y);
            return;
          }
          case ro: {
            Td(s, h, k, O);
            return;
          }
          case ao: {
            fu(s, h, k, O);
            return;
          }
          case Ca: {
            Cd(s, h, k, O);
            return;
          }
        }
      var oe = "";
      throw (k === void 0 || typeof k == "object" && k !== null && Object.keys(k).length === 0) && (oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (k == null ? k : typeof k) + "." + oe));
    }
    function Ad(s, h) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      s[Symbol.toStringTag] === "Generator" && (Xl || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Xl = !0), s.entries === h && (ql || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), ql = !0);
    }
    function sr(s, h, k) {
      try {
        return Jl(s, h, k);
      } catch (O) {
        throw typeof O == "object" && O !== null && typeof O.then == "function" || (_a = _a !== null ? _a : yi()), O;
      }
    }
    function Jl(s, h, k) {
      if (h.node = k, typeof k == "object" && k !== null) {
        switch (k.$$typeof) {
          case Xc: {
            var O = k, Y = O.type, oe = O.props, he = O.ref;
            Ql(s, h, Y, oe, he);
            return;
          }
          case Ms:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Ca: {
            var Pe = k, o = Pe._payload, d = Pe._init, S;
            try {
              S = d(o);
            } catch (dt) {
              throw typeof dt == "object" && dt !== null && typeof dt.then == "function" && Vr(h, "Lazy"), dt;
            }
            sr(s, h, S);
            return;
          }
        }
        if (zn(k)) {
          pu(s, h, k);
          return;
        }
        var L = Zc(k);
        if (L) {
          Ad(k, L);
          var $ = L.call(k);
          if ($) {
            var ne = $.next();
            if (!ne.done) {
              var fe = [];
              do
                fe.push(ne.value), ne = $.next();
              while (!ne.done);
              pu(s, h, fe);
              return;
            }
            return;
          }
        }
        var Le = Object.prototype.toString.call(k);
        throw new Error("Objects are not valid as a React child (found: " + (Le === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : Le) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof k == "string") {
        var Ke = h.blockedSegment;
        Ke.lastPushedText = gn(h.blockedSegment.chunks, k, s.responseState, Ke.lastPushedText);
        return;
      }
      if (typeof k == "number") {
        var it = h.blockedSegment;
        it.lastPushedText = gn(h.blockedSegment.chunks, "" + k, s.responseState, it.lastPushedText);
        return;
      }
      typeof k == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function pu(s, h, k) {
      for (var O = k.length, Y = 0; Y < O; Y++) {
        var oe = h.treeContext;
        h.treeContext = Eo(oe, O, Y);
        try {
          es(s, h, k[Y]);
        } finally {
          h.treeContext = oe;
        }
      }
    }
    function ur(s, h, k) {
      var O = h.blockedSegment, Y = O.chunks.length, oe = _o(
        s,
        Y,
        null,
        O.formatContext,
        // Adopt the parent segment's leading text embed
        O.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      O.children.push(oe), O.lastPushedText = !1;
      var he = Wl(s, h.node, h.blockedBoundary, oe, h.abortSet, h.legacyContext, h.context, h.treeContext);
      h.componentStack !== null && (he.componentStack = h.componentStack.parent);
      var Pe = he.ping;
      k.then(Pe, Pe);
    }
    function es(s, h, k) {
      var O = h.blockedSegment.formatContext, Y = h.legacyContext, oe = h.context, he = null;
      he = h.componentStack;
      try {
        return sr(s, h, k);
      } catch (Pe) {
        if ($l(), typeof Pe == "object" && Pe !== null && typeof Pe.then == "function") {
          ur(s, h, Pe), h.blockedSegment.formatContext = O, h.legacyContext = Y, h.context = oe, si(oe), h.componentStack = he;
          return;
        } else
          throw h.blockedSegment.formatContext = O, h.legacyContext = Y, h.context = oe, si(oe), h.componentStack = he, Pe;
      }
    }
    function hu(s, h, k, O) {
      var Y = mr(s, O);
      if (h === null ? jr(s, O) : (h.pendingTasks--, h.forceClientRender || (h.forceClientRender = !0, h.errorDigest = Y, jl(h, O), h.parentFlushed && s.clientRenderedBoundaries.push(h))), s.allPendingTasks--, s.allPendingTasks === 0) {
        var oe = s.onAllReady;
        oe();
      }
    }
    function Ld(s) {
      var h = this, k = s.blockedBoundary, O = s.blockedSegment;
      O.status = No, mu(h, k, O);
    }
    function Fo(s, h, k) {
      var O = s.blockedBoundary, Y = s.blockedSegment;
      if (Y.status = No, O === null)
        h.allPendingTasks--, h.status !== ca && (h.status = ca, h.destination !== null && T(h.destination));
      else {
        if (O.pendingTasks--, !O.forceClientRender) {
          O.forceClientRender = !0;
          var oe = k === void 0 ? new Error("The render was aborted by the server without a reason.") : k;
          O.errorDigest = h.onError(oe);
          {
            var he = "The server did not finish this Suspense boundary: ";
            oe && typeof oe.message == "string" ? oe = he + oe.message : oe = he + String(oe);
            var Pe = Nr;
            Nr = s;
            try {
              jl(O, oe);
            } finally {
              Nr = Pe;
            }
          }
          O.parentFlushed && h.clientRenderedBoundaries.push(O);
        }
        if (O.fallbackAbortableTasks.forEach(function(d) {
          return Fo(d, h, k);
        }), O.fallbackAbortableTasks.clear(), h.allPendingTasks--, h.allPendingTasks === 0) {
          var o = h.onAllReady;
          o();
        }
      }
    }
    function Mo(s, h) {
      if (h.chunks.length === 0 && h.children.length === 1 && h.children[0].boundary === null) {
        var k = h.children[0];
        k.id = h.id, k.parentFlushed = !0, k.status === Wr && Mo(s, k);
      } else {
        var O = s.completedSegments;
        O.push(h);
      }
    }
    function mu(s, h, k) {
      if (h === null) {
        if (k.parentFlushed) {
          if (s.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          s.completedRootSegment = k;
        }
        if (s.pendingRootTasks--, s.pendingRootTasks === 0) {
          s.onShellError = wr;
          var O = s.onShellReady;
          O();
        }
      } else if (h.pendingTasks--, !h.forceClientRender) {
        if (h.pendingTasks === 0)
          k.parentFlushed && k.status === Wr && Mo(h, k), h.parentFlushed && s.completedBoundaries.push(h), h.fallbackAbortableTasks.forEach(Ld, s), h.fallbackAbortableTasks.clear();
        else if (k.parentFlushed && k.status === Wr) {
          Mo(h, k);
          var Y = h.completedSegments;
          Y.length === 1 && h.parentFlushed && s.partialBoundaries.push(h);
        }
      }
      if (s.allPendingTasks--, s.allPendingTasks === 0) {
        var oe = s.onAllReady;
        oe();
      }
    }
    function yu(s, h) {
      var k = h.blockedSegment;
      if (k.status === Il) {
        si(h.context);
        var O = null;
        O = Nr, Nr = h;
        try {
          sr(s, h, h.node), Vn(k.chunks, s.responseState, k.lastPushedText, k.textEmbedded), h.abortSet.delete(h), k.status = Wr, mu(s, h.blockedBoundary, k);
        } catch (oe) {
          if ($l(), typeof oe == "object" && oe !== null && typeof oe.then == "function") {
            var Y = h.ping;
            oe.then(Y, Y);
          } else
            h.abortSet.delete(h), k.status = ua, hu(s, h.blockedBoundary, k, oe);
        } finally {
          Nr = O;
        }
      }
    }
    function bi(s) {
      if (s.status !== ca) {
        var h = po(), k = hi.current;
        hi.current = ru;
        var O;
        O = Ro.getCurrentStack, Ro.getCurrentStack = yi;
        var Y = Bl;
        pi(s.responseState);
        try {
          var oe = s.pingedTasks, he;
          for (he = 0; he < oe.length; he++) {
            var Pe = oe[he];
            yu(s, Pe);
          }
          oe.splice(0, he), s.destination !== null && $o(s, s.destination);
        } catch (o) {
          mr(s, o), jr(s, o);
        } finally {
          pi(Y), hi.current = k, Ro.getCurrentStack = O, k === ru && si(h);
        }
      }
    }
    function Si(s, h, k) {
      switch (k.parentFlushed = !0, k.status) {
        case Il: {
          var O = k.id = s.nextSegmentId++;
          return k.lastPushedText = !1, k.textEmbedded = !1, ga(h, s.responseState, O);
        }
        case Wr: {
          k.status = Do;
          for (var Y = !0, oe = k.chunks, he = 0, Pe = k.children, o = 0; o < Pe.length; o++) {
            for (var d = Pe[o]; he < d.index; he++)
              v(h, oe[he]);
            Y = zo(s, h, d);
          }
          for (; he < oe.length - 1; he++)
            v(h, oe[he]);
          return he < oe.length && (Y = x(h, oe[he])), Y;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function zo(s, h, k) {
      var O = k.boundary;
      if (O === null)
        return Si(s, h, k);
      if (O.parentFlushed = !0, O.forceClientRender)
        return Xn(h, s.responseState, O.errorDigest, O.errorMessage, O.errorComponentStack), Si(s, h, k), dl(h, s.responseState);
      if (O.pendingTasks > 0) {
        O.rootSegmentID = s.nextSegmentId++, O.completedSegments.length > 0 && s.partialBoundaries.push(O);
        var Y = O.id = pn(s.responseState);
        return ba(h, s.responseState, Y), Si(s, h, k), Sa(h, s.responseState);
      } else {
        if (O.byteSize > s.progressiveChunkSize)
          return O.rootSegmentID = s.nextSegmentId++, s.completedBoundaries.push(O), ba(h, s.responseState, O.id), Si(s, h, k), Sa(h, s.responseState);
        Yi(h, s.responseState);
        var oe = O.completedSegments;
        if (oe.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var he = oe[0];
        return zo(s, h, he), Xi(h, s.responseState);
      }
    }
    function gu(s, h, k) {
      return Os(h, s.responseState, k.id, k.errorDigest, k.errorMessage, k.errorComponentStack);
    }
    function Ei(s, h, k) {
      return Dt(h, s.responseState, k.formatContext, k.id), zo(s, h, k), an(h, k.formatContext);
    }
    function ki(s, h, k) {
      for (var O = k.completedSegments, Y = 0; Y < O.length; Y++) {
        var oe = O[Y];
        ts(s, h, k, oe);
      }
      return O.length = 0, fl(h, s.responseState, k.id, k.rootSegmentID);
    }
    function Pd(s, h, k) {
      for (var O = k.completedSegments, Y = 0; Y < O.length; Y++) {
        var oe = O[Y];
        if (!ts(s, h, k, oe))
          return Y++, O.splice(0, Y), !1;
      }
      return O.splice(0, Y), !0;
    }
    function ts(s, h, k, O) {
      if (O.status === Do)
        return !0;
      var Y = O.id;
      if (Y === -1) {
        var oe = O.id = k.rootSegmentID;
        if (oe === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Ei(s, h, O);
      } else
        return Ei(s, h, O), Ic(h, s.responseState, Y);
    }
    function $o(s, h) {
      y();
      try {
        var k = s.completedRootSegment;
        k !== null && s.pendingRootTasks === 0 && (zo(s, h, k), s.completedRootSegment = null, sl(h, s.responseState));
        var O = s.clientRenderedBoundaries, Y;
        for (Y = 0; Y < O.length; Y++) {
          var oe = O[Y];
          gu(s, h, oe);
        }
        O.splice(0, Y);
        var he = s.completedBoundaries;
        for (Y = 0; Y < he.length; Y++) {
          var Pe = he[Y];
          ki(s, h, Pe);
        }
        he.splice(0, Y), A(h), y(h);
        var o = s.partialBoundaries;
        for (Y = 0; Y < o.length; Y++) {
          var d = o[Y];
          if (!Pd(s, h, d)) {
            s.destination = null, Y++, o.splice(0, Y);
            return;
          }
        }
        o.splice(0, Y);
        var S = s.completedBoundaries;
        for (Y = 0; Y < S.length; Y++) {
          var L = S[Y];
          ki(s, h, L);
        }
        S.splice(0, Y);
      } finally {
        A(h), s.allPendingTasks === 0 && s.pingedTasks.length === 0 && s.clientRenderedBoundaries.length === 0 && s.completedBoundaries.length === 0 && (s.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), T(h));
      }
    }
    function Rd(s) {
      c(function() {
        return bi(s);
      });
    }
    function vu(s, h) {
      if (s.status === Hl) {
        s.status = ca, C(h, s.fatalError);
        return;
      }
      if (s.status !== ca && s.destination === null) {
        s.destination = h;
        try {
          $o(s, h);
        } catch (k) {
          mr(s, k), jr(s, k);
        }
      }
    }
    function Bo(s, h) {
      try {
        var k = s.abortableTasks;
        k.forEach(function(O) {
          return Fo(O, s, h);
        }), k.clear(), s.destination !== null && $o(s, s.destination);
      } catch (O) {
        mr(s, O), jr(s, O);
      }
    }
    function Dd(s, h) {
      return new Promise(function(k, O) {
        var Y, oe, he = new Promise(function($, ne) {
          oe = $, Y = ne;
        });
        function Pe() {
          var $ = new ReadableStream(
            {
              type: "bytes",
              pull: function(ne) {
                vu(d, ne);
              },
              cancel: function(ne) {
                Bo(d);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          $.allReady = he, k($);
        }
        function o($) {
          he.catch(function() {
          }), O($);
        }
        var d = bd(s, mt(h ? h.identifierPrefix : void 0, h ? h.nonce : void 0, h ? h.bootstrapScriptContent : void 0, h ? h.bootstrapScripts : void 0, h ? h.bootstrapModules : void 0), Ut(h ? h.namespaceURI : void 0), h ? h.progressiveChunkSize : void 0, h ? h.onError : void 0, oe, Pe, o, Y);
        if (h && h.signal) {
          var S = h.signal, L = function() {
            Bo(d, S.reason), S.removeEventListener("abort", L);
          };
          S.addEventListener("abort", L);
        }
        Rd(d);
      });
    }
    Mu.renderToReadableStream = Dd, Mu.version = t;
  }()), Mu;
}
var Ii, _f;
process.env.NODE_ENV === "production" ? (Ii = lE(), _f = sE()) : (Ii = uE(), _f = cE());
Va.version = Ii.version;
Va.renderToString = Ii.renderToString;
Va.renderToStaticMarkup = Ii.renderToStaticMarkup;
Va.renderToNodeStream = Ii.renderToNodeStream;
Va.renderToStaticNodeStream = Ii.renderToStaticNodeStream;
Va.renderToReadableStream = _f.renderToReadableStream;
const dE = ({ width: e, height: t, runtime: n }) => {
  var ce, Re, He, Ge, Ne, ye, Oe, ue;
  const { config: a } = le.useContext(bt), { sankey: i } = a, l = (ie) => ie.visualizationType === "Sankey", [c, f] = le.useState(0), u = le.useRef([]), [m, y] = le.useState(""), v = (ie) => {
    y(ie);
  }, x = () => {
    y("");
  }, [A, T] = le.useState(!1);
  le.useEffect(() => {
    window.innerWidth < 768 && window.innerHeight > window.innerWidth && T(!0);
  }, [window.innerWidth]);
  const M = () => {
    T(!1);
  };
  if (le.useEffect(() => {
    var Ce;
    let ie = 0;
    (Ce = u == null ? void 0 : u.current) == null || Ce.map(($e) => {
      const Ve = $e == null ? void 0 : $e.getBoundingClientRect().width;
      Ve > ie && (ie = Ve);
    }), f(ie);
  }, [u, i, window.innerWidth]), !l(a))
    return;
  const E = a == null ? void 0 : a.data[0], p = Array.from(new Set((ce = E == null ? void 0 : E.links) == null ? void 0 : ce.flatMap((ie) => [ie.source, ie.target]))), C = {
    nodes: p.map((ie) => ({ id: ie })),
    links: (Re = E == null ? void 0 : E.links) == null ? void 0 : Re.map((ie) => ({
      source: p.findIndex((Ce) => Ce === ie.source),
      target: p.findIndex((Ce) => Ce === ie.target),
      value: ie.value
    }))
  };
  let _ = 5;
  const w = 50, R = rE().nodeWidth(i.nodeSize.nodeWidth).nodePadding(i.nodePadding).iterations(i.iterations).nodeAlign(QS).extent([
    [i.margin.margin_x, Number(i.margin.margin_y)],
    [e - _ - c, a.heights.vertical - w]
  ]), { nodes: P, links: z } = R(C), q = (ie) => {
    var Ue;
    let Ce = 30, $e = 0, Ve = "node-value--storynode", Ee = !0;
    return (Ue = E == null ? void 0 : E.storyNodeText) != null && Ue.every((ft) => ft.StoryNode !== ie) && (Ee = !1, $e = 10, Ce = 8, Ve = "node-value"), { textPositionHorizontal: Ce, textPositionVertical: $e, classStyle: Ve, storyNodes: Ee };
  }, V = (ie) => {
    if (!(C != null && C.nodes))
      return { sourceNodes: [], activeLinks: [] };
    const Ce = C.nodes.find((Ee) => Ee.id === ie), $e = [], Ve = [];
    return Ce && (z.forEach((Ee) => {
      const Ue = Ee.target, ft = Ee.source;
      Ue.id === ie && $e.push(ft.id);
    }), $e.forEach((Ee) => {
      z.forEach((Ue) => {
        const ft = Ue.target, Qe = Ue.source;
        ft.id === m && Qe.id === Ee && Ve.push(Ue);
      });
    })), { sourceNodes: $e, activeLinks: Ve };
  }, G = `${(((He = E == null ? void 0 : E.tooltips) == null ? void 0 : He.find((ie) => ie.node === m)) || {}).value}`, ee = `${(((Ge = E == null ? void 0 : E.tooltips) == null ? void 0 : Ge.find((ie) => ie.node === m)) || {}).summary}`, W = (((Ne = E == null ? void 0 : E.tooltips) == null ? void 0 : Ne.find((ie) => ie.node === m)) || {}).column1Label, Q = (((ye = E == null ? void 0 : E.tooltips) == null ? void 0 : ye.find((ie) => ie.node === m)) || {}).column2Label, j = (((Oe = E == null ? void 0 : E.tooltips) == null ? void 0 : Oe.find((ie) => ie.node === m)) || {}).column1, te = (((ue = E == null ? void 0 : E.tooltips) == null ? void 0 : ue.find((ie) => ie.node === m)) || {}).column2, se = ({ columnData: ie }) => /* @__PURE__ */ r.createElement("ul", null, ie == null ? void 0 : ie.map((Ce, $e) => /* @__PURE__ */ r.createElement("li", { key: $e }, Ce.label, ": ", Ce.value, " (", Ce.additional_info, "%)"))), re = Va.renderToString(/* @__PURE__ */ r.createElement(se, { columnData: j })), ae = Va.renderToString(/* @__PURE__ */ r.createElement(se, { columnData: te })), K = `<div class="sankey-chart__tooltip">
                    <span class="sankey-chart__tooltip--tooltip-header">${m}</span>
                    <span class="sankey-chart__tooltip--tooltip-header">${G}</span>
                    <div class="divider"></div>
                    <span><strong>Summary: </strong>${ee}</span>
                    <div class="divider"></div>
                      <div class="sankey-chart__tooltip--info-section">
                        <div>
                          <span><strong>${W}<strong></span>
                          ${re}
                        </div>
                        <div>
                          <span><strong>${Q}<strong></span>
                          ${ae}
                        </div>
                      </div>
                    </div>`, U = C.nodes.map((ie, Ce) => {
    var Ie, Me;
    let { textPositionHorizontal: $e, textPositionVertical: Ve, classStyle: Ee, storyNodes: Ue } = q(ie.id), { sourceNodes: ft } = V(m), Qe = i.opacity.nodeOpacityDefault, We = i.nodeColor.default;
    return m !== ie.id && m !== "" && !ft.includes(ie.id) && (We = i.nodeColor.inactive, Qe = i.opacity.nodeOpacityInactive), /* @__PURE__ */ r.createElement(rt, { className: "", key: Ce }, /* @__PURE__ */ r.createElement(
      "rect",
      {
        height: ie.y1 - ie.y0 + 2,
        width: R.nodeWidth(),
        x: ie.x0,
        y: ie.y0 - 1,
        fill: We,
        fillOpacity: Qe,
        rx: i.rxValue,
        "data-tooltip-html": E.tooltips && a.enableTooltips ? K : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
        onClick: () => v(ie.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), Ue ? /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
      xt,
      {
        x: ie.x0 + $e,
        textAnchor: C.nodes.length - 1 === Ce ? "end" : "start",
        verticalAnchor: "end",
        y: (ie.y1 + ie.y0) / 2 - 30,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        className: "node-text",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => v(ie.id),
        "data-tooltip-html": E.tooltips && a.enableTooltips ? K : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      (((Ie = E == null ? void 0 : E.storyNodeText) == null ? void 0 : Ie.find((tt) => tt.StoryNode === ie.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ r.createElement(
      xt,
      {
        verticalAnchor: "end",
        className: Ee,
        x: ie.x0 + $e,
        y: (ie.y1 + ie.y0 + 25) / 2,
        fill: i.storyNodeFontColor || i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => v(ie.id),
        "data-tooltip-html": E.tooltips && a.enableTooltips ? K : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      typeof ie.value == "number" ? ie.value.toLocaleString() : ie.value
    ), /* @__PURE__ */ r.createElement(
      xt,
      {
        x: ie.x0 + $e,
        y: (ie.y1 + ie.y0) / 2 + 50,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: C.nodes.length === Ce ? "end" : "start",
        className: "node-text",
        verticalAnchor: "end",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => v(ie.id),
        "data-tooltip-html": E.tooltips && a.enableTooltips ? K : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      (((Me = E == null ? void 0 : E.storyNodeText) == null ? void 0 : Me.find((tt) => tt.StoryNode === ie.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
      xt,
      {
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => v(ie.id),
        "data-tooltip-html": E.tooltips && a.enableTooltips ? K : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
        x: ie.x0 + $e,
        y: (ie.y1 + ie.y0) / 2 + Ve,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start"
      },
      ie.id
    ), /* @__PURE__ */ r.createElement(
      "text",
      {
        x: ie.x0 + $e,
        y: (ie.y1 + ie.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => v(ie.id),
        "data-tooltip-html": E.tooltips && a.enableTooltips ? K : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      /* @__PURE__ */ r.createElement("tspan", { className: Ee }, i.nodeValueStyle.textBefore + (typeof ie.value == "number" ? ie.value.toLocaleString() : ie.value) + i.nodeValueStyle.textAfter)
    )));
  }), X = z.map((ie, Ce) => {
    const Ve = oE()(ie);
    let Ee = i.opacity.LinkOpacityDefault, Ue = i.linkColor.default, { activeLinks: ft } = V(m);
    return !ft.includes(ie) && m !== "" && (Ue = i.linkColor.inactive, Ee = i.opacity.LinkOpacityInactive), /* @__PURE__ */ r.createElement(
      "path",
      {
        key: Ce,
        d: Ve,
        stroke: Ue,
        fill: "none",
        strokeOpacity: Ee,
        strokeWidth: ie.width + 2,
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => v(ie.target.id || null),
        "data-tooltip-html": E.tooltips && a.enableTooltips ? K : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      }
    );
  }), H = C.nodes.reduce((ie, Ce) => Math.max(ie, Ce.depth), -1), be = C.nodes.filter((ie) => ie.depth === H).map((ie, Ce) => {
    var Ie, Me;
    let { textPositionHorizontal: $e, textPositionVertical: Ve, classStyle: Ee, storyNodes: Ue } = q(ie.id), { sourceNodes: ft } = V(m), Qe = i.opacity.nodeOpacityDefault, We = i.nodeColor.default;
    return m !== ie.id && m !== "" && !ft.includes(ie.id) && (We = i.nodeColor.inactive, Qe = i.opacity.nodeOpacityInactive), /* @__PURE__ */ r.createElement(rt, { className: "", key: Ce, innerRef: (tt) => u.current[Ce] = tt }, /* @__PURE__ */ r.createElement(
      "rect",
      {
        height: ie.y1 - ie.y0 + 2,
        width: R.nodeWidth(),
        x: ie.x0,
        y: ie.y0 - 1,
        fill: We,
        fillOpacity: Qe,
        rx: i.rxValue,
        "data-tooltip-html": E.tooltips && a.enableTooltips ? K : null,
        "data-tooltip-id": "tooltip",
        onClick: () => v(ie.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), Ue ? /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
      xt,
      {
        x: ie.x0 + $e,
        textAnchor: C.nodes.length - 1 === Ce ? "end" : "start",
        verticalAnchor: "end",
        y: (ie.y1 + ie.y0) / 2 - 30,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        style: { pointerEvents: "none" },
        className: "node-text"
      },
      (((Ie = E == null ? void 0 : E.storyNodeText) == null ? void 0 : Ie.find((tt) => tt.StoryNode === ie.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ r.createElement(xt, { verticalAnchor: "end", className: Ee, x: ie.x0 + $e, y: (ie.y1 + ie.y0 + 25) / 2, fill: i.storyNodeFontColor || i.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, typeof ie.value == "number" ? ie.value.toLocaleString() : ie.value), /* @__PURE__ */ r.createElement(
      xt,
      {
        x: ie.x0 + $e,
        y: (ie.y1 + ie.y0) / 2 + 50,
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: C.nodes.length === Ce ? "end" : "start",
        style: { pointerEvents: "none" },
        className: "node-text",
        verticalAnchor: "end"
      },
      (((Me = E == null ? void 0 : E.storyNodeText) == null ? void 0 : Me.find((tt) => tt.StoryNode === ie.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("text", { x: ie.x0 + $e, y: (ie.y1 + ie.y0) / 2 + Ve, dominantBaseline: "text-before-edge", fill: i.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, /* @__PURE__ */ r.createElement("tspan", { id: ie.id, className: "node-id" }, ie.id)), /* @__PURE__ */ r.createElement(
      "text",
      {
        x: ie.x0 + $e,
        y: (ie.y1 + ie.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: i.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ r.createElement("tspan", { onClick: () => v(ie.id), className: Ee }, i.nodeValueStyle.textBefore + (typeof ie.value == "number" ? ie.value.toLocaleString() : ie.value) + i.nodeValueStyle.textAfter)
    )));
  });
  return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("div", { className: "sankey-chart" }, /* @__PURE__ */ r.createElement("svg", { className: "sankey-chart__diagram", width: e, height: Number(a.heights.vertical), style: { overflow: "visible" } }, /* @__PURE__ */ r.createElement(rt, { className: "links" }, X), /* @__PURE__ */ r.createElement(rt, { className: "nodes" }, U), /* @__PURE__ */ r.createElement(rt, { className: "finalNodes", style: { display: "none" } }, be)), /* @__PURE__ */ r.createElement(Nf, { id: `cdc-open-viz-tooltip-${n.uniqueId}-sankey`, afterHide: () => x(), events: ["click"], place: "bottom", style: { backgroundColor: "rgba(238, 238, 238, 1)", color: "black", boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)" } }), A && /* @__PURE__ */ r.createElement("div", { className: "popup" }, /* @__PURE__ */ r.createElement("div", { className: "popup-content" }, /* @__PURE__ */ r.createElement("button", { className: "visually-hidden", onClick: M }, "Select for accessible version."), /* @__PURE__ */ r.createElement("p", null, /* @__PURE__ */ r.createElement("strong", null, "Please change the orientation of your screen or increase the size of your browser to view the diagram better."))))));
};
var fE = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const dr = fE;
function pE(e) {
  var t = e.labelOffset, n = e.labelProps, a = e.orientation, i = e.range, l = e.tickLabelFontSize, c = e.tickLength, f = a === dr.left || a === dr.top ? -1 : 1, u, m, y;
  if (a === dr.top || a === dr.bottom) {
    var v = a === dr.bottom && typeof n.fontSize == "number" ? n.fontSize : 0;
    u = (Number(i[0]) + Number(i[i.length - 1])) / 2, m = f * (c + t + l + v);
  } else
    u = f * ((Number(i[0]) + Number(i[i.length - 1])) / 2), m = -(c + t), y = "rotate(" + f * 90 + ")";
  return {
    x: u,
    y: m,
    transform: y
  };
}
function gs() {
  return gs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, gs.apply(this, arguments);
}
function hE(e) {
  var t = e.hideTicks, n = e.horizontal, a = e.orientation, i = e.tickClassName, l = e.tickComponent, c = e.tickLabelProps, f = e.tickStroke, u = f === void 0 ? "#222" : f, m = e.tickTransform, y = e.ticks, v = e.strokeWidth, x = e.tickLineProps;
  return y.map(function(A) {
    var T, M = A.value, E = A.index, p = A.from, C = A.to, _ = A.formattedValue, w = (T = c[E]) != null ? T : {}, R = Math.max(10, typeof w.fontSize == "number" && w.fontSize || 0), P = C.y + (n && a !== dr.top ? R : 0);
    return /* @__PURE__ */ r.createElement(rt, {
      key: "visx-tick-" + M + "-" + E,
      className: An("visx-axis-tick", i),
      transform: m
    }, !t && /* @__PURE__ */ r.createElement(en, gs({
      from: p,
      to: C,
      stroke: u,
      strokeWidth: v,
      strokeLinecap: "square"
    }, x)), l ? l(gs({}, w, {
      x: C.x,
      y: P,
      formattedValue: _
    })) : /* @__PURE__ */ r.createElement(xt, gs({
      x: C.x,
      y: P
    }, w), _));
  });
}
function bc() {
  return bc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, bc.apply(this, arguments);
}
var Yh = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function mE(e) {
  var t = e.axisFromPoint, n = e.axisLineClassName, a = e.axisToPoint, i = e.hideAxisLine, l = e.hideTicks, c = e.horizontal, f = e.label, u = f === void 0 ? "" : f, m = e.labelClassName, y = e.labelOffset, v = y === void 0 ? 14 : y, x = e.labelProps, A = x === void 0 ? Yh : x, T = e.orientation, M = T === void 0 ? dr.bottom : T, E = e.scale, p = e.stroke, C = p === void 0 ? "#222" : p, _ = e.strokeDasharray, w = e.strokeWidth, R = w === void 0 ? 1 : w, P = e.tickClassName, z = e.tickComponent, q = e.tickLineProps, V = e.tickLabelProps, G = e.tickLength, ee = G === void 0 ? 8 : G, W = e.tickStroke, Q = W === void 0 ? "#222" : W, j = e.tickTransform, te = e.ticks, se = e.ticksComponent, re = se === void 0 ? hE : se, ae = bc({}, Yh, typeof V == "object" ? V : null), K = te.map(function(X) {
    var H = X.value, Te = X.index;
    return typeof V == "function" ? V(H, Te, te) : ae;
  }), U = Math.max.apply(Math, [10].concat(K.map(function(X) {
    return typeof X.fontSize == "number" ? X.fontSize : 0;
  })));
  return /* @__PURE__ */ r.createElement(r.Fragment, null, re({
    hideTicks: l,
    horizontal: c,
    orientation: M,
    scale: E,
    tickClassName: P,
    tickComponent: z,
    tickLabelProps: K,
    tickStroke: Q,
    tickTransform: j,
    ticks: te,
    strokeWidth: R,
    tickLineProps: q
  }), !i && /* @__PURE__ */ r.createElement(en, {
    className: An("visx-axis-line", n),
    from: t,
    to: a,
    stroke: C,
    strokeWidth: R,
    strokeDasharray: _
  }), u && /* @__PURE__ */ r.createElement(xt, bc({
    className: An("visx-axis-label", m)
  }, pE({
    labelOffset: v,
    labelProps: A,
    orientation: M,
    range: E.range(),
    tickLabelFontSize: U,
    tickLength: ee
  }), A), u));
}
function yE(e, t) {
  t === void 0 && (t = "center");
  var n = e;
  if (t !== "start" && "bandwidth" in n) {
    var a = n.bandwidth();
    return t === "center" && (a /= 2), n.round() && (a = Math.round(a)), function(i) {
      var l = n(i);
      return typeof l == "number" ? l + a : l;
    };
  }
  return e;
}
function gE(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : xv;
}
function zu(e, t) {
  var n = e.x, a = e.y;
  return new pg(t ? {
    x: n,
    y: a
  } : {
    x: a,
    y: n
  });
}
function Of() {
  return Of = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Of.apply(this, arguments);
}
var Zd = 0;
function vE(e) {
  return e === void 0 && (e = Zd), typeof e == "number" ? {
    start: e,
    end: e
  } : Of({
    start: Zd,
    end: Zd
  }, e);
}
var xE = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Ff() {
  return Ff = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Ff.apply(this, arguments);
}
function bE(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Mc(e) {
  var t = e.children, n = t === void 0 ? mE : t, a = e.axisClassName, i = e.hideAxisLine, l = i === void 0 ? !1 : i, c = e.hideTicks, f = c === void 0 ? !1 : c, u = e.hideZero, m = u === void 0 ? !1 : u, y = e.innerRef, v = e.left, x = v === void 0 ? 0 : v, A = e.numTicks, T = A === void 0 ? 10 : A, M = e.orientation, E = M === void 0 ? dr.bottom : M, p = e.rangePadding, C = p === void 0 ? 0 : p, _ = e.scale, w = e.tickFormat, R = e.tickLength, P = R === void 0 ? 8 : R, z = e.tickValues, q = e.top, V = q === void 0 ? 0 : q, G = bE(e, xE), ee = w ?? gE(_), W = E === dr.left, Q = E === dr.top, j = Q || E === dr.bottom, te = yE(_), se = W || Q ? -1 : 1, re = _.range(), ae = vE(C), K = zu({
    x: Number(re[0]) + 0.5 - ae.start,
    y: 0
  }, j), U = zu({
    x: Number(re[re.length - 1]) + 0.5 + ae.end,
    y: 0
  }, j), X = (z ?? vv(_, T)).filter(function(Te) {
    return !m || Te !== 0 && Te !== "0";
  }).map(function(Te, be) {
    return {
      value: Te,
      index: be
    };
  }), H = X.map(function(Te) {
    var be = Te.value, ce = Te.index, Re = gv(te(be));
    return {
      value: be,
      index: ce,
      from: zu({
        x: Re,
        y: 0
      }, j),
      to: zu({
        x: Re,
        y: P * se
      }, j),
      formattedValue: ee(be, ce, X)
    };
  });
  return /* @__PURE__ */ r.createElement(rt, {
    className: An("visx-axis", a),
    innerRef: y,
    top: V,
    left: x
  }, n(Ff({}, G, {
    axisFromPoint: K,
    axisToPoint: U,
    hideAxisLine: l,
    hideTicks: f,
    hideZero: m,
    horizontal: j,
    numTicks: T,
    orientation: E,
    rangePadding: C,
    scale: _,
    tickFormat: ee,
    tickLength: P,
    tickPosition: te,
    tickSign: se,
    ticks: H
  })));
}
var SE = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Sc() {
  return Sc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Sc.apply(this, arguments);
}
function EE(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var kE = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function wE(e) {
  var t = e.axisClassName, n = e.labelOffset, a = n === void 0 ? 36 : n, i = e.tickLength, l = i === void 0 ? 8 : i, c = e.tickLabelProps, f = EE(e, SE), u = typeof c == "function" ? c : Sc({}, kE, c);
  return /* @__PURE__ */ r.createElement(Mc, Sc({
    axisClassName: An("visx-axis-left", t),
    labelOffset: a,
    orientation: dr.left,
    tickLabelProps: u,
    tickLength: l
  }, f));
}
var TE = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Ec() {
  return Ec = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Ec.apply(this, arguments);
}
function CE(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var AE = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function LE(e) {
  var t = e.axisClassName, n = e.labelOffset, a = n === void 0 ? 36 : n, i = e.tickLength, l = i === void 0 ? 8 : i, c = e.tickLabelProps, f = CE(e, TE), u = typeof c == "function" ? c : Ec({}, AE, c);
  return /* @__PURE__ */ r.createElement(Mc, Ec({
    axisClassName: An("visx-axis-right", t),
    labelOffset: a,
    orientation: dr.right,
    tickLabelProps: u,
    tickLength: l
  }, f));
}
var PE = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function kc() {
  return kc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, kc.apply(this, arguments);
}
function RE(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var DE = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function NE(e) {
  var t = e.axisClassName, n = e.labelOffset, a = n === void 0 ? 8 : n, i = e.tickLength, l = i === void 0 ? 8 : i, c = e.tickLabelProps, f = RE(e, PE), u = typeof c == "function" ? c : kc({}, DE, c);
  return /* @__PURE__ */ r.createElement(Mc, kc({
    axisClassName: An("visx-axis-top", t),
    labelOffset: a,
    orientation: dr.top,
    tickLabelProps: u,
    tickLength: l
  }, f));
}
var _E = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function wc() {
  return wc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, wc.apply(this, arguments);
}
function OE(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), i, l;
  for (l = 0; l < a.length; l++)
    i = a[l], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var FE = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function Uu(e) {
  var t = e.axisClassName, n = e.labelOffset, a = n === void 0 ? 8 : n, i = e.tickLength, l = i === void 0 ? 8 : i, c = e.tickLabelProps, f = OE(e, _E), u = typeof c == "function" ? c : wc({}, FE, c);
  return /* @__PURE__ */ r.createElement(Mc, wc({
    axisClassName: An("visx-axis-bottom", t),
    labelOffset: a,
    orientation: dr.bottom,
    tickLabelProps: u,
    tickLength: l
  }, f));
}
const Qd = (e) => () => e;
function ME(e, {
  sourceEvent: t,
  target: n,
  selection: a,
  mode: i,
  dispatch: l
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    selection: { value: a, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: l }
  });
}
function zE(e) {
  e.stopImmediatePropagation();
}
function Jd(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var Xh = { name: "drag" }, ef = { name: "space" }, jo = { name: "handle" }, Uo = { name: "center" };
const { abs: qh, max: Qn, min: Jn } = Math;
function Gh(e) {
  return [+e[0], +e[1]];
}
function Zh(e) {
  return [Gh(e[0]), Gh(e[1])];
}
var Ku = {
  name: "x",
  handles: ["w", "e"].map(Tc),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, tf = {
  name: "y",
  handles: ["n", "s"].map(Tc),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, da = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, Qh = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, Jh = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, $E = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, BE = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Tc(e) {
  return { type: e };
}
function IE(e) {
  return !e.ctrlKey && !e.button;
}
function HE() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function WE() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function nf(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function VE(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function jE() {
  return UE(Ku);
}
function UE(e) {
  var t = HE, n = IE, a = WE, i = !0, l = Ng("start", "brush", "end"), c = 6, f;
  function u(E) {
    var p = E.property("__brush", M).selectAll(".overlay").data([Tc("overlay")]);
    p.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", da.overlay).merge(p).each(function() {
      var _ = nf(this).extent;
      Ko(this).attr("x", _[0][0]).attr("y", _[0][1]).attr("width", _[1][0] - _[0][0]).attr("height", _[1][1] - _[0][1]);
    }), E.selectAll(".selection").data([Tc("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", da.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var C = E.selectAll(".handle").data(e.handles, function(_) {
      return _.type;
    });
    C.exit().remove(), C.enter().append("rect").attr("class", function(_) {
      return "handle handle--" + _.type;
    }).attr("cursor", function(_) {
      return da[_.type];
    }), E.each(m).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", x).filter(a).on("touchstart.brush", x).on("touchmove.brush", A).on("touchend.brush touchcancel.brush", T).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  u.move = function(E, p, C) {
    E.tween ? E.on("start.brush", function(_) {
      y(this, arguments).beforestart().start(_);
    }).on("interrupt.brush end.brush", function(_) {
      y(this, arguments).end(_);
    }).tween("brush", function() {
      var _ = this, w = _.__brush, R = y(_, arguments), P = w.selection, z = e.input(typeof p == "function" ? p.apply(this, arguments) : p, w.extent), q = Pg(P, z);
      function V(G) {
        w.selection = G === 1 && z === null ? null : q(G), m.call(_), R.brush();
      }
      return P !== null && z !== null ? V : V(1);
    }) : E.each(function() {
      var _ = this, w = arguments, R = _.__brush, P = e.input(typeof p == "function" ? p.apply(_, w) : p, R.extent), z = y(_, w).beforestart();
      Pp(_), R.selection = P === null ? null : P, m.call(_), z.start(C).brush(C).end(C);
    });
  }, u.clear = function(E, p) {
    u.move(E, null, p);
  };
  function m() {
    var E = Ko(this), p = nf(this).selection;
    p ? (E.selectAll(".selection").style("display", null).attr("x", p[0][0]).attr("y", p[0][1]).attr("width", p[1][0] - p[0][0]).attr("height", p[1][1] - p[0][1]), E.selectAll(".handle").style("display", null).attr("x", function(C) {
      return C.type[C.type.length - 1] === "e" ? p[1][0] - c / 2 : p[0][0] - c / 2;
    }).attr("y", function(C) {
      return C.type[0] === "s" ? p[1][1] - c / 2 : p[0][1] - c / 2;
    }).attr("width", function(C) {
      return C.type === "n" || C.type === "s" ? p[1][0] - p[0][0] + c : c;
    }).attr("height", function(C) {
      return C.type === "e" || C.type === "w" ? p[1][1] - p[0][1] + c : c;
    })) : E.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function y(E, p, C) {
    var _ = E.__brush.emitter;
    return _ && (!C || !_.clean) ? _ : new v(E, p, C);
  }
  function v(E, p, C) {
    this.that = E, this.args = p, this.state = E.__brush, this.active = 0, this.clean = C;
  }
  v.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(E, p) {
      return this.starting ? (this.starting = !1, this.emit("start", E, p)) : this.emit("brush", E), this;
    },
    brush: function(E, p) {
      return this.emit("brush", E, p), this;
    },
    end: function(E, p) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", E, p)), this;
    },
    emit: function(E, p, C) {
      var _ = Ko(this.that).datum();
      l.call(
        E,
        this.that,
        new ME(E, {
          sourceEvent: p,
          target: u,
          selection: e.output(this.state.selection),
          mode: C,
          dispatch: l
        }),
        _
      );
    }
  };
  function x(E) {
    if (f && !E.touches || !n.apply(this, arguments))
      return;
    var p = this, C = E.target.__data__.type, _ = (i && E.metaKey ? C = "overlay" : C) === "selection" ? Xh : i && E.altKey ? Uo : jo, w = e === tf ? null : $E[C], R = e === Ku ? null : BE[C], P = nf(p), z = P.extent, q = P.selection, V = z[0][0], G, ee, W = z[0][1], Q, j, te = z[1][0], se, re, ae = z[1][1], K, U, X = 0, H = 0, Te, be = w && R && i && E.shiftKey, ce, Re, He = Array.from(E.touches || [E], (Ee) => {
      const Ue = Ee.identifier;
      return Ee = Ep(Ee, p), Ee.point0 = Ee.slice(), Ee.identifier = Ue, Ee;
    });
    Pp(p);
    var Ge = y(p, arguments, !0).beforestart();
    if (C === "overlay") {
      q && (Te = !0);
      const Ee = [He[0], He[1] || He[0]];
      P.selection = q = [[
        G = e === tf ? V : Jn(Ee[0][0], Ee[1][0]),
        Q = e === Ku ? W : Jn(Ee[0][1], Ee[1][1])
      ], [
        se = e === tf ? te : Qn(Ee[0][0], Ee[1][0]),
        K = e === Ku ? ae : Qn(Ee[0][1], Ee[1][1])
      ]], He.length > 1 && ie(E);
    } else
      G = q[0][0], Q = q[0][1], se = q[1][0], K = q[1][1];
    ee = G, j = Q, re = se, U = K;
    var Ne = Ko(p).attr("pointer-events", "none"), ye = Ne.selectAll(".overlay").attr("cursor", da[C]);
    if (E.touches)
      Ge.moved = ue, Ge.ended = Ce;
    else {
      var Oe = Ko(E.view).on("mousemove.brush", ue, !0).on("mouseup.brush", Ce, !0);
      i && Oe.on("keydown.brush", $e, !0).on("keyup.brush", Ve, !0), hg(E.view);
    }
    m.call(p), Ge.start(E, _.name);
    function ue(Ee) {
      for (const Ue of Ee.changedTouches || [Ee])
        for (const ft of He)
          ft.identifier === Ue.identifier && (ft.cur = Ep(Ue, p));
      if (be && !ce && !Re && He.length === 1) {
        const Ue = He[0];
        qh(Ue.cur[0] - Ue[0]) > qh(Ue.cur[1] - Ue[1]) ? Re = !0 : ce = !0;
      }
      for (const Ue of He)
        Ue.cur && (Ue[0] = Ue.cur[0], Ue[1] = Ue.cur[1]);
      Te = !0, Jd(Ee), ie(Ee);
    }
    function ie(Ee) {
      const Ue = He[0], ft = Ue.point0;
      var Qe;
      switch (X = Ue[0] - ft[0], H = Ue[1] - ft[1], _) {
        case ef:
        case Xh: {
          w && (X = Qn(V - G, Jn(te - se, X)), ee = G + X, re = se + X), R && (H = Qn(W - Q, Jn(ae - K, H)), j = Q + H, U = K + H);
          break;
        }
        case jo: {
          He[1] ? (w && (ee = Qn(V, Jn(te, He[0][0])), re = Qn(V, Jn(te, He[1][0])), w = 1), R && (j = Qn(W, Jn(ae, He[0][1])), U = Qn(W, Jn(ae, He[1][1])), R = 1)) : (w < 0 ? (X = Qn(V - G, Jn(te - G, X)), ee = G + X, re = se) : w > 0 && (X = Qn(V - se, Jn(te - se, X)), ee = G, re = se + X), R < 0 ? (H = Qn(W - Q, Jn(ae - Q, H)), j = Q + H, U = K) : R > 0 && (H = Qn(W - K, Jn(ae - K, H)), j = Q, U = K + H));
          break;
        }
        case Uo: {
          w && (ee = Qn(V, Jn(te, G - X * w)), re = Qn(V, Jn(te, se + X * w))), R && (j = Qn(W, Jn(ae, Q - H * R)), U = Qn(W, Jn(ae, K + H * R)));
          break;
        }
      }
      re < ee && (w *= -1, Qe = G, G = se, se = Qe, Qe = ee, ee = re, re = Qe, C in Qh && ye.attr("cursor", da[C = Qh[C]])), U < j && (R *= -1, Qe = Q, Q = K, K = Qe, Qe = j, j = U, U = Qe, C in Jh && ye.attr("cursor", da[C = Jh[C]])), P.selection && (q = P.selection), ce && (ee = q[0][0], re = q[1][0]), Re && (j = q[0][1], U = q[1][1]), (q[0][0] !== ee || q[0][1] !== j || q[1][0] !== re || q[1][1] !== U) && (P.selection = [[ee, j], [re, U]], m.call(p), Ge.brush(Ee, _.name));
    }
    function Ce(Ee) {
      if (zE(Ee), Ee.touches) {
        if (Ee.touches.length)
          return;
        f && clearTimeout(f), f = setTimeout(function() {
          f = null;
        }, 500);
      } else
        mg(Ee.view, Te), Oe.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      Ne.attr("pointer-events", "all"), ye.attr("cursor", da.overlay), P.selection && (q = P.selection), VE(q) && (P.selection = null, m.call(p)), Ge.end(Ee, _.name);
    }
    function $e(Ee) {
      switch (Ee.keyCode) {
        case 16: {
          be = w && R;
          break;
        }
        case 18: {
          _ === jo && (w && (se = re - X * w, G = ee + X * w), R && (K = U - H * R, Q = j + H * R), _ = Uo, ie(Ee));
          break;
        }
        case 32: {
          (_ === jo || _ === Uo) && (w < 0 ? se = re - X : w > 0 && (G = ee - X), R < 0 ? K = U - H : R > 0 && (Q = j - H), _ = ef, ye.attr("cursor", da.selection), ie(Ee));
          break;
        }
        default:
          return;
      }
      Jd(Ee);
    }
    function Ve(Ee) {
      switch (Ee.keyCode) {
        case 16: {
          be && (ce = Re = be = !1, ie(Ee));
          break;
        }
        case 18: {
          _ === Uo && (w < 0 ? se = re : w > 0 && (G = ee), R < 0 ? K = U : R > 0 && (Q = j), _ = jo, ie(Ee));
          break;
        }
        case 32: {
          _ === ef && (Ee.altKey ? (w && (se = re - X * w, G = ee + X * w), R && (K = U - H * R, Q = j + H * R), _ = Uo) : (w < 0 ? se = re : w > 0 && (G = ee), R < 0 ? K = U : R > 0 && (Q = j), _ = jo), ye.attr("cursor", da[C]), ie(Ee));
          break;
        }
        default:
          return;
      }
      Jd(Ee);
    }
  }
  function A(E) {
    y(this, arguments).moved(E);
  }
  function T(E) {
    y(this, arguments).ended(E);
  }
  function M() {
    var E = this.__brush || { selection: null };
    return E.extent = Zh(t.apply(this, arguments)), E.dim = e, E;
  }
  return u.extent = function(E) {
    return arguments.length ? (t = typeof E == "function" ? E : Qd(Zh(E)), u) : t;
  }, u.filter = function(E) {
    return arguments.length ? (n = typeof E == "function" ? E : Qd(!!E), u) : n;
  }, u.touchable = function(E) {
    return arguments.length ? (a = typeof E == "function" ? E : Qd(!!E), u) : a;
  }, u.handleSize = function(E) {
    return arguments.length ? (c = +E, u) : c;
  }, u.keyModifiers = function(E) {
    return arguments.length ? (i = !!E, u) : i;
  }, u.on = function() {
    var E = l.on.apply(l, arguments);
    return E === l ? u : E;
  }, u;
}
const KE = (e, t) => e && typeof e.invert == "function" ? e.invert(t) : null, YE = ({ xMax: e, yMax: t, xScaleBrush: n }) => {
  const { tableData: a, config: i, setBrushConfig: l, getTextWidth: c } = le.useContext(bt), [f, u] = le.useState({ isBrushing: !1, selection: [] }), [m, y] = le.useState(!1), v = le.useRef(), x = 25, A = 15, M = c("Drag edges to focus on a specific segment ", `normal ${16 / 1.1}px sans-serif`), E = () => Number(t) + i.xAxis.axisBBox + x * 1.5, p = () => {
    f.selection[0] === 0 && e === f.selection[1] && y(!0);
  }, C = () => {
    (f.selection[0] !== 0 || f.selection[1] !== e) && y(!1), y(!1);
  }, _ = (w, R, P, z) => {
    const q = c(P, `normal ${14.545454545454545}px sans-serif`);
    return w.selectAll(".handle--custom").data([{ side: "left" }, { side: "right" }]).join((V) => {
      const G = V.append("g").attr("class", "handle--custom");
      return G.append("text").attr("x", (ee) => ee.side === "left" ? 0 : -q).attr("y", 30).text((ee) => ee.side === "left" ? P : z).attr("font-size", "13px"), G;
    }).attr("display", "block").attr("transform", R === null ? null : (V, G) => `translate(${R[G]},10)`);
  };
  return le.useEffect(() => {
    const w = Ko(v.current).attr("overflow", "visible");
    w.append("rect").attr("fill", "#949494").attr("stroke", "#c5c5c5").attr("stroke-width", 2).attr("ry", A).attr("rx", A).attr("height", x).attr("width", e);
    const R = (V) => {
      var ee, W, Q, j;
      if (!V)
        return;
      const G = V == null ? void 0 : V.selection;
      if (G && G.length > 0) {
        const [te, se] = G.map((U) => KE(n, U)), re = a.filter((U) => new Date(U[i.runtime.originalXAxis.dataKey]) >= te && new Date(U[i.runtime.originalXAxis.dataKey]) <= se), ae = (re.length && re[0][(W = (ee = i == null ? void 0 : i.runtime) == null ? void 0 : ee.originalXAxis) == null ? void 0 : W.dataKey]) ?? "", K = (re.length && re[re.length - 1][(j = (Q = i == null ? void 0 : i.runtime) == null ? void 0 : Q.originalXAxis) == null ? void 0 : j.dataKey]) ?? "";
        w.selectAll(".handle--custom").remove(), w.call(_, G, ae, K), l({
          active: !0,
          isBrushing: !0,
          data: re
        }), u({
          isBrushing: !0,
          selection: G
        });
      }
    }, P = jE().extent([
      [0, 0],
      [e, x]
    ]).on("start brush end", R), z = [0, e], q = w.append("g").call(P).call(P.move, z);
    return q.select(".overlay").style("pointer-events", "none"), q.selectAll(".selection").attr("fill", "#474747").attr("fill-opacity", 1).attr("rx", A).attr("ry", A), () => {
      w.selectAll("*").remove();
    };
  }, [i, i.brush.active]), console.log(i.brush.active, "ace"), /* @__PURE__ */ r.createElement(rt, { onMouseLeave: C, onMouseOver: p, className: "brush-container", left: Number(i.runtime.yAxis.size), top: E() }, /* @__PURE__ */ r.createElement(xt, { pointerEvents: "visiblePainted", display: m ? "block" : "none", fontSize: 16, x: (Number(e) - Number(M)) / 2, y: -10 }, "Drag edges to focus on a specific segment"), /* @__PURE__ */ r.createElement("svg", { width: "100%", height: x * 3, ref: v }));
}, vs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: l0,
  curveBasisClosed: s0,
  curveBasisOpen: u0,
  curveBundle: c0,
  curveCardinal: d0,
  curveCardinalClosed: f0,
  curveCardinalOpen: p0,
  curveCatmullRom: h0,
  curveCatmullRomClosed: m0,
  curveCatmullRomOpen: y0,
  curveLinear: Rc,
  curveLinearClosed: pf,
  curveMonotoneX: ju,
  curveMonotoneY: g0,
  curveNatural: v0,
  curveStep: x0,
  curveStepAfter: S0,
  curveStepBefore: b0
}, Symbol.toStringTag, { value: "Module" })), XE = (e) => {
  var P, z;
  const { xScale: t, yScale: n, yMax: a, xMax: i, handleTooltipMouseOver: l, handleTooltipMouseOff: c, isDebug: f, children: u } = e;
  let { transformedData: m, config: y, handleLineType: v, parseDate: x, formatDate: A, formatNumber: T, seriesHighlight: M, colorScale: E, rawData: p, brushConfig: C } = le.useContext(bt);
  const _ = (P = y.brush) != null && P.active && ((z = C.data) != null && z.length) ? C.data : m;
  if (!_)
    return;
  const w = (q) => (Cn(y.xAxis) ? t(x(q[y.xAxis.dataKey], !1)) : t(q[y.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), R = (q, V, G = void 0) => n(q[G.dataKey]);
  return _ && /* @__PURE__ */ r.createElement("svg", null, /* @__PURE__ */ r.createElement($r, { component: "AreaChart" }, /* @__PURE__ */ r.createElement(rt, { className: "area-chart", key: "area-wrapper", left: Number(y.yAxis.size) }, (y.runtime.areaSeriesKeys || y.series).map((q, V) => {
    let G = _.map((j) => ({
      [y.xAxis.dataKey]: j[y.xAxis.dataKey],
      [q.dataKey]: j[q.dataKey]
    })), ee = vs[q.lineType], W = y.legend.behavior === "highlight" && M.length > 0 && M.indexOf(q.dataKey) === -1, Q = y.legend.behavior === "highlight" || M.length === 0 || M.indexOf(q.dataKey) !== -1;
    return /* @__PURE__ */ r.createElement(r.Fragment, { key: V }, /* @__PURE__ */ r.createElement(
      zr,
      {
        data: G,
        x: (j) => w(j),
        y: (j) => R(j, V, q),
        stroke: Q ? E ? E(y.runtime.seriesLabels ? y.runtime.seriesLabels[q.dataKey] : q.dataKey) : "#000" : "transparent",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        curve: ee,
        strokeDasharray: q.type ? v(q.type) : 0
      }
    ), /* @__PURE__ */ r.createElement(
      Y0,
      {
        key: "area-chart",
        fill: Q ? E ? E(y.runtime.seriesLabels ? y.runtime.seriesLabels[q.dataKey] : q.dataKey) : "#000" : "transparent",
        fillOpacity: W ? 0.25 : 0.5,
        data: G,
        x: (j) => w(j),
        y: (j) => R(j, V, q),
        yScale: n,
        curve: ee,
        strokeDasharray: q.type ? v(q.type) : 0
      }
    ));
  }), /* @__PURE__ */ r.createElement(Ar, { width: Number(i), height: Number(a), fill: "transparent", fillOpacity: 0.05, onMouseMove: (q) => l(q, p), onMouseLeave: c }))));
}, qE = le.memo(XE), GE = ({ xScale: e, yScale: t, yMax: n, xMax: a, handleTooltipMouseOver: i, handleTooltipMouseOff: l, isDebug: c }) => {
  var M, E;
  let { transformedData: f, config: u, seriesHighlight: m, colorScale: y, rawData: v } = le.useContext(bt);
  const x = (M = u.brush) != null && M.active && ((E = u.brush.data) != null && E.length) ? u.brush.data : f;
  if (!x)
    return;
  const A = (p) => {
    if (u.xAxis.type === "categorical")
      return e(p);
    if (Cn(u.xAxis)) {
      let C = new Date(p);
      return e(C);
    }
  }, T = 2;
  return x && /* @__PURE__ */ r.createElement("svg", { height: Number(n) }, /* @__PURE__ */ r.createElement($r, { component: "AreaChartStacked" }, /* @__PURE__ */ r.createElement(rt, { className: "area-chart", key: "area-wrapper", left: Number(u.yAxis.size) + T / 2, height: Number(n), style: { overflow: "hidden" } }, /* @__PURE__ */ r.createElement(
    J0,
    {
      data: x,
      keys: u.runtime.areaSeriesKeys.map((p) => p.dataKey) || u.series.map((p) => p.dataKey),
      x0: (p) => A(p.data[u.xAxis.dataKey]),
      y0: (p) => Number(t(p[0])),
      y1: (p) => Number(t(p[1])),
      curve: vs[Gu[u.stackedAreaChartLineType]]
    },
    ({ stacks: p, path: C }) => p.map((_, w) => {
      let R = u.legend.behavior === "highlight" && m.length > 0 && m.indexOf(_.key) === -1, P = u.legend.behavior === "highlight" || m.length === 0 || m.indexOf(_.key) !== -1;
      return (
        // prettier-ignore
        /* @__PURE__ */ r.createElement(
          "path",
          {
            key: _.key,
            d: C(_) || "",
            strokeWidth: 2,
            stroke: P ? y ? y(u.runtime.seriesLabels ? u.runtime.seriesLabels[_.key] : _.key) : "#000" : "transparent",
            fillOpacity: R ? 0.2 : 1,
            fill: P ? y ? y(u.runtime.seriesLabels ? u.runtime.seriesLabels[_.key] : _.key) : "#000" : "transparent"
          }
        )
      );
    })
  ), /* @__PURE__ */ r.createElement(Ar, { width: Number(a), height: Number(n), fill: "transparent", onMouseMove: (p) => i(p, v), onMouseLeave: l }))));
}, ZE = le.memo(GE), Rs = () => {
  const { config: e, colorPalettes: t, tableData: n, updateConfig: a, parseDate: i, formatDate: l, setSeriesHighlight: c, seriesHighlight: f } = le.useContext(bt), { orientation: u } = e, [m, y] = le.useState(null), v = u === "horizontal", x = 1, A = e.lollipopSize === "large" ? 7 : e.lollipopSize === "medium" ? 6 : 5, T = e.lollipopSize === "large" ? 14 : e.lollipopSize === "medium" ? 12 : 10, M = e.yAxis.labelPlacement === "Below Bar", E = e.yAxis.displayNumbersOnBar, p = e.orientation === "horizontal" ? "yAxis" : "xAxis", C = e.barStyle === "rounded", _ = e.visualizationSubType === "stacked", w = e.tipRounding, R = e.roundingStyle === "standard" ? "8px" : e.roundingStyle === "shallow" ? "5px" : e.roundingStyle === "finger" ? "15px" : "0px", P = e.runtime.seriesKeys.length, z = { small: 16, medium: 18, large: 20 }, q = Object.keys(e.runtime.seriesLabels).length > 1, G = e.visualizationType === "Bar" && e.legend.behavior === "isolate" && e.legend.axisAlign && (f != null && f.length) ? f : e.runtime.barSeriesKeys || e.runtime.seriesKeys;
  return le.useEffect(() => {
    u === "horizontal" && !e.yAxis.labelPlacement && a({
      ...e,
      yAxis: {
        ...e.yAxis,
        labelPlacement: "Below Bar"
      }
    });
  }, [e, a]), le.useEffect(() => {
    e.isLollipopChart === !1 && e.barHeight < 25 && a({ ...e, barHeight: 25 });
  }, [e.isLollipopChart]), le.useEffect(() => {
    e.visualizationSubType === "horizontal" && a({
      ...e,
      orientation: "horizontal"
    });
  }, []), le.useEffect(() => {
    e.barStyle === "lollipop" && !e.isLollipopChart && a({ ...e, isLollipopChart: !0 }), (C || e.barStyle === "flat") && a({ ...e, isLollipopChart: !1 });
  }, [e.barStyle]), {
    isHorizontal: v,
    barBorderWidth: x,
    lollipopBarWidth: A,
    lollipopShapeSize: T,
    isLabelBelowBar: M,
    displayNumbersOnBar: E,
    shouldSuppress: (U) => {
      var X;
      return (X = e.preliminaryData) == null ? void 0 : X.some((H) => {
        const Te = H.column ? H.column === U.key : !0, be = String(U.value) === String(H.value) && H.value !== "";
        return Te && be && H.symbol && H.type === "suppression";
      });
    },
    section: p,
    isRounded: C,
    isStacked: _,
    tipRounding: w,
    radius: R,
    stackCount: P,
    barStackedSeriesKeys: G,
    fontSize: z,
    hasMultipleSeries: q,
    applyRadius: (U) => {
      if (U == null || !C)
        return {};
      let X = {};
      return (_ && U + 1 === P || !_) && (X = v ? { borderRadius: `0 ${R}  ${R}  0` } : { borderRadius: `${R} ${R} 0 0` }), !_ && U === -1 && (X = v ? { borderRadius: `${R} 0  0 ${R} ` } : { borderRadius: ` 0  0 ${R} ${R}` }), w === "full" && _ && U === 0 && P > 1 && (X = v ? { borderRadius: `${R} 0 0 ${R}` } : { borderRadius: `0 0 ${R} ${R}` }), w === "full" && (_ && U === 0 && P === 1 || !_) && (X = { borderRadius: R }), X;
    },
    updateBars: (U) => {
      if (e.visualizationType !== "Bar" && !v)
        return U;
      const X = [...U];
      let H;
      const Te = {
        stacked: e.barHeight,
        lollipop: A
      };
      _ ? H = Te.stacked : H = Te[e.isLollipopChart ? "lollipop" : "stacked"] * P;
      const be = M ? z[e.fontSize] * 1.2 : 0;
      let ce = Number(e.barSpace), Re = X.length * (H + be + ce);
      return v && (e.heights.horizontal = Re), X.map((He, Ge) => {
        let Ne = 0;
        return He.index !== 0 && (Ne = (H + ce + be) * Ge), { ...He, y: Ne, height: H };
      });
    },
    assignColorsToValues: (U, X, H) => {
      if (!e.legend.colorCode && e.series.length > 1)
        return H;
      const Te = e.customColors ?? t[e.palette], be = n.map((Ge) => Ge[e.legend.colorCode]);
      let ce = /* @__PURE__ */ new Map(), Re = [];
      for (let Ge = 0; Ge < be.length; Ge++)
        ce.has(be[Ge]) || ce.set(be[Ge], Te[ce.size % Te.length]), Re.push(ce.get(be[Ge]));
      for (; Re.length < U; )
        Re = Re.concat(Re);
      return Re[X];
    },
    getHighlightedBarColorByValue: (U) => {
      const X = e == null ? void 0 : e.highlightedBarValues.find((H) => {
        if (H.value)
          return e.xAxis.type === "date" ? l(i(H.value)) === U : H.value === U;
      });
      return X != null && X.color ? X.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (U) => {
      const X = e == null ? void 0 : e.highlightedBarValues.filter((H) => {
        if (H.value)
          return e.xAxis.type === "date" ? l(i(H.value)) === U : H.value === U;
      })[0];
      return X != null && X.color ? X : !1;
    },
    getAdditionalColumn: (U, X) => {
      if (!X)
        return "";
      const H = e.columns, Te = [];
      let be = "";
      const ce = n.find((Re) => Re[e.xAxis.dataKey] === X) || {};
      return Object.keys(H).forEach((Re) => {
        if (U && e.columns[Re].series && e.columns[Re].series !== U)
          return;
        const He = {
          addColPrefix: e.columns[Re].prefix,
          addColSuffix: e.columns[Re].suffix,
          addColRoundTo: e.columns[Re].roundToPlace ? e.columns[Re].roundToPlace : "",
          addColCommas: e.columns[Re].commas
        }, Ge = Mf(ce[e.columns[Re].name], "left", !0, e, He);
        e.columns[Re].tooltips && Te.push([e.columns[Re].label, Ge]);
      }), Te.forEach((Re) => {
        be += `${Re[0]} : ${Re[1]} <br/>`;
      }), be;
    },
    hoveredBar: m,
    setHoveredBar: y,
    onMouseOverBar: (U, X) => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && X && c([X]), y(U);
    },
    onMouseLeaveBar: () => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && c([]);
    }
  };
}, Ds = le.createContext(null), lp = ({ xScale: e, barWidth: t = 0, totalBarsInGroup: n = 1, yMax: a, handleTooltipMouseOff: i, handleTooltipMouseOver: l, handleTooltipClick: c, tooltipData: f, showTooltip: u, hideTooltip: m }) => {
  const { parseDate: y, config: v } = le.useContext(bt), { runtime: x, regions: A, visualizationType: T, orientation: M, xAxis: E } = v, p = e.domain(), C = (R) => {
    let P;
    if (!(R != null && R.fromType) || R.fromType === "Fixed") {
      const z = new Date(R.from), q = y(ns(v.xAxis.dateParseFormat, z)).getTime();
      P = e(q), T === "Bar" && E.type === "date-time" && (P = P - t * n / 2);
    }
    if (R.fromType === "Previous Days") {
      const z = Number(R.from) || 0;
      p.map((ee) => ns(v.xAxis.dateParseFormat, new Date(ee)));
      const q = R.toType === "Last Date" ? new Date(p[p.length - 1]).getTime() : new Date(R.to), V = v.xAxis.type === "categorical" ? ns(v.xAxis.dateParseFormat, q) : ns(v.xAxis.dateParseFormat, q), G = new Date(V);
      if (P = new Date(G.setDate(G.getDate() - Number(z))), E.type === "date") {
        P = new Date(ns(E.dateParseFormat, P)).getTime();
        let ee = p[0], W = Math.abs(P - ee);
        for (let Q = 1; Q < p.length; Q++) {
          const j = Math.abs(P - p[Q]);
          j < W && (W = j, ee = p[Q]);
        }
        P = ee;
      }
      if (E.type === "categorical") {
        let ee = p[0], W = Math.abs(new Date(P).getTime() - new Date(ee).getTime());
        for (let Q = 1; Q < p.length; Q++) {
          const j = Math.abs(new Date(P).getTime() - new Date(p[Q]).getTime());
          j < W && (W = j, ee = p[Q]);
        }
        P = ee;
      }
      P = e(P);
    }
    if (E.type === "categorical" && R.fromType !== "Previous Days" && (P = e(R.from)), T === "Line" || T === "Area Chart") {
      let z = Number(v.yAxis.size);
      e.bandwidth && (z += e.bandwidth() / 2), P = P + z;
    }
    return T === "Bar" && v.xAxis.type === "date-time" && R.fromType === "Previous Days" && (P = P - t * n / 2), P;
  }, _ = (R) => {
    let P;
    if (E.type === "categorical" && (P = e(R.to)), Cn(E) && ((!(R != null && R.toType) || R.toType === "Fixed") && (P = e(y(R.to).getTime())), (T === "Bar" || v.visualizationType === "Combo") && (P = R.toType !== "Last Date" ? e(y(R.to).getTime()) + t * n : P)), R.toType === "Last Date") {
      const z = p[p.length - 1];
      P = Number(e(z) + ((T === "Bar" || T === "Combo") && v.xAxis.type === "date" ? t * n : 0));
    }
    if (T === "Line" || T === "Area Chart") {
      let z = Number(v.yAxis.size);
      e.bandwidth && (z += e.bandwidth() / 2), P = P + z;
    }
    return T === "Bar" && v.xAxis.type === "date-time" && R.toType !== "Last Date" && (P = P - t * n / 2), (T === "Bar" || T === "Combo") && E.type === "categorical" && (P = P + (T === "Bar" || T === "Combo" ? t * n : 0)), P;
  }, w = (R, P) => R - P;
  if (A && M === "vertical")
    return A.map((R) => {
      const P = C(R), z = _(R), q = w(z, P);
      if (!P || !z)
        return null;
      const V = () => /* @__PURE__ */ r.createElement(
        "path",
        {
          stroke: "#333",
          d: `M${P} -5
                L${P} 5
                M${P} 0
                L${z} 0
                M${z} -5
                L${z} 5`
        }
      ), G = () => /* @__PURE__ */ r.createElement("rect", { x: P, y: 0, width: q, height: a, fill: R.background, opacity: 0.3 });
      return /* @__PURE__ */ r.createElement(rt, { height: 100, fill: "red", className: "regions regions-group--line zzz", key: R.label, onMouseMove: l, onMouseLeave: i, handleTooltipClick: c, tooltipData: JSON.stringify(f), showTooltip: u }, /* @__PURE__ */ r.createElement(V, null), /* @__PURE__ */ r.createElement(G, null), /* @__PURE__ */ r.createElement(xt, { x: P + q / 2, y: 5, fill: R.color, verticalAnchor: "start", textAnchor: "middle" }, R.label));
    });
};
function Ns(e) {
  var H, Te;
  const { config: t, index: n, id: a, className: i, background: l, borderColor: c, borderWidth: f, width: u, height: m, x: y, y: v, onMouseOver: x, onMouseLeave: A, onClick: T, tooltipHtml: M, tooltipId: E, styleOverrides: p, seriesHighlight: C, type: _ } = e, w = Math.max(0, u), R = Math.max(0, m), P = t.orientation === "horizontal", z = t.barStyle === "rounded", q = t.visualizationSubType === "stacked", V = t.tipRounding, G = t.visualizationType === "Combo" && ((Te = (H = t.runtime) == null ? void 0 : H.barSeriesKeys) == null ? void 0 : Te.length), ee = t.runtime.seriesKeys.length, W = t.visualizationType === "Bar" && t.legend.axisAlign && (C != null && C.length) ? C == null ? void 0 : C.length : 0, Q = G || W || ee;
  let j = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  (j > w / 2 || j > R / 2) && (j = Math.min(w / 2, R / 2));
  const te = () => `M${y},${v + R}
      L${y},${v + j}
      Q${y},${v} ${y + j},${v}
      L${y + w - j},${v}
      Q${y + w},${v} ${y + w},${v + j}
      L${y + w},${v + R}
      L${y},${v + R}`, se = () => `M${y},${v + R}
      L${y},${v}
      L${y + w - j},${v}
      Q${y + w},${v} ${y + w},${v + j}
      L${y + w},${v + R - j}
      Q${y + w},${v + R} ${y + w - j},${v + R}
      L${y},${v + R}`, re = () => `M${y + j},${v + R}
      Q${y},${v + R} ${y},${v + R - j}
      L${y},${v}
      L${y + w},${v}
      L${y + w},${v + R - j}
      Q${y + w},${v + R} ${y + w - j},${v + R}
      L${y + j},${v + R}`, ae = () => `M${y + j},${v + R}
      Q${y},${v + R} ${y},${v + R - j}
      L${y},${v + j}
      Q${y},${v} ${y + j},${v}
      L${y + w},${v}
      L${y + w},${v + R}
      L${y + j},${v + R}`, K = () => `M${y + j},${v + R}
      Q${y},${v + R} ${y},${v + R - j}
      L${y},${v + j}
      Q${y},${v} ${y + j},${v}
      L${y + w - j},${v}
      Q${y + w},${v} ${y + w},${v + j}
      L${y + w},${v + R - j}
      Q${y + w},${v + R} ${y + w - j},${v + R}
      L${y + j},${v + R}`, U = () => `M${y},${v}
      L${y + w},${v}
      L${y + w},${v + R}
      L${y},${v + R}
      L${y},${v}`;
  let X;
  return n == null || !z || _ == "axisBar" ? X = U() : (X = U(), (q && n + 1 === Q || !q) && (X = P ? se() : te()), !q && n === -1 && (X = P ? ae() : re()), V === "full" && q && n === 0 && Q > 1 && (X = P ? ae() : re()), V === "full" && (q && n === 0 && Q === 1 || !q) && (X = K())), /* @__PURE__ */ r.createElement(
    "path",
    {
      id: a,
      className: i,
      d: X,
      fill: l,
      stroke: c,
      strokeWidth: f,
      onMouseOver: x,
      onMouseLeave: A,
      onClick: T,
      "data-tooltip-html": M,
      "data-tooltip-id": E,
      style: {
        transition: "all 0.2s linear",
        ...p
      }
    }
  );
}
const QE = () => {
  var G, ee;
  const [e, t] = le.useState(0), { xScale: n, yScale: a, seriesScale: i, xMax: l, yMax: c } = le.useContext(Ds), { transformedData: f, colorScale: u, seriesHighlight: m, config: y, formatNumber: v, formatDate: x, parseDate: A, setSharedFilter: T } = le.useContext(bt), { isHorizontal: M, barBorderWidth: E, applyRadius: p, hoveredBar: C, getAdditionalColumn: _, onMouseLeaveBar: w, onMouseOverBar: R, barStackedSeriesKeys: P } = Rs(), { orientation: z } = y, q = (G = y.brush) != null && G.active && ((ee = y.brush.data) != null && ee.length) ? y.brush.data : f, V = y.runtime.xAxis.type === "date-time" || y.runtime.xAxis.type === "date";
  return y.visualizationSubType === "stacked" && !M && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(gy, { data: q, keys: P, x: (W) => W[y.runtime.xAxis.dataKey], xScale: n, yScale: a, color: u }, (W) => W.reverse().map(
    (Q) => Q.bars.map((j) => {
      let te = y.legend.behavior === "highlight" && m.length > 0 && m.indexOf(j.key) === -1, se = y.legend.behavior === "highlight" || m.length === 0 || m.indexOf(j.key) !== -1, re = V ? i.range()[1] - i.range()[0] : l / Q.bars.length;
      y.runtime.xAxis.type !== "date" && (re = y.barThickness * re);
      const ae = j.bar.data[y.runtime.xAxis.dataKey], K = V ? x(A(ae)) : ae, U = v(j.bar ? j.bar.data[j.key] : 0, "left");
      if (!U)
        return;
      const X = n(V ? A(ae) : ae) - (V ? re / 2 : 0), H = y.runtime.xAxis.label ? `${y.runtime.xAxis.label}: ${K}` : K, Te = _(C), be = `${y.runtime.seriesLabels[j.key]}: ${U}`, ce = `<ul>
                  <li class="tooltip-heading"">${H}</li>
                  <li class="tooltip-body ">${be}</li>
                  <li class="tooltip-body ">${Te}</li>
                    </li></ul>`;
      return t(re), /* @__PURE__ */ r.createElement(rt, { key: `${Q.index}--${j.index}--${z}` }, /* @__PURE__ */ r.createElement(rt, { key: `bar-stack-${Q.index}-${j.index}`, id: `barStack${Q.index}-${j.index}`, className: "stack vertical" }, Ns({
        config: y,
        seriesHighlight: m,
        index: Q.index,
        background: u(y.runtime.seriesLabels[j.key]),
        borderColor: "#333",
        borderStyle: "solid",
        borderWidth: `${y.barHasBorder === "true" ? E : 0}px`,
        width: re,
        height: j.height,
        x: X,
        y: j.y,
        onMouseOver: () => R(K, j.key),
        onMouseLeave: w,
        tooltipHtml: ce,
        tooltipId: `cdc-open-viz-tooltip-${y.runtime.uniqueId}`,
        onClick: (Re) => {
          Re.preventDefault(), T && (j[y.xAxis.dataKey] = K, T(y.uid, j));
        },
        styleOverrides: {
          animationDelay: `${Q.index * 0.5}s`,
          transformOrigin: `${re / 2}px ${j.y + j.height}px`,
          opacity: te ? 0.2 : 1,
          display: se ? "block" : "none"
        }
      })));
    })
  )), /* @__PURE__ */ r.createElement(lp, { xScale: n, yMax: c, barWidth: e, totalBarsInGroup: 1 }));
}, JE = () => {
  const { yMax: e, yScale: t, xScale: n } = le.useContext(Ds), {
    animatedChart: a,
    colorScale: i,
    config: l,
    formatDate: c,
    formatNumber: f,
    getTextWidth: u,
    parseDate: m,
    seriesHighlight: y,
    setSharedFilter: v,
    transformedData: x
  } = le.useContext(bt), { barBorderWidth: A, displayNumbersOnBar: T, fontSize: M, getAdditionalColumn: E, hoveredBar: p, isHorizontal: C, isLabelBelowBar: _, onMouseLeaveBar: w, onMouseOverBar: R, updateBars: P, barStackedSeriesKeys: z } = Rs(), { orientation: q, visualizationSubType: V } = l;
  return l.visualizationSubType === "stacked" && C && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(oS, { data: x, keys: z, height: e, y: (G) => G[l.runtime.yAxis.dataKey], xScale: n, yScale: t, color: i, offset: "none" }, (G) => G.map(
    (ee) => P(ee.bars).map((W, Q) => {
      const j = l.legend.behavior === "highlight" && y.length > 0 && y.indexOf(W.key) === -1, te = l.legend.behavior === "highlight" || y.length === 0 || y.indexOf(W.key) !== -1;
      l.barHeight = Number(l.barHeight);
      const se = Qo("#000", i(l.runtime.seriesLabels[W.key])), re = f(x[W.index][W.key], "left"), ae = l.runtime.yAxis.type === "date" ? c(m(x[W.index][l.runtime.originalXAxis.dataKey])) : x[W.index][l.runtime.originalXAxis.dataKey], K = l.runtime.yAxis.label ? `${l.runtime.yAxis.label}: ${ae}` : ae, U = u(re, `normal ${M[l.fontSize]}px sans-serif`), X = E(p), H = `${l.runtime.seriesLabels[W.key]}: ${re}`, Te = `<ul>
                  <li class="tooltip-heading"">${K}</li>
                  <li class="tooltip-body ">${H}</li>
                  <li class="tooltip-body ">${X}</li>
                    </li></ul>`;
      return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(rt, { key: Q, id: `barStack${ee.index}-${W.index}`, className: "stack horizontal" }, Ns({
        config: l,
        seriesHighlight: y,
        index: ee.index,
        className: `animated-chart group ${a ? "animated" : ""}`,
        background: i(l.runtime.seriesLabels[W.key]),
        borderColor: "#333",
        borderStyle: "solid",
        borderWidth: `${l.barHasBorder === "true" ? A : 0}px`,
        width: W.width,
        height: W.height,
        x: W.x,
        y: W.y,
        onMouseOver: () => R(ae, W.key),
        onMouseLeave: w,
        tooltipHtml: Te,
        tooltipId: `cdc-open-viz-tooltip-${l.runtime.uniqueId}`,
        onClick: (be) => {
          be.preventDefault(), v && (W[l.xAxis.dataKey] = re, v(l.uid, W));
        },
        styleOverrides: {
          animationDelay: `${ee.index * 0.5}s`,
          transformOrigin: `${W.x}px 0`,
          opacity: j ? 0.2 : 1,
          display: te ? "block" : "none"
        }
      }), q === "horizontal" && V === "stacked" && _ && ee.index === 0 && !l.yAxis.hideLabel && /* @__PURE__ */ r.createElement(
        xt,
        {
          x: `${W.x + (l.isLollipopChart ? 15 : 5)}`,
          y: W.y + W.height * 1.2,
          fill: "#000000",
          textAnchor: "start",
          verticalAnchor: "start"
        },
        ae
      ), T && U < W.width && /* @__PURE__ */ r.createElement(
        xt,
        {
          display: te ? "block" : "none",
          x: W.x + ee.bars[W.index].width / 2,
          y: W.y + W.height / 2,
          fill: se,
          textAnchor: "middle",
          verticalAnchor: "middle"
        },
        re
      )));
    })
  )));
}, Ky = ({ bar: e, defaultBarHeight: t, defaultBarWidth: n, config: a, isNumber: i, getTextWidth: l, barWidth: c, isVertical: f }) => {
  let m = t, y = n, v = "", x = !1, A = !1, T = !1;
  const M = a.general.showSuppressedSymbol;
  if (a.preliminaryData.forEach((C) => {
    (!C.column || C.column === e.key) && C.type === "suppression" && C.value && String(C.value) === String(e.value) && (!C.hideBarSymbol && M ? (m = c > 10 ? 3 : 0, y = 3, x = !0) : (m = 0, y = 0, x = !0));
  }), !x && !i(e.value) && a.general.showMissingDataLabel) {
    const C = l(v, `normal ${c / 2}px sans-serif`), _ = Number(C) < c && c > 10;
    A = !0, m = _ ? 3 : 0, y = 3;
  }
  if (!x && String(e.value) === "0" && a.general.showZeroValueDataLabel) {
    const C = l(v, `normal ${c / 2}px sans-serif`), _ = Number(C) < c && c > 10;
    m = a.isLollipopChart ? 3 * 2 : !a.isLollipopChart && _ ? 3 : 0, y = 3, T = !0;
  }
  return { barWidthHorizontal: y, barHeight: m, isSuppressed: x, showMissingDataLabel: A, showZeroValueDataLabel: T, getBarY: (C, _) => x || A || T ? a.isLollipopChart ? _ - 3 * 2 : _ - 3 : C, getAbsentDataLabel: (C) => {
    let _ = "";
    String(C) === "0" && (_ = ""), x && (_ = ""), A && (_ = "N/A"), T && (_ = "0");
    const w = l(v, `normal ${c / 2}px sans-serif`), R = Number(w) < c && c > 10;
    return a.isLollipopChart || R && f ? _ : f ? "" : _;
  } };
}, xs = (e) => e == null ? void 0 : /^0(\.0)?$/.test(e.toString()), zc = (e, t, n) => !!(e === "Line" && (t == null ? void 0 : t.length) < 3 && n), ek = () => {
  const { xScale: e, yScale: t, xMax: n, yMax: a, seriesScale: i } = le.useContext(Ds), [l, c] = le.useState(0), [f, u] = le.useState(0), {
    // prettier-ignore
    assignColorsToValues: m,
    barBorderWidth: y,
    getAdditionalColumn: v,
    getHighlightedBarByValue: x,
    getHighlightedBarColorByValue: A,
    lollipopBarWidth: T,
    lollipopShapeSize: M,
    onMouseLeaveBar: E,
    onMouseOverBar: p,
    section: C
  } = Rs(), { colorScale: _, config: w, dashboardConfig: R, tableData: P, formatDate: z, formatNumber: q, getXAxisData: V, getYAxisData: G, isNumber: ee, parseDate: W, seriesHighlight: Q, setSharedFilter: j, transformedData: te, brushConfig: se, getTextWidth: re } = le.useContext(bt), { HighLightedBarUtils: ae } = _c(w);
  let K = te;
  return w.preliminaryData.some((X) => X.value && X.type === "suppression") && (K = P), se.data.length && (K = se.data), w.visualizationSubType !== "stacked" && (w.visualizationType === "Bar" || w.visualizationType === "Combo" || zc(w.visualizationType, K, w.allowLineToBarGraph)) && w.orientation === "vertical" && /* @__PURE__ */ r.createElement(rt, null, /* @__PURE__ */ r.createElement(
    hy,
    {
      data: K,
      keys: w.runtime.barSeriesKeys || w.runtime.seriesKeys,
      height: a,
      x0: (X) => {
        const H = X[w.runtime.originalXAxis.dataKey];
        return Cn(w.runtime.xAxis) ? W(H) : H;
      },
      x0Scale: e,
      x1Scale: i,
      yScale: t,
      color: () => ""
    },
    (X) => X.map((H, Te) => /* @__PURE__ */ r.createElement(rt, { className: `bar-group-${H.index}-${H.x0}--${Te} ${w.orientation}`, key: `bar-group-${H.index}-${H.x0}--${Te}`, id: `bar-group-${H.index}-${H.x0}--${Te}`, left: H.x0 }, H.bars.map((be, ce) => {
      const Re = w.yAxis.type === "logarithmic" ? 0.1 : 0;
      let He = w.highlightedBarValues.map((ot) => ot.value).filter((ot) => ot !== void 0);
      He = w.xAxis.type === "date" ? ae.formatDates(He) : He;
      const Ge = w.legend.behavior === "highlight" && Q.length > 0 && Q.indexOf(be.key) === -1, Ne = w.legend.behavior === "highlight" || Q.length === 0 || Q.indexOf(be.key) !== -1;
      let ye = i.range()[1] - i.range()[0];
      const Oe = Math.abs(t(be.value) - t(Re)), ue = be.value >= 0 && ee(be.value) ? be.y : t(0);
      let ie = w.isLollipopChart ? T : i.bandwidth(), Ce = be.x + (w.isLollipopChart ? (ye / H.bars.length - T) / 2 : 0) - (w.xAxis.type === "date-time" ? ye / 2 : 0);
      c(ie), u(H.bars.length);
      const $e = q(/[a-zA-Z]/.test(String(be.value)) ? "" : be.value, "left"), Ve = w.runtime[C].type === "date" ? z(W(K[H.index][w.runtime.originalXAxis.dataKey])) : K[H.index][w.runtime.originalXAxis.dataKey], Ee = be.value < 0 ? -1 : ce, Ue = v(be.key, K[H.index][w.runtime.originalXAxis.dataKey]);
      let ft = w.runtime.xAxis.label ? `${w.runtime.xAxis.label}: ${Ve}` : Ve;
      const Qe = `${w.runtime.seriesLabels[be.key]}: ${$e}`, We = `<ul>
                  <li class="tooltip-heading">${ft}</li>
                  <li class="tooltip-body ">${Qe}</li>
                  ${Ue ? '<li class="tooltip-body ">' + Ue + "</li>" : ""}
                    </li></ul>`;
      let Ie = "#000000";
      Ie = ae.checkFontColor($e, He, Ie), w.runtime.seriesLabels && w.runtime.seriesLabels[be.key] ? _(w.runtime.seriesLabels[be.key]) : _(be.key);
      const Me = w.isLollipopChart && w.lollipopColorStyle === "regular", tt = w.isLollipopChart && w.lollipopColorStyle === "two-tone", Ze = He == null ? void 0 : He.includes(Ve), et = A(Ve), at = x(Ve), gt = Ze ? et : w.barHasBorder === "true" ? "#000" : "transparent", Ot = Ze ? at.borderWidth : w.isLollipopChart ? 0 : w.barHasBorder === "true" ? y : 0, { barHeight: Kt, isSuppressed: on, getBarY: Wt, getAbsentDataLabel: Zt } = Ky({ bar: be, defaultBarHeight: Oe, config: w, isNumber: ee, getTextWidth: re, barWidth: ie, isVertical: !0, yAxisValue: $e }), zt = Zt($e), fn = on || !w.labels ? "" : $e, Yt = Wt(ue, t(Re)), tn = xs(be.value) ? "none" : "block", kn = (ot, _e) => {
        var nn;
        let $t = ot, Lt = _e || "#f2f2f2";
        if (R && ((nn = R.dashboard.sharedFilters) == null ? void 0 : nn.length) !== 0) {
          const { sharedFilters: un } = R.dashboard;
          return $t = un ? un.map((At) => At.setBy === w.uid ? At.resetLabel === At.active || At.active === te[H.index][w.xAxis.dataKey] ? _(w.runtime.seriesLabels[be.key]) : Lt : _(w.runtime.seriesLabels[be.key]))[0] : _(w.runtime.seriesLabels[be.key]), Me && ($t = ot), Ze && ($t = "transparent"), w.legend.colorCode && ($t = m(X.length, H.index, ot)), tt && ($t = Ba(ot).brighten(1)), $t;
        }
        return tt && ($t = Ba(ot).brighten(1)), w.legend.colorCode && ($t = m(X.length, H.index, ot)), Ze && ($t = "transparent"), $t;
      };
      return /* @__PURE__ */ r.createElement(rt, { key: `${H.index}--${ce}` }, /* @__PURE__ */ r.createElement(rt, { key: `bar-sub-group-${H.index}-${H.x0}-${Yt}--${ce}` }, Ns({
        config: w,
        index: Ee,
        id: `barGroup${H.index}`,
        background: kn(_(w.runtime.seriesLabels[be.key])),
        borderColor: gt,
        borderStyle: "solid",
        borderWidth: `${Ot}px`,
        width: ie,
        height: Kt,
        x: Ce,
        y: Yt,
        onMouseOver: () => p(Ve, be.key),
        onMouseLeave: E,
        tooltipHtml: We,
        tooltipId: `cdc-open-viz-tooltip-${w.runtime.uniqueId}`,
        onClick: (ot) => {
          ot.preventDefault(), j && (be[w.xAxis.dataKey] = Ve, j(w.uid, be));
        },
        styleOverrides: {
          transformOrigin: `0 ${Yt + Kt}px`,
          opacity: Ge ? 0.2 : 1,
          display: Ne ? "block" : "none",
          cursor: R ? "pointer" : "default"
        }
      }), w.preliminaryData.map((ot, _e) => {
        const $t = !ot.column || ot.column === be.key;
        if (!(String(ot.value) === String(be.value) && ot.value !== "" && $t) || ie < 10 || !w.general.showSuppressedSymbol || ot.hideBarSymbol)
          return;
        const un = String(ot.symbol).includes("Asterisk"), At = un ? -5 : -8, rn = un ? "middle" : "end", ln = ot.symbol === "Asterisk" ? ie * 1.2 : ot.symbol === "Double Asterisk" ? ie : ie / 1.5;
        return /* @__PURE__ */ r.createElement(
          xt,
          {
            key: _e,
            dy: At,
            display: Ne ? "block" : "none",
            opacity: Ge ? 0.5 : 1,
            x: Ce + ie / 2,
            y: Yt,
            verticalAnchor: rn,
            fill: Ie,
            textAnchor: "middle",
            fontSize: `${ln}px`
          },
          ot.iconCode
        );
      }), /* @__PURE__ */ r.createElement(
        xt,
        {
          display: Ne ? "block" : "none",
          opacity: Ge ? 0.5 : 1,
          x: Ce + ie / 2,
          y: Yt - 5,
          fill: Ie,
          textAnchor: "middle"
        },
        xs(be.value) ? "" : fn
      ), /* @__PURE__ */ r.createElement(
        xt,
        {
          display: Ne ? "block" : "none",
          opacity: Ge ? 0.5 : 1,
          x: Ce + ie / 2,
          y: Yt - 5,
          fill: Ie,
          textAnchor: "middle",
          fontSize: w.isLollipopChart ? null : ie / 2
        },
        zt
      ), w.isLollipopChart && w.lollipopShape === "circle" && /* @__PURE__ */ r.createElement(
        "circle",
        {
          display: tn,
          cx: Ce + M / 3.5,
          cy: be.y,
          r: M / 2,
          fill: kn(_(w.runtime.seriesLabels[be.key])),
          key: `circle--${be.index}`,
          "data-tooltip-html": We,
          "data-tooltip-id": `cdc-open-viz-tooltip-${w.runtime.uniqueId}`,
          style: { filter: "unset", opacity: 1 }
        }
      ), w.isLollipopChart && w.lollipopShape === "square" && /* @__PURE__ */ r.createElement(
        "rect",
        {
          display: tn,
          x: Ce - T / 2,
          y: Yt,
          width: M,
          height: M,
          fill: kn(_(w.runtime.seriesLabels[be.key])),
          key: `circle--${be.index}`,
          "data-tooltip-html": We,
          "data-tooltip-id": `cdc-open-viz-tooltip-${w.runtime.uniqueId}`,
          style: { opacity: 1, filter: "unset" }
        },
        /* @__PURE__ */ r.createElement("animate", { attributeName: "height", values: `0, ${M}`, dur: "2.5s" })
      )));
    })))
  ), Object.keys(w.confidenceKeys).length > 0 ? K.map((X) => {
    let H, Te, be, ce, Re = 5;
    return H = e(V(X)) + (w.xAxis.type !== "date-time" ? i.range()[1] / 2 : 0), be = t(G(X, w.confidenceKeys.lower)), ce = t(G(X, w.confidenceKeys.upper)), /* @__PURE__ */ r.createElement(
      "path",
      {
        key: `confidence-interval-v-${Te}-${X[w.runtime.originalXAxis.dataKey]}`,
        stroke: "#333",
        strokeWidth: "px",
        d: `
                    M${H - Re} ${be}
                    L${H + Re} ${be}
                    M${H} ${be}
                    L${H} ${ce}
                    M${H - Re} ${ce}
                    L${H + Re} ${ce}`
      }
    );
  }) : "", /* @__PURE__ */ r.createElement(lp, { xScale: e, yMax: a, barWidth: l, totalBarsInGroup: f }));
}, tk = () => {
  var ae;
  const { xScale: e, yScale: t, yMax: n, seriesScale: a } = le.useContext(Ds), { transformedData: i, tableData: l, colorScale: c, seriesHighlight: f, config: u, formatNumber: m, formatDate: y, parseDate: v, setSharedFilter: x, isNumber: A, getTextWidth: T, getYAxisData: M, getXAxisData: E } = le.useContext(bt), { isHorizontal: p, barBorderWidth: C, updateBars: _, assignColorsToValues: w, section: R, fontSize: P, isLabelBelowBar: z, displayNumbersOnBar: q, lollipopBarWidth: V, lollipopShapeSize: G, getHighlightedBarColorByValue: ee, getHighlightedBarByValue: W, getAdditionalColumn: Q, hoveredBar: j, onMouseLeaveBar: te, onMouseOverBar: se } = Rs(), { HighLightedBarUtils: re } = _c(u);
  return u.visualizationSubType !== "stacked" && u.visualizationType === "Bar" && u.orientation === "horizontal" && /* @__PURE__ */ r.createElement(rt, null, /* @__PURE__ */ r.createElement(
    hy,
    {
      data: (ae = u.preliminaryData) != null && ae.some((K) => K.value && K.type === "suppression") ? l : i,
      keys: u.runtime.barSeriesKeys || u.runtime.seriesKeys,
      height: n,
      x0: (K) => K[u.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: a,
      yScale: e,
      color: () => ""
    },
    (K) => _(K).map((U, X) => /* @__PURE__ */ r.createElement(rt, { className: `bar-group-${U.index}-${U.x0}--${X} ${u.orientation}`, key: `bar-group-${U.index}-${U.x0}--${X}`, id: `bar-group-${U.index}-${U.x0}--${X}`, top: U.y }, U.bars.map((H, Te) => {
      var un;
      const be = u.yAxis.type === "logarithmic" ? 0.1 : 0;
      let ce = u.highlightedBarValues.map((At) => At.value).filter((At) => At !== void 0);
      ce = u.xAxis.type === "date" ? re.formatDates(ce) : ce;
      let Re = u.legend.behavior === "highlight" && f.length > 0 && f.indexOf(H.key) === -1, He = u.legend.behavior === "highlight" || f.length === 0 || f.indexOf(H.key) !== -1, Ge = u.barHeight, Ne = parseInt(u.isLollipopChart ? V : Ge);
      isNaN(Ne) && (Ne = 25);
      let ye = H.value >= 0 && A(H.value) ? H.y : t(be);
      const Oe = Math.abs(e(H.value) - e(be)), ue = H.value >= 0 && A(H.value), { barWidthHorizontal: ie, isSuppressed: Ce, getAbsentDataLabel: $e } = Ky({ bar: H, defaultBarWidth: Oe, config: u, isNumber: A, getTextWidth: T, isVertical: !1 }), Ve = H.value < 0 ? Math.abs(e(H.value)) : e(be), Ee = m(H.value, "left"), Ue = u.runtime[R].type === "date" ? y(v(i[U.index][u.runtime.originalXAxis.dataKey])) : i[U.index][u.runtime.originalXAxis.dataKey], ft = ue ? "above" : "below", Qe = $e(Ee), We = u.yAxis.displayNumbersOnBar ? Ee : "", Ie = T(We, `normal ${P[u.fontSize]}px sans-serif`), Me = Number(Ie) < Oe - 5;
      let tt = Me ? "end" : "start", Ze = "start", et = Me ? -5 : 5, at = 10;
      ft === "below" && (tt = Me ? "start" : "end", et = Me ? 5 : -5, u.isLollipopChart && (Ze = "end", at = -10));
      const gt = H.value < 0 ? -1 : Te;
      let Ot = u.runtime.yAxis.label ? `${u.runtime.yAxis.label}: ${Ue}` : Ue;
      const Kt = Q(j), on = `${u.runtime.seriesLabels[H.key]}: ${Ee}`, Wt = `<ul>
                  <li class="tooltip-heading"">${Ot}</li>
                  <li class="tooltip-body ">${on}</li>
                  <li class="tooltip-body ">${Kt}</li>
                    </li></ul>`;
      let Zt = "#000000";
      Zt = re.checkFontColor(Ee, ce, Zt);
      let zt = u.runtime.seriesLabels && u.runtime.seriesLabels[H.key] ? c(u.runtime.seriesLabels[H.key]) : c(H.key);
      zt = w(K.length, U.index, zt);
      const fn = u.isLollipopChart && u.lollipopColorStyle === "regular", Yt = u.isLollipopChart && u.lollipopColorStyle === "two-tone", tn = ce == null ? void 0 : ce.includes(Ue), kn = ee(Ue), ot = W(Ue), _e = tn ? kn : u.barHasBorder === "true" ? "#000" : "transparent", $t = tn ? ot.borderWidth : u.isLollipopChart ? 0 : u.barHasBorder === "true" ? C : 0, Lt = xs(H.value) ? "none" : "block";
      zt && Zt && Me && (Zt = Qo("#000", zt));
      const nn = () => fn ? zt : Yt ? Ba(zt).brighten(1) : tn ? "transparent" : zt;
      return /* @__PURE__ */ r.createElement(rt, { key: `${U.index}--${Te}` }, /* @__PURE__ */ r.createElement(rt, { key: `bar-sub-group-${U.index}-${U.x0}-${ye}--${Te}` }, Ns({
        config: u,
        index: gt,
        id: `barGroup${U.index}`,
        background: nn(),
        borderColor: _e,
        borderStyle: "solid",
        borderWidth: `${$t}px`,
        width: ie,
        height: Ne,
        x: Ve,
        y: Ge * H.index,
        onMouseOver: () => se(Ue, H.key),
        onMouseLeave: te,
        tooltipHtml: Wt,
        tooltipId: `cdc-open-viz-tooltip-${u.runtime.uniqueId}`,
        onClick: (At) => {
          At.preventDefault(), x && (H[u.xAxis.dataKey] = Ee, x(u.uid, H));
        },
        styleOverrides: {
          transformOrigin: `0 ${ye + Ge}px`,
          opacity: Re ? 0.2 : 1,
          display: He ? "block" : "none"
        }
      }), (un = u.preliminaryData) == null ? void 0 : un.map((At, rn) => {
        const ln = !At.column || At.column === H.key;
        if (!(String(At.value) === String(H.value) && At.value !== "" && ln) || At.hideBarSymbol || !u.general.showSuppressedSymbol)
          return;
        const Hn = String(At.symbol).includes("Asterisk") ? "middle" : "end", Pn = At.symbol === "Asterisk" ? Ge * 1.2 : At.symbol === "Double Asterisk" ? Ge : Ge / 1.5;
        return /* @__PURE__ */ r.createElement(
          xt,
          {
            key: rn,
            fontSize: Pn,
            display: He ? "block" : "none",
            opacity: Re ? 0.5 : 1,
            x: Ve,
            y: u.barHeight / 2 + u.barHeight * H.index,
            fill: "#000",
            dy: u.barHeight / 5,
            dx: 10,
            textAnchor: "start",
            verticalAnchor: Hn
          },
          At.iconCode
        );
      }), !u.isLollipopChart && /* @__PURE__ */ r.createElement(
        xt,
        {
          display: He ? "block" : "none",
          x: H.y,
          opacity: Re ? 0.5 : 1,
          y: u.barHeight / 2 + u.barHeight * H.index,
          fill: Zt,
          dx: et,
          verticalAnchor: "middle",
          textAnchor: tt
        },
        xs(H.value) ? "" : We
      ), /* @__PURE__ */ r.createElement(
        xt,
        {
          display: He ? "block" : "none",
          x: H.y,
          opacity: Re ? 0.5 : 1,
          y: u.barHeight / 2 + u.barHeight * H.index,
          fill: Zt,
          dx: Qe === "N/A" ? 20 : et,
          dy: u.isLollipopChart ? -10 : 0,
          verticalAnchor: "middle",
          textAnchor: Qe === "N/A" ? "middle" : tt
        },
        Qe
      ), u.isLollipopChart && /* @__PURE__ */ r.createElement(
        xt,
        {
          display: He ? "block" : "none",
          x: H.y,
          y: 0,
          fill: "#000000",
          dx: at,
          textAnchor: Ze,
          verticalAnchor: "middle",
          fontWeight: "normal"
        },
        xs(H.value) ? "" : We
      ), z && !u.yAxis.hideLabel && /* @__PURE__ */ r.createElement(xt, { x: u.yAxis.hideAxis ? 0 : 5, y: U.height, dy: 4, verticalAnchor: "start", textAnchor: "start" }, u.runtime.yAxis.type === "date" ? y(v(i[U.index][u.runtime.originalXAxis.dataKey])) : p ? i[U.index][u.runtime.originalXAxis.dataKey] : m(i[U.index][u.runtime.originalXAxis.dataKey])), u.isLollipopChart && u.lollipopShape === "circle" && /* @__PURE__ */ r.createElement(
        "circle",
        {
          display: Lt,
          cx: H.y,
          cy: Ge * H.index + V / 2,
          r: G / 2,
          fill: zt,
          key: `circle--${H.index}`,
          "data-tooltip-html": Wt,
          "data-tooltip-id": `cdc-open-viz-tooltip-${u.runtime.uniqueId}`,
          style: { filter: "unset", opacity: 1 }
        }
      ), u.isLollipopChart && u.lollipopShape === "square" && /* @__PURE__ */ r.createElement(
        "rect",
        {
          display: Lt,
          x: H.y > 10 ? H.y - G / 2 : 0,
          y: 0 - V / 2,
          width: G,
          height: G,
          fill: zt,
          key: `circle--${H.index}`,
          "data-tooltip-html": Wt,
          "data-tooltip-id": `cdc-open-viz-tooltip-${u.runtime.uniqueId}`,
          style: { opacity: 1, filter: "unset" }
        },
        /* @__PURE__ */ r.createElement("animate", { attributeName: "height", values: `0, ${G}`, dur: "2.5s" })
      )));
    })))
  ), Object.keys(u.confidenceKeys).length > 0 ? i.map((K) => {
    let U, X, H, Te = 5;
    return U = t(E(K)) - 0.75 * u.barHeight, X = e(M(K, u.confidenceKeys.upper)), H = e(M(K, u.confidenceKeys.lower)), /* @__PURE__ */ r.createElement(
      "path",
      {
        key: `confidence-interval-h-${U}-${K[u.runtime.originalXAxis.dataKey]}`,
        stroke: "#333",
        strokeWidth: "px",
        d: `
                    M${H} ${U - Te}
                    L${H} ${U + Te}
                    M${H} ${U}
                    L${X} ${U}
                    M${X} ${U - Te}
                    L${X} ${U + Te} `
      }
    );
  }) : "");
}, $u = {
  Vertical: ek,
  Horizontal: tk,
  StackedVertical: QE,
  StackedHorizontal: JE
}, nk = ({ xScale: e, yScale: t, seriesScale: n, xMax: a, yMax: i, handleTooltipMouseOver: l, handleTooltipMouseOff: c, handleTooltipClick: f }) => {
  const { transformedData: u, config: m } = le.useContext(bt), y = {
    xScale: e,
    yScale: t,
    xMax: a,
    yMax: i,
    seriesScale: n
  };
  return /* @__PURE__ */ r.createElement($r, { component: "BarChart" }, /* @__PURE__ */ r.createElement(Ds.Provider, { value: y }, /* @__PURE__ */ r.createElement(rt, { left: parseFloat(m.runtime.yAxis.size) }, /* @__PURE__ */ r.createElement($u.StackedVertical, null), /* @__PURE__ */ r.createElement($u.StackedHorizontal, null), /* @__PURE__ */ r.createElement($u.Vertical, null), /* @__PURE__ */ r.createElement($u.Horizontal, null), /* @__PURE__ */ r.createElement(Ar, { key: "bars", display: m.tooltips.singleSeries ? "none" : "block", width: Number(a), height: Number(i), fill: "transparent", fillOpacity: 0.05, onMouseMove: (v) => l(v, u), onMouseOut: c, onClick: (v) => f(v, u) }))));
};
function Ma() {
  return Ma = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Ma.apply(this, arguments);
}
function Di(e) {
  var t = e.x1, n = e.x2, a = e.y1, i = e.y2;
  return {
    x1: a,
    x2: i,
    y1: t,
    y2: n
  };
}
function Yy(e) {
  var t = e.left, n = t === void 0 ? 0 : t, a = e.top, i = a === void 0 ? 0 : a, l = e.className, c = e.max, f = e.min, u = e.firstQuartile, m = e.thirdQuartile, y = e.median, v = e.boxWidth, x = v === void 0 ? 10 : v, A = e.fill, T = e.fillOpacity, M = e.stroke, E = e.strokeWidth, p = e.rx, C = p === void 0 ? 2 : p, _ = e.ry, w = _ === void 0 ? 2 : _, R = e.valueScale, P = e.outliers, z = P === void 0 ? [] : P, q = e.horizontal, V = e.medianProps, G = V === void 0 ? {} : V, ee = e.maxProps, W = ee === void 0 ? {} : ee, Q = e.minProps, j = Q === void 0 ? {} : Q, te = e.boxProps, se = te === void 0 ? {} : te, re = e.outlierProps, ae = re === void 0 ? {} : re, K = e.container, U = K === void 0 ? !1 : K, X = e.containerProps, H = X === void 0 ? {} : X, Te = e.children, be = q ? i : n, ce = be + (x || 0) / 2, Re = R.range(), He = R(f ?? 0), Ge = R(u ?? 0), Ne = R(y ?? 0), ye = R(m ?? 0), Oe = R(c ?? 0), ue = {
    valueRange: Re,
    center: ce,
    offset: be,
    boxWidth: x,
    max: {
      x1: ce - (x || 0) / 4,
      x2: ce + (x || 0) / 4,
      y1: Oe,
      y2: Oe
    },
    maxToThird: {
      x1: ce,
      x2: ce,
      y1: Oe,
      y2: ye
    },
    median: {
      x1: be,
      x2: be + (x || 0),
      y1: Ne,
      y2: Ne
    },
    minToFirst: {
      x1: ce,
      x2: ce,
      y1: Ge,
      y2: He
    },
    min: {
      x1: ce - (x || 0) / 4,
      x2: ce + (x || 0) / 4,
      y1: He,
      y2: He
    },
    box: {
      x1: be,
      x2: x || 0,
      y1: ye,
      y2: Math.abs(ye - Ge)
    },
    container: {
      x1: be,
      x2: x || 0,
      y1: Math.min.apply(Math, Re),
      y2: Math.abs(Re[0] - Re[1])
    }
  };
  return q && (ue.max = Di(ue.max), ue.maxToThird = Di(ue.maxToThird), ue.box.y1 = Ge, ue.box = Di(ue.box), ue.median = Di(ue.median), ue.minToFirst = Di(ue.minToFirst), ue.min = Di(ue.min), ue.container = Di(ue.container), ue.container.y1 = Math.min.apply(Math, Re)), Te ? /* @__PURE__ */ r.createElement(r.Fragment, null, Te(ue)) : /* @__PURE__ */ r.createElement(rt, {
    className: An("visx-boxplot", l)
  }, z.map(function(ie, Ce) {
    var $e = q ? R(ie) : ce, Ve = q ? ce : R(ie);
    return /* @__PURE__ */ r.createElement("circle", Ma({
      key: "visx-boxplot-outlier-" + Ce,
      className: "visx-boxplot-outlier",
      cx: $e,
      cy: Ve,
      r: 4,
      stroke: M,
      strokeWidth: E,
      fill: A,
      fillOpacity: T
    }, ae));
  }), /* @__PURE__ */ r.createElement("line", Ma({
    className: "visx-boxplot-max",
    x1: ue.max.x1,
    y1: ue.max.y1,
    x2: ue.max.x2,
    y2: ue.max.y2,
    stroke: M,
    strokeWidth: E
  }, W)), /* @__PURE__ */ r.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: ue.maxToThird.x1,
    y1: ue.maxToThird.y1,
    x2: ue.maxToThird.x2,
    y2: ue.maxToThird.y2,
    stroke: M,
    strokeWidth: E
  }), /* @__PURE__ */ r.createElement("rect", Ma({
    className: "visx-boxplot-box",
    x: ue.box.x1,
    y: ue.box.y1,
    width: ue.box.x2,
    height: ue.box.y2,
    stroke: M,
    strokeWidth: E,
    fill: A,
    fillOpacity: T,
    rx: C,
    ry: w
  }, se)), /* @__PURE__ */ r.createElement("line", Ma({
    className: "visx-boxplot-median",
    x1: ue.median.x1,
    y1: ue.median.y1,
    x2: ue.median.x2,
    y2: ue.median.y2,
    stroke: M,
    strokeWidth: E
  }, G)), /* @__PURE__ */ r.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: ue.minToFirst.x1,
    y1: ue.minToFirst.y1,
    x2: ue.minToFirst.x2,
    y2: ue.minToFirst.y2,
    stroke: M,
    strokeWidth: E
  }), /* @__PURE__ */ r.createElement("line", Ma({
    className: "visx-boxplot-min",
    x1: ue.min.x1,
    y1: ue.min.y1,
    x2: ue.min.x2,
    y2: ue.min.y2,
    stroke: M,
    strokeWidth: E
  }, j)), U && /* @__PURE__ */ r.createElement("rect", Ma({
    x: ue.container.x1,
    y: ue.container.y1,
    width: ue.container.x2,
    height: ue.container.y2,
    fillOpacity: "0"
  }, H)));
}
Yy.propTypes = {
  max: Ye.number,
  min: Ye.number,
  firstQuartile: Ye.number,
  thirdQuartile: Ye.number,
  median: Ye.number,
  boxWidth: Ye.number,
  fill: Ye.string,
  fillOpacity: Ye.oneOfType([Ye.number, Ye.string]),
  stroke: Ye.string,
  strokeWidth: Ye.oneOfType([Ye.number, Ye.string]),
  rx: Ye.number,
  ry: Ye.number,
  outliers: Ye.arrayOf(Ye.number),
  container: Ye.bool,
  children: Ye.func
};
const rk = ({ xScale: e, yScale: t }) => {
  const { config: n, setConfig: a } = le.useContext(bt), { boxplot: i } = n;
  le.useEffect(() => {
    n.legend.hide === !1 && a({
      ...n,
      legend: {
        ...n.legend,
        hide: !0
      }
    });
  }, []);
  const l = `cdc-open-viz-tooltip-${n.runtime.uniqueId}`, c = (E) => `
      <strong>${E.columnCategory}</strong></br>
      ${i.labels.q1}: ${E.columnFirstQuartile}<br/>
      ${i.labels.q3}: ${E.columnThirdQuartile}<br/>
      ${i.labels.iqr}: ${E.columnIqr}<br/>
      ${i.labels.median}: ${E.columnMedian}
    `, f = (E) => Number(E.columnMax), u = (E) => Number(E.columnMin), m = (E) => Number(E.columnMedian), y = (E) => Number(E.columnThirdQuartile), v = (E) => Number(E.columnFirstQuartile), x = 0.5, A = e.bandwidth(), T = Math.min(40, A), M = cr[n == null ? void 0 : n.palette][0] ? cr[n == null ? void 0 : n.palette][0] : "#000";
  return /* @__PURE__ */ r.createElement($r, { component: "BoxPlot" }, /* @__PURE__ */ r.createElement(rt, { className: "boxplot", key: "boxplot-group" }, i.plots.map((E, p) => {
    const C = A - T, _ = 4;
    return /* @__PURE__ */ r.createElement(rt, { key: `boxplotplot-${p}` }, i.plotNonOutlierValues && E.nonOutlierValues.map((w, R) => /* @__PURE__ */ r.createElement("circle", { cx: e(E.columnCategory) + Number(n.yAxis.size) + A / 2, cy: t(w), r: _, fill: "#ccc", style: { opacity: 1, fillOpacity: 1, stroke: "black" }, key: `boxplot-${p}--circle-${R}` })), /* @__PURE__ */ r.createElement(
      Yy,
      {
        "data-left": e(E.columnCategory) + n.yAxis.size + C / 2 + 0.5,
        key: `box-plot-${p}`,
        min: u(E),
        max: f(E),
        left: Number(e(E.columnCategory)) + Number(n.yAxis.size) + C / 2 + 0.5,
        firstQuartile: v(E),
        thirdQuartile: y(E),
        median: m(E),
        boxWidth: T,
        fill: M,
        fillOpacity: x,
        stroke: "black",
        valueScale: t,
        outliers: i.plotOutlierValues ? E.columnOutliers : [],
        outlierProps: {
          style: {
            fill: `${M}`,
            opacity: 1
          }
        },
        medianProps: {
          style: {
            stroke: "black"
          }
        },
        boxProps: {
          style: {
            stroke: "black",
            strokeWidth: i.borders === "true" ? 1 : 0
          }
        },
        maxProps: {
          style: {
            stroke: "black"
          }
        },
        container: !0,
        containerProps: {
          "data-tooltip-html": c(E),
          "data-tooltip-id": l,
          tabIndex: -1
        }
      }
    ));
  })));
}, ak = ({ xScale: e, yScale: t }) => {
  const { transformedData: n, config: a, tableData: i, formatNumber: l, seriesHighlight: c, colorPalettes: f } = le.useContext(bt), u = 4.5, m = Object.keys(a.runtime.seriesLabels).length > 1, y = Object.entries(a.columns).filter(([x, A]) => A.tooltips).map(([x, A]) => [
    A.label || A.name,
    A.name,
    {
      addColPrefix: A.prefix,
      addColSuffix: A.suffix,
      addColRoundTo: A.roundToPlace,
      addColCommas: A.commas
    }
  ]), v = (x, A, T) => `<div>
    ${a.legend.showLegendValuesTooltip && a.runtime.seriesLabels && m ? `${a.runtime.seriesLabels[A] || ""}<br/>` : ""}
    ${a.xAxis.label}: ${l(x[a.xAxis.dataKey], "bottom")} <br/>
    ${a.yAxis.label}: ${l(x[A], "left")}<br/>
   ${y.map(([M, E, p]) => `${M} : ${Mf(i[T][E], "left", !1, a, p)}<br/>`).join("")}
</div>`;
  return /* @__PURE__ */ r.createElement(rt, { className: "scatter-plot", left: a.yAxis.size }, n.map((x, A) => a.runtime.seriesKeys.map((T, M) => {
    const E = a.legend.behavior === "highlight" && c.length > 0 && c.indexOf(T) === -1, p = a.legend.behavior === "highlight" || c.length === 0 || c.indexOf(T) !== -1, C = a.palette ? f[a.palette][M] : "#000";
    let _ = {
      filter: "unset",
      opacity: 1,
      stroke: p ? "black" : ""
    };
    return /* @__PURE__ */ r.createElement(
      "circle",
      {
        key: `${A}-${M}`,
        r: u,
        cx: e(x[a.xAxis.dataKey]),
        cy: t(x[T]),
        fill: p ? C : "transparent",
        fillOpacity: E ? 0.25 : 1,
        style: _,
        "data-tooltip-html": v(x, T, A),
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      }
    );
  })));
};
function ik({ height: e, xScale: t }) {
  const { transformedData: n, config: a, formatNumber: i, twoColorPalette: l, getTextWidth: c, updateConfig: f, parseDate: u, formatDate: m, currentViewport: y } = le.useContext(bt), { barStyle: v, tipRounding: x, roundingStyle: A, twoColor: T } = a, M = le.useRef([]), [E, p] = le.useState(window.innerWidth), C = A === "standard" ? "8px" : A === "shallow" ? "5px" : A === "finger" ? "15px" : "0px", _ = { small: 16, medium: 18, large: 20 };
  a.barStyle;
  const w = Number(a.xAxis.target), R = a.series[0].dataKey, P = Number(t.domain()[1]), q = n.some((K) => K[R] < 0) || w > 0 || t.domain()[0] < 0, V = a.barHasBorder === "true" ? 1 : 0, G = a.lollipopSize === "large" ? 7 : a.lollipopSize === "medium" ? 6 : 5, ee = a.lollipopSize === "large" ? 14 : a.lollipopSize === "medium" ? 12 : 10, W = Math.max(t(0), Math.min(t(w), t(P))), Q = (K) => {
    if (K == null || v !== "rounded")
      return;
    let U = {};
    return K === "left" && (U = { borderRadius: `${C} 0 0 ${C}` }), K === "right" && (U = { borderRadius: `0 ${C} ${C} 0` }), x === "full" && (U = { borderRadius: C }), U;
  }, j = {
    calculate: function() {
      const U = n[0][R] < w ? "left" : "right", X = `${a.xAxis.targetLabel} ${i(a.xAxis.target || 0, "left")}`, H = c(X, `bold ${_[a.fontSize]}px sans-serif`);
      let Te = a.isLollipopChart ? G / 2 : Number(a.barHeight) / 2, be = 0, ce = 0, Re = !1;
      U === "right" && (be = -10, Re = H - be < W, ce = W - H), U === "left" && (be = 10, Re = t(P) - W > H + be, ce = W), this.text = X, this.y = Te, this.x = ce, this.padding = be, this.showLabel = a.xAxis.showTargetLabel ? Re : !1;
    }
  };
  j.calculate();
  const te = le.useRef(null), se = rp(te, {});
  le.useEffect(() => {
    const K = () => {
      var U;
      p(window.innerWidth), (U = M.current) == null || U.forEach((X) => {
        !X || !X.style || (X.style.transition = "none", X.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", K), () => {
      window.removeEventListener("resize", K);
    };
  }, []);
  const [re, ae] = le.useState(!1);
  return le.useEffect(() => {
    se != null && se.isIntersecting && setTimeout(() => {
      ae(!0);
    }, 100);
  }, [se == null ? void 0 : se.isIntersecting, a.animate]), le.useEffect(() => {
    var K;
    (K = M.current) == null || K.forEach((U, X) => {
      if (!(!U || !U.style)) {
        if (a.animate) {
          const H = w / P * 100;
          U.style.opacity = "0", U.style.transform = `translate(${H / 1.07}%) scale(0, 1)`, setTimeout(() => {
            U.style.opacity = "1", U.style.transform = "translate(0) scale(1)", U.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          U.style.transition = "none", U.style.opacity = "0";
        a.animate || (U.style.transition = "none", U.style.opacity = "1");
      }
    });
  }, [a.animate, a, re]), /* @__PURE__ */ r.createElement($r, { component: "Deviation Bar" }, /* @__PURE__ */ r.createElement(rt, { left: Number(a.xAxis.size) }, n.map((K, U) => {
    const X = Number(K[R]), H = a.isLollipopChart ? G : Number(a.barHeight), Te = Number(a.barSpace), be = Math.abs(t(X) - W), ce = t(X), Re = X > w ? W : ce, He = X < w ? "left" : "right";
    let Ge = 0;
    Ge = U !== 0 ? (Te + H + V) * U : Ge;
    const Ne = (Te + H + V) * n.length;
    a.heights.horizontal = Ne;
    const Oe = c(i(X, "left"), `normal ${_[a.fontSize]}px sans-serif`) < be - 6, ue = ce, ie = Ge + H / 2, Ce = ce, $e = Ge + H / 2, Ve = ce, Ee = Ge - H / 2, Ue = Q(He), [ft, Qe] = l[T.palette], We = { left: ft, right: Qe }, Ie = Qo("#000", We[He]);
    let Me = ok(a.isLollipopChart, Oe, ee, Ie);
    const tt = i(X, "left"), Ze = a.runtime.yAxis.type === "date" ? m(u(n[U][a.runtime.originalXAxis.dataKey])) : n[U][a.runtime.originalXAxis.dataKey];
    let et = a.runtime.yAxis.label ? `${a.runtime.yAxis.label}: ${Ze}` : Ze, at = a.runtime.xAxis.label ? `${a.runtime.xAxis.label}: ${tt}` : tt;
    const gt = `<div>
          ${et}<br />
          ${at}
            </div>`;
    return /* @__PURE__ */ r.createElement(rt, { key: `deviation-bar-${a.orientation}-${R}-${U}` }, /* @__PURE__ */ r.createElement(
      "foreignObject",
      {
        ref: (Ot) => {
          M.current[U] = Ot;
        },
        x: Re,
        y: Ge,
        width: be,
        height: H,
        "data-tooltip-html": gt,
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      },
      /* @__PURE__ */ r.createElement("div", { style: { width: be, height: H, border: `${V}px solid #333`, backgroundColor: We[He], ...Ue } })
    ), a.yAxis.displayNumbersOnBar && /* @__PURE__ */ r.createElement(xt, { verticalAnchor: "middle", x: ue, y: ie, ...Me[He] }, i(K[R], "left")), a.isLollipopChart && a.lollipopShape === "circle" && /* @__PURE__ */ r.createElement("circle", { cx: Ce, cy: $e, r: ee / 2, fill: We[He], style: { filter: "unset", opacity: 1 } }), a.isLollipopChart && a.lollipopShape === "square" && /* @__PURE__ */ r.createElement("rect", { x: Ve, y: Ee, width: ee, height: ee, fill: We[He], style: { opacity: 1, filter: "unset" } }));
  }), j.showLabel && /* @__PURE__ */ r.createElement(xt, { fontWeight: "bold", dx: j.padding, verticalAnchor: "middle", x: j.x, y: j.y }, j.text), q && /* @__PURE__ */ r.createElement(en, { from: { x: W, y: 0 }, to: { x: W, y: e }, stroke: "#333", strokeWidth: 2 })), /* @__PURE__ */ r.createElement("foreignObject", { y: e / 2, ref: te }));
}
function ok(e, t, n, a) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: n + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -n,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? a : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? a : "#000000"
    }
  };
}
const lk = ({ xScale: e, yScale: t, height: n, width: a, handleTooltipMouseOver: i, handleTooltipMouseOff: l }) => {
  var T;
  const { transformedData: c, rawData: f, config: u, seriesHighlight: m } = le.useContext(bt), { xAxis: y, yAxis: v, legend: x, runtime: A } = u;
  return c && /* @__PURE__ */ r.createElement($r, { component: "ForecastingChart" }, /* @__PURE__ */ r.createElement(rt, { className: "forecasting-items", key: "forecasting-items-wrapper", left: Number(v.size) }, (T = A.forecastingSeriesKeys) == null ? void 0 : T.map((M, E) => !M || !M.stages ? !1 : M.stages.map((p, C) => {
    var z;
    const { behavior: _ } = x, w = f.filter((q) => q[M.stageColumn] === p.key);
    let R = _ === "highlight" && m.length > 0 && m.indexOf(p.key) === -1, P = _ === "highlight" || m.length === 0 || m.indexOf(p.key) !== -1;
    return /* @__PURE__ */ r.createElement(rt, { className: `forecasting-areas-combo-${E}`, key: `forecasting-areas--stage-${p.key.replaceAll(" ", "-")}-${E}` }, (z = M.confidenceIntervals) == null ? void 0 : z.map((q, V) => {
      const G = qu[p.color] || cr[p.color] || !1, ee = () => P && G[2] ? G[2] : "transparent", W = () => P && G[1] ? G[1] : "transparent";
      if (!(q.high === "" || q.low === ""))
        return /* @__PURE__ */ r.createElement(rt, { key: `forecasting-areas--stage-${p.key.replaceAll(" ", "-")}--group-${C}-${V}` }, /* @__PURE__ */ r.createElement(
          j0,
          {
            curve: ju,
            data: w,
            fill: ee(),
            opacity: R ? 0.1 : 0.5,
            x: (Q) => e(Date.parse(Q[y.dataKey])),
            y0: (Q) => t(Q[q.low]),
            y1: (Q) => t(Q[q.high])
          }
        ), V === 0 && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(zr, { data: w, x: (Q) => Number(e(Date.parse(Q[y.dataKey]))), y: (Q) => Number(t(Q[q.high])), curve: ju, stroke: W(), strokeWidth: 1, strokeOpacity: 1 }), /* @__PURE__ */ r.createElement(zr, { data: w, x: (Q) => Number(e(Date.parse(Q[y.dataKey]))), y: (Q) => Number(t(Q[q.low])), curve: ju, stroke: W(), strokeWidth: 1, strokeOpacity: 1 })));
    }));
  })), /* @__PURE__ */ r.createElement(rt, { key: "tooltip-hover-section" }, /* @__PURE__ */ r.createElement(Ar, { key: "bars", width: Number(a), height: Number(n), fill: "transparent", fillOpacity: 0.05, onMouseMove: (M) => i(M, c), onMouseOut: l }))));
};
function Yu(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
function $c(e, t) {
  const n = e.series.every(({ type: x }) => x === "Bar"), a = e.series.every(({ type: x }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(x)), i = (x) => (A) => x.reduce((T, M) => isNaN(Number(A[M])) ? T : T + Number(A[M]), 0), l = () => {
    let x = Math.max(...t.map((A) => Math.max(...e.runtime.seriesKeys.map((T) => Yu(A[T]) ? Number(u(A[T])) : 0))));
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && n) && e.visualizationSubType === "stacked") {
      const A = t.map(i(e.runtime.seriesKeys)).filter((T) => !isNaN(T));
      x = Math.max(...A);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const A = t.map(i(e.runtime.seriesKeys));
      x = Math.max(...A);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (x = Math.max(...t.map((A) => Yu(A[e.series.dataKey]) ? Number(u(A[e.series.dataKey])) : 0))), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !n && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const A = t.map(i(e.runtime.barSeriesKeys)), T = Math.max(...t.map((E) => Math.max(...e.runtime.lineSeriesKeys.map((p) => Number(u(E[p])))))), M = Math.max(...A);
      x = Math.max(M, T);
    }
    return x;
  }, c = () => {
    const x = Math.min(...t.map((A) => Math.min(...e.runtime.seriesKeys.map((T) => Yu(A[T]) ? Number(u(A[T])) : 1 / 0))));
    return String(x);
  }, f = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((x) => t.some((A) => A[x] >= 0)) : !1, u = (x) => x === null || x === "" ? "" : typeof x == "string" ? x.replace(/[,$]/g, "") : x, m = Number(l()), y = Number(c()), v = f();
  return { minValue: y, maxValue: m, existPositiveValue: v, isAllLine: a };
}
function sp({ config: e, yMax: t = 0, data: n = [], updateConfig: a }) {
  var x, A, T, M;
  const i = e.visualizationType === "Combo" && e.orientation === "vertical", l = e.series && e.series.filter((E) => E.axis === "Right").map((E) => E.dataKey);
  let { minValue: c } = $c(e, n);
  const f = (E) => {
    if (!E)
      return [0];
    let p = [];
    return E.map((C, _) => p = [...p, ...n.map((w) => Number(w[C]))]), p;
  };
  let u = Math.max.apply(null, f(l));
  e.yAxis.rightMax > u && (u = e.yAxis.rightMax), e.yAxis.rightMin < c && (c = e.yAxis.rightMin);
  const m = ((A = (x = e.runtime) == null ? void 0 : x.barSeriesKeys) == null ? void 0 : A.length) > 0, y = ((M = (T = e.runtime) == null ? void 0 : T.lineSeriesKeys) == null ? void 0 : M.length) > 0;
  return (m || y) && c > 0 && (c = 0), { yScaleRight: In({
    domain: [c, u],
    range: [t, 0]
  }), hasRightAxis: i };
}
const sk = (e) => {
  const { preliminaryData: t, data: n, stroke: a, strokeWidth: i, handleLineType: l, lineType: c, seriesKey: f } = e, u = t.filter((x) => x.seriesKey && x.column && x.value && x.type && x.style && x.type === "effect"), m = (x) => u.find((A) => A.seriesKey === f && x[A.column] === A.value && A.type === "effect" && A.style !== "Open Circles");
  let y = [];
  const v = (x) => ({
    stroke: a,
    strokeWidth: i,
    strokeDasharray: x
  });
  return n.forEach((x, A) => {
    let T = m(x), M = v(l(T ? T.style : c));
    y.push(M), T && A > 0 && (y[A - 1] = v(l(T.style)));
  }), y;
}, uk = (e, t, n) => {
  const a = e == null ? void 0 : e.filter((l) => l.style.includes("Circles") && l.type === "effect").map((l) => ({ column: l.column, value: l.value, seriesKey: l.seriesKey, circleSize: l.circleSize, style: l.style })), i = [];
  return t.forEach((l) => {
    a.forEach((c) => {
      if (l[c.column] === c.value && c.seriesKey === n && l[n] && c.style === "Open Circles") {
        const f = {
          data: l,
          size: c.circleSize,
          isFilled: !1
        };
        i.push(f);
      }
      if ((!c.value || l[c.column] === c.value) && c.seriesKey === n && l[n] && c.style === "Filled Circles") {
        const f = {
          data: l,
          size: c.circleSize,
          isFilled: !0
        };
        i.push(f);
      }
    });
  }), i;
}, Cc = (e) => !isNaN(parseFloat(e)) && isFinite(e), ck = (e, t, n) => {
  const a = {
    data: [],
    style: ""
  };
  if (!e.length)
    return a;
  const i = e[0], l = (f) => {
    if (!(f.type === "effect" || f.hideLineStyle))
      return f.type == "suppression" && f.value === i[t] && (!f.column || f.column === t);
  }, c = n.find(l);
  if (c && c.style) {
    const f = { ...i, [t]: 0 };
    a.data.push(f), a.style = c.style;
    let u = 1;
    for (; u < e.length && !Cc(e[u][t]); )
      u++;
    u < e.length && a.data.push(e[u]);
  } else
    a.data.push(i);
  return a;
}, dk = (e, t, n) => {
  const a = {
    data: [],
    style: ""
  };
  let i = -1;
  return n == null || n.forEach((l) => {
    if (l.type !== "effect" && e[e.length - 1][t] === l.value && l.style && (!l.column || l.column === t) && l.type == "suppression" && !l.hideLineStyle) {
      const c = e.length - 1, f = { ...e[c], [t]: 0 };
      a.data.push(f);
      let u = c - 1;
      for (; u >= 0 && !Cc(e[u][t]); )
        u--;
      u >= 0 && i !== u && (a.data.push(e[u]), i = u), a.style = l.style;
    }
  }), a;
};
function fk(e, t, n, a) {
  const i = {
    data: [],
    style: ""
  }, l = (c) => c > 0 && c < e.length - 1;
  return a == null || a.forEach((c) => {
    if (c.type === "effect" || c.hideLineStyle)
      return;
    const f = c.value;
    e.reduce((m, y, v) => (y[t] === f && l(v) && (!c.column || c.column === t) && m.push(v), m), []).forEach((m) => {
      i.style = c.style, Cc(e[m - 1][t]) && i.data.push(e[m - 1]);
      const y = e.slice(m + 1).findIndex((v) => v[t] !== f && Cc(v[t]));
      y !== -1 && i.data.push(e[m + 1 + y]);
    });
  }), i.data = vr.uniqWith(i.data, (c, f) => c[n] === f[n] && c[t] === f[t]), i;
}
const pk = (e, t, n, a) => {
  const i = ck(e, t, n), l = dk(e, t, n), c = fk(e, t, a, n);
  return [i, c, l].filter((f) => f.data.length > 0 && f.style !== "");
}, rf = (e) => {
  var w, R, P, z, q, V, G, ee;
  const { config: t, d: n, tableData: a, displayArea: i, seriesKey: l, tooltipData: c, xScale: f, yScale: u, colorScale: m, parseDate: y, yScaleRight: v, data: x, circleData: A, dataIndex: T, mode: M } = e, { lineDatapointStyle: E } = t, p = (w = t == null ? void 0 : t.series.filter((W) => W.dataKey === l)) == null ? void 0 : w[0], C = (W, Q, j, te, se) => {
    const re = j.runtime.seriesLabels || [];
    let ae;
    return W ? ae = Q(re[te] || se) : ae = "transparent", j.lineDatapointColor === "Lighter than Line" && ae !== "transparent" && ae && (ae = Ba(ae).brighten(1)), ae;
  }, _ = (W) => (t.xAxis.type === "categorical" ? f(W) : f(y(W))) + (f.bandwidth ? f.bandwidth() / 2 : 0);
  if (M === "ALWAYS_SHOW_POINTS") {
    if (E === "hidden")
      return /* @__PURE__ */ r.createElement(r.Fragment, null);
    if (E === "always show")
      return (A == null ? void 0 : A.some((Q) => Q[t.xAxis.dataKey] === n[t.xAxis.dataKey] && Q[l] === n[l])) ? /* @__PURE__ */ r.createElement(r.Fragment, null) : /* @__PURE__ */ r.createElement(
        "circle",
        {
          cx: _(n[t.xAxis.dataKey]),
          cy: p.axis === "Right" ? v(n[p.dataKey]) : u(n[p.dataKey]),
          r: 4.5,
          opacity: n[l] ? 1 : 0,
          fillOpacity: 1,
          fill: C(i, m, t, l, l),
          style: { filter: "unset", opacity: 1 }
        }
      );
  }
  if (M === "HOVER_POINTS" && E === "hover") {
    if (!c || !l || !c.data)
      return;
    let W = (P = (R = c == null ? void 0 : c.data) == null ? void 0 : R[0]) == null ? void 0 : P[1];
    if (!W)
      return;
    let Q, j = c.data.filter((re) => re[0] === l), te = (z = j == null ? void 0 : j[0]) == null ? void 0 : z[0], se = (q = j == null ? void 0 : j[0]) == null ? void 0 : q[2];
    return te ? (c == null || c.data.indexOf(te), Q = (V = a == null ? void 0 : a.find((re) => re[t == null ? void 0 : t.xAxis.dataKey] === W)) == null ? void 0 : V[l], c == null ? void 0 : c.data.map((re, ae) => (t.runtime.seriesLabelsAll.indexOf(W), isNaN(Q) ? /* @__PURE__ */ r.createElement(r.Fragment, null) : (A == null ? void 0 : A.some((U) => U[t.xAxis.dataKey] === W)) ? /* @__PURE__ */ r.createElement(r.Fragment, null) : /* @__PURE__ */ r.createElement(
      "circle",
      {
        cx: _(W),
        cy: se === "right" ? v(Q) : u(Q),
        r: 4.5,
        opacity: 1,
        fillOpacity: 1,
        fill: C(i, m, t, te, l),
        style: { filter: "unset", opacity: 1 },
        key: `line-chart-circle--${JSON.stringify(re)}--${ae}`
      }
    )))) : void 0;
  }
  return M === "ISOLATED_POINTS" && M && ((Q, j) => {
    const te = x[Q], se = Q > 0 ? x[Q - 1] : null, re = Q < x.length - 1 ? x[Q + 1] : null;
    let ae = !1;
    return Q === 0 && re && !re[j] && (ae = !0), Q === x.length - 1 && se && !se[j] && (ae = !0), Q > 0 && Q < x.length - 1 && te && te[j] && (!se || !se[j]) && (!re || !re[j]) && (ae = !0), ae;
  })(T, l) ? /* @__PURE__ */ r.createElement("circle", { cx: _(n[(G = t.xAxis) == null ? void 0 : G.dataKey]), cy: (p == null ? void 0 : p.axis) === "Right" ? v(n[p == null ? void 0 : p.dataKey]) : u(n[p == null ? void 0 : p.dataKey]), r: 5.3, strokeWidth: 2, stroke: m(t.runtime.seriesLabels[l]), fill: m((ee = t.runtime) == null ? void 0 : ee.seriesLabels[l]) }) : null;
}, hk = (e) => {
  const { config: t, xScale: n, yScale: a, parseDate: i } = e;
  if (!t.series)
    return;
  const l = (y) => {
    if (t.xAxis.type === "date")
      return i(y).getTime();
    if (t.xAxis.type === "date-time")
      return new Date(y);
    if (t.xAxis.type === "categorical")
      return y;
  }, c = (y) => n.bandwidth ? n.bandwidth() / 2 + Number(y) : Number(y), f = (y) => {
    var v;
    return (v = Object.values(t.columns)) == null ? void 0 : v.filter((x) => x.tooltips).map((x) => `
        <li className='tooltip-body'>
          <strong>${x.label || x.name}</strong>: ${y[x.name]}
        </li>`).join(" ");
  }, u = (y) => `<ul> ${f(y)} </ul>`, m = t.series.map((y) => t.data.map((v, x) => {
    let A = v[y.dataKey], T = v[t.xAxis.dataKey];
    return /* @__PURE__ */ r.createElement(r.Fragment, { key: `bump-circle-${A}-${x}` }, /* @__PURE__ */ r.createElement(rt, { left: Number(t.runtime.yAxis.size) }, A && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
      "circle",
      {
        key: `bump-circle-${A}-${x}`,
        "data-tooltip-html": u(v),
        "data-tooltip-id": "bump-chart",
        r: 10,
        cx: Number(c(n(l(T)))),
        cy: Number(a(A)),
        stroke: "#CACACA",
        strokeWidth: 1,
        fill: "#E5E4E2"
      }
    ), A.toString().length === 2 ? (
      // prettier-ignore
      /* @__PURE__ */ r.createElement(
        "text",
        {
          x: Number(c(n(l(T)))) - 7,
          y: Number(a(A)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        A
      )
    ) : (
      // prettier-ignore
      /* @__PURE__ */ r.createElement(
        "text",
        {
          x: Number(c(n(l(T)))) - 4,
          y: Number(a(A)) + 4,
          fill: "#000000",
          fontSize: 11.5
        },
        A
      )
    ))));
  }));
  return /* @__PURE__ */ r.createElement(r.Fragment, null, m);
}, em = (e) => {
  var Q;
  const {
    getXAxisData: t,
    getYAxisData: n,
    handleTooltipClick: a,
    handleTooltipMouseOff: i,
    handleTooltipMouseOver: l,
    tooltipData: c,
    xMax: f,
    xScale: u,
    yMax: m,
    yScale: y
  } = e, { colorScale: v, config: x, formatNumber: A, handleLineType: T, isNumber: M, parseDate: E, seriesHighlight: p, tableData: C, transformedData: _, updateConfig: w, brushConfig: R, clean: P } = le.useContext(bt), { yScaleRight: z } = sp({ config: x, yMax: m, data: _, updateConfig: w });
  if (!l)
    return;
  const { lineDatapointStyle: q, showLineSeriesLabels: V, legend: G } = x;
  let ee = _, W = C;
  return R.data.length > 0 && ((Q = x.brush) != null && Q.active) && (ee = P(R.data), W = P(R.data)), /* @__PURE__ */ r.createElement($r, { component: "LineChart" }, /* @__PURE__ */ r.createElement(rt, { left: Number(x.runtime.yAxis.size) }, " ", (x.runtime.lineSeriesKeys || x.runtime.seriesKeys).map((j, te) => {
    var be;
    let se = x.runtime.series.filter((ce) => ce.dataKey === j)[0].type;
    const re = x.runtime.series.filter((ce) => ce.dataKey === j), ae = re[0].axis ? re[0].axis : "left";
    let K = G.behavior === "highlight" || p.length === 0 || p.indexOf(j) !== -1;
    const U = uk(x == null ? void 0 : x.preliminaryData, W, j);
    let X = sk({ preliminaryData: x.preliminaryData, data: W, stroke: v(x.runtime.seriesLabels[j]), strokeWidth: re[0].weight || 2, handleLineType: T, lineType: se, seriesKey: j });
    const H = pk(C, j, x.preliminaryData, x.xAxis.dataKey);
    let Te = (ce) => u(t(ce)) + (u.bandwidth ? u.bandwidth() / 2 : 0);
    return /* @__PURE__ */ r.createElement(
      rt,
      {
        key: `series-${j}`,
        opacity: G.behavior === "highlight" && p.length > 0 && p.indexOf(j) === -1 ? 0.5 : 1,
        display: G.behavior === "highlight" || p.length === 0 && !G.dynamicLegend || p.indexOf(j) !== -1 ? "block" : "none"
      },
      ee.map((ce, Re) => {
        const He = x.runtime.series.find(({ dataKey: ue }) => ue === j), { axis: Ge } = He, Ne = Object.keys(x.runtime.seriesLabels).length > 1, ye = Ge === "Right" ? "rightLabel" : "label";
        let Oe = x.runtime.yAxis[ye];
        return Ne || (Oe = x.isLegendValue ? x.runtime.seriesLabels[j] : Oe), ce[j] !== void 0 && ce[j] !== "" && ce[j] !== null && M(ce[j]) && /* @__PURE__ */ r.createElement(rt, { key: `series-${j}-point-${Re}`, className: "checkwidth" }, /* @__PURE__ */ r.createElement(Ar, { key: "bars", width: Number(f), height: Number(m), fill: "transparent", fillOpacity: 0.05, onMouseMove: (ue) => l(ue, C), onMouseOut: i, onClick: (ue) => a(ue, ee) }), x.labels && /* @__PURE__ */ r.createElement(xt, { x: Te(ce), y: ae === "Right" ? z(n(ce, j)) : y(n(ce, j)), fill: "#000", textAnchor: "middle" }, A(ce[j], "left")), (q === "hidden" || q === "always show") && /* @__PURE__ */ r.createElement(
          rf,
          {
            mode: "ALWAYS_SHOW_POINTS",
            dataIndex: Re,
            circleData: U,
            tableData: C,
            data: ee,
            d: ce,
            config: x,
            seriesKey: j,
            displayArea: K,
            tooltipData: c,
            xScale: u,
            yScale: y,
            colorScale: v,
            parseDate: E,
            yScaleRight: z,
            seriesAxis: ae,
            key: `line-circle--${Re}`
          }
        ), /* @__PURE__ */ r.createElement(
          rf,
          {
            mode: "ISOLATED_POINTS",
            dataIndex: Re,
            tableData: C,
            circleData: U,
            data: ee,
            d: ce,
            config: x,
            seriesKey: j,
            displayArea: K,
            tooltipData: c,
            xScale: u,
            yScale: y,
            colorScale: v,
            parseDate: E,
            yScaleRight: z,
            seriesAxis: ae,
            key: `isolated-circle-${Re}`
          }
        ));
      }),
      /* @__PURE__ */ r.createElement(r.Fragment, null, q === "hover" && /* @__PURE__ */ r.createElement(
        rf,
        {
          tableData: C,
          dataIndex: 0,
          mode: "HOVER_POINTS",
          circleData: U,
          data: ee,
          config: x,
          seriesKey: j,
          displayArea: K,
          tooltipData: c,
          xScale: u,
          yScale: y,
          colorScale: v,
          parseDate: E,
          yScaleRight: z,
          seriesAxis: ae
        }
      )),
      (be = x == null ? void 0 : x.preliminaryData) != null && be.some((ce) => ce.value && ce.type) ? /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
        vy,
        {
          curve: vs[re[0].lineType],
          segments: ee.map((ce) => [ce]),
          segmentation: "x",
          x: (ce) => Te(ce),
          y: (ce) => ae === "Right" ? z(n(ce, j)) : y(Number(n(ce, j))),
          styles: X,
          defined: (ce, Re) => ce[j] !== "" && ce[j] !== null && ce[j] !== void 0
        }
      ), H.map((ce, Re) => /* @__PURE__ */ r.createElement(
        zr,
        {
          key: Re,
          data: ce.data,
          x: (He) => Te(He),
          y: (He) => ae === "Right" ? z(n(He, j)) : y(Number(n(He, j))),
          stroke: v(x.runtime.seriesLabels[j]),
          strokeWidth: re[0].weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: T(ce.style),
          defined: (He, Ge) => He[j] !== "" && He[j] !== null && He[j] !== void 0
        }
      ))) : /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
        zr,
        {
          curve: vs[re[0].lineType],
          data: x.visualizationType == "Bump Chart" ? ee : x.xAxis.type === "date-time" || x.xAxis.type === "date" ? ee.sort((ce, Re) => {
            let He = t(ce), Ge = t(Re);
            return He < Ge ? -1 : Ge < He ? 1 : 0;
          }) : ee,
          x: (ce) => Te(ce),
          y: (ce) => ae === "Right" ? z(n(ce, j)) : y(Number(n(ce, j))),
          stroke: v(x.runtime.seriesLabels[j]),
          strokeWidth: re[0].weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: se ? T(se) : 0,
          defined: (ce, Re) => ce[j] !== "" && ce[j] !== null && ce[j] !== void 0
        }
      )),
      U.map((ce, Re) => /* @__PURE__ */ r.createElement(
        "circle",
        {
          key: Re,
          cx: Te(ce.data),
          cy: ae === "Right" ? z(n(ce.data, j)) : y(Number(n(ce.data, j))),
          r: ce.size,
          strokeWidth: re[0].weight || 2,
          stroke: v ? v(x.runtime.seriesLabels[j]) : "#000",
          fill: ce.isFilled ? v ? v(x.runtime.seriesLabels[j]) : "#000" : "#fff"
        }
      )),
      x.animate && /* @__PURE__ */ r.createElement(
        zr,
        {
          className: "animation",
          curve: vs[re[0].lineType],
          data: ee,
          x: (ce) => Te(ce),
          y: (ce) => ae === "Right" ? z(n(ce, j)) : y(Number(n(ce, j))),
          stroke: "#fff",
          strokeWidth: 3,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: se ? T(se) : 0,
          defined: (ce, Re) => ce[j] !== "" && ce[j] !== null && ce[j] !== void 0
        }
      ),
      V && (x.runtime.lineSeriesKeys || x.runtime.seriesKeys).map((ce) => {
        let Re;
        for (let He = ee.length - 1; He >= 0; He--)
          if (ee[He][ce]) {
            Re = ee[He];
            break;
          }
        return Re ? /* @__PURE__ */ r.createElement("text", { x: Te(Re) + 5, y: y(n(Re, ce)), alignmentBaseline: "middle", fill: x.colorMatchLineSeriesLabels && v ? v(x.runtime.seriesLabels[ce] || ce) : "black" }, x.runtime.seriesLabels[ce] || ce) : /* @__PURE__ */ r.createElement(r.Fragment, null);
      })
    );
  }), x.legend.dynamicLegend && p.length === 0 && /* @__PURE__ */ r.createElement(xt, { x: f / 2, y: m / 2, fill: "black", textAnchor: "middle", color: "black" }, x.legend.dynamicLegendChartMessage)), x.visualizationType === "Bump Chart" && /* @__PURE__ */ r.createElement(hk, { config: x, xScale: u, yScale: y }));
}, mk = (e) => {
  const { rawData: t, updateConfig: n } = le.useContext(bt), { xScale: a, yScale: i, config: l, height: c, width: f, handleTooltipMouseOff: u, handleTooltipMouseOver: m } = e, { forestPlot: y } = l, v = l.xAxis.tickWidthMax + 10, [x, A] = le.useState(!1);
  le.useEffect(() => {
    try {
      const w = ["estimateField", "lower", "upper", "estimateRadius"], R = l, P = 10;
      for (let z = 0; z < P; z++)
        w.forEach((q) => {
          var V;
          l.forestPlot[q] && l.forestPlot[q] !== ((V = R.columns[l.forestPlot[`additionalColumn${z}`]]) == null ? void 0 : V.name) && (delete R.columns[`additionalColumn${z}`], R.columns[l.forestPlot[q]] = {}, R.columns[l.forestPlot[q]].dataKey = R.forestPlot[q], R.columns[l.forestPlot[q]].name = R.forestPlot[q], R.columns[l.forestPlot[q]].dataTable = !0, R.columns[l.forestPlot[q]].tooltips = !0, R.columns[l.forestPlot[q]].label = R.forestPlot[q]);
        });
      l.forestPlot.radius.scalingColumn && (R.columns[l.forestPlot.radius.scalingColumn] = {}, R.columns[l.forestPlot.radius.scalingColumn].dataKey = R.forestPlot.radius.scalingColumn, R.columns[l.forestPlot.radius.scalingColumn].name = R.forestPlot.radius.scalingColumn, R.columns[l.forestPlot.radius.scalingColumn].label = R.forestPlot.radius.scalingColumn, R.columns[l.forestPlot.radius.scalingColumn].dataTable = !0, R.columns[l.forestPlot.radius.scalingColumn].tooltips = !0), R.table.showVertical && (R.table.indexLabel = l.xAxis.dataKey), n(R);
    } catch (w) {
      console.log(w.message);
    }
  }, []), le.useEffect(() => {
    !x && l.forestPlot.type === "Logarithmic" && (n({
      ...l,
      dataFormat: {
        ...l.dataFormat,
        roundTo: 2
      }
    }), A(!0));
  }, [l.forestPlot.type]);
  const T = l.data.find((w) => w[l.xAxis.dataKey] === l.forestPlot.pooledResult.column), M = T ? [
    { x: a(T[l.forestPlot.lower]), y: c - Number(l.forestPlot.rowHeight) },
    { x: a(T[l.forestPlot.estimateField]), y: c - y.pooledResult.diamondHeight - Number(l.forestPlot.rowHeight) },
    { x: a(T[l.forestPlot.upper]), y: c - Number(l.forestPlot.rowHeight) },
    { x: a(T[l.forestPlot.estimateField]), y: c + y.pooledResult.diamondHeight - Number(l.forestPlot.rowHeight) },
    { x: a(T[l.forestPlot.lower]), y: c - Number(l.forestPlot.rowHeight) }
  ] : [], E = l.forestPlot.rowHeight, p = [
    { x: 0, y: E },
    { x: f, y: E }
  ], C = [
    { x: 0, y: c },
    { x: f, y: c }
  ], _ = Object.entries(l.columns).map((w) => w[1]).filter((w) => w.forestPlot === !0);
  return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(rt, { width: f }, y.title && /* @__PURE__ */ r.createElement(xt, { className: "forest-plot--title", x: y.type === "Linear" ? a(0) : a(1), y: 0, textAnchor: "middle", verticalAnchor: "start", fontSize: Ci(l.fontSize), fill: "black" }, y.title), y.lineOfNoEffect.show && y.type === "Linear" && /* @__PURE__ */ r.createElement(en, { from: { x: a(0), y: 0 + E }, to: { x: a(0), y: c }, className: "forestplot__line-of-no-effect", stroke: y.regression.baseLineColor || "black" }), y.lineOfNoEffect.show && y.type === "Logarithmic" && /* @__PURE__ */ r.createElement(en, { from: { x: a(1), y: 0 + E }, to: { x: a(1), y: c }, className: "forestplot__line-of-no-effect", stroke: y.regression.baseLineColor || "black" }), t.map((w, R) => {
    const P = In({
      domain: t.map((W) => W[y.radius.scalingColumn]),
      range: [y.radius.min, y.radius.max]
    }), z = y.radius.scalingColumn !== "" ? P(t[R][y.radius.scalingColumn]) : 4, q = y.colors.shape ? y.colors.shape : "black", V = y.colors.line ? y.colors.line : "black", G = 4;
    return w[l.xAxis.dataKey] === y.pooledResult.column ? /* @__PURE__ */ r.createElement(zr, { data: M, x: (W) => W.x, y: (W) => W.y - Ci(l.fontSize) / 2, stroke: "black", strokeWidth: 2, fill: "black", curve: pf }) : /* @__PURE__ */ r.createElement(rt, null, /* @__PURE__ */ r.createElement(
      "path",
      {
        stroke: V,
        strokeWidth: 1,
        className: "lower-ci",
        d: `
                    M${a(w[y.lower])} ${i(R) - Number(G)}
                    L${a(w[y.lower])} ${i(R) + Number(G)}
                `
      }
    ), /* @__PURE__ */ r.createElement(
      "path",
      {
        stroke: V,
        strokeWidth: 1,
        className: "upper-ci",
        d: `
                    M${a(w[y.upper])} ${i(R) - Number(G)}
                    L${a(w[y.upper])} ${i(R) + Number(G)}
                `
      }
    ), /* @__PURE__ */ r.createElement("line", { stroke: V, className: `line-${w[l.yAxis.dataKey]}`, key: R, x1: a(w[y.lower]), x2: a(w[y.upper]), y1: i(R), y2: i(R) }), y.shape === "circle" && /* @__PURE__ */ r.createElement(Rg, { className: "forest-plot--circle", cx: a(Number(w[y.estimateField])), cy: i(R), r: y.radius.scalingColumn !== "" ? P(t[R][y.radius.scalingColumn]) : 4, fill: q, style: { opacity: 1, filter: "unset" } }), y.shape === "square" && /* @__PURE__ */ r.createElement("rect", { className: "forest-plot--square", x: a(Number(w[y.estimateField])), y: i(R) - z / 2, width: z, height: z, fill: q, style: { opacity: 1, filter: "unset" } }), y.shape === "text" && /* @__PURE__ */ r.createElement(xt, { className: "forest-plot--text", x: a(Number(w[y.estimateField])), y: i(R), textAnchor: "middle", verticalAnchor: "middle", fontSize: Ci(l.fontSize), fill: q }, w[y.estimateField]));
  }), M && y.regression.showDiamond && /* @__PURE__ */ r.createElement(zr, { data: M, x: (w) => w.x, y: (w) => w.y, stroke: "black", strokeWidth: 2, fill: y.regression.baseLineColor, curve: pf }), y.regression.description && /* @__PURE__ */ r.createElement(xt, { x: 0 - Number(l.xAxis.size), width: f, y: c - l.forestPlot.rowHeight - Number(y.rowHeight) / 3, verticalAnchor: "start", textAnchor: "start", style: { fontWeight: "bold", fontSize: 12 } }, y.regression.description), /* @__PURE__ */ r.createElement(Ar, { key: "forest-plot-tooltip-area", className: "forest-plot-tooltip-area", width: f, height: c, fill: "transparent", fillOpacity: 0.5, onMouseMove: (w) => m(w, t), onMouseOut: u })), /* @__PURE__ */ r.createElement(en, { from: p[0], to: p[1], style: { stroke: "black", strokeWidth: 2 }, className: "forestplot__top-line" }), /* @__PURE__ */ r.createElement(en, { from: C[0], to: C[1], style: { stroke: "black", strokeWidth: 2 }, className: "forestplot__bottom-line" }), _.map((w) => t.map((R, P) => /* @__PURE__ */ r.createElement(xt, { className: `${R[w.name]}`, x: w.forestPlotAlignRight ? f : w.forestPlotStartingPoint, y: i(P), textAnchor: w.forestPlotAlignRight ? "end" : "start", verticalAnchor: "middle", fontSize: Ci(l.fontSize), fill: "black" }, R[w.name]))), !y.hideDateCategoryCol && t.map((w, R) => /* @__PURE__ */ r.createElement(xt, { className: `${w[l.xAxis.dataKey]}`, x: 0, y: i(R), textAnchor: "start", verticalAnchor: "middle", fontSize: Ci(l.fontSize), fill: "black" }, w[l.xAxis.dataKey])), !y.hideDateCategoryCol && l.xAxis.dataKey && /* @__PURE__ */ r.createElement(xt, { className: l.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fontSize: Ci(l.fontSize), fill: "black" }, l.xAxis.dataKey), _.map((w) => /* @__PURE__ */ r.createElement(xt, { className: `${w.label}`, x: w.forestPlotAlignRight ? f : w.forestPlotStartingPoint, y: 0, textAnchor: w.forestPlotAlignRight ? "end" : "start", verticalAnchor: "start", fontSize: Ci(l.fontSize), fill: "black" }, w.label)), y.leftLabel && /* @__PURE__ */ r.createElement(xt, { className: "forest-plot__left-label", x: y.type === "Linear" ? a(0) - 25 : a(1) - 25, y: c + v, textAnchor: "end", verticalAnchor: "start" }, y.leftLabel), y.rightLabel && /* @__PURE__ */ r.createElement(xt, { className: "forest-plot__right-label", x: y.type === "Linear" ? a(0) + 25 : a(1) + 25, y: c + v, textAnchor: "start", verticalAnchor: "start" }, y.rightLabel));
}, yk = ({ width: e, height: t, originalWidth: n }) => {
  var _, w, R;
  const { config: a, colorScale: i, transformedData: l, formatNumber: c, seriesHighlight: f, getTextWidth: u } = le.useContext(bt);
  if (!a || ((_ = a == null ? void 0 : a.series) == null ? void 0 : _.length) < 2)
    return;
  const m = a.barHasBorder === "true" ? 1 : 0, y = e / 2, v = { small: 16, medium: 18, large: 20 }, x = 1.02, A = {
    parentKey: (w = a.dataDescription) == null ? void 0 : w.seriesKey,
    dataKey: a.series[0].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[0].dataKey] || a.series[0].dataKey,
    color: i(a.runtime.seriesLabels[a.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      l.map((P) => P[a.series[0].dataKey])
    ),
    labelColor: ""
  }, T = {
    parentKey: (R = a.dataDescription) == null ? void 0 : R.seriesKey,
    dataKey: a.series[1].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[1].dataKey] || a.series[1].dataKey,
    color: i(a.runtime.seriesLabels[a.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      l.map((P) => P[a.series[1].dataKey])
    ),
    labelColor: ""
  }, M = In({
    domain: [0, Math.max(A.max * x, T.max * 1.1)],
    range: [0, y]
  });
  A.labelColor = A.color ? Qo("#000", A.color) : "#000", T.labelColor = T.color ? Qo("#000", T.color) : "#000";
  const E = a.yAxis.label ? `${a.yAxis.label}: ` : "", p = (P) => {
    var z;
    return `<p>
				${(z = a.dataDescription) == null ? void 0 : z.seriesKey}: ${A.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${P[a.xAxis.dataKey]}<br/>
				${E}${c(P[A.dataKey], "left")}
			</p>`;
  }, C = (P) => {
    var z;
    return `<p>
				${(z = a.dataDescription) == null ? void 0 : z.seriesKey}: ${T.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${P[a.xAxis.dataKey]}<br/>
				${E}${c(P[T.dataKey], "left")}
			</p>`;
  };
  return e > 0 && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("style", null, `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				`), /* @__PURE__ */ r.createElement("svg", { id: "cdc-visualization__paired-bar-chart", width: n, height: t, viewBox: `0 0 ${e + Number(a.runtime.yAxis.size)} ${t}`, role: "img", tabIndex: 0 }, /* @__PURE__ */ r.createElement("title", null, `Paired bar chart graphic with the title ${a.title ? a.title : "No Title Found"}`), /* @__PURE__ */ r.createElement(rt, { top: 0, left: Number(a.xAxis.size) }, l.filter((P) => a.series[0].dataKey === A.dataKey).map((P, z) => {
    var se, re;
    let q = a.legend.behavior === "highlight" && f.length > 0 && f.indexOf(a.series[0].dataKey) === -1, V = a.legend.behavior === "highlight" || f.length === 0 || f.indexOf(a.series[0].dataKey) !== -1, G = M(P[a.series[0].dataKey]), ee = Number(a.barHeight) ? Number(a.barHeight) : 25, W = 0;
    W = z !== 0 ? (Number(a.barSpace) + ee + m) * z : W;
    const Q = (Number(a.barSpace) + ee + m) * l.length;
    a.heights.horizontal = Q;
    const te = u(c(P[A.dataKey], "left"), `normal ${v[a.fontSize]}px sans-serif`) < G - 5;
    return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(rt, { key: `group-${A.dataKey}-${P[a.xAxis.dataKey]}`, className: "horizontal" }, /* @__PURE__ */ r.createElement(
      Ar,
      {
        id: `bar-${A.dataKey}-${P[(se = a.dataDescription) == null ? void 0 : se.xKey]}`,
        className: "bar group-1",
        key: `bar-${A.dataKey}-${P[(re = a.dataDescription) == null ? void 0 : re.xKey]}`,
        x: y - G,
        y: W,
        width: M(P[a.series[0].dataKey]),
        height: ee,
        fill: A.color,
        "data-tooltip-html": p(P),
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        stroke: "#333",
        strokeWidth: m,
        opacity: q ? 0.5 : 1,
        display: V ? "block" : "none",
        tabIndex: -1
      }
    ), a.yAxis.displayNumbersOnBar && V && /* @__PURE__ */ r.createElement(xt, { textAnchor: te ? "start" : "end", dx: te ? 5 : -5, verticalAnchor: "middle", x: y - G, y: W + a.barHeight / 2, fill: te ? A.labelColor : "#000" }, c(P[A.dataKey], "left"))));
  }), l.filter((P) => a.series[1].dataKey === T.dataKey).map((P, z) => {
    var se, re, ae;
    let q = M(P[a.series[1].dataKey]), V = a.legend.behavior === "highlight" && f.length > 0 && f.indexOf(a.series[1].dataKey) === -1, G = a.legend.behavior === "highlight" || f.length === 0 || f.indexOf(a.series[1].dataKey) !== -1, ee = a.barHeight ? Number(a.barHeight) : 25, W = 0;
    W = z !== 0 ? (Number(a.barSpace) + ee + m) * z : W;
    const Q = (Number(a.barSpace) + ee + m) * l.length;
    a.heights.horizontal = Q;
    const te = u(c(P[T.dataKey], "left"), `normal ${v[a.fontSize]}px sans-serif`) < q - 5;
    return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("style", null, `
                      .bar-${T.dataKey}-${P[a.xAxis.dataKey]} {
                          transform-origin: ${y}px ${W}px
                      }
							      `), /* @__PURE__ */ r.createElement(rt, { key: `group-${T.dataKey}-${P[(se = a.dataDescription) == null ? void 0 : se.xKey]}`, className: "horizontal" }, /* @__PURE__ */ r.createElement(
      Ar,
      {
        id: `bar-${T.dataKey}-${P[(re = a.dataDescription) == null ? void 0 : re.xKey]}`,
        className: "bar group-2",
        key: `bar-${T.dataKey}-${P[(ae = a.dataDescription) == null ? void 0 : ae.xKey]}`,
        x: y,
        y: W,
        width: M(P[a.series[1].dataKey]),
        height: ee,
        fill: T.color,
        "data-tooltip-html": C(P),
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        strokeWidth: m,
        stroke: "#333",
        opacity: V ? 0.5 : 1,
        display: G ? "block" : "none",
        tabIndex: -1
      }
    ), a.yAxis.displayNumbersOnBar && G && /* @__PURE__ */ r.createElement(xt, { textAnchor: te ? "end" : "start", dx: te ? -5 : 5, verticalAnchor: "middle", x: y + q, y: W + a.barHeight / 2, fill: te ? T.labelColor : "#000" }, c(P[T.dataKey], "left"))));
  }))));
}, gk = ({ yMax: e, leftSize: t, max: n, xMax: a }) => {
  var C;
  const { config: i, getTextWidth: l } = le.useContext(bt), { fontSize: c } = Rs(), { orientation: f } = i, u = (_, w = "#f1f1f1") => {
    try {
      return Ba(_).hex();
    } catch {
      return w;
    }
  }, m = (C = i.yAxis) == null ? void 0 : C.categories, x = ((_) => {
    const w = Object.keys(_), R = w[w.length - 1];
    if (_[R] === "") {
      const P = w.slice(0, -1).reduce((q, V) => {
        const G = parseInt(_[V], 10);
        return q + (isNaN(G) ? 0 : G);
      }, 0), z = n - P;
      _[R] = z.toString();
    }
    return [_];
  })(((_) => [..._].reduce((R, P) => (R[P.label] = P.height, R), {}))(m)), A = 0, T = Qu({
    domain: [A],
    padding: 0,
    range: [0, t]
  }), M = In({
    domain: [0, n],
    range: [e, 0],
    clamp: !0
  }), E = Oi({
    domain: m.map((_) => _ == null ? void 0 : _.label),
    range: m.map((_) => {
      var w;
      return u((w = _ == null ? void 0 : _.color) == null ? void 0 : w.trim());
    })
  }), p = Object.keys(x[0]);
  return /* @__PURE__ */ r.createElement(rt, { left: t - T.bandwidth(), top: 0 }, /* @__PURE__ */ r.createElement(gy, { data: x, keys: p, x: () => T(A), xScale: T, yScale: M, color: E }, (_) => _.map(
    (w) => w.bars.map((R) => {
      const P = i.yAxis.categories.length - 1 === w.index, z = c[i.fontSize] / 1.3, q = Ba(R.color).luminance() < 0.4 ? "#fff" : "#000", V = l(R.key, `normal ${z}px sans-serif`), G = Number(V) < R.width && R.height > z, ee = `<ul>
              <li class="tooltip-heading""> Label : ${R.key}  </li>
                    </li></ul>`;
      return /* @__PURE__ */ r.createElement(rt, { key: `${w.index}--${R.index}--${f}` }, /* @__PURE__ */ r.createElement(rt, { key: `bar-stack-${w.index}-${R.index}`, id: `barStack${w.index}-${R.index}`, className: "stack vertical" }, Ns({
        type: "axisBar",
        config: i,
        index: w.index,
        background: E(R.key),
        borderColor: "#333",
        borderStyle: "solid",
        borderWidth: 0,
        width: T.bandwidth(),
        height: R.height,
        x: R.x,
        y: R.y,
        tooltipHtml: ee,
        tooltipId: `cdc-open-viz-tooltip-${i.runtime.uniqueId}`
      }), /* @__PURE__ */ r.createElement(
        xt,
        {
          display: G ? "block" : "none",
          key: `text-${w.index}-${R.index}`,
          x: R.x + T.bandwidth() / 2,
          y: R.y + R.height / 2,
          fill: q,
          textAnchor: "middle",
          verticalAnchor: "middle",
          style: { fontSize: z }
        },
        R.key
      ), i.runtime.yAxis.gridLines && /* @__PURE__ */ r.createElement(en, { from: { x: R.x + T.bandwidth(), y: R.y }, to: { x: a + T.bandwidth(), y: R.y }, stroke: "rgba(0,0,0,0.3)" }), !P && /* @__PURE__ */ r.createElement("rect", { x: R.x, y: R.y, width: R.width, height: 1, fill: "#fff" }), /* @__PURE__ */ r.createElement("rect", { x: R.x + R.width, y: 0, width: 1, height: e, fill: "#000" })));
    })
  )));
}, Xy = ({ config: e, minValue: t, maxValue: n, existPositiveValue: a, data: i, isAllLine: l, tableData: c }) => {
  let f = 0, u = 0, m = 0, y = 0;
  if (!i)
    return { min: f, max: u };
  const v = () => zc(e.visualizationType, i, e.allowLineToBarGraph), { visualizationType: x, series: A } = e, { max: T, min: M } = e.runtime.yAxis, E = e.yAxis.type === "logarithmic", p = a ? T >= n : T >= 0, C = E ? M >= 0 : M <= 0 && t >= 0 || M <= t && t < 0;
  f = M && C ? M : t, u = T && p ? T : Number.MIN_VALUE;
  const { lower: _, upper: w } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (_ && w && e.visualizationType === "Bar") {
    const R = f < 0 ? 1.1 : 0;
    u = Math.max(n, Math.max(...i.flatMap((P) => [P[w], P[_]])) * 1.15), f = Math.min(t, Math.min(...i.flatMap((P) => [P[w], P[_]])) * 1.15) * R;
  }
  if (e.series.filter((R) => (R == null ? void 0 : R.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: R }
    } = e;
    if ((R == null ? void 0 : R.length) > 0) {
      let P = [];
      R.forEach((G) => {
        var ee;
        (ee = G.confidenceIntervals) == null || ee.map((W) => {
          P.push(W.high), P.push(W.low);
        });
      });
      const z = i.map((G) => P.map((ee) => G[ee])), q = Math.max.apply(
        null,
        z.map((G) => G[0])
      ), V = Math.min.apply(
        null,
        z.map((G) => G[1])
      );
      q > u && (u = q), V < f && (f = V);
    }
  }
  if (x === "Combo")
    try {
      if (!i)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let R = A.filter((q) => q.axis === "Left"), P = A.filter((q) => q.axis === "Right");
      const z = (q, V, G, ee = "left") => {
        let W = 0;
        return (V.map((j) => j.dataKey) || []).forEach((j) => {
          let te = V.find((ae) => ae.dataKey === j), se = q.map((ae) => ae[j]), re = Math.max.apply(null, se);
          e.visualizationSubType === "stacked" && ee === "left" && te.type === "Bar" && (W += re), re > G && (G = re), G < W && (G = W);
        }), G;
      };
      m = z(i, R, m, "left"), y = z(i, P, y, "right"), m < T && (m = T);
    } catch (R) {
      console.error(R.message);
    }
  if ((x === "Bar" || v() || x === "Combo" && !l) && f > 0 && (f = 0), (e.visualizationType === "Bar" || v() || e.visualizationType === "Combo" && !l) && f < 0 && (f = f * 1.1), e.visualizationType === "Combo" && l && ((M == null || M === "") && f > 0 && (f = 0), M)) {
    const R = E ? M >= 0 && M < t : M < t;
    f = M && R ? M : t;
  }
  if (e.visualizationType === "Deviation Bar" && f > 0) {
    const R = Number(M) < Math.min(t, Number(e.xAxis.target));
    f = M && R ? M : 0;
  }
  if (e.visualizationType === "Line" && !v()) {
    const R = E ? M >= 0 && M < t : M < t, P = c == null ? void 0 : c.some((z, q) => {
      var V;
      return (V = e.preliminaryData) == null ? void 0 : V.some((G) => {
        var j;
        if (G.type !== "suppression" || !G.style)
          return !1;
        const ee = vr.pick(z, (j = e.runtime) == null ? void 0 : j.seriesKeys), W = vr.values(ee).includes(G.value);
        return (G.column ? z[G.column] === G.value : W) && (q === 0 || q === c.length - 1);
      });
    });
    f = M && R ? M : P ? 0 : t;
  }
  if (u === Number.MIN_VALUE && (u = a ? n : 0), e.runtime.yAxis.paddingPercent) {
    let R = (u - f) * e.runtime.yAxis.paddingPercent;
    f -= R, u += R;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const R = i.map((z) => z[e.series[0].dataKey]), P = Math.max(...R).toString().length;
    switch (!0) {
      case (P > 8 && P <= 12):
        u = u * 1.3;
        break;
      case (P > 4 && P <= 7):
        u = u * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (f < 0 ? (u *= 1 + e.yAxis.scalePadding * 2 / 100, f *= 1 + e.yAxis.scalePadding * 2 / 100) : u *= 1 + e.yAxis.scalePadding / 100), { min: f, max: u, leftMax: m, rightMax: y };
}, Yr = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, vk = (e) => {
  let { xAxisDataMapped: t, xMax: n, yMax: a, min: i, max: l, config: c, data: f } = e;
  const { rawData: u, dimensions: m } = le.useContext(bt), [y, v] = m, x = c.runtime.barSeriesKeys || c.runtime.seriesKeys, A = c.runtime.xAxis.type, T = c.orientation === "horizontal", M = (V) => V[c.runtime.originalXAxis.dataKey];
  f.map((V) => M(V));
  const { visualizationType: E } = c;
  let p = null, C = null, _ = null, w = null, R = null, P = null, z = null, q = In({
    domain: [0, 100],
    range: [0, n]
  });
  if (T && (p = bk({ min: i * 1.03, ...e }), p.type = c.yAxis.type === "logarithmic" ? Yr.LOG : Yr.LINEAR, C = Ek(A, t), C.rangeRound([0, a]), R = kk(x, [0, a])), T || (z = Wp({
    domain: yg(f, (V) => new Date(V[c.runtime.originalXAxis.dataKey])),
    range: [0, n]
  }), p = Bu(t, [0, n], 1 - c.barThickness), C = Sk(e), R = Bu(x, [0, p.bandwidth()], 0)), c.xAxis.type === "date" && !T) {
    const V = t ? t.sort() : [];
    p = Bu(V, [0, n], 1 - c.barThickness);
  }
  if (c.xAxis.type === "date-time") {
    let V = Math.min(...t), G = Math.max(...t);
    V -= (c.xAxis.padding ? c.xAxis.padding * 0.01 : 0) * (G - V), G += (c.xAxis.padding ? c.xAxis.padding * 0.01 : 0) * (G - V), p = Wp({
      domain: [V, G],
      range: [0, n]
    }), p.type = Yr.TIME;
    let ee = Number.MAX_VALUE, W = t ? t.sort() : [];
    for (let Q = 0; Q < W.length - 1; Q++) {
      let j = p(W[Q + 1]) - p(W[Q]);
      j < ee && (ee = j);
    }
    (t.length === 1 || ee > n / 4) && (ee = n / 4), R = Bu(x, [0, (c.barThickness || 1) * ee], 0);
  }
  if (c.visualizationType === "Deviation Bar") {
    const V = c.isLollipopChart ? 1.05 : 1.03;
    C = Qu({
      domain: t,
      range: [0, a]
    }), p = In({
      domain: [i * V, Math.max(Number(c.xAxis.target), l)],
      range: [0, n],
      round: !0,
      nice: !0
    }), p.type = Yr.LINEAR;
  }
  if (c.visualizationType === "Scatter Plot" && c.xAxis.type === "continuous" && (p = In({
    domain: [0, Math.max.apply(null, p.domain())],
    range: [0, n]
  }), p.type = Yr.LINEAR), E === "Box Plot") {
    const V = [];
    if (c.boxplot.plots.map((Q) => Q.columnOutliers.map((j) => V.push(j))) && !c.boxplot.hideOutliers) {
      let Q = Math.min(...V), j = Math.max(...V);
      Q < i && (i = Q), j > l && (l = j);
    }
    let ee = Math.min(...c.boxplot.plots.map((Q) => Q.columnLowerBounds)), W = Math.max(...c.boxplot.plots.map((Q) => Q.columnUpperBounds));
    ee < i && (i = ee), W > l && (l = W), C = In({
      range: [a, 0],
      round: !0,
      domain: [i, l]
    }), p = Qu({
      range: [0, n],
      round: !0,
      domain: c.boxplot.categories,
      padding: 0.4
    }), p.type = Yr.BAND;
  }
  if (E === "Paired Bar") {
    let G = Math.max.apply(
      Math,
      f.map((W) => {
        var Q;
        return W[(Q = c.series[0]) == null ? void 0 : Q.dataKey];
      })
    ), ee = Math.max.apply(
      Math,
      f.map((W) => {
        var Q;
        return W[(Q = c.series[1]) == null ? void 0 : Q.dataKey];
      })
    );
    w = In({
      domain: [0, Math.max(G, ee) * 1.02],
      range: [n / 2, 0]
    }), _ = In({
      domain: w.domain(),
      range: [n / 2, n],
      nice: !0
    });
  }
  if (E === "Forest Plot") {
    const V = () => c.forestPlot.regression.showDiamond || c.forestPlot.regression.description ? [0 + c.forestPlot.rowHeight * 2, a - c.forestPlot.rowHeight] : [0 + c.forestPlot.rowHeight * 2, a];
    C = In({
      domain: [0, u.length],
      range: V()
    });
    const G = 5, ee = Number(c.forestPlot.leftWidthOffset) / 100 * n, W = Number(c.forestPlot.rightWidthOffset) / 100 * n, Q = Number(c.forestPlot.rightWidthOffsetMobile) / 100 * n, j = Number(c.forestPlot.leftWidthOffsetMobile) / 100 * n;
    if (y > 480) {
      if (c.forestPlot.type === "Linear" && (p = In({
        domain: [Math.min(...f.map((te) => parseFloat(te[c.forestPlot.lower]))) - G, Math.max(...f.map((te) => parseFloat(te[c.forestPlot.upper]))) + G],
        range: [ee, m[0] - W]
      }), p.type = Yr.LINEAR), c.forestPlot.type === "Logarithmic") {
        let te = Math.max(...f.map((re) => parseFloat(re[c.forestPlot.upper]))), se = Math.min(...f.map((re) => parseFloat(re[c.forestPlot.lower])));
        p = Ju({
          domain: [se, te],
          range: [ee, n - W],
          nice: !0
        }), p.type = Yr.LOG;
      }
    } else if (c.forestPlot.type === "Linear" && (p = In({
      domain: [Math.min(...f.map((te) => parseFloat(te[c.forestPlot.lower]))) - G, Math.max(...f.map((te) => parseFloat(te[c.forestPlot.upper]))) + G],
      range: [j, n - Q],
      type: Yr.LINEAR
    })), c.forestPlot.type === "Logarithmic") {
      let te = Math.max(...f.map((re) => parseFloat(re[c.forestPlot.upper]))), se = Math.min(...f.map((re) => parseFloat(re[c.forestPlot.lower])));
      p = Ju({
        domain: [se, te],
        range: [ee, n - W],
        nice: !0,
        base: te > 1 ? 10 : 2,
        round: !1,
        type: Yr.LOG
      });
    }
  }
  return { xScale: p, yScale: C, seriesScale: R, g1xScale: w, g2xScale: _, xScaleNoPadding: P, xScaleBrush: z, xScaleAnnotation: q };
}, xk = (e, t, n) => {
  const a = t.domain();
  if (t.type === "time") {
    const i = e[e.length - 1], l = e[0], c = (i - l) / (n - 1), f = [];
    for (let u = i; u >= l; u -= c)
      f.push(u);
    return f[f.length - 1] !== l && f.push(l), f.reverse(), f;
  }
  if (a.length > 2) {
    const i = n || 1, l = [];
    for (let c = a.length; c > 0; c -= i) {
      const f = Math.max(Math.round(c) - 1, 0);
      l.push(a[f]);
    }
    return l.reverse(), l;
  }
}, bk = ({ min: e, max: t, xMax: n, config: a }) => {
  const i = a.yAxis.type === "logarithmic";
  return e = i && e >= 0 && e < 1 ? e + 0.1 : e, (i ? Ju : In)({
    domain: [e, t],
    range: [0, n],
    nice: i,
    zero: i
  });
}, Sk = ({ min: e, max: t, yMax: n, config: a, leftMax: i }) => {
  const l = a.yAxis.type === "logarithmic";
  e = l && e >= 0 && e < 1 ? e + 0.1 : e;
  const c = l ? Ju : In;
  a.visualizationType === "Combo" && (t = i);
  const f = a.visualizationType === "Bump Chart" ? [1, t] : [e, t], u = a.visualizationType === "Bump Chart" ? [30, n] : [n, 0];
  return c({
    domain: f,
    range: u,
    nice: l,
    zero: l
  });
}, Ek = (e, t) => e === "date" ? In({
  domain: [Math.min(...t), Math.max(...t)]
}) : Xo({ domain: t, padding: 0.5 }), kk = (e, t, n = 0) => Xo({
  domain: e,
  range: t,
  padding: n
}), Bu = (e, t, n = 0) => Qu({
  domain: e,
  range: t,
  padding: n
});
function wk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const _s = () => {
  const { config: e } = le.useContext(bt), { visualizationType: t, series: n, orientation: a, visualizationSubType: i } = e, l = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Bump Chart",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], c = ["theme-blue", "theme-purple", "theme-brown", "theme-teal", "theme-pink", "theme-orange", "theme-slate", "theme-indigo", "theme-cyan", "theme-green", "theme-amber"], f = () => !["Forest Plot", "Sankey"].includes(t), u = () => !["Spark Line"].includes(t), m = () => !["Spark Line"].includes(t), y = () => !["Area Chart", "Box Plot", "Pie", "Scatter Plot", "Forest Plot", "Spark Line", "Sankey", "Bump Chart"].includes(t), v = () => !["Area Chart", "Scatter Plot", "Box Plot", "Forest Plot", "Spark Line", "Sankey", "Bump Chart"].includes(t), x = () => {
    switch (t) {
      case "Box Plot":
        return !1;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, A = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), T = () => !!["Bar", "Combo", "Line"].includes(e.visualizationType), M = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, E = () => {
    if ((t === "Bar" || "Combo") && i === "regular")
      return !0;
  }, p = () => e.xAxis.type === "categorical" ? !1 : ["Line", "Bar", "Area Chart", "Combo"].includes(t) && a === "vertical", C = () => ["Box Plot", "Scatter Plot", "Pie", "Line"].includes(t) ? !1 : n == null ? void 0 : n.some((Ue) => Ue.type === "Bar" || Ue.type === "Paired Bar" || Ue.type === "Deviation Bar"), _ = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, w = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: l,
    headerColors: c,
    visCanAnimate: v,
    visHasAnchors: M,
    visHasBarBorders: C,
    visHasDataCutoff: _,
    visHasLabelOnData: y,
    visHasDataSuppression: E,
    visHasLegend: x,
    visHasLegendAxisAlign: () => t === "Bar" && i === "stacked" && e.legend.behavior === "isolate",
    visHasBrushChart: p,
    visHasNumbersOnBars: A,
    visHasaAdditionalLabelsOnBars: T,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : a === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxis: f,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line", "Bump Chart"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !["Spark Line", "Sankey", "Bump Chart"].includes(t),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => ["Bump Chart"].includes(t) ? !1 : e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: m,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => (e == null || e.series.some((Ee) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(Ee == null ? void 0 : Ee.type)), t === "Line" || t === "Bar" && i === "regular" || t === "Combo"),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: u,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: w,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const Ee = ["Forest Plot"];
      return !(a === "horizontal" || Ee.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot", "Bump Chart"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (e.yAxis.type === "categorical" || ["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t) || t === "Bar" && e.tooltips.singleSeries)
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t),
    visSupportsDynamicSeries: () => t === "Line" || t === "Bar" || t === "Scatter Plot" || t === "Area Chart",
    visHasSingleSeriesTooltip: () => t === "Bar" || t === "Line" || t === "Area Chart" && i === "stacked",
    visHasCategoricalAxis: () => {
      if ((t === "Line" || t === "Bar" || t === "Combo" || t === "Area Chart") && e.yAxis.type === "categorical" && a === "vertical")
        return !0;
    }
  };
}, Tk = ({ data: e, xScale: t, yScale: n, config: a, xMax: i, annotationSeriesKey: l }, c) => {
  const { xAxis: f, visualizationType: u, orientation: m } = a, y = (E, p, C, _, w) => {
    let R = [];
    a.xAxis.type === "date-time" && (p = new Date(p), C = new Date(C), _ = _.map((q) => new Date(q)), R = w.ticks().map((q) => new Date(q)));
    const P = (E - p) / (C - p), z = Math.round(P * (_.length - 1));
    return a.xAxis.type === "date-time" ? R[z] : _[z];
  }, x = ((E, p = !1) => {
    if (u !== "Pie" && m !== "horizontal") {
      if (a.xAxis.type === "date-time") {
        const C = new Date(t.invert(E)), _ = a.data.map((P) => new Date(P[a.xAxis.dataKey]).getTime());
        let w = 1 / 0, R = null;
        return _.forEach((P) => {
          const z = Math.abs(C.getTime() - P);
          z < w && (w = z, R = P);
        }), new Date(R).getTime();
      }
      if (a.xAxis.type === "categorical" || u === "Combo" && m !== "horizontal" && u !== "Forest Plot") {
        const _ = (t.range()[1] - t.range()[0]) / (t.domain().length + 1), R = Math.floor((Number(E) - _ / 2) / _);
        return t.domain()[R];
      }
      if (a.xAxis.type === "date") {
        const C = y(E, 0, i, t.domain(), t);
        let _ = null, w = Number.MAX_VALUE;
        return t.domain().forEach((R) => {
          const P = Math.abs(C - R);
          P < w && (w = P, _ = R);
        }), _;
      }
      return E;
    }
  })(c - Number(a.yAxis.size || 0));
  let A = [];
  if (!x)
    return { x: 0, y: 0 };
  f.type === "categorical" && (A = a.data.filter((E) => E[a.xAxis.dataKey] === x)), (f.type === "date" || f.type === "date-time") && (A = a.data.filter((E) => new Date(E[a.xAxis.dataKey]).getTime() === x));
  const T = A[0][l];
  return { x, y: T };
}, Ck = (e, t, n) => {
  const { connectionLocation: a } = e;
  return a === "right" ? "end" : a === "left" ? "start" : a === "bottom" || a === "top" || t(e.xKey) + e.dx < n.yAxis.size ? "middle" : null;
}, Ak = (e, t, n) => {
  const { connectionLocation: a } = e;
  return a === "top" ? "start" : a === "bottom" ? "end" : a === "right" || a === "left" ? "middle" : t(e.xKey) + e.dx < n.yAxis.size ? "end" : null;
}, Lk = () => {
  var u;
  const { config: e, data: t } = le.useContext(bt), { visualizationSubType: n, visualizationType: a, series: i, legend: l } = e, c = (m) => {
    if (!(i != null && i.length))
      return [];
    const v = ["Paired Bar", "Deviation Bar"].includes(a) ? e.twoColor.palette : e.palette, x = { ...cr, ...Ss };
    let A = e.customColors || x[v];
    for (; m > A.length; )
      A = A.concat(A);
    return A.slice(0, m);
  };
  let f = Oi({
    domain: (u = e == null ? void 0 : e.runtime) == null ? void 0 : u.seriesLabelsAll,
    range: c(i.length)
  });
  if (a === "Deviation Bar") {
    const { targetLabel: m } = e.xAxis;
    f = Oi({
      domain: [`Below ${m}`, `Above ${m}`],
      range: c(2)
    });
  }
  if (a === "Bar" && n === "regular" && (i == null ? void 0 : i.length) === 1 && (l != null && l.colorCode)) {
    const m = new Set(t == null ? void 0 : t.map((y) => y[l.colorCode]));
    f = Oi({
      domain: [...m],
      range: c([...m].length)
    });
  }
  if (e.series.some((m) => m.name)) {
    const m = new Set(i.map((y) => y.name || y.dataKey));
    f = f = Oi({
      domain: [...m],
      range: c(i.length)
    });
  }
  return { colorScale: f };
};
const Pk = ({ xScale: e, yScale: t, xScaleAnnotation: n, xMax: a, svgRef: i, onDragStateChange: l }) => {
  const {
    config: c,
    currentViewport: f,
    dimensions: u,
    isDraggingAnnotation: m,
    isEditor: y,
    isLegendBottom: v,
    updateConfig: x
  } = le.useContext(bt), { annotations: A } = c, [T] = u, { colorScale: M } = Lk(), E = y ? xg : bg;
  return A && A.map((p, C) => {
    var P;
    const _ = p.text || "", w = n(p.x), R = () => ({
      __html: im.sanitize(_)
    });
    return /* @__PURE__ */ r.createElement(
      E,
      {
        width: 200,
        height: T,
        dx: p.dx,
        dy: p.dy,
        x: w,
        y: p.y,
        canEditLabel: p.edit.label || !1,
        canEditSubject: p.edit.subject && p.connectionType !== "none" || !1,
        onDragStart: () => l(!0),
        onDragEnd: (z) => {
          l(!1);
          let q = [...A];
          if (p.x === n.invert(z.x) && p.y === z.y)
            q[C] = { ...q[C], dx: z.dx, dy: z.dy };
          else if (p.snapToNearestPoint) {
            let V = Tk(
              {
                data: c.data,
                xScale: e,
                yScale: t,
                config: c,
                xMax: a - c.yAxis.size / 2,
                annotationSeriesKey: p.seriesKey
              },
              z.x
            );
            q[C] = { ...q[C], x: n.invert(e(V.x)), y: t(V.y) };
          } else
            q[C] = { ...q[C], x: n.invert(z.x), y: z.y };
          x({
            ...c,
            annotations: q
          });
        }
      },
      /* @__PURE__ */ r.createElement(gg, { className: "annotation__desktop-label", showAnchorLine: !1, horizontalAnchor: Ck(p, e, c), verticalAnchor: Ak(p, e, c) }, /* @__PURE__ */ r.createElement(
        "div",
        {
          style: {
            borderRadius: 5,
            // Optional: set border radius
            backgroundColor: `rgba(255, 255, 255, ${p != null && p.opacity ? Number(p == null ? void 0 : p.opacity) / 100 : 1})`,
            padding: "10px",
            width: "auto",
            display: c.general.showAnnotationDropdown ? "inline-flex" : "flex",
            justifyContent: "start",
            flexDirection: "row"
          },
          tabIndex: 0,
          "aria-label": `Annotation text that reads: ${p.text}`
        },
        ((P = c == null ? void 0 : c.general) == null ? void 0 : P.showAnnotationDropdown) && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("p", { className: "annotation__has-dropdown-number", style: { margin: "2px 6px" } }, C + 1)),
        /* @__PURE__ */ r.createElement("div", { style: { fontSize: om[c.fontSize] }, dangerouslySetInnerHTML: R() })
      )),
      p.connectionType === "line" && /* @__PURE__ */ r.createElement(kp, { type: "line", pathProps: { markerStart: `url(#marker-start--${C})` } }),
      p.connectionType === "elbow" && /* @__PURE__ */ r.createElement(kp, { type: "elbow", pathProps: { markerStart: `url(#marker-start--${C})` } }),
      p.connectionType === "curve" && /* @__PURE__ */ r.createElement(
        zr,
        {
          d: `M ${w},${p.y}
                      Q ${w + p.dx / 2}, ${p.y + p.dy / 2 + Number(p == null ? void 0 : p.bezier) || 0} ${w + p.dx},${p.y + p.dy}`,
          stroke: "black",
          strokeWidth: "2",
          fill: "none",
          "marker-start": `url(#marker-start--${C})`
        }
      ),
      p.marker === "circle" && /* @__PURE__ */ r.createElement(vg, { id: `marker-start--${C}`, className: "circle-subject", stroke: M(p.seriesKey), radius: 8 }),
      p.marker === "arrow" && /* @__PURE__ */ r.createElement(am, { fill: "black", id: `marker-start--${C}`, x: w, y: p.y, stroke: "#333", markerWidth: 10, size: 10, strokeWidth: 1, orient: "auto-start-reverse", markerUnits: "userSpaceOnUse" }),
      /* @__PURE__ */ r.createElement("circle", { fill: "white", cx: w + p.dx, cy: p.y + p.dy, r: 16, className: "annotation__mobile-label annotation__mobile-label-circle", stroke: M(p.seriesKey) }),
      /* @__PURE__ */ r.createElement("text", { height: 16, x: w + p.dx, y: p.y + p.dy, className: "annotation__mobile-label", alignmentBaseline: "middle", textAnchor: "middle" }, C + 1)
    );
  });
};
const Rk = ({ useBootstrapVisibilityClasses: e = !0 }) => {
  const { config: t } = le.useContext(bt), n = t.annotations || [], a = () => {
    const l = ["annotation-list"];
    return e && l.push("d-block", "d-md-none"), l.join(" ");
  }, i = n.map((l, c) => {
    const f = l.text || "", u = () => ({
      __html: im.sanitize(f)
    });
    return /* @__PURE__ */ r.createElement("li", { key: "annotation-li-item__annotationIndex" }, /* @__PURE__ */ r.createElement("div", { className: "annotation__title-wrapper" }, /* @__PURE__ */ r.createElement("div", { className: "annotation__title-circle" }, c + 1), /* @__PURE__ */ r.createElement("p", { className: "annotation__subtext", dangerouslySetInnerHTML: u() })));
  });
  return /* @__PURE__ */ r.createElement("ul", { className: a() }, i);
};
const Dk = () => {
  var u;
  const { currentViewport: e, config: t } = le.useContext(bt), [n, a] = le.useState(!1), i = ["sm", "xs", "xxs"].includes(e) ? "13px" : `${om[t == null ? void 0 : t.fontSize]}px`;
  le.useContext(bt);
  const l = {
    maxHeight: t.table.limitHeight && `${t.table.height}px`,
    OverflowY: "scroll"
  }, c = () => {
    const m = ["data-table-heading", "annotation__dropdown-list"];
    return n || m.push("collapsed"), m.join(" ");
  }, f = () => {
    const m = ["data-table-container", e, "d-block", "d-lg-none"];
    return t.general.showAnnotationDropdown && (m.push("d-lg-block"), m.splice(m.indexOf("d-lg-none"), 1)), m.join(" ");
  };
  return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("section", { className: f() }, /* @__PURE__ */ r.createElement(
    "div",
    {
      style: { fontSize: i },
      role: "button",
      className: c(),
      onClick: () => {
        a(!n);
      },
      tabIndex: 0,
      onKeyDown: (m) => {
        m.keyCode === 13 && a(!n);
      }
    },
    /* @__PURE__ */ r.createElement(st, { display: n ? "minus" : "plus", base: !0 }),
    t.general.annotationDropdownText === "" ? "Annotations" : (u = t == null ? void 0 : t.general) == null ? void 0 : u.annotationDropdownText
  ), n && /* @__PURE__ */ r.createElement("div", { className: "table-container annotation-dropdown__panel", style: l }, /* @__PURE__ */ r.createElement(up.List, { useBootstrapVisibilityClasses: !1 }))));
}, up = {
  Draggable: Pk,
  // Mobile auto display
  List: Rk,
  // Desktop Accessible Option
  Dropdown: Dk
}, _r = (e) => {
  var Mn, Kn, zn, Rn, Wn;
  const {
    brushConfig: t,
    config: n,
    currentViewport: a,
    dimensions: i,
    formatDate: l,
    formatNumber: c,
    getTextWidth: f,
    handleChartAriaLabels: u,
    handleLineType: m,
    handleDragStateChange: y,
    parseDate: v,
    tableData: x,
    transformedData: A,
    updateConfig: T,
    isDraggingAnnotation: M,
    seriesHighlight: E,
    colorScale: p
  } = le.useContext(bt), { visualizationType: C, visualizationSubType: _, orientation: w, xAxis: R, yAxis: P, runtime: z, debugSvg: q } = n, V = () => zc(n.visualizationType, A, n.allowLineToBarGraph);
  let [G] = i;
  n && n.legend && !n.legend.hide && ((Mn = n.legend) == null ? void 0 : Mn.position) !== "bottom" && ["lg", "md"].includes(a) && (G = G * 0.73);
  const { horizontal: ee } = n.heights, W = w === "horizontal" || n.visualizationType === "Forest Plot", Q = !0, j = n.yAxis.type === "logarithmic", te = isNaN(parseInt(z.xAxis.labelOffset)) ? 0 : parseInt(z.xAxis.labelOffset), se = isNaN(parseInt(z.yAxis.labelOffset)) ? 0 : parseInt(z.yAxis.labelOffset), re = isNaN(parseInt(z.xAxis.size)) ? 0 : parseInt(z.xAxis.size);
  let ae = n.aspectRatio ? G * n.aspectRatio : n.visualizationType === "Forest Plot" ? n.heights.vertical : n.heights[w];
  ae = Number(ae);
  const K = G - z.yAxis.size - (C === "Combo" ? n.yAxis.rightAxisSize : 0);
  let U = ae - (w === "horizontal" ? 0 : re);
  ae += w === "horizontal" ? re : 0, n.visualizationType === "Forest Plot" && (ae = ae + n.data.length * n.forestPlot.rowHeight, U = U + n.data.length * n.forestPlot.rowHeight, G = i[0]), (Kn = n.brush) != null && Kn.active && (ae = ae + ((zn = n.brush) == null ? void 0 : zn.height));
  const { minValue: X, maxValue: H, existPositiveValue: Te, isAllLine: be } = $c(n, A), { visSupportsReactTooltip: ce } = _s(), { hasTopAxis: Re } = wk(n), [He, Ge] = le.useState(!1), [Ne, ye] = le.useState({ x: 0, y: 0 });
  le.useRef(null);
  const Oe = le.useRef(), ue = le.useRef(null), ie = le.useRef(), Ce = rp(Oe, {
    freezeOnceVisible: !1
  }), $e = (F) => Cn(n.runtime.xAxis) ? v(F[n.runtime.originalXAxis.dataKey]).getTime() : F[n.runtime.originalXAxis.dataKey], Ve = (F, Ae) => F[Ae], Ee = n.brush.active && ((Rn = t.data) != null && Rn.length) ? t.data.map((F) => $e(F)) : A.map((F) => $e(F)), Ue = n.orientation === "horizontal" || n.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", ft = { data: A, tableData: x, config: n, minValue: X, maxValue: H, isAllLine: be, existPositiveValue: Te, xAxisDataMapped: Ee, xMax: K, yMax: U }, { min: Qe, max: We, leftMax: Ie, rightMax: Me } = Xy(ft), { yScaleRight: tt, hasRightAxis: Ze } = sp({ config: n, yMax: U, data: A, updateConfig: T }), { xScale: et, yScale: at, seriesScale: gt, g1xScale: Ot, g2xScale: Kt, xScaleNoPadding: on, xScaleBrush: Wt, xScaleAnnotation: Zt } = vk({ ...ft, min: Qe, max: We, leftMax: Ie, rightMax: Me, dimensions: i }), [zt, fn] = le.useState(null);
  le.useEffect(() => {
    var F;
    fn((F = ie == null ? void 0 : ie.current) == null ? void 0 : F.getBoundingClientRect());
  }, [ie, n.legend]);
  const Yt = (F, Ae) => {
    if (j && F === 0.1 && (F = 0), !(n.data && !n.data[Ae] && C === "Forest Plot"))
      return n.visualizationType === "Forest Plot" ? n.data[Ae][n.xAxis.dataKey] : Cn(z.yAxis) ? l(v(F)) : w === "vertical" && We - Qe < 3 ? c(F, "left", Q, !1, !1, "1") : w === "vertical" ? c(F, "left", Q) : F;
  }, tn = (F) => (j && F === 0.1 && (F = 0), Cn(z.xAxis) && n.visualizationType !== "Forest Plot" ? l(F) : w === "horizontal" && n.visualizationType !== "Forest Plot" ? c(F, "left", Q) : n.xAxis.type === "continuous" && n.visualizationType !== "Forest Plot" ? c(F, "bottom", Q) : n.visualizationType === "Forest Plot" ? c(F, "left", n.dataFormat.abbreviated, n.runtime.xAxis.prefix, n.runtime.xAxis.suffix, Number(n.dataFormat.roundTo)) : F), kn = (F) => {
    let { numTicks: Ae } = z[F];
    z[F].viewportNumTicks && z[F].viewportNumTicks[a] && (Ae = z[F].viewportNumTicks[a]);
    let ze;
    return F === "yAxis" && (ze = W && !Ae ? A.length : W && Ae ? Ae : !W && !Ae ? void 0 : !W && Ae && Ae, ze === void 0 && !n.dataFormat.roundTo && (Number(We) <= 3 ? ze = 2 : ze = 4), Number(ze) > Number(We) && (ze = Number(Qe) < 0 ? Math.round(We) * 2 : Math.round(We))), F === "xAxis" && (ze = W && !Ae ? void 0 : W && Ae ? Ae : !W && !Ae ? void 0 : !W && Ae && Ae, W && ze === void 0 && !n.dataFormat.roundTo && (We <= 3 ? ze = 2 : ze = 4), n.visualizationType === "Forest Plot" && (ze = n.yAxis.numTicks !== "" ? n.yAxis.numTicks : 4)), ze;
  }, { tooltipData: ot, showTooltip: _e, hideTooltip: $t, tooltipOpen: Lt, tooltipLeft: nn, tooltipTop: un } = xy(), {
    handleTooltipMouseOver: At,
    handleTooltipClick: rn,
    handleTooltipMouseOff: ln,
    tooltipStyles: Ln,
    TooltipListItem: qt,
    getXValueFromCoordinateDate: mn,
    getXValueFromCoordinate: Hn
  } = wy({
    xScale: et,
    yScale: at,
    showTooltip: _e,
    hideTooltip: $t
  });
  le.useEffect(() => {
    document.querySelector(".isEditor") && Ge((Ae) => !0);
  }), le.useEffect(() => {
    (Ce == null ? void 0 : Ce.isIntersecting) === !0 && n.animate && setTimeout(() => {
      Ge((F) => !0);
    }, 500);
  }, [Ce == null ? void 0 : Ce.isIntersecting, n.animate]), le.useEffect(() => {
    We && T({ ...n, yAxis: { ...n.yAxis, maxValue: We } });
  }, [We]);
  const Pn = () => {
    const { visualizationType: F } = n;
    return F === "Combo" && z.forecastingSeriesKeys > 0 || F === "Area Chart" || F === "Line" || F === "Bar";
  }, Vt = Number(w === "horizontal" ? n.xAxis.size : n.yAxis.size), wn = { small: 16, medium: 18, large: 20 }, tr = () => n.visualizationType === "Forest Plot" ? n.data.length : kn("yAxis"), nr = () => {
    let F = n.xAxis.manualStep;
    return n.xAxis.viewportStepCount && n.xAxis.viewportStepCount[a] && (F = n.xAxis.viewportStepCount[a]), F;
  }, En = (F) => {
    const Ae = F.currentTarget.getBoundingClientRect(), ze = F.clientX - Ae.left, xe = F.clientY - Ae.top;
    ye({
      x: ze,
      y: xe
    });
  }, Tn = () => {
    let F = 40;
    const Ae = (ze, xe) => {
      if (!ze.length)
        return !1;
      const lt = ze.filter((wt) => wt.index !== 0), nt = lt == null ? void 0 : lt.length, mt = xe.range()[0] || K / 2, ht = lt.map((wt) => f(c(wt.value, "left"), `normal ${wn[n.fontSize]}px sans-serif`)), je = 100, yt = ht.reduce((wt, kt) => wt + kt, je), Tt = (mt - yt) / nt;
      let Rt = [0];
      for (let wt = 1; wt < ht.length; wt++)
        Rt[wt] = Rt[wt - 1] + ht[wt - 1] + Tt;
      let jt = !1;
      return ht.forEach((wt, kt) => {
        if (Rt[kt] + ht[kt] > Rt[kt + 1]) {
          jt = !0;
          return;
        }
      }), jt;
    };
    return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(Uu, { top: U, left: Number(z.yAxis.size), label: z.xAxis.label, tickFormat: Cn(z.xAxis) ? l : c, scale: Ot, stroke: "#333", tickStroke: "#333", numTicks: z.xAxis.numTicks || void 0 }, (ze) => /* @__PURE__ */ r.createElement(rt, { className: "bottom-axis" }, ze.ticks.map((xe, lt) => {
      const nt = f(c(xe.value, "left"), `normal ${wn[n.fontSize]}px sans-serif`), mt = Ae(ze.ticks, Ot), ht = Number(n.xAxis.maxTickRotation) || 90, je = n.isResponsiveTicks && mt, yt = xe.index !== 0 && (je ? ht : Number(n.yAxis.tickRotation)), Tt = nt * Math.sin(yt * (Math.PI / 180)) + 25, Rt = yt && xe.index !== 0 ? "end" : "middle";
      return Tt > F && (F = Tt), /* @__PURE__ */ r.createElement(rt, { key: `vx-tick-${xe.value}-${lt}`, className: "vx-axis-tick" }, !z.yAxis.hideTicks && /* @__PURE__ */ r.createElement(en, { from: xe.from, to: xe.to, stroke: "#333" }), !z.yAxis.hideLabel && /* @__PURE__ */ r.createElement(
        xt,
        {
          x: xe.to.x,
          y: xe.to.y,
          angle: -yt,
          verticalAnchor: yt ? "middle" : "start",
          textAnchor: Rt
        },
        c(xe.value, "left")
      ));
    }), !z.yAxis.hideAxis && /* @__PURE__ */ r.createElement(en, { from: ze.axisFromPoint, to: ze.axisToPoint, stroke: "#333" }))), /* @__PURE__ */ r.createElement(
      Uu,
      {
        top: U,
        left: Number(z.yAxis.size),
        label: z.xAxis.label,
        tickFormat: Cn(z.xAxis) ? l : z.xAxis.dataKey !== "Year" ? c : (ze) => ze,
        scale: Kt,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: z.xAxis.numTicks || void 0
      },
      (ze) => /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(rt, { className: "bottom-axis" }, ze.ticks.map((xe, lt) => {
        const nt = f(c(xe.value, "left"), `normal ${wn[n.fontSize]}px sans-serif`), mt = Ae(ze.ticks, Kt), ht = Number(n.xAxis.maxTickRotation) || 90, je = n.isResponsiveTicks && mt, yt = xe.index !== 0 && (je ? ht : Number(n.yAxis.tickRotation)), Tt = nt * Math.sin(yt * (Math.PI / 180)) + 25, Rt = yt && xe.index !== 0 ? "end" : "middle";
        return Tt > F && (F = Tt), /* @__PURE__ */ r.createElement(rt, { key: `vx-tick-${xe.value}-${lt}`, className: "vx-axis-tick" }, !z.yAxis.hideTicks && /* @__PURE__ */ r.createElement(en, { from: xe.from, to: xe.to, stroke: "#333" }), !z.yAxis.hideLabel && /* @__PURE__ */ r.createElement(
          xt,
          {
            x: xe.to.x,
            y: xe.to.y,
            angle: -yt,
            verticalAnchor: yt ? "middle" : "start",
            textAnchor: Rt
          },
          c(xe.value, "left")
        ));
      }), !z.yAxis.hideAxis && /* @__PURE__ */ r.createElement(en, { from: ze.axisFromPoint, to: ze.axisToPoint, stroke: "#333" })), /* @__PURE__ */ r.createElement(rt, null, /* @__PURE__ */ r.createElement(xt, { x: K / 2, y: F + 20 + te, stroke: "#333", textAnchor: "middle", verticalAnchor: "start" }, z.xAxis.label)), ie.current ? ie.current.setAttribute("height", Number(ae) + Number(F) + (z.xAxis.label ? 50 : 0) + "px") : "")
    ));
  };
  return isNaN(G) ? /* @__PURE__ */ r.createElement(r.Fragment, null) : /* @__PURE__ */ r.createElement($r, { component: "LinearChart" }, /* @__PURE__ */ r.createElement("div", { style: { width: `${G}px`, overflow: "visible" }, className: "tooltip-boundary" }, /* @__PURE__ */ r.createElement(
    "svg",
    {
      onMouseMove: En,
      width: "100%",
      height: ae,
      className: `linear ${n.animate ? "animated" : ""} ${He && n.animate ? "animate" : ""} ${q && "debug"} ${M && "dragging-annotation"}`,
      role: "img",
      "aria-label": u(n),
      ref: ie,
      style: { overflow: "visible" }
    },
    !M && /* @__PURE__ */ r.createElement(Ar, { width: G, height: ae, fill: "transparent" }),
    " ",
    !["Spark Line", "Forest Plot"].includes(C) && n.yAxis.type !== "categorical" && /* @__PURE__ */ r.createElement(wE, { scale: at, tickLength: j ? 6 : 8, left: Number(z.yAxis.size) - n.yAxis.axisPadding, label: z.yAxis.label || z.yAxis.label, stroke: "#333", tickFormat: (F, Ae) => Yt(F, Ae), numTicks: tr() }, (F) => {
      const Ae = n.orientation === "horizontal" ? (F.axisToPoint.y - F.axisFromPoint.y) / 2 : (F.axisFromPoint.y - F.axisToPoint.y) / 2, ze = U / F.ticks.length / 2 - U / F.ticks.length * (1 - n.barThickness) + 5;
      return /* @__PURE__ */ r.createElement(rt, { className: "left-axis" }, F.ticks.map((xe, lt) => {
        const nt = F.ticks[0].to.y, mt = 15, ht = String(xe.value).startsWith("1") || xe.value === 0.1 ? "block" : "none", je = ht === "block" ? 7 : 0, yt = { x: xe.to.x - je, y: xe.to.y }, Tt = xe.index !== 0 || n.xAxis.hideAxis;
        return /* @__PURE__ */ r.createElement(rt, { key: `vx-tick-${xe.value}-${lt}`, className: "vx-axis-tick" }, !z.yAxis.hideTicks && /* @__PURE__ */ r.createElement(en, { key: `${xe.value}--hide-hideTicks`, from: xe.from, to: j ? yt : xe.to, stroke: n.yAxis.tickColor, display: w === "horizontal" ? "none" : "block" }), z.yAxis.gridLines && Tt ? /* @__PURE__ */ r.createElement(en, { key: `${xe.value}--hide-hideGridLines`, display: (j && ht).toString(), from: { x: xe.from.x + K, y: xe.from.y }, to: xe.from, stroke: "rgba(0,0,0,0.3)" }) : "", w === "horizontal" && _ !== "stacked" && n.yAxis.labelPlacement === "On Date/Category Axis" && !n.yAxis.hideLabel && /* @__PURE__ */ r.createElement(
          xt,
          {
            transform: `translate(${xe.to.x - 5}, ${n.isLollipopChart ? xe.to.y - nt : xe.to.y - nt + (Number(n.barHeight * n.runtime.series.length) - mt) / 2}) rotate(-${n.runtime.horizontal && n.runtime.yAxis.tickRotation || 0})`,
            verticalAnchor: "start",
            textAnchor: "end"
          },
          xe.formattedValue
        ), w === "horizontal" && _ === "stacked" && n.yAxis.labelPlacement === "On Date/Category Axis" && !n.yAxis.hideLabel && /* @__PURE__ */ r.createElement(xt, { transform: `translate(${xe.to.x - 5}, ${xe.to.y - nt + (Number(n.barHeight) - mt) / 2}) rotate(-${z.horizontal ? z.yAxis.tickRotation : 0})`, verticalAnchor: "start", textAnchor: "end" }, xe.formattedValue), w === "horizontal" && C === "Paired Bar" && !n.yAxis.hideLabel && /* @__PURE__ */ r.createElement(xt, { transform: `translate(${xe.to.x - 5}, ${xe.to.y - nt + Number(n.barHeight) / 2}) rotate(-${z.horizontal ? z.yAxis.tickRotation : 0})`, textAnchor: "end", verticalAnchor: "middle" }, xe.formattedValue), w === "horizontal" && C === "Deviation Bar" && !n.yAxis.hideLabel && /* @__PURE__ */ r.createElement(xt, { transform: `translate(${xe.to.x - 5}, ${n.isLollipopChart ? xe.to.y - nt + 2 : xe.to.y - nt + Number(n.barHeight) / 2}) rotate(-${z.horizontal ? z.yAxis.tickRotation : 0})`, textAnchor: "end", verticalAnchor: "middle" }, xe.formattedValue), w === "vertical" && C === "Bump Chart" && !n.yAxis.hideLabel && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
          xt,
          {
            display: n.useLogScale ? ht : "block",
            dx: n.useLogScale ? -6 : 0,
            x: n.runtime.horizontal ? xe.from.x + 2 : xe.to.x - 8.5,
            y: xe.to.y - 13 + (n.runtime.horizontal ? ze : 0),
            angle: -Number(n.yAxis.tickRotation) || 0,
            verticalAnchor: n.runtime.horizontal ? "start" : "middle",
            textAnchor: n.runtime.horizontal ? "start" : "end",
            fill: n.yAxis.tickLabelColor
          },
          n.runtime.seriesLabelsAll[xe.formattedValue - 1]
        ), (E.length === 0 || E.includes(n.runtime.seriesLabelsAll[xe.formattedValue - 1])) && /* @__PURE__ */ r.createElement(
          "rect",
          {
            x: 0 - Number(n.yAxis.size),
            y: xe.to.y - 8 + (n.runtime.horizontal ? ze : 7),
            width: Number(n.yAxis.size) + et(et.domain()[0]),
            height: "2",
            fill: p(n.runtime.seriesLabelsAll[xe.formattedValue - 1])
          }
        )), w === "vertical" && C !== "Paired Bar" && C !== "Bump Chart" && !n.yAxis.hideLabel && /* @__PURE__ */ r.createElement(
          xt,
          {
            display: j ? ht : "block",
            dx: j ? -6 : 0,
            x: n.runtime.horizontal ? xe.from.x + 2 : xe.to.x,
            y: xe.to.y + (n.runtime.horizontal ? ze : 0),
            angle: -Number(n.yAxis.tickRotation) || 0,
            verticalAnchor: n.runtime.horizontal ? "start" : "middle",
            textAnchor: n.runtime.horizontal ? "start" : "end",
            fill: n.yAxis.tickLabelColor
          },
          xe.formattedValue
        ));
      }), !n.yAxis.hideAxis && /* @__PURE__ */ r.createElement(en, { from: F.axisFromPoint, to: z.horizontal ? { x: 0, y: n.visualizationType === "Forest Plot" ? ae : Number(ee) } : F.axisToPoint, stroke: "#000" }), at.domain()[0] < 0 && /* @__PURE__ */ r.createElement(en, { from: { x: F.axisFromPoint.x, y: at(0) }, to: { x: K, y: at(0) }, stroke: "#333" }), C === "Bar" && w === "horizontal" && et.domain()[0] < 0 && /* @__PURE__ */ r.createElement(en, { from: { x: et(0), y: 0 }, to: { x: et(0), y: U }, stroke: "#333", strokeWidth: 2 }), /* @__PURE__ */ r.createElement(xt, { className: "y-label", textAnchor: "middle", verticalAnchor: "start", transform: `translate(${-1 * z.yAxis.size + se}, ${Ae}) rotate(-90)`, fontWeight: "bold", fill: n.yAxis.labelColor }, F.label));
    }),
    n.yAxis.type === "categorical" && n.orientation === "vertical" && /* @__PURE__ */ r.createElement(gk, { max: We, maxValue: H, height: ae, xMax: K, yMax: U, leftSize: Number(z.yAxis.size) - n.yAxis.axisPadding }),
    Ze && /* @__PURE__ */ r.createElement(LE, { scale: tt, left: Number(G - n.yAxis.rightAxisSize), label: n.yAxis.rightLabel, tickFormat: (F) => c(F, "right"), numTicks: z.yAxis.rightNumTicks || void 0, labelOffset: 45 }, (F) => {
      const Ae = n.orientation === "horizontal" ? (F.axisToPoint.y - F.axisFromPoint.y) / 2 : (F.axisFromPoint.y - F.axisToPoint.y) / 2, ze = U / F.ticks.length / 2 - U / F.ticks.length * (1 - n.barThickness) + 5;
      return /* @__PURE__ */ r.createElement(rt, { className: "right-axis" }, F.ticks.map((xe, lt) => /* @__PURE__ */ r.createElement(rt, { key: `vx-tick-${xe.value}-${lt}`, className: "vx-axis-tick" }, !z.yAxis.rightHideTicks && /* @__PURE__ */ r.createElement(en, { from: xe.from, to: xe.to, display: z.horizontal ? "none" : "block", stroke: n.yAxis.rightAxisTickColor }), z.yAxis.rightGridLines ? /* @__PURE__ */ r.createElement(en, { from: { x: xe.from.x + K, y: xe.from.y }, to: xe.from, stroke: "rgba(0,0,0,0.3)" }) : "", !n.yAxis.rightHideLabel && /* @__PURE__ */ r.createElement(xt, { x: xe.to.x, y: xe.to.y + (z.horizontal ? ze : 0), verticalAnchor: z.horizontal ? "start" : "middle", textAnchor: "start", fill: n.yAxis.rightAxisTickLabelColor }, xe.formattedValue))), !n.yAxis.rightHideAxis && /* @__PURE__ */ r.createElement(en, { from: F.axisFromPoint, to: F.axisToPoint, stroke: "#333" }), /* @__PURE__ */ r.createElement(xt, { className: "y-label", textAnchor: "middle", verticalAnchor: "start", transform: `translate(${n.yAxis.rightLabelOffsetSize ? n.yAxis.rightLabelOffsetSize : 0}, ${Ae}) rotate(-90)`, fontWeight: "bold", fill: n.yAxis.rightAxisLabelColor }, F.label));
    }),
    Re && n.topAxis.hasLine && /* @__PURE__ */ r.createElement(
      NE,
      {
        stroke: "#333",
        left: Number(z.yAxis.size),
        scale: et,
        hideTicks: !0,
        hideZero: !0,
        tickLabelProps: () => ({
          fill: "transparent"
        })
      }
    ),
    C !== "Paired Bar" && C !== "Spark Line" && /* @__PURE__ */ r.createElement(
      Uu,
      {
        innerRef: ue,
        top: z.horizontal && n.visualizationType !== "Forest Plot" ? Number(ee) + Number(n.xAxis.axisPadding) : n.visualizationType === "Forest Plot" ? U + Number(n.xAxis.axisPadding) : U,
        left: n.visualizationType !== "Forest Plot" ? Number(z.yAxis.size) : 0,
        label: n[Ue].label,
        tickFormat: tn,
        scale: et,
        stroke: "#333",
        numTicks: kn("xAxis"),
        tickStroke: "#333",
        tickValues: n.xAxis.manual ? xk(Ee, et, n.xAxis.type === "date-time" ? kn("xAxis") : nr()) : void 0
      },
      (F) => {
        var Ut;
        const Ae = n.visualizationType !== "Forest Plot" ? (F.axisToPoint.x - F.axisFromPoint.x) / 2 : i[0] / 2, ze = (Et) => /\s/.test(Et), xe = F.ticks.some((Et) => ze(Et.value)), lt = 8, nt = Math.max(...F.ticks.map((Et) => f(Et.formattedValue, `normal ${wn[n.fontSize]}px sans-serif`))), mt = xe ? 180 : 100, ht = F.ticks.map((Et) => f(Et.formattedValue, `normal ${wn[n.fontSize]}px sans-serif`)), je = ht.reduce((Et, xn) => Et + xn, mt), yt = (K - je) / (F.ticks.length - 1);
        let Tt = [0];
        for (let Et = 1; Et < ht.length; Et++)
          Tt[Et] = Tt[Et - 1] + ht[Et - 1] + yt;
        const Rt = (Ut = ue == null ? void 0 : ue.current) == null ? void 0 : Ut.getBBox().height;
        n.xAxis.axisBBox = Rt;
        let jt = !1;
        ht.forEach((Et, xn) => {
          if (Tt[xn] + ht[xn] > Tt[xn + 1]) {
            jt = !0;
            return;
          }
        });
        const wt = jt && n.isResponsiveTicks ? nt + lt + 20 : 0;
        Number(n.xAxis.tickRotation) > 0 && Number(n.xAxis.tickRotation), n.dynamicMarginTop = wt, n.xAxis.tickWidthMax = nt;
        let kt = 40;
        const Ft = /* @__PURE__ */ r.createElement(rt, { className: "bottom-axis", width: i[0] }, F.ticks.map((Et, xn, pn) => {
          const sn = String(Et.value).startsWith("1") || Et.value === 0.1 ? "block" : "none", yn = sn === "block" ? 16 : lt, Qt = { x: Et.to.x, y: yn }, gn = f(Et.formattedValue, `normal ${wn[n.fontSize]}px sans-serif`), Vn = 100 / pn.length;
          n.yAxis.tickRotation = n.isResponsiveTicks && n.orientation === "horizontal" ? 0 : n.yAxis.tickRotation, n.xAxis.tickRotation = n.isResponsiveTicks && n.orientation === "vertical" ? 0 : n.xAxis.tickRotation;
          const g = n.isResponsiveTicks && jt ? -Number(n.xAxis.maxTickRotation) || -90 : -Number(n.runtime.xAxis.tickRotation), D = gn * Math.sin(g * -1 * (Math.PI / 180)) + 25;
          return D > kt && (kt = D), /* @__PURE__ */ r.createElement(rt, { key: `vx-tick-${Et.value}-${xn}`, className: "vx-axis-tick" }, !n.xAxis.hideTicks && /* @__PURE__ */ r.createElement(en, { from: Et.from, to: w === "horizontal" && j ? Qt : Et.to, stroke: n.xAxis.tickColor, strokeWidth: sn === "block" && j ? 1.3 : 1 }), !n.xAxis.hideLabel && /* @__PURE__ */ r.createElement(
            xt,
            {
              dy: n.orientation === "horizontal" && j ? 8 : 0,
              display: n.orientation === "horizontal" && j ? sn : "block",
              x: Et.to.x,
              y: Et.to.y,
              angle: g,
              verticalAnchor: g < -50 ? "middle" : "start",
              textAnchor: g ? "end" : "middle",
              width: jt && !n.isResponsiveTicks && !Number(n[Ue].tickRotation) ? Vn : void 0,
              fill: n.xAxis.tickLabelColor
            },
            Et.formattedValue
          ));
        }), !n.xAxis.hideAxis && /* @__PURE__ */ r.createElement(en, { from: F.axisFromPoint, to: F.axisToPoint, stroke: "#333" }), /* @__PURE__ */ r.createElement(xt, { x: Ae, y: kt + 20 + te, textAnchor: "middle", verticalAnchor: "start", fontWeight: "bold", fill: n.xAxis.labelColor }, F.label));
        return ie.current && ie.current.setAttribute("height", Number(ae) + Number(kt) + (z.xAxis.label ? 50 : 0) + "px"), Ft;
      }
    ),
    C === "Paired Bar" && Tn(),
    C === "Deviation Bar" && ((Wn = n.runtime.series) == null ? void 0 : Wn.length) === 1 && /* @__PURE__ */ r.createElement(ik, { animatedChart: He, xScale: et, yScale: at, width: K, height: U }),
    C === "Paired Bar" && /* @__PURE__ */ r.createElement(yk, { originalWidth: G, width: K, height: U }),
    C === "Scatter Plot" && /* @__PURE__ */ r.createElement(
      ak,
      {
        xScale: et,
        yScale: at,
        getXAxisData: $e,
        getYAxisData: Ve,
        xMax: K,
        yMax: U,
        handleTooltipMouseOver: At,
        handleTooltipMouseOff: ln,
        handleTooltipClick: rn,
        tooltipData: ot,
        showTooltip: _e
      }
    ),
    C === "Box Plot" && /* @__PURE__ */ r.createElement(rk, { xScale: et, yScale: at }),
    (C === "Area Chart" && n.visualizationSubType === "regular" || C === "Combo") && /* @__PURE__ */ r.createElement(qE, { xScale: et, yScale: at, yMax: U, xMax: K, chartRef: ie, width: K, height: U, handleTooltipMouseOver: At, handleTooltipMouseOff: ln, tooltipData: ot, showTooltip: _e }),
    (C === "Area Chart" && n.visualizationSubType === "stacked" || C === "Combo") && /* @__PURE__ */ r.createElement(ZE, { xScale: et, yScale: at, yMax: U, xMax: K, chartRef: ie, width: K, height: U, handleTooltipMouseOver: At, handleTooltipMouseOff: ln, tooltipData: ot, showTooltip: _e }),
    (C === "Bar" || C === "Combo" || V()) && /* @__PURE__ */ r.createElement(
      nk,
      {
        xScale: et,
        yScale: at,
        seriesScale: gt,
        xMax: K,
        yMax: U,
        getXAxisData: $e,
        getYAxisData: Ve,
        animatedChart: He,
        visible: He,
        handleTooltipMouseOver: At,
        handleTooltipMouseOff: ln,
        handleTooltipClick: rn,
        tooltipData: ot,
        showTooltip: _e,
        chartRef: ie
      }
    ),
    (C === "Line" && !V() || C === "Combo" || C === "Bump Chart") && /* @__PURE__ */ r.createElement(
      em,
      {
        xScale: et,
        yScale: at,
        getXAxisData: $e,
        getYAxisData: Ve,
        xMax: K,
        yMax: U,
        seriesStyle: n.runtime.series,
        handleTooltipMouseOver: At,
        handleTooltipMouseOff: ln,
        handleTooltipClick: rn,
        tooltipData: ot,
        showTooltip: _e,
        chartRef: ie
      }
    ),
    (C === "Forecasting" || C === "Combo") && /* @__PURE__ */ r.createElement(
      lk,
      {
        showTooltip: _e,
        tooltipData: ot,
        xScale: et,
        yScale: at,
        width: K,
        le: !0,
        height: U,
        xScaleNoPadding: on,
        chartRef: ie,
        getXValueFromCoordinate: Hn,
        handleTooltipMouseOver: At,
        handleTooltipMouseOff: ln,
        isBrush: !1
      }
    ),
    n.yAxis.anchors && n.yAxis.anchors.map((F) => /* @__PURE__ */ r.createElement(en, { strokeDasharray: m(F.lineStyle), stroke: "rgba(0,0,0,1)", className: "customAnchor", from: { x: 0 + n.yAxis.size, y: at(F.value) }, to: { x: K, y: at(F.value) }, display: z.horizontal ? "none" : "block" })),
    C === "Forest Plot" && /* @__PURE__ */ r.createElement(
      mk,
      {
        xScale: et,
        yScale: at,
        seriesScale: gt,
        width: G,
        height: ae,
        getXAxisData: $e,
        getYAxisData: Ve,
        animatedChart: He,
        visible: He,
        handleTooltipMouseOver: At,
        handleTooltipMouseOff: ln,
        handleTooltipClick: rn,
        tooltipData: ot,
        showTooltip: _e,
        chartRef: ie,
        config: n
      }
    ),
    n.brush.active && n.xAxis.type !== "categorical" && /* @__PURE__ */ r.createElement(YE, { xScaleBrush: Wt, yScale: at, xMax: K, yMax: U, xScale: et, seriesScale: gt }),
    !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(C) && !V() && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(em, { xScale: et, yScale: at, getXAxisData: $e, getYAxisData: Ve, xMax: K, yMax: U, seriesStyle: n.runtime.series })),
    n.yAxis.anchors && n.yAxis.anchors.map((F, Ae) => {
      let ze = at(F.value);
      if (!F.value)
        return;
      const xe = w === "horizontal" && C === "Bar" ? n.barHeight / 4 : 0;
      if (ze)
        return (
          // prettier-ignore
          /* @__PURE__ */ r.createElement(
            en,
            {
              key: `yAxis-${F.value}--${Ae}`,
              strokeDasharray: m(F.lineStyle),
              stroke: F.color ? F.color : "rgba(0,0,0,1)",
              className: "anchor-y",
              from: { x: 0 + Vt, y: ze - xe },
              to: { x: G - n.yAxis.rightAxisSize, y: ze - xe }
            }
          )
        );
    }),
    n.xAxis.anchors && n.xAxis.anchors.map((F, Ae) => {
      let ze = R;
      w === "horizontal" && (ze = P);
      let xe = Cn(ze) ? et(v(F.value, !1)) : et(F.value);
      if (xe)
        return (
          // prettier-ignore
          /* @__PURE__ */ r.createElement(
            en,
            {
              key: `xAxis-${F.value}--${Ae}`,
              strokeDasharray: m(F.lineStyle),
              stroke: F.color ? F.color : "rgba(0,0,0,1)",
              fill: F.color ? F.color : "rgba(0,0,0,1)",
              className: "anchor-x",
              from: { x: Number(xe) + Number(Vt), y: 0 },
              to: { x: Number(xe) + Number(Vt), y: U }
            }
          )
        );
    }),
    n.visualizationType !== "Bar" && n.visualizationType !== "Combo" && /* @__PURE__ */ r.createElement(lp, { xScale: et, handleTooltipClick: rn, handleTooltipMouseOff: ln, handleTooltipMouseOver: At, showTooltip: _e, hideTooltip: $t, tooltipData: ot, yMax: U, width: G }),
    Pn && _e && ot && n.visual.verticalHoverLine && /* @__PURE__ */ r.createElement(rt, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ r.createElement(en, { from: { x: ot.dataXPosition - 10, y: 0 }, to: { x: ot.dataXPosition - 10, y: U }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "vertical-tooltip-line" })),
    Pn && _e && ot && n.visual.horizontalHoverLine && /* @__PURE__ */ r.createElement(rt, { key: "tooltipLine-horizontal", className: "horizontal-tooltip-line", left: n.yAxis.size ? n.yAxis.size : 0 }, /* @__PURE__ */ r.createElement(en, { from: { x: 0, y: ot.dataYPosition }, to: { x: K, y: ot.dataYPosition }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "horizontal-tooltip-line" })),
    n.filters && n.filters.values.length === 0 && A.length === 0 && /* @__PURE__ */ r.createElement(xt, { x: Number(n.yAxis.size) + Number(K / 2), y: ae / 2 - n.xAxis.padding / 2, textAnchor: "middle" }, n.chartMessage.noData),
    (n.visualizationType === "Bar" || V()) && n.tooltips.singleSeries && n.visual.horizontalHoverLine && /* @__PURE__ */ r.createElement(rt, { key: "tooltipLine-horizontal", className: "horizontal-tooltip-line", left: n.yAxis.size ? n.yAxis.size : 0 }, /* @__PURE__ */ r.createElement(en, { from: { x: 0, y: Ne.y }, to: { x: K, y: Ne.y }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "horizontal-tooltip-line" })),
    (n.visualizationType === "Bar" || V()) && n.tooltips.singleSeries && n.visual.verticalHoverLine && /* @__PURE__ */ r.createElement(rt, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ r.createElement(en, { from: { x: Ne.x, y: 0 }, to: { x: Ne.x, y: U }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "vertical-tooltip-line" })),
    /* @__PURE__ */ r.createElement(rt, { left: Number(n.runtime.yAxis.size) }, /* @__PURE__ */ r.createElement(up.Draggable, { xScale: et, yScale: at, xScaleAnnotation: Zt, xMax: K, svgRef: ie, onDragStateChange: y }))
  ), !M && ot && Object.entries(ot.data).length > 0 && Lt && _e && ot.dataYPosition && ot.dataXPosition && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${n.tooltips.opacity / 100}) !important;`), /* @__PURE__ */ r.createElement("style", null, ".tooltip {max-width:300px} !important; word-wrap: break-word; "), /* @__PURE__ */ r.createElement(ky, { key: Math.random(), className: "tooltip cdc-open-viz-module", left: nn, top: un }, /* @__PURE__ */ r.createElement("ul", null, typeof ot == "object" && Object.entries(ot.data).map((F, Ae) => /* @__PURE__ */ r.createElement(qt, { item: F, key: Ae }))))), n.visualizationType === "Bump Chart" && /* @__PURE__ */ r.createElement(Nf, { id: "bump-chart", variant: "light", arrowColor: "rgba(0,0,0,0)", className: "tooltip", style: { background: `rgba(255,255,255, ${n.tooltips.opacity / 100})`, color: "black" } }), ce() && !M && /* @__PURE__ */ r.createElement(Nf, { id: `cdc-open-viz-tooltip-${z.uniqueId}`, variant: "light", arrowColor: "rgba(0,0,0,0)", className: "tooltip", style: { background: `rgba(255,255,255, ${n.tooltips.opacity / 100})`, color: "black" } }), /* @__PURE__ */ r.createElement("div", { className: "animation-trigger", ref: Oe })));
};
const Nk = (e) => {
  var ee;
  const { width: t, height: n } = e, { transformedData: a, config: i, parseDate: l, formatDate: c, seriesHighlight: f, formatNumber: u, colorScale: m, handleChartAriaLabels: y } = le.useContext(bt);
  let v = Number(t);
  const { minValue: x, maxValue: A } = $c(i, a), T = { top: 5, right: 10, bottom: 10, left: 10 }, M = Number(n), E = v - i.runtime.yAxis.size, p = M - T.top - 20, C = (W) => i.runtime.xAxis.type === "date" ? l(W[i.runtime.originalXAxis.dataKey]).getTime() : W[i.runtime.originalXAxis.dataKey], _ = (W, Q) => W[Q];
  let w, R;
  const { max: P, min: z } = i.runtime.yAxis, q = Number(P) >= Number(A), V = Number(z) <= Number(x);
  if (a) {
    let W = Number(z && V ? z : x), Q = Number(P && q ? P : Number.MIN_VALUE);
    if (Q === Number.MIN_VALUE && (Q = A), i.runtime.yAxis.paddingPercent) {
      let te = (Q - W) * i.runtime.yAxis.paddingPercent;
      W -= te, Q += te;
    }
    let j = a.map((te) => C(te));
    i.runtime.horizontal ? (w = In({
      domain: [W, Q],
      range: [0, E]
    }), R = i.runtime.xAxis.type === "date" ? In({ domain: [Math.min(...j), Math.max(...j)] }) : Xo({ domain: j, padding: 0.5 }), Xo({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, p]
    }), R.rangeRound([0, p])) : (W = W < 0 ? W * 1.11 : W, R = In({
      domain: [W, Q],
      range: [p - T.bottom, T.top]
    }), w = Xo({
      domain: j,
      range: [T.left, v - T.right]
    }), Xo({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, E]
    }));
  }
  const G = [w.domain()[0], w.domain()[w.domain().length - 1]];
  return /* @__PURE__ */ r.createElement($r, { component: "SparkLine" }, /* @__PURE__ */ r.createElement("svg", { role: "img", "aria-label": y(i), width: t, height: 100, className: "sparkline", tabIndex: 0 }, /* @__PURE__ */ r.createElement("title", null, `Spark line graphic with the title ${i.title ? i.title : "No Title Found"}`), ((ee = i.runtime.lineSeriesKeys) == null ? void 0 : ee.length) > 0 ? i.runtime.lineSeriesKeys : i.runtime.seriesKeys.map((W, Q) => /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
    rt,
    {
      style: { width: v },
      className: "sparkline-group",
      key: `series-${W}`,
      opacity: i.legend.behavior === "highlight" && f.length > 0 && f.indexOf(W) === -1 ? 0.5 : 1,
      display: i.legend.behavior === "highlight" || f.length === 0 || f.indexOf(W) !== -1 ? "block" : "none"
    },
    i.labels && a.map((j, te) => /* @__PURE__ */ r.createElement(rt, { key: `series-${W}-point-${te}` }, /* @__PURE__ */ r.createElement(xt, { x: w(C(j)), y: R(_(j, W)), fill: m ? m(i.runtime.seriesLabels ? i.runtime.seriesLabels[W] : W) : "#000", textAnchor: "middle" }, u(j[W])))),
    /* @__PURE__ */ r.createElement(
      zr,
      {
        curve: Rc,
        data: a,
        x: (j) => w(C(j)),
        y: (j) => R(_(j, W)),
        stroke: m ? m(i.runtime.seriesLabels ? i.runtime.seriesLabels[W] : W) : "#000",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        markerEnd: `url(#arrow--${Q})`
      }
    ),
    /* @__PURE__ */ r.createElement(am, { id: `arrow--${Q}`, refX: 2, size: 6, markerEnd: `url(#arrow--${Q})`, strokeOpacity: 1, fillOpacity: 1, fill: m ? m(i.runtime.seriesLabels ? i.runtime.seriesLabels[W] : W) : "#000" })
  ), /* @__PURE__ */ r.createElement(
    Uu,
    {
      top: p + T.top,
      hideAxisLine: !0,
      hideTicks: !0,
      scale: w,
      tickValues: G,
      tickFormat: (j) => i.xAxis.type === "date" ? c(j) : null,
      stroke: "black",
      tickStroke: "black",
      tickLabelProps: () => ({
        fill: "black",
        fontSize: 11,
        textAnchor: "middle"
      })
    }
  )))));
}, _k = le.forwardRef((e, t) => {
  const {
    config: n,
    colorScale: a,
    seriesHighlight: i,
    highlight: l,
    tableData: c,
    highlightReset: f,
    transformedData: u,
    currentViewport: m
  } = le.useContext(bt);
  if (!n.legend)
    return null;
  const y = Ny(n, c, u, a);
  return !["Box Plot", "Pie"].includes(n.visualizationType) && /* @__PURE__ */ r.createElement(Dy, { ref: t, skipId: e.skipId || "legend", config: n, colorScale: a, seriesHighlight: i, highlight: l, highlightReset: f, currentViewport: m, formatLabels: y });
}), af = {
  annotations: [],
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  fontSize: "medium",
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "false",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    annotationDropdownText: "Annotations",
    showDownloadButton: !1,
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0,
    showZeroValueDataLabel: !0
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !0,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: [],
    shoMissingDataLabel: !0,
    showMissingDataLine: !0,
    categories: []
  },
  boxplot: {
    plots: [],
    borders: "true",
    firstQuartilePercentage: 25,
    thirdQuartilePercentage: 75,
    boxWidthPercentage: 40,
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    legend: {
      showHowToReadText: !1,
      howToReadText: ""
    },
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      total: "Total",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 65,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: "",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    seriesHighlight: []
  },
  brush: {
    height: 25,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, Xu = (e) => /* @__PURE__ */ le.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ le.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), Ok = ({ name: e }) => {
  var f, u, m, y, v;
  const { config: t, rawData: n, updateConfig: a } = le.useContext(bt);
  if (t.visualizationType !== "Forest Plot")
    return;
  const i = (x) => {
    x.orientation === "horizontal" && (x.labels = !1), x.table.show === void 0 && (x.table.show = !isDashboard), x.visualizationType === "Combo" && (x.orientation = "vertical");
  }, l = (x = !0) => {
    let A = {};
    return n.forEach((T) => {
      Object.keys(T).forEach((M) => A[M] = !0);
    }), x && Object.keys(A).forEach((T) => {
      (t.series && t.series.filter((M) => M.dataKey === T).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(T)) && delete A[T];
    }), Object.keys(A);
  }, c = (x, A, T, M) => {
    if (x === "boxplot" && A === "legend") {
      a({
        ...t,
        [x]: {
          ...t[x],
          [A]: {
            ...t.boxplot[A],
            [T]: M
          }
        }
      });
      return;
    }
    if (x === "boxplot" && A === "labels") {
      a({
        ...t,
        [x]: {
          ...t[x],
          [A]: {
            ...t.boxplot[A],
            [T]: M
          }
        }
      });
      return;
    }
    if (x === "forestPlot" && A) {
      let _ = {
        ...t,
        [x]: {
          ...t[x],
          [A]: {
            ...t.forestPlot[A],
            [T]: M
          }
        }
      };
      a(_);
      return;
    }
    if (x === "columns" && A !== "" && T !== "") {
      a({
        ...t,
        [x]: {
          ...t[x],
          [A]: {
            ...t[x][A],
            [T]: M
          }
        }
      });
      return;
    }
    if (x === null && A === null) {
      let _ = { ...t, [T]: M };
      i(_), a(_);
      return;
    }
    const E = Array.isArray(t[x]);
    let p = E ? [...t[x], M] : { ...t[x], [T]: M };
    A !== null && (E ? (p = [...t[x]], p[A] = { ...p[A], [T]: M }) : typeof M == "string" ? p[A] = M : p = { ...t[x], [A]: { ...t[x][A], [T]: M } });
    let C = { ...t, [x]: p };
    i(C), a(C);
  };
  return /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, e, (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ r.createElement(Xu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: t.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Study Column",
      initial: "Select",
      required: !0,
      updateField: c,
      options: l(!1),
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  ), /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: t.forestPlot.type,
      label: "Forest Plot Type",
      initial: "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            type: x.target.value
          }
        }), x.target.value = "";
      },
      options: ["Linear", "Logarithmic"],
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ", /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement("br", null), " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1.")))
    }
  ), /* @__PURE__ */ r.createElement(Je, { type: "text", value: ((f = t.forestPlot) == null ? void 0 : f.title) || "", updateField: c, section: "forestPlot", fieldName: "title", label: "Plot Title" }), /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement("hr", null), /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement("h4", null, "Column Settings"), /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: t.forestPlot.estimateField,
      label: "Point Estimate Column",
      initial: t.forestPlot.estimateField || "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            estimateField: x.target.value
          }
        }), x.target.value = "";
      },
      options: l(!1)
    }
  ), /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: t.forestPlot.shape,
      label: "Point Estimate Shape",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            shape: x.target.value
          }
        }), x.target.value = "";
      },
      options: ["text", "circle", "square"]
    }
  ), /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: t.forestPlot.lower,
      label: "Lower CI Column",
      required: !0,
      initial: t.forestPlot.lower || "Select",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            lower: x.target.value
          }
        }), x.target.value = "";
      },
      options: l(!1)
    }
  ), /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: t.forestPlot.upper,
      label: "Upper CI Column",
      initial: t.forestPlot.upper || "Select",
      required: !0,
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            upper: x.target.value
          }
        }), x.target.value = "";
      },
      options: l(!1)
    }
  ), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Pooled Result Column", /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      value: t.forestPlot.pooledResult.column || "",
      label: "Pooled Result Row",
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            pooledResult: {
              ...t.forestPlot.pooledResult,
              column: x.target.value
            }
          }
        }), x.target.value = "";
      }
    }
  ))), /* @__PURE__ */ r.createElement(ct, { value: ((m = (u = t.forestPlot) == null ? void 0 : u.lineOfNoEffect) == null ? void 0 : m.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: c }), /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement("hr", null), /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement("h4", null, "Width Settings"), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left (%)"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffset || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffset: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left Mobile(%)"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffsetMobile || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffsetMobile: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right (%)"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffset || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffset: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right Mobile(%)"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffsetMobile || 0,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffsetMobile: x.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement(Je, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: c, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }), /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement("hr", null), /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement("h4", null, "Labels Settings"), /* @__PURE__ */ r.createElement(Je, { type: "text", value: ((y = t.forestPlot) == null ? void 0 : y.leftLabel) || "", updateField: c, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }), /* @__PURE__ */ r.createElement(Je, { type: "text", value: ((v = t.forestPlot) == null ? void 0 : v.rightLabel) || "", updateField: c, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }), /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement("hr", null), /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: t.forestPlot.radius.scalingColumn,
      label: "Weight Column",
      initial: "Select",
      onChange: (x) => {
        x.target.value !== "" && x.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              scalingColumn: x.target.value
            }
          }
        }), x.target.value = "";
      },
      options: l(!1)
    }
  ), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Radius Minimum Size"), /* @__PURE__ */ r.createElement(
    "input",
    {
      min: 3,
      max: 6,
      value: t.forestPlot.radius.min || 3,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              min: Number(x.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  )), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Radius Maximum Size"), /* @__PURE__ */ r.createElement(
    "input",
    {
      min: 7,
      max: 10,
      value: t.forestPlot.radius.max,
      onChange: (x) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              max: Number(x.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  ))));
}, al = r.createContext({}), Fk = (e) => {
  const { updateConfig: t, config: n, rawData: a } = le.useContext(bt), { getColumns: i, selectComponent: l } = e, c = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], f = (u, m, y) => {
    let v = [...n.series];
    if (v[u][y] = m, y === "type" && m === "Bar" && (v[u].axis = "Left"), v[u].type === "Forecasting") {
      let x = Array.from(new Set(a.map((T) => T[v[u].dataKey]))), A = [];
      x.forEach((T) => {
        A.push({ key: T });
      }), v[u].stages = A, v[u].stageColumn = v[u].dataKey;
    }
    t({ ...n, series: v });
  };
  return /* @__PURE__ */ r.createElement(al.Provider, { value: { updateSeries: f, supportedRightAxisTypes: c, getColumns: i, selectComponent: l } }, e.children);
}, Mk = (e) => {
  const { config: t, updateConfig: n } = le.useContext(bt), { series: a, index: i } = e;
  if (!(() => {
    let u = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart", "Bump Chart"].some((y) => y.includes(a.type)) && (u = !0), u;
  })())
    return;
  const c = (u, m) => {
    let y = [...t.series];
    y[u].lineType = m, n({ ...t, series: y });
  };
  let f = [];
  return Object.keys(Gu).map((u) => f.push(Gu[u])), /* @__PURE__ */ r.createElement(
    Ia,
    {
      initial: "Select an option",
      value: a.lineType ? a.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (u) => {
        c(i, u.target.value);
      },
      options: f
    }
  );
}, zk = (e) => {
  const { config: t } = le.useContext(bt), { updateSeries: n } = le.useContext(al), { index: a, series: i } = e, l = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line" || t.visualizationType === "Bump Chart")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo", "Bump Chart"].includes(t.visualizationType))
    return /* @__PURE__ */ r.createElement(
      Ia,
      {
        initial: "Select an option",
        value: i.type,
        label: "Series Type",
        onChange: (c) => {
          n(a, c.target.value, "type");
        },
        options: l()
      }
    );
}, $k = (e) => {
  const { config: t, updateConfig: n, rawData: a } = le.useContext(bt), { updateSeries: i, getColumns: l } = le.useContext(al), { index: c, series: f } = e;
  return /* @__PURE__ */ r.createElement(
    Ia,
    {
      initial: "Select an option",
      value: f.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (u) => {
        let m = [], y = new Set(a == null ? void 0 : a.map((x) => x[u.target.value]));
        y = Array.from(y), y = y.filter((x) => x !== void 0), y.forEach((x) => m.push({ key: x }));
        const v = [...t.series];
        v[c] = { ...v[c], stages: m, stageColumn: u.target.value }, n({
          ...t,
          series: v
        });
      },
      options: l(!1)
    }
  );
}, Bk = (e) => {
  const { config: t, rawData: n } = le.useContext(bt), { updateSeries: a } = le.useContext(al), { index: i, series: l } = e;
  if (l.type !== "Forecasting" || !n || !l.stageColumn)
    return;
  let c = new Set(n.map((f) => f[l.stageColumn]));
  return c = Array.from(c), c = c.filter((f) => f !== void 0), /* @__PURE__ */ r.createElement(
    Ia,
    {
      initial: "Select an option",
      value: l.stageItem,
      label: "Forecasting Item Column",
      onChange: (f) => {
        a(i, f.target.value, "stageItem");
      },
      options: c
    }
  );
}, Ik = (e) => {
  const { config: t } = le.useContext(bt), { updateSeries: n, supportedRightAxisTypes: a } = le.useContext(al), { index: i, series: l } = e;
  if (!(t.visualizationType !== "Combo" || !l) && a.includes(l.type))
    return /* @__PURE__ */ r.createElement(
      Ia,
      {
        initial: "Select an option",
        value: l.axis ? l.axis : "Left",
        label: "Series Axis",
        onChange: (c) => {
          n(i, c.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, Hk = (e) => {
  var l;
  const { config: t, updateConfig: n } = le.useContext(bt), { index: a, series: i } = e;
  if (i.type === "Forecasting" && i)
    return (l = i == null ? void 0 : i.stages) == null ? void 0 : l.map((c, f) => {
      var u, m, y, v;
      return /* @__PURE__ */ r.createElement(
        Ia,
        {
          key: `${c}--${f}`,
          initial: "Select an option",
          value: (m = (u = t.series) == null ? void 0 : u[a].stages) != null && m[f].color ? (v = (y = t.series) == null ? void 0 : y[a].stages) == null ? void 0 : v[f].color : "Select",
          label: `${c.key} Series Color`,
          onChange: (x) => {
            const A = [...t.series], T = A[a].stages;
            T[f].color = x.target.value, A[a] = { ...A[a], stages: T }, n({
              ...t,
              series: A
            });
          },
          options: Object.keys(qu)
        }
      );
    });
}, Wk = (e) => {
  var c;
  const { config: t, updateConfig: n } = le.useContext(bt), { series: a, index: i } = e, { getColumns: l } = le.useContext(al);
  if (a.type === "Forecasting")
    return /* @__PURE__ */ r.createElement("div", { className: "edit-block" }, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Confidence Interval Groups"), /* @__PURE__ */ r.createElement("fieldset", null, /* @__PURE__ */ r.createElement(_i, { allowZeroExpanded: !0 }, (c = a == null ? void 0 : a.confidenceIntervals) == null ? void 0 : c.map((f, u) => {
      const m = f.showInTooltip ? f.showInTooltip : !1, y = (v, x, A) => {
        v.preventDefault();
        let T = [...t.series];
        T[x].confidenceIntervals[A].showInTooltip = !m, n({
          ...t,
          series: T
        });
      };
      return /* @__PURE__ */ r.createElement(Nn, { className: "series-item series-item--chart", key: `${u}` }, /* @__PURE__ */ r.createElement(_n, { className: "series-item__title" }, /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(On, { className: "accordion__button accordion__button" }, "Group ", u + 1, /* @__PURE__ */ r.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (v) => {
            v.preventDefault();
            const x = [...t.series[i].confidenceIntervals];
            x.splice(u, 1);
            const A = [...t.series];
            A[i] = { ...A[i], confidenceIntervals: [...x] }, n({
              ...t,
              series: A
            });
          }
        },
        "Remove"
      )))), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement("div", { className: "input-group" }, /* @__PURE__ */ r.createElement("label", { htmlFor: "showInTooltip" }, "Show In Tooltip"), /* @__PURE__ */ r.createElement("div", { className: "cove-input__checkbox--small", onClick: (v) => y(v, i, u) }, /* @__PURE__ */ r.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, m && /* @__PURE__ */ r.createElement(mm, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ r.createElement("input", { className: "cove-input--hidden", type: "checkbox", name: "showInTooltip", checked: m || !1, readOnly: !0 }))), /* @__PURE__ */ r.createElement(
        Ia,
        {
          initial: "Select an option",
          value: t.series[i].confidenceIntervals[u].low ? t.series[i].confidenceIntervals[u].low : "Select",
          label: "Low Confidence Interval",
          onChange: (v) => {
            const x = [...t.series[i].confidenceIntervals];
            x[u].low = v.target.value;
            const A = [...t.series];
            A[i] = { ...A[i], confidenceIntervals: x }, n({
              ...t,
              series: A
            });
          },
          options: l()
        }
      ), /* @__PURE__ */ r.createElement(
        Ia,
        {
          initial: "Select an option",
          value: t.series[i].confidenceIntervals[u].high ? t.series[i].confidenceIntervals[u].high : "Select",
          label: "High Confidence Interval",
          onChange: (v) => {
            const x = [...t.series[i].confidenceIntervals];
            x[u].high = v.target.value;
            const A = [...t.series];
            A[i] = { ...A[i], confidenceIntervals: x }, n({
              ...t,
              series: A
            });
          },
          options: l()
        }
      )));
    })), /* @__PURE__ */ r.createElement(
      "button",
      {
        className: "btn full-width",
        onClick: (f) => {
          f.preventDefault();
          let u = null;
          t.series[i].confidenceIntervals ? u = [...t.series[i].confidenceIntervals] : u = [];
          const m = [...t.series];
          m[i] = { ...m[i], confidenceIntervals: [...u, { high: "", low: "" }] }, n({
            ...t,
            series: m
          });
        }
      },
      "Add Confidence Interval Group"
    )));
}, Vk = (e) => {
  const { series: t, index: n } = e, { config: a, updateConfig: i } = le.useContext(bt);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const c = (f, u, m, y) => {
    let v = [...a.series], x = { ...a.runtime.seriesLabels };
    v[f].weight = u && Math.max(Number(m), Math.min(Number(y), Number(u))), x[v[f].dataKey] = v[f].weight ? v[f].weight : v[f].dataKey;
    const A = {
      ...a,
      series: v,
      runtime: {
        ...a.runtime,
        seriesLabels: x
      }
    };
    i(A);
  };
  return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("label", { htmlFor: "series-weight" }, "Line Weight"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "number",
      key: `series-weight-${n}`,
      value: t.weight ? t.weight : "",
      min: "1",
      max: "9",
      onChange: (f) => {
        c(n, f.target.value, f.target.min, f.target.max);
      }
    }
  ));
}, jk = (e) => {
  const { series: t, index: n } = e, { config: a, updateConfig: i } = le.useContext(bt);
  if (!["Bump Chart", "Bar", "Line", "Area Chart", "Combo", "Deviation", "Paired", "Scatter", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const c = (f, u) => {
    let m = [...a.series], y = { ...a.runtime.seriesLabels };
    m[f].name = u, y[m[f].dataKey] = m[f].name ? m[f].name : m[f].dataKey;
    let v = {
      ...a,
      series: m,
      runtime: {
        ...a.runtime,
        seriesLabels: y
      }
    };
    i(v);
  };
  return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("label", { htmlFor: "series-name" }, "Series Name"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      key: `series-name-${n}`,
      value: t.name ? t.name : "",
      onChange: (f) => {
        c(n, f.target.value);
      }
    }
  ));
}, Uk = (e) => {
  const { series: t, index: n } = e, { config: a, updateConfig: i } = le.useContext(bt);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(a.visualizationType))
    return;
  const l = (c) => {
    let f = [...a.series];
    f[c].tooltip && f[c].tooltip, f[c].tooltip = !f[c].tooltip, i({
      ...a,
      series: f
    });
  };
  return /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("div", { className: "input-group" }, /* @__PURE__ */ r.createElement("label", { htmlFor: `series-tooltip--${n}` }, "Show In Tooltip"), /* @__PURE__ */ r.createElement("div", { className: "cove-input__checkbox--small", onClick: (c) => l(n) }, /* @__PURE__ */ r.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, t.tooltip && /* @__PURE__ */ r.createElement(mm, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ r.createElement("input", { className: "cove-input--hidden", type: "checkbox", name: `series-tooltip--${n}`, checked: t.tooltip ? t.tooltip : !1, readOnly: !0 }))));
}, Kk = (e) => {
  const { config: t, updateConfig: n } = le.useContext(bt), { series: a, index: i } = e, l = (f) => {
    let u = [...t.series], m = -1;
    for (let y = 0; y < u.length; y++)
      if (u[y].dataKey === f) {
        m = y;
        break;
      }
    if (m !== -1) {
      u.splice(m, 1);
      let y = { ...t, series: u };
      u.length === 0 && delete y.series, n(y);
    }
    t.visualizationType === "Paired Bar" && n({
      ...t,
      series: []
    });
  }, c = (f, u, m) => {
    f.preventDefault(), l(u.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ r.createElement("button", { className: "series-list__remove", onClick: (f) => c(f, a) }, "Remove");
}, qy = (e) => {
  const { config: t } = le.useContext(bt), { series: n, getItemStyle: a, sortableItemStyles: i, chartsWithOptions: l, index: c } = e;
  return /* @__PURE__ */ r.createElement(eg, { key: n.dataKey, draggableId: `draggableFilter-${n.dataKey}`, index: c }, (f, u) => /* @__PURE__ */ r.createElement("div", { key: c, className: u.isDragging ? "currently-dragging" : "", style: a(u.isDragging, f.draggableProps.style, i), ref: f.innerRef, ...f.draggableProps, ...f.dragHandleProps }, /* @__PURE__ */ r.createElement(_i, { allowZeroExpanded: !0 }, /* @__PURE__ */ r.createElement(Nn, { className: "series-item series-item--chart" }, /* @__PURE__ */ r.createElement(_n, { className: "series-item__title" }, /* @__PURE__ */ r.createElement(On, { className: l.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow" }, /* @__PURE__ */ r.createElement(st, { display: "move", size: 15, style: { cursor: "default" } }), n.dataKey, /* @__PURE__ */ r.createElement(Xr.Button.Remove, { series: n, index: c }))), l.includes(t.visualizationType) && /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement(Xr.Input.Name, { series: n, index: c }), /* @__PURE__ */ r.createElement(Xr.Input.Weight, { series: n, index: c }), /* @__PURE__ */ r.createElement(Xr.Dropdown.SeriesType, { series: n, index: c }), /* @__PURE__ */ r.createElement(Xr.Dropdown.AxisPosition, { series: n, index: c }), /* @__PURE__ */ r.createElement(Xr.Dropdown.LineType, { series: n, index: c }), /* @__PURE__ */ r.createElement(Xr.Dropdown.ForecastingColor, { series: n, index: c }), /* @__PURE__ */ r.createElement(Xr.Dropdown.ConfidenceInterval, { series: n, index: c }), /* @__PURE__ */ r.createElement(Xr.Checkbox.DisplayInTooltip, { series: n, index: c }))))));
}, Yk = (e) => {
  const { series: t, getItemStyle: n, sortableItemStyles: a, chartsWithOptions: i } = e;
  return t.map((l, c) => /* @__PURE__ */ r.createElement(qy, { getItemStyle: n, sortableItemStyles: a, chartsWithOptions: i, series: l, index: c, key: `series-list-${c}` }));
}, Xr = {
  Wrapper: Fk,
  Dropdown: {
    SeriesType: zk,
    AxisPosition: Ik,
    ConfidenceInterval: Wk,
    LineType: Mk,
    ForecastingStage: $k,
    ForecastingColumn: Bk,
    ForecastingColor: Hk
  },
  Input: {
    Name: jk,
    Weight: Vk
  },
  Checkbox: {
    DisplayInTooltip: Uk
  },
  Button: {
    Remove: Kk
  },
  Item: qy,
  List: Yk
}, Xk = le.memo(({ config: e, updateConfig: t }) => {
  let n = (u, m, y) => {
    let v = [];
    e.regions && (v = [...e.regions]), v[y][u] = m, t({ ...e, regions: v });
  }, a = (u, m, y, v, x) => n(y, v, x), i = (u) => {
    let m = [];
    e.regions && (m = [...e.regions]), m.splice(u, 1), t({ ...e, regions: m });
  }, l = () => {
    let u = [];
    e.regions && (u = [...e.regions]), u.push({}), t({ ...e, regions: u });
  };
  const c = ["Fixed", "Previous Days"], f = ["Last Date", "Fixed"];
  return /* @__PURE__ */ r.createElement(r.Fragment, null, e.regions && e.regions.map(({ label: u, color: m, from: y, to: v, background: x, range: A = "Custom" }, T) => {
    var M;
    return /* @__PURE__ */ r.createElement("div", { className: "edit-block", key: `region-${T}` }, /* @__PURE__ */ r.createElement(
      "button",
      {
        type: "button",
        className: "remove-column",
        onClick: (E) => {
          E.preventDefault(), i(T);
        }
      },
      "Remove"
    ), /* @__PURE__ */ r.createElement(Je, { value: u, label: "Region Label", fieldName: "label", i: T, updateField: a }), /* @__PURE__ */ r.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ r.createElement(Je, { value: m, label: "Text Color", fieldName: "color", updateField: (E, p, C, _) => n(C, _, T) }), /* @__PURE__ */ r.createElement(Je, { value: x, label: "Background", fieldName: "background", updateField: (E, p, C, _) => n(C, _, T) })), /* @__PURE__ */ r.createElement(
      Pt,
      {
        value: e.regions[T].fromType ?? "Fixed",
        label: "Minimum Region Type",
        initial: "Select",
        required: !0,
        onChange: (E) => {
          if (E.target.value !== "" && E.target.value !== "Select") {
            const p = [...e.regions];
            p[T].fromType = E.target.value, t({
              ...e,
              regions: p
            });
          }
          E.target.value = "";
        },
        options: c
      }
    ), (e.regions[T].fromType === "Fixed" || e.regions[T].fromType === "Previous Days" || !e.regions[T].fromType) && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
      Je,
      {
        value: y,
        label: e.regions[T].fromType === "Fixed" || !((M = e.regions[T]) != null && M.fromType) ? "From Value" : "Previous Number of Days",
        fieldName: "from",
        updateField: (E, p, C, _) => n(C, _, T),
        tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value.")))
      }
    )), /* @__PURE__ */ r.createElement(
      Pt,
      {
        value: e.regions[T].toType ?? "Fixed",
        label: "Maximum Region Type",
        initial: "Select",
        required: !0,
        onChange: (E) => {
          if (E.target.value !== "" && E.target.value !== "Select") {
            const p = [...e.regions];
            p[T].toType = E.target.value, t({
              ...e,
              regions: p
            });
          }
          E.target.value = "";
        },
        options: f
      }
    ), (e.regions[T].toType === "Fixed" || !e.regions[T].toType) && /* @__PURE__ */ r.createElement(Je, { value: v, label: "To Value", fieldName: "to", updateField: (E, p, C, _) => n(C, _, T) }));
  }), !e.regions && /* @__PURE__ */ r.createElement("p", { style: { textAlign: "center" } }, "There are currently no regions."), /* @__PURE__ */ r.createElement(
    "button",
    {
      type: "button",
      className: "btn full-width",
      onClick: (u) => {
        u.preventDefault(), l();
      }
    },
    "Add Region"
  ));
}), qk = ({ name: e }) => {
  const { visSupportsRegions: t } = _s(), { config: n, updateConfig: a } = le.useContext(bt);
  return t() ? /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, e)), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement(Xk, { config: n, updateConfig: a }))) : null;
}, cp = le.createContext(null), dp = () => {
  const e = le.useContext(cp);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, Gk = (e) => {
  const { config: t } = le.useContext(bt), { updateField: n } = dp(), { enabledChartTypes: a, visHasNumbersOnBars: i, visHasaAdditionalLabelsOnBars: l, visHasLabelOnData: c, visSupportsChartHeight: f, visSupportsSuperTitle: u, visSupportsFootnotes: m } = _s(), { visualizationType: y, visualizationSubType: v, barStyle: x } = t, A = () => (y === "Bar" || y === "Deviation Bar") && v !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ r.createElement(Nn, null, " ", /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, "General")), /* @__PURE__ */ r.createElement(Fn, null, (t == null ? void 0 : t.visualizationType) !== "Sankey" && /* @__PURE__ */ r.createElement(Pt, { value: y, fieldName: "visualizationType", label: "Chart Type", updateField: n, options: a }), f() && t.orientation === "vertical" && /* @__PURE__ */ r.createElement(
    Je,
    {
      type: "number",
      value: t.heights.vertical,
      section: "heights",
      fieldName: "vertical",
      label: "Chart Height",
      updateField: n,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "For some visualization types, such as the Sankey diagram, it may be necessary to adjust the chart height for optimal display.")))
    }
  ), (y === "Bar" || y === "Combo" || y === "Area Chart") && /* @__PURE__ */ r.createElement(Pt, { value: v || "Regular", fieldName: "visualizationSubType", label: "Chart Subtype", updateField: n, options: ["regular", "stacked"] }), y === "Area Chart" && v === "stacked" && /* @__PURE__ */ r.createElement(Pt, { value: t.stackedAreaChartLineType || "Linear", fieldName: "stackedAreaChartLineType", label: "Stacked Area Chart Line Type", updateField: n, options: Object.keys(Gu) }), y === "Bar" && /* @__PURE__ */ r.createElement(Pt, { value: t.orientation || "vertical", fieldName: "orientation", label: "Orientation", updateField: n, options: ["vertical", "horizontal"] }), y === "Deviation Bar" && /* @__PURE__ */ r.createElement(Pt, { label: "Orientation", options: ["horizontal"] }), (y === "Bar" || y === "Deviation Bar") && /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: t.isLollipopChart ? "lollipop" : x || "flat",
      fieldName: "barStyle",
      label: "bar style",
      updateField: n,
      options: A(),
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Consider using the 'Flat' bar style when presenting data that includes '0' values.")))
    }
  ), (y === "Bar" || y === "Deviation Bar") && x === "rounded" && /* @__PURE__ */ r.createElement(Pt, { value: t.tipRounding || "top", fieldName: "tipRounding", label: "tip rounding", updateField: n, options: ["top", "full"] }), (y === "Bar" || y === "Deviation Bar") && x === "rounded" && /* @__PURE__ */ r.createElement(Pt, { value: t.roundingStyle || "standard", fieldName: "roundingStyle", label: "rounding style", updateField: n, options: ["standard", "shallow", "finger"] }), y === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ r.createElement(Pt, { value: t.yAxis.labelPlacement || "Below Bar", section: "yAxis", fieldName: "labelPlacement", label: "Label Placement", updateField: n, options: ["Below Bar", "On Date/Category Axis"] }), i() ? /* @__PURE__ */ r.createElement(ct, { value: t.yAxis.displayNumbersOnBar, section: "yAxis", fieldName: "displayNumbersOnBar", label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar", updateField: n }) : c() && /* @__PURE__ */ r.createElement(
    ct,
    {
      value: t.labels,
      fieldName: "labels",
      label: "Display label on data",
      updateField: n,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, 'Selecting this option will not hide the display of "zero value", "suppressed data", or "missing data" indicators on the chart (if applicable).')))
    }
  ), l() && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
    ct,
    {
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Selecting this option will display 'N/A' on the Date/Category Axis, in the tooltip hover, and in the data table to indicate missing or undefined data values."))),
      value: t.general.showMissingDataLabel,
      section: "general",
      fieldName: "showMissingDataLabel",
      label: 'Display "Missing Data" Label',
      updateField: n
    }
  ), /* @__PURE__ */ r.createElement(
    ct,
    {
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, ' Selecting this option will display a thin line slightly above the Date/Category Axis to indicate "zero value" where zero values are indicated in the Data Series.'))),
      value: t.general.showZeroValueDataLabel,
      section: "general",
      fieldName: "showZeroValueDataLabel",
      label: 'Display "Zero Value Data" Label',
      updateField: n
    }
  ), /* @__PURE__ */ r.createElement(
    ct,
    {
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Selecting this option will display the 'suppressed data symbol' on the Date/Category Axis, in the tooltip hover, and in the data table where suppressed data values are indicated in the Data Series"))),
      value: t.general.showSuppressedSymbol,
      section: "general",
      fieldName: "showSuppressedSymbol",
      label: 'Display "suppressed data" label',
      updateField: n
    }
  )), y === "Pie" && /* @__PURE__ */ r.createElement(Pt, { fieldName: "pieType", label: "Pie Chart Type", updateField: n, options: ["Regular", "Donut"] }), y === "Line" && /* @__PURE__ */ r.createElement(
    ct,
    {
      value: t.allowLineToBarGraph,
      fieldName: "allowLineToBarGraph",
      label: "Convert to Bar Graph",
      updateField: n,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Switch to bar graph when less than 3 data points available.")))
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      value: t.title || "Chart Title",
      fieldName: "title",
      id: "title",
      label: "Title",
      placeholder: "Chart Title",
      updateField: n,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Title is required to set the name of the download file but can be hidden using the option below.")))
    }
  ), /* @__PURE__ */ r.createElement(ct, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: n }), u() && /* @__PURE__ */ r.createElement(
    Je,
    {
      value: t.superTitle,
      updateField: n,
      fieldName: "superTitle",
      label: "Super Title",
      placeholder: "Super Title",
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Super Title")))
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      type: "textarea",
      value: t.introText,
      updateField: n,
      fieldName: "introText",
      label: "Message",
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Intro Text")))
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      type: "textarea",
      value: t.description,
      fieldName: "description",
      label: "Subtext/Citation",
      updateField: n,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub.")))
    }
  ), m() && /* @__PURE__ */ r.createElement(
    Je,
    {
      type: "textarea",
      value: t.footnotes,
      updateField: n,
      fieldName: "footnotes",
      label: "Footnotes",
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data.")))
    }
  )));
}, Zk = (e) => {
  const { config: t } = le.useContext(bt), { boxplot: n } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: a } = dp();
  return /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, e.name)), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement("h4", { style: { fontSize: "18px" } }, "Labels for 5-Number Summary"), /* @__PURE__ */ r.createElement(
    Je,
    {
      type: "text",
      value: n.labels.maximum,
      fieldName: "maximum",
      section: "boxplot",
      subsection: "labels",
      label: "Maximum",
      updateField: a,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Highest value, excluding outliers")))
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      type: "text",
      value: n.labels.q3,
      fieldName: "q3",
      section: "boxplot",
      subsection: "labels",
      label: "Upper Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Represented by top line of box. 25% of data are higher.")))
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      type: "text",
      value: n.labels.median,
      fieldName: "median",
      section: "boxplot",
      subsection: "labels",
      label: "Median",
      updateField: a,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Middle data point. Half of data are higher value.")))
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      type: "text",
      value: n.labels.q1,
      fieldName: "q1",
      section: "boxplot",
      subsection: "labels",
      label: "Lower Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Represented by bottom line of box. 25% of data are lower.")))
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      type: "text",
      value: n.labels.minimum,
      fieldName: "minimum",
      section: "boxplot",
      subsection: "labels",
      label: "Minimum",
      updateField: a,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Lowest value, excluding outliers")))
    }
  ), /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement("h4", { style: { fontSize: "18px" } }, "Labels for Additional Measures"), /* @__PURE__ */ r.createElement(Je, { type: "text", value: n.labels.iqr, fieldName: "iqr", section: "boxplot", subsection: "labels", label: "Interquartile Range", updateField: a }), /* @__PURE__ */ r.createElement(Je, { type: "text", value: n.labels.total, fieldName: "total", section: "boxplot", subsection: "labels", label: "Total", updateField: a }), /* @__PURE__ */ r.createElement(Je, { type: "text", value: n.labels.mean, fieldName: "mean", section: "boxplot", subsection: "labels", label: "Mean", updateField: a }), /* @__PURE__ */ r.createElement(Je, { type: "text", value: n.labels.outliers, fieldName: "outliers", section: "boxplot", subsection: "labels", label: "Outliers", updateField: a }), /* @__PURE__ */ r.createElement(Je, { type: "text", value: n.labels.values, fieldName: "values", section: "boxplot", subsection: "labels", label: "Values", updateField: a })));
}, Qk = (e, t) => {
  let n = [], a = [], i = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const l = e.twoColor.isPaletteReversed;
    n = Object.keys(Ss).filter((c) => l ? c.endsWith("reverse") : !c.endsWith("reverse"));
  } else {
    const l = [], c = [];
    for (const f in cr) {
      const u = f.startsWith("sequential"), m = f.startsWith("qualitative"), y = f.endsWith("reverse");
      u && (!e.isPaletteReversed && !y || e.isPaletteReversed && y) && l.push(f), m && (!e.isPaletteReversed && !y || e.isPaletteReversed && y) && c.push(f);
    }
    a = l, i = c;
  }
  return le.useEffect(() => {
    let l = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (l = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (l = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: l } });
  }, [e.twoColor.isPaletteReversed]), le.useEffect(() => {
    let l = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (l = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (l = e.palette.slice(0, -7)), t({ ...e, palette: l });
  }, [e.isPaletteReversed]), { twoColorPalettes: n, sequential: a, nonSequential: i };
}, Jk = (e) => {
  var q;
  const { config: t, updateConfig: n, colorPalettes: a, twoColorPalette: i } = le.useContext(bt), { visual: l } = t, { setLollipopShape: c, updateField: f } = dp(), { visHasBarBorders: u, visCanAnimate: m, visSupportsNonSequentialPallete: y, headerColors: v, visSupportsTooltipOpacity: x, visSupportsTooltipLines: A, visSupportsBarSpace: T, visSupportsBarThickness: M, visHasDataCutoff: E, visSupportsSequentialPallete: p, visSupportsReverseColorPalette: C, visHasSingleSeriesTooltip: _ } = _s(), { twoColorPalettes: w, sequential: R, nonSequential: P } = Qk(t, n), z = (V, G) => {
    if (console.log("value", G), V === "storyNodeFontColor") {
      n({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: G
        }
      });
      return;
    } else
      n({
        ...t,
        sankey: {
          ...t.sankey,
          [V]: {
            ...t.sankey[V],
            default: G
          }
        }
      });
  };
  return /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, "Visual")), /* @__PURE__ */ r.createElement(Fn, null, (t.barStyle === "lollipop" || t.isLollipopChart) && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("fieldset", { className: "header" }, /* @__PURE__ */ r.createElement("legend", { className: "edit-label" }, "Lollipop Shape"), /* @__PURE__ */ r.createElement(
    "div",
    {
      onChange: (V) => {
        c(V.target.value);
      }
    },
    /* @__PURE__ */ r.createElement("label", { className: "radio-label" }, /* @__PURE__ */ r.createElement("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }), "Circle"),
    /* @__PURE__ */ r.createElement("label", { className: "radio-label" }, /* @__PURE__ */ r.createElement("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }), "Square")
  )), /* @__PURE__ */ r.createElement(Pt, { value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone", fieldName: "lollipopColorStyle", label: "Lollipop Color Style", updateField: f, options: ["regular", "two-tone"] }), /* @__PURE__ */ r.createElement(Pt, { value: t.lollipopSize ? t.lollipopSize : "small", fieldName: "lollipopSize", label: "Lollipop Size", updateField: f, options: ["small", "medium", "large"] })), t.visualizationType === "Box Plot" && /* @__PURE__ */ r.createElement("fieldset", { className: "fieldset fieldset--boxplot" }, /* @__PURE__ */ r.createElement("legend", { className: "" }, "Box Plot Settings"), /* @__PURE__ */ r.createElement(Pt, { value: t.boxplot.borders, fieldName: "borders", section: "boxplot", label: "Box Plot Borders", updateField: f, options: ["true", "false"] }), /* @__PURE__ */ r.createElement(ct, { value: t.boxplot.plotOutlierValues, fieldName: "plotOutlierValues", section: "boxplot", label: "Plot Outliers", updateField: f }), /* @__PURE__ */ r.createElement(ct, { value: t.boxplot.plotNonOutlierValues, fieldName: "plotNonOutlierValues", section: "boxplot", label: "Plot non-outlier values", updateField: f })), /* @__PURE__ */ r.createElement(Pt, { value: t.fontSize, fieldName: "fontSize", label: "Font Size", updateField: f, options: ["small", "medium", "large"] }), u() && /* @__PURE__ */ r.createElement(Pt, { value: t.barHasBorder, fieldName: "barHasBorder", label: "Bar Borders", updateField: f, options: ["true", "false"] }), m() && /* @__PURE__ */ r.createElement(ct, { value: t.animate, fieldName: "animate", label: "Animate Visualization", updateField: f }), (((q = t.series) == null ? void 0 : q.some((V) => V.type === "Line" || V.type === "dashed-lg" || V.type === "dashed-sm" || V.type === "dashed-md")) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(Pt, { value: t.lineDatapointStyle, fieldName: "lineDatapointStyle", label: "Line Datapoint Style", updateField: f, options: ["hidden", "hover", "always show"] }), /* @__PURE__ */ r.createElement(Pt, { value: t.lineDatapointColor, fieldName: "lineDatapointColor", label: "Line Datapoint Color", updateField: f, options: ["Same as Line", "Lighter than Line"] })), /* @__PURE__ */ r.createElement("label", { className: "header" }, /* @__PURE__ */ r.createElement("span", { className: "edit-label" }, "Header Theme"), /* @__PURE__ */ r.createElement("ul", { className: "color-palette" }, v.map((V) => /* @__PURE__ */ r.createElement(
    "button",
    {
      title: V,
      key: V,
      onClick: (G) => {
        G.preventDefault(), n({ ...t, theme: V });
      },
      className: t.theme === V ? "selected " + V : V
    }
  )))), (y() || y()) && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label" }, "Chart Color Palette")), C() && /* @__PURE__ */ r.createElement(wp, { fieldName: "isPaletteReversed", size: "small", label: "Use selected palette in reverse order", updateField: f, value: t.isPaletteReversed }), p() && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("span", null, "Sequential"), /* @__PURE__ */ r.createElement("ul", { className: "color-palette" }, R.map((V) => {
    const G = {
      backgroundColor: a[V][2]
    }, ee = {
      backgroundColor: a[V][3]
    }, W = {
      backgroundColor: a[V][5]
    };
    return /* @__PURE__ */ r.createElement(
      "button",
      {
        title: V,
        key: V,
        onClick: (Q) => {
          Q.preventDefault(), n({ ...t, palette: V });
        },
        className: t.palette === V ? "selected" : ""
      },
      /* @__PURE__ */ r.createElement("span", { style: G }),
      /* @__PURE__ */ r.createElement("span", { style: ee }),
      /* @__PURE__ */ r.createElement("span", { style: W })
    );
  }))), y() && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("span", null, "Non-Sequential"), /* @__PURE__ */ r.createElement("ul", { className: "color-palette" }, P.map((V) => {
    const G = {
      backgroundColor: a[V][2]
    }, ee = {
      backgroundColor: a[V][4]
    }, W = {
      backgroundColor: a[V][6]
    };
    return /* @__PURE__ */ r.createElement(
      "button",
      {
        title: V,
        key: V,
        onClick: (Q) => {
          Q.preventDefault(), n({ ...t, palette: V });
        },
        className: t.palette === V ? "selected" : ""
      },
      /* @__PURE__ */ r.createElement("span", { style: G }),
      /* @__PURE__ */ r.createElement("span", { style: ee }),
      /* @__PURE__ */ r.createElement("span", { style: W })
    );
  })))), t.visualizationType === "Sankey" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ r.createElement("input", { type: "color", value: t.sankey.nodeColor.default, id: "storyNodeColor", name: "storyNodeColor", onChange: (V) => z("nodeColor", V.target.value) }), /* @__PURE__ */ r.createElement("label", { htmlFor: "storyNodeColor" }, "Story Node Color")), /* @__PURE__ */ r.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ r.createElement("input", { type: "color", value: t.sankey.storyNodeFontColor || "red", id: "storyNodeFontColor", name: "storyNodeFontColor", onChange: (V) => z("storyNodeFontColor", V.target.value) }), /* @__PURE__ */ r.createElement("label", { htmlFor: "storyNodeFontColor" }, "Story Node Font Color")), /* @__PURE__ */ r.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ r.createElement("input", { type: "color", value: t.sankey.linkColor.default, id: "linkColor", name: "linkColor", onChange: (V) => z("linkColor", V.target.value) }), /* @__PURE__ */ r.createElement("label", { htmlFor: "linkColor" }, "Link Color"))), (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(wp, { section: "twoColor", fieldName: "isPaletteReversed", size: "small", label: "Use selected palette in reverse order", updateField: f, value: t.twoColor.isPaletteReversed }), /* @__PURE__ */ r.createElement("ul", { className: "color-palette" }, w.map((V) => {
    const G = {
      backgroundColor: i[V][0]
    }, ee = {
      backgroundColor: i[V][1]
    };
    return /* @__PURE__ */ r.createElement(
      "button",
      {
        title: V,
        key: V,
        onClick: (W) => {
          W.preventDefault(), n({ ...t, twoColor: { ...t.twoColor, palette: V } });
        },
        className: t.twoColor.palette === V ? "selected" : ""
      },
      /* @__PURE__ */ r.createElement("span", { className: "two-color", style: G }),
      /* @__PURE__ */ r.createElement("span", { className: "two-color", style: ee })
    );
  }))), E() && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
    Je,
    {
      value: t.dataCutoff,
      type: "number",
      fieldName: "dataCutoff",
      className: "number-narrow",
      label: "Data Cutoff",
      updateField: f,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.')))
    }
  )), M() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ r.createElement(Je, { type: "number", value: t.barHeight || "25", fieldName: "barHeight", label: " Bar Thickness", updateField: f, min: 15 }), (t.visualizationType === "Bar" && t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ r.createElement(Je, { value: t.barThickness, type: "number", fieldName: "barThickness", label: "Bar Thickness", updateField: f }), T() && /* @__PURE__ */ r.createElement(Je, { type: "number", value: t.barSpace || "15", fieldName: "barSpace", label: "Bar Space", updateField: f, min: 0 }), (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ r.createElement(ct, { value: t.topAxis.hasLine, section: "topAxis", fieldName: "hasLine", label: "Add Top Axis Line", updateField: f }), t.visualizationType === "Spark Line" && /* @__PURE__ */ r.createElement("div", { className: "cove-accordion__panel-section checkbox-group" }, /* @__PURE__ */ r.createElement(ct, { value: l == null ? void 0 : l.border, section: "visual", fieldName: "border", label: "Show Border", updateField: f }), /* @__PURE__ */ r.createElement(ct, { value: l == null ? void 0 : l.borderColorTheme, section: "visual", fieldName: "borderColorTheme", label: "Use Border Color Theme", updateField: f }), /* @__PURE__ */ r.createElement(ct, { value: l == null ? void 0 : l.accent, section: "visual", fieldName: "accent", label: "Use Accent Style", updateField: f }), /* @__PURE__ */ r.createElement(ct, { value: l == null ? void 0 : l.background, section: "visual", fieldName: "background", label: "Use Theme Background Color", updateField: f }), /* @__PURE__ */ r.createElement(ct, { value: l == null ? void 0 : l.hideBackgroundColor, section: "visual", fieldName: "hideBackgroundColor", label: "Hide Background Color", updateField: f })), (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ r.createElement(ct, { value: t.showLineSeriesLabels, fieldName: "showLineSeriesLabels", label: "Append Series Name to End of Line Charts", updateField: f }), (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ r.createElement(ct, { value: t.colorMatchLineSeriesLabels, fieldName: "colorMatchLineSeriesLabels", label: "Match Series Color to Name at End of Line Charts", updateField: f }), A() && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(ct, { value: l.verticalHoverLine, fieldName: "verticalHoverLine", section: "visual", label: "Vertical Hover Line", updateField: f }), /* @__PURE__ */ r.createElement(ct, { value: l.horizontalHoverLine, fieldName: "horizontalHoverLine", section: "visual", label: "Horizontal Hover Line", updateField: f })), x() && /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Tooltip Opacity"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "number",
      value: t.tooltips.opacity ? t.tooltips.opacity : 100,
      onChange: (V) => n({
        ...t,
        tooltips: {
          ...t.tooltips,
          opacity: V.target.value
        }
      })
    }
  )), _() && /* @__PURE__ */ r.createElement(ct, { value: t.tooltips.singleSeries, fieldName: "singleSeries", section: "tooltips", label: "SHOW HOVER FOR SINGLE DATA SERIES", updateField: f }), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "No Data Message"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      value: t.chartMessage.noData ? t.chartMessage.noData : "",
      onChange: (V) => n({
        ...t,
        chartMessage: {
          ...t.chartMessage,
          noData: V.target.value
        }
      })
    }
  ))));
}, ew = () => {
  var f, u, m, y;
  const { config: e, updateConfig: t } = le.useContext(bt), n = (f = e.data) == null ? void 0 : f[0], { updateField: a } = le.useContext(cp);
  if (e.visualizationType !== "Sankey")
    return;
  const i = (v, x, A) => {
    let T = [];
    n != null && n.storyNodeText && (T = [...n == null ? void 0 : n.storyNodeText]), T[A][v] = x, t({
      ...e,
      sankey: {
        ...e.sankey,
        data: {
          ...e.sankey.data,
          storyNodeText: T
        }
      }
    });
  }, l = () => {
    const v = n;
    v.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), t({
      ...e,
      sankey: {
        ...e.sankey,
        data: [{ ...v }]
      }
    });
  }, c = (v) => {
    const x = n;
    x.storyNodeText.splice(v, 1), t({ ...e, sankey: { ...e.sankey, data: { ...x } } });
  };
  return /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, "Sankey Settings")), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement("p", null, "Node stories can provide additional details to support public health messaging. COVE can display a maximum of 3 node stories."), (n == null ? void 0 : n.storyNodeText) && (n == null ? void 0 : n.storyNodeText.map(({ StoryNode: v, segmentTextBefore: x, segmentTextAfter: A }, T) => /* @__PURE__ */ r.createElement("div", { key: T, style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" } }, /* @__PURE__ */ r.createElement("label", null, "Story Node Text", /* @__PURE__ */ r.createElement("input", { type: "text", value: v, fieldName: "StoryNode", label: "StoryNode", onChange: (M) => i("StoryNode", M.target.value, T) })), /* @__PURE__ */ r.createElement("label", null, "Story Text Before", /* @__PURE__ */ r.createElement("input", { type: "text", value: x, fieldName: "segmentTextBefore", label: "Segment Text Before", onChange: (M) => i("segmentTextBefore", M.target.value, T) })), /* @__PURE__ */ r.createElement("label", null, "Story Text After", /* @__PURE__ */ r.createElement("input", { type: "text", value: A, fieldName: "segmentTextAfter", label: "Segment Text After", onChange: (M) => i("segmentTextAfter", M.target.value, T) })), /* @__PURE__ */ r.createElement(bs, { onClick: (M) => c(T), className: "btn", style: { background: "tomato" } }, "Remove Story Node")))), ((u = n == null ? void 0 : n.storyNodeText) == null ? void 0 : u.length) < 3 && /* @__PURE__ */ r.createElement(
    "button",
    {
      type: "button",
      className: "btn full-width",
      onClick: (v) => {
        v.preventDefault(), l();
      }
    },
    "Add StoryNode"
  ), e.enableTooltips && ((y = (m = e.data) == null ? void 0 : m.tooltips) == null ? void 0 : y.length) > 0 && /* @__PURE__ */ r.createElement(ct, { value: e.enableTooltips, fieldName: "enableTooltips", label: "Enable Tooltips", updateField: a })));
};
const tw = (e) => {
  var m, y, v;
  const { updateConfig: t, config: n, unfilteredData: a, dimensions: i, isDraggingAnnotation: l } = le.useContext(bt), c = (x, A, T) => {
    var C;
    const M = (C = document.querySelector(".chart-container > div > svg")) == null ? void 0 : C.getBoundingClientRect(), E = [M.width, M.height], p = [...n == null ? void 0 : n.annotations];
    p[T][A] = x, p[T].savedDimensions = E, t({
      ...n,
      annotations: p
    });
  }, f = () => {
    var E, p, C;
    const x = (E = document.querySelector(".chart-container > div > svg")) == null ? void 0 : E.getBoundingClientRect(), A = [x.width, x.height], T = {
      text: "New Annotation",
      snapToNearestPoint: !1,
      fontSize: 16,
      bezier: 10,
      show: {
        desktop: !0,
        tablet: !0,
        mobile: !0
      },
      connectorType: "line",
      colors: {
        label: "black",
        connector: "black",
        marker: "black"
      },
      selected: !0,
      anchor: {
        vertical: !1,
        horizontal: !1
      },
      marker: "arrow",
      edit: {
        subject: !0,
        label: !0
      },
      seriesKey: "",
      x: 50,
      y: Number((A == null ? void 0 : A[1]) / 2),
      xKey: n.xAxis.type === "date" ? new Date((C = (p = n == null ? void 0 : n.data) == null ? void 0 : p[0]) == null ? void 0 : C[n.xAxis.dataKey]).getTime() : n.xAxis.type === "categorical" ? "1/15/2016" : "",
      yKey: "",
      dx: 20,
      dy: -20,
      opacity: "100",
      savedDimensions: A,
      connectionType: "line"
    }, M = Array.isArray(n.annotations) ? n.annotations : [];
    t({
      ...n,
      annotations: [...M, T]
    });
  }, u = (x) => {
    const A = n.annotations.filter((T, M) => M !== x);
    t({
      ...n,
      annotations: A
    });
  };
  return /* @__PURE__ */ r.createElement(Tu, { key: e.name }, /* @__PURE__ */ r.createElement(Tu.Section, { title: e.name, key: e.name }, /* @__PURE__ */ r.createElement("label", { key: "key-1" }, "Show Annotation Dropdown", /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "checkbox",
      checked: ((m = n == null ? void 0 : n.general) == null ? void 0 : m.showAnnotationDropdown) || !1,
      onChange: (x) => {
        t({
          ...n,
          general: {
            ...n.general,
            showAnnotationDropdown: x.target.checked
          }
        });
      }
    }
  )), n.general.showAnnotationDropdown && /* @__PURE__ */ r.createElement("label", { key: "key-2" }, "Annotation Dropdown Title:", /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      style: { marginBottom: "10px" },
      value: (y = n == null ? void 0 : n.general) == null ? void 0 : y.annotationDropdownText,
      onChange: (x) => {
        t({
          ...n,
          general: {
            ...n.general,
            annotationDropdownText: x.target.value
          }
        });
      }
    }
  )), (n == null ? void 0 : n.annotations) && (n == null ? void 0 : n.annotations.map((x, A) => {
    var T, M, E, p, C, _, w, R;
    return /* @__PURE__ */ r.createElement(Tu, { key: A }, /* @__PURE__ */ r.createElement(Tu.Section, { title: x.text ? x.text.substring(0, 15) + "..." : `Annotation ${A + 1}` }, /* @__PURE__ */ r.createElement("div", { className: "annotation-group" }, /* @__PURE__ */ r.createElement("label", null, "Annotation Text:", /* @__PURE__ */ r.createElement("textarea", { rows: 5, value: x.text, onChange: (P) => c(P.target.value, "text", A) })), /* @__PURE__ */ r.createElement("label", null, "Opacity", /* @__PURE__ */ r.createElement("br", null), /* @__PURE__ */ r.createElement(
      "input",
      {
        type: "range",
        onChange: (P) => {
          const z = vr.cloneDeep(n == null ? void 0 : n.annotations);
          z[A].opacity = P.target.value, t({
            ...n,
            annotations: z
          });
        },
        value: ((M = (T = n == null ? void 0 : n.annotations) == null ? void 0 : T[A]) == null ? void 0 : M.opacity) || "100"
      }
    )), /* @__PURE__ */ r.createElement("label", null, "Edit Subject", /* @__PURE__ */ r.createElement(
      "input",
      {
        type: "checkbox",
        checked: ((p = (E = n == null ? void 0 : n.annotations[A]) == null ? void 0 : E.edit) == null ? void 0 : p.subject) || !1,
        onChange: (P) => {
          const z = vr.cloneDeep(n == null ? void 0 : n.annotations);
          z[A].edit.subject = P.target.checked, t({
            ...n,
            annotations: z
          });
        }
      }
    )), /* @__PURE__ */ r.createElement("label", null, "Edit Label", /* @__PURE__ */ r.createElement(
      "input",
      {
        type: "checkbox",
        checked: ((_ = (C = n == null ? void 0 : n.annotations[A]) == null ? void 0 : C.edit) == null ? void 0 : _.label) || !1,
        onChange: (P) => {
          const z = vr.cloneDeep(n == null ? void 0 : n.annotations);
          z[A].edit.label = P.target.checked, t({
            ...n,
            annotations: z
          });
        }
      }
    )), /* @__PURE__ */ r.createElement("label", null, "Connection Type:", /* @__PURE__ */ r.createElement(
      "select",
      {
        key: "annotation-connection-type",
        onChange: (P) => {
          const z = vr.cloneDeep(n == null ? void 0 : n.annotations);
          z[A].connectionType = P.target.value, t({
            ...n,
            annotations: z
          });
        },
        value: (w = n == null ? void 0 : n.annotations[A]) == null ? void 0 : w.connectionType
      },
      /* @__PURE__ */ r.createElement("option", { key: "select", value: "select" }, "Select"),
      ["curve", "line", "elbow", "none"].map((P, z) => /* @__PURE__ */ r.createElement("option", { key: P, value: P }, P))
    )), x.connectionType === "curve" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("label", null, "Curve Control", /* @__PURE__ */ r.createElement(
      "input",
      {
        type: "range",
        min: "-20",
        max: "20",
        value: ((R = n == null ? void 0 : n.annotations[A]) == null ? void 0 : R.bezier) || 0,
        onChange: (P) => {
          const z = vr.cloneDeep(n == null ? void 0 : n.annotations);
          z[A].bezier = P.target.value, t({
            ...n,
            annotations: z
          });
        }
      }
    ))), /* @__PURE__ */ r.createElement("label", null, "Marker", /* @__PURE__ */ r.createElement(
      "select",
      {
        key: "annotation-marker",
        value: x.marker,
        onChange: (P) => {
          const z = vr.cloneDeep(n == null ? void 0 : n.annotations);
          z[A].marker = P.target.value, t({
            ...n,
            annotations: z
          });
        }
      },
      ["arrow", "circle"].map((P, z) => /* @__PURE__ */ r.createElement("option", { key: `col-${z}` }, P))
    )), /* @__PURE__ */ r.createElement(bs, { className: "warn btn-warn btn btn-remove delete", onClick: () => u(A) }, "Delete Annotation"))));
  })), ((v = n == null ? void 0 : n.annotations) == null ? void 0 : v.length) < 3 && /* @__PURE__ */ r.createElement(bs, { onClick: f, className: "mt-2" }, "Add Annotation")));
}, fa = {
  ForestPlot: Ok,
  Series: Xr,
  Regions: qk,
  General: Gk,
  BoxPlot: Zk,
  Visual: Jk,
  Sankey: ew,
  Annotate: tw
};
const nw = ({ config: e, updateConfig: t, data: n }) => {
  var E, p, C;
  const a = e.visualizationType === "Combo", i = ((E = e.runtime.lineSeriesKeys) == null ? void 0 : E.length) > 0, l = ((p = e.runtime.barSeriesKeys) == null ? void 0 : p.length) > 0, c = a && i, f = a && l, u = () => vr.uniq(vr.flatMap(n, vr.keys)), m = () => e.visualizationType === "Line" || c ? ["effect", "suppression"] : ["suppression"], y = {
    "Dashed Small": "- - -",
    "Dashed Medium": " ",
    "Dashed Large": " ",
    "Open Circles": "",
    "Filled Circles": ""
  }, v = (_) => {
    const w = Object.keys(y);
    return _ === "suppression" ? w.slice(0, -1) : w;
  }, x = () => {
    if (e.visualizationType === "Bar" || f)
      return Object.keys(Np);
  };
  let A = (_) => {
    let w = [];
    e.preliminaryData && (w = [...e.preliminaryData]), w.splice(_, 1), t({ ...e, preliminaryData: w });
  }, T = () => {
    const _ = e.visualizationType === "Line" ? "effect" : "suppression";
    let w = e.preliminaryData ? [...e.preliminaryData] : [];
    const R = {
      type: _,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: "",
      hideBarSymbol: !1,
      hideLineStyle: !1,
      circleSize: 6
    };
    w.push(R), t({ ...e, preliminaryData: w });
  }, M = (_, w, R) => {
    let P = [];
    e.preliminaryData && (P = [...e.preliminaryData]), P[R][_] = w, _ === "symbol" && (P[R].iconCode = Np[w]), _ === "style" && (P[R].lineCode = y[w]), t({ ...e, preliminaryData: P });
  };
  return /* @__PURE__ */ r.createElement(r.Fragment, null, e.preliminaryData && ((C = e.preliminaryData) == null ? void 0 : C.map(({ circleSize: _, column: w, displayLegend: R, displayTable: P, displayTooltip: z, label: q, seriesKey: V, style: G, symbol: ee, type: W, value: Q, hideBarSymbol: j, hideLineStyle: te }, se) => {
    var re, ae;
    return /* @__PURE__ */ r.createElement("div", { key: `preliminaryData-${se}`, className: "edit-block" }, /* @__PURE__ */ r.createElement("p", null, " ", W === "suppression" ? "Suppressed" : "Effect", " Data"), /* @__PURE__ */ r.createElement(
      "button",
      {
        type: "button",
        className: "remove-column",
        onClick: (K) => {
          K.preventDefault(), A(se);
        }
      },
      "Remove"
    ), /* @__PURE__ */ r.createElement(Pt, { value: W, initial: e.visualizationType == "Bar" ? "" : "Select", fieldName: "type", label: "Type", updateField: (K, U, X, H) => M(X, H, se), options: m() }), W === "suppression" ? /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
      Pt,
      {
        tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, ` If no Data Series" is selected, the symbol will be applied to "all" suppressed values indicated in the dataset. If you select a particular data series, there's no need to fill in suppression line style and suppression symbol below.`))),
        value: w,
        initial: "Select",
        fieldName: "column",
        label: "Add Data Series",
        updateField: (K, U, X, H) => M(X, H, se),
        options: (re = e.runtime) == null ? void 0 : re.seriesKeys
      }
    ), /* @__PURE__ */ r.createElement(Je, { value: Q, fieldName: "value", label: "Suppressed Data  Value", updateField: (K, U, X, H) => M(X, H, se) }), (c || e.visualizationType === "Line") && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
      Pt,
      {
        tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "The recommended approach for presenting data is to include a footnote indicating any data suppression."))),
        value: G,
        initial: "Select",
        fieldName: "style",
        label: "suppression line style",
        updateField: (K, U, X, H) => M(X, H, se),
        options: v(W)
      }
    ), /* @__PURE__ */ r.createElement(ct, { value: te, fieldName: "hideLineStyle", label: "Hide Suppressed line Style", updateField: (K, U, X, H) => M(X, H, se) })), (f || e.visualizationType === "Bar") && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
      Pt,
      {
        tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, 'The suggested method for presenting suppressed data is to use "double asterisks". If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'))),
        value: ee,
        initial: "Select",
        fieldName: "symbol",
        label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
        updateField: (K, U, X, H) => M(X, H, se),
        options: x()
      }
    ), /* @__PURE__ */ r.createElement(ct, { value: j, fieldName: "hideBarSymbol", label: "Hide Suppressed Bar Symbol  ", updateField: (K, U, X, H) => M(X, H, se) })), /* @__PURE__ */ r.createElement(
      Je,
      {
        tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "This label will display in the tooltip and legend."))),
        value: q || "Suppressed",
        fieldName: "label",
        label: "Suppressed Data Label",
        placeholder: "",
        updateField: (K, U, X, H) => M(X, H, se)
      }
    ), /* @__PURE__ */ r.createElement(
      ct,
      {
        tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Enabling this tooltip will provide a clearer indication of 'suppressed' or 'zero data' values, whichever is applicable. Deselecting 'Display In Tooltip' indicates that you do not want to display 'suppressed' or 'zero data' values in tooltips when hovering over them."))),
        value: z,
        fieldName: "displayTooltip",
        label: "Display in tooltips",
        updateField: (K, U, X, H) => M(X, H, se)
      }
    ), /* @__PURE__ */ r.createElement(
      ct,
      {
        tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.'))),
        value: R,
        fieldName: "displayLegend",
        label: "Display in legend",
        updateField: (K, U, X, H) => M(X, H, se)
      }
    ), /* @__PURE__ */ r.createElement(
      ct,
      {
        tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.'))),
        value: P,
        fieldName: "displayTable",
        label: "Display in table",
        updateField: (K, U, X, H) => M(X, H, se)
      }
    )) : /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(Pt, { value: V, initial: "Select", fieldName: "seriesKey", label: "ASSOCIATE TO SERIES", updateField: (K, U, X, H) => M(X, H, se), options: e.runtime.lineSeriesKeys ?? ((ae = e.runtime) == null ? void 0 : ae.seriesKeys) }), /* @__PURE__ */ r.createElement(Pt, { value: w, initial: "Select", fieldName: "column", label: "COLUMN WITH CONFIGURATION VALUE", updateField: (K, U, X, H) => M(X, H, se), options: u() }), /* @__PURE__ */ r.createElement(
      Je,
      {
        tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "If 'Filled Circles' is selected as the style, this field is optional, and the style 'Filled Circles' will apply to all points within the associated series data."))),
        value: Q,
        fieldName: "value",
        label: "VALUE TO TRIGGER",
        updateField: (K, U, X, H) => M(X, H, se)
      }
    ), /* @__PURE__ */ r.createElement(Pt, { value: G, initial: "Select", fieldName: "style", label: "Style", updateField: (K, U, X, H) => M(X, H, se), options: v(W) }), G.includes("Circles") && /* @__PURE__ */ r.createElement(Je, { className: "number-narrow", type: "number", value: _, fieldName: "circleSize", label: "circle size", updateField: (K, U, X, H) => M(X, H, se) }), G !== "Filled Circles" && /* @__PURE__ */ r.createElement(Je, { value: q, fieldName: "label", label: "Label", placeholder: "", updateField: (K, U, X, H) => M(X, H, se) })));
  })), /* @__PURE__ */ r.createElement("button", { type: "button", onClick: T, className: "btn full-width" }, e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line"));
}, rw = ({ config: e, updateConfig: t, display: n }) => {
  var m, y, v, x;
  const a = (m = e == null ? void 0 : e.yAxis) == null ? void 0 : m.maxValue, i = ((v = (y = e == null ? void 0 : e.yAxis) == null ? void 0 : y.categories) == null ? void 0 : v.reduce((A, T) => A + (parseFloat(T.height) || 0), 0)) || 0, l = (A) => {
    let T = [];
    e.yAxis.categories && (T = [...e.yAxis.categories]), T.splice(A, 1), t({ ...e, yAxis: { ...e.yAxis, categories: T } });
  }, c = () => {
    var E, p;
    const A = (p = (E = e.yAxis) == null ? void 0 : E.categories) == null ? void 0 : p.length, T = 0.4;
    return Ba("#ddd").darken(T * A).hex();
  }, f = () => {
    const A = e.yAxis.categories ? [...e.yAxis.categories] : [], T = {
      label: "Label " + Number(A.length + 1),
      height: "",
      color: c()
    };
    A.push(T), t({ ...e, yAxis: { ...e.yAxis, categories: A } });
  }, u = (A, T, M) => {
    let E = [];
    e.yAxis.categories && (E = [...e.yAxis.categories]), E[M][A] = T, t({ ...e, yAxis: { ...e.yAxis, categories: E } });
  };
  return n ? /* @__PURE__ */ r.createElement(r.Fragment, null, e.yAxis.type === "categorical" && ((x = e.yAxis.categories) == null ? void 0 : x.map(({ label: A, color: T, height: M }, E) => /* @__PURE__ */ r.createElement("div", { key: `preliminaryData-${E}`, className: "edit-block" }, /* @__PURE__ */ r.createElement("p", null, "Axis Category ", E + 1), /* @__PURE__ */ r.createElement(
    "button",
    {
      type: "button",
      className: "remove-column",
      onClick: (p) => {
        p.preventDefault(), l(E);
      }
    },
    "Remove"
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, " Category Height will be ignored for the last category. The last category will fill the rest of the axis height."))),
      type: "number",
      value: M,
      fieldName: "height",
      label: "Category Height",
      updateField: (p, C, _, w) => u(_, w, E)
    }
  ), Number(i) > Number(a) && e.yAxis.categories.length - 1 === E && /* @__PURE__ */ r.createElement("span", { style: { color: "red", display: "block", fontSize: "15px" } }, "Update Max value to show all categories"), /* @__PURE__ */ r.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ r.createElement(Je, { value: T, fieldName: "color", label: "Color", updateField: (p, C, _, w) => u(_, w, E) }), /* @__PURE__ */ r.createElement(Je, { value: A, fieldName: "label", label: "Label", updateField: (p, C, _, w) => u(_, w, E) }))))), /* @__PURE__ */ r.createElement("button", { type: "button", onClick: f, className: "btn full-width" }, "Add Axis Category")) : /* @__PURE__ */ r.createElement(r.Fragment, null);
}, aw = () => {
  var pn, sn, yn, Qt, gn, Vn, g, D, B, Z, Se, ve, De, Xe, ut, vt, pt, Mt, Dn;
  const {
    config: e,
    updateConfig: t,
    tableData: n,
    transformedData: a,
    loading: i,
    colorScale: l,
    colorPalettes: c,
    twoColorPalette: f,
    unfilteredData: u,
    excludedData: m,
    isDashboard: y,
    setParentConfig: v,
    missingRequiredSections: x,
    isDebug: A,
    setFilteredData: T,
    lineOptions: M,
    rawData: E,
    highlight: p,
    highlightReset: C,
    dimensions: _
  } = le.useContext(bt), { minValue: w, maxValue: R, existPositiveValue: P, isAllLine: z } = $c(e, u), q = { data: a, config: e }, { leftMax: V, rightMax: G } = Xy(q), {
    headerColors: ee,
    visSupportsTooltipLines: W,
    visSupportsNonSequentialPallete: Q,
    visSupportsSequentialPallete: j,
    visSupportsReverseColorPalette: te,
    visHasLabelOnData: se,
    visHasNumbersOnBars: re,
    visHasAnchors: ae,
    visHasBarBorders: K,
    visHasDataCutoff: U,
    visHasSelectableLegendValues: X,
    visCanAnimate: H,
    visHasLegend: Te,
    visHasLegendAxisAlign: be,
    visHasBrushChart: ce,
    visSupportsDateCategoryAxis: Re,
    visSupportsValueAxisMin: He,
    visSupportsValueAxisMax: Ge,
    visSupportsDateCategoryAxisLabel: Ne,
    visSupportsDateCategoryAxisLine: ye,
    visSupportsDateCategoryAxisTicks: Oe,
    visSupportsDateCategoryTickRotation: ue,
    visSupportsDateCategoryNumTicks: ie,
    visSupportsDateCategoryAxisPadding: Ce,
    visSupportsRegions: $e,
    visSupportsFilters: Ve,
    visSupportsPreliminaryData: Ee,
    visSupportsValueAxisGridLines: Ue,
    visSupportsValueAxisLine: ft,
    visSupportsValueAxisTicks: Qe,
    visSupportsValueAxisLabels: We,
    visSupportsBarSpace: Ie,
    visSupportsBarThickness: Me,
    visSupportsFootnotes: tt,
    visSupportsSuperTitle: Ze,
    visSupportsDataCutoff: et,
    visSupportsChartHeight: at,
    visSupportsLeftValueAxis: gt,
    visSupportsTooltipOpacity: Ot,
    visSupportsRankByValue: Kt,
    visSupportsResponsiveTicks: on,
    visSupportsDateCategoryHeight: Wt,
    visHasDataSuppression: Zt,
    visHasCategoricalAxis: zt,
    visSupportsDynamicSeries: fn
  } = _s();
  le.useEffect(() => {
    let pe = [];
    e.series && (pe = e.series.map((de) => ({
      ...de,
      type: e.visualizationType === "Combo" ? "Bar" : e.visualizationType ? e.visualizationType : "Bar",
      axis: "Left"
    }))), t({
      ...e,
      series: pe
    });
  }, [e.visualizationType]), le.useEffect(() => {
    e.visualizationType === "Scatter Plot" && t({
      ...e,
      xAxis: {
        ...e.xAxis,
        type: "continuous"
      }
    });
  }, []), le.useEffect(() => {
    e.visualizationType !== "Bar" && t({ ...e, tooltips: { ...e.tooltips, singleSeries: !1 } });
  }, [e.visualizationType]);
  const { hasRightAxis: Yt } = sp({ config: e, yMax: e.yAxis.size, data: e.data, updateConfig: t }), tn = (pe, de) => ({
    ...de
  }), kn = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, ot = (pe) => {
    pe.orientation === "horizontal" && (pe.labels = !1), pe.table.show === void 0 && (pe.table.show = !y), pe.visualizationType === "Combo" && (pe.orientation = "vertical"), Cn(pe.xAxis) && !pe.xAxis.padding && (pe.xAxis.padding = 6), pe.visualizationType === "Line" && (pe.visualizationSubType = "regular", pe.barStyle = "flat", pe.isLollipopChart = !1);
  }, _e = (pe, de, ge, Fe) => {
    if (A && console.log("#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue", pe, de, ge, Fe), pe === "boxplot" && de === "legend") {
      t({
        ...e,
        [pe]: {
          ...e[pe],
          [de]: {
            ...e.boxplot[de],
            [ge]: Fe
          }
        }
      });
      return;
    }
    if (pe === "boxplot" && de === "labels") {
      t({
        ...e,
        [pe]: {
          ...e[pe],
          [de]: {
            ...e.boxplot[de],
            [ge]: Fe
          }
        }
      });
      return;
    }
    const Nt = (rr) => rr === 0 ? !0 : !!rr;
    if (pe === "columns" && Nt(de) && Nt(ge)) {
      t({
        ...e,
        columns: {
          ...e.columns,
          [de]: {
            ...e.columns[de],
            [ge]: Fe
          }
        }
      });
      return;
    }
    if (pe === null && de === null) {
      Nt(ge) || console.error("fieldName is required");
      let rr = { ...e, [ge]: Fe };
      ot(rr), t(rr);
      return;
    }
    const bn = Array.isArray(e[pe]);
    let jn = bn ? [...e[pe], Fe] : { ...e[pe], [ge]: Fe };
    Nt(de) && (bn ? (jn = [...e[pe]], jn[de] = { ...jn[de], [ge]: Fe }) : typeof Fe == "string" ? jn[de] = Fe : Nt(ge) && (jn = { ...e[pe], [de]: { ...e[pe][de], [ge]: Fe } }));
    let Gn = { ...e, [pe]: jn };
    ot(Gn), t(Gn);
  }, [$t, Lt] = le.useState(!0), [nn, un] = le.useState(!1);
  if (i)
    return null;
  le.useEffect(() => {
    var pe;
    (pe = e.general) != null && pe.boxplot && (e.general.boxplot.firstQuartilePercentage || t({
      ...e,
      boxplot: {
        ...e.boxplot,
        firstQuartilePercentage: 25
      }
    }));
  }, [e]);
  const At = (pe) => {
    t({
      ...e,
      lollipopShape: pe
    });
  }, rn = (pe) => {
    let de = e.series ? [...e.series] : [], ge = Array.from(new Set(a.map((Nt) => Nt[pe]))), Fe = [];
    ge.forEach((Nt) => {
      Fe.push({ key: Nt });
    }), e.visualizationType === "Forecasting" ? de.push({ dataKey: pe, type: e.visualizationType, stages: Fe, stageColumn: pe, axis: "Left", tooltip: !0 }) : de.push({ dataKey: pe, type: e.visualizationType, axis: "Left", tooltip: !0 }), t({ ...e, series: de });
  }, ln = (pe) => {
    const de = e.series[0].dataKey, ge = a.sort((Nt, bn) => Nt[de] - bn[de]), Fe = pe === "asc" ? ge : ge.reverse();
    t({ ...e }, Fe);
  }, Ln = (pe) => {
    let de = [...e.exclusions.keys];
    de.push(pe);
    let ge = { ...e.exclusions, keys: de };
    t({ ...e, exclusions: ge });
  }, qt = (pe) => {
    let de = -1, ge = [...e.exclusions.keys];
    for (let Fe = 0; Fe < ge.length; Fe++)
      if (ge[Fe] === pe) {
        de = Fe;
        break;
      }
    if (de !== -1) {
      ge.splice(de, 1);
      let Fe = { ...e.exclusions, keys: ge }, Nt = { ...e, exclusions: Fe };
      ge.length === 0 && delete Nt.exclusions.keys, t(Nt);
    }
  }, mn = (pe = !0) => {
    let de = {};
    if (u.forEach((ge) => {
      Object.keys(ge).forEach((Fe) => de[Fe] = !0);
    }), pe) {
      const { lower: ge, upper: Fe } = e.confidenceKeys || {};
      Object.keys(de).forEach((Nt) => {
        (e.series && e.series.filter((bn) => bn.dataKey === Nt).length > 0 || e.confidenceKeys && Object.keys(e.confidenceKeys).includes(Nt) && (ge && Fe || ge || Fe) && Nt !== ge && Nt !== Fe) && delete de[Nt];
      });
    }
    return Object.keys(de);
  }, Hn = (pe) => {
    if (!pe)
      return [];
    const de = /* @__PURE__ */ new Set();
    for (let ge = 0; ge < pe.length; ge++)
      for (const [Fe] of Object.entries(pe[ge]))
        de.add(Fe);
    return Array.from(de);
  }, Pn = (pe, de = !1) => {
    let ge = [];
    return m.forEach((Fe) => {
      ge.push(Fe[pe]);
    }), de ? [...new Set(ge)] : ge;
  }, Vt = () => {
    Lt(!$t), t({
      ...e,
      showEditorPanel: !$t
    });
  }, wn = () => {
    let pe = JSON.parse(JSON.stringify(e));
    return x() === !1 && delete pe.newViz, delete pe.runtime, pe;
  };
  le.useEffect(() => {
    if (v) {
      const pe = wn();
      v(pe);
    }
  }, [e]), le.useEffect(() => {
    const pe = e.xAxis.anchors.length > 0 ? e.xAxis.anchors : [], de = e.yAxis.anchors.length > 0 ? e.yAxis.anchors : [];
    t({
      ...e,
      xAxis: {
        ...e.xAxis,
        anchors: de
      },
      yAxis: {
        ...e.yAxis,
        anchors: pe
      }
    });
  }, [e.orientation]), le.useEffect(() => {
    e.visualizationType === "Paired Bar" && t({
      ...e,
      orientation: "horizontal"
    });
  }, []), le.useEffect(() => {
    e.orientation === "horizontal" && t({
      ...e,
      lollipopShape: e.lollipopShape
    });
  }, [e.isLollipopChart, e.lollipopShape]), le.useEffect(() => {
    e.visualizationType === "Deviation Bar" && t({ ...e, orientation: "horizontal" });
  }, [e.visualizationType]);
  const tr = le.useCallback(() => {
    const pe = [...e.exclusions.keys];
    return /* @__PURE__ */ r.createElement("ul", { className: "series-list" }, pe.map((de, ge) => /* @__PURE__ */ r.createElement("li", { key: de }, /* @__PURE__ */ r.createElement("div", { className: "series-list__name", "data-title": de }, /* @__PURE__ */ r.createElement("div", { className: "series-list__name--text" }, de)), /* @__PURE__ */ r.createElement("button", { className: "series-list__remove", onClick: () => qt(de) }, ""))));
  }, [e]), nr = (pe, de) => {
    let ge = e.series, [Fe] = ge.splice(pe, 1);
    ge.splice(de, 0, Fe), t({ ...e, series: ge });
  };
  e.isLollipopChart && ((pn = e == null ? void 0 : e.series) == null ? void 0 : pn.length) > 1 && (e.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), e.visualizationType === "Paired Bar" && ((sn = e == null ? void 0 : e.series) == null ? void 0 : sn.length) !== 2 && (e.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), e.visualizationType === "Deviation Bar" && ((yn = e == null ? void 0 : e.series) == null ? void 0 : yn.length) !== 1 && (e.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), e.isLollipopChart && ((Qt = e == null ? void 0 : e.series) == null ? void 0 : Qt.length) === 0 && (e.runtime.editorErrorMessage = "Add a data series");
  const En = e.orientation === "horizontal" ? "xAxis" : "yAxis", [Tn, Mn] = le.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), Kn = () => {
    const pe = e[En].max, de = e[En].rightMax;
    let ge = "", Fe = "";
    if (e.visualizationType !== "Combo")
      switch (!0) {
        case (pe && parseFloat(pe) < parseFloat(R) && P):
          ge = "Max value must be more than " + R;
          break;
        case (pe && parseFloat(pe) < 0 && !P):
          ge = "Value must be more than or equal to 0";
          break;
        default:
          ge = "";
      }
    if (e.visualizationType === "Combo")
      switch (!0) {
        case (pe && parseFloat(pe) < V):
          ge = "Max value must be more than " + V;
          break;
        case (de && parseFloat(de) < G):
          Fe = "Max value must be more than " + G;
          break;
        case (pe && parseFloat(pe) < 0 && !P):
          ge = "Value must be more than or equal to 0";
          break;
        default:
          ge = "";
      }
    Mn((Nt) => ({ ...Nt, maxMsg: ge, rightMaxMessage: Fe }));
  }, zn = () => {
    const pe = parseFloat(e[En].min);
    let de = Number(w), ge = "";
    switch (!0) {
      case (e.useLogScale && ["Line", "Combo", "Bar"].includes(e.visualizationType) && pe < 0):
        ge = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((e.visualizationType === "Line" || e.visualizationType === "Spark Line") && pe > de):
        ge = "Value should not exceed " + w;
        break;
      case (e.visualizationType === "Combo" && z && pe > de):
        ge = "Value should not exceed " + w;
        break;
      case ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && !z) && de > 0 && pe > 0):
        ge = e.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (e.visualizationType === "Deviation Bar" && pe >= Math.min(de, e.xAxis.target)):
        ge = "Value must be less than " + Math.min(de, e.xAxis.target);
        break;
      case (e.visualizationType !== "Deviation Bar" && pe && de < 0 && pe > de):
        ge = "Value should not exceed " + w;
        break;
      default:
        ge = "";
    }
    Mn((Fe) => ({ ...Fe, minMsg: ge }));
  };
  le.useEffect(() => {
    zn(), Kn();
  }, [w, R, e]);
  const Rn = ((gn = e == null ? void 0 : e.dataKey) == null ? void 0 : gn.includes("http://")) || ((Vn = e == null ? void 0 : e.dataKey) == null ? void 0 : Vn.includes("https://")), Wn = () => {
    var pe, de;
    if (A !== void 0 && A && !((pe = e == null ? void 0 : e.xAxis) != null && pe.dataKey)) {
      let ge = mn(!1);
      if (ge.includes("Date"))
        return "Date";
      if (ge.includes("Race"))
        return "Race";
      if (ge.includes("Month"))
        return "Month";
    }
    return ((de = e == null ? void 0 : e.xAxis) == null ? void 0 : de.dataKey) || "";
  }, F = () => {
    if (A !== void 0 && A && mn(!1).length > 0) {
      let pe = mn(!1).filter((de) => de !== Wn());
      if (pe.length > 0)
        return pe[0];
    }
    return "";
  };
  if (A && !e.xAxis.dataKey && (e.xAxis.dataKey = Wn()), A && ((g = e == null ? void 0 : e.series) == null ? void 0 : g.length) === 0) {
    let pe = F();
    pe !== "" && rn(pe), A && console.log("### COVE DEBUG: Chart: Setting default datacol=", pe);
  }
  const Ae = ["Bump Chart", "Area Chart", "Combo", "Line", "Bar", "Forecasting", "Scatter Plot", "Paired Bar", "Deviation Bar"], ze = [
    /* @__PURE__ */ r.createElement("option", { value: "", key: "Select Option" }, "- Select Option -")
  ];
  if (e.data && e.series) {
    Object.keys(((D = e.data) == null ? void 0 : D[0]) || []).map((de) => {
      const ge = e == null ? void 0 : e.series.some((Fe) => Fe.dataKey === de);
      if (de !== e.xAxis.dataKey && !ge)
        return ze.push(
          /* @__PURE__ */ r.createElement("option", { value: de, key: de }, de)
        );
    });
    let pe = {};
    e.data.forEach((de) => {
      Object.keys(de).forEach((ge) => {
        pe[ge] = pe[ge] || [];
        const Fe = typeof de[ge] == "number" ? de[ge].toString() : de[ge];
        pe[ge].indexOf(Fe) === -1 && pe[ge].push(Fe);
      });
    });
  }
  if (!e.data && a) {
    if (!a[0])
      return;
    Object.keys(a[0]).map((de) => {
      const ge = a.some((Fe) => Fe.dataKey === de);
      if (de !== e.xAxis.dataKey && !ge)
        return ze.push(
          /* @__PURE__ */ r.createElement("option", { value: de, key: de }, de)
        );
    });
    let pe = {};
    a.forEach((de) => {
      Object.keys(de).forEach((ge) => {
        pe[ge] = pe[ge] || [];
        const Fe = typeof de[ge] == "number" ? de[ge].toString() : de[ge];
        pe[ge].indexOf(Fe) === -1 && pe[ge].push(Fe);
      });
    });
  }
  const xe = (pe) => {
    const de = vr.cloneDeep(e.columns);
    delete de[pe], t({
      ...e,
      columns: de
    });
  }, lt = async (pe, de, ge) => {
    switch (de) {
      case "name":
        t({
          ...e,
          columns: {
            ...e.columns,
            [pe]: {
              ...e.columns[pe],
              [de]: ge
            }
          }
        });
        break;
      default:
        t({
          ...e,
          columns: {
            ...e.columns,
            [pe]: {
              ...e.columns[pe],
              [de]: ge
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: nt,
    highlightedSeriesValues: mt,
    handleUpdateHighlightedBar: ht,
    handleAddNewHighlightedBar: je,
    handleRemoveHighlightedBar: yt,
    handleUpdateHighlightedBarColor: Tt,
    handleHighlightedBarLegendLabel: Rt,
    handleUpdateHighlightedBorderWidth: jt
  } = _c(e, t), wt = e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1, kt = () => {
    const pe = a.map((de) => de[e.legend.colorCode]);
    return wt ? pe : mn(!1).filter((de) => de !== e.xAxis.dataKey);
  }, Ft = (pe) => {
    t({ ...e, legend: { ...e.legend, seriesHighlight: pe } });
  }, Ut = (pe, de, ge) => {
    var bn;
    const Fe = { ...e[pe], [de]: ge }, Nt = { ...e, [pe]: Fe };
    ge === "highlight" && ((bn = e.legend.seriesHighlight) != null && bn.length) && (Nt.legend.seriesHighlight.length = 0), t(Nt);
  }, Et = (pe, de, ge) => {
    const Fe = { ...e.xAxis[pe] };
    Fe[de] = ge;
    const Nt = { ...e, xAxis: { ...e.xAxis, [pe]: Fe } };
    t(Nt);
  }, xn = {
    addNewExclusion: Ln,
    data: a,
    editColumn: lt,
    getColumns: mn,
    getDataValueOptions: Hn,
    getDataValues: Pn,
    getItemStyle: tn,
    handleSeriesChange: nr,
    handleAddNewHighlightedBar: je,
    setCategoryAxis: Wn,
    sortSeries: ln,
    updateField: _e,
    warningMsg: Tn,
    highlightedBarValues: nt,
    handleHighlightedBarLegendLabel: Rt,
    handleUpdateHighlightedBar: ht,
    handleRemoveHighlightedBar: yt,
    isPaletteReversed: e.isPaletteReversed,
    highlightedSeriesValues: mt,
    handleUpdateHighlightedBorderWidth: jt,
    handleUpdateHighlightedBarColor: Tt,
    setLollipopShape: At
  };
  return /* @__PURE__ */ r.createElement(cp.Provider, { value: xn }, /* @__PURE__ */ r.createElement($r, { component: "EditorPanel" }, /* @__PURE__ */ r.createElement(of.Sidebar, { displayPanel: $t, isDashboard: y, title: "Configure Chart", onBackClick: Vt }, /* @__PURE__ */ r.createElement(_i, { allowZeroExpanded: !0 }, /* @__PURE__ */ r.createElement(fa.General, { name: "General" }), /* @__PURE__ */ r.createElement(fa.ForestPlot, { name: "Forest Plot Settings" }), /* @__PURE__ */ r.createElement(fa.Sankey, { name: "Sankey" }), e.visualizationType !== "Pie" && e.visualizationType !== "Forest Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, "Data Series ", (!e.series || e.series.length === 0 || e.visualizationType === "Paired Bar" && e.series.length < 2) && !e.dynamicSeries && /* @__PURE__ */ r.createElement(Xu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ r.createElement(Fn, null, fn() && /* @__PURE__ */ r.createElement(ct, { value: e.dynamicSeries, fieldName: "dynamicSeries", label: "Dynamically generate series", updateField: _e }), (!fn() || !e.dynamicSeries) && /* @__PURE__ */ r.createElement(r.Fragment, null, (!e.series || e.series.length === 0) && !e.dynamicSeries && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ r.createElement("p", { className: "warning" }, "At least one series is required"), (!e.series || e.series.length === 0 || e.series.length < 2) && e.visualizationType === "Paired Bar" && /* @__PURE__ */ r.createElement("p", { className: "warning" }, "Select two data series for paired bar chart (e.g., Male and Female)."), /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
    Pt,
    {
      fieldName: "visualizationType",
      label: "Add Data Series",
      initial: "Select",
      onChange: (pe) => {
        pe.target.value !== "" && pe.target.value !== "Select" && rn(pe.target.value), pe.target.value = "";
      },
      options: mn()
    }
  ), e.series && e.series.length !== 0 && /* @__PURE__ */ r.createElement(fa.Series.Wrapper, { getColumns: mn }, /* @__PURE__ */ r.createElement("fieldset", null, /* @__PURE__ */ r.createElement("legend", { className: "edit-label float-left" }, "Displaying"), /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "A data series is a set of related data points plotted in a chart and typically represented in the chart legend.")))), /* @__PURE__ */ r.createElement(tg, { onDragEnd: ({ source: pe, destination: de }) => nr(pe.index, de.index) }, /* @__PURE__ */ r.createElement(ng, { droppableId: "filter_order" }, (pe) => /* @__PURE__ */ r.createElement("ul", { ...pe.droppableProps, className: "series-list", ref: pe.innerRef }, /* @__PURE__ */ r.createElement(fa.Series.List, { series: e.series, getItemStyle: tn, sortableItemStyles: kn, chartsWithOptions: Ae }), pe.placeholder))))), e.series && e.series.length <= 1 && e.visualizationType === "Bar" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("span", { className: "divider-heading" }, "Confidence Keys"), /* @__PURE__ */ r.createElement(Pt, { value: e.confidenceKeys.upper || "", section: "confidenceKeys", fieldName: "upper", label: "Upper", updateField: _e, initial: "Select", options: mn() }), /* @__PURE__ */ r.createElement(Pt, { value: e.confidenceKeys.lower || "", section: "confidenceKeys", fieldName: "lower", label: "Lower", updateField: _e, initial: "Select", options: mn() })), Kt() && e.series && e.series.length === 1 && /* @__PURE__ */ r.createElement(Pt, { fieldName: "visualizationType", label: "Rank by Value", initial: "Select", onChange: (pe) => ln(pe.target.value), options: ["asc", "desc"] }), Ee() && /* @__PURE__ */ r.createElement(nw, { config: e, updateConfig: t, data: a })))), /* @__PURE__ */ r.createElement(fa.BoxPlot, { name: "Measures" }), gt() && /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, e.visualizationType === "Pie" ? "Data Format" : e.orientation === "vertical" ? "Left Value Axis" : "Value Axis", e.visualizationType === "Pie" && !e.yAxis.dataKey && /* @__PURE__ */ r.createElement(Xu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ r.createElement(Fn, null, e.visualizationType === "Pie" && /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: e.yAxis.dataKey || "",
      section: "yAxis",
      fieldName: "dataKey",
      label: "Data Column",
      initial: "Select",
      required: !0,
      updateField: _e,
      options: mn(!1),
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Select the source data to be visually represented.")))
    }
  ), e.visualizationType !== "Pie" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label" }, "Axis Type", /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, "Select 'Numeric (Linear Scale)' for uniform scaling, 'Numeric (Logarithmic Scale)' for exponential data, or 'Categorical' for discrete categories."))), /* @__PURE__ */ r.createElement(
    "select",
    {
      value: e.yAxis.type,
      onChange: (pe) => t({
        ...e,
        yAxis: {
          ...e.yAxis,
          type: pe.target.value
        }
      })
    },
    /* @__PURE__ */ r.createElement("option", { value: "linear" }, "Numeric (Linear Scale)"),
    e.visualizationSubType !== "stacked" && /* @__PURE__ */ r.createElement("option", { value: "logarithmic" }, "Numeric (Logarithmic Scale)"),
    e.orientation !== "horizontal" && /* @__PURE__ */ r.createElement("option", { value: "categorical" }, "Categorical")
  )), /* @__PURE__ */ r.createElement(rw, { config: e, updateConfig: t, data: a, display: zt() }), /* @__PURE__ */ r.createElement(Je, { display: !zt(), value: e.yAxis.label, section: "yAxis", fieldName: "label", label: "Label ", updateField: _e }), e.runtime.seriesKeys && e.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(e.visualizationType) && /* @__PURE__ */ r.createElement(ct, { value: e.isLegendValue, fieldName: "isLegendValue", label: "Use Legend Value in Hover", updateField: _e }), /* @__PURE__ */ r.createElement(
    Je,
    {
      display: !zt(),
      value: e.yAxis.numTicks,
      placeholder: "Auto",
      type: "number",
      section: "yAxis",
      fieldName: "numTicks",
      label: "Number of ticks",
      className: "number-narrow",
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used."))),
      updateField: _e
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.yAxis.size,
      type: "number",
      section: "yAxis",
      fieldName: "size",
      label: e.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, `Increase the size if elements in the ${e.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.`)))
    }
  ), /* @__PURE__ */ r.createElement(Je, { display: !zt(), value: e.yAxis.labelOffset, section: "yAxis", fieldName: "labelOffset", label: "Label offset", type: "number", className: "number-narrow", updateField: _e }), e.orientation === "horizontal" && /* @__PURE__ */ r.createElement(ct, { value: e.isResponsiveTicks, fieldName: "isResponsiveTicks", label: "Use Responsive Ticks", updateField: _e }), (e.orientation === "vertical" || !e.isResponsiveTicks) && /* @__PURE__ */ r.createElement(Je, { display: !zt(), value: e.yAxis.tickRotation || 0, type: "number", min: 0, section: "yAxis", fieldName: "tickRotation", label: "Tick rotation (Degrees)", className: "number-narrow", updateField: _e }), e.isResponsiveTicks && e.orientation === "horizontal" && /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.xAxis.maxTickRotation,
      type: "number",
      min: 0,
      section: "xAxis",
      fieldName: "maxTickRotation",
      label: "Max Tick Rotation",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
    }
  ), Ue() && /* @__PURE__ */ r.createElement(ct, { value: e.yAxis.gridLines, section: "yAxis", fieldName: "gridLines", label: "Show Gridlines", updateField: _e }), /* @__PURE__ */ r.createElement(ct, { value: e.yAxis.enablePadding, section: "yAxis", fieldName: "enablePadding", label: "Add Padding to Value Axis Scale", updateField: _e }), e.yAxis.enablePadding && /* @__PURE__ */ r.createElement(Je, { type: "number", section: "yAxis", fieldName: "scalePadding", label: "Padding Percentage", className: "number-narrow", updateField: _e, value: e.yAxis.scalePadding })), /* @__PURE__ */ r.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ r.createElement(
    ct,
    {
      value: e.dataFormat.commas,
      section: "dataFormat",
      fieldName: "commas",
      label: "Add commas",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Selecting this option will add commas to the left value axis, tooltip hover, and data table.")))
    }
  ), /* @__PURE__ */ r.createElement(
    ct,
    {
      display: !zt(),
      value: e.dataFormat.abbreviated,
      section: "dataFormat",
      fieldName: "abbreviated",
      label: "Abbreviate Axis Values",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
    }
  ), /* @__PURE__ */ r.createElement(Je, { value: e.dataFormat.roundTo ? e.dataFormat.roundTo : 0, type: "number", section: "dataFormat", fieldName: "roundTo", label: "Round to decimal point", className: "number-narrow", updateField: _e, min: 0 }), /* @__PURE__ */ r.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.dataFormat.prefix,
      section: "dataFormat",
      fieldName: "prefix",
      label: "Prefix",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ r.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ r.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.dataFormat.suffix,
      section: "dataFormat",
      fieldName: "suffix",
      label: "Suffix",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ r.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ r.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
    }
  )), e.orientation === "horizontal" ? (
    // horizontal - x is vertical y is horizontal
    /* @__PURE__ */ r.createElement(r.Fragment, null, ft() && /* @__PURE__ */ r.createElement(ct, { value: e.xAxis.hideAxis, section: "xAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: _e }), We() && /* @__PURE__ */ r.createElement(ct, { value: e.xAxis.hideLabel, section: "xAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: _e }), Qe() && /* @__PURE__ */ r.createElement(ct, { value: e.xAxis.hideTicks, section: "xAxis", fieldName: "hideTicks", label: "Hide Ticks", updateField: _e }), Ge() && /* @__PURE__ */ r.createElement(Je, { value: e.xAxis.max, section: "xAxis", fieldName: "max", label: "max value", type: "number", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ r.createElement("span", { style: { color: "red", display: "block" } }, Tn.maxMsg), He() && /* @__PURE__ */ r.createElement(Je, { value: e.xAxis.min, section: "xAxis", fieldName: "min", type: "number", label: "min value", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ r.createElement("span", { style: { color: "red", display: "block" } }, Tn.minMsg), e.visualizationType === "Deviation Bar" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(Je, { value: e.xAxis.target, section: "xAxis", fieldName: "target", type: "number", label: "Deviation point", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ r.createElement(Je, { value: e.xAxis.targetLabel || "Target", section: "xAxis", fieldName: "targetLabel", type: "text", label: "Deviation point Label", updateField: _e }), /* @__PURE__ */ r.createElement(ct, { value: e.xAxis.showTargetLabel, section: "xAxis", fieldName: "showTargetLabel", label: "Show Deviation point label", updateField: _e })))
  ) : e.visualizationType !== "Pie" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(ct, { display: !zt(), value: e.yAxis.hideAxis, section: "yAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: _e }), /* @__PURE__ */ r.createElement(ct, { display: !zt(), value: e.yAxis.hideLabel, section: "yAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: _e }), /* @__PURE__ */ r.createElement(ct, { display: !zt(), value: e.yAxis.hideTicks, section: "yAxis", fieldName: "hideTicks", label: "Hide Ticks", updateField: _e }), /* @__PURE__ */ r.createElement(Je, { value: e.yAxis.max, section: "yAxis", fieldName: "max", type: "number", label: "left axis max value", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ r.createElement("span", { style: { color: "red", display: "block" } }, Tn.maxMsg), /* @__PURE__ */ r.createElement(Je, { value: e.yAxis.min, section: "yAxis", fieldName: "min", type: "number", label: "left axis min value", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ r.createElement("span", { style: { color: "red", display: "block" } }, Tn.minMsg)), ae() && e.orientation !== "horizontal" && /* @__PURE__ */ r.createElement("div", { className: "edit-block" }, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ r.createElement(_i, { allowZeroExpanded: !0 }, (Z = (B = e.yAxis) == null ? void 0 : B.anchors) == null ? void 0 : Z.map((pe, de) => /* @__PURE__ */ r.createElement(Nn, { className: "series-item series-item--chart", key: `yaxis-anchors-2-${de}` }, /* @__PURE__ */ r.createElement(_n, { className: "series-item__title" }, /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(On, { className: "accordion__button accordion__button" }, "Anchor ", de + 1, /* @__PURE__ */ r.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (ge) => {
        ge.preventDefault();
        const Fe = [...e.yAxis.anchors];
        Fe.splice(de, 1), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Fe
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", null, "Anchor Value"), /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[de].value ? e.yAxis.anchors[de].value : "",
      onChange: (ge) => {
        ge.preventDefault();
        const Fe = [...e.yAxis.anchors];
        Fe[de].value = ge.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Fe
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", null, "Anchor Color"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[de].color ? e.yAxis.anchors[de].color : "",
      onChange: (ge) => {
        ge.preventDefault();
        const Fe = [...e.yAxis.anchors];
        Fe[de].color = ge.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Fe
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ r.createElement(
    "select",
    {
      value: e.yAxis.anchors[de].lineStyle || "",
      onChange: (ge) => {
        const Fe = [...e.yAxis.anchors];
        Fe[de].lineStyle = ge.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Fe
          }
        });
      }
    },
    /* @__PURE__ */ r.createElement("option", null, "Select"),
    M.map((ge) => /* @__PURE__ */ r.createElement("option", { key: ge.key }, ge.value))
  )))))), /* @__PURE__ */ r.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (pe) => {
        pe.preventDefault();
        const de = [...e.yAxis.anchors];
        de.push({}), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: de
          }
        });
      }
    },
    "Add Anchor"
  )), ae() && e.orientation === "horizontal" && /* @__PURE__ */ r.createElement("div", { className: "edit-block" }, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ r.createElement(_i, { allowZeroExpanded: !0 }, (ve = (Se = e.xAxis) == null ? void 0 : Se.anchors) == null ? void 0 : ve.map((pe, de) => /* @__PURE__ */ r.createElement(Nn, { className: "series-item series-item--chart", key: `xaxis-anchors-${de}` }, /* @__PURE__ */ r.createElement(_n, { className: "series-item__title" }, /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(On, { className: "accordion__button accordion__button" }, "Anchor ", de + 1, /* @__PURE__ */ r.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (ge) => {
        ge.preventDefault();
        const Fe = [...e.xAxis.anchors];
        Fe.splice(de, 1), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Fe
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", null, "Anchor Value"), /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[de].value ? e.xAxis.anchors[de].value : "",
      onChange: (ge) => {
        ge.preventDefault();
        const Fe = [...e.xAxis.anchors];
        Fe[de].value = ge.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Fe
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", null, "Anchor Color"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[de].color ? e.xAxis.anchors[de].color : "",
      onChange: (ge) => {
        ge.preventDefault();
        const Fe = [...e.xAxis.anchors];
        Fe[de].color = ge.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Fe
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ r.createElement(
    "select",
    {
      value: e.xAxis.anchors[de].lineStyle || "",
      onChange: (ge) => {
        const Fe = [...e.xAxis.anchors];
        Fe[de].lineStyle = ge.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Fe
          }
        });
      }
    },
    /* @__PURE__ */ r.createElement("option", null, "Select"),
    M.map((ge) => /* @__PURE__ */ r.createElement("option", { key: ge.key }, ge.value))
  )))))), /* @__PURE__ */ r.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (pe) => {
        pe.preventDefault();
        const de = [...e.xAxis.anchors];
        de.push({}), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: de
          }
        });
      }
    },
    "Add Anchor"
  )))), Yt && /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, "Right Value Axis")), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement(Je, { value: e.yAxis.rightLabel, section: "yAxis", fieldName: "rightLabel", label: "Label", updateField: _e }), /* @__PURE__ */ r.createElement(Je, { value: e.yAxis.rightNumTicks, placeholder: "Auto", type: "number", section: "yAxis", fieldName: "rightNumTicks", label: "Number of ticks", className: "number-narrow", updateField: _e }), /* @__PURE__ */ r.createElement(Je, { value: e.yAxis.rightAxisSize, type: "number", section: "yAxis", fieldName: "rightAxisSize", label: "Size (Width)", className: "number-narrow", updateField: _e }), /* @__PURE__ */ r.createElement(Je, { value: e.yAxis.rightLabelOffsetSize, type: "number", section: "yAxis", fieldName: "rightLabelOffsetSize", label: "Label Offset", className: "number-narrow", updateField: _e }), /* @__PURE__ */ r.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ r.createElement(ct, { value: e.dataFormat.rightCommas, section: "dataFormat", fieldName: "rightCommas", label: "Add commas", updateField: _e }), /* @__PURE__ */ r.createElement(Je, { value: e.dataFormat.rightRoundTo, type: "number", section: "dataFormat", fieldName: "rightRoundTo", label: "Round to decimal point", className: "number-narrow", updateField: _e, min: 0 }), /* @__PURE__ */ r.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.dataFormat.rightPrefix,
      section: "dataFormat",
      fieldName: "rightPrefix",
      label: "Prefix",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ r.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ r.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.dataFormat.rightSuffix,
      section: "dataFormat",
      fieldName: "rightSuffix",
      label: "Suffix",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ r.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ r.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
    }
  )), /* @__PURE__ */ r.createElement(ct, { value: e.yAxis.rightHideAxis, section: "yAxis", fieldName: "rightHideAxis", label: "Hide Axis", updateField: _e }), /* @__PURE__ */ r.createElement(ct, { value: e.yAxis.rightHideLabel, section: "yAxis", fieldName: "rightHideLabel", label: "Hide Tick Labels", updateField: _e }), /* @__PURE__ */ r.createElement(ct, { value: e.yAxis.rightHideTicks, section: "yAxis", fieldName: "rightHideTicks", label: "Hide Ticks", updateField: _e }), /* @__PURE__ */ r.createElement(Je, { value: e.yAxis.max, section: "yAxis", fieldName: "rightMax", type: "number", label: "right axis max value", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ r.createElement("span", { style: { color: "red", display: "block" } }, Tn.rightMaxMessage), /* @__PURE__ */ r.createElement(Je, { value: e.yAxis.min, section: "yAxis", fieldName: "rightMin", type: "number", label: "right axis min value", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ r.createElement("span", { style: { color: "red", display: "block" } }, Tn.minMsg))), Re() && /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, e.visualizationType === "Pie" ? "Segments" : "Date/Category Axis", !e.xAxis.dataKey && /* @__PURE__ */ r.createElement(Xu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ r.createElement(Fn, null, e.visualizationType !== "Pie" && /* @__PURE__ */ r.createElement(r.Fragment, null, e.visualizationType !== "Forest Plot" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label" }, "Data Scaling Type", /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, "Linear scales are employed for quantitative data, while time scales are used for time-series data."))), /* @__PURE__ */ r.createElement(
    "select",
    {
      value: e.xAxis.type,
      onChange: (pe) => t({
        ...e,
        xAxis: {
          ...e.xAxis,
          type: pe.target.value
        }
      })
    },
    e.visualizationType !== "Bump Chart" && /* @__PURE__ */ r.createElement("option", { value: "categorical" }, "Categorical (Linear Scale)"),
    e.visualizationType !== "Bump Chart" && /* @__PURE__ */ r.createElement("option", { value: "date" }, "Date (Linear Scale)"),
    /* @__PURE__ */ r.createElement("option", { value: "date-time" }, "Date (Date Time Scale)"),
    e.visualizationType === "Scatter Plot" && /* @__PURE__ */ r.createElement("option", { value: "continuous" }, "Continuous")
  )), /* @__PURE__ */ r.createElement(ct, { value: e.xAxis.manual, section: "xAxis", fieldName: "manual", label: "Manual Ticks", updateField: _e }), Ce() && /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.xAxis.padding,
      type: "number",
      min: 0,
      section: "xAxis",
      fieldName: "padding",
      label: "Padding (Percent)",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified.")))
    }
  )), /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: e.xAxis.dataKey || Wn() || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Data Key",
      initial: "Select",
      required: !0,
      updateField: _e,
      options: mn(!1),
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  )), e.visualizationType === "Pie" && /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: e.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Segment Labels",
      initial: "Select",
      required: !0,
      updateField: _e,
      options: mn(!1),
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."')))
    }
  ), e.visualizationType !== "Pie" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(Je, { value: e.xAxis.label, section: "xAxis", fieldName: "label", label: "Label", updateField: _e }), e.xAxis.type === "continuous" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.dataFormat.bottomPrefix,
      section: "dataFormat",
      fieldName: "bottomPrefix",
      label: "Prefix",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.dataFormat.bottomSuffix,
      section: "dataFormat",
      fieldName: "bottomSuffix",
      label: "Suffix",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
    }
  ), /* @__PURE__ */ r.createElement(
    ct,
    {
      value: e.dataFormat.bottomAbbreviated,
      section: "dataFormat",
      fieldName: "bottomAbbreviated",
      label: "Abbreviate Axis Values",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
    }
  )), Cn(e.xAxis) && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" } }, "Format how charts should parse and display your dates using", " ", /* @__PURE__ */ r.createElement("a", { href: "https://github.com/d3/d3-time-format#locale_format", target: "_blank", rel: "noreferrer" }, "these guidelines"), "."), /* @__PURE__ */ r.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed. "))),
      value: e.xAxis.dateParseFormat,
      section: "xAxis",
      fieldName: "dateParseFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "Date Parse Format",
      updateField: _e
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, " Adjusts the date display format on the axis for clear, visual date representation."))),
      value: e.xAxis.dateDisplayFormat,
      section: "xAxis",
      fieldName: "dateDisplayFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "AXIS DATE DISPLAY FORMAT",
      updateField: _e
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format. "))),
      value: e.table.dateDisplayFormat,
      section: "table",
      fieldName: "dateDisplayFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "DATA TABLE DATE DISPLAY FORMAT",
      updateField: _e
    }
  ), /* @__PURE__ */ r.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format. "))),
      value: e.tooltips.dateDisplayFormat,
      section: "tooltips",
      fieldName: "dateDisplayFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "HOVER DATE DISPLAY FORMAT",
      updateField: _e
    }
  )), /* @__PURE__ */ r.createElement(
    ct,
    {
      value: e.exclusions.active,
      section: "exclusions",
      fieldName: "active",
      label: e.xAxis.type === "date" ? "Limit by start and/or end dates" : "Exclude one or more values",
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "When this option is checked, you can select source-file values for exclusion from the date/category axis. "))),
      updateField: _e
    }
  ), ce() && /* @__PURE__ */ r.createElement(
    ct,
    {
      value: (De = e.brush) == null ? void 0 : De.active,
      section: "brush",
      fieldName: "active",
      label: "Brush Slider ",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Use the brush slider to narrow down your data view to specific values along the axis. This tool is useful for examining detailed data segments within the larger dataset. ")))
    }
  ), e.exclusions.active && /* @__PURE__ */ r.createElement(r.Fragment, null, e.xAxis.type === "categorical" && /* @__PURE__ */ r.createElement(r.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("fieldset", null, /* @__PURE__ */ r.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ r.createElement(tr, null)), /* @__PURE__ */ r.createElement(
    Pt,
    {
      fieldName: "visualizationType",
      label: "Add Exclusion",
      initial: "Select",
      onChange: (pe) => {
        pe.target.value !== "" && pe.target.value !== "Select" && Ln(pe.target.value), pe.target.value = "";
      },
      options: Pn(e.xAxis.dataKey, !0)
    }
  )), e.xAxis.type === "date" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(Je, { type: "date", section: "exclusions", fieldName: "dateStart", label: "Start Date", updateField: _e, value: e.exclusions.dateStart || "" }), /* @__PURE__ */ r.createElement(Je, { type: "date", section: "exclusions", fieldName: "dateEnd", label: "End Date", updateField: _e, value: e.exclusions.dateEnd || "" }))), ie() && e.xAxis.type !== "date-time" && e.xAxis.manual && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.xAxis.manualStep,
      placeholder: "Auto",
      type: "number",
      min: 1,
      section: "xAxis",
      fieldName: "manualStep",
      label: "Step count",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc.")))
    }
  ), /* @__PURE__ */ r.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("button", { onClick: () => un(!nn), className: "edit-label" }, "Step Count: viewport overrides ", /* @__PURE__ */ r.createElement("span", { style: { transform: `rotate(${nn ? "90deg" : "0deg"})` } }, ">"))), nn && /* @__PURE__ */ r.createElement("div", { className: "edit-block" }, Object.keys(fp).map((pe) => /* @__PURE__ */ r.createElement(
    Je,
    {
      key: `viewport-step-count-input-${pe}`,
      value: e.xAxis.viewportStepCount ? e.xAxis.viewportStepCount[pe] : void 0,
      placeholder: "Auto",
      type: "number",
      label: pe,
      className: "number-narrow",
      updateField: (de, ge, Fe, Nt) => Et("viewportStepCount", pe, Nt)
    }
  ))))), ie() && (e.xAxis.type === "date-time" || !e.xAxis.manual) && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.xAxis.numTicks,
      placeholder: "Auto",
      type: "number",
      min: 1,
      section: "xAxis",
      fieldName: "numTicks",
      label: "Number of ticks",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.')))
    }
  ), /* @__PURE__ */ r.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("button", { onClick: () => un(!nn), className: "edit-label" }, "Number of ticks: viewport overrides ", /* @__PURE__ */ r.createElement("span", { style: { transform: `rotate(${nn ? "90deg" : "0deg"})` } }, ">"))), nn && /* @__PURE__ */ r.createElement("div", { className: "edit-block" }, Object.keys(fp).map((pe) => /* @__PURE__ */ r.createElement(
    Je,
    {
      key: `viewport-num-ticks-input-${pe}`,
      value: e.xAxis.viewportNumTicks ? e.xAxis.viewportNumTicks[pe] : void 0,
      placeholder: "Auto",
      type: "number",
      label: pe,
      className: "number-narrow",
      updateField: (de, ge, Fe, Nt) => Et("viewportNumTicks", pe, Nt)
    }
  ))))), Wt() && /* @__PURE__ */ r.createElement(Je, { value: e.xAxis.size, type: "number", min: 0, section: "xAxis", fieldName: "size", label: e.orientation === "horizontal" ? "Size (Width)" : "Size (Height)", className: "number-narrow", updateField: _e }), /* @__PURE__ */ r.createElement(Je, { value: e.xAxis.labelOffset, section: "xAxis", fieldName: "labelOffset", label: "Label offset", type: "number", className: "number-narrow", updateField: _e }), (e.xAxis.type === "continuous" || e.forestPlot.type === "Logarithmic") && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(ct, { value: e.dataFormat.bottomCommas, section: "dataFormat", fieldName: "bottomCommas", label: "Add commas", updateField: _e }), /* @__PURE__ */ r.createElement(Je, { value: e.dataFormat.bottomRoundTo, type: "number", section: "dataFormat", fieldName: "bottomRoundTo", label: "Round to decimal point", className: "number-narrow", updateField: _e, min: 0 })), on() && e.orientation === "vertical" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ r.createElement(ct, { value: e.isResponsiveTicks, fieldName: "isResponsiveTicks", label: "Use Responsive Ticks", updateField: _e }), (e.orientation === "horizontal" || !e.isResponsiveTicks) && ue() && /* @__PURE__ */ r.createElement(Je, { value: e.xAxis.tickRotation, type: "number", min: 0, section: "xAxis", fieldName: "tickRotation", label: "Tick rotation (Degrees)", className: "number-narrow", updateField: _e }), e.orientation === "vertical" && e.isResponsiveTicks && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ r.createElement(
    Je,
    {
      value: e.xAxis.maxTickRotation,
      type: "number",
      min: 0,
      section: "xAxis",
      fieldName: "maxTickRotation",
      label: "Max Tick Rotation",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
    }
  ), e.orientation === "horizontal" ? /* @__PURE__ */ r.createElement(r.Fragment, null, ye() && /* @__PURE__ */ r.createElement(ct, { value: e.yAxis.hideAxis, section: "yAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: _e }), Ne() && /* @__PURE__ */ r.createElement(ct, { value: e.yAxis.hideLabel, section: "yAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: _e })) : /* @__PURE__ */ r.createElement(r.Fragment, null, ye() && /* @__PURE__ */ r.createElement(ct, { value: e.xAxis.hideAxis, section: "xAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: _e }), Ne() && /* @__PURE__ */ r.createElement(ct, { value: e.xAxis.hideLabel, section: "xAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: _e }), Oe() && /* @__PURE__ */ r.createElement(ct, { value: e.xAxis.hideTicks, section: "xAxis", fieldName: "hideTicks", label: "Hide Ticks", updateField: _e })), ((Xe = e.series) == null ? void 0 : Xe.length) === 1 && e.visualizationType === "Bar" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("label", { htmlFor: "barHighlight" }, "Bar Highlighting"), e.series.length === 1 && nt.map((pe, de) => /* @__PURE__ */ r.createElement("fieldset", null, /* @__PURE__ */ r.createElement("div", { className: "edit-block", key: `highlighted-bar-${de}` }, /* @__PURE__ */ r.createElement("button", { className: "remove-column", onClick: (ge) => yt(ge, de) }, "Remove"), /* @__PURE__ */ r.createElement("p", null, "Highlighted Bar ", de + 1), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Value"), /* @__PURE__ */ r.createElement("select", { value: e.highlightedBarValues[de].value, onChange: (ge) => ht(ge, de) }, /* @__PURE__ */ r.createElement("option", { value: "" }, "- Select Value -"), mt && [...new Set(mt)].sort().map((ge) => /* @__PURE__ */ r.createElement("option", { key: `special-class-value-option-${de}-${ge}` }, ge)))), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Color"), /* @__PURE__ */ r.createElement("input", { type: "text", value: e.highlightedBarValues[de].color ? e.highlightedBarValues[de].color : "", onChange: (ge) => Tt(ge, de) })), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Border Width"), /* @__PURE__ */ r.createElement("input", { max: "5", min: "0", type: "number", value: e.highlightedBarValues[de].borderWidth ? e.highlightedBarValues[de].borderWidth : "", onChange: (ge) => jt(ge, de) })), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Legend Label"), /* @__PURE__ */ r.createElement("input", { type: "text", value: e.highlightedBarValues[de].legendLabel ? e.highlightedBarValues[de].legendLabel : "", onChange: (ge) => Rt(ge, de) }))))), /* @__PURE__ */ r.createElement("button", { className: "btn full-width", onClick: (pe) => je(pe) }, "Add Highlighted Bar"))), e.visualizationType === "Pie" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(
    ct,
    {
      value: e.exclusions.active,
      section: "exclusions",
      fieldName: "active",
      label: "Exclude one or more values",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "When this option is checked, you can select values for exclusion from the pie segments.")))
    }
  ), e.exclusions.active && /* @__PURE__ */ r.createElement(r.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement("fieldset", null, /* @__PURE__ */ r.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ r.createElement(tr, null)), /* @__PURE__ */ r.createElement(
    Pt,
    {
      fieldName: "visualizationType",
      label: "Add Exclusion",
      initial: "Select",
      onChange: (pe) => {
        pe.target.value !== "" && pe.target.value !== "Select" && Ln(pe.target.value), pe.target.value = "";
      },
      options: Pn(e.xAxis.dataKey, !0)
    }
  ))), ae() && e.orientation !== "horizontal" && /* @__PURE__ */ r.createElement("div", { className: "edit-block" }, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ r.createElement(_i, { allowZeroExpanded: !0 }, (vt = (ut = e.xAxis) == null ? void 0 : ut.anchors) == null ? void 0 : vt.map((pe, de) => /* @__PURE__ */ r.createElement(Nn, { className: "series-item series-item--chart", key: `xaxis-anchors-2-${de}` }, /* @__PURE__ */ r.createElement(_n, { className: "series-item__title" }, /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(On, { className: "accordion__button accordion__button" }, "Anchor ", de + 1, /* @__PURE__ */ r.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (ge) => {
        ge.preventDefault();
        const Fe = [...e.xAxis.anchors];
        Fe.splice(de, 1), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Fe
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", null, "Anchor Value"), /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[de].value ? e.xAxis.anchors[de].value : "",
      onChange: (ge) => {
        ge.preventDefault();
        const Fe = [...e.xAxis.anchors];
        Fe[de].value = ge.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Fe
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", null, "Anchor Color"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[de].color ? e.xAxis.anchors[de].color : "",
      onChange: (ge) => {
        ge.preventDefault();
        const Fe = [...e.xAxis.anchors];
        Fe[de].color = ge.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Fe
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ r.createElement(
    "select",
    {
      value: e.xAxis.anchors[de].lineStyle || "",
      onChange: (ge) => {
        const Fe = [...e.xAxis.anchors];
        Fe[de].lineStyle = ge.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Fe
          }
        });
      }
    },
    /* @__PURE__ */ r.createElement("option", null, "Select"),
    M.map((ge) => /* @__PURE__ */ r.createElement("option", { key: ge.key }, ge.value))
  )))))), /* @__PURE__ */ r.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (pe) => {
        pe.preventDefault();
        const de = [...e.xAxis.anchors];
        de.push({}), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: de
          }
        });
      }
    },
    "Add Anchor"
  )), ae() && e.orientation === "horizontal" && /* @__PURE__ */ r.createElement("div", { className: "edit-block" }, /* @__PURE__ */ r.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ r.createElement(_i, { allowZeroExpanded: !0 }, (Mt = (pt = e.yAxis) == null ? void 0 : pt.anchors) == null ? void 0 : Mt.map((pe, de) => /* @__PURE__ */ r.createElement(Nn, { className: "series-item series-item--chart", key: `accordion-yaxis-anchors-${de}` }, /* @__PURE__ */ r.createElement(_n, { className: "series-item__title" }, /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(On, { className: "accordion__button accordion__button" }, "Anchor ", de + 1, /* @__PURE__ */ r.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (ge) => {
        ge.preventDefault();
        const Fe = [...e.yAxis.anchors];
        Fe.splice(de, 1), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Fe
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", null, "Anchor Value"), /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[de].value ? e.yAxis.anchors[de].value : "",
      onChange: (ge) => {
        ge.preventDefault();
        const Fe = [...e.yAxis.anchors];
        Fe[de].value = ge.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Fe
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", null, "Anchor Color"), /* @__PURE__ */ r.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[de].color ? e.yAxis.anchors[de].color : "",
      onChange: (ge) => {
        ge.preventDefault();
        const Fe = [...e.yAxis.anchors];
        Fe[de].color = ge.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Fe
          }
        });
      }
    }
  )), /* @__PURE__ */ r.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ r.createElement(
    "select",
    {
      value: e.yAxis.anchors[de].lineStyle || "",
      onChange: (ge) => {
        const Fe = [...e.yAxis.anchors];
        Fe[de].lineStyle = ge.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Fe
          }
        });
      }
    },
    /* @__PURE__ */ r.createElement("option", null, "Select"),
    M.map((ge) => /* @__PURE__ */ r.createElement("option", { key: ge.key }, ge.value))
  )))))), /* @__PURE__ */ r.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (pe) => {
        pe.preventDefault();
        const de = [...e.yAxis.anchors];
        de.push({}), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: de
          }
        });
      }
    },
    "Add Anchor"
  )))), /* @__PURE__ */ r.createElement(fa.Regions, { name: "Regions" }), e.visualizationType !== "Box Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, "Columns")), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement(Fg, { config: e, updateField: _e, deleteColumn: xe }), " ")), Te() && /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, "Legend")), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement(ct, { value: e.legend.reverseLabelOrder, section: "legend", fieldName: "reverseLabelOrder", label: "Reverse Labels", updateField: _e }), /* @__PURE__ */ r.createElement(
    ct,
    {
      value: !!e.legend.hide,
      section: "legend",
      fieldName: "hide",
      label: "Hide Legend",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "With a single-series chart, consider hiding the legend to reduce visual clutter.")))
    }
  ), /* @__PURE__ */ r.createElement(
    ct,
    {
      value: e.legend.hideSuppressedLabels,
      section: "legend",
      fieldName: "hideSuppressedLabels",
      label: "Hide Suppressed Labels",
      updateField: _e,
      tooltip: /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.`)))
    }
  ), e.visualizationType === "Line" && /* @__PURE__ */ r.createElement(ct, { value: e.legend.lineMode, section: "legend", fieldName: "lineMode", label: "Show Lined Style Legend", updateField: _e }), e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1 && /* @__PURE__ */ r.createElement(Pt, { value: e.legend.colorCode, section: "legend", fieldName: "colorCode", label: "Color code by category", initial: "Select", updateField: _e, options: Hn(a) }), /* @__PURE__ */ r.createElement(Pt, { value: e.legend.behavior, section: "legend", fieldName: "behavior", label: "Legend Behavior (When clicked)", updateField: (...[pe, , de, ge]) => Ut(pe, de, ge), options: ["highlight", "isolate"] }), be() && /* @__PURE__ */ r.createElement(ct, { value: e.legend.axisAlign, fieldName: "axisAlign", section: "legend", label: "Align to Axis on Isolate", updateField: _e }), e.legend.behavior === "highlight" && e.tooltips.singleSeries && /* @__PURE__ */ r.createElement(ct, { value: e.legend.highlightOnHover, section: "legend", fieldName: "highlightOnHover", label: "HIGHLIGHT DATA SERIES ON HOVER", updateField: _e }), X && e.legend.behavior === "isolate" && !wt && /* @__PURE__ */ r.createElement("fieldset", { className: "primary-fieldset edit-block", key: "additional-highlight-values" }, /* @__PURE__ */ r.createElement("label", null, /* @__PURE__ */ r.createElement("span", { className: "edit-label" }, "Isolate Data Series", /* @__PURE__ */ r.createElement(me, { style: { textTransform: "none" } }, /* @__PURE__ */ r.createElement(me.Target, null, /* @__PURE__ */ r.createElement(st, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ r.createElement(me.Content, null, /* @__PURE__ */ r.createElement("p", null, "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend."))))), e.legend.seriesHighlight && e.legend.seriesHighlight.map((pe, de) => /* @__PURE__ */ r.createElement("fieldset", { className: "edit-block", key: `${pe}-${de}` }, /* @__PURE__ */ r.createElement(
    "button",
    {
      className: "remove-column",
      onClick: (ge) => {
        ge.preventDefault();
        const Fe = [...e.legend.seriesHighlight];
        Fe.splice(de, 1), _e("legend", null, "seriesHighlight", Fe), Fe.length || C();
      }
    },
    "Remove"
  ), /* @__PURE__ */ r.createElement(
    Pt,
    {
      value: e.legend.seriesHighlight[de],
      fieldName: "seriesHighlight",
      label: "Isolate Value",
      onChange: (ge) => {
        const Fe = [...e.legend.seriesHighlight];
        Fe.includes(ge.target.value) || (Fe[de] = ge.target.value, Ft([...Fe]));
      },
      options: kt()
    }
  ))), /* @__PURE__ */ r.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (pe) => {
        pe.preventDefault();
        const de = kt(), ge = [...e.legend.seriesHighlight];
        if (ge.length < de.length) {
          const [Nt] = de.filter((bn) => !ge.includes(bn));
          ge.push(Nt), Ft([...ge]);
        }
      }
    },
    "Add Isolate Value"
  )), /* @__PURE__ */ r.createElement(Je, { value: e.legend.label, section: "legend", fieldName: "label", label: "Title", updateField: _e }), /* @__PURE__ */ r.createElement(Pt, { value: (Dn = e.legend) == null ? void 0 : Dn.position, section: "legend", fieldName: "position", label: "Position", updateField: _e, options: ["right", "left", "bottom"] }), e.legend.position === "bottom" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(ct, { value: e.legend.singleRow, section: "legend", fieldName: "singleRow", label: "Single Row Legend", updateField: _e }), /* @__PURE__ */ r.createElement(ct, { value: e.legend.verticalSorted, section: "legend", fieldName: "verticalSorted", label: "Vertical sorted Legend", updateField: _e })), /* @__PURE__ */ r.createElement(Je, { type: "textarea", value: e.legend.description, updateField: _e, section: "legend", fieldName: "description", label: "Legend Description" }))), Ve() && /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, "Filters")), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement(Mg, { config: e, updateField: _e, rawData: E }))), /* @__PURE__ */ r.createElement(fa.Visual, { name: "Visual" }), e.visualizationType !== "Spark Line" && /* @__PURE__ */ r.createElement(Nn, null, /* @__PURE__ */ r.createElement(_n, null, /* @__PURE__ */ r.createElement(On, null, "Data Table")), /* @__PURE__ */ r.createElement(Fn, null, /* @__PURE__ */ r.createElement(zg, { config: e, columns: Object.keys(a[0] || {}), updateField: _e, isDashboard: y, isLoadedFromUrl: Rn }), " ")), /* @__PURE__ */ r.createElement(fa.Annotate, { name: "Text Annotations" })), e.type !== "Spark Line" && /* @__PURE__ */ r.createElement(rg, { loadConfig: t, config: e, convertStateToConfig: wn }))));
}, tm = (e) => {
  let t = "", n = Math.abs(e);
  return n >= 1e9 ? (t = "B", e = e / 1e9) : n >= 1e6 ? (t = "M", e = e / 1e6) : n >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, Iu = (e, t) => {
  var n;
  return e ? (n = e.legend) != null && n.hide ? e != null && e.title ? `dataTableSection__${e.title.replace(/\s/g, "")}` : "dataTableSection" : t : "dataTableSection";
}, iw = (e) => {
  e.sort((m, y) => m - y);
  const t = Math.floor(e.length / 2), n = e.length % 2 === 0, a = n ? e.slice(0, t) : e.slice(0, t + 1), i = n ? e.slice(t) : e.slice(t + 1), l = Math.floor(a.length / 2), c = n ? (a[l - 1] + a[l]) / 2 : a[l], f = Math.floor(i.length / 2), u = n ? (i[f - 1] + i[f]) / 2 : i[f];
  return { q1: c, q3: u };
}, ow = (e, t) => e.toString().localeCompare(t.toString(), "en", { numeric: !0 }), lw = (e, t) => t.toString().localeCompare(e.toString(), "en", { numeric: !0 }), sw = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], nm = (e = "#000000", t = !1) => {
  let n = Ba(e), a = t ? n.brighten(0.5).hex() : n.saturate(1.3).hex();
  return [e, a, n.darken(0.3).hex()];
};
const rm = (e) => {
  const t = /(?:\.([^.]+))$/, n = /[?&]wt=(csv|json)(?:&|$)/, a = new URL(e, window.location.origin), i = a.pathname, l = a.search, c = t.exec(i);
  if (c && c[1])
    return c[1];
  const f = n.exec(l);
  return f && f[1] ? f[1] : "";
};
function Hw({ configUrl: e, config: t, isEditor: n = !1, isDebug: a = !1, isDashboard: i = !1, setConfig: l, setEditing: c, hostname: f, link: u, setSharedFilter: m, setSharedFilterValue: y, dashboardConfig: v }) {
  var Pn, Vt, wn, tr, nr, En, Tn, Mn, Kn, zn, Rn, Wn;
  const x = new Og(), [A, T] = le.useState(!0), [M, E] = le.useState(null), [p, C] = le.useState({}), [_, w] = le.useState(p.data || []), [R, P] = le.useState(void 0), [z, q] = le.useState(void 0), [V, G] = le.useState(t && ((Vt = (Pn = t == null ? void 0 : t.legend) == null ? void 0 : Pn.seriesHighlight) != null && Vt.length) ? [...(wn = t == null ? void 0 : t.legend) == null ? void 0 : wn.seriesHighlight] : []), [ee, W] = le.useState("lg"), [Q, j] = le.useState([]), [te, se] = le.useState(), [re, ae] = le.useState(), [K, U] = le.useState(!1), [X, H] = le.useState(!1), [Te, be] = le.useState([]), [ce] = le.useState(`cove-${Math.random().toString(16).slice(-4)}`), [Re, He] = le.useState({
    data: [],
    isActive: !1,
    isBrushing: !1
  });
  le.useRef(/* @__PURE__ */ new Map()), le.useRef();
  const Ge = le.useRef(null), Ne = (F) => {
    H(F);
  };
  a && console.log("Chart config, isEditor", p, n);
  let { legend: ye, title: Oe, description: ue, visualizationType: ie } = p;
  n && (!Oe || Oe === "") && (Oe = "Chart Title"), p.table && (!((tr = p.table) != null && tr.label) || ((nr = p.table) == null ? void 0 : nr.label) === "") && (p.table.label = "Data Table");
  const { barBorderClass: Ce, lineDatapointClass: $e, contentClasses: Ve, sparkLineStyles: Ee } = $g(p), Ue = le.useId(), ft = () => zc(p.visualizationType, z, p.allowLineToBarGraph), Qe = async () => {
    var F;
    if (p.dataUrl) {
      const Ae = new URL(p.runtimeDataUrl || p.dataUrl, window.location.origin);
      let ze = Object.fromEntries(new URLSearchParams(Ae.search)), xe = !1;
      if ((F = p.filters) == null || F.forEach((mt) => {
        mt.type === "url" && ze[mt.queryParameter] !== decodeURIComponent(mt.active) && (ze[mt.queryParameter] = mt.active, xe = !0);
      }), (!p.formattedData || p.formattedData.urlFiltered) && !xe)
        return;
      let lt = `${Ae.origin}${Ae.pathname}${Object.keys(ze).map((mt, ht) => {
        let je = ht === 0 ? "?" : "&";
        return je += mt + "=", je += ze[mt], je;
      }).join("")}`, nt = [];
      try {
        const mt = rm(Ae.href);
        mt === "csv" || pp(lt) ? nt = await fetch(lt).then((ht) => ht.text()).then((ht) => yp.parse(ht, {
          header: !0,
          dynamicTyping: !0,
          skipEmptyLines: !0
        }).data) : mt === "json" || hp(lt) ? nt = await fetch(lt).then((ht) => ht.json()) : nt = [];
      } catch {
        console.error(`Cannot parse URL: ${lt}`), nt = [];
      }
      p.dataDescription && (nt = x.autoStandardize(nt), nt = x.developerStandardize(nt, p.dataDescription)), Object.assign(nt, { urlFiltered: !0 }), Ie({ ...p, runtimeDataUrl: lt, data: nt, formattedData: nt }), nt && (w(nt), P(nt), q(wi(p.filters, nt)));
    }
  }, We = async () => {
    let F = t || await (await fetch(e)).json(), Ae = F.data || [];
    const ze = F.filters ? F.filters.filter((nt) => nt.type === "url").length > 0 : !1;
    if (F.dataUrl && !ze)
      try {
        const nt = rm(F.dataUrl);
        (nt === "csv" || pp(F.dataUrl)) && (Ae = await fetch(F.dataUrl + `?v=${Op()}`).then((mt) => mt.text()).then((mt) => (mt = mt.replace(/(".*?")|,/g, (...je) => je[1] || "|"), mt = mt.replace(/["]+/g, ""), yp.parse(mt, {
          //quotes: "true",  // dont need these
          //quoteChar: "'",  // has no effect that I can tell
          header: !0,
          dynamicTyping: !0,
          skipEmptyLines: !0,
          delimiter: "|"
          // we are using pipe symbol as delimiter so setting this explicitly for Papa.parse
        }).data))), (nt === "json" || hp(F.dataUrl)) && (Ae = await fetch(F.dataUrl + `?v=${Op()}`).then((mt) => mt.json()));
      } catch {
        console.error(`COVE: Cannot parse URL: ${F.dataUrl}`), Ae = [];
      }
    F.dataDescription && (Ae = x.autoStandardize(Ae), Ae = x.developerStandardize(Ae, F.dataDescription)), Ae && (w(Ae), P(Ae)), F !== void 0 && F.table !== void 0 && (!F.table || !F.table.showVertical) && (F.table = F.table || {}, F.table.showVertical = !1);
    let xe = { ...af, ...F };
    xe.filters && xe.filters.forEach((nt, mt) => {
      const ht = ag(nt);
      ht && (xe.filters[mt].active = ht);
    }), xe.visualizationType === "Box Plot" && (xe.legend.hide = !0), xe.table.show === void 0 && (xe.table.show = !i), xe.series.forEach((nt) => {
      (nt.tooltip === void 0 || nt.tooltip === null) && (nt.tooltip = !0), nt.axis || (nt.axis = "Left");
    }), Ae && (xe.data = Ae);
    const lt = { ...await ig(xe) };
    Ie(lt, Ae);
  }, Ie = (F, Ae) => {
    var nt, mt, ht;
    let ze = Ae || _;
    Object.keys(af).forEach((je) => {
      F[je] && typeof F[je] == "object" && !Array.isArray(F[je]) && (F[je] = { ...af[je], ...F[je] });
    });
    let xe = [];
    if (F.exclusions && F.exclusions.active)
      if (F.xAxis.type === "categorical" && ((nt = F.exclusions.keys) == null ? void 0 : nt.length) > 0)
        xe = ze.filter((je) => !F.exclusions.keys.includes(je[F.xAxis.dataKey]));
      else if (Cn(F.xAxis) && (F.exclusions.dateStart || F.exclusions.dateEnd) && F.xAxis.dateParseFormat) {
        const je = (wt) => new Date(wt).getTime();
        let yt = je(F.exclusions.dateStart), Tt = je(F.exclusions.dateEnd) + 86399999, Rt = typeof yt !== void 0 && isNaN(yt) === !1, jt = typeof Tt !== void 0 && isNaN(Tt) === !1;
        Rt && jt ? xe = ze.filter((wt) => je(wt[F.xAxis.dataKey]) >= yt && je(wt[F.xAxis.dataKey]) <= Tt) : Rt ? xe = ze.filter((wt) => je(wt[F.xAxis.dataKey]) >= yt) : jt && (xe = ze.filter((wt) => je(wt[F.xAxis.dataKey]) <= Tt));
      } else
        xe = Ae || _;
    else
      xe = Ae || _;
    P(xe);
    let lt = [];
    if (F.filters && (F.filters.forEach((je, yt) => {
      const Tt = je.filterStyle === "nested-dropdown" ? je.values : je.orderedValues || Me(je.columnName, xe).sort(je.order === "desc" ? lw : ow);
      F.filters[yt].values = Tt, F.filters[yt].active = !F.filters[yt].active || Tt.indexOf(F.filters[yt].active) === -1 ? Tt[0] : F.filters[yt].active, F.filters[yt].filterStyle = F.filters[yt].filterStyle ? F.filters[yt].filterStyle : "dropdown";
    }), lt = wi(F.filters, xe), q(lt)), F.xAxis.type === "date-time" && p.orientation === "horizontal" && (F.xAxis.type = "date"), F.runtime = {}, F.runtime.series = F.dynamicSeries ? [] : F.series, F.runtime.seriesLabels = {}, F.runtime.seriesLabelsAll = [], F.runtime.originalXAxis = F.xAxis, F.dynamicSeries) {
      let je = Ae || F.formattedData || F.data;
      je && je.length && je.length > 0 && Object.keys(je[0]).forEach((yt) => {
        yt !== F.xAxis.dataKey && je[0][yt] && (!F.filters || F.filters.filter((Tt) => Tt.columnName === yt).length === 0) && (!F.columns || Object.keys(F.columns).indexOf(yt) === -1) && F.runtime.series.push({
          dataKey: yt,
          tooltip: !0
        });
      });
    }
    if (F.visualizationType === "Pie" ? (F.runtime.seriesKeys = (Ae || ze).map((je) => je[F.xAxis.dataKey]), F.runtime.seriesLabelsAll = F.runtime.seriesKeys) : F.runtime.seriesKeys = F.runtime.series ? F.runtime.series.map((je) => (F.runtime.seriesLabels[je.dataKey] = je.name || je.label || je.dataKey, F.runtime.seriesLabelsAll.push(je.name || je.dataKey), je.dataKey)) : [], F.visualizationType === "Box Plot" && F.series) {
      let je = xe ? xe.map((kt) => kt[F.xAxis.dataKey]) : ze.map((kt) => kt[F.xAxis.dataKey]), yt = xe ? xe.map((kt) => {
        var Ft;
        return Number(kt[(Ft = F == null ? void 0 : F.series[0]) == null ? void 0 : Ft.dataKey]);
      }) : ze.map((kt) => {
        var Ft;
        return Number(kt[(Ft = F == null ? void 0 : F.series[0]) == null ? void 0 : Ft.dataKey]);
      });
      const Rt = function(kt) {
        return kt.filter(function(Ft, Ut, Et) {
          return Et.indexOf(Ft) === Ut;
        });
      }(je);
      let jt = [];
      const wt = [];
      if (!Rt)
        return;
      Rt.forEach((kt) => {
        try {
          if (!kt)
            throw new _e("No groups resolved in box plots");
          let Ft = xe ? xe.filter((Z) => Z[F.xAxis.dataKey] === kt) : ze.filter((Z) => Z[F.xAxis.dataKey] === kt), Ut = Ft.map((Z) => {
            var Se;
            return Number(Z[(Se = F == null ? void 0 : F.series[0]) == null ? void 0 : Se.dataKey]);
          }), Et = Ut.sort((Z, Se) => Z - Se);
          const xn = iw(Et);
          if (!Ft)
            throw new _e("boxplots dont have data yet");
          if (!wt)
            throw new _e("boxplots dont have plots yet");
          F.boxplot.firstQuartilePercentage === "" && (F.boxplot.firstQuartilePercentage = 0), F.boxplot.thirdQuartilePercentage === "" && (F.boxplot.thirdQuartilePercentage = 0);
          const pn = xn.q1, sn = xn.q3, yn = sn - pn, Qt = pn - (sn - pn) * 1.5, gn = sn + (sn - pn) * 1.5, Vn = Et.filter((Z) => Z < Qt || Z > gn);
          let g = Ut;
          g = g.filter((Z) => !Vn.includes(Z));
          const D = us(Ut) || 0, B = ss([D, pn - 1.5 * yn]);
          wt.push({
            columnCategory: kt,
            columnMax: us([ss(Ut), pn + 1.5 * yn]),
            columnThirdQuartile: Number(sn).toFixed(F.dataFormat.roundTo),
            columnMedian: Number(Xg(Ut)).toFixed(F.dataFormat.roundTo),
            columnFirstQuartile: pn.toFixed(F.dataFormat.roundTo),
            columnMin: B,
            columnTotal: Ut.reduce((Z, Se) => Z + Se, 0),
            columnSd: Number(Ug(Ut)).toFixed(F.dataFormat.roundTo),
            columnMean: Number(Yg(Ut)).toFixed(F.dataFormat.roundTo),
            columnIqr: Number(yn).toFixed(F.dataFormat.roundTo),
            columnLowerBounds: B,
            columnUpperBounds: us([ss(Et), pn + 1.5 * yn]),
            columnOutliers: Vn,
            values: Ut,
            nonOutlierValues: g
          });
        } catch (Ft) {
          console.error("COVE: ", Ft.message);
        }
      }), jt = JSON.parse(JSON.stringify(wt)), jt.map((kt) => (kt.columnIqr = void 0, kt.nonOutlierValues = void 0, kt.columnLowerBounds = void 0, kt.columnUpperBounds = void 0, null)), F.boxplot.allValues = yt, F.boxplot.categories = Rt, F.boxplot.plots = wt, F.boxplot.tableData = jt;
    }
    F.visualizationType === "Combo" && F.series && (F.runtime.barSeriesKeys = [], F.runtime.lineSeriesKeys = [], F.runtime.areaSeriesKeys = [], F.runtime.forecastingSeriesKeys = [], F.series.forEach((je) => {
      je.type === "Area Chart" && F.runtime.areaSeriesKeys.push(je), je.type === "Forecasting" && F.runtime.forecastingSeriesKeys.push(je), (je.type === "Bar" || je.type === "Combo") && F.runtime.barSeriesKeys.push(je.dataKey), (je.type === "Line" || je.type === "dashed-sm" || je.type === "dashed-md" || je.type === "dashed-lg") && F.runtime.lineSeriesKeys.push(je.dataKey), je.type === "Combo" && (je.type = "Bar");
    })), F.visualizationType === "Forecasting" && F.series && (F.runtime.forecastingSeriesKeys = [], F.series.forEach((je) => {
      je.type === "Forecasting" && F.runtime.forecastingSeriesKeys.push(je);
    })), F.visualizationType === "Area Chart" && F.series && (F.runtime.areaSeriesKeys = [], F.series.forEach((je) => {
      F.runtime.areaSeriesKeys.push({ ...je, type: "Area Chart" });
    })), F.visualizationType === "Bar" && F.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(F.visualizationType) ? (F.runtime.xAxis = F.yAxis.yAxis ? F.yAxis.yAxis : F.yAxis, F.runtime.yAxis = F.xAxis.xAxis ? F.xAxis.xAxis : F.xAxis, F.runtime.horizontal = !1, F.orientation = "horizontal", F.yAxis.type = F.yAxis.type === "categorical" ? "linear" : F.yAxis.type) : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(F.visualizationType) && !ft() ? (F.runtime.xAxis = F.xAxis, F.runtime.yAxis = F.yAxis, F.runtime.horizontal = !1, F.orientation = "vertical") : (F.runtime.xAxis = F.xAxis, F.runtime.yAxis = F.yAxis, F.runtime.horizontal = !1), F.runtime.uniqueId = Date.now(), F.runtime.editorErrorMessage = F.visualizationType === "Pie" && !F.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", F.runtime.editorErrorMessage = F.visualizationType === "Sankey" && !F.description ? "SUBTEXT/CITATION field is empty: A description of the Sankey Diagram data must be inputted." : "", (mt = F.legend.seriesHighlight) != null && mt.length && G((ht = F.legend) == null ? void 0 : ht.seriesHighlight), C(F);
  }, Me = (F, Ae = this.state.data) => {
    const ze = [];
    return Ae.forEach((xe) => {
      const lt = xe[F];
      lt && ze.includes(lt) === !1 && ze.push(lt);
    }), ze;
  }, tt = (F, Ae) => {
    let ze = p.visualizationType === "Bar" && p.visualizationSubType === "horizontal" ? p.xAxis.dataKey : p.yAxis.sortKey, xe = parseFloat(F[ze]), lt = parseFloat(Ae[ze]);
    return xe < lt ? p.sortData === "ascending" ? 1 : -1 : xe > lt ? p.sortData === "ascending" ? -1 : 1 : 0;
  }, Ze = new Qy((F) => {
    for (let Ae of F) {
      let { width: ze, height: xe } = Ae.contentRect, lt = Jy(ze), nt = 32, mt = 350;
      W(lt), n && (ze = ze - mt), Ae.target.dataset.lollipop === "true" && (ze = ze - 2.5), ze = ze - nt, j([ze, xe]);
    }
  }), et = le.useCallback((F) => {
    F !== null && Ze.observe(F), ae(F);
  }, []);
  function at(F) {
    return Object.keys(F).length === 0;
  }
  le.useEffect(() => {
    We();
  }, []), le.useEffect(() => {
    Qe();
  }, [JSON.stringify(p.filters)]), le.useEffect(() => {
    re && !at(p) && !K && (Bg("cove_loaded", { config: p }), U(!0));
  }, [re, p]), le.useEffect(() => {
    const F = (Ae) => {
      let ze = [];
      ze.push(Ae.detail), se(ze);
    };
    return Ig("cove_filterData", (Ae) => F(Ae)), () => {
      Hg("cove_filterData", F);
    };
  }, [p]), le.useEffect(() => {
    if (te && te[0] && !te[0].hasOwnProperty("active")) {
      let Ae = { ...p };
      delete Ae.filters, C(Ae), q(wi(te, R));
    }
    if (te && te.length > 0 && te.length > 0 && te[0].hasOwnProperty("active")) {
      let F = { ...p, filters: te };
      C(F), q(wi(te, R));
    }
  }, [te]), t && le.useEffect(() => {
    We();
  }, [t.data]), le.useEffect(() => {
    var F;
    if (_ && p.xAxis && ((F = p.runtime) != null && F.seriesKeys)) {
      const Ae = ["Paired Bar", "Deviation Bar"].includes(p.visualizationType) ? p.twoColor.palette : p.palette, ze = { ...cr, ...Ss };
      let xe = p.customColors || ze[Ae], lt = p.runtime.seriesKeys.length, nt;
      for (; lt > xe.length; )
        xe = xe.concat(xe);
      xe = xe.slice(0, lt), nt = () => Oi({
        domain: p.runtime.seriesLabelsAll,
        range: xe,
        unknown: null
      }), E(nt), T(!1);
    }
    p && _ && p.sortData && _.sort(tt);
  }, [p, _]);
  const gt = (F) => {
    if (V.length + 1 === p.runtime.seriesKeys.length && p.visualizationType !== "Forecasting") {
      Ot();
      return;
    }
    const Ae = [...V];
    let ze = F.datum;
    p.runtime.seriesLabels && p.runtime.seriesKeys.forEach((xe) => {
      p.runtime.seriesLabels[xe] === F.datum && (ze = xe);
    }), Ae.indexOf(ze) !== -1 ? Ae.splice(Ae.indexOf(ze), 1) : Ae.push(ze), G(Ae);
  }, Ot = () => {
    try {
      const F = Ge.current;
      if (!F)
        throw new _e("No legend available to set previous focus on.");
      F.focus();
    } catch (F) {
      console.error("COVE:", F.message);
    }
    G([]);
  }, Kt = p.orientation === "horizontal" ? "yAxis" : "xAxis", on = (F, Ae = !0) => {
    let ze = jm(p.runtime[Kt].dateParseFormat)(F);
    return ze || (Ae && (p.runtime.editorErrorMessage = `Error parsing date "${F}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, Wt = (F) => sf(p.runtime[Kt].dateDisplayFormat)(F), Zt = (F) => sf(p.tooltips.dateDisplayFormat)(F);
  function zt(F, Ae) {
    const xe = document.createElement("canvas").getContext("2d");
    if (!xe) {
      console.error("2d context not found");
      return;
    }
    return xe.font = Ae || getComputedStyle(document.body).font, Math.ceil(xe.measureText(F).width);
  }
  const fn = (F, Ae, ze = !1, xe, lt, nt) => {
    if (isNaN(F) || !F)
      return F;
    const mt = F < 0;
    (Ae === void 0 || !Ae) && (Ae = "left"), mt && (F = Math.abs(F));
    let {
      dataFormat: { commas: ht, abbreviated: je, roundTo: yt, prefix: Tt, suffix: Rt, rightRoundTo: jt, bottomRoundTo: wt, rightPrefix: kt, rightSuffix: Ft, bottomPrefix: Ut, bottomSuffix: Et, bottomAbbreviated: xn }
    } = p;
    String(F).indexOf(",") !== -1 && (F = F.replaceAll(",", ""));
    let pn = F, sn = {
      useGrouping: !!ht
      // for old chart data table to work right cant just leave this to undefined
    };
    if (Ae === "left" || Ae === void 0) {
      let gn;
      nt !== void 0 ? gn = nt ? Number(nt) : 0 : gn = yt ? Number(yt) : 0, sn = {
        useGrouping: nt ? !0 : !!p.dataFormat.commas,
        minimumFractionDigits: gn,
        maximumFractionDigits: gn
      };
    }
    Ae === "right" && (sn = {
      useGrouping: !!p.dataFormat.rightCommas,
      minimumFractionDigits: jt ? Number(jt) : 0,
      maximumFractionDigits: jt ? Number(jt) : 0
    });
    const yn = () => p.forestPlot.type === "Logarithmic" && !wt ? 2 : Number(wt) ? Number(wt) : 0;
    if (Ae === "bottom" && (sn = {
      useGrouping: !!p.dataFormat.bottomCommas,
      minimumFractionDigits: yn(),
      maximumFractionDigits: yn()
    }), F = _p(F), isNaN(F))
      return p.runtime.editorErrorMessage = `Unable to parse number from data ${pn}. Try reviewing your data and selections in the Data Series section.`, pn;
    if (!p.dataFormat)
      return F;
    if (p.dataCutoff) {
      let gn = _p(p.dataCutoff);
      F < gn && (F = gn);
    }
    Ae === "left" && ht && je && ze || Ae === "bottom" && ht && je && ze ? F = F : F = F.toLocaleString("en-US", sn);
    let Qt = "";
    return je && Ae === "left" && ze && (F = tm(parseFloat(F))), xn && Ae === "bottom" && ze && (F = tm(parseFloat(F))), xe && Ae === "left" ? Qt = xe + Qt : Tt && Ae === "left" && (Qt += Tt), kt && Ae === "right" && (Qt += kt), Ut && Ae === "bottom" && (Qt += Ut), Qt += F, lt && Ae === "left" ? Qt += lt : Rt && Ae === "left" && (Qt += Rt), Ft && Ae === "right" && (Qt += Ft), Et && Ae === "bottom" && (Qt += Et), mt && (Qt = "-" + Qt), String(Qt);
  }, Yt = {
    "Paired Bar": /* @__PURE__ */ r.createElement(_r, null),
    Forecasting: /* @__PURE__ */ r.createElement(_r, null),
    Bar: /* @__PURE__ */ r.createElement(_r, null),
    Line: /* @__PURE__ */ r.createElement(_r, null),
    Combo: /* @__PURE__ */ r.createElement(_r, null),
    Pie: /* @__PURE__ */ r.createElement(MS, null),
    "Box Plot": /* @__PURE__ */ r.createElement(_r, null),
    "Area Chart": /* @__PURE__ */ r.createElement(_r, null),
    "Scatter Plot": /* @__PURE__ */ r.createElement(_r, null),
    "Deviation Bar": /* @__PURE__ */ r.createElement(_r, null),
    "Forest Plot": /* @__PURE__ */ r.createElement(_r, null),
    "Bump Chart": /* @__PURE__ */ r.createElement(_r, null)
  }, tn = () => {
    if (p.visualizationType === "Sankey" || p.visualizationType === "Forecasting" || p.visualizationType === "Forest Plot")
      return !1;
    if (p.visualizationType === "Pie") {
      if ((p == null ? void 0 : p.yAxis.dataKey) === void 0)
        return !0;
    } else if (((p == null ? void 0 : p.series) === void 0 || !((p == null ? void 0 : p.series.length) > 0)) && !(p != null && p.dynamicSeries))
      return !0;
    return !p.xAxis.dataKey;
  }, kn = (F, Ae) => {
    if (F === null || F === "" || F === void 0)
      return "";
    if (typeof F == "string" && F.length > 0 && p.legend.type === "equalnumber")
      return F;
    let ze = F, xe;
    if (Object.keys(p.columns).length > 0 && Object.keys(p.columns).forEach(function(lt) {
      var nt = p.columns[lt];
      nt.name === Ae && (xe = nt);
    }), xe === void 0 && (xe = p.type === "chart" ? p.dataFormat : p.primary, xe.useCommas = xe.commas, xe.roundToPlace = xe.roundTo ? xe.roundTo : ""), xe) {
      let lt = !1, nt = 0;
      Number(F) && (xe.roundToPlace >= 0 && (lt = xe.roundToPlace ? xe.roundToPlace !== "" || xe.roundToPlace !== null : !1, nt = xe.roundToPlace ? Number(xe.roundToPlace) : 0, xe.hasOwnProperty("roundToPlace") && lt && (ze = Number(F).toFixed(nt))), xe.hasOwnProperty("useCommas") && xe.useCommas === !0 && (ze = Number(F).toLocaleString("en-US", {
        style: "decimal",
        minimumFractionDigits: lt ? nt : 0,
        maximumFractionDigits: lt ? nt : 5
      }))), ze = (xe.prefix || "") + ze + (xe.suffix || "");
    }
    return ze;
  }, ot = () => {
    const F = (ze) => {
      ze && ze.preventDefault();
      let xe = { ...p };
      delete xe.newViz, Ie(xe);
    }, Ae = {
      position: "relative",
      height: "100vh",
      width: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gridArea: "content"
    };
    return /* @__PURE__ */ r.createElement("section", { className: "waiting", style: Ae }, /* @__PURE__ */ r.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ r.createElement("h3", null, "Finish Configuring"), /* @__PURE__ */ r.createElement("p", null, "Set all required options to the left and confirm below to display a preview of the chart."), /* @__PURE__ */ r.createElement(bs, { className: "btn", style: { margin: "1em auto" }, disabled: tn(), onClick: (ze) => F(ze) }, "I'm Done")));
  }, _e = () => {
    const F = {
      position: "absolute",
      background: "white",
      zIndex: "999",
      height: "100vh",
      width: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gridArea: "content"
    };
    return /* @__PURE__ */ r.createElement("section", { className: "waiting", style: F }, /* @__PURE__ */ r.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ r.createElement("h3", null, "Error With Configuration"), /* @__PURE__ */ r.createElement("p", null, p.runtime.editorErrorMessage)));
  }, $t = (F) => {
    try {
      if (!F)
        throw new _e("COVE: No rowObj in applyLegendToRow");
      if (p.type === "navigation") {
        let Ae = cr[p.color] || cr.bluegreenreverse;
        return nm(Ae[3]);
      }
      return nm();
    } catch (Ae) {
      console.error("COVE: ", Ae);
    }
  }, Lt = (F) => {
    var Ae;
    return Array.isArray(F) ? p.visualizationType === "Forecasting" ? F : (Ae = p == null ? void 0 : p.xAxis) != null && Ae.dataKey ? x.cleanData(F, p.xAxis.dataKey) : F : [];
  }, nn = (F) => F;
  let un = /* @__PURE__ */ r.createElement(kg, null);
  const At = (F) => {
    if (!(!F || !F.toLowerCase))
      return F.toLowerCase().replaceAll(/ /g, "-");
  }, rn = () => {
    var ze, xe, lt;
    const F = (ye == null ? void 0 : ye.position) === "bottom" || ["sm", "xs", "xxs"].includes(ee), Ae = ["chart-container", "p-relative"];
    return ((ze = p.legend) == null ? void 0 : ze.position) === "bottom" && Ae.push("bottom"), (xe = p.legend) != null && xe.hide && Ae.push("legend-hidden"), $e && Ae.push($e), p.barHasBorder || Ae.push("chart-bar--no-border"), (lt = p.brush) != null && lt.active && (v == null ? void 0 : v.type) === "dashboard" && (!F || p.legend.hide) && Ae.push("dashboard-brush"), Ae.push(...Ve), Ae;
  }, ln = () => {
    var ze, xe;
    const F = ["subtext "], Ae = (ye == null ? void 0 : ye.position) === "bottom" || ["sm", "xs", "xxs"].includes(ee);
    return p.isResponsiveTicks && F.push("subtext--responsive-ticks "), (ze = p.brush) != null && ze.active && !Ae && F.push("subtext--brush-active "), (xe = p.brush) != null && xe.active && p.legend.hide && F.push("subtext--brush-active "), F;
  };
  if (!A) {
    const F = /* @__PURE__ */ r.createElement("a", { href: `#data-table-${p.dataKey}`, className: "margin-left-href" }, p.dataKey, " (Go to Table)");
    un = /* @__PURE__ */ r.createElement(r.Fragment, null, n && /* @__PURE__ */ r.createElement(aw, null), /* @__PURE__ */ r.createElement(of.Responsive, { isEditor: n }, p.newViz && /* @__PURE__ */ r.createElement(ot, null), p.newViz === void 0 && n && p.runtime && ((En = p.runtime) == null ? void 0 : En.editorErrorMessage) && /* @__PURE__ */ r.createElement(_e, null), !tn() && !p.newViz && /* @__PURE__ */ r.createElement("div", { className: `cdc-chart-inner-container cove-component__content type-${At(p.visualizationType)}`, "aria-label": Cf(p), tabIndex: 0 }, /* @__PURE__ */ r.createElement(ug, { showTitle: p.showTitle, isDashboard: i, title: Oe, superTitle: p.superTitle, classes: ["chart-title", `${p.theme}`, "cove-component__header"], style: void 0 }), p.filters && !te && p.visualizationType !== "Spark Line" && /* @__PURE__ */ r.createElement(mp, { config: p, setConfig: C, setFilteredData: q, filteredData: z, excludedData: R, filterData: wi, dimensions: Q }), /* @__PURE__ */ r.createElement(Cp, { skipId: Iu(p, Ue), skipMessage: "Skip Over Chart Container" }), ((Tn = p.annotations) == null ? void 0 : Tn.length) > 0 && /* @__PURE__ */ r.createElement(Cp, { skipId: Iu(p, Ue), skipMessage: "Skip over annotations", key: "skip-annotations" }), (p == null ? void 0 : p.introText) && p.visualizationType !== "Spark Line" && /* @__PURE__ */ r.createElement("section", { className: "introText" }, Ni(p.introText)), /* @__PURE__ */ r.createElement("div", { className: rn().join(" ") }, p.visualizationType !== "Spark Line" && p.visualizationType !== "Line" && Yt[p.visualizationType], p.visualizationType === "Line" && (ft() ? Yt.Bar : Yt.Line), p.visualizationType === "Spark Line" && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(mp, { config: p, setConfig: C, setFilteredData: q, filteredData: z, excludedData: R, filterData: wi, dimensions: Q }), (p == null ? void 0 : p.introText) && /* @__PURE__ */ r.createElement("section", { className: "introText", style: { padding: "0px 0 35px" } }, Ni(p.introText)), /* @__PURE__ */ r.createElement("div", { style: { height: "100px", width: "100%", ...Ee } }, /* @__PURE__ */ r.createElement(Qp, null, (Ae) => /* @__PURE__ */ r.createElement(Nk, { width: Ae.width, height: Ae.height }))), ue && /* @__PURE__ */ r.createElement("div", { className: "subtext", style: { padding: "35px 0 15px" } }, Ni(ue))), p.visualizationType === "Sankey" && /* @__PURE__ */ r.createElement(Qp, { "aria-hidden": "true" }, (Ae) => /* @__PURE__ */ r.createElement(dE, { runtime: p.runtime, width: Ae.width, height: Ae.height })), !p.legend.hide && p.visualizationType !== "Spark Line" && p.visualizationType !== "Sankey" && /* @__PURE__ */ r.createElement(_k, { ref: Ge, skipId: Iu(p, Ue) })), i && p.table && p.table.show && p.table.showDataTableLink ? F : u && u, ue && p.visualizationType !== "Spark Line" && /* @__PURE__ */ r.createElement("div", { className: ln().join("") }, Ni(ue)), !1, /* @__PURE__ */ r.createElement(_d.Section, { classes: ["download-buttons"] }, p.table.showDownloadImgButton && /* @__PURE__ */ r.createElement(_d.Button, { text: "Download Image", title: "Download Chart as Image", type: "image", state: p, elementToCapture: ce }), p.table.showDownloadPdfButton && /* @__PURE__ */ r.createElement(_d.Button, { text: "Download PDF", title: "Download Chart as PDF", type: "pdf", state: p, elementToCapture: ce })), (p.xAxis.dataKey && p.table.show && p.visualizationType !== "Spark Line" && p.visualizationType !== "Sankey" || p.visualizationType === "Sankey" && p.table.show) && /* @__PURE__ */ r.createElement(
      Eg,
      {
        config: p,
        rawData: p.visualizationType === "Sankey" ? (Kn = (Mn = p == null ? void 0 : p.data) == null ? void 0 : Mn[0]) == null ? void 0 : Kn.tableData : p.table.customTableConfig ? wi(p.filters, p.data) : p.data,
        runtimeData: p.visualizationType === "Sankey" ? (Rn = (zn = p == null ? void 0 : p.data) == null ? void 0 : zn[0]) == null ? void 0 : Rn.tableData : z || R,
        expandDataTable: p.table.expanded,
        columns: p.columns,
        displayDataAsText: kn,
        displayGeoName: nn,
        applyLegendToRow: $t,
        tableTitle: p.table.label,
        indexTitle: p.table.indexLabel,
        vizTitle: Oe,
        viewport: ee,
        tabbingId: Iu(p, Ue),
        colorScale: M
      }
    ), ((Wn = p == null ? void 0 : p.annotations) == null ? void 0 : Wn.length) > 0 && /* @__PURE__ */ r.createElement(up.Dropdown, null), (p == null ? void 0 : p.footnotes) && /* @__PURE__ */ r.createElement("section", { className: "footnotes" }, Ni(p.footnotes)))));
  }
  const Hn = {
    brushConfig: Re,
    capitalize: (F) => F.charAt(0).toUpperCase() + F.slice(1),
    clean: Lt,
    colorPalettes: cr,
    colorScale: M,
    config: p,
    currentViewport: ee,
    dashboardConfig: v,
    debugSvg: a,
    dimensions: Q,
    dynamicLegendItems: Te,
    excludedData: R,
    formatDate: Wt,
    formatNumber: fn,
    formatTooltipsDate: Zt,
    getTextWidth: zt,
    getXAxisData: (F) => Cn(p.runtime.xAxis) ? on(F[p.runtime.originalXAxis.dataKey]).getTime() : F[p.runtime.originalXAxis.dataKey],
    getYAxisData: (F, Ae) => F[Ae],
    handleChartAriaLabels: Cf,
    handleLineType: Ry,
    highlight: gt,
    highlightReset: Ot,
    imageId: ce,
    isDashboard: i,
    isLegendBottom: (ye == null ? void 0 : ye.position) === "bottom" || ["sm", "xs", "xxs"].includes(ee),
    isDebug: a,
    isDraggingAnnotation: X,
    handleDragStateChange: Ne,
    isEditor: n,
    isNumber: Yu,
    legend: ye,
    lineOptions: sw,
    loading: A,
    missingRequiredSections: tn,
    outerContainerRef: et,
    parseDate: on,
    rawData: _ ?? {},
    seriesHighlight: V,
    setBrushConfig: He,
    setConfig: C,
    setDynamicLegendItems: be,
    setEditing: c,
    setFilteredData: q,
    setParentConfig: l,
    setSeriesHighlight: G,
    setSharedFilter: m,
    setSharedFilterValue: y,
    tableData: z || R,
    // do not clean table data
    transformedData: Lt(z || R),
    // do this right before passing to components
    twoColorPalette: Ss,
    unfilteredData: _,
    updateConfig: Ie
  };
  return /* @__PURE__ */ r.createElement(bt.Provider, { value: Hn }, /* @__PURE__ */ r.createElement(of.VisualizationWrapper, { config: p, isEditor: n, currentViewport: ee, ref: et, imageId: ce, showEditorPanel: p == null ? void 0 : p.showEditorPanel }, un));
}
export {
  Hw as C
};
