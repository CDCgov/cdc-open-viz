import { j as a, a as O, F as ze } from "./storybook-jsx-runtime-ea6e0d87.es.js";
import { r as he, R as Me } from "./storybook-index-f2fed736.es.js";
import { v as Hf, i as Pg, g as Ng } from "./storybook-getViewport-513ec896.es.js";
import { $ as kl, p as Vf, a0 as Fa, a1 as ii, a2 as Bt, a3 as Wf, a4 as Rc, a5 as rr, t as Yu, a6 as Qo, a7 as jd, a8 as jf, a9 as er, aa as Kf, ab as Rg, ac as Dg, d as Dc, m as Uf, W as is, P as Og, e as Fg, g as Zo, j as Gf, h as Yf, k as Mg, y as Ig, _ as Bg, ad as yr, B as as, X as Ir, I as _m, ae as zg, af as Pm, s as $g, l as Qh, Q as Nm, R as Rm, U as ic, S as Dm, Z as Om, H as Hg, u as Xf, v as Vg, M as Fm, w as Wg, x as jg, z as Mm, O as Kg, G as Ug, b as Gg, N as Yg, L as qf, J as Xg, K as qg, V as Zg, A as Qg, C as Jg } from "./storybook-ConfigContext-9f571f8e.es.js";
import { a as Yi, E as qr, b as mh, L as ev } from "./storybook-viewports-6b80499f.es.js";
import { L as yh, u as tv, b as nv, p as rv, s as iv, c as av } from "./storybook-useDataVizClasses-2dec1abb.es.js";
import { B as Oc } from "./storybook-Button-f953e457.es.js";
import { m as Jh, n as En, t as Xu, o as al, L as gh, l as Zf, M as Kd, D as ov, p as sv } from "./storybook-DataTable-8965f731.es.js";
import { T as lv } from "./storybook-index-4a64ea6e.es.js";
import { p as uv, P as De } from "./storybook-index-43433e35.es.js";
import { d as cv } from "./storybook-debounce-cc216a80.es.js";
import { a as dv } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { p as Gi } from "./storybook-index-31bf6905.es.js";
import { _ as Ke, l as hv } from "./storybook-lodash-a4231e1c.es.js";
import { r as fv, R as pv } from "./storybook-index-8cf78369.es.js";
import { a as Lr, s as ac, t as Fc } from "./storybook-colorPalettes-bc80e395.es.js";
import { u as Im, v as Qf, G as qe, c as vn, s as Mc, w as mv, x as Bm, y as Jf, z as yv, A as gv, B as vv, D as bv } from "./storybook-linear-d485c82c.es.js";
import { s as dl, t as zm, a as $m, b as Hm, B as Er, d as Fl, c as $n, C as xv } from "./storybook-linear-395e5b60.es.js";
import { k as oc, T as ee } from "./storybook-Tooltip-5b6ee371.es.js";
import { T as ft } from "./storybook-Text-0ce4510d.es.js";
import { t as Vm, m as Ud, f as Wm, d as Pu, a as Nu, b as Ru, n as ep, o as Sv, p as tp, c as jm, e as Km } from "./storybook-year-24bd1dc7.es.js";
import { c as Qi, n as np } from "./storybook-index-80cf478c.es.js";
import { a as Ve, S as Um } from "./storybook-Icon-e250778e.es.js";
import { B as rp } from "./storybook-BlurStrokeText-f87cf8cc.es.js";
import { a as Tn, b as Cn, c as An, d as Ln, A as za } from "./storybook-index-d975883a.es.js";
import { T as $e, S as ht, C as Ge, F as wv, f as ol, a as kv } from "./storybook-FootnotesStandAlone-282ea454.es.js";
import { M as ip } from "./storybook-MultiSelect-2a170cbd.es.js";
import { I as Ji } from "./storybook-InputSelect-4074d1ac.es.js";
import { A as Du } from "./storybook-Accordion-edcda35b.es.js";
import { a as ap } from "./storybook-footnoteSymbols-a3828433.es.js";
import { D as Gm } from "./storybook-DataTransform-cd90df2e.es.js";
import { F as op, a as sp } from "./storybook-Filters-1bcf5dff.es.js";
import { c as Tv } from "./storybook-coveUpdateWorker-2d39117f.es.js";
const vh = (e) => {
  if (e.visualizationType === "Sankey" || e.visualizationType === "Forecasting" || e.visualizationType === "Forest Plot")
    return !1;
  if (e.visualizationType === "Pie") {
    if ((e == null ? void 0 : e.yAxis.dataKey) === void 0)
      return !0;
  } else if (((e == null ? void 0 : e.series) === void 0 || !((e == null ? void 0 : e.series.length) > 0)) && !(e != null && e.dynamicSeries))
    return !0;
  return !e.xAxis.dataKey;
}, Cv = (e) => {
  const { updateConfig: t, config: n } = e, r = (o) => {
    o && o.preventDefault();
    let h = { ...n };
    delete h.newViz, t(h);
  };
  return /* @__PURE__ */ a("section", { className: "waiting", style: {
    position: "relative",
    height: "100vh",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gridArea: "content"
  }, children: /* @__PURE__ */ O("section", { className: "waiting-container", children: [
    /* @__PURE__ */ a("h3", { children: "Finish Configuring" }),
    /* @__PURE__ */ a("p", { children: "Set all required options to the left and confirm below to display a preview of the chart." }),
    /* @__PURE__ */ a(
      Oc,
      {
        className: "btn btn-primary",
        style: { margin: "1em auto" },
        disabled: vh(n),
        onClick: (o) => r(o),
        children: "I'm Done"
      }
    )
  ] }) });
}, Gd = ({ errorMessage: e }) => /* @__PURE__ */ a("section", { className: "waiting", style: {
  position: "absolute",
  background: "white",
  zIndex: "999",
  height: "100vh",
  width: "100%",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  gridArea: "content"
}, children: /* @__PURE__ */ O("section", { className: "waiting-container", children: [
  /* @__PURE__ */ a("h3", { children: "Error With Configuration" }),
  /* @__PURE__ */ a("p", { children: e })
] }) }), sc = Vm(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
sc.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Vm((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : sc);
sc.range;
function Av(e, t) {
  let n = 0, r, i = 0, o = 0;
  if (t === void 0)
    for (let h of e)
      h != null && (h = +h) >= h && (r = h - i, i += r / ++n, o += r * (h - i));
  else {
    let h = -1;
    for (let u of e)
      (u = t(u, ++h, e)) != null && (u = +u) >= u && (r = u - i, i += r / ++n, o += r * (u - i));
  }
  if (n > 1)
    return o / (n - 1);
}
function Lv(e, t) {
  const n = Av(e, t);
  return n && Math.sqrt(n);
}
class lp extends Map {
  constructor(t, n = Pv) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [r, i] of t)
        this.set(r, i);
  }
  get(t) {
    return super.get(up(this, t));
  }
  has(t) {
    return super.has(up(this, t));
  }
  set(t, n) {
    return super.set(Ev(this, t), n);
  }
  delete(t) {
    return super.delete(_v(this, t));
  }
}
function up({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function Ev({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function _v({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function Pv(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function Nv(e, t) {
  let n = 0, r = 0;
  if (t === void 0)
    for (let i of e)
      i != null && (i = +i) >= i && (++n, r += i);
  else {
    let i = -1;
    for (let o of e)
      (o = t(o, ++i, e)) != null && (o = +o) >= o && (++n, r += o);
  }
  if (n)
    return r / n;
}
function Ym(e, t) {
  return kl(e, 0.5, t);
}
function Rv(e, t, n) {
  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(i); ++r < i; )
    o[r] = e + r * n;
  return o;
}
function Dv(e, t, n, r, i, o) {
  const h = [
    [dl, 1, Pu],
    [dl, 5, 5 * Pu],
    [dl, 15, 15 * Pu],
    [dl, 30, 30 * Pu],
    [o, 1, Nu],
    [o, 5, 5 * Nu],
    [o, 15, 15 * Nu],
    [o, 30, 30 * Nu],
    [i, 1, Ru],
    [i, 3, 3 * Ru],
    [i, 6, 6 * Ru],
    [i, 12, 12 * Ru],
    [r, 1, ep],
    [r, 2, 2 * ep],
    [n, 1, Sv],
    [t, 1, tp],
    [t, 3, 3 * tp],
    [e, 1, Ud]
  ];
  function u(p, m, g) {
    const x = m < p;
    x && ([p, m] = [m, p]);
    const A = g && typeof g.range == "function" ? g : d(p, m, g), k = A ? A.range(p, +m + 1) : [];
    return x ? k.reverse() : k;
  }
  function d(p, m, g) {
    const x = Math.abs(m - p) / g, A = Im(([, , v]) => v).right(h, x);
    if (A === h.length)
      return e.every(Qf(p / Ud, m / Ud, g));
    if (A === 0)
      return sc.every(Math.max(Qf(p, m, g), 1));
    const [k, y] = h[x / h[A - 1][2] < h[A][2] / x ? A - 1 : A];
    return k.every(y);
  }
  return [u, d];
}
const [Ov, Fv] = Dv(Wm, Hm, Km, jm, $m, zm), ef = he.createContext(() => {
}), pt = he.createContext({}), Mv = (e) => {
  const { children: t } = e, { config: n, currentViewport: r } = he.useContext(pt);
  return /* @__PURE__ */ O("div", { className: (() => {
    let o = ["legend-wrapper", "d-flex", "flex-nowrap", "w-100"];
    const { legend: h } = n;
    return (h.position === "bottom" || h.position === "top" || Yi(r)) && (o = o.filter((u) => u !== "flex-nowrap"), o.push("flex-wrap")), o.join(" ");
  })(), children: [
    ...t
  ] });
};
var Ha = [], Iv = function() {
  return Ha.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Bv = function() {
  return Ha.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, cp = "ResizeObserver loop completed with undelivered notifications.", zv = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: cp
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = cp), window.dispatchEvent(e);
}, Tl;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Tl || (Tl = {}));
var Va = function(e) {
  return Object.freeze(e);
}, Xm = function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Va(this);
  }
  return e;
}(), qm = function() {
  function e(t, n, r, i) {
    return this.x = t, this.y = n, this.width = r, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Va(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, i = t.top, o = t.right, h = t.bottom, u = t.left, d = t.width, p = t.height;
    return { x: n, y: r, top: i, right: o, bottom: h, left: u, width: d, height: p };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), tf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Zm = function(e) {
  if (tf(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var i = e, o = i.offsetWidth, h = i.offsetHeight;
  return !(o || h || e.getClientRects().length);
}, dp = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, $v = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, fl = typeof window < "u" ? window : {}, Ou = /* @__PURE__ */ new WeakMap(), hp = /auto|scroll/, Hv = /^tb|vertical/, Vv = /msie|trident/i.test(fl.navigator && fl.navigator.userAgent), ai = function(e) {
  return parseFloat(e || "0");
}, ts = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Xm((n ? t : e) || 0, (n ? e : t) || 0);
}, fp = Va({
  devicePixelContentBoxSize: ts(),
  borderBoxSize: ts(),
  contentBoxSize: ts(),
  contentRect: new qm(0, 0, 0, 0)
}), Qm = function(e, t) {
  if (t === void 0 && (t = !1), Ou.has(e) && !t)
    return Ou.get(e);
  if (Zm(e))
    return Ou.set(e, fp), fp;
  var n = getComputedStyle(e), r = tf(e) && e.ownerSVGElement && e.getBBox(), i = !Vv && n.boxSizing === "border-box", o = Hv.test(n.writingMode || ""), h = !r && hp.test(n.overflowY || ""), u = !r && hp.test(n.overflowX || ""), d = r ? 0 : ai(n.paddingTop), p = r ? 0 : ai(n.paddingRight), m = r ? 0 : ai(n.paddingBottom), g = r ? 0 : ai(n.paddingLeft), x = r ? 0 : ai(n.borderTopWidth), A = r ? 0 : ai(n.borderRightWidth), k = r ? 0 : ai(n.borderBottomWidth), y = r ? 0 : ai(n.borderLeftWidth), v = g + p, S = d + m, B = y + A, R = x + k, N = u ? e.offsetHeight - R - e.clientHeight : 0, D = h ? e.offsetWidth - B - e.clientWidth : 0, L = i ? v + B : 0, q = i ? S + R : 0, V = r ? r.width : ai(n.width) - L - D, ae = r ? r.height : ai(n.height) - q - N, Y = V + v + D + B, Q = ae + S + N + R, se = Va({
    devicePixelContentBoxSize: ts(Math.round(V * devicePixelRatio), Math.round(ae * devicePixelRatio), o),
    borderBoxSize: ts(Y, Q, o),
    contentBoxSize: ts(V, ae, o),
    contentRect: new qm(g, d, V, ae)
  });
  return Ou.set(e, se), se;
}, Jm = function(e, t, n) {
  var r = Qm(e, n), i = r.borderBoxSize, o = r.contentBoxSize, h = r.devicePixelContentBoxSize;
  switch (t) {
    case Tl.DEVICE_PIXEL_CONTENT_BOX:
      return h;
    case Tl.BORDER_BOX:
      return i;
    default:
      return o;
  }
}, ey = function() {
  function e(t) {
    var n = Qm(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Va([n.borderBoxSize]), this.contentBoxSize = Va([n.contentBoxSize]), this.devicePixelContentBoxSize = Va([n.devicePixelContentBoxSize]);
  }
  return e;
}(), ty = function(e) {
  if (Zm(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Wv = function() {
  var e = 1 / 0, t = [];
  Ha.forEach(function(h) {
    if (h.activeTargets.length !== 0) {
      var u = [];
      h.activeTargets.forEach(function(p) {
        var m = new ey(p.target), g = ty(p.target);
        u.push(m), p.lastReportedSize = Jm(p.target, p.observedBox), g < e && (e = g);
      }), t.push(function() {
        h.callback.call(h.observer, u, h.observer);
      }), h.activeTargets.splice(0, h.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var i = r[n];
    i();
  }
  return e;
}, pp = function(e) {
  Ha.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(i) {
      i.isActive() && (ty(i.target) > e ? n.activeTargets.push(i) : n.skippedTargets.push(i));
    });
  });
}, jv = function() {
  var e = 0;
  for (pp(e); Iv(); )
    e = Wv(), pp(e);
  return Bv() && zv(), e > 0;
}, Yd, ny = [], Kv = function() {
  return ny.splice(0).forEach(function(e) {
    return e();
  });
}, Uv = function(e) {
  if (!Yd) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return Kv();
    }).observe(n, r), Yd = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  ny.push(e), Yd();
}, Gv = function(e) {
  Uv(function() {
    requestAnimationFrame(e);
  });
}, qu = 0, Yv = function() {
  return !!qu;
}, Xv = 250, qv = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, mp = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], yp = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Xd = !1, Zv = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Xv), !Xd) {
      Xd = !0;
      var r = yp(t);
      Gv(function() {
        var i = !1;
        try {
          i = jv();
        } finally {
          if (Xd = !1, t = r - yp(), !Yv())
            return;
          i ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, qv);
    };
    document.body ? n() : fl.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), mp.forEach(function(n) {
      return fl.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), mp.forEach(function(n) {
      return fl.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), bh = new Zv(), gp = function(e) {
  !qu && e > 0 && bh.start(), qu += e, !qu && bh.stop();
}, Qv = function(e) {
  return !tf(e) && !$v(e) && getComputedStyle(e).display === "inline";
}, Jv = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Tl.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Jm(this.target, this.observedBox, !0);
    return Qv(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), eb = function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Fu = /* @__PURE__ */ new WeakMap(), vp = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Mu = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new eb(t, n);
    Fu.set(t, r);
  }, e.observe = function(t, n, r) {
    var i = Fu.get(t), o = i.observationTargets.length === 0;
    vp(i.observationTargets, n) < 0 && (o && Ha.push(i), i.observationTargets.push(new Jv(n, r && r.box)), gp(1), bh.schedule());
  }, e.unobserve = function(t, n) {
    var r = Fu.get(t), i = vp(r.observationTargets, n), o = r.observationTargets.length === 1;
    i >= 0 && (o && Ha.splice(Ha.indexOf(r), 1), r.observationTargets.splice(i, 1), gp(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Fu.get(t);
    r.observationTargets.slice().forEach(function(i) {
      return n.unobserve(t, i.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), tb = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Mu.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!dp(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Mu.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!dp(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Mu.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Mu.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const nb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: tb,
  ResizeObserverEntry: ey,
  ResizeObserverSize: Xm
}, Symbol.toStringTag, { value: "Module" })), rb = /* @__PURE__ */ dv(nb);
var Ko = ay, ji = iy(uv), ib = iy(cv), Uo = sb(he), ab = rb, ob = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function ry(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (ry = function(i) {
    return i ? n : t;
  })(e);
}
function sb(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = ry(t);
  if (n && n.has(e))
    return n.get(e);
  var r = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var h = i ? Object.getOwnPropertyDescriptor(e, o) : null;
      h && (h.get || h.set) ? Object.defineProperty(r, o, h) : r[o] = e[o];
    }
  return r.default = e, n && n.set(e, r), r;
}
function iy(e) {
  return e && e.__esModule ? e : { default: e };
}
function lc() {
  return lc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, lc.apply(this, arguments);
}
function lb(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var ub = [];
function ay(e) {
  var t = e.className, n = e.children, r = e.debounceTime, i = r === void 0 ? 300 : r, o = e.ignoreDimensions, h = o === void 0 ? ub : o, u = e.parentSizeStyles, d = u === void 0 ? {
    width: "100%",
    height: "100%"
  } : u, p = e.enableDebounceLeadingCall, m = p === void 0 ? !0 : p, g = lb(e, ob), x = (0, Uo.useRef)(null), A = (0, Uo.useRef)(0), k = (0, Uo.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), y = k[0], v = k[1], S = (0, Uo.useMemo)(function() {
    var B = Array.isArray(h) ? h : [h];
    return (0, ib.default)(function(R) {
      v(function(N) {
        var D = Object.keys(N), L = D.filter(function(V) {
          return N[V] !== R[V];
        }), q = L.every(function(V) {
          return B.includes(V);
        });
        return q ? N : R;
      });
    }, i, {
      leading: m
    });
  }, [i, m, h]);
  return (0, Uo.useEffect)(function() {
    var B = new ab.ResizeObserver(function(R) {
      R === void 0 && (R = []), R.forEach(function(N) {
        var D = N.contentRect, L = D.left, q = D.top, V = D.width, ae = D.height;
        A.current = window.requestAnimationFrame(function() {
          S({
            width: V,
            height: ae,
            top: q,
            left: L
          });
        });
      });
    });
    return x.current && B.observe(x.current), function() {
      window.cancelAnimationFrame(A.current), B.disconnect(), S != null && S.cancel && S.cancel();
    };
  }, [S]), /* @__PURE__ */ Uo.default.createElement("div", lc({
    style: d,
    ref: x,
    className: t
  }, g), n(lc({}, y, {
    ref: x.current,
    resize: S
  })));
}
ay.propTypes = {
  className: ji.default.string,
  debounceTime: ji.default.number,
  enableDebounceLeadingCall: ji.default.bool,
  ignoreDimensions: ji.default.oneOfType([ji.default.any, ji.default.arrayOf(ji.default.any)]),
  children: ji.default.func.isRequired
};
var nf = Il(), Et = (e) => Ml(e, nf), rf = Il();
Et.write = (e) => Ml(e, rf);
var Ic = Il();
Et.onStart = (e) => Ml(e, Ic);
var af = Il();
Et.onFrame = (e) => Ml(e, af);
var of = Il();
Et.onFinish = (e) => Ml(e, of);
var ns = [];
Et.setTimeout = (e, t) => {
  const n = Et.now() + t, r = () => {
    const o = ns.findIndex((h) => h.cancel == r);
    ~o && ns.splice(o, 1), qi -= ~o ? 1 : 0;
  }, i = { time: n, handler: e, cancel: r };
  return ns.splice(oy(n), 0, i), qi += 1, sy(), i;
};
var oy = (e) => ~(~ns.findIndex((t) => t.time > e) || ~ns.length);
Et.cancel = (e) => {
  Ic.delete(e), af.delete(e), of.delete(e), nf.delete(e), rf.delete(e);
};
Et.sync = (e) => {
  xh = !0, Et.batchedUpdates(e), xh = !1;
};
Et.throttle = (e) => {
  let t;
  function n() {
    try {
      e(...t);
    } finally {
      t = null;
    }
  }
  function r(...i) {
    t = i, Et.onStart(n);
  }
  return r.handler = e, r.cancel = () => {
    Ic.delete(n), t = null;
  }, r;
};
var sf = typeof window < "u" ? window.requestAnimationFrame : (
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  () => {
  }
);
Et.use = (e) => sf = e;
Et.now = typeof performance < "u" ? () => performance.now() : Date.now;
Et.batchedUpdates = (e) => e();
Et.catch = console.error;
Et.frameLoop = "always";
Et.advance = () => {
  Et.frameLoop !== "demand" ? console.warn(
    "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
  ) : uy();
};
var Xi = -1, qi = 0, xh = !1;
function Ml(e, t) {
  xh ? (t.delete(e), e(0)) : (t.add(e), sy());
}
function sy() {
  Xi < 0 && (Xi = 0, Et.frameLoop !== "demand" && sf(ly));
}
function cb() {
  Xi = -1;
}
function ly() {
  ~Xi && (sf(ly), Et.batchedUpdates(uy));
}
function uy() {
  const e = Xi;
  Xi = Et.now();
  const t = oy(Xi);
  if (t && (cy(ns.splice(0, t), (n) => n.handler()), qi -= t), !qi) {
    cb();
    return;
  }
  Ic.flush(), nf.flush(e ? Math.min(64, Xi - e) : 16.667), af.flush(), rf.flush(), of.flush();
}
function Il() {
  let e = /* @__PURE__ */ new Set(), t = e;
  return {
    add(n) {
      qi += t == e && !e.has(n) ? 1 : 0, e.add(n);
    },
    delete(n) {
      return qi -= t == e && e.has(n) ? 1 : 0, e.delete(n);
    },
    flush(n) {
      t.size && (e = /* @__PURE__ */ new Set(), qi -= t.size, cy(t, (r) => r(n) && e.add(r)), qi += e.size, t = e);
    }
  };
}
function cy(e, t) {
  e.forEach((n) => {
    try {
      t(n);
    } catch (r) {
      Et.catch(r);
    }
  });
}
var db = Object.defineProperty, hb = (e, t) => {
  for (var n in t)
    db(e, n, { get: t[n], enumerable: !0 });
}, Xr = {};
hb(Xr, {
  assign: () => pb,
  colors: () => Zi,
  createStringInterpolator: () => uf,
  skipAnimation: () => hy,
  to: () => dy,
  willAdvance: () => cf
});
function Sh() {
}
var fb = (e, t, n) => Object.defineProperty(e, t, { value: n, writable: !0, configurable: !0 }), We = {
  arr: Array.isArray,
  obj: (e) => !!e && e.constructor.name === "Object",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0
};
function ki(e, t) {
  if (We.arr(e)) {
    if (!We.arr(t) || e.length !== t.length)
      return !1;
    for (let n = 0; n < e.length; n++)
      if (e[n] !== t[n])
        return !1;
    return !0;
  }
  return e === t;
}
var Pt = (e, t) => e.forEach(t);
function li(e, t, n) {
  if (We.arr(e)) {
    for (let r = 0; r < e.length; r++)
      t.call(n, e[r], `${r}`);
    return;
  }
  for (const r in e)
    e.hasOwnProperty(r) && t.call(n, e[r], r);
}
var mr = (e) => We.und(e) ? [] : We.arr(e) ? e : [e];
function pl(e, t) {
  if (e.size) {
    const n = Array.from(e);
    e.clear(), Pt(n, t);
  }
}
var hl = (e, ...t) => pl(e, (n) => n(...t)), lf = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), uf, dy, Zi = null, hy = !1, cf = Sh, pb = (e) => {
  e.to && (dy = e.to), e.now && (Et.now = e.now), e.colors !== void 0 && (Zi = e.colors), e.skipAnimation != null && (hy = e.skipAnimation), e.createStringInterpolator && (uf = e.createStringInterpolator), e.requestAnimationFrame && Et.use(e.requestAnimationFrame), e.batchedUpdates && (Et.batchedUpdates = e.batchedUpdates), e.willAdvance && (cf = e.willAdvance), e.frameLoop && (Et.frameLoop = e.frameLoop);
}, ml = /* @__PURE__ */ new Set(), Mr = [], qd = [], uc = 0, Bc = {
  get idle() {
    return !ml.size && !Mr.length;
  },
  /** Advance the given animation on every frame until idle. */
  start(e) {
    uc > e.priority ? (ml.add(e), Et.onStart(mb)) : (fy(e), Et(wh));
  },
  /** Advance all animations by the given time. */
  advance: wh,
  /** Call this when an animation's priority changes. */
  sort(e) {
    if (uc)
      Et.onFrame(() => Bc.sort(e));
    else {
      const t = Mr.indexOf(e);
      ~t && (Mr.splice(t, 1), py(e));
    }
  },
  /**
   * Clear all animations. For testing purposes.
   *
   * ☠️ Never call this from within the frameloop.
   */
  clear() {
    Mr = [], ml.clear();
  }
};
function mb() {
  ml.forEach(fy), ml.clear(), Et(wh);
}
function fy(e) {
  Mr.includes(e) || py(e);
}
function py(e) {
  Mr.splice(
    yb(Mr, (t) => t.priority > e.priority),
    0,
    e
  );
}
function wh(e) {
  const t = qd;
  for (let n = 0; n < Mr.length; n++) {
    const r = Mr[n];
    uc = r.priority, r.idle || (cf(r), r.advance(e), r.idle || t.push(r));
  }
  return uc = 0, qd = Mr, qd.length = 0, Mr = t, Mr.length > 0;
}
function yb(e, t) {
  const n = e.findIndex(t);
  return n < 0 ? e.length : n;
}
var gb = (e, t, n) => Math.min(Math.max(n, e), t), vb = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, Gr = "[-+]?\\d*\\.?\\d+", cc = Gr + "%";
function zc(...e) {
  return "\\(\\s*(" + e.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var bb = new RegExp("rgb" + zc(Gr, Gr, Gr)), xb = new RegExp("rgba" + zc(Gr, Gr, Gr, Gr)), Sb = new RegExp("hsl" + zc(Gr, cc, cc)), wb = new RegExp(
  "hsla" + zc(Gr, cc, cc, Gr)
), kb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Tb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Cb = /^#([0-9a-fA-F]{6})$/, Ab = /^#([0-9a-fA-F]{8})$/;
function Lb(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = Cb.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : Zi && Zi[e] !== void 0 ? Zi[e] : (t = bb.exec(e)) ? (Go(t[1]) << 24 | // r
  Go(t[2]) << 16 | // g
  Go(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = xb.exec(e)) ? (Go(t[1]) << 24 | // r
  Go(t[2]) << 16 | // g
  Go(t[3]) << 8 | // b
  Sp(t[4])) >>> // a
  0 : (t = kb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = Ab.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = Tb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = Sb.exec(e)) ? (bp(
    xp(t[1]),
    // h
    Iu(t[2]),
    // s
    Iu(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = wb.exec(e)) ? (bp(
    xp(t[1]),
    // h
    Iu(t[2]),
    // s
    Iu(t[3])
    // l
  ) | Sp(t[4])) >>> // a
  0 : null;
}
function Zd(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function bp(e, t, n) {
  const r = n < 0.5 ? n * (1 + t) : n + t - n * t, i = 2 * n - r, o = Zd(i, r, e + 1 / 3), h = Zd(i, r, e), u = Zd(i, r, e - 1 / 3);
  return Math.round(o * 255) << 24 | Math.round(h * 255) << 16 | Math.round(u * 255) << 8;
}
function Go(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function xp(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function Sp(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function Iu(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function wp(e) {
  let t = Lb(e);
  if (t === null)
    return e;
  t = t || 0;
  const n = (t & 4278190080) >>> 24, r = (t & 16711680) >>> 16, i = (t & 65280) >>> 8, o = (t & 255) / 255;
  return `rgba(${n}, ${r}, ${i}, ${o})`;
}
var Cl = (e, t, n) => {
  if (We.fun(e))
    return e;
  if (We.arr(e))
    return Cl({
      range: e,
      output: t,
      extrapolate: n
    });
  if (We.str(e.output[0]))
    return uf(e);
  const r = e, i = r.output, o = r.range || [0, 1], h = r.extrapolateLeft || r.extrapolate || "extend", u = r.extrapolateRight || r.extrapolate || "extend", d = r.easing || ((p) => p);
  return (p) => {
    const m = _b(p, o);
    return Eb(
      p,
      o[m],
      o[m + 1],
      i[m],
      i[m + 1],
      d,
      h,
      u,
      r.map
    );
  };
};
function Eb(e, t, n, r, i, o, h, u, d) {
  let p = d ? d(e) : e;
  if (p < t) {
    if (h === "identity")
      return p;
    h === "clamp" && (p = t);
  }
  if (p > n) {
    if (u === "identity")
      return p;
    u === "clamp" && (p = n);
  }
  return r === i ? r : t === n ? e <= t ? r : i : (t === -1 / 0 ? p = -p : n === 1 / 0 ? p = p - t : p = (p - t) / (n - t), p = o(p), r === -1 / 0 ? p = -p : i === 1 / 0 ? p = p + r : p = p * (i - r) + r, p);
}
function _b(e, t) {
  for (var n = 1; n < t.length - 1 && !(t[n] >= e); ++n)
    ;
  return n - 1;
}
var Pb = (e, t = "end") => (n) => {
  n = t === "end" ? Math.min(n, 0.999) : Math.max(n, 1e-3);
  const r = n * e, i = t === "end" ? Math.floor(r) : Math.ceil(r);
  return gb(0, 1, i / e);
}, dc = 1.70158, Bu = dc * 1.525, kp = dc + 1, Tp = 2 * Math.PI / 3, Cp = 2 * Math.PI / 4.5, zu = (e) => e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375, Nb = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => 1 - (1 - e) * (1 - e),
  easeInOutQuad: (e) => e < 0.5 ? 2 * e * e : 1 - Math.pow(-2 * e + 2, 2) / 2,
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => 1 - Math.pow(1 - e, 3),
  easeInOutCubic: (e) => e < 0.5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2,
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => 1 - Math.pow(1 - e, 4),
  easeInOutQuart: (e) => e < 0.5 ? 8 * e * e * e * e : 1 - Math.pow(-2 * e + 2, 4) / 2,
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => 1 - Math.pow(1 - e, 5),
  easeInOutQuint: (e) => e < 0.5 ? 16 * e * e * e * e * e : 1 - Math.pow(-2 * e + 2, 5) / 2,
  easeInSine: (e) => 1 - Math.cos(e * Math.PI / 2),
  easeOutSine: (e) => Math.sin(e * Math.PI / 2),
  easeInOutSine: (e) => -(Math.cos(Math.PI * e) - 1) / 2,
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * e - 10),
  easeOutExpo: (e) => e === 1 ? 1 : 1 - Math.pow(2, -10 * e),
  easeInOutExpo: (e) => e === 0 ? 0 : e === 1 ? 1 : e < 0.5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2,
  easeInCirc: (e) => 1 - Math.sqrt(1 - Math.pow(e, 2)),
  easeOutCirc: (e) => Math.sqrt(1 - Math.pow(e - 1, 2)),
  easeInOutCirc: (e) => e < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * e, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * e + 2, 2)) + 1) / 2,
  easeInBack: (e) => kp * e * e * e - dc * e * e,
  easeOutBack: (e) => 1 + kp * Math.pow(e - 1, 3) + dc * Math.pow(e - 1, 2),
  easeInOutBack: (e) => e < 0.5 ? Math.pow(2 * e, 2) * ((Bu + 1) * 2 * e - Bu) / 2 : (Math.pow(2 * e - 2, 2) * ((Bu + 1) * (e * 2 - 2) + Bu) + 2) / 2,
  easeInElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : -Math.pow(2, 10 * e - 10) * Math.sin((e * 10 - 10.75) * Tp),
  easeOutElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : Math.pow(2, -10 * e) * Math.sin((e * 10 - 0.75) * Tp) + 1,
  easeInOutElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : e < 0.5 ? -(Math.pow(2, 20 * e - 10) * Math.sin((20 * e - 11.125) * Cp)) / 2 : Math.pow(2, -20 * e + 10) * Math.sin((20 * e - 11.125) * Cp) / 2 + 1,
  easeInBounce: (e) => 1 - zu(1 - e),
  easeOutBounce: zu,
  easeInOutBounce: (e) => e < 0.5 ? (1 - zu(1 - 2 * e)) / 2 : (1 + zu(2 * e - 1)) / 2,
  steps: Pb
}, Al = Symbol.for("FluidValue.get"), os = Symbol.for("FluidValue.observers"), Fr = (e) => !!(e && e[Al]), Tr = (e) => e && e[Al] ? e[Al]() : e, Ap = (e) => e[os] || null;
function Rb(e, t) {
  e.eventObserved ? e.eventObserved(t) : e(t);
}
function Ll(e, t) {
  const n = e[os];
  n && n.forEach((r) => {
    Rb(r, t);
  });
}
var my = class {
  constructor(e) {
    if (!e && !(e = this.get))
      throw Error("Unknown getter");
    Db(this, e);
  }
}, Db = (e, t) => yy(e, Al, t);
function us(e, t) {
  if (e[Al]) {
    let n = e[os];
    n || yy(e, os, n = /* @__PURE__ */ new Set()), n.has(t) || (n.add(t), e.observerAdded && e.observerAdded(n.size, t));
  }
  return t;
}
function El(e, t) {
  const n = e[os];
  if (n && n.has(t)) {
    const r = n.size - 1;
    r ? n.delete(t) : e[os] = null, e.observerRemoved && e.observerRemoved(r, t);
  }
}
var yy = (e, t, n) => Object.defineProperty(e, t, {
  value: n,
  writable: !0,
  configurable: !0
}), Zu = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Ob = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Lp = new RegExp(`(${Zu.source})(%|[a-z]+)`, "i"), Fb = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, $c = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/, gy = (e) => {
  const [t, n] = Mb(e);
  if (!t || lf())
    return e;
  const r = window.getComputedStyle(document.documentElement).getPropertyValue(t);
  if (r)
    return r.trim();
  if (n && n.startsWith("--")) {
    const i = window.getComputedStyle(document.documentElement).getPropertyValue(n);
    return i || e;
  } else {
    if (n && $c.test(n))
      return gy(n);
    if (n)
      return n;
  }
  return e;
}, Mb = (e) => {
  const t = $c.exec(e);
  if (!t)
    return [,];
  const [, n, r] = t;
  return [n, r];
}, Qd, Ib = (e, t, n, r, i) => `rgba(${Math.round(t)}, ${Math.round(n)}, ${Math.round(r)}, ${i})`, vy = (e) => {
  Qd || (Qd = Zi ? (
    // match color names, ignore partial matches
    new RegExp(`(${Object.keys(Zi).join("|")})(?!\\w)`, "g")
  ) : (
    // never match
    /^\b$/
  ));
  const t = e.output.map((o) => Tr(o).replace($c, gy).replace(Ob, wp).replace(Qd, wp)), n = t.map((o) => o.match(Zu).map(Number)), i = n[0].map(
    (o, h) => n.map((u) => {
      if (!(h in u))
        throw Error('The arity of each "output" value must be equal');
      return u[h];
    })
  ).map(
    (o) => Cl({ ...e, output: o })
  );
  return (o) => {
    var d;
    const h = !Lp.test(t[0]) && ((d = t.find((p) => Lp.test(p))) == null ? void 0 : d.replace(Zu, ""));
    let u = 0;
    return t[0].replace(
      Zu,
      () => `${i[u++](o)}${h || ""}`
    ).replace(Fb, Ib);
  };
}, df = "react-spring: ", by = (e) => {
  const t = e;
  let n = !1;
  if (typeof t != "function")
    throw new TypeError(`${df}once requires a function parameter`);
  return (...r) => {
    n || (t(...r), n = !0);
  };
}, Bb = by(console.warn);
function zb() {
  Bb(
    `${df}The "interpolate" function is deprecated in v9 (use "to" instead)`
  );
}
var $b = by(console.warn);
function Hb() {
  $b(
    `${df}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
  );
}
function Hc(e) {
  return We.str(e) && (e[0] == "#" || /\d/.test(e) || // Do not identify a CSS variable as an AnimatedString if its SSR
  !lf() && $c.test(e) || e in (Zi || {}));
}
var Jo = lf() ? he.useEffect : he.useLayoutEffect, Vb = () => {
  const e = he.useRef(!1);
  return Jo(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
};
function xy() {
  const e = he.useState()[1], t = Vb();
  return () => {
    t.current && e(Math.random());
  };
}
function Wb(e, t) {
  const [n] = he.useState(
    () => ({
      inputs: t,
      result: e()
    })
  ), r = he.useRef(), i = r.current;
  let o = i;
  return o ? t && o.inputs && jb(t, o.inputs) || (o = {
    inputs: t,
    result: e()
  }) : o = n, he.useEffect(() => {
    r.current = o, i == n && (n.inputs = n.result = void 0);
  }, [o]), o.result;
}
function jb(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
var Sy = (e) => he.useEffect(e, Kb), Kb = [];
function Ub(e) {
  const t = he.useRef();
  return he.useEffect(() => {
    t.current = e;
  }), t.current;
}
var _l = Symbol.for("Animated:node"), Gb = (e) => !!e && e[_l] === e, si = (e) => e && e[_l], hf = (e, t) => fb(e, _l, t), Vc = (e) => e && e[_l] && e[_l].getPayload(), wy = class {
  constructor() {
    hf(this, this);
  }
  /** Get every `AnimatedValue` used by this node. */
  getPayload() {
    return this.payload || [];
  }
}, Bl = class extends wy {
  constructor(e) {
    super(), this._value = e, this.done = !0, this.durationProgress = 0, We.num(this._value) && (this.lastPosition = this._value);
  }
  /** @internal */
  static create(e) {
    return new Bl(e);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(e, t) {
    return We.num(e) && (this.lastPosition = e, t && (e = Math.round(e / t) * t, this.done && (this.lastPosition = e))), this._value === e ? !1 : (this._value = e, !0);
  }
  reset() {
    const { done: e } = this;
    this.done = !1, We.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null);
  }
}, Pl = class extends Bl {
  constructor(e) {
    super(0), this._string = null, this._toString = Cl({
      output: [e, e]
    });
  }
  /** @internal */
  static create(e) {
    return new Pl(e);
  }
  getValue() {
    const e = this._string;
    return e ?? (this._string = this._toString(this._value));
  }
  setValue(e) {
    if (We.str(e)) {
      if (e == this._string)
        return !1;
      this._string = e, this._value = 1;
    } else if (super.setValue(e))
      this._string = null;
    else
      return !1;
    return !0;
  }
  reset(e) {
    e && (this._toString = Cl({
      output: [this.getValue(), e]
    })), this._value = 0, super.reset();
  }
}, hc = { dependencies: null }, Wc = class extends wy {
  constructor(e) {
    super(), this.source = e, this.setValue(e);
  }
  getValue(e) {
    const t = {};
    return li(this.source, (n, r) => {
      Gb(n) ? t[r] = n.getValue(e) : Fr(n) ? t[r] = Tr(n) : e || (t[r] = n);
    }), t;
  }
  /** Replace the raw object data */
  setValue(e) {
    this.source = e, this.payload = this._makePayload(e);
  }
  reset() {
    this.payload && Pt(this.payload, (e) => e.reset());
  }
  /** Create a payload set. */
  _makePayload(e) {
    if (e) {
      const t = /* @__PURE__ */ new Set();
      return li(e, this._addToPayload, t), Array.from(t);
    }
  }
  /** Add to a payload set. */
  _addToPayload(e) {
    hc.dependencies && Fr(e) && hc.dependencies.add(e);
    const t = Vc(e);
    t && Pt(t, (n) => this.add(n));
  }
}, ky = class extends Wc {
  constructor(e) {
    super(e);
  }
  /** @internal */
  static create(e) {
    return new ky(e);
  }
  getValue() {
    return this.source.map((e) => e.getValue());
  }
  setValue(e) {
    const t = this.getPayload();
    return e.length == t.length ? t.map((n, r) => n.setValue(e[r])).some(Boolean) : (super.setValue(e.map(Yb)), !0);
  }
};
function Yb(e) {
  return (Hc(e) ? Pl : Bl).create(e);
}
function kh(e) {
  const t = si(e);
  return t ? t.constructor : We.arr(e) ? ky : Hc(e) ? Pl : Bl;
}
var Ep = (e, t) => {
  const n = (
    // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !We.fun(e) || e.prototype && e.prototype.isReactComponent
  );
  return he.forwardRef((r, i) => {
    const o = he.useRef(null), h = n && // eslint-disable-next-line react-hooks/rules-of-hooks
    he.useCallback(
      (k) => {
        o.current = Zb(i, k);
      },
      [i]
    ), [u, d] = qb(r, t), p = xy(), m = () => {
      const k = o.current;
      if (n && !k)
        return;
      (k ? t.applyAnimatedValues(k, u.getValue(!0)) : !1) === !1 && p();
    }, g = new Xb(m, d), x = he.useRef();
    Jo(() => (x.current = g, Pt(d, (k) => us(k, g)), () => {
      x.current && (Pt(
        x.current.deps,
        (k) => El(k, x.current)
      ), Et.cancel(x.current.update));
    })), he.useEffect(m, []), Sy(() => () => {
      const k = x.current;
      Pt(k.deps, (y) => El(y, k));
    });
    const A = t.getComponentProps(u.getValue());
    return /* @__PURE__ */ he.createElement(e, { ...A, ref: h });
  });
}, Xb = class {
  constructor(e, t) {
    this.update = e, this.deps = t;
  }
  eventObserved(e) {
    e.type == "change" && Et.write(this.update);
  }
};
function qb(e, t) {
  const n = /* @__PURE__ */ new Set();
  return hc.dependencies = n, e.style && (e = {
    ...e,
    style: t.createAnimatedStyle(e.style)
  }), e = new Wc(e), hc.dependencies = null, [e, n];
}
function Zb(e, t) {
  return e && (We.fun(e) ? e(t) : e.current = t), t;
}
var _p = Symbol.for("AnimatedComponent"), Qb = (e, {
  applyAnimatedValues: t = () => !1,
  createAnimatedStyle: n = (i) => new Wc(i),
  getComponentProps: r = (i) => i
} = {}) => {
  const i = {
    applyAnimatedValues: t,
    createAnimatedStyle: n,
    getComponentProps: r
  }, o = (h) => {
    const u = Pp(h) || "Anonymous";
    return We.str(h) ? h = o[h] || (o[h] = Ep(h, i)) : h = h[_p] || (h[_p] = Ep(h, i)), h.displayName = `Animated(${u})`, h;
  };
  return li(e, (h, u) => {
    We.arr(e) && (u = Pp(h)), o[u] = o(h);
  }), {
    animated: o
  };
}, Pp = (e) => We.str(e) ? e : e && We.str(e.displayName) ? e.displayName : We.fun(e) && e.name || null;
function Cr(e, ...t) {
  return We.fun(e) ? e(...t) : e;
}
var yl = (e, t) => e === !0 || !!(t && e && (We.fun(e) ? e(t) : mr(e).includes(t))), Ty = (e, t) => We.obj(e) ? t && e[t] : e, Cy = (e, t) => e.default === !0 ? e[t] : e.default ? e.default[t] : void 0, Jb = (e) => e, ff = (e, t = Jb) => {
  let n = ex;
  e.default && e.default !== !0 && (e = e.default, n = Object.keys(e));
  const r = {};
  for (const i of n) {
    const o = t(e[i], i);
    We.und(o) || (r[i] = o);
  }
  return r;
}, ex = [
  "config",
  "onProps",
  "onStart",
  "onChange",
  "onPause",
  "onResume",
  "onRest"
], tx = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  // Transition props
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  // Internal props
  keys: 1,
  callId: 1,
  parentId: 1
};
function nx(e) {
  const t = {};
  let n = 0;
  if (li(e, (r, i) => {
    tx[i] || (t[i] = r, n++);
  }), n)
    return t;
}
function pf(e) {
  const t = nx(e);
  if (t) {
    const n = { to: t };
    return li(e, (r, i) => i in t || (n[i] = r)), n;
  }
  return { ...e };
}
function Nl(e) {
  return e = Tr(e), We.arr(e) ? e.map(Nl) : Hc(e) ? Xr.createStringInterpolator({
    range: [0, 1],
    output: [e, e]
  })(1) : e;
}
function rx(e) {
  for (const t in e)
    return !0;
  return !1;
}
function Th(e) {
  return We.fun(e) || We.arr(e) && We.obj(e[0]);
}
function Np(e, t) {
  var n;
  (n = e.ref) == null || n.delete(e), t == null || t.delete(e);
}
function ix(e, t) {
  var n;
  t && e.ref !== t && ((n = e.ref) == null || n.delete(e), t.add(e), e.ref = t);
}
var ax = {
  default: { tension: 170, friction: 26 },
  gentle: { tension: 120, friction: 14 },
  wobbly: { tension: 180, friction: 12 },
  stiff: { tension: 210, friction: 20 },
  slow: { tension: 280, friction: 60 },
  molasses: { tension: 280, friction: 120 }
}, Ch = {
  ...ax.default,
  mass: 1,
  damping: 1,
  easing: Nb.linear,
  clamp: !1
}, ox = class {
  constructor() {
    this.velocity = 0, Object.assign(this, Ch);
  }
};
function sx(e, t, n) {
  n && (n = { ...n }, Rp(n, t), t = { ...n, ...t }), Rp(e, t), Object.assign(e, t);
  for (const h in Ch)
    e[h] == null && (e[h] = Ch[h]);
  let { frequency: r, damping: i } = e;
  const { mass: o } = e;
  return We.und(r) || (r < 0.01 && (r = 0.01), i < 0 && (i = 0), e.tension = Math.pow(2 * Math.PI / r, 2) * o, e.friction = 4 * Math.PI * i * o / r), e;
}
function Rp(e, t) {
  if (!We.und(t.decay))
    e.duration = void 0;
  else {
    const n = !We.und(t.tension) || !We.und(t.friction);
    (n || !We.und(t.frequency) || !We.und(t.damping) || !We.und(t.mass)) && (e.duration = void 0, e.decay = void 0), n && (e.frequency = void 0);
  }
}
var Dp = [], lx = class {
  constructor() {
    this.changed = !1, this.values = Dp, this.toValues = null, this.fromValues = Dp, this.config = new ox(), this.immediate = !1;
  }
};
function Ay(e, { key: t, props: n, defaultProps: r, state: i, actions: o }) {
  return new Promise((h, u) => {
    let d, p, m = yl(n.cancel ?? (r == null ? void 0 : r.cancel), t);
    if (m)
      A();
    else {
      We.und(n.pause) || (i.paused = yl(n.pause, t));
      let k = r == null ? void 0 : r.pause;
      k !== !0 && (k = i.paused || yl(k, t)), d = Cr(n.delay || 0, t), k ? (i.resumeQueue.add(x), o.pause()) : (o.resume(), x());
    }
    function g() {
      i.resumeQueue.add(x), i.timeouts.delete(p), p.cancel(), d = p.time - Et.now();
    }
    function x() {
      d > 0 && !Xr.skipAnimation ? (i.delayed = !0, p = Et.setTimeout(A, d), i.pauseQueue.add(g), i.timeouts.add(p)) : A();
    }
    function A() {
      i.delayed && (i.delayed = !1), i.pauseQueue.delete(g), i.timeouts.delete(p), e <= (i.cancelId || 0) && (m = !0);
      try {
        o.start({ ...n, callId: e, cancel: m }, h);
      } catch (k) {
        u(k);
      }
    }
  });
}
var mf = (e, t) => t.length == 1 ? t[0] : t.some((n) => n.cancelled) ? rs(e.get()) : t.every((n) => n.noop) ? Ly(e.get()) : Ur(
  e.get(),
  t.every((n) => n.finished)
), Ly = (e) => ({
  value: e,
  noop: !0,
  finished: !0,
  cancelled: !1
}), Ur = (e, t, n = !1) => ({
  value: e,
  finished: t,
  cancelled: n
}), rs = (e) => ({
  value: e,
  cancelled: !0,
  finished: !1
});
function Ey(e, t, n, r) {
  const { callId: i, parentId: o, onRest: h } = t, { asyncTo: u, promise: d } = n;
  return !o && e === u && !t.reset ? d : n.promise = (async () => {
    n.asyncId = i, n.asyncTo = e;
    const p = ff(
      t,
      (v, S) => (
        // The `onRest` prop is only called when the `runAsync` promise is resolved.
        S === "onRest" ? void 0 : v
      )
    );
    let m, g;
    const x = new Promise(
      (v, S) => (m = v, g = S)
    ), A = (v) => {
      const S = (
        // The `cancel` prop or `stop` method was used.
        i <= (n.cancelId || 0) && rs(r) || // The async `to` prop was replaced.
        i !== n.asyncId && Ur(r, !1)
      );
      if (S)
        throw v.result = S, g(v), v;
    }, k = (v, S) => {
      const B = new Op(), R = new Fp();
      return (async () => {
        if (Xr.skipAnimation)
          throw Rl(n), R.result = Ur(r, !1), g(R), R;
        A(B);
        const N = We.obj(v) ? { ...v } : { ...S, to: v };
        N.parentId = i, li(p, (L, q) => {
          We.und(N[q]) && (N[q] = L);
        });
        const D = await r.start(N);
        return A(B), n.paused && await new Promise((L) => {
          n.resumeQueue.add(L);
        }), D;
      })();
    };
    let y;
    if (Xr.skipAnimation)
      return Rl(n), Ur(r, !1);
    try {
      let v;
      We.arr(e) ? v = (async (S) => {
        for (const B of S)
          await k(B);
      })(e) : v = Promise.resolve(e(k, r.stop.bind(r))), await Promise.all([v.then(m), x]), y = Ur(r.get(), !0, !1);
    } catch (v) {
      if (v instanceof Op)
        y = v.result;
      else if (v instanceof Fp)
        y = v.result;
      else
        throw v;
    } finally {
      i == n.asyncId && (n.asyncId = o, n.asyncTo = o ? u : void 0, n.promise = o ? d : void 0);
    }
    return We.fun(h) && Et.batchedUpdates(() => {
      h(y, r, r.item);
    }), y;
  })();
}
function Rl(e, t) {
  pl(e.timeouts, (n) => n.cancel()), e.pauseQueue.clear(), e.resumeQueue.clear(), e.asyncId = e.asyncTo = e.promise = void 0, t && (e.cancelId = t);
}
var Op = class extends Error {
  constructor() {
    super(
      "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
    );
  }
}, Fp = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
}, Ah = (e) => e instanceof yf, ux = 1, yf = class extends my {
  constructor() {
    super(...arguments), this.id = ux++, this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(e) {
    this._priority != e && (this._priority = e, this._onPriorityChange(e));
  }
  /** Get the current value */
  get() {
    const e = si(this);
    return e && e.getValue();
  }
  /** Create a spring that maps our value to another value */
  to(...e) {
    return Xr.to(this, e);
  }
  /** @deprecated Use the `to` method instead. */
  interpolate(...e) {
    return zb(), Xr.to(this, e);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(e) {
    e == 1 && this._attach();
  }
  observerRemoved(e) {
    e == 0 && this._detach();
  }
  /** Called when the first child is added. */
  _attach() {
  }
  /** Called when the last child is removed. */
  _detach() {
  }
  /** Tell our children about our new value */
  _onChange(e, t = !1) {
    Ll(this, {
      type: "change",
      parent: this,
      value: e,
      idle: t
    });
  }
  /** Tell our children about our new priority */
  _onPriorityChange(e) {
    this.idle || Bc.sort(this), Ll(this, {
      type: "priority",
      parent: this,
      priority: e
    });
  }
}, ja = Symbol.for("SpringPhase"), _y = 1, Lh = 2, Eh = 4, Jd = (e) => (e[ja] & _y) > 0, Ki = (e) => (e[ja] & Lh) > 0, sl = (e) => (e[ja] & Eh) > 0, Mp = (e, t) => t ? e[ja] |= Lh | _y : e[ja] &= ~Lh, Ip = (e, t) => t ? e[ja] |= Eh : e[ja] &= ~Eh, cx = class extends yf {
  constructor(e, t) {
    if (super(), this.animation = new lx(), this.defaultProps = {}, this._state = {
      paused: !1,
      delayed: !1,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._pendingCalls = /* @__PURE__ */ new Set(), this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !We.und(e) || !We.und(t)) {
      const n = We.obj(e) ? { ...e } : { ...t, from: e };
      We.und(n.default) && (n.default = !0), this.start(n);
    }
  }
  /** Equals true when not advancing on each frame. */
  get idle() {
    return !(Ki(this) || this._state.asyncTo) || sl(this);
  }
  get goal() {
    return Tr(this.animation.to);
  }
  get velocity() {
    const e = si(this);
    return e instanceof Bl ? e.lastVelocity || 0 : e.getPayload().map((t) => t.lastVelocity || 0);
  }
  /**
   * When true, this value has been animated at least once.
   */
  get hasAnimated() {
    return Jd(this);
  }
  /**
   * When true, this value has an unfinished animation,
   * which is either active or paused.
   */
  get isAnimating() {
    return Ki(this);
  }
  /**
   * When true, all current and future animations are paused.
   */
  get isPaused() {
    return sl(this);
  }
  /**
   *
   *
   */
  get isDelayed() {
    return this._state.delayed;
  }
  /** Advance the current animation by a number of milliseconds */
  advance(e) {
    let t = !0, n = !1;
    const r = this.animation;
    let { toValues: i } = r;
    const { config: o } = r, h = Vc(r.to);
    !h && Fr(r.to) && (i = mr(Tr(r.to))), r.values.forEach((p, m) => {
      if (p.done)
        return;
      const g = (
        // Animated strings always go from 0 to 1.
        p.constructor == Pl ? 1 : h ? h[m].lastPosition : i[m]
      );
      let x = r.immediate, A = g;
      if (!x) {
        if (A = p.lastPosition, o.tension <= 0) {
          p.done = !0;
          return;
        }
        let k = p.elapsedTime += e;
        const y = r.fromValues[m], v = p.v0 != null ? p.v0 : p.v0 = We.arr(o.velocity) ? o.velocity[m] : o.velocity;
        let S;
        const B = o.precision || (y == g ? 5e-3 : Math.min(1, Math.abs(g - y) * 1e-3));
        if (We.und(o.duration))
          if (o.decay) {
            const R = o.decay === !0 ? 0.998 : o.decay, N = Math.exp(-(1 - R) * k);
            A = y + v / (1 - R) * (1 - N), x = Math.abs(p.lastPosition - A) <= B, S = v * N;
          } else {
            S = p.lastVelocity == null ? v : p.lastVelocity;
            const R = o.restVelocity || B / 10, N = o.clamp ? 0 : o.bounce, D = !We.und(N), L = y == g ? p.v0 > 0 : y < g;
            let q, V = !1;
            const ae = 1, Y = Math.ceil(e / ae);
            for (let Q = 0; Q < Y && (q = Math.abs(S) > R, !(!q && (x = Math.abs(g - A) <= B, x))); ++Q) {
              D && (V = A == g || A > g == L, V && (S = -S * N, A = g));
              const se = -o.tension * 1e-6 * (A - g), ie = -o.friction * 1e-3 * S, M = (se + ie) / o.mass;
              S = S + M * ae, A = A + S * ae;
            }
          }
        else {
          let R = 1;
          o.duration > 0 && (this._memoizedDuration !== o.duration && (this._memoizedDuration = o.duration, p.durationProgress > 0 && (p.elapsedTime = o.duration * p.durationProgress, k = p.elapsedTime += e)), R = (o.progress || 0) + k / this._memoizedDuration, R = R > 1 ? 1 : R < 0 ? 0 : R, p.durationProgress = R), A = y + o.easing(R) * (g - y), S = (A - p.lastPosition) / e, x = R == 1;
        }
        p.lastVelocity = S, Number.isNaN(A) && (console.warn("Got NaN while animating:", this), x = !0);
      }
      h && !h[m].done && (x = !1), x ? p.done = !0 : t = !1, p.setValue(A, o.round) && (n = !0);
    });
    const u = si(this), d = u.getValue();
    if (t) {
      const p = Tr(r.to);
      (d !== p || n) && !o.decay ? (u.setValue(p), this._onChange(p)) : n && o.decay && this._onChange(d), this._stop();
    } else
      n && this._onChange(d);
  }
  /** Set the current value, while stopping the current animation */
  set(e) {
    return Et.batchedUpdates(() => {
      this._stop(), this._focus(e), this._set(e);
    }), this;
  }
  /**
   * Freeze the active animation in time, as well as any updates merged
   * before `resume` is called.
   */
  pause() {
    this._update({ pause: !0 });
  }
  /** Resume the animation if paused. */
  resume() {
    this._update({ pause: !1 });
  }
  /** Skip to the end of the current animation. */
  finish() {
    if (Ki(this)) {
      const { to: e, config: t } = this.animation;
      Et.batchedUpdates(() => {
        this._onStart(), t.decay || this._set(e, !1), this._stop();
      });
    }
    return this;
  }
  /** Push props into the pending queue. */
  update(e) {
    return (this.queue || (this.queue = [])).push(e), this;
  }
  start(e, t) {
    let n;
    return We.und(e) ? (n = this.queue || [], this.queue = []) : n = [We.obj(e) ? e : { ...t, to: e }], Promise.all(
      n.map((r) => this._update(r))
    ).then((r) => mf(this, r));
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   *
   * Pass `true` to call `onRest` with `cancelled: true`.
   */
  stop(e) {
    const { to: t } = this.animation;
    return this._focus(this.get()), Rl(this._state, e && this._lastCallId), Et.batchedUpdates(() => this._stop(t, e)), this;
  }
  /** Restart the animation. */
  reset() {
    this._update({ reset: !0 });
  }
  /** @internal */
  eventObserved(e) {
    e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1);
  }
  /**
   * Parse the `to` and `from` range from the given `props` object.
   *
   * This also ensures the initial value is available to animated components
   * during the render phase.
   */
  _prepareNode(e) {
    const t = this.key || "";
    let { to: n, from: r } = e;
    n = We.obj(n) ? n[t] : n, (n == null || Th(n)) && (n = void 0), r = We.obj(r) ? r[t] : r, r == null && (r = void 0);
    const i = { to: n, from: r };
    return Jd(this) || (e.reverse && ([n, r] = [r, n]), r = Tr(r), We.und(r) ? si(this) || this._set(n) : this._set(r)), i;
  }
  /** Every update is processed by this method before merging. */
  _update({ ...e }, t) {
    const { key: n, defaultProps: r } = this;
    e.default && Object.assign(
      r,
      ff(
        e,
        (h, u) => /^on/.test(u) ? Ty(h, n) : h
      )
    ), zp(this, e, "onProps"), ul(this, "onProps", e, this);
    const i = this._prepareNode(e);
    if (Object.isFrozen(this))
      throw Error(
        "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
      );
    const o = this._state;
    return Ay(++this._lastCallId, {
      key: n,
      props: e,
      defaultProps: r,
      state: o,
      actions: {
        pause: () => {
          sl(this) || (Ip(this, !0), hl(o.pauseQueue), ul(
            this,
            "onPause",
            Ur(this, ll(this, this.animation.to)),
            this
          ));
        },
        resume: () => {
          sl(this) && (Ip(this, !1), Ki(this) && this._resume(), hl(o.resumeQueue), ul(
            this,
            "onResume",
            Ur(this, ll(this, this.animation.to)),
            this
          ));
        },
        start: this._merge.bind(this, i)
      }
    }).then((h) => {
      if (e.loop && h.finished && !(t && h.noop)) {
        const u = Py(e);
        if (u)
          return this._update(u, !0);
      }
      return h;
    });
  }
  /** Merge props into the current animation */
  _merge(e, t, n) {
    if (t.cancel)
      return this.stop(!0), n(rs(this));
    const r = !We.und(e.to), i = !We.und(e.from);
    if (r || i)
      if (t.callId > this._lastToId)
        this._lastToId = t.callId;
      else
        return n(rs(this));
    const { key: o, defaultProps: h, animation: u } = this, { to: d, from: p } = u;
    let { to: m = d, from: g = p } = e;
    i && !r && (!t.default || We.und(m)) && (m = g), t.reverse && ([m, g] = [g, m]);
    const x = !ki(g, p);
    x && (u.from = g), g = Tr(g);
    const A = !ki(m, d);
    A && this._focus(m);
    const k = Th(t.to), { config: y } = u, { decay: v, velocity: S } = y;
    (r || i) && (y.velocity = 0), t.config && !k && sx(
      y,
      Cr(t.config, o),
      // Avoid calling the same "config" prop twice.
      t.config !== h.config ? Cr(h.config, o) : void 0
    );
    let B = si(this);
    if (!B || We.und(m))
      return n(Ur(this, !0));
    const R = (
      // When `reset` is undefined, the `from` prop implies `reset: true`,
      // except for declarative updates. When `reset` is defined, there
      // must exist a value to animate from.
      We.und(t.reset) ? i && !t.default : !We.und(g) && yl(t.reset, o)
    ), N = R ? g : this.get(), D = Nl(m), L = We.num(D) || We.arr(D) || Hc(D), q = !k && (!L || yl(h.immediate || t.immediate, o));
    if (A) {
      const Q = kh(m);
      if (Q !== B.constructor)
        if (q)
          B = this._set(D);
        else
          throw Error(
            `Cannot animate between ${B.constructor.name} and ${Q.name}, as the "to" prop suggests`
          );
    }
    const V = B.constructor;
    let ae = Fr(m), Y = !1;
    if (!ae) {
      const Q = R || !Jd(this) && x;
      (A || Q) && (Y = ki(Nl(N), D), ae = !Y), (!ki(u.immediate, q) && !q || !ki(y.decay, v) || !ki(y.velocity, S)) && (ae = !0);
    }
    if (Y && Ki(this) && (u.changed && !R ? ae = !0 : ae || this._stop(d)), !k && ((ae || Fr(d)) && (u.values = B.getPayload(), u.toValues = Fr(m) ? null : V == Pl ? [1] : mr(D)), u.immediate != q && (u.immediate = q, !q && !R && this._set(d)), ae)) {
      const { onRest: Q } = u;
      Pt(dx, (ie) => zp(this, t, ie));
      const se = Ur(this, ll(this, d));
      hl(this._pendingCalls, se), this._pendingCalls.add(n), u.changed && Et.batchedUpdates(() => {
        var ie;
        u.changed = !R, Q == null || Q(se, this), R ? Cr(h.onRest, se) : (ie = u.onStart) == null || ie.call(u, se, this);
      });
    }
    R && this._set(N), k ? n(Ey(t.to, t, this._state, this)) : ae ? this._start() : Ki(this) && !A ? this._pendingCalls.add(n) : n(Ly(N));
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  _focus(e) {
    const t = this.animation;
    e !== t.to && (Ap(this) && this._detach(), t.to = e, Ap(this) && this._attach());
  }
  _attach() {
    let e = 0;
    const { to: t } = this.animation;
    Fr(t) && (us(t, this), Ah(t) && (e = t.priority + 1)), this.priority = e;
  }
  _detach() {
    const { to: e } = this.animation;
    Fr(e) && El(e, this);
  }
  /**
   * Update the current value from outside the frameloop,
   * and return the `Animated` node.
   */
  _set(e, t = !0) {
    const n = Tr(e);
    if (!We.und(n)) {
      const r = si(this);
      if (!r || !ki(n, r.getValue())) {
        const i = kh(n);
        !r || r.constructor != i ? hf(this, i.create(n)) : r.setValue(n), r && Et.batchedUpdates(() => {
          this._onChange(n, t);
        });
      }
    }
    return si(this);
  }
  _onStart() {
    const e = this.animation;
    e.changed || (e.changed = !0, ul(
      this,
      "onStart",
      Ur(this, ll(this, e.to)),
      this
    ));
  }
  _onChange(e, t) {
    t || (this._onStart(), Cr(this.animation.onChange, e, this)), Cr(this.defaultProps.onChange, e, this), super._onChange(e, t);
  }
  // This method resets the animation state (even if already animating) to
  // ensure the latest from/to range is used, and it also ensures this spring
  // is added to the frameloop.
  _start() {
    const e = this.animation;
    si(this).reset(Tr(e.to)), e.immediate || (e.fromValues = e.values.map((t) => t.lastPosition)), Ki(this) || (Mp(this, !0), sl(this) || this._resume());
  }
  _resume() {
    Xr.skipAnimation ? this.finish() : Bc.start(this);
  }
  /**
   * Exit the frameloop and notify `onRest` listeners.
   *
   * Always wrap `_stop` calls with `batchedUpdates`.
   */
  _stop(e, t) {
    if (Ki(this)) {
      Mp(this, !1);
      const n = this.animation;
      Pt(n.values, (i) => {
        i.done = !0;
      }), n.toValues && (n.onChange = n.onPause = n.onResume = void 0), Ll(this, {
        type: "idle",
        parent: this
      });
      const r = t ? rs(this.get()) : Ur(this.get(), ll(this, e ?? n.to));
      hl(this._pendingCalls, r), n.changed && (n.changed = !1, ul(this, "onRest", r, this));
    }
  }
};
function ll(e, t) {
  const n = Nl(t), r = Nl(e.get());
  return ki(r, n);
}
function Py(e, t = e.loop, n = e.to) {
  const r = Cr(t);
  if (r) {
    const i = r !== !0 && pf(r), o = (i || e).reverse, h = !i || i.reset;
    return fc({
      ...e,
      loop: t,
      // Avoid updating default props when looping.
      default: !1,
      // Never loop the `pause` prop.
      pause: void 0,
      // For the "reverse" prop to loop as expected, the "to" prop
      // must be undefined. The "reverse" prop is ignored when the
      // "to" prop is an array or function.
      to: !o || Th(n) ? n : void 0,
      // Ignore the "from" prop except on reset.
      from: h ? e.from : void 0,
      reset: h,
      // The "loop" prop can return a "useSpring" props object to
      // override any of the original props.
      ...i
    });
  }
}
function fc(e) {
  const { to: t, from: n } = e = pf(e), r = /* @__PURE__ */ new Set();
  return We.obj(t) && Bp(t, r), We.obj(n) && Bp(n, r), e.keys = r.size ? Array.from(r) : null, e;
}
function Bp(e, t) {
  li(e, (n, r) => n != null && t.add(r));
}
var dx = [
  "onStart",
  "onRest",
  "onChange",
  "onPause",
  "onResume"
];
function zp(e, t, n) {
  e.animation[n] = t[n] !== Cy(t, n) ? Ty(t[n], e.key) : void 0;
}
function ul(e, t, ...n) {
  var r, i, o, h;
  (i = (r = e.animation)[t]) == null || i.call(r, ...n), (h = (o = e.defaultProps)[t]) == null || h.call(o, ...n);
}
var hx = ["onStart", "onChange", "onRest"], fx = 1, px = class {
  constructor(e, t) {
    this.id = fx++, this.springs = {}, this.queue = [], this._lastAsyncId = 0, this._active = /* @__PURE__ */ new Set(), this._changed = /* @__PURE__ */ new Set(), this._started = !1, this._state = {
      paused: !1,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    }, this._onFrame = this._onFrame.bind(this), t && (this._flush = t), e && this.start({ default: !0, ...e });
  }
  /**
   * Equals `true` when no spring values are in the frameloop, and
   * no async animation is currently active.
   */
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((e) => e.idle && !e.isDelayed && !e.isPaused);
  }
  get item() {
    return this._item;
  }
  set item(e) {
    this._item = e;
  }
  /** Get the current values of our springs */
  get() {
    const e = {};
    return this.each((t, n) => e[n] = t.get()), e;
  }
  /** Set the current values without animating. */
  set(e) {
    for (const t in e) {
      const n = e[t];
      We.und(n) || this.springs[t].set(n);
    }
  }
  /** Push an update onto the queue of each value. */
  update(e) {
    return e && this.queue.push(fc(e)), this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  start(e) {
    let { queue: t } = this;
    return e ? t = mr(e).map(fc) : this.queue = [], this._flush ? this._flush(this, t) : (Oy(this, t), mx(this, t));
  }
  /** @internal */
  stop(e, t) {
    if (e !== !!e && (t = e), t) {
      const n = this.springs;
      Pt(mr(t), (r) => n[r].stop(!!e));
    } else
      Rl(this._state, this._lastAsyncId), this.each((n) => n.stop(!!e));
    return this;
  }
  /** Freeze the active animation in time */
  pause(e) {
    if (We.und(e))
      this.start({ pause: !0 });
    else {
      const t = this.springs;
      Pt(mr(e), (n) => t[n].pause());
    }
    return this;
  }
  /** Resume the animation if paused. */
  resume(e) {
    if (We.und(e))
      this.start({ pause: !1 });
    else {
      const t = this.springs;
      Pt(mr(e), (n) => t[n].resume());
    }
    return this;
  }
  /** Call a function once per spring value */
  each(e) {
    li(this.springs, e);
  }
  /** @internal Called at the end of every animation frame */
  _onFrame() {
    const { onStart: e, onChange: t, onRest: n } = this._events, r = this._active.size > 0, i = this._changed.size > 0;
    (r && !this._started || i && !this._started) && (this._started = !0, pl(e, ([u, d]) => {
      d.value = this.get(), u(d, this, this._item);
    }));
    const o = !r && this._started, h = i || o && n.size ? this.get() : null;
    i && t.size && pl(t, ([u, d]) => {
      d.value = h, u(d, this, this._item);
    }), o && (this._started = !1, pl(n, ([u, d]) => {
      d.value = h, u(d, this, this._item);
    }));
  }
  /** @internal */
  eventObserved(e) {
    if (e.type == "change")
      this._changed.add(e.parent), e.idle || this._active.add(e.parent);
    else if (e.type == "idle")
      this._active.delete(e.parent);
    else
      return;
    Et.onFrame(this._onFrame);
  }
};
function mx(e, t) {
  return Promise.all(t.map((n) => Ny(e, n))).then(
    (n) => mf(e, n)
  );
}
async function Ny(e, t, n) {
  const { keys: r, to: i, from: o, loop: h, onRest: u, onResolve: d } = t, p = We.obj(t.default) && t.default;
  h && (t.loop = !1), i === !1 && (t.to = null), o === !1 && (t.from = null);
  const m = We.arr(i) || We.fun(i) ? i : void 0;
  m ? (t.to = void 0, t.onRest = void 0, p && (p.onRest = void 0)) : Pt(hx, (y) => {
    const v = t[y];
    if (We.fun(v)) {
      const S = e._events[y];
      t[y] = ({ finished: B, cancelled: R }) => {
        const N = S.get(v);
        N ? (B || (N.finished = !1), R && (N.cancelled = !0)) : S.set(v, {
          value: null,
          finished: B || !1,
          cancelled: R || !1
        });
      }, p && (p[y] = t[y]);
    }
  });
  const g = e._state;
  t.pause === !g.paused ? (g.paused = t.pause, hl(t.pause ? g.pauseQueue : g.resumeQueue)) : g.paused && (t.pause = !0);
  const x = (r || Object.keys(e.springs)).map(
    (y) => e.springs[y].start(t)
  ), A = t.cancel === !0 || Cy(t, "cancel") === !0;
  (m || A && g.asyncId) && x.push(
    Ay(++e._lastAsyncId, {
      props: t,
      state: g,
      actions: {
        pause: Sh,
        resume: Sh,
        start(y, v) {
          A ? (Rl(g, e._lastAsyncId), v(rs(e))) : (y.onRest = u, v(
            Ey(
              m,
              y,
              g,
              e
            )
          ));
        }
      }
    })
  ), g.paused && await new Promise((y) => {
    g.resumeQueue.add(y);
  });
  const k = mf(e, await Promise.all(x));
  if (h && k.finished && !(n && k.noop)) {
    const y = Py(t, h, i);
    if (y)
      return Oy(e, [y]), Ny(e, y, !0);
  }
  return d && Et.batchedUpdates(() => d(k, e, e.item)), k;
}
function yx(e, t) {
  const n = { ...e.springs };
  return t && Pt(mr(t), (r) => {
    We.und(r.keys) && (r = fc(r)), We.obj(r.to) || (r = { ...r, to: void 0 }), Dy(n, r, (i) => Ry(i));
  }), gx(e, n), n;
}
function gx(e, t) {
  li(t, (n, r) => {
    e.springs[r] || (e.springs[r] = n, us(n, e));
  });
}
function Ry(e, t) {
  const n = new cx();
  return n.key = e, t && us(n, t), n;
}
function Dy(e, t, n) {
  t.keys && Pt(t.keys, (r) => {
    (e[r] || (e[r] = n(r)))._prepareNode(t);
  });
}
function Oy(e, t) {
  Pt(t, (n) => {
    Dy(e.springs, n, (r) => Ry(r, e));
  });
}
var jc = ({
  children: e,
  ...t
}) => {
  const n = he.useContext(pc), r = t.pause || !!n.pause, i = t.immediate || !!n.immediate;
  t = Wb(() => ({ pause: r, immediate: i }), [r, i]);
  const { Provider: o } = pc;
  return /* @__PURE__ */ he.createElement(o, { value: t }, e);
}, pc = vx(jc, {});
jc.Provider = pc.Provider;
jc.Consumer = pc.Consumer;
function vx(e, t) {
  return Object.assign(e, he.createContext(t)), e.Provider._context = e, e.Consumer._context = e, e;
}
var bx = () => {
  const e = [], t = function(r) {
    Hb();
    const i = [];
    return Pt(e, (o, h) => {
      if (We.und(r))
        i.push(o.start());
      else {
        const u = n(r, o, h);
        u && i.push(o.start(u));
      }
    }), i;
  };
  t.current = e, t.add = function(r) {
    e.includes(r) || e.push(r);
  }, t.delete = function(r) {
    const i = e.indexOf(r);
    ~i && e.splice(i, 1);
  }, t.pause = function() {
    return Pt(e, (r) => r.pause(...arguments)), this;
  }, t.resume = function() {
    return Pt(e, (r) => r.resume(...arguments)), this;
  }, t.set = function(r) {
    Pt(e, (i, o) => {
      const h = We.fun(r) ? r(o, i) : r;
      h && i.set(h);
    });
  }, t.start = function(r) {
    const i = [];
    return Pt(e, (o, h) => {
      if (We.und(r))
        i.push(o.start());
      else {
        const u = this._getProps(r, o, h);
        u && i.push(o.start(u));
      }
    }), i;
  }, t.stop = function() {
    return Pt(e, (r) => r.stop(...arguments)), this;
  }, t.update = function(r) {
    return Pt(e, (i, o) => i.update(this._getProps(r, i, o))), this;
  };
  const n = function(r, i, o) {
    return We.fun(r) ? r(o, i) : r;
  };
  return t._getProps = n, t;
};
function xx(e, t, n) {
  const r = We.fun(t) && t, {
    reset: i,
    sort: o,
    trail: h = 0,
    expires: u = !0,
    exitBeforeEnter: d = !1,
    onDestroyed: p,
    ref: m,
    config: g
  } = r ? r() : t, x = he.useMemo(
    () => r || arguments.length == 3 ? bx() : void 0,
    []
  ), A = mr(e), k = [], y = he.useRef(null), v = i ? null : y.current;
  Jo(() => {
    y.current = k;
  }), Sy(() => (Pt(k, (M) => {
    x == null || x.add(M.ctrl), M.ctrl.ref = x;
  }), () => {
    Pt(y.current, (M) => {
      M.expired && clearTimeout(M.expirationId), Np(M.ctrl, x), M.ctrl.stop(!0);
    });
  }));
  const S = wx(A, r ? r() : t, v), B = i && y.current || [];
  Jo(
    () => Pt(B, ({ ctrl: M, item: U, key: re }) => {
      Np(M, x), Cr(p, U, re);
    })
  );
  const R = [];
  if (v && Pt(v, (M, U) => {
    M.expired ? (clearTimeout(M.expirationId), B.push(M)) : (U = R[U] = S.indexOf(M.key), ~U && (k[U] = M));
  }), Pt(A, (M, U) => {
    k[U] || (k[U] = {
      key: S[U],
      item: M,
      phase: "mount",
      ctrl: new px()
    }, k[U].ctrl.item = M);
  }), R.length) {
    let M = -1;
    const { leave: U } = r ? r() : t;
    Pt(R, (re, j) => {
      const de = v[j];
      ~re ? (M = k.indexOf(de), k[M] = { ...de, item: A[re] }) : U && k.splice(++M, 0, de);
    });
  }
  We.fun(o) && k.sort((M, U) => o(M.item, U.item));
  let N = -h;
  const D = xy(), L = ff(t), q = /* @__PURE__ */ new Map(), V = he.useRef(/* @__PURE__ */ new Map()), ae = he.useRef(!1);
  Pt(k, (M, U) => {
    const re = M.key, j = M.phase, de = r ? r() : t;
    let Z, ge;
    const ne = Cr(de.delay || 0, re);
    if (j == "mount")
      Z = de.enter, ge = "enter";
    else {
      const Se = S.indexOf(re) < 0;
      if (j != "leave")
        if (Se)
          Z = de.leave, ge = "leave";
        else if (Z = de.update)
          ge = "update";
        else
          return;
      else if (!Se)
        Z = de.enter, ge = "enter";
      else
        return;
    }
    if (Z = Cr(Z, M.item, U), Z = We.obj(Z) ? pf(Z) : { to: Z }, !Z.config) {
      const Se = g || L.config;
      Z.config = Cr(Se, M.item, U, ge);
    }
    N += h;
    const G = {
      ...L,
      // we need to add our props.delay value you here.
      delay: ne + N,
      ref: m,
      immediate: de.immediate,
      // This prevents implied resets.
      reset: !1,
      // Merge any phase-specific props.
      ...Z
    };
    if (ge == "enter" && We.und(G.from)) {
      const Se = r ? r() : t, ce = We.und(Se.initial) || v ? Se.from : Se.initial;
      G.from = Cr(ce, M.item, U);
    }
    const { onResolve: me } = G;
    G.onResolve = (Se) => {
      Cr(me, Se);
      const ce = y.current, ke = ce.find((Ie) => Ie.key === re);
      if (ke && !(Se.cancelled && ke.phase != "update") && ke.ctrl.idle) {
        const Ie = ce.every((Le) => Le.ctrl.idle);
        if (ke.phase == "leave") {
          const Le = Cr(u, ke.item);
          if (Le !== !1) {
            const Fe = Le === !0 ? 0 : Le;
            if (ke.expired = !0, !Ie && Fe > 0) {
              Fe <= 2147483647 && (ke.expirationId = setTimeout(D, Fe));
              return;
            }
          }
        }
        Ie && ce.some((Le) => Le.expired) && (V.current.delete(ke), d && (ae.current = !0), D());
      }
    };
    const ye = yx(M.ctrl, G);
    ge === "leave" && d ? V.current.set(M, { phase: ge, springs: ye, payload: G }) : q.set(M, { phase: ge, springs: ye, payload: G });
  });
  const Y = he.useContext(jc), Q = Ub(Y), se = Y !== Q && rx(Y);
  Jo(() => {
    se && Pt(k, (M) => {
      M.ctrl.start({ default: Y });
    });
  }, [Y]), Pt(q, (M, U) => {
    if (V.current.size) {
      const re = k.findIndex((j) => j.key === U.key);
      k.splice(re, 1);
    }
  }), Jo(
    () => {
      Pt(
        V.current.size ? V.current : q,
        ({ phase: M, payload: U }, re) => {
          const { ctrl: j } = re;
          re.phase = M, x == null || x.add(j), se && M == "enter" && j.start({ default: Y }), U && (ix(j, U.ref), (j.ref || x) && !ae.current ? j.update(U) : (j.start(U), ae.current && (ae.current = !1)));
        }
      );
    },
    i ? void 0 : n
  );
  const ie = (M) => /* @__PURE__ */ he.createElement(he.Fragment, null, k.map((U, re) => {
    const { springs: j } = q.get(U) || U.ctrl, de = M({ ...j }, U.item, U, re);
    return de && de.type ? /* @__PURE__ */ he.createElement(
      de.type,
      {
        ...de.props,
        key: We.str(U.key) || We.num(U.key) ? U.key : U.ctrl.id,
        ref: de.ref
      }
    ) : de;
  }));
  return x ? [ie, x] : ie;
}
var Sx = 1;
function wx(e, { key: t, keys: n = t }, r) {
  if (n === null) {
    const i = /* @__PURE__ */ new Set();
    return e.map((o) => {
      const h = r && r.find(
        (u) => u.item === o && u.phase !== "leave" && !i.has(u)
      );
      return h ? (i.add(h), h.key) : Sx++;
    });
  }
  return We.und(n) ? e : We.fun(n) ? e.map(n) : mr(n);
}
var Fy = class extends yf {
  constructor(e, t) {
    super(), this.source = e, this.idle = !0, this._active = /* @__PURE__ */ new Set(), this.calc = Cl(...t);
    const n = this._get(), r = kh(n);
    hf(this, r.create(n));
  }
  advance(e) {
    const t = this._get(), n = this.get();
    ki(t, n) || (si(this).setValue(t), this._onChange(t, this.idle)), !this.idle && $p(this._active) && eh(this);
  }
  _get() {
    const e = We.arr(this.source) ? this.source.map(Tr) : mr(Tr(this.source));
    return this.calc(...e);
  }
  _start() {
    this.idle && !$p(this._active) && (this.idle = !1, Pt(Vc(this), (e) => {
      e.done = !1;
    }), Xr.skipAnimation ? (Et.batchedUpdates(() => this.advance()), eh(this)) : Bc.start(this));
  }
  // Observe our sources only when we're observed.
  _attach() {
    let e = 1;
    Pt(mr(this.source), (t) => {
      Fr(t) && us(t, this), Ah(t) && (t.idle || this._active.add(t), e = Math.max(e, t.priority + 1));
    }), this.priority = e, this._start();
  }
  // Stop observing our sources once we have no observers.
  _detach() {
    Pt(mr(this.source), (e) => {
      Fr(e) && El(e, this);
    }), this._active.clear(), eh(this);
  }
  /** @internal */
  eventObserved(e) {
    e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = mr(this.source).reduce(
      (t, n) => Math.max(t, (Ah(n) ? n.priority : 0) + 1),
      0
    ));
  }
};
function kx(e) {
  return e.idle !== !1;
}
function $p(e) {
  return !e.size || Array.from(e).every(kx);
}
function eh(e) {
  e.idle || (e.idle = !0, Pt(Vc(e), (t) => {
    t.done = !0;
  }), Ll(e, {
    type: "idle",
    parent: e
  }));
}
var Hp = (e, ...t) => new Fy(e, t);
Xr.assign({
  createStringInterpolator: vy,
  to: (e, t) => new Fy(e, t)
});
var My = /^--/;
function Tx(e, t) {
  return t == null || typeof t == "boolean" || t === "" ? "" : typeof t == "number" && t !== 0 && !My.test(e) && !(gl.hasOwnProperty(e) && gl[e]) ? t + "px" : ("" + t).trim();
}
var Vp = {};
function Cx(e, t) {
  if (!e.nodeType || !e.setAttribute)
    return !1;
  const n = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter", {
    className: r,
    style: i,
    children: o,
    scrollTop: h,
    scrollLeft: u,
    viewBox: d,
    ...p
  } = t, m = Object.values(p), g = Object.keys(p).map(
    (x) => n || e.hasAttribute(x) ? x : Vp[x] || (Vp[x] = x.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (A) => "-" + A.toLowerCase()
    ))
  );
  o !== void 0 && (e.textContent = o);
  for (const x in i)
    if (i.hasOwnProperty(x)) {
      const A = Tx(x, i[x]);
      My.test(x) ? e.style.setProperty(x, A) : e.style[x] = A;
    }
  g.forEach((x, A) => {
    e.setAttribute(x, m[A]);
  }), r !== void 0 && (e.className = r), h !== void 0 && (e.scrollTop = h), u !== void 0 && (e.scrollLeft = u), d !== void 0 && e.setAttribute("viewBox", d);
}
var gl = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, Ax = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), Lx = ["Webkit", "Ms", "Moz", "O"];
gl = Object.keys(gl).reduce((e, t) => (Lx.forEach((n) => e[Ax(n, t)] = e[t]), e), gl);
var Ex = /^(matrix|translate|scale|rotate|skew)/, _x = /^(translate)/, Px = /^(rotate|skew)/, th = (e, t) => We.num(e) && e !== 0 ? e + t : e, Qu = (e, t) => We.arr(e) ? e.every((n) => Qu(n, t)) : We.num(e) ? e === t : parseFloat(e) === t, Nx = class extends Wc {
  constructor({ x: e, y: t, z: n, ...r }) {
    const i = [], o = [];
    (e || t || n) && (i.push([e || 0, t || 0, n || 0]), o.push((h) => [
      `translate3d(${h.map((u) => th(u, "px")).join(",")})`,
      // prettier-ignore
      Qu(h, 0)
    ])), li(r, (h, u) => {
      if (u === "transform")
        i.push([h || ""]), o.push((d) => [d, d === ""]);
      else if (Ex.test(u)) {
        if (delete r[u], We.und(h))
          return;
        const d = _x.test(u) ? "px" : Px.test(u) ? "deg" : "";
        i.push(mr(h)), o.push(
          u === "rotate3d" ? ([p, m, g, x]) => [
            `rotate3d(${p},${m},${g},${th(x, d)})`,
            Qu(x, 0)
          ] : (p) => [
            `${u}(${p.map((m) => th(m, d)).join(",")})`,
            Qu(p, u.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    }), i.length && (r.transform = new Rx(i, o)), super(r);
  }
}, Rx = class extends my {
  constructor(e, t) {
    super(), this.inputs = e, this.transforms = t, this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let e = "", t = !0;
    return Pt(this.inputs, (n, r) => {
      const i = Tr(n[0]), [o, h] = this.transforms[r](
        We.arr(i) ? i : n.map(Tr)
      );
      e += " " + o, t = t && h;
    }), t ? "none" : e;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(e) {
    e == 1 && Pt(
      this.inputs,
      (t) => Pt(
        t,
        (n) => Fr(n) && us(n, this)
      )
    );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(e) {
    e == 0 && Pt(
      this.inputs,
      (t) => Pt(
        t,
        (n) => Fr(n) && El(n, this)
      )
    );
  }
  eventObserved(e) {
    e.type == "change" && (this._value = null), Ll(this, e);
  }
}, Dx = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
Xr.assign({
  batchedUpdates: fv.unstable_batchedUpdates,
  createStringInterpolator: vy,
  colors: vb
});
var Ox = Qb(Dx, {
  applyAnimatedValues: Cx,
  createAnimatedStyle: (e) => new Nx(e),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop: e, scrollLeft: t, ...n }) => n
}), Wp = Ox.animated;
function Fx(e) {
  return e.innerRadius;
}
function Mx(e) {
  return e.outerRadius;
}
function Ix(e) {
  return e.startAngle;
}
function Bx(e) {
  return e.endAngle;
}
function zx(e) {
  return e && e.padAngle;
}
function $x(e, t, n, r, i, o, h, u) {
  var d = n - e, p = r - t, m = h - i, g = u - o, x = g * d - m * p;
  if (!(x * x < rr))
    return x = (m * (t - o) - g * (e - i)) / x, [e + x * d, t + x * p];
}
function $u(e, t, n, r, i, o, h) {
  var u = e - n, d = t - r, p = (h ? o : -o) / Qo(u * u + d * d), m = p * d, g = -p * u, x = e + m, A = t + g, k = n + m, y = r + g, v = (x + k) / 2, S = (A + y) / 2, B = k - x, R = y - A, N = B * B + R * R, D = i - o, L = x * y - k * A, q = (R < 0 ? -1 : 1) * Qo(Dg(0, D * D * N - L * L)), V = (L * R - B * q) / N, ae = (-L * B - R * q) / N, Y = (L * R + B * q) / N, Q = (-L * B + R * q) / N, se = V - v, ie = ae - S, M = Y - v, U = Q - S;
  return se * se + ie * ie > M * M + U * U && (V = Y, ae = Q), {
    cx: V,
    cy: ae,
    x01: -m,
    y01: -g,
    x11: V * (i / D - 1),
    y11: ae * (i / D - 1)
  };
}
function Hx() {
  var e = Fx, t = Mx, n = Bt(0), r = null, i = Ix, o = Bx, h = zx, u = null;
  function d() {
    var p, m, g = +e.apply(this, arguments), x = +t.apply(this, arguments), A = i.apply(this, arguments) - Wf, k = o.apply(this, arguments) - Wf, y = jf(k - A), v = k > A;
    if (u || (u = p = Rc()), x < g && (m = x, x = g, g = m), !(x > rr))
      u.moveTo(0, 0);
    else if (y > Yu - rr)
      u.moveTo(x * Fa(A), x * ii(A)), u.arc(0, 0, x, A, k, !v), g > rr && (u.moveTo(g * Fa(k), g * ii(k)), u.arc(0, 0, g, k, A, v));
    else {
      var S = A, B = k, R = A, N = k, D = y, L = y, q = h.apply(this, arguments) / 2, V = q > rr && (r ? +r.apply(this, arguments) : Qo(g * g + x * x)), ae = jd(jf(x - g) / 2, +n.apply(this, arguments)), Y = ae, Q = ae, se, ie;
      if (V > rr) {
        var M = Kf(V / g * ii(q)), U = Kf(V / x * ii(q));
        (D -= M * 2) > rr ? (M *= v ? 1 : -1, R += M, N -= M) : (D = 0, R = N = (A + k) / 2), (L -= U * 2) > rr ? (U *= v ? 1 : -1, S += U, B -= U) : (L = 0, S = B = (A + k) / 2);
      }
      var re = x * Fa(S), j = x * ii(S), de = g * Fa(N), Z = g * ii(N);
      if (ae > rr) {
        var ge = x * Fa(B), ne = x * ii(B), G = g * Fa(R), me = g * ii(R), ye;
        if (y < Vf && (ye = $x(re, j, G, me, ge, ne, de, Z))) {
          var Se = re - ye[0], ce = j - ye[1], ke = ge - ye[0], Ie = ne - ye[1], Le = 1 / ii(Rg((Se * ke + ce * Ie) / (Qo(Se * Se + ce * ce) * Qo(ke * ke + Ie * Ie))) / 2), Fe = Qo(ye[0] * ye[0] + ye[1] * ye[1]);
          Y = jd(ae, (g - Fe) / (Le - 1)), Q = jd(ae, (x - Fe) / (Le + 1));
        }
      }
      L > rr ? Q > rr ? (se = $u(G, me, re, j, x, Q, v), ie = $u(ge, ne, de, Z, x, Q, v), u.moveTo(se.cx + se.x01, se.cy + se.y01), Q < ae ? u.arc(se.cx, se.cy, Q, er(se.y01, se.x01), er(ie.y01, ie.x01), !v) : (u.arc(se.cx, se.cy, Q, er(se.y01, se.x01), er(se.y11, se.x11), !v), u.arc(0, 0, x, er(se.cy + se.y11, se.cx + se.x11), er(ie.cy + ie.y11, ie.cx + ie.x11), !v), u.arc(ie.cx, ie.cy, Q, er(ie.y11, ie.x11), er(ie.y01, ie.x01), !v))) : (u.moveTo(re, j), u.arc(0, 0, x, S, B, !v)) : u.moveTo(re, j), !(g > rr) || !(D > rr) ? u.lineTo(de, Z) : Y > rr ? (se = $u(de, Z, ge, ne, g, -Y, v), ie = $u(re, j, G, me, g, -Y, v), u.lineTo(se.cx + se.x01, se.cy + se.y01), Y < ae ? u.arc(se.cx, se.cy, Y, er(se.y01, se.x01), er(ie.y01, ie.x01), !v) : (u.arc(se.cx, se.cy, Y, er(se.y01, se.x01), er(se.y11, se.x11), !v), u.arc(0, 0, g, er(se.cy + se.y11, se.cx + se.x11), er(ie.cy + ie.y11, ie.cx + ie.x11), v), u.arc(ie.cx, ie.cy, Y, er(ie.y11, ie.x11), er(ie.y01, ie.x01), !v))) : u.arc(0, 0, g, N, R, v);
    }
    if (u.closePath(), p)
      return u = null, p + "" || null;
  }
  return d.centroid = function() {
    var p = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, m = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Vf / 2;
    return [Fa(m) * p, ii(m) * p];
  }, d.innerRadius = function(p) {
    return arguments.length ? (e = typeof p == "function" ? p : Bt(+p), d) : e;
  }, d.outerRadius = function(p) {
    return arguments.length ? (t = typeof p == "function" ? p : Bt(+p), d) : t;
  }, d.cornerRadius = function(p) {
    return arguments.length ? (n = typeof p == "function" ? p : Bt(+p), d) : n;
  }, d.padRadius = function(p) {
    return arguments.length ? (r = p == null ? null : typeof p == "function" ? p : Bt(+p), d) : r;
  }, d.startAngle = function(p) {
    return arguments.length ? (i = typeof p == "function" ? p : Bt(+p), d) : i;
  }, d.endAngle = function(p) {
    return arguments.length ? (o = typeof p == "function" ? p : Bt(+p), d) : o;
  }, d.padAngle = function(p) {
    return arguments.length ? (h = typeof p == "function" ? p : Bt(+p), d) : h;
  }, d.context = function(p) {
    return arguments.length ? (u = p ?? null, d) : u;
  }, d;
}
function Iy(e) {
  this._context = e;
}
Iy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Kc(e) {
  return new Iy(e);
}
function gf(e) {
  return e[0];
}
function vf(e) {
  return e[1];
}
function By() {
  var e = gf, t = vf, n = Bt(!0), r = null, i = Kc, o = null;
  function h(u) {
    var d, p = u.length, m, g = !1, x;
    for (r == null && (o = i(x = Rc())), d = 0; d <= p; ++d)
      !(d < p && n(m = u[d], d, u)) === g && ((g = !g) ? o.lineStart() : o.lineEnd()), g && o.point(+e(m, d, u), +t(m, d, u));
    if (x)
      return o = null, x + "" || null;
  }
  return h.x = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Bt(+u), h) : e;
  }, h.y = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Bt(+u), h) : t;
  }, h.defined = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : Bt(!!u), h) : n;
  }, h.curve = function(u) {
    return arguments.length ? (i = u, r != null && (o = i(r)), h) : i;
  }, h.context = function(u) {
    return arguments.length ? (u == null ? r = o = null : o = i(r = u), h) : r;
  }, h;
}
function Vx() {
  var e = gf, t = null, n = Bt(0), r = vf, i = Bt(!0), o = null, h = Kc, u = null;
  function d(m) {
    var g, x, A, k = m.length, y, v = !1, S, B = new Array(k), R = new Array(k);
    for (o == null && (u = h(S = Rc())), g = 0; g <= k; ++g) {
      if (!(g < k && i(y = m[g], g, m)) === v)
        if (v = !v)
          x = g, u.areaStart(), u.lineStart();
        else {
          for (u.lineEnd(), u.lineStart(), A = g - 1; A >= x; --A)
            u.point(B[A], R[A]);
          u.lineEnd(), u.areaEnd();
        }
      v && (B[g] = +e(y, g, m), R[g] = +n(y, g, m), u.point(t ? +t(y, g, m) : B[g], r ? +r(y, g, m) : R[g]));
    }
    if (S)
      return u = null, S + "" || null;
  }
  function p() {
    return By().defined(i).curve(h).context(o);
  }
  return d.x = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Bt(+m), t = null, d) : e;
  }, d.x0 = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Bt(+m), d) : e;
  }, d.x1 = function(m) {
    return arguments.length ? (t = m == null ? null : typeof m == "function" ? m : Bt(+m), d) : t;
  }, d.y = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Bt(+m), r = null, d) : n;
  }, d.y0 = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Bt(+m), d) : n;
  }, d.y1 = function(m) {
    return arguments.length ? (r = m == null ? null : typeof m == "function" ? m : Bt(+m), d) : r;
  }, d.lineX0 = d.lineY0 = function() {
    return p().x(e).y(n);
  }, d.lineY1 = function() {
    return p().x(e).y(r);
  }, d.lineX1 = function() {
    return p().x(t).y(n);
  }, d.defined = function(m) {
    return arguments.length ? (i = typeof m == "function" ? m : Bt(!!m), d) : i;
  }, d.curve = function(m) {
    return arguments.length ? (h = m, o != null && (u = h(o)), d) : h;
  }, d.context = function(m) {
    return arguments.length ? (m == null ? o = u = null : u = h(o = m), d) : o;
  }, d;
}
function Wx(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function jx(e) {
  return e;
}
function Kx() {
  var e = jx, t = Wx, n = null, r = Bt(0), i = Bt(Yu), o = Bt(0);
  function h(u) {
    var d, p = u.length, m, g, x = 0, A = new Array(p), k = new Array(p), y = +r.apply(this, arguments), v = Math.min(Yu, Math.max(-Yu, i.apply(this, arguments) - y)), S, B = Math.min(Math.abs(v) / p, o.apply(this, arguments)), R = B * (v < 0 ? -1 : 1), N;
    for (d = 0; d < p; ++d)
      (N = k[A[d] = d] = +e(u[d], d, u)) > 0 && (x += N);
    for (t != null ? A.sort(function(D, L) {
      return t(k[D], k[L]);
    }) : n != null && A.sort(function(D, L) {
      return n(u[D], u[L]);
    }), d = 0, g = x ? (v - p * R) / x : 0; d < p; ++d, y = S)
      m = A[d], N = k[m], S = y + (N > 0 ? N * g : 0) + R, k[m] = {
        data: u[m],
        index: d,
        value: N,
        startAngle: y,
        endAngle: S,
        padAngle: B
      };
    return k;
  }
  return h.value = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Bt(+u), h) : e;
  }, h.sortValues = function(u) {
    return arguments.length ? (t = u, n = null, h) : t;
  }, h.sort = function(u) {
    return arguments.length ? (n = u, t = null, h) : n;
  }, h.startAngle = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Bt(+u), h) : r;
  }, h.endAngle = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : Bt(+u), h) : i;
  }, h.padAngle = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : Bt(+u), h) : o;
  }, h;
}
var _h = Array.prototype.slice;
function Ux(e) {
  return e.source;
}
function Gx(e) {
  return e.target;
}
function Yx(e) {
  var t = Ux, n = Gx, r = gf, i = vf, o = null;
  function h() {
    var u, d = _h.call(arguments), p = t.apply(this, d), m = n.apply(this, d);
    if (o || (o = u = Rc()), e(o, +r.apply(this, (d[0] = p, d)), +i.apply(this, d), +r.apply(this, (d[0] = m, d)), +i.apply(this, d)), u)
      return o = null, u + "" || null;
  }
  return h.source = function(u) {
    return arguments.length ? (t = u, h) : t;
  }, h.target = function(u) {
    return arguments.length ? (n = u, h) : n;
  }, h.x = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Bt(+u), h) : r;
  }, h.y = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : Bt(+u), h) : i;
  }, h.context = function(u) {
    return arguments.length ? (o = u ?? null, h) : o;
  }, h;
}
function Xx(e, t, n, r, i) {
  e.moveTo(t, n), e.bezierCurveTo(t = (t + r) / 2, n, t, i, r, i);
}
function qx() {
  return Yx(Xx);
}
const Zx = {
  draw: function(e, t) {
    var n = Math.sqrt(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
};
function ea() {
}
function mc(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function Uc(e) {
  this._context = e;
}
Uc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        mc(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        mc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function Qx(e) {
  return new Uc(e);
}
function zy(e) {
  this._context = e;
}
zy.prototype = {
  areaStart: ea,
  areaEnd: ea,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        mc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function Jx(e) {
  return new zy(e);
}
function $y(e) {
  this._context = e;
}
$y.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      default:
        mc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function e0(e) {
  return new $y(e);
}
function Hy(e, t) {
  this._basis = new Uc(e), this._beta = t;
}
Hy.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var r = e[0], i = t[0], o = e[n] - r, h = t[n] - i, u = -1, d; ++u <= n; )
        d = u / n, this._basis.point(
          this._beta * e[u] + (1 - this._beta) * (r + d * o),
          this._beta * t[u] + (1 - this._beta) * (i + d * h)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const t0 = function e(t) {
  function n(r) {
    return t === 1 ? new Uc(r) : new Hy(r, t);
  }
  return n.beta = function(r) {
    return e(+r);
  }, n;
}(0.85);
function yc(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function bf(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
bf.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        yc(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        yc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const n0 = function e(t) {
  function n(r) {
    return new bf(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function xf(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
xf.prototype = {
  areaStart: ea,
  areaEnd: ea,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        yc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const r0 = function e(t) {
  function n(r) {
    return new xf(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function Sf(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Sf.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        yc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const i0 = function e(t) {
  function n(r) {
    return new Sf(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function wf(e, t, n) {
  var r = e._x1, i = e._y1, o = e._x2, h = e._y2;
  if (e._l01_a > rr) {
    var u = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, d = 3 * e._l01_a * (e._l01_a + e._l12_a);
    r = (r * u - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / d, i = (i * u - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / d;
  }
  if (e._l23_a > rr) {
    var p = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, m = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * p + e._x1 * e._l23_2a - t * e._l12_2a) / m, h = (h * p + e._y1 * e._l23_2a - n * e._l12_2a) / m;
  }
  e._context.bezierCurveTo(r, i, o, h, e._x2, e._y2);
}
function Vy(e, t) {
  this._context = e, this._alpha = t;
}
Vy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        wf(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const a0 = function e(t) {
  function n(r) {
    return t ? new Vy(r, t) : new bf(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Wy(e, t) {
  this._context = e, this._alpha = t;
}
Wy.prototype = {
  areaStart: ea,
  areaEnd: ea,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        wf(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const o0 = function e(t) {
  function n(r) {
    return t ? new Wy(r, t) : new xf(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function jy(e, t) {
  this._context = e, this._alpha = t;
}
jy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        wf(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const s0 = function e(t) {
  function n(r) {
    return t ? new jy(r, t) : new Sf(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Ky(e) {
  this._context = e;
}
Ky.prototype = {
  areaStart: ea,
  areaEnd: ea,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function Ph(e) {
  return new Ky(e);
}
function jp(e) {
  return e < 0 ? -1 : 1;
}
function Kp(e, t, n) {
  var r = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (r || i < 0 && -0), h = (n - e._y1) / (i || r < 0 && -0), u = (o * i + h * r) / (r + i);
  return (jp(o) + jp(h)) * Math.min(Math.abs(o), Math.abs(h), 0.5 * Math.abs(u)) || 0;
}
function Up(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function nh(e, t, n) {
  var r = e._x0, i = e._y0, o = e._x1, h = e._y1, u = (o - r) / 3;
  e._context.bezierCurveTo(r + u, i + u * t, o - u, h - u * n, o, h);
}
function gc(e) {
  this._context = e;
}
gc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        nh(this, this._t0, Up(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, nh(this, Up(this, n = Kp(this, e, t)), n);
          break;
        default:
          nh(this, this._t0, n = Kp(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function Uy(e) {
  this._context = new Gy(e);
}
(Uy.prototype = Object.create(gc.prototype)).point = function(e, t) {
  gc.prototype.point.call(this, t, e);
};
function Gy(e) {
  this._context = e;
}
Gy.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, i, o) {
    this._context.bezierCurveTo(t, e, r, n, o, i);
  }
};
function Ju(e) {
  return new gc(e);
}
function l0(e) {
  return new Uy(e);
}
function Yy(e) {
  this._context = e;
}
Yy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = Gp(e), i = Gp(t), o = 0, h = 1; h < n; ++o, ++h)
          this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], e[h], t[h]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Gp(e) {
  var t, n = e.length - 1, r, i = new Array(n), o = new Array(n), h = new Array(n);
  for (i[0] = 0, o[0] = 2, h[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    i[t] = 1, o[t] = 4, h[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, o[n - 1] = 7, h[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    r = i[t] / o[t - 1], o[t] -= r, h[t] -= r * h[t - 1];
  for (i[n - 1] = h[n - 1] / o[n - 1], t = n - 2; t >= 0; --t)
    i[t] = (h[t] - i[t + 1]) / o[t];
  for (o[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)
    o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function u0(e) {
  return new Yy(e);
}
function Gc(e, t) {
  this._context = e, this._t = t;
}
Gc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function c0(e) {
  return new Gc(e, 0.5);
}
function d0(e) {
  return new Gc(e, 0);
}
function h0(e) {
  return new Gc(e, 1);
}
function ss(e, t) {
  if ((h = e.length) > 1)
    for (var n = 1, r, i, o = e[t[0]], h, u = o.length; n < h; ++n)
      for (i = o, o = e[t[n]], r = 0; r < u; ++r)
        o[r][1] += o[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1];
}
function ls(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; )
    n[t] = t;
  return n;
}
function f0(e, t) {
  return e[t];
}
function kf() {
  var e = Bt([]), t = ls, n = ss, r = f0;
  function i(o) {
    var h = e.apply(this, arguments), u, d = o.length, p = h.length, m = new Array(p), g;
    for (u = 0; u < p; ++u) {
      for (var x = h[u], A = m[u] = new Array(d), k = 0, y; k < d; ++k)
        A[k] = y = [0, +r(o[k], x, k, o)], y.data = o[k];
      A.key = x;
    }
    for (u = 0, g = t(m); u < p; ++u)
      m[g[u]].index = u;
    return n(m, g), m;
  }
  return i.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Bt(_h.call(o)), i) : e;
  }, i.value = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : Bt(+o), i) : r;
  }, i.order = function(o) {
    return arguments.length ? (t = o == null ? ls : typeof o == "function" ? o : Bt(_h.call(o)), i) : t;
  }, i.offset = function(o) {
    return arguments.length ? (n = o ?? ss, i) : n;
  }, i;
}
function p0(e, t) {
  if ((r = e.length) > 0) {
    for (var n, r, i = 0, o = e[0].length, h; i < o; ++i) {
      for (h = n = 0; n < r; ++n)
        h += e[n][i][1] || 0;
      if (h)
        for (n = 0; n < r; ++n)
          e[n][i][1] /= h;
    }
    ss(e, t);
  }
}
function m0(e, t) {
  if ((d = e.length) > 0)
    for (var n, r = 0, i, o, h, u, d, p = e[t[0]].length; r < p; ++r)
      for (h = u = 0, n = 0; n < d; ++n)
        (o = (i = e[t[n]][r])[1] - i[0]) > 0 ? (i[0] = h, i[1] = h += o) : o < 0 ? (i[1] = u, i[0] = u += o) : (i[0] = 0, i[1] = o);
}
function y0(e, t) {
  if ((i = e.length) > 0) {
    for (var n = 0, r = e[t[0]], i, o = r.length; n < o; ++n) {
      for (var h = 0, u = 0; h < i; ++h)
        u += e[h][n][1] || 0;
      r[n][1] += r[n][0] = -u / 2;
    }
    ss(e, t);
  }
}
function g0(e, t) {
  if (!(!((h = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var n = 0, r = 1, i, o, h; r < o; ++r) {
      for (var u = 0, d = 0, p = 0; u < h; ++u) {
        for (var m = e[t[u]], g = m[r][1] || 0, x = m[r - 1][1] || 0, A = (g - x) / 2, k = 0; k < u; ++k) {
          var y = e[t[k]], v = y[r][1] || 0, S = y[r - 1][1] || 0;
          A += v - S;
        }
        d += g, p += A * g;
      }
      i[r - 1][1] += i[r - 1][0] = n, d && (n -= p / d);
    }
    i[r - 1][1] += i[r - 1][0] = n, ss(e, t);
  }
}
function v0(e) {
  var t = e.map(b0);
  return ls(e).sort(function(n, r) {
    return t[n] - t[r];
  });
}
function b0(e) {
  for (var t = -1, n = 0, r = e.length, i, o = -1 / 0; ++t < r; )
    (i = +e[t][1]) > o && (o = i, n = t);
  return n;
}
function Xy(e) {
  var t = e.map(qy);
  return ls(e).sort(function(n, r) {
    return t[n] - t[r];
  });
}
function qy(e) {
  for (var t = 0, n = -1, r = e.length, i; ++n < r; )
    (i = +e[n][1]) && (t += i);
  return t;
}
function x0(e) {
  return Xy(e).reverse();
}
function S0(e) {
  var t = e.length, n, r, i = e.map(qy), o = v0(e), h = 0, u = 0, d = [], p = [];
  for (n = 0; n < t; ++n)
    r = o[n], h < u ? (h += i[r], d.push(r)) : (u += i[r], p.push(r));
  return p.reverse().concat(d);
}
function w0(e) {
  return ls(e).reverse();
}
function hn(e, t) {
  e(t);
}
var Yp = {
  ascending: Xy,
  descending: x0,
  insideout: S0,
  none: ls,
  reverse: w0
};
function Tf(e) {
  return e && Yp[e] || Yp.none;
}
var Xp = {
  expand: p0,
  diverging: m0,
  none: ss,
  silhouette: y0,
  wiggle: g0
};
function Cf(e) {
  return e && Xp[e] || Xp.none;
}
function k0(e) {
  var t = e === void 0 ? {} : e, n = t.innerRadius, r = t.outerRadius, i = t.cornerRadius, o = t.startAngle, h = t.endAngle, u = t.padAngle, d = t.padRadius, p = Hx();
  return n != null && hn(p.innerRadius, n), r != null && hn(p.outerRadius, r), i != null && hn(p.cornerRadius, i), o != null && hn(p.startAngle, o), h != null && hn(p.endAngle, h), u != null && hn(p.padAngle, u), d != null && hn(p.padRadius, d), p;
}
function Af(e) {
  var t = e === void 0 ? {} : e, n = t.x, r = t.x0, i = t.x1, o = t.y, h = t.y0, u = t.y1, d = t.defined, p = t.curve, m = Vx();
  return n && hn(m.x, n), r && hn(m.x0, r), i && hn(m.x1, i), o && hn(m.y, o), h && hn(m.y0, h), u && hn(m.y1, u), d && m.defined(d), p && m.curve(p), m;
}
function Zy(e) {
  var t = e === void 0 ? {} : e, n = t.x, r = t.y, i = t.defined, o = t.curve, h = By();
  return n && hn(h.x, n), r && hn(h.y, r), i && h.defined(i), o && h.curve(o), h;
}
function T0(e) {
  var t = e === void 0 ? {} : e, n = t.startAngle, r = t.endAngle, i = t.padAngle, o = t.value, h = t.sort, u = t.sortValues, d = Kx();
  return (h === null || h != null) && d.sort(h), (u === null || u != null) && d.sortValues(u), o != null && d.value(o), i != null && hn(d.padAngle, i), n != null && hn(d.startAngle, n), r != null && hn(d.endAngle, r), d;
}
function C0(e) {
  var t = e.keys, n = e.value, r = e.order, i = e.offset, o = kf();
  return t && o.keys(t), n && hn(o.value, n), r && o.order(Tf(r)), i && o.offset(Cf(i)), o;
}
var A0 = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function Nh() {
  return Nh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Nh.apply(this, arguments);
}
function L0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function E0(e) {
  var t = e.className, n = e.top, r = e.left, i = e.data, o = i === void 0 ? [] : i, h = e.centroid, u = e.innerRadius, d = u === void 0 ? 0 : u, p = e.outerRadius, m = e.cornerRadius, g = e.startAngle, x = e.endAngle, A = e.padAngle, k = e.padRadius, y = e.pieSort, v = e.pieSortValues, S = e.pieValue, B = e.children, R = e.fill, N = R === void 0 ? "" : R, D = L0(e, A0), L = k0({
    innerRadius: d,
    outerRadius: p,
    cornerRadius: m,
    padRadius: k
  }), q = T0({
    startAngle: g,
    endAngle: x,
    padAngle: A,
    value: S,
    sort: y,
    sortValues: v
  }), V = q(o);
  return B ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, B({
    arcs: V,
    path: L,
    pie: q
  })) : /* @__PURE__ */ Me.createElement(qe, {
    className: "visx-pie-arcs-group",
    top: n,
    left: r
  }, V.map(function(ae, Y) {
    return /* @__PURE__ */ Me.createElement("g", {
      key: "pie-arc-" + Y
    }, /* @__PURE__ */ Me.createElement("path", Nh({
      className: vn("visx-pie-arc", t),
      d: L(ae) || "",
      fill: N == null || typeof N == "string" ? N : N(ae)
    }, D)), h == null ? void 0 : h(L.centroid(ae), ae));
  }));
}
var _0 = ["from", "to", "fill", "className", "innerRef"];
function Rh() {
  return Rh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Rh.apply(this, arguments);
}
function P0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function ln(e) {
  var t = e.from, n = t === void 0 ? {
    x: 0,
    y: 0
  } : t, r = e.to, i = r === void 0 ? {
    x: 1,
    y: 1
  } : r, o = e.fill, h = o === void 0 ? "transparent" : o, u = e.className, d = e.innerRef, p = P0(e, _0), m = n.x === i.x || n.y === i.y;
  return /* @__PURE__ */ Me.createElement("line", Rh({
    ref: d,
    className: vn("visx-line", u),
    x1: n.x,
    y1: n.y,
    x2: i.x,
    y2: i.y,
    fill: h,
    shapeRendering: m ? "crispEdges" : "auto"
  }, p));
}
var N0 = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function Dh() {
  return Dh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Dh.apply(this, arguments);
}
function R0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Yr(e) {
  var t = e.children, n = e.data, r = n === void 0 ? [] : n, i = e.x, o = e.y, h = e.fill, u = h === void 0 ? "transparent" : h, d = e.className, p = e.curve, m = e.innerRef, g = e.defined, x = g === void 0 ? function() {
    return !0;
  } : g, A = R0(e, N0), k = Zy({
    x: i,
    y: o,
    defined: x,
    curve: p
  });
  return t ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, t({
    path: k
  })) : /* @__PURE__ */ Me.createElement("path", Dh({
    ref: m,
    className: vn("visx-linepath", d),
    d: k(r) || "",
    fill: u,
    strokeLinecap: "round"
  }, A));
}
var D0 = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function Oh() {
  return Oh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Oh.apply(this, arguments);
}
function O0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function F0(e) {
  var t = e.children, n = e.x, r = e.x0, i = e.x1, o = e.y, h = e.y0, u = e.y1, d = e.data, p = d === void 0 ? [] : d, m = e.defined, g = m === void 0 ? function() {
    return !0;
  } : m, x = e.className, A = e.curve, k = e.innerRef, y = O0(e, D0), v = Af({
    x: n,
    x0: r,
    x1: i,
    y: o,
    y0: h,
    y1: u,
    defined: g,
    curve: A
  });
  return t ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, t({
    path: v
  })) : /* @__PURE__ */ Me.createElement("path", Oh({
    ref: k,
    className: vn("visx-area", x),
    d: v(p) || ""
  }, y));
}
var M0 = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function Fh() {
  return Fh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Fh.apply(this, arguments);
}
function I0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Mh(e) {
  var t = e.x, n = e.x0, r = e.x1, i = e.y, o = e.y1, h = e.y0, u = e.yScale, d = e.data, p = d === void 0 ? [] : d, m = e.defined, g = m === void 0 ? function() {
    return !0;
  } : m, x = e.className, A = e.curve, k = e.innerRef, y = e.children, v = I0(e, M0), S = Af({
    x: t,
    x0: n,
    x1: r,
    defined: g,
    curve: A
  });
  return h == null ? S.y0(u.range()[0]) : hn(S.y0, h), i && !o && hn(S.y1, i), o && !i && hn(S.y1, o), y ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, y({
    path: S
  })) : /* @__PURE__ */ Me.createElement("path", Fh({
    ref: k,
    className: vn("visx-area-closed", x),
    d: S(p) || ""
  }, v));
}
var B0 = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function Ih() {
  return Ih = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ih.apply(this, arguments);
}
function z0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function $0(e) {
  var t = e.className, n = e.top, r = e.left, i = e.keys, o = e.data, h = e.curve, u = e.defined, d = e.x, p = e.x0, m = e.x1, g = e.y0, x = e.y1, A = e.value, k = e.order, y = e.offset, v = e.color, S = e.children, B = z0(e, B0), R = C0({
    keys: i,
    value: A,
    order: k,
    offset: y
  }), N = Af({
    x: d,
    x0: p,
    x1: m,
    y0: g,
    y1: x,
    curve: h,
    defined: u
  }), D = R(o);
  return S ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, S({
    stacks: D,
    path: N,
    stack: R
  })) : /* @__PURE__ */ Me.createElement(qe, {
    top: n,
    left: r
  }, D.map(function(L, q) {
    return /* @__PURE__ */ Me.createElement("path", Ih({
      className: vn("visx-stack", t),
      key: "stack-" + q + "-" + (L.key || ""),
      d: N(L) || "",
      fill: v == null ? void 0 : v(L.key, q)
    }, B));
  }));
}
var H0 = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function vc() {
  return vc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, vc.apply(this, arguments);
}
function V0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function W0(e) {
  var t = e.className, n = e.top, r = e.left, i = e.keys, o = e.data, h = e.curve, u = e.defined, d = e.x, p = e.x0, m = e.x1, g = e.y0, x = e.y1, A = e.value, k = e.order, y = e.offset, v = e.color, S = e.children, B = V0(e, H0);
  return /* @__PURE__ */ Me.createElement($0, vc({
    className: t,
    top: n,
    left: r,
    keys: i,
    data: o,
    curve: h,
    defined: u,
    x: d,
    x0: p,
    x1: m,
    y0: g,
    y1: x,
    value: A,
    order: k,
    offset: y,
    color: v
  }, B), S || function(R) {
    var N = R.stacks, D = R.path;
    return N.map(function(L, q) {
      return /* @__PURE__ */ Me.createElement("path", vc({
        className: vn("visx-area-stack", t),
        key: "area-stack-" + q + "-" + (L.key || ""),
        d: D(L) || "",
        fill: v == null ? void 0 : v(L.key, q)
      }, B));
    });
  });
}
function Lf(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), n = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / n.length;
}
var j0 = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function Bh() {
  return Bh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Bh.apply(this, arguments);
}
function K0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Qy(e) {
  var t = e.data, n = e.className, r = e.top, i = e.left, o = e.x0, h = e.x0Scale, u = e.x1Scale, d = e.yScale, p = e.color, m = e.keys, g = e.height, x = e.children, A = K0(e, j0), k = Lf(u), y = t.map(function(v, S) {
    return {
      index: S,
      x0: h(o(v)),
      bars: m.map(function(B, R) {
        var N = v[B];
        return {
          index: R,
          key: B,
          value: N,
          width: k,
          x: u(B) || 0,
          y: d(N) || 0,
          color: p(B, R),
          height: g - (d(N) || 0)
        };
      })
    };
  });
  return x ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, x(y)) : /* @__PURE__ */ Me.createElement(qe, {
    className: vn("visx-bar-group", n),
    top: r,
    left: i
  }, y.map(function(v) {
    return /* @__PURE__ */ Me.createElement(qe, {
      key: "bar-group-" + v.index + "-" + v.x0,
      left: v.x0
    }, v.bars.map(function(S) {
      return /* @__PURE__ */ Me.createElement(Er, Bh({
        key: "bar-group-bar-" + v.index + "-" + S.index + "-" + S.value + "-" + S.key,
        x: S.x,
        y: S.y,
        width: S.width,
        height: S.height,
        fill: S.color
      }, A));
    }));
  }));
}
function Jy(e) {
  return e == null ? void 0 : e[0];
}
function eg(e) {
  return e == null ? void 0 : e[1];
}
var U0 = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function zh() {
  return zh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, zh.apply(this, arguments);
}
function G0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function tg(e) {
  var t = e.data, n = e.className, r = e.top, i = e.left, o = e.x, h = e.y0, u = h === void 0 ? Jy : h, d = e.y1, p = d === void 0 ? eg : d, m = e.xScale, g = e.yScale, x = e.color, A = e.keys, k = e.value, y = e.order, v = e.offset, S = e.children, B = G0(e, U0), R = kf();
  A && R.keys(A), k && hn(R.value, k), y && R.order(Tf(y)), v && R.offset(Cf(v));
  var N = R(t), D = Lf(m), L = N.map(function(q, V) {
    var ae = q.key;
    return {
      index: V,
      key: ae,
      bars: q.map(function(Y, Q) {
        var se = (g(u(Y)) || 0) - (g(p(Y)) || 0), ie = g(p(Y)), M = "bandwidth" in m ? m(o(Y.data)) : Math.max((m(o(Y.data)) || 0) - D / 2);
        return {
          bar: Y,
          key: ae,
          index: Q,
          height: se,
          width: D,
          x: M || 0,
          y: ie || 0,
          color: x(q.key, Q)
        };
      })
    };
  });
  return S ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, S(L)) : /* @__PURE__ */ Me.createElement(qe, {
    className: vn("visx-bar-stack", n),
    top: r,
    left: i
  }, L.map(function(q) {
    return q.bars.map(function(V) {
      return /* @__PURE__ */ Me.createElement(Er, zh({
        key: "bar-stack-" + q.index + "-" + V.index,
        x: V.x,
        y: V.y,
        height: V.height,
        width: V.width,
        fill: V.color
      }, B));
    });
  }));
}
var Y0 = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function $h() {
  return $h = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, $h.apply(this, arguments);
}
function X0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function q0(e) {
  var t = e.data, n = e.className, r = e.top, i = e.left, o = e.y, h = e.x0, u = h === void 0 ? Jy : h, d = e.x1, p = d === void 0 ? eg : d, m = e.xScale, g = e.yScale, x = e.color, A = e.keys, k = e.value, y = e.order, v = e.offset, S = e.children, B = X0(e, Y0), R = kf();
  A && R.keys(A), k && hn(R.value, k), y && R.order(Tf(y)), v && R.offset(Cf(v));
  var N = R(t), D = Lf(g), L = N.map(function(q, V) {
    var ae = q.key;
    return {
      index: V,
      key: ae,
      bars: q.map(function(Y, Q) {
        var se = (m(p(Y)) || 0) - (m(u(Y)) || 0), ie = m(u(Y)), M = "bandwidth" in g ? g(o(Y.data)) : Math.max((g(o(Y.data)) || 0) - se / 2);
        return {
          bar: Y,
          key: ae,
          index: Q,
          height: D,
          width: se,
          x: ie || 0,
          y: M || 0,
          color: x(q.key, Q)
        };
      })
    };
  });
  return S ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, S(L)) : /* @__PURE__ */ Me.createElement(qe, {
    className: vn("visx-bar-stack-horizontal", n),
    top: r,
    left: i
  }, L.map(function(q) {
    return q.bars.map(function(V) {
      return /* @__PURE__ */ Me.createElement(Er, $h({
        key: "bar-stack-" + q.index + "-" + V.index,
        x: V.x,
        y: V.y,
        height: V.height,
        width: V.width,
        fill: V.color
      }, B));
    });
  }));
}
var qp = "http://www.w3.org/2000/svg";
function Z0(e) {
  var t = document.getElementById(e);
  if (!t) {
    var n = document.createElementNS(qp, "svg");
    n.setAttribute("aria-hidden", "true"), n.style.opacity = "0", n.style.width = "0", n.style.height = "0", n.style.position = "absolute", n.style.top = "-100%", n.style.left = "-100%", n.style.pointerEvents = "none", t = document.createElementNS(qp, "path"), t.setAttribute("id", e), n.appendChild(t), document.body.appendChild(n);
  }
  return t;
}
var Q0 = "__visx_splitpath_svg_path_measurement_id", Zp = function() {
  return !0;
};
function J0(e) {
  var t = e.path, n = e.pointsInSegments, r = e.segmentation, i = r === void 0 ? "x" : r, o = e.sampleRate, h = o === void 0 ? 1 : o;
  try {
    var u = Z0(Q0);
    u.setAttribute("d", t);
    var d = u.getTotalLength(), p = n.length, m = n.map(function() {
      return [];
    });
    if (i === "x" || i === "y")
      for (var g = n.map(function(ie) {
        var M;
        return (M = ie.find(function(U) {
          return typeof U[i] == "number";
        })) == null ? void 0 : M[i];
      }), x = u.getPointAtLength(0), A = u.getPointAtLength(d), k = A[i] > x[i], y = k ? g.map(function(ie) {
        return typeof ie > "u" ? Zp : function(M) {
          return M >= ie;
        };
      }) : g.map(function(ie) {
        return typeof ie > "u" ? Zp : function(M) {
          return M <= ie;
        };
      }), v = 0, S = 0; S <= d; S += h) {
        for (var B = u.getPointAtLength(S), R = B[i]; v < p - 1 && y[v + 1](R); )
          v += 1;
        m[v].push(B);
      }
    else {
      var N = n.map(function(ie) {
        return ie.length;
      }), D = N.reduce(function(ie, M) {
        return ie + M;
      }, 0), L = d / Math.max(1, D - 1), q = N.slice(0, p - 1);
      q.unshift(0);
      for (var V = 2; V < p; V += 1)
        q[V] += q[V - 1];
      for (var ae = 0; ae < p; ae += 1)
        q[ae] *= L;
      for (var Y = 0, Q = 0; Q <= d; Q += h) {
        for (var se = u.getPointAtLength(Q); Y < p - 1 && Q >= q[Y + 1]; )
          Y += 1;
        m[Y].push(se);
      }
    }
    return m;
  } catch {
    return [];
  }
}
function Hh() {
  return Hh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Hh.apply(this, arguments);
}
var eS = function(t) {
  return t.x || 0;
}, tS = function(t) {
  return t.y || 0;
};
function ng(e) {
  var t = e.children, n = e.className, r = e.curve, i = e.defined, o = e.segmentation, h = e.sampleRate, u = e.segments, d = e.x, p = e.y, m = e.styles, g = he.useMemo(function() {
    var k = typeof d == "number" || typeof d > "u" ? function() {
      return d;
    } : d, y = typeof p == "number" || typeof p > "u" ? function() {
      return p;
    } : p;
    return u.map(function(v) {
      return v.map(function(S, B) {
        return {
          x: k(S, B, v),
          y: y(S, B, v)
        };
      });
    });
  }, [d, p, u]), x = he.useMemo(function() {
    var k = Zy({
      x: d,
      y: p,
      defined: i,
      curve: r
    });
    return k(u.flat()) || "";
  }, [d, p, i, r, u]), A = he.useMemo(function() {
    return J0({
      path: x,
      segmentation: o,
      pointsInSegments: g,
      sampleRate: h
    });
  }, [x, o, g, h]);
  return /* @__PURE__ */ Me.createElement("g", null, A.map(function(k, y) {
    return t ? /* @__PURE__ */ Me.createElement(Me.Fragment, {
      key: y
    }, t({
      index: y,
      segment: k,
      styles: m[y] || m[y % m.length]
    })) : /* @__PURE__ */ Me.createElement(Yr, Hh({
      key: y,
      className: n,
      data: k,
      x: eS,
      y: tS
    }, m[y] || m[y % m.length]));
  }));
}
ng.propTypes = {
  segments: De.arrayOf(De.array).isRequired,
  styles: De.array.isRequired,
  children: De.func,
  className: De.string
};
var nS = ["tooltipOpen"];
function rS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function bc() {
  return bc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, bc.apply(this, arguments);
}
function rg(e) {
  var t = he.useState(bc({
    tooltipOpen: !1
  }, e)), n = t[0], r = t[1], i = he.useCallback(function(h) {
    return r(typeof h == "function" ? function(u) {
      u.tooltipOpen;
      var d = rS(u, nS);
      return bc({}, h(d), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: h.tooltipLeft,
      tooltipTop: h.tooltipTop,
      tooltipData: h.tooltipData
    });
  }, [r]), o = he.useCallback(function() {
    return r({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [r]);
  return {
    tooltipOpen: n.tooltipOpen,
    tooltipLeft: n.tooltipLeft,
    tooltipTop: n.tooltipTop,
    tooltipData: n.tooltipData,
    updateTooltip: r,
    showTooltip: i,
    hideTooltip: o
  };
}
var iS = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function xc() {
  return xc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, xc.apply(this, arguments);
}
function aS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var ig = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, Ef = /* @__PURE__ */ Me.forwardRef(function(e, t) {
  var n = e.className, r = e.top, i = e.left, o = e.offsetLeft, h = o === void 0 ? 10 : o, u = e.offsetTop, d = u === void 0 ? 10 : u, p = e.style, m = p === void 0 ? ig : p, g = e.children, x = e.unstyled, A = x === void 0 ? !1 : x, k = e.applyPositionStyle, y = k === void 0 ? !1 : k, v = aS(e, iS);
  return /* @__PURE__ */ Me.createElement("div", xc({
    ref: t,
    className: vn("visx-tooltip", n),
    style: xc({
      top: r == null || d == null ? r : r + d,
      left: i == null || h == null ? i : i + h
    }, y && {
      position: "absolute"
    }, !A && m)
  }, v), g);
});
Ef.propTypes = {
  children: De.node,
  className: De.string,
  left: De.number,
  offsetLeft: De.number,
  offsetTop: De.number,
  top: De.number,
  applyPositionStyle: De.bool,
  unstyled: De.bool
};
Ef.displayName = "Tooltip";
const oS = Ef;
function Vh() {
  return Vh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Vh.apply(this, arguments);
}
function sS(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function lS(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Wh(e, t);
}
function Wh(e, t) {
  return Wh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, Wh(e, t);
}
var Qp = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function uS(e) {
  var t;
  return t = /* @__PURE__ */ function(n) {
    lS(r, n);
    function r(o) {
      var h;
      return h = n.call(this, o) || this, h.state = {
        rect: void 0,
        parentRect: void 0
      }, h.nodeRef = /* @__PURE__ */ Me.createRef(), h.getRects = h.getRects.bind(sS(h)), h;
    }
    var i = r.prototype;
    return i.componentDidMount = function() {
      var h, u = this;
      this.node = (h = this.nodeRef) != null && h.current ? this.nodeRef.current : pv.findDOMNode(this), this.setState(function() {
        return u.getRects();
      });
    }, i.getRects = function() {
      if (!this.node)
        return this.state;
      var h = this.node, u = h.parentNode, d = h.getBoundingClientRect ? h.getBoundingClientRect() : Qp, p = u != null && u.getBoundingClientRect ? u.getBoundingClientRect() : Qp;
      return {
        rect: d,
        parentRect: p
      };
    }, i.render = function() {
      return /* @__PURE__ */ Me.createElement(e, Vh({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, r;
  }(Me.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var ag = /* @__PURE__ */ he.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), cS = ag.Provider;
ag.Consumer;
var dS = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function Sc() {
  return Sc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Sc.apply(this, arguments);
}
function hS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function og(e) {
  var t = e.children;
  e.getRects;
  var n = e.left, r = n === void 0 ? 0 : n, i = e.offsetLeft, o = i === void 0 ? 10 : i, h = e.offsetTop, u = h === void 0 ? 10 : h, d = e.parentRect, p = e.rect, m = e.style, g = m === void 0 ? ig : m, x = e.top, A = x === void 0 ? 0 : x, k = e.unstyled, y = k === void 0 ? !1 : k, v = e.nodeRef, S = hS(e, dS), B, R = !1, N = !1;
  if (p && d) {
    var D = r, L = A;
    if (d.width) {
      var q = D + o + p.width - d.width, V = p.width - D - o;
      R = q > 0 && q > V;
    } else {
      var ae = D + o + p.width - window.innerWidth, Y = p.width - D - o;
      R = ae > 0 && ae > Y;
    }
    if (d.height) {
      var Q = L + u + p.height - d.height, se = p.height - L - u;
      N = Q > 0 && Q > se;
    } else
      N = L + u + p.height > window.innerHeight;
    D = R ? D - p.width - o : D + o, L = N ? L - p.height - u : L + u, D = Math.round(D), L = Math.round(L), B = "translate(" + D + "px, " + L + "px)";
  }
  return /* @__PURE__ */ Me.createElement(oS, Sc({
    ref: v,
    style: Sc({
      left: 0,
      top: 0,
      transform: B
    }, !y && g)
  }, S), /* @__PURE__ */ Me.createElement(cS, {
    value: {
      isFlippedVertically: !N,
      isFlippedHorizontally: !R
    }
  }, t));
}
og.propTypes = {
  nodeRef: De.oneOfType([De.string, De.func, De.object])
};
const sg = uS(og), _f = (e, t) => {
  const n = e.orientation === "horizontal", r = e.visualizationSubType === "stacked";
  let i;
  if (r)
    i = e.barHeight;
  else {
    const d = e.runtime.seriesKeys.length;
    e.isLollipopChart ? i = ({
      large: 7,
      medium: 6,
      small: 5
    }[e.lollipopSize] || 5) * d : i = e.barHeight * d;
  }
  const o = Dc * 1.2, h = e.yAxis.labelPlacement === "Below Bar" ? o : 0, u = i + h + Number(e.barSpace);
  if (n) {
    const d = t.length * u;
    e.heights || (e.heights = {}), e.heights.horizontal = d;
  }
  return t.map((d, p) => {
    const m = d.index === 0 ? 0 : Ke.round(u * p);
    return { ...d, y: m, height: i };
  });
}, lg = (e) => {
  const {
    tableData: t,
    config: n,
    formatNumber: r,
    capitalize: i,
    formatDate: o,
    formatTooltipsDate: h,
    parseDate: u,
    setSharedFilter: d,
    isDraggingAnnotation: p
  } = he.useContext(pt), { xScale: m, yScale: g, seriesScale: x, showTooltip: A, hideTooltip: k } = e, { xAxis: y, visualizationType: v, orientation: S, yAxis: B, runtime: R } = n, N = Number(n.yAxis.size || 0), D = (ne, G) => {
    var ce;
    let me = null, ye = null;
    const Se = n.series.find((ke) => ke.dynamicCategory);
    if (Se)
      me = G[Se.dynamicCategory], ye = G[Se.dataKey];
    else {
      let ke = 0, Ie;
      try {
        Ie = Number(g.invert(ne));
      } catch {
        return [];
      }
      for (let Le of (ce = n.runtime) == null ? void 0 : ce.seriesKeys)
        if (G.hasOwnProperty(Le) && (ke += Number(G[Le]), ke >= Ie)) {
          ye = G[Le], me = Le;
          break;
        }
    }
    return [me, ye];
  }, L = (ne, G, me, ye) => {
    const Se = me.general.showMissingDataLabel && (!G || G === "null"), ce = ne === me.xAxis.dataKey ? G : r(G, ye(ne));
    return Se ? "N/A" : ce;
  }, q = (ne, G) => {
    var st, dt, Ye, Je;
    if (v === "Bump Chart" || p)
      return;
    const me = Uf(ne), { x: ye, y: Se } = me, ce = re([ye, Se]), ke = se(Se, ce), Ie = [], Le = [];
    for (const [yt, nt] of Object.entries(n.columns)) {
      const lt = {
        addColPrefix: nt.prefix,
        addColSuffix: nt.suffix,
        addColRoundTo: nt.roundToPlace || "",
        addColCommas: nt.commas
      }, je = (st = G == null ? void 0 : G.arc) == null ? void 0 : st.data[nt.name], at = n.tooltips.singleSeries && v === "Line" ? ce.filter(
        (rn) => rn[n.runtime.series[0].dynamicCategory] === ke
      )[0][yt] : (dt = ce[0]) == null ? void 0 : dt[yt], ct = n.visualizationType === "Pie" ? je : at, wt = Jh(ct, "left", !0, n, lt);
      nt.tooltips && Ie.push([nt.label, wt]);
    }
    const Fe = [];
    if (Ie.forEach((yt) => {
      Fe.push([yt[0], yt[1]]);
    }), v === "Pie") {
      const yt = Number(n.dataFormat.roundTo) || 0, nt = (G == null ? void 0 : G.data) ?? {}, lt = (G == null ? void 0 : G.startAngle) ?? 0, wt = ((((G == null ? void 0 : G.endAngle) ?? 0) - lt) * 180 / Math.PI / 360 * 100).toFixed(yt) + "%";
      Le.push(
        [n.xAxis.dataKey, nt[n.xAxis.dataKey]],
        [n.runtime.yAxis.dataKey, r(nt[n.runtime.yAxis.dataKey])],
        ["Percent", wt]
      );
    }
    if (v === "Forest Plot" && Le.push([n.xAxis.dataKey, M(Se)]), !["Pie", "Forest Plot"].includes(v)) {
      const yt = (nt) => {
        const lt = n.runtime.series.filter((at) => at.dataKey === nt)[0];
        return lt != null && lt.axis ? String(lt.axis).toLowerCase() : "left";
      };
      if (!n.tooltips.singleSeries || v === "Line") {
        Le.push(
          ...(Je = (Ye = j()) == null ? void 0 : Ye.filter((lt) => {
            var at, ct;
            return ((at = n.runtime.series) == null ? void 0 : at.find(
              (wt) => wt.dataKey === lt && (wt == null ? void 0 : wt.tooltip) && !wt.dynamicCategory
            )) || ((ct = n.xAxis) == null ? void 0 : ct.dataKey) == lt || v === "Forecasting";
          })) == null ? void 0 : Je.flatMap((lt) => {
            var wt;
            const je = (wt = ce[0]) == null ? void 0 : wt[lt], at = L(lt, je, n, yt), ct = n.runtime.series.find(
              (rn) => rn.dataKey === lt && rn.name !== void 0
            );
            return (je == null || je === "" || at === "N/A") && n.general.hideNullValue ? [] : ct && ct.name === "" ? [["", at, yt(lt)]] : [[lt, at, yt(lt)]];
          })
        );
        const nt = n.tooltips.singleSeries && v === "Line" ? [Ke.find(n.runtime.series, (lt) => lt.dataKey === ke)] : n.runtime.series;
        nt == null || nt.forEach((lt) => {
          if (lt != null && lt.dynamicCategory) {
            const je = lt.dataKey, at = ce.find((ct) => ct[lt.dynamicCategory] === je);
            if (at) {
              const ct = at[lt.originalDataKey], wt = L(je, ct, n, yt);
              Le.push([je, wt, yt(je)]);
            }
          }
        });
      } else {
        const nt = ce[0], [lt, je] = D(Se, nt);
        if (lt && je) {
          const at = nt[n.xAxis.dataKey], ct = Y(ye - N);
          Le.push([n.xAxis.dataKey, ct || at]);
          const wt = L(lt, je, n, yt);
          Le.push([lt, wt]);
        } else
          Object.keys(nt).forEach((at) => {
            Le.push([at, nt[at]]);
          });
      }
    }
    const Be = me.x + 10, ot = me.y, gt = {
      tooltipLeft: Be,
      tooltipTop: ot,
      tooltipData: {
        data: [...Le, ...Fe],
        dataXPosition: Be,
        dataYPosition: ot
      }
    };
    A(gt);
  }, V = () => {
    n.visualizationType === "Area Chart" ? setTimeout(() => {
      k();
    }, 3e3) : k();
  }, ae = (ne) => {
    if (n.xAxis.type === "categorical" || n.visualizationType === "Combo") {
      let G = m.step();
      const ye = Math.floor(Number(ne) / G);
      return m.domain()[ye - 1];
    }
    if (En(n.xAxis) && n.visualizationType !== "Combo") {
      const G = Im((ce) => u(ce[n.xAxis.dataKey])).left, me = m.invert(m(ne)), ye = G(n.data, me, 1);
      return u(n.data[ye - 1][n.xAxis.dataKey]);
    }
  }, Y = (ne, G = !1) => {
    if (v !== "Pie" && S !== "horizontal") {
      if (m.type === "point" || y.type === "continuous" || En(y)) {
        let me = null, ye = Number.MAX_VALUE, Se = ne;
        return t.forEach((ce) => {
          const ke = En(y) ? m(u(ce[y.dataKey])) : m(ce[y.dataKey]);
          let Ie = n.barHeight;
          const Le = Math.abs(Number(ke - Se + (G ? Ie * 2 : 0)));
          Le <= ye && (ye = Le, me = (En(y), ce[y.dataKey]));
        }), me;
      }
      if (n.xAxis.type === "categorical" || v === "Combo") {
        let ye = (m.range()[1] - m.range()[0]) / (m.domain().length + 1);
        const ce = Math.floor((Number(ne) - ye / 2) / ye);
        return m.domain()[ce];
      }
    }
  }, Q = (ne, G) => {
    let me;
    return ne.find(([ye, Se]) => {
      if (Se > G)
        return !0;
      me = ye;
    }), me;
  }, se = (ne, G) => {
    let me = null, ye = Number.MAX_VALUE, Se = ne;
    return G.forEach((ce) => {
      const ke = g(ce[n.runtime.series[0].originalDataKey]), Ie = Math.abs(Number(ke - Se));
      Ie <= ye && (ye = Ie, me = ce[n.runtime.series[0].dynamicCategory]);
    }), me;
  }, ie = (ne) => {
    const G = g.domain().map((ke, Ie) => ({ group: ke, index: Ie })), me = _f(n, G), ye = Q(
      me.map((ke) => [ke, Ke.round(ke.y)]),
      ne
    ), Se = ne - ye.y, ce = t.filter((ke) => ke[n.xAxis.dataKey] === ye.group);
    if (n.series.length > 1 && !n.series.find((ke) => ke.dynamicCategory)) {
      const ke = n.series.map((Xe, Be) => [Xe, n.barHeight * Be]), Ie = Q(ke, Se), Le = n.series.filter((Xe) => Xe.dataKey !== Ie.dataKey).map((Xe) => Xe.dataKey);
      return Ke.omit(ce[0], Le);
    } else {
      const ke = ce.map((Le, Fe) => [Le, n.barHeight * Fe]);
      return Q(ke, Se);
    }
  }, M = (ne, G = "") => {
    if (v === "Pie")
      return;
    let me = Number.MAX_VALUE, ye = null;
    return t.forEach((Se, ce) => {
      const ke = g(v !== "Forest Plot" ? Se[n.xAxis.dataKey] : ce), Ie = Math.abs(ke - ne);
      Ie < me && (me = Ie, ye = G ? Se[G] : Se[n.xAxis.dataKey]);
    }), ye;
  }, U = (ne) => {
    var G, me;
    try {
      if (n.visualizationType === "Bump Chart")
        return;
      const ye = Uf(ne), { x: Se } = ye;
      if (!Se)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let ce = Y(Se, !0), ke = (G = n.data) == null ? void 0 : G.filter((Ie) => Ie[n.xAxis.dataKey] === ce);
      if (!ce)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (En(y) && ce && (ce = new Date(ce), ce = o(ce), ke = (me = n.data) == null ? void 0 : me.filter((Ie) => o(new Date(Ie[n.xAxis.dataKey])) === ce)), !ke[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${ce}`);
      d && (n != null && n.uid) && (ke != null && ke[0]) && d(n.uid, ke[0]);
    } catch (ye) {
      console.error(ye.message);
    }
  }, re = ([ne, G]) => {
    if (S !== "vertical")
      return n.visualizationType === "Bar" && n.tooltips.singleSeries ? [ie(G)] : t.filter((Le) => Le[y.dataKey] === M(G));
    const ye = n.runtime.series.filter(
      (Le) => v === "Pie" || Le.tooltip === !0 && !Le.dynamicCategory
    ).map((Le) => Le.dataKey);
    ye.push(n.xAxis.dataKey);
    const Se = Ke.uniq(
      n.runtime.series.flatMap((Le) => {
        if (Le.dynamicCategory)
          return [Le.dynamicCategory, Le.originalDataKey];
      })
    );
    ye.push(...Se), n.visualizationType === "Forecasting" && n.runtime.series.map((Le) => {
      Le.confidenceIntervals.map((Fe) => {
        Fe.showInTooltip && (ye.push(Fe.high), ye.push(Fe.low));
      });
    });
    const ce = Object.values(n.columns).map((Le) => Le.name);
    ye.push(...ce, ...ce);
    const ke = Y(ne - N);
    let Ie = (t || []).filter((Le) => Le[y.dataKey] === ke);
    if (n.tooltips.singleSeries && n.visualizationType !== "Line") {
      const Le = n.series.find((Fe) => Fe.dynamicCategory);
      if (Le) {
        const Fe = Ie.map(
          (Be) => [Be, x(Be[Le.dynamicCategory])]
        ), Xe = ne - N - m(ke);
        Ie = [Q(Fe, Xe)];
      }
    }
    return Ie.map((Le) => Ke.pick(Le, ye));
  }, j = () => {
    const ne = n.runtime.series.filter((Se) => Se.type === "Forecasting"), G = ne.map((Se) => Se.stageColumn), me = ne.flatMap(
      (Se) => {
        var ce;
        return (ce = Se.confidenceIntervals) == null ? void 0 : ce.filter((ke) => ke.showInTooltip).map((ke) => [ke.low, ke.high]);
      }
    ), ye = [R.xAxis.dataKey, ...R == null ? void 0 : R.seriesKeys];
    switch (v) {
      case "Line":
      case "Area Chart":
      case "Pie":
        return ye;
      case "Combo":
        return [...ye, ...me];
      case "Forecasting":
        return [R.xAxis.dataKey, ...G, ...me];
      case "Bar":
        return S === "vertical" ? ye : [R.yAxis.dataKey, ...R == null ? void 0 : R.seriesKeys];
      default:
        throw new Error("No visualization type found in handleTooltipMouseOver");
    }
  }, de = (ne) => {
    const { dataXPosition: G, dataYPosition: me } = ne;
    return {
      opacity: n.tooltips.opacity ? n.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${G}px, ${Number(me)}px)`
    };
  }, Z = (ne) => {
    var me, ye;
    let G = n.runtime.series.filter((Se) => Se.dataKey === ne);
    return (me = G[0]) != null && me.name ? (ye = G[0]) == null ? void 0 : ye.name : ne;
  };
  return {
    getIncludedTooltipSeries: j,
    getXValueFromCoordinate: Y,
    getXValueFromCoordinateDate: ae,
    handleTooltipClick: U,
    handleTooltipMouseOff: V,
    handleTooltipMouseOver: q,
    TooltipListItem: ({ item: ne }) => {
      var gt;
      const [G, me] = ne, [ye, Se, ce] = me;
      if (v === "Forest Plot")
        return ye === n.xAxis.dataKey ? /* @__PURE__ */ a("li", { className: "tooltip-heading", children: `${i(n.xAxis.dataKey ? `${n.xAxis.dataKey}: ` : "")} ${En(B) ? o(u(ye, !1)) : Se}` }) : /* @__PURE__ */ a("li", { className: "tooltip-body", children: `${Z(ye)}: ${r(Se, "left")}` });
      const ke = n.tooltips.dateDisplayFormat ? h(u(Se, !1)) : o(u(Se, !1));
      if (v === "Bar" && S === "horizontal" && ye === n.xAxis.dataKey)
        return /* @__PURE__ */ a("li", { className: "tooltip-heading", children: `${i(
          n.runtime.yAxis.label ? `${n.runtime.yAxis.label}: ` : ""
        )} ${n.xAxis.type === "date" ? ke : Se}` });
      if (ye === n.xAxis.dataKey)
        return /* @__PURE__ */ a("li", { className: "tooltip-heading", children: `${i(
          n.runtime.xAxis.label ? `${n.runtime.xAxis.label}: ` : ""
        )} ${En(y) ? ke : Se}` });
      const { label: Ie, displayGray: Le } = n.visualizationSubType !== "stacked" && n.general.showSuppressedSymbol && ((gt = n.preliminaryData) == null ? void 0 : gt.find(
        (st) => st.label && st.type === "suppression" && st.displayTooltip && Se === st.value && (!st.column || ye === st.column)
      )) || {};
      let Fe = Ie || Se;
      const Xe = Le ? { color: "#8b8b8a" } : {};
      G == 1 && n.dataFormat.onlyShowTopPrefixSuffix && (Fe = `${n.dataFormat.prefix}${Fe}${n.dataFormat.suffix}`);
      const Be = Z(ye), ot = Be ? `${Be}: ${Fe}` : Fe;
      return /* @__PURE__ */ a("li", { style: Xe, className: "tooltip-body", children: ot });
    },
    tooltipStyles: de
  };
};
function Pf(e, { threshold: t = 0, root: n = null, rootMargin: r = "0%", freezeOnceVisible: i = !1 }) {
  const [o, h] = he.useState(), u = (o == null ? void 0 : o.isIntersecting) && i, d = ([p]) => {
    h(p);
  };
  return he.useEffect(() => {
    const p = e == null ? void 0 : e.current;
    if (!!!window.IntersectionObserver || u || !p)
      return;
    const g = { threshold: t, root: n, rootMargin: r }, x = new IntersectionObserver(d, g);
    return x.observe(p), () => x.disconnect();
  }, [e, t, n, r, u]), o;
}
const jh = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let n = "";
    return e.visualizationType && (n += `${e.visualizationType} chart`), e.title && e.visualizationType && (n += ` with the title: ${e.title}`), n;
  } catch (n) {
    console.error("COVE: ", n.message);
  }
}, Jp = Symbol("implicit");
function Nf() {
  var e = new lp(), t = [], n = [], r = Jp;
  function i(o) {
    let h = e.get(o);
    if (h === void 0) {
      if (r !== Jp)
        return r;
      e.set(o, h = t.push(o) - 1);
    }
    return n[h % n.length];
  }
  return i.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new lp();
    for (const h of o)
      e.has(h) || e.set(h, t.push(h) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (n = Array.from(o), i) : n.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (r = o, i) : r;
  }, i.copy = function() {
    return Nf(t, n).unknown(r);
  }, Mc.apply(i, arguments), i;
}
function Rf() {
  var e = Nf().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, o, h, u = !1, d = 0, p = 0, m = 0.5;
  delete e.unknown;
  function g() {
    var x = t().length, A = i < r, k = A ? i : r, y = A ? r : i;
    o = (y - k) / Math.max(1, x - d + p * 2), u && (o = Math.floor(o)), k += (y - k - o * (x - d)) * m, h = o * (1 - d), u && (k = Math.round(k), h = Math.round(h));
    var v = Rv(x).map(function(S) {
      return k + o * S;
    });
    return n(A ? v.reverse() : v);
  }
  return e.domain = function(x) {
    return arguments.length ? (t(x), g()) : t();
  }, e.range = function(x) {
    return arguments.length ? ([r, i] = x, r = +r, i = +i, g()) : [r, i];
  }, e.rangeRound = function(x) {
    return [r, i] = x, r = +r, i = +i, u = !0, g();
  }, e.bandwidth = function() {
    return h;
  }, e.step = function() {
    return o;
  }, e.round = function(x) {
    return arguments.length ? (u = !!x, g()) : u;
  }, e.padding = function(x) {
    return arguments.length ? (d = Math.min(1, p = +x), g()) : d;
  }, e.paddingInner = function(x) {
    return arguments.length ? (d = Math.min(1, x), g()) : d;
  }, e.paddingOuter = function(x) {
    return arguments.length ? (p = +x, g()) : p;
  }, e.align = function(x) {
    return arguments.length ? (m = Math.max(0, Math.min(1, x)), g()) : m;
  }, e.copy = function() {
    return Rf(t(), [r, i]).round(u).paddingInner(d).paddingOuter(p).align(m);
  }, Mc.apply(g(), arguments);
}
function ug(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return ug(t());
  }, e;
}
function fS() {
  return ug(Rf.apply(null, arguments).paddingInner(1));
}
function cg(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, i = e[n], o = e[r], h;
  return o < i && (h = n, n = r, r = h, h = i, i = o, o = h), e[n] = t.floor(i), e[r] = t.ceil(o), e;
}
function em(e) {
  return Math.log(e);
}
function tm(e) {
  return Math.exp(e);
}
function pS(e) {
  return -Math.log(-e);
}
function mS(e) {
  return -Math.exp(-e);
}
function yS(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function gS(e) {
  return e === 10 ? yS : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function vS(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function nm(e) {
  return (t, n) => -e(-t, n);
}
function bS(e) {
  const t = e(em, tm), n = t.domain;
  let r = 10, i, o;
  function h() {
    return i = vS(r), o = gS(r), n()[0] < 0 ? (i = nm(i), o = nm(o), e(pS, mS)) : e(em, tm), t;
  }
  return t.base = function(u) {
    return arguments.length ? (r = +u, h()) : r;
  }, t.domain = function(u) {
    return arguments.length ? (n(u), h()) : n();
  }, t.ticks = (u) => {
    const d = n();
    let p = d[0], m = d[d.length - 1];
    const g = m < p;
    g && ([p, m] = [m, p]);
    let x = i(p), A = i(m), k, y;
    const v = u == null ? 10 : +u;
    let S = [];
    if (!(r % 1) && A - x < v) {
      if (x = Math.floor(x), A = Math.ceil(A), p > 0) {
        for (; x <= A; ++x)
          for (k = 1; k < r; ++k)
            if (y = x < 0 ? k / o(-x) : k * o(x), !(y < p)) {
              if (y > m)
                break;
              S.push(y);
            }
      } else
        for (; x <= A; ++x)
          for (k = r - 1; k >= 1; --k)
            if (y = x > 0 ? k / o(-x) : k * o(x), !(y < p)) {
              if (y > m)
                break;
              S.push(y);
            }
      S.length * 2 < v && (S = Jf(p, m, v));
    } else
      S = Jf(x, A, Math.min(A - x, v)).map(o);
    return g ? S.reverse() : S;
  }, t.tickFormat = (u, d) => {
    if (u == null && (u = 10), d == null && (d = r === 10 ? "s" : ","), typeof d != "function" && (!(r % 1) && (d = yv(d)).precision == null && (d.trim = !0), d = gv(d)), u === 1 / 0)
      return d;
    const p = Math.max(1, r * u / t.ticks().length);
    return (m) => {
      let g = m / o(Math.round(i(m)));
      return g * r < r - 0.5 && (g *= r), g <= p ? d(m) : "";
    };
  }, t.nice = () => n(cg(n(), {
    floor: (u) => o(Math.floor(i(u))),
    ceil: (u) => o(Math.ceil(i(u)))
  })), t;
}
function dg() {
  const e = bS(mv()).domain([1, 10]);
  return e.copy = () => Bm(e, dg()).base(e.base()), Mc.apply(e, arguments), e;
}
function xS(e) {
  return new Date(e);
}
function SS(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function hg(e, t, n, r, i, o, h, u, d, p) {
  var m = vv(), g = m.invert, x = m.domain, A = p(".%L"), k = p(":%S"), y = p("%I:%M"), v = p("%I %p"), S = p("%a %d"), B = p("%b %d"), R = p("%B"), N = p("%Y");
  function D(L) {
    return (d(L) < L ? A : u(L) < L ? k : h(L) < L ? y : o(L) < L ? v : r(L) < L ? i(L) < L ? S : B : n(L) < L ? R : N)(L);
  }
  return m.invert = function(L) {
    return new Date(g(L));
  }, m.domain = function(L) {
    return arguments.length ? x(Array.from(L, SS)) : x().map(xS);
  }, m.ticks = function(L) {
    var q = x();
    return e(q[0], q[q.length - 1], L ?? 10);
  }, m.tickFormat = function(L, q) {
    return q == null ? D : p(q);
  }, m.nice = function(L) {
    var q = x();
    return (!L || typeof L.range != "function") && (L = t(q[0], q[q.length - 1], L ?? 10)), L ? x(cg(q, L)) : m;
  }, m.copy = function() {
    return Bm(m, hg(e, t, n, r, i, o, h, u, d, p));
  }, m;
}
function fg() {
  return Mc.apply(hg(Ov, Fv, Wm, Hm, Km, jm, $m, zm, dl, Xu).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var wS = Fl("domain", "range", "reverse", "align", "padding", "round");
function wc(e) {
  return wS(Rf(), e);
}
var kS = Fl("domain", "range", "reverse", "align", "padding", "round");
function es(e) {
  return kS(fS(), e);
}
var TS = Fl("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function CS(e) {
  return TS(fg(), e);
}
var AS = Fl("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function kc(e) {
  return AS(dg(), e);
}
var LS = Fl("domain", "range", "reverse", "unknown");
function Df(e) {
  return LS(Nf(), e);
}
function ES(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function pg(e, t) {
  var n = e;
  return "ticks" in n ? n.ticks(t) : n.domain().filter(function(r, i, o) {
    return t == null || o.length <= t || i % Math.round((o.length - 1) / t) === 0;
  });
}
function _S(e) {
  return e == null ? void 0 : e.toString();
}
const PS = (e) => {
  const {
    transformedData: t,
    config: n,
    colorScale: r,
    currentViewport: i,
    seriesHighlight: o,
    isDraggingAnnotation: h
  } = he.useContext(pt), { tooltipData: u, showTooltip: d, hideTooltip: p, tooltipOpen: m, tooltipLeft: g, tooltipTop: x } = rg(), { handleTooltipMouseOver: A, handleTooltipMouseOff: k, TooltipListItem: y } = lg({
    xScale: !1,
    yScale: !1,
    showTooltip: d,
    hideTooltip: p
  }), [v, S] = he.useState(void 0), [B, R] = he.useState(!1), N = Object.values(n.columns).filter((ge) => ge.showInViz), D = N.length > 0, L = D ? "pivotColumn" : void 0, q = he.useMemo(() => {
    if (D) {
      let ge = [];
      const ne = n.yAxis.dataKey, G = N.map((Se) => Se.name), me = [ne, ...G], ye = n.xAxis.dataKey;
      return t.forEach((Se) => {
        me.forEach((ce) => {
          const ke = Se[ce];
          ke && ge.push({
            [L]: ke,
            [ye]: `${Se[ye]} - ${ce}`
          });
        });
      }), ge;
    }
    return t;
  }, [t, D]), V = he.useMemo(() => {
    if (D) {
      const ge = {};
      q.forEach((me) => {
        ge[me[n.xAxis.dataKey]] || (ge[me[n.xAxis.dataKey]] = !0);
      });
      const ne = Object.entries(ge).length;
      let G = n.customColors || Lr[n.palette];
      return G = G.slice(0, ne), Df({
        domain: Object.keys(ge),
        range: G,
        unknown: null
      });
    }
    return r;
  }, [r, D]), ae = he.useRef(), Y = Pf(ae, {
    freezeOnceVisible: !1
  });
  he.useEffect(() => {
    document.querySelector(".isEditor") && R((ne) => !0);
  }), he.useEffect(() => {
    Y != null && Y.isIntersecting && n.animate && !B && setTimeout(() => {
      R(!0);
    }, 500);
  }, [Y == null ? void 0 : Y.isIntersecting, n.animate]);
  function Q({ arcs: ge, path: ne, getKey: G, colorScale: me, onHover: ye, onLeave: Se }) {
    const ce = ({ startAngle: Ie, endAngle: Le }) => ({ startAngle: Ie, endAngle: Le });
    return xx(ge, {
      keys: G,
      from: ce,
      enter: ce,
      update: ce,
      leave: ce
    })((Ie, Le) => {
      const Fe = G(Le);
      let Xe = "#FFF";
      Fe && V(Fe) && (Xe = is(Xe, V(Le.data[n.runtime.xAxis.dataKey])));
      const Be = Number(n.dataFormat.roundTo) || 0, st = ((Le.endAngle - Le.startAngle) * 180 / Math.PI / 360 * 100).toFixed(Be) + "%";
      return /* @__PURE__ */ O(qe, { className: `slice-${Fe}`, children: [
        /* @__PURE__ */ a(
          Wp.path,
          {
            d: Hp(
              [Ie.startAngle, Ie.endAngle],
              (dt, Ye) => ne({ ...Le, startAngle: dt, endAngle: Ye })
            ),
            fill: me(Fe),
            onMouseEnter: (dt) => ye(dt, {
              data: Le.data,
              dataXPosition: dt.clientX,
              dataYPosition: dt.clientY,
              startAngle: Le.startAngle,
              endAngle: Le.endAngle
            }),
            onMouseLeave: Se
          }
        ),
        Le.endAngle - Le.startAngle > 0.1 && /* @__PURE__ */ a(
          Wp.text,
          {
            transform: Hp([Ie.startAngle, Ie.endAngle], (dt, Ye) => {
              const [Je, yt] = ne.centroid({
                ...Le,
                startAngle: dt,
                endAngle: Ye
              });
              return `translate(${Je},${yt})`;
            }),
            textAnchor: "middle",
            pointerEvents: "none",
            fill: Xe,
            children: st
          }
        )
      ] }, Fe);
    });
  }
  let se = e.parentWidth, ie = e.parentWidth;
  n && n.legend && !n.legend.hide && i === "lg" && (ie = Number(se) * 0.73);
  const M = n.heights.vertical, U = Math.min(ie, M) / 2, re = M / 2, j = e.parentWidth / 2, de = n.pieType === "Donut" ? 75 : U;
  he.useEffect(() => {
    if (o.length > 0 && n.legend.behavior !== "highlight") {
      let ge = [];
      q.forEach((ne) => {
        o.indexOf(ne[n.runtime.xAxis.dataKey]) !== -1 && ge.push(ne);
      }), S(ge);
    } else
      S(void 0);
  }, [o]);
  const Z = () => {
    let ge = ["animated-pie", "group"];
    return (n.animate === !1 || B) && ge.push("animated"), ge.join(" ");
  };
  return /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O(qr, { component: "PieChart", children: [
    /* @__PURE__ */ a(
      "svg",
      {
        width: U * 2,
        height: M,
        className: Z(),
        role: "img",
        "aria-label": jh(n),
        children: /* @__PURE__ */ a(qe, { top: re, left: U, children: /* @__PURE__ */ a(
          E0,
          {
            data: v || q,
            pieValue: (ge) => parseFloat(ge[L || n.runtime.yAxis.dataKey]),
            pieSortValues: () => -1,
            innerRadius: U - de,
            outerRadius: U,
            children: (ge) => /* @__PURE__ */ a(
              Q,
              {
                ...ge,
                getKey: (ne) => ne.data[n.runtime.xAxis.dataKey],
                colorScale: V,
                onHover: A,
                onLeave: k
              }
            )
          }
        ) })
      }
    ),
    /* @__PURE__ */ a("div", { ref: ae }),
    !h && u && Object.entries(u.data).length > 0 && m && d && u.dataYPosition && u.dataXPosition && /* @__PURE__ */ O(ze, { children: [
      /* @__PURE__ */ a("style", { children: `.tooltip {background-color: rgba(255,255,255, ${n.tooltips.opacity / 100}) !important` }),
      /* @__PURE__ */ a(
        sg,
        {
          className: "tooltip cdc-open-viz-module",
          left: g + j - U,
          top: x,
          children: /* @__PURE__ */ a("ul", { children: typeof u == "object" && Object.entries(u.data).map((ge, ne) => /* @__PURE__ */ a(y, { item: ge }, ne)) })
        },
        Math.random()
      )
    ] })
  ] }) });
};
function rm(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function NS(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function rh(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      (r = +r) && (n += r);
  else {
    let r = -1;
    for (let i of e)
      (i = +t(i, ++r, e)) && (n += i);
  }
  return n;
}
function RS(e) {
  return e.depth;
}
function DS(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function Hu(e) {
  return function() {
    return e;
  };
}
function im(e, t) {
  return Tc(e.source, t.source) || e.index - t.index;
}
function am(e, t) {
  return Tc(e.target, t.target) || e.index - t.index;
}
function Tc(e, t) {
  return e.y0 - t.y0;
}
function ih(e) {
  return e.value;
}
function OS(e) {
  return e.index;
}
function FS(e) {
  return e.nodes;
}
function MS(e) {
  return e.links;
}
function om(e, t) {
  const n = e.get(t);
  if (!n)
    throw new Error("missing: " + t);
  return n;
}
function sm({ nodes: e }) {
  for (const t of e) {
    let n = t.y0, r = n;
    for (const i of t.sourceLinks)
      i.y0 = n + i.width / 2, n += i.width;
    for (const i of t.targetLinks)
      i.y1 = r + i.width / 2, r += i.width;
  }
}
function IS() {
  let e = 0, t = 0, n = 1, r = 1, i = 24, o = 8, h, u = OS, d = DS, p, m, g = FS, x = MS, A = 6;
  function k() {
    const U = { nodes: g.apply(null, arguments), links: x.apply(null, arguments) };
    return y(U), v(U), S(U), B(U), D(U), sm(U), U;
  }
  k.update = function(U) {
    return sm(U), U;
  }, k.nodeId = function(U) {
    return arguments.length ? (u = typeof U == "function" ? U : Hu(U), k) : u;
  }, k.nodeAlign = function(U) {
    return arguments.length ? (d = typeof U == "function" ? U : Hu(U), k) : d;
  }, k.nodeSort = function(U) {
    return arguments.length ? (p = U, k) : p;
  }, k.nodeWidth = function(U) {
    return arguments.length ? (i = +U, k) : i;
  }, k.nodePadding = function(U) {
    return arguments.length ? (o = h = +U, k) : o;
  }, k.nodes = function(U) {
    return arguments.length ? (g = typeof U == "function" ? U : Hu(U), k) : g;
  }, k.links = function(U) {
    return arguments.length ? (x = typeof U == "function" ? U : Hu(U), k) : x;
  }, k.linkSort = function(U) {
    return arguments.length ? (m = U, k) : m;
  }, k.size = function(U) {
    return arguments.length ? (e = t = 0, n = +U[0], r = +U[1], k) : [n - e, r - t];
  }, k.extent = function(U) {
    return arguments.length ? (e = +U[0][0], n = +U[1][0], t = +U[0][1], r = +U[1][1], k) : [[e, t], [n, r]];
  }, k.iterations = function(U) {
    return arguments.length ? (A = +U, k) : A;
  };
  function y({ nodes: U, links: re }) {
    for (const [de, Z] of U.entries())
      Z.index = de, Z.sourceLinks = [], Z.targetLinks = [];
    const j = new Map(U.map((de, Z) => [u(de, Z, U), de]));
    for (const [de, Z] of re.entries()) {
      Z.index = de;
      let { source: ge, target: ne } = Z;
      typeof ge != "object" && (ge = Z.source = om(j, ge)), typeof ne != "object" && (ne = Z.target = om(j, ne)), ge.sourceLinks.push(Z), ne.targetLinks.push(Z);
    }
    if (m != null)
      for (const { sourceLinks: de, targetLinks: Z } of U)
        de.sort(m), Z.sort(m);
  }
  function v({ nodes: U }) {
    for (const re of U)
      re.value = re.fixedValue === void 0 ? Math.max(rh(re.sourceLinks, ih), rh(re.targetLinks, ih)) : re.fixedValue;
  }
  function S({ nodes: U }) {
    const re = U.length;
    let j = new Set(U), de = /* @__PURE__ */ new Set(), Z = 0;
    for (; j.size; ) {
      for (const ge of j) {
        ge.depth = Z;
        for (const { target: ne } of ge.sourceLinks)
          de.add(ne);
      }
      if (++Z > re)
        throw new Error("circular link");
      j = de, de = /* @__PURE__ */ new Set();
    }
  }
  function B({ nodes: U }) {
    const re = U.length;
    let j = new Set(U), de = /* @__PURE__ */ new Set(), Z = 0;
    for (; j.size; ) {
      for (const ge of j) {
        ge.height = Z;
        for (const { source: ne } of ge.targetLinks)
          de.add(ne);
      }
      if (++Z > re)
        throw new Error("circular link");
      j = de, de = /* @__PURE__ */ new Set();
    }
  }
  function R({ nodes: U }) {
    const re = rm(U, (Z) => Z.depth) + 1, j = (n - e - i) / (re - 1), de = new Array(re);
    for (const Z of U) {
      const ge = Math.max(0, Math.min(re - 1, Math.floor(d.call(null, Z, re))));
      Z.layer = ge, Z.x0 = e + ge * j, Z.x1 = Z.x0 + i, de[ge] ? de[ge].push(Z) : de[ge] = [Z];
    }
    if (p)
      for (const Z of de)
        Z.sort(p);
    return de;
  }
  function N(U) {
    const re = NS(U, (j) => (r - t - (j.length - 1) * h) / rh(j, ih));
    for (const j of U) {
      let de = t;
      for (const Z of j) {
        Z.y0 = de, Z.y1 = de + Z.value * re, de = Z.y1 + h;
        for (const ge of Z.sourceLinks)
          ge.width = ge.value * re;
      }
      de = (r - de + h) / (j.length + 1);
      for (let Z = 0; Z < j.length; ++Z) {
        const ge = j[Z];
        ge.y0 += de * (Z + 1), ge.y1 += de * (Z + 1);
      }
      se(j);
    }
  }
  function D(U) {
    const re = R(U);
    h = Math.min(o, (r - t) / (rm(re, (j) => j.length) - 1)), N(re);
    for (let j = 0; j < A; ++j) {
      const de = Math.pow(0.99, j), Z = Math.max(1 - de, (j + 1) / A);
      q(re, de, Z), L(re, de, Z);
    }
  }
  function L(U, re, j) {
    for (let de = 1, Z = U.length; de < Z; ++de) {
      const ge = U[de];
      for (const ne of ge) {
        let G = 0, me = 0;
        for (const { source: Se, value: ce } of ne.targetLinks) {
          let ke = ce * (ne.layer - Se.layer);
          G += ie(Se, ne) * ke, me += ke;
        }
        if (!(me > 0))
          continue;
        let ye = (G / me - ne.y0) * re;
        ne.y0 += ye, ne.y1 += ye, Q(ne);
      }
      p === void 0 && ge.sort(Tc), V(ge, j);
    }
  }
  function q(U, re, j) {
    for (let de = U.length, Z = de - 2; Z >= 0; --Z) {
      const ge = U[Z];
      for (const ne of ge) {
        let G = 0, me = 0;
        for (const { target: Se, value: ce } of ne.sourceLinks) {
          let ke = ce * (Se.layer - ne.layer);
          G += M(ne, Se) * ke, me += ke;
        }
        if (!(me > 0))
          continue;
        let ye = (G / me - ne.y0) * re;
        ne.y0 += ye, ne.y1 += ye, Q(ne);
      }
      p === void 0 && ge.sort(Tc), V(ge, j);
    }
  }
  function V(U, re) {
    const j = U.length >> 1, de = U[j];
    Y(U, de.y0 - h, j - 1, re), ae(U, de.y1 + h, j + 1, re), Y(U, r, U.length - 1, re), ae(U, t, 0, re);
  }
  function ae(U, re, j, de) {
    for (; j < U.length; ++j) {
      const Z = U[j], ge = (re - Z.y0) * de;
      ge > 1e-6 && (Z.y0 += ge, Z.y1 += ge), re = Z.y1 + h;
    }
  }
  function Y(U, re, j, de) {
    for (; j >= 0; --j) {
      const Z = U[j], ge = (Z.y1 - re) * de;
      ge > 1e-6 && (Z.y0 -= ge, Z.y1 -= ge), re = Z.y0 - h;
    }
  }
  function Q({ sourceLinks: U, targetLinks: re }) {
    if (m === void 0) {
      for (const { source: { sourceLinks: j } } of re)
        j.sort(am);
      for (const { target: { targetLinks: j } } of U)
        j.sort(im);
    }
  }
  function se(U) {
    if (m === void 0)
      for (const { sourceLinks: re, targetLinks: j } of U)
        re.sort(am), j.sort(im);
  }
  function ie(U, re) {
    let j = U.y0 - (U.sourceLinks.length - 1) * h / 2;
    for (const { target: de, width: Z } of U.sourceLinks) {
      if (de === re)
        break;
      j += Z + h;
    }
    for (const { source: de, width: Z } of re.targetLinks) {
      if (de === U)
        break;
      j -= Z;
    }
    return j;
  }
  function M(U, re) {
    let j = re.y0 - (re.targetLinks.length - 1) * h / 2;
    for (const { source: de, width: Z } of re.targetLinks) {
      if (de === U)
        break;
      j += Z + h;
    }
    for (const { target: de, width: Z } of U.sourceLinks) {
      if (de === re)
        break;
      j -= Z;
    }
    return j;
  }
  return k;
}
function BS(e) {
  return [e.source.x1, e.y0];
}
function zS(e) {
  return [e.target.x0, e.y1];
}
function $S() {
  return qx().source(BS).target(zS);
}
const HS = () => {
  const { config: e, handleChartTabbing: t, legendId: n } = he.useContext(pt), [r, i] = he.useState(!1), o = /* @__PURE__ */ O(ze, { children: [
    "For best viewing we recommend portrait mode. If you are unable to put your device in portrait mode, please review the ",
    /* @__PURE__ */ a("a", { href: `#${t(e, n)}`, children: "data table" }),
    " below.",
    " ",
    /* @__PURE__ */ a("a", { onClick: () => i(!1), href: "#!", children: "Close this alert" }),
    " ",
    "to continue viewing the chart."
  ] }), h = () => {
    i(!1);
  }, u = r ? /* @__PURE__ */ O("div", { className: "alert alert-warning alert-dismissible", role: "alert", children: [
    /* @__PURE__ */ a("p", { style: { padding: "35px" }, children: o }),
    /* @__PURE__ */ a("button", { type: "button", className: "close", "data-dismiss": "alert", "aria-label": "Close", onClick: h, children: /* @__PURE__ */ a("span", { "aria-hidden": "true", children: "×" }) })
  ] }) : null;
  return he.useEffect(() => {
    const d = () => {
      window.innerWidth < 768 && window.innerHeight > window.innerWidth ? i(!0) : i(!1);
    };
    return window.addEventListener("resize", d), d(), () => {
      window.removeEventListener("resize", d);
    };
  }, []), {
    setShowAlert: i,
    showAlert: r,
    handleCloseModal: h,
    alertMessage: o,
    alert: u
  };
};
var ta = {}, Ma = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lm;
function VS() {
  if (lm)
    return Ma;
  lm = 1;
  var e = he;
  function t(b) {
    for (var C = "https://reactjs.org/docs/error-decoder.html?invariant=" + b, I = 1; I < arguments.length; I++)
      C += "&args[]=" + encodeURIComponent(arguments[I]);
    return "Minified React error #" + b + "; visit " + C + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = Object.prototype.hasOwnProperty, r = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, i = {}, o = {};
  function h(b) {
    return n.call(o, b) ? !0 : n.call(i, b) ? !1 : r.test(b) ? o[b] = !0 : (i[b] = !0, !1);
  }
  function u(b, C, I, H, oe, pe, we) {
    this.acceptsBooleans = C === 2 || C === 3 || C === 4, this.attributeName = H, this.attributeNamespace = oe, this.mustUseProperty = I, this.propertyName = b, this.type = C, this.sanitizeURL = pe, this.removeEmptyString = we;
  }
  var d = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(b) {
    d[b] = new u(b, 0, !1, b, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(b) {
    var C = b[0];
    d[C] = new u(C, 1, !1, b[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(b) {
    d[b] = new u(b, 2, !1, b.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(b) {
    d[b] = new u(b, 2, !1, b, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(b) {
    d[b] = new u(b, 3, !1, b.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(b) {
    d[b] = new u(b, 3, !0, b, null, !1, !1);
  }), ["capture", "download"].forEach(function(b) {
    d[b] = new u(b, 4, !1, b, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(b) {
    d[b] = new u(b, 6, !1, b, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(b) {
    d[b] = new u(b, 5, !1, b.toLowerCase(), null, !1, !1);
  });
  var p = /[\-:]([a-z])/g;
  function m(b) {
    return b[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(b) {
    var C = b.replace(
      p,
      m
    );
    d[C] = new u(C, 1, !1, b, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(b) {
    var C = b.replace(p, m);
    d[C] = new u(C, 1, !1, b, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(b) {
    var C = b.replace(p, m);
    d[C] = new u(C, 1, !1, b, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(b) {
    d[b] = new u(b, 1, !1, b.toLowerCase(), null, !1, !1);
  }), d.xlinkHref = new u("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(b) {
    d[b] = new u(b, 1, !1, b.toLowerCase(), null, !0, !0);
  });
  var g = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, x = ["Webkit", "ms", "Moz", "O"];
  Object.keys(g).forEach(function(b) {
    x.forEach(function(C) {
      C = C + b.charAt(0).toUpperCase() + b.substring(1), g[C] = g[b];
    });
  });
  var A = /["'&<>]/;
  function k(b) {
    if (typeof b == "boolean" || typeof b == "number")
      return "" + b;
    b = "" + b;
    var C = A.exec(b);
    if (C) {
      var I = "", H, oe = 0;
      for (H = C.index; H < b.length; H++) {
        switch (b.charCodeAt(H)) {
          case 34:
            C = "&quot;";
            break;
          case 38:
            C = "&amp;";
            break;
          case 39:
            C = "&#x27;";
            break;
          case 60:
            C = "&lt;";
            break;
          case 62:
            C = "&gt;";
            break;
          default:
            continue;
        }
        oe !== H && (I += b.substring(oe, H)), oe = H + 1, I += C;
      }
      b = oe !== H ? I + b.substring(oe, H) : I;
    }
    return b;
  }
  var y = /([A-Z])/g, v = /^ms-/, S = Array.isArray;
  function B(b, C) {
    return { insertionMode: b, selectedValue: C };
  }
  function R(b, C, I) {
    switch (C) {
      case "select":
        return B(1, I.value != null ? I.value : I.defaultValue);
      case "svg":
        return B(2, null);
      case "math":
        return B(3, null);
      case "foreignObject":
        return B(1, null);
      case "table":
        return B(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return B(5, null);
      case "colgroup":
        return B(7, null);
      case "tr":
        return B(6, null);
    }
    return 4 <= b.insertionMode || b.insertionMode === 0 ? B(1, null) : b;
  }
  var N = /* @__PURE__ */ new Map();
  function D(b, C, I) {
    if (typeof I != "object")
      throw Error(t(62));
    C = !0;
    for (var H in I)
      if (n.call(I, H)) {
        var oe = I[H];
        if (oe != null && typeof oe != "boolean" && oe !== "") {
          if (H.indexOf("--") === 0) {
            var pe = k(H);
            oe = k(("" + oe).trim());
          } else {
            pe = H;
            var we = N.get(pe);
            we !== void 0 || (we = k(pe.replace(y, "-$1").toLowerCase().replace(v, "-ms-")), N.set(pe, we)), pe = we, oe = typeof oe == "number" ? oe === 0 || n.call(g, H) ? "" + oe : oe + "px" : k(("" + oe).trim());
          }
          C ? (C = !1, b.push(' style="', pe, ":", oe)) : b.push(";", pe, ":", oe);
        }
      }
    C || b.push('"');
  }
  function L(b, C, I, H) {
    switch (I) {
      case "style":
        D(b, C, H);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < I.length) || I[0] !== "o" && I[0] !== "O" || I[1] !== "n" && I[1] !== "N") {
      if (C = d.hasOwnProperty(I) ? d[I] : null, C !== null) {
        switch (typeof H) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!C.acceptsBooleans)
              return;
        }
        switch (I = C.attributeName, C.type) {
          case 3:
            H && b.push(" ", I, '=""');
            break;
          case 4:
            H === !0 ? b.push(" ", I, '=""') : H !== !1 && b.push(" ", I, '="', k(H), '"');
            break;
          case 5:
            isNaN(H) || b.push(" ", I, '="', k(H), '"');
            break;
          case 6:
            !isNaN(H) && 1 <= H && b.push(" ", I, '="', k(H), '"');
            break;
          default:
            C.sanitizeURL && (H = "" + H), b.push(" ", I, '="', k(H), '"');
        }
      } else if (h(I)) {
        switch (typeof H) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (C = I.toLowerCase().slice(0, 5), C !== "data-" && C !== "aria-")
              return;
        }
        b.push(" ", I, '="', k(H), '"');
      }
    }
  }
  function q(b, C, I) {
    if (C != null) {
      if (I != null)
        throw Error(t(60));
      if (typeof C != "object" || !("__html" in C))
        throw Error(t(61));
      C = C.__html, C != null && b.push("" + C);
    }
  }
  function V(b) {
    var C = "";
    return e.Children.forEach(b, function(I) {
      I != null && (C += I);
    }), C;
  }
  function ae(b, C, I, H) {
    b.push(se(I));
    var oe = I = null, pe;
    for (pe in C)
      if (n.call(C, pe)) {
        var we = C[pe];
        if (we != null)
          switch (pe) {
            case "children":
              I = we;
              break;
            case "dangerouslySetInnerHTML":
              oe = we;
              break;
            default:
              L(b, H, pe, we);
          }
      }
    return b.push(">"), q(b, oe, I), typeof I == "string" ? (b.push(k(I)), null) : I;
  }
  var Y = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Q = /* @__PURE__ */ new Map();
  function se(b) {
    var C = Q.get(b);
    if (C === void 0) {
      if (!Y.test(b))
        throw Error(t(65, b));
      C = "<" + b, Q.set(b, C);
    }
    return C;
  }
  function ie(b, C, I, H, oe) {
    switch (C) {
      case "select":
        b.push(se("select"));
        var pe = null, we = null;
        for (be in I)
          if (n.call(I, be)) {
            var K = I[be];
            if (K != null)
              switch (be) {
                case "children":
                  pe = K;
                  break;
                case "dangerouslySetInnerHTML":
                  we = K;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  L(b, H, be, K);
              }
          }
        return b.push(">"), q(b, we, pe), pe;
      case "option":
        we = oe.selectedValue, b.push(se("option"));
        var X = K = null, le = null, be = null;
        for (pe in I)
          if (n.call(I, pe)) {
            var Ue = I[pe];
            if (Ue != null)
              switch (pe) {
                case "children":
                  K = Ue;
                  break;
                case "selected":
                  le = Ue;
                  break;
                case "dangerouslySetInnerHTML":
                  be = Ue;
                  break;
                case "value":
                  X = Ue;
                default:
                  L(b, H, pe, Ue);
              }
          }
        if (we != null)
          if (I = X !== null ? "" + X : V(K), S(we)) {
            for (H = 0; H < we.length; H++)
              if ("" + we[H] === I) {
                b.push(' selected=""');
                break;
              }
          } else
            "" + we === I && b.push(' selected=""');
        else
          le && b.push(' selected=""');
        return b.push(">"), q(b, be, K), K;
      case "textarea":
        b.push(se("textarea")), be = we = pe = null;
        for (K in I)
          if (n.call(I, K) && (X = I[K], X != null))
            switch (K) {
              case "children":
                be = X;
                break;
              case "value":
                pe = X;
                break;
              case "defaultValue":
                we = X;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                L(
                  b,
                  H,
                  K,
                  X
                );
            }
        if (pe === null && we !== null && (pe = we), b.push(">"), be != null) {
          if (pe != null)
            throw Error(t(92));
          if (S(be) && 1 < be.length)
            throw Error(t(93));
          pe = "" + be;
        }
        return typeof pe == "string" && pe[0] === `
` && b.push(`
`), pe !== null && b.push(k("" + pe)), null;
      case "input":
        b.push(se("input")), X = be = K = pe = null;
        for (we in I)
          if (n.call(I, we) && (le = I[we], le != null))
            switch (we) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                X = le;
                break;
              case "defaultValue":
                K = le;
                break;
              case "checked":
                be = le;
                break;
              case "value":
                pe = le;
                break;
              default:
                L(b, H, we, le);
            }
        return be !== null ? L(b, H, "checked", be) : X !== null && L(b, H, "checked", X), pe !== null ? L(b, H, "value", pe) : K !== null && L(b, H, "value", K), b.push("/>"), null;
      case "menuitem":
        b.push(se("menuitem"));
        for (var Ft in I)
          if (n.call(I, Ft) && (pe = I[Ft], pe != null))
            switch (Ft) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                L(b, H, Ft, pe);
            }
        return b.push(">"), null;
      case "title":
        b.push(se("title")), pe = null;
        for (Ue in I)
          if (n.call(I, Ue) && (we = I[Ue], we != null))
            switch (Ue) {
              case "children":
                pe = we;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                L(b, H, Ue, we);
            }
        return b.push(">"), pe;
      case "listing":
      case "pre":
        b.push(se(C)), we = pe = null;
        for (X in I)
          if (n.call(I, X) && (K = I[X], K != null))
            switch (X) {
              case "children":
                pe = K;
                break;
              case "dangerouslySetInnerHTML":
                we = K;
                break;
              default:
                L(b, H, X, K);
            }
        if (b.push(">"), we != null) {
          if (pe != null)
            throw Error(t(60));
          if (typeof we != "object" || !("__html" in we))
            throw Error(t(61));
          I = we.__html, I != null && (typeof I == "string" && 0 < I.length && I[0] === `
` ? b.push(`
`, I) : b.push("" + I));
        }
        return typeof pe == "string" && pe[0] === `
` && b.push(`
`), pe;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        b.push(se(C));
        for (var Ht in I)
          if (n.call(I, Ht) && (pe = I[Ht], pe != null))
            switch (Ht) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, C));
              default:
                L(b, H, Ht, pe);
            }
        return b.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return ae(
          b,
          I,
          C,
          H
        );
      case "html":
        return oe.insertionMode === 0 && b.push("<!DOCTYPE html>"), ae(b, I, C, H);
      default:
        if (C.indexOf("-") === -1 && typeof I.is != "string")
          return ae(b, I, C, H);
        b.push(se(C)), we = pe = null;
        for (le in I)
          if (n.call(I, le) && (K = I[le], K != null))
            switch (le) {
              case "children":
                pe = K;
                break;
              case "dangerouslySetInnerHTML":
                we = K;
                break;
              case "style":
                D(b, H, K);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                h(le) && typeof K != "function" && typeof K != "symbol" && b.push(" ", le, '="', k(K), '"');
            }
        return b.push(">"), q(b, we, pe), pe;
    }
  }
  function M(b, C, I) {
    if (b.push('<!--$?--><template id="'), I === null)
      throw Error(t(395));
    return b.push(I), b.push('"></template>');
  }
  function U(b, C, I, H) {
    switch (I.insertionMode) {
      case 0:
      case 1:
        return b.push('<div hidden id="'), b.push(C.segmentPrefix), C = H.toString(16), b.push(C), b.push('">');
      case 2:
        return b.push('<svg aria-hidden="true" style="display:none" id="'), b.push(C.segmentPrefix), C = H.toString(16), b.push(C), b.push('">');
      case 3:
        return b.push('<math aria-hidden="true" style="display:none" id="'), b.push(C.segmentPrefix), C = H.toString(16), b.push(C), b.push('">');
      case 4:
        return b.push('<table hidden id="'), b.push(C.segmentPrefix), C = H.toString(16), b.push(C), b.push('">');
      case 5:
        return b.push('<table hidden><tbody id="'), b.push(C.segmentPrefix), C = H.toString(16), b.push(C), b.push('">');
      case 6:
        return b.push('<table hidden><tr id="'), b.push(C.segmentPrefix), C = H.toString(16), b.push(C), b.push('">');
      case 7:
        return b.push('<table hidden><colgroup id="'), b.push(C.segmentPrefix), C = H.toString(16), b.push(C), b.push('">');
      default:
        throw Error(t(397));
    }
  }
  function re(b, C) {
    switch (C.insertionMode) {
      case 0:
      case 1:
        return b.push("</div>");
      case 2:
        return b.push("</svg>");
      case 3:
        return b.push("</math>");
      case 4:
        return b.push("</table>");
      case 5:
        return b.push("</tbody></table>");
      case 6:
        return b.push("</tr></table>");
      case 7:
        return b.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var j = /[<\u2028\u2029]/g;
  function de(b) {
    return JSON.stringify(b).replace(j, function(C) {
      switch (C) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function Z(b, C) {
    return C = C === void 0 ? "" : C, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: C + "P:", segmentPrefix: C + "S:", boundaryPrefix: C + "B:", idPrefix: C, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: b };
  }
  function ge(b, C, I, H) {
    return I.generateStaticMarkup ? (b.push(k(C)), !1) : (C === "" ? b = H : (H && b.push("<!-- -->"), b.push(k(C)), b = !0), b);
  }
  var ne = Object.assign, G = Symbol.for("react.element"), me = Symbol.for("react.portal"), ye = Symbol.for("react.fragment"), Se = Symbol.for("react.strict_mode"), ce = Symbol.for("react.profiler"), ke = Symbol.for("react.provider"), Ie = Symbol.for("react.context"), Le = Symbol.for("react.forward_ref"), Fe = Symbol.for("react.suspense"), Xe = Symbol.for("react.suspense_list"), Be = Symbol.for("react.memo"), ot = Symbol.for("react.lazy"), gt = Symbol.for("react.scope"), st = Symbol.for("react.debug_trace_mode"), dt = Symbol.for("react.legacy_hidden"), Ye = Symbol.for("react.default_value"), Je = Symbol.iterator;
  function yt(b) {
    if (b == null)
      return null;
    if (typeof b == "function")
      return b.displayName || b.name || null;
    if (typeof b == "string")
      return b;
    switch (b) {
      case ye:
        return "Fragment";
      case me:
        return "Portal";
      case ce:
        return "Profiler";
      case Se:
        return "StrictMode";
      case Fe:
        return "Suspense";
      case Xe:
        return "SuspenseList";
    }
    if (typeof b == "object")
      switch (b.$$typeof) {
        case Ie:
          return (b.displayName || "Context") + ".Consumer";
        case ke:
          return (b._context.displayName || "Context") + ".Provider";
        case Le:
          var C = b.render;
          return b = b.displayName, b || (b = C.displayName || C.name || "", b = b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef"), b;
        case Be:
          return C = b.displayName || null, C !== null ? C : yt(b.type) || "Memo";
        case ot:
          C = b._payload, b = b._init;
          try {
            return yt(b(C));
          } catch {
          }
      }
    return null;
  }
  var nt = {};
  function lt(b, C) {
    if (b = b.contextTypes, !b)
      return nt;
    var I = {}, H;
    for (H in b)
      I[H] = C[H];
    return I;
  }
  var je = null;
  function at(b, C) {
    if (b !== C) {
      b.context._currentValue2 = b.parentValue, b = b.parent;
      var I = C.parent;
      if (b === null) {
        if (I !== null)
          throw Error(t(401));
      } else {
        if (I === null)
          throw Error(t(401));
        at(b, I);
      }
      C.context._currentValue2 = C.value;
    }
  }
  function ct(b) {
    b.context._currentValue2 = b.parentValue, b = b.parent, b !== null && ct(b);
  }
  function wt(b) {
    var C = b.parent;
    C !== null && wt(C), b.context._currentValue2 = b.value;
  }
  function rn(b, C) {
    if (b.context._currentValue2 = b.parentValue, b = b.parent, b === null)
      throw Error(t(402));
    b.depth === C.depth ? at(b, C) : rn(b, C);
  }
  function Ne(b, C) {
    var I = C.parent;
    if (I === null)
      throw Error(t(402));
    b.depth === I.depth ? at(b, I) : Ne(b, I), C.context._currentValue2 = C.value;
  }
  function Ct(b) {
    var C = je;
    C !== b && (C === null ? wt(b) : b === null ? ct(C) : C.depth === b.depth ? at(C, b) : C.depth > b.depth ? rn(C, b) : Ne(C, b), je = b);
  }
  var bn = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(b, C) {
    b = b._reactInternals, b.queue !== null && b.queue.push(C);
  }, enqueueReplaceState: function(b, C) {
    b = b._reactInternals, b.replace = !0, b.queue = [C];
  }, enqueueForceUpdate: function() {
  } };
  function Zt(b, C, I, H) {
    var oe = b.state !== void 0 ? b.state : null;
    b.updater = bn, b.props = I, b.state = oe;
    var pe = { queue: [], replace: !1 };
    b._reactInternals = pe;
    var we = C.contextType;
    if (b.context = typeof we == "object" && we !== null ? we._currentValue2 : H, we = C.getDerivedStateFromProps, typeof we == "function" && (we = we(I, oe), oe = we == null ? oe : ne({}, oe, we), b.state = oe), typeof C.getDerivedStateFromProps != "function" && typeof b.getSnapshotBeforeUpdate != "function" && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function"))
      if (C = b.state, typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(), C !== b.state && bn.enqueueReplaceState(b, b.state, null), pe.queue !== null && 0 < pe.queue.length)
        if (C = pe.queue, we = pe.replace, pe.queue = null, pe.replace = !1, we && C.length === 1)
          b.state = C[0];
        else {
          for (pe = we ? C[0] : b.state, oe = !0, we = we ? 1 : 0; we < C.length; we++) {
            var K = C[we];
            K = typeof K == "function" ? K.call(b, pe, I, H) : K, K != null && (oe ? (oe = !1, pe = ne({}, pe, K)) : ne(pe, K));
          }
          b.state = pe;
        }
      else
        pe.queue = null;
  }
  var jt = { id: 1, overflow: "" };
  function Qt(b, C, I) {
    var H = b.id;
    b = b.overflow;
    var oe = 32 - _n(H) - 1;
    H &= ~(1 << oe), I += 1;
    var pe = 32 - _n(C) + oe;
    if (30 < pe) {
      var we = oe - oe % 5;
      return pe = (H & (1 << we) - 1).toString(32), H >>= we, oe -= we, { id: 1 << 32 - _n(C) + oe | I << oe | H, overflow: pe + b };
    }
    return { id: 1 << pe | I << oe | H, overflow: b };
  }
  var _n = Math.clz32 ? Math.clz32 : Nt, Gt = Math.log, fn = Math.LN2;
  function Nt(b) {
    return b >>>= 0, b === 0 ? 32 : 31 - (Gt(b) / fn | 0) | 0;
  }
  function Yt(b, C) {
    return b === C && (b !== 0 || 1 / b === 1 / C) || b !== b && C !== C;
  }
  var tn = typeof Object.is == "function" ? Object.is : Yt, zt = null, It = null, $t = null, Ze = null, mt = !1, Kt = !1, Pe = 0, _e = null, xe = 0;
  function ut() {
    if (zt === null)
      throw Error(t(321));
    return zt;
  }
  function et() {
    if (0 < xe)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function rt() {
    return Ze === null ? $t === null ? (mt = !1, $t = Ze = et()) : (mt = !0, Ze = $t) : Ze.next === null ? (mt = !1, Ze = Ze.next = et()) : (mt = !0, Ze = Ze.next), Ze;
  }
  function At() {
    It = zt = null, Kt = !1, $t = null, xe = 0, Ze = _e = null;
  }
  function Xt(b, C) {
    return typeof C == "function" ? C(b) : C;
  }
  function tt(b, C, I) {
    if (zt = ut(), Ze = rt(), mt) {
      var H = Ze.queue;
      if (C = H.dispatch, _e !== null && (I = _e.get(H), I !== void 0)) {
        _e.delete(H), H = Ze.memoizedState;
        do
          H = b(H, I.action), I = I.next;
        while (I !== null);
        return Ze.memoizedState = H, [H, C];
      }
      return [Ze.memoizedState, C];
    }
    return b = b === Xt ? typeof C == "function" ? C() : C : I !== void 0 ? I(C) : C, Ze.memoizedState = b, b = Ze.queue = { last: null, dispatch: null }, b = b.dispatch = yn.bind(null, zt, b), [Ze.memoizedState, b];
  }
  function _t(b, C) {
    if (zt = ut(), Ze = rt(), C = C === void 0 ? null : C, Ze !== null) {
      var I = Ze.memoizedState;
      if (I !== null && C !== null) {
        var H = I[1];
        e:
          if (H === null)
            H = !1;
          else {
            for (var oe = 0; oe < H.length && oe < C.length; oe++)
              if (!tn(C[oe], H[oe])) {
                H = !1;
                break e;
              }
            H = !0;
          }
        if (H)
          return I[0];
      }
    }
    return b = b(), Ze.memoizedState = [b, C], b;
  }
  function yn(b, C, I) {
    if (25 <= xe)
      throw Error(t(301));
    if (b === zt)
      if (Kt = !0, b = { action: I, next: null }, _e === null && (_e = /* @__PURE__ */ new Map()), I = _e.get(C), I === void 0)
        _e.set(C, b);
      else {
        for (C = I; C.next !== null; )
          C = C.next;
        C.next = b;
      }
  }
  function vt() {
    throw Error(t(394));
  }
  function St() {
  }
  var gn = { readContext: function(b) {
    return b._currentValue2;
  }, useContext: function(b) {
    return ut(), b._currentValue2;
  }, useMemo: _t, useReducer: tt, useRef: function(b) {
    zt = ut(), Ze = rt();
    var C = Ze.memoizedState;
    return C === null ? (b = { current: b }, Ze.memoizedState = b) : C;
  }, useState: function(b) {
    return tt(Xt, b);
  }, useInsertionEffect: St, useLayoutEffect: function() {
  }, useCallback: function(b, C) {
    return _t(function() {
      return b;
    }, C);
  }, useImperativeHandle: St, useEffect: St, useDebugValue: St, useDeferredValue: function(b) {
    return ut(), b;
  }, useTransition: function() {
    return ut(), [
      !1,
      vt
    ];
  }, useId: function() {
    var b = It.treeContext, C = b.overflow;
    b = b.id, b = (b & ~(1 << 32 - _n(b) - 1)).toString(32) + C;
    var I = xn;
    if (I === null)
      throw Error(t(404));
    return C = Pe++, b = ":" + I.idPrefix + "R" + b, 0 < C && (b += "H" + C.toString(32)), b + ":";
  }, useMutableSource: function(b, C) {
    return ut(), C(b._source);
  }, useSyncExternalStore: function(b, C, I) {
    if (I === void 0)
      throw Error(t(407));
    return I();
  } }, xn = null, On = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function Fn(b) {
    return console.error(b), null;
  }
  function Pn() {
  }
  function ir(b, C, I, H, oe, pe, we, K, X) {
    var le = [], be = /* @__PURE__ */ new Set();
    return C = { destination: null, responseState: C, progressiveChunkSize: H === void 0 ? 12800 : H, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: be, pingedTasks: le, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: oe === void 0 ? Fn : oe, onAllReady: pe === void 0 ? Pn : pe, onShellReady: we === void 0 ? Pn : we, onShellError: K === void 0 ? Pn : K, onFatalError: X === void 0 ? Pn : X }, I = Sn(C, 0, null, I, !1, !1), I.parentFlushed = !0, b = Nn(C, b, null, I, be, nt, null, jt), le.push(b), C;
  }
  function Nn(b, C, I, H, oe, pe, we, K) {
    b.allPendingTasks++, I === null ? b.pendingRootTasks++ : I.pendingTasks++;
    var X = { node: C, ping: function() {
      var le = b.pingedTasks;
      le.push(X), le.length === 1 && mn(b);
    }, blockedBoundary: I, blockedSegment: H, abortSet: oe, legacyContext: pe, context: we, treeContext: K };
    return oe.add(X), X;
  }
  function Sn(b, C, I, H, oe, pe) {
    return { status: 0, id: -1, index: C, parentFlushed: !1, chunks: [], children: [], formatContext: H, boundary: I, lastPushedText: oe, textEmbedded: pe };
  }
  function Dt(b, C) {
    if (b = b.onError(C), b != null && typeof b != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof b + '" instead');
    return b;
  }
  function nn(b, C) {
    var I = b.onShellError;
    I(C), I = b.onFatalError, I(C), b.destination !== null ? (b.status = 2, b.destination.destroy(C)) : (b.status = 1, b.fatalError = C);
  }
  function dn(b, C, I, H, oe) {
    for (zt = {}, It = C, Pe = 0, b = I(H, oe); Kt; )
      Kt = !1, Pe = 0, xe += 1, Ze = null, b = I(H, oe);
    return At(), b;
  }
  function Hn(b, C, I, H) {
    var oe = I.render(), pe = H.childContextTypes;
    if (pe != null) {
      var we = C.legacyContext;
      if (typeof I.getChildContext != "function")
        H = we;
      else {
        I = I.getChildContext();
        for (var K in I)
          if (!(K in pe))
            throw Error(t(108, yt(H) || "Unknown", K));
        H = ne({}, we, I);
      }
      C.legacyContext = H, Ot(b, C, oe), C.legacyContext = we;
    } else
      Ot(b, C, oe);
  }
  function Jt(b, C) {
    if (b && b.defaultProps) {
      C = ne({}, C), b = b.defaultProps;
      for (var I in b)
        C[I] === void 0 && (C[I] = b[I]);
      return C;
    }
    return C;
  }
  function qt(b, C, I, H, oe) {
    if (typeof I == "function")
      if (I.prototype && I.prototype.isReactComponent) {
        oe = lt(I, C.legacyContext);
        var pe = I.contextType;
        pe = new I(H, typeof pe == "object" && pe !== null ? pe._currentValue2 : oe), Zt(pe, I, H, oe), Hn(b, C, pe, I);
      } else {
        pe = lt(I, C.legacyContext), oe = dn(b, C, I, H, pe);
        var we = Pe !== 0;
        if (typeof oe == "object" && oe !== null && typeof oe.render == "function" && oe.$$typeof === void 0)
          Zt(oe, I, H, pe), Hn(b, C, oe, I);
        else if (we) {
          H = C.treeContext, C.treeContext = Qt(H, 1, 0);
          try {
            Ot(b, C, oe);
          } finally {
            C.treeContext = H;
          }
        } else
          Ot(b, C, oe);
      }
    else if (typeof I == "string") {
      switch (oe = C.blockedSegment, pe = ie(oe.chunks, I, H, b.responseState, oe.formatContext), oe.lastPushedText = !1, we = oe.formatContext, oe.formatContext = R(we, I, H), an(b, C, pe), oe.formatContext = we, I) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          oe.chunks.push("</", I, ">");
      }
      oe.lastPushedText = !1;
    } else {
      switch (I) {
        case dt:
        case st:
        case Se:
        case ce:
        case ye:
          Ot(b, C, H.children);
          return;
        case Xe:
          Ot(b, C, H.children);
          return;
        case gt:
          throw Error(t(343));
        case Fe:
          e: {
            I = C.blockedBoundary, oe = C.blockedSegment, pe = H.fallback, H = H.children, we = /* @__PURE__ */ new Set();
            var K = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: we, errorDigest: null }, X = Sn(b, oe.chunks.length, K, oe.formatContext, !1, !1);
            oe.children.push(X), oe.lastPushedText = !1;
            var le = Sn(b, 0, null, oe.formatContext, !1, !1);
            le.parentFlushed = !0, C.blockedBoundary = K, C.blockedSegment = le;
            try {
              if (an(
                b,
                C,
                H
              ), b.responseState.generateStaticMarkup || le.lastPushedText && le.textEmbedded && le.chunks.push("<!-- -->"), le.status = 1, Rn(K, le), K.pendingTasks === 0)
                break e;
            } catch (be) {
              le.status = 4, K.forceClientRender = !0, K.errorDigest = Dt(b, be);
            } finally {
              C.blockedBoundary = I, C.blockedSegment = oe;
            }
            C = Nn(b, pe, I, X, we, C.legacyContext, C.context, C.treeContext), b.pingedTasks.push(C);
          }
          return;
      }
      if (typeof I == "object" && I !== null)
        switch (I.$$typeof) {
          case Le:
            if (H = dn(b, C, I.render, H, oe), Pe !== 0) {
              I = C.treeContext, C.treeContext = Qt(I, 1, 0);
              try {
                Ot(b, C, H);
              } finally {
                C.treeContext = I;
              }
            } else
              Ot(b, C, H);
            return;
          case Be:
            I = I.type, H = Jt(I, H), qt(b, C, I, H, oe);
            return;
          case ke:
            if (oe = H.children, I = I._context, H = H.value, pe = I._currentValue2, I._currentValue2 = H, we = je, je = H = { parent: we, depth: we === null ? 0 : we.depth + 1, context: I, parentValue: pe, value: H }, C.context = H, Ot(b, C, oe), b = je, b === null)
              throw Error(t(403));
            H = b.parentValue, b.context._currentValue2 = H === Ye ? b.context._defaultValue : H, b = je = b.parent, C.context = b;
            return;
          case Ie:
            H = H.children, H = H(I._currentValue2), Ot(b, C, H);
            return;
          case ot:
            oe = I._init, I = oe(I._payload), H = Jt(I, H), qt(
              b,
              C,
              I,
              H,
              void 0
            );
            return;
        }
      throw Error(t(130, I == null ? I : typeof I, ""));
    }
  }
  function Ot(b, C, I) {
    if (C.node = I, typeof I == "object" && I !== null) {
      switch (I.$$typeof) {
        case G:
          qt(b, C, I.type, I.props, I.ref);
          return;
        case me:
          throw Error(t(257));
        case ot:
          var H = I._init;
          I = H(I._payload), Ot(b, C, I);
          return;
      }
      if (S(I)) {
        pn(b, C, I);
        return;
      }
      if (I === null || typeof I != "object" ? H = null : (H = Je && I[Je] || I["@@iterator"], H = typeof H == "function" ? H : null), H && (H = H.call(I))) {
        if (I = H.next(), !I.done) {
          var oe = [];
          do
            oe.push(I.value), I = H.next();
          while (!I.done);
          pn(b, C, oe);
        }
        return;
      }
      throw b = Object.prototype.toString.call(I), Error(t(31, b === "[object Object]" ? "object with keys {" + Object.keys(I).join(", ") + "}" : b));
    }
    typeof I == "string" ? (H = C.blockedSegment, H.lastPushedText = ge(C.blockedSegment.chunks, I, b.responseState, H.lastPushedText)) : typeof I == "number" && (H = C.blockedSegment, H.lastPushedText = ge(C.blockedSegment.chunks, "" + I, b.responseState, H.lastPushedText));
  }
  function pn(b, C, I) {
    for (var H = I.length, oe = 0; oe < H; oe++) {
      var pe = C.treeContext;
      C.treeContext = Qt(pe, H, oe);
      try {
        an(b, C, I[oe]);
      } finally {
        C.treeContext = pe;
      }
    }
  }
  function an(b, C, I) {
    var H = C.blockedSegment.formatContext, oe = C.legacyContext, pe = C.context;
    try {
      return Ot(b, C, I);
    } catch (X) {
      if (At(), typeof X == "object" && X !== null && typeof X.then == "function") {
        I = X;
        var we = C.blockedSegment, K = Sn(b, we.chunks.length, null, we.formatContext, we.lastPushedText, !0);
        we.children.push(K), we.lastPushedText = !1, b = Nn(b, C.node, C.blockedBoundary, K, C.abortSet, C.legacyContext, C.context, C.treeContext).ping, I.then(b, b), C.blockedSegment.formatContext = H, C.legacyContext = oe, C.context = pe, Ct(pe);
      } else
        throw C.blockedSegment.formatContext = H, C.legacyContext = oe, C.context = pe, Ct(pe), X;
    }
  }
  function un(b) {
    var C = b.blockedBoundary;
    b = b.blockedSegment, b.status = 3, wn(this, C, b);
  }
  function ar(b, C, I) {
    var H = b.blockedBoundary;
    b.blockedSegment.status = 3, H === null ? (C.allPendingTasks--, C.status !== 2 && (C.status = 2, C.destination !== null && C.destination.push(null))) : (H.pendingTasks--, H.forceClientRender || (H.forceClientRender = !0, b = I === void 0 ? Error(t(432)) : I, H.errorDigest = C.onError(b), H.parentFlushed && C.clientRenderedBoundaries.push(H)), H.fallbackAbortableTasks.forEach(function(oe) {
      return ar(oe, C, I);
    }), H.fallbackAbortableTasks.clear(), C.allPendingTasks--, C.allPendingTasks === 0 && (H = C.onAllReady, H()));
  }
  function Rn(b, C) {
    if (C.chunks.length === 0 && C.children.length === 1 && C.children[0].boundary === null) {
      var I = C.children[0];
      I.id = C.id, I.parentFlushed = !0, I.status === 1 && Rn(b, I);
    } else
      b.completedSegments.push(C);
  }
  function wn(b, C, I) {
    if (C === null) {
      if (I.parentFlushed) {
        if (b.completedRootSegment !== null)
          throw Error(t(389));
        b.completedRootSegment = I;
      }
      b.pendingRootTasks--, b.pendingRootTasks === 0 && (b.onShellError = Pn, C = b.onShellReady, C());
    } else
      C.pendingTasks--, C.forceClientRender || (C.pendingTasks === 0 ? (I.parentFlushed && I.status === 1 && Rn(C, I), C.parentFlushed && b.completedBoundaries.push(C), C.fallbackAbortableTasks.forEach(un, b), C.fallbackAbortableTasks.clear()) : I.parentFlushed && I.status === 1 && (Rn(C, I), C.completedSegments.length === 1 && C.parentFlushed && b.partialBoundaries.push(C)));
    b.allPendingTasks--, b.allPendingTasks === 0 && (b = b.onAllReady, b());
  }
  function mn(b) {
    if (b.status !== 2) {
      var C = je, I = On.current;
      On.current = gn;
      var H = xn;
      xn = b.responseState;
      try {
        var oe = b.pingedTasks, pe;
        for (pe = 0; pe < oe.length; pe++) {
          var we = oe[pe], K = b, X = we.blockedSegment;
          if (X.status === 0) {
            Ct(we.context);
            try {
              Ot(K, we, we.node), K.responseState.generateStaticMarkup || X.lastPushedText && X.textEmbedded && X.chunks.push("<!-- -->"), we.abortSet.delete(we), X.status = 1, wn(K, we.blockedBoundary, X);
            } catch (Rt) {
              if (At(), typeof Rt == "object" && Rt !== null && typeof Rt.then == "function") {
                var le = we.ping;
                Rt.then(le, le);
              } else {
                we.abortSet.delete(we), X.status = 4;
                var be = we.blockedBoundary, Ue = Rt, Ft = Dt(K, Ue);
                if (be === null ? nn(K, Ue) : (be.pendingTasks--, be.forceClientRender || (be.forceClientRender = !0, be.errorDigest = Ft, be.parentFlushed && K.clientRenderedBoundaries.push(be))), K.allPendingTasks--, K.allPendingTasks === 0) {
                  var Ht = K.onAllReady;
                  Ht();
                }
              }
            } finally {
            }
          }
        }
        oe.splice(0, pe), b.destination !== null && Vn(b, b.destination);
      } catch (Rt) {
        Dt(b, Rt), nn(b, Rt);
      } finally {
        xn = H, On.current = I, I === gn && Ct(C);
      }
    }
  }
  function Mn(b, C, I) {
    switch (I.parentFlushed = !0, I.status) {
      case 0:
        var H = I.id = b.nextSegmentId++;
        return I.lastPushedText = !1, I.textEmbedded = !1, b = b.responseState, C.push('<template id="'), C.push(b.placeholderPrefix), b = H.toString(16), C.push(b), C.push('"></template>');
      case 1:
        I.status = 2;
        var oe = !0;
        H = I.chunks;
        var pe = 0;
        I = I.children;
        for (var we = 0; we < I.length; we++) {
          for (oe = I[we]; pe < oe.index; pe++)
            C.push(H[pe]);
          oe = Wn(b, C, oe);
        }
        for (; pe < H.length - 1; pe++)
          C.push(H[pe]);
        return pe < H.length && (oe = C.push(H[pe])), oe;
      default:
        throw Error(t(390));
    }
  }
  function Wn(b, C, I) {
    var H = I.boundary;
    if (H === null)
      return Mn(b, C, I);
    if (H.parentFlushed = !0, H.forceClientRender)
      return b.responseState.generateStaticMarkup || (H = H.errorDigest, C.push("<!--$!-->"), C.push("<template"), H && (C.push(' data-dgst="'), H = k(H), C.push(H), C.push('"')), C.push("></template>")), Mn(b, C, I), b = b.responseState.generateStaticMarkup ? !0 : C.push("<!--/$-->"), b;
    if (0 < H.pendingTasks) {
      H.rootSegmentID = b.nextSegmentId++, 0 < H.completedSegments.length && b.partialBoundaries.push(H);
      var oe = b.responseState, pe = oe.nextSuspenseID++;
      return oe = oe.boundaryPrefix + pe.toString(16), H = H.id = oe, M(C, b.responseState, H), Mn(b, C, I), C.push("<!--/$-->");
    }
    if (H.byteSize > b.progressiveChunkSize)
      return H.rootSegmentID = b.nextSegmentId++, b.completedBoundaries.push(H), M(C, b.responseState, H.id), Mn(b, C, I), C.push("<!--/$-->");
    if (b.responseState.generateStaticMarkup || C.push("<!--$-->"), I = H.completedSegments, I.length !== 1)
      throw Error(t(391));
    return Wn(b, C, I[0]), b = b.responseState.generateStaticMarkup ? !0 : C.push("<!--/$-->"), b;
  }
  function gr(b, C, I) {
    return U(C, b.responseState, I.formatContext, I.id), Wn(b, C, I), re(C, I.formatContext);
  }
  function vr(b, C, I) {
    for (var H = I.completedSegments, oe = 0; oe < H.length; oe++)
      Xn(b, C, I, H[oe]);
    if (H.length = 0, b = b.responseState, H = I.id, I = I.rootSegmentID, C.push(b.startInlineScript), b.sentCompleteBoundaryFunction ? C.push('$RC("') : (b.sentCompleteBoundaryFunction = !0, C.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), H === null)
      throw Error(t(395));
    return I = I.toString(16), C.push(H), C.push('","'), C.push(b.segmentPrefix), C.push(I), C.push('")<\/script>');
  }
  function Xn(b, C, I, H) {
    if (H.status === 2)
      return !0;
    var oe = H.id;
    if (oe === -1) {
      if ((H.id = I.rootSegmentID) === -1)
        throw Error(t(392));
      return gr(b, C, H);
    }
    return gr(b, C, H), b = b.responseState, C.push(b.startInlineScript), b.sentCompleteSegmentFunction ? C.push('$RS("') : (b.sentCompleteSegmentFunction = !0, C.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), C.push(b.segmentPrefix), oe = oe.toString(16), C.push(oe), C.push('","'), C.push(b.placeholderPrefix), C.push(oe), C.push('")<\/script>');
  }
  function Vn(b, C) {
    try {
      var I = b.completedRootSegment;
      if (I !== null && b.pendingRootTasks === 0) {
        Wn(b, C, I), b.completedRootSegment = null;
        var H = b.responseState.bootstrapChunks;
        for (I = 0; I < H.length - 1; I++)
          C.push(H[I]);
        I < H.length && C.push(H[I]);
      }
      var oe = b.clientRenderedBoundaries, pe;
      for (pe = 0; pe < oe.length; pe++) {
        var we = oe[pe];
        H = C;
        var K = b.responseState, X = we.id, le = we.errorDigest, be = we.errorMessage, Ue = we.errorComponentStack;
        if (H.push(K.startInlineScript), K.sentClientRenderFunction ? H.push('$RX("') : (K.sentClientRenderFunction = !0, H.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), X === null)
          throw Error(t(395));
        if (H.push(X), H.push('"'), le || be || Ue) {
          H.push(",");
          var Ft = de(le || "");
          H.push(Ft);
        }
        if (be || Ue) {
          H.push(",");
          var Ht = de(be || "");
          H.push(Ht);
        }
        if (Ue) {
          H.push(",");
          var Rt = de(Ue);
          H.push(Rt);
        }
        if (!H.push(")<\/script>")) {
          b.destination = null, pe++, oe.splice(0, pe);
          return;
        }
      }
      oe.splice(0, pe);
      var Vt = b.completedBoundaries;
      for (pe = 0; pe < Vt.length; pe++)
        if (!vr(b, C, Vt[pe])) {
          b.destination = null, pe++, Vt.splice(0, pe);
          return;
        }
      Vt.splice(0, pe);
      var kn = b.partialBoundaries;
      for (pe = 0; pe < kn.length; pe++) {
        var jn = kn[pe];
        e: {
          oe = b, we = C;
          var Qn = jn.completedSegments;
          for (K = 0; K < Qn.length; K++)
            if (!Xn(oe, we, jn, Qn[K])) {
              K++, Qn.splice(0, K);
              var sr = !1;
              break e;
            }
          Qn.splice(0, K), sr = !0;
        }
        if (!sr) {
          b.destination = null, pe++, kn.splice(0, pe);
          return;
        }
      }
      kn.splice(0, pe);
      var Kn = b.completedBoundaries;
      for (pe = 0; pe < Kn.length; pe++)
        if (!vr(b, C, Kn[pe])) {
          b.destination = null, pe++, Kn.splice(0, pe);
          return;
        }
      Kn.splice(0, pe);
    } finally {
      b.allPendingTasks === 0 && b.pingedTasks.length === 0 && b.clientRenderedBoundaries.length === 0 && b.completedBoundaries.length === 0 && C.push(null);
    }
  }
  function or(b, C) {
    try {
      var I = b.abortableTasks;
      I.forEach(function(H) {
        return ar(H, b, C);
      }), I.clear(), b.destination !== null && Vn(b, b.destination);
    } catch (H) {
      Dt(b, H), nn(b, H);
    }
  }
  function qn() {
  }
  function Zn(b, C, I, H) {
    var oe = !1, pe = null, we = "", K = { push: function(le) {
      return le !== null && (we += le), !0;
    }, destroy: function(le) {
      oe = !0, pe = le;
    } }, X = !1;
    if (b = ir(b, Z(I, C ? C.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, qn, void 0, function() {
      X = !0;
    }, void 0, void 0), mn(b), or(b, H), b.status === 1)
      b.status = 2, K.destroy(b.fatalError);
    else if (b.status !== 2 && b.destination === null) {
      b.destination = K;
      try {
        Vn(b, K);
      } catch (le) {
        Dt(b, le), nn(b, le);
      }
    }
    if (oe)
      throw pe;
    if (!X)
      throw Error(t(426));
    return we;
  }
  return Ma.renderToNodeStream = function() {
    throw Error(t(207));
  }, Ma.renderToStaticMarkup = function(b, C) {
    return Zn(b, C, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Ma.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, Ma.renderToString = function(b, C) {
    return Zn(b, C, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Ma.version = "18.3.1", Ma;
}
var Vu = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var um;
function WS() {
  if (um)
    return Vu;
  um = 1;
  var e = he;
  function t(w) {
    for (var P = "https://reactjs.org/docs/error-decoder.html?invariant=" + w, $ = 1; $ < arguments.length; $++)
      P += "&args[]=" + encodeURIComponent(arguments[$]);
    return "Minified React error #" + w + "; visit " + P + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = null, r = 0;
  function i(w, P) {
    if (P.length !== 0)
      if (512 < P.length)
        0 < r && (w.enqueue(new Uint8Array(n.buffer, 0, r)), n = new Uint8Array(512), r = 0), w.enqueue(P);
      else {
        var $ = n.length - r;
        $ < P.length && ($ === 0 ? w.enqueue(n) : (n.set(P.subarray(0, $), r), w.enqueue(n), P = P.subarray($)), n = new Uint8Array(512), r = 0), n.set(P, r), r += P.length;
      }
  }
  function o(w, P) {
    return i(w, P), !0;
  }
  function h(w) {
    n && 0 < r && (w.enqueue(new Uint8Array(n.buffer, 0, r)), n = null, r = 0);
  }
  var u = new TextEncoder();
  function d(w) {
    return u.encode(w);
  }
  function p(w) {
    return u.encode(w);
  }
  function m(w, P) {
    typeof w.error == "function" ? w.error(P) : w.close();
  }
  var g = Object.prototype.hasOwnProperty, x = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, A = {}, k = {};
  function y(w) {
    return g.call(k, w) ? !0 : g.call(A, w) ? !1 : x.test(w) ? k[w] = !0 : (A[w] = !0, !1);
  }
  function v(w, P, $, J, Ce, Te, Re) {
    this.acceptsBooleans = P === 2 || P === 3 || P === 4, this.attributeName = J, this.attributeNamespace = Ce, this.mustUseProperty = $, this.propertyName = w, this.type = P, this.sanitizeURL = Te, this.removeEmptyString = Re;
  }
  var S = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(w) {
    S[w] = new v(w, 0, !1, w, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(w) {
    var P = w[0];
    S[P] = new v(P, 1, !1, w[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(w) {
    S[w] = new v(w, 2, !1, w.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(w) {
    S[w] = new v(w, 2, !1, w, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(w) {
    S[w] = new v(w, 3, !1, w.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(w) {
    S[w] = new v(w, 3, !0, w, null, !1, !1);
  }), ["capture", "download"].forEach(function(w) {
    S[w] = new v(w, 4, !1, w, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(w) {
    S[w] = new v(w, 6, !1, w, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(w) {
    S[w] = new v(w, 5, !1, w.toLowerCase(), null, !1, !1);
  });
  var B = /[\-:]([a-z])/g;
  function R(w) {
    return w[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(w) {
    var P = w.replace(
      B,
      R
    );
    S[P] = new v(P, 1, !1, w, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(w) {
    var P = w.replace(B, R);
    S[P] = new v(P, 1, !1, w, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(w) {
    var P = w.replace(B, R);
    S[P] = new v(P, 1, !1, w, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(w) {
    S[w] = new v(w, 1, !1, w.toLowerCase(), null, !1, !1);
  }), S.xlinkHref = new v("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(w) {
    S[w] = new v(w, 1, !1, w.toLowerCase(), null, !0, !0);
  });
  var N = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, D = ["Webkit", "ms", "Moz", "O"];
  Object.keys(N).forEach(function(w) {
    D.forEach(function(P) {
      P = P + w.charAt(0).toUpperCase() + w.substring(1), N[P] = N[w];
    });
  });
  var L = /["'&<>]/;
  function q(w) {
    if (typeof w == "boolean" || typeof w == "number")
      return "" + w;
    w = "" + w;
    var P = L.exec(w);
    if (P) {
      var $ = "", J, Ce = 0;
      for (J = P.index; J < w.length; J++) {
        switch (w.charCodeAt(J)) {
          case 34:
            P = "&quot;";
            break;
          case 38:
            P = "&amp;";
            break;
          case 39:
            P = "&#x27;";
            break;
          case 60:
            P = "&lt;";
            break;
          case 62:
            P = "&gt;";
            break;
          default:
            continue;
        }
        Ce !== J && ($ += w.substring(Ce, J)), Ce = J + 1, $ += P;
      }
      w = Ce !== J ? $ + w.substring(Ce, J) : $;
    }
    return w;
  }
  var V = /([A-Z])/g, ae = /^ms-/, Y = Array.isArray, Q = p("<script>"), se = p("<\/script>"), ie = p('<script src="'), M = p('<script type="module" src="'), U = p('" async=""><\/script>'), re = /(<\/|<)(s)(cript)/gi;
  function j(w, P, $, J) {
    return "" + P + ($ === "s" ? "\\u0073" : "\\u0053") + J;
  }
  function de(w, P, $, J, Ce) {
    w = w === void 0 ? "" : w, P = P === void 0 ? Q : p('<script nonce="' + q(P) + '">');
    var Te = [];
    if ($ !== void 0 && Te.push(P, d(("" + $).replace(re, j)), se), J !== void 0)
      for ($ = 0; $ < J.length; $++)
        Te.push(ie, d(q(J[$])), U);
    if (Ce !== void 0)
      for (J = 0; J < Ce.length; J++)
        Te.push(M, d(q(Ce[J])), U);
    return { bootstrapChunks: Te, startInlineScript: P, placeholderPrefix: p(w + "P:"), segmentPrefix: p(w + "S:"), boundaryPrefix: w + "B:", idPrefix: w, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function Z(w, P) {
    return { insertionMode: w, selectedValue: P };
  }
  function ge(w) {
    return Z(w === "http://www.w3.org/2000/svg" ? 2 : w === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function ne(w, P, $) {
    switch (P) {
      case "select":
        return Z(1, $.value != null ? $.value : $.defaultValue);
      case "svg":
        return Z(2, null);
      case "math":
        return Z(3, null);
      case "foreignObject":
        return Z(1, null);
      case "table":
        return Z(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return Z(5, null);
      case "colgroup":
        return Z(7, null);
      case "tr":
        return Z(6, null);
    }
    return 4 <= w.insertionMode || w.insertionMode === 0 ? Z(1, null) : w;
  }
  var G = p("<!-- -->");
  function me(w, P, $, J) {
    return P === "" ? J : (J && w.push(G), w.push(d(q(P))), !0);
  }
  var ye = /* @__PURE__ */ new Map(), Se = p(' style="'), ce = p(":"), ke = p(";");
  function Ie(w, P, $) {
    if (typeof $ != "object")
      throw Error(t(62));
    P = !0;
    for (var J in $)
      if (g.call($, J)) {
        var Ce = $[J];
        if (Ce != null && typeof Ce != "boolean" && Ce !== "") {
          if (J.indexOf("--") === 0) {
            var Te = d(q(J));
            Ce = d(q(("" + Ce).trim()));
          } else {
            Te = J;
            var Re = ye.get(Te);
            Re !== void 0 || (Re = p(q(Te.replace(V, "-$1").toLowerCase().replace(ae, "-ms-"))), ye.set(Te, Re)), Te = Re, Ce = typeof Ce == "number" ? Ce === 0 || g.call(N, J) ? d("" + Ce) : d(Ce + "px") : d(q(("" + Ce).trim()));
          }
          P ? (P = !1, w.push(Se, Te, ce, Ce)) : w.push(ke, Te, ce, Ce);
        }
      }
    P || w.push(Xe);
  }
  var Le = p(" "), Fe = p('="'), Xe = p('"'), Be = p('=""');
  function ot(w, P, $, J) {
    switch ($) {
      case "style":
        Ie(w, P, J);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < $.length) || $[0] !== "o" && $[0] !== "O" || $[1] !== "n" && $[1] !== "N") {
      if (P = S.hasOwnProperty($) ? S[$] : null, P !== null) {
        switch (typeof J) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!P.acceptsBooleans)
              return;
        }
        switch ($ = d(P.attributeName), P.type) {
          case 3:
            J && w.push(Le, $, Be);
            break;
          case 4:
            J === !0 ? w.push(Le, $, Be) : J !== !1 && w.push(Le, $, Fe, d(q(J)), Xe);
            break;
          case 5:
            isNaN(J) || w.push(Le, $, Fe, d(q(J)), Xe);
            break;
          case 6:
            !isNaN(J) && 1 <= J && w.push(Le, $, Fe, d(q(J)), Xe);
            break;
          default:
            P.sanitizeURL && (J = "" + J), w.push(Le, $, Fe, d(q(J)), Xe);
        }
      } else if (y($)) {
        switch (typeof J) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (P = $.toLowerCase().slice(0, 5), P !== "data-" && P !== "aria-")
              return;
        }
        w.push(Le, d($), Fe, d(q(J)), Xe);
      }
    }
  }
  var gt = p(">"), st = p("/>");
  function dt(w, P, $) {
    if (P != null) {
      if ($ != null)
        throw Error(t(60));
      if (typeof P != "object" || !("__html" in P))
        throw Error(t(61));
      P = P.__html, P != null && w.push(d("" + P));
    }
  }
  function Ye(w) {
    var P = "";
    return e.Children.forEach(w, function($) {
      $ != null && (P += $);
    }), P;
  }
  var Je = p(' selected=""');
  function yt(w, P, $, J) {
    w.push(at($));
    var Ce = $ = null, Te;
    for (Te in P)
      if (g.call(P, Te)) {
        var Re = P[Te];
        if (Re != null)
          switch (Te) {
            case "children":
              $ = Re;
              break;
            case "dangerouslySetInnerHTML":
              Ce = Re;
              break;
            default:
              ot(w, J, Te, Re);
          }
      }
    return w.push(gt), dt(w, Ce, $), typeof $ == "string" ? (w.push(d(q($))), null) : $;
  }
  var nt = p(`
`), lt = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, je = /* @__PURE__ */ new Map();
  function at(w) {
    var P = je.get(w);
    if (P === void 0) {
      if (!lt.test(w))
        throw Error(t(65, w));
      P = p("<" + w), je.set(w, P);
    }
    return P;
  }
  var ct = p("<!DOCTYPE html>");
  function wt(w, P, $, J, Ce) {
    switch (P) {
      case "select":
        w.push(at("select"));
        var Te = null, Re = null;
        for (Tt in $)
          if (g.call($, Tt)) {
            var He = $[Tt];
            if (He != null)
              switch (Tt) {
                case "children":
                  Te = He;
                  break;
                case "dangerouslySetInnerHTML":
                  Re = He;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  ot(w, J, Tt, He);
              }
          }
        return w.push(gt), dt(w, Re, Te), Te;
      case "option":
        Re = Ce.selectedValue, w.push(at("option"));
        var bt = He = null, Lt = null, Tt = null;
        for (Te in $)
          if (g.call($, Te)) {
            var en = $[Te];
            if (en != null)
              switch (Te) {
                case "children":
                  He = en;
                  break;
                case "selected":
                  Lt = en;
                  break;
                case "dangerouslySetInnerHTML":
                  Tt = en;
                  break;
                case "value":
                  bt = en;
                default:
                  ot(w, J, Te, en);
              }
          }
        if (Re != null)
          if ($ = bt !== null ? "" + bt : Ye(He), Y(Re)) {
            for (J = 0; J < Re.length; J++)
              if ("" + Re[J] === $) {
                w.push(Je);
                break;
              }
          } else
            "" + Re === $ && w.push(Je);
        else
          Lt && w.push(Je);
        return w.push(gt), dt(w, Tt, He), He;
      case "textarea":
        w.push(at("textarea")), Tt = Re = Te = null;
        for (He in $)
          if (g.call($, He) && (bt = $[He], bt != null))
            switch (He) {
              case "children":
                Tt = bt;
                break;
              case "value":
                Te = bt;
                break;
              case "defaultValue":
                Re = bt;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                ot(w, J, He, bt);
            }
        if (Te === null && Re !== null && (Te = Re), w.push(gt), Tt != null) {
          if (Te != null)
            throw Error(t(92));
          if (Y(Tt) && 1 < Tt.length)
            throw Error(t(93));
          Te = "" + Tt;
        }
        return typeof Te == "string" && Te[0] === `
` && w.push(nt), Te !== null && w.push(d(q("" + Te))), null;
      case "input":
        w.push(at("input")), bt = Tt = He = Te = null;
        for (Re in $)
          if (g.call($, Re) && (Lt = $[Re], Lt != null))
            switch (Re) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                bt = Lt;
                break;
              case "defaultValue":
                He = Lt;
                break;
              case "checked":
                Tt = Lt;
                break;
              case "value":
                Te = Lt;
                break;
              default:
                ot(w, J, Re, Lt);
            }
        return Tt !== null ? ot(
          w,
          J,
          "checked",
          Tt
        ) : bt !== null && ot(w, J, "checked", bt), Te !== null ? ot(w, J, "value", Te) : He !== null && ot(w, J, "value", He), w.push(st), null;
      case "menuitem":
        w.push(at("menuitem"));
        for (var Yn in $)
          if (g.call($, Yn) && (Te = $[Yn], Te != null))
            switch (Yn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                ot(w, J, Yn, Te);
            }
        return w.push(gt), null;
      case "title":
        w.push(at("title")), Te = null;
        for (en in $)
          if (g.call($, en) && (Re = $[en], Re != null))
            switch (en) {
              case "children":
                Te = Re;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                ot(w, J, en, Re);
            }
        return w.push(gt), Te;
      case "listing":
      case "pre":
        w.push(at(P)), Re = Te = null;
        for (bt in $)
          if (g.call($, bt) && (He = $[bt], He != null))
            switch (bt) {
              case "children":
                Te = He;
                break;
              case "dangerouslySetInnerHTML":
                Re = He;
                break;
              default:
                ot(w, J, bt, He);
            }
        if (w.push(gt), Re != null) {
          if (Te != null)
            throw Error(t(60));
          if (typeof Re != "object" || !("__html" in Re))
            throw Error(t(61));
          $ = Re.__html, $ != null && (typeof $ == "string" && 0 < $.length && $[0] === `
` ? w.push(nt, d($)) : w.push(d("" + $)));
        }
        return typeof Te == "string" && Te[0] === `
` && w.push(nt), Te;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        w.push(at(P));
        for (var ur in $)
          if (g.call($, ur) && (Te = $[ur], Te != null))
            switch (ur) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, P));
              default:
                ot(w, J, ur, Te);
            }
        return w.push(st), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return yt(w, $, P, J);
      case "html":
        return Ce.insertionMode === 0 && w.push(ct), yt(w, $, P, J);
      default:
        if (P.indexOf("-") === -1 && typeof $.is != "string")
          return yt(w, $, P, J);
        w.push(at(P)), Re = Te = null;
        for (Lt in $)
          if (g.call($, Lt) && (He = $[Lt], He != null))
            switch (Lt) {
              case "children":
                Te = He;
                break;
              case "dangerouslySetInnerHTML":
                Re = He;
                break;
              case "style":
                Ie(w, J, He);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                y(Lt) && typeof He != "function" && typeof He != "symbol" && w.push(Le, d(Lt), Fe, d(q(He)), Xe);
            }
        return w.push(gt), dt(w, Re, Te), Te;
    }
  }
  var rn = p("</"), Ne = p(">"), Ct = p('<template id="'), bn = p('"></template>'), Zt = p("<!--$-->"), jt = p('<!--$?--><template id="'), Qt = p('"></template>'), _n = p("<!--$!-->"), Gt = p("<!--/$-->"), fn = p("<template"), Nt = p('"'), Yt = p(' data-dgst="');
  p(' data-msg="'), p(' data-stck="');
  var tn = p("></template>");
  function zt(w, P, $) {
    if (i(w, jt), $ === null)
      throw Error(t(395));
    return i(w, $), o(w, Qt);
  }
  var It = p('<div hidden id="'), $t = p('">'), Ze = p("</div>"), mt = p('<svg aria-hidden="true" style="display:none" id="'), Kt = p('">'), Pe = p("</svg>"), _e = p('<math aria-hidden="true" style="display:none" id="'), xe = p('">'), ut = p("</math>"), et = p('<table hidden id="'), rt = p('">'), At = p("</table>"), Xt = p('<table hidden><tbody id="'), tt = p('">'), _t = p("</tbody></table>"), yn = p('<table hidden><tr id="'), vt = p('">'), St = p("</tr></table>"), gn = p('<table hidden><colgroup id="'), xn = p('">'), On = p("</colgroup></table>");
  function Fn(w, P, $, J) {
    switch ($.insertionMode) {
      case 0:
      case 1:
        return i(w, It), i(w, P.segmentPrefix), i(w, d(J.toString(16))), o(w, $t);
      case 2:
        return i(w, mt), i(w, P.segmentPrefix), i(w, d(J.toString(16))), o(w, Kt);
      case 3:
        return i(w, _e), i(w, P.segmentPrefix), i(w, d(J.toString(16))), o(w, xe);
      case 4:
        return i(w, et), i(w, P.segmentPrefix), i(w, d(J.toString(16))), o(w, rt);
      case 5:
        return i(w, Xt), i(w, P.segmentPrefix), i(w, d(J.toString(16))), o(w, tt);
      case 6:
        return i(w, yn), i(w, P.segmentPrefix), i(w, d(J.toString(16))), o(w, vt);
      case 7:
        return i(
          w,
          gn
        ), i(w, P.segmentPrefix), i(w, d(J.toString(16))), o(w, xn);
      default:
        throw Error(t(397));
    }
  }
  function Pn(w, P) {
    switch (P.insertionMode) {
      case 0:
      case 1:
        return o(w, Ze);
      case 2:
        return o(w, Pe);
      case 3:
        return o(w, ut);
      case 4:
        return o(w, At);
      case 5:
        return o(w, _t);
      case 6:
        return o(w, St);
      case 7:
        return o(w, On);
      default:
        throw Error(t(397));
    }
  }
  var ir = p('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Nn = p('$RS("'), Sn = p('","'), Dt = p('")<\/script>'), nn = p('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), dn = p('$RC("'), Hn = p('","'), Jt = p('")<\/script>'), qt = p('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Ot = p('$RX("'), pn = p('"'), an = p(")<\/script>"), un = p(","), ar = /[<\u2028\u2029]/g;
  function Rn(w) {
    return JSON.stringify(w).replace(ar, function(P) {
      switch (P) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var wn = Object.assign, mn = Symbol.for("react.element"), Mn = Symbol.for("react.portal"), Wn = Symbol.for("react.fragment"), gr = Symbol.for("react.strict_mode"), vr = Symbol.for("react.profiler"), Xn = Symbol.for("react.provider"), Vn = Symbol.for("react.context"), or = Symbol.for("react.forward_ref"), qn = Symbol.for("react.suspense"), Zn = Symbol.for("react.suspense_list"), b = Symbol.for("react.memo"), C = Symbol.for("react.lazy"), I = Symbol.for("react.scope"), H = Symbol.for("react.debug_trace_mode"), oe = Symbol.for("react.legacy_hidden"), pe = Symbol.for("react.default_value"), we = Symbol.iterator;
  function K(w) {
    if (w == null)
      return null;
    if (typeof w == "function")
      return w.displayName || w.name || null;
    if (typeof w == "string")
      return w;
    switch (w) {
      case Wn:
        return "Fragment";
      case Mn:
        return "Portal";
      case vr:
        return "Profiler";
      case gr:
        return "StrictMode";
      case qn:
        return "Suspense";
      case Zn:
        return "SuspenseList";
    }
    if (typeof w == "object")
      switch (w.$$typeof) {
        case Vn:
          return (w.displayName || "Context") + ".Consumer";
        case Xn:
          return (w._context.displayName || "Context") + ".Provider";
        case or:
          var P = w.render;
          return w = w.displayName, w || (w = P.displayName || P.name || "", w = w !== "" ? "ForwardRef(" + w + ")" : "ForwardRef"), w;
        case b:
          return P = w.displayName || null, P !== null ? P : K(w.type) || "Memo";
        case C:
          P = w._payload, w = w._init;
          try {
            return K(w(P));
          } catch {
          }
      }
    return null;
  }
  var X = {};
  function le(w, P) {
    if (w = w.contextTypes, !w)
      return X;
    var $ = {}, J;
    for (J in w)
      $[J] = P[J];
    return $;
  }
  var be = null;
  function Ue(w, P) {
    if (w !== P) {
      w.context._currentValue = w.parentValue, w = w.parent;
      var $ = P.parent;
      if (w === null) {
        if ($ !== null)
          throw Error(t(401));
      } else {
        if ($ === null)
          throw Error(t(401));
        Ue(w, $);
      }
      P.context._currentValue = P.value;
    }
  }
  function Ft(w) {
    w.context._currentValue = w.parentValue, w = w.parent, w !== null && Ft(w);
  }
  function Ht(w) {
    var P = w.parent;
    P !== null && Ht(P), w.context._currentValue = w.value;
  }
  function Rt(w, P) {
    if (w.context._currentValue = w.parentValue, w = w.parent, w === null)
      throw Error(t(402));
    w.depth === P.depth ? Ue(w, P) : Rt(w, P);
  }
  function Vt(w, P) {
    var $ = P.parent;
    if ($ === null)
      throw Error(t(402));
    w.depth === $.depth ? Ue(w, $) : Vt(w, $), P.context._currentValue = P.value;
  }
  function kn(w) {
    var P = be;
    P !== w && (P === null ? Ht(w) : w === null ? Ft(P) : P.depth === w.depth ? Ue(P, w) : P.depth > w.depth ? Rt(P, w) : Vt(P, w), be = w);
  }
  var jn = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(w, P) {
    w = w._reactInternals, w.queue !== null && w.queue.push(P);
  }, enqueueReplaceState: function(w, P) {
    w = w._reactInternals, w.replace = !0, w.queue = [P];
  }, enqueueForceUpdate: function() {
  } };
  function Qn(w, P, $, J) {
    var Ce = w.state !== void 0 ? w.state : null;
    w.updater = jn, w.props = $, w.state = Ce;
    var Te = { queue: [], replace: !1 };
    w._reactInternals = Te;
    var Re = P.contextType;
    if (w.context = typeof Re == "object" && Re !== null ? Re._currentValue : J, Re = P.getDerivedStateFromProps, typeof Re == "function" && (Re = Re($, Ce), Ce = Re == null ? Ce : wn({}, Ce, Re), w.state = Ce), typeof P.getDerivedStateFromProps != "function" && typeof w.getSnapshotBeforeUpdate != "function" && (typeof w.UNSAFE_componentWillMount == "function" || typeof w.componentWillMount == "function"))
      if (P = w.state, typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount(), P !== w.state && jn.enqueueReplaceState(w, w.state, null), Te.queue !== null && 0 < Te.queue.length)
        if (P = Te.queue, Re = Te.replace, Te.queue = null, Te.replace = !1, Re && P.length === 1)
          w.state = P[0];
        else {
          for (Te = Re ? P[0] : w.state, Ce = !0, Re = Re ? 1 : 0; Re < P.length; Re++) {
            var He = P[Re];
            He = typeof He == "function" ? He.call(w, Te, $, J) : He, He != null && (Ce ? (Ce = !1, Te = wn({}, Te, He)) : wn(Te, He));
          }
          w.state = Te;
        }
      else
        Te.queue = null;
  }
  var sr = { id: 1, overflow: "" };
  function Kn(w, P, $) {
    var J = w.id;
    w = w.overflow;
    var Ce = 32 - Ar(J) - 1;
    J &= ~(1 << Ce), $ += 1;
    var Te = 32 - Ar(P) + Ce;
    if (30 < Te) {
      var Re = Ce - Ce % 5;
      return Te = (J & (1 << Re) - 1).toString(32), J >>= Re, Ce -= Re, { id: 1 << 32 - Ar(P) + Ce | $ << Ce | J, overflow: Te + w };
    }
    return { id: 1 << Te | $ << Ce | J, overflow: w };
  }
  var Ar = Math.clz32 ? Math.clz32 : kt, na = Math.log, Ti = Math.LN2;
  function kt(w) {
    return w >>>= 0, w === 0 ? 32 : 31 - (na(w) / Ti | 0) | 0;
  }
  function Dn(w, P) {
    return w === P && (w !== 0 || 1 / w === 1 / P) || w !== w && P !== P;
  }
  var Br = typeof Object.is == "function" ? Object.is : Dn, Un = null, zr = null, Zr = null, Wt = null, Jn = !1, In = !1, $r = 0, _r = null, Ci = 0;
  function Pr() {
    if (Un === null)
      throw Error(t(321));
    return Un;
  }
  function lr() {
    if (0 < Ci)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function ra() {
    return Wt === null ? Zr === null ? (Jn = !1, Zr = Wt = lr()) : (Jn = !0, Wt = Zr) : Wt.next === null ? (Jn = !1, Wt = Wt.next = lr()) : (Jn = !0, Wt = Wt.next), Wt;
  }
  function ia() {
    zr = Un = null, In = !1, Zr = null, Ci = 0, Wt = _r = null;
  }
  function Ga(w, P) {
    return typeof P == "function" ? P(w) : P;
  }
  function Ya(w, P, $) {
    if (Un = Pr(), Wt = ra(), Jn) {
      var J = Wt.queue;
      if (P = J.dispatch, _r !== null && ($ = _r.get(J), $ !== void 0)) {
        _r.delete(J), J = Wt.memoizedState;
        do
          J = w(J, $.action), $ = $.next;
        while ($ !== null);
        return Wt.memoizedState = J, [J, P];
      }
      return [Wt.memoizedState, P];
    }
    return w = w === Ga ? typeof P == "function" ? P() : P : $ !== void 0 ? $(P) : P, Wt.memoizedState = w, w = Wt.queue = { last: null, dispatch: null }, w = w.dispatch = cs.bind(null, Un, w), [Wt.memoizedState, w];
  }
  function Xa(w, P) {
    if (Un = Pr(), Wt = ra(), P = P === void 0 ? null : P, Wt !== null) {
      var $ = Wt.memoizedState;
      if ($ !== null && P !== null) {
        var J = $[1];
        e:
          if (J === null)
            J = !1;
          else {
            for (var Ce = 0; Ce < J.length && Ce < P.length; Ce++)
              if (!Br(P[Ce], J[Ce])) {
                J = !1;
                break e;
              }
            J = !0;
          }
        if (J)
          return $[0];
      }
    }
    return w = w(), Wt.memoizedState = [w, P], w;
  }
  function cs(w, P, $) {
    if (25 <= Ci)
      throw Error(t(301));
    if (w === Un)
      if (In = !0, w = { action: $, next: null }, _r === null && (_r = /* @__PURE__ */ new Map()), $ = _r.get(P), $ === void 0)
        _r.set(P, w);
      else {
        for (P = $; P.next !== null; )
          P = P.next;
        P.next = w;
      }
  }
  function ds() {
    throw Error(t(394));
  }
  function Ai() {
  }
  var Li = { readContext: function(w) {
    return w._currentValue;
  }, useContext: function(w) {
    return Pr(), w._currentValue;
  }, useMemo: Xa, useReducer: Ya, useRef: function(w) {
    Un = Pr(), Wt = ra();
    var P = Wt.memoizedState;
    return P === null ? (w = { current: w }, Wt.memoizedState = w) : P;
  }, useState: function(w) {
    return Ya(Ga, w);
  }, useInsertionEffect: Ai, useLayoutEffect: function() {
  }, useCallback: function(w, P) {
    return Xa(function() {
      return w;
    }, P);
  }, useImperativeHandle: Ai, useEffect: Ai, useDebugValue: Ai, useDeferredValue: function(w) {
    return Pr(), w;
  }, useTransition: function() {
    return Pr(), [!1, ds];
  }, useId: function() {
    var w = zr.treeContext, P = w.overflow;
    w = w.id, w = (w & ~(1 << 32 - Ar(w) - 1)).toString(32) + P;
    var $ = Ei;
    if ($ === null)
      throw Error(t(404));
    return P = $r++, w = ":" + $.idPrefix + "R" + w, 0 < P && (w += "H" + P.toString(32)), w + ":";
  }, useMutableSource: function(w, P) {
    return Pr(), P(w._source);
  }, useSyncExternalStore: function(w, P, $) {
    if ($ === void 0)
      throw Error(t(407));
    return $();
  } }, Ei = null, ui = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function hs(w) {
    return console.error(w), null;
  }
  function ci() {
  }
  function aa(w, P, $, J, Ce, Te, Re, He, bt) {
    var Lt = [], Tt = /* @__PURE__ */ new Set();
    return P = { destination: null, responseState: P, progressiveChunkSize: J === void 0 ? 12800 : J, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Tt, pingedTasks: Lt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Ce === void 0 ? hs : Ce, onAllReady: Te === void 0 ? ci : Te, onShellReady: Re === void 0 ? ci : Re, onShellError: He === void 0 ? ci : He, onFatalError: bt === void 0 ? ci : bt }, $ = Qr(P, 0, null, $, !1, !1), $.parentFlushed = !0, w = oa(P, w, null, $, Tt, X, null, sr), Lt.push(w), P;
  }
  function oa(w, P, $, J, Ce, Te, Re, He) {
    w.allPendingTasks++, $ === null ? w.pendingRootTasks++ : $.pendingTasks++;
    var bt = { node: P, ping: function() {
      var Lt = w.pingedTasks;
      Lt.push(bt), Lt.length === 1 && to(w);
    }, blockedBoundary: $, blockedSegment: J, abortSet: Ce, legacyContext: Te, context: Re, treeContext: He };
    return Ce.add(bt), bt;
  }
  function Qr(w, P, $, J, Ce, Te) {
    return { status: 0, id: -1, index: P, parentFlushed: !1, chunks: [], children: [], formatContext: J, boundary: $, lastPushedText: Ce, textEmbedded: Te };
  }
  function Jr(w, P) {
    if (w = w.onError(P), w != null && typeof w != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof w + '" instead');
    return w;
  }
  function _i(w, P) {
    var $ = w.onShellError;
    $(P), $ = w.onFatalError, $(P), w.destination !== null ? (w.status = 2, m(w.destination, P)) : (w.status = 1, w.fatalError = P);
  }
  function qa(w, P, $, J, Ce) {
    for (Un = {}, zr = P, $r = 0, w = $(J, Ce); In; )
      In = !1, $r = 0, Ci += 1, Wt = null, w = $(J, Ce);
    return ia(), w;
  }
  function sa(w, P, $, J) {
    var Ce = $.render(), Te = J.childContextTypes;
    if (Te != null) {
      var Re = P.legacyContext;
      if (typeof $.getChildContext != "function")
        J = Re;
      else {
        $ = $.getChildContext();
        for (var He in $)
          if (!(He in Te))
            throw Error(t(108, K(J) || "Unknown", He));
        J = wn({}, Re, $);
      }
      P.legacyContext = J, Gn(w, P, Ce), P.legacyContext = Re;
    } else
      Gn(w, P, Ce);
  }
  function Za(w, P) {
    if (w && w.defaultProps) {
      P = wn({}, P), w = w.defaultProps;
      for (var $ in w)
        P[$] === void 0 && (P[$] = w[$]);
      return P;
    }
    return P;
  }
  function Pi(w, P, $, J, Ce) {
    if (typeof $ == "function")
      if ($.prototype && $.prototype.isReactComponent) {
        Ce = le($, P.legacyContext);
        var Te = $.contextType;
        Te = new $(J, typeof Te == "object" && Te !== null ? Te._currentValue : Ce), Qn(Te, $, J, Ce), sa(w, P, Te, $);
      } else {
        Te = le($, P.legacyContext), Ce = qa(w, P, $, J, Te);
        var Re = $r !== 0;
        if (typeof Ce == "object" && Ce !== null && typeof Ce.render == "function" && Ce.$$typeof === void 0)
          Qn(Ce, $, J, Te), sa(w, P, Ce, $);
        else if (Re) {
          J = P.treeContext, P.treeContext = Kn(J, 1, 0);
          try {
            Gn(w, P, Ce);
          } finally {
            P.treeContext = J;
          }
        } else
          Gn(w, P, Ce);
      }
    else if (typeof $ == "string") {
      switch (Ce = P.blockedSegment, Te = wt(Ce.chunks, $, J, w.responseState, Ce.formatContext), Ce.lastPushedText = !1, Re = Ce.formatContext, Ce.formatContext = ne(Re, $, J), Ni(w, P, Te), Ce.formatContext = Re, $) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Ce.chunks.push(rn, d($), Ne);
      }
      Ce.lastPushedText = !1;
    } else {
      switch ($) {
        case oe:
        case H:
        case gr:
        case vr:
        case Wn:
          Gn(w, P, J.children);
          return;
        case Zn:
          Gn(w, P, J.children);
          return;
        case I:
          throw Error(t(343));
        case qn:
          e: {
            $ = P.blockedBoundary, Ce = P.blockedSegment, Te = J.fallback, J = J.children, Re = /* @__PURE__ */ new Set();
            var He = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Re, errorDigest: null }, bt = Qr(w, Ce.chunks.length, He, Ce.formatContext, !1, !1);
            Ce.children.push(bt), Ce.lastPushedText = !1;
            var Lt = Qr(w, 0, null, Ce.formatContext, !1, !1);
            Lt.parentFlushed = !0, P.blockedBoundary = He, P.blockedSegment = Lt;
            try {
              if (Ni(
                w,
                P,
                J
              ), Lt.lastPushedText && Lt.textEmbedded && Lt.chunks.push(G), Lt.status = 1, Ri(He, Lt), He.pendingTasks === 0)
                break e;
            } catch (Tt) {
              Lt.status = 4, He.forceClientRender = !0, He.errorDigest = Jr(w, Tt);
            } finally {
              P.blockedBoundary = $, P.blockedSegment = Ce;
            }
            P = oa(w, Te, $, bt, Re, P.legacyContext, P.context, P.treeContext), w.pingedTasks.push(P);
          }
          return;
      }
      if (typeof $ == "object" && $ !== null)
        switch ($.$$typeof) {
          case or:
            if (J = qa(w, P, $.render, J, Ce), $r !== 0) {
              $ = P.treeContext, P.treeContext = Kn($, 1, 0);
              try {
                Gn(w, P, J);
              } finally {
                P.treeContext = $;
              }
            } else
              Gn(w, P, J);
            return;
          case b:
            $ = $.type, J = Za($, J), Pi(w, P, $, J, Ce);
            return;
          case Xn:
            if (Ce = J.children, $ = $._context, J = J.value, Te = $._currentValue, $._currentValue = J, Re = be, be = J = { parent: Re, depth: Re === null ? 0 : Re.depth + 1, context: $, parentValue: Te, value: J }, P.context = J, Gn(w, P, Ce), w = be, w === null)
              throw Error(t(403));
            J = w.parentValue, w.context._currentValue = J === pe ? w.context._defaultValue : J, w = be = w.parent, P.context = w;
            return;
          case Vn:
            J = J.children, J = J($._currentValue), Gn(w, P, J);
            return;
          case C:
            Ce = $._init, $ = Ce($._payload), J = Za($, J), Pi(w, P, $, J, void 0);
            return;
        }
      throw Error(t(
        130,
        $ == null ? $ : typeof $,
        ""
      ));
    }
  }
  function Gn(w, P, $) {
    if (P.node = $, typeof $ == "object" && $ !== null) {
      switch ($.$$typeof) {
        case mn:
          Pi(w, P, $.type, $.props, $.ref);
          return;
        case Mn:
          throw Error(t(257));
        case C:
          var J = $._init;
          $ = J($._payload), Gn(w, P, $);
          return;
      }
      if (Y($)) {
        Qa(w, P, $);
        return;
      }
      if ($ === null || typeof $ != "object" ? J = null : (J = we && $[we] || $["@@iterator"], J = typeof J == "function" ? J : null), J && (J = J.call($))) {
        if ($ = J.next(), !$.done) {
          var Ce = [];
          do
            Ce.push($.value), $ = J.next();
          while (!$.done);
          Qa(w, P, Ce);
        }
        return;
      }
      throw w = Object.prototype.toString.call($), Error(t(31, w === "[object Object]" ? "object with keys {" + Object.keys($).join(", ") + "}" : w));
    }
    typeof $ == "string" ? (J = P.blockedSegment, J.lastPushedText = me(P.blockedSegment.chunks, $, w.responseState, J.lastPushedText)) : typeof $ == "number" && (J = P.blockedSegment, J.lastPushedText = me(P.blockedSegment.chunks, "" + $, w.responseState, J.lastPushedText));
  }
  function Qa(w, P, $) {
    for (var J = $.length, Ce = 0; Ce < J; Ce++) {
      var Te = P.treeContext;
      P.treeContext = Kn(Te, J, Ce);
      try {
        Ni(w, P, $[Ce]);
      } finally {
        P.treeContext = Te;
      }
    }
  }
  function Ni(w, P, $) {
    var J = P.blockedSegment.formatContext, Ce = P.legacyContext, Te = P.context;
    try {
      return Gn(w, P, $);
    } catch (bt) {
      if (ia(), typeof bt == "object" && bt !== null && typeof bt.then == "function") {
        $ = bt;
        var Re = P.blockedSegment, He = Qr(w, Re.chunks.length, null, Re.formatContext, Re.lastPushedText, !0);
        Re.children.push(He), Re.lastPushedText = !1, w = oa(w, P.node, P.blockedBoundary, He, P.abortSet, P.legacyContext, P.context, P.treeContext).ping, $.then(w, w), P.blockedSegment.formatContext = J, P.legacyContext = Ce, P.context = Te, kn(Te);
      } else
        throw P.blockedSegment.formatContext = J, P.legacyContext = Ce, P.context = Te, kn(Te), bt;
    }
  }
  function fs(w) {
    var P = w.blockedBoundary;
    w = w.blockedSegment, w.status = 3, eo(this, P, w);
  }
  function Ja(w, P, $) {
    var J = w.blockedBoundary;
    w.blockedSegment.status = 3, J === null ? (P.allPendingTasks--, P.status !== 2 && (P.status = 2, P.destination !== null && P.destination.close())) : (J.pendingTasks--, J.forceClientRender || (J.forceClientRender = !0, w = $ === void 0 ? Error(t(432)) : $, J.errorDigest = P.onError(w), J.parentFlushed && P.clientRenderedBoundaries.push(J)), J.fallbackAbortableTasks.forEach(function(Ce) {
      return Ja(Ce, P, $);
    }), J.fallbackAbortableTasks.clear(), P.allPendingTasks--, P.allPendingTasks === 0 && (J = P.onAllReady, J()));
  }
  function Ri(w, P) {
    if (P.chunks.length === 0 && P.children.length === 1 && P.children[0].boundary === null) {
      var $ = P.children[0];
      $.id = P.id, $.parentFlushed = !0, $.status === 1 && Ri(w, $);
    } else
      w.completedSegments.push(P);
  }
  function eo(w, P, $) {
    if (P === null) {
      if ($.parentFlushed) {
        if (w.completedRootSegment !== null)
          throw Error(t(389));
        w.completedRootSegment = $;
      }
      w.pendingRootTasks--, w.pendingRootTasks === 0 && (w.onShellError = ci, P = w.onShellReady, P());
    } else
      P.pendingTasks--, P.forceClientRender || (P.pendingTasks === 0 ? ($.parentFlushed && $.status === 1 && Ri(P, $), P.parentFlushed && w.completedBoundaries.push(P), P.fallbackAbortableTasks.forEach(fs, w), P.fallbackAbortableTasks.clear()) : $.parentFlushed && $.status === 1 && (Ri(P, $), P.completedSegments.length === 1 && P.parentFlushed && w.partialBoundaries.push(P)));
    w.allPendingTasks--, w.allPendingTasks === 0 && (w = w.onAllReady, w());
  }
  function to(w) {
    if (w.status !== 2) {
      var P = be, $ = ui.current;
      ui.current = Li;
      var J = Ei;
      Ei = w.responseState;
      try {
        var Ce = w.pingedTasks, Te;
        for (Te = 0; Te < Ce.length; Te++) {
          var Re = Ce[Te], He = w, bt = Re.blockedSegment;
          if (bt.status === 0) {
            kn(Re.context);
            try {
              Gn(He, Re, Re.node), bt.lastPushedText && bt.textEmbedded && bt.chunks.push(G), Re.abortSet.delete(Re), bt.status = 1, eo(He, Re.blockedBoundary, bt);
            } catch (cr) {
              if (ia(), typeof cr == "object" && cr !== null && typeof cr.then == "function") {
                var Lt = Re.ping;
                cr.then(Lt, Lt);
              } else {
                Re.abortSet.delete(Re), bt.status = 4;
                var Tt = Re.blockedBoundary, en = cr, Yn = Jr(He, en);
                if (Tt === null ? _i(He, en) : (Tt.pendingTasks--, Tt.forceClientRender || (Tt.forceClientRender = !0, Tt.errorDigest = Yn, Tt.parentFlushed && He.clientRenderedBoundaries.push(Tt))), He.allPendingTasks--, He.allPendingTasks === 0) {
                  var ur = He.onAllReady;
                  ur();
                }
              }
            } finally {
            }
          }
        }
        Ce.splice(0, Te), w.destination !== null && la(w, w.destination);
      } catch (cr) {
        Jr(w, cr), _i(w, cr);
      } finally {
        Ei = J, ui.current = $, $ === Li && kn(P);
      }
    }
  }
  function Di(w, P, $) {
    switch ($.parentFlushed = !0, $.status) {
      case 0:
        var J = $.id = w.nextSegmentId++;
        return $.lastPushedText = !1, $.textEmbedded = !1, w = w.responseState, i(P, Ct), i(P, w.placeholderPrefix), w = d(J.toString(16)), i(P, w), o(P, bn);
      case 1:
        $.status = 2;
        var Ce = !0;
        J = $.chunks;
        var Te = 0;
        $ = $.children;
        for (var Re = 0; Re < $.length; Re++) {
          for (Ce = $[Re]; Te < Ce.index; Te++)
            i(P, J[Te]);
          Ce = Oi(w, P, Ce);
        }
        for (; Te < J.length - 1; Te++)
          i(P, J[Te]);
        return Te < J.length && (Ce = o(P, J[Te])), Ce;
      default:
        throw Error(t(390));
    }
  }
  function Oi(w, P, $) {
    var J = $.boundary;
    if (J === null)
      return Di(w, P, $);
    if (J.parentFlushed = !0, J.forceClientRender)
      J = J.errorDigest, o(P, _n), i(P, fn), J && (i(P, Yt), i(P, d(q(J))), i(P, Nt)), o(P, tn), Di(w, P, $);
    else if (0 < J.pendingTasks) {
      J.rootSegmentID = w.nextSegmentId++, 0 < J.completedSegments.length && w.partialBoundaries.push(J);
      var Ce = w.responseState, Te = Ce.nextSuspenseID++;
      Ce = p(Ce.boundaryPrefix + Te.toString(16)), J = J.id = Ce, zt(P, w.responseState, J), Di(w, P, $);
    } else if (J.byteSize > w.progressiveChunkSize)
      J.rootSegmentID = w.nextSegmentId++, w.completedBoundaries.push(J), zt(P, w.responseState, J.id), Di(w, P, $);
    else {
      if (o(P, Zt), $ = J.completedSegments, $.length !== 1)
        throw Error(t(391));
      Oi(w, P, $[0]);
    }
    return o(P, Gt);
  }
  function no(w, P, $) {
    return Fn(P, w.responseState, $.formatContext, $.id), Oi(w, P, $), Pn(P, $.formatContext);
  }
  function ro(w, P, $) {
    for (var J = $.completedSegments, Ce = 0; Ce < J.length; Ce++)
      io(w, P, $, J[Ce]);
    if (J.length = 0, w = w.responseState, J = $.id, $ = $.rootSegmentID, i(P, w.startInlineScript), w.sentCompleteBoundaryFunction ? i(P, dn) : (w.sentCompleteBoundaryFunction = !0, i(P, nn)), J === null)
      throw Error(t(395));
    return $ = d($.toString(16)), i(P, J), i(P, Hn), i(P, w.segmentPrefix), i(P, $), o(P, Jt);
  }
  function io(w, P, $, J) {
    if (J.status === 2)
      return !0;
    var Ce = J.id;
    if (Ce === -1) {
      if ((J.id = $.rootSegmentID) === -1)
        throw Error(t(392));
      return no(w, P, J);
    }
    return no(w, P, J), w = w.responseState, i(P, w.startInlineScript), w.sentCompleteSegmentFunction ? i(P, Nn) : (w.sentCompleteSegmentFunction = !0, i(P, ir)), i(P, w.segmentPrefix), Ce = d(Ce.toString(16)), i(P, Ce), i(P, Sn), i(P, w.placeholderPrefix), i(P, Ce), o(P, Dt);
  }
  function la(w, P) {
    n = new Uint8Array(512), r = 0;
    try {
      var $ = w.completedRootSegment;
      if ($ !== null && w.pendingRootTasks === 0) {
        Oi(w, P, $), w.completedRootSegment = null;
        var J = w.responseState.bootstrapChunks;
        for ($ = 0; $ < J.length - 1; $++)
          i(P, J[$]);
        $ < J.length && o(P, J[$]);
      }
      var Ce = w.clientRenderedBoundaries, Te;
      for (Te = 0; Te < Ce.length; Te++) {
        var Re = Ce[Te];
        J = P;
        var He = w.responseState, bt = Re.id, Lt = Re.errorDigest, Tt = Re.errorMessage, en = Re.errorComponentStack;
        if (i(J, He.startInlineScript), He.sentClientRenderFunction ? i(J, Ot) : (He.sentClientRenderFunction = !0, i(
          J,
          qt
        )), bt === null)
          throw Error(t(395));
        i(J, bt), i(J, pn), (Lt || Tt || en) && (i(J, un), i(J, d(Rn(Lt || "")))), (Tt || en) && (i(J, un), i(J, d(Rn(Tt || "")))), en && (i(J, un), i(J, d(Rn(en)))), o(J, an);
      }
      Ce.splice(0, Te);
      var Yn = w.completedBoundaries;
      for (Te = 0; Te < Yn.length; Te++)
        ro(w, P, Yn[Te]);
      Yn.splice(0, Te), h(P), n = new Uint8Array(512), r = 0;
      var ur = w.partialBoundaries;
      for (Te = 0; Te < ur.length; Te++) {
        var cr = ur[Te];
        e: {
          Ce = w, Re = P;
          var Fi = cr.completedSegments;
          for (He = 0; He < Fi.length; He++)
            if (!io(
              Ce,
              Re,
              cr,
              Fi[He]
            )) {
              He++, Fi.splice(0, He);
              var oo = !1;
              break e;
            }
          Fi.splice(0, He), oo = !0;
        }
        if (!oo) {
          w.destination = null, Te++, ur.splice(0, Te);
          return;
        }
      }
      ur.splice(0, Te);
      var ua = w.completedBoundaries;
      for (Te = 0; Te < ua.length; Te++)
        ro(w, P, ua[Te]);
      ua.splice(0, Te);
    } finally {
      h(P), w.allPendingTasks === 0 && w.pingedTasks.length === 0 && w.clientRenderedBoundaries.length === 0 && w.completedBoundaries.length === 0 && P.close();
    }
  }
  function ao(w, P) {
    try {
      var $ = w.abortableTasks;
      $.forEach(function(J) {
        return Ja(J, w, P);
      }), $.clear(), w.destination !== null && la(w, w.destination);
    } catch (J) {
      Jr(w, J), _i(w, J);
    }
  }
  return Vu.renderToReadableStream = function(w, P) {
    return new Promise(function($, J) {
      var Ce, Te, Re = new Promise(function(Tt, en) {
        Te = Tt, Ce = en;
      }), He = aa(w, de(P ? P.identifierPrefix : void 0, P ? P.nonce : void 0, P ? P.bootstrapScriptContent : void 0, P ? P.bootstrapScripts : void 0, P ? P.bootstrapModules : void 0), ge(P ? P.namespaceURI : void 0), P ? P.progressiveChunkSize : void 0, P ? P.onError : void 0, Te, function() {
        var Tt = new ReadableStream({ type: "bytes", pull: function(en) {
          if (He.status === 1)
            He.status = 2, m(en, He.fatalError);
          else if (He.status !== 2 && He.destination === null) {
            He.destination = en;
            try {
              la(He, en);
            } catch (Yn) {
              Jr(He, Yn), _i(He, Yn);
            }
          }
        }, cancel: function() {
          ao(He);
        } }, { highWaterMark: 0 });
        Tt.allReady = Re, $(Tt);
      }, function(Tt) {
        Re.catch(function() {
        }), J(Tt);
      }, Ce);
      if (P && P.signal) {
        var bt = P.signal, Lt = function() {
          ao(He, bt.reason), bt.removeEventListener("abort", Lt);
        };
        bt.addEventListener("abort", Lt);
      }
      to(He);
    });
  }, Vu.version = "18.3.1", Vu;
}
var Ia = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cm;
function jS() {
  return cm || (cm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = he, t = "18.3.1", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(s) {
      {
        for (var c = arguments.length, T = new Array(c > 1 ? c - 1 : 0), _ = 1; _ < c; _++)
          T[_ - 1] = arguments[_];
        o("warn", s, T);
      }
    }
    function i(s) {
      {
        for (var c = arguments.length, T = new Array(c > 1 ? c - 1 : 0), _ = 1; _ < c; _++)
          T[_ - 1] = arguments[_];
        o("error", s, T);
      }
    }
    function o(s, c, T) {
      {
        var _ = n.ReactDebugCurrentFrame, z = _.getStackAddendum();
        z !== "" && (c += "%s", T = T.concat([z]));
        var te = T.map(function(fe) {
          return String(fe);
        });
        te.unshift("Warning: " + c), Function.prototype.apply.call(console[s], console, te);
      }
    }
    function h(s) {
      s();
    }
    function u(s) {
    }
    function d(s, c) {
      p(s, c);
    }
    function p(s, c) {
      return s.push(c);
    }
    function m(s) {
    }
    function g(s) {
      s.push(null);
    }
    function x(s) {
      return s;
    }
    function A(s) {
      return s;
    }
    function k(s, c) {
      s.destroy(c);
    }
    function y(s) {
      {
        var c = typeof Symbol == "function" && Symbol.toStringTag, T = c && s[Symbol.toStringTag] || s.constructor.name || "Object";
        return T;
      }
    }
    function v(s) {
      try {
        return S(s), !1;
      } catch {
        return !0;
      }
    }
    function S(s) {
      return "" + s;
    }
    function B(s, c) {
      if (v(s))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", c, y(s)), S(s);
    }
    function R(s, c) {
      if (v(s))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", c, y(s)), S(s);
    }
    function N(s) {
      if (v(s))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", y(s)), S(s);
    }
    var D = Object.prototype.hasOwnProperty, L = 0, q = 1, V = 2, ae = 3, Y = 4, Q = 5, se = 6, ie = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", M = ie + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", U = new RegExp("^[" + ie + "][" + M + "]*$"), re = {}, j = {};
    function de(s) {
      return D.call(j, s) ? !0 : D.call(re, s) ? !1 : U.test(s) ? (j[s] = !0, !0) : (re[s] = !0, i("Invalid attribute name: `%s`", s), !1);
    }
    function Z(s, c, T, _) {
      if (T !== null && T.type === L)
        return !1;
      switch (typeof c) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (_)
            return !1;
          if (T !== null)
            return !T.acceptsBooleans;
          var z = s.toLowerCase().slice(0, 5);
          return z !== "data-" && z !== "aria-";
        }
        default:
          return !1;
      }
    }
    function ge(s) {
      return G.hasOwnProperty(s) ? G[s] : null;
    }
    function ne(s, c, T, _, z, te, fe) {
      this.acceptsBooleans = c === V || c === ae || c === Y, this.attributeName = _, this.attributeNamespace = z, this.mustUseProperty = T, this.propertyName = s, this.type = c, this.sanitizeURL = te, this.removeEmptyString = fe;
    }
    var G = {}, me = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    me.forEach(function(s) {
      G[s] = new ne(
        s,
        L,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(s) {
      var c = s[0], T = s[1];
      G[c] = new ne(
        c,
        q,
        !1,
        // mustUseProperty
        T,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
      G[s] = new ne(
        s,
        V,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
      G[s] = new ne(
        s,
        V,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(s) {
      G[s] = new ne(
        s,
        ae,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      G[s] = new ne(
        s,
        ae,
        !0,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      G[s] = new ne(
        s,
        Y,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      G[s] = new ne(
        s,
        se,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(s) {
      G[s] = new ne(
        s,
        Q,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ye = /[\-\:]([a-z])/g, Se = function(s) {
      return s[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var c = s.replace(ye, Se);
      G[c] = new ne(
        c,
        q,
        !1,
        // mustUseProperty
        s,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var c = s.replace(ye, Se);
      G[c] = new ne(
        c,
        q,
        !1,
        // mustUseProperty
        s,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var c = s.replace(ye, Se);
      G[c] = new ne(
        c,
        q,
        !1,
        // mustUseProperty
        s,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(s) {
      G[s] = new ne(
        s,
        q,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ce = "xlinkHref";
    G[ce] = new ne(
      "xlinkHref",
      q,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(s) {
      G[s] = new ne(
        s,
        q,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var ke = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ie(s, c) {
      return s + c.charAt(0).toUpperCase() + c.substring(1);
    }
    var Le = ["Webkit", "ms", "Moz", "O"];
    Object.keys(ke).forEach(function(s) {
      Le.forEach(function(c) {
        ke[Ie(c, s)] = ke[s];
      });
    });
    var Fe = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Xe(s, c) {
      Fe[c.type] || c.onChange || c.onInput || c.readOnly || c.disabled || c.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), c.onChange || c.readOnly || c.disabled || c.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Be(s, c) {
      if (s.indexOf("-") === -1)
        return typeof c.is == "string";
      switch (s) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ot = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, gt = {}, st = new RegExp("^(aria)-[" + M + "]*$"), dt = new RegExp("^(aria)[A-Z][" + M + "]*$");
    function Ye(s, c) {
      {
        if (D.call(gt, c) && gt[c])
          return !0;
        if (dt.test(c)) {
          var T = "aria-" + c.slice(4).toLowerCase(), _ = ot.hasOwnProperty(T) ? T : null;
          if (_ == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", c), gt[c] = !0, !0;
          if (c !== _)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", c, _), gt[c] = !0, !0;
        }
        if (st.test(c)) {
          var z = c.toLowerCase(), te = ot.hasOwnProperty(z) ? z : null;
          if (te == null)
            return gt[c] = !0, !1;
          if (c !== te)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", c, te), gt[c] = !0, !0;
        }
      }
      return !0;
    }
    function Je(s, c) {
      {
        var T = [];
        for (var _ in c) {
          var z = Ye(s, _);
          z || T.push(_);
        }
        var te = T.map(function(fe) {
          return "`" + fe + "`";
        }).join(", ");
        T.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", te, s) : T.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", te, s);
      }
    }
    function yt(s, c) {
      Be(s, c) || Je(s, c);
    }
    var nt = !1;
    function lt(s, c) {
      {
        if (s !== "input" && s !== "textarea" && s !== "select")
          return;
        c != null && c.value === null && !nt && (nt = !0, s === "select" && c.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", s) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", s));
      }
    }
    var je = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, at = function() {
    };
    {
      var ct = {}, wt = /^on./, rn = /^on[^A-Z]/, Ne = new RegExp("^(aria)-[" + M + "]*$"), Ct = new RegExp("^(aria)[A-Z][" + M + "]*$");
      at = function(s, c, T, _) {
        if (D.call(ct, c) && ct[c])
          return !0;
        var z = c.toLowerCase();
        if (z === "onfocusin" || z === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), ct[c] = !0, !0;
        if (_ != null) {
          var te = _.registrationNameDependencies, fe = _.possibleRegistrationNames;
          if (te.hasOwnProperty(c))
            return !0;
          var Ae = fe.hasOwnProperty(z) ? fe[z] : null;
          if (Ae != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", c, Ae), ct[c] = !0, !0;
          if (wt.test(c))
            return i("Unknown event handler property `%s`. It will be ignored.", c), ct[c] = !0, !0;
        } else if (wt.test(c))
          return rn.test(c) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", c), ct[c] = !0, !0;
        if (Ne.test(c) || Ct.test(c))
          return !0;
        if (z === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), ct[c] = !0, !0;
        if (z === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), ct[c] = !0, !0;
        if (z === "is" && T !== null && T !== void 0 && typeof T != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof T), ct[c] = !0, !0;
        if (typeof T == "number" && isNaN(T))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", c), ct[c] = !0, !0;
        var Oe = ge(c), Qe = Oe !== null && Oe.type === L;
        if (je.hasOwnProperty(z)) {
          var it = je[z];
          if (it !== c)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", c, it), ct[c] = !0, !0;
        } else if (!Qe && c !== z)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", c, z), ct[c] = !0, !0;
        return typeof T == "boolean" && Z(c, T, Oe, !1) ? (T ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', T, c, c, T, c) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', T, c, c, T, c, c, c), ct[c] = !0, !0) : Qe ? !0 : Z(c, T, Oe, !1) ? (ct[c] = !0, !1) : ((T === "false" || T === "true") && Oe !== null && Oe.type === ae && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", T, c, T === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', c, T), ct[c] = !0), !0);
      };
    }
    var bn = function(s, c, T) {
      {
        var _ = [];
        for (var z in c) {
          var te = at(s, z, c[z], T);
          te || _.push(z);
        }
        var fe = _.map(function(Ae) {
          return "`" + Ae + "`";
        }).join(", ");
        _.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", fe, s) : _.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", fe, s);
      }
    };
    function Zt(s, c, T) {
      Be(s, c) || bn(s, c, T);
    }
    var jt = function() {
    };
    {
      var Qt = /^(?:webkit|moz|o)[A-Z]/, _n = /^-ms-/, Gt = /-(.)/g, fn = /;\s*$/, Nt = {}, Yt = {}, tn = !1, zt = !1, It = function(s) {
        return s.replace(Gt, function(c, T) {
          return T.toUpperCase();
        });
      }, $t = function(s) {
        Nt.hasOwnProperty(s) && Nt[s] || (Nt[s] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          s,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          It(s.replace(_n, "ms-"))
        ));
      }, Ze = function(s) {
        Nt.hasOwnProperty(s) && Nt[s] || (Nt[s] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", s, s.charAt(0).toUpperCase() + s.slice(1)));
      }, mt = function(s, c) {
        Yt.hasOwnProperty(c) && Yt[c] || (Yt[c] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, s, c.replace(fn, "")));
      }, Kt = function(s, c) {
        tn || (tn = !0, i("`NaN` is an invalid value for the `%s` css style property.", s));
      }, Pe = function(s, c) {
        zt || (zt = !0, i("`Infinity` is an invalid value for the `%s` css style property.", s));
      };
      jt = function(s, c) {
        s.indexOf("-") > -1 ? $t(s) : Qt.test(s) ? Ze(s) : fn.test(c) && mt(s, c), typeof c == "number" && (isNaN(c) ? Kt(s, c) : isFinite(c) || Pe(s, c));
      };
    }
    var _e = jt, xe = /["'&<>]/;
    function ut(s) {
      N(s);
      var c = "" + s, T = xe.exec(c);
      if (!T)
        return c;
      var _, z = "", te, fe = 0;
      for (te = T.index; te < c.length; te++) {
        switch (c.charCodeAt(te)) {
          case 34:
            _ = "&quot;";
            break;
          case 38:
            _ = "&amp;";
            break;
          case 39:
            _ = "&#x27;";
            break;
          case 60:
            _ = "&lt;";
            break;
          case 62:
            _ = "&gt;";
            break;
          default:
            continue;
        }
        fe !== te && (z += c.substring(fe, te)), fe = te + 1, z += _;
      }
      return fe !== te ? z + c.substring(fe, te) : z;
    }
    function et(s) {
      return typeof s == "boolean" || typeof s == "number" ? "" + s : ut(s);
    }
    var rt = /([A-Z])/g, At = /^ms-/;
    function Xt(s) {
      return s.replace(rt, "-$1").toLowerCase().replace(At, "-ms-");
    }
    var tt = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, _t = !1;
    function yn(s) {
      !_t && tt.test(s) && (_t = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(s)));
    }
    var vt = Array.isArray;
    function St(s) {
      return vt(s);
    }
    var gn = "<script>", xn = "<\/script>", On = '<script src="', Fn = '<script type="module" src="', Pn = '" async=""><\/script>';
    function ir(s) {
      return N(s), ("" + s).replace(Nn, Sn);
    }
    var Nn = /(<\/|<)(s)(cript)/gi, Sn = function(s, c, T, _) {
      return "" + c + (T === "s" ? "\\u0073" : "\\u0053") + _;
    };
    function Dt(s, c, T, _, z) {
      var te = s === void 0 ? "" : s, fe = c === void 0 ? gn : '<script nonce="' + et(c) + '">', Ae = [];
      if (T !== void 0 && Ae.push(fe, ir(T), xn), _ !== void 0)
        for (var Oe = 0; Oe < _.length; Oe++)
          Ae.push(On, et(_[Oe]), Pn);
      if (z !== void 0)
        for (var Qe = 0; Qe < z.length; Qe++)
          Ae.push(Fn, et(z[Qe]), Pn);
      return {
        bootstrapChunks: Ae,
        startInlineScript: fe,
        placeholderPrefix: te + "P:",
        segmentPrefix: te + "S:",
        boundaryPrefix: te + "B:",
        idPrefix: te,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var nn = 0, dn = 1, Hn = 2, Jt = 3, qt = 4, Ot = 5, pn = 6, an = 7;
    function un(s, c) {
      return {
        insertionMode: s,
        selectedValue: c
      };
    }
    function ar(s, c, T) {
      switch (c) {
        case "select":
          return un(dn, T.value != null ? T.value : T.defaultValue);
        case "svg":
          return un(Hn, null);
        case "math":
          return un(Jt, null);
        case "foreignObject":
          return un(dn, null);
        case "table":
          return un(qt, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return un(Ot, null);
        case "colgroup":
          return un(an, null);
        case "tr":
          return un(pn, null);
      }
      return s.insertionMode >= qt || s.insertionMode === nn ? un(dn, null) : s;
    }
    var Rn = null;
    function wn(s) {
      var c = s.nextSuspenseID++;
      return s.boundaryPrefix + c.toString(16);
    }
    function mn(s, c, T) {
      var _ = s.idPrefix, z = ":" + _ + "R" + c;
      return T > 0 && (z += "H" + T.toString(32)), z + ":";
    }
    function Mn(s) {
      return et(s);
    }
    var Wn = "<!-- -->";
    function gr(s, c, T, _) {
      return c === "" ? _ : (_ && s.push(Wn), s.push(Mn(c)), !0);
    }
    function vr(s, c, T, _) {
      T && _ && s.push(Wn);
    }
    var Xn = /* @__PURE__ */ new Map();
    function Vn(s) {
      var c = Xn.get(s);
      if (c !== void 0)
        return c;
      var T = et(Xt(s));
      return Xn.set(s, T), T;
    }
    var or = ' style="', qn = ":", Zn = ";";
    function b(s, c, T) {
      if (typeof T != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var _ = !0;
      for (var z in T)
        if (D.call(T, z)) {
          var te = T[z];
          if (!(te == null || typeof te == "boolean" || te === "")) {
            var fe = void 0, Ae = void 0, Oe = z.indexOf("--") === 0;
            Oe ? (fe = et(z), R(te, z), Ae = et(("" + te).trim())) : (_e(z, te), fe = Vn(z), typeof te == "number" ? te !== 0 && !D.call(ke, z) ? Ae = te + "px" : Ae = "" + te : (R(te, z), Ae = et(("" + te).trim()))), _ ? (_ = !1, s.push(or, fe, qn, Ae)) : s.push(Zn, fe, qn, Ae);
          }
        }
      _ || s.push(H);
    }
    var C = " ", I = '="', H = '"', oe = '=""';
    function pe(s, c, T, _) {
      switch (T) {
        case "style": {
          b(s, c, _);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(T.length > 2 && (T[0] === "o" || T[0] === "O") && (T[1] === "n" || T[1] === "N"))
      ) {
        var z = ge(T);
        if (z !== null) {
          switch (typeof _) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!z.acceptsBooleans)
                return;
          }
          var te = z.attributeName, fe = te;
          switch (z.type) {
            case ae:
              _ && s.push(C, fe, oe);
              return;
            case Y:
              _ === !0 ? s.push(C, fe, oe) : _ === !1 || s.push(C, fe, I, et(_), H);
              return;
            case Q:
              isNaN(_) || s.push(C, fe, I, et(_), H);
              break;
            case se:
              !isNaN(_) && _ >= 1 && s.push(C, fe, I, et(_), H);
              break;
            default:
              z.sanitizeURL && (B(_, te), _ = "" + _, yn(_)), s.push(C, fe, I, et(_), H);
          }
        } else if (de(T)) {
          switch (typeof _) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Ae = T.toLowerCase().slice(0, 5);
              if (Ae !== "data-" && Ae !== "aria-")
                return;
            }
          }
          s.push(C, T, I, et(_), H);
        }
      }
    }
    var we = ">", K = "/>";
    function X(s, c, T) {
      if (c != null) {
        if (T != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof c != "object" || !("__html" in c))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var _ = c.__html;
        _ != null && (N(_), s.push("" + _));
      }
    }
    var le = !1, be = !1, Ue = !1, Ft = !1, Ht = !1, Rt = !1, Vt = !1;
    function kn(s, c) {
      {
        var T = s[c];
        if (T != null) {
          var _ = St(T);
          s.multiple && !_ ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", c) : !s.multiple && _ && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", c);
        }
      }
    }
    function jn(s, c, T) {
      Xe("select", c), kn(c, "value"), kn(c, "defaultValue"), c.value !== void 0 && c.defaultValue !== void 0 && !Ue && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Ue = !0), s.push(In("select"));
      var _ = null, z = null;
      for (var te in c)
        if (D.call(c, te)) {
          var fe = c[te];
          if (fe == null)
            continue;
          switch (te) {
            case "children":
              _ = fe;
              break;
            case "dangerouslySetInnerHTML":
              z = fe;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              pe(s, T, te, fe);
              break;
          }
        }
      return s.push(we), X(s, z, _), _;
    }
    function Qn(s) {
      var c = "";
      return e.Children.forEach(s, function(T) {
        T != null && (c += T, !Ht && typeof T != "string" && typeof T != "number" && (Ht = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), c;
    }
    var sr = ' selected=""';
    function Kn(s, c, T, _) {
      var z = _.selectedValue;
      s.push(In("option"));
      var te = null, fe = null, Ae = null, Oe = null;
      for (var Qe in c)
        if (D.call(c, Qe)) {
          var it = c[Qe];
          if (it == null)
            continue;
          switch (Qe) {
            case "children":
              te = it;
              break;
            case "selected":
              Ae = it, Vt || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Vt = !0);
              break;
            case "dangerouslySetInnerHTML":
              Oe = it;
              break;
            case "value":
              fe = it;
            default:
              pe(s, T, Qe, it);
              break;
          }
        }
      if (z != null) {
        var xt;
        if (fe !== null ? (B(fe, "value"), xt = "" + fe) : (Oe !== null && (Rt || (Rt = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), xt = Qn(te)), St(z))
          for (var sn = 0; sn < z.length; sn++) {
            B(z[sn], "value");
            var zn = "" + z[sn];
            if (zn === xt) {
              s.push(sr);
              break;
            }
          }
        else
          B(z, "select.value"), "" + z === xt && s.push(sr);
      } else
        Ae && s.push(sr);
      return s.push(we), X(s, Oe, te), te;
    }
    function Ar(s, c, T) {
      Xe("input", c), c.checked !== void 0 && c.defaultChecked !== void 0 && !be && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", c.type), be = !0), c.value !== void 0 && c.defaultValue !== void 0 && !le && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", c.type), le = !0), s.push(In("input"));
      var _ = null, z = null, te = null, fe = null;
      for (var Ae in c)
        if (D.call(c, Ae)) {
          var Oe = c[Ae];
          if (Oe == null)
            continue;
          switch (Ae) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              fe = Oe;
              break;
            case "defaultValue":
              z = Oe;
              break;
            case "checked":
              te = Oe;
              break;
            case "value":
              _ = Oe;
              break;
            default:
              pe(s, T, Ae, Oe);
              break;
          }
        }
      return te !== null ? pe(s, T, "checked", te) : fe !== null && pe(s, T, "checked", fe), _ !== null ? pe(s, T, "value", _) : z !== null && pe(s, T, "value", z), s.push(K), null;
    }
    function na(s, c, T) {
      Xe("textarea", c), c.value !== void 0 && c.defaultValue !== void 0 && !Ft && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Ft = !0), s.push(In("textarea"));
      var _ = null, z = null, te = null;
      for (var fe in c)
        if (D.call(c, fe)) {
          var Ae = c[fe];
          if (Ae == null)
            continue;
          switch (fe) {
            case "children":
              te = Ae;
              break;
            case "value":
              _ = Ae;
              break;
            case "defaultValue":
              z = Ae;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              pe(s, T, fe, Ae);
              break;
          }
        }
      if (_ === null && z !== null && (_ = z), s.push(we), te != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), _ != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (St(te)) {
          if (te.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          N(te[0]), _ = "" + te[0];
        }
        N(te), _ = "" + te;
      }
      return typeof _ == "string" && _[0] === `
` && s.push(zr), _ !== null && (B(_, "value"), s.push(Mn("" + _))), null;
    }
    function Ti(s, c, T, _) {
      s.push(In(T));
      for (var z in c)
        if (D.call(c, z)) {
          var te = c[z];
          if (te == null)
            continue;
          switch (z) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(T + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              pe(s, _, z, te);
              break;
          }
        }
      return s.push(K), null;
    }
    function kt(s, c, T) {
      s.push(In("menuitem"));
      for (var _ in c)
        if (D.call(c, _)) {
          var z = c[_];
          if (z == null)
            continue;
          switch (_) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              pe(s, T, _, z);
              break;
          }
        }
      return s.push(we), null;
    }
    function Dn(s, c, T) {
      s.push(In("title"));
      var _ = null;
      for (var z in c)
        if (D.call(c, z)) {
          var te = c[z];
          if (te == null)
            continue;
          switch (z) {
            case "children":
              _ = te;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              pe(s, T, z, te);
              break;
          }
        }
      s.push(we);
      {
        var fe = Array.isArray(_) && _.length < 2 ? _[0] || null : _;
        Array.isArray(_) && _.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : fe != null && fe.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : fe != null && typeof fe != "string" && typeof fe != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return _;
    }
    function Br(s, c, T, _) {
      s.push(In(T));
      var z = null, te = null;
      for (var fe in c)
        if (D.call(c, fe)) {
          var Ae = c[fe];
          if (Ae == null)
            continue;
          switch (fe) {
            case "children":
              z = Ae;
              break;
            case "dangerouslySetInnerHTML":
              te = Ae;
              break;
            default:
              pe(s, _, fe, Ae);
              break;
          }
        }
      return s.push(we), X(s, te, z), typeof z == "string" ? (s.push(Mn(z)), null) : z;
    }
    function Un(s, c, T, _) {
      s.push(In(T));
      var z = null, te = null;
      for (var fe in c)
        if (D.call(c, fe)) {
          var Ae = c[fe];
          if (Ae == null)
            continue;
          switch (fe) {
            case "children":
              z = Ae;
              break;
            case "dangerouslySetInnerHTML":
              te = Ae;
              break;
            case "style":
              b(s, _, Ae);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              de(fe) && typeof Ae != "function" && typeof Ae != "symbol" && s.push(C, fe, I, et(Ae), H);
              break;
          }
        }
      return s.push(we), X(s, te, z), z;
    }
    var zr = `
`;
    function Zr(s, c, T, _) {
      s.push(In(T));
      var z = null, te = null;
      for (var fe in c)
        if (D.call(c, fe)) {
          var Ae = c[fe];
          if (Ae == null)
            continue;
          switch (fe) {
            case "children":
              z = Ae;
              break;
            case "dangerouslySetInnerHTML":
              te = Ae;
              break;
            default:
              pe(s, _, fe, Ae);
              break;
          }
        }
      if (s.push(we), te != null) {
        if (z != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof te != "object" || !("__html" in te))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var Oe = te.__html;
        Oe != null && (typeof Oe == "string" && Oe.length > 0 && Oe[0] === `
` ? s.push(zr, Oe) : (N(Oe), s.push("" + Oe)));
      }
      return typeof z == "string" && z[0] === `
` && s.push(zr), z;
    }
    var Wt = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Jn = /* @__PURE__ */ new Map();
    function In(s) {
      var c = Jn.get(s);
      if (c === void 0) {
        if (!Wt.test(s))
          throw new Error("Invalid tag: " + s);
        c = "<" + s, Jn.set(s, c);
      }
      return c;
    }
    var $r = "<!DOCTYPE html>";
    function _r(s, c, T, _, z) {
      switch (yt(c, T), lt(c, T), Zt(c, T, null), !T.suppressContentEditableWarning && T.contentEditable && T.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), z.insertionMode !== Hn && z.insertionMode !== Jt && c.indexOf("-") === -1 && typeof T.is != "string" && c.toLowerCase() !== c && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", c), c) {
        case "select":
          return jn(s, T, _);
        case "option":
          return Kn(s, T, _, z);
        case "textarea":
          return na(s, T, _);
        case "input":
          return Ar(s, T, _);
        case "menuitem":
          return kt(s, T, _);
        case "title":
          return Dn(s, T, _);
        case "listing":
        case "pre":
          return Zr(s, T, c, _);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Ti(s, T, c, _);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Br(s, T, c, _);
        case "html":
          return z.insertionMode === nn && s.push($r), Br(s, T, c, _);
        default:
          return c.indexOf("-") === -1 && typeof T.is != "string" ? Br(s, T, c, _) : Un(s, T, c, _);
      }
    }
    var Ci = "</", Pr = ">";
    function lr(s, c, T) {
      switch (c) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          s.push(Ci, c, Pr);
      }
    }
    function ra(s, c) {
      for (var T = c.bootstrapChunks, _ = 0; _ < T.length - 1; _++)
        d(s, T[_]);
      return _ < T.length ? p(s, T[_]) : !0;
    }
    var ia = '<template id="', Ga = '"></template>';
    function Ya(s, c, T) {
      d(s, ia), d(s, c.placeholderPrefix);
      var _ = T.toString(16);
      return d(s, _), p(s, Ga);
    }
    var Xa = "<!--$-->", cs = '<!--$?--><template id="', ds = '"></template>', Ai = "<!--$!-->", Li = "<!--/$-->", Ei = "<template", ui = '"', hs = ' data-dgst="', ci = ' data-msg="', aa = ' data-stck="', oa = "></template>";
    function Qr(s, c) {
      return p(s, Xa);
    }
    function Jr(s, c, T) {
      if (d(s, cs), T === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return d(s, T), p(s, ds);
    }
    function _i(s, c, T, _, z) {
      var te;
      return te = p(s, Ai), d(s, Ei), T && (d(s, hs), d(s, et(T)), d(s, ui)), _ && (d(s, ci), d(s, et(_)), d(s, ui)), z && (d(s, aa), d(s, et(z)), d(s, ui)), te = p(s, oa), te;
    }
    function qa(s, c) {
      return p(s, Li);
    }
    function sa(s, c) {
      return p(s, Li);
    }
    function Za(s, c) {
      return p(s, Li);
    }
    var Pi = '<div hidden id="', Gn = '">', Qa = "</div>", Ni = '<svg aria-hidden="true" style="display:none" id="', fs = '">', Ja = "</svg>", Ri = '<math aria-hidden="true" style="display:none" id="', eo = '">', to = "</math>", Di = '<table hidden id="', Oi = '">', no = "</table>", ro = '<table hidden><tbody id="', io = '">', la = "</tbody></table>", ao = '<table hidden><tr id="', w = '">', P = "</tr></table>", $ = '<table hidden><colgroup id="', J = '">', Ce = "</colgroup></table>";
    function Te(s, c, T, _) {
      switch (T.insertionMode) {
        case nn:
        case dn:
          return d(s, Pi), d(s, c.segmentPrefix), d(s, _.toString(16)), p(s, Gn);
        case Hn:
          return d(s, Ni), d(s, c.segmentPrefix), d(s, _.toString(16)), p(s, fs);
        case Jt:
          return d(s, Ri), d(s, c.segmentPrefix), d(s, _.toString(16)), p(s, eo);
        case qt:
          return d(s, Di), d(s, c.segmentPrefix), d(s, _.toString(16)), p(s, Oi);
        case Ot:
          return d(s, ro), d(s, c.segmentPrefix), d(s, _.toString(16)), p(s, io);
        case pn:
          return d(s, ao), d(s, c.segmentPrefix), d(s, _.toString(16)), p(s, w);
        case an:
          return d(s, $), d(s, c.segmentPrefix), d(s, _.toString(16)), p(s, J);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Re(s, c) {
      switch (c.insertionMode) {
        case nn:
        case dn:
          return p(s, Qa);
        case Hn:
          return p(s, Ja);
        case Jt:
          return p(s, to);
        case qt:
          return p(s, no);
        case Ot:
          return p(s, la);
        case pn:
          return p(s, P);
        case an:
          return p(s, Ce);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var He = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", bt = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Lt = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Tt = He + ';$RS("', en = '$RS("', Yn = '","', ur = '")<\/script>';
    function cr(s, c, T) {
      d(s, c.startInlineScript), c.sentCompleteSegmentFunction ? d(s, en) : (c.sentCompleteSegmentFunction = !0, d(s, Tt)), d(s, c.segmentPrefix);
      var _ = T.toString(16);
      return d(s, _), d(s, Yn), d(s, c.placeholderPrefix), d(s, _), p(s, ur);
    }
    var Fi = bt + ';$RC("', oo = '$RC("', ua = '","', Zc = '")<\/script>';
    function Qc(s, c, T, _) {
      if (d(s, c.startInlineScript), c.sentCompleteBoundaryFunction ? d(s, oo) : (c.sentCompleteBoundaryFunction = !0, d(s, Fi)), T === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var z = _.toString(16);
      return d(s, T), d(s, ua), d(s, c.segmentPrefix), d(s, z), p(s, Zc);
    }
    var Jc = Lt + ';$RX("', ed = '$RX("', td = '"', nd = ")<\/script>", ps = ",";
    function rd(s, c, T, _, z, te) {
      if (d(s, c.startInlineScript), c.sentClientRenderFunction ? d(s, ed) : (c.sentClientRenderFunction = !0, d(s, Jc)), T === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return d(s, T), d(s, td), (_ || z || te) && (d(s, ps), d(s, ms(_ || ""))), (z || te) && (d(s, ps), d(s, ms(z || ""))), te && (d(s, ps), d(s, ms(te))), p(s, nd);
    }
    var id = /[<\u2028\u2029]/g;
    function ms(s) {
      var c = JSON.stringify(s);
      return c.replace(id, function(T) {
        switch (T) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function ad(s, c) {
      var T = Dt(c, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: T.bootstrapChunks,
        startInlineScript: T.startInlineScript,
        placeholderPrefix: T.placeholderPrefix,
        segmentPrefix: T.segmentPrefix,
        boundaryPrefix: T.boundaryPrefix,
        idPrefix: T.idPrefix,
        nextSuspenseID: T.nextSuspenseID,
        sentCompleteSegmentFunction: T.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: T.sentCompleteBoundaryFunction,
        sentClientRenderFunction: T.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: s
      };
    }
    function ys() {
      return {
        insertionMode: dn,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function Vl(s, c, T, _) {
      return T.generateStaticMarkup ? (s.push(et(c)), !1) : gr(s, c, T, _);
    }
    function Wl(s, c, T, _) {
      if (!c.generateStaticMarkup)
        return vr(s, c, T, _);
    }
    function gs(s, c) {
      return c.generateStaticMarkup ? !0 : Qr(s);
    }
    function br(s, c, T, _, z) {
      return c.generateStaticMarkup ? !0 : _i(s, c, T, _, z);
    }
    function od(s, c) {
      return c.generateStaticMarkup ? !0 : qa(s);
    }
    function jl(s, c) {
      return c.generateStaticMarkup ? !0 : Za(s);
    }
    var dr = Object.assign, Kl = Symbol.for("react.element"), vs = Symbol.for("react.portal"), so = Symbol.for("react.fragment"), lo = Symbol.for("react.strict_mode"), uo = Symbol.for("react.profiler"), ca = Symbol.for("react.provider"), da = Symbol.for("react.context"), ha = Symbol.for("react.forward_ref"), Mi = Symbol.for("react.suspense"), bs = Symbol.for("react.suspense_list"), xs = Symbol.for("react.memo"), co = Symbol.for("react.lazy"), sd = Symbol.for("react.scope"), Ul = Symbol.for("react.debug_trace_mode"), ld = Symbol.for("react.legacy_hidden"), ud = Symbol.for("react.default_value"), Gl = Symbol.iterator, Yl = "@@iterator";
    function cn(s) {
      if (s === null || typeof s != "object")
        return null;
      var c = Gl && s[Gl] || s[Yl];
      return typeof c == "function" ? c : null;
    }
    function fa(s, c, T) {
      var _ = s.displayName;
      if (_)
        return _;
      var z = c.displayName || c.name || "";
      return z !== "" ? T + "(" + z + ")" : T;
    }
    function Ss(s) {
      return s.displayName || "Context";
    }
    function on(s) {
      if (s == null)
        return null;
      if (typeof s.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof s == "function")
        return s.displayName || s.name || null;
      if (typeof s == "string")
        return s;
      switch (s) {
        case so:
          return "Fragment";
        case vs:
          return "Portal";
        case uo:
          return "Profiler";
        case lo:
          return "StrictMode";
        case Mi:
          return "Suspense";
        case bs:
          return "SuspenseList";
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case da:
            var c = s;
            return Ss(c) + ".Consumer";
          case ca:
            var T = s;
            return Ss(T._context) + ".Provider";
          case ha:
            return fa(s, s.render, "ForwardRef");
          case xs:
            var _ = s.displayName || null;
            return _ !== null ? _ : on(s.type) || "Memo";
          case co: {
            var z = s, te = z._payload, fe = z._init;
            try {
              return on(fe(te));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ii = 0, ws, ks, Ts, Cs, As, Xl, ql;
    function ho() {
    }
    ho.__reactDisabledLog = !0;
    function Ls() {
      {
        if (Ii === 0) {
          ws = console.log, ks = console.info, Ts = console.warn, Cs = console.error, As = console.group, Xl = console.groupCollapsed, ql = console.groupEnd;
          var s = {
            configurable: !0,
            enumerable: !0,
            value: ho,
            writable: !0
          };
          Object.defineProperties(console, {
            info: s,
            log: s,
            warn: s,
            error: s,
            group: s,
            groupCollapsed: s,
            groupEnd: s
          });
        }
        Ii++;
      }
    }
    function pa() {
      {
        if (Ii--, Ii === 0) {
          var s = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: dr({}, s, {
              value: ws
            }),
            info: dr({}, s, {
              value: ks
            }),
            warn: dr({}, s, {
              value: Ts
            }),
            error: dr({}, s, {
              value: Cs
            }),
            group: dr({}, s, {
              value: As
            }),
            groupCollapsed: dr({}, s, {
              value: Xl
            }),
            groupEnd: dr({}, s, {
              value: ql
            })
          });
        }
        Ii < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ma = n.ReactCurrentDispatcher, Bi;
    function ya(s, c, T) {
      {
        if (Bi === void 0)
          try {
            throw Error();
          } catch (z) {
            var _ = z.stack.trim().match(/\n( *(at )?)/);
            Bi = _ && _[1] || "";
          }
        return `
` + Bi + s;
      }
    }
    var ga = !1, fo;
    {
      var Zl = typeof WeakMap == "function" ? WeakMap : Map;
      fo = new Zl();
    }
    function Es(s, c) {
      if (!s || ga)
        return "";
      {
        var T = fo.get(s);
        if (T !== void 0)
          return T;
      }
      var _;
      ga = !0;
      var z = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var te;
      te = ma.current, ma.current = null, Ls();
      try {
        if (c) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (kr) {
              _ = kr;
            }
            Reflect.construct(s, [], fe);
          } else {
            try {
              fe.call();
            } catch (kr) {
              _ = kr;
            }
            s.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (kr) {
            _ = kr;
          }
          s();
        }
      } catch (kr) {
        if (kr && _ && typeof kr.stack == "string") {
          for (var Ae = kr.stack.split(`
`), Oe = _.stack.split(`
`), Qe = Ae.length - 1, it = Oe.length - 1; Qe >= 1 && it >= 0 && Ae[Qe] !== Oe[it]; )
            it--;
          for (; Qe >= 1 && it >= 0; Qe--, it--)
            if (Ae[Qe] !== Oe[it]) {
              if (Qe !== 1 || it !== 1)
                do
                  if (Qe--, it--, it < 0 || Ae[Qe] !== Oe[it]) {
                    var xt = `
` + Ae[Qe].replace(" at new ", " at ");
                    return s.displayName && xt.includes("<anonymous>") && (xt = xt.replace("<anonymous>", s.displayName)), typeof s == "function" && fo.set(s, xt), xt;
                  }
                while (Qe >= 1 && it >= 0);
              break;
            }
        }
      } finally {
        ga = !1, ma.current = te, pa(), Error.prepareStackTrace = z;
      }
      var sn = s ? s.displayName || s.name : "", zn = sn ? ya(sn) : "";
      return typeof s == "function" && fo.set(s, zn), zn;
    }
    function _s(s, c, T) {
      return Es(s, !0);
    }
    function Ps(s, c, T) {
      return Es(s, !1);
    }
    function Ql(s) {
      var c = s.prototype;
      return !!(c && c.isReactComponent);
    }
    function zi(s, c, T) {
      if (s == null)
        return "";
      if (typeof s == "function")
        return Es(s, Ql(s));
      if (typeof s == "string")
        return ya(s);
      switch (s) {
        case Mi:
          return ya("Suspense");
        case bs:
          return ya("SuspenseList");
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case ha:
            return Ps(s.render);
          case xs:
            return zi(s.type, c, T);
          case co: {
            var _ = s, z = _._payload, te = _._init;
            try {
              return zi(te(z), c, T);
            } catch {
            }
          }
        }
      return "";
    }
    var Ns = {}, po = n.ReactDebugCurrentFrame;
    function di(s) {
      if (s) {
        var c = s._owner, T = zi(s.type, s._source, c ? c.type : null);
        po.setExtraStackFrame(T);
      } else
        po.setExtraStackFrame(null);
    }
    function Rs(s, c, T, _, z) {
      {
        var te = Function.call.bind(D);
        for (var fe in s)
          if (te(s, fe)) {
            var Ae = void 0;
            try {
              if (typeof s[fe] != "function") {
                var Oe = Error((_ || "React class") + ": " + T + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              Ae = s[fe](c, fe, _, T, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Qe) {
              Ae = Qe;
            }
            Ae && !(Ae instanceof Error) && (di(z), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", _ || "React class", T, fe, typeof Ae), di(null)), Ae instanceof Error && !(Ae.message in Ns) && (Ns[Ae.message] = !0, di(z), i("Failed %s type: %s", T, Ae.message), di(null));
          }
      }
    }
    var Ds;
    Ds = {};
    var ei = {};
    Object.freeze(ei);
    function Jl(s, c) {
      {
        var T = s.contextTypes;
        if (!T)
          return ei;
        var _ = {};
        for (var z in T)
          _[z] = c[z];
        {
          var te = on(s) || "Unknown";
          Rs(T, _, "context", te);
        }
        return _;
      }
    }
    function hi(s, c, T, _) {
      {
        if (typeof s.getChildContext != "function") {
          {
            var z = on(c) || "Unknown";
            Ds[z] || (Ds[z] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", z, z));
          }
          return T;
        }
        var te = s.getChildContext();
        for (var fe in te)
          if (!(fe in _))
            throw new Error((on(c) || "Unknown") + '.getChildContext(): key "' + fe + '" is not defined in childContextTypes.');
        {
          var Ae = on(c) || "Unknown";
          Rs(_, te, "child context", Ae);
        }
        return dr({}, T, te);
      }
    }
    var fi;
    fi = {};
    var Os = null, Nr = null;
    function mo(s) {
      s.context._currentValue2 = s.parentValue;
    }
    function yo(s) {
      s.context._currentValue2 = s.value;
    }
    function va(s, c) {
      if (s !== c) {
        mo(s);
        var T = s.parent, _ = c.parent;
        if (T === null) {
          if (_ !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (_ === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          va(T, _);
        }
        yo(c);
      }
    }
    function Fs(s) {
      mo(s);
      var c = s.parent;
      c !== null && Fs(c);
    }
    function ba(s) {
      var c = s.parent;
      c !== null && ba(c), yo(s);
    }
    function eu(s, c) {
      mo(s);
      var T = s.parent;
      if (T === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      T.depth === c.depth ? va(T, c) : eu(T, c);
    }
    function tu(s, c) {
      var T = c.parent;
      if (T === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      s.depth === T.depth ? va(s, T) : tu(s, T), yo(c);
    }
    function go(s) {
      var c = Nr, T = s;
      c !== T && (c === null ? ba(T) : T === null ? Fs(c) : c.depth === T.depth ? va(c, T) : c.depth > T.depth ? eu(c, T) : tu(c, T), Nr = T);
    }
    function xa(s, c) {
      var T;
      T = s._currentValue2, s._currentValue2 = c, s._currentRenderer2 !== void 0 && s._currentRenderer2 !== null && s._currentRenderer2 !== fi && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer2 = fi;
      var _ = Nr, z = {
        parent: _,
        depth: _ === null ? 0 : _.depth + 1,
        context: s,
        parentValue: T,
        value: c
      };
      return Nr = z, z;
    }
    function Ms(s) {
      var c = Nr;
      if (c === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      c.context !== s && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var T = c.parentValue;
        T === ud ? c.context._currentValue2 = c.context._defaultValue : c.context._currentValue2 = T, s._currentRenderer2 !== void 0 && s._currentRenderer2 !== null && s._currentRenderer2 !== fi && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer2 = fi;
      }
      return Nr = c.parent;
    }
    function cd() {
      return Nr;
    }
    function $i(s) {
      var c = s._currentValue2;
      return c;
    }
    function vo(s) {
      return s._reactInternals;
    }
    function Is(s, c) {
      s._reactInternals = c;
    }
    var bo = {}, xo = {}, Sa, So, Hi, wa, wo, Vi, ko, To, Co;
    {
      Sa = /* @__PURE__ */ new Set(), So = /* @__PURE__ */ new Set(), Hi = /* @__PURE__ */ new Set(), ko = /* @__PURE__ */ new Set(), wa = /* @__PURE__ */ new Set(), To = /* @__PURE__ */ new Set(), Co = /* @__PURE__ */ new Set();
      var nu = /* @__PURE__ */ new Set();
      Vi = function(s, c) {
        if (!(s === null || typeof s == "function")) {
          var T = c + "_" + s;
          nu.has(T) || (nu.add(T), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", c, s));
        }
      }, wo = function(s, c) {
        if (c === void 0) {
          var T = on(s) || "Component";
          wa.has(T) || (wa.add(T), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", T));
        }
      };
    }
    function ru(s, c) {
      {
        var T = s.constructor, _ = T && on(T) || "ReactClass", z = _ + "." + c;
        if (bo[z])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, c, c, _), bo[z] = !0;
      }
    }
    var iu = {
      isMounted: function(s) {
        return !1;
      },
      enqueueSetState: function(s, c, T) {
        var _ = vo(s);
        _.queue === null ? ru(s, "setState") : (_.queue.push(c), T != null && Vi(T, "setState"));
      },
      enqueueReplaceState: function(s, c, T) {
        var _ = vo(s);
        _.replace = !0, _.queue = [c], T != null && Vi(T, "setState");
      },
      enqueueForceUpdate: function(s, c) {
        var T = vo(s);
        T.queue === null ? ru(s, "forceUpdate") : c != null && Vi(c, "setState");
      }
    };
    function dd(s, c, T, _, z) {
      var te = T(z, _);
      wo(c, te);
      var fe = te == null ? _ : dr({}, _, te);
      return fe;
    }
    function hd(s, c, T) {
      var _ = ei, z = s.contextType;
      if ("contextType" in s) {
        var te = (
          // Allow null for conditional declaration
          z === null || z !== void 0 && z.$$typeof === da && z._context === void 0
        );
        if (!te && !Co.has(s)) {
          Co.add(s);
          var fe = "";
          z === void 0 ? fe = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof z != "object" ? fe = " However, it is set to a " + typeof z + "." : z.$$typeof === ca ? fe = " Did you accidentally pass the Context.Provider instead?" : z._context !== void 0 ? fe = " Did you accidentally pass the Context.Consumer instead?" : fe = " However, it is set to an object with keys {" + Object.keys(z).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", on(s) || "Component", fe);
        }
      }
      typeof z == "object" && z !== null ? _ = $i(z) : _ = T;
      var Ae = new s(c, _);
      {
        if (typeof s.getDerivedStateFromProps == "function" && (Ae.state === null || Ae.state === void 0)) {
          var Oe = on(s) || "Component";
          Sa.has(Oe) || (Sa.add(Oe), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Oe, Ae.state === null ? "null" : "undefined", Oe));
        }
        if (typeof s.getDerivedStateFromProps == "function" || typeof Ae.getSnapshotBeforeUpdate == "function") {
          var Qe = null, it = null, xt = null;
          if (typeof Ae.componentWillMount == "function" && Ae.componentWillMount.__suppressDeprecationWarning !== !0 ? Qe = "componentWillMount" : typeof Ae.UNSAFE_componentWillMount == "function" && (Qe = "UNSAFE_componentWillMount"), typeof Ae.componentWillReceiveProps == "function" && Ae.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? it = "componentWillReceiveProps" : typeof Ae.UNSAFE_componentWillReceiveProps == "function" && (it = "UNSAFE_componentWillReceiveProps"), typeof Ae.componentWillUpdate == "function" && Ae.componentWillUpdate.__suppressDeprecationWarning !== !0 ? xt = "componentWillUpdate" : typeof Ae.UNSAFE_componentWillUpdate == "function" && (xt = "UNSAFE_componentWillUpdate"), Qe !== null || it !== null || xt !== null) {
            var sn = on(s) || "Component", zn = typeof s.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Hi.has(sn) || (Hi.add(sn), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, sn, zn, Qe !== null ? `
  ` + Qe : "", it !== null ? `
  ` + it : "", xt !== null ? `
  ` + xt : ""));
          }
        }
      }
      return Ae;
    }
    function au(s, c, T) {
      {
        var _ = on(c) || "Component", z = s.render;
        z || (c.prototype && typeof c.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", _) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", _)), s.getInitialState && !s.getInitialState.isReactClassApproved && !s.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", _), s.getDefaultProps && !s.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", _), s.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", _), s.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", _), s.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", _), c.contextType && c.contextTypes && !To.has(c) && (To.add(c), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", _)), typeof s.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", _), c.prototype && c.prototype.isPureReactComponent && typeof s.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", on(c) || "A pure component"), typeof s.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", _), typeof s.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", _), typeof s.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", _), typeof s.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", _);
        var te = s.props !== T;
        s.props !== void 0 && te && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", _, _), s.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", _, _), typeof s.getSnapshotBeforeUpdate == "function" && typeof s.componentDidUpdate != "function" && !So.has(c) && (So.add(c), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", on(c))), typeof s.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", _), typeof s.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", _), typeof c.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", _);
        var fe = s.state;
        fe && (typeof fe != "object" || St(fe)) && i("%s.state: must be set to an object or null", _), typeof s.getChildContext == "function" && typeof c.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", _);
      }
    }
    function fd(s, c) {
      var T = c.state;
      if (typeof c.componentWillMount == "function") {
        if (c.componentWillMount.__suppressDeprecationWarning !== !0) {
          var _ = on(s) || "Unknown";
          xo[_] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            _
          ), xo[_] = !0);
        }
        c.componentWillMount();
      }
      typeof c.UNSAFE_componentWillMount == "function" && c.UNSAFE_componentWillMount(), T !== c.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", on(s) || "Component"), iu.enqueueReplaceState(c, c.state, null));
    }
    function pd(s, c, T, _) {
      if (s.queue !== null && s.queue.length > 0) {
        var z = s.queue, te = s.replace;
        if (s.queue = null, s.replace = !1, te && z.length === 1)
          c.state = z[0];
        else {
          for (var fe = te ? z[0] : c.state, Ae = !0, Oe = te ? 1 : 0; Oe < z.length; Oe++) {
            var Qe = z[Oe], it = typeof Qe == "function" ? Qe.call(c, fe, T, _) : Qe;
            it != null && (Ae ? (Ae = !1, fe = dr({}, fe, it)) : dr(fe, it));
          }
          c.state = fe;
        }
      } else
        s.queue = null;
    }
    function Ao(s, c, T, _) {
      au(s, c, T);
      var z = s.state !== void 0 ? s.state : null;
      s.updater = iu, s.props = T, s.state = z;
      var te = {
        queue: [],
        replace: !1
      };
      Is(s, te);
      var fe = c.contextType;
      if (typeof fe == "object" && fe !== null ? s.context = $i(fe) : s.context = _, s.state === T) {
        var Ae = on(c) || "Component";
        ko.has(Ae) || (ko.add(Ae), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Ae));
      }
      var Oe = c.getDerivedStateFromProps;
      typeof Oe == "function" && (s.state = dd(s, c, Oe, z, T)), typeof c.getDerivedStateFromProps != "function" && typeof s.getSnapshotBeforeUpdate != "function" && (typeof s.UNSAFE_componentWillMount == "function" || typeof s.componentWillMount == "function") && (fd(c, s), pd(te, s, T, _));
    }
    var Lo = {
      id: 1,
      overflow: ""
    };
    function md(s) {
      var c = s.overflow, T = s.id, _ = T & ~yd(T);
      return _.toString(32) + c;
    }
    function Bs(s, c, T) {
      var _ = s.id, z = s.overflow, te = Eo(_) - 1, fe = _ & ~(1 << te), Ae = T + 1, Oe = Eo(c) + te;
      if (Oe > 30) {
        var Qe = te - te % 5, it = (1 << Qe) - 1, xt = (fe & it).toString(32), sn = fe >> Qe, zn = te - Qe, kr = Eo(c) + zn, Lu = Ae << zn, Eu = Lu | sn, _u = xt + z;
        return {
          id: 1 << kr | Eu,
          overflow: _u
        };
      } else {
        var jo = Ae << te, Eg = jo | fe, _g = z;
        return {
          id: 1 << Oe | Eg,
          overflow: _g
        };
      }
    }
    function Eo(s) {
      return 32 - gd(s);
    }
    function yd(s) {
      return 1 << Eo(s) - 1;
    }
    var gd = Math.clz32 ? Math.clz32 : Hr, vd = Math.log, bd = Math.LN2;
    function Hr(s) {
      var c = s >>> 0;
      return c === 0 ? 32 : 31 - (vd(c) / bd | 0) | 0;
    }
    function zs(s, c) {
      return s === c && (s !== 0 || 1 / s === 1 / c) || s !== s && c !== c;
    }
    var _o = typeof Object.is == "function" ? Object.is : zs, Mt = null, pi = null, mi = null, Ut = null, xr = !1, yi = !1, Po = 0, Bn = null, Vr = 0, gi = 25, Rr = !1, vi;
    function Wr() {
      if (Mt === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Rr && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Mt;
    }
    function xd(s, c) {
      if (c === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", vi), !1;
      s.length !== c.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, vi, "[" + s.join(", ") + "]", "[" + c.join(", ") + "]");
      for (var T = 0; T < c.length && T < s.length; T++)
        if (!_o(s[T], c[T]))
          return !1;
      return !0;
    }
    function ou() {
      if (Vr > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function No() {
      return Ut === null ? mi === null ? (xr = !1, mi = Ut = ou()) : (xr = !0, Ut = mi) : Ut.next === null ? (xr = !1, Ut = Ut.next = ou()) : (xr = !0, Ut = Ut.next), Ut;
    }
    function $s(s, c) {
      Mt = c, pi = s, Rr = !1, Po = 0;
    }
    function Sd(s, c, T, _) {
      for (; yi; )
        yi = !1, Po = 0, Vr += 1, Ut = null, T = s(c, _);
      return ka(), T;
    }
    function su() {
      var s = Po !== 0;
      return s;
    }
    function ka() {
      Rr = !1, Mt = null, pi = null, yi = !1, mi = null, Vr = 0, Bn = null, Ut = null;
    }
    function wd(s) {
      return Rr && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), $i(s);
    }
    function lu(s) {
      return vi = "useContext", Wr(), $i(s);
    }
    function Ro(s, c) {
      return typeof c == "function" ? c(s) : c;
    }
    function kd(s) {
      return vi = "useState", uu(
        Ro,
        // useReducer has a special case to support lazy useState initializers
        s
      );
    }
    function uu(s, c, T) {
      if (s !== Ro && (vi = "useReducer"), Mt = Wr(), Ut = No(), xr) {
        var _ = Ut.queue, z = _.dispatch;
        if (Bn !== null) {
          var te = Bn.get(_);
          if (te !== void 0) {
            Bn.delete(_);
            var fe = Ut.memoizedState, Ae = te;
            do {
              var Oe = Ae.action;
              Rr = !0, fe = s(fe, Oe), Rr = !1, Ae = Ae.next;
            } while (Ae !== null);
            return Ut.memoizedState = fe, [fe, z];
          }
        }
        return [Ut.memoizedState, z];
      } else {
        Rr = !0;
        var Qe;
        s === Ro ? Qe = typeof c == "function" ? c() : c : Qe = T !== void 0 ? T(c) : c, Rr = !1, Ut.memoizedState = Qe;
        var it = Ut.queue = {
          last: null,
          dispatch: null
        }, xt = it.dispatch = Ad.bind(null, Mt, it);
        return [Ut.memoizedState, xt];
      }
    }
    function cu(s, c) {
      Mt = Wr(), Ut = No();
      var T = c === void 0 ? null : c;
      if (Ut !== null) {
        var _ = Ut.memoizedState;
        if (_ !== null && T !== null) {
          var z = _[1];
          if (xd(T, z))
            return _[0];
        }
      }
      Rr = !0;
      var te = s();
      return Rr = !1, Ut.memoizedState = [te, T], te;
    }
    function Td(s) {
      Mt = Wr(), Ut = No();
      var c = Ut.memoizedState;
      if (c === null) {
        var T = {
          current: s
        };
        return Object.seal(T), Ut.memoizedState = T, T;
      } else
        return c;
    }
    function Cd(s, c) {
      vi = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function Ad(s, c, T) {
      if (Vr >= gi)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (s === Mt) {
        yi = !0;
        var _ = {
          action: T,
          next: null
        };
        Bn === null && (Bn = /* @__PURE__ */ new Map());
        var z = Bn.get(c);
        if (z === void 0)
          Bn.set(c, _);
        else {
          for (var te = z; te.next !== null; )
            te = te.next;
          te.next = _;
        }
      }
    }
    function Ld(s, c) {
      return cu(function() {
        return s;
      }, c);
    }
    function Ed(s, c, T) {
      return Wr(), c(s._source);
    }
    function _d(s, c, T) {
      if (T === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return T();
    }
    function Pd(s) {
      return Wr(), s;
    }
    function Do() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function du() {
      return Wr(), [!1, Do];
    }
    function Hs() {
      var s = pi, c = md(s.treeContext), T = Ca;
      if (T === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var _ = Po++;
      return mn(T, c, _);
    }
    function Ta() {
    }
    var hu = {
      readContext: wd,
      useContext: lu,
      useMemo: cu,
      useReducer: uu,
      useRef: Td,
      useState: kd,
      useInsertionEffect: Ta,
      useLayoutEffect: Cd,
      useCallback: Ld,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: Ta,
      // Effects are not run in the server environment.
      useEffect: Ta,
      // Debugging effect
      useDebugValue: Ta,
      useDeferredValue: Pd,
      useTransition: du,
      useId: Hs,
      // Subscriptions are not setup in a server environment.
      useMutableSource: Ed,
      useSyncExternalStore: _d
    }, Ca = null;
    function Oo(s) {
      Ca = s;
    }
    function Vs(s) {
      try {
        var c = "", T = s;
        do {
          switch (T.tag) {
            case 0:
              c += ya(T.type, null, null);
              break;
            case 1:
              c += Ps(T.type, null, null);
              break;
            case 2:
              c += _s(T.type, null, null);
              break;
          }
          T = T.parent;
        } while (T);
        return c;
      } catch (_) {
        return `
Error generating stack: ` + _.message + `
` + _.stack;
      }
    }
    var ti = n.ReactCurrentDispatcher, Fo = n.ReactDebugCurrentFrame, Mo = 0, bi = 1, fu = 2, Ws = 3, xi = 4, Nd = 0, pu = 1, Dr = 2, Rd = 12800;
    function Dd(s) {
      return console.error(s), null;
    }
    function Aa() {
    }
    function js(s, c, T, _, z, te, fe, Ae, Oe) {
      var Qe = [], it = /* @__PURE__ */ new Set(), xt = {
        destination: null,
        responseState: c,
        progressiveChunkSize: _ === void 0 ? Rd : _,
        status: Nd,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: it,
        pingedTasks: Qe,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: z === void 0 ? Dd : z,
        onAllReady: te === void 0 ? Aa : te,
        onShellReady: fe === void 0 ? Aa : fe,
        onShellError: Ae === void 0 ? Aa : Ae,
        onFatalError: Oe === void 0 ? Aa : Oe
      }, sn = ni(
        xt,
        0,
        null,
        T,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      sn.parentFlushed = !0;
      var zn = La(xt, s, null, sn, it, ei, Os, Lo);
      return Qe.push(zn), xt;
    }
    function Io(s, c) {
      var T = s.pingedTasks;
      T.push(c), T.length === 1 && h(function() {
        return Cu(s);
      });
    }
    function jr(s, c) {
      return {
        id: Rn,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: c,
        errorDigest: null
      };
    }
    function La(s, c, T, _, z, te, fe, Ae) {
      s.allPendingTasks++, T === null ? s.pendingRootTasks++ : T.pendingTasks++;
      var Oe = {
        node: c,
        ping: function() {
          return Io(s, Oe);
        },
        blockedBoundary: T,
        blockedSegment: _,
        abortSet: z,
        legacyContext: te,
        context: fe,
        treeContext: Ae
      };
      return Oe.componentStack = null, z.add(Oe), Oe;
    }
    function ni(s, c, T, _, z, te) {
      return {
        status: Mo,
        id: -1,
        // lazily assigned later
        index: c,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: _,
        boundary: T,
        lastPushedText: z,
        textEmbedded: te
      };
    }
    var Or = null;
    function Ks() {
      return Or === null || Or.componentStack === null ? "" : Vs(Or.componentStack);
    }
    function Sr(s, c) {
      s.componentStack = {
        tag: 0,
        parent: s.componentStack,
        type: c
      };
    }
    function Wi(s, c) {
      s.componentStack = {
        tag: 1,
        parent: s.componentStack,
        type: c
      };
    }
    function Us(s, c) {
      s.componentStack = {
        tag: 2,
        parent: s.componentStack,
        type: c
      };
    }
    function wr(s) {
      s.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : s.componentStack = s.componentStack.parent;
    }
    var ri = null;
    function Gs(s, c) {
      {
        var T;
        typeof c == "string" ? T = c : c && typeof c.message == "string" ? T = c.message : T = String(c);
        var _ = ri || Ks();
        ri = null, s.errorMessage = T, s.errorComponentStack = _;
      }
    }
    function Ea(s, c) {
      var T = s.onError(c);
      if (T != null && typeof T != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof T + '" instead');
      return T;
    }
    function Bo(s, c) {
      var T = s.onShellError;
      T(c);
      var _ = s.onFatalError;
      _(c), s.destination !== null ? (s.status = Dr, k(s.destination, c)) : (s.status = pu, s.fatalError = c);
    }
    function mu(s, c, T) {
      Sr(c, "Suspense");
      var _ = c.blockedBoundary, z = c.blockedSegment, te = T.fallback, fe = T.children, Ae = /* @__PURE__ */ new Set(), Oe = jr(s, Ae), Qe = z.chunks.length, it = ni(
        s,
        Qe,
        Oe,
        z.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      z.children.push(it), z.lastPushedText = !1;
      var xt = ni(
        s,
        0,
        null,
        z.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      xt.parentFlushed = !0, c.blockedBoundary = Oe, c.blockedSegment = xt;
      try {
        if (zo(s, c, fe), Wl(xt.chunks, s.responseState, xt.lastPushedText, xt.textEmbedded), xt.status = bi, Na(Oe, xt), Oe.pendingTasks === 0) {
          wr(c);
          return;
        }
      } catch (zn) {
        xt.status = xi, Oe.forceClientRender = !0, Oe.errorDigest = Ea(s, zn), Gs(Oe, zn);
      } finally {
        c.blockedBoundary = _, c.blockedSegment = z;
      }
      var sn = La(s, te, _, it, Ae, c.legacyContext, c.context, c.treeContext);
      sn.componentStack = c.componentStack, s.pingedTasks.push(sn), wr(c);
    }
    function yu(s, c, T, _) {
      Sr(c, T);
      var z = c.blockedSegment, te = _r(z.chunks, T, _, s.responseState, z.formatContext);
      z.lastPushedText = !1;
      var fe = z.formatContext;
      z.formatContext = ar(fe, T, _), zo(s, c, te), z.formatContext = fe, lr(z.chunks, T), z.lastPushedText = !1, wr(c);
    }
    function Od(s) {
      return s.prototype && s.prototype.isReactComponent;
    }
    function Ys(s, c, T, _, z) {
      var te = {};
      $s(c, te);
      var fe = T(_, z);
      return Sd(T, _, fe, z);
    }
    function _a(s, c, T, _, z) {
      var te = T.render();
      T.props !== z && (Qs || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", on(_) || "a component"), Qs = !0);
      {
        var fe = _.childContextTypes;
        if (fe != null) {
          var Ae = c.legacyContext, Oe = hi(T, _, Ae, fe);
          c.legacyContext = Oe, fr(s, c, te), c.legacyContext = Ae;
          return;
        }
      }
      fr(s, c, te);
    }
    function gu(s, c, T, _) {
      Us(c, T);
      var z = Jl(T, c.legacyContext), te = hd(T, _, z);
      Ao(te, T, _, z), _a(s, c, te, T, _), wr(c);
    }
    var Xs = {}, Pa = {}, qs = {}, Zs = {}, Qs = !1, Js = {}, vu = !1, bu = !1, el = !1;
    function Fd(s, c, T, _) {
      var z;
      if (z = Jl(T, c.legacyContext), Wi(c, T), T.prototype && typeof T.prototype.render == "function") {
        var te = on(T) || "Unknown";
        Xs[te] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", te, te), Xs[te] = !0);
      }
      var fe = Ys(s, c, T, _, z), Ae = su();
      if (typeof fe == "object" && fe !== null && typeof fe.render == "function" && fe.$$typeof === void 0) {
        var Oe = on(T) || "Unknown";
        Pa[Oe] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Oe, Oe, Oe), Pa[Oe] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof fe == "object" && fe !== null && typeof fe.render == "function" && fe.$$typeof === void 0
      ) {
        {
          var Qe = on(T) || "Unknown";
          Pa[Qe] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Qe, Qe, Qe), Pa[Qe] = !0);
        }
        Ao(fe, T, _, z), _a(s, c, fe, T, _);
      } else if (Md(T), Ae) {
        var it = c.treeContext, xt = 1, sn = 0;
        c.treeContext = Bs(it, xt, sn);
        try {
          fr(s, c, fe);
        } finally {
          c.treeContext = it;
        }
      } else
        fr(s, c, fe);
      wr(c);
    }
    function Md(s) {
      {
        if (s && s.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", s.displayName || s.name || "Component"), s.defaultProps !== void 0) {
          var c = on(s) || "Unknown";
          Js[c] || (i("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", c), Js[c] = !0);
        }
        if (typeof s.getDerivedStateFromProps == "function") {
          var T = on(s) || "Unknown";
          Zs[T] || (i("%s: Function components do not support getDerivedStateFromProps.", T), Zs[T] = !0);
        }
        if (typeof s.contextType == "object" && s.contextType !== null) {
          var _ = on(s) || "Unknown";
          qs[_] || (i("%s: Function components do not support contextType.", _), qs[_] = !0);
        }
      }
    }
    function xu(s, c) {
      if (s && s.defaultProps) {
        var T = dr({}, c), _ = s.defaultProps;
        for (var z in _)
          T[z] === void 0 && (T[z] = _[z]);
        return T;
      }
      return c;
    }
    function Id(s, c, T, _, z) {
      Wi(c, T.render);
      var te = Ys(s, c, T.render, _, z), fe = su();
      if (fe) {
        var Ae = c.treeContext, Oe = 1, Qe = 0;
        c.treeContext = Bs(Ae, Oe, Qe);
        try {
          fr(s, c, te);
        } finally {
          c.treeContext = Ae;
        }
      } else
        fr(s, c, te);
      wr(c);
    }
    function Bd(s, c, T, _, z) {
      var te = T.type, fe = xu(te, _);
      nl(s, c, te, fe, z);
    }
    function tl(s, c, T, _) {
      T._context === void 0 ? T !== T.Consumer && (el || (el = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : T = T._context;
      var z = _.children;
      typeof z != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var te = $i(T), fe = z(te);
      fr(s, c, fe);
    }
    function zd(s, c, T, _) {
      var z = T._context, te = _.value, fe = _.children, Ae;
      Ae = c.context, c.context = xa(z, te), fr(s, c, fe), c.context = Ms(z), Ae !== c.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function hr(s, c, T, _, z) {
      Sr(c, "Lazy");
      var te = T._payload, fe = T._init, Ae = fe(te), Oe = xu(Ae, _);
      nl(s, c, Ae, Oe, z), wr(c);
    }
    function nl(s, c, T, _, z) {
      if (typeof T == "function")
        if (Od(T)) {
          gu(s, c, T, _);
          return;
        } else {
          Fd(s, c, T, _);
          return;
        }
      if (typeof T == "string") {
        yu(s, c, T, _);
        return;
      }
      switch (T) {
        case ld:
        case Ul:
        case lo:
        case uo:
        case so: {
          fr(s, c, _.children);
          return;
        }
        case bs: {
          Sr(c, "SuspenseList"), fr(s, c, _.children), wr(c);
          return;
        }
        case sd:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Mi: {
          mu(s, c, _);
          return;
        }
      }
      if (typeof T == "object" && T !== null)
        switch (T.$$typeof) {
          case ha: {
            Id(s, c, T, _, z);
            return;
          }
          case xs: {
            Bd(s, c, T, _, z);
            return;
          }
          case ca: {
            zd(s, c, T, _);
            return;
          }
          case da: {
            tl(s, c, T, _);
            return;
          }
          case co: {
            hr(s, c, T, _);
            return;
          }
        }
      var te = "";
      throw (T === void 0 || typeof T == "object" && T !== null && Object.keys(T).length === 0) && (te += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (T == null ? T : typeof T) + "." + te));
    }
    function Su(s, c) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      s[Symbol.toStringTag] === "Generator" && (vu || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), vu = !0), s.entries === c && (bu || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), bu = !0);
    }
    function fr(s, c, T) {
      try {
        return rl(s, c, T);
      } catch (_) {
        throw typeof _ == "object" && _ !== null && typeof _.then == "function" || (ri = ri !== null ? ri : Ks()), _;
      }
    }
    function rl(s, c, T) {
      if (c.node = T, typeof T == "object" && T !== null) {
        switch (T.$$typeof) {
          case Kl: {
            var _ = T, z = _.type, te = _.props, fe = _.ref;
            nl(s, c, z, te, fe);
            return;
          }
          case vs:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case co: {
            var Ae = T, Oe = Ae._payload, Qe = Ae._init, it;
            try {
              it = Qe(Oe);
            } catch (jo) {
              throw typeof jo == "object" && jo !== null && typeof jo.then == "function" && Sr(c, "Lazy"), jo;
            }
            fr(s, c, it);
            return;
          }
        }
        if (St(T)) {
          wu(s, c, T);
          return;
        }
        var xt = cn(T);
        if (xt) {
          Su(T, xt);
          var sn = xt.call(T);
          if (sn) {
            var zn = sn.next();
            if (!zn.done) {
              var kr = [];
              do
                kr.push(zn.value), zn = sn.next();
              while (!zn.done);
              wu(s, c, kr);
              return;
            }
            return;
          }
        }
        var Lu = Object.prototype.toString.call(T);
        throw new Error("Objects are not valid as a React child (found: " + (Lu === "[object Object]" ? "object with keys {" + Object.keys(T).join(", ") + "}" : Lu) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof T == "string") {
        var Eu = c.blockedSegment;
        Eu.lastPushedText = Vl(c.blockedSegment.chunks, T, s.responseState, Eu.lastPushedText);
        return;
      }
      if (typeof T == "number") {
        var _u = c.blockedSegment;
        _u.lastPushedText = Vl(c.blockedSegment.chunks, "" + T, s.responseState, _u.lastPushedText);
        return;
      }
      typeof T == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function wu(s, c, T) {
      for (var _ = T.length, z = 0; z < _; z++) {
        var te = c.treeContext;
        c.treeContext = Bs(te, _, z);
        try {
          zo(s, c, T[z]);
        } finally {
          c.treeContext = te;
        }
      }
    }
    function $d(s, c, T) {
      var _ = c.blockedSegment, z = _.chunks.length, te = ni(
        s,
        z,
        null,
        _.formatContext,
        // Adopt the parent segment's leading text embed
        _.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      _.children.push(te), _.lastPushedText = !1;
      var fe = La(s, c.node, c.blockedBoundary, te, c.abortSet, c.legacyContext, c.context, c.treeContext);
      c.componentStack !== null && (fe.componentStack = c.componentStack.parent);
      var Ae = fe.ping;
      T.then(Ae, Ae);
    }
    function zo(s, c, T) {
      var _ = c.blockedSegment.formatContext, z = c.legacyContext, te = c.context, fe = null;
      fe = c.componentStack;
      try {
        return fr(s, c, T);
      } catch (Ae) {
        if (ka(), typeof Ae == "object" && Ae !== null && typeof Ae.then == "function") {
          $d(s, c, Ae), c.blockedSegment.formatContext = _, c.legacyContext = z, c.context = te, go(te), c.componentStack = fe;
          return;
        } else
          throw c.blockedSegment.formatContext = _, c.legacyContext = z, c.context = te, go(te), c.componentStack = fe, Ae;
      }
    }
    function $o(s, c, T, _) {
      var z = Ea(s, _);
      if (c === null ? Bo(s, _) : (c.pendingTasks--, c.forceClientRender || (c.forceClientRender = !0, c.errorDigest = z, Gs(c, _), c.parentFlushed && s.clientRenderedBoundaries.push(c))), s.allPendingTasks--, s.allPendingTasks === 0) {
        var te = s.onAllReady;
        te();
      }
    }
    function ku(s) {
      var c = this, T = s.blockedBoundary, _ = s.blockedSegment;
      _.status = Ws, Ra(c, T, _);
    }
    function Tu(s, c, T) {
      var _ = s.blockedBoundary, z = s.blockedSegment;
      if (z.status = Ws, _ === null)
        c.allPendingTasks--, c.status !== Dr && (c.status = Dr, c.destination !== null && g(c.destination));
      else {
        if (_.pendingTasks--, !_.forceClientRender) {
          _.forceClientRender = !0;
          var te = T === void 0 ? new Error("The render was aborted by the server without a reason.") : T;
          _.errorDigest = c.onError(te);
          {
            var fe = "The server did not finish this Suspense boundary: ";
            te && typeof te.message == "string" ? te = fe + te.message : te = fe + String(te);
            var Ae = Or;
            Or = s;
            try {
              Gs(_, te);
            } finally {
              Or = Ae;
            }
          }
          _.parentFlushed && c.clientRenderedBoundaries.push(_);
        }
        if (_.fallbackAbortableTasks.forEach(function(Qe) {
          return Tu(Qe, c, T);
        }), _.fallbackAbortableTasks.clear(), c.allPendingTasks--, c.allPendingTasks === 0) {
          var Oe = c.onAllReady;
          Oe();
        }
      }
    }
    function Na(s, c) {
      if (c.chunks.length === 0 && c.children.length === 1 && c.children[0].boundary === null) {
        var T = c.children[0];
        T.id = c.id, T.parentFlushed = !0, T.status === bi && Na(s, T);
      } else {
        var _ = s.completedSegments;
        _.push(c);
      }
    }
    function Ra(s, c, T) {
      if (c === null) {
        if (T.parentFlushed) {
          if (s.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          s.completedRootSegment = T;
        }
        if (s.pendingRootTasks--, s.pendingRootTasks === 0) {
          s.onShellError = Aa;
          var _ = s.onShellReady;
          _();
        }
      } else if (c.pendingTasks--, !c.forceClientRender) {
        if (c.pendingTasks === 0)
          T.parentFlushed && T.status === bi && Na(c, T), c.parentFlushed && s.completedBoundaries.push(c), c.fallbackAbortableTasks.forEach(ku, s), c.fallbackAbortableTasks.clear();
        else if (T.parentFlushed && T.status === bi) {
          Na(c, T);
          var z = c.completedSegments;
          z.length === 1 && c.parentFlushed && s.partialBoundaries.push(c);
        }
      }
      if (s.allPendingTasks--, s.allPendingTasks === 0) {
        var te = s.onAllReady;
        te();
      }
    }
    function Ho(s, c) {
      var T = c.blockedSegment;
      if (T.status === Mo) {
        go(c.context);
        var _ = null;
        _ = Or, Or = c;
        try {
          fr(s, c, c.node), Wl(T.chunks, s.responseState, T.lastPushedText, T.textEmbedded), c.abortSet.delete(c), T.status = bi, Ra(s, c.blockedBoundary, T);
        } catch (te) {
          if (ka(), typeof te == "object" && te !== null && typeof te.then == "function") {
            var z = c.ping;
            te.then(z, z);
          } else
            c.abortSet.delete(c), T.status = xi, $o(s, c.blockedBoundary, T, te);
        } finally {
          Or = _;
        }
      }
    }
    function Cu(s) {
      if (s.status !== Dr) {
        var c = cd(), T = ti.current;
        ti.current = hu;
        var _;
        _ = Fo.getCurrentStack, Fo.getCurrentStack = Ks;
        var z = Ca;
        Oo(s.responseState);
        try {
          var te = s.pingedTasks, fe;
          for (fe = 0; fe < te.length; fe++) {
            var Ae = te[fe];
            Ho(s, Ae);
          }
          te.splice(0, fe), s.destination !== null && Wo(s, s.destination);
        } catch (Oe) {
          Ea(s, Oe), Bo(s, Oe);
        } finally {
          Oo(z), ti.current = T, Fo.getCurrentStack = _, T === hu && go(c);
        }
      }
    }
    function Da(s, c, T) {
      switch (T.parentFlushed = !0, T.status) {
        case Mo: {
          var _ = T.id = s.nextSegmentId++;
          return T.lastPushedText = !1, T.textEmbedded = !1, Ya(c, s.responseState, _);
        }
        case bi: {
          T.status = fu;
          for (var z = !0, te = T.chunks, fe = 0, Ae = T.children, Oe = 0; Oe < Ae.length; Oe++) {
            for (var Qe = Ae[Oe]; fe < Qe.index; fe++)
              d(c, te[fe]);
            z = Oa(s, c, Qe);
          }
          for (; fe < te.length - 1; fe++)
            d(c, te[fe]);
          return fe < te.length && (z = p(c, te[fe])), z;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Oa(s, c, T) {
      var _ = T.boundary;
      if (_ === null)
        return Da(s, c, T);
      if (_.parentFlushed = !0, _.forceClientRender)
        return br(c, s.responseState, _.errorDigest, _.errorMessage, _.errorComponentStack), Da(s, c, T), jl(c, s.responseState);
      if (_.pendingTasks > 0) {
        _.rootSegmentID = s.nextSegmentId++, _.completedSegments.length > 0 && s.partialBoundaries.push(_);
        var z = _.id = wn(s.responseState);
        return Jr(c, s.responseState, z), Da(s, c, T), sa(c, s.responseState);
      } else {
        if (_.byteSize > s.progressiveChunkSize)
          return _.rootSegmentID = s.nextSegmentId++, s.completedBoundaries.push(_), Jr(c, s.responseState, _.id), Da(s, c, T), sa(c, s.responseState);
        gs(c, s.responseState);
        var te = _.completedSegments;
        if (te.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var fe = te[0];
        return Oa(s, c, fe), od(c, s.responseState);
      }
    }
    function Hd(s, c, T) {
      return rd(c, s.responseState, T.id, T.errorDigest, T.errorMessage, T.errorComponentStack);
    }
    function il(s, c, T) {
      return Te(c, s.responseState, T.formatContext, T.id), Oa(s, c, T), Re(c, T.formatContext);
    }
    function Vo(s, c, T) {
      for (var _ = T.completedSegments, z = 0; z < _.length; z++) {
        var te = _[z];
        Au(s, c, T, te);
      }
      return _.length = 0, Qc(c, s.responseState, T.id, T.rootSegmentID);
    }
    function Vd(s, c, T) {
      for (var _ = T.completedSegments, z = 0; z < _.length; z++) {
        var te = _[z];
        if (!Au(s, c, T, te))
          return z++, _.splice(0, z), !1;
      }
      return _.splice(0, z), !0;
    }
    function Au(s, c, T, _) {
      if (_.status === fu)
        return !0;
      var z = _.id;
      if (z === -1) {
        var te = _.id = T.rootSegmentID;
        if (te === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return il(s, c, _);
      } else
        return il(s, c, _), cr(c, s.responseState, z);
    }
    function Wo(s, c) {
      try {
        var T = s.completedRootSegment;
        T !== null && s.pendingRootTasks === 0 && (Oa(s, c, T), s.completedRootSegment = null, ra(c, s.responseState));
        var _ = s.clientRenderedBoundaries, z;
        for (z = 0; z < _.length; z++) {
          var te = _[z];
          if (!Hd(s, c, te)) {
            s.destination = null, z++, _.splice(0, z);
            return;
          }
        }
        _.splice(0, z);
        var fe = s.completedBoundaries;
        for (z = 0; z < fe.length; z++) {
          var Ae = fe[z];
          if (!Vo(s, c, Ae)) {
            s.destination = null, z++, fe.splice(0, z);
            return;
          }
        }
        fe.splice(0, z);
        var Oe = s.partialBoundaries;
        for (z = 0; z < Oe.length; z++) {
          var Qe = Oe[z];
          if (!Vd(s, c, Qe)) {
            s.destination = null, z++, Oe.splice(0, z);
            return;
          }
        }
        Oe.splice(0, z);
        var it = s.completedBoundaries;
        for (z = 0; z < it.length; z++) {
          var xt = it[z];
          if (!Vo(s, c, xt)) {
            s.destination = null, z++, it.splice(0, z);
            return;
          }
        }
        it.splice(0, z);
      } finally {
        s.allPendingTasks === 0 && s.pingedTasks.length === 0 && s.clientRenderedBoundaries.length === 0 && s.completedBoundaries.length === 0 && (s.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), g(c));
      }
    }
    function Wd(s) {
      h(function() {
        return Cu(s);
      });
    }
    function l(s, c) {
      if (s.status === pu) {
        s.status = Dr, k(c, s.fatalError);
        return;
      }
      if (s.status !== Dr && s.destination === null) {
        s.destination = c;
        try {
          Wo(s, c);
        } catch (T) {
          Ea(s, T), Bo(s, T);
        }
      }
    }
    function f(s, c) {
      try {
        var T = s.abortableTasks;
        T.forEach(function(_) {
          return Tu(_, s, c);
        }), T.clear(), s.destination !== null && Wo(s, s.destination);
      } catch (_) {
        Ea(s, _), Bo(s, _);
      }
    }
    function E() {
    }
    function F(s, c, T, _) {
      var z = !1, te = null, fe = "", Ae = {
        push: function(xt) {
          return xt !== null && (fe += xt), !0;
        },
        destroy: function(xt) {
          z = !0, te = xt;
        }
      }, Oe = !1;
      function Qe() {
        Oe = !0;
      }
      var it = js(s, ad(T, c ? c.identifierPrefix : void 0), ys(), 1 / 0, E, void 0, Qe, void 0, void 0);
      if (Wd(it), f(it, _), l(it, Ae), z)
        throw te;
      if (!Oe)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return fe;
    }
    function W(s, c) {
      return F(s, c, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function ue(s, c) {
      return F(s, c, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function ve() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Ee() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Ia.renderToNodeStream = ve, Ia.renderToStaticMarkup = ue, Ia.renderToStaticNodeStream = Ee, Ia.renderToString = W, Ia.version = t;
  }()), Ia;
}
var Wu = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dm;
function KS() {
  return dm || (dm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = he, t = "18.3.1", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(l) {
      {
        for (var f = arguments.length, E = new Array(f > 1 ? f - 1 : 0), F = 1; F < f; F++)
          E[F - 1] = arguments[F];
        o("warn", l, E);
      }
    }
    function i(l) {
      {
        for (var f = arguments.length, E = new Array(f > 1 ? f - 1 : 0), F = 1; F < f; F++)
          E[F - 1] = arguments[F];
        o("error", l, E);
      }
    }
    function o(l, f, E) {
      {
        var F = n.ReactDebugCurrentFrame, W = F.getStackAddendum();
        W !== "" && (f += "%s", E = E.concat([W]));
        var ue = E.map(function(ve) {
          return String(ve);
        });
        ue.unshift("Warning: " + f), Function.prototype.apply.call(console[l], console, ue);
      }
    }
    function h(l) {
      l();
    }
    var u = 512, d = null, p = 0;
    function m(l) {
      d = new Uint8Array(u), p = 0;
    }
    function g(l, f) {
      if (f.length !== 0) {
        if (f.length > u) {
          p > 0 && (l.enqueue(new Uint8Array(d.buffer, 0, p)), d = new Uint8Array(u), p = 0), l.enqueue(f);
          return;
        }
        var E = f, F = d.length - p;
        F < E.length && (F === 0 ? l.enqueue(d) : (d.set(E.subarray(0, F), p), l.enqueue(d), E = E.subarray(F)), d = new Uint8Array(u), p = 0), d.set(E, p), p += E.length;
      }
    }
    function x(l, f) {
      return g(l, f), !0;
    }
    function A(l) {
      d && p > 0 && (l.enqueue(new Uint8Array(d.buffer, 0, p)), d = null, p = 0);
    }
    function k(l) {
      l.close();
    }
    var y = new TextEncoder();
    function v(l) {
      return y.encode(l);
    }
    function S(l) {
      return y.encode(l);
    }
    function B(l, f) {
      typeof l.error == "function" ? l.error(f) : l.close();
    }
    function R(l) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, E = f && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return E;
      }
    }
    function N(l) {
      try {
        return D(l), !1;
      } catch {
        return !0;
      }
    }
    function D(l) {
      return "" + l;
    }
    function L(l, f) {
      if (N(l))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", f, R(l)), D(l);
    }
    function q(l, f) {
      if (N(l))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", f, R(l)), D(l);
    }
    function V(l) {
      if (N(l))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", R(l)), D(l);
    }
    var ae = Object.prototype.hasOwnProperty, Y = 0, Q = 1, se = 2, ie = 3, M = 4, U = 5, re = 6, j = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", de = j + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Z = new RegExp("^[" + j + "][" + de + "]*$"), ge = {}, ne = {};
    function G(l) {
      return ae.call(ne, l) ? !0 : ae.call(ge, l) ? !1 : Z.test(l) ? (ne[l] = !0, !0) : (ge[l] = !0, i("Invalid attribute name: `%s`", l), !1);
    }
    function me(l, f, E, F) {
      if (E !== null && E.type === Y)
        return !1;
      switch (typeof f) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (F)
            return !1;
          if (E !== null)
            return !E.acceptsBooleans;
          var W = l.toLowerCase().slice(0, 5);
          return W !== "data-" && W !== "aria-";
        }
        default:
          return !1;
      }
    }
    function ye(l) {
      return ce.hasOwnProperty(l) ? ce[l] : null;
    }
    function Se(l, f, E, F, W, ue, ve) {
      this.acceptsBooleans = f === se || f === ie || f === M, this.attributeName = F, this.attributeNamespace = W, this.mustUseProperty = E, this.propertyName = l, this.type = f, this.sanitizeURL = ue, this.removeEmptyString = ve;
    }
    var ce = {}, ke = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ke.forEach(function(l) {
      ce[l] = new Se(
        l,
        Y,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
      var f = l[0], E = l[1];
      ce[f] = new Se(
        f,
        Q,
        !1,
        // mustUseProperty
        E,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
      ce[l] = new Se(
        l,
        se,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
      ce[l] = new Se(
        l,
        se,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(l) {
      ce[l] = new Se(
        l,
        ie,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ce[l] = new Se(
        l,
        ie,
        !0,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ce[l] = new Se(
        l,
        M,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ce[l] = new Se(
        l,
        re,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(l) {
      ce[l] = new Se(
        l,
        U,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Ie = /[\-\:]([a-z])/g, Le = function(l) {
      return l[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(Ie, Le);
      ce[f] = new Se(
        f,
        Q,
        !1,
        // mustUseProperty
        l,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(Ie, Le);
      ce[f] = new Se(
        f,
        Q,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(Ie, Le);
      ce[f] = new Se(
        f,
        Q,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(l) {
      ce[l] = new Se(
        l,
        Q,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Fe = "xlinkHref";
    ce[Fe] = new Se(
      "xlinkHref",
      Q,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(l) {
      ce[l] = new Se(
        l,
        Q,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Xe = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Be(l, f) {
      return l + f.charAt(0).toUpperCase() + f.substring(1);
    }
    var ot = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Xe).forEach(function(l) {
      ot.forEach(function(f) {
        Xe[Be(f, l)] = Xe[l];
      });
    });
    var gt = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function st(l, f) {
      gt[f.type] || f.onChange || f.onInput || f.readOnly || f.disabled || f.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), f.onChange || f.readOnly || f.disabled || f.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function dt(l, f) {
      if (l.indexOf("-") === -1)
        return typeof f.is == "string";
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Ye = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Je = {}, yt = new RegExp("^(aria)-[" + de + "]*$"), nt = new RegExp("^(aria)[A-Z][" + de + "]*$");
    function lt(l, f) {
      {
        if (ae.call(Je, f) && Je[f])
          return !0;
        if (nt.test(f)) {
          var E = "aria-" + f.slice(4).toLowerCase(), F = Ye.hasOwnProperty(E) ? E : null;
          if (F == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", f), Je[f] = !0, !0;
          if (f !== F)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", f, F), Je[f] = !0, !0;
        }
        if (yt.test(f)) {
          var W = f.toLowerCase(), ue = Ye.hasOwnProperty(W) ? W : null;
          if (ue == null)
            return Je[f] = !0, !1;
          if (f !== ue)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", f, ue), Je[f] = !0, !0;
        }
      }
      return !0;
    }
    function je(l, f) {
      {
        var E = [];
        for (var F in f) {
          var W = lt(l, F);
          W || E.push(F);
        }
        var ue = E.map(function(ve) {
          return "`" + ve + "`";
        }).join(", ");
        E.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ue, l) : E.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ue, l);
      }
    }
    function at(l, f) {
      dt(l, f) || je(l, f);
    }
    var ct = !1;
    function wt(l, f) {
      {
        if (l !== "input" && l !== "textarea" && l !== "select")
          return;
        f != null && f.value === null && !ct && (ct = !0, l === "select" && f.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", l) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", l));
      }
    }
    var rn = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Ne = function() {
    };
    {
      var Ct = {}, bn = /^on./, Zt = /^on[^A-Z]/, jt = new RegExp("^(aria)-[" + de + "]*$"), Qt = new RegExp("^(aria)[A-Z][" + de + "]*$");
      Ne = function(l, f, E, F) {
        if (ae.call(Ct, f) && Ct[f])
          return !0;
        var W = f.toLowerCase();
        if (W === "onfocusin" || W === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Ct[f] = !0, !0;
        if (F != null) {
          var ue = F.registrationNameDependencies, ve = F.possibleRegistrationNames;
          if (ue.hasOwnProperty(f))
            return !0;
          var Ee = ve.hasOwnProperty(W) ? ve[W] : null;
          if (Ee != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", f, Ee), Ct[f] = !0, !0;
          if (bn.test(f))
            return i("Unknown event handler property `%s`. It will be ignored.", f), Ct[f] = !0, !0;
        } else if (bn.test(f))
          return Zt.test(f) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", f), Ct[f] = !0, !0;
        if (jt.test(f) || Qt.test(f))
          return !0;
        if (W === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Ct[f] = !0, !0;
        if (W === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Ct[f] = !0, !0;
        if (W === "is" && E !== null && E !== void 0 && typeof E != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof E), Ct[f] = !0, !0;
        if (typeof E == "number" && isNaN(E))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", f), Ct[f] = !0, !0;
        var s = ye(f), c = s !== null && s.type === Y;
        if (rn.hasOwnProperty(W)) {
          var T = rn[W];
          if (T !== f)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", f, T), Ct[f] = !0, !0;
        } else if (!c && f !== W)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", f, W), Ct[f] = !0, !0;
        return typeof E == "boolean" && me(f, E, s, !1) ? (E ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', E, f, f, E, f) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', E, f, f, E, f, f, f), Ct[f] = !0, !0) : c ? !0 : me(f, E, s, !1) ? (Ct[f] = !0, !1) : ((E === "false" || E === "true") && s !== null && s.type === ie && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", E, f, E === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', f, E), Ct[f] = !0), !0);
      };
    }
    var _n = function(l, f, E) {
      {
        var F = [];
        for (var W in f) {
          var ue = Ne(l, W, f[W], E);
          ue || F.push(W);
        }
        var ve = F.map(function(Ee) {
          return "`" + Ee + "`";
        }).join(", ");
        F.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", ve, l) : F.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", ve, l);
      }
    };
    function Gt(l, f, E) {
      dt(l, f) || _n(l, f, E);
    }
    var fn = function() {
    };
    {
      var Nt = /^(?:webkit|moz|o)[A-Z]/, Yt = /^-ms-/, tn = /-(.)/g, zt = /;\s*$/, It = {}, $t = {}, Ze = !1, mt = !1, Kt = function(l) {
        return l.replace(tn, function(f, E) {
          return E.toUpperCase();
        });
      }, Pe = function(l) {
        It.hasOwnProperty(l) && It[l] || (It[l] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          l,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Kt(l.replace(Yt, "ms-"))
        ));
      }, _e = function(l) {
        It.hasOwnProperty(l) && It[l] || (It[l] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", l, l.charAt(0).toUpperCase() + l.slice(1)));
      }, xe = function(l, f) {
        $t.hasOwnProperty(f) && $t[f] || ($t[f] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, l, f.replace(zt, "")));
      }, ut = function(l, f) {
        Ze || (Ze = !0, i("`NaN` is an invalid value for the `%s` css style property.", l));
      }, et = function(l, f) {
        mt || (mt = !0, i("`Infinity` is an invalid value for the `%s` css style property.", l));
      };
      fn = function(l, f) {
        l.indexOf("-") > -1 ? Pe(l) : Nt.test(l) ? _e(l) : zt.test(f) && xe(l, f), typeof f == "number" && (isNaN(f) ? ut(l, f) : isFinite(f) || et(l, f));
      };
    }
    var rt = fn, At = /["'&<>]/;
    function Xt(l) {
      V(l);
      var f = "" + l, E = At.exec(f);
      if (!E)
        return f;
      var F, W = "", ue, ve = 0;
      for (ue = E.index; ue < f.length; ue++) {
        switch (f.charCodeAt(ue)) {
          case 34:
            F = "&quot;";
            break;
          case 38:
            F = "&amp;";
            break;
          case 39:
            F = "&#x27;";
            break;
          case 60:
            F = "&lt;";
            break;
          case 62:
            F = "&gt;";
            break;
          default:
            continue;
        }
        ve !== ue && (W += f.substring(ve, ue)), ve = ue + 1, W += F;
      }
      return ve !== ue ? W + f.substring(ve, ue) : W;
    }
    function tt(l) {
      return typeof l == "boolean" || typeof l == "number" ? "" + l : Xt(l);
    }
    var _t = /([A-Z])/g, yn = /^ms-/;
    function vt(l) {
      return l.replace(_t, "-$1").toLowerCase().replace(yn, "-ms-");
    }
    var St = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, gn = !1;
    function xn(l) {
      !gn && St.test(l) && (gn = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(l)));
    }
    var On = Array.isArray;
    function Fn(l) {
      return On(l);
    }
    var Pn = S("<script>"), ir = S("<\/script>"), Nn = S('<script src="'), Sn = S('<script type="module" src="'), Dt = S('" async=""><\/script>');
    function nn(l) {
      return V(l), ("" + l).replace(dn, Hn);
    }
    var dn = /(<\/|<)(s)(cript)/gi, Hn = function(l, f, E, F) {
      return "" + f + (E === "s" ? "\\u0073" : "\\u0053") + F;
    };
    function Jt(l, f, E, F, W) {
      var ue = l === void 0 ? "" : l, ve = f === void 0 ? Pn : S('<script nonce="' + tt(f) + '">'), Ee = [];
      if (E !== void 0 && Ee.push(ve, v(nn(E)), ir), F !== void 0)
        for (var s = 0; s < F.length; s++)
          Ee.push(Nn, v(tt(F[s])), Dt);
      if (W !== void 0)
        for (var c = 0; c < W.length; c++)
          Ee.push(Sn, v(tt(W[c])), Dt);
      return {
        bootstrapChunks: Ee,
        startInlineScript: ve,
        placeholderPrefix: S(ue + "P:"),
        segmentPrefix: S(ue + "S:"),
        boundaryPrefix: ue + "B:",
        idPrefix: ue,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var qt = 0, Ot = 1, pn = 2, an = 3, un = 4, ar = 5, Rn = 6, wn = 7;
    function mn(l, f) {
      return {
        insertionMode: l,
        selectedValue: f
      };
    }
    function Mn(l) {
      var f = l === "http://www.w3.org/2000/svg" ? pn : l === "http://www.w3.org/1998/Math/MathML" ? an : qt;
      return mn(f, null);
    }
    function Wn(l, f, E) {
      switch (f) {
        case "select":
          return mn(Ot, E.value != null ? E.value : E.defaultValue);
        case "svg":
          return mn(pn, null);
        case "math":
          return mn(an, null);
        case "foreignObject":
          return mn(Ot, null);
        case "table":
          return mn(un, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return mn(ar, null);
        case "colgroup":
          return mn(wn, null);
        case "tr":
          return mn(Rn, null);
      }
      return l.insertionMode >= un || l.insertionMode === qt ? mn(Ot, null) : l;
    }
    var gr = null;
    function vr(l) {
      var f = l.nextSuspenseID++;
      return S(l.boundaryPrefix + f.toString(16));
    }
    function Xn(l, f, E) {
      var F = l.idPrefix, W = ":" + F + "R" + f;
      return E > 0 && (W += "H" + E.toString(32)), W + ":";
    }
    function Vn(l) {
      return tt(l);
    }
    var or = S("<!-- -->");
    function qn(l, f, E, F) {
      return f === "" ? F : (F && l.push(or), l.push(v(Vn(f))), !0);
    }
    function Zn(l, f, E, F) {
      E && F && l.push(or);
    }
    var b = /* @__PURE__ */ new Map();
    function C(l) {
      var f = b.get(l);
      if (f !== void 0)
        return f;
      var E = S(tt(vt(l)));
      return b.set(l, E), E;
    }
    var I = S(' style="'), H = S(":"), oe = S(";");
    function pe(l, f, E) {
      if (typeof E != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var F = !0;
      for (var W in E)
        if (ae.call(E, W)) {
          var ue = E[W];
          if (!(ue == null || typeof ue == "boolean" || ue === "")) {
            var ve = void 0, Ee = void 0, s = W.indexOf("--") === 0;
            s ? (ve = v(tt(W)), q(ue, W), Ee = v(tt(("" + ue).trim()))) : (rt(W, ue), ve = C(W), typeof ue == "number" ? ue !== 0 && !ae.call(Xe, W) ? Ee = v(ue + "px") : Ee = v("" + ue) : (q(ue, W), Ee = v(tt(("" + ue).trim())))), F ? (F = !1, l.push(I, ve, H, Ee)) : l.push(oe, ve, H, Ee);
          }
        }
      F || l.push(X);
    }
    var we = S(" "), K = S('="'), X = S('"'), le = S('=""');
    function be(l, f, E, F) {
      switch (E) {
        case "style": {
          pe(l, f, F);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(E.length > 2 && (E[0] === "o" || E[0] === "O") && (E[1] === "n" || E[1] === "N"))
      ) {
        var W = ye(E);
        if (W !== null) {
          switch (typeof F) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!W.acceptsBooleans)
                return;
          }
          var ue = W.attributeName, ve = v(ue);
          switch (W.type) {
            case ie:
              F && l.push(we, ve, le);
              return;
            case M:
              F === !0 ? l.push(we, ve, le) : F === !1 || l.push(we, ve, K, v(tt(F)), X);
              return;
            case U:
              isNaN(F) || l.push(we, ve, K, v(tt(F)), X);
              break;
            case re:
              !isNaN(F) && F >= 1 && l.push(we, ve, K, v(tt(F)), X);
              break;
            default:
              W.sanitizeURL && (L(F, ue), F = "" + F, xn(F)), l.push(we, ve, K, v(tt(F)), X);
          }
        } else if (G(E)) {
          switch (typeof F) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Ee = E.toLowerCase().slice(0, 5);
              if (Ee !== "data-" && Ee !== "aria-")
                return;
            }
          }
          l.push(we, v(E), K, v(tt(F)), X);
        }
      }
    }
    var Ue = S(">"), Ft = S("/>");
    function Ht(l, f, E) {
      if (f != null) {
        if (E != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof f != "object" || !("__html" in f))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var F = f.__html;
        F != null && (V(F), l.push(v("" + F)));
      }
    }
    var Rt = !1, Vt = !1, kn = !1, jn = !1, Qn = !1, sr = !1, Kn = !1;
    function Ar(l, f) {
      {
        var E = l[f];
        if (E != null) {
          var F = Fn(E);
          l.multiple && !F ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", f) : !l.multiple && F && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", f);
        }
      }
    }
    function na(l, f, E) {
      st("select", f), Ar(f, "value"), Ar(f, "defaultValue"), f.value !== void 0 && f.defaultValue !== void 0 && !kn && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), kn = !0), l.push(lr("select"));
      var F = null, W = null;
      for (var ue in f)
        if (ae.call(f, ue)) {
          var ve = f[ue];
          if (ve == null)
            continue;
          switch (ue) {
            case "children":
              F = ve;
              break;
            case "dangerouslySetInnerHTML":
              W = ve;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              be(l, E, ue, ve);
              break;
          }
        }
      return l.push(Ue), Ht(l, W, F), F;
    }
    function Ti(l) {
      var f = "";
      return e.Children.forEach(l, function(E) {
        E != null && (f += E, !Qn && typeof E != "string" && typeof E != "number" && (Qn = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), f;
    }
    var kt = S(' selected=""');
    function Dn(l, f, E, F) {
      var W = F.selectedValue;
      l.push(lr("option"));
      var ue = null, ve = null, Ee = null, s = null;
      for (var c in f)
        if (ae.call(f, c)) {
          var T = f[c];
          if (T == null)
            continue;
          switch (c) {
            case "children":
              ue = T;
              break;
            case "selected":
              Ee = T, Kn || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Kn = !0);
              break;
            case "dangerouslySetInnerHTML":
              s = T;
              break;
            case "value":
              ve = T;
            default:
              be(l, E, c, T);
              break;
          }
        }
      if (W != null) {
        var _;
        if (ve !== null ? (L(ve, "value"), _ = "" + ve) : (s !== null && (sr || (sr = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), _ = Ti(ue)), Fn(W))
          for (var z = 0; z < W.length; z++) {
            L(W[z], "value");
            var te = "" + W[z];
            if (te === _) {
              l.push(kt);
              break;
            }
          }
        else
          L(W, "select.value"), "" + W === _ && l.push(kt);
      } else
        Ee && l.push(kt);
      return l.push(Ue), Ht(l, s, ue), ue;
    }
    function Br(l, f, E) {
      st("input", f), f.checked !== void 0 && f.defaultChecked !== void 0 && !Vt && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), Vt = !0), f.value !== void 0 && f.defaultValue !== void 0 && !Rt && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), Rt = !0), l.push(lr("input"));
      var F = null, W = null, ue = null, ve = null;
      for (var Ee in f)
        if (ae.call(f, Ee)) {
          var s = f[Ee];
          if (s == null)
            continue;
          switch (Ee) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              ve = s;
              break;
            case "defaultValue":
              W = s;
              break;
            case "checked":
              ue = s;
              break;
            case "value":
              F = s;
              break;
            default:
              be(l, E, Ee, s);
              break;
          }
        }
      return ue !== null ? be(l, E, "checked", ue) : ve !== null && be(l, E, "checked", ve), F !== null ? be(l, E, "value", F) : W !== null && be(l, E, "value", W), l.push(Ft), null;
    }
    function Un(l, f, E) {
      st("textarea", f), f.value !== void 0 && f.defaultValue !== void 0 && !jn && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), jn = !0), l.push(lr("textarea"));
      var F = null, W = null, ue = null;
      for (var ve in f)
        if (ae.call(f, ve)) {
          var Ee = f[ve];
          if (Ee == null)
            continue;
          switch (ve) {
            case "children":
              ue = Ee;
              break;
            case "value":
              F = Ee;
              break;
            case "defaultValue":
              W = Ee;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              be(l, E, ve, Ee);
              break;
          }
        }
      if (F === null && W !== null && (F = W), l.push(Ue), ue != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), F != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (Fn(ue)) {
          if (ue.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          V(ue[0]), F = "" + ue[0];
        }
        V(ue), F = "" + ue;
      }
      return typeof F == "string" && F[0] === `
` && l.push($r), F !== null && (L(F, "value"), l.push(v(Vn("" + F)))), null;
    }
    function zr(l, f, E, F) {
      l.push(lr(E));
      for (var W in f)
        if (ae.call(f, W)) {
          var ue = f[W];
          if (ue == null)
            continue;
          switch (W) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(E + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              be(l, F, W, ue);
              break;
          }
        }
      return l.push(Ft), null;
    }
    function Zr(l, f, E) {
      l.push(lr("menuitem"));
      for (var F in f)
        if (ae.call(f, F)) {
          var W = f[F];
          if (W == null)
            continue;
          switch (F) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              be(l, E, F, W);
              break;
          }
        }
      return l.push(Ue), null;
    }
    function Wt(l, f, E) {
      l.push(lr("title"));
      var F = null;
      for (var W in f)
        if (ae.call(f, W)) {
          var ue = f[W];
          if (ue == null)
            continue;
          switch (W) {
            case "children":
              F = ue;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              be(l, E, W, ue);
              break;
          }
        }
      l.push(Ue);
      {
        var ve = Array.isArray(F) && F.length < 2 ? F[0] || null : F;
        Array.isArray(F) && F.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : ve != null && ve.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : ve != null && typeof ve != "string" && typeof ve != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return F;
    }
    function Jn(l, f, E, F) {
      l.push(lr(E));
      var W = null, ue = null;
      for (var ve in f)
        if (ae.call(f, ve)) {
          var Ee = f[ve];
          if (Ee == null)
            continue;
          switch (ve) {
            case "children":
              W = Ee;
              break;
            case "dangerouslySetInnerHTML":
              ue = Ee;
              break;
            default:
              be(l, F, ve, Ee);
              break;
          }
        }
      return l.push(Ue), Ht(l, ue, W), typeof W == "string" ? (l.push(v(Vn(W))), null) : W;
    }
    function In(l, f, E, F) {
      l.push(lr(E));
      var W = null, ue = null;
      for (var ve in f)
        if (ae.call(f, ve)) {
          var Ee = f[ve];
          if (Ee == null)
            continue;
          switch (ve) {
            case "children":
              W = Ee;
              break;
            case "dangerouslySetInnerHTML":
              ue = Ee;
              break;
            case "style":
              pe(l, F, Ee);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              G(ve) && typeof Ee != "function" && typeof Ee != "symbol" && l.push(we, v(ve), K, v(tt(Ee)), X);
              break;
          }
        }
      return l.push(Ue), Ht(l, ue, W), W;
    }
    var $r = S(`
`);
    function _r(l, f, E, F) {
      l.push(lr(E));
      var W = null, ue = null;
      for (var ve in f)
        if (ae.call(f, ve)) {
          var Ee = f[ve];
          if (Ee == null)
            continue;
          switch (ve) {
            case "children":
              W = Ee;
              break;
            case "dangerouslySetInnerHTML":
              ue = Ee;
              break;
            default:
              be(l, F, ve, Ee);
              break;
          }
        }
      if (l.push(Ue), ue != null) {
        if (W != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof ue != "object" || !("__html" in ue))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var s = ue.__html;
        s != null && (typeof s == "string" && s.length > 0 && s[0] === `
` ? l.push($r, v(s)) : (V(s), l.push(v("" + s))));
      }
      return typeof W == "string" && W[0] === `
` && l.push($r), W;
    }
    var Ci = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Pr = /* @__PURE__ */ new Map();
    function lr(l) {
      var f = Pr.get(l);
      if (f === void 0) {
        if (!Ci.test(l))
          throw new Error("Invalid tag: " + l);
        f = S("<" + l), Pr.set(l, f);
      }
      return f;
    }
    var ra = S("<!DOCTYPE html>");
    function ia(l, f, E, F, W) {
      switch (at(f, E), wt(f, E), Gt(f, E, null), !E.suppressContentEditableWarning && E.contentEditable && E.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), W.insertionMode !== pn && W.insertionMode !== an && f.indexOf("-") === -1 && typeof E.is != "string" && f.toLowerCase() !== f && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", f), f) {
        case "select":
          return na(l, E, F);
        case "option":
          return Dn(l, E, F, W);
        case "textarea":
          return Un(l, E, F);
        case "input":
          return Br(l, E, F);
        case "menuitem":
          return Zr(l, E, F);
        case "title":
          return Wt(l, E, F);
        case "listing":
        case "pre":
          return _r(l, E, f, F);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return zr(l, E, f, F);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Jn(l, E, f, F);
        case "html":
          return W.insertionMode === qt && l.push(ra), Jn(l, E, f, F);
        default:
          return f.indexOf("-") === -1 && typeof E.is != "string" ? Jn(l, E, f, F) : In(l, E, f, F);
      }
    }
    var Ga = S("</"), Ya = S(">");
    function Xa(l, f, E) {
      switch (f) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          l.push(Ga, v(f), Ya);
      }
    }
    function cs(l, f) {
      for (var E = f.bootstrapChunks, F = 0; F < E.length - 1; F++)
        g(l, E[F]);
      return F < E.length ? x(l, E[F]) : !0;
    }
    var ds = S('<template id="'), Ai = S('"></template>');
    function Li(l, f, E) {
      g(l, ds), g(l, f.placeholderPrefix);
      var F = v(E.toString(16));
      return g(l, F), x(l, Ai);
    }
    var Ei = S("<!--$-->"), ui = S('<!--$?--><template id="'), hs = S('"></template>'), ci = S("<!--$!-->"), aa = S("<!--/$-->"), oa = S("<template"), Qr = S('"'), Jr = S(' data-dgst="'), _i = S(' data-msg="'), qa = S(' data-stck="'), sa = S("></template>");
    function Za(l, f) {
      return x(l, Ei);
    }
    function Pi(l, f, E) {
      if (g(l, ui), E === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(l, E), x(l, hs);
    }
    function Gn(l, f, E, F, W) {
      var ue;
      return ue = x(l, ci), g(l, oa), E && (g(l, Jr), g(l, v(tt(E))), g(l, Qr)), F && (g(l, _i), g(l, v(tt(F))), g(l, Qr)), W && (g(l, qa), g(l, v(tt(W))), g(l, Qr)), ue = x(l, sa), ue;
    }
    function Qa(l, f) {
      return x(l, aa);
    }
    function Ni(l, f) {
      return x(l, aa);
    }
    function fs(l, f) {
      return x(l, aa);
    }
    var Ja = S('<div hidden id="'), Ri = S('">'), eo = S("</div>"), to = S('<svg aria-hidden="true" style="display:none" id="'), Di = S('">'), Oi = S("</svg>"), no = S('<math aria-hidden="true" style="display:none" id="'), ro = S('">'), io = S("</math>"), la = S('<table hidden id="'), ao = S('">'), w = S("</table>"), P = S('<table hidden><tbody id="'), $ = S('">'), J = S("</tbody></table>"), Ce = S('<table hidden><tr id="'), Te = S('">'), Re = S("</tr></table>"), He = S('<table hidden><colgroup id="'), bt = S('">'), Lt = S("</colgroup></table>");
    function Tt(l, f, E, F) {
      switch (E.insertionMode) {
        case qt:
        case Ot:
          return g(l, Ja), g(l, f.segmentPrefix), g(l, v(F.toString(16))), x(l, Ri);
        case pn:
          return g(l, to), g(l, f.segmentPrefix), g(l, v(F.toString(16))), x(l, Di);
        case an:
          return g(l, no), g(l, f.segmentPrefix), g(l, v(F.toString(16))), x(l, ro);
        case un:
          return g(l, la), g(l, f.segmentPrefix), g(l, v(F.toString(16))), x(l, ao);
        case ar:
          return g(l, P), g(l, f.segmentPrefix), g(l, v(F.toString(16))), x(l, $);
        case Rn:
          return g(l, Ce), g(l, f.segmentPrefix), g(l, v(F.toString(16))), x(l, Te);
        case wn:
          return g(l, He), g(l, f.segmentPrefix), g(l, v(F.toString(16))), x(l, bt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function en(l, f) {
      switch (f.insertionMode) {
        case qt:
        case Ot:
          return x(l, eo);
        case pn:
          return x(l, Oi);
        case an:
          return x(l, io);
        case un:
          return x(l, w);
        case ar:
          return x(l, J);
        case Rn:
          return x(l, Re);
        case wn:
          return x(l, Lt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Yn = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", ur = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', cr = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Fi = S(Yn + ';$RS("'), oo = S('$RS("'), ua = S('","'), Zc = S('")<\/script>');
    function Qc(l, f, E) {
      g(l, f.startInlineScript), f.sentCompleteSegmentFunction ? g(l, oo) : (f.sentCompleteSegmentFunction = !0, g(l, Fi)), g(l, f.segmentPrefix);
      var F = v(E.toString(16));
      return g(l, F), g(l, ua), g(l, f.placeholderPrefix), g(l, F), x(l, Zc);
    }
    var Jc = S(ur + ';$RC("'), ed = S('$RC("'), td = S('","'), nd = S('")<\/script>');
    function ps(l, f, E, F) {
      if (g(l, f.startInlineScript), f.sentCompleteBoundaryFunction ? g(l, ed) : (f.sentCompleteBoundaryFunction = !0, g(l, Jc)), E === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var W = v(F.toString(16));
      return g(l, E), g(l, td), g(l, f.segmentPrefix), g(l, W), x(l, nd);
    }
    var rd = S(cr + ';$RX("'), id = S('$RX("'), ms = S('"'), ad = S(")<\/script>"), ys = S(",");
    function Vl(l, f, E, F, W, ue) {
      if (g(l, f.startInlineScript), f.sentClientRenderFunction ? g(l, id) : (f.sentClientRenderFunction = !0, g(l, rd)), E === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(l, E), g(l, ms), (F || W || ue) && (g(l, ys), g(l, v(gs(F || "")))), (W || ue) && (g(l, ys), g(l, v(gs(W || "")))), ue && (g(l, ys), g(l, v(gs(ue)))), x(l, ad);
    }
    var Wl = /[<\u2028\u2029]/g;
    function gs(l) {
      var f = JSON.stringify(l);
      return f.replace(Wl, function(E) {
        switch (E) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var br = Object.assign, od = Symbol.for("react.element"), jl = Symbol.for("react.portal"), dr = Symbol.for("react.fragment"), Kl = Symbol.for("react.strict_mode"), vs = Symbol.for("react.profiler"), so = Symbol.for("react.provider"), lo = Symbol.for("react.context"), uo = Symbol.for("react.forward_ref"), ca = Symbol.for("react.suspense"), da = Symbol.for("react.suspense_list"), ha = Symbol.for("react.memo"), Mi = Symbol.for("react.lazy"), bs = Symbol.for("react.scope"), xs = Symbol.for("react.debug_trace_mode"), co = Symbol.for("react.legacy_hidden"), sd = Symbol.for("react.default_value"), Ul = Symbol.iterator, ld = "@@iterator";
    function ud(l) {
      if (l === null || typeof l != "object")
        return null;
      var f = Ul && l[Ul] || l[ld];
      return typeof f == "function" ? f : null;
    }
    function Gl(l, f, E) {
      var F = l.displayName;
      if (F)
        return F;
      var W = f.displayName || f.name || "";
      return W !== "" ? E + "(" + W + ")" : E;
    }
    function Yl(l) {
      return l.displayName || "Context";
    }
    function cn(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case dr:
          return "Fragment";
        case jl:
          return "Portal";
        case vs:
          return "Profiler";
        case Kl:
          return "StrictMode";
        case ca:
          return "Suspense";
        case da:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case lo:
            var f = l;
            return Yl(f) + ".Consumer";
          case so:
            var E = l;
            return Yl(E._context) + ".Provider";
          case uo:
            return Gl(l, l.render, "ForwardRef");
          case ha:
            var F = l.displayName || null;
            return F !== null ? F : cn(l.type) || "Memo";
          case Mi: {
            var W = l, ue = W._payload, ve = W._init;
            try {
              return cn(ve(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var fa = 0, Ss, on, Ii, ws, ks, Ts, Cs;
    function As() {
    }
    As.__reactDisabledLog = !0;
    function Xl() {
      {
        if (fa === 0) {
          Ss = console.log, on = console.info, Ii = console.warn, ws = console.error, ks = console.group, Ts = console.groupCollapsed, Cs = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: As,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        fa++;
      }
    }
    function ql() {
      {
        if (fa--, fa === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: br({}, l, {
              value: Ss
            }),
            info: br({}, l, {
              value: on
            }),
            warn: br({}, l, {
              value: Ii
            }),
            error: br({}, l, {
              value: ws
            }),
            group: br({}, l, {
              value: ks
            }),
            groupCollapsed: br({}, l, {
              value: Ts
            }),
            groupEnd: br({}, l, {
              value: Cs
            })
          });
        }
        fa < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ho = n.ReactCurrentDispatcher, Ls;
    function pa(l, f, E) {
      {
        if (Ls === void 0)
          try {
            throw Error();
          } catch (W) {
            var F = W.stack.trim().match(/\n( *(at )?)/);
            Ls = F && F[1] || "";
          }
        return `
` + Ls + l;
      }
    }
    var ma = !1, Bi;
    {
      var ya = typeof WeakMap == "function" ? WeakMap : Map;
      Bi = new ya();
    }
    function ga(l, f) {
      if (!l || ma)
        return "";
      {
        var E = Bi.get(l);
        if (E !== void 0)
          return E;
      }
      var F;
      ma = !0;
      var W = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = ho.current, ho.current = null, Xl();
      try {
        if (f) {
          var ve = function() {
            throw Error();
          };
          if (Object.defineProperty(ve.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ve, []);
            } catch (fe) {
              F = fe;
            }
            Reflect.construct(l, [], ve);
          } else {
            try {
              ve.call();
            } catch (fe) {
              F = fe;
            }
            l.call(ve.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (fe) {
            F = fe;
          }
          l();
        }
      } catch (fe) {
        if (fe && F && typeof fe.stack == "string") {
          for (var Ee = fe.stack.split(`
`), s = F.stack.split(`
`), c = Ee.length - 1, T = s.length - 1; c >= 1 && T >= 0 && Ee[c] !== s[T]; )
            T--;
          for (; c >= 1 && T >= 0; c--, T--)
            if (Ee[c] !== s[T]) {
              if (c !== 1 || T !== 1)
                do
                  if (c--, T--, T < 0 || Ee[c] !== s[T]) {
                    var _ = `
` + Ee[c].replace(" at new ", " at ");
                    return l.displayName && _.includes("<anonymous>") && (_ = _.replace("<anonymous>", l.displayName)), typeof l == "function" && Bi.set(l, _), _;
                  }
                while (c >= 1 && T >= 0);
              break;
            }
        }
      } finally {
        ma = !1, ho.current = ue, ql(), Error.prepareStackTrace = W;
      }
      var z = l ? l.displayName || l.name : "", te = z ? pa(z) : "";
      return typeof l == "function" && Bi.set(l, te), te;
    }
    function fo(l, f, E) {
      return ga(l, !0);
    }
    function Zl(l, f, E) {
      return ga(l, !1);
    }
    function Es(l) {
      var f = l.prototype;
      return !!(f && f.isReactComponent);
    }
    function _s(l, f, E) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return ga(l, Es(l));
      if (typeof l == "string")
        return pa(l);
      switch (l) {
        case ca:
          return pa("Suspense");
        case da:
          return pa("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case uo:
            return Zl(l.render);
          case ha:
            return _s(l.type, f, E);
          case Mi: {
            var F = l, W = F._payload, ue = F._init;
            try {
              return _s(ue(W), f, E);
            } catch {
            }
          }
        }
      return "";
    }
    var Ps = {}, Ql = n.ReactDebugCurrentFrame;
    function zi(l) {
      if (l) {
        var f = l._owner, E = _s(l.type, l._source, f ? f.type : null);
        Ql.setExtraStackFrame(E);
      } else
        Ql.setExtraStackFrame(null);
    }
    function Ns(l, f, E, F, W) {
      {
        var ue = Function.call.bind(ae);
        for (var ve in l)
          if (ue(l, ve)) {
            var Ee = void 0;
            try {
              if (typeof l[ve] != "function") {
                var s = Error((F || "React class") + ": " + E + " type `" + ve + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[ve] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw s.name = "Invariant Violation", s;
              }
              Ee = l[ve](f, ve, F, E, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (c) {
              Ee = c;
            }
            Ee && !(Ee instanceof Error) && (zi(W), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", F || "React class", E, ve, typeof Ee), zi(null)), Ee instanceof Error && !(Ee.message in Ps) && (Ps[Ee.message] = !0, zi(W), i("Failed %s type: %s", E, Ee.message), zi(null));
          }
      }
    }
    var po;
    po = {};
    var di = {};
    Object.freeze(di);
    function Rs(l, f) {
      {
        var E = l.contextTypes;
        if (!E)
          return di;
        var F = {};
        for (var W in E)
          F[W] = f[W];
        {
          var ue = cn(l) || "Unknown";
          Ns(E, F, "context", ue);
        }
        return F;
      }
    }
    function Ds(l, f, E, F) {
      {
        if (typeof l.getChildContext != "function") {
          {
            var W = cn(f) || "Unknown";
            po[W] || (po[W] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", W, W));
          }
          return E;
        }
        var ue = l.getChildContext();
        for (var ve in ue)
          if (!(ve in F))
            throw new Error((cn(f) || "Unknown") + '.getChildContext(): key "' + ve + '" is not defined in childContextTypes.');
        {
          var Ee = cn(f) || "Unknown";
          Ns(F, ue, "child context", Ee);
        }
        return br({}, E, ue);
      }
    }
    var ei;
    ei = {};
    var Jl = null, hi = null;
    function fi(l) {
      l.context._currentValue = l.parentValue;
    }
    function Os(l) {
      l.context._currentValue = l.value;
    }
    function Nr(l, f) {
      if (l !== f) {
        fi(l);
        var E = l.parent, F = f.parent;
        if (E === null) {
          if (F !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (F === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          Nr(E, F);
        }
        Os(f);
      }
    }
    function mo(l) {
      fi(l);
      var f = l.parent;
      f !== null && mo(f);
    }
    function yo(l) {
      var f = l.parent;
      f !== null && yo(f), Os(l);
    }
    function va(l, f) {
      fi(l);
      var E = l.parent;
      if (E === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      E.depth === f.depth ? Nr(E, f) : va(E, f);
    }
    function Fs(l, f) {
      var E = f.parent;
      if (E === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      l.depth === E.depth ? Nr(l, E) : Fs(l, E), Os(f);
    }
    function ba(l) {
      var f = hi, E = l;
      f !== E && (f === null ? yo(E) : E === null ? mo(f) : f.depth === E.depth ? Nr(f, E) : f.depth > E.depth ? va(f, E) : Fs(f, E), hi = E);
    }
    function eu(l, f) {
      var E;
      E = l._currentValue, l._currentValue = f, l._currentRenderer !== void 0 && l._currentRenderer !== null && l._currentRenderer !== ei && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer = ei;
      var F = hi, W = {
        parent: F,
        depth: F === null ? 0 : F.depth + 1,
        context: l,
        parentValue: E,
        value: f
      };
      return hi = W, W;
    }
    function tu(l) {
      var f = hi;
      if (f === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      f.context !== l && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var E = f.parentValue;
        E === sd ? f.context._currentValue = f.context._defaultValue : f.context._currentValue = E, l._currentRenderer !== void 0 && l._currentRenderer !== null && l._currentRenderer !== ei && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer = ei;
      }
      return hi = f.parent;
    }
    function go() {
      return hi;
    }
    function xa(l) {
      var f = l._currentValue;
      return f;
    }
    function Ms(l) {
      return l._reactInternals;
    }
    function cd(l, f) {
      l._reactInternals = f;
    }
    var $i = {}, vo = {}, Is, bo, xo, Sa, So, Hi, wa, wo, Vi;
    {
      Is = /* @__PURE__ */ new Set(), bo = /* @__PURE__ */ new Set(), xo = /* @__PURE__ */ new Set(), wa = /* @__PURE__ */ new Set(), Sa = /* @__PURE__ */ new Set(), wo = /* @__PURE__ */ new Set(), Vi = /* @__PURE__ */ new Set();
      var ko = /* @__PURE__ */ new Set();
      Hi = function(l, f) {
        if (!(l === null || typeof l == "function")) {
          var E = f + "_" + l;
          ko.has(E) || (ko.add(E), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, l));
        }
      }, So = function(l, f) {
        if (f === void 0) {
          var E = cn(l) || "Component";
          Sa.has(E) || (Sa.add(E), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", E));
        }
      };
    }
    function To(l, f) {
      {
        var E = l.constructor, F = E && cn(E) || "ReactClass", W = F + "." + f;
        if ($i[W])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, f, f, F), $i[W] = !0;
      }
    }
    var Co = {
      isMounted: function(l) {
        return !1;
      },
      enqueueSetState: function(l, f, E) {
        var F = Ms(l);
        F.queue === null ? To(l, "setState") : (F.queue.push(f), E != null && Hi(E, "setState"));
      },
      enqueueReplaceState: function(l, f, E) {
        var F = Ms(l);
        F.replace = !0, F.queue = [f], E != null && Hi(E, "setState");
      },
      enqueueForceUpdate: function(l, f) {
        var E = Ms(l);
        E.queue === null ? To(l, "forceUpdate") : f != null && Hi(f, "setState");
      }
    };
    function nu(l, f, E, F, W) {
      var ue = E(W, F);
      So(f, ue);
      var ve = ue == null ? F : br({}, F, ue);
      return ve;
    }
    function ru(l, f, E) {
      var F = di, W = l.contextType;
      if ("contextType" in l) {
        var ue = (
          // Allow null for conditional declaration
          W === null || W !== void 0 && W.$$typeof === lo && W._context === void 0
        );
        if (!ue && !Vi.has(l)) {
          Vi.add(l);
          var ve = "";
          W === void 0 ? ve = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof W != "object" ? ve = " However, it is set to a " + typeof W + "." : W.$$typeof === so ? ve = " Did you accidentally pass the Context.Provider instead?" : W._context !== void 0 ? ve = " Did you accidentally pass the Context.Consumer instead?" : ve = " However, it is set to an object with keys {" + Object.keys(W).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", cn(l) || "Component", ve);
        }
      }
      typeof W == "object" && W !== null ? F = xa(W) : F = E;
      var Ee = new l(f, F);
      {
        if (typeof l.getDerivedStateFromProps == "function" && (Ee.state === null || Ee.state === void 0)) {
          var s = cn(l) || "Component";
          Is.has(s) || (Is.add(s), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", s, Ee.state === null ? "null" : "undefined", s));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof Ee.getSnapshotBeforeUpdate == "function") {
          var c = null, T = null, _ = null;
          if (typeof Ee.componentWillMount == "function" && Ee.componentWillMount.__suppressDeprecationWarning !== !0 ? c = "componentWillMount" : typeof Ee.UNSAFE_componentWillMount == "function" && (c = "UNSAFE_componentWillMount"), typeof Ee.componentWillReceiveProps == "function" && Ee.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? T = "componentWillReceiveProps" : typeof Ee.UNSAFE_componentWillReceiveProps == "function" && (T = "UNSAFE_componentWillReceiveProps"), typeof Ee.componentWillUpdate == "function" && Ee.componentWillUpdate.__suppressDeprecationWarning !== !0 ? _ = "componentWillUpdate" : typeof Ee.UNSAFE_componentWillUpdate == "function" && (_ = "UNSAFE_componentWillUpdate"), c !== null || T !== null || _ !== null) {
            var z = cn(l) || "Component", te = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            xo.has(z) || (xo.add(z), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, z, te, c !== null ? `
  ` + c : "", T !== null ? `
  ` + T : "", _ !== null ? `
  ` + _ : ""));
          }
        }
      }
      return Ee;
    }
    function iu(l, f, E) {
      {
        var F = cn(f) || "Component", W = l.render;
        W || (f.prototype && typeof f.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", F) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", F)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", F), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", F), l.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", F), l.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", F), l.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", F), f.contextType && f.contextTypes && !wo.has(f) && (wo.add(f), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", F)), typeof l.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", F), f.prototype && f.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", cn(f) || "A pure component"), typeof l.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", F), typeof l.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", F), typeof l.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", F), typeof l.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", F);
        var ue = l.props !== E;
        l.props !== void 0 && ue && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", F, F), l.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", F, F), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !bo.has(f) && (bo.add(f), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", cn(f))), typeof l.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", F), typeof l.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", F), typeof f.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", F);
        var ve = l.state;
        ve && (typeof ve != "object" || Fn(ve)) && i("%s.state: must be set to an object or null", F), typeof l.getChildContext == "function" && typeof f.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", F);
      }
    }
    function dd(l, f) {
      var E = f.state;
      if (typeof f.componentWillMount == "function") {
        if (f.componentWillMount.__suppressDeprecationWarning !== !0) {
          var F = cn(l) || "Unknown";
          vo[F] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            F
          ), vo[F] = !0);
        }
        f.componentWillMount();
      }
      typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), E !== f.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", cn(l) || "Component"), Co.enqueueReplaceState(f, f.state, null));
    }
    function hd(l, f, E, F) {
      if (l.queue !== null && l.queue.length > 0) {
        var W = l.queue, ue = l.replace;
        if (l.queue = null, l.replace = !1, ue && W.length === 1)
          f.state = W[0];
        else {
          for (var ve = ue ? W[0] : f.state, Ee = !0, s = ue ? 1 : 0; s < W.length; s++) {
            var c = W[s], T = typeof c == "function" ? c.call(f, ve, E, F) : c;
            T != null && (Ee ? (Ee = !1, ve = br({}, ve, T)) : br(ve, T));
          }
          f.state = ve;
        }
      } else
        l.queue = null;
    }
    function au(l, f, E, F) {
      iu(l, f, E);
      var W = l.state !== void 0 ? l.state : null;
      l.updater = Co, l.props = E, l.state = W;
      var ue = {
        queue: [],
        replace: !1
      };
      cd(l, ue);
      var ve = f.contextType;
      if (typeof ve == "object" && ve !== null ? l.context = xa(ve) : l.context = F, l.state === E) {
        var Ee = cn(f) || "Component";
        wa.has(Ee) || (wa.add(Ee), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Ee));
      }
      var s = f.getDerivedStateFromProps;
      typeof s == "function" && (l.state = nu(l, f, s, W, E)), typeof f.getDerivedStateFromProps != "function" && typeof l.getSnapshotBeforeUpdate != "function" && (typeof l.UNSAFE_componentWillMount == "function" || typeof l.componentWillMount == "function") && (dd(f, l), hd(ue, l, E, F));
    }
    var fd = {
      id: 1,
      overflow: ""
    };
    function pd(l) {
      var f = l.overflow, E = l.id, F = E & ~md(E);
      return F.toString(32) + f;
    }
    function Ao(l, f, E) {
      var F = l.id, W = l.overflow, ue = Lo(F) - 1, ve = F & ~(1 << ue), Ee = E + 1, s = Lo(f) + ue;
      if (s > 30) {
        var c = ue - ue % 5, T = (1 << c) - 1, _ = (ve & T).toString(32), z = ve >> c, te = ue - c, fe = Lo(f) + te, Ae = Ee << te, Oe = Ae | z, Qe = _ + W;
        return {
          id: 1 << fe | Oe,
          overflow: Qe
        };
      } else {
        var it = Ee << ue, xt = it | ve, sn = W;
        return {
          id: 1 << s | xt,
          overflow: sn
        };
      }
    }
    function Lo(l) {
      return 32 - Bs(l);
    }
    function md(l) {
      return 1 << Lo(l) - 1;
    }
    var Bs = Math.clz32 ? Math.clz32 : gd, Eo = Math.log, yd = Math.LN2;
    function gd(l) {
      var f = l >>> 0;
      return f === 0 ? 32 : 31 - (Eo(f) / yd | 0) | 0;
    }
    function vd(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var bd = typeof Object.is == "function" ? Object.is : vd, Hr = null, zs = null, _o = null, Mt = null, pi = !1, mi = !1, Ut = 0, xr = null, yi = 0, Po = 25, Bn = !1, Vr;
    function gi() {
      if (Hr === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Bn && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Hr;
    }
    function Rr(l, f) {
      if (f === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Vr), !1;
      l.length !== f.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Vr, "[" + l.join(", ") + "]", "[" + f.join(", ") + "]");
      for (var E = 0; E < f.length && E < l.length; E++)
        if (!bd(l[E], f[E]))
          return !1;
      return !0;
    }
    function vi() {
      if (yi > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Wr() {
      return Mt === null ? _o === null ? (pi = !1, _o = Mt = vi()) : (pi = !0, Mt = _o) : Mt.next === null ? (pi = !1, Mt = Mt.next = vi()) : (pi = !0, Mt = Mt.next), Mt;
    }
    function xd(l, f) {
      Hr = f, zs = l, Bn = !1, Ut = 0;
    }
    function ou(l, f, E, F) {
      for (; mi; )
        mi = !1, Ut = 0, yi += 1, Mt = null, E = l(f, F);
      return $s(), E;
    }
    function No() {
      var l = Ut !== 0;
      return l;
    }
    function $s() {
      Bn = !1, Hr = null, zs = null, mi = !1, _o = null, yi = 0, xr = null, Mt = null;
    }
    function Sd(l) {
      return Bn && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), xa(l);
    }
    function su(l) {
      return Vr = "useContext", gi(), xa(l);
    }
    function ka(l, f) {
      return typeof f == "function" ? f(l) : f;
    }
    function wd(l) {
      return Vr = "useState", lu(
        ka,
        // useReducer has a special case to support lazy useState initializers
        l
      );
    }
    function lu(l, f, E) {
      if (l !== ka && (Vr = "useReducer"), Hr = gi(), Mt = Wr(), pi) {
        var F = Mt.queue, W = F.dispatch;
        if (xr !== null) {
          var ue = xr.get(F);
          if (ue !== void 0) {
            xr.delete(F);
            var ve = Mt.memoizedState, Ee = ue;
            do {
              var s = Ee.action;
              Bn = !0, ve = l(ve, s), Bn = !1, Ee = Ee.next;
            } while (Ee !== null);
            return Mt.memoizedState = ve, [ve, W];
          }
        }
        return [Mt.memoizedState, W];
      } else {
        Bn = !0;
        var c;
        l === ka ? c = typeof f == "function" ? f() : f : c = E !== void 0 ? E(f) : f, Bn = !1, Mt.memoizedState = c;
        var T = Mt.queue = {
          last: null,
          dispatch: null
        }, _ = T.dispatch = cu.bind(null, Hr, T);
        return [Mt.memoizedState, _];
      }
    }
    function Ro(l, f) {
      Hr = gi(), Mt = Wr();
      var E = f === void 0 ? null : f;
      if (Mt !== null) {
        var F = Mt.memoizedState;
        if (F !== null && E !== null) {
          var W = F[1];
          if (Rr(E, W))
            return F[0];
        }
      }
      Bn = !0;
      var ue = l();
      return Bn = !1, Mt.memoizedState = [ue, E], ue;
    }
    function kd(l) {
      Hr = gi(), Mt = Wr();
      var f = Mt.memoizedState;
      if (f === null) {
        var E = {
          current: l
        };
        return Object.seal(E), Mt.memoizedState = E, E;
      } else
        return f;
    }
    function uu(l, f) {
      Vr = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function cu(l, f, E) {
      if (yi >= Po)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (l === Hr) {
        mi = !0;
        var F = {
          action: E,
          next: null
        };
        xr === null && (xr = /* @__PURE__ */ new Map());
        var W = xr.get(f);
        if (W === void 0)
          xr.set(f, F);
        else {
          for (var ue = W; ue.next !== null; )
            ue = ue.next;
          ue.next = F;
        }
      }
    }
    function Td(l, f) {
      return Ro(function() {
        return l;
      }, f);
    }
    function Cd(l, f, E) {
      return gi(), f(l._source);
    }
    function Ad(l, f, E) {
      if (E === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return E();
    }
    function Ld(l) {
      return gi(), l;
    }
    function Ed() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function _d() {
      return gi(), [!1, Ed];
    }
    function Pd() {
      var l = zs, f = pd(l.treeContext), E = Hs;
      if (E === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var F = Ut++;
      return Xn(E, f, F);
    }
    function Do() {
    }
    var du = {
      readContext: Sd,
      useContext: su,
      useMemo: Ro,
      useReducer: lu,
      useRef: kd,
      useState: wd,
      useInsertionEffect: Do,
      useLayoutEffect: uu,
      useCallback: Td,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: Do,
      // Effects are not run in the server environment.
      useEffect: Do,
      // Debugging effect
      useDebugValue: Do,
      useDeferredValue: Ld,
      useTransition: _d,
      useId: Pd,
      // Subscriptions are not setup in a server environment.
      useMutableSource: Cd,
      useSyncExternalStore: Ad
    }, Hs = null;
    function Ta(l) {
      Hs = l;
    }
    function hu(l) {
      try {
        var f = "", E = l;
        do {
          switch (E.tag) {
            case 0:
              f += pa(E.type, null, null);
              break;
            case 1:
              f += Zl(E.type, null, null);
              break;
            case 2:
              f += fo(E.type, null, null);
              break;
          }
          E = E.parent;
        } while (E);
        return f;
      } catch (F) {
        return `
Error generating stack: ` + F.message + `
` + F.stack;
      }
    }
    var Ca = n.ReactCurrentDispatcher, Oo = n.ReactDebugCurrentFrame, Vs = 0, ti = 1, Fo = 2, Mo = 3, bi = 4, fu = 0, Ws = 1, xi = 2, Nd = 12800;
    function pu(l) {
      return console.error(l), null;
    }
    function Dr() {
    }
    function Rd(l, f, E, F, W, ue, ve, Ee, s) {
      var c = [], T = /* @__PURE__ */ new Set(), _ = {
        destination: null,
        responseState: f,
        progressiveChunkSize: F === void 0 ? Nd : F,
        status: fu,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: T,
        pingedTasks: c,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: W === void 0 ? pu : W,
        onAllReady: ue === void 0 ? Dr : ue,
        onShellReady: ve === void 0 ? Dr : ve,
        onShellError: Ee === void 0 ? Dr : Ee,
        onFatalError: s === void 0 ? Dr : s
      }, z = Io(
        _,
        0,
        null,
        E,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      z.parentFlushed = !0;
      var te = js(_, l, null, z, T, di, Jl, fd);
      return c.push(te), _;
    }
    function Dd(l, f) {
      var E = l.pingedTasks;
      E.push(f), E.length === 1 && h(function() {
        return Na(l);
      });
    }
    function Aa(l, f) {
      return {
        id: gr,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: f,
        errorDigest: null
      };
    }
    function js(l, f, E, F, W, ue, ve, Ee) {
      l.allPendingTasks++, E === null ? l.pendingRootTasks++ : E.pendingTasks++;
      var s = {
        node: f,
        ping: function() {
          return Dd(l, s);
        },
        blockedBoundary: E,
        blockedSegment: F,
        abortSet: W,
        legacyContext: ue,
        context: ve,
        treeContext: Ee
      };
      return s.componentStack = null, W.add(s), s;
    }
    function Io(l, f, E, F, W, ue) {
      return {
        status: Vs,
        id: -1,
        // lazily assigned later
        index: f,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: F,
        boundary: E,
        lastPushedText: W,
        textEmbedded: ue
      };
    }
    var jr = null;
    function La() {
      return jr === null || jr.componentStack === null ? "" : hu(jr.componentStack);
    }
    function ni(l, f) {
      l.componentStack = {
        tag: 0,
        parent: l.componentStack,
        type: f
      };
    }
    function Or(l, f) {
      l.componentStack = {
        tag: 1,
        parent: l.componentStack,
        type: f
      };
    }
    function Ks(l, f) {
      l.componentStack = {
        tag: 2,
        parent: l.componentStack,
        type: f
      };
    }
    function Sr(l) {
      l.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : l.componentStack = l.componentStack.parent;
    }
    var Wi = null;
    function Us(l, f) {
      {
        var E;
        typeof f == "string" ? E = f : f && typeof f.message == "string" ? E = f.message : E = String(f);
        var F = Wi || La();
        Wi = null, l.errorMessage = E, l.errorComponentStack = F;
      }
    }
    function wr(l, f) {
      var E = l.onError(f);
      if (E != null && typeof E != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof E + '" instead');
      return E;
    }
    function ri(l, f) {
      var E = l.onShellError;
      E(f);
      var F = l.onFatalError;
      F(f), l.destination !== null ? (l.status = xi, B(l.destination, f)) : (l.status = Ws, l.fatalError = f);
    }
    function Gs(l, f, E) {
      ni(f, "Suspense");
      var F = f.blockedBoundary, W = f.blockedSegment, ue = E.fallback, ve = E.children, Ee = /* @__PURE__ */ new Set(), s = Aa(l, Ee), c = W.chunks.length, T = Io(
        l,
        c,
        s,
        W.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      W.children.push(T), W.lastPushedText = !1;
      var _ = Io(
        l,
        0,
        null,
        W.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      _.parentFlushed = !0, f.blockedBoundary = s, f.blockedSegment = _;
      try {
        if (rl(l, f, ve), Zn(_.chunks, l.responseState, _.lastPushedText, _.textEmbedded), _.status = ti, $o(s, _), s.pendingTasks === 0) {
          Sr(f);
          return;
        }
      } catch (te) {
        _.status = bi, s.forceClientRender = !0, s.errorDigest = wr(l, te), Us(s, te);
      } finally {
        f.blockedBoundary = F, f.blockedSegment = W;
      }
      var z = js(l, ue, F, T, Ee, f.legacyContext, f.context, f.treeContext);
      z.componentStack = f.componentStack, l.pingedTasks.push(z), Sr(f);
    }
    function Ea(l, f, E, F) {
      ni(f, E);
      var W = f.blockedSegment, ue = ia(W.chunks, E, F, l.responseState, W.formatContext);
      W.lastPushedText = !1;
      var ve = W.formatContext;
      W.formatContext = Wn(ve, E, F), rl(l, f, ue), W.formatContext = ve, Xa(W.chunks, E), W.lastPushedText = !1, Sr(f);
    }
    function Bo(l) {
      return l.prototype && l.prototype.isReactComponent;
    }
    function mu(l, f, E, F, W) {
      var ue = {};
      xd(f, ue);
      var ve = E(F, W);
      return ou(E, F, ve, W);
    }
    function yu(l, f, E, F, W) {
      var ue = E.render();
      E.props !== W && (Pa || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", cn(F) || "a component"), Pa = !0);
      {
        var ve = F.childContextTypes;
        if (ve != null) {
          var Ee = f.legacyContext, s = Ds(E, F, Ee, ve);
          f.legacyContext = s, hr(l, f, ue), f.legacyContext = Ee;
          return;
        }
      }
      hr(l, f, ue);
    }
    function Od(l, f, E, F) {
      Ks(f, E);
      var W = Rs(E, f.legacyContext), ue = ru(E, F, W);
      au(ue, E, F, W), yu(l, f, ue, E, F), Sr(f);
    }
    var Ys = {}, _a = {}, gu = {}, Xs = {}, Pa = !1, qs = {}, Zs = !1, Qs = !1, Js = !1;
    function vu(l, f, E, F) {
      var W;
      if (W = Rs(E, f.legacyContext), Or(f, E), E.prototype && typeof E.prototype.render == "function") {
        var ue = cn(E) || "Unknown";
        Ys[ue] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", ue, ue), Ys[ue] = !0);
      }
      var ve = mu(l, f, E, F, W), Ee = No();
      if (typeof ve == "object" && ve !== null && typeof ve.render == "function" && ve.$$typeof === void 0) {
        var s = cn(E) || "Unknown";
        _a[s] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", s, s, s), _a[s] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof ve == "object" && ve !== null && typeof ve.render == "function" && ve.$$typeof === void 0
      ) {
        {
          var c = cn(E) || "Unknown";
          _a[c] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", c, c, c), _a[c] = !0);
        }
        au(ve, E, F, W), yu(l, f, ve, E, F);
      } else if (bu(E), Ee) {
        var T = f.treeContext, _ = 1, z = 0;
        f.treeContext = Ao(T, _, z);
        try {
          hr(l, f, ve);
        } finally {
          f.treeContext = T;
        }
      } else
        hr(l, f, ve);
      Sr(f);
    }
    function bu(l) {
      {
        if (l && l.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), l.defaultProps !== void 0) {
          var f = cn(l) || "Unknown";
          qs[f] || (i("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", f), qs[f] = !0);
        }
        if (typeof l.getDerivedStateFromProps == "function") {
          var E = cn(l) || "Unknown";
          Xs[E] || (i("%s: Function components do not support getDerivedStateFromProps.", E), Xs[E] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var F = cn(l) || "Unknown";
          gu[F] || (i("%s: Function components do not support contextType.", F), gu[F] = !0);
        }
      }
    }
    function el(l, f) {
      if (l && l.defaultProps) {
        var E = br({}, f), F = l.defaultProps;
        for (var W in F)
          E[W] === void 0 && (E[W] = F[W]);
        return E;
      }
      return f;
    }
    function Fd(l, f, E, F, W) {
      Or(f, E.render);
      var ue = mu(l, f, E.render, F, W), ve = No();
      if (ve) {
        var Ee = f.treeContext, s = 1, c = 0;
        f.treeContext = Ao(Ee, s, c);
        try {
          hr(l, f, ue);
        } finally {
          f.treeContext = Ee;
        }
      } else
        hr(l, f, ue);
      Sr(f);
    }
    function Md(l, f, E, F, W) {
      var ue = E.type, ve = el(ue, F);
      tl(l, f, ue, ve, W);
    }
    function xu(l, f, E, F) {
      E._context === void 0 ? E !== E.Consumer && (Js || (Js = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : E = E._context;
      var W = F.children;
      typeof W != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var ue = xa(E), ve = W(ue);
      hr(l, f, ve);
    }
    function Id(l, f, E, F) {
      var W = E._context, ue = F.value, ve = F.children, Ee;
      Ee = f.context, f.context = eu(W, ue), hr(l, f, ve), f.context = tu(W), Ee !== f.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function Bd(l, f, E, F, W) {
      ni(f, "Lazy");
      var ue = E._payload, ve = E._init, Ee = ve(ue), s = el(Ee, F);
      tl(l, f, Ee, s, W), Sr(f);
    }
    function tl(l, f, E, F, W) {
      if (typeof E == "function")
        if (Bo(E)) {
          Od(l, f, E, F);
          return;
        } else {
          vu(l, f, E, F);
          return;
        }
      if (typeof E == "string") {
        Ea(l, f, E, F);
        return;
      }
      switch (E) {
        case co:
        case xs:
        case Kl:
        case vs:
        case dr: {
          hr(l, f, F.children);
          return;
        }
        case da: {
          ni(f, "SuspenseList"), hr(l, f, F.children), Sr(f);
          return;
        }
        case bs:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case ca: {
          Gs(l, f, F);
          return;
        }
      }
      if (typeof E == "object" && E !== null)
        switch (E.$$typeof) {
          case uo: {
            Fd(l, f, E, F, W);
            return;
          }
          case ha: {
            Md(l, f, E, F, W);
            return;
          }
          case so: {
            Id(l, f, E, F);
            return;
          }
          case lo: {
            xu(l, f, E, F);
            return;
          }
          case Mi: {
            Bd(l, f, E, F);
            return;
          }
        }
      var ue = "";
      throw (E === void 0 || typeof E == "object" && E !== null && Object.keys(E).length === 0) && (ue += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (E == null ? E : typeof E) + "." + ue));
    }
    function zd(l, f) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      l[Symbol.toStringTag] === "Generator" && (Zs || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Zs = !0), l.entries === f && (Qs || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Qs = !0);
    }
    function hr(l, f, E) {
      try {
        return nl(l, f, E);
      } catch (F) {
        throw typeof F == "object" && F !== null && typeof F.then == "function" || (Wi = Wi !== null ? Wi : La()), F;
      }
    }
    function nl(l, f, E) {
      if (f.node = E, typeof E == "object" && E !== null) {
        switch (E.$$typeof) {
          case od: {
            var F = E, W = F.type, ue = F.props, ve = F.ref;
            tl(l, f, W, ue, ve);
            return;
          }
          case jl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Mi: {
            var Ee = E, s = Ee._payload, c = Ee._init, T;
            try {
              T = c(s);
            } catch (it) {
              throw typeof it == "object" && it !== null && typeof it.then == "function" && ni(f, "Lazy"), it;
            }
            hr(l, f, T);
            return;
          }
        }
        if (Fn(E)) {
          Su(l, f, E);
          return;
        }
        var _ = ud(E);
        if (_) {
          zd(E, _);
          var z = _.call(E);
          if (z) {
            var te = z.next();
            if (!te.done) {
              var fe = [];
              do
                fe.push(te.value), te = z.next();
              while (!te.done);
              Su(l, f, fe);
              return;
            }
            return;
          }
        }
        var Ae = Object.prototype.toString.call(E);
        throw new Error("Objects are not valid as a React child (found: " + (Ae === "[object Object]" ? "object with keys {" + Object.keys(E).join(", ") + "}" : Ae) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof E == "string") {
        var Oe = f.blockedSegment;
        Oe.lastPushedText = qn(f.blockedSegment.chunks, E, l.responseState, Oe.lastPushedText);
        return;
      }
      if (typeof E == "number") {
        var Qe = f.blockedSegment;
        Qe.lastPushedText = qn(f.blockedSegment.chunks, "" + E, l.responseState, Qe.lastPushedText);
        return;
      }
      typeof E == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function Su(l, f, E) {
      for (var F = E.length, W = 0; W < F; W++) {
        var ue = f.treeContext;
        f.treeContext = Ao(ue, F, W);
        try {
          rl(l, f, E[W]);
        } finally {
          f.treeContext = ue;
        }
      }
    }
    function fr(l, f, E) {
      var F = f.blockedSegment, W = F.chunks.length, ue = Io(
        l,
        W,
        null,
        F.formatContext,
        // Adopt the parent segment's leading text embed
        F.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      F.children.push(ue), F.lastPushedText = !1;
      var ve = js(l, f.node, f.blockedBoundary, ue, f.abortSet, f.legacyContext, f.context, f.treeContext);
      f.componentStack !== null && (ve.componentStack = f.componentStack.parent);
      var Ee = ve.ping;
      E.then(Ee, Ee);
    }
    function rl(l, f, E) {
      var F = f.blockedSegment.formatContext, W = f.legacyContext, ue = f.context, ve = null;
      ve = f.componentStack;
      try {
        return hr(l, f, E);
      } catch (Ee) {
        if ($s(), typeof Ee == "object" && Ee !== null && typeof Ee.then == "function") {
          fr(l, f, Ee), f.blockedSegment.formatContext = F, f.legacyContext = W, f.context = ue, ba(ue), f.componentStack = ve;
          return;
        } else
          throw f.blockedSegment.formatContext = F, f.legacyContext = W, f.context = ue, ba(ue), f.componentStack = ve, Ee;
      }
    }
    function wu(l, f, E, F) {
      var W = wr(l, F);
      if (f === null ? ri(l, F) : (f.pendingTasks--, f.forceClientRender || (f.forceClientRender = !0, f.errorDigest = W, Us(f, F), f.parentFlushed && l.clientRenderedBoundaries.push(f))), l.allPendingTasks--, l.allPendingTasks === 0) {
        var ue = l.onAllReady;
        ue();
      }
    }
    function $d(l) {
      var f = this, E = l.blockedBoundary, F = l.blockedSegment;
      F.status = Mo, ku(f, E, F);
    }
    function zo(l, f, E) {
      var F = l.blockedBoundary, W = l.blockedSegment;
      if (W.status = Mo, F === null)
        f.allPendingTasks--, f.status !== xi && (f.status = xi, f.destination !== null && k(f.destination));
      else {
        if (F.pendingTasks--, !F.forceClientRender) {
          F.forceClientRender = !0;
          var ue = E === void 0 ? new Error("The render was aborted by the server without a reason.") : E;
          F.errorDigest = f.onError(ue);
          {
            var ve = "The server did not finish this Suspense boundary: ";
            ue && typeof ue.message == "string" ? ue = ve + ue.message : ue = ve + String(ue);
            var Ee = jr;
            jr = l;
            try {
              Us(F, ue);
            } finally {
              jr = Ee;
            }
          }
          F.parentFlushed && f.clientRenderedBoundaries.push(F);
        }
        if (F.fallbackAbortableTasks.forEach(function(c) {
          return zo(c, f, E);
        }), F.fallbackAbortableTasks.clear(), f.allPendingTasks--, f.allPendingTasks === 0) {
          var s = f.onAllReady;
          s();
        }
      }
    }
    function $o(l, f) {
      if (f.chunks.length === 0 && f.children.length === 1 && f.children[0].boundary === null) {
        var E = f.children[0];
        E.id = f.id, E.parentFlushed = !0, E.status === ti && $o(l, E);
      } else {
        var F = l.completedSegments;
        F.push(f);
      }
    }
    function ku(l, f, E) {
      if (f === null) {
        if (E.parentFlushed) {
          if (l.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          l.completedRootSegment = E;
        }
        if (l.pendingRootTasks--, l.pendingRootTasks === 0) {
          l.onShellError = Dr;
          var F = l.onShellReady;
          F();
        }
      } else if (f.pendingTasks--, !f.forceClientRender) {
        if (f.pendingTasks === 0)
          E.parentFlushed && E.status === ti && $o(f, E), f.parentFlushed && l.completedBoundaries.push(f), f.fallbackAbortableTasks.forEach($d, l), f.fallbackAbortableTasks.clear();
        else if (E.parentFlushed && E.status === ti) {
          $o(f, E);
          var W = f.completedSegments;
          W.length === 1 && f.parentFlushed && l.partialBoundaries.push(f);
        }
      }
      if (l.allPendingTasks--, l.allPendingTasks === 0) {
        var ue = l.onAllReady;
        ue();
      }
    }
    function Tu(l, f) {
      var E = f.blockedSegment;
      if (E.status === Vs) {
        ba(f.context);
        var F = null;
        F = jr, jr = f;
        try {
          hr(l, f, f.node), Zn(E.chunks, l.responseState, E.lastPushedText, E.textEmbedded), f.abortSet.delete(f), E.status = ti, ku(l, f.blockedBoundary, E);
        } catch (ue) {
          if ($s(), typeof ue == "object" && ue !== null && typeof ue.then == "function") {
            var W = f.ping;
            ue.then(W, W);
          } else
            f.abortSet.delete(f), E.status = bi, wu(l, f.blockedBoundary, E, ue);
        } finally {
          jr = F;
        }
      }
    }
    function Na(l) {
      if (l.status !== xi) {
        var f = go(), E = Ca.current;
        Ca.current = du;
        var F;
        F = Oo.getCurrentStack, Oo.getCurrentStack = La;
        var W = Hs;
        Ta(l.responseState);
        try {
          var ue = l.pingedTasks, ve;
          for (ve = 0; ve < ue.length; ve++) {
            var Ee = ue[ve];
            Tu(l, Ee);
          }
          ue.splice(0, ve), l.destination !== null && Vo(l, l.destination);
        } catch (s) {
          wr(l, s), ri(l, s);
        } finally {
          Ta(W), Ca.current = E, Oo.getCurrentStack = F, E === du && ba(f);
        }
      }
    }
    function Ra(l, f, E) {
      switch (E.parentFlushed = !0, E.status) {
        case Vs: {
          var F = E.id = l.nextSegmentId++;
          return E.lastPushedText = !1, E.textEmbedded = !1, Li(f, l.responseState, F);
        }
        case ti: {
          E.status = Fo;
          for (var W = !0, ue = E.chunks, ve = 0, Ee = E.children, s = 0; s < Ee.length; s++) {
            for (var c = Ee[s]; ve < c.index; ve++)
              g(f, ue[ve]);
            W = Ho(l, f, c);
          }
          for (; ve < ue.length - 1; ve++)
            g(f, ue[ve]);
          return ve < ue.length && (W = x(f, ue[ve])), W;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ho(l, f, E) {
      var F = E.boundary;
      if (F === null)
        return Ra(l, f, E);
      if (F.parentFlushed = !0, F.forceClientRender)
        return Gn(f, l.responseState, F.errorDigest, F.errorMessage, F.errorComponentStack), Ra(l, f, E), fs(f, l.responseState);
      if (F.pendingTasks > 0) {
        F.rootSegmentID = l.nextSegmentId++, F.completedSegments.length > 0 && l.partialBoundaries.push(F);
        var W = F.id = vr(l.responseState);
        return Pi(f, l.responseState, W), Ra(l, f, E), Ni(f, l.responseState);
      } else {
        if (F.byteSize > l.progressiveChunkSize)
          return F.rootSegmentID = l.nextSegmentId++, l.completedBoundaries.push(F), Pi(f, l.responseState, F.id), Ra(l, f, E), Ni(f, l.responseState);
        Za(f, l.responseState);
        var ue = F.completedSegments;
        if (ue.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var ve = ue[0];
        return Ho(l, f, ve), Qa(f, l.responseState);
      }
    }
    function Cu(l, f, E) {
      return Vl(f, l.responseState, E.id, E.errorDigest, E.errorMessage, E.errorComponentStack);
    }
    function Da(l, f, E) {
      return Tt(f, l.responseState, E.formatContext, E.id), Ho(l, f, E), en(f, E.formatContext);
    }
    function Oa(l, f, E) {
      for (var F = E.completedSegments, W = 0; W < F.length; W++) {
        var ue = F[W];
        il(l, f, E, ue);
      }
      return F.length = 0, ps(f, l.responseState, E.id, E.rootSegmentID);
    }
    function Hd(l, f, E) {
      for (var F = E.completedSegments, W = 0; W < F.length; W++) {
        var ue = F[W];
        if (!il(l, f, E, ue))
          return W++, F.splice(0, W), !1;
      }
      return F.splice(0, W), !0;
    }
    function il(l, f, E, F) {
      if (F.status === Fo)
        return !0;
      var W = F.id;
      if (W === -1) {
        var ue = F.id = E.rootSegmentID;
        if (ue === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Da(l, f, F);
      } else
        return Da(l, f, F), Qc(f, l.responseState, W);
    }
    function Vo(l, f) {
      m();
      try {
        var E = l.completedRootSegment;
        E !== null && l.pendingRootTasks === 0 && (Ho(l, f, E), l.completedRootSegment = null, cs(f, l.responseState));
        var F = l.clientRenderedBoundaries, W;
        for (W = 0; W < F.length; W++) {
          var ue = F[W];
          Cu(l, f, ue);
        }
        F.splice(0, W);
        var ve = l.completedBoundaries;
        for (W = 0; W < ve.length; W++) {
          var Ee = ve[W];
          Oa(l, f, Ee);
        }
        ve.splice(0, W), A(f), m(f);
        var s = l.partialBoundaries;
        for (W = 0; W < s.length; W++) {
          var c = s[W];
          if (!Hd(l, f, c)) {
            l.destination = null, W++, s.splice(0, W);
            return;
          }
        }
        s.splice(0, W);
        var T = l.completedBoundaries;
        for (W = 0; W < T.length; W++) {
          var _ = T[W];
          Oa(l, f, _);
        }
        T.splice(0, W);
      } finally {
        A(f), l.allPendingTasks === 0 && l.pingedTasks.length === 0 && l.clientRenderedBoundaries.length === 0 && l.completedBoundaries.length === 0 && (l.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), k(f));
      }
    }
    function Vd(l) {
      h(function() {
        return Na(l);
      });
    }
    function Au(l, f) {
      if (l.status === Ws) {
        l.status = xi, B(f, l.fatalError);
        return;
      }
      if (l.status !== xi && l.destination === null) {
        l.destination = f;
        try {
          Vo(l, f);
        } catch (E) {
          wr(l, E), ri(l, E);
        }
      }
    }
    function Wo(l, f) {
      try {
        var E = l.abortableTasks;
        E.forEach(function(F) {
          return zo(F, l, f);
        }), E.clear(), l.destination !== null && Vo(l, l.destination);
      } catch (F) {
        wr(l, F), ri(l, F);
      }
    }
    function Wd(l, f) {
      return new Promise(function(E, F) {
        var W, ue, ve = new Promise(function(z, te) {
          ue = z, W = te;
        });
        function Ee() {
          var z = new ReadableStream(
            {
              type: "bytes",
              pull: function(te) {
                Au(c, te);
              },
              cancel: function(te) {
                Wo(c);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          z.allReady = ve, E(z);
        }
        function s(z) {
          ve.catch(function() {
          }), F(z);
        }
        var c = Rd(l, Jt(f ? f.identifierPrefix : void 0, f ? f.nonce : void 0, f ? f.bootstrapScriptContent : void 0, f ? f.bootstrapScripts : void 0, f ? f.bootstrapModules : void 0), Mn(f ? f.namespaceURI : void 0), f ? f.progressiveChunkSize : void 0, f ? f.onError : void 0, ue, Ee, s, W);
        if (f && f.signal) {
          var T = f.signal, _ = function() {
            Wo(c, T.reason), T.removeEventListener("abort", _);
          };
          T.addEventListener("abort", _);
        }
        Vd(c);
      });
    }
    Wu.renderToReadableStream = Wd, Wu.version = t;
  }()), Wu;
}
var Ka, Kh;
process.env.NODE_ENV === "production" ? (Ka = VS(), Kh = WS()) : (Ka = jS(), Kh = KS());
ta.version = Ka.version;
ta.renderToString = Ka.renderToString;
ta.renderToStaticMarkup = Ka.renderToStaticMarkup;
ta.renderToNodeStream = Ka.renderToNodeStream;
ta.renderToStaticNodeStream = Ka.renderToStaticNodeStream;
ta.renderToReadableStream = Kh.renderToReadableStream;
const hm = ({ columnData: e }) => /* @__PURE__ */ a("ul", { children: e == null ? void 0 : e.map((t, n) => /* @__PURE__ */ O("li", { children: [
  t.label,
  ": ",
  t.value,
  " (",
  t.additional_info,
  "%)"
] }, n)) }), US = (e, t) => {
  var m, g, x, A, k, y;
  const n = `${(((m = e == null ? void 0 : e.tooltips) == null ? void 0 : m.find((v) => v.node === t)) || {}).value}`, r = `${(((g = e == null ? void 0 : e.tooltips) == null ? void 0 : g.find((v) => v.node === t)) || {}).summary}`, i = (((x = e == null ? void 0 : e.tooltips) == null ? void 0 : x.find((v) => v.node === t)) || {}).column1Label, o = (((A = e == null ? void 0 : e.tooltips) == null ? void 0 : A.find((v) => v.node === t)) || {}).column2Label, h = (((k = e == null ? void 0 : e.tooltips) == null ? void 0 : k.find((v) => v.node === t)) || {}).column1, u = (((y = e == null ? void 0 : e.tooltips) == null ? void 0 : y.find((v) => v.node === t)) || {}).column2, d = ta.renderToString(/* @__PURE__ */ a(hm, { columnData: h })), p = ta.renderToString(/* @__PURE__ */ a(hm, { columnData: u }));
  return `<div class="sankey-chart__tooltip">
    <span class="sankey-chart__tooltip--tooltip-header">${t}</span>
    <span class="sankey-chart__tooltip--tooltip-header">${n}</span>
    <div class="divider"></div>
    <span><strong>Summary: </strong>${r}</span>
    <div class="divider"></div>
    <div class="sankey-chart__tooltip--info-section">
      <div>
        <span><strong>${i}</strong></span>
        ${d}
      </div>
      <div>
        <span><strong>${o}</strong></span>
        ${p}
      </div>
    </div>
  </div>
`;
}, GS = ({ width: e, height: t, runtime: n }) => {
  var se, ie;
  const { config: r } = he.useContext(pt), { sankey: i } = r, [o, h] = he.useState(0), [u, d] = he.useState(""), { showAlert: p, alert: m } = HS(), g = he.useRef([]), x = (M) => {
    const U = u;
    U && d(""), U !== M && d(M);
  };
  if (he.useEffect(() => {
    var U;
    let M = 0;
    (U = g == null ? void 0 : g.current) == null || U.map((re) => {
      const j = re == null ? void 0 : re.getBoundingClientRect().width;
      j > M && (M = j);
    }), h(M);
  }, [g, i, window.innerWidth]), r.visualizationType !== "Sankey")
    return;
  const A = r == null ? void 0 : r.data[0], k = Array.from(new Set((se = A == null ? void 0 : A.links) == null ? void 0 : se.flatMap((M) => [M.source, M.target]))), y = {
    nodes: k.map((M) => ({ id: M })),
    links: (ie = A == null ? void 0 : A.links) == null ? void 0 : ie.map((M) => ({
      source: k.findIndex((U) => U === M.source),
      target: k.findIndex((U) => U === M.target),
      value: M.value
    }))
  };
  let v = 5;
  const S = 50, B = IS().nodeWidth(i.nodeSize.nodeWidth).nodePadding(i.nodePadding).iterations(i.iterations).nodeAlign(RS).extent([
    [i.margin.margin_x, Number(i.margin.margin_y)],
    [e - v - o, r.heights.vertical - S]
  ]), { links: R } = B(y), N = (M) => {
    var Z;
    let U = 30, re = 0, j = "node-value--storynode", de = !0;
    return (Z = A == null ? void 0 : A.storyNodeText) != null && Z.every((ge) => ge.StoryNode !== M) && (de = !1, re = 10, U = 8, j = "node-value"), { textPositionHorizontal: U, textPositionVertical: re, classStyle: j, storyNodes: de };
  }, D = (M) => {
    if (!(y != null && y.nodes))
      return { sourceNodes: [], activeLinks: [] };
    const U = y.nodes.find((de) => de.id === M), re = [], j = [];
    return U && (R.forEach((de) => {
      const Z = de.target, ge = de.source;
      Z.id === M && re.push(ge.id);
    }), re.forEach((de) => {
      R.forEach((Z) => {
        const ge = Z.target, ne = Z.source;
        ge.id === u && ne.id === de && j.push(Z);
      });
    })), { sourceNodes: re, activeLinks: j };
  }, L = US(A, u), q = y.nodes.map((M, U) => {
    var Se, ce;
    let { textPositionHorizontal: re, textPositionVertical: j, classStyle: de, storyNodes: Z } = N(M.id), { sourceNodes: ge } = D(u), ne = i.opacity.nodeOpacityDefault, G = i.nodeColor.default;
    u !== M.id && u !== "" && !ge.includes(M.id) && (G = i.nodeColor.inactive, ne = i.opacity.nodeOpacityInactive);
    const me = B.nodeWidth(), ye = () => Math.sqrt(
      Math.pow(R[0].target.x0 - R[0].source.x1, 2) + Math.pow(R[0].target.y0 - R[0].source.y1, 2)
    ) - o;
    return /* @__PURE__ */ O(qe, { className: "", children: [
      /* @__PURE__ */ a(
        "rect",
        {
          height: M.y1 - M.y0 + 2,
          width: me,
          x: M.x0,
          y: M.y0 - 1,
          fill: G,
          fillOpacity: ne,
          rx: i.rxValue,
          "data-tooltip-html": A.tooltips && r.enableTooltips && u !== "" ? L : null,
          "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
          onClick: () => x(M.id),
          style: { pointerEvents: "visible", cursor: "pointer" }
        }
      ),
      Z ? /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ a(
          ft,
          {
            width: ye(),
            x: M.x0 + re,
            textAnchor: y.nodes.length - 1 === U ? "end" : "start",
            verticalAnchor: "end",
            y: (M.y1 + M.y0) / 2 - 30,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            className: "node-text",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => x(M.id),
            "data-tooltip-html": A.tooltips && r.enableTooltips && u !== "" ? L : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: (((Se = A == null ? void 0 : A.storyNodeText) == null ? void 0 : Se.find((ke) => ke.StoryNode === M.id)) || {}).segmentTextBefore
          }
        ),
        /* @__PURE__ */ a(
          ft,
          {
            width: ye(),
            verticalAnchor: "middle",
            className: de,
            x: M.x0 + re,
            y: (M.y1 + M.y0 + 25) / 2,
            fill: i.storyNodeFontColor || i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => x(M.id),
            "data-tooltip-html": A.tooltips && r.enableTooltips && u !== "" ? L : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: typeof M.value == "number" ? M.value.toLocaleString() : M.value
          }
        ),
        /* @__PURE__ */ a(
          ft,
          {
            width: ye(),
            x: M.x0 + re,
            y: (M.y1 + M.y0) / 2 + 50,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: y.nodes.length === U ? "end" : "start",
            className: "node-text",
            verticalAnchor: "start",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => x(M.id),
            "data-tooltip-html": A.tooltips && r.enableTooltips && u !== "" ? L : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: (((ce = A == null ? void 0 : A.storyNodeText) == null ? void 0 : ce.find((ke) => ke.StoryNode === M.id)) || {}).segmentTextAfter
          }
        )
      ] }) : /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ a(
          ft,
          {
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => x(M.id),
            "data-tooltip-html": A.tooltips && r.enableTooltips && u !== "" ? L : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            x: M.x0 + re,
            y: (M.y1 + M.y0) / 2 + j,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            children: M.id
          }
        ),
        /* @__PURE__ */ a(
          "text",
          {
            x: M.x0 + re,
            y: (M.y1 + M.y0) / 2 + 30,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => x(M.id),
            "data-tooltip-html": A.tooltips && r.enableTooltips && u !== "" ? L : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: /* @__PURE__ */ a("tspan", { className: de, children: i.nodeValueStyle.textBefore + (typeof M.value == "number" ? M.value.toLocaleString() : M.value) + i.nodeValueStyle.textAfter })
          }
        )
      ] })
    ] }, U);
  }), V = R.map((M, U) => {
    const j = $S()(M);
    let de = i.opacity.LinkOpacityDefault, Z = i.linkColor.default, { activeLinks: ge } = D(u);
    return !ge.includes(M) && u !== "" && (Z = i.linkColor.inactive, de = i.opacity.LinkOpacityInactive), /* @__PURE__ */ a(
      "path",
      {
        d: j,
        stroke: Z,
        fill: "none",
        strokeOpacity: de,
        strokeWidth: M.width + 2,
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => x(M.target.id || null),
        "data-tooltip-html": A.tooltips && r.enableTooltips && u !== "" ? L : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      U
    );
  }), ae = y.nodes.reduce((M, U) => Math.max(M, U.depth), -1), Q = y.nodes.filter((M) => M.depth === ae).map((M, U) => {
    var me, ye;
    let { textPositionHorizontal: re, textPositionVertical: j, classStyle: de, storyNodes: Z } = N(M.id), { sourceNodes: ge } = D(u), ne = i.opacity.nodeOpacityDefault, G = i.nodeColor.default;
    return u !== M.id && u !== "" && !ge.includes(M.id) && (G = i.nodeColor.inactive, ne = i.opacity.nodeOpacityInactive), /* @__PURE__ */ O(qe, { className: "", innerRef: (Se) => g.current[U] = Se, children: [
      /* @__PURE__ */ a(
        "rect",
        {
          height: M.y1 - M.y0 + 2,
          width: B.nodeWidth(),
          x: M.x0,
          y: M.y0 - 1,
          fill: G,
          fillOpacity: ne,
          rx: i.rxValue,
          "data-tooltip-html": A.tooltips && r.enableTooltips && u !== "" ? L : null,
          "data-tooltip-id": "tooltip",
          onClick: () => x(M.id),
          style: { pointerEvents: "visible", cursor: "pointer" }
        }
      ),
      Z ? /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ a(
          ft,
          {
            x: M.x0 + re,
            textAnchor: y.nodes.length - 1 === U ? "end" : "start",
            verticalAnchor: "end",
            y: (M.y1 + M.y0) / 2 - 30,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            style: { pointerEvents: "none" },
            className: "node-text",
            children: (((me = A == null ? void 0 : A.storyNodeText) == null ? void 0 : me.find((Se) => Se.StoryNode === M.id)) || {}).segmentTextBefore
          }
        ),
        /* @__PURE__ */ a(
          ft,
          {
            verticalAnchor: "end",
            className: de,
            x: M.x0 + re,
            y: (M.y1 + M.y0 + 25) / 2,
            fill: i.storyNodeFontColor || i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "none" },
            children: typeof M.value == "number" ? M.value.toLocaleString() : M.value
          }
        ),
        /* @__PURE__ */ a(
          ft,
          {
            x: M.x0 + re,
            y: (M.y1 + M.y0) / 2 + 50,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: y.nodes.length === U ? "end" : "start",
            style: { pointerEvents: "none" },
            className: "node-text",
            verticalAnchor: "end",
            children: (((ye = A == null ? void 0 : A.storyNodeText) == null ? void 0 : ye.find((Se) => Se.StoryNode === M.id)) || {}).segmentTextAfter
          }
        )
      ] }) : /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ a(
          "text",
          {
            x: M.x0 + re,
            y: (M.y1 + M.y0) / 2 + j,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "none" },
            children: /* @__PURE__ */ a("tspan", { id: M.id, className: "node-id", children: M.id })
          }
        ),
        /* @__PURE__ */ a(
          "text",
          {
            x: M.x0 + re,
            y: (M.y1 + M.y0) / 2 + 30,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "none" },
            children: /* @__PURE__ */ a("tspan", { onClick: () => x(M.id), className: de, children: i.nodeValueStyle.textBefore + (typeof M.value == "number" ? M.value.toLocaleString() : M.value) + i.nodeValueStyle.textAfter })
          }
        )
      ] })
    ] }, U);
  });
  return p ? m : /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O("div", { className: "sankey-chart", children: [
    /* @__PURE__ */ O(
      "svg",
      {
        className: "sankey-chart__diagram",
        width: e,
        height: Number(r.heights.vertical),
        style: { overflow: "visible" },
        children: [
          /* @__PURE__ */ a(qe, { className: "links", children: V }),
          /* @__PURE__ */ a(qe, { className: "nodes", children: q }),
          /* @__PURE__ */ a(qe, { className: "finalNodes", style: { display: "none" }, children: Q })
        ]
      }
    ),
    /* @__PURE__ */ a(
      oc,
      {
        id: `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
        afterHide: () => d(""),
        events: ["click"],
        place: "bottom",
        style: {
          backgroundColor: "rgba(238, 238, 238, 1)",
          color: "black",
          boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)"
        }
      }
    )
  ] }) });
};
var YS = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const pr = YS;
function XS(e) {
  var t = e.labelOffset, n = e.labelProps, r = e.orientation, i = e.range, o = e.tickLabelFontSize, h = e.tickLength, u = r === pr.left || r === pr.top ? -1 : 1, d, p, m;
  if (r === pr.top || r === pr.bottom) {
    var g = r === pr.bottom && typeof n.fontSize == "number" ? n.fontSize : 0;
    d = (Number(i[0]) + Number(i[i.length - 1])) / 2, p = u * (h + t + o + g);
  } else
    d = u * ((Number(i[0]) + Number(i[i.length - 1])) / 2), p = -(h + t), m = "rotate(" + u * 90 + ")";
  return {
    x: d,
    y: p,
    transform: m
  };
}
function vl() {
  return vl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, vl.apply(this, arguments);
}
function qS(e) {
  var t = e.hideTicks, n = e.horizontal, r = e.orientation, i = e.tickClassName, o = e.tickComponent, h = e.tickLabelProps, u = e.tickStroke, d = u === void 0 ? "#222" : u, p = e.tickTransform, m = e.ticks, g = e.strokeWidth, x = e.tickLineProps;
  return m.map(function(A) {
    var k, y = A.value, v = A.index, S = A.from, B = A.to, R = A.formattedValue, N = (k = h[v]) != null ? k : {}, D = Math.max(10, typeof N.fontSize == "number" && N.fontSize || 0), L = B.y + (n && r !== pr.top ? D : 0);
    return /* @__PURE__ */ Me.createElement(qe, {
      key: "visx-tick-" + y + "-" + v,
      className: vn("visx-axis-tick", i),
      transform: p
    }, !t && /* @__PURE__ */ Me.createElement(ln, vl({
      from: S,
      to: B,
      stroke: d,
      strokeWidth: g,
      strokeLinecap: "square"
    }, x)), o ? o(vl({}, N, {
      x: B.x,
      y: L,
      formattedValue: R
    })) : /* @__PURE__ */ Me.createElement(ft, vl({
      x: B.x,
      y: L
    }, N), R));
  });
}
function bl() {
  return bl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, bl.apply(this, arguments);
}
var fm = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function ZS(e) {
  var t = e.axisFromPoint, n = e.axisLineClassName, r = e.axisToPoint, i = e.hideAxisLine, o = e.hideTicks, h = e.horizontal, u = e.label, d = u === void 0 ? "" : u, p = e.labelClassName, m = e.labelOffset, g = m === void 0 ? 14 : m, x = e.labelProps, A = e.orientation, k = A === void 0 ? pr.bottom : A, y = e.scale, v = e.stroke, S = v === void 0 ? "#222" : v, B = e.strokeDasharray, R = e.strokeWidth, N = R === void 0 ? 1 : R, D = e.tickClassName, L = e.tickComponent, q = e.tickLineProps, V = e.tickLabelProps, ae = e.tickLength, Y = ae === void 0 ? 8 : ae, Q = e.tickStroke, se = Q === void 0 ? "#222" : Q, ie = e.tickTransform, M = e.ticks, U = e.ticksComponent, re = U === void 0 ? qS : U, j = bl({}, fm, x), de = bl({}, fm, typeof V == "object" ? V : null), Z = M.map(function(ne) {
    var G = ne.value, me = ne.index;
    return typeof V == "function" ? V(G, me, M) : de;
  }), ge = Math.max.apply(Math, [10].concat(Z.map(function(ne) {
    return typeof ne.fontSize == "number" ? ne.fontSize : 0;
  })));
  return /* @__PURE__ */ Me.createElement(Me.Fragment, null, re({
    hideTicks: o,
    horizontal: h,
    orientation: k,
    scale: y,
    tickClassName: D,
    tickComponent: L,
    tickLabelProps: Z,
    tickStroke: se,
    tickTransform: ie,
    ticks: M,
    strokeWidth: N,
    tickLineProps: q
  }), !i && /* @__PURE__ */ Me.createElement(ln, {
    className: vn("visx-axis-line", n),
    from: t,
    to: r,
    stroke: S,
    strokeWidth: N,
    strokeDasharray: B
  }), d && /* @__PURE__ */ Me.createElement(ft, bl({
    className: vn("visx-axis-label", p)
  }, XS({
    labelOffset: g,
    labelProps: j,
    orientation: k,
    range: y.range(),
    tickLabelFontSize: ge,
    tickLength: Y
  }), j), d));
}
function QS(e, t) {
  t === void 0 && (t = "center");
  var n = e;
  if (t !== "start" && "bandwidth" in n) {
    var r = n.bandwidth();
    return t === "center" && (r /= 2), n.round() && (r = Math.round(r)), function(i) {
      var o = n(i);
      return typeof o == "number" ? o + r : o;
    };
  }
  return e;
}
function JS(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : _S;
}
function ju(e, t) {
  var n = e.x, r = e.y;
  return new Og(t ? {
    x: n,
    y: r
  } : {
    x: r,
    y: n
  });
}
function Uh() {
  return Uh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Uh.apply(this, arguments);
}
var ah = 0;
function ew(e) {
  return e === void 0 && (e = ah), typeof e == "number" ? {
    start: e,
    end: e
  } : Uh({
    start: ah,
    end: ah
  }, e);
}
var tw = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Gh() {
  return Gh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Gh.apply(this, arguments);
}
function nw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Yc(e) {
  var t = e.children, n = t === void 0 ? ZS : t, r = e.axisClassName, i = e.hideAxisLine, o = i === void 0 ? !1 : i, h = e.hideTicks, u = h === void 0 ? !1 : h, d = e.hideZero, p = d === void 0 ? !1 : d, m = e.innerRef, g = e.left, x = g === void 0 ? 0 : g, A = e.numTicks, k = A === void 0 ? 10 : A, y = e.orientation, v = y === void 0 ? pr.bottom : y, S = e.rangePadding, B = S === void 0 ? 0 : S, R = e.scale, N = e.tickFormat, D = e.tickLength, L = D === void 0 ? 8 : D, q = e.tickValues, V = e.top, ae = V === void 0 ? 0 : V, Y = nw(e, tw), Q = N ?? JS(R), se = v === pr.left, ie = v === pr.top, M = ie || v === pr.bottom, U = QS(R), re = se || ie ? -1 : 1, j = R.range(), de = ew(B), Z = ju({
    x: Number(j[0]) + 0.5 - de.start,
    y: 0
  }, M), ge = ju({
    x: Number(j[j.length - 1]) + 0.5 + de.end,
    y: 0
  }, M), ne = (q ?? pg(R, k)).filter(function(me) {
    return !p || me !== 0 && me !== "0";
  }).map(function(me, ye) {
    return {
      value: me,
      index: ye
    };
  }), G = ne.map(function(me) {
    var ye = me.value, Se = me.index, ce = ES(U(ye));
    return {
      value: ye,
      index: Se,
      from: ju({
        x: ce,
        y: 0
      }, M),
      to: ju({
        x: ce,
        y: L * re
      }, M),
      formattedValue: Q(ye, Se, ne)
    };
  });
  return /* @__PURE__ */ Me.createElement(qe, {
    className: vn("visx-axis", r),
    innerRef: m,
    top: ae,
    left: x
  }, n(Gh({}, Y, {
    axisFromPoint: Z,
    axisToPoint: ge,
    hideAxisLine: o,
    hideTicks: u,
    hideZero: p,
    horizontal: M,
    numTicks: k,
    orientation: v,
    rangePadding: B,
    scale: R,
    tickFormat: Q,
    tickLength: L,
    tickPosition: U,
    tickSign: re,
    ticks: G
  })));
}
var rw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Cc() {
  return Cc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Cc.apply(this, arguments);
}
function iw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var aw = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function pm(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 36 : n, i = e.tickLength, o = i === void 0 ? 8 : i, h = e.tickLabelProps, u = iw(e, rw), d = typeof h == "function" ? h : Cc({}, aw, h);
  return /* @__PURE__ */ Me.createElement(Yc, Cc({
    axisClassName: vn("visx-axis-left", t),
    labelOffset: r,
    orientation: pr.left,
    tickLabelProps: d,
    tickLength: o
  }, u));
}
var ow = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Ac() {
  return Ac = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ac.apply(this, arguments);
}
function sw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var lw = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function uw(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 36 : n, i = e.tickLength, o = i === void 0 ? 8 : i, h = e.tickLabelProps, u = sw(e, ow), d = typeof h == "function" ? h : Ac({}, lw, h);
  return /* @__PURE__ */ Me.createElement(Yc, Ac({
    axisClassName: vn("visx-axis-right", t),
    labelOffset: r,
    orientation: pr.right,
    tickLabelProps: d,
    tickLength: o
  }, u));
}
var cw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Lc() {
  return Lc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Lc.apply(this, arguments);
}
function dw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var hw = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function fw(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 8 : n, i = e.tickLength, o = i === void 0 ? 8 : i, h = e.tickLabelProps, u = dw(e, cw), d = typeof h == "function" ? h : Lc({}, hw, h);
  return /* @__PURE__ */ Me.createElement(Yc, Lc({
    axisClassName: vn("visx-axis-top", t),
    labelOffset: r,
    orientation: pr.top,
    tickLabelProps: d,
    tickLength: o
  }, u));
}
var pw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Ec() {
  return Ec = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ec.apply(this, arguments);
}
function mw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var yw = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function ec(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 8 : n, i = e.tickLength, o = i === void 0 ? 8 : i, h = e.tickLabelProps, u = mw(e, pw), d = typeof h == "function" ? h : Ec({}, yw, h);
  return /* @__PURE__ */ Me.createElement(Yc, Ec({
    axisClassName: vn("visx-axis-bottom", t),
    labelOffset: r,
    orientation: pr.bottom,
    tickLabelProps: d,
    tickLength: o
  }, u));
}
const oh = (e) => () => e;
function gw(e, {
  sourceEvent: t,
  target: n,
  selection: r,
  mode: i,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    selection: { value: r, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function vw(e) {
  e.stopImmediatePropagation();
}
function sh(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var mm = { name: "drag" }, lh = { name: "space" }, Yo = { name: "handle" }, Xo = { name: "center" };
const { abs: ym, max: tr, min: nr } = Math;
function gm(e) {
  return [+e[0], +e[1]];
}
function vm(e) {
  return [gm(e[0]), gm(e[1])];
}
var tc = {
  name: "x",
  handles: ["w", "e"].map(_c),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, uh = {
  name: "y",
  handles: ["n", "s"].map(_c),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, Si = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, bm = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, xm = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, bw = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, xw = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function _c(e) {
  return { type: e };
}
function Sw(e) {
  return !e.ctrlKey && !e.button;
}
function ww() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function kw() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function ch(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function Tw(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function Cw() {
  return Aw(tc);
}
function Aw(e) {
  var t = ww, n = Sw, r = kw, i = !0, o = Fg("start", "brush", "end"), h = 6, u;
  function d(v) {
    var S = v.property("__brush", y).selectAll(".overlay").data([_c("overlay")]);
    S.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", Si.overlay).merge(S).each(function() {
      var R = ch(this).extent;
      Zo(this).attr("x", R[0][0]).attr("y", R[0][1]).attr("width", R[1][0] - R[0][0]).attr("height", R[1][1] - R[0][1]);
    }), v.selectAll(".selection").data([_c("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", Si.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var B = v.selectAll(".handle").data(e.handles, function(R) {
      return R.type;
    });
    B.exit().remove(), B.enter().append("rect").attr("class", function(R) {
      return "handle handle--" + R.type;
    }).attr("cursor", function(R) {
      return Si[R.type];
    }), v.each(p).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", x).filter(r).on("touchstart.brush", x).on("touchmove.brush", A).on("touchend.brush touchcancel.brush", k).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  d.move = function(v, S, B) {
    v.tween ? v.on("start.brush", function(R) {
      m(this, arguments).beforestart().start(R);
    }).on("interrupt.brush end.brush", function(R) {
      m(this, arguments).end(R);
    }).tween("brush", function() {
      var R = this, N = R.__brush, D = m(R, arguments), L = N.selection, q = e.input(typeof S == "function" ? S.apply(this, arguments) : S, N.extent), V = bv(L, q);
      function ae(Y) {
        N.selection = Y === 1 && q === null ? null : V(Y), p.call(R), D.brush();
      }
      return L !== null && q !== null ? ae : ae(1);
    }) : v.each(function() {
      var R = this, N = arguments, D = R.__brush, L = e.input(typeof S == "function" ? S.apply(R, N) : S, D.extent), q = m(R, N).beforestart();
      Gf(R), D.selection = L === null ? null : L, p.call(R), q.start(B).brush(B).end(B);
    });
  }, d.clear = function(v, S) {
    d.move(v, null, S);
  };
  function p() {
    var v = Zo(this), S = ch(this).selection;
    S ? (v.selectAll(".selection").style("display", null).attr("x", S[0][0]).attr("y", S[0][1]).attr("width", S[1][0] - S[0][0]).attr("height", S[1][1] - S[0][1]), v.selectAll(".handle").style("display", null).attr("x", function(B) {
      return B.type[B.type.length - 1] === "e" ? S[1][0] - h / 2 : S[0][0] - h / 2;
    }).attr("y", function(B) {
      return B.type[0] === "s" ? S[1][1] - h / 2 : S[0][1] - h / 2;
    }).attr("width", function(B) {
      return B.type === "n" || B.type === "s" ? S[1][0] - S[0][0] + h : h;
    }).attr("height", function(B) {
      return B.type === "e" || B.type === "w" ? S[1][1] - S[0][1] + h : h;
    })) : v.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function m(v, S, B) {
    var R = v.__brush.emitter;
    return R && (!B || !R.clean) ? R : new g(v, S, B);
  }
  function g(v, S, B) {
    this.that = v, this.args = S, this.state = v.__brush, this.active = 0, this.clean = B;
  }
  g.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(v, S) {
      return this.starting ? (this.starting = !1, this.emit("start", v, S)) : this.emit("brush", v), this;
    },
    brush: function(v, S) {
      return this.emit("brush", v, S), this;
    },
    end: function(v, S) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", v, S)), this;
    },
    emit: function(v, S, B) {
      var R = Zo(this.that).datum();
      o.call(
        v,
        this.that,
        new gw(v, {
          sourceEvent: S,
          target: d,
          selection: e.output(this.state.selection),
          mode: B,
          dispatch: o
        }),
        R
      );
    }
  };
  function x(v) {
    if (u && !v.touches || !n.apply(this, arguments))
      return;
    var S = this, B = v.target.__data__.type, R = (i && v.metaKey ? B = "overlay" : B) === "selection" ? mm : i && v.altKey ? Xo : Yo, N = e === uh ? null : bw[B], D = e === tc ? null : xw[B], L = ch(S), q = L.extent, V = L.selection, ae = q[0][0], Y, Q, se = q[0][1], ie, M, U = q[1][0], re, j, de = q[1][1], Z, ge, ne = 0, G = 0, me, ye = N && D && i && v.shiftKey, Se, ce, ke = Array.from(v.touches || [v], (Ye) => {
      const Je = Ye.identifier;
      return Ye = Yf(Ye, S), Ye.point0 = Ye.slice(), Ye.identifier = Je, Ye;
    });
    Gf(S);
    var Ie = m(S, arguments, !0).beforestart();
    if (B === "overlay") {
      V && (me = !0);
      const Ye = [ke[0], ke[1] || ke[0]];
      L.selection = V = [[
        Y = e === uh ? ae : nr(Ye[0][0], Ye[1][0]),
        ie = e === tc ? se : nr(Ye[0][1], Ye[1][1])
      ], [
        re = e === uh ? U : tr(Ye[0][0], Ye[1][0]),
        Z = e === tc ? de : tr(Ye[0][1], Ye[1][1])
      ]], ke.length > 1 && ot(v);
    } else
      Y = V[0][0], ie = V[0][1], re = V[1][0], Z = V[1][1];
    Q = Y, M = ie, j = re, ge = Z;
    var Le = Zo(S).attr("pointer-events", "none"), Fe = Le.selectAll(".overlay").attr("cursor", Si[B]);
    if (v.touches)
      Ie.moved = Be, Ie.ended = gt;
    else {
      var Xe = Zo(v.view).on("mousemove.brush", Be, !0).on("mouseup.brush", gt, !0);
      i && Xe.on("keydown.brush", st, !0).on("keyup.brush", dt, !0), Mg(v.view);
    }
    p.call(S), Ie.start(v, R.name);
    function Be(Ye) {
      for (const Je of Ye.changedTouches || [Ye])
        for (const yt of ke)
          yt.identifier === Je.identifier && (yt.cur = Yf(Je, S));
      if (ye && !Se && !ce && ke.length === 1) {
        const Je = ke[0];
        ym(Je.cur[0] - Je[0]) > ym(Je.cur[1] - Je[1]) ? ce = !0 : Se = !0;
      }
      for (const Je of ke)
        Je.cur && (Je[0] = Je.cur[0], Je[1] = Je.cur[1]);
      me = !0, sh(Ye), ot(Ye);
    }
    function ot(Ye) {
      const Je = ke[0], yt = Je.point0;
      var nt;
      switch (ne = Je[0] - yt[0], G = Je[1] - yt[1], R) {
        case lh:
        case mm: {
          N && (ne = tr(ae - Y, nr(U - re, ne)), Q = Y + ne, j = re + ne), D && (G = tr(se - ie, nr(de - Z, G)), M = ie + G, ge = Z + G);
          break;
        }
        case Yo: {
          ke[1] ? (N && (Q = tr(ae, nr(U, ke[0][0])), j = tr(ae, nr(U, ke[1][0])), N = 1), D && (M = tr(se, nr(de, ke[0][1])), ge = tr(se, nr(de, ke[1][1])), D = 1)) : (N < 0 ? (ne = tr(ae - Y, nr(U - Y, ne)), Q = Y + ne, j = re) : N > 0 && (ne = tr(ae - re, nr(U - re, ne)), Q = Y, j = re + ne), D < 0 ? (G = tr(se - ie, nr(de - ie, G)), M = ie + G, ge = Z) : D > 0 && (G = tr(se - Z, nr(de - Z, G)), M = ie, ge = Z + G));
          break;
        }
        case Xo: {
          N && (Q = tr(ae, nr(U, Y - ne * N)), j = tr(ae, nr(U, re + ne * N))), D && (M = tr(se, nr(de, ie - G * D)), ge = tr(se, nr(de, Z + G * D)));
          break;
        }
      }
      j < Q && (N *= -1, nt = Y, Y = re, re = nt, nt = Q, Q = j, j = nt, B in bm && Fe.attr("cursor", Si[B = bm[B]])), ge < M && (D *= -1, nt = ie, ie = Z, Z = nt, nt = M, M = ge, ge = nt, B in xm && Fe.attr("cursor", Si[B = xm[B]])), L.selection && (V = L.selection), Se && (Q = V[0][0], j = V[1][0]), ce && (M = V[0][1], ge = V[1][1]), (V[0][0] !== Q || V[0][1] !== M || V[1][0] !== j || V[1][1] !== ge) && (L.selection = [[Q, M], [j, ge]], p.call(S), Ie.brush(Ye, R.name));
    }
    function gt(Ye) {
      if (vw(Ye), Ye.touches) {
        if (Ye.touches.length)
          return;
        u && clearTimeout(u), u = setTimeout(function() {
          u = null;
        }, 500);
      } else
        Ig(Ye.view, me), Xe.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      Le.attr("pointer-events", "all"), Fe.attr("cursor", Si.overlay), L.selection && (V = L.selection), Tw(V) && (L.selection = null, p.call(S)), Ie.end(Ye, R.name);
    }
    function st(Ye) {
      switch (Ye.keyCode) {
        case 16: {
          ye = N && D;
          break;
        }
        case 18: {
          R === Yo && (N && (re = j - ne * N, Y = Q + ne * N), D && (Z = ge - G * D, ie = M + G * D), R = Xo, ot(Ye));
          break;
        }
        case 32: {
          (R === Yo || R === Xo) && (N < 0 ? re = j - ne : N > 0 && (Y = Q - ne), D < 0 ? Z = ge - G : D > 0 && (ie = M - G), R = lh, Fe.attr("cursor", Si.selection), ot(Ye));
          break;
        }
        default:
          return;
      }
      sh(Ye);
    }
    function dt(Ye) {
      switch (Ye.keyCode) {
        case 16: {
          ye && (Se = ce = ye = !1, ot(Ye));
          break;
        }
        case 18: {
          R === Xo && (N < 0 ? re = j : N > 0 && (Y = Q), D < 0 ? Z = ge : D > 0 && (ie = M), R = Yo, ot(Ye));
          break;
        }
        case 32: {
          R === lh && (Ye.altKey ? (N && (re = j - ne * N, Y = Q + ne * N), D && (Z = ge - G * D, ie = M + G * D), R = Xo) : (N < 0 ? re = j : N > 0 && (Y = Q), D < 0 ? Z = ge : D > 0 && (ie = M), R = Yo), Fe.attr("cursor", Si[B]), ot(Ye));
          break;
        }
        default:
          return;
      }
      sh(Ye);
    }
  }
  function A(v) {
    m(this, arguments).moved(v);
  }
  function k(v) {
    m(this, arguments).ended(v);
  }
  function y() {
    var v = this.__brush || { selection: null };
    return v.extent = vm(t.apply(this, arguments)), v.dim = e, v;
  }
  return d.extent = function(v) {
    return arguments.length ? (t = typeof v == "function" ? v : oh(vm(v)), d) : t;
  }, d.filter = function(v) {
    return arguments.length ? (n = typeof v == "function" ? v : oh(!!v), d) : n;
  }, d.touchable = function(v) {
    return arguments.length ? (r = typeof v == "function" ? v : oh(!!v), d) : r;
  }, d.handleSize = function(v) {
    return arguments.length ? (h = +v, d) : h;
  }, d.keyModifiers = function(v) {
    return arguments.length ? (i = !!v, d) : i;
  }, d.on = function() {
    var v = o.on.apply(o, arguments);
    return v === o ? d : v;
  }, d;
}
const Lw = ({ xMax: e, yMax: t }) => {
  var M, U;
  const { tableData: n, config: r, dashboardConfig: i, formatDate: o, parseDate: h } = he.useContext(pt), u = he.useContext(ef), [d, p] = he.useState({ isBrushing: !1, selection: [] }), [m, g] = he.useState(0), x = ((M = i == null ? void 0 : i.dashboard) == null ? void 0 : M.sharedFilters) ?? [], A = (x == null ? void 0 : x.length) > 0, [k, y] = he.useState(!1), v = he.useRef(), S = 25, B = 15, R = Bg(n, (re) => new Date(re[r.runtime.originalXAxis.dataKey])), N = fg().domain(R).range([0, e]), L = yr("Drag edges to focus on a specific segment ", `normal ${16 / 1.1}px sans-serif`), q = 50, V = 1.5, ae = () => (i == null ? void 0 : i.type) === "dashboard" ? Number(t) + r.xAxis.axisBBox + S * V + q : Number(t) + r.xAxis.axisBBox + S * V, Y = () => {
    d.selection[0] === 0 && e === d.selection[1] && y(!0);
  }, Q = () => {
    (d.selection[0] !== 0 || d.selection[1] !== e) && y(!1), y(!1);
  }, se = (re, j, de, Z) => {
    const ge = yr(de, `normal ${14.545454545454545}px sans-serif`), ne = j[0] < ge ? 0 : -ge, G = e - j[1] < ge ? -ge : 0;
    return re.selectAll(".handle--custom").data([{ side: "left" }, { side: "right" }]).join((me) => {
      const ye = me.append("g").attr("class", "handle--custom");
      return ye.append("text").attr("x", (Se) => Se.side === "left" ? ne : G).attr("y", 30).text((Se) => Se.side === "left" ? de : Z).attr("font-size", "13px"), ye;
    }).attr("display", "block").attr("transform", j === null ? null : (me, ye) => `translate(${j[ye]},10)`);
  }, ie = () => {
    const re = Zo(v.current).attr("overflow", "visible");
    re.append("rect").attr("fill", "#949494").attr("stroke", "#c5c5c5").attr("stroke-width", 2).attr("ry", B).attr("rx", B).attr("height", S).attr("width", e);
    const j = (ne) => {
      const G = ne == null ? void 0 : ne.selection;
      let me = ne.type === "brush" && G && G.length > 0;
      const [ye, Se] = G.map((dt) => N.invert(dt)), ce = Ke.filter(n, (dt) => {
        const Ye = new Date(dt[r.xAxis.dataKey]);
        return Ye && !isNaN(Ye.getTime()) && Ye >= ye && Ye <= Se;
      }), ke = r.xAxis.sortByRecentDate, Ie = Ke.sortBy(ce, (dt) => new Date(dt[r.xAxis.dataKey])), Le = ke ? Ie.reverse() : Ie, Fe = Ke.get(Ke.first(Le), r.xAxis.dataKey, ""), Xe = Ke.get(Ke.last(Le), r.xAxis.dataKey, "");
      re.selectAll(".handle--custom").remove();
      const Be = (dt) => dt ? o(h(dt)) : "", ot = Be(Fe), gt = Be(Xe);
      re.call(se, G, ot, gt);
      const st = {
        active: r.brush.active,
        isBrushing: me,
        data: Le
      };
      u({ type: "SET_BRUSH_CONFIG", payload: st }), p({
        isBrushing: !0,
        selection: G
      });
    }, de = Cw().extent([
      [0, 0],
      [e, 25]
    ]).on("start brush end", j), Z = [0, e];
    let ge = re.append("g").call(de).call(de.move, Z);
    ge.select(".overlay").style("pointer-events", "none"), ge.selectAll(".selection").attr("fill", "#474747").attr("fill-opacity", 1).attr("rx", B).attr("ry", B);
  };
  return he.useEffect(() => {
    var de, Z, ge;
    const re = (de = r.filters) == null ? void 0 : de.some((ne) => ne.active), j = (Z = r.exclusions) == null ? void 0 : Z.active;
    return (re || j || A) && ((ge = r.brush) != null && ge.active) && g((ne) => ne + 1), u({ type: "SET_BRUSH_CONFIG", payload: { ...r.brush, data: n } }), () => u({ type: "SET_BRUSH_CONFIG", payload: { ...r.brush, data: [] } });
  }, [r.filters, r.exclusions, (U = r.brush) == null ? void 0 : U.active, A]), he.useEffect(() => {
    let re = null;
    const j = () => {
      e > 0 ? ie() : (clearTimeout(re), re = setTimeout(j, 500));
    };
    return j(), () => {
      re && clearTimeout(re);
    };
  }, [e]), he.useEffect(() => {
    m && ie();
  }, [m]), d.isBrushing || ie(), /* @__PURE__ */ O(
    qe,
    {
      onMouseLeave: Q,
      onMouseOver: Y,
      className: "brush-container",
      left: Number(r.runtime.yAxis.size),
      top: ae(),
      children: [
        /* @__PURE__ */ a(
          ft,
          {
            pointerEvents: "visiblePainted",
            display: k ? "block" : "none",
            fontSize: 16,
            x: (Number(e) - Number(L)) / 2,
            y: -10,
            children: "Drag edges to focus on a specific segment"
          }
        ),
        /* @__PURE__ */ a("svg", { width: "100%", height: S * 3, ref: v })
      ]
    }
  );
}, $a = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: Qx,
  curveBasisClosed: Jx,
  curveBasisOpen: e0,
  curveBundle: t0,
  curveCardinal: n0,
  curveCardinalClosed: r0,
  curveCardinalOpen: i0,
  curveCatmullRom: a0,
  curveCatmullRomClosed: o0,
  curveCatmullRomOpen: s0,
  curveLinear: Kc,
  curveLinearClosed: Ph,
  curveMonotoneX: Ju,
  curveMonotoneY: l0,
  curveNatural: u0,
  curveStep: c0,
  curveStepAfter: h0,
  curveStepBefore: d0
}, Symbol.toStringTag, { value: "Module" })), Ew = (e) => {
  var L, q;
  const { xScale: t, yScale: n, yMax: r, xMax: i, handleTooltipMouseOver: o, handleTooltipMouseOff: h, isDebug: u, children: d } = e;
  let {
    transformedData: p,
    config: m,
    handleLineType: g,
    parseDate: x,
    formatDate: A,
    formatNumber: k,
    seriesHighlight: y,
    colorScale: v,
    rawData: S,
    brushConfig: B
  } = he.useContext(pt);
  const R = (L = m.brush) != null && L.active && ((q = B.data) != null && q.length) ? B.data : p;
  if (!R)
    return;
  const N = (V) => (En(m.xAxis) ? t(x(V[m.xAxis.dataKey], !1)) : t(V[m.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), D = (V, ae, Y = void 0) => n(V[Y.dataKey]);
  return R && /* @__PURE__ */ a("svg", { children: /* @__PURE__ */ a(qr, { component: "AreaChart", children: /* @__PURE__ */ O(qe, { className: "area-chart", left: Number(m.yAxis.size), children: [
    (m.runtime.areaSeriesKeys || m.series).map((V, ae) => {
      let Y = R.map((M) => ({
        [m.xAxis.dataKey]: M[m.xAxis.dataKey],
        [V.dataKey]: M[V.dataKey]
      })), Q = $a[V.lineType], se = m.legend.behavior === "highlight" && y.length > 0 && y.indexOf(V.dataKey) === -1, ie = m.legend.behavior === "highlight" || y.length === 0 || y.indexOf(V.dataKey) !== -1;
      return /* @__PURE__ */ O(Me.Fragment, { children: [
        /* @__PURE__ */ a(
          Yr,
          {
            data: Y,
            x: (M) => N(M),
            y: (M) => D(M, ae, V),
            stroke: ie ? v ? v(m.runtime.seriesLabels ? m.runtime.seriesLabels[V.dataKey] : V.dataKey) : "#000" : "transparent",
            strokeWidth: 2,
            strokeOpacity: 1,
            shapeRendering: "geometricPrecision",
            curve: Q,
            strokeDasharray: V.type ? g(V.type) : 0
          }
        ),
        /* @__PURE__ */ a(
          Mh,
          {
            fill: ie ? v ? v(m.runtime.seriesLabels ? m.runtime.seriesLabels[V.dataKey] : V.dataKey) : "#000" : "transparent",
            fillOpacity: se ? 0.25 : 0.5,
            data: Y,
            x: (M) => N(M),
            y: (M) => D(M, ae, V),
            yScale: n,
            curve: Q,
            strokeDasharray: V.type ? g(V.type) : 0
          },
          "area-chart"
        )
      ] }, ae);
    }),
    /* @__PURE__ */ a(
      Er,
      {
        width: Number(i),
        height: Number(r),
        fill: "transparent",
        fillOpacity: 0.05,
        onMouseMove: (V) => o(V, S),
        onMouseLeave: h
      }
    )
  ] }, "area-wrapper") }) });
};
he.memo(Ew);
const _w = ({ xScale: e, yScale: t, yMax: n, xMax: r, handleTooltipMouseOver: i, handleTooltipMouseOff: o, isDebug: h }) => {
  var y, v;
  let { transformedData: u, config: d, seriesHighlight: p, colorScale: m, rawData: g } = he.useContext(pt);
  const x = (y = d.brush) != null && y.active && ((v = d.brush.data) != null && v.length) ? d.brush.data : u;
  if (!x)
    return;
  const A = (S) => {
    if (d.xAxis.type === "categorical")
      return e(S);
    if (En(d.xAxis)) {
      let B = new Date(S);
      return e(B);
    }
  }, k = 2;
  return x && /* @__PURE__ */ a("svg", { height: Number(n), children: /* @__PURE__ */ a(qr, { component: "AreaChartStacked", children: /* @__PURE__ */ O(
    qe,
    {
      className: "area-chart",
      left: Number(d.yAxis.size) + k / 2,
      height: Number(n),
      style: { overflow: "hidden" },
      children: [
        /* @__PURE__ */ a(
          W0,
          {
            data: x,
            keys: d.runtime.areaSeriesKeys.map((S) => S.dataKey) || d.series.map((S) => S.dataKey),
            x0: (S) => A(S.data[d.xAxis.dataKey]),
            y0: (S) => Number(t(S[0])),
            y1: (S) => Number(t(S[1])),
            curve: $a[as[d.stackedAreaChartLineType]],
            children: ({ stacks: S, path: B }) => S.map((R, N) => {
              let D = d.legend.behavior === "highlight" && p.length > 0 && p.indexOf(R.key) === -1, L = d.legend.behavior === "highlight" || p.length === 0 || p.indexOf(R.key) !== -1;
              return (
                // prettier-ignore
                /* @__PURE__ */ a(
                  "path",
                  {
                    d: B(R) || "",
                    strokeWidth: 2,
                    stroke: L ? m ? m(d.runtime.seriesLabels ? d.runtime.seriesLabels[R.key] : R.key) : "#000" : "transparent",
                    fillOpacity: D ? 0.2 : 1,
                    fill: L ? m ? m(d.runtime.seriesLabels ? d.runtime.seriesLabels[R.key] : R.key) : "#000" : "transparent"
                  },
                  R.key
                )
              );
            })
          }
        ),
        /* @__PURE__ */ a(Er, { width: Number(r), height: Number(n), fill: "transparent", onMouseMove: (S) => i(S, g), onMouseLeave: o })
      ]
    },
    "area-wrapper"
  ) }) });
}, Pw = he.memo(_w), zl = he.createContext(null), Of = ({
  xScale: e,
  barWidth: t = 0,
  totalBarsInGroup: n = 1,
  yMax: r,
  handleTooltipMouseOff: i,
  handleTooltipMouseOver: o,
  handleTooltipClick: h,
  tooltipData: u,
  showTooltip: d,
  hideTooltip: p
}) => {
  const { parseDate: m, config: g } = he.useContext(pt), { runtime: x, regions: A, visualizationType: k, orientation: y, xAxis: v } = g, S = e.domain(), B = (D) => {
    let L;
    if (!(D != null && D.fromType) || D.fromType === "Fixed") {
      const q = new Date(D.from), V = m(al(g.xAxis.dateParseFormat, q)).getTime();
      L = e(V), k === "Bar" && v.type === "date-time" && (L = L - t * n / 2);
    }
    if (D.fromType === "Previous Days") {
      const q = Number(D.from) || 0;
      S.map((Q) => al(g.xAxis.dateParseFormat, new Date(Q)));
      const V = D.toType === "Last Date" ? new Date(S[S.length - 1]).getTime() : new Date(D.to), ae = g.xAxis.type === "categorical" ? al(g.xAxis.dateParseFormat, V) : al(g.xAxis.dateParseFormat, V), Y = new Date(ae);
      if (L = new Date(Y.setDate(Y.getDate() - Number(q))), v.type === "date") {
        L = new Date(al(v.dateParseFormat, L)).getTime();
        let Q = S[0], se = Math.abs(L - Q);
        for (let ie = 1; ie < S.length; ie++) {
          const M = Math.abs(L - S[ie]);
          M < se && (se = M, Q = S[ie]);
        }
        L = Q;
      }
      if (v.type === "categorical") {
        let Q = S[0], se = Math.abs(new Date(L).getTime() - new Date(Q).getTime());
        for (let ie = 1; ie < S.length; ie++) {
          const M = Math.abs(new Date(L).getTime() - new Date(S[ie]).getTime());
          M < se && (se = M, Q = S[ie]);
        }
        L = Q;
      }
      L = e(L);
    }
    if (v.type === "categorical" && D.fromType !== "Previous Days" && (L = e(D.from)), k === "Line" || k === "Area Chart") {
      let q = Number(g.yAxis.size);
      e.bandwidth && (q += e.bandwidth() / 2), L = L + q;
    }
    return k === "Bar" && g.xAxis.type === "date-time" && D.fromType === "Previous Days" && (L = L - t * n / 2), L;
  }, R = (D) => {
    let L;
    if (v.type === "categorical" && (L = e(D.to)), En(v) && ((!(D != null && D.toType) || D.toType === "Fixed") && (L = e(m(D.to).getTime())), (k === "Bar" || g.visualizationType === "Combo") && (L = D.toType !== "Last Date" ? e(m(D.to).getTime()) + t * n : L)), D.toType === "Last Date") {
      const q = S[S.length - 1];
      L = Number(
        e(q) + ((k === "Bar" || k === "Combo") && g.xAxis.type === "date" ? t * n : 0)
      );
    }
    if (k === "Line" || k === "Area Chart") {
      let q = Number(g.yAxis.size);
      e.bandwidth && (q += e.bandwidth() / 2), L = L + q;
    }
    return k === "Bar" && g.xAxis.type === "date-time" && D.toType !== "Last Date" && (L = L - t * n / 2), (k === "Bar" || k === "Combo") && v.type === "categorical" && (L = L + (k === "Bar" || k === "Combo" ? t * n : 0)), L;
  }, N = (D, L) => D - L;
  if (A && y === "vertical")
    return A.map((D) => {
      const L = B(D), q = R(D), V = N(q, L);
      if (!L || !q)
        return null;
      const ae = () => /* @__PURE__ */ a("rect", { x: L, y: 0, width: V, height: r, fill: D.background, opacity: 0.3 });
      return /* @__PURE__ */ O(
        qe,
        {
          height: 100,
          fill: "red",
          className: "regions regions-group--line zzz",
          onMouseMove: o,
          onMouseLeave: i,
          handleTooltipClick: h,
          tooltipData: JSON.stringify(u),
          showTooltip: d,
          children: [
            /* @__PURE__ */ a(ae, {}),
            /* @__PURE__ */ a(ft, { x: L + V / 2, y: 5, fill: D.color, verticalAnchor: "start", textAnchor: "middle", children: D.label })
          ]
        },
        D.label
      );
    });
};
function $l(e) {
  var G, me;
  const { config: t, index: n, id: r, className: i, background: o, borderColor: h, borderWidth: u, width: d, height: p, x: m, y: g, onMouseOver: x, onMouseLeave: A, onClick: k, tooltipHtml: y, tooltipId: v, styleOverrides: S, seriesHighlight: B, type: R } = e, N = Math.max(0, d), D = Math.max(0, p), L = t.orientation === "horizontal", q = t.barStyle === "rounded", V = t.visualizationSubType === "stacked", ae = t.tipRounding, Y = t.visualizationType === "Combo" && ((me = (G = t.runtime) == null ? void 0 : G.barSeriesKeys) == null ? void 0 : me.length), Q = t.runtime.seriesKeys.length, se = t.visualizationType === "Bar" && t.legend.axisAlign && (B != null && B.length) ? B == null ? void 0 : B.length : 0, ie = Y || se || Q;
  let M = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  (M > N / 2 || M > D / 2) && (M = Math.min(N / 2, D / 2));
  const U = () => `M${m},${g + D}
      L${m},${g + M}
      Q${m},${g} ${m + M},${g}
      L${m + N - M},${g}
      Q${m + N},${g} ${m + N},${g + M}
      L${m + N},${g + D}
      L${m},${g + D}`, re = () => `M${m},${g + D}
      L${m},${g}
      L${m + N - M},${g}
      Q${m + N},${g} ${m + N},${g + M}
      L${m + N},${g + D - M}
      Q${m + N},${g + D} ${m + N - M},${g + D}
      L${m},${g + D}`, j = () => `M${m + M},${g + D}
      Q${m},${g + D} ${m},${g + D - M}
      L${m},${g}
      L${m + N},${g}
      L${m + N},${g + D - M}
      Q${m + N},${g + D} ${m + N - M},${g + D}
      L${m + M},${g + D}`, de = () => `M${m + M},${g + D}
      Q${m},${g + D} ${m},${g + D - M}
      L${m},${g + M}
      Q${m},${g} ${m + M},${g}
      L${m + N},${g}
      L${m + N},${g + D}
      L${m + M},${g + D}`, Z = () => `M${m + M},${g + D}
      Q${m},${g + D} ${m},${g + D - M}
      L${m},${g + M}
      Q${m},${g} ${m + M},${g}
      L${m + N - M},${g}
      Q${m + N},${g} ${m + N},${g + M}
      L${m + N},${g + D - M}
      Q${m + N},${g + D} ${m + N - M},${g + D}
      L${m + M},${g + D}`, ge = () => `M${m},${g}
      L${m + N},${g}
      L${m + N},${g + D}
      L${m},${g + D}
      L${m},${g}`;
  let ne;
  return n == null || !q || R == "axisBar" ? ne = ge() : (ne = ge(), (V && n + 1 === ie || !V) && (ne = L ? re() : U()), !V && n === -1 && (ne = L ? de() : j()), ae === "full" && V && n === 0 && ie > 1 && (ne = L ? de() : j()), ae === "full" && (V && n === 0 && ie === 1 || !V) && (ne = Z())), /* @__PURE__ */ a(
    "path",
    {
      id: r,
      className: i,
      d: ne,
      fill: o,
      stroke: h,
      strokeWidth: u,
      onMouseOver: x,
      onMouseLeave: A,
      onClick: k,
      "data-tooltip-html": y,
      "data-tooltip-id": v,
      style: {
        transition: "all 0.2s linear",
        ...S
      }
    }
  );
}
const Nw = () => {
  const [e, t] = he.useState(0), { xScale: n, yScale: r, seriesScale: i, xMax: o, yMax: h, barChart: u } = he.useContext(zl), {
    isHorizontal: d,
    barBorderWidth: p,
    hoveredBar: m,
    getAdditionalColumn: g,
    onMouseLeaveBar: x,
    onMouseOverBar: A,
    barStackedSeriesKeys: k
  } = u, {
    transformedData: y,
    colorScale: v,
    seriesHighlight: S,
    config: B,
    formatNumber: R,
    formatDate: N,
    parseDate: D,
    setSharedFilter: L,
    brushConfig: q
  } = he.useContext(pt), { orientation: V } = B;
  let ae = y;
  q.data.length && (ae = q.data);
  const Y = B.runtime.xAxis.type === "date-time" || B.runtime.xAxis.type === "date", Q = B.runtime.xAxis.type === "date-time";
  return B.visualizationSubType === "stacked" && !d && /* @__PURE__ */ O(ze, { children: [
    /* @__PURE__ */ a(
      tg,
      {
        data: ae,
        keys: k,
        x: (se) => se[B.runtime.xAxis.dataKey],
        xScale: n,
        yScale: r,
        color: v,
        children: (se) => se.reverse().map(
          (ie) => ie.bars.map((M) => {
            let U = B.legend.behavior === "highlight" && S.length > 0 && S.indexOf(M.key) === -1, re = B.legend.behavior === "highlight" || S.length === 0 || S.indexOf(M.key) !== -1, j = Y ? i.range()[1] - i.range()[0] : o / ie.bars.length;
            B.runtime.xAxis.type !== "date" && (j = B.barThickness * j);
            const de = M.bar.data[B.runtime.xAxis.dataKey], Z = Y ? N(D(de)) : de, ge = R(M.bar ? M.bar.data[M.key] : 0, "left");
            if (!ge)
              return;
            const ne = n(Y ? D(de) : de) - (Q ? j / 2 : 0), G = B.runtime.xAxis.label ? `${B.runtime.xAxis.label}: ${Z}` : Z, me = g(M.key, m), ye = `${B.runtime.seriesLabels[M.key]}: ${ge}`, Se = `<ul>
                  <li class="tooltip-heading"">${G}</li>
                  <li class="tooltip-body ">${ye}</li>
                  <li class="tooltip-body ">${me}</li>
                    </li></ul>`;
            return t(j), /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ a(
              qe,
              {
                id: `barStack${ie.index}-${M.index}`,
                className: "stack vertical",
                children: $l({
                  config: B,
                  seriesHighlight: S,
                  index: ie.index,
                  background: v(B.runtime.seriesLabels[M.key]),
                  borderColor: "#333",
                  borderStyle: "solid",
                  borderWidth: `${B.barHasBorder === "true" ? p : 0}px`,
                  width: j,
                  height: M.height,
                  x: ne,
                  y: M.y,
                  onMouseOver: (ce) => A(Z, M.key, ce, ae),
                  onMouseLeave: x,
                  tooltipHtml: Se,
                  tooltipId: `cdc-open-viz-tooltip-${B.runtime.uniqueId}`,
                  onClick: (ce) => {
                    ce.preventDefault(), L && (M[B.xAxis.dataKey] = Z, L(B.uid, M));
                  },
                  styleOverrides: {
                    animationDelay: `${ie.index * 0.5}s`,
                    transformOrigin: `${j / 2}px ${M.y + M.height}px`,
                    opacity: U ? 0.2 : 1,
                    display: re ? "block" : "none"
                  }
                })
              },
              `bar-stack-${ie.index}-${M.index}`
            ) }, `${ie.index}--${M.index}--${V}`);
          })
        )
      }
    ),
    /* @__PURE__ */ a(Of, { xScale: n, yMax: h, barWidth: e, totalBarsInGroup: 1 })
  ] });
}, Rw = () => {
  const { yMax: e, yScale: t, xScale: n, barChart: r } = he.useContext(zl), {
    animatedChart: i,
    colorScale: o,
    config: h,
    formatDate: u,
    formatNumber: d,
    parseDate: p,
    seriesHighlight: m,
    setSharedFilter: g,
    transformedData: x
  } = he.useContext(pt), {
    barBorderWidth: A,
    displayNumbersOnBar: k,
    getAdditionalColumn: y,
    hoveredBar: v,
    isHorizontal: S,
    isLabelBelowBar: B,
    onMouseLeaveBar: R,
    onMouseOverBar: N,
    barStackedSeriesKeys: D
  } = r, { orientation: L, visualizationSubType: q } = h;
  return h.visualizationSubType === "stacked" && S && /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ a(
    q0,
    {
      data: x,
      keys: D,
      height: e,
      y: (V) => V[h.runtime.yAxis.dataKey],
      xScale: n,
      yScale: t,
      color: o,
      offset: "none",
      children: (V) => V.map(
        (ae) => _f(h, ae.bars).map((Y, Q) => {
          const se = h.legend.behavior === "highlight" && m.length > 0 && m.indexOf(Y.key) === -1, ie = h.legend.behavior === "highlight" || m.length === 0 || m.indexOf(Y.key) !== -1;
          h.barHeight = Number(h.barHeight);
          let M = o(h.runtime.seriesLabels[Y.key]), U = is(Ir, M);
          _m(Ir, M) < 7 && (U = "#fff");
          const de = d(x[Y.index][Y.key], "left"), Z = h.runtime.yAxis.type === "date" ? u(p(x[Y.index][h.runtime.originalXAxis.dataKey])) : x[Y.index][h.runtime.originalXAxis.dataKey], ge = h.runtime.yAxis.label ? `${h.runtime.yAxis.label}: ${Z}` : Z, ne = yr(de), G = y(Y.key, v), me = `${h.runtime.seriesLabels[Y.key]}: ${de}`, ye = `<ul>
                  <li class="tooltip-heading"">${ge}</li>
                  <li class="tooltip-body ">${me}</li>
                  <li class="tooltip-body ">${G}</li>
                    </li></ul>`;
          return /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O(qe, { id: `barStack${ae.index}-${Y.index}`, className: "stack horizontal", children: [
            $l({
              config: h,
              seriesHighlight: m,
              index: ae.index,
              className: `animated-chart group ${i ? "animated" : ""}`,
              background: o(h.runtime.seriesLabels[Y.key]),
              borderColor: "#333",
              borderStyle: "solid",
              borderWidth: `${h.barHasBorder === "true" ? A : 0}px`,
              width: Y.width,
              height: Y.height,
              x: Y.x,
              y: Y.y,
              onMouseOver: (Se) => N(Z, Y.key, Se, x),
              onMouseLeave: R,
              tooltipHtml: ye,
              tooltipId: `cdc-open-viz-tooltip-${h.runtime.uniqueId}`,
              onClick: (Se) => {
                Se.preventDefault(), g && (Y[h.xAxis.dataKey] = de, g(h.uid, Y));
              },
              styleOverrides: {
                animationDelay: `${ae.index * 0.5}s`,
                transformOrigin: `${Y.x}px 0`,
                opacity: se ? 0.2 : 1,
                display: ie ? "block" : "none"
              }
            }),
            L === "horizontal" && q === "stacked" && B && ae.index === 0 && !h.yAxis.hideLabel && /* @__PURE__ */ a(
              ft,
              {
                x: `${Y.x + (h.isLollipopChart ? 15 : 5)}`,
                y: Y.y + Y.height * 1.2,
                fill: "#000000",
                textAnchor: "start",
                verticalAnchor: "start",
                children: Z
              }
            ),
            k && ne < Y.width && /* @__PURE__ */ a(
              ft,
              {
                display: ie ? "block" : "none",
                x: Y.x + ae.bars[Y.index].width / 2,
                y: Y.y + Y.height / 2,
                fill: U,
                textAnchor: "middle",
                verticalAnchor: "middle",
                children: de
              }
            )
          ] }, Q) });
        })
      )
    }
  ) });
}, Xc = (e, t) => {
  var y;
  const { formatDate: n, parseDate: r } = he.useContext(pt);
  let i = [], o = "", h = [], u = [];
  ((y = e.series) == null ? void 0 : y.length) > 0 && e.data ? (i = e.series[0], o = e.series[0].dataKey, h = e.highlightedBarValues, u = e.data.map((v) => v[e.xAxis.dataKey])) : (i = [], o = "", h = [], u = []);
  const d = (v, S) => {
    const B = [...e.highlightedBarValues];
    B[S].borderWidth = v.target.value, t({
      ...e,
      highlightedBarValues: B
    });
  }, p = (v, S) => {
    v.preventDefault();
    const B = [...e.highlightedBarValues];
    B[S].value = v.target.value, B[S].dataKey = o, t({
      ...e,
      highlightedBarValues: B
    });
  }, m = (v, S) => {
    v.preventDefault();
    const B = [...e.highlightedBarValues];
    B.push({ dataKey: o }), t({
      ...e,
      highlightedBarValues: B
    });
  }, g = (v, S) => {
    v.preventDefault();
    const B = [...e.highlightedBarValues];
    B.splice(S, 1), t({
      ...e,
      highlightedBarValues: B
    });
  }, x = (v, S) => {
    const B = [...e.highlightedBarValues];
    B[S].color = v.target.value, t({
      ...e
    });
  }, A = (v, S) => {
    const B = [...e.highlightedBarValues];
    B[S].legendLabel = v.target.value, t({
      ...e,
      copyOfHighlightedBarValues: B
    });
  }, k = () => {
  };
  return k.checkFontColor = (v, S, B) => {
    if (e.xAxis.type === "date") {
      if (k.formatDates(S).includes(v))
        return "#000";
    } else if (S.includes(v))
      return "#000";
    return B;
  }, k.formatDates = (v) => v.map((S) => S ? n(r(S)) : !1), k.findDuplicates = (v) => {
    const S = {};
    return v == null ? void 0 : v.filter((R) => {
      const { legendLabel: N } = R;
      return S[N] ? !1 : (S[N] = !0, !0);
    });
  }, {
    HighLightedBarUtils: k,
    highlightedSeries: i,
    highlightedSeriesKey: o,
    highlightedBarValues: h,
    highlightedSeriesValues: u,
    handleUpdateHighlightedBar: p,
    handleAddNewHighlightedBar: m,
    handleRemoveHighlightedBar: g,
    handleUpdateHighlightedBarColor: x,
    handleHighlightedBarLegendLabel: A,
    handleUpdateHighlightedBorderWidth: d
  };
};
function Wa(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
const mg = ({
  bar: e,
  defaultBarHeight: t,
  defaultBarWidth: n,
  config: r,
  barWidth: i,
  isVertical: o,
  yAxisValue: h
}) => {
  let d = t, p = n, m = "", g = !1, x = !1, A = !1;
  const k = r.general.showSuppressedSymbol;
  if (r.preliminaryData.forEach((B) => {
    (!B.column || B.column === e.key) && B.type === "suppression" && B.value && String(B.value) === String(e.value) && (!B.hideBarSymbol && k ? (d = i > 10 ? 3 : 0, p = 3, g = !0) : (d = 0, p = 0, g = !0));
  }), !g && !Wa(e.value) && r.general.showMissingDataLabel) {
    const B = yr(m, `normal ${i / 2}px sans-serif`), R = Number(B) < i && i > 10;
    x = !0, d = R ? 3 : 0, p = 3;
  }
  if (!g && e.value === "0" && r.general.showZeroValueData) {
    const B = yr("0", `normal ${i / 2}px sans-serif`), R = Number(B) < i && i > 10;
    A = !0, d = R ? 3 : 0, p = 3;
  }
  const y = (B, R) => g || x || A ? r.isLollipopChart ? R - 3 * 2 : R - 3 : B, S = ((B) => {
    let R = "";
    String(B) === "0" && (R = ""), g && (R = ""), x && (R = "N/A"), A && (R = "0");
    const N = yr(m, `normal ${i / 2}px sans-serif`), D = Number(N) < i && i > 10;
    return r.isLollipopChart || D && o ? R : o ? "" : R;
  })(h);
  return { barWidthHorizontal: p, barHeight: d, isSuppressed: g, showMissingDataLabel: x, getBarY: y, absentDataLabel: S };
}, xl = (e) => e == null ? void 0 : /^0(\.0)?$/.test(e.toString()), yg = (e, t, n) => {
  const r = e.series.find((d) => d.dynamicCategory);
  if (!r)
    return t;
  const { dynamicCategory: i, dataKey: o } = r, h = e.runtime.originalXAxis.dataKey, u = Ke.groupBy(t, h);
  return Object.values(u).map((d) => d.reduce((p, m) => {
    const g = m[o], x = m[i];
    if (n) {
      const { lower: A, upper: k } = e.confidenceKeys;
      p.CI || (p.CI = {});
      const y = m[A], v = m[k];
      p.CI[x] = { lower: y, upper: v };
    }
    return p[x] = g, p[h] = m[h], p.dynamicData = !0, p;
  }, {}));
}, Dw = () => {
  const { xScale: e, yScale: t, xMax: n, yMax: r, seriesScale: i, convertLineToBarGraph: o, barChart: h } = he.useContext(zl), {
    assignColorsToValues: u,
    barBorderWidth: d,
    getAdditionalColumn: p,
    getHighlightedBarByValue: m,
    getHighlightedBarColorByValue: g,
    lollipopBarWidth: x,
    lollipopShapeSize: A,
    onMouseLeaveBar: k,
    onMouseOverBar: y,
    section: v
  } = h, [S, B] = he.useState(0), [R, N] = he.useState(0), {
    colorScale: D,
    config: L,
    dashboardConfig: q,
    tableData: V,
    formatDate: ae,
    formatNumber: Y,
    parseDate: Q,
    seriesHighlight: se,
    setSharedFilter: ie,
    transformedData: M,
    brushConfig: U
  } = he.useContext(pt), { HighLightedBarUtils: re } = Xc(L);
  let j = M;
  L.preliminaryData.some((ne) => ne.value && ne.type === "suppression") && (j = V), U.data.length && (j = U.data);
  const Z = L.confidenceKeys.upper && L.confidenceKeys.lower && L.confidenceKeys.upper !== "" && L.confidenceKeys.lower !== "", ge = yg(L, j, Z);
  return L.visualizationSubType !== "stacked" && (L.visualizationType === "Bar" || L.visualizationType === "Combo" || o) && L.orientation === "vertical" && /* @__PURE__ */ O(qe, { children: [
    /* @__PURE__ */ a(
      Qy,
      {
        data: ge,
        keys: L.runtime.barSeriesKeys || L.runtime.seriesKeys,
        height: r,
        x0: (ne) => {
          const G = ne[L.runtime.originalXAxis.dataKey];
          return En(L.runtime.xAxis) ? Q(G) : G;
        },
        x0Scale: e,
        x1Scale: i,
        yScale: t,
        color: () => "",
        children: (ne) => ne.map((G, me) => /* @__PURE__ */ a(
          qe,
          {
            className: `bar-group-${G.index}-${G.x0}--${me} ${L.orientation}`,
            id: `bar-group-${G.index}-${G.x0}--${me}`,
            left: G.x0,
            children: G.bars.map((ye, Se) => {
              var Pe, _e;
              const ce = ge[G.index], ke = ce[L.runtime.originalXAxis.dataKey], Ie = L.yAxis.type === "logarithmic" ? 0.1 : 0;
              let Le = L.highlightedBarValues.map((xe) => xe.value).filter((xe) => xe !== void 0);
              Le = L.xAxis.type === "date" ? re.formatDates(Le) : Le;
              const Fe = L.legend.behavior === "highlight" && se.length > 0 && se.indexOf(ye.key) === -1, Xe = L.legend.behavior === "highlight" || se.length === 0 || se.indexOf(ye.key) !== -1;
              let Be = i.range()[1] - i.range()[0];
              const ot = Math.abs(t(ye.value) - t(Ie)), gt = ye.value >= 0 && Wa(ye.value) ? ye.y : t(0);
              let st = L.isLollipopChart ? x : i.bandwidth(), dt = ye.x + (L.isLollipopChart ? (Be / G.bars.length - x) / 2 : 0) - (L.xAxis.type === "date-time" ? Be / 2 : 0);
              B(st), N(G.bars.length);
              const Ye = Y(/[a-zA-Z]/.test(String(ye.value)) ? "" : ye.value, "left"), Je = L.runtime[v].type === "date" ? ae(Q(ke)) : ke, yt = ye.value < 0 ? -1 : Se, nt = p(ye.key, ke);
              let lt = L.runtime.xAxis.label ? `${L.runtime.xAxis.label}: ${Je}` : Je;
              const je = `${L.runtime.seriesLabels[ye.key]}: ${Ye}`, at = `<ul>
                  <li class="tooltip-heading">${lt}</li>
                  <li class="tooltip-body ">${je}</li>
                  ${nt ? '<li class="tooltip-body ">' + nt + "</li>" : ""}
                    </li></ul>`, { barHeight: ct, isSuppressed: wt, getBarY: rn, absentDataLabel: Ne } = mg({
                bar: ye,
                defaultBarHeight: ot,
                config: L,
                barWidth: st,
                isVertical: !0,
                yAxisValue: Ye
              });
              let Ct = "#000000";
              Ct = re.checkFontColor(Ye, Le, Ct);
              const bn = L.isLollipopChart && L.lollipopColorStyle === "regular", Zt = L.isLollipopChart && L.lollipopColorStyle === "two-tone", jt = Le == null ? void 0 : Le.includes(Je), Qt = g(Je), _n = m(Je), Gt = jt ? Qt : L.barHasBorder === "true" ? "#000" : "transparent", fn = jt ? _n.borderWidth : L.isLollipopChart ? 0 : L.barHasBorder === "true" && !Ne && !wt ? d : 0, Nt = wt || !L.labels ? "" : Ye, Yt = rn(gt, t(Ie)), tn = xl(ye.value) ? "none" : "block", zt = (xe, ut) => {
                var At;
                let et = xe, rt = ut || "#f2f2f2";
                if (q && ((At = q.dashboard.sharedFilters) == null ? void 0 : At.length) !== 0) {
                  const { sharedFilters: Xt } = q.dashboard;
                  return et = Xt ? Xt.map((tt) => tt.setBy === L.uid ? tt.resetLabel === tt.active || tt.active === M[G.index][L.xAxis.dataKey] ? D(L.runtime.seriesLabels[ye.key]) : rt : D(L.runtime.seriesLabels[ye.key]))[0] : D(L.runtime.seriesLabels[ye.key]), bn && (et = xe), jt && (et = "transparent"), L.legend.colorCode && (et = u(ne.length, G.index, xe)), Zt && (et = Qi(xe).brighten(1)), et;
                }
                return Zt && (et = Qi(xe).brighten(1)), L.legend.colorCode && (et = u(ne.length, G.index, xe)), jt && (et = "transparent"), et;
              }, It = 5, $t = dt + (L.xAxis.type !== "date-time" ? st / 2 : 0), Ze = t(
                ce.dynamicData && ((Pe = ce == null ? void 0 : ce.CI) != null && Pe[ye.key]) ? ce.CI[ye.key].upper : ce[L.confidenceKeys.upper]
              ), mt = t(
                ce.dynamicData && ((_e = ce == null ? void 0 : ce.CI) != null && _e[ye.key]) ? ce.CI[ye.key].lower : ce[L.confidenceKeys.lower]
              ), Kt = 10;
              return /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ O(qe, { children: [
                $l({
                  config: L,
                  index: yt,
                  id: `barGroup${G.index}`,
                  background: zt(D(L.runtime.seriesLabels[ye.key])),
                  borderColor: Gt,
                  borderStyle: "solid",
                  borderWidth: `${fn}px`,
                  width: st,
                  height: ct,
                  x: dt,
                  y: Yt,
                  onMouseOver: (xe) => y(Je, ye.key, xe, j),
                  onMouseLeave: k,
                  tooltipHtml: at,
                  tooltipId: `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                  onClick: (xe) => {
                    xe.preventDefault(), ie && (ye[L.xAxis.dataKey] = Je, ie(L.uid, ye));
                  },
                  styleOverrides: {
                    transformOrigin: `0 ${Yt + ct}px`,
                    opacity: Fe ? 0.2 : 1,
                    display: Xe ? "block" : "none",
                    cursor: q ? "pointer" : "default"
                  }
                }),
                L.preliminaryData.map((xe, ut) => {
                  const et = !xe.column || xe.column === ye.key;
                  if (!(String(xe.value) === String(ye.value) && xe.value !== "" && et) || st < 10 || !L.general.showSuppressedSymbol || xe.hideBarSymbol)
                    return;
                  const Xt = String(xe.symbol).includes("Asterisk"), tt = Xt ? -5 : -8, _t = Xt ? "middle" : "end", yn = xe.symbol === "Asterisk" ? st * 1.2 : xe.symbol === "Double Asterisk" ? st : st / 1.5, vt = xe.displayGray ? "#8b8b8a" : "#000";
                  return /* @__PURE__ */ a(
                    ft,
                    {
                      dy: tt,
                      display: Xe ? "block" : "none",
                      opacity: Fe ? 0.5 : 1,
                      x: dt + st / 2,
                      y: Yt,
                      verticalAnchor: _t,
                      fill: vt,
                      textAnchor: "middle",
                      fontSize: `${yn}px`,
                      children: xe.iconCode
                    },
                    ut
                  );
                }),
                /* @__PURE__ */ a(
                  ft,
                  {
                    display: Xe ? "block" : "none",
                    opacity: Fe ? 0.5 : 1,
                    x: Z ? dt + st : dt + st / 2,
                    y: Yt - Kt,
                    fill: Ct,
                    textAnchor: "middle",
                    children: xl(ye.value) ? "" : Nt
                  }
                ),
                /* @__PURE__ */ a(
                  ft,
                  {
                    display: Xe ? "block" : "none",
                    opacity: Fe ? 0.5 : 1,
                    x: dt + st / 2,
                    y: Yt - Kt,
                    fill: Ct,
                    textAnchor: "middle",
                    fontSize: L.isLollipopChart ? null : st / 2,
                    children: Ne
                  }
                ),
                L.isLollipopChart && L.lollipopShape === "circle" && /* @__PURE__ */ a(
                  "circle",
                  {
                    display: tn,
                    cx: dt + A / 3.5,
                    cy: ye.y,
                    r: A / 2,
                    fill: zt(D(L.runtime.seriesLabels[ye.key])),
                    "data-tooltip-html": at,
                    "data-tooltip-id": `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                    style: { filter: "unset", opacity: 1 }
                  },
                  `circle--${ye.index}`
                ),
                L.isLollipopChart && L.lollipopShape === "square" && /* @__PURE__ */ a(
                  "rect",
                  {
                    display: tn,
                    x: dt - x / 2,
                    y: ye.y,
                    width: A,
                    height: A,
                    fill: zt(D(L.runtime.seriesLabels[ye.key])),
                    "data-tooltip-html": at,
                    "data-tooltip-id": `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                    style: { opacity: 1, filter: "unset" },
                    children: /* @__PURE__ */ a("animate", { attributeName: "height", values: `0, ${A}`, dur: "2.5s" })
                  },
                  `circle--${ye.index}`
                ),
                Z && ye.value !== void 0 && ce && /* @__PURE__ */ a(
                  "path",
                  {
                    stroke: Ir,
                    strokeWidth: "px",
                    d: `M${$t - It} ${Ze}
                                L${$t + It} ${Ze}
                                M${$t} ${Ze}
                                L${$t} ${mt}
                                M${$t - It} ${mt}
                                L${$t + It} ${mt}`
                  },
                  `confidence-interval-v-${ce[L.runtime.originalXAxis.dataKey]}`
                )
              ] }, `bar-sub-group-${G.index}-${G.x0}-${Yt}--${Se}`) }, `${G.index}--${Se}`);
            })
          },
          `bar-group-${G.index}-${G.x0}--${me}`
        ))
      }
    ),
    /* @__PURE__ */ a(Of, { xScale: e, yMax: r, barWidth: S, totalBarsInGroup: R })
  ] });
}, Ow = () => {
  var U;
  const { xScale: e, yScale: t, yMax: n, seriesScale: r, barChart: i } = he.useContext(zl), {
    isHorizontal: o,
    barBorderWidth: h,
    assignColorsToValues: u,
    section: d,
    isLabelBelowBar: p,
    lollipopBarWidth: m,
    lollipopShapeSize: g,
    getHighlightedBarColorByValue: x,
    getHighlightedBarByValue: A,
    getAdditionalColumn: k,
    hoveredBar: y,
    onMouseLeaveBar: v,
    onMouseOverBar: S
  } = i, {
    transformedData: B,
    tableData: R,
    colorScale: N,
    seriesHighlight: D,
    config: L,
    formatNumber: q,
    formatDate: V,
    parseDate: ae,
    setSharedFilter: Y,
    isNumber: Q
  } = he.useContext(pt), { HighLightedBarUtils: se } = Xc(L), ie = L.confidenceKeys.upper && L.confidenceKeys.lower && L.confidenceKeys.upper !== "" && L.confidenceKeys.lower !== "", M = yg(L, B, ie);
  return L.visualizationSubType !== "stacked" && L.visualizationType === "Bar" && L.orientation === "horizontal" && /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ a(
    Qy,
    {
      data: (U = L.preliminaryData) != null && U.some((re) => re.value && re.type === "suppression") ? R : M,
      keys: L.runtime.barSeriesKeys || L.runtime.seriesKeys,
      height: n,
      x0: (re) => re[L.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: r,
      yScale: e,
      color: () => "",
      children: (re) => _f(L, re).map((j, de) => /* @__PURE__ */ a(
        qe,
        {
          className: `bar-group-${j.index}-${j.x0}--${de} ${L.orientation}`,
          id: `bar-group-${j.index}-${j.x0}--${de}`,
          top: j.y,
          children: j.bars.map((Z, ge) => {
            var et;
            const ne = M[j.index], G = ne[L.runtime.originalXAxis.dataKey], me = L.yAxis.type === "logarithmic" ? 0.1 : 0;
            let ye = L.highlightedBarValues.map((rt) => rt.value).filter((rt) => rt !== void 0);
            ye = L.xAxis.type === "date" ? se.formatDates(ye) : ye;
            let Se = L.legend.behavior === "highlight" && D.length > 0 && D.indexOf(Z.key) === -1, ce = L.legend.behavior === "highlight" || D.length === 0 || D.indexOf(Z.key) !== -1, ke = L.barHeight, Ie = parseInt(L.isLollipopChart ? m : ke);
            isNaN(Ie) && (Ie = 25);
            let Le = Z.value >= 0 && Q(Z.value) ? Z.y : t(me);
            const Fe = Math.abs(e(Z.value) - e(me)), Xe = Z.value >= 0 && Q(Z.value), Be = Z.value < 0 ? Math.abs(e(Z.value)) : e(me), ot = q(Z.value, "left"), gt = L.runtime[d].type === "date" ? V(ae(G)) : G, {
              barWidthHorizontal: st,
              isSuppressed: dt,
              absentDataLabel: Ye
            } = mg({ bar: Z, defaultBarWidth: Fe, config: L, isNumber: Q, isVertical: !1, yAxisValue: ot }), Je = Xe ? "above" : "below", yt = L.yAxis.displayNumbersOnBar ? ot : "", nt = yr(yt), lt = Number(nt) < Fe - 5;
            let je = lt ? "end" : "start", at = "start", ct = lt ? -5 : 5, wt = 10;
            Je === "below" && (je = lt ? "start" : "end", ct = lt ? 5 : -5, L.isLollipopChart && (at = "end", wt = -10));
            const rn = Z.value < 0 ? -1 : ge;
            let Ne = L.runtime.yAxis.label ? `${L.runtime.yAxis.label}: ${gt}` : gt;
            const Ct = k(Z.key, y), bn = `${L.runtime.seriesLabels[Z.key]}: ${ot}`, Zt = `<ul>
                  <li class="tooltip-heading"">${Ne}</li>
                  <li class="tooltip-body ">${bn}</li>
                  <li class="tooltip-body ">${Ct}</li>
                    </li></ul>`;
            let jt = "#000000";
            jt = se.checkFontColor(ot, ye, jt);
            let Qt = L.runtime.seriesLabels && L.runtime.seriesLabels[Z.key] ? N(L.runtime.seriesLabels[Z.key]) : N(Z.key);
            L.series.find((rt) => rt.dynamicCategory) || (Qt = u(re.length, j.index, Qt));
            const Gt = L.isLollipopChart && L.lollipopColorStyle === "regular", fn = L.isLollipopChart && L.lollipopColorStyle === "two-tone", Nt = ye == null ? void 0 : ye.includes(gt), Yt = x(gt), tn = A(gt), zt = Nt ? Yt : L.barHasBorder === "true" ? "#000" : "transparent", It = Nt ? tn.borderWidth : L.isLollipopChart ? 0 : L.barHasBorder === "true" && !Ye && !dt ? h : 0, $t = xl(Z.value) ? "none" : "block";
            Qt && jt && lt && (jt = is(Ir, Qt), _m(Ir, Qt) < 7 && (jt = "#fff"));
            const Ze = () => Gt ? Qt : fn ? Qi(Qt).brighten(1) : Nt ? "transparent" : Qt, mt = 5, Kt = ke * Z.index + ke / 2, [Pe, _e] = ["upper", "lower"].map((rt) => {
              if (!ie)
                return;
              if (ne.dynamicData) {
                const Xt = ne.CI[Z.key];
                if (!Xt)
                  return;
                const tt = Xt[rt];
                return e(tt);
              }
              const At = ne[L.confidenceKeys[rt]];
              return e(At);
            }), xe = Z.y, ut = ie && xe >= _e && xe <= Pe;
            return /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ O(qe, { children: [
              $l({
                config: L,
                index: rn,
                id: `barGroup${j.index}`,
                background: Ze(),
                borderColor: zt,
                borderStyle: "solid",
                borderWidth: `${It}px`,
                width: st,
                height: Ie,
                x: Be,
                y: ke * Z.index,
                onMouseOver: (rt) => S(gt, Z.key, rt, B),
                onMouseLeave: v,
                tooltipHtml: Zt,
                tooltipId: `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                onClick: (rt) => {
                  rt.preventDefault(), Y && (Z[L.xAxis.dataKey] = ot, Y(L.uid, Z));
                },
                styleOverrides: {
                  transformOrigin: `0 ${Le + ke}px`,
                  opacity: Se ? 0.2 : 1,
                  display: ce ? "block" : "none"
                }
              }),
              (et = L.preliminaryData) == null ? void 0 : et.map((rt, At) => {
                const Xt = !rt.column || rt.column === Z.key;
                if (!(String(rt.value) === String(Z.value) && rt.value !== "" && Xt) || rt.hideBarSymbol || !L.general.showSuppressedSymbol)
                  return;
                const vt = String(rt.symbol).includes("Asterisk") ? "middle" : "end", St = rt.symbol === "Asterisk" ? ke * 1.2 : rt.symbol === "Double Asterisk" ? ke : ke / 1.5, gn = rt.displayGray ? "#8b8b8a" : "#000";
                return /* @__PURE__ */ a(
                  ft,
                  {
                    fontSize: St,
                    display: ce ? "block" : "none",
                    opacity: Se ? 0.5 : 1,
                    x: Be,
                    y: L.barHeight / 2 + L.barHeight * Z.index,
                    fill: gn,
                    dy: L.barHeight / 5,
                    dx: 10,
                    textAnchor: "start",
                    verticalAnchor: vt,
                    children: rt.iconCode
                  },
                  At
                );
              }),
              !L.isLollipopChart && /* @__PURE__ */ a(
                ft,
                {
                  display: ce ? "block" : "none",
                  x: Z.y,
                  opacity: Se ? 0.5 : 1,
                  y: ie && ut ? L.barHeight * Z.index : L.barHeight / 2 + L.barHeight * Z.index,
                  fill: ie && ut ? "#000" : jt,
                  dx: ct,
                  verticalAnchor: "middle",
                  textAnchor: je,
                  children: xl(Z.value) ? "" : yt
                }
              ),
              /* @__PURE__ */ a(
                ft,
                {
                  display: ce ? "block" : "none",
                  x: Z.y,
                  opacity: Se ? 0.5 : 1,
                  y: L.barHeight / 2 + L.barHeight * Z.index,
                  fill: jt,
                  dx: Ye === "N/A" ? 20 : ct,
                  dy: L.isLollipopChart ? -10 : 0,
                  verticalAnchor: "middle",
                  textAnchor: Ye === "N/A" ? "middle" : je,
                  children: Ye
                }
              ),
              L.isLollipopChart && /* @__PURE__ */ a(
                ft,
                {
                  display: ce ? "block" : "none",
                  x: Z.y,
                  y: 0,
                  fill: "#000000",
                  dx: wt,
                  textAnchor: at,
                  verticalAnchor: "middle",
                  fontWeight: "normal",
                  children: xl(Z.value) ? "" : yt
                }
              ),
              p && !L.yAxis.hideLabel && /* @__PURE__ */ a(
                ft,
                {
                  x: L.yAxis.hideAxis ? 0 : 5,
                  y: j.height,
                  dy: 4,
                  verticalAnchor: "start",
                  textAnchor: "start",
                  children: L.runtime.yAxis.type === "date" ? V(ae(G)) : o ? G : q(G)
                }
              ),
              L.isLollipopChart && L.lollipopShape === "circle" && /* @__PURE__ */ a(
                "circle",
                {
                  display: $t,
                  cx: Z.y,
                  cy: ke * Z.index + m / 2,
                  r: g / 2,
                  fill: Qt,
                  "data-tooltip-html": Zt,
                  "data-tooltip-id": `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                  style: { filter: "unset", opacity: 1 }
                },
                `circle--${Z.index}`
              ),
              L.isLollipopChart && L.lollipopShape === "square" && /* @__PURE__ */ a(
                "rect",
                {
                  display: $t,
                  x: Z.y > 10 ? Z.y - g / 2 : 0,
                  y: 0 - m / 2,
                  width: g,
                  height: g,
                  fill: Qt,
                  "data-tooltip-html": Zt,
                  "data-tooltip-id": `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                  style: { opacity: 1, filter: "unset" },
                  children: /* @__PURE__ */ a("animate", { attributeName: "height", values: `0, ${g}`, dur: "2.5s" })
                },
                `circle--${Z.index}`
              ),
              ie && ce && /* @__PURE__ */ a(
                "path",
                {
                  stroke: Ir,
                  strokeWidth: "px",
                  d: `
                                M${_e} ${Kt - mt}
                                L${_e} ${Kt + mt}
                                M${_e} ${Kt}
                                L${Pe} ${Kt}
                                M${Pe} ${Kt - mt}
                                L${Pe} ${Kt + mt} `
                },
                `confidence-interval-h-${Kt}-${ne[L.runtime.originalXAxis.dataKey]}`
              )
            ] }, `bar-sub-group-${j.index}-${j.x0}-${Le}--${ge}`) }, `${j.index}--${ge}`);
          })
        },
        `bar-group-${j.index}-${j.x0}--${de}`
      ))
    }
  ) });
}, Ku = {
  Vertical: Dw,
  Horizontal: Ow,
  StackedVertical: Nw,
  StackedHorizontal: Rw
}, Fw = (e, t, n) => {
  const { config: r, colorPalettes: i, tableData: o, updateConfig: h, parseDate: u, formatDate: d, seriesHighlight: p } = n, { orientation: m } = r, g = he.useContext(ef), [x, A] = he.useState(null), k = m === "horizontal", y = 1, v = r.lollipopSize === "large" ? 7 : r.lollipopSize === "medium" ? 6 : 5, S = r.lollipopSize === "large" ? 14 : r.lollipopSize === "medium" ? 12 : 10, B = r.yAxis.labelPlacement === "Below Bar", R = r.yAxis.displayNumbersOnBar, N = r.orientation === "horizontal" ? "yAxis" : "xAxis", D = r.barStyle === "rounded", L = r.visualizationSubType === "stacked", q = r.tipRounding, V = r.roundingStyle === "standard" ? "8px" : r.roundingStyle === "shallow" ? "5px" : r.roundingStyle === "finger" ? "15px" : "0px", ae = r.runtime.seriesKeys.length, Y = Object.keys(r.runtime.seriesLabels).length > 1, se = r.visualizationType === "Bar" && r.legend.behavior === "isolate" && r.legend.axisAlign && (p != null && p.length) ? p : r.runtime.barSeriesKeys || r.runtime.seriesKeys;
  return he.useEffect(() => {
    m === "horizontal" && !r.yAxis.labelPlacement && h({
      ...r,
      yAxis: {
        ...r.yAxis,
        labelPlacement: "Below Bar"
      }
    });
  }, [r, h]), he.useEffect(() => {
    r.isLollipopChart === !1 && r.barHeight < 25 && h({ ...r, barHeight: 25 });
  }, [r.isLollipopChart]), he.useEffect(() => {
    r.visualizationSubType === "horizontal" && h({
      ...r,
      orientation: "horizontal"
    });
  }, []), he.useEffect(() => {
    r.barStyle === "lollipop" && !r.isLollipopChart && h({ ...r, isLollipopChart: !0 }), (D || r.barStyle === "flat") && h({ ...r, isLollipopChart: !1 });
  }, [r.barStyle]), {
    isHorizontal: k,
    barBorderWidth: y,
    lollipopBarWidth: v,
    lollipopShapeSize: S,
    isLabelBelowBar: B,
    displayNumbersOnBar: R,
    shouldSuppress: (ne) => {
      var G;
      return (G = r.preliminaryData) == null ? void 0 : G.some((me) => {
        const ye = me.column ? me.column === ne.key : !0, Se = String(ne.value) === String(me.value) && me.value !== "";
        return ye && Se && me.symbol && me.type === "suppression";
      });
    },
    section: N,
    isRounded: D,
    isStacked: L,
    tipRounding: q,
    radius: V,
    stackCount: ae,
    barStackedSeriesKeys: se,
    hasMultipleSeries: Y,
    applyRadius: (ne) => {
      if (ne == null || !D)
        return {};
      let G = {};
      return (L && ne + 1 === ae || !L) && (G = k ? { borderRadius: `0 ${V}  ${V}  0` } : { borderRadius: `${V} ${V} 0 0` }), !L && ne === -1 && (G = k ? { borderRadius: `${V} 0  0 ${V} ` } : { borderRadius: ` 0  0 ${V} ${V}` }), q === "full" && L && ne === 0 && ae > 1 && (G = k ? { borderRadius: `${V} 0 0 ${V}` } : { borderRadius: `0 0 ${V} ${V}` }), q === "full" && (L && ne === 0 && ae === 1 || !L) && (G = { borderRadius: V }), G;
    },
    assignColorsToValues: (ne, G, me) => {
      if (!r.legend.colorCode && r.series.length > 1)
        return me;
      const ye = r.customColors ?? i[r.palette], Se = o.map((Le) => Le[r.legend.colorCode]);
      let ce = /* @__PURE__ */ new Map(), ke = [];
      for (let Le = 0; Le < Se.length; Le++)
        ce.has(Se[Le]) || ce.set(Se[Le], ye[ce.size % ye.length]), ke.push(ce.get(Se[Le]));
      for (; ke.length < ne; )
        ke = ke.concat(ke);
      return ke[G];
    },
    getHighlightedBarColorByValue: (ne) => {
      const G = r == null ? void 0 : r.highlightedBarValues.find((me) => {
        if (me.value)
          return r.xAxis.type === "date" ? d(u(me.value)) === ne : me.value === ne;
      });
      return G != null && G.color ? G.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (ne) => {
      const G = r == null ? void 0 : r.highlightedBarValues.filter((me) => {
        if (me.value)
          return r.xAxis.type === "date" ? d(u(me.value)) === ne : me.value === ne;
      })[0];
      return G != null && G.color ? G : !1;
    },
    getAdditionalColumn: (ne, G) => {
      var Ie, Le;
      if (!G)
        return "";
      const me = r.columns, ye = [];
      let Se = "";
      const ce = (Le = (Ie = r.runtime) == null ? void 0 : Ie.series) == null ? void 0 : Le.find((Fe) => Fe == null ? void 0 : Fe.dynamicCategory), ke = o.find((Fe) => {
        const Xe = ce ? Fe[ce.dynamicCategory] === ne : !0;
        return Fe[r.xAxis.dataKey] === G && Xe;
      }) || {};
      return Object.keys(me).forEach((Fe) => {
        const Xe = r.columns[Fe];
        if (ne && Xe.series && Xe.series !== ne && !Xe.tooltips)
          return;
        const Be = {
          addColPrefix: r.columns[Fe].prefix,
          addColSuffix: r.columns[Fe].suffix,
          addColRoundTo: r.columns[Fe].roundToPlace ? r.columns[Fe].roundToPlace : "",
          addColCommas: r.columns[Fe].commas
        }, ot = Jh(
          ke[r.columns[Fe].name],
          "left",
          !0,
          r,
          Be
        );
        r.columns[Fe].tooltips && ye.push([r.columns[Fe].label, ot]);
      }), ye.forEach((Fe) => {
        Se += `${Fe[0]} : ${Fe[1]} <br/>`;
      }), Se;
    },
    hoveredBar: x,
    setHoveredBar: A,
    onMouseOverBar: (ne, G, me, ye) => {
      r.legend.highlightOnHover && r.legend.behavior === "highlight" && G && g({ type: "SET_SERIES_HIGHLIGHT", payload: [G] }), e(me, ye), A(ne);
    },
    onMouseLeaveBar: () => {
      r.legend.highlightOnHover && r.legend.behavior === "highlight" && g({ type: "SET_SERIES_HIGHLIGHT", payload: [] }), t();
    }
  };
}, Mw = ({
  xScale: e,
  yScale: t,
  seriesScale: n,
  xMax: r,
  yMax: i,
  handleTooltipMouseOver: o,
  handleTooltipMouseOff: h,
  handleTooltipClick: u
}) => {
  const d = he.useContext(pt), { transformedData: p, config: m, convertLineToBarGraph: g } = d, x = Fw(o, h, d), A = {
    xScale: e,
    yScale: t,
    xMax: r,
    yMax: i,
    seriesScale: n,
    convertLineToBarGraph: g,
    barChart: x
  };
  return /* @__PURE__ */ a(qr, { component: "BarChart", children: /* @__PURE__ */ a(zl.Provider, { value: A, children: /* @__PURE__ */ O(qe, { left: parseFloat(m.runtime.yAxis.size), children: [
    /* @__PURE__ */ a(Ku.StackedVertical, {}),
    /* @__PURE__ */ a(Ku.StackedHorizontal, {}),
    /* @__PURE__ */ a(Ku.Vertical, {}),
    /* @__PURE__ */ a(Ku.Horizontal, {}),
    /* @__PURE__ */ a(
      Er,
      {
        display: m.tooltips.singleSeries ? "none" : "block",
        width: Number(r),
        height: Number(i),
        fill: "transparent",
        fillOpacity: 0.05,
        onMouseMove: (k) => {
          o(k, p);
        },
        onMouseOut: h,
        onClick: (k) => u(k, p)
      },
      "bars"
    )
  ] }) }) });
};
function Ui() {
  return Ui = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ui.apply(this, arguments);
}
function Ba(e) {
  var t = e.x1, n = e.x2, r = e.y1, i = e.y2;
  return {
    x1: r,
    x2: i,
    y1: t,
    y2: n
  };
}
function gg(e) {
  var t = e.left, n = t === void 0 ? 0 : t, r = e.top, i = r === void 0 ? 0 : r, o = e.className, h = e.max, u = e.min, d = e.firstQuartile, p = e.thirdQuartile, m = e.median, g = e.boxWidth, x = g === void 0 ? 10 : g, A = e.fill, k = e.fillOpacity, y = e.stroke, v = e.strokeWidth, S = e.rx, B = S === void 0 ? 2 : S, R = e.ry, N = R === void 0 ? 2 : R, D = e.valueScale, L = e.outliers, q = L === void 0 ? [] : L, V = e.horizontal, ae = e.medianProps, Y = ae === void 0 ? {} : ae, Q = e.maxProps, se = Q === void 0 ? {} : Q, ie = e.minProps, M = ie === void 0 ? {} : ie, U = e.boxProps, re = U === void 0 ? {} : U, j = e.outlierProps, de = j === void 0 ? {} : j, Z = e.container, ge = Z === void 0 ? !1 : Z, ne = e.containerProps, G = ne === void 0 ? {} : ne, me = e.children, ye = V ? i : n, Se = ye + (x || 0) / 2, ce = D.range(), ke = D(u ?? 0), Ie = D(d ?? 0), Le = D(m ?? 0), Fe = D(p ?? 0), Xe = D(h ?? 0), Be = {
    valueRange: ce,
    center: Se,
    offset: ye,
    boxWidth: x,
    max: {
      x1: Se - (x || 0) / 4,
      x2: Se + (x || 0) / 4,
      y1: Xe,
      y2: Xe
    },
    maxToThird: {
      x1: Se,
      x2: Se,
      y1: Xe,
      y2: Fe
    },
    median: {
      x1: ye,
      x2: ye + (x || 0),
      y1: Le,
      y2: Le
    },
    minToFirst: {
      x1: Se,
      x2: Se,
      y1: Ie,
      y2: ke
    },
    min: {
      x1: Se - (x || 0) / 4,
      x2: Se + (x || 0) / 4,
      y1: ke,
      y2: ke
    },
    box: {
      x1: ye,
      x2: x || 0,
      y1: Fe,
      y2: Math.abs(Fe - Ie)
    },
    container: {
      x1: ye,
      x2: x || 0,
      y1: Math.min.apply(Math, ce),
      y2: Math.abs(ce[0] - ce[1])
    }
  };
  return V && (Be.max = Ba(Be.max), Be.maxToThird = Ba(Be.maxToThird), Be.box.y1 = Ie, Be.box = Ba(Be.box), Be.median = Ba(Be.median), Be.minToFirst = Ba(Be.minToFirst), Be.min = Ba(Be.min), Be.container = Ba(Be.container), Be.container.y1 = Math.min.apply(Math, ce)), me ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, me(Be)) : /* @__PURE__ */ Me.createElement(qe, {
    className: vn("visx-boxplot", o)
  }, q.map(function(ot, gt) {
    var st = V ? D(ot) : Se, dt = V ? Se : D(ot);
    return /* @__PURE__ */ Me.createElement("circle", Ui({
      key: "visx-boxplot-outlier-" + gt,
      className: "visx-boxplot-outlier",
      cx: st,
      cy: dt,
      r: 4,
      stroke: y,
      strokeWidth: v,
      fill: A,
      fillOpacity: k
    }, de));
  }), /* @__PURE__ */ Me.createElement("line", Ui({
    className: "visx-boxplot-max",
    x1: Be.max.x1,
    y1: Be.max.y1,
    x2: Be.max.x2,
    y2: Be.max.y2,
    stroke: y,
    strokeWidth: v
  }, se)), /* @__PURE__ */ Me.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: Be.maxToThird.x1,
    y1: Be.maxToThird.y1,
    x2: Be.maxToThird.x2,
    y2: Be.maxToThird.y2,
    stroke: y,
    strokeWidth: v
  }), /* @__PURE__ */ Me.createElement("rect", Ui({
    className: "visx-boxplot-box",
    x: Be.box.x1,
    y: Be.box.y1,
    width: Be.box.x2,
    height: Be.box.y2,
    stroke: y,
    strokeWidth: v,
    fill: A,
    fillOpacity: k,
    rx: B,
    ry: N
  }, re)), /* @__PURE__ */ Me.createElement("line", Ui({
    className: "visx-boxplot-median",
    x1: Be.median.x1,
    y1: Be.median.y1,
    x2: Be.median.x2,
    y2: Be.median.y2,
    stroke: y,
    strokeWidth: v
  }, Y)), /* @__PURE__ */ Me.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: Be.minToFirst.x1,
    y1: Be.minToFirst.y1,
    x2: Be.minToFirst.x2,
    y2: Be.minToFirst.y2,
    stroke: y,
    strokeWidth: v
  }), /* @__PURE__ */ Me.createElement("line", Ui({
    className: "visx-boxplot-min",
    x1: Be.min.x1,
    y1: Be.min.y1,
    x2: Be.min.x2,
    y2: Be.min.y2,
    stroke: y,
    strokeWidth: v
  }, M)), ge && /* @__PURE__ */ Me.createElement("rect", Ui({
    x: Be.container.x1,
    y: Be.container.y1,
    width: Be.container.x2,
    height: Be.container.y2,
    fillOpacity: "0"
  }, G)));
}
gg.propTypes = {
  max: De.number,
  min: De.number,
  firstQuartile: De.number,
  thirdQuartile: De.number,
  median: De.number,
  boxWidth: De.number,
  fill: De.string,
  fillOpacity: De.oneOfType([De.number, De.string]),
  stroke: De.string,
  strokeWidth: De.oneOfType([De.number, De.string]),
  rx: De.number,
  ry: De.number,
  outliers: De.arrayOf(De.number),
  container: De.bool,
  children: De.func
};
const Iw = (e, t, n, r, i, o, h, u, d) => `
    <div class="p-2  text-red" style="max-width: 300px; word-wrap: break-word; opacity:0.7; background: rgba(255, 255, 255, 0.9)">
      <div class="fw-bold" style="color: ${d};">
        ${u ? `${u} : ${t}` : t}
      </div>
      <div class="" style="background: ${d}; height: 2px;"></div>
        <strong>Key:</strong> ${n}<br/>
        <strong>${e.labels.q1}:</strong> ${r}<br/>
        <strong>${e.labels.q3}:</strong> ${i}<br/>
        <strong>${e.labels.iqr}:</strong> ${h}<br/>
        <strong>${e.labels.median}:</strong> ${o}
    </div>
  `, Bw = (e) => {
  if (!e || e.length === 0)
    return {};
  const t = Ke.sortBy(e), n = kl(t, 0.25) ?? 0, r = kl(t, 0.75) ?? 0, i = r - n, o = n - 1.5 * i, h = r + 1.5 * i, u = t.filter((d) => d >= o && d <= h);
  return {
    min: zg(u),
    // Smallest non-outlier value
    max: Pm(u),
    // Largest non-outlier value
    median: Ym(t),
    // Median of all values
    firstQuartile: n,
    thirdQuartile: r,
    iqr: i
  };
}, zw = (e, t, n) => {
  const r = t.series.map((h) => h == null ? void 0 : h.dataKey), i = {}, o = n.filter((h) => h[t.xAxis.dataKey] === e);
  return r.forEach((h) => {
    i[h] = o.map((u) => u[h]);
  }), i;
}, $w = (e, t, n) => {
  const r = n - t, i = t - 1.5 * r, o = n + 1.5 * r;
  return e.filter((h) => h < i || h > o);
}, Hw = (e, t, n) => {
  const r = n - t, i = t - 1.5 * r, o = n + 1.5 * r;
  return e.filter((h) => h >= i && h <= o);
}, Vw = (e, t) => {
  const n = e.map((o) => o[t.xAxis.dataKey]), r = [], i = Ke.uniq(n);
  return i && i.length > 0 && i.forEach((o) => {
    const h = zw(o, t, e), u = {}, d = {}, p = {}, m = {}, g = {}, x = {}, A = {}, k = {};
    Object.keys(h).forEach((y) => {
      const v = h[y], { firstQuartile: S, thirdQuartile: B, min: R, max: N, median: D, iqr: L } = Bw(v);
      u[y] = $w(v, S, B).map(Number), d[y] = Hw(v, S, B).map(Number), p[y] = D, m[y] = R, g[y] = N, x[y] = S, A[y] = B, k[y] = L;
    }), r.push({
      columnCategory: o,
      keyValues: h,
      columnOutliers: u,
      columnNonOutliers: d,
      min: m,
      max: g,
      q1: x,
      q3: A,
      median: p,
      iqr: k
    });
  }), r;
}, Ww = ({ xScale: e, yScale: t, seriesScale: n }) => {
  const { config: r, colorScale: i, seriesHighlight: o, transformedData: h } = he.useContext(pt), { boxplot: u } = r, d = `cdc-open-viz-tooltip-${r.runtime.uniqueId}`, p = e.bandwidth();
  getComputedStyle(document.body);
  const m = Ir, g = Math.min(40, p);
  Ke.get(Lr, [r.palette, 0], "#000");
  const x = Vw(h, r);
  return /* @__PURE__ */ a(qr, { component: "BoxPlot", children: /* @__PURE__ */ a(qe, { left: Number(r.yAxis.size), className: "boxplot", children: x.map((A, k) => {
    const y = p - g, v = 4;
    return /* @__PURE__ */ a(
      qe,
      {
        left: e(A.columnCategory) + (e.bandwidth() - n.bandwidth()) / 2,
        children: r.series.map((S, B) => {
          const R = r.legend.behavior === "highlight" && o.length > 0 && o.indexOf(S.dataKey) === -1, N = r.legend.behavior === "highlight" || o.length === 0 || o.indexOf(S.dataKey) !== -1, D = R ? 0.3 : 0.5;
          return /* @__PURE__ */ O(qe, { children: [
            u.plotNonOutlierValues && A.columnNonOutliers[S.dataKey].map((L, q) => /* @__PURE__ */ a(
              "circle",
              {
                display: N ? "block" : "none",
                cx: n(S.dataKey) + n.bandwidth() / 2,
                cy: t(L),
                r: v,
                opacity: D,
                fill: m,
                style: { stroke: m }
              },
              `boxplot-${k}--circle-${q}`
            )),
            N && /* @__PURE__ */ a(
              gg,
              {
                display: N ? "block" : "none",
                "data-left": e(A.columnCategory) + r.yAxis.size + y / 2 + 0.5,
                min: Number(A.min[S.dataKey]),
                max: Number(A.max[S.dataKey]),
                left: n(S.dataKey),
                firstQuartile: A.q1[S.dataKey],
                thirdQuartile: A.q3[S.dataKey],
                median: A.median[S.dataKey],
                boxWidth: n.bandwidth(),
                fill: i(S.dataKey),
                fillOpacity: 1,
                stroke: m,
                valueScale: t,
                outliers: u.plotOutlierValues ? Ke.map(A.columnOutliers[S.dataKey], (L) => L) : [],
                outlierProps: {
                  style: {
                    fill: m,
                    opacity: D,
                    stroke: m
                  }
                },
                medianProps: {
                  style: {
                    opacity: D,
                    stroke: m
                  }
                },
                boxProps: {
                  style: {
                    stroke: m,
                    strokeWidth: u.borders === "true" ? 1.5 : 0,
                    opacity: D
                  }
                },
                maxProps: {
                  style: {
                    opacity: D,
                    stroke: m
                  }
                },
                container: !0,
                containerProps: {
                  "data-tooltip-html": Iw(
                    u,
                    A.columnCategory,
                    S.dataKey,
                    Ke.round(A.q1[S.dataKey], r.dataFormat.roundTo),
                    Ke.round(A.q3[S.dataKey], r.dataFormat.roundTo),
                    Ke.round(A.median[S.dataKey], r.dataFormat.roundTo),
                    Ke.round(A.iqr[S.dataKey], r.dataFormat.roundTo),
                    r.xAxis.label,
                    m
                  ),
                  "data-tooltip-id": d,
                  tabIndex: -1
                }
              },
              `box-plot-${k}-${S}`
            )
          ] }, `boxplotplot-${S.dataKey}-${B}`);
        })
      },
      `boxplotplot-${A.columnCategory}`
    );
  }) }, "boxplot-group") });
}, jw = ({ xScale: e, yScale: t }) => {
  const {
    transformedData: n,
    config: r,
    tableData: i,
    formatNumber: o,
    seriesHighlight: h,
    colorPalettes: u
  } = he.useContext(pt), d = 4.5, p = Object.keys(r.runtime.seriesLabels).length > 1, m = Object.entries(r.columns).filter(([x, A]) => A.tooltips).map(([x, A]) => [
    A.label || A.name,
    A.name,
    {
      addColPrefix: A.prefix,
      addColSuffix: A.suffix,
      addColRoundTo: A.roundToPlace,
      addColCommas: A.commas
    }
  ]), g = (x, A, k) => `<div>
    ${r.legend.showLegendValuesTooltip && r.runtime.seriesLabels && p ? `${r.runtime.seriesLabels[A] || ""}<br/>` : ""}
    ${r.xAxis.label}: ${o(x[r.xAxis.dataKey], "bottom")} <br/>
    ${r.yAxis.label}: ${o(x[A], "left")}<br/>
   ${m.map(
    ([y, v, S]) => `${y} : ${Jh(i[k][v], "left", !1, r, S)}<br/>`
  ).join("")}
</div>`;
  return /* @__PURE__ */ a(qe, { className: "scatter-plot", left: r.yAxis.size, children: n.map((x, A) => r.runtime.seriesKeys.map((k, y) => {
    const v = r.legend.behavior === "highlight" && h.length > 0 && h.indexOf(k) === -1, S = r.legend.behavior === "highlight" || h.length === 0 || h.indexOf(k) !== -1, B = r != null && r.customColors ? r.customColors[y] : r.palette ? u[r.palette][y] : "#000";
    let R = {
      filter: "unset",
      opacity: 1,
      stroke: S ? "black" : ""
    };
    return /* @__PURE__ */ a(
      "circle",
      {
        r: d,
        cx: e(x[r.xAxis.dataKey]),
        cy: t(x[k]),
        fill: S ? B : "transparent",
        fillOpacity: v ? 0.25 : 1,
        style: R,
        "data-tooltip-html": g(x, k, A),
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
        tabIndex: -1
      },
      `${A}-${y}`
    );
  })) });
};
function Kw({ height: e, xScale: t }) {
  const {
    transformedData: n,
    config: r,
    formatNumber: i,
    twoColorPalette: o,
    parseDate: h,
    formatDate: u,
    currentViewport: d
  } = he.useContext(pt), { barStyle: p, tipRounding: m, roundingStyle: g, twoColor: x } = r, A = he.useRef([]), [k, y] = he.useState(window.innerWidth), v = g === "standard" ? "8px" : g === "shallow" ? "5px" : g === "finger" ? "15px" : "0px";
  r.barStyle;
  const S = Number(r.xAxis.target), B = r.series[0].dataKey, R = Number(t.domain()[1]), D = n.some((re) => re[B] < 0) || S > 0 || t.domain()[0] < 0, L = r.barHasBorder === "true" ? 1 : 0, q = r.lollipopSize === "large" ? 7 : r.lollipopSize === "medium" ? 6 : 5, V = r.lollipopSize === "large" ? 14 : r.lollipopSize === "medium" ? 12 : 10, ae = Math.max(t(0), Math.min(t(S), t(R))), Y = (re) => {
    if (re == null || p !== "rounded")
      return;
    let j = {};
    return re === "left" && (j = { borderRadius: `${v} 0 0 ${v}` }), re === "right" && (j = { borderRadius: `0 ${v} ${v} 0` }), m === "full" && (j = { borderRadius: v }), j;
  }, Q = {
    calculate: function() {
      const j = n[0][B] < S ? "left" : "right", de = `${r.xAxis.targetLabel} ${i(r.xAxis.target || 0, "left")}`, Z = yr(de, "bold 20px sans-serif");
      let ge = r.isLollipopChart ? q / 2 : Number(r.barHeight) / 2, ne = 0, G = 0, me = !1;
      j === "right" && (ne = -10, me = Z - ne < ae, G = ae - Z), j === "left" && (ne = 10, me = t(R) - ae > Z + ne, G = ae), this.text = de, this.y = ge, this.x = G, this.padding = ne, this.showLabel = r.xAxis.showTargetLabel ? me : !1;
    }
  };
  Q.calculate();
  const se = he.useRef(null), ie = Pf(se, {});
  he.useEffect(() => {
    const re = () => {
      var j;
      y(window.innerWidth), (j = A.current) == null || j.forEach((de) => {
        !de || !de.style || (de.style.transition = "none", de.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", re), () => {
      window.removeEventListener("resize", re);
    };
  }, []);
  const [M, U] = he.useState(!1);
  return he.useEffect(() => {
    ie != null && ie.isIntersecting && setTimeout(() => {
      U(!0);
    }, 100);
  }, [ie == null ? void 0 : ie.isIntersecting, r.animate]), he.useEffect(() => {
    var re;
    (re = A.current) == null || re.forEach((j, de) => {
      if (!(!j || !j.style)) {
        if (r.animate) {
          const Z = S / R * 100;
          j.style.opacity = "0", j.style.transform = `translate(${Z / 1.07}%) scale(0, 1)`, setTimeout(() => {
            j.style.opacity = "1", j.style.transform = "translate(0) scale(1)", j.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          j.style.transition = "none", j.style.opacity = "0";
        r.animate || (j.style.transition = "none", j.style.opacity = "1");
      }
    });
  }, [r.animate, r, M]), /* @__PURE__ */ O(qr, { component: "Deviation Bar", children: [
    /* @__PURE__ */ O(qe, { left: Number(r.xAxis.size), children: [
      n.map((re, j) => {
        const de = Number(re[B]), Z = r.isLollipopChart ? q : Number(r.barHeight), ge = Number(r.barSpace), ne = Math.abs(t(de) - ae), G = t(de), me = de > S ? ae : G, ye = de < S ? "left" : "right";
        let Se = 0;
        Se = j !== 0 ? (ge + Z + L) * j : Se;
        const ce = (ge + Z + L) * n.length;
        r.heights.horizontal = ce;
        const Ie = yr(i(de, "left"), "normal 16px sans-serif") < ne - 6, Le = G, Fe = Se + Z / 2, Xe = G, Be = Se + Z / 2, ot = G, gt = Se - Z / 2, st = Y(ye), [dt, Ye] = o[x.palette], Je = { left: dt, right: Ye }, yt = is(Ir, Je[ye]);
        let nt = Uw(r.isLollipopChart, Ie, V, yt);
        const lt = i(de, "left"), je = r.runtime.yAxis.type === "date" ? u(h(n[j][r.runtime.originalXAxis.dataKey])) : n[j][r.runtime.originalXAxis.dataKey];
        let at = r.runtime.yAxis.label ? `${r.runtime.yAxis.label}: ${je}` : je, ct = r.runtime.xAxis.label ? `${r.runtime.xAxis.label}: ${lt}` : lt;
        const wt = `<div>
          ${at}<br />
          ${ct}
            </div>`;
        return /* @__PURE__ */ O(qe, { children: [
          /* @__PURE__ */ a(
            "foreignObject",
            {
              ref: (rn) => {
                A.current[j] = rn;
              },
              x: me,
              y: Se,
              width: ne,
              height: Z,
              "data-tooltip-html": wt,
              "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
              tabIndex: -1,
              children: /* @__PURE__ */ a(
                "div",
                {
                  style: {
                    width: ne,
                    height: Z,
                    border: `${L}px solid #333`,
                    backgroundColor: Je[ye],
                    ...st
                  }
                }
              )
            }
          ),
          r.yAxis.displayNumbersOnBar && /* @__PURE__ */ a(ft, { verticalAnchor: "middle", x: Le, y: Fe, ...nt[ye], children: i(re[B], "left") }),
          r.isLollipopChart && r.lollipopShape === "circle" && /* @__PURE__ */ a(
            "circle",
            {
              cx: Xe,
              cy: Be,
              r: V / 2,
              fill: Je[ye],
              style: { filter: "unset", opacity: 1 }
            }
          ),
          r.isLollipopChart && r.lollipopShape === "square" && /* @__PURE__ */ a(
            "rect",
            {
              x: ot,
              y: gt,
              width: V,
              height: V,
              fill: Je[ye],
              style: { opacity: 1, filter: "unset" }
            }
          )
        ] }, `deviation-bar-${r.orientation}-${B}-${j}`);
      }),
      Q.showLabel && /* @__PURE__ */ a(ft, { fontWeight: "bold", dx: Q.padding, verticalAnchor: "middle", x: Q.x, y: Q.y, children: Q.text }),
      D && /* @__PURE__ */ a(ln, { from: { x: ae, y: 0 }, to: { x: ae, y: e }, stroke: "#333", strokeWidth: 2 })
    ] }),
    /* @__PURE__ */ a("foreignObject", { y: e / 2, ref: se })
  ] });
}
function Uw(e, t, n, r) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: n + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -n,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? r : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? r : "#000000"
    }
  };
}
const Gw = ({ xScale: e, yScale: t, height: n, width: r, handleTooltipMouseOver: i, handleTooltipMouseOff: o }) => {
  var k;
  const { transformedData: h, rawData: u, config: d, seriesHighlight: p } = he.useContext(pt), { xAxis: m, yAxis: g, legend: x, runtime: A } = d;
  return h && /* @__PURE__ */ a(qr, { component: "ForecastingChart", children: /* @__PURE__ */ O(qe, { className: "forecasting-items", left: Number(g.size), children: [
    (k = A.forecastingSeriesKeys) == null ? void 0 : k.map((y, v) => !y || !y.stages ? !1 : y.stages.map((S, B) => {
      var q;
      const { behavior: R } = x, N = u.filter((V) => V[y.stageColumn] === S.key);
      let D = R === "highlight" && p.length > 0 && p.indexOf(S.key) === -1, L = R === "highlight" || p.length === 0 || p.indexOf(S.key) !== -1;
      return /* @__PURE__ */ a(qe, { className: `forecasting-areas-combo-${v}`, children: (q = y.confidenceIntervals) == null ? void 0 : q.map((V, ae) => {
        const Y = ac[S.color] || Lr[S.color] || !1, Q = () => L && Y[2] ? Y[2] : "transparent", se = () => L && Y[1] ? Y[1] : "transparent";
        if (!(V.high === "" || V.low === ""))
          return /* @__PURE__ */ O(qe, { children: [
            /* @__PURE__ */ a(
              F0,
              {
                curve: Ju,
                data: N,
                fill: Q(),
                opacity: D ? 0.1 : 0.5,
                x: (ie) => e(Date.parse(ie[m.dataKey])),
                y0: (ie) => t(ie[V.low]),
                y1: (ie) => t(ie[V.high])
              }
            ),
            ae === 0 && /* @__PURE__ */ O(ze, { children: [
              /* @__PURE__ */ a(Yr, { data: N, x: (ie) => Number(e(Date.parse(ie[m.dataKey]))), y: (ie) => Number(t(ie[V.high])), curve: Ju, stroke: se(), strokeWidth: 1, strokeOpacity: 1 }),
              /* @__PURE__ */ a(Yr, { data: N, x: (ie) => Number(e(Date.parse(ie[m.dataKey]))), y: (ie) => Number(t(ie[V.low])), curve: Ju, stroke: se(), strokeWidth: 1, strokeOpacity: 1 })
            ] })
          ] }, `forecasting-areas--stage-${S.key.replaceAll(" ", "-")}--group-${B}-${ae}`);
      }) }, `forecasting-areas--stage-${S.key.replaceAll(" ", "-")}-${v}`);
    })),
    /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ a(Er, { width: Number(r), height: Number(n), fill: "transparent", fillOpacity: 0.05, onMouseMove: (y) => i(y, h), onMouseOut: o }, "bars") }, "tooltip-hover-section")
  ] }, "forecasting-items-wrapper") });
};
function qc(e, t) {
  const n = e.series.every(({ type: A }) => A === "Bar"), r = e.series.every(({ type: A }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(A)), i = (A) => (k) => A.reduce((y, v) => isNaN(Number(k[v])) ? y : y + Number(k[v]), 0), o = (A) => {
    const k = e.runtime.series.find((y) => y.dataKey === A);
    return k != null && k.dynamicCategory ? k.originalDataKey : A;
  }, h = () => {
    let A = Math.max(
      ...t == null ? void 0 : t.map(
        (k) => Math.max(
          ...e.runtime.seriesKeys.map((y) => {
            const v = o(y);
            return Wa(k[v]) ? Number(p(k[v])) : 0;
          })
        )
      )
    );
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && n) && e.visualizationSubType === "stacked") {
      const k = t.map(i(e.runtime.seriesKeys)).filter((y) => !isNaN(y));
      A = Math.max(...k);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const k = t.map(i(e.runtime.seriesKeys));
      A = Math.max(...k);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (A = Math.max(
      ...t.map((k) => Wa(k[e.series.dataKey]) ? Number(p(k[e.series.dataKey])) : 0)
    )), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !n && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const k = t.map(i(e.runtime.barSeriesKeys)), y = Math.max(
        ...t.map((S) => Math.max(...e.runtime.lineSeriesKeys.map((B) => Number(p(S[B])))))
      ), v = Math.max(...k);
      A = Math.max(v, y);
    }
    return A;
  }, u = () => {
    const A = Math.min(
      ...t.map(
        (k) => Math.min(
          ...e.runtime.seriesKeys.map((y) => {
            const v = o(y);
            return Wa(k[v]) ? Number(p(k[v])) : 1 / 0;
          })
        )
      )
    );
    return String(A);
  }, d = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((A) => t.some((k) => k[o(A)] >= 0)) : !1, p = (A) => A === null || A === "" ? "" : typeof A == "string" ? A.replace(/[,$]/g, "") : A, m = Number(h()), g = Number(u()), x = d();
  return { minValue: g, maxValue: m, existPositiveValue: x, isAllLine: r };
}
const Kr = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, vg = 10, Yw = (e) => {
  let { xAxisDataMapped: t, xMax: n, yMax: r, min: i, max: o, config: h, data: u } = e;
  const { rawData: d, dimensions: p } = he.useContext(pt), [m] = p, g = h.runtime.barSeriesKeys || h.runtime.seriesKeys, x = h.runtime.xAxis.type, A = h.orientation === "horizontal", { visualizationType: k, xAxis: y, forestPlot: v } = h;
  let S = null, B = null, R = null, N = null, D = null, L = null, q = $n({
    domain: [0, 100],
    range: [0, n]
  });
  if (A && (S = Jw({ min: i * 1.03, ...e }), S.type = h.yAxis.type === "logarithmic" ? Kr.LOG : Kr.LINEAR, B = tk(x, t), B.rangeRound([0, r]), D = nk(g, [0, r])), A || (S = qo(t, [0, n], 1 - h.barThickness), B = ek(e), D = qo(g, [0, S.bandwidth()], 0)), h.xAxis.type === "date" && !A) {
    const V = Sm(t, h.xAxis.sortByRecentDate);
    S = qo(V, [0, n], 1 - h.barThickness);
  }
  if (y.type === "date-time" || y.type === "continuous") {
    let V = Math.min(...t.map(Number)), ae = Math.max(...t.map(Number)), Y = h.xAxis.padding ? h.xAxis.padding * 0.01 : 0;
    h.brush.active && (Y = h.barThickness * 0.2), V -= Y * (ae - V), ae += k === "Line" ? 0 : Y * (ae - V);
    const Q = h.xAxis.sortByRecentDate ? [n, 0] : [0, n];
    S = CS({
      domain: [V, ae],
      range: Q
    }), S.type = Kr.TIME;
    let se = Number.MAX_VALUE, ie = Sm(t, h.xAxis.sortByRecentDate);
    for (let M = 0; M < ie.length - 1; M++) {
      let U = S(ie[M + 1]) - S(ie[M]);
      U < se && (se = U);
    }
    (t.length === 1 || se > n / 4) && (se = n / 4), D = qo(g, [0, (h.barThickness || 1) * se], 0);
  }
  if (h.visualizationType === "Deviation Bar") {
    const V = h.isLollipopChart ? 1.05 : 1.03;
    B = wc({
      domain: t,
      range: [0, r]
    }), S = $n({
      domain: [i * V, Math.max(Number(y.target), o)],
      range: [0, n],
      round: !0,
      nice: !0
    }), S.type = Kr.LINEAR;
  }
  if (h.visualizationType === "Scatter Plot") {
    if (y.type === "continuous") {
      let V = y.min ? y.min : Math.min.apply(null, S.domain()), ae = y.max ? y.max : Math.max.apply(null, S.domain());
      S = $n({
        domain: [V, ae],
        range: [0, n]
      }), S.type = Kr.LINEAR;
    }
    y.type === "categorical" && (S = qo(t, [0, n], 1), S.type = Kr.BAND);
  }
  if (k === "Box Plot") {
    const V = [];
    if (h.boxplot.plots.map((U) => U.columnOutliers.map((re) => V.push(re))) && !h.boxplot.hideOutliers) {
      let U = Math.min(...V), re = Math.max(...V);
      U < i && (i = U), re > o && (o = re);
    }
    let Y = Math.min(...h.boxplot.plots.map((U) => U.columnLowerBounds)), Q = Math.max(...h.boxplot.plots.map((U) => U.columnUpperBounds));
    Y < i && (i = Y), Q > o && (o = Q);
    const se = Ke.uniq(u.map((U) => U[h.xAxis.dataKey])), ie = [0, h.barThickness * 100 || 1], M = Ke.map(h.series, "dataKey");
    B = $n({
      range: [r, 0],
      round: !0,
      domain: [i, o]
    }), S = wc({
      range: [0, n],
      domain: se
    }), S.type = Kr.BAND, D = qo(M, ie);
  }
  if (k === "Paired Bar") {
    let ae = Math.max.apply(
      Math,
      u.map((Q) => {
        var se;
        return Q[(se = h.series[0]) == null ? void 0 : se.dataKey];
      })
    ), Y = Math.max.apply(
      Math,
      u.map((Q) => {
        var se;
        return Q[(se = h.series[1]) == null ? void 0 : se.dataKey];
      })
    );
    N = $n({
      domain: [0, Math.max(ae, Y) * 1.02],
      range: [n / 2, 0]
    }), R = $n({
      domain: N.domain(),
      range: [n / 2, n],
      nice: !0
    });
  }
  if (k === "Forest Plot") {
    const V = () => v.regression.showDiamond || v.regression.description ? [0 + v.rowHeight * 2, r - v.rowHeight] : [0 + v.rowHeight * 2, r];
    B = $n({
      domain: [0, d.length],
      range: V()
    });
    const ae = 5, Y = Number(v.leftWidthOffset) / 100 * n, Q = Number(v.rightWidthOffset) / 100 * n, se = Number(v.rightWidthOffsetMobile) / 100 * n, ie = Number(v.leftWidthOffsetMobile) / 100 * n;
    if (m > 480) {
      if (v.type === "Linear" && (S = $n({
        domain: [
          Math.min(...u.map((M) => parseFloat(M[v.lower]))) - ae,
          Math.max(...u.map((M) => parseFloat(M[v.upper]))) + ae
        ],
        range: [Y, Number(m) - Q]
      }), S.type = Kr.LINEAR), v.type === "Logarithmic") {
        let M = Math.max(...u.map((re) => parseFloat(re[v.upper]))), U = Math.min(...u.map((re) => parseFloat(re[v.lower])));
        S = kc({
          domain: [U, M],
          range: [Y, n - Q],
          nice: !0
        }), S.type = Kr.LOG;
      }
    } else if (v.type === "Linear" && (S = $n({
      domain: [
        Math.min(...u.map((M) => parseFloat(M[v.lower]))) - ae,
        Math.max(...u.map((M) => parseFloat(M[v.upper]))) + ae
      ],
      range: [ie, n - se],
      type: Kr.LINEAR
    })), v.type === "Logarithmic") {
      let M = Math.max(...u.map((re) => parseFloat(re[v.upper]))), U = Math.min(...u.map((re) => parseFloat(re[v.lower])));
      S = kc({
        domain: [U, M],
        range: [Y, n - Q],
        nice: !0,
        base: M > 1 ? 10 : 2,
        round: !1,
        type: Kr.LOG
      });
    }
  }
  return { xScale: S, yScale: B, seriesScale: D, g1xScale: N, g2xScale: R, xScaleNoPadding: L, xScaleAnnotation: q };
}, Xw = (e) => {
  const t = new Date(e);
  return new Date(t.getFullYear(), t.getMonth(), 1).getTime();
}, qw = (e) => (e.includes("%b") || e.includes("%B") || e.includes("%m") || e.includes("%-m") || e.includes("%_m")) && !e.includes("%d") && !e.includes("%-d") && !e.includes("%_d") && !e.includes("%e"), Zw = (e, t, n, r) => {
  const i = t.domain();
  if (t.type === "time") {
    const o = e[e.length - 1], h = e[0], u = (o - h) / (n - 1);
    let d = [];
    for (let p = o; p >= h; p -= u)
      d.push(p);
    return d[d.length - 1] !== h && d.push(h), d.reverse(), qw(r.xAxis.dateDisplayFormat) && (d = d.map((p) => Xw(p))), d;
  }
  if (i.length > 2) {
    const o = n || 1, h = [];
    for (let u = i.length; u > 0; u -= o) {
      const d = Math.max(Math.round(u) - 1, 0);
      h.push(i[d]);
    }
    return h.reverse(), h;
  }
}, Qw = (e, t, n, r) => {
  let i = t.ticks;
  const o = pg(t.scale, t.numTicks);
  if (o.length < n.length) {
    let h = 0;
    const u = n.indexOf(o[o.length - 1]);
    u < n.length - 1 && (h = e.xAxis.sortByRecentDate ? n.indexOf(o[0]) * -1 : n.length - 1 - u), i = o.map((d) => t.ticks[t.ticks.findIndex((p) => p.value === d) + h]);
  }
  return i.forEach((h, u) => {
    h.formattedValue = r(h.value, u, i);
  }), i;
}, Jw = ({ min: e, max: t, xMax: n, config: r }) => {
  const i = r.yAxis.type === "logarithmic";
  return e = i && e >= 0 && e < 1 ? e + 0.1 : e, (i ? kc : $n)({
    domain: [e, t],
    range: [0, n],
    nice: i,
    zero: i
  });
}, ek = ({ min: e, max: t, yMax: n, config: r, leftMax: i }) => {
  const o = r.yAxis.type === "logarithmic";
  e = o && e >= 0 && e < 1 ? e + 0.1 : e;
  const h = o ? kc : $n;
  r.visualizationType === "Combo" && (t = i);
  const u = r.visualizationType === "Bump Chart" ? [1, t] : [e, t], d = r.visualizationType === "Bump Chart" ? [30, n] : [n, vg];
  return h({
    domain: u,
    range: d,
    nice: o,
    zero: o
  });
}, tk = (e, t) => e === "date" ? $n({
  domain: [Math.min(...t), Math.max(...t)]
}) : es({ domain: t, padding: 0.5 }), nk = (e, t, n = 0) => es({
  domain: e,
  range: t,
  padding: n
}), qo = (e, t, n = 0) => wc({
  domain: e,
  range: t,
  padding: n
}), Sm = (e, t) => !e || e.length === 0 ? [] : e.length === 1 ? e : t ? e.sort((n, r) => Number(r) - Number(n)) : e.sort((n, r) => Number(n) - Number(r));
function Ff({ config: e, yMax: t = 0, data: n = [] }) {
  var g, x, A, k;
  const r = e.visualizationType === "Combo" && e.orientation === "vertical", i = e.series && e.series.filter((y) => y.axis === "Right").map((y) => y.dataKey);
  let { minValue: o } = qc(e, n);
  const h = (y) => {
    if (!y)
      return [0];
    let v = [];
    return y.map((S, B) => v = [...v, ...n.map((R) => Number(R[S]))]), v;
  };
  let u = Math.max.apply(null, h(i));
  e.yAxis.rightMax > u && (u = e.yAxis.rightMax), e.yAxis.rightMin < o && (o = e.yAxis.rightMin);
  const d = ((x = (g = e.runtime) == null ? void 0 : g.barSeriesKeys) == null ? void 0 : x.length) > 0, p = ((k = (A = e.runtime) == null ? void 0 : A.lineSeriesKeys) == null ? void 0 : k.length) > 0;
  return (d || p) && o > 0 && (o = 0), { yScaleRight: $n({
    domain: [o, u],
    range: [t, vg]
  }), hasRightAxis: r };
}
const rk = (e) => {
  const {
    preliminaryData: t,
    data: n,
    stroke: r,
    strokeWidth: i,
    handleLineType: o,
    lineType: h,
    seriesKey: u,
    dynamicCategory: d,
    originalSeriesKey: p
  } = e, m = d ? p : u, g = t.filter(
    (v) => v.seriesKey && v.column && v.value && v.type && v.style && v.type === "effect"
  ), x = (v, S) => d ? v.type === "effect" && v.style !== "Open Circles" && v.seriesKey === u && String(S[m]) === String(v.value) : v.seriesKey === u && S[v.column] === v.value && v.type === "effect" && v.style !== "Open Circles", A = (v) => g.find((S) => x(S, v)), k = [], y = (v) => ({
    stroke: r,
    strokeWidth: i,
    strokeDasharray: v
  });
  return n.forEach((v, S) => {
    const B = A(v);
    let R = y(o(B ? B.style : h));
    k.push(R), B && S > 0 && (k[S - 1] = y(o(B.style)));
  }), k;
}, ik = (e, t, n) => {
  const r = e == null ? void 0 : e.filter((o) => o.style.includes("Circles") && o.type === "effect").map((o) => ({
    column: o.column,
    value: o.value,
    seriesKey: o.seriesKey,
    circleSize: o.circleSize,
    style: o.style
  })), i = [];
  return t.forEach((o) => {
    r.forEach((h) => {
      if (o[h.column] === h.value && h.seriesKey === n && o[n] && h.style === "Open Circles") {
        const u = {
          data: o,
          size: h.circleSize,
          isFilled: !1
        };
        i.push(u);
      }
      if ((!h.value || o[h.column] === h.value) && h.seriesKey === n && o[n] && h.style === "Filled Circles") {
        const u = {
          data: o,
          size: h.circleSize,
          isFilled: !0
        };
        i.push(u);
      }
    });
  }), i;
}, Pc = (e) => !isNaN(parseFloat(e)) && isFinite(e), ak = ({
  data: e,
  seriesKey: t,
  preliminaryData: n,
  dynamicCategory: r,
  originalSeriesKey: i,
  colorScale: o,
  isSuppressed: h
}) => {
  let u = "0";
  const d = {
    data: { 0: [] },
    style: "",
    color: ""
  };
  if (!e.length)
    return d;
  const p = e[0], m = (n ?? []).find(
    (g) => g && p && h(g, p)
  );
  if (m && m.style) {
    const g = r ? i : t, x = { ...p, [g]: 0 };
    d.data[u].push(x), d.style = m.style, d.color = r && x ? o(x[r]) : "";
    let A = 1;
    for (; A < e.length && !Pc(e[A][g]); )
      A++;
    A < e.length && d.data[u].push(e[A]);
  } else
    d.data[u].push(p);
  return d;
}, ok = ({
  data: e,
  seriesKey: t,
  preliminaryData: n,
  dynamicCategory: r,
  originalSeriesKey: i,
  colorScale: o,
  isSuppressed: h
}) => {
  let u = "0";
  const d = {
    data: { 0: [] },
    style: "",
    color: ""
  }, p = e[e.length - 1], m = r ? i : t;
  let g = -1;
  return n == null || n.forEach((x) => {
    if (x.type === "effect")
      return [];
    if (h(x, p)) {
      const A = e.length - 1, k = { ...e[A], [m]: 0 };
      d.data[u].push(k);
      let y = A - 1;
      for (; y >= 0 && !Pc(e[y][m]); )
        y--;
      y >= 0 && g !== y && (d.data[u].push(e[y]), g = y), d.style = x.style, d.color = o(k[r]);
    }
  }), d;
}, sk = ({
  data: e,
  seriesKey: t,
  preliminaryData: n,
  dynamicCategory: r,
  originalSeriesKey: i,
  colorScale: o,
  isSuppressed: h
}) => {
  let u = {
    data: {},
    style: "",
    color: "red"
  };
  if (!Array.isArray(e) || !Array.isArray(n))
    return u;
  let d = 1;
  const p = r ? i : t;
  return e.forEach((m, g) => {
    n.forEach((x) => {
      if (h(x, m)) {
        let A = null, k = null;
        for (let y = g - 1; y >= 0; y--)
          if (Pc(e[y][p])) {
            A = e[y];
            break;
          }
        for (let y = g + 1; y < e.length; y++)
          if (Pc(e[y][p])) {
            k = e[y];
            break;
          }
        A && k && (u.style = x.style, u.color = o(m[r]), u.data[d++] = [A, k]);
      }
    });
  }), u;
}, lk = (e) => {
  const t = (e.data ?? []).filter((u) => e != null && e.dynamicCategory ? (e.preliminaryData ?? []).some((d) => (u == null ? void 0 : u[e.dynamicCategory]) === (e == null ? void 0 : e.seriesKey)) : !0), n = (u, d) => u.type === "effect" || u.hideLineStyle ? !1 : e.dynamicCategory ? u.type === "suppression" && (!u.column || u.column === d[e.dynamicCategory]) && u.value === d[e.originalSeriesKey] : u.type === "suppression" && u.value === d[e.seriesKey] && (!u.column || u.column === e.seriesKey), r = ak({ ...e, data: t, isSuppressed: n }), i = ok({ ...e, data: t, isSuppressed: n }), o = sk({ ...e, data: t, isSuppressed: n });
  return [r, o, i].filter((u) => !u || !u.data ? !1 : Object.values(u.data).some((p) => Array.isArray(p) && p.length > 0));
};
var uk = ["children", "className", "top", "left", "size"];
function Yh() {
  return Yh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Yh.apply(this, arguments);
}
function ck(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Mf(e) {
  var t = e.children, n = e.className, r = e.top, i = e.left, o = e.size, h = ck(e, uk), u = $g();
  return u.type(Zx), (typeof o == "number" || o) && u.size(o), t ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, t({
    path: u
  })) : /* @__PURE__ */ Me.createElement(Qh, {
    top: r,
    left: i
  }, /* @__PURE__ */ Me.createElement("path", Yh({
    className: vn("visx-glyph-cross", n),
    d: u() || ""
  }, h)));
}
Mf.propTypes = {
  children: De.func,
  className: De.string,
  top: De.number,
  left: De.number,
  size: De.oneOfType([De.number, De.func])
};
const dk = [
  Nm,
  Rm,
  ic,
  Dm,
  ic,
  Mf,
  ({ fill: e }) => /* @__PURE__ */ a(Qh, { children: /* @__PURE__ */ a(ft, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle", children: "⬟" }) })
], Uu = (e) => {
  var ie, M;
  const {
    config: t,
    d: n,
    displayArea: r,
    seriesKey: i,
    xScale: o,
    yScale: h,
    colorScale: u,
    parseDate: d,
    yScaleRight: p,
    data: m,
    tooltipPoint: g,
    dataIndex: x,
    mode: A,
    seriesIndex: k,
    handleTooltipMouseOver: y,
    handleTooltipMouseOff: v
  } = e, { isolatedDotsSameSize: S, lineDatapointStyle: B, visual: R } = t, N = (ie = t == null ? void 0 : t.series.filter((U) => U.dataKey === i)) == null ? void 0 : ie[0], D = dk[t.visual.lineDatapointSymbol === "standard" && k < R.maximumShapeAmount ? k : 0], L = k === 4, ae = S ? 55 : 124, Y = (U) => (t.xAxis.type === "categorical" ? o(U) : o(d(U))) + (o.bandwidth ? o.bandwidth() / 2 : 0), Q = (U, re) => {
    const j = Y(U), de = (N == null ? void 0 : N.axis) === "Right" ? p(re) : h(re);
    return `translate(${j}, ${de})${L ? " rotate(180)" : ""}`;
  }, se = (U, re, j, de) => {
    const Z = j.runtime.seriesLabels || [], ge = j.runtime.seriesLabelsAll || [];
    let ne = U ? re(Z[de] || ge[k]) : "transparent";
    return j.lineDatapointColor === "Lighter than Line" && ne !== "transparent" && ne && (ne = Qi(ne).brighten(1)), ne;
  };
  if (["ALWAYS_SHOW_POINTS", "HOVER_POINTS"].includes(A))
    return !N || R.maximumShapeAmount === k && R.lineDatapointSymbol === "standard" ? /* @__PURE__ */ a(ze, {}) : /* @__PURE__ */ a(
      "g",
      {
        transform: Q(n[t.xAxis.dataKey], n[N == null ? void 0 : N.dataKey]),
        className: `visx-glyph-group${r ? "" : "-hidden"}`,
        "data-seriesIndex": k,
        children: /* @__PURE__ */ a(
          D,
          {
            fillOpacity: A === "ALWAYS_SHOW_POINTS" ? 1 : 0,
            fill: se(r, u, t, i)
          }
        )
      }
    );
  if (A === "ISOLATED_POINTS") {
    const U = (j, de) => {
      const Z = m[j], ge = m[j - 1] || {}, ne = m[j + 1] || {}, G = j === 0 && !ne[de], me = j === m.length - 1 && !ge[de], ye = j > 0 && j < m.length - 1 && Z[de] && !ge[de] && !ne[de];
      return G || me || ye;
    }, re = n ? m.findIndex((j) => j[t.xAxis.dataKey] === n[t.xAxis.dataKey]) : x;
    if (U(re, i)) {
      const j = u(t.runtime.seriesLabelsAll[k]);
      return /* @__PURE__ */ a(
        "g",
        {
          transform: Q(n[(M = t.xAxis) == null ? void 0 : M.dataKey], n[N == null ? void 0 : N.dataKey]),
          className: `visx-glyph-group${r ? "" : "-hidden"}`,
          "data-seriesIndex": k,
          children: /* @__PURE__ */ a(D, { size: ae, stroke: j, fill: j })
        }
      );
    }
  }
  return A === "TOOLTIP_POINTS" && r === !0 ? /* @__PURE__ */ a(
    "g",
    {
      transform: Q(g.xValue, g.yValue),
      className: "visx-glyph-circle",
      onMouseOver: (U) => {
        y(U), B == "hover" && (U.target.style.fillOpacity = "1");
      },
      onMouseOut: (U) => {
        v(), B == "hover" && (U.target.style.fillOpacity = "0");
      },
      children: /* @__PURE__ */ a(D, { size: 55, fill: g.color, fillOpacity: "0" })
    }
  ) : null;
}, hk = (e) => {
  var m, g;
  const { config: t, xScale: n, yScale: r, parseDate: i } = e;
  if (!((m = t == null ? void 0 : t.runtime) != null && m.series))
    return;
  const o = (x) => {
    if (t.xAxis.type === "date")
      return i(x).getTime();
    if (t.xAxis.type === "date-time")
      return new Date(x);
    if (t.xAxis.type === "categorical")
      return x;
  }, h = (x) => n.bandwidth ? n.bandwidth() / 2 + Number(x) : Number(x), u = (x) => {
    var A;
    return (A = Object.values(t.columns)) == null ? void 0 : A.filter((k) => k.tooltips).map((k) => `
        <li className='tooltip-body'>
          <strong>${k.label || k.name}</strong>: ${x[k.name]}
        </li>`).join(" ");
  }, d = (x) => `<ul> ${u(x)} </ul>`, p = (g = t.runtime) == null ? void 0 : g.series.map((x) => t.data.map((A, k) => {
    let y = A[x.dataKey], v = A[t.xAxis.dataKey];
    return /* @__PURE__ */ a(Me.Fragment, { children: /* @__PURE__ */ a(qe, { left: Number(t.runtime.yAxis.size), children: y && /* @__PURE__ */ O(ze, { children: [
      /* @__PURE__ */ a(
        "circle",
        {
          "data-tooltip-html": d(A),
          "data-tooltip-id": "bump-chart",
          r: 10,
          cx: Number(h(n(o(v)))),
          cy: Number(r(y)),
          stroke: "#CACACA",
          strokeWidth: 1,
          fill: "#E5E4E2"
        },
        `bump-circle-${y}-${k}`
      ),
      y.toString().length === 2 ? (
        // prettier-ignore
        /* @__PURE__ */ a(
          "text",
          {
            x: Number(h(n(o(v)))) - 7,
            y: Number(r(y)) + 4,
            fill: "#000000",
            fontSize: 11.5,
            children: y
          }
        )
      ) : (
        // prettier-ignore
        /* @__PURE__ */ a(
          "text",
          {
            x: Number(h(n(o(v)))) - 4,
            y: Number(r(y)) + 4,
            fill: "#000000",
            fontSize: 11.5,
            children: y
          }
        )
      )
    ] }) }) }, `bump-circle-${y}-${k}`);
  }));
  return /* @__PURE__ */ a(ze, { children: p });
}, wm = (e) => {
  var ie;
  const {
    getXAxisData: t,
    getYAxisData: n,
    handleTooltipMouseOff: r,
    handleTooltipMouseOver: i,
    tooltipData: o,
    xMax: h,
    xScale: u,
    yMax: d,
    yScale: p
  } = e, { colorScale: m, config: g, formatNumber: x, handleLineType: A, parseDate: k, seriesHighlight: y, tableData: v, transformedData: S, brushConfig: B, clean: R } = he.useContext(pt), { yScaleRight: N } = Ff({ config: g, yMax: d, data: S }), D = g.tooltips.singleSeries;
  if (!i)
    return;
  const { lineDatapointStyle: L, showLineSeriesLabels: q, legend: V } = g, ae = B.data.length > 0 && ((ie = g.brush) == null ? void 0 : ie.active), Y = ae ? R(B.data) : S;
  ae && R(B.data);
  const Q = (M) => u(t(M)) + (u.bandwidth ? u.bandwidth() / 2 : 0), se = [];
  return /* @__PURE__ */ O(qr, { component: "LineChart", children: [
    /* @__PURE__ */ O(qe, { left: Number(g.runtime.yAxis.size), className: "line-chart-group", children: [
      (g.runtime.lineSeriesKeys || g.runtime.seriesKeys).map((M, U) => {
        var Se;
        const re = g.runtime.series.find((ce) => ce.dataKey === M), j = re.dynamicCategory ? re.originalDataKey : M, de = re.type, Z = re.axis || "left", ge = V.behavior === "highlight" || y.length === 0 || y.indexOf(M) !== -1, ne = lk({
          data: v,
          seriesKey: M,
          preliminaryData: g.preliminaryData,
          dynamicCategory: re.dynamicCategory,
          originalSeriesKey: j,
          colorScale: m
        }), G = ((Se = g == null ? void 0 : g.preliminaryData) == null ? void 0 : Se.filter((ce) => ce.style && !ce.style.includes("Circles")).length) > 0, me = re.dynamicCategory ? Y.filter((ce) => ce[re.dynamicCategory] === M) : Y, ye = ik(g == null ? void 0 : g.preliminaryData, v, j);
        return /* @__PURE__ */ O(
          qe,
          {
            opacity: V.behavior === "highlight" && y.length > 0 && y.indexOf(M) === -1 ? 0.5 : 1,
            display: V.behavior === "highlight" || y.length === 0 && !V.dynamicLegend || y.indexOf(M) !== -1 ? "block" : "none",
            children: [
              /* @__PURE__ */ a(
                Er,
                {
                  width: Number(h),
                  height: Number(d),
                  fill: "transparent",
                  fillOpacity: 0.05
                },
                "bars"
              ),
              me.map((ce, ke) => (se.push({
                color: m(g.runtime.seriesLabels[M]),
                seriesKey: j,
                seriesIndex: U,
                xValue: ce[g.xAxis.dataKey],
                yValue: ce[j]
              }), Wa(ce[j]) && /* @__PURE__ */ O(Me.Fragment, { children: [
                g.labels && /* @__PURE__ */ a(
                  ft,
                  {
                    x: Q(ce),
                    y: Z === "Right" ? N(n(ce, j)) : p(n(ce, j)),
                    fill: "#000",
                    textAnchor: "middle",
                    children: x(ce[j], "left")
                  }
                ),
                L === "always show" && /* @__PURE__ */ a(
                  Uu,
                  {
                    mode: "ALWAYS_SHOW_POINTS",
                    dataIndex: ke,
                    tableData: v,
                    data: me,
                    d: ce,
                    config: g,
                    seriesKey: j,
                    displayArea: ge,
                    tooltipData: o,
                    xScale: u,
                    yScale: p,
                    colorScale: m,
                    parseDate: k,
                    yScaleRight: N,
                    seriesAxis: Z,
                    seriesIndex: U
                  },
                  `line-circle--${ke}`
                ),
                (L === "hover" || L === "hidden") && /* @__PURE__ */ a(
                  Uu,
                  {
                    mode: "HOVER_POINTS",
                    dataIndex: ke,
                    tableData: v,
                    data: me,
                    d: ce,
                    config: g,
                    seriesKey: j,
                    displayArea: ge,
                    xScale: u,
                    yScale: p,
                    colorScale: m,
                    parseDate: k,
                    yScaleRight: N,
                    seriesAxis: Z,
                    seriesIndex: U
                  },
                  `line-hover-circle--${ke}`
                ),
                /* @__PURE__ */ a(
                  Uu,
                  {
                    mode: "ISOLATED_POINTS",
                    seriesIndex: U,
                    dataIndex: ke,
                    tableData: v,
                    data: me,
                    d: ce,
                    config: g,
                    seriesKey: j,
                    displayArea: ge,
                    xScale: u,
                    yScale: p,
                    colorScale: m,
                    parseDate: k,
                    yScaleRight: N,
                    seriesAxis: Z
                  },
                  `isolated-circle-${ke}`
                )
              ] }, `series-${M}-point-${ke}`))),
              G ? /* @__PURE__ */ O(ze, { children: [
                /* @__PURE__ */ a(
                  ng,
                  {
                    curve: $a[re.lineType],
                    segments: me.map((ce) => [ce]),
                    segmentation: "x",
                    x: (ce) => Q(ce),
                    y: (ce) => Z === "Right" ? N(n(ce, j)) : p(Number(n(ce, j))),
                    styles: rk({
                      preliminaryData: g.preliminaryData,
                      data: v,
                      stroke: m(g.runtime.seriesLabels[M]),
                      strokeWidth: re.weight || 2,
                      handleLineType: A,
                      lineType: de,
                      seriesKey: M,
                      dynamicCategory: re.dynamicCategory,
                      originalSeriesKey: j
                    }),
                    defined: (ce, ke) => ce[j] !== "" && ce[j] !== null && ce[j] !== void 0
                  }
                ),
                ne.map((ce, ke) => Object.entries(ce.data).map(([Ie, Le]) => {
                  var Fe;
                  return /* @__PURE__ */ a(
                    Yr,
                    {
                      data: Le,
                      x: (Xe) => Q(Xe),
                      y: (Xe) => Z === "Right" ? N(n(Xe, j)) : p(Number(n(Xe, j))),
                      stroke: re.dynamicCategory ? ce.color : m(g.runtime.seriesLabels[M]),
                      strokeWidth: ((Fe = re[0]) == null ? void 0 : Fe.weight) || 2,
                      strokeOpacity: 1,
                      shapeRendering: "geometricPrecision",
                      strokeDasharray: A(ce.style),
                      defined: (Xe, Be) => Xe[j] !== "" && Xe[j] !== null && Xe[j] !== void 0
                    },
                    ke
                  );
                }))
              ] }) : /* @__PURE__ */ O(ze, { children: [
                g.confidenceKeys && g.series.map((ce, ke) => ce.dynamicCategory ? [...new Set(Y.map((Le) => Le[ce.dynamicCategory]))].map((Le, Fe) => {
                  const Xe = Y.filter((Be) => Be[ce.dynamicCategory] === Le);
                  return /* @__PURE__ */ a(
                    Mh,
                    {
                      className: "confidence-interval",
                      data: Xe,
                      x: (Be) => Q(Be),
                      y0: (Be) => p(Be[g.confidenceKeys.lower]),
                      y1: (Be) => p(Be[g.confidenceKeys.upper]),
                      opacity: 0.5,
                      fill: m(Le),
                      yScale: p,
                      curve: $a[ce.lineType]
                    },
                    `area-closed-${ke}-${Fe}`
                  );
                }) : /* @__PURE__ */ a(
                  Mh,
                  {
                    data: Y,
                    x: (Ie) => Q(Ie),
                    y0: (Ie) => p(Ie[g.confidenceKeys.lower]),
                    y1: (Ie) => p(Ie[g.confidenceKeys.upper]),
                    opacity: 0.5,
                    fill: m(
                      g.runtime.seriesLabels ? g.runtime.seriesLabels[ce.dataKey] : ce.dataKey
                    ),
                    yScale: p,
                    curve: $a[ce.lineType]
                  },
                  `area-closed-${ke}`
                )),
                /* @__PURE__ */ a(
                  Yr,
                  {
                    curve: $a[re.lineType],
                    data: g.visualizationType == "Bump Chart" ? me : g.xAxis.type === "date-time" || g.xAxis.type === "date" ? me.sort((ce, ke) => {
                      let Ie = t(ce), Le = t(ke);
                      return Ie < Le ? -1 : Le < Ie ? 1 : 0;
                    }) : me,
                    x: (ce) => Q(ce),
                    y: (ce) => Z === "Right" ? N(n(ce, j)) : p(Number(n(ce, j))),
                    stroke: m(g.runtime.seriesLabels[M]),
                    strokeWidth: re.weight || 2,
                    strokeOpacity: 1,
                    shapeRendering: "geometricPrecision",
                    strokeDasharray: de ? A(de) : 0,
                    defined: (ce, ke) => ce[j] !== "" && ce[j] !== null && ce[j] !== void 0
                  }
                )
              ] }),
              ye.map((ce, ke) => /* @__PURE__ */ a(
                "circle",
                {
                  cx: Q(ce.data),
                  cy: Z === "Right" ? N(n(ce.data, j)) : p(Number(n(ce.data, j))),
                  r: ce.size,
                  strokeWidth: re.weight || 2,
                  stroke: m ? m(g.runtime.seriesLabels[M]) : "#000",
                  fill: ce.isFilled ? m ? m(g.runtime.seriesLabels[M]) : "#000" : "#fff"
                },
                ke
              )),
              g.animate && /* @__PURE__ */ a(
                Yr,
                {
                  className: "animation",
                  curve: $a[re.lineType],
                  data: me,
                  x: (ce) => Q(ce),
                  y: (ce) => Z === "Right" ? N(n(ce, j)) : p(Number(n(ce, j))),
                  stroke: "#fff",
                  strokeWidth: 3,
                  strokeOpacity: 1,
                  shapeRendering: "geometricPrecision",
                  strokeDasharray: de ? A(de) : 0,
                  defined: (ce, ke) => ce[M] !== "" && ce[M] !== null && ce[M] !== void 0
                }
              ),
              q && (g.runtime.lineSeriesKeys || g.runtime.seriesKeys).map((ce) => {
                let ke;
                for (let Fe = me.length - 1; Fe >= 0; Fe--)
                  if (me[Fe][ce]) {
                    ke = me[Fe];
                    break;
                  }
                if (!ke || V.position === "right")
                  return /* @__PURE__ */ a(ze, {});
                let Ie = g.runtime.seriesLabels[ce] || ce;
                const Le = "...";
                return Ie.length > 10 && (Ie = Ie.substring(0, 10) + Le), /* @__PURE__ */ a(
                  ft,
                  {
                    display: V.behavior === "highlight" || y.length === 0 && !V.dynamicLegend || y.indexOf(ce) !== -1 ? "block" : "none",
                    x: Q(ke) + 5,
                    y: p(n(ke, ce)),
                    alignmentBaseline: "middle",
                    fill: m(g.runtime.seriesLabels[ce] || ce),
                    children: Ie
                  }
                );
              })
            ]
          },
          `series-${M}-${U}`
        );
      }),
      g.legend.dynamicLegend && y.length === 0 && /* @__PURE__ */ a(ft, { x: h / 2, y: d / 2, fill: "black", textAnchor: "middle", color: "black", children: g.legend.dynamicLegendChartMessage })
    ] }),
    /* @__PURE__ */ a(qe, { left: Number(g.runtime.yAxis.size), className: "glyph-tooltip-group", children: /* @__PURE__ */ O(qe, { display: "block", children: [
      /* @__PURE__ */ a(
        Er,
        {
          width: Number(h),
          height: Number(d),
          fill: "transparent",
          fillOpacity: 0.05,
          onMouseMove: (M) => {
            D || i(M, v);
          },
          onMouseOut: r
        },
        "tooltip bars"
      ),
      se.map((M, U) => {
        const { _data: re, seriesKey: j, seriesIndex: de, color: Z } = M;
        return /* @__PURE__ */ a(Me.Fragment, { children: /* @__PURE__ */ a(
          Uu,
          {
            mode: "TOOLTIP_POINTS",
            dataIndex: U,
            tooltipPoint: M,
            tableData: v,
            data: re,
            d: M,
            config: g,
            seriesKey: j,
            displayArea: !0,
            tooltipData: o,
            xScale: u,
            yScale: p,
            colorScale: m,
            parseDate: k,
            yScaleRight: N,
            seriesAxis: "[circle]",
            seriesIndex: de,
            handleTooltipMouseOver: i,
            handleTooltipMouseOff: r
          },
          `line-circle--${U}`
        ) }, `series-${j}-point-${U}`);
      })
    ] }, "tooltip-group") }),
    g.visualizationType === "Bump Chart" && /* @__PURE__ */ a(hk, { config: g, xScale: u, yScale: p })
  ] });
}, fk = ({
  xScale: e,
  yScale: t,
  config: n,
  height: r,
  width: i,
  handleTooltipMouseOff: o,
  handleTooltipMouseOver: h,
  forestPlotRightLabelRef: u
}) => {
  const { rawData: d, updateConfig: p } = he.useContext(pt), { forestPlot: m } = n, g = n.xAxis.tickWidthMax + 10, [x, A] = he.useState(!1);
  he.useEffect(() => {
    try {
      const N = ["estimateField", "lower", "upper", "estimateRadius"], D = n, L = 10;
      for (let q = 0; q < L; q++)
        N.forEach((V) => {
          var ae;
          n.forestPlot[V] && n.forestPlot[V] !== ((ae = D.columns[n.forestPlot[`additionalColumn${q}`]]) == null ? void 0 : ae.name) && (delete D.columns[`additionalColumn${q}`], D.columns[n.forestPlot[V]] = {}, D.columns[n.forestPlot[V]].dataKey = D.forestPlot[V], D.columns[n.forestPlot[V]].name = D.forestPlot[V], D.columns[n.forestPlot[V]].dataTable = !0, D.columns[n.forestPlot[V]].tooltips = !0, D.columns[n.forestPlot[V]].label = D.forestPlot[V]);
        });
      n.forestPlot.radius.scalingColumn && (D.columns[n.forestPlot.radius.scalingColumn] = {}, D.columns[n.forestPlot.radius.scalingColumn].dataKey = D.forestPlot.radius.scalingColumn, D.columns[n.forestPlot.radius.scalingColumn].name = D.forestPlot.radius.scalingColumn, D.columns[n.forestPlot.radius.scalingColumn].label = D.forestPlot.radius.scalingColumn, D.columns[n.forestPlot.radius.scalingColumn].dataTable = !0, D.columns[n.forestPlot.radius.scalingColumn].tooltips = !0), D.table.showVertical && (D.table.indexLabel = n.xAxis.dataKey), p(D);
    } catch (N) {
      console.log(N.message);
    }
  }, []), he.useEffect(() => {
    !x && n.forestPlot.type === "Logarithmic" && (p({
      ...n,
      dataFormat: {
        ...n.dataFormat,
        roundTo: 2
      }
    }), A(!0));
  }, [n.forestPlot.type]);
  const k = n.data.find((N) => N[n.xAxis.dataKey] === n.forestPlot.pooledResult.column), y = k ? [
    { x: e(k[n.forestPlot.lower]), y: r - Number(n.forestPlot.rowHeight) },
    {
      x: e(k[n.forestPlot.estimateField]),
      y: r - m.pooledResult.diamondHeight - Number(n.forestPlot.rowHeight)
    },
    { x: e(k[n.forestPlot.upper]), y: r - Number(n.forestPlot.rowHeight) },
    {
      x: e(k[n.forestPlot.estimateField]),
      y: r + m.pooledResult.diamondHeight - Number(n.forestPlot.rowHeight)
    },
    { x: e(k[n.forestPlot.lower]), y: r - Number(n.forestPlot.rowHeight) }
  ] : [], v = n.forestPlot.rowHeight, S = [
    { x: 0, y: v },
    { x: i, y: v }
  ], B = [
    { x: 0, y: r },
    { x: i, y: r }
  ], R = Object.entries(n.columns).map((N) => N[1]).filter((N) => N.forestPlot === !0);
  return /* @__PURE__ */ O(ze, { children: [
    /* @__PURE__ */ O(qe, { width: i, children: [
      m.title && /* @__PURE__ */ a(
        ft,
        {
          className: "forest-plot--title",
          x: m.type === "Linear" ? e(0) : e(1),
          y: 0,
          textAnchor: "middle",
          verticalAnchor: "start",
          fill: "black",
          children: m.title
        }
      ),
      m.lineOfNoEffect.show && m.type === "Linear" && /* @__PURE__ */ a(
        ln,
        {
          from: { x: e(0), y: 0 + v },
          to: { x: e(0), y: r },
          className: "forestplot__line-of-no-effect",
          stroke: m.regression.baseLineColor || "black"
        }
      ),
      m.lineOfNoEffect.show && m.type === "Logarithmic" && /* @__PURE__ */ a(
        ln,
        {
          from: { x: e(1), y: 0 + v },
          to: { x: e(1), y: r },
          className: "forestplot__line-of-no-effect",
          stroke: m.regression.baseLineColor || "black"
        }
      ),
      d.map((N, D) => {
        const L = $n({
          domain: d.map((se) => se[m.radius.scalingColumn]),
          range: [m.radius.min, m.radius.max]
        }), q = m.radius.scalingColumn !== "" ? L(d[D][m.radius.scalingColumn]) : 4, V = m.colors.shape ? m.colors.shape : "black", ae = m.colors.line ? m.colors.line : "black", Y = 4;
        return N[n.xAxis.dataKey] === m.pooledResult.column ? /* @__PURE__ */ a(
          Yr,
          {
            data: y,
            x: (se) => se.x,
            y: (se) => se.y - Dc / 2,
            stroke: "black",
            strokeWidth: 2,
            fill: "black",
            curve: Ph
          }
        ) : /* @__PURE__ */ O(qe, { children: [
          /* @__PURE__ */ a(
            "path",
            {
              stroke: ae,
              strokeWidth: 1,
              className: "lower-ci",
              d: `
                    M${e(N[m.lower])} ${t(D) - Number(Y)}
                    L${e(N[m.lower])} ${t(D) + Number(Y)}
                `
            }
          ),
          /* @__PURE__ */ a(
            "path",
            {
              stroke: ae,
              strokeWidth: 1,
              className: "upper-ci",
              d: `
                    M${e(N[m.upper])} ${t(D) - Number(Y)}
                    L${e(N[m.upper])} ${t(D) + Number(Y)}
                `
            }
          ),
          /* @__PURE__ */ a(
            "line",
            {
              stroke: ae,
              className: `line-${N[n.yAxis.dataKey]}`,
              x1: e(N[m.lower]),
              x2: e(N[m.upper]),
              y1: t(D),
              y2: t(D)
            },
            D
          ),
          m.shape === "circle" && /* @__PURE__ */ a(
            xv,
            {
              className: "forest-plot--circle",
              cx: e(Number(N[m.estimateField])),
              cy: t(D),
              r: m.radius.scalingColumn !== "" ? L(d[D][m.radius.scalingColumn]) : 4,
              fill: V,
              style: { opacity: 1, filter: "unset" }
            }
          ),
          m.shape === "square" && /* @__PURE__ */ a(
            "rect",
            {
              className: "forest-plot--square",
              x: e(Number(N[m.estimateField])),
              y: t(D) - q / 2,
              width: q,
              height: q,
              fill: V,
              style: { opacity: 1, filter: "unset" }
            }
          ),
          m.shape === "text" && /* @__PURE__ */ a(
            ft,
            {
              className: "forest-plot--text",
              x: e(Number(N[m.estimateField])),
              y: t(D),
              textAnchor: "middle",
              verticalAnchor: "middle",
              fill: V,
              children: N[m.estimateField]
            }
          )
        ] });
      }),
      y && m.regression.showDiamond && /* @__PURE__ */ a(
        Yr,
        {
          data: y,
          x: (N) => N.x,
          y: (N) => N.y,
          stroke: "black",
          strokeWidth: 2,
          fill: m.regression.baseLineColor,
          curve: Ph
        }
      ),
      m.regression.description && /* @__PURE__ */ a(
        ft,
        {
          x: 0 - Number(n.xAxis.size),
          width: i,
          y: r - n.forestPlot.rowHeight - Number(m.rowHeight) / 3,
          verticalAnchor: "start",
          textAnchor: "start",
          style: { fontWeight: "bold", fontSize: 12 },
          children: m.regression.description
        }
      ),
      /* @__PURE__ */ a(
        Er,
        {
          className: "forest-plot-tooltip-area",
          width: i,
          height: r,
          fill: "transparent",
          fillOpacity: 0.5,
          onMouseMove: (N) => h(N, d),
          onMouseOut: o
        },
        "forest-plot-tooltip-area"
      )
    ] }),
    /* @__PURE__ */ a(
      ln,
      {
        from: S[0],
        to: S[1],
        style: { stroke: "black", strokeWidth: 2 },
        className: "forestplot__top-line"
      }
    ),
    /* @__PURE__ */ a(
      ln,
      {
        from: B[0],
        to: B[1],
        style: { stroke: "black", strokeWidth: 2 },
        className: "forestplot__bottom-line"
      }
    ),
    R.map((N) => d.map((D, L) => /* @__PURE__ */ a(
      ft,
      {
        className: `${D[N.name]}`,
        x: N.forestPlotAlignRight ? i : N.forestPlotStartingPoint,
        y: t(L),
        textAnchor: N.forestPlotAlignRight ? "end" : "start",
        verticalAnchor: "middle",
        fill: "black",
        children: D[N.name]
      }
    ))),
    !m.hideDateCategoryCol && d.map((N, D) => /* @__PURE__ */ a(
      ft,
      {
        className: `${N[n.xAxis.dataKey]}`,
        x: 0,
        y: t(D),
        textAnchor: "start",
        verticalAnchor: "middle",
        fill: "black",
        children: N[n.xAxis.dataKey]
      }
    )),
    !m.hideDateCategoryCol && n.xAxis.dataKey && /* @__PURE__ */ a(ft, { className: n.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fill: "black", children: n.xAxis.dataKey }),
    R.map((N) => /* @__PURE__ */ a(
      ft,
      {
        className: `${N.label}`,
        x: N.forestPlotAlignRight ? i : N.forestPlotStartingPoint,
        y: 0,
        textAnchor: N.forestPlotAlignRight ? "end" : "start",
        verticalAnchor: "start",
        fill: "black",
        children: N.label
      }
    )),
    m.leftLabel && /* @__PURE__ */ a(
      ft,
      {
        className: "forest-plot__left-label",
        x: m.type === "Linear" ? e(0) - 25 : e(1) - 25,
        y: r + g,
        textAnchor: "end",
        verticalAnchor: "start",
        children: m.leftLabel
      }
    ),
    m.rightLabel && /* @__PURE__ */ a(
      ft,
      {
        innerRef: u,
        className: "forest-plot__right-label",
        x: m.type === "Linear" ? e(0) + 25 : e(1) + 25,
        y: r + g,
        textAnchor: "start",
        verticalAnchor: "start",
        children: m.rightLabel
      }
    )
  ] });
}, pk = ({ width: e, height: t, originalWidth: n }) => {
  var S, B, R;
  const { config: r, colorScale: i, transformedData: o, formatNumber: h, seriesHighlight: u } = he.useContext(pt);
  if (!r || ((S = r == null ? void 0 : r.series) == null ? void 0 : S.length) < 2)
    return;
  const d = r.barHasBorder === "true" ? 1 : 0, p = e / 2, m = 1.02, g = {
    parentKey: (B = r.dataDescription) == null ? void 0 : B.seriesKey,
    dataKey: r.series[0].dataKey,
    dataKeyLabel: r.runtime.seriesLabels[r.series[0].dataKey] || r.series[0].dataKey,
    color: i(r.runtime.seriesLabels[r.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((N) => N[r.series[0].dataKey])
    ),
    labelColor: ""
  }, x = {
    parentKey: (R = r.dataDescription) == null ? void 0 : R.seriesKey,
    dataKey: r.series[1].dataKey,
    dataKeyLabel: r.runtime.seriesLabels[r.series[1].dataKey] || r.series[1].dataKey,
    color: i(r.runtime.seriesLabels[r.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((N) => N[r.series[1].dataKey])
    ),
    labelColor: ""
  }, A = $n({
    domain: [0, Math.max(g.max * m, x.max * 1.1)],
    range: [0, p]
  });
  g.labelColor = g.color ? is(Ir, g.color) : Ir, x.labelColor = x.color ? is(Ir, x.color) : Ir;
  const k = r.yAxis.label ? `${r.yAxis.label}: ` : "", y = (N) => {
    var D;
    return `<p>
				${(D = r.dataDescription) == null ? void 0 : D.seriesKey}: ${g.dataKeyLabel}<br/>
				${r.xAxis.dataKey}: ${N[r.xAxis.dataKey]}<br/>
				${k}${h(N[g.dataKey], "left")}
			</p>`;
  }, v = (N) => {
    var D;
    return `<p>
				${(D = r.dataDescription) == null ? void 0 : D.seriesKey}: ${x.dataKeyLabel}<br/>
				${r.xAxis.dataKey}: ${N[r.xAxis.dataKey]}<br/>
				${k}${h(N[x.dataKey], "left")}
			</p>`;
  };
  return e > 0 && /* @__PURE__ */ O(ze, { children: [
    /* @__PURE__ */ a("style", { children: `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				` }),
    /* @__PURE__ */ O(
      "svg",
      {
        id: "cdc-visualization__paired-bar-chart",
        width: n,
        height: t,
        viewBox: `0 0 ${e + Number(r.runtime.yAxis.size)} ${t}`,
        role: "img",
        tabIndex: 0,
        children: [
          /* @__PURE__ */ a("title", { children: `Paired bar chart graphic with the title ${r.title ? r.title : "No Title Found"}` }),
          /* @__PURE__ */ O(qe, { top: 0, left: Number(r.xAxis.size), children: [
            o.filter((N) => r.series[0].dataKey === g.dataKey).map((N, D) => {
              var M, U;
              let L = r.legend.behavior === "highlight" && u.length > 0 && u.indexOf(r.series[0].dataKey) === -1, q = r.legend.behavior === "highlight" || u.length === 0 || u.indexOf(r.series[0].dataKey) !== -1, V = A(N[r.series[0].dataKey]), ae = Number(r.barHeight) ? Number(r.barHeight) : 25, Y = 0;
              Y = D !== 0 ? (Number(r.barSpace) + ae + d) * D : Y;
              const Q = (Number(r.barSpace) + ae + d) * o.length;
              r.heights.horizontal = Q;
              const ie = yr(h(N[g.dataKey], "left")) < V - 5;
              return /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O(qe, { className: "horizontal", children: [
                /* @__PURE__ */ a(
                  Er,
                  {
                    id: `bar-${g.dataKey}-${N[(M = r.dataDescription) == null ? void 0 : M.xKey]}`,
                    className: "bar group-1",
                    x: p - V,
                    y: Y,
                    width: A(N[r.series[0].dataKey]),
                    height: ae,
                    fill: g.color,
                    "data-tooltip-html": y(N),
                    "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
                    stroke: "#333",
                    strokeWidth: d,
                    opacity: L ? 0.5 : 1,
                    display: q ? "block" : "none",
                    tabIndex: -1
                  },
                  `bar-${g.dataKey}-${N[(U = r.dataDescription) == null ? void 0 : U.xKey]}`
                ),
                r.yAxis.displayNumbersOnBar && q && /* @__PURE__ */ a(
                  ft,
                  {
                    textAnchor: ie ? "start" : "end",
                    dx: ie ? 5 : -5,
                    verticalAnchor: "middle",
                    x: p - V,
                    y: Y + r.barHeight / 2,
                    fill: ie ? g.labelColor : "#000",
                    children: h(N[g.dataKey], "left")
                  }
                )
              ] }, `group-${g.dataKey}-${N[r.xAxis.dataKey]}`) });
            }),
            o.filter((N) => r.series[1].dataKey === x.dataKey).map((N, D) => {
              var M, U, re;
              let L = A(N[r.series[1].dataKey]), q = r.legend.behavior === "highlight" && u.length > 0 && u.indexOf(r.series[1].dataKey) === -1, V = r.legend.behavior === "highlight" || u.length === 0 || u.indexOf(r.series[1].dataKey) !== -1, ae = r.barHeight ? Number(r.barHeight) : 25, Y = 0;
              Y = D !== 0 ? (Number(r.barSpace) + ae + d) * D : Y;
              const Q = (Number(r.barSpace) + ae + d) * o.length;
              r.heights.horizontal = Q;
              const ie = yr(h(N[x.dataKey], "left")) < L - 5;
              return /* @__PURE__ */ O(ze, { children: [
                /* @__PURE__ */ a("style", { children: `
                      .bar-${x.dataKey}-${N[r.xAxis.dataKey]} {
                          transform-origin: ${p}px ${Y}px
                      }
							      ` }),
                /* @__PURE__ */ O(qe, { className: "horizontal", children: [
                  /* @__PURE__ */ a(
                    Er,
                    {
                      id: `bar-${x.dataKey}-${N[(M = r.dataDescription) == null ? void 0 : M.xKey]}`,
                      className: "bar group-2",
                      x: p,
                      y: Y,
                      width: A(N[r.series[1].dataKey]),
                      height: ae,
                      fill: x.color,
                      "data-tooltip-html": v(N),
                      "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
                      strokeWidth: d,
                      stroke: "#333",
                      opacity: q ? 0.5 : 1,
                      display: V ? "block" : "none",
                      tabIndex: -1
                    },
                    `bar-${x.dataKey}-${N[(U = r.dataDescription) == null ? void 0 : U.xKey]}`
                  ),
                  r.yAxis.displayNumbersOnBar && V && /* @__PURE__ */ a(
                    ft,
                    {
                      textAnchor: ie ? "end" : "start",
                      dx: ie ? -5 : 5,
                      verticalAnchor: "middle",
                      x: p + L,
                      y: Y + r.barHeight / 2,
                      fill: ie ? x.labelColor : "#000",
                      children: h(N[x.dataKey], "left")
                    }
                  )
                ] }, `group-${x.dataKey}-${N[(re = r.dataDescription) == null ? void 0 : re.xKey]}`)
              ] });
            })
          ] })
        ]
      }
    )
  ] });
}, mk = ({ yMax: e, leftSize: t, max: n, xMax: r }) => {
  var v;
  const { config: i } = he.useContext(pt), { orientation: o } = i, h = (S, B = "#f1f1f1") => {
    try {
      return Qi(S).hex();
    } catch {
      return B;
    }
  }, u = (v = i.yAxis) == null ? void 0 : v.categories, m = ((S) => {
    const B = Object.keys(S), R = B[B.length - 1];
    if (S[R] === "") {
      const N = B.slice(0, -1).reduce((L, q) => {
        const V = Number(S[q]);
        return L + (isNaN(V) ? 0 : V);
      }, 0), D = n - N;
      S[R] = D;
    }
    return [S];
  })(((S) => [...S].reduce((R, N) => (R[N.label] = N.height, R), {}))(u)), g = 0, x = wc({
    domain: [g],
    padding: 0,
    range: [0, t]
  }), A = $n({
    domain: [0, n],
    range: [e, 0],
    clamp: !0
  }), k = Df({
    domain: u.map((S) => S == null ? void 0 : S.label),
    range: u.map((S) => {
      var B;
      return h((B = S == null ? void 0 : S.color) == null ? void 0 : B.trim());
    })
  }), y = Object.keys(m[0]);
  return /* @__PURE__ */ a(qe, { left: t - x.bandwidth(), top: 0, children: /* @__PURE__ */ a(
    tg,
    {
      data: m,
      keys: y,
      x: () => x(g),
      xScale: x,
      yScale: A,
      color: k,
      children: (S) => S.map(
        (B) => B.bars.map((R) => {
          const N = i.yAxis.categories.length - 1 === B.index, D = Dc / 1.3, L = Qi(R.color).luminance() < 0.4 ? "#fff" : "#000", q = yr(R.key, `${D}px`), V = Number(q) < R.width && R.height > D, ae = `<ul>
              <li class="tooltip-heading""> Label : ${R.key}  </li>
                    </li></ul>`;
          return /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ O(
            qe,
            {
              id: `barStack${B.index}-${R.index}`,
              className: "stack vertical",
              children: [
                $l({
                  type: "axisBar",
                  config: i,
                  index: B.index,
                  background: k(R.key),
                  borderColor: "#333",
                  borderStyle: "solid",
                  borderWidth: 0,
                  width: x.bandwidth(),
                  height: R.height,
                  x: R.x,
                  y: R.y,
                  tooltipHtml: ae,
                  tooltipId: `cdc-open-viz-tooltip-${i.runtime.uniqueId}`
                }),
                /* @__PURE__ */ a(
                  ft,
                  {
                    display: V ? "block" : "none",
                    x: R.x + x.bandwidth() / 2,
                    y: R.y + R.height / 2,
                    fill: L,
                    textAnchor: "middle",
                    verticalAnchor: "middle",
                    style: { fontSize: D },
                    children: R.key
                  },
                  `text-${B.index}-${R.index}`
                ),
                i.runtime.yAxis.gridLines && /* @__PURE__ */ a(
                  ln,
                  {
                    from: { x: R.x + x.bandwidth(), y: R.y },
                    to: { x: r + x.bandwidth(), y: R.y },
                    stroke: "#d6d6d6"
                  }
                ),
                !N && /* @__PURE__ */ a("rect", { x: R.x, y: R.y, width: R.width, height: 1, fill: "#fff" }),
                /* @__PURE__ */ a("rect", { x: R.x + R.width, y: 0, width: 1, height: e, fill: "#000" })
              ]
            },
            `bar-stack-${B.index}-${R.index}`
          ) }, `${B.index}--${R.index}--${o}`);
        })
      )
    }
  ) });
};
function yk({ orientation: e, heights: t, visualizationType: n }, r) {
  const o = e === "vertical" || n === "Forest Plot", u = (t == null ? void 0 : t.mobileVertical) && mh(r) ? "mobileVertical" : "vertical";
  return o ? u : "horizontal";
}
function gk({ heights: e, orientation: t, visualizationType: n }, r) {
  if (!e)
    return 0;
  const i = yk({ orientation: t, heights: e, visualizationType: n }, r), o = Number(e == null ? void 0 : e[i]);
  return isNaN(o) ? 0 : o;
}
function vk(e, t, n) {
  var v, S;
  const r = e.current.getBoundingClientRect().x, i = !!document.querySelector(".editor-panel:not(.hidden)"), o = (S = (v = t.current) == null ? void 0 : v[t.current.length - 1]) == null ? void 0 : S.getBoundingClientRect(), h = o ? o.x + o.width : 0, u = i ? Om : 0, d = h - r - u - n, p = hv.clamp(d, 0, 20), m = Number(e.current.style.paddingRight.replace("px", "")), g = Math.abs(m - p), x = 5, A = m === d, k = g < x && d > 0 || Math.abs(d) < 1;
  return [!A && !k, p];
}
const bg = ({ config: e, minValue: t, maxValue: n, existPositiveValue: r, data: i, isAllLine: o, tableData: h }) => {
  let u = 0, d = 0, p = 0, m = 0;
  const { convertLineToBarGraph: g } = he.useContext(pt);
  if (!i)
    return { min: u, max: d };
  const { visualizationType: x, series: A } = e, { max: k, min: y } = e.runtime.yAxis, v = e.yAxis.enablePadding ? 1 + e.yAxis.scalePadding / 100 : 1, S = e.yAxis.type === "logarithmic", B = r ? Number(k) >= n : Number(k) >= 0, R = S ? Number(y) >= 0 : Number(y) <= 0 && t >= 0 || Number(y) <= t && t < 0;
  u = y && R ? Number(y) : t, d = k && B ? Number(k) : Number.MIN_VALUE;
  const { lower: N, upper: D } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (N && D && e.visualizationType === "Bar") {
    const L = u < 0 ? 1.1 : 0, q = Math.max(...i.flatMap((ae) => [ae[D], ae[N]])) * v, V = Math.min(...i.flatMap((ae) => [ae[D], ae[N]])) * v * L;
    d = d > q ? d : q, u = u < V ? u : V;
  }
  if (e.series.filter((L) => (L == null ? void 0 : L.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: L }
    } = e;
    if ((L == null ? void 0 : L.length) > 0) {
      let q = [];
      L.forEach((Q) => {
        var se;
        (se = Q.confidenceIntervals) == null || se.map((ie) => {
          q.push(ie.high), q.push(ie.low);
        });
      });
      const V = i.map((Q) => q.map((se) => Q[se])), ae = Math.max.apply(
        null,
        V.map((Q) => Q[0])
      ), Y = Math.min.apply(
        null,
        V.map((Q) => Q[1])
      );
      ae > d && (d = ae), Y < u && (u = Y);
    }
  }
  if (x === "Combo")
    try {
      if (!i)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let L = A.filter((ae) => ae.axis === "Left"), q = A.filter((ae) => ae.axis === "Right");
      const V = (ae, Y, Q, se = "left") => {
        let ie = 0;
        return (Y.map((U) => U.dataKey) || []).forEach((U) => {
          let re = Y.find((Z) => Z.dataKey === U), j = ae.map((Z) => Z[U]), de = Math.max.apply(null, j);
          e.visualizationSubType === "stacked" && se === "left" && re.type === "Bar" && (ie += de), de > Q && (Q = de), Q < ie && (Q = ie);
        }), Q;
      };
      p = V(i, L, p, "left"), m = V(i, q, m, "right"), p < Number(k) && (p = Number(k));
    } catch (L) {
      console.error(L.message);
    }
  if ((x === "Bar" || g || x === "Combo" && !o) && u > 0 && (u = 0), (e.visualizationType === "Bar" || g || e.visualizationType === "Combo" && !o) && u < 0 && (u = u * 1.1), e.visualizationType === "Combo" && o && ((y == null || y === "") && u > 0 && (u = 0), y)) {
    const L = S ? Number(y) >= 0 && Number(y) < t : Number(y) < t;
    u = Number(y) && L ? Number(y) : t;
  }
  if (e.visualizationType === "Deviation Bar" && u > 0) {
    const L = Number(y) < Math.min(t, Number(e.xAxis.target));
    u = Number(y) && L ? Number(y) : 0;
  }
  if (e.visualizationType === "Line" && !g) {
    const L = Number(y), q = S ? L >= 0 && L < t : L < t, V = h == null ? void 0 : h.some(
      (Y, Q, se) => {
        var ie;
        return (ie = e.preliminaryData) == null ? void 0 : ie.some(({ type: M, style: U, column: re, value: j }) => {
          var G;
          if (M !== "suppression" || !U)
            return !1;
          const de = Ke.values(Ke.pick(Y, (G = e.runtime) == null ? void 0 : G.seriesKeys)), Z = e.series[0].dynamicCategory, ge = re ? Y[re] === j : de.includes(j), ne = Z && (Y[Z] === re || !re);
          return (ge || ne) && (Q === 0 || Q === se.length - 1);
        });
      }
    ), ae = e.yAxis.type === "categorical";
    u = y !== "" && q ? L : V || ae ? 0 : t;
  }
  if (d === Number.MIN_VALUE && (d = r ? n : 0), e.runtime.yAxis.paddingPercent) {
    let L = (d - u) * e.runtime.yAxis.paddingPercent;
    u -= L, d += L;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const L = i.map((V) => V[e.series[0].dataKey]), q = Math.max(...L).toString().length;
    switch (!0) {
      case (q > 8 && q <= 12):
        d = d * 1.3;
        break;
      case (q > 4 && q <= 7):
        d = d * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (u < 0 ? (d *= 1 + e.yAxis.scalePadding * 2 / 100, u *= 1 + e.yAxis.scalePadding * 2 / 100) : d *= 1 + e.yAxis.scalePadding / 100), e.visualizationType === "Area Chart" && e.visualizationSubType === "stacked" && (u = 0), e.visualizationType === "Scatter Plot" && (d = d * 1.1), { min: u, max: d, leftMax: p, rightMax: m };
};
function bk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const Hl = () => {
  const { config: e } = he.useContext(pt), { visualizationType: t, series: n, orientation: r, visualizationSubType: i } = e, o = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Bump Chart",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], h = [
    "theme-blue",
    "theme-purple",
    "theme-brown",
    "theme-teal",
    "theme-pink",
    "theme-orange",
    "theme-slate",
    "theme-indigo",
    "theme-cyan",
    "theme-green",
    "theme-amber"
  ], u = () => !["Forest Plot", "Sankey"].includes(t), d = () => !!["Scatter Plot"].includes(t), p = () => !!["Scatter Plot"].includes(t), m = () => !["Spark Line"].includes(t), g = () => !["Spark Line"].includes(t), x = () => ![
    "Area Chart",
    "Box Plot",
    "Pie",
    "Scatter Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), A = () => ![
    "Area Chart",
    "Scatter Plot",
    "Box Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), k = () => {
    switch (t) {
      case "Box Plot":
        return !0;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, y = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), v = () => !!["Bar", "Combo", "Line"].includes(e.visualizationType), S = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, B = () => {
    if ((t === "Bar" || "Combo") && i === "regular")
      return !0;
  }, R = () => e.xAxis.type === "categorical" ? !1 : ["Line", "Bar", "Area Chart", "Combo"].includes(t) && r === "vertical", N = () => ["Box Plot", "Scatter Plot", "Pie", "Line"].includes(t) ? !1 : n == null ? void 0 : n.some(
    (at) => at.type === "Bar" || at.type === "Paired Bar" || at.type === "Deviation Bar"
  ), D = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, L = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: o,
    headerColors: h,
    visCanAnimate: A,
    visHasAnchors: S,
    visHasBarBorders: N,
    visHasDataCutoff: D,
    visHasLabelOnData: x,
    visHasDataSuppression: B,
    visHasLegend: k,
    visHasLegendAxisAlign: () => t === "Bar" && i === "stacked" && e.legend.behavior === "isolate",
    visHasLegendColorCategory: () => {
      var je;
      return t === "Bar" && i === "regular" && ((je = e.series) == null ? void 0 : je.length) === 1;
    },
    visHasBrushChart: R,
    visHasNumbersOnBars: y,
    visHasaAdditionalLabelsOnBars: v,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : r === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsMobileChartHeight: () => !!["Bar", "Line", "Combo", "Area Chart"].includes(t),
    visSupportsDateCategoryAxis: u,
    visSupportsDateCategoryAxisMin: d,
    visSupportsDateCategoryAxisMax: p,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line", "Bump Chart"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !(["Spark Line", "Sankey", "Bump Chart"].includes(t) || e.orientation !== "horizontal"),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: g,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => !!["Line", "Bar", "Combo"].includes(t),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: m,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: L,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const je = ["Forest Plot"];
      return !(r === "horizontal" || je.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot", "Bump Chart"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (e.yAxis.type === "categorical" || ["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t))
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t),
    visSupportsDynamicSeries: () => t === "Line" || t === "Bar" || t === "Scatter Plot" || t === "Area Chart",
    visSupportsYPadding: () => {
      var je;
      return !e.dataFormat.onlyShowTopPrefixSuffix || !((je = e.dataFormat.suffix) != null && je.includes(" "));
    },
    visHasSingleSeriesTooltip: () => t === "Bar" || t === "Line" || t === "Area Chart" && i === "stacked",
    visHasCategoricalAxis: () => {
      if ((t === "Line" || t === "Bar" || t === "Combo" || t === "Area Chart") && e.yAxis.type === "categorical" && r === "vertical")
        return !0;
    }
  };
}, xk = ({ data: e, xScale: t, yScale: n, config: r, xMax: i, annotationSeriesKey: o }, h) => {
  const { xAxis: u, visualizationType: d, orientation: p } = r, m = (v, S, B, R, N) => {
    let D = [];
    r.xAxis.type === "date-time" && (S = new Date(S), B = new Date(B), R = R.map((V) => new Date(V)), D = N.ticks().map((V) => new Date(V)));
    const L = (v - S) / (B - S), q = Math.round(L * (R.length - 1));
    return r.xAxis.type === "date-time" ? D[q] : R[q];
  }, x = ((v, S = !1) => {
    if (d !== "Pie" && p !== "horizontal") {
      if (r.xAxis.type === "date-time") {
        const B = new Date(t.invert(v)), R = r.data.map((L) => new Date(L[r.xAxis.dataKey]).getTime());
        let N = 1 / 0, D = null;
        return R.forEach((L) => {
          const q = Math.abs(B.getTime() - L);
          q < N && (N = q, D = L);
        }), new Date(D).getTime();
      }
      if (r.xAxis.type === "categorical" || d === "Combo" && p !== "horizontal" && d !== "Forest Plot") {
        const R = (t.range()[1] - t.range()[0]) / (t.domain().length + 1), D = Math.floor((Number(v) - R / 2) / R);
        return t.domain()[D];
      }
      if (r.xAxis.type === "date") {
        const B = m(v, 0, i, t.domain(), t);
        let R = null, N = Number.MAX_VALUE;
        return t.domain().forEach((D) => {
          const L = Math.abs(B - D);
          L < N && (N = L, R = D);
        }), R;
      }
      return v;
    }
  })(h - Number(r.yAxis.size || 0));
  let A = [];
  if (!x)
    return { x: 0, y: 0 };
  u.type === "categorical" && (A = r.data.filter((v) => v[r.xAxis.dataKey] === x)), (u.type === "date" || u.type === "date-time") && (A = r.data.filter((v) => new Date(v[r.xAxis.dataKey]).getTime() === x));
  const k = A[0][o];
  return { x, y: k };
}, Sk = (e, t, n) => {
  const { connectionLocation: r } = e;
  return r === "right" ? "end" : r === "left" ? "start" : r === "bottom" || r === "top" || t(e.xKey) + e.dx < n.yAxis.size ? "middle" : null;
}, wk = (e, t, n) => {
  const { connectionLocation: r } = e;
  return r === "top" ? "start" : r === "bottom" ? "end" : r === "right" || r === "left" ? "middle" : t(e.xKey) + e.dx < n.yAxis.size ? "end" : null;
};
const kk = ({ xScale: e, yScale: t, xScaleAnnotation: n, xMax: r, svgRef: i, onDragStateChange: o }) => {
  const { config: h, dimensions: u, isEditor: d, updateConfig: p, colorScale: m } = he.useContext(pt), { annotations: g } = h, [x] = u, A = d ? Wg : jg;
  return g && g.map((k, y) => {
    var R;
    const v = k.text || "", S = n(k.x), B = () => ({
      __html: Mm.sanitize(v)
    });
    return /* @__PURE__ */ O(
      A,
      {
        width: 200,
        height: x,
        dx: k.dx,
        dy: k.dy,
        x: S,
        y: k.y,
        canEditLabel: k.edit.label || !1,
        canEditSubject: k.edit.subject && k.connectionType !== "none" || !1,
        onDragStart: () => o(!0),
        onDragEnd: (N) => {
          o(!1);
          let D = [...g];
          if (k.x === n.invert(N.x) && k.y === N.y)
            D[y] = { ...D[y], dx: N.dx, dy: N.dy };
          else if (k.snapToNearestPoint) {
            let L = xk(
              {
                data: h.data,
                xScale: e,
                yScale: t,
                config: h,
                xMax: r - h.yAxis.size / 2,
                annotationSeriesKey: k.seriesKey
              },
              N.x
            );
            D[y] = {
              ...D[y],
              x: n.invert(e(L.x)),
              y: t(L.y)
            };
          } else
            D[y] = {
              ...D[y],
              x: n.invert(N.x),
              y: N.y
            };
          p({
            ...h,
            annotations: D
          });
        },
        children: [
          /* @__PURE__ */ a(
            Hg,
            {
              className: "annotation__desktop-label",
              showAnchorLine: !1,
              horizontalAnchor: Sk(k, e, h),
              verticalAnchor: wk(k, e, h),
              children: /* @__PURE__ */ O(
                "div",
                {
                  style: {
                    borderRadius: 5,
                    // Optional: set border radius
                    backgroundColor: `rgba(255, 255, 255, ${k != null && k.opacity ? Number(k == null ? void 0 : k.opacity) / 100 : 1})`,
                    padding: "10px",
                    width: "auto",
                    display: h.general.showAnnotationDropdown ? "inline-flex" : "flex",
                    justifyContent: "start",
                    flexDirection: "row"
                  },
                  tabIndex: 0,
                  "aria-label": `Annotation text that reads: ${k.text}`,
                  children: [
                    ((R = h == null ? void 0 : h.general) == null ? void 0 : R.showAnnotationDropdown) && /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ a("p", { className: "annotation__has-dropdown-number", style: { margin: "2px 6px" }, children: y + 1 }) }),
                    /* @__PURE__ */ a("div", { dangerouslySetInnerHTML: B() })
                  ]
                }
              )
            }
          ),
          k.connectionType === "line" && /* @__PURE__ */ a(Xf, { type: "line", pathProps: { markerStart: `url(#marker-start--${y})` } }),
          k.connectionType === "elbow" && /* @__PURE__ */ a(Xf, { type: "elbow", pathProps: { markerStart: `url(#marker-start--${y})` } }),
          k.connectionType === "curve" && /* @__PURE__ */ a(
            Yr,
            {
              d: `M ${S},${k.y}
                      Q ${S + k.dx / 2}, ${k.y + k.dy / 2 + Number(k == null ? void 0 : k.bezier) || 0} ${S + k.dx},${k.y + k.dy}`,
              stroke: "black",
              strokeWidth: "2",
              fill: "none",
              "marker-start": `url(#marker-start--${y})`
            }
          ),
          k.marker === "circle" && /* @__PURE__ */ a(
            Vg,
            {
              id: `marker-start--${y}`,
              className: "circle-subject",
              stroke: m(k.seriesKey),
              radius: 8
            }
          ),
          k.marker === "arrow" && /* @__PURE__ */ a(
            Fm,
            {
              fill: "black",
              id: `marker-start--${y}`,
              x: S,
              y: k.y,
              stroke: "#333",
              markerWidth: 10,
              size: 10,
              strokeWidth: 1,
              orient: "auto-start-reverse",
              markerUnits: "userSpaceOnUse"
            }
          ),
          /* @__PURE__ */ a(
            "circle",
            {
              fill: "white",
              cx: S + k.dx,
              cy: k.y + k.dy,
              r: 16,
              className: "annotation__mobile-label annotation__mobile-label-circle",
              stroke: m(k.seriesKey)
            }
          ),
          /* @__PURE__ */ a(
            "text",
            {
              height: 16,
              x: S + k.dx,
              y: k.y + k.dy,
              className: "annotation__mobile-label",
              alignmentBaseline: "middle",
              textAnchor: "middle",
              children: y + 1
            }
          )
        ]
      }
    );
  });
};
const Tk = ({ useBootstrapVisibilityClasses: e = !0 }) => {
  const { config: t } = he.useContext(pt), n = t.annotations || [], r = () => {
    const o = ["annotation-list"];
    return e && o.push("d-block", "d-md-none"), o.join(" ");
  }, i = n.map((o, h) => {
    const u = o.text || "", d = () => ({
      __html: Mm.sanitize(u)
    });
    return /* @__PURE__ */ a("li", { children: /* @__PURE__ */ O("div", { className: "annotation__title-wrapper", children: [
      /* @__PURE__ */ a("div", { className: "annotation__title-circle", children: h + 1 }),
      /* @__PURE__ */ a("p", { className: "annotation__subtext", dangerouslySetInnerHTML: d() })
    ] }) }, "annotation-li-item__annotationIndex");
  });
  return /* @__PURE__ */ a("ul", { className: r(), children: i });
};
const Ck = () => {
  var d;
  const { currentViewport: e, config: t } = he.useContext(pt), [n, r] = he.useState(!1), i = ["sm", "xs", "xxs"].includes(e) ? "13px" : `${Dc}px`;
  he.useContext(pt);
  const o = {
    maxHeight: t.table.limitHeight && `${t.table.height}px`,
    OverflowY: "scroll"
  }, h = () => {
    const p = ["data-table-heading", "annotation__dropdown-list", "p-3"];
    return n || p.push("collapsed"), p.join(" ");
  };
  return /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O("section", { className: (() => {
    const p = ["data-table-container", e, "d-block", "d-lg-none", "w-100"];
    return t.general.showAnnotationDropdown && (p.push("d-lg-block"), p.splice(p.indexOf("d-lg-none"), 1)), p.join(" ");
  })(), children: [
    /* @__PURE__ */ O(
      "div",
      {
        style: { fontSize: i },
        role: "button",
        className: h(),
        onClick: () => {
          r(!n);
        },
        tabIndex: 0,
        onKeyDown: (p) => {
          p.keyCode === 13 && r(!n);
        },
        children: [
          /* @__PURE__ */ a(Ve, { display: n ? "minus" : "plus", base: !0 }),
          t.general.annotationDropdownText === "" ? "Annotations" : (d = t == null ? void 0 : t.general) == null ? void 0 : d.annotationDropdownText
        ]
      }
    ),
    n && /* @__PURE__ */ a("div", { className: "table-container annotation-dropdown__panel", style: o, children: /* @__PURE__ */ a(If.List, { useBootstrapVisibilityClasses: !1 }) })
  ] }) });
}, If = {
  Draggable: kk,
  // Mobile auto display
  List: Tk,
  // Desktop Accessible Option
  Dropdown: Ck
}, Ak = ({ axis: e, max: t, runtime: n, currentViewport: r, isHorizontal: i, data: o, config: h, min: u }) => {
  let { numTicks: d } = n[e];
  n[e].viewportNumTicks && n[e].viewportNumTicks[r] && (d = n[e].viewportNumTicks[r]);
  let p;
  return e === "yAxis" && (p = i && !d ? o.length : i && d ? d : !i && !d ? void 0 : !i && d && d, p === void 0 && !h.dataFormat.roundTo && (Number(t) <= 3 ? p = 2 : p = 4), Number(p) > Number(t) && !i && (p = Math.max(2, Number(u) < 0 ? Math.round(t) * 2 : Math.round(t)))), e === "xAxis" && (p = i && !d ? void 0 : i && d ? d : !i && !d ? void 0 : !i && d && d, i && p === void 0 && !h.dataFormat.roundTo && (t <= 3 ? p = 2 : p = 4), h.visualizationType === "Forest Plot" && (p = h.yAxis.numTicks !== "" ? h.yAxis.numTicks : 4)), p;
}, dh = 9, Gu = 4.5, hh = 8, Lk = 1e3 * 60 * 60 * 24 * 30, Ek = 16, _k = 13, Pk = 18, Nk = 14, Rk = 4.5, fh = he.forwardRef(({ parentHeight: e, parentWidth: t }, n) => {
  var Xn, Vn, or, qn, Zn, b;
  const {
    brushConfig: r,
    colorScale: i,
    config: o,
    convertLineToBarGraph: h,
    currentViewport: u,
    dimensions: d,
    formatDate: p,
    formatNumber: m,
    handleChartAriaLabels: g,
    handleLineType: x,
    handleDragStateChange: A,
    isDraggingAnnotation: k,
    legendRef: y,
    parseDate: v,
    parentRef: S,
    tableData: B,
    transformedData: R,
    seriesHighlight: N
  } = he.useContext(pt), {
    heights: D,
    visualizationType: L,
    visualizationSubType: q,
    orientation: V,
    xAxis: ae,
    yAxis: Y,
    runtime: Q,
    legend: se,
    forestPlot: ie,
    brush: M,
    dataFormat: U,
    debugSvg: re
  } = o, { suffix: j, onlyShowTopPrefixSuffix: de } = U, { labelsAboveGridlines: Z, hideAxis: ge } = o.yAxis, { minValue: ne, maxValue: G, existPositiveValue: me, isAllLine: ye } = qc(o, R), { visSupportsReactTooltip: Se } = Hl(), { hasTopAxis: ce } = bk(o), [ke, Ie] = he.useState(!1), [Le, Fe] = he.useState({ x: 0, y: 0 }), [Xe, Be] = he.useState(0), [ot, gt] = he.useState(0), st = he.useRef(null), dt = he.useRef(null), Ye = he.useRef(null), Je = he.useRef(null), yt = he.useRef(), nt = he.useRef([]), lt = he.useRef(null), je = he.useRef(G), at = he.useRef([]), ct = Pf(yt, {
    freezeOnceVisible: !1
  }), wt = !0, rn = V === "horizontal" || o.visualizationType === "Forest Plot", Ne = o.yAxis.type === "logarithmic", Ct = L === "Forest Plot", bn = o.xAxis.type === "date-time", Zt = !j.includes(" "), jt = de && !Zt, Qt = Number(V === "horizontal" ? o.xAxis.size : o.yAxis.size), _n = isNaN(parseInt(`${Q.yAxis.labelOffset}`)) ? 0 : parseInt(`${Q.yAxis.labelOffset}`), Gt = mh(u) ? _k : Ek, fn = mh(u) ? Nk : Pk, Nt = `normal ${Gt}px Nunito, sans-serif`, Yt = Ct ? o.data.length * o.forestPlot.rowHeight : 0, tn = he.useMemo(
    () => gk(o, u),
    [o, u, e, (Xn = o.heights) == null ? void 0 : Xn.vertical, (Vn = o.heights) == null ? void 0 : Vn.horizontal]
  ), zt = he.useMemo(() => tn + Yt, [tn, Yt]), It = he.useMemo(() => {
    var we;
    const C = d[0], I = se == null ? void 0 : se.hide, H = ["bottom", "top"].includes((we = o.legend) == null ? void 0 : we.position), oe = Yi(u);
    if (!(!Ct && !I && !H && !oe))
      return C;
    if (y.current) {
      const K = getComputedStyle(y.current);
      return C - y.current.getBoundingClientRect().width - parseInt(K.marginLeft) - parseInt(K.marginRight);
    }
    return C * 0.73;
  }, [d[0], o.legend, u, y.current]), $t = he.useMemo(() => {
    var I;
    return nt.current = (I = nt.current) == null ? void 0 : I.filter((H) => H), nt.current.length ? Math.max(...nt.current.map((H) => H.getBBox().height)) + Gu + hh : void 0;
  }, [d[0], o.xAxis, nt.current, o.xAxis.tickRotation]), Ze = It - Q.yAxis.size - (L === "Combo" ? o.yAxis.rightAxisSize : 0), mt = tn + Yt, Kt = o.filters && o.filters.values.length === 0 && R.length === 0, Pe = (C) => En(o.runtime.xAxis) ? v(C[o.runtime.originalXAxis.dataKey]).getTime() : C[o.runtime.originalXAxis.dataKey], _e = (C, I) => C[I], xe = o.brush.active && ((or = r.data) != null && or.length) ? r.data.map((C) => Pe(C)) : R.map((C) => Pe(C)), ut = o.orientation === "horizontal" || o.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", et = {
    data: R,
    tableData: B,
    config: {
      ...o,
      yAxis: {
        ...o.yAxis,
        scalePadding: jt ? ot : o.yAxis.scalePadding,
        enablePadding: jt || o.yAxis.enablePadding
      }
    },
    minValue: ne,
    maxValue: G,
    isAllLine: ye,
    existPositiveValue: me,
    xAxisDataMapped: xe,
    xMax: Ze,
    yMax: mt
  }, { min: rt, max: At, leftMax: Xt, rightMax: tt } = bg(et), { yScaleRight: _t, hasRightAxis: yn } = Ff({ config: o, yMax: mt, data: R }), { xScale: vt, yScale: St, seriesScale: gn, g1xScale: xn, g2xScale: On, xScaleNoPadding: Fn, xScaleAnnotation: Pn } = Yw({
    ...et,
    min: rt,
    max: At,
    leftMax: Xt,
    rightMax: tt,
    dimensions: d,
    xMax: t - Number(o.orientation === "horizontal" ? o.xAxis.size : o.yAxis.size) - (yn ? o.yAxis.rightAxisSize : 0)
  }), [ir, Nn] = ["yAxis", "xAxis"].map(
    (C) => Ak({ axis: C, max: At, runtime: Q, currentViewport: u, isHorizontal: rn, data: R, config: o, min: rt })
  ), Sn = Ct ? o.data.length : ir, { tooltipData: Dt, showTooltip: nn, hideTooltip: dn, tooltipOpen: Hn, tooltipLeft: Jt, tooltipTop: qt } = rg(), {
    handleTooltipMouseOver: Ot,
    handleTooltipClick: pn,
    handleTooltipMouseOff: an,
    TooltipListItem: un
  } = lg({
    xScale: vt,
    yScale: St,
    seriesScale: gn,
    showTooltip: nn,
    hideTooltip: dn
  }), { dataKey: ar } = Q.xAxis, Rn = R.length && bn ? [0, R.length - 1].map((C) => v(R[C][ar])).reduce((C, I) => Math.abs(C - I)) / Lk : 0, wn = bn && Rn > Nn && !o.runtime.xAxis.manual, mn = (C, I, H) => {
    if (Ne && C === 0.1 && (C = 0), !(o.data && !o.data[I] && L === "Forest Plot"))
      return o.visualizationType === "Forest Plot" ? o.data[I][o.xAxis.dataKey] : En(Q.yAxis) ? p(v(C)) : V === "vertical" && At - rt < 3 ? m(C, "left", wt, !1, !1, "1", { index: I, length: H.length }) : V === "vertical" ? m(C, "left", wt, !1, !1, void 0, { index: I, length: H.length }) : C;
  }, Mn = (C, I, H) => (Ne && C === 0.1 && (C = 0), En(Q.xAxis) && o.visualizationType !== "Forest Plot" ? p(C, I, H) : V === "horizontal" && o.visualizationType !== "Forest Plot" ? m(C, "left", wt) : o.xAxis.type === "continuous" && o.visualizationType !== "Forest Plot" ? m(C, "bottom", wt) : o.visualizationType === "Forest Plot" ? m(
    C,
    "left",
    o.dataFormat.abbreviated,
    o.runtime.xAxis.prefix,
    o.runtime.xAxis.suffix,
    Number(o.dataFormat.roundTo)
  ) : C), Wn = () => {
    let C = o.xAxis.manualStep;
    return o.xAxis.viewportStepCount && o.xAxis.viewportStepCount[u] && (C = o.xAxis.viewportStepCount[u]), C;
  }, gr = (C) => {
    const I = C.currentTarget.getBoundingClientRect(), H = C.clientX - I.left, oe = C.clientY - I.top;
    Fe({
      x: H,
      y: oe
    });
  };
  he.useEffect(() => {
    if (!S.current || !t || !at.current.length)
      return;
    const [C, I] = vk(S, nt, t);
    C && (S.current.style.paddingRight = `${I}px`, at.current.forEach((H) => {
      H && H.setAttribute("x1", Ze - I);
    }));
  }, [t, e, R]), he.useEffect(() => {
    document.querySelector(".isEditor") && Ie((I) => !0);
  }), he.useEffect(() => {
    (ct == null ? void 0 : ct.isIntersecting) === !0 && o.animate && setTimeout(() => {
      Ie((C) => !0);
    }, 500);
  }, [ct == null ? void 0 : ct.isIntersecting, o.animate]), he.useEffect(() => {
    const C = Ye.current;
    if (!C && !Xe)
      return;
    if (!C)
      return Be(0);
    const I = C.getBBox().width;
    Be(I);
  }, [o.dataFormat.suffix, o.dataFormat.onlyShowTopPrefixSuffix]), he.useEffect(() => {
    if (!Ct || ae.hideLabel)
      return;
    const C = dt.current;
    if (!C)
      return;
    const I = mt + Number(o.xAxis.axisPadding), oe = C.getBBox().y - I + C.getBBox().height + dh;
    lt.current && lt.current.setAttribute("y", oe);
  }, [(qn = o == null ? void 0 : o.data) == null ? void 0 : qn.length, Yt]), he.useEffect(() => {
    if (!st.current)
      return;
    const C = st.current.getBBox().height, I = L === "Forest Plot", H = Je.current && Y.labelsAboveGridlines, oe = M != null && M.active ? (M == null ? void 0 : M.height) + (M == null ? void 0 : M.height) : 0, pe = I ? o.data.length * ie.rowHeight : 0, we = H ? Je.current.getBBox().height : 0, K = C + oe + pe + we, X = tn + K;
    if (!S.current || (S.current.style.height = `${X}px`, !we))
      return;
    const le = n.current;
    if (!le)
      return;
    const be = S.current.getBoundingClientRect().width;
    if (le.setAttribute("viewBox", `0 ${-we} ${be} ${X}`), !y.current)
      return;
    const Ue = (se == null ? void 0 : se.position) !== "top" && (se == null ? void 0 : se.position) !== "bottom" && !Yi(u);
    y.current.style.transform = Ue ? `translateY(${we}px)` : "none";
  }, [st.current, o, $t, M, u, Je.current, tn]), he.useEffect(() => {
    je.current !== G && (je.current = G, ot && gt(0));
  }, [G]), he.useEffect(() => {
    var Ue;
    if (!(St != null && St.ticks))
      return;
    const C = St.ticks(Sn);
    if (V === "horizontal" || !jt || (Ue = o.yAxis) != null && Ue.max || C.length === 0) {
      gt(0);
      return;
    }
    const I = 0.025, oe = Math.max(...C) - G * I;
    if (!(G > oe))
      return;
    const we = C.length === 1 ? C[0] : C[1] - C[0], K = Math.max(...St.ticks(Sn)) + we, X = ne < 0 ? G / 2 : G, le = (K - G) / X, be = le > I ? le : le + we / X;
    gt(be * 100 + 0.1);
  }, [G, jt, St, Sn]);
  const vr = () => {
    const C = $t + dh, I = (H, oe) => {
      if (!H.length)
        return !1;
      const pe = H.filter((Rt) => Rt.index !== 0), we = pe == null ? void 0 : pe.length, K = oe.range()[0] || Ze / 2, X = pe.map(
        (Rt) => yr(m(Rt.value, "left"), Nt)
      ), le = 100, be = X.reduce((Rt, Vt) => Rt + Vt, le), Ue = (K - be) / we;
      let Ft = [0];
      for (let Rt = 1; Rt < X.length; Rt++)
        Ft[Rt] = Ft[Rt - 1] + X[Rt - 1] + Ue;
      let Ht = !1;
      return X.forEach((Rt, Vt) => {
        if (Ft[Vt] + X[Vt] > Ft[Vt + 1]) {
          Ht = !0;
          return;
        }
      }), Ht;
    };
    return /* @__PURE__ */ O(ze, { children: [
      /* @__PURE__ */ a(
        ec,
        {
          top: mt,
          left: Number(Q.yAxis.size),
          label: Q.xAxis.label,
          tickFormat: En(Q.xAxis) ? p : m,
          scale: xn,
          stroke: "#333",
          tickStroke: "#333",
          numTicks: Q.xAxis.numTicks || void 0,
          children: (H) => /* @__PURE__ */ O(qe, { className: "bottom-axis", children: [
            H.ticks.map((oe, pe) => {
              const we = I(H.ticks, xn), K = Number(o.xAxis.maxTickRotation) || 90, X = o.isResponsiveTicks && we, le = oe.index !== 0 && (X ? K : Number(o.yAxis.tickRotation)), be = le && oe.index !== 0 ? "end" : "middle";
              return /* @__PURE__ */ O(qe, { className: "vx-axis-tick", children: [
                !Q.yAxis.hideTicks && /* @__PURE__ */ a(ln, { from: oe.from, to: oe.to, stroke: "#333" }),
                !Q.yAxis.hideLabel && /* @__PURE__ */ a(
                  ft,
                  {
                    innerRef: (Ue) => nt.current[pe] = Ue,
                    x: oe.to.x,
                    y: oe.to.y,
                    angle: -le,
                    verticalAnchor: le ? "middle" : "start",
                    textAnchor: be,
                    fontSize: Gt,
                    children: m(oe.value, "left")
                  }
                )
              ] }, `vx-tick-${oe.value}-${pe}`);
            }),
            !Q.yAxis.hideAxis && /* @__PURE__ */ a(ln, { from: H.axisFromPoint, to: H.axisToPoint, stroke: "#333" })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        ec,
        {
          innerRef: st,
          top: mt,
          left: Number(Q.yAxis.size),
          label: Q.xAxis.label,
          tickFormat: En(Q.xAxis) ? p : Q.xAxis.dataKey !== "Year" ? m : (H) => H,
          scale: On,
          stroke: "#333",
          tickStroke: "#333",
          numTicks: Q.xAxis.numTicks || void 0,
          children: (H) => /* @__PURE__ */ O(ze, { children: [
            /* @__PURE__ */ O(qe, { className: "bottom-axis", children: [
              H.ticks.map((oe, pe) => {
                const we = I(H.ticks, On), K = Number(o.xAxis.maxTickRotation) || 90, X = o.isResponsiveTicks && we, le = oe.index !== 0 && (X ? K : Number(o.yAxis.tickRotation)), be = le && oe.index !== 0 ? "end" : "middle";
                return pe ? /* @__PURE__ */ O(qe, { className: "vx-axis-tick", children: [
                  !Q.yAxis.hideTicks && /* @__PURE__ */ a(ln, { from: oe.from, to: oe.to, stroke: "#333" }),
                  !Q.yAxis.hideLabel && /* @__PURE__ */ a(
                    ft,
                    {
                      x: oe.to.x,
                      y: oe.to.y + Gu,
                      angle: -le,
                      verticalAnchor: le ? "middle" : "start",
                      textAnchor: be,
                      fontSize: Gt,
                      children: m(oe.value, "left")
                    }
                  )
                ] }, `vx-tick-${oe.value}-${pe}`) : /* @__PURE__ */ a(ze, {});
              }),
              !Q.yAxis.hideAxis && /* @__PURE__ */ a(ln, { from: H.axisFromPoint, to: H.axisToPoint, stroke: "#333" })
            ] }),
            /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ a(
              ft,
              {
                className: "x-axis-title-label",
                x: Ze / 2,
                y: C,
                stroke: "#333",
                textAnchor: "middle",
                verticalAnchor: "start",
                fontSize: fn,
                children: Q.xAxis.label
              }
            ) })
          ] })
        }
      )
    ] });
  };
  return isNaN(It) ? /* @__PURE__ */ a(Me.Fragment, {}) : /* @__PURE__ */ a(qr, { component: "LinearChart", children: /* @__PURE__ */ O(
    "div",
    {
      style: { width: `${t}px`, overflow: "visible", position: "relative" },
      className: "tooltip-boundary",
      children: [
        /* @__PURE__ */ O(
          "svg",
          {
            ref: n,
            onMouseMove: gr,
            width: t + o.yAxis.rightAxisSize,
            height: Kt ? 1 : e,
            className: `linear ${o.animate ? "animated" : ""} ${ke && o.animate ? "animate" : ""} ${re && "debug"} ${k && "dragging-annotation"}`,
            role: "img",
            "aria-label": g(o),
            style: { overflow: "visible" },
            children: [
              !k && /* @__PURE__ */ a(Er, { width: t, height: tn, fill: "transparent" }),
              " ",
              !["Spark Line", "Forest Plot"].includes(L) && o.yAxis.type !== "categorical" && /* @__PURE__ */ a(
                pm,
                {
                  scale: St,
                  left: Number(Q.yAxis.size) - o.yAxis.axisPadding,
                  numTicks: Sn,
                  children: (C) => {
                    const I = o.orientation === "horizontal" ? (C.axisToPoint.y - C.axisFromPoint.y) / 2 : (C.axisFromPoint.y - C.axisToPoint.y) / 2;
                    return /* @__PURE__ */ O(qe, { className: "left-axis", children: [
                      C.ticks.map((H, oe) => {
                        const pe = String(H.value).startsWith("1") || H.value === 0.1 ? "block" : "none", we = H.index === 0 && H.value === 0 && o.xAxis.hideAxis;
                        return /* @__PURE__ */ a(qe, { className: "vx-axis-tick", children: Q.yAxis.gridLines && !we ? /* @__PURE__ */ a(
                          ln,
                          {
                            innerRef: (K) => at.current[oe] = K,
                            display: (Ne && pe).toString(),
                            from: { x: H.from.x + Ze, y: H.from.y },
                            to: H.from,
                            stroke: "#d6d6d6"
                          },
                          `${H.value}--hide-hideGridLines`
                        ) : "" }, `vx-tick-${H.value}-${oe}`);
                      }),
                      /* @__PURE__ */ a(
                        ft,
                        {
                          className: "y-label",
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          transform: `translate(${-1 * Q.yAxis.size + _n}, ${I}) rotate(-90)`,
                          fontWeight: "bold",
                          fill: o.yAxis.labelColor,
                          fontSize: fn,
                          children: C.label
                        }
                      )
                    ] });
                  }
                }
              ),
              L === "Paired Bar" && vr(),
              L === "Deviation Bar" && ((Zn = o.runtime.series) == null ? void 0 : Zn.length) === 1 && /* @__PURE__ */ a(Kw, { animatedChart: ke, xScale: vt, yScale: St, width: Ze, height: mt }),
              L === "Paired Bar" && /* @__PURE__ */ a(pk, { originalWidth: It, width: Ze, height: mt }),
              L === "Scatter Plot" && /* @__PURE__ */ a(
                jw,
                {
                  xScale: vt,
                  yScale: St,
                  getXAxisData: Pe,
                  getYAxisData: _e,
                  xMax: Ze,
                  yMax: mt,
                  handleTooltipMouseOver: Ot,
                  handleTooltipMouseOff: an,
                  handleTooltipClick: pn,
                  tooltipData: Dt,
                  showTooltip: nn
                }
              ),
              L === "Box Plot" && /* @__PURE__ */ a(
                Ww,
                {
                  seriesScale: gn,
                  xMax: Ze,
                  yMax: mt,
                  min: rt,
                  max: At,
                  xScale: vt,
                  yScale: St
                }
              ),
              (L === "Area Chart" && o.visualizationSubType === "stacked" || L === "Combo") && /* @__PURE__ */ a(
                Pw,
                {
                  xScale: vt,
                  yScale: St,
                  yMax: mt,
                  xMax: Ze,
                  chartRef: n,
                  width: Ze,
                  height: mt,
                  handleTooltipMouseOver: Ot,
                  handleTooltipMouseOff: an,
                  tooltipData: Dt,
                  showTooltip: nn
                }
              ),
              (L === "Bar" || L === "Combo" || h) && /* @__PURE__ */ a(
                Mw,
                {
                  xScale: vt,
                  yScale: St,
                  seriesScale: gn,
                  xMax: Ze,
                  yMax: mt,
                  getXAxisData: Pe,
                  getYAxisData: _e,
                  animatedChart: ke,
                  visible: ke,
                  handleTooltipMouseOver: Ot,
                  handleTooltipMouseOff: an,
                  handleTooltipClick: pn,
                  tooltipData: Dt,
                  showTooltip: nn,
                  chartRef: n
                }
              ),
              (L === "Combo" || L === "Bump Chart") && /* @__PURE__ */ a(
                wm,
                {
                  xScale: vt,
                  yScale: St,
                  getXAxisData: Pe,
                  getYAxisData: _e,
                  xMax: Ze,
                  yMax: mt,
                  seriesStyle: o.runtime.series,
                  handleTooltipMouseOver: Ot,
                  handleTooltipMouseOff: an,
                  handleTooltipClick: pn,
                  tooltipData: Dt,
                  showTooltip: nn
                }
              ),
              (L === "Forecasting" || L === "Combo") && /* @__PURE__ */ a(
                Gw,
                {
                  showTooltip: nn,
                  tooltipData: Dt,
                  xScale: vt,
                  yScale: St,
                  width: Ze,
                  le: !0,
                  height: mt,
                  xScaleNoPadding: Fn,
                  chartRef: n,
                  handleTooltipMouseOver: Ot,
                  handleTooltipMouseOff: an,
                  isBrush: !1
                }
              ),
              L === "Forest Plot" && /* @__PURE__ */ a(
                fk,
                {
                  xScale: vt,
                  yScale: St,
                  seriesScale: gn,
                  width: It,
                  height: zt,
                  getXAxisData: Pe,
                  getYAxisData: _e,
                  animatedChart: ke,
                  visible: ke,
                  handleTooltipMouseOver: Ot,
                  handleTooltipMouseOff: an,
                  handleTooltipClick: pn,
                  tooltipData: Dt,
                  showTooltip: nn,
                  chartRef: n,
                  config: o,
                  forestPlotRightLabelRef: dt
                }
              ),
              o.brush.active && o.xAxis.type !== "categorical" && /* @__PURE__ */ a(Lw, { xMax: Ze, yMax: mt }),
              !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(
                L
              ) && !h && /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ a(
                wm,
                {
                  xScale: vt,
                  yScale: St,
                  getXAxisData: Pe,
                  getYAxisData: _e,
                  xMax: Ze,
                  yMax: mt,
                  seriesStyle: o.runtime.series,
                  tooltipData: Dt,
                  handleTooltipMouseOver: Ot,
                  handleTooltipMouseOff: an
                }
              ) }),
              o.yAxis.anchors && o.yAxis.anchors.map((C, I) => {
                let H = St(C.value), oe = 0;
                if (C.value && (o.yAxis.labelPlacement === "Below Bar" ? oe = -6.5 + Number(o.series.length * o.barHeight) / o.series.length : oe = 8, !!H))
                  return (
                    // prettier-ignore
                    /* @__PURE__ */ a(
                      ln,
                      {
                        strokeDasharray: x(C.lineStyle),
                        stroke: C.color ? C.color : "rgba(0,0,0,1)",
                        className: "anchor-y",
                        from: { x: 0 + Qt, y: H - oe },
                        to: { x: It - o.yAxis.rightAxisSize, y: H - oe }
                      },
                      `yAxis-${C.value}--${I}`
                    )
                  );
              }),
              o.xAxis.anchors && o.xAxis.anchors.map((C, I) => {
                let H = ae;
                V === "horizontal" && (H = Y);
                let pe = (() => {
                  let we;
                  return we = En(H) ? vt(v(C.value, !1)) : vt(C.value), (o.xAxis.type === "categorical" || o.xAxis.type === "date") && (we = we ? we + (H.type === "categorical" || H.type === "date" ? vt.bandwidth() : 0) / 2 : 0), we;
                })();
                if (pe)
                  return (
                    // prettier-ignore
                    /* @__PURE__ */ a(
                      ln,
                      {
                        strokeDasharray: x(C.lineStyle),
                        stroke: C.color ? C.color : "rgba(0,0,0,1)",
                        fill: C.color ? C.color : "rgba(0,0,0,1)",
                        className: "anchor-x",
                        from: { x: Number(pe) + Number(Qt), y: 0 },
                        to: { x: Number(pe) + Number(Qt), y: mt }
                      },
                      `xAxis-${C.value}--${I}`
                    )
                  );
              }),
              o.visualizationType !== "Bar" && o.visualizationType !== "Combo" && /* @__PURE__ */ a(
                Of,
                {
                  xScale: vt,
                  handleTooltipClick: pn,
                  handleTooltipMouseOff: an,
                  handleTooltipMouseOver: Ot,
                  showTooltip: nn,
                  hideTooltip: dn,
                  tooltipData: Dt,
                  yMax: mt,
                  width: It
                }
              ),
              Kt && /* @__PURE__ */ a(
                ft,
                {
                  x: Number(o.yAxis.size) + Number(Ze / 2),
                  y: tn / 2 - (o.xAxis.padding || 0) / 2,
                  textAnchor: "middle",
                  children: o.chartMessage.noData
                }
              ),
              o.visual.horizontalHoverLine && Dt && /* @__PURE__ */ a(
                qe,
                {
                  className: "horizontal-tooltip-line",
                  left: o.yAxis.size ? o.yAxis.size : 0,
                  children: /* @__PURE__ */ a(
                    ln,
                    {
                      from: { x: 0, y: Le.y },
                      to: { x: Ze, y: Le.y },
                      stroke: "black",
                      strokeWidth: 1,
                      pointerEvents: "none",
                      strokeDasharray: "5,5",
                      className: "horizontal-tooltip-line"
                    }
                  )
                },
                `tooltipLine-horizontal${Le.y}${Le.x}`
              ),
              o.visual.verticalHoverLine && Dt && /* @__PURE__ */ a(qe, { className: "vertical-tooltip-line", children: /* @__PURE__ */ a(
                ln,
                {
                  from: { x: Le.x, y: 0 },
                  to: { x: Le.x, y: mt },
                  stroke: "black",
                  strokeWidth: 1,
                  pointerEvents: "none",
                  strokeDasharray: "5,5",
                  className: "vertical-tooltip-line"
                }
              ) }, `tooltipLine-vertical${Le.y}${Le.x}`),
              /* @__PURE__ */ a(qe, { left: Number(o.runtime.yAxis.size), children: /* @__PURE__ */ a(
                If.Draggable,
                {
                  xScale: vt,
                  yScale: St,
                  xScaleAnnotation: Pn,
                  xMax: Ze,
                  svgRef: n,
                  onDragStateChange: A
                }
              ) }),
              !["Spark Line", "Forest Plot"].includes(L) && o.yAxis.type !== "categorical" && /* @__PURE__ */ a(
                pm,
                {
                  scale: St,
                  tickLength: Ne ? 6 : 8,
                  left: Number(Q.yAxis.size) - o.yAxis.axisPadding,
                  label: Q.yAxis.label || Q.yAxis.label,
                  stroke: "#333",
                  tickFormat: mn,
                  numTicks: Sn,
                  children: (C) => {
                    const I = o.orientation === "horizontal" ? (C.axisToPoint.y - C.axisFromPoint.y) / 2 : (C.axisFromPoint.y - C.axisToPoint.y) / 2, H = mt / C.ticks.length / 2 - mt / C.ticks.length * (1 - o.barThickness) + 5;
                    return /* @__PURE__ */ O(qe, { className: "left-axis", children: [
                      !o.yAxis.hideAxis && /* @__PURE__ */ a(
                        ln,
                        {
                          from: C.axisFromPoint,
                          to: Q.horizontal ? {
                            x: 0,
                            y: o.visualizationType === "Forest Plot" ? e : Number(D.horizontal)
                          } : C.axisToPoint,
                          stroke: "#000"
                        }
                      ),
                      St.domain()[0] < 0 && /* @__PURE__ */ a(
                        ln,
                        {
                          from: { x: C.axisFromPoint.x, y: St(0) },
                          to: { x: Ze, y: St(0) },
                          stroke: "#333"
                        }
                      ),
                      L === "Bar" && V === "horizontal" && vt.domain()[0] < 0 && /* @__PURE__ */ a(
                        ln,
                        {
                          from: { x: vt(0), y: 0 },
                          to: { x: vt(0), y: mt },
                          stroke: "#333",
                          strokeWidth: 2
                        }
                      ),
                      C.ticks.map((oe, pe) => {
                        const we = C.ticks[0].to.y, K = 15, X = String(oe.value).startsWith("1") || oe.value === 0.1 ? "block" : "none", le = X === "block" ? 7 : 0, be = { x: oe.to.x - le, y: oe.to.y }, Ue = C.ticks.length - 1 === pe, Ft = Ue && de && j && !Zt, Rt = Z ? ge ? -8 : -12 : Rk, Vt = Z ? 4 : 0, kn = oe.to.x - Rt, jn = oe.to.y - Vt, Qn = Z ? "end" : "middle", sr = de && Z && j && Ue;
                        return /* @__PURE__ */ O(qe, { className: "vx-axis-tick", children: [
                          !Q.yAxis.hideTicks && !Z && !Ft && /* @__PURE__ */ a(
                            ln,
                            {
                              from: oe.from,
                              to: Ne ? be : oe.to,
                              stroke: o.yAxis.tickColor,
                              display: V === "horizontal" ? "none" : "block",
                              fontSize: Gt
                            },
                            `${oe.value}--hide-hideTicks`
                          ),
                          V === "horizontal" && q !== "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            ft,
                            {
                              transform: `translate(${oe.to.x - 5}, ${o.isLollipopChart ? oe.to.y - we : oe.to.y - we + (Number(o.barHeight * o.runtime.series.length) - K) / 2}) rotate(-${o.runtime.horizontal && o.runtime.yAxis.tickRotation || 0})`,
                              verticalAnchor: "start",
                              textAnchor: "end",
                              fontSize: Gt,
                              children: oe.formattedValue
                            }
                          ),
                          V === "horizontal" && q === "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            ft,
                            {
                              transform: `translate(${oe.to.x - 5}, ${oe.to.y - we + (Number(o.barHeight) - K) / 2}) rotate(-${Q.horizontal ? Q.yAxis.tickRotation : 0})`,
                              verticalAnchor: "start",
                              textAnchor: "end",
                              fontSize: Gt,
                              children: oe.formattedValue
                            }
                          ),
                          V === "horizontal" && L === "Paired Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            ft,
                            {
                              transform: `translate(${oe.to.x - 5}, ${oe.to.y - we + Number(o.barHeight) / 2}) rotate(-${Q.horizontal ? Q.yAxis.tickRotation : 0})`,
                              textAnchor: "end",
                              verticalAnchor: "middle",
                              fontSize: Gt,
                              children: oe.formattedValue
                            }
                          ),
                          V === "horizontal" && L === "Deviation Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            ft,
                            {
                              transform: `translate(${oe.to.x - 5}, ${o.isLollipopChart ? oe.to.y - we + 2 : oe.to.y - we + Number(o.barHeight) / 2}) rotate(-${Q.horizontal ? Q.yAxis.tickRotation : 0})`,
                              textAnchor: "end",
                              verticalAnchor: "middle",
                              fontSize: Gt,
                              children: oe.formattedValue
                            }
                          ),
                          V === "vertical" && L === "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ O(ze, { children: [
                            /* @__PURE__ */ a(
                              ft,
                              {
                                display: o.useLogScale ? X : "block",
                                dx: o.useLogScale ? -6 : 0,
                                x: o.runtime.horizontal ? oe.from.x + 2 : oe.to.x - 8.5,
                                y: oe.to.y - 13 + (o.runtime.horizontal ? H : 0),
                                angle: -Number(o.yAxis.tickRotation) || 0,
                                verticalAnchor: o.runtime.horizontal ? "start" : "middle",
                                textAnchor: o.runtime.horizontal ? "start" : "end",
                                fill: o.yAxis.tickLabelColor,
                                fontSize: Gt,
                                children: o.runtime.seriesLabelsAll[oe.formattedValue - 1]
                              }
                            ),
                            (N.length === 0 || N.includes(
                              o.runtime.seriesLabelsAll[oe.formattedValue - 1]
                            )) && /* @__PURE__ */ a(
                              "rect",
                              {
                                x: 0 - Number(o.yAxis.size),
                                y: oe.to.y - 8 + (o.runtime.horizontal ? H : 7),
                                width: Number(o.yAxis.size) + vt(vt.domain()[0]),
                                height: "2",
                                fill: i(o.runtime.seriesLabelsAll[oe.formattedValue - 1])
                              }
                            )
                          ] }),
                          V === "vertical" && L !== "Paired Bar" && L !== "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ O(ze, { children: [
                            de && Ue && !Z && /* @__PURE__ */ a(
                              rp,
                              {
                                innerRef: Ye,
                                display: Ne ? X : "block",
                                dx: Ne ? -6 : 0,
                                x: kn,
                                y: jn,
                                angle: -Number(o.yAxis.tickRotation) || 0,
                                verticalAnchor: Qn,
                                textAnchor: Zt ? "end" : "start",
                                fill: o.yAxis.tickLabelColor,
                                stroke: "#fff",
                                paintOrder: "stroke",
                                strokeLinejoin: "round",
                                style: { whiteSpace: "pre-wrap" },
                                fontSize: Gt,
                                children: j
                              }
                            ),
                            /* @__PURE__ */ a(
                              rp,
                              {
                                innerRef: (Kn) => Ue && (Je.current = Kn),
                                display: Ne ? X : "block",
                                dx: Ne ? -6 : 0,
                                x: Zt ? kn - Xe : kn,
                                y: jn + (o.runtime.horizontal ? H : 0),
                                angle: -Number(o.yAxis.tickRotation) || 0,
                                verticalAnchor: o.runtime.horizontal ? "start" : Qn,
                                textAnchor: o.runtime.horizontal || Z ? "start" : "end",
                                fill: o.yAxis.tickLabelColor,
                                stroke: "#fff",
                                disableStroke: !Z,
                                strokeLinejoin: "round",
                                paintOrder: "stroke",
                                style: { whiteSpace: "pre-wrap" },
                                fontSize: Gt,
                                children: `${oe.formattedValue}${sr ? j : ""}`
                              }
                            )
                          ] })
                        ] }, `vx-tick-${oe.value}-${pe}`);
                      }),
                      /* @__PURE__ */ a(
                        ft,
                        {
                          className: "y-label",
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          transform: `translate(${-1 * Q.yAxis.size + _n}, ${I}) rotate(-90)`,
                          fontWeight: "bold",
                          fill: o.yAxis.labelColor,
                          fontSize: fn,
                          children: C.label
                        }
                      )
                    ] });
                  }
                }
              ),
              o.yAxis.type === "categorical" && o.orientation === "vertical" && /* @__PURE__ */ a(
                mk,
                {
                  max: At,
                  maxValue: G,
                  height: tn,
                  xMax: Ze,
                  yMax: mt,
                  leftSize: Number(Q.yAxis.size) - o.yAxis.axisPadding
                }
              ),
              yn && /* @__PURE__ */ a(
                uw,
                {
                  scale: _t,
                  left: Number(It - o.yAxis.rightAxisSize),
                  label: o.yAxis.rightLabel,
                  tickFormat: (C) => m(C, "right"),
                  numTicks: Q.yAxis.rightNumTicks || void 0,
                  labelOffset: 45,
                  children: (C) => {
                    const I = o.orientation === "horizontal" ? (C.axisToPoint.y - C.axisFromPoint.y) / 2 : (C.axisFromPoint.y - C.axisToPoint.y) / 2, H = mt / C.ticks.length / 2 - mt / C.ticks.length * (1 - o.barThickness) + 5;
                    return /* @__PURE__ */ O(qe, { className: "right-axis", children: [
                      C.ticks.map((oe, pe) => /* @__PURE__ */ O(qe, { className: "vx-axis-tick", children: [
                        !Q.yAxis.rightHideTicks && /* @__PURE__ */ a(
                          ln,
                          {
                            from: oe.from,
                            to: oe.to,
                            display: Q.horizontal ? "none" : "block",
                            stroke: o.yAxis.rightAxisTickColor
                          }
                        ),
                        Q.yAxis.rightGridLines ? /* @__PURE__ */ a(ln, { from: { x: oe.from.x + Ze, y: oe.from.y }, to: oe.from, stroke: "#d6d6d6" }) : "",
                        !o.yAxis.rightHideLabel && /* @__PURE__ */ a(
                          ft,
                          {
                            x: oe.to.x,
                            y: oe.to.y + (Q.horizontal ? H : 0),
                            verticalAnchor: Q.horizontal ? "start" : "middle",
                            textAnchor: "start",
                            fill: o.yAxis.rightAxisTickLabelColor,
                            fontSize: Gt,
                            children: oe.formattedValue
                          }
                        )
                      ] }, `vx-tick-${oe.value}-${pe}`)),
                      !o.yAxis.rightHideAxis && /* @__PURE__ */ a(ln, { from: C.axisFromPoint, to: C.axisToPoint, stroke: "#333" }),
                      /* @__PURE__ */ a(
                        ft,
                        {
                          className: "y-label",
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          transform: `translate(${o.yAxis.rightLabelOffsetSize ? o.yAxis.rightLabelOffsetSize : 0}, ${I}) rotate(-90)`,
                          fontWeight: "bold",
                          fill: o.yAxis.rightAxisLabelColor,
                          fontSize: fn,
                          children: C.label
                        }
                      )
                    ] });
                  }
                }
              ),
              ce && o.topAxis.hasLine && /* @__PURE__ */ a(
                fw,
                {
                  stroke: "#333",
                  left: Number(Q.yAxis.size),
                  scale: vt,
                  hideTicks: !0,
                  hideZero: !0,
                  tickLabelProps: () => ({
                    fill: "transparent"
                  })
                }
              ),
              L !== "Paired Bar" && L !== "Spark Line" && /* @__PURE__ */ a(
                ec,
                {
                  innerRef: st,
                  top: Q.horizontal && o.visualizationType !== "Forest Plot" ? Number(D.horizontal) + Number(o.xAxis.axisPadding) : o.visualizationType === "Forest Plot" ? mt + Number(o.xAxis.axisPadding) : mt,
                  left: o.visualizationType !== "Forest Plot" ? Number(Q.yAxis.size) : 0,
                  label: o[ut].label,
                  tickFormat: Mn,
                  scale: vt,
                  stroke: "#333",
                  numTicks: wn ? Rn : Nn,
                  tickStroke: "#333",
                  tickValues: o.runtime.xAxis.manual ? Zw(xe, vt, bn ? Nn : Wn(), o) : o.runtime.xAxis.type === "date" ? xe : void 0,
                  children: (C) => {
                    var Ti;
                    const I = o.series.some((kt) => kt.dynamicCategory);
                    o.runtime.xAxis.type === "date" && !o.runtime.xAxis.manual && !I && (C.ticks = Qw(o, C, xe, p));
                    const H = wn && vt.ticks(Nn).map(
                      (kt) => C.ticks.findIndex(
                        (Dn) => (typeof Dn.value == "number" ? Dn.value : Dn.value.getTime()) === kt.getTime()
                      )
                    ).slice(0, 2).reduce((kt, Dn) => Dn - kt), oe = wn ? [...C.ticks].reverse().filter((kt, Dn) => Dn % H === 0).reverse().map((kt, Dn, Br) => ({
                      ...kt,
                      // reformat in case showYearsOnce, since first month of year may have changed
                      formattedValue: Mn(kt.value, Dn, Br)
                    })) : C.ticks, pe = $t + dh, we = (kt) => /\s/.test(kt), K = oe.some((kt) => we(kt.value)), X = Math.max(
                      ...oe.map((kt) => yr(kt.formattedValue, Nt))
                    ), le = K ? 180 : 100, be = oe.map((kt) => yr(kt.formattedValue, Nt)), Ue = be.reduce((kt, Dn) => kt + Dn, le), Ft = (Ze - Ue) / (oe.length - 1), Ht = 40, Rt = It / oe.length - Gu * 2 - Ht;
                    let Vt = [0];
                    for (let kt = 1; kt < be.length; kt++)
                      Vt[kt] = Vt[kt - 1] + be[kt - 1] + Ft;
                    const kn = (Ti = st == null ? void 0 : st.current) == null ? void 0 : Ti.getBBox().height;
                    o.xAxis.axisBBox = kn;
                    const jn = be[be.length - 1], sr = Vt[Vt.length - 1] + jn + jn / 2, Kn = Ze - jn, Ar = be.some((kt) => kt > Rt) || // Force wrap if any tick is too long
                    o.xAxis.showYearsOnce || // Force wrap when showing years once so it's easier to read
                    sr > Kn, na = Ar && o.isResponsiveTicks ? X + hh + 20 : 0;
                    return o.dynamicMarginTop = na, o.xAxis.tickWidthMax = X, /* @__PURE__ */ O(qe, { className: "bottom-axis", width: d[0], children: [
                      oe.map((kt, Dn, Br) => {
                        const Un = String(kt.value).startsWith("1") || kt.value === 0.1 ? "block" : "none", zr = Un === "block" ? 16 : hh, Zr = { x: kt.to.x, y: zr }, Wt = 100 / Br.length;
                        o.yAxis.tickRotation = o.isResponsiveTicks && o.orientation === "horizontal" ? 0 : o.yAxis.tickRotation, o.xAxis.tickRotation = o.isResponsiveTicks && o.orientation === "vertical" ? 0 : o.xAxis.tickRotation;
                        const Jn = o.isResponsiveTicks && Ar ? -Number(o.xAxis.maxTickRotation) || -90 : -Number(o.runtime.xAxis.tickRotation);
                        return /* @__PURE__ */ O(qe, { className: "vx-axis-tick", children: [
                          !o.xAxis.hideTicks && /* @__PURE__ */ a(
                            ln,
                            {
                              from: kt.from,
                              to: V === "horizontal" && Ne ? Zr : kt.to,
                              stroke: o.xAxis.tickColor,
                              strokeWidth: Un === "block" && Ne ? 1.3 : 1
                            }
                          ),
                          !o.xAxis.hideLabel && /* @__PURE__ */ a(
                            ft,
                            {
                              innerRef: (In) => nt.current[Dn] = In,
                              dy: o.orientation === "horizontal" && Ne ? 8 : 0,
                              display: o.orientation === "horizontal" && Ne ? Un : "block",
                              x: kt.to.x,
                              y: kt.to.y + Gu,
                              angle: Jn,
                              verticalAnchor: Jn < -50 ? "middle" : "start",
                              textAnchor: Jn ? "end" : "middle",
                              width: Ar && !o.isResponsiveTicks && !Number(o[ut].tickRotation) ? Wt : void 0,
                              fill: o.xAxis.tickLabelColor,
                              fontSize: Gt,
                              children: kt.formattedValue
                            }
                          )
                        ] }, `vx-tick-${kt.value}-${Dn}`);
                      }),
                      !o.xAxis.hideAxis && /* @__PURE__ */ a(ln, { from: C.axisFromPoint, to: C.axisToPoint, stroke: "#333" }),
                      /* @__PURE__ */ a(
                        ft,
                        {
                          innerRef: lt,
                          className: "x-axis-title-label",
                          x: Ze / 2,
                          y: Ct ? 0 : pe,
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          fontWeight: "bold",
                          fill: o.xAxis.labelColor,
                          fontSize: fn,
                          children: C.label
                        }
                      )
                    ] });
                  }
                }
              )
            ]
          }
        ),
        !k && Dt && Object.entries(Dt.data).length > 0 && Hn && nn && !((b = Dt == null ? void 0 : Dt.data) != null && b.some((C) => C.some((I) => I === void 0))) && Dt.dataYPosition && Dt.dataXPosition && /* @__PURE__ */ O(ze, { children: [
          /* @__PURE__ */ a("style", { children: `.tooltip {background-color: rgba(255,255,255, ${o.tooltips.opacity / 100}) !important;` }),
          /* @__PURE__ */ a("style", { children: ".tooltip {max-width:300px} !important; word-wrap: break-word; " }),
          /* @__PURE__ */ a(
            sg,
            {
              className: "tooltip cdc-open-viz-module",
              left: Jt,
              top: qt,
              children: /* @__PURE__ */ a("ul", { children: typeof Dt == "object" && Object.entries(Dt.data).filter(([C, I]) => Array.isArray(I) && !I.includes(void 0)).map((C, I) => /* @__PURE__ */ a(un, { item: C }, I)) })
            },
            Math.random()
          )
        ] }),
        o.visualizationType === "Bump Chart" && /* @__PURE__ */ a(
          oc,
          {
            id: "bump-chart",
            variant: "light",
            arrowColor: "rgba(0,0,0,0)",
            className: "tooltip",
            style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
          }
        ),
        Se() && !k && /* @__PURE__ */ a(
          oc,
          {
            id: `cdc-open-viz-tooltip-${Q.uniqueId}`,
            variant: "light",
            arrowColor: "rgba(0,0,0,0)",
            className: "tooltip",
            style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
          }
        ),
        /* @__PURE__ */ a("div", { className: "animation-trigger", ref: yt })
      ]
    }
  ) });
});
const Dk = (e) => {
  var Q;
  const { width: t, height: n } = e, {
    transformedData: r,
    config: i,
    parseDate: o,
    formatDate: h,
    seriesHighlight: u,
    formatNumber: d,
    colorScale: p,
    handleChartAriaLabels: m
  } = he.useContext(pt);
  let g = Number(t);
  const { minValue: x, maxValue: A } = qc(i, r), k = { top: 5, right: 20, bottom: 10, left: 10 }, y = Number(n), v = g - i.runtime.yAxis.size, S = y - k.top - 20, B = (se) => i.runtime.xAxis.type === "date" ? o(se[i.runtime.originalXAxis.dataKey]).getTime() : se[i.runtime.originalXAxis.dataKey], R = (se, ie) => se[ie];
  let N, D;
  const { max: L, min: q } = i.runtime.yAxis, V = Number(L) >= Number(A), ae = Number(q) <= Number(x);
  if (r) {
    let se = Number(q && ae ? q : x), ie = Number(L && V ? L : Number.MIN_VALUE);
    if (ie === Number.MIN_VALUE && (ie = A), i.runtime.yAxis.paddingPercent) {
      let U = (ie - se) * i.runtime.yAxis.paddingPercent;
      se -= U, ie += U;
    }
    let M = r.map((U) => B(U));
    i.runtime.horizontal ? (N = $n({
      domain: [se, ie],
      range: [0, v]
    }), D = i.runtime.xAxis.type === "date" ? $n({ domain: [Math.min(...M), Math.max(...M)] }) : es({ domain: M, padding: 0.5 }), es({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, S]
    }), D.rangeRound([0, S])) : (se = se < 0 ? se * 1.11 : se, D = $n({
      domain: [se, ie],
      range: [S - k.bottom, k.top]
    }), N = es({
      domain: M,
      range: [k.left, g - k.right]
    }), es({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, v]
    }));
  }
  const Y = [N.domain()[0], N.domain()[N.domain().length - 1]];
  return /* @__PURE__ */ a(qr, { component: "SparkLine", children: /* @__PURE__ */ O(
    "svg",
    {
      role: "img",
      "aria-label": m(i),
      width: t,
      height: 100,
      className: "sparkline",
      tabIndex: 0,
      children: [
        /* @__PURE__ */ a("title", { children: `Spark line graphic with the title ${i.title ? i.title : "No Title Found"}` }),
        ((Q = i.runtime.lineSeriesKeys) == null ? void 0 : Q.length) > 0 ? i.runtime.lineSeriesKeys : i.runtime.seriesKeys.map((se, ie) => /* @__PURE__ */ O(ze, { children: [
          /* @__PURE__ */ O(
            qe,
            {
              style: { width: g },
              className: "sparkline-group",
              opacity: i.legend.behavior === "highlight" && u.length > 0 && u.indexOf(se) === -1 ? 0.5 : 1,
              display: i.legend.behavior === "highlight" || u.length === 0 || u.indexOf(se) !== -1 ? "block" : "none",
              children: [
                i.labels && r.map((M, U) => /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ a(
                  ft,
                  {
                    x: N(B(M)),
                    y: D(R(M, se)),
                    fill: p ? p(
                      i.runtime.seriesLabels ? i.runtime.seriesLabels[se] : se
                    ) : "#000",
                    textAnchor: "middle",
                    children: d(M[se])
                  }
                ) }, `series-${se}-point-${U}`)),
                /* @__PURE__ */ a(
                  Yr,
                  {
                    curve: Kc,
                    data: r,
                    x: (M) => N(B(M)),
                    y: (M) => D(R(M, se)),
                    stroke: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[se] : se) : "#000",
                    strokeWidth: 2,
                    strokeOpacity: 1,
                    shapeRendering: "geometricPrecision",
                    markerEnd: `url(#arrow--${ie})`
                  }
                ),
                /* @__PURE__ */ a(
                  Fm,
                  {
                    id: `arrow--${ie}`,
                    refX: 2,
                    size: 6,
                    markerEnd: `url(#arrow--${ie})`,
                    strokeOpacity: 1,
                    fillOpacity: 1,
                    fill: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[se] : se) : "#000"
                  }
                )
              ]
            },
            `series-${se}`
          ),
          /* @__PURE__ */ a(
            ec,
            {
              top: S + k.top,
              hideAxisLine: !0,
              hideTicks: !0,
              scale: N,
              tickValues: Y,
              tickFormat: (M) => i.xAxis.type === "date" ? h(M) : null,
              stroke: "black",
              tickStroke: "black",
              tickLabelProps: () => ({
                fill: "black",
                fontSize: 11,
                textAnchor: "middle"
              })
            }
          )
        ] }))
      ]
    }
  ) });
};
var Ok = ["flexDirection", "alignItems", "margin", "display", "children"];
function Xh() {
  return Xh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Xh.apply(this, arguments);
}
function Fk(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Dl(e) {
  var t = e.flexDirection, n = t === void 0 ? "row" : t, r = e.alignItems, i = r === void 0 ? "center" : r, o = e.margin, h = o === void 0 ? "0" : o, u = e.display, d = u === void 0 ? "flex" : u, p = e.children, m = Fk(e, Ok);
  return /* @__PURE__ */ Me.createElement("div", Xh({
    className: "visx-legend-item",
    style: {
      display: d,
      alignItems: i,
      flexDirection: n,
      margin: h
    }
  }, m), p);
}
Dl.propTypes = {
  alignItems: De.string,
  margin: De.oneOfType([De.string, De.number]),
  children: De.node,
  display: De.string
};
var Mk = ["flex", "label", "margin", "align", "children"];
function qh() {
  return qh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, qh.apply(this, arguments);
}
function Ik(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Ol(e) {
  var t = e.flex, n = t === void 0 ? "1" : t, r = e.label, i = e.margin, o = i === void 0 ? "5px 0" : i, h = e.align, u = h === void 0 ? "left" : h, d = e.children, p = Ik(e, Mk);
  return /* @__PURE__ */ Me.createElement("div", qh({
    className: "visx-legend-label",
    style: {
      justifyContent: u,
      display: "flex",
      flex: n,
      margin: o
    }
  }, p), d || r);
}
Ol.propTypes = {
  align: De.string,
  label: De.node,
  flex: De.oneOfType([De.string, De.number]),
  margin: De.oneOfType([De.string, De.number]),
  children: De.node
};
function Zh() {
  return Zh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Zh.apply(this, arguments);
}
function Bf(e) {
  var t = e.fill, n = e.width, r = e.height, i = e.style;
  return /* @__PURE__ */ Me.createElement("div", {
    style: Zh({
      width: n,
      height: r,
      background: t
    }, i)
  });
}
Bf.propTypes = {
  fill: De.string,
  width: De.oneOfType([De.string, De.number]),
  height: De.oneOfType([De.string, De.number])
};
function xg(e) {
  var t = e.fill, n = e.width, r = e.height, i = e.style, o = typeof n == "string" || typeof n > "u" ? 0 : n, h = typeof r == "string" || typeof r > "u" ? 0 : r, u = Math.max(o, h), d = u / 2;
  return /* @__PURE__ */ Me.createElement("svg", {
    width: u,
    height: u
  }, /* @__PURE__ */ Me.createElement(qe, {
    top: d,
    left: d
  }, /* @__PURE__ */ Me.createElement("circle", {
    r: d,
    fill: t,
    style: i
  })));
}
xg.propTypes = {
  fill: De.string,
  width: De.oneOfType([De.string, De.number]),
  height: De.oneOfType([De.string, De.number])
};
function Sg(e) {
  var t = e.fill, n = e.width, r = e.height, i = e.style, o = typeof r == "string" || typeof r > "u" ? 0 : r, h = typeof (i == null ? void 0 : i.strokeWidth) == "number" ? i == null ? void 0 : i.strokeWidth : 2;
  return /* @__PURE__ */ Me.createElement("svg", {
    width: n,
    height: r
  }, /* @__PURE__ */ Me.createElement(qe, {
    top: o / 2 - h / 2
  }, /* @__PURE__ */ Me.createElement("line", {
    x1: 0,
    x2: n,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: h,
    style: i
  })));
}
Sg.propTypes = {
  fill: De.string,
  width: De.oneOfType([De.string, De.number]),
  height: De.oneOfType([De.string, De.number])
};
function Sl() {
  return Sl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Sl.apply(this, arguments);
}
var ph = function() {
};
function Bk(e) {
  var t = e.shape, n = t === void 0 ? "rect" : t, r = e.fill, i = r === void 0 ? ph : r, o = e.size, h = o === void 0 ? ph : o, u = e.width, d = e.height, p = e.label, m = e.item, g = e.itemIndex, x = e.shapeStyle, A = x === void 0 ? ph : x, k = {
    width: u,
    height: d,
    item: m,
    itemIndex: g,
    label: p,
    fill: i(Sl({}, p)),
    size: h(Sl({}, p)),
    style: A(Sl({}, p))
  };
  return typeof n == "string" ? n === "circle" ? /* @__PURE__ */ Me.createElement(xg, k) : n === "line" ? /* @__PURE__ */ Me.createElement(Sg, k) : /* @__PURE__ */ Me.createElement(Bf, k) : /* @__PURE__ */ Me.isValidElement(n) ? /* @__PURE__ */ Me.cloneElement(n, k) : n ? /* @__PURE__ */ Me.createElement(n, k) : null;
}
function Nc() {
  return Nc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Nc.apply(this, arguments);
}
function wg(e) {
  var t = e.shape, n = t === void 0 ? Bf : t, r = e.width, i = e.height, o = e.margin, h = e.label, u = e.item, d = e.itemIndex, p = e.fill, m = e.size, g = e.shapeStyle;
  return /* @__PURE__ */ Me.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: m ? m(Nc({}, h)) : r,
      height: m ? m(Nc({}, h)) : i,
      margin: o
    }
  }, Bk({
    shape: n,
    item: u,
    itemIndex: d,
    label: h,
    width: r,
    height: i,
    fill: p,
    shapeStyle: g
  }));
}
wg.propTypes = {
  itemIndex: De.number.isRequired,
  margin: De.oneOfType([De.string, De.number]),
  width: De.oneOfType([De.string, De.number]),
  height: De.oneOfType([De.string, De.number])
};
function kg(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function km(e) {
  return String(kg(e));
}
function zk(e) {
  var t = e.scale, n = e.labelFormat;
  return function(r, i) {
    return {
      datum: r,
      index: i,
      text: "" + n(r, i),
      value: t(r)
    };
  };
}
var $k = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function wl() {
  return wl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, wl.apply(this, arguments);
}
function Hk(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var Vk = {
  display: "flex"
};
function Tg(e) {
  var t = e.className, n = e.style, r = n === void 0 ? Vk : n, i = e.scale, o = e.shape, h = e.domain, u = e.fill, d = u === void 0 ? km : u, p = e.size, m = p === void 0 ? km : p, g = e.labelFormat, x = g === void 0 ? kg : g, A = e.labelTransform, k = A === void 0 ? zk : A, y = e.shapeWidth, v = y === void 0 ? 15 : y, S = e.shapeHeight, B = S === void 0 ? 15 : S, R = e.shapeMargin, N = R === void 0 ? "2px 4px 2px 0" : R, D = e.shapeStyle, L = e.labelAlign, q = L === void 0 ? "left" : L, V = e.labelFlex, ae = V === void 0 ? "1" : V, Y = e.labelMargin, Q = Y === void 0 ? "0 4px" : Y, se = e.itemMargin, ie = se === void 0 ? "0" : se, M = e.direction, U = M === void 0 ? "column" : M, re = e.itemDirection, j = re === void 0 ? "row" : re, de = e.legendLabelProps, Z = e.children, ge = Hk(e, $k), ne = h || ("domain" in i ? i.domain() : []), G = k({
    scale: i,
    labelFormat: x
  }), me = ne.map(G);
  return Z ? /* @__PURE__ */ Me.createElement(Me.Fragment, null, Z(me)) : /* @__PURE__ */ Me.createElement("div", {
    className: vn("visx-legend", t),
    style: wl({}, r, {
      flexDirection: U
    })
  }, me.map(function(ye, Se) {
    return /* @__PURE__ */ Me.createElement(Dl, wl({
      key: "legend-" + ye.text + "-" + Se,
      margin: ie,
      flexDirection: j
    }, ge), /* @__PURE__ */ Me.createElement(wg, {
      shape: o,
      height: B,
      width: v,
      margin: N,
      item: ne[Se],
      itemIndex: Se,
      label: ye,
      fill: d,
      size: m,
      shapeStyle: D
    }), /* @__PURE__ */ Me.createElement(Ol, wl({
      label: ye.text,
      flex: ae,
      margin: Q,
      align: q
    }, de)));
  }));
}
Tg.propTypes = {
  children: De.func,
  className: De.string,
  domain: De.array,
  shapeWidth: De.oneOfType([De.string, De.number]),
  shapeHeight: De.oneOfType([De.string, De.number]),
  shapeMargin: De.oneOfType([De.string, De.number]),
  labelAlign: De.string,
  labelFlex: De.oneOfType([De.string, De.number]),
  labelMargin: De.oneOfType([De.string, De.number]),
  itemMargin: De.oneOfType([De.string, De.number]),
  fill: De.func,
  size: De.func,
  shapeStyle: De.func
};
function Cg(e) {
  return /* @__PURE__ */ Me.createElement(Tg, e);
}
const Wk = (e) => {
  const { position: t, singleRow: n, verticalSorted: r, hideBorder: i } = e.legend, o = {
    left: "left",
    right: "right",
    bottom: "bottom",
    top: "top"
  }, h = {
    bottom: n ? ["single-row", "bottom"] : ["double-column", "bottom"],
    top: n ? ["single-row", "top"] : ["double-column", "top"]
  }, u = ["legend-container", o[t]].filter(Boolean), d = ["legend-container__inner", ...h[t] || []];
  ["bottom", "top"].includes(t) && r && d.push("vertical-sorted");
  const p = (["right", "left"].includes(t) || !t) && i.side, m = ["top", "bottom"].includes(t) && i.topBottom;
  return p || m ? u.push("border-0", "p-0") : u.push("p-3"), {
    containerClasses: u,
    innerClasses: d
  };
}, jk = (e, t, n) => {
  const i = t([{ datum: "", index: 0, text: "", value: "" }]), o = e.legend.colorCode ? i.map((u) => u == null ? void 0 : u.value) : (n == null ? void 0 : n.range()) ?? [], h = e.legend.colorCode ? i.map((u) => (u == null ? void 0 : u.text) || (u == null ? void 0 : u.datum)) : (n == null ? void 0 : n.domain()) ?? [];
  return { colors: o, labels: h };
}, Kk = (e, t) => e && t.legend.hide || !e ? "0px" : e && t.brush.active && !t.legend.hide ? `${27 + t.brush.height + 25}px` : "27px", Uk = (e, t) => {
  var o, h, u;
  const n = ((o = t.legend) == null ? void 0 : o.position) === "top" && !t.legend.hide, r = !t.legend.hideSuppressionLink && t.visualizationSubType !== "stacked" && ((h = t.preliminaryData) == null ? void 0 : h.some((d) => d.label && d.type === "suppression" && d.value && ((d == null ? void 0 : d.style) || d.symbol)));
  let i = 0;
  return n && (i = 27), n && ((u = t.dataFormat) != null && u.onlyShowTopPrefixSuffix) && (i += 9), e && (i += 9), r && (i += 40), `${i}px`;
};
const Gk = ({ linkText: e, href: t = null, tooltipOpacity: n = 100, tooltipContent: r }) => /* @__PURE__ */ O(ze, { children: [
  /* @__PURE__ */ a(
    "a",
    {
      className: "tooltip-link",
      "data-tooltip-content": r,
      "data-tooltip-id": "supression-tooltip",
      href: t,
      children: e
    }
  ),
  /* @__PURE__ */ a(
    oc,
    {
      id: "supression-tooltip",
      place: "top",
      effect: "solid",
      variant: "light",
      style: {
        background: `rgba(255, 255, 255, ${n})`,
        color: "var(--cool-gray-90)",
        padding: "9px 18px",
        boxShadow: "0px 2px 2px rgba(28, 29, 31, 0.45)",
        maxWidth: "239px",
        fontSize: "var(--filter-label-font-size)",
        fontFamily: "var(--app-font-main)",
        borderRadius: "4px"
      }
    }
  )
] }), Yk = ({ config: e, isLegendBottom: t }) => {
  const { preliminaryData: n, visualizationType: r, visualizationSubType: i, legend: o } = e, h = () => (n == null ? void 0 : n.some((x) => x.label && x.type === "effect" && x.style !== "Filled Circles")) && ["Line", "Combo"].includes(r), u = () => !o.hideSuppressedLabels && (n == null ? void 0 : n.some(
    (x) => x.label && x.displayLegend && x.type === "suppression" && x.value && ((x == null ? void 0 : x.style) || x.symbol)
  )) && (r === "Bar" && i === "regular" || r === "Line" || r === "Combo"), d = () => n == null ? void 0 : n.map(
    (x, A) => x.label && x.type === "effect" && x.style && /* @__PURE__ */ O("div", { className: "legend-preliminary", children: [
      /* @__PURE__ */ a("span", { className: x.symbol, children: x.lineCode }),
      /* @__PURE__ */ a("p", { children: x.label })
    ] }, A)
  ), p = () => {
    const x = (A) => A ? {
      color: "#777772"
    } : null;
    return n == null ? void 0 : n.map((A, k) => {
      if (!A.displayLegend || A.type !== "suppression")
        return null;
      const y = "legend-preliminary", v = k + r;
      return r === "Bar" ? /* @__PURE__ */ O("div", { style: x(A.displayGray), className: `${y} ${A.symbol}`, children: [
        /* @__PURE__ */ a("span", { className: A.symbol, children: A.iconCode }),
        /* @__PURE__ */ a("p", { className: A.type, children: A.label })
      ] }, v) : r === "Line" ? /* @__PURE__ */ O("div", { style: x(A.displayGray), className: y, children: [
        /* @__PURE__ */ a("span", { children: A.lineCode }),
        /* @__PURE__ */ a("p", { className: A.type, children: A.label })
      ] }, v) : r === "Combo" ? /* @__PURE__ */ O(Me.Fragment, { children: [
        A.symbol && A.iconCode && /* @__PURE__ */ O("div", { style: x(A.displayGray), className: `${y} ${A.symbol}`, children: [
          /* @__PURE__ */ a("span", { className: A.symbol, children: A.iconCode }),
          /* @__PURE__ */ a("p", { className: A.type, children: A.label })
        ] }, v),
        A.style && A.lineCode && /* @__PURE__ */ O("div", { style: x(A.displayGray), className: y, children: [
          /* @__PURE__ */ a("span", { children: A.lineCode }),
          /* @__PURE__ */ a("p", { children: A.label })
        ] }, v)
      ] }) : null;
    });
  }, m = () => o.singleRow && t ? "legend-container__inner bottom single-row" : "", g = () => !e.legend.hideSuppressionLink && e.visualizationSubType !== "stacked" && (n == null ? void 0 : n.some((x) => x.label && x.type === "suppression" && x.value && ((x == null ? void 0 : x.style) || x.symbol)));
  return /* @__PURE__ */ O(Me.Fragment, { children: [
    h() && /* @__PURE__ */ O(Me.Fragment, { children: [
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("div", { className: m(), children: d() })
    ] }),
    u() && /* @__PURE__ */ O(Me.Fragment, { children: [
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("div", { className: m(), children: p() })
    ] }),
    g() && /* @__PURE__ */ a("div", { className: "legend-container__outer link-container", children: /* @__PURE__ */ O("p", { children: [
      "This chart contains",
      /* @__PURE__ */ a(
        Gk,
        {
          tooltipContent: `Data is
                           suppressed to maintain statistical reliability.
                            This occurs when the number of respondents or 
                            reported values does not meet the minimum
                             reporting threshold.`,
          linkText: "suppressed data",
          href: null,
          tooltipOpacity: e.tooltips.opacity
        }
      )
    ] }) })
  ] });
}, Ag = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, Xk = [
  Nm,
  Rm,
  ic,
  Dm,
  ic,
  Mf,
  ({ fill: e }) => /* @__PURE__ */ a(Qh, { children: /* @__PURE__ */ a(ft, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle", children: "⬟" }) })
], qk = (e) => {
  var u;
  const { config: t, label: n, index: r } = e, i = r === 4, o = Xk[t.visual.lineDatapointSymbol === "standard" && r < t.visual.maximumShapeAmount ? r : 0], h = `translate(15, 3) ${i ? "rotate(180)" : ""}`;
  return /* @__PURE__ */ O("svg", { width: 30, height: 10, style: { overflow: "visible" }, className: "me-2", children: [
    /* @__PURE__ */ a(
      ln,
      {
        from: { x: 0, y: 3 },
        to: { x: 30, y: 3 },
        stroke: n.value,
        strokeWidth: 2,
        strokeDasharray: Ag(((u = t.series[r]) == null ? void 0 : u.type) || "")
      }
    ),
    /* @__PURE__ */ a("g", { display: t.legend.hasShape ? "block" : "none", transform: h, children: /* @__PURE__ */ a(o, { fillOpacity: 1, fill: n.value }) })
  ] });
};
const Zk = ({ formatLabels: e }) => {
  const {
    highlight: t,
    seriesHighlight: n,
    colorScale: r,
    transformedData: i,
    config: o,
    currentViewport: h
  } = he.useContext(pt), d = ((A, k) => {
    const y = /* @__PURE__ */ new Set();
    return A.forEach((v) => {
      o.series.forEach((S) => {
        v[k] && v[S.dataKey] && y.add(v[k]);
      });
    }), Array.from(y);
  })(i, o.legend.groupBy), p = ["legend-group", "container", o.legend.position, h, "row"], m = h === "xs" ? "col-12" : h === "sm" ? "col-6" : h === "md" ? "col-4" : "col-3";
  let x = ["legend-group group-item", o.legend.position === "bottom" || o.legend.position === "top" ? m : "col-12"];
  return /* @__PURE__ */ a("div", { className: p.join(" "), children: d.map((A) => /* @__PURE__ */ O("div", { className: x.join(" "), children: [
    /* @__PURE__ */ a("div", { children: /* @__PURE__ */ a("p", { className: "legend-group group-label", children: A }) }),
    /* @__PURE__ */ a(Cg, { scale: r, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0", children: (k) => e(k).filter((y) => {
      const v = o.legend.groupBy || "";
      return i.some((S) => S[v] === A && S[y.text] !== void 0 && S[y.text] !== "NA");
    }).map((y, v) => {
      let S = ["legend-group", "group-item"];
      return n.length && (n.includes(y.datum) ? S.push("highlighted") : S.push("inactive")), /* @__PURE__ */ O(
        Dl,
        {
          alignItems: "start",
          className: S.join(" "),
          onClick: (B) => {
            B.preventDefault(), t(y);
          },
          tabIndex: 0,
          children: [
            /* @__PURE__ */ a(gh, { shape: o.legend.style === "boxes" ? "square" : "circle", fill: y.value }),
            /* @__PURE__ */ a(Ol, { align: "left", margin: "0", children: y.text })
          ]
        },
        `legend-item-${v}`
      );
    }) })
  ] }, A)) });
}, Qk = (e) => {
  const { filters: t, data: n, runtime: r, legend: i } = e, { colorCode: o } = i, { series: h } = r, u = n.filter((m) => t.every((g) => m[g.columnName] === g.active)), d = o && Array.from(new Set(u.map((m) => m[o])));
  return h.flatMap((m) => !o || m.type !== "Bar" ? m : d.map((g) => ({ ...m, colorCodeSeries: g }))).map((m) => ({
    ...m,
    data: u.filter((g) => !m.dynamicCategory || g[m.dynamicCategory] === m.dataKey).filter((g) => !m.colorCodeSeries || g[o] === m.colorCodeSeries).filter((g) => {
      const x = m.dynamicCategory ? m.originalDataKey : m.dataKey;
      return g[x] || g[x] === 0;
    })
  })).filter((m) => m.data.length).map((m) => m.colorCodeSeries || m.name || m.dataKey);
}, Jk = 36, eT = he.forwardRef(
  ({
    config: e,
    colorScale: t,
    seriesHighlight: n,
    highlight: r,
    handleShowAll: i,
    currentViewport: o,
    formatLabels: h,
    skipId: u = "legend",
    dimensions: d,
    transformedData: p
  }, m) => {
    const { innerClasses: g, containerClasses: x } = Wk(e), { runtime: A, legend: k } = e, { series: y } = A, v = Qk(e), S = !y.length || k.unified || !v.length, B = (k == null ? void 0 : k.position) === "bottom" || Yi(o) && !k.hide && (k == null ? void 0 : k.position) !== "top", R = {
      marginBottom: Uk(B, e),
      marginTop: Kk(B, e)
    }, { HighLightedBarUtils: N } = Xc(e);
    let D = N.findDuplicates(e.highlightedBarValues);
    return k ? /* @__PURE__ */ O(
      "aside",
      {
        ref: m,
        style: R,
        id: u || "legend",
        className: x.join(" "),
        role: "region",
        "aria-label": "legend",
        tabIndex: 0,
        children: [
          (k.label || k.description) && /* @__PURE__ */ O("div", { className: k.description ? "mb-3" : "mb-2", children: [
            k.label && /* @__PURE__ */ a("h3", { className: "fw-bold", children: Gi(k.label) }),
            k.description && /* @__PURE__ */ a("p", { className: "mt-2", children: Gi(k.description) })
          ] }),
          /* @__PURE__ */ a(
            Kg,
            {
              config: e,
              ...jk(e, h, t),
              dimensions: d,
              parentPaddingToSubtract: k.hideBorder ? 0 : Jk
            }
          ),
          /* @__PURE__ */ a(Zk, { formatLabels: h }),
          /* @__PURE__ */ a(Cg, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0", children: (L) => /* @__PURE__ */ O(ze, { children: [
            /* @__PURE__ */ O("div", { className: g.join(" "), children: [
              h(L).filter((q) => S || v.includes(q.datum)).map((q, V) => {
                var Q, se;
                let ae = ["legend-item", `legend-text--${q.text.replace(" ", "").toLowerCase()}`], Y = q.datum;
                if (e.exclusions.active && ((Q = e.exclusions.keys) != null && Q.includes(Y)))
                  return null;
                if (A.seriesLabels) {
                  let ie = e.runtime.seriesLabelsAll.indexOf(Y);
                  Y = e.runtime.seriesKeys[ie], ((se = A == null ? void 0 : A.forecastingSeriesKeys) == null ? void 0 : se.length) > 0 && (Y = q.text);
                }
                return n.length && (n.includes(Y) ? ae.push("highlighted") : ae.push("inactive")), e.legend.style === "gradient" || e.legend.groupBy ? /* @__PURE__ */ a(ze, {}) : /* @__PURE__ */ O(
                  Dl,
                  {
                    className: ae.join(" "),
                    tabIndex: 0,
                    onKeyDown: (ie) => {
                      ie.key === "Enter" && (ie.preventDefault(), r(q));
                    },
                    onClick: (ie) => {
                      ie.preventDefault(), r(q);
                    },
                    role: "button",
                    children: [
                      /* @__PURE__ */ a(ze, { children: e.visualizationType === "Line" && e.legend.style === "lines" ? /* @__PURE__ */ a(Me.Fragment, { children: /* @__PURE__ */ a(qk, { index: V, label: q, config: e }) }) : /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ a(
                        gh,
                        {
                          shape: e.legend.style === "boxes" ? "square" : "circle",
                          fill: q.value
                        }
                      ) }) }),
                      /* @__PURE__ */ a(Ol, { align: "left", className: "m-0", children: Gi(q.text) })
                    ]
                  },
                  `legend-quantile-${V}`
                );
              }),
              D.map((q, V) => {
                let ae = "legend-item", Y = q.legendLabel;
                return Y ? (n.length > 0 && n.includes(Y) === !1 && (ae += " inactive"), /* @__PURE__ */ O(
                  Dl,
                  {
                    className: ae,
                    tabIndex: 0,
                    onKeyDown: (Q) => {
                      Q.key === "Enter" && (Q.preventDefault(), r(q.legendLabel));
                    },
                    onClick: (Q) => {
                      Q.preventDefault(), r(q.legendLabel);
                    },
                    children: [
                      /* @__PURE__ */ a(
                        gh,
                        {
                          shape: e.legend.style === "boxes" ? "square" : "circle",
                          style: { borderRadius: "0px" },
                          fill: "transparent",
                          borderColor: q.color ? q.color : "rgba(255, 102, 1)"
                        }
                      ),
                      " ",
                      /* @__PURE__ */ a(Ol, { align: "left", children: q.legendLabel ? q.legendLabel : q.value })
                    ]
                  },
                  `legend-quantile-${V}`
                )) : !1;
              })
            ] }),
            /* @__PURE__ */ a(Yk, { config: e, isLegendBottom: B })
          ] }) }),
          n.length > 0 && /* @__PURE__ */ a(Oc, { onClick: (L) => i(L), style: { marginTop: "1rem" }, children: "Show All" })
        ]
      }
    ) : null;
  }
);
function tT(e) {
  return Ug({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" }, child: [] }] })(e);
}
const nT = (e, t, n, r) => (i) => {
  var k, y, v, S, B;
  const { visualizationType: o, visualizationSubType: h, series: u, runtime: d, legend: p } = e, m = (R) => p.verticalSorted ? Ke.sortBy(Ke.cloneDeep(R), (N) => {
    var L;
    const D = (L = N.datum) == null ? void 0 : L.match(/-?\d+(\.\d+)?/);
    return D ? parseFloat(D[0]) : Number.MAX_SAFE_INTEGER;
  }) : R, g = (R) => e.series.some((N) => N.dynamicCategory) ? x(R) : e.legend.reverseLabelOrder ? m(R).reverse() : m(R), x = (R) => {
    switch (e.legend.order) {
      case "dataColumn":
        return R;
      case "asc":
      case "desc":
        return R.sort((N, D) => {
          const L = N.datum || N.text, q = D.datum || D.text, V = parseFloat(L), ae = parseFloat(q);
          return !isNaN(V) && !isNaN(ae) ? e.legend.order === "asc" ? V - ae : ae - V : e.legend.order === "asc" ? L.localeCompare(q) : q.localeCompare(L);
        });
      default:
        return R;
    }
  }, A = (k = e.legend) == null ? void 0 : k.colorCode;
  if (o === "Deviation Bar") {
    const [R, N] = Fc[e.twoColor.palette], D = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: R
    }, L = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: N
    };
    return g([D, L]);
  }
  if (o === "Bar" && h === "regular" && A && (u == null ? void 0 : u.length) === 1) {
    let R = Lr[e.palette];
    for (; t.length > R.length; )
      R = R.concat(R);
    R = R.slice(0, n.length);
    const N = /* @__PURE__ */ new Set();
    t.forEach((L) => N.add(L[A]));
    const D = Array.from(N).map((L, q) => ({
      datum: L,
      index: q,
      text: L,
      value: R[q]
    }));
    return g(D);
  }
  if (((y = d == null ? void 0 : d.forecastingSeriesKeys) == null ? void 0 : y.length) > 0) {
    let R = [];
    return (S = (v = e.runtime) == null ? void 0 : v.forecastingSeriesKeys) == null || S.map((N, D) => {
      var L;
      return (L = N == null ? void 0 : N.stages) == null ? void 0 : L.map((q, V) => {
        var Q, se, ie, M;
        let ae = (Q = ac[q.color]) != null && Q[2] ? (se = ac[q.color]) == null ? void 0 : se[2] : (ie = Lr[q.color]) != null && ie[2] ? (M = Lr[q.color]) == null ? void 0 : M[2] : "#ccc";
        const Y = {
          datum: q.key,
          index: V,
          text: q.key,
          value: ae
        };
        R.push(Y);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((N, D) => {
      let L = Lr[e.palette][D] ? Lr[e.palette][D] : "#ccc";
      const q = {
        datum: N,
        index: D,
        text: N,
        value: L
      };
      R.push(q);
    }), g(R);
  }
  if (e.series.some((R) => R.name)) {
    const R = Array.from(new Set(e.series.map((N) => N.name || N.dataKey))).map((N, D) => ({
      datum: N,
      index: D,
      text: N,
      value: r(N)
    }));
    return g(R);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const R = i.length - 1;
    let N = [];
    return (B = e.suppressedData) == null || B.forEach(({ label: D, icon: L }, q) => {
      if (D && L) {
        const V = {
          datum: D,
          index: R + q,
          text: D,
          icon: /* @__PURE__ */ a(tT, { color: "#000", size: 15 })
        };
        N.push(V);
      }
    }), [...i, ...N];
  }
  return g(i);
}, rT = he.forwardRef((e, t) => {
  const {
    // prettier-ignore
    config: n,
    colorScale: r,
    seriesHighlight: i,
    highlight: o,
    tableData: h,
    handleShowAll: u,
    transformedData: d,
    currentViewport: p,
    dimensions: m,
    getTextWidth: g,
    transformedData: x
  } = he.useContext(pt);
  if (!n.legend)
    return null;
  const A = nT(n, h, d, r);
  return /* @__PURE__ */ a(he.Fragment, { children: /* @__PURE__ */ a(
    eT,
    {
      getTextWidth: g,
      dimensions: m,
      ref: t,
      transformedData: x,
      skipId: e.skipId || "legend",
      config: n,
      colorScale: r,
      seriesHighlight: i,
      highlight: o,
      handleShowAll: u,
      currentViewport: p,
      formatLabels: A
    }
  ) });
}), nc = {
  annotations: [],
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "true",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    annotationDropdownText: "Annotations",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0,
    showZeroValueData: !0,
    hideNullValue: !0
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !1,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: [],
    shoMissingDataLabel: !0,
    showMissingDataLine: !0,
    categories: []
  },
  boxplot: {
    plots: [],
    borders: "true",
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      count: "Count",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 0,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0,
    padding: 5,
    showYearsOnce: !1,
    sortByRecentDate: !1
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    showDownloadLinkBelow: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: "",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    label: "",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    hideSuppressionLink: !1,
    seriesHighlight: [],
    style: "circles",
    subStyle: "linear blocks",
    groupBy: "",
    shape: "circle",
    tickRotation: "",
    order: "dataColumn",
    hideBorder: {
      side: !1,
      topBottom: !0
    },
    position: "right",
    orderedValues: []
  },
  brush: {
    height: 45,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  filters: [],
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1,
    lineDatapointSymbol: "none",
    maximumShapeAmount: 7
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, iT = ({
  config: e,
  deleteColumn: t,
  updateField: n,
  colKey: r,
  controls: i
}) => {
  var g, x, A, k;
  const [o, h] = i, u = (y, v) => {
    if (y === "dataTable" && v === !0) {
      const S = Ke.cloneDeep(e.columns);
      S[r] = { ...S[r], dataTable: v }, n(null, null, "columns", S);
    } else
      n("columns", r, y, v);
  }, d = (y) => {
    const v = Ke.cloneDeep(e.columns), B = { ...e.columns[r], name: y, label: y };
    if (B.dataTable === void 0 && (B.dataTable = !0), y !== r) {
      v[y] = B, delete v[r];
      const R = { ...Ke.cloneDeep(o), [y]: !0 };
      delete R[r], h(R);
    }
    n(null, null, "columns", v);
  }, p = () => {
    var B;
    const y = e.data.flatMap((R) => Object.keys(R).map((N) => N)), v = Object.values(e.columns).map((R) => R.name), S = Ke.uniq(y).filter((R) => !(e.table.groupBy === R || v.includes(R)));
    return (B = e.columns[r]) != null && B.name && S.push(e.columns[r].name), S;
  }, m = (g = e.columns[r]) == null ? void 0 : g.name;
  return /* @__PURE__ */ O(
    Gg,
    {
      fieldName: m,
      fieldKey: r,
      fieldType: "Column",
      controls: i,
      deleteField: () => t(r),
      children: [
        /* @__PURE__ */ a(
          ht,
          {
            label: "Column",
            value: (x = e.columns[r]) == null ? void 0 : x.name,
            fieldName: "name",
            section: "columns",
            initial: "-Select-",
            options: p(),
            updateField: (y, v, S, B) => d(B)
          }
        ),
        e.type !== "table" && /* @__PURE__ */ a(
          ht,
          {
            label: "Associate to Series",
            value: (A = e.columns[r]) == null ? void 0 : A.series,
            fieldName: "series",
            section: "columns",
            initial: "Select series",
            options: ((k = e.series) == null ? void 0 : k.map((y) => y.dataKey)) || [],
            updateField: (y, v, S, B) => u("series", B)
          }
        ),
        /* @__PURE__ */ a(
          $e,
          {
            value: e.columns[r].label,
            section: "columns",
            subsection: r,
            fieldName: "label",
            label: "Label",
            updateField: n
          }
        ),
        /* @__PURE__ */ O("ul", { className: "column-edit", children: [
          /* @__PURE__ */ O("li", { className: "three-col", children: [
            /* @__PURE__ */ a(
              $e,
              {
                value: e.columns[r].prefix,
                section: "columns",
                subsection: r,
                fieldName: "prefix",
                label: "Prefix",
                updateField: n
              }
            ),
            /* @__PURE__ */ a(
              $e,
              {
                value: e.columns[r].suffix,
                section: "columns",
                subsection: r,
                fieldName: "suffix",
                label: "Suffix",
                updateField: n
              }
            ),
            /* @__PURE__ */ a(
              $e,
              {
                type: "number",
                value: e.columns[r].roundToPlace,
                section: "columns",
                subsection: r,
                fieldName: "roundToPlace",
                label: "Round",
                updateField: n
              }
            )
          ] }),
          /* @__PURE__ */ a("li", { children: /* @__PURE__ */ O("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].commas,
                onChange: (y) => {
                  u("commas", y.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Add Commas to Numbers" })
          ] }) }),
          /* @__PURE__ */ a("li", { children: e.table.showVertical && /* @__PURE__ */ O("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].dataTable ?? !0,
                onChange: (y) => {
                  u("dataTable", y.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in Data Table" })
          ] }) }),
          e.visualizationType === "Pie" && /* @__PURE__ */ a("li", { children: /* @__PURE__ */ O("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].showInViz,
                onChange: (y) => {
                  u("showInViz", y.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in Visualization" })
          ] }) }),
          e.type !== "table" && /* @__PURE__ */ a("li", { children: /* @__PURE__ */ O("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].tooltips || !1,
                onChange: (y) => {
                  n("columns", r, "tooltips", y.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in tooltip" })
          ] }) }),
          e.visualizationType === "Forest Plot" && /* @__PURE__ */ O(ze, { children: [
            /* @__PURE__ */ a("li", { children: /* @__PURE__ */ O("label", { className: "checkbox", children: [
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: e.columns[r].forestPlot || !1,
                  onChange: (y) => {
                    u("forestPlot", y.target.checked);
                  }
                }
              ),
              /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in Forest Plot" })
            ] }) }),
            /* @__PURE__ */ a("li", { children: /* @__PURE__ */ O("label", { className: "checkbox", children: [
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: e.columns[r].forestPlotAlignRight || !1,
                  onChange: (y) => {
                    u("forestPlotAlignRight", y.target.checked);
                  }
                }
              ),
              /* @__PURE__ */ a("span", { className: "edit-label", children: "Align Right" })
            ] }) }),
            !e.columns[r].forestPlotAlignRight && /* @__PURE__ */ a("li", { children: /* @__PURE__ */ O("label", { className: "text", children: [
              /* @__PURE__ */ a("span", { className: "edit-label", children: "Forest Plot Starting Point" }),
              /* @__PURE__ */ a(
                "input",
                {
                  type: "number",
                  value: e.columns[r].forestPlotStartingPoint || 0,
                  onChange: (y) => {
                    u("forestPlotStartingPoint", y.target.value);
                  }
                }
              )
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ O("label", { children: [
          /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Order" }),
          /* @__PURE__ */ a(
            "input",
            {
              onWheel: (y) => y.currentTarget.blur(),
              type: "number",
              min: "1",
              value: e.columns[r].order,
              onChange: (y) => n("columns", r, "order", parseInt(y.target.value))
            }
          )
        ] })
      ]
    }
  );
}, aT = ({ config: e, updateField: t, deleteColumn: n }) => {
  var h;
  const r = he.useState({}), i = Object.keys(e.columns), o = (u) => {
    const d = `additionalColumn${u}`, p = {
      label: "New Column",
      dataTable: !0,
      tooltips: !1,
      prefix: "",
      suffix: "",
      forestPlot: !1,
      startingPoint: "0",
      forestPlotAlignRight: !1,
      roundToPlace: 0,
      commas: !1,
      showInViz: !1,
      forestPlotStartingPoint: 0
    }, [m, g] = r;
    g({ ...m, [d]: !0 }), t("columns", null, d, p);
  };
  return /* @__PURE__ */ O(ze, { children: [
    e.type !== "navigation" && /* @__PURE__ */ O("fieldset", { children: [
      /* @__PURE__ */ a("label", { children: /* @__PURE__ */ O("span", { className: "edit-label", children: [
        "Configurations",
        /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "You can specify additional columns to display in tooltips and / or the supporting data table." }) })
        ] })
      ] }) }),
      i.map((u, d) => /* @__PURE__ */ a(
        iT,
        {
          controls: r,
          config: e,
          deleteColumn: n,
          updateField: t,
          colKey: u
        },
        u + d
      )),
      /* @__PURE__ */ a(
        "button",
        {
          className: "btn btn-primary",
          onClick: (u) => {
            u.preventDefault(), o(i.length + 1);
          },
          children: "Add Configuration"
        }
      )
    ] }),
    ((h = e.legend) == null ? void 0 : h.type) === "category" && /* @__PURE__ */ O("fieldset", { children: [
      /* @__PURE__ */ a("label", { children: /* @__PURE__ */ O("span", { className: "edit-label", children: [
        "Additional Category",
        /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "You can provide additional categories to ensure they appear in the legend" }) })
        ] })
      ] }) }),
      e.legend.additionalCategories && e.legend.additionalCategories.map((u, d) => /* @__PURE__ */ O("fieldset", { className: "edit-block", children: [
        /* @__PURE__ */ a(
          "button",
          {
            className: "remove-column",
            onClick: (p) => {
              p.preventDefault();
              const m = [...e.legend.additionalCategories];
              m.splice(d, 1), t("legend", null, "additionalCategories", m);
            },
            children: "Remove"
          }
        ),
        /* @__PURE__ */ a(
          $e,
          {
            value: u,
            label: "Category",
            section: "legend",
            subsection: null,
            fieldName: "additionalCategories",
            updateField: (p, m, g, x) => {
              const A = [...e.legend.additionalCategories];
              A[d] = x, t(p, m, g, A);
            }
          }
        )
      ] }, u)),
      /* @__PURE__ */ a(
        "button",
        {
          className: "btn btn-primary full-width",
          onClick: (u) => {
            u.preventDefault();
            const d = [...e.legend.additionalCategories || []];
            d.push(""), t("legend", null, "additionalCategories", d);
          },
          children: "Add Category"
        }
      )
    ] })
  ] });
}, Tm = "-Select-", oT = ({ config: e, updateField: t, isDashboard: n, columns: r }) => {
  var p, m, g, x, A, k;
  const i = ((p = e.dataKey) == null ? void 0 : p.includes("http://")) || ((m = e == null ? void 0 : e.dataKey) == null ? void 0 : m.includes("https://")), o = he.useMemo(() => Object.keys(e.columns).map((y) => [y, e.columns[y].dataTable]).filter(([y, v]) => !v).map(([y]) => y), [e.columns]), h = he.useMemo(() => {
    const y = e.data.flatMap(Object.keys);
    return Ke.uniq(y).filter((S) => !0);
  }, [e.data]), u = (y) => {
    y === Tm && (y = void 0), t("table", null, "groupBy", y);
  }, d = (y, v, S, B) => {
    const R = Ke.cloneDeep(e.columns), N = [];
    for (let D in R) {
      const L = R[D];
      N.push(L.name), B.includes(L.name) ? R[D].dataTable = !1 : R[D].dataTable = !0;
    }
    B.forEach((D) => {
      N.includes(D) || (R[D] = { name: D, dataTable: !1 });
    }), t(null, null, "columns", R);
  };
  return /* @__PURE__ */ O(ze, { children: [
    /* @__PURE__ */ a(
      $e,
      {
        value: e.table.label,
        updateField: t,
        section: "table",
        fieldName: "label",
        id: "tableLabel",
        label: "Data Table Title",
        placeholder: "Data Table",
        tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Label is required for Data Table for 508 Compliance" }) })
        ] })
      }
    ),
    e.type !== "table" && /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.show,
        fieldName: "show",
        label: "Show Data Table",
        section: "table",
        updateField: t,
        className: "column-heading",
        tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
            Ve,
            {
              display: "question",
              style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
            }
          ) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Hiding the data table may affect accessibility. An alternate form of accessing visualization data is a 508 requirement." }) })
        ] })
      }
    ),
    e.visualizationType !== "Box Plot" && e.type !== "table" && /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.showVertical,
        fieldName: "showVertical",
        label: "Show Vertical Data",
        section: "table",
        updateField: t,
        className: "column-heading",
        tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
            Ve,
            {
              display: "question",
              style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
            }
          ) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "This will draw the data table with vertical data instead of horizontal." }) })
        ] })
      }
    ),
    e.type !== "table" && /* @__PURE__ */ a(
      $e,
      {
        value: e.table.indexLabel,
        section: "table",
        fieldName: "indexLabel",
        label: "Index Column Header",
        updateField: t,
        tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "To comply with 508 standards, if the first column in the data table has no header, enter a brief one here." }) })
        ] })
      }
    ),
    /* @__PURE__ */ a(
      $e,
      {
        value: e.table.caption,
        updateField: t,
        section: "table",
        type: "textarea",
        fieldName: "caption",
        label: "Screen Reader Description",
        placeholder: " Data table",
        tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter a description of the data table to be read by screen readers." }) })
        ] })
      }
    ),
    /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.limitHeight,
        section: "table",
        fieldName: "limitHeight",
        label: " Limit Table Height",
        updateField: t
      }
    ),
    e.table.limitHeight && /* @__PURE__ */ a(
      $e,
      {
        value: e.table.height,
        section: "table",
        fieldName: "height",
        label: "Data Table Height",
        type: "number",
        min: 0,
        max: 500,
        placeholder: "Height(px)",
        updateField: t
      }
    ),
    (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ O("label", { children: [
      /* @__PURE__ */ a("span", { className: "edit-label column-heading mt-1", children: "Exclude Columns " }),
      /* @__PURE__ */ a(
        ip,
        {
          options: r.map((y) => ({ label: y, value: y })),
          selected: o,
          label: "Exclude Columns",
          fieldName: "dataTable",
          section: "columns",
          updateField: d
        },
        o.join("") + "excluded"
      )
    ] }),
    /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.collapsible,
        fieldName: "collapsible",
        label: " Collapsible",
        section: "table",
        updateField: t
      }
    ),
    e.table.collapsible !== !1 && /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.expanded,
        fieldName: "expanded",
        label: " Expanded by Default",
        section: "table",
        updateField: t
      }
    ),
    /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.download,
        fieldName: "download",
        label: "Show Download CSV Link",
        section: "table",
        updateField: t
      }
    ),
    e.table.download && /* @__PURE__ */ O(ze, { children: [
      /* @__PURE__ */ a(
        Ge,
        {
          value: e.table.showDownloadLinkBelow,
          fieldName: "showDownloadLinkBelow",
          className: "ms-4",
          label: "Show Link Below Table",
          section: "table",
          updateField: t
        }
      ),
      /* @__PURE__ */ a(
        Ge,
        {
          value: e.table.downloadVisibleDataOnly,
          fieldName: "downloadVisibleDataOnly",
          className: "ms-4",
          label: "Download only visible data",
          section: "table",
          updateField: t
        }
      )
    ] }),
    n && e.type !== "table" && /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.showDataTableLink,
        fieldName: "showDataTableLink",
        label: "Show Data Table Name & Link",
        section: "table",
        updateField: t
      }
    ),
    i && /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.showDownloadUrl,
        fieldName: "showDownloadUrl",
        label: "Show URL to Automatically Updated Data",
        section: "table",
        updateField: t
      }
    ),
    e.type !== "table" && /* @__PURE__ */ a(
      Ge,
      {
        value: e.table.showDownloadImgButton,
        fieldName: "showDownloadImgButton",
        label: "Display Image Button",
        section: "table",
        updateField: t
      }
    ),
    /* @__PURE__ */ O("label", { children: [
      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Table Cell Min Width" }),
      /* @__PURE__ */ a(
        "input",
        {
          type: "number",
          value: e.table.cellMinWidth ? e.table.cellMinWidth : 0,
          onChange: (y) => t("table", null, "cellMinWidth", y.target.value)
        }
      )
    ] }),
    (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ a(
      ht,
      {
        value: e.table.groupBy,
        fieldName: "groupBy",
        section: "table",
        label: "Group By",
        updateField: (y, v, S, B) => u(B),
        initial: Tm,
        options: h.filter(
          (y) => {
            var v, S;
            return y !== ((v = e.table.pivot) == null ? void 0 : v.columnName) && !(((S = e.table.pivot) == null ? void 0 : S.valueColumns) || []).includes(y);
          }
        ),
        tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Choose a column to use for grouping data rows. The selected column will not be shown in the data table. You will only be able to choose a column which does not have a column configuration." }) })
        ] })
      }
    ),
    /* @__PURE__ */ a(
      ht,
      {
        label: "Pivot Column",
        tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Select a Column whos data values will be pivoted to Column Values." }) })
        ] }),
        value: (g = e.table.pivot) == null ? void 0 : g.columnName,
        options: h.filter(
          (y) => {
            var v;
            return y !== e.table.groupBy && !(((v = e.table.pivot) == null ? void 0 : v.valueColumns) || []).includes(y);
          }
        ),
        initial: "-Select-",
        section: "table",
        subsection: "pivot",
        fieldName: "columnName",
        updateField: t
      }
    ),
    ((x = e.table.pivot) == null ? void 0 : x.columnName) && /* @__PURE__ */ O("label", { children: [
      /* @__PURE__ */ O("span", { className: "edit-label column-heading mt-1", children: [
        "Pivot Value Column(s)",
        /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "The column(s) whos values will be pivoted under the column selected as the Filter." }) })
        ] })
      ] }),
      /* @__PURE__ */ a(
        ip,
        {
          options: h.filter((y) => {
            var v;
            return y !== ((v = e.table.pivot) == null ? void 0 : v.columnName) && y !== e.table.groupBy;
          }).map((y) => ({ label: y, value: y })),
          selected: (A = e.table.pivot) == null ? void 0 : A.valueColumns,
          label: "Pivot Value Column(s) ",
          section: "table",
          subsection: "pivot",
          fieldName: "valueColumns",
          updateField: t
        },
        (k = e.table.pivot) == null ? void 0 : k.columnName
      )
    ] })
  ] });
}, rc = (e) => /* @__PURE__ */ he.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ he.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), sT = ({ name: e }) => {
  var u, d, p, m, g;
  const { config: t, rawData: n, updateConfig: r } = he.useContext(pt);
  if (t.visualizationType !== "Forest Plot")
    return;
  const i = (x) => {
    x.orientation === "horizontal" && (x.labels = !1), x.table.show === void 0 && (x.table.show = !isDashboard), x.visualizationType === "Combo" && (x.orientation = "vertical");
  }, o = (x = !0) => {
    let A = {};
    return n.forEach((k) => {
      Object.keys(k).forEach((y) => A[y] = !0);
    }), x && Object.keys(A).forEach((k) => {
      (t.series && t.series.filter((y) => y.dataKey === k).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(k)) && delete A[k];
    }), Object.keys(A);
  }, h = (x, A, k, y) => {
    if (x === "boxplot" && A === "legend") {
      r({
        ...t,
        [x]: {
          ...t[x],
          [A]: {
            ...t.boxplot[A],
            [k]: y
          }
        }
      });
      return;
    }
    if (x === "boxplot" && A === "labels") {
      r({
        ...t,
        [x]: {
          ...t[x],
          [A]: {
            ...t.boxplot[A],
            [k]: y
          }
        }
      });
      return;
    }
    if (x === "forestPlot" && A) {
      let R = {
        ...t,
        [x]: {
          ...t[x],
          [A]: {
            ...t.forestPlot[A],
            [k]: y
          }
        }
      };
      r(R);
      return;
    }
    if (x === "columns" && A !== "" && k !== "") {
      r({
        ...t,
        [x]: {
          ...t[x],
          [A]: {
            ...t[x][A],
            [k]: y
          }
        }
      });
      return;
    }
    if (x === null && A === null) {
      let R = { ...t, [k]: y };
      i(R), r(R);
      return;
    }
    const v = Array.isArray(t[x]);
    let S = v ? [...t[x], y] : { ...t[x], [k]: y };
    A !== null && (v ? (S = [...t[x]], S[A] = { ...S[A], [k]: y }) : typeof y == "string" ? S[A] = y : S = { ...t[x], [A]: { ...t[x][A], [k]: y } });
    let B = { ...t, [x]: S };
    i(B), r(B);
  };
  return /* @__PURE__ */ O(Tn, { children: [
    /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ O(An, { children: [
      e,
      (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ a(rc, { width: "25", className: "warning-icon" })
    ] }) }),
    /* @__PURE__ */ O(Ln, { children: [
      /* @__PURE__ */ a(
        ht,
        {
          value: t.xAxis.dataKey || "",
          section: "xAxis",
          fieldName: "dataKey",
          label: "Study Column",
          initial: "Select",
          required: !0,
          updateField: h,
          options: o(!1),
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Select the column or row containing the categories or dates for this axis. " }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        ht,
        {
          value: t.forestPlot.type,
          label: "Forest Plot Type",
          initial: "Select",
          required: !0,
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                type: x.target.value
              }
            }), x.target.value = "";
          },
          options: ["Linear", "Logarithmic"],
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ O("p", { children: [
              "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ",
              /* @__PURE__ */ a("br", {}),
              /* @__PURE__ */ a("br", {}),
              " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1."
            ] }) })
          ] })
        }
      ),
      /* @__PURE__ */ a($e, { type: "text", value: ((u = t.forestPlot) == null ? void 0 : u.title) || "", updateField: h, section: "forestPlot", fieldName: "title", label: "Plot Title" }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { children: "Column Settings" }),
      /* @__PURE__ */ a(
        ht,
        {
          value: t.forestPlot.estimateField,
          label: "Point Estimate Column",
          initial: t.forestPlot.estimateField || "Select",
          required: !0,
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                estimateField: x.target.value
              }
            }), x.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ a(
        ht,
        {
          value: t.forestPlot.shape,
          label: "Point Estimate Shape",
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                shape: x.target.value
              }
            }), x.target.value = "";
          },
          options: ["text", "circle", "square"]
        }
      ),
      /* @__PURE__ */ a(
        ht,
        {
          value: t.forestPlot.lower,
          label: "Lower CI Column",
          required: !0,
          initial: t.forestPlot.lower || "Select",
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                lower: x.target.value
              }
            }), x.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ a(
        ht,
        {
          value: t.forestPlot.upper,
          label: "Upper CI Column",
          initial: t.forestPlot.upper || "Select",
          required: !0,
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                upper: x.target.value
              }
            }), x.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ a("label", { children: /* @__PURE__ */ O("span", { className: "edit-label column-heading", children: [
        "Pooled Result Column",
        /* @__PURE__ */ a(
          "input",
          {
            type: "text",
            value: t.forestPlot.pooledResult.column || "",
            label: "Pooled Result Row",
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  pooledResult: {
                    ...t.forestPlot.pooledResult,
                    column: x.target.value
                  }
                }
              }), x.target.value = "";
            }
          }
        )
      ] }) }),
      /* @__PURE__ */ a(Ge, { value: ((p = (d = t.forestPlot) == null ? void 0 : d.lineOfNoEffect) == null ? void 0 : p.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: h }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { children: "Width Settings" }),
      /* @__PURE__ */ O("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Left (%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.leftWidthOffset || 0,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  leftWidthOffset: x.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ O("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Left Mobile(%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.leftWidthOffsetMobile || 0,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  leftWidthOffsetMobile: x.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ O("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Right (%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.rightWidthOffset || 0,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  rightWidthOffset: x.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ O("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Right Mobile(%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.rightWidthOffsetMobile || 0,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  rightWidthOffsetMobile: x.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ a($e, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: h, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { children: "Labels Settings" }),
      /* @__PURE__ */ a($e, { type: "text", value: ((m = t.forestPlot) == null ? void 0 : m.leftLabel) || "", updateField: h, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }),
      /* @__PURE__ */ a($e, { type: "text", value: ((g = t.forestPlot) == null ? void 0 : g.rightLabel) || "", updateField: h, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a(
        ht,
        {
          value: t.forestPlot.radius.scalingColumn,
          label: "Weight Column",
          initial: "Select",
          onChange: (x) => {
            x.target.value !== "" && x.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                radius: {
                  ...t.forestPlot.radius,
                  scalingColumn: x.target.value
                }
              }
            }), x.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ O("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Radius Minimum Size" }),
        /* @__PURE__ */ a(
          "input",
          {
            min: 3,
            max: 6,
            value: t.forestPlot.radius.min || 3,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  radius: {
                    ...t.forestPlot.radius,
                    min: Number(x.target.value)
                  }
                }
              });
            },
            type: "number",
            label: "Radius Minimum",
            placeholder: " 1"
          }
        )
      ] }),
      /* @__PURE__ */ O("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Radius Maximum Size" }),
        /* @__PURE__ */ a(
          "input",
          {
            min: 7,
            max: 10,
            value: t.forestPlot.radius.max,
            onChange: (x) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  radius: {
                    ...t.forestPlot.radius,
                    max: Number(x.target.value)
                  }
                }
              });
            },
            type: "number",
            label: "Radius Minimum",
            placeholder: " 1"
          }
        )
      ] })
    ] })
  ] });
}, Ua = Me.createContext({}), lT = (e) => {
  const { updateConfig: t, config: n, rawData: r } = he.useContext(pt), { getColumns: i, selectComponent: o } = e, h = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], u = (d, p, m) => {
    let g = [...n.series];
    if (g[d][m] = p, m === "type" && p === "Bar" && (g[d].axis = "Left"), g[d].type === "Forecasting") {
      let x = Array.from(new Set(r.map((k) => k[g[d].dataKey]))), A = [];
      x.forEach((k) => {
        A.push({ key: k });
      }), g[d].stages = A, g[d].stageColumn = g[d].dataKey;
    }
    t({ ...n, series: g });
  };
  return /* @__PURE__ */ a(Ua.Provider, { value: { updateSeries: u, supportedRightAxisTypes: h, getColumns: i, selectComponent: o }, children: e.children });
}, uT = (e) => {
  const { config: t, updateConfig: n } = he.useContext(pt), { series: r, index: i } = e;
  if (!(() => {
    let d = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart", "Bump Chart"].some((m) => m.includes(r.type)) && (d = !0), d;
  })())
    return;
  const h = (d, p) => {
    let m = [...t.series];
    m[d].lineType = p, n({ ...t, series: m });
  };
  let u = [];
  return Object.keys(as).map((d) => u.push(as[d])), /* @__PURE__ */ a(
    Ji,
    {
      initial: "Select an option",
      value: r.lineType ? r.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (d) => {
        h(i, d.target.value);
      },
      options: u
    }
  );
}, cT = (e) => {
  const { config: t } = he.useContext(pt), { updateSeries: n } = he.useContext(Ua), { index: r, series: i } = e, o = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line" || t.visualizationType === "Bump Chart")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo", "Bump Chart"].includes(t.visualizationType))
    return /* @__PURE__ */ a(
      Ji,
      {
        initial: "Select an option",
        value: i.type,
        label: "Series Type",
        onChange: (h) => {
          n(r, h.target.value, "type");
        },
        options: o()
      }
    );
}, dT = (e) => {
  const { config: t, updateConfig: n, rawData: r } = he.useContext(pt), { updateSeries: i, getColumns: o } = he.useContext(Ua), { index: h, series: u } = e;
  return /* @__PURE__ */ a(
    Ji,
    {
      initial: "Select an option",
      value: u.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (d) => {
        let p = [], m = new Set(r == null ? void 0 : r.map((x) => x[d.target.value]));
        m = Array.from(m), m = m.filter((x) => x !== void 0), m.forEach((x) => p.push({ key: x }));
        const g = [...t.series];
        g[h] = { ...g[h], stages: p, stageColumn: d.target.value }, n({
          ...t,
          series: g
        });
      },
      options: o(!1)
    }
  );
}, hT = (e) => {
  const { config: t, rawData: n } = he.useContext(pt), { updateSeries: r } = he.useContext(Ua), { index: i, series: o } = e;
  if (o.type !== "Forecasting" || !n || !o.stageColumn)
    return;
  let h = new Set(n.map((u) => u[o.stageColumn]));
  return h = Array.from(h), h = h.filter((u) => u !== void 0), /* @__PURE__ */ a(
    Ji,
    {
      initial: "Select an option",
      value: o.stageItem,
      label: "Forecasting Item Column",
      onChange: (u) => {
        r(i, u.target.value, "stageItem");
      },
      options: h
    }
  );
}, fT = (e) => {
  const { config: t } = he.useContext(pt), { updateSeries: n, supportedRightAxisTypes: r } = he.useContext(Ua), { index: i, series: o } = e;
  if (!(t.visualizationType !== "Combo" || !o) && r.includes(o.type))
    return /* @__PURE__ */ a(
      Ji,
      {
        initial: "Select an option",
        value: o.axis ? o.axis : "Left",
        label: "Series Axis",
        onChange: (h) => {
          n(i, h.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, pT = (e) => {
  var o;
  const { config: t, updateConfig: n } = he.useContext(pt), { index: r, series: i } = e;
  if (i.type === "Forecasting" && i)
    return (o = i == null ? void 0 : i.stages) == null ? void 0 : o.map((h, u) => {
      var d, p, m, g;
      return /* @__PURE__ */ a(
        Ji,
        {
          initial: "Select an option",
          value: (p = (d = t.series) == null ? void 0 : d[r].stages) != null && p[u].color ? (g = (m = t.series) == null ? void 0 : m[r].stages) == null ? void 0 : g[u].color : "Select",
          label: `${h.key} Series Color`,
          onChange: (x) => {
            const A = [...t.series], k = A[r].stages;
            k[u].color = x.target.value, A[r] = { ...A[r], stages: k }, n({
              ...t,
              series: A
            });
          },
          options: Object.keys(ac)
        },
        `${h}--${u}`
      );
    });
}, mT = (e) => {
  var h;
  const { config: t, updateConfig: n } = he.useContext(pt), { series: r, index: i } = e, { getColumns: o } = he.useContext(Ua);
  if (r.type === "Forecasting")
    return /* @__PURE__ */ O("div", { className: "edit-block", children: [
      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Confidence Interval Groups" }),
      /* @__PURE__ */ O("fieldset", { children: [
        /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: (h = r == null ? void 0 : r.confidenceIntervals) == null ? void 0 : h.map((u, d) => {
          const p = u.showInTooltip ? u.showInTooltip : !1, m = (g, x, A) => {
            g.preventDefault();
            let k = [...t.series];
            k[x].confidenceIntervals[A].showInTooltip = !p, n({
              ...t,
              series: k
            });
          };
          return /* @__PURE__ */ O(Tn, { className: "series-item series-item--chart", children: [
            /* @__PURE__ */ a(Cn, { className: "series-item__title", children: /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O(An, { className: "accordion__button accordion__button", children: [
              "Group ",
              d + 1,
              /* @__PURE__ */ a(
                "button",
                {
                  className: "series-list__remove",
                  onClick: (g) => {
                    g.preventDefault();
                    const x = [...t.series[i].confidenceIntervals];
                    x.splice(d, 1);
                    const A = [...t.series];
                    A[i] = { ...A[i], confidenceIntervals: [...x] }, n({
                      ...t,
                      series: A
                    });
                  },
                  children: "Remove"
                }
              )
            ] }) }) }),
            /* @__PURE__ */ O(Ln, { children: [
              /* @__PURE__ */ O("div", { className: "input-group", children: [
                /* @__PURE__ */ a("label", { htmlFor: "showInTooltip", children: "Show In Tooltip" }),
                /* @__PURE__ */ O(
                  "div",
                  {
                    className: "cove-input__checkbox--small",
                    onClick: (g) => m(g, i, d),
                    children: [
                      /* @__PURE__ */ a(
                        "div",
                        {
                          className: "cove-input__checkbox-box custom-color",
                          style: { backgroundColor: "" },
                          children: p && /* @__PURE__ */ a(Um, { className: "", style: { fill: "#025eaa" } })
                        }
                      ),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          className: "cove-input--hidden",
                          type: "checkbox",
                          name: "showInTooltip",
                          checked: p || !1,
                          readOnly: !0
                        }
                      )
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ a(
                Ji,
                {
                  initial: "Select an option",
                  value: t.series[i].confidenceIntervals[d].low ? t.series[i].confidenceIntervals[d].low : "Select",
                  label: "Low Confidence Interval",
                  onChange: (g) => {
                    const x = [...t.series[i].confidenceIntervals];
                    x[d].low = g.target.value;
                    const A = [...t.series];
                    A[i] = { ...A[i], confidenceIntervals: x }, n({
                      ...t,
                      series: A
                    });
                  },
                  options: o()
                }
              ),
              /* @__PURE__ */ a(
                Ji,
                {
                  initial: "Select an option",
                  value: t.series[i].confidenceIntervals[d].high ? t.series[i].confidenceIntervals[d].high : "Select",
                  label: "High Confidence Interval",
                  onChange: (g) => {
                    const x = [...t.series[i].confidenceIntervals];
                    x[d].high = g.target.value;
                    const A = [...t.series];
                    A[i] = { ...A[i], confidenceIntervals: x }, n({
                      ...t,
                      series: A
                    });
                  },
                  options: o()
                }
              )
            ] })
          ] }, `${d}`);
        }) }),
        /* @__PURE__ */ a(
          "button",
          {
            className: "btn btn-primary full-width",
            onClick: (u) => {
              u.preventDefault();
              let d = null;
              t.series[i].confidenceIntervals ? d = [...t.series[i].confidenceIntervals] : d = [];
              const p = [...t.series];
              p[i] = {
                ...p[i],
                confidenceIntervals: [...d, { high: "", low: "" }]
              }, n({
                ...t,
                series: p
              });
            },
            children: "Add Confidence Interval Group"
          }
        )
      ] })
    ] });
}, yT = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: i } = he.useContext(pt);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const h = (u, d, p, m) => {
    let g = [...r.series], x = { ...r.runtime.seriesLabels };
    g[u].weight = d && Math.max(Number(p), Math.min(Number(m), Number(d))), x[g[u].dataKey] = g[u].weight ? g[u].weight : g[u].dataKey;
    const A = {
      ...r,
      series: g,
      runtime: {
        ...r.runtime,
        seriesLabels: x
      }
    };
    i(A);
  };
  return /* @__PURE__ */ O(ze, { children: [
    /* @__PURE__ */ a("label", { htmlFor: "series-weight", children: "Line Weight" }),
    /* @__PURE__ */ a(
      "input",
      {
        type: "number",
        value: t.weight ? t.weight : "",
        min: "1",
        max: "9",
        onChange: (u) => {
          h(n, u.target.value, u.target.min, u.target.max);
        }
      },
      `series-weight-${n}`
    )
  ] });
}, gT = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: i } = he.useContext(pt);
  if (![
    "Bump Chart",
    "Bar",
    "Line",
    "Area Chart",
    "Combo",
    "Deviation",
    "Paired",
    "Scatter",
    "dashed-sm",
    "dashed-md",
    "dashed-lg"
  ].includes(t.type))
    return;
  const h = (d, p) => {
    let m = [...r.series], g = { ...r.runtime.seriesLabels };
    m[d].name = p, g[m[d].dataKey] = m[d].name ? m[d].name : m[d].dataKey;
    let x = {
      ...r,
      series: m,
      runtime: {
        ...r.runtime,
        seriesLabels: g
      }
    };
    i(x);
  }, u = t.name !== void 0 && t.name !== t.dataKey ? t.name : t.dataKey;
  return /* @__PURE__ */ O(ze, { children: [
    /* @__PURE__ */ a("label", { htmlFor: "series-name", children: "Series Name" }),
    /* @__PURE__ */ a(
      "input",
      {
        type: "text",
        value: u,
        onChange: (d) => {
          h(n, d.target.value);
        }
      },
      `series-name-${n}`
    )
  ] });
}, vT = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: i } = he.useContext(pt);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(r.visualizationType))
    return;
  const o = (h) => {
    let u = [...r.series];
    u[h].tooltip && u[h].tooltip, u[h].tooltip = !u[h].tooltip, i({
      ...r,
      series: u
    });
  };
  return /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O("div", { className: "input-group", children: [
    /* @__PURE__ */ a("label", { htmlFor: `series-tooltip--${n}`, children: "Show In Tooltip" }),
    /* @__PURE__ */ O("div", { className: "cove-input__checkbox--small", onClick: (h) => o(n), children: [
      /* @__PURE__ */ a("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" }, children: t.tooltip && /* @__PURE__ */ a(Um, { className: "", style: { fill: "#025eaa" } }) }),
      /* @__PURE__ */ a(
        "input",
        {
          className: "cove-input--hidden",
          type: "checkbox",
          name: `series-tooltip--${n}`,
          checked: t.tooltip ? t.tooltip : !1,
          readOnly: !0
        }
      )
    ] })
  ] }) });
}, bT = (e) => {
  const { config: t, updateConfig: n } = he.useContext(pt), { series: r, index: i } = e, o = (u) => {
    let d = [...t.series], p = -1;
    for (let m = 0; m < d.length; m++)
      if (d[m].dataKey === u) {
        p = m;
        break;
      }
    if (p !== -1) {
      d.splice(p, 1);
      let m = { ...t, series: d };
      d.length === 0 && delete m.series, n(m);
    }
    t.visualizationType === "Paired Bar" && n({
      ...t,
      series: []
    });
  }, h = (u, d, p) => {
    u.preventDefault(), o(d.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ a("button", { className: "series-list__remove", onClick: (u) => h(u, r), children: "Remove" });
}, Lg = (e) => {
  const { config: t, updateConfig: n } = he.useContext(pt), { updateSeries: r, getColumns: i } = he.useContext(Ua), { series: o, getItemStyle: h, sortableItemStyles: u, chartsWithOptions: d, index: p } = e, m = [
    { label: "Order By Data Column", value: "dataColumn" },
    {
      label: "Ascending Alphanumeric",
      value: "asc"
    },
    {
      label: "Descending Alphanumeric",
      value: "desc"
    }
  ], g = ["Bar", "Line"].includes(t.visualizationType) && t.visualizationSubType !== "Stacked" && !t.series.find((x) => x.dynamicCategory && x.dataKey !== o.dataKey);
  return /* @__PURE__ */ a(Yg, { draggableId: `draggableFilter-${o.dataKey}`, index: p, children: (x, A) => /* @__PURE__ */ a(
    "div",
    {
      className: A.isDragging ? "currently-dragging" : "",
      style: h(A.isDragging, x.draggableProps.style, u),
      ref: x.innerRef,
      ...x.draggableProps,
      ...x.dragHandleProps,
      children: /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: /* @__PURE__ */ O(Tn, { className: "series-item series-item--chart", children: [
        /* @__PURE__ */ a(Cn, { className: "series-item__title", children: /* @__PURE__ */ O(
          An,
          {
            className: d.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow",
            children: [
              /* @__PURE__ */ a(Ve, { display: "move", size: 15, style: { cursor: "default" } }),
              o.dataKey,
              /* @__PURE__ */ a(oi.Button.Remove, { series: o, index: p })
            ]
          }
        ) }),
        d.includes(t.visualizationType) && /* @__PURE__ */ O(Ln, { children: [
          /* @__PURE__ */ a(oi.Input.Name, { series: o, index: p }),
          g && /* @__PURE__ */ O(ze, { children: [
            /* @__PURE__ */ a(
              ht,
              {
                label: "Dynamic Category",
                value: o.dynamicCategory,
                options: ["- Select - ", ...i().filter((k) => o.dataKey !== k)],
                updateField: (k, y, v, S) => {
                  S === "- Select -" && (S = ""), r(p, S, "dynamicCategory");
                },
                tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "This field is Optional. If you have a dynamic data series you can select the category field here. You can only add one dynamic category per visualization." }) })
                ] })
              }
            ),
            /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ a(
              ht,
              {
                value: t.legend.order,
                options: m,
                section: "legend",
                fieldName: "order",
                updateField: (k, y, v, S) => {
                  n({ ...t, legend: { ...t.legend, order: S } });
                },
                label: "Dynamic Series Order"
              }
            ) })
          ] }),
          /* @__PURE__ */ a(oi.Input.Weight, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Dropdown.SeriesType, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Dropdown.AxisPosition, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Dropdown.LineType, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Dropdown.ForecastingColor, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Dropdown.ConfidenceInterval, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Checkbox.DisplayInTooltip, { series: o, index: p })
        ] })
      ] }) })
    },
    p
  ) }, o.dataKey);
}, xT = (e) => {
  const { series: t, getItemStyle: n, sortableItemStyles: r, chartsWithOptions: i } = e;
  return t.map((o, h) => /* @__PURE__ */ a(
    Lg,
    {
      getItemStyle: n,
      sortableItemStyles: r,
      chartsWithOptions: i,
      series: o,
      index: h
    },
    `series-list-${h}`
  ));
}, oi = {
  Wrapper: lT,
  Dropdown: {
    SeriesType: cT,
    AxisPosition: fT,
    ConfidenceInterval: mT,
    LineType: uT,
    ForecastingStage: dT,
    ForecastingColumn: hT,
    ForecastingColor: pT
  },
  Input: {
    Name: gT,
    Weight: yT
  },
  Checkbox: {
    DisplayInTooltip: vT
  },
  Button: {
    Remove: bT
  },
  Item: Lg,
  List: xT
}, ST = he.memo(({ config: e, updateConfig: t }) => {
  let n = (d, p, m) => {
    let g = [];
    e.regions && (g = [...e.regions]), g[m][d] = p, t({ ...e, regions: g });
  }, r = (d, p, m, g, x) => n(m, g, x), i = (d) => {
    let p = [];
    e.regions && (p = [...e.regions]), p.splice(d, 1), t({ ...e, regions: p });
  }, o = () => {
    let d = [];
    e.regions && (d = [...e.regions]), d.push({}), t({ ...e, regions: d });
  };
  const h = ["Fixed", "Previous Days"], u = ["Last Date", "Fixed"];
  return /* @__PURE__ */ O(ze, { children: [
    e.regions && e.regions.map(({ label: d, color: p, from: m, to: g, background: x, range: A = "Custom" }, k) => {
      var y;
      return /* @__PURE__ */ O("div", { className: "edit-block", children: [
        /* @__PURE__ */ a(
          "button",
          {
            type: "button",
            className: "btn btn-danger remove-column",
            onClick: (v) => {
              v.preventDefault(), i(k);
            },
            children: "Remove"
          }
        ),
        /* @__PURE__ */ a($e, { value: d, label: "Region Label", fieldName: "label", i: k, updateField: r }),
        /* @__PURE__ */ O("div", { className: "two-col-inputs", children: [
          /* @__PURE__ */ a(
            $e,
            {
              value: p,
              label: "Text Color",
              fieldName: "color",
              updateField: (v, S, B, R) => n(B, R, k)
            }
          ),
          /* @__PURE__ */ a(
            $e,
            {
              value: x,
              label: "Background",
              fieldName: "background",
              updateField: (v, S, B, R) => n(B, R, k)
            }
          )
        ] }),
        /* @__PURE__ */ a(
          ht,
          {
            value: e.regions[k].fromType ?? "Fixed",
            label: "Minimum Region Type",
            initial: "Select",
            required: !0,
            onChange: (v) => {
              if (v.target.value !== "" && v.target.value !== "Select") {
                const S = [...e.regions];
                S[k].fromType = v.target.value, t({
                  ...e,
                  regions: S
                });
              }
              v.target.value = "";
            },
            options: h
          }
        ),
        (e.regions[k].fromType === "Fixed" || e.regions[k].fromType === "Previous Days" || !e.regions[k].fromType) && /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ a(
          $e,
          {
            value: m,
            label: e.regions[k].fromType === "Fixed" || !((y = e.regions[k]) != null && y.fromType) ? "From Value" : "Previous Number of Days",
            fieldName: "from",
            updateField: (v, S, B, R) => n(B, R, k),
            tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value." }) })
            ] })
          }
        ) }),
        /* @__PURE__ */ a(
          ht,
          {
            value: e.regions[k].toType ?? "Fixed",
            label: "Maximum Region Type",
            initial: "Select",
            required: !0,
            onChange: (v) => {
              if (v.target.value !== "" && v.target.value !== "Select") {
                const S = [...e.regions];
                S[k].toType = v.target.value, t({
                  ...e,
                  regions: S
                });
              }
              v.target.value = "";
            },
            options: u
          }
        ),
        (e.regions[k].toType === "Fixed" || !e.regions[k].toType) && /* @__PURE__ */ a(
          $e,
          {
            value: g,
            label: "To Value",
            fieldName: "to",
            updateField: (v, S, B, R) => n(B, R, k)
          }
        )
      ] }, `region-${k}`);
    }),
    !e.regions && /* @__PURE__ */ a("p", { style: { textAlign: "center" }, children: "There are currently no regions." }),
    /* @__PURE__ */ a(
      "button",
      {
        type: "button",
        className: "btn btn-primary full-width",
        onClick: (d) => {
          d.preventDefault(), o();
        },
        children: "Add Region"
      }
    )
  ] });
}), wT = ({ name: e }) => {
  const { visSupportsRegions: t } = Hl(), { config: n, updateConfig: r } = he.useContext(pt);
  return t() ? /* @__PURE__ */ O(Tn, { children: [
    /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: e }) }),
    /* @__PURE__ */ a(Ln, { children: /* @__PURE__ */ a(ST, { config: n, updateConfig: r }) })
  ] }) : null;
}, zf = he.createContext(null), $f = () => {
  const e = he.useContext(zf);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, kT = (e) => {
  const { config: t } = he.useContext(pt), { updateField: n } = $f(), {
    enabledChartTypes: r,
    visHasNumbersOnBars: i,
    visHasaAdditionalLabelsOnBars: o,
    visHasLabelOnData: h,
    visSupportsChartHeight: u,
    visSupportsMobileChartHeight: d,
    visSupportsSuperTitle: p,
    visSupportsFootnotes: m
  } = Hl(), { visualizationType: g, visualizationSubType: x, barStyle: A } = t, k = () => (g === "Bar" || g === "Deviation Bar") && x !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ O(Tn, { children: [
    " ",
    /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: "General" }) }),
    /* @__PURE__ */ O(Ln, { children: [
      (t == null ? void 0 : t.visualizationType) !== "Sankey" && /* @__PURE__ */ a(
        ht,
        {
          value: g,
          fieldName: "visualizationType",
          label: "Chart Type",
          updateField: n,
          options: r
        }
      ),
      u() && t.orientation === "vertical" && /* @__PURE__ */ O("div", { className: d() ? "two-col-inputs" : "", children: [
        /* @__PURE__ */ a(
          $e,
          {
            type: "number",
            value: t.heights.vertical,
            section: "heights",
            fieldName: "vertical",
            label: "Chart Height",
            updateField: n,
            tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ O(ee.Target, { children: [
                "˝",
                /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } })
              ] }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "For some visualization types, such as the Sankey diagram, it may be necessary to adjust the chart height for optimal display." }) })
            ] })
          }
        ),
        d() && t.orientation === "vertical" && /* @__PURE__ */ a(
          $e,
          {
            type: "number",
            value: t.heights.mobileVertical,
            section: "heights",
            fieldName: "mobileVertical",
            label: "Mobile Height",
            updateField: n,
            tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "If the chart height is not optimized for mobile, you can adjust the height for better display. Not setting a value will default to the chart height." }) })
            ] })
          }
        )
      ] }),
      (g === "Bar" || g === "Combo") && /* @__PURE__ */ a(
        ht,
        {
          value: x || "Regular",
          fieldName: "visualizationSubType",
          label: "Chart Subtype",
          updateField: n,
          options: ["regular", "stacked"]
        }
      ),
      g === "Area Chart" && x === "stacked" && /* @__PURE__ */ a(
        ht,
        {
          value: t.stackedAreaChartLineType || "Linear",
          fieldName: "stackedAreaChartLineType",
          label: "Stacked Area Chart Line Type",
          updateField: n,
          options: Object.keys(as)
        }
      ),
      g === "Bar" && /* @__PURE__ */ a(
        ht,
        {
          value: t.orientation || "vertical",
          fieldName: "orientation",
          label: "Orientation",
          updateField: n,
          options: ["vertical", "horizontal"]
        }
      ),
      g === "Deviation Bar" && /* @__PURE__ */ a(ht, { label: "Orientation", options: ["horizontal"] }),
      (g === "Bar" || g === "Deviation Bar") && /* @__PURE__ */ a(
        ht,
        {
          value: t.isLollipopChart ? "lollipop" : A || "flat",
          fieldName: "barStyle",
          label: "bar style",
          updateField: n,
          options: k(),
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Consider using the 'Flat' bar style when presenting data that includes '0' values." }) })
          ] })
        }
      ),
      (g === "Bar" || g === "Deviation Bar") && A === "rounded" && /* @__PURE__ */ a(
        ht,
        {
          value: t.tipRounding || "top",
          fieldName: "tipRounding",
          label: "tip rounding",
          updateField: n,
          options: ["top", "full"]
        }
      ),
      (g === "Bar" || g === "Deviation Bar") && A === "rounded" && /* @__PURE__ */ a(
        ht,
        {
          value: t.roundingStyle || "standard",
          fieldName: "roundingStyle",
          label: "rounding style",
          updateField: n,
          options: ["standard", "shallow", "finger"]
        }
      ),
      g === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ a(
        ht,
        {
          value: t.yAxis.labelPlacement || "Below Bar",
          section: "yAxis",
          fieldName: "labelPlacement",
          label: "Label Placement",
          updateField: n,
          options: ["Below Bar", "On Date/Category Axis"]
        }
      ),
      i() ? /* @__PURE__ */ a(
        Ge,
        {
          value: t.yAxis.displayNumbersOnBar,
          section: "yAxis",
          fieldName: "displayNumbersOnBar",
          label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar",
          updateField: n
        }
      ) : h() && /* @__PURE__ */ a(
        Ge,
        {
          value: t.labels,
          fieldName: "labels",
          label: "Display label on data",
          updateField: n,
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ O(ee.Content, { children: [
              /* @__PURE__ */ a("p", { children: "Recommended set to display for Section 508 compliance." }),
              /* @__PURE__ */ a("hr", {}),
              /* @__PURE__ */ O("p", { children: [
                "Selecting this option will ",
                /* @__PURE__ */ a("i", { children: " not " }),
                ' hide the display of "zero value", "suppressed data", or "missing data" indicators on the chart (if applicable).'
              ] })
            ] })
          ] })
        }
      ),
      o() && /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ a(
          Ge,
          {
            tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Selecting this option will display a thin line slightly above the Date/Category Axis to indicate "zero value" where zero values are indicated in the Data Series.' }) })
            ] }),
            value: t.general.showZeroValueData,
            section: "general",
            fieldName: "showZeroValueData",
            label: 'Display "Zero Data" Label',
            updateField: n
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ O(ee.Content, { children: [
                t.visualizationSubType === "stacked" && /* @__PURE__ */ a("p", { children: "We do not recommend using stacked vertical/horizontal bar charts for missing data. If you choose to proceed, selecting this option will display 'N/A' in the tooltip hover and data table (e.g. nothing will display in chart)." }),
                t.visualizationSubType !== "stacked" && /* @__PURE__ */ a("p", { children: "Selecting this option will display 'N/A' on the Date/Category Axis, in the tooltip hover, and in the data table to indicate missing or undefined data values." })
              ] })
            ] }),
            value: t.general.showMissingDataLabel,
            section: "general",
            fieldName: "showMissingDataLabel",
            label: 'Display "Missing Data" Label',
            updateField: n
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            display: t.visualizationType === "Bar" || t.visualizationType === "Combo",
            tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting 'Remove Null Values' will hide the 'N/A' (no data indicator) when you hover over the chart." }) })
            ] }),
            value: t.general.hideNullValue,
            section: "general",
            fieldName: "hideNullValue",
            label: 'Remove "Null" Values From Hover',
            updateField: n
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ O(ee.Content, { children: [
                t.visualizationSubType !== "stacked" && /* @__PURE__ */ O("p", { children: [
                  "Selecting this option will show the ",
                  /* @__PURE__ */ a("i", { children: "suppression indicator " }),
                  " on the Date/Category axis, within tooltips, and in the data table where suppressed data values appear in the Data Series."
                ] }),
                t.visualizationSubType === "stacked" && /* @__PURE__ */ a("p", { children: "We do not recommend using stacked vertical/horizontal bar charts for suppressed data. If you choose to proceed, selecting this option will display the 'suppressed data symbol' in the tooltip hover and data table (e.g., nothing will display in the chart)." })
              ] })
            ] }),
            value: t.general.showSuppressedSymbol,
            section: "general",
            fieldName: "showSuppressedSymbol",
            label: 'Display "suppressed data" label',
            updateField: n
          }
        )
      ] }),
      g === "Pie" && /* @__PURE__ */ a(ht, { fieldName: "pieType", label: "Pie Chart Type", updateField: n, options: ["Regular", "Donut"] }),
      g === "Line" && /* @__PURE__ */ a(
        Ge,
        {
          value: t.allowLineToBarGraph,
          fieldName: "allowLineToBarGraph",
          label: "Convert to Bar Graph",
          updateField: n,
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Switch to bar graph when less than 3 data points available." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          value: t.title || "Chart Title",
          fieldName: "title",
          id: "title",
          label: "Title",
          placeholder: "Chart Title",
          updateField: n,
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Title is required to set the name of the download file but can be hidden using the option below." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(Ge, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: n }),
      p() && /* @__PURE__ */ a(
        $e,
        {
          value: t.superTitle,
          updateField: n,
          fieldName: "superTitle",
          label: "Super Title",
          placeholder: "Super Title",
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Super Title" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          type: "textarea",
          value: t.introText,
          updateField: n,
          fieldName: "introText",
          label: "Message",
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Intro Text" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          type: "textarea",
          value: t.description,
          fieldName: "description",
          label: "Subtext/Citation",
          updateField: n,
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub." }) })
          ] })
        }
      ),
      m() && /* @__PURE__ */ a(
        $e,
        {
          type: "textarea",
          value: t.legacyFootnotes,
          updateField: n,
          fieldName: "legacyFootnotes",
          label: "Footnotes",
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data." }) })
          ] })
        }
      )
    ] })
  ] });
}, TT = (e) => {
  const { config: t } = he.useContext(pt), { boxplot: n } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: r } = $f();
  return /* @__PURE__ */ O(Tn, { children: [
    /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: e.name }) }),
    /* @__PURE__ */ O(Ln, { children: [
      /* @__PURE__ */ a("h4", { style: { fontSize: "18px" }, children: "Labels for 5-Number Summary" }),
      /* @__PURE__ */ a(
        $e,
        {
          type: "text",
          value: n.labels.maximum,
          fieldName: "maximum",
          section: "boxplot",
          subsection: "labels",
          label: "Maximum",
          updateField: r,
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Highest value, excluding outliers" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          type: "text",
          value: n.labels.q3,
          fieldName: "q3",
          section: "boxplot",
          subsection: "labels",
          label: "Upper Quartile",
          updateField: r,
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Represented by top line of box. 25% of data are higher." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          type: "text",
          value: n.labels.median,
          fieldName: "median",
          section: "boxplot",
          subsection: "labels",
          label: "Median",
          updateField: r,
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Middle data point. Half of data are higher value." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          type: "text",
          value: n.labels.q1,
          fieldName: "q1",
          section: "boxplot",
          subsection: "labels",
          label: "Lower Quartile",
          updateField: r,
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Represented by bottom line of box. 25% of data are lower." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          type: "text",
          value: n.labels.minimum,
          fieldName: "minimum",
          section: "boxplot",
          subsection: "labels",
          label: "Minimum",
          updateField: r,
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Lowest value, excluding outliers" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { style: { fontSize: "18px" }, children: "Labels for Additional Measures" }),
      /* @__PURE__ */ a(
        $e,
        {
          type: "text",
          value: n.labels.iqr,
          fieldName: "iqr",
          section: "boxplot",
          subsection: "labels",
          label: "Interquartile Range",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          type: "text",
          value: n.labels.count,
          fieldName: "count",
          section: "boxplot",
          subsection: "labels",
          label: "Count",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          type: "text",
          value: n.labels.mean,
          fieldName: "mean",
          section: "boxplot",
          subsection: "labels",
          label: "Mean",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          type: "text",
          value: n.labels.outliers,
          fieldName: "outliers",
          section: "boxplot",
          subsection: "labels",
          label: "Outliers",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          type: "text",
          value: n.labels.values,
          fieldName: "values",
          section: "boxplot",
          subsection: "labels",
          label: "Values",
          updateField: r
        }
      )
    ] })
  ] });
}, CT = (e, t) => {
  let n = [], r = [], i = [];
  const o = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const h = e.twoColor.isPaletteReversed;
    n = Object.keys(Fc).filter(
      (u) => h ? u.endsWith("reverse") : !u.endsWith("reverse")
    );
  } else {
    const h = [], u = [];
    for (const d in Lr) {
      const p = d.startsWith("sequential"), m = d.startsWith("qualitative"), g = d.startsWith("colorblindsafe"), x = d.endsWith("reverse");
      p && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && h.push(d), m && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && u.push(d), g && (!e.isPaletteReversed && !x || e.isPaletteReversed && x) && o.push(d);
    }
    r = h, i = u;
  }
  return he.useEffect(() => {
    let h = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (h = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (h = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: h } });
  }, [e.twoColor.isPaletteReversed]), he.useEffect(() => {
    let h = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (h = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (h = e.palette.slice(0, -7)), t({ ...e, palette: h });
  }, [e.isPaletteReversed]), { twoColorPalettes: n, sequential: r, nonSequential: i, accessibleColors: o };
}, AT = (e) => {
  var ae;
  const { config: t, updateConfig: n, colorPalettes: r, twoColorPalette: i } = he.useContext(pt), { visual: o } = t, { setLollipopShape: h, updateField: u } = $f(), {
    visHasBarBorders: d,
    visCanAnimate: p,
    visSupportsNonSequentialPallete: m,
    headerColors: g,
    visSupportsTooltipOpacity: x,
    visSupportsTooltipLines: A,
    visSupportsBarSpace: k,
    visSupportsBarThickness: y,
    visHasDataCutoff: v,
    visSupportsSequentialPallete: S,
    visSupportsReverseColorPalette: B,
    visHasSingleSeriesTooltip: R
  } = Hl(), { twoColorPalettes: N, sequential: D, nonSequential: L, accessibleColors: q } = CT(t, n), V = (Y, Q) => {
    if (console.log("value", Q), Y === "storyNodeFontColor") {
      n({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: Q
        }
      });
      return;
    } else
      n({
        ...t,
        sankey: {
          ...t.sankey,
          [Y]: {
            ...t.sankey[Y],
            default: Q
          }
        }
      });
  };
  return /* @__PURE__ */ O(Tn, { children: [
    /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: "Visual" }) }),
    /* @__PURE__ */ O(Ln, { children: [
      (t.barStyle === "lollipop" || t.isLollipopChart) && /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ O("fieldset", { className: "header", children: [
          /* @__PURE__ */ a("legend", { className: "edit-label", children: "Lollipop Shape" }),
          /* @__PURE__ */ O(
            "div",
            {
              onChange: (Y) => {
                h(Y.target.value);
              },
              children: [
                /* @__PURE__ */ O("label", { className: "radio-label", children: [
                  /* @__PURE__ */ a("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }),
                  "Circle"
                ] }),
                /* @__PURE__ */ O("label", { className: "radio-label", children: [
                  /* @__PURE__ */ a("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }),
                  "Square"
                ] })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ a(
          ht,
          {
            value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone",
            fieldName: "lollipopColorStyle",
            label: "Lollipop Color Style",
            updateField: u,
            options: ["regular", "two-tone"]
          }
        ),
        /* @__PURE__ */ a(
          ht,
          {
            value: t.lollipopSize ? t.lollipopSize : "small",
            fieldName: "lollipopSize",
            label: "Lollipop Size",
            updateField: u,
            options: ["small", "medium", "large"]
          }
        )
      ] }),
      t.visualizationType === "Box Plot" && /* @__PURE__ */ O("fieldset", { className: "fieldset fieldset--boxplot", children: [
        /* @__PURE__ */ a("legend", { className: "", children: "Box Plot Settings" }),
        /* @__PURE__ */ a(
          ht,
          {
            value: t.boxplot.borders,
            fieldName: "borders",
            section: "boxplot",
            label: "Box Plot Borders",
            updateField: u,
            options: ["true", "false"]
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: t.boxplot.plotOutlierValues,
            fieldName: "plotOutlierValues",
            section: "boxplot",
            label: "Plot Outliers",
            updateField: u
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: t.boxplot.plotNonOutlierValues,
            fieldName: "plotNonOutlierValues",
            section: "boxplot",
            label: "Plot non-outlier values",
            updateField: u
          }
        )
      ] }),
      d() && /* @__PURE__ */ a(
        ht,
        {
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
              Ve,
              {
                display: "question",
                style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
              }
            ) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Recommended set to display for Section 508 compliance." }) })
          ] }),
          value: t.barHasBorder,
          fieldName: "barHasBorder",
          label: "Bar Borders",
          updateField: u,
          options: ["true", "false"]
        }
      ),
      p() && /* @__PURE__ */ a(
        Ge,
        {
          value: t.animate,
          fieldName: "animate",
          label: "Animate Visualization",
          updateField: u
        }
      ),
      (((ae = t.series) == null ? void 0 : ae.some(
        (Y) => Y.type === "Line" || Y.type === "dashed-lg" || Y.type === "dashed-sm" || Y.type === "dashed-md"
      )) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ a(
          ht,
          {
            tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                Ve,
                {
                  display: "question",
                  style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                }
              ) }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Shapes will appear in the following order: circle, square, triangle, diamond, and inverted triangle. Use with a maximum of 5 data points." }) })
            ] }),
            value: t.visual.lineDatapointSymbol,
            section: "visual",
            fieldName: "lineDatapointSymbol",
            label: "Line Datapoint Symbols",
            updateField: u,
            options: ["none", "standard"]
          }
        ),
        t.series.length > t.visual.maximumShapeAmount && t.visual.lineDatapointSymbol === "standard" && /* @__PURE__ */ a("small", { className: "text-danger", children: "Standard only supports up to 7 data points" }),
        /* @__PURE__ */ a(
          ht,
          {
            value: t.lineDatapointStyle,
            fieldName: "lineDatapointStyle",
            label: "Line Datapoint Style",
            updateField: u,
            options: ["hidden", "hover", "always show"]
          }
        ),
        /* @__PURE__ */ a(
          ht,
          {
            value: t.lineDatapointColor,
            fieldName: "lineDatapointColor",
            label: "Line Datapoint Color",
            updateField: u,
            options: ["Same as Line", "Lighter than Line"]
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: !t.isolatedDotsSameSize,
            fieldName: "isolatedDotsSameSize",
            label: "Accentuate isolated data points",
            updateField: (Y, Q, se, ie) => u(Y, Q, se, !ie)
          }
        )
      ] }),
      /* @__PURE__ */ O("label", { className: "header", children: [
        /* @__PURE__ */ a("span", { className: "edit-label", children: "Header Theme" }),
        /* @__PURE__ */ a("ul", { className: "color-palette", children: g.map((Y) => /* @__PURE__ */ a(
          "button",
          {
            title: Y,
            onClick: (Q) => {
              Q.preventDefault(), n({ ...t, theme: Y });
            },
            className: t.theme === Y ? "selected " + Y : Y
          },
          Y
        )) })
      ] }),
      (m() || m()) && /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ a("label", { children: /* @__PURE__ */ a("span", { className: "edit-label", children: "Chart Color Palette" }) }),
        B() && /* @__PURE__ */ a(
          qf,
          {
            fieldName: "isPaletteReversed",
            size: "small",
            label: "Use selected palette in reverse order",
            updateField: u,
            value: t.isPaletteReversed
          }
        ),
        S() && /* @__PURE__ */ O(ze, { children: [
          /* @__PURE__ */ a("span", { children: "Sequential" }),
          /* @__PURE__ */ a("ul", { className: "color-palette", children: D.map((Y) => {
            const Q = {
              backgroundColor: r[Y][2]
            }, se = {
              backgroundColor: r[Y][3]
            }, ie = {
              backgroundColor: r[Y][5]
            };
            return /* @__PURE__ */ O(
              "button",
              {
                title: Y,
                onClick: (M) => {
                  M.preventDefault(), n({ ...t, palette: Y });
                },
                className: t.palette === Y ? "selected" : "",
                children: [
                  /* @__PURE__ */ a("span", { style: Q }),
                  /* @__PURE__ */ a("span", { style: se }),
                  /* @__PURE__ */ a("span", { style: ie })
                ]
              },
              Y
            );
          }) })
        ] }),
        m() && /* @__PURE__ */ O(ze, { children: [
          /* @__PURE__ */ a("span", { children: "Non-Sequential" }),
          /* @__PURE__ */ a("ul", { className: "color-palette", children: L.map((Y) => {
            const Q = {
              backgroundColor: r[Y][2]
            }, se = {
              backgroundColor: r[Y][4]
            }, ie = {
              backgroundColor: r[Y][6]
            };
            return /* @__PURE__ */ O(
              "button",
              {
                title: Y,
                onClick: (M) => {
                  M.preventDefault(), n({ ...t, palette: Y });
                },
                className: t.palette === Y ? "selected" : "",
                children: [
                  /* @__PURE__ */ a("span", { style: Q }),
                  /* @__PURE__ */ a("span", { style: se }),
                  /* @__PURE__ */ a("span", { style: ie })
                ]
              },
              Y
            );
          }) }),
          /* @__PURE__ */ a("span", { children: "Colorblind Safe" }),
          /* @__PURE__ */ a("ul", { className: "color-palette", children: q.map((Y) => {
            const Q = {
              backgroundColor: r[Y][2]
            }, se = {
              backgroundColor: r[Y][3]
            }, ie = {
              backgroundColor: r[Y][5]
            };
            return /* @__PURE__ */ O(
              "button",
              {
                title: Y,
                onClick: (M) => {
                  M.preventDefault(), n({ ...t, palette: Y });
                },
                className: t.palette === Y ? "selected" : "",
                children: [
                  /* @__PURE__ */ a("span", { style: Q }),
                  /* @__PURE__ */ a("span", { style: se }),
                  /* @__PURE__ */ a("span", { style: ie })
                ]
              },
              Y
            );
          }) })
        ] })
      ] }),
      t.visualizationType === "Sankey" && /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ O("span", { className: "sankey__color-input", children: [
          /* @__PURE__ */ a(
            "input",
            {
              type: "color",
              value: t.sankey.nodeColor.default,
              id: "storyNodeColor",
              name: "storyNodeColor",
              onChange: (Y) => V("nodeColor", Y.target.value)
            }
          ),
          /* @__PURE__ */ a("label", { htmlFor: "storyNodeColor", children: "Story Node Color" })
        ] }),
        /* @__PURE__ */ O("span", { className: "sankey__color-input", children: [
          /* @__PURE__ */ a(
            "input",
            {
              type: "color",
              value: t.sankey.storyNodeFontColor || "red",
              id: "storyNodeFontColor",
              name: "storyNodeFontColor",
              onChange: (Y) => V("storyNodeFontColor", Y.target.value)
            }
          ),
          /* @__PURE__ */ a("label", { htmlFor: "storyNodeFontColor", children: "Story Node Font Color" })
        ] }),
        /* @__PURE__ */ O("span", { className: "sankey__color-input", children: [
          /* @__PURE__ */ a(
            "input",
            {
              type: "color",
              value: t.sankey.linkColor.default,
              id: "linkColor",
              name: "linkColor",
              onChange: (Y) => V("linkColor", Y.target.value)
            }
          ),
          /* @__PURE__ */ a("label", { htmlFor: "linkColor", children: "Link Color" })
        ] })
      ] }),
      (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ a(
          qf,
          {
            section: "twoColor",
            fieldName: "isPaletteReversed",
            size: "small",
            label: "Use selected palette in reverse order",
            updateField: u,
            value: t.twoColor.isPaletteReversed
          }
        ),
        /* @__PURE__ */ a("ul", { className: "color-palette", children: N.map((Y) => {
          const Q = {
            backgroundColor: i[Y][0]
          }, se = {
            backgroundColor: i[Y][1]
          };
          return /* @__PURE__ */ O(
            "button",
            {
              title: Y,
              onClick: (ie) => {
                ie.preventDefault(), n({ ...t, twoColor: { ...t.twoColor, palette: Y } });
              },
              className: t.twoColor.palette === Y ? "selected" : "",
              children: [
                /* @__PURE__ */ a("span", { className: "two-color", style: Q }),
                /* @__PURE__ */ a("span", { className: "two-color", style: se })
              ]
            },
            Y
          );
        }) })
      ] }),
      v() && /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ a(
        $e,
        {
          value: t.dataCutoff,
          type: "number",
          fieldName: "dataCutoff",
          className: "number-narrow",
          label: "Data Cutoff",
          updateField: u,
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.' }) })
          ] })
        }
      ) }),
      y() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ a(
        $e,
        {
          type: "number",
          value: t.barHeight || "25",
          fieldName: "barHeight",
          label: " Bar Thickness",
          updateField: u,
          min: 15
        }
      ),
      (t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ a(
        $e,
        {
          value: t.barThickness,
          type: "number",
          fieldName: "barThickness",
          label: "Bar Thickness",
          updateField: u
        }
      ),
      k() && /* @__PURE__ */ a(
        $e,
        {
          type: "number",
          value: t.barSpace || "15",
          fieldName: "barSpace",
          label: "Bar Space",
          updateField: u,
          min: 0
        }
      ),
      (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ a(
        Ge,
        {
          value: t.topAxis.hasLine,
          section: "topAxis",
          fieldName: "hasLine",
          label: "Add Top Axis Line",
          updateField: u
        }
      ),
      t.visualizationType === "Spark Line" && /* @__PURE__ */ O("div", { className: "cove-accordion__panel-section checkbox-group", children: [
        /* @__PURE__ */ a(
          Ge,
          {
            value: o == null ? void 0 : o.border,
            section: "visual",
            fieldName: "border",
            label: "Show Border",
            updateField: u
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: o == null ? void 0 : o.borderColorTheme,
            section: "visual",
            fieldName: "borderColorTheme",
            label: "Use Border Color Theme",
            updateField: u
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: o == null ? void 0 : o.accent,
            section: "visual",
            fieldName: "accent",
            label: "Use Accent Style",
            updateField: u
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: o == null ? void 0 : o.background,
            section: "visual",
            fieldName: "background",
            label: "Use Theme Background Color",
            updateField: u
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: o == null ? void 0 : o.hideBackgroundColor,
            section: "visual",
            fieldName: "hideBackgroundColor",
            label: "Hide Background Color",
            updateField: u
          }
        )
      ] }),
      (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ a(
        Ge,
        {
          value: t.showLineSeriesLabels,
          fieldName: "showLineSeriesLabels",
          label: "Append Series Name to End of Line Charts",
          updateField: u
        }
      ),
      (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ a(
        Ge,
        {
          value: t.colorMatchLineSeriesLabels,
          fieldName: "colorMatchLineSeriesLabels",
          label: "Match Series Color to Name at End of Line Charts",
          updateField: u
        }
      ),
      A() && /* @__PURE__ */ O(ze, { children: [
        /* @__PURE__ */ a(
          Ge,
          {
            value: o.verticalHoverLine,
            fieldName: "verticalHoverLine",
            section: "visual",
            label: "Vertical Hover Line",
            updateField: u
          }
        ),
        /* @__PURE__ */ a(
          Ge,
          {
            value: o.horizontalHoverLine,
            fieldName: "horizontalHoverLine",
            section: "visual",
            label: "Horizontal Hover Line",
            updateField: u
          }
        )
      ] }),
      x() && /* @__PURE__ */ O("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Tooltip Opacity" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            value: t.tooltips.opacity ? t.tooltips.opacity : 100,
            onChange: (Y) => n({
              ...t,
              tooltips: {
                ...t.tooltips,
                opacity: Y.target.value
              }
            })
          }
        )
      ] }),
      R() && /* @__PURE__ */ a(
        Ge,
        {
          value: t.tooltips.singleSeries,
          fieldName: "singleSeries",
          section: "tooltips",
          label: "SHOW HOVER FOR SINGLE DATA SERIES",
          updateField: u
        }
      ),
      /* @__PURE__ */ O("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "No Data Message" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "text",
            value: t.chartMessage.noData ? t.chartMessage.noData : "",
            onChange: (Y) => n({
              ...t,
              chartMessage: {
                ...t.chartMessage,
                noData: Y.target.value
              }
            })
          }
        )
      ] })
    ] })
  ] });
}, LT = (e) => {
  var d, p, m, g, x;
  const { config: t, updateConfig: n } = he.useContext(pt), r = (d = t.data) == null ? void 0 : d[0], { updateField: i } = he.useContext(zf);
  if (t.visualizationType !== "Sankey")
    return;
  const o = (A, k, y) => {
    let v = [];
    r != null && r.storyNodeText && (v = [...r == null ? void 0 : r.storyNodeText]), v[y][A] = k, n({
      ...t,
      sankey: {
        ...t.sankey,
        data: {
          ...t.sankey.data,
          storyNodeText: v
        }
      }
    });
  }, h = () => {
    const A = r;
    A.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), n({
      ...t,
      sankey: {
        ...t.sankey,
        data: [{ ...A }]
      }
    });
  }, u = (A) => {
    const k = r;
    k.storyNodeText.splice(A, 1), n({ ...t, sankey: { ...t.sankey, data: { ...k } } });
  };
  return /* @__PURE__ */ O(Tn, { children: [
    /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: "Sankey Settings" }) }),
    /* @__PURE__ */ O(Ln, { children: [
      /* @__PURE__ */ a("p", { children: "Node stories can provide additional details to support public health messaging. COVE can display a maximum of 3 node stories." }),
      (r == null ? void 0 : r.storyNodeText) && (r == null ? void 0 : r.storyNodeText.map(({ StoryNode: A, segmentTextBefore: k, segmentTextAfter: y }, v) => /* @__PURE__ */ O(
        "div",
        {
          style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" },
          children: [
            /* @__PURE__ */ O("label", { children: [
              "Story Node Text",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "text",
                  value: A,
                  fieldName: "StoryNode",
                  label: "StoryNode",
                  onChange: (S) => o("StoryNode", S.target.value, v)
                }
              )
            ] }),
            /* @__PURE__ */ O("label", { children: [
              "Story Text Before",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "text",
                  value: k,
                  fieldName: "segmentTextBefore",
                  label: "Segment Text Before",
                  onChange: (S) => o("segmentTextBefore", S.target.value, v)
                }
              )
            ] }),
            /* @__PURE__ */ O("label", { children: [
              "Story Text After",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "text",
                  value: y,
                  fieldName: "segmentTextAfter",
                  label: "Segment Text After",
                  onChange: (S) => o("segmentTextAfter", S.target.value, v)
                }
              )
            ] }),
            /* @__PURE__ */ a(Oc, { onClick: (S) => u(v), className: "btn btn-danger full-width", children: "Remove Story Node" })
          ]
        },
        v
      ))),
      ((p = r == null ? void 0 : r.storyNodeText) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ a(
        "button",
        {
          type: "button",
          className: "btn btn-primary full-width",
          onClick: (A) => {
            A.preventDefault(), h();
          },
          children: "Add StoryNode"
        }
      ),
      ((x = (g = (m = t.data) == null ? void 0 : m[0]) == null ? void 0 : g.tooltips) == null ? void 0 : x.length) > 0 && /* @__PURE__ */ a(
        Ge,
        {
          value: t.enableTooltips,
          fieldName: "enableTooltips",
          label: "Enable Tooltips",
          updateField: i
        }
      )
    ] })
  ] });
};
const ET = (e) => {
  var u, d, p;
  const { updateConfig: t, config: n, svgRef: r } = he.useContext(pt), i = (m, g, x) => {
    var v;
    const A = (v = document.querySelector(".chart-container  > svg")) == null ? void 0 : v.getBoundingClientRect(), k = [A == null ? void 0 : A.width, A == null ? void 0 : A.height], y = [...n == null ? void 0 : n.annotations];
    y[x][g] = m, y[x].savedDimensions = k, t({
      ...n,
      annotations: y
    });
  }, o = () => {
    var A, k, y, v, S, B, R, N, D, L;
    const m = [
      ((y = (k = (A = r == null ? void 0 : r.current) == null ? void 0 : A.width) == null ? void 0 : k.baseVal) == null ? void 0 : y.value) || ((v = r == null ? void 0 : r.current) == null ? void 0 : v.width),
      ((R = (B = (S = r == null ? void 0 : r.current) == null ? void 0 : S.height) == null ? void 0 : B.baseVal) == null ? void 0 : R.value) || ((N = r == null ? void 0 : r.current) == null ? void 0 : N.height)
    ], g = {
      text: "New Annotation",
      snapToNearestPoint: !1,
      fontSize: 16,
      bezier: 10,
      show: {
        desktop: !0,
        tablet: !0,
        mobile: !0
      },
      connectorType: "line",
      colors: {
        label: "black",
        connector: "black",
        marker: "black"
      },
      selected: !0,
      anchor: {
        vertical: !1,
        horizontal: !1
      },
      marker: "arrow",
      edit: {
        subject: !0,
        label: !0
      },
      seriesKey: "",
      x: 50,
      y: Number((m == null ? void 0 : m[1]) / 2),
      xKey: n.xAxis.type === "date" ? new Date((L = (D = n == null ? void 0 : n.data) == null ? void 0 : D[0]) == null ? void 0 : L[n.xAxis.dataKey]).getTime() : n.xAxis.type === "categorical" ? "1/15/2016" : "",
      yKey: "",
      dx: 20,
      dy: -20,
      opacity: "100",
      savedDimensions: m,
      connectionType: "line"
    }, x = Array.isArray(n.annotations) ? n.annotations : [];
    t({
      ...n,
      annotations: [...x, g]
    });
  }, h = (m) => {
    const g = n.annotations.filter((x, A) => A !== m);
    t({
      ...n,
      annotations: g
    });
  };
  return /* @__PURE__ */ a(Du, { children: /* @__PURE__ */ O(Du.Section, { title: e.name, children: [
    /* @__PURE__ */ O("label", { children: [
      "Show Annotation Dropdown",
      /* @__PURE__ */ a(
        "input",
        {
          type: "checkbox",
          checked: ((u = n == null ? void 0 : n.general) == null ? void 0 : u.showAnnotationDropdown) || !1,
          onChange: (m) => {
            t({
              ...n,
              general: {
                ...n.general,
                showAnnotationDropdown: m.target.checked
              }
            });
          }
        }
      )
    ] }, "key-1"),
    n.general.showAnnotationDropdown && /* @__PURE__ */ O("label", { children: [
      "Annotation Dropdown Title:",
      /* @__PURE__ */ a(
        "input",
        {
          type: "text",
          style: { marginBottom: "10px" },
          value: (d = n == null ? void 0 : n.general) == null ? void 0 : d.annotationDropdownText,
          onChange: (m) => {
            t({
              ...n,
              general: {
                ...n.general,
                annotationDropdownText: m.target.value
              }
            });
          }
        }
      )
    ] }, "key-2"),
    (n == null ? void 0 : n.annotations) && (n == null ? void 0 : n.annotations.map((m, g) => {
      var x, A, k, y, v, S, B, R;
      return /* @__PURE__ */ a(Du, { children: /* @__PURE__ */ a(
        Du.Section,
        {
          title: m.text ? m.text.substring(0, 15) + "..." : `Annotation ${g + 1}`,
          children: /* @__PURE__ */ O("div", { className: "annotation-group", children: [
            /* @__PURE__ */ O("label", { children: [
              "Annotation Text:",
              /* @__PURE__ */ a(
                "textarea",
                {
                  rows: 5,
                  value: m.text,
                  onChange: (N) => i(N.target.value, "text", g)
                }
              )
            ] }),
            /* @__PURE__ */ O("label", { children: [
              "Opacity",
              /* @__PURE__ */ a("br", {}),
              /* @__PURE__ */ a(
                "input",
                {
                  type: "range",
                  onChange: (N) => {
                    const D = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    D[g].opacity = N.target.value, t({
                      ...n,
                      annotations: D
                    });
                  },
                  value: ((A = (x = n == null ? void 0 : n.annotations) == null ? void 0 : x[g]) == null ? void 0 : A.opacity) || "100"
                }
              )
            ] }),
            /* @__PURE__ */ O("label", { children: [
              "Edit Subject",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: ((y = (k = n == null ? void 0 : n.annotations[g]) == null ? void 0 : k.edit) == null ? void 0 : y.subject) || !1,
                  onChange: (N) => {
                    const D = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    D[g].edit.subject = N.target.checked, t({
                      ...n,
                      annotations: D
                    });
                  }
                }
              )
            ] }),
            /* @__PURE__ */ O("label", { children: [
              "Edit Label",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: ((S = (v = n == null ? void 0 : n.annotations[g]) == null ? void 0 : v.edit) == null ? void 0 : S.label) || !1,
                  onChange: (N) => {
                    const D = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    D[g].edit.label = N.target.checked, t({
                      ...n,
                      annotations: D
                    });
                  }
                }
              )
            ] }),
            /* @__PURE__ */ O("label", { children: [
              "Connection Type:",
              /* @__PURE__ */ O(
                "select",
                {
                  onChange: (N) => {
                    const D = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    D[g].connectionType = N.target.value, t({
                      ...n,
                      annotations: D
                    });
                  },
                  value: (B = n == null ? void 0 : n.annotations[g]) == null ? void 0 : B.connectionType,
                  children: [
                    /* @__PURE__ */ a("option", { value: "select", children: "Select" }, "select"),
                    ["curve", "line", "elbow", "none"].map((N, D) => /* @__PURE__ */ a("option", { value: N, children: N }, N))
                  ]
                },
                "annotation-connection-type"
              )
            ] }),
            m.connectionType === "curve" && /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O("label", { children: [
              "Curve Control",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "range",
                  min: "-20",
                  max: "20",
                  value: ((R = n == null ? void 0 : n.annotations[g]) == null ? void 0 : R.bezier) || 0,
                  onChange: (N) => {
                    const D = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    D[g].bezier = N.target.value, t({
                      ...n,
                      annotations: D
                    });
                  }
                }
              )
            ] }) }),
            /* @__PURE__ */ O("label", { children: [
              "Marker",
              /* @__PURE__ */ a(
                "select",
                {
                  value: m.marker,
                  onChange: (N) => {
                    const D = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    D[g].marker = N.target.value, t({
                      ...n,
                      annotations: D
                    });
                  },
                  children: ["arrow", "circle"].map((N, D) => /* @__PURE__ */ a("option", { children: N }, `col-${D}`))
                },
                "annotation-marker"
              )
            ] }),
            /* @__PURE__ */ a(Oc, { className: "btn btn-danger full-width", onClick: () => h(g), children: "Delete Annotation" })
          ] })
        }
      ) }, g);
    })),
    ((p = n == null ? void 0 : n.annotations) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ a("button", { onClick: o, className: "btn btn-primary mt-2 full-width", children: "Add Annotation" })
  ] }, e.name) }, e.name);
}, wi = {
  ForestPlot: sT,
  Series: oi,
  Regions: wT,
  General: kT,
  BoxPlot: TT,
  Visual: AT,
  Sankey: LT,
  Annotate: ET
};
const _T = new Gm(), Cm = (e, t) => {
  for (let n = 0; n < e.length; n++) {
    let r = Object.keys(e[n]), i = !0;
    for (let o = 0; o < r.length; o++)
      if (e[n][r[o]] !== t[r[o]]) {
        i = !1;
        break;
      }
    if (i)
      return n;
  }
  return -1;
}, PT = (e, t, n) => {
  var i;
  const r = Ke.cloneDeep(e);
  if (r.rankByValue = t, e.rankByValue && !t) {
    const o = Object.values(Ke.get(e, "confidenceKeys", {})), u = [...Ke.get(e, "series", []).map((m) => m.dataKey) ?? [], ...o ?? []], d = (i = e == null ? void 0 : e.xAxis) != null && i.dataKey ? _T.cleanData(e.data, e.xAxis.dataKey, u) : e.data, p = n.sort((m, g) => {
      const x = Cm(d, m), A = Cm(d, g);
      return x - A;
    });
    return [r, p];
  }
  return [r];
}, NT = ({ config: e, updateConfig: t, data: n }) => {
  var v, S, B;
  const r = e.visualizationType === "Combo", i = ((v = e.runtime.lineSeriesKeys) == null ? void 0 : v.length) > 0, o = ((S = e.runtime.barSeriesKeys) == null ? void 0 : S.length) > 0, h = r && i, u = r && o, d = () => Ke.uniq(Ke.flatMap(n, Ke.keys)), p = () => e.visualizationType === "Line" || h ? ["effect", "suppression"] : ["suppression"], m = {
    "Dashed Small": "- - -",
    "Dashed Medium": "– –",
    "Dashed Large": "— –",
    "Open Circles": "◯",
    "Filled Circles": ""
  }, g = (R) => {
    const N = Object.keys(m);
    return R === "suppression" ? N.slice(0, -2) : N;
  }, x = () => {
    if (e.visualizationType === "Bar" || u)
      return Object.keys(ap);
  };
  let A = (R) => {
    let N = [];
    e.preliminaryData && (N = [...e.preliminaryData]), N.splice(R, 1), t({ ...e, preliminaryData: N });
  }, k = () => {
    const R = e.visualizationType === "Line" ? "effect" : "suppression";
    let N = e.preliminaryData ? [...e.preliminaryData] : [];
    const D = {
      type: R,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: "",
      hideBarSymbol: !1,
      hideLineStyle: !1,
      circleSize: 6,
      displayGray: !0
    };
    N.push(D), t({ ...e, preliminaryData: N });
  }, y = (R, N, D) => {
    let L = [];
    e.preliminaryData && (L = [...e.preliminaryData]), L[D][R] = N, R === "symbol" && (L[D].iconCode = ap[N]), R === "style" && (L[D].lineCode = m[N]), t({ ...e, preliminaryData: L });
  };
  return /* @__PURE__ */ O(ze, { children: [
    e.preliminaryData && ((B = e.preliminaryData) == null ? void 0 : B.map(
      ({
        displayGray: R,
        circleSize: N,
        column: D,
        displayLegend: L,
        displayTable: q,
        displayTooltip: V,
        label: ae,
        seriesKey: Y,
        style: Q,
        symbol: se,
        type: ie,
        value: M,
        hideBarSymbol: U,
        hideLineStyle: re
      }, j) => {
        var de, Z;
        return /* @__PURE__ */ O("div", { className: "edit-block", children: [
          /* @__PURE__ */ O("p", { children: [
            " ",
            ie === "suppression" ? "Suppressed" : "Effect",
            " Data"
          ] }),
          /* @__PURE__ */ a(
            "button",
            {
              type: "button",
              className: "btn btn-danger",
              onClick: (ge) => {
                ge.preventDefault(), A(j);
              },
              children: "Remove"
            }
          ),
          /* @__PURE__ */ a(
            ht,
            {
              value: ie,
              initial: e.visualizationType == "Bar" ? "" : "Select",
              fieldName: "type",
              label: "Type",
              updateField: (ge, ne, G, me) => y(G, me, j),
              options: p()
            }
          ),
          ie === "suppression" ? /* @__PURE__ */ O(ze, { children: [
            /* @__PURE__ */ a(
              ht,
              {
                tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ O("p", { children: [
                    " ",
                    'Without a selected "Data Series", the suppression symbol will be applied for all series in the current dataset visualization. However, choosing a specific "data series" will isolate the suppression to that series.'
                  ] }) })
                ] }),
                value: D,
                initial: "Select",
                fieldName: "column",
                label: "Add Data Series",
                updateField: (ge, ne, G, me) => y(G, me, j),
                options: (de = e.runtime) == null ? void 0 : de.seriesKeys
              }
            ),
            /* @__PURE__ */ a(
              $e,
              {
                value: M,
                fieldName: "value",
                label: "Suppressed Data  Value",
                updateField: (ge, ne, G, me) => y(G, me, j)
              }
            ),
            (h || e.visualizationType === "Line") && /* @__PURE__ */ O(ze, { children: [
              /* @__PURE__ */ a(
                ht,
                {
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "The recommended approach for presenting data is to include a footnote indicating any data suppression." }) })
                  ] }),
                  value: Q,
                  initial: "Select",
                  fieldName: "style",
                  label: "suppression line style",
                  updateField: (ge, ne, G, me) => y(G, me, j),
                  options: g(ie)
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: re,
                  fieldName: "hideLineStyle",
                  label: "Hide Suppressed line Style",
                  updateField: (ge, ne, G, me) => y(G, me, j)
                }
              )
            ] }),
            (u || e.visualizationType === "Bar") && /* @__PURE__ */ O(ze, { children: [
              /* @__PURE__ */ a(
                ht,
                {
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ O("p", { children: [
                      "A symbol is ",
                      /* @__PURE__ */ a("i", { children: "required" }),
                      ' to indicate suppressed data. We suggest "double asterisks." If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'
                    ] }) })
                  ] }),
                  value: se,
                  initial: "Select",
                  fieldName: "symbol",
                  label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
                  updateField: (ge, ne, G, me) => y(G, me, j),
                  options: x()
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: U,
                  fieldName: "hideBarSymbol",
                  label: "Hide Suppressed Bar Symbol  ",
                  updateField: (ge, ne, G, me) => y(G, me, j)
                }
              )
            ] }),
            /* @__PURE__ */ a(
              $e,
              {
                tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "This label will display in the tooltip and legend." }) })
                ] }),
                value: ae || "Suppressed",
                fieldName: "label",
                label: "Suppressed Data Label",
                placeholder: "",
                updateField: (ge, ne, G, me) => y(G, me, j)
              }
            ),
            /* @__PURE__ */ a(
              Ge,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Deselecting the "Display In Tooltips" option prevents suppressed values from appearing in tooltips.' }) })
                ] }),
                value: V,
                fieldName: "displayTooltip",
                label: "Display in tooltips",
                updateField: (ge, ne, G, me) => y(G, me, j)
              }
            ),
            /* @__PURE__ */ a(
              Ge,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.' }) })
                ] }),
                value: L,
                fieldName: "displayLegend",
                label: "Display in legend",
                updateField: (ge, ne, G, me) => y(G, me, j)
              }
            ),
            /* @__PURE__ */ a(
              Ge,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.' }) })
                ] }),
                value: q,
                fieldName: "displayTable",
                label: "Display in table",
                updateField: (ge, ne, G, me) => y(G, me, j)
              }
            ),
            /* @__PURE__ */ a(
              Ge,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting this option will apply to chart, tooltip hover, legend, and data table." }) })
                ] }),
                value: R,
                fieldName: "displayGray",
                label: "Highlight Suppressed Data In Gray",
                updateField: (ge, ne, G, me) => y(G, me, j)
              }
            )
          ] }) : /* @__PURE__ */ O(ze, { children: [
            /* @__PURE__ */ a(
              ht,
              {
                value: Y,
                initial: "Select",
                fieldName: "seriesKey",
                label: "ASSOCIATE TO SERIES",
                updateField: (ge, ne, G, me) => y(G, me, j),
                options: e.runtime.lineSeriesKeys ?? ((Z = e.runtime) == null ? void 0 : Z.seriesKeys)
              }
            ),
            /* @__PURE__ */ a(
              ht,
              {
                value: D,
                initial: "Select",
                fieldName: "column",
                label: "COLUMN WITH CONFIGURATION VALUE",
                updateField: (ge, ne, G, me) => y(G, me, j),
                options: d()
              }
            ),
            /* @__PURE__ */ a(
              $e,
              {
                tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "If 'Filled Circles' is selected as the style, this field is optional, and the style 'Filled Circles' will apply to all points within the associated series data." }) })
                ] }),
                value: M,
                fieldName: "value",
                label: "VALUE TO TRIGGER",
                updateField: (ge, ne, G, me) => y(G, me, j)
              }
            ),
            /* @__PURE__ */ a(
              ht,
              {
                value: Q,
                initial: "Select",
                fieldName: "style",
                label: "Style",
                updateField: (ge, ne, G, me) => y(G, me, j),
                options: g(ie)
              }
            ),
            Q.includes("Circles") && /* @__PURE__ */ a(
              $e,
              {
                className: "number-narrow",
                type: "number",
                value: N,
                fieldName: "circleSize",
                label: "circle size",
                updateField: (ge, ne, G, me) => y(G, me, j)
              }
            ),
            Q !== "Filled Circles" && /* @__PURE__ */ a(
              $e,
              {
                value: ae,
                fieldName: "label",
                label: "Label",
                placeholder: "",
                updateField: (ge, ne, G, me) => y(G, me, j)
              }
            )
          ] })
        ] }, `preliminaryData-${j}`);
      }
    )),
    /* @__PURE__ */ a("button", { type: "button", onClick: k, className: "btn btn-primary full-width", children: e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line" })
  ] });
}, RT = ({ config: e, updateConfig: t, display: n }) => {
  var p, m, g, x;
  const r = (p = e == null ? void 0 : e.yAxis) == null ? void 0 : p.maxValue, i = ((g = (m = e == null ? void 0 : e.yAxis) == null ? void 0 : m.categories) == null ? void 0 : g.reduce((A, k) => A + (parseFloat(k.height) || 0), 0)) || 0, o = (A) => {
    let k = [];
    e.yAxis.categories && (k = [...e.yAxis.categories]), k.splice(A, 1), t({ ...e, yAxis: { ...e.yAxis, categories: k } });
  }, h = () => {
    var v, S;
    const A = (S = (v = e.yAxis) == null ? void 0 : v.categories) == null ? void 0 : S.length, k = 0.4;
    return Qi("#ddd").darken(k * A).hex();
  }, u = () => {
    const A = e.yAxis.categories ? [...e.yAxis.categories] : [], k = {
      label: "Label " + Number(A.length + 1),
      height: "",
      color: h()
    };
    A.push(k), t({ ...e, yAxis: { ...e.yAxis, categories: A } });
  }, d = (A, k, y) => {
    let v = [];
    e.yAxis.categories && (v = [...e.yAxis.categories]), v[y][A] = k, t({ ...e, yAxis: { ...e.yAxis, categories: v } });
  };
  return n ? /* @__PURE__ */ O(ze, { children: [
    e.yAxis.type === "categorical" && ((x = e.yAxis.categories) == null ? void 0 : x.map(({ label: A, color: k, height: y }, v) => /* @__PURE__ */ O("div", { className: "edit-block", children: [
      /* @__PURE__ */ O("p", { children: [
        "Axis Category ",
        v + 1
      ] }),
      /* @__PURE__ */ a(
        "button",
        {
          type: "button",
          className: "btn btn-danger",
          onClick: (S) => {
            S.preventDefault(), o(v);
          },
          children: "Remove"
        }
      ),
      /* @__PURE__ */ a(
        $e,
        {
          tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ O("p", { children: [
              " ",
              "Category Height will be ignored for the last category. The last category will fill the rest of the axis height."
            ] }) })
          ] }),
          type: "number",
          value: y,
          fieldName: "height",
          label: "Category Height",
          updateField: (S, B, R, N) => d(R, N, v)
        }
      ),
      Number(i) > Number(r) && e.yAxis.categories.length - 1 === v && /* @__PURE__ */ a("span", { style: { color: "red", display: "block", fontSize: "15px" }, children: "Update Max value to show all categories" }),
      /* @__PURE__ */ O("div", { className: "two-col-inputs", children: [
        /* @__PURE__ */ a(
          $e,
          {
            value: k,
            fieldName: "color",
            label: "Color",
            updateField: (S, B, R, N) => d(R, N, v)
          }
        ),
        /* @__PURE__ */ a(
          $e,
          {
            value: A,
            fieldName: "label",
            label: "Label",
            updateField: (S, B, R, N) => d(R, N, v)
          }
        )
      ] })
    ] }, `preliminaryData-${v}`))),
    /* @__PURE__ */ a("button", { type: "button", onClick: u, className: "btn btn-primary full-width", children: "Add Axis Category" })
  ] }) : /* @__PURE__ */ a(ze, {});
}, DT = ({ datasets: e }) => {
  var Ot, pn, an, un, ar, Rn, wn, mn, Mn, Wn, gr, vr, Xn, Vn, or, qn, Zn, b, C, I, H, oe, pe, we;
  const {
    config: t,
    updateConfig: n,
    tableData: r,
    transformedData: i,
    isLoading: o,
    colorScale: h,
    colorPalettes: u,
    twoColorPalette: d,
    unfilteredData: p,
    excludedData: m,
    isDashboard: g,
    setParentConfig: x,
    missingRequiredSections: A,
    isDebug: k,
    setFilteredData: y,
    lineOptions: v,
    rawData: S,
    highlight: B,
    handleShowAll: R,
    dimensions: N
  } = he.useContext(pt), { minValue: D, maxValue: L, existPositiveValue: q, isAllLine: V } = qc(t, p), ae = { data: i, config: t }, { leftMax: Y, rightMax: Q } = bg(ae), {
    visHasAnchors: se,
    visHasBrushChart: ie,
    visHasCategoricalAxis: M,
    visHasLegend: U,
    visHasLegendAxisAlign: re,
    visHasLegendColorCategory: j,
    visHasSelectableLegendValues: de,
    visSupportsDateCategoryAxis: Z,
    visSupportsDateCategoryAxisLabel: ge,
    visSupportsDateCategoryAxisLine: ne,
    visSupportsDateCategoryAxisMax: G,
    visSupportsDateCategoryAxisMin: me,
    visSupportsDateCategoryAxisPadding: ye,
    visSupportsDateCategoryAxisTicks: Se,
    visSupportsDateCategoryHeight: ce,
    visSupportsDateCategoryNumTicks: ke,
    visSupportsDateCategoryTickRotation: Ie,
    visSupportsDynamicSeries: Le,
    visSupportsFilters: Fe,
    visSupportsLeftValueAxis: Xe,
    visSupportsPreliminaryData: Be,
    visSupportsRankByValue: ot,
    visSupportsResponsiveTicks: gt,
    visSupportsValueAxisGridLines: st,
    visSupportsValueAxisLabels: dt,
    visSupportsValueAxisLine: Ye,
    visSupportsValueAxisMax: Je,
    visSupportsValueAxisMin: yt,
    visSupportsValueAxisTicks: nt,
    visSupportsYPadding: lt
  } = Hl();
  he.useEffect(() => {
    let K = [];
    t.series && (K = t.series.map((X) => ({
      ...X,
      type: t.visualizationType === "Combo" ? "Bar" : t.visualizationType ? t.visualizationType : "Bar",
      axis: "Left"
    }))), n({
      ...t,
      series: K
    });
  }, [t.visualizationType]), he.useEffect(() => {
    t.visualizationType === "Scatter Plot" && n({
      ...t,
      xAxis: {
        ...t.xAxis,
        type: "continuous"
      }
    });
  }, []), he.useEffect(() => {
    t.visualizationType !== "Bar" && n({ ...t, tooltips: { ...t.tooltips, singleSeries: !1 } });
  }, [t.visualizationType]);
  const { hasRightAxis: je } = Ff({ config: t, yMax: t.yAxis.size, data: t.data, updateConfig: n }), at = (K, X) => ({
    ...X
  }), ct = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, wt = (K) => {
    K.orientation === "horizontal" && (K.labels = !1), K.table.show === void 0 && (K.table.show = !g), K.visualizationType === "Combo" && (K.orientation = "vertical"), En(K.xAxis) && !K.xAxis.padding && (K.xAxis.padding = 0), K.visualizationType === "Line" && (K.visualizationSubType = "regular", K.barStyle = "flat", K.isLollipopChart = !1);
  }, rn = tv(t, n), Ne = (K, X, le, be) => {
    if (k && console.log(
      "#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue",
      K,
      X,
      le,
      be
    ), K === "boxplot" && (X === "legend" || X === "labels")) {
      n({
        ...t,
        [K]: {
          ...t[K],
          [X]: {
            ...t.boxplot[X],
            [le]: be
          }
        }
      });
      return;
    }
    const Ue = (Vt) => Vt === 0 ? !0 : !!Vt;
    if (K === "columns" && Ue(X) && Ue(le)) {
      n({
        ...t,
        columns: {
          ...t.columns,
          [X]: {
            ...t.columns[X],
            [le]: be
          }
        }
      });
      return;
    }
    if (K === null && X === null) {
      Ue(le) || console.error("fieldName is required");
      let Vt = { ...t, [le]: be };
      wt(Vt), n(Vt);
      return;
    }
    const Ft = Array.isArray(t[K]);
    let Ht = Ft ? [...t[K], be] : { ...t[K], [le]: be };
    Ue(X) && (Ft ? (Ht = [...t[K]], Ht[X] = { ...Ht[X], [le]: be }) : typeof be == "string" ? Ht[X] = be : Ue(le) && (Ht = { ...t[K], [X]: { ...t[K][X], [le]: be } }));
    let Rt = { ...t, [K]: Ht };
    wt(Rt), n(Rt);
  }, [Ct, bn] = he.useState(!0), [Zt, jt] = he.useState(!1);
  if (o)
    return null;
  const Qt = (K) => {
    n({
      ...t,
      lollipopShape: K
    });
  }, _n = (K) => {
    let X = t.series ? [...t.series] : [], le = Array.from(new Set(i.map((Ue) => Ue[K]))), be = [];
    le.forEach((Ue) => {
      be.push({ key: Ue });
    }), t.visualizationType === "Forecasting" ? X.push({
      dataKey: K,
      type: t.visualizationType,
      stages: be,
      stageColumn: K,
      axis: "Left",
      tooltip: !0
    }) : X.push({ dataKey: K, type: t.visualizationType, axis: "Left", tooltip: !0 }), n({ ...t, series: X });
  }, Gt = (K) => {
    let X = [...t.exclusions.keys];
    X.push(K);
    let le = { ...t.exclusions, keys: X };
    n({ ...t, exclusions: le });
  }, fn = (K) => {
    let X = -1, le = [...t.exclusions.keys];
    for (let be = 0; be < le.length; be++)
      if (le[be] === K) {
        X = be;
        break;
      }
    if (X !== -1) {
      le.splice(X, 1);
      let be = { ...t.exclusions, keys: le }, Ue = { ...t, exclusions: be };
      le.length === 0 && delete Ue.exclusions.keys, n(Ue);
    }
  }, Nt = (K = !0) => {
    let X = {};
    if (p.forEach((le) => {
      Object.keys(le).forEach((be) => X[be] = !0);
    }), K) {
      const { lower: le, upper: be } = t.confidenceKeys || {};
      Object.keys(X).forEach((Ue) => {
        (t.series && t.series.filter((Ft) => Ft.dataKey === Ue).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(Ue) && (le && be || le || be) && Ue !== le && Ue !== be) && delete X[Ue];
      });
    }
    return Object.keys(X);
  }, Yt = (K) => {
    const X = [];
    switch (K) {
      case "style":
        X.push("circles", "boxes"), t.visualizationType === "Bar" && (!["right", "left"].includes(t.legend.position) || !t.legend.position) && X.push("gradient"), t.visualizationType === "Line" && X.push("lines");
        break;
      case "subStyle":
        t.visualizationType === "Bar" ? X.push("linear blocks") : X.push("linear blocks", "smooth");
        break;
      case "groupBy":
        X.push(...Nt());
        break;
    }
    return X;
  }, tn = (K) => {
    if (!K)
      return [];
    const X = /* @__PURE__ */ new Set();
    for (let le = 0; le < K.length; le++)
      for (const [be] of Object.entries(K[le]))
        X.add(be);
    return Array.from(X);
  }, zt = (K, X = !1) => {
    let le = [];
    return m.forEach((be) => {
      le.push(be[K]);
    }), X ? [...new Set(le)] : le;
  }, It = () => {
    bn(!Ct), n({
      ...t,
      showEditorPanel: !Ct
    });
  }, $t = () => {
    let K = Ke.cloneDeep(t);
    return A(t) === !1 && delete K.newViz, delete K.runtime, K;
  };
  he.useEffect(() => {
    if (x) {
      const K = $t();
      x(K);
    }
  }, [t]), he.useEffect(() => {
    const K = t.xAxis.anchors.length > 0 ? t.xAxis.anchors : [], X = t.yAxis.anchors.length > 0 ? t.yAxis.anchors : [];
    n({
      ...t,
      xAxis: {
        ...t.xAxis,
        anchors: X
      },
      yAxis: {
        ...t.yAxis,
        anchors: K
      }
    });
  }, [t.orientation]), he.useEffect(() => {
    t.visualizationType === "Paired Bar" && n({
      ...t,
      orientation: "horizontal"
    });
  }, []), he.useEffect(() => {
    t.orientation === "horizontal" && n({
      ...t,
      lollipopShape: t.lollipopShape
    });
  }, [t.isLollipopChart, t.lollipopShape]), he.useEffect(() => {
    t.visualizationType === "Deviation Bar" && n({ ...t, orientation: "horizontal" });
  }, [t.visualizationType]);
  const Ze = he.useCallback(() => {
    const K = [...t.exclusions.keys];
    return /* @__PURE__ */ a("ul", { className: "series-list", children: K.map((X, le) => /* @__PURE__ */ O("li", { children: [
      /* @__PURE__ */ a("div", { className: "series-list__name", "data-title": X, children: /* @__PURE__ */ a("div", { className: "series-list__name--text", children: X }) }),
      /* @__PURE__ */ a("button", { className: "series-list__remove", onClick: () => fn(X), children: "×" })
    ] }, X)) });
  }, [t]), mt = (K, X) => {
    let le = t.series, [be] = le.splice(K, 1);
    le.splice(X, 0, be), n({ ...t, series: le });
  };
  t.isLollipopChart && ((Ot = t == null ? void 0 : t.series) == null ? void 0 : Ot.length) > 1 && (t.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), t.visualizationType === "Paired Bar" && ((pn = t == null ? void 0 : t.series) == null ? void 0 : pn.length) !== 2 && (t.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), t.visualizationType === "Deviation Bar" && ((an = t == null ? void 0 : t.series) == null ? void 0 : an.length) !== 1 && (t.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), t.isLollipopChart && ((un = t == null ? void 0 : t.series) == null ? void 0 : un.length) === 0 && (t.runtime.editorErrorMessage = "Add a data series");
  const Kt = t.orientation === "horizontal" ? "xAxis" : "yAxis", [Pe, _e] = he.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), xe = () => {
    const K = t[Kt].max, X = t[Kt].rightMax;
    let le = "", be = "";
    if (t.visualizationType !== "Combo")
      switch (!0) {
        case (K && parseFloat(K) < parseFloat(L) && q):
          le = "Max value must be more than " + L;
          break;
        case (K && parseFloat(K) < 0 && !q):
          le = "Value must be more than or equal to 0";
          break;
        default:
          le = "";
      }
    if (t.visualizationType === "Combo")
      switch (!0) {
        case (K && parseFloat(K) < Y):
          le = "Max value must be more than " + Y;
          break;
        case (X && parseFloat(X) < Q):
          be = "Max value must be more than " + Q;
          break;
        case (K && parseFloat(K) < 0 && !q):
          le = "Value must be more than or equal to 0";
          break;
        default:
          le = "";
      }
    _e((Ue) => ({ ...Ue, maxMsg: le, rightMaxMessage: be }));
  }, ut = () => {
    const K = parseFloat(t[Kt].min);
    let X = Number(D), le = "";
    switch (!0) {
      case (t.useLogScale && ["Line", "Combo", "Bar"].includes(t.visualizationType) && K < 0):
        le = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((t.visualizationType === "Line" || t.visualizationType === "Spark Line") && K > X):
        le = "Value should not exceed " + D;
        break;
      case (t.visualizationType === "Combo" && V && K > X):
        le = "Value should not exceed " + D;
        break;
      case ((t.visualizationType === "Bar" || t.visualizationType === "Combo" && !V) && X > 0 && K > 0):
        le = t.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (t.visualizationType === "Deviation Bar" && K >= Math.min(X, t.xAxis.target)):
        le = "Value must be less than " + Math.min(X, t.xAxis.target);
        break;
      case (t.visualizationType !== "Deviation Bar" && K && X < 0 && K > X):
        le = "Value should not exceed " + D;
        break;
      default:
        le = "";
    }
    _e((be) => ({ ...be, minMsg: le }));
  };
  he.useEffect(() => {
    ut(), xe();
  }, [D, L, t]);
  const et = ((ar = t == null ? void 0 : t.dataKey) == null ? void 0 : ar.includes("http://")) || ((Rn = t == null ? void 0 : t.dataKey) == null ? void 0 : Rn.includes("https://")), rt = () => {
    var K, X;
    if (k !== void 0 && k && !((K = t == null ? void 0 : t.xAxis) != null && K.dataKey)) {
      let le = Nt(!1);
      if (le.includes("Date"))
        return "Date";
      if (le.includes("Race"))
        return "Race";
      if (le.includes("Month"))
        return "Month";
    }
    return ((X = t == null ? void 0 : t.xAxis) == null ? void 0 : X.dataKey) || "";
  }, At = () => {
    if (k !== void 0 && k && Nt(!1).length > 0) {
      let K = Nt(!1).filter((X) => X !== rt());
      if (K.length > 0)
        return K[0];
    }
    return "";
  };
  if (k && !t.xAxis.dataKey && (t.xAxis.dataKey = rt()), k && ((wn = t == null ? void 0 : t.series) == null ? void 0 : wn.length) === 0) {
    let K = At();
    K !== "" && _n(K), k && console.log("### COVE DEBUG: Chart: Setting default datacol=", K);
  }
  const Xt = [
    "Bump Chart",
    "Area Chart",
    "Combo",
    "Line",
    "Bar",
    "Forecasting",
    "Scatter Plot",
    "Paired Bar",
    "Deviation Bar"
  ], tt = [
    /* @__PURE__ */ a("option", { value: "", children: "- Select Option -" }, "Select Option")
  ];
  if (t.data && t.series) {
    Object.keys(((mn = t.data) == null ? void 0 : mn[0]) || []).map((X) => {
      const le = t == null ? void 0 : t.series.some((be) => be.dataKey === X);
      if (X !== t.xAxis.dataKey && !le)
        return tt.push(
          /* @__PURE__ */ a("option", { value: X, children: X }, X)
        );
    });
    let K = {};
    t.data.forEach((X) => {
      Object.keys(X).forEach((le) => {
        K[le] = K[le] || [];
        const be = typeof X[le] == "number" ? X[le].toString() : X[le];
        K[le].indexOf(be) === -1 && K[le].push(be);
      });
    });
  }
  if (!t.data && i) {
    if (!i[0])
      return;
    Object.keys(i[0]).map((X) => {
      const le = i.some((be) => be.dataKey === X);
      if (X !== t.xAxis.dataKey && !le)
        return tt.push(
          /* @__PURE__ */ a("option", { value: X, children: X }, X)
        );
    });
    let K = {};
    i.forEach((X) => {
      Object.keys(X).forEach((le) => {
        K[le] = K[le] || [];
        const be = typeof X[le] == "number" ? X[le].toString() : X[le];
        K[le].indexOf(be) === -1 && K[le].push(be);
      });
    });
  }
  const _t = (K) => {
    const X = Ke.cloneDeep(t.columns);
    delete X[K], n({
      ...t,
      columns: X
    });
  }, yn = async (K, X, le) => {
    switch (X) {
      case "name":
        n({
          ...t,
          columns: {
            ...t.columns,
            [K]: {
              ...t.columns[K],
              [X]: le
            }
          }
        });
        break;
      default:
        n({
          ...t,
          columns: {
            ...t.columns,
            [K]: {
              ...t.columns[K],
              [X]: le
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: vt,
    highlightedSeriesValues: St,
    handleUpdateHighlightedBar: gn,
    handleAddNewHighlightedBar: xn,
    handleRemoveHighlightedBar: On,
    handleUpdateHighlightedBarColor: Fn,
    handleHighlightedBarLegendLabel: Pn,
    handleUpdateHighlightedBorderWidth: ir
  } = Xc(t, n), Nn = t.visualizationType === "Bar" && t.visualizationSubType === "regular" && t.runtime.seriesKeys.length === 1, Sn = () => {
    const K = i.map((X) => X[t.legend.colorCode]);
    return Nn ? K : Nt(!1).filter((X) => X !== t.xAxis.dataKey);
  }, Dt = (K) => {
    n({ ...t, legend: { ...t.legend, seriesHighlight: K } });
  }, nn = (K, X, le) => {
    var Ft;
    const be = { ...t[K], [X]: le }, Ue = { ...t, [K]: be };
    le === "highlight" && ((Ft = t.legend.seriesHighlight) != null && Ft.length) && (Ue.legend.seriesHighlight.length = 0), n(Ue);
  }, dn = (K, X, le) => {
    const be = { ...t.xAxis[K] };
    be[X] = le;
    const Ue = { ...t, xAxis: { ...t.xAxis, [K]: be } };
    n(Ue);
  }, Hn = ![void 0, "- Select - "].includes((Wn = (Mn = t.series) == null ? void 0 : Mn[0]) == null ? void 0 : Wn.dynamicCategory), Jt = ((gr = t.series) == null ? void 0 : gr.length) > 1, qt = {
    addNewExclusion: Gt,
    data: i,
    editColumn: yn,
    getColumns: Nt,
    getDataValueOptions: tn,
    getDataValues: zt,
    getItemStyle: at,
    handleSeriesChange: mt,
    handleAddNewHighlightedBar: xn,
    setCategoryAxis: rt,
    updateField: Ne,
    warningMsg: Pe,
    highlightedBarValues: vt,
    handleHighlightedBarLegendLabel: Pn,
    handleUpdateHighlightedBar: gn,
    handleRemoveHighlightedBar: On,
    isPaletteReversed: t.isPaletteReversed,
    highlightedSeriesValues: St,
    handleUpdateHighlightedBorderWidth: ir,
    handleUpdateHighlightedBarColor: Fn,
    setLollipopShape: Qt
  };
  return /* @__PURE__ */ a(zf.Provider, { value: qt, children: /* @__PURE__ */ a(qr, { component: "EditorPanel", children: /* @__PURE__ */ O(
    yh.Sidebar,
    {
      displayPanel: Ct,
      isDashboard: g,
      title: "Configure Chart",
      onBackClick: It,
      children: [
        /* @__PURE__ */ O(za, { allowZeroExpanded: !0, children: [
          /* @__PURE__ */ a(wi.General, { name: "General" }),
          /* @__PURE__ */ a(wi.ForestPlot, { name: "Forest Plot Settings" }),
          /* @__PURE__ */ a(wi.Sankey, { name: "Sankey" }),
          t.visualizationType !== "Pie" && t.visualizationType !== "Forest Plot" && t.visualizationType !== "Sankey" && /* @__PURE__ */ O(Tn, { children: [
            /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ O(An, { children: [
              "Data Series",
              " ",
              (!t.series || t.series.length === 0 || t.visualizationType === "Paired Bar" && t.series.length < 2) && !t.dynamicSeries && /* @__PURE__ */ a(rc, { width: "25", className: "warning-icon" })
            ] }) }),
            /* @__PURE__ */ O(Ln, { children: [
              t.dynamicSeries && t.visualizationType === "Line" && /* @__PURE__ */ a(
                ht,
                {
                  fieldName: "dynamicSeriesType",
                  value: t.dynamicSeriesType,
                  label: "Series Type",
                  initial: "Select",
                  updateField: Ne,
                  options: ["Line", "dashed-sm", "dashed-md", "dashed-lg"]
                }
              ),
              t.dynamicSeries && t.visualizationType === "Line" && t.dynamicSeriesType === "Line" && /* @__PURE__ */ a(
                ht,
                {
                  fieldName: "dynamicSeriesLineType",
                  value: t.dynamicSeriesLineType ? t.dynamicSeriesLineType : "curveLinear",
                  label: "Line Type",
                  initial: "Select",
                  updateField: Ne,
                  options: Object.keys(as).map((K) => as[K])
                }
              ),
              (!Le() || !t.dynamicSeries) && /* @__PURE__ */ O(ze, { children: [
                (!t.series || t.series.length === 0) && !t.dynamicSeries && t.visualizationType !== "Paired Bar" && /* @__PURE__ */ a("p", { className: "warning", children: "At least one series is required" }),
                (!t.series || t.series.length === 0 || t.series.length < 2) && t.visualizationType === "Paired Bar" && /* @__PURE__ */ a("p", { className: "warning", children: "Select two data series for paired bar chart (e.g., Male and Female)." }),
                /* @__PURE__ */ O(ze, { children: [
                  /* @__PURE__ */ a(
                    ht,
                    {
                      fieldName: "visualizationType",
                      label: "Add Data Series",
                      initial: "Select",
                      onChange: (K) => {
                        K.target.value !== "" && K.target.value !== "Select" && _n(K.target.value), K.target.value = "";
                      },
                      options: Nt()
                    }
                  ),
                  t.series && t.series.length !== 0 && /* @__PURE__ */ O(wi.Series.Wrapper, { getColumns: Nt, children: [
                    /* @__PURE__ */ O("fieldset", { children: [
                      /* @__PURE__ */ a("legend", { className: "edit-label float-left", children: "Displaying" }),
                      /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "A data series is a set of related data points plotted in a chart and typically represented in the chart legend." }) })
                      ] })
                    ] }),
                    /* @__PURE__ */ a(
                      Xg,
                      {
                        onDragEnd: ({ source: K, destination: X }) => mt(K.index, X.index),
                        children: /* @__PURE__ */ a(qg, { droppableId: "filter_order", children: (K) => /* @__PURE__ */ O("ul", { ...K.droppableProps, className: "series-list", ref: K.innerRef, children: [
                          /* @__PURE__ */ a(
                            wi.Series.List,
                            {
                              series: t.series,
                              getItemStyle: at,
                              sortableItemStyles: ct,
                              chartsWithOptions: Xt
                            }
                          ),
                          K.placeholder
                        ] }) })
                      }
                    )
                  ] })
                ] }),
                (t.series && t.series.length && t.visualizationType === "Bar" || t.series && t.series.length <= 1 && t.visualizationType === "Line") && /* @__PURE__ */ O(ze, { children: [
                  /* @__PURE__ */ a("span", { className: "divider-heading", children: "Confidence Keys" }),
                  /* @__PURE__ */ a(
                    ht,
                    {
                      value: t.confidenceKeys.upper || "",
                      section: "confidenceKeys",
                      fieldName: "upper",
                      label: "Upper",
                      updateField: Ne,
                      initial: "Select",
                      options: Nt()
                    }
                  ),
                  /* @__PURE__ */ a(
                    ht,
                    {
                      value: t.confidenceKeys.lower || "",
                      section: "confidenceKeys",
                      fieldName: "lower",
                      label: "Lower",
                      updateField: Ne,
                      initial: "Select",
                      options: Nt()
                    }
                  )
                ] }),
                ot() && t.series && t.series.length === 1 && /* @__PURE__ */ a(
                  ht,
                  {
                    value: t.rankByValue,
                    fieldName: "rankByValue",
                    label: "Rank by Value",
                    initial: "Select",
                    updateField: (K, X, le, be) => {
                      const [Ue, Ft] = PT(t, be, i);
                      n(Ue, Ft);
                    },
                    options: ["asc", "desc"]
                  }
                ),
                Be() && /* @__PURE__ */ a(NT, { config: t, updateConfig: n, data: i })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ a(wi.BoxPlot, { name: "Measures" }),
          Xe() && /* @__PURE__ */ O(Tn, { children: [
            /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ O(An, { children: [
              t.visualizationType === "Pie" ? "Data Format" : t.orientation === "vertical" ? "Left Value Axis" : "Value Axis",
              t.visualizationType === "Pie" && !t.yAxis.dataKey && /* @__PURE__ */ a(rc, { width: "25", className: "warning-icon" })
            ] }) }),
            /* @__PURE__ */ O(Ln, { children: [
              t.visualizationType === "Pie" && /* @__PURE__ */ a(
                ht,
                {
                  value: t.yAxis.dataKey || "",
                  section: "yAxis",
                  fieldName: "dataKey",
                  label: "Data Column",
                  initial: "Select",
                  required: !0,
                  updateField: Ne,
                  options: Nt(!1),
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Select the source data to be visually represented." }) })
                  ] })
                }
              ),
              t.visualizationType !== "Pie" && /* @__PURE__ */ O(ze, { children: [
                /* @__PURE__ */ O("label", { children: [
                  /* @__PURE__ */ O("span", { className: "edit-label", children: [
                    "Axis Type",
                    /* @__PURE__ */ O(ee, { style: { textTransform: "none", display: "inline-block" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(ee.Content, { children: "Select 'Numeric (Linear Scale)' for uniform scaling, 'Numeric (Logarithmic Scale)' for exponential data, or 'Categorical' for discrete categories." })
                    ] })
                  ] }),
                  /* @__PURE__ */ O(
                    "select",
                    {
                      value: t.yAxis.type,
                      onChange: (K) => n({
                        ...t,
                        yAxis: {
                          ...t.yAxis,
                          type: K.target.value
                        }
                      }),
                      children: [
                        /* @__PURE__ */ a("option", { value: "linear", children: "Numeric (Linear Scale)" }),
                        t.visualizationSubType !== "stacked" && /* @__PURE__ */ a("option", { value: "logarithmic", children: "Numeric (Logarithmic Scale)" }),
                        t.orientation !== "horizontal" && /* @__PURE__ */ a("option", { value: "categorical", children: "Categorical" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ a(
                  RT,
                  {
                    config: t,
                    updateConfig: n,
                    data: i,
                    display: M()
                  }
                ),
                /* @__PURE__ */ a(
                  $e,
                  {
                    display: !M(),
                    value: t.yAxis.label,
                    section: "yAxis",
                    fieldName: "label",
                    label: "Label",
                    updateField: Ne,
                    maxLength: 35,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "35 character limit" }) })
                    ] })
                  }
                ),
                t.runtime.seriesKeys && t.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(t.visualizationType) && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: t.isLegendValue,
                    fieldName: "isLegendValue",
                    label: "Use Legend Value in Hover",
                    updateField: Ne
                  }
                ),
                /* @__PURE__ */ a(
                  $e,
                  {
                    display: !M(),
                    value: t.yAxis.numTicks,
                    placeholder: "Auto",
                    type: "number",
                    section: "yAxis",
                    fieldName: "numTicks",
                    label: "Number of ticks",
                    className: "number-narrow",
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used." }) })
                    ] }),
                    updateField: Ne
                  }
                ),
                /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.yAxis.size,
                    type: "number",
                    section: "yAxis",
                    fieldName: "size",
                    label: t.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
                    className: "number-narrow",
                    updateField: Ne,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: `Increase the size if elements in the ${t.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.` }) })
                    ] })
                  }
                ),
                /* @__PURE__ */ a(
                  $e,
                  {
                    display: !M(),
                    value: t.yAxis.labelOffset,
                    section: "yAxis",
                    fieldName: "labelOffset",
                    label: "Label offset",
                    type: "number",
                    className: "number-narrow",
                    updateField: Ne
                  }
                ),
                t.orientation === "horizontal" && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: t.isResponsiveTicks,
                    fieldName: "isResponsiveTicks",
                    label: "Use Responsive Ticks",
                    updateField: Ne
                  }
                ),
                (t.orientation === "vertical" || !t.isResponsiveTicks) && /* @__PURE__ */ a(
                  $e,
                  {
                    display: !M(),
                    value: t.yAxis.tickRotation || 0,
                    type: "number",
                    min: 0,
                    section: "yAxis",
                    fieldName: "tickRotation",
                    label: "Tick rotation (Degrees)",
                    className: "number-narrow",
                    updateField: Ne
                  }
                ),
                t.isResponsiveTicks && t.orientation === "horizontal" && /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.xAxis.maxTickRotation,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "maxTickRotation",
                    label: "Max Tick Rotation",
                    className: "number-narrow",
                    updateField: Ne,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Degrees ticks will be rotated if values overlap, especially in smaller viewports." }) })
                    ] })
                  }
                ),
                st() && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: t.yAxis.gridLines,
                    section: "yAxis",
                    fieldName: "gridLines",
                    label: "Show Gridlines",
                    updateField: Ne
                  }
                ),
                st() && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: t.yAxis.labelsAboveGridlines,
                    section: "yAxis",
                    fieldName: "labelsAboveGridlines",
                    label: "Tick labels above gridlines",
                    updateField: Ne,
                    disabled: !t.yAxis.gridLines,
                    title: t.yAxis.gridLines ? "" : "Show gridlines to enable"
                  }
                ),
                lt() && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: t.yAxis.enablePadding,
                    section: "yAxis",
                    fieldName: "enablePadding",
                    label: "Add Padding to Value Axis Scale",
                    updateField: Ne
                  }
                ),
                t.yAxis.enablePadding && lt() && /* @__PURE__ */ a(
                  $e,
                  {
                    type: "number",
                    section: "yAxis",
                    fieldName: "scalePadding",
                    label: "Padding Percentage",
                    className: "number-narrow",
                    updateField: Ne,
                    value: t.yAxis.scalePadding
                  }
                )
              ] }),
              /* @__PURE__ */ a("span", { className: "divider-heading", children: "Number Formatting" }),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: t.dataFormat.commas,
                  section: "dataFormat",
                  fieldName: "commas",
                  label: "Add commas",
                  updateField: Ne,
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting this option will add commas to the left value axis, tooltip hover, and data table." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  display: !M(),
                  value: t.dataFormat.abbreviated,
                  section: "dataFormat",
                  fieldName: "abbreviated",
                  label: "Abbreviate Axis Values",
                  updateField: Ne,
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "This option abbreviates very large or very small numbers on the value axis" }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                $e,
                {
                  value: t.dataFormat.roundTo ? t.dataFormat.roundTo : 0,
                  type: "number",
                  section: "dataFormat",
                  fieldName: "roundTo",
                  label: "Round to decimal point",
                  className: "number-narrow",
                  updateField: Ne,
                  min: 0
                }
              ),
              " ",
              /* @__PURE__ */ O("div", { className: "two-col-inputs", children: [
                /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.dataFormat.prefix,
                    section: "dataFormat",
                    fieldName: "prefix",
                    label: "Prefix",
                    updateField: Ne,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ O(ee.Content, { children: [
                        t.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data prefix to display in the data table and chart tooltips, if applicable." }),
                        t.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data prefix (such as "$"), if applicable.' })
                      ] })
                    ] })
                  }
                ),
                /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.dataFormat.suffix,
                    section: "dataFormat",
                    fieldName: "suffix",
                    label: "Suffix",
                    updateField: Ne,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ O(ee.Content, { children: [
                        t.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data suffix to display in the data table and tooltips, if applicable." }),
                        t.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data suffix (such as "%"), if applicable.' })
                      ] })
                    ] })
                  }
                )
              ] }),
              t.orientation === "horizontal" ? (
                // horizontal - x is vertical y is horizontal
                /* @__PURE__ */ O(ze, { children: [
                  Ye() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.xAxis.hideAxis,
                      section: "xAxis",
                      fieldName: "hideAxis",
                      label: "Hide Axis",
                      updateField: Ne
                    }
                  ),
                  dt() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.xAxis.hideLabel,
                      section: "xAxis",
                      fieldName: "hideLabel",
                      label: "Hide Tick Labels",
                      updateField: Ne
                    }
                  ),
                  nt() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.xAxis.hideTicks,
                      section: "xAxis",
                      fieldName: "hideTicks",
                      label: "Hide Ticks",
                      updateField: Ne
                    }
                  ),
                  Je() && /* @__PURE__ */ a(
                    $e,
                    {
                      value: t.xAxis.max,
                      section: "xAxis",
                      fieldName: "max",
                      label: "max value",
                      type: "number",
                      placeholder: "Auto",
                      updateField: Ne
                    }
                  ),
                  /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: Pe.maxMsg }),
                  yt() && /* @__PURE__ */ a(
                    $e,
                    {
                      value: t.xAxis.min,
                      section: "xAxis",
                      fieldName: "min",
                      type: "number",
                      label: "min value",
                      placeholder: "Auto",
                      updateField: Ne
                    }
                  ),
                  /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: Pe.minMsg }),
                  t.visualizationType === "Deviation Bar" && /* @__PURE__ */ O(ze, { children: [
                    /* @__PURE__ */ a(
                      $e,
                      {
                        value: t.xAxis.target,
                        section: "xAxis",
                        fieldName: "target",
                        type: "number",
                        label: "Deviation point",
                        placeholder: "Auto",
                        updateField: Ne
                      }
                    ),
                    /* @__PURE__ */ a(
                      $e,
                      {
                        value: t.xAxis.targetLabel || "Target",
                        section: "xAxis",
                        fieldName: "targetLabel",
                        type: "text",
                        label: "Deviation point Label",
                        updateField: Ne
                      }
                    ),
                    /* @__PURE__ */ a(
                      Ge,
                      {
                        value: t.xAxis.showTargetLabel,
                        section: "xAxis",
                        fieldName: "showTargetLabel",
                        label: "Show Deviation point label",
                        updateField: Ne
                      }
                    )
                  ] })
                ] })
              ) : t.visualizationType !== "Pie" && /* @__PURE__ */ O(ze, { children: [
                /* @__PURE__ */ a(
                  Ge,
                  {
                    display: !M(),
                    value: t.dataFormat.onlyShowTopPrefixSuffix,
                    section: "dataFormat",
                    fieldName: "onlyShowTopPrefixSuffix",
                    label: "Only Show Top Prefix/Suffix",
                    updateField: Ne
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    display: !M(),
                    value: t.yAxis.hideAxis,
                    section: "yAxis",
                    fieldName: "hideAxis",
                    label: "Hide Axis",
                    updateField: Ne
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    display: !M(),
                    value: t.yAxis.hideLabel,
                    section: "yAxis",
                    fieldName: "hideLabel",
                    label: "Hide Tick Labels",
                    updateField: Ne
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    display: !M(),
                    value: t.yAxis.hideTicks,
                    section: "yAxis",
                    fieldName: "hideTicks",
                    label: "Hide Ticks",
                    updateField: Ne
                  }
                ),
                /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.yAxis.max,
                    section: "yAxis",
                    fieldName: "max",
                    type: "number",
                    label: "left axis max value",
                    placeholder: "Auto",
                    updateField: Ne
                  }
                ),
                /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: Pe.maxMsg }),
                t.visualizationType !== "Area Chart" && t.visualizationSubType !== "stacked" && /* @__PURE__ */ O(ze, { children: [
                  /* @__PURE__ */ a(
                    $e,
                    {
                      value: t.yAxis.min,
                      section: "yAxis",
                      fieldName: "min",
                      type: "number",
                      label: "left axis min value",
                      placeholder: "Auto",
                      updateField: Ne
                    }
                  ),
                  /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: Pe.minMsg })
                ] })
              ] }),
              se() && t.orientation !== "horizontal" && /* @__PURE__ */ O("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: (Xn = (vr = t.yAxis) == null ? void 0 : vr.anchors) == null ? void 0 : Xn.map((K, X) => /* @__PURE__ */ O(Tn, { className: "series-item series-item--chart", children: [
                  /* @__PURE__ */ a(Cn, { className: "series-item__title", children: /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O(An, { className: "accordion__button accordion__button", children: [
                    "Anchor ",
                    X + 1,
                    /* @__PURE__ */ a(
                      "button",
                      {
                        className: "series-list__remove",
                        onClick: (le) => {
                          le.preventDefault();
                          const be = [...t.yAxis.anchors];
                          be.splice(X, 1), n({
                            ...t,
                            yAxis: {
                              ...t.yAxis,
                              anchors: be
                            }
                          });
                        },
                        children: "Remove"
                      }
                    )
                  ] }) }) }),
                  /* @__PURE__ */ O(Ln, { children: [
                    /* @__PURE__ */ O("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                      /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                      ] }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: t.yAxis.anchors[X].value ? t.yAxis.anchors[X].value : "",
                          onChange: (le) => {
                            le.preventDefault();
                            const be = [...t.yAxis.anchors];
                            be[X].value = le.target.value, n({
                              ...t,
                              yAxis: {
                                ...t.yAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ O("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: t.yAxis.anchors[X].color ? t.yAxis.anchors[X].color : "",
                          onChange: (le) => {
                            le.preventDefault();
                            const be = [...t.yAxis.anchors];
                            be[X].color = le.target.value, n({
                              ...t,
                              yAxis: {
                                ...t.yAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ O("label", { children: [
                      "Anchor Line Style",
                      /* @__PURE__ */ O(
                        "select",
                        {
                          value: t.yAxis.anchors[X].lineStyle || "",
                          onChange: (le) => {
                            const be = [...t.yAxis.anchors];
                            be[X].lineStyle = le.target.value, n({
                              ...t,
                              yAxis: {
                                ...t.yAxis,
                                anchors: be
                              }
                            });
                          },
                          children: [
                            /* @__PURE__ */ a("option", { children: "Select" }),
                            v.map((le) => /* @__PURE__ */ a("option", { children: le.value }, le.key))
                          ]
                        }
                      )
                    ] })
                  ] })
                ] }, `yaxis-anchors-2-${X}`)) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (K) => {
                      K.preventDefault();
                      const X = [...t.yAxis.anchors];
                      X.push({}), n({
                        ...t,
                        yAxis: {
                          ...t.yAxis,
                          anchors: X
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] }),
              se() && t.orientation === "horizontal" && /* @__PURE__ */ O("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: (or = (Vn = t.xAxis) == null ? void 0 : Vn.anchors) == null ? void 0 : or.map((K, X) => /* @__PURE__ */ O(Tn, { className: "series-item series-item--chart", children: [
                  /* @__PURE__ */ a(Cn, { className: "series-item__title", children: /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O(An, { className: "accordion__button accordion__button", children: [
                    "Anchor ",
                    X + 1,
                    /* @__PURE__ */ a(
                      "button",
                      {
                        className: "series-list__remove",
                        onClick: (le) => {
                          le.preventDefault();
                          const be = [...t.xAxis.anchors];
                          be.splice(X, 1), n({
                            ...t,
                            xAxis: {
                              ...t.xAxis,
                              anchors: be
                            }
                          });
                        },
                        children: "Remove"
                      }
                    )
                  ] }) }) }),
                  /* @__PURE__ */ O(Ln, { children: [
                    /* @__PURE__ */ O("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                      /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                      ] }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: t.xAxis.anchors[X].value ? t.xAxis.anchors[X].value : "",
                          onChange: (le) => {
                            le.preventDefault();
                            const be = [...t.xAxis.anchors];
                            be[X].value = le.target.value, n({
                              ...t,
                              xAxis: {
                                ...t.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ O("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: t.xAxis.anchors[X].color ? t.xAxis.anchors[X].color : "",
                          onChange: (le) => {
                            le.preventDefault();
                            const be = [...t.xAxis.anchors];
                            be[X].color = le.target.value, n({
                              ...t,
                              xAxis: {
                                ...t.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ O("label", { children: [
                      "Anchor Line Style",
                      /* @__PURE__ */ O(
                        "select",
                        {
                          value: t.xAxis.anchors[X].lineStyle || "",
                          onChange: (le) => {
                            const be = [...t.xAxis.anchors];
                            be[X].lineStyle = le.target.value, n({
                              ...t,
                              xAxis: {
                                ...t.xAxis,
                                anchors: be
                              }
                            });
                          },
                          children: [
                            /* @__PURE__ */ a("option", { children: "Select" }),
                            v.map((le) => /* @__PURE__ */ a("option", { children: le.value }, le.key))
                          ]
                        }
                      )
                    ] })
                  ] })
                ] }, `xaxis-anchors-${X}`)) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (K) => {
                      K.preventDefault();
                      const X = [...t.xAxis.anchors];
                      X.push({}), n({
                        ...t,
                        xAxis: {
                          ...t.xAxis,
                          anchors: X
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] })
            ] })
          ] }),
          je && /* @__PURE__ */ O(Tn, { children: [
            /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: "Right Value Axis" }) }),
            /* @__PURE__ */ O(Ln, { children: [
              /* @__PURE__ */ a(
                $e,
                {
                  value: t.yAxis.rightLabel,
                  section: "yAxis",
                  fieldName: "rightLabel",
                  label: "Label",
                  updateField: Ne,
                  maxLength: 35,
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "35 character limit" }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                $e,
                {
                  value: t.yAxis.rightNumTicks,
                  placeholder: "Auto",
                  type: "number",
                  section: "yAxis",
                  fieldName: "rightNumTicks",
                  label: "Number of ticks",
                  className: "number-narrow",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                $e,
                {
                  value: t.yAxis.rightAxisSize,
                  type: "number",
                  section: "yAxis",
                  fieldName: "rightAxisSize",
                  label: "Size (Width)",
                  className: "number-narrow",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                $e,
                {
                  value: t.yAxis.rightLabelOffsetSize,
                  type: "number",
                  section: "yAxis",
                  fieldName: "rightLabelOffsetSize",
                  label: "Label Offset",
                  className: "number-narrow",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a("span", { className: "divider-heading", children: "Number Formatting" }),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: t.dataFormat.rightCommas,
                  section: "dataFormat",
                  fieldName: "rightCommas",
                  label: "Add commas",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                $e,
                {
                  value: t.dataFormat.rightRoundTo,
                  type: "number",
                  section: "dataFormat",
                  fieldName: "rightRoundTo",
                  label: "Round to decimal point",
                  className: "number-narrow",
                  updateField: Ne,
                  min: 0
                }
              ),
              /* @__PURE__ */ O("div", { className: "two-col-inputs", children: [
                /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.dataFormat.rightPrefix,
                    section: "dataFormat",
                    fieldName: "rightPrefix",
                    label: "Prefix",
                    updateField: Ne,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ O(ee.Content, { children: [
                        t.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data prefix to display in the data table and chart tooltips, if applicable." }),
                        t.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data prefix (such as "$"), if applicable.' })
                      ] })
                    ] })
                  }
                ),
                /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.dataFormat.rightSuffix,
                    section: "dataFormat",
                    fieldName: "rightSuffix",
                    label: "Suffix",
                    updateField: Ne,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ O(ee.Content, { children: [
                        t.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data suffix to display in the data table and tooltips, if applicable." }),
                        t.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data suffix (such as "%"), if applicable.' })
                      ] })
                    ] })
                  }
                )
              ] }),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: t.yAxis.rightHideAxis,
                  section: "yAxis",
                  fieldName: "rightHideAxis",
                  label: "Hide Axis",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: t.yAxis.rightHideLabel,
                  section: "yAxis",
                  fieldName: "rightHideLabel",
                  label: "Hide Tick Labels",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: t.yAxis.rightHideTicks,
                  section: "yAxis",
                  fieldName: "rightHideTicks",
                  label: "Hide Ticks",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                $e,
                {
                  value: t.yAxis.max,
                  section: "yAxis",
                  fieldName: "rightMax",
                  type: "number",
                  label: "right axis max value",
                  placeholder: "Auto",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: Pe.rightMaxMessage }),
              /* @__PURE__ */ a(
                $e,
                {
                  value: t.yAxis.min,
                  section: "yAxis",
                  fieldName: "rightMin",
                  type: "number",
                  label: "right axis min value",
                  placeholder: "Auto",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: Pe.minMsg })
            ] })
          ] }),
          Z() && /* @__PURE__ */ O(Tn, { children: [
            /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ O(An, { children: [
              t.visualizationType === "Pie" ? "Segments" : "Date/Category Axis",
              !t.xAxis.dataKey && /* @__PURE__ */ a(rc, { width: "25", className: "warning-icon" })
            ] }) }),
            /* @__PURE__ */ O(Ln, { children: [
              t.visualizationType !== "Pie" && /* @__PURE__ */ O(ze, { children: [
                t.visualizationType !== "Forest Plot" && /* @__PURE__ */ O(ze, { children: [
                  /* @__PURE__ */ O("label", { children: [
                    /* @__PURE__ */ O("span", { className: "edit-label", children: [
                      "Data Scaling Type",
                      /* @__PURE__ */ O(ee, { style: { textTransform: "none", display: "inline-block" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: "Linear scales are employed for quantitative data, while time scales are used for time-series data." })
                      ] })
                    ] }),
                    /* @__PURE__ */ O(
                      "select",
                      {
                        value: t.xAxis.type,
                        onChange: (K) => n({
                          ...t,
                          xAxis: {
                            ...t.xAxis,
                            type: K.target.value
                          }
                        }),
                        children: [
                          t.visualizationType !== "Bump Chart" && /* @__PURE__ */ a("option", { value: "categorical", children: "Categorical (Linear Scale)" }),
                          t.visualizationType !== "Bump Chart" && /* @__PURE__ */ a("option", { value: "date", children: "Date (Linear Scale)" }),
                          /* @__PURE__ */ a("option", { value: "date-time", children: "Date (Date Time Scale)" }),
                          t.visualizationType === "Scatter Plot" && /* @__PURE__ */ a("option", { value: "continuous", children: "Continuous" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.xAxis.manual,
                      section: "xAxis",
                      fieldName: "manual",
                      label: "Manual Ticks",
                      updateField: Ne
                    }
                  ),
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      display: t.xAxis.type !== "categorical",
                      value: t.xAxis.sortByRecentDate,
                      section: "xAxis",
                      fieldName: "sortByRecentDate",
                      label: "Show dates newest to oldest",
                      updateField: Ne
                    }
                  ),
                  ye() && /* @__PURE__ */ a(
                    $e,
                    {
                      value: t.xAxis.padding,
                      type: "number",
                      min: 0,
                      section: "xAxis",
                      fieldName: "padding",
                      label: "Padding (Percent)",
                      className: "number-narrow",
                      updateField: Ne,
                      tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified." }) })
                      ] })
                    }
                  )
                ] }),
                /* @__PURE__ */ a(
                  ht,
                  {
                    value: t.xAxis.dataKey || rt() || "",
                    section: "xAxis",
                    fieldName: "dataKey",
                    label: "Data Key",
                    initial: "Select",
                    required: !0,
                    updateField: Ne,
                    options: Nt(!1),
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Select the column or row containing the categories or dates for this axis. " }) })
                    ] })
                  }
                )
              ] }),
              t.visualizationType === "Pie" && /* @__PURE__ */ a(
                ht,
                {
                  value: t.xAxis.dataKey || "",
                  section: "xAxis",
                  fieldName: "dataKey",
                  label: "Segment Labels",
                  initial: "Select",
                  required: !0,
                  updateField: Ne,
                  options: Nt(!1),
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."' }) })
                  ] })
                }
              ),
              t.visualizationType !== "Pie" && /* @__PURE__ */ O(ze, { children: [
                /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.xAxis.label,
                    section: "xAxis",
                    fieldName: "label",
                    label: "Label",
                    updateField: Ne,
                    maxLength: 35,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "35 character limit" }) })
                    ] })
                  }
                ),
                t.xAxis.type === "continuous" && /* @__PURE__ */ O(ze, { children: [
                  /* @__PURE__ */ a(
                    $e,
                    {
                      value: t.dataFormat.bottomPrefix,
                      section: "dataFormat",
                      fieldName: "bottomPrefix",
                      label: "Prefix",
                      updateField: Ne,
                      tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Enter a data prefix (such as "$"), if applicable.' }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ a(
                    $e,
                    {
                      value: t.dataFormat.bottomSuffix,
                      section: "dataFormat",
                      fieldName: "bottomSuffix",
                      label: "Suffix",
                      updateField: Ne,
                      tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Enter a data suffix (such as "%"), if applicable.' }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.dataFormat.bottomAbbreviated,
                      section: "dataFormat",
                      fieldName: "bottomAbbreviated",
                      label: "Abbreviate Axis Values",
                      updateField: Ne,
                      tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "This option abbreviates very large or very small numbers on the value axis" }) })
                      ] })
                    }
                  )
                ] }),
                (En(t.xAxis) || (t == null ? void 0 : t.visualizationType) === "Bump Chart") && /* @__PURE__ */ O(ze, { children: [
                  /* @__PURE__ */ O("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" }, children: [
                    "Format how charts should parse and display your dates using",
                    " ",
                    /* @__PURE__ */ a("a", { href: "https://d3js.org/d3-time-format#locale_format", target: "_blank", rel: "noreferrer", children: "these guidelines" }),
                    "."
                  ] }),
                  /* @__PURE__ */ a(
                    $e,
                    {
                      tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ O("p", { children: [
                          "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed.",
                          " "
                        ] }) })
                      ] }),
                      value: t.xAxis.dateParseFormat,
                      section: "xAxis",
                      fieldName: "dateParseFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "Date Parse Format",
                      updateField: Ne
                    }
                  ),
                  /* @__PURE__ */ a(
                    $e,
                    {
                      tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ O("p", { children: [
                          " ",
                          "Adjusts the date display format on the axis for clear, visual date representation."
                        ] }) })
                      ] }),
                      value: t.xAxis.dateDisplayFormat,
                      section: "xAxis",
                      fieldName: "dateDisplayFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "AXIS DATE DISPLAY FORMAT",
                      updateField: Ne
                    }
                  ),
                  /* @__PURE__ */ a(
                    $e,
                    {
                      tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ O("p", { children: [
                          "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format.",
                          " "
                        ] }) })
                      ] }),
                      value: t.table.dateDisplayFormat,
                      section: "table",
                      fieldName: "dateDisplayFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "DATA TABLE DATE DISPLAY FORMAT",
                      updateField: Ne
                    }
                  ),
                  /* @__PURE__ */ a(
                    $e,
                    {
                      tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ O("p", { children: [
                          "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format.",
                          " "
                        ] }) })
                      ] }),
                      value: t.tooltips.dateDisplayFormat,
                      section: "tooltips",
                      fieldName: "dateDisplayFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "HOVER DATE DISPLAY FORMAT",
                      updateField: Ne
                    }
                  )
                ] }),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    value: t.exclusions.active,
                    section: "exclusions",
                    fieldName: "active",
                    label: t.xAxis.type === "date" || t.xAxis.type === "date-time" ? "Limit by start and/or end dates" : "Exclude one or more values",
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ O("p", { children: [
                        "When this option is checked, you can select source-file values for exclusion from the date/category axis.",
                        " "
                      ] }) })
                    ] }),
                    updateField: Ne
                  }
                ),
                /* @__PURE__ */ a(
                  Ge,
                  {
                    value: t.xAxis.showYearsOnce,
                    section: "xAxis",
                    fieldName: "showYearsOnce",
                    label: "Show years once",
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "When this option is checked and the date format for the axis includes years, each year will only be shown once in the axis." }) })
                    ] }),
                    updateField: Ne
                  }
                ),
                ie() && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: (qn = t.brush) == null ? void 0 : qn.active,
                    section: "brush",
                    fieldName: "active",
                    label: "Brush Slider ",
                    updateField: Ne,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ O("p", { children: [
                        "Use the brush slider to narrow down your data view to specific values along the axis. This tool is useful for examining detailed data segments within the larger dataset.",
                        " "
                      ] }) })
                    ] })
                  }
                ),
                t.exclusions.active && /* @__PURE__ */ O(ze, { children: [
                  t.xAxis.type === "categorical" && /* @__PURE__ */ O(ze, { children: [
                    t.exclusions.keys.length > 0 && /* @__PURE__ */ O(ze, { children: [
                      /* @__PURE__ */ a("fieldset", { children: /* @__PURE__ */ a("legend", { className: "edit-label", children: "Excluded Keys" }) }),
                      /* @__PURE__ */ a(Ze, {})
                    ] }),
                    /* @__PURE__ */ a(
                      ht,
                      {
                        fieldName: "visualizationType",
                        label: "Add Exclusion",
                        initial: "Select",
                        onChange: (K) => {
                          K.target.value !== "" && K.target.value !== "Select" && Gt(K.target.value), K.target.value = "";
                        },
                        options: zt(t.xAxis.dataKey, !0)
                      }
                    )
                  ] }),
                  (t.xAxis.type === "date" || t.xAxis.type === "date-time") && /* @__PURE__ */ O(ze, { children: [
                    /* @__PURE__ */ a(
                      $e,
                      {
                        type: "date",
                        section: "exclusions",
                        fieldName: "dateStart",
                        label: "Start Date",
                        updateField: Ne,
                        value: t.exclusions.dateStart || ""
                      }
                    ),
                    /* @__PURE__ */ a(
                      $e,
                      {
                        type: "date",
                        section: "exclusions",
                        fieldName: "dateEnd",
                        label: "End Date",
                        updateField: Ne,
                        value: t.exclusions.dateEnd || ""
                      }
                    )
                  ] })
                ] }),
                ke() && t.xAxis.type !== "date-time" && t.xAxis.manual && /* @__PURE__ */ O(ze, { children: [
                  /* @__PURE__ */ a(
                    $e,
                    {
                      value: t.xAxis.manualStep,
                      placeholder: "Auto",
                      type: "number",
                      min: 1,
                      section: "xAxis",
                      fieldName: "manualStep",
                      label: "Step count",
                      className: "number-narrow",
                      updateField: Ne,
                      tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc." }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ O("div", { className: "viewport-overrides", children: [
                    /* @__PURE__ */ a("label", { children: /* @__PURE__ */ O(
                      "button",
                      {
                        onClick: () => jt(!Zt),
                        className: "edit-label",
                        children: [
                          "Step Count: viewport overrides",
                          " ",
                          /* @__PURE__ */ a("span", { style: { transform: `rotate(${Zt ? "90deg" : "0deg"})` }, children: ">" })
                        ]
                      }
                    ) }),
                    Zt && /* @__PURE__ */ a("div", { className: "edit-block", children: Object.keys(Hf).map((K) => /* @__PURE__ */ a(
                      $e,
                      {
                        value: t.xAxis.viewportStepCount ? t.xAxis.viewportStepCount[K] : void 0,
                        placeholder: "Auto",
                        type: "number",
                        label: K,
                        className: "number-narrow",
                        updateField: (X, le, be, Ue) => dn("viewportStepCount", K, Ue)
                      },
                      `viewport-step-count-input-${K}`
                    )) })
                  ] })
                ] }),
                ke() && (t.xAxis.type === "date-time" || !t.xAxis.manual) && /* @__PURE__ */ O(ze, { children: [
                  /* @__PURE__ */ a(
                    $e,
                    {
                      value: t.xAxis.numTicks,
                      placeholder: "Auto",
                      type: "number",
                      min: 1,
                      section: "xAxis",
                      fieldName: "numTicks",
                      label: "Number of ticks",
                      className: "number-narrow",
                      updateField: Ne,
                      tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.' }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ O("div", { className: "viewport-overrides", children: [
                    /* @__PURE__ */ a("label", { children: /* @__PURE__ */ O(
                      "button",
                      {
                        onClick: () => jt(!Zt),
                        className: "edit-label",
                        children: [
                          "Number of ticks: viewport overrides",
                          " ",
                          /* @__PURE__ */ a("span", { style: { transform: `rotate(${Zt ? "90deg" : "0deg"})` }, children: ">" })
                        ]
                      }
                    ) }),
                    Zt && /* @__PURE__ */ a("div", { className: "edit-block", children: Object.keys(Hf).map((K) => /* @__PURE__ */ a(
                      $e,
                      {
                        value: t.xAxis.viewportNumTicks ? t.xAxis.viewportNumTicks[K] : void 0,
                        placeholder: "Auto",
                        type: "number",
                        label: K,
                        className: "number-narrow",
                        updateField: (X, le, be, Ue) => dn("viewportNumTicks", K, Ue)
                      },
                      `viewport-num-ticks-input-${K}`
                    )) })
                  ] })
                ] }),
                ce() && /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.xAxis.size,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "size",
                    label: t.orientation === "horizontal" ? "Size (Width)" : "Size (Height)",
                    className: "number-narrow",
                    updateField: Ne
                  }
                ),
                t.orientation === "horizontal" && /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.xAxis.labelOffset,
                    section: "xAxis",
                    fieldName: "labelOffset",
                    label: "Label offset",
                    type: "number",
                    className: "number-narrow",
                    updateField: Ne
                  }
                ),
                (t.xAxis.type === "continuous" || t.forestPlot.type === "Logarithmic") && /* @__PURE__ */ O(ze, { children: [
                  /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.dataFormat.bottomCommas,
                      section: "dataFormat",
                      fieldName: "bottomCommas",
                      label: "Add commas",
                      updateField: Ne
                    }
                  ),
                  /* @__PURE__ */ a(
                    $e,
                    {
                      value: t.dataFormat.bottomRoundTo,
                      type: "number",
                      section: "dataFormat",
                      fieldName: "bottomRoundTo",
                      label: "Round to decimal point",
                      className: "number-narrow",
                      updateField: Ne,
                      min: 0
                    }
                  )
                ] }),
                gt() && t.orientation === "vertical" && t.visualizationType !== "Paired Bar" && /* @__PURE__ */ a(
                  Ge,
                  {
                    value: t.isResponsiveTicks,
                    fieldName: "isResponsiveTicks",
                    label: "Use Responsive Ticks",
                    updateField: Ne
                  }
                ),
                (t.orientation === "horizontal" || !t.isResponsiveTicks) && Ie() && /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.xAxis.tickRotation,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "tickRotation",
                    label: "Tick rotation (Degrees)",
                    className: "number-narrow",
                    updateField: Ne
                  }
                ),
                t.orientation === "vertical" && t.isResponsiveTicks && t.visualizationType !== "Paired Bar" && /* @__PURE__ */ a(
                  $e,
                  {
                    value: t.xAxis.maxTickRotation,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "maxTickRotation",
                    label: "Max Tick Rotation",
                    className: "number-narrow",
                    updateField: Ne,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Degrees ticks will be rotated if values overlap, especially in smaller viewports." }) })
                    ] })
                  }
                ),
                t.orientation === "horizontal" ? /* @__PURE__ */ O(ze, { children: [
                  ne() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.yAxis.hideAxis,
                      section: "yAxis",
                      fieldName: "hideAxis",
                      label: "Hide Axis",
                      updateField: Ne
                    }
                  ),
                  ge() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.yAxis.hideLabel,
                      section: "yAxis",
                      fieldName: "hideLabel",
                      label: "Hide Tick Labels",
                      updateField: Ne
                    }
                  )
                ] }) : /* @__PURE__ */ O(ze, { children: [
                  ne() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.xAxis.hideAxis,
                      section: "xAxis",
                      fieldName: "hideAxis",
                      label: "Hide Axis",
                      updateField: Ne
                    }
                  ),
                  ge() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.xAxis.hideLabel,
                      section: "xAxis",
                      fieldName: "hideLabel",
                      label: "Hide Tick Labels",
                      updateField: Ne
                    }
                  ),
                  Se() && /* @__PURE__ */ a(
                    Ge,
                    {
                      value: t.xAxis.hideTicks,
                      section: "xAxis",
                      fieldName: "hideTicks",
                      label: "Hide Ticks",
                      updateField: Ne
                    }
                  )
                ] }),
                ((Zn = t.series) == null ? void 0 : Zn.length) === 1 && t.visualizationType === "Bar" && /* @__PURE__ */ O(ze, { children: [
                  /* @__PURE__ */ a("label", { htmlFor: "barHighlight", children: "Bar Highlighting" }),
                  t.series.length === 1 && vt.map((K, X) => /* @__PURE__ */ a("fieldset", { children: /* @__PURE__ */ O("div", { className: "edit-block", children: [
                    /* @__PURE__ */ a("button", { className: "btn btn-danger", onClick: (le) => On(le, X), children: "Remove" }),
                    /* @__PURE__ */ O("p", { children: [
                      "Highlighted Bar ",
                      X + 1
                    ] }),
                    /* @__PURE__ */ O("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Value" }),
                      /* @__PURE__ */ O(
                        "select",
                        {
                          value: t.highlightedBarValues[X].value,
                          onChange: (le) => gn(le, X),
                          children: [
                            /* @__PURE__ */ a("option", { value: "", children: "- Select Value -" }),
                            St && [...new Set(St)].sort().map((le) => /* @__PURE__ */ a("option", { children: le }, `special-class-value-option-${X}-${le}`))
                          ]
                        }
                      )
                    ] }),
                    /* @__PURE__ */ O("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: t.highlightedBarValues[X].color ? t.highlightedBarValues[X].color : "",
                          onChange: (le) => Fn(le, X)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ O("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Border Width" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          max: "5",
                          min: "0",
                          type: "number",
                          value: t.highlightedBarValues[X].borderWidth ? t.highlightedBarValues[X].borderWidth : "",
                          onChange: (le) => ir(le, X)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ O("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Legend Label" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: t.highlightedBarValues[X].legendLabel ? t.highlightedBarValues[X].legendLabel : "",
                          onChange: (le) => Pn(le, X)
                        }
                      )
                    ] })
                  ] }, `highlighted-bar-${X}`) })),
                  /* @__PURE__ */ a("button", { className: "btn btn-primary full-width", onClick: (K) => xn(K), children: "Add Highlighted Bar" })
                ] })
              ] }),
              t.visualizationType === "Pie" && /* @__PURE__ */ O(ze, { children: [
                /* @__PURE__ */ a(
                  Ge,
                  {
                    value: t.exclusions.active,
                    section: "exclusions",
                    fieldName: "active",
                    label: "Exclude one or more values",
                    updateField: Ne,
                    tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "When this option is checked, you can select values for exclusion from the pie segments." }) })
                    ] })
                  }
                ),
                t.exclusions.active && /* @__PURE__ */ O(ze, { children: [
                  t.exclusions.keys.length > 0 && /* @__PURE__ */ O(ze, { children: [
                    /* @__PURE__ */ a("fieldset", { children: /* @__PURE__ */ a("legend", { className: "edit-label", children: "Excluded Keys" }) }),
                    /* @__PURE__ */ a(Ze, {})
                  ] }),
                  /* @__PURE__ */ a(
                    ht,
                    {
                      fieldName: "visualizationType",
                      label: "Add Exclusion",
                      initial: "Select",
                      onChange: (K) => {
                        K.target.value !== "" && K.target.value !== "Select" && Gt(K.target.value), K.target.value = "";
                      },
                      options: zt(t.xAxis.dataKey, !0)
                    }
                  )
                ] })
              ] }),
              me() && /* @__PURE__ */ a(
                $e,
                {
                  value: t.xAxis.min,
                  section: "xAxis",
                  fieldName: "min",
                  type: "number",
                  label: "min value",
                  placeholder: "Auto",
                  updateField: Ne
                }
              ),
              G() && /* @__PURE__ */ a(
                $e,
                {
                  value: t.xAxis.max,
                  section: "xAxis",
                  fieldName: "max",
                  type: "number",
                  label: "max value",
                  placeholder: "Auto",
                  updateField: Ne
                }
              ),
              se() && t.orientation !== "horizontal" && /* @__PURE__ */ O("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: (C = (b = t.xAxis) == null ? void 0 : b.anchors) == null ? void 0 : C.map((K, X) => /* @__PURE__ */ O(Tn, { className: "series-item series-item--chart", children: [
                  /* @__PURE__ */ a(Cn, { className: "series-item__title", children: /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O(An, { className: "accordion__button accordion__button", children: [
                    "Anchor ",
                    X + 1,
                    /* @__PURE__ */ a(
                      "button",
                      {
                        className: "series-list__remove",
                        onClick: (le) => {
                          le.preventDefault();
                          const be = [...t.xAxis.anchors];
                          be.splice(X, 1), n({
                            ...t,
                            xAxis: {
                              ...t.xAxis,
                              anchors: be
                            }
                          });
                        },
                        children: "Remove"
                      }
                    )
                  ] }) }) }),
                  /* @__PURE__ */ O(Ln, { children: [
                    /* @__PURE__ */ O("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                      /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                      ] }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: t.xAxis.anchors[X].value ? t.xAxis.anchors[X].value : "",
                          onChange: (le) => {
                            le.preventDefault();
                            const be = [...t.xAxis.anchors];
                            be[X].value = le.target.value, n({
                              ...t,
                              xAxis: {
                                ...t.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ O("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: t.xAxis.anchors[X].color ? t.xAxis.anchors[X].color : "",
                          onChange: (le) => {
                            le.preventDefault();
                            const be = [...t.xAxis.anchors];
                            be[X].color = le.target.value, n({
                              ...t,
                              xAxis: {
                                ...t.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ O("label", { children: [
                      "Anchor Line Style",
                      /* @__PURE__ */ O(
                        "select",
                        {
                          value: t.xAxis.anchors[X].lineStyle || "",
                          onChange: (le) => {
                            const be = [...t.xAxis.anchors];
                            be[X].lineStyle = le.target.value, n({
                              ...t,
                              xAxis: {
                                ...t.xAxis,
                                anchors: be
                              }
                            });
                          },
                          children: [
                            /* @__PURE__ */ a("option", { children: "Select" }),
                            v.map((le) => /* @__PURE__ */ a("option", { children: le.value }, le.key))
                          ]
                        }
                      )
                    ] })
                  ] })
                ] }, `xaxis-anchors-2-${X}`)) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (K) => {
                      K.preventDefault();
                      const X = [...t.xAxis.anchors];
                      X.push({}), n({
                        ...t,
                        xAxis: {
                          ...t.xAxis,
                          anchors: X
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] }),
              se() && t.orientation === "horizontal" && /* @__PURE__ */ O("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: (H = (I = t.yAxis) == null ? void 0 : I.anchors) == null ? void 0 : H.map((K, X) => /* @__PURE__ */ O(
                  Tn,
                  {
                    className: "series-item series-item--chart",
                    children: [
                      /* @__PURE__ */ a(Cn, { className: "series-item__title", children: /* @__PURE__ */ a(ze, { children: /* @__PURE__ */ O(An, { className: "accordion__button accordion__button", children: [
                        "Anchor ",
                        X + 1,
                        /* @__PURE__ */ a(
                          "button",
                          {
                            className: "series-list__remove",
                            onClick: (le) => {
                              le.preventDefault();
                              const be = [...t.yAxis.anchors];
                              be.splice(X, 1), n({
                                ...t,
                                yAxis: {
                                  ...t.yAxis,
                                  anchors: be
                                }
                              });
                            },
                            children: "Remove"
                          }
                        )
                      ] }) }) }),
                      /* @__PURE__ */ O(Ln, { children: [
                        /* @__PURE__ */ O("label", { children: [
                          /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                          /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                          ] }),
                          /* @__PURE__ */ a(
                            "input",
                            {
                              type: "text",
                              value: t.yAxis.anchors[X].value ? t.yAxis.anchors[X].value : "",
                              onChange: (le) => {
                                le.preventDefault();
                                const be = [...t.yAxis.anchors];
                                be[X].value = le.target.value, n({
                                  ...t,
                                  yAxis: {
                                    ...t.yAxis,
                                    anchors: be
                                  }
                                });
                              }
                            }
                          )
                        ] }),
                        /* @__PURE__ */ O("label", { children: [
                          /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                          /* @__PURE__ */ a(
                            "input",
                            {
                              type: "text",
                              value: t.yAxis.anchors[X].color ? t.yAxis.anchors[X].color : "",
                              onChange: (le) => {
                                le.preventDefault();
                                const be = [...t.yAxis.anchors];
                                be[X].color = le.target.value, n({
                                  ...t,
                                  yAxis: {
                                    ...t.yAxis,
                                    anchors: be
                                  }
                                });
                              }
                            }
                          )
                        ] }),
                        /* @__PURE__ */ O("label", { children: [
                          "Anchor Line Style",
                          /* @__PURE__ */ O(
                            "select",
                            {
                              value: t.yAxis.anchors[X].lineStyle || "",
                              onChange: (le) => {
                                const be = [...t.yAxis.anchors];
                                be[X].lineStyle = le.target.value, n({
                                  ...t,
                                  yAxis: {
                                    ...t.yAxis,
                                    anchors: be
                                  }
                                });
                              },
                              children: [
                                /* @__PURE__ */ a("option", { children: "Select" }),
                                v.map((le) => /* @__PURE__ */ a("option", { children: le.value }, le.key))
                              ]
                            }
                          )
                        ] })
                      ] })
                    ]
                  },
                  `accordion-yaxis-anchors-${X}`
                )) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (K) => {
                      K.preventDefault();
                      const X = [...t.yAxis.anchors];
                      X.push({}), n({
                        ...t,
                        yAxis: {
                          ...t.yAxis,
                          anchors: X
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ a(wi.Regions, { name: "Regions" }),
          t.visualizationType !== "Box Plot" && t.visualizationType !== "Sankey" && /* @__PURE__ */ O(Tn, { children: [
            /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: "Columns" }) }),
            /* @__PURE__ */ O(Ln, { children: [
              /* @__PURE__ */ a(
                aT,
                {
                  config: t,
                  updateField: Ne,
                  deleteColumn: _t
                }
              ),
              " "
            ] })
          ] }),
          U() && /* @__PURE__ */ O(Tn, { children: [
            /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: "Legend" }) }),
            /* @__PURE__ */ O(Ln, { children: [
              /* @__PURE__ */ a(
                ht,
                {
                  value: (oe = t.legend) == null ? void 0 : oe.position,
                  section: "legend",
                  fieldName: "position",
                  label: "Position",
                  updateField: Ne,
                  options: ["right", "left", "bottom", "top"]
                }
              ),
              (t.legend.position === "left" || t.legend.position === "right" || !t.legend.position) && t.legend.style === "gradient" && /* @__PURE__ */ a("span", { style: { color: "red", fontSize: "14px" }, children: "Position must be set to top or bottom to use gradient style." }),
              /* @__PURE__ */ a(
                ht,
                {
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "If using gradient style, limit the legend to five items for better mobile visibility, and position the legend at the top or bottom." }) })
                  ] }),
                  display: !t.legend.hide,
                  value: t.legend.style,
                  section: "legend",
                  fieldName: "style",
                  label: "Legend Style",
                  updateField: Ne,
                  options: Yt("style")
                }
              ),
              /* @__PURE__ */ a(
                ht,
                {
                  value: t.legend.groupBy,
                  section: "legend",
                  fieldName: "groupBy",
                  initial: "Select",
                  label: "Legend Group By:",
                  updateField: Ne,
                  options: Yt("groupBy")
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Choose option Shapes in Line Datapoint Symbols to display." }) })
                  ] }),
                  display: !t.legend.hide && t.legend.style === "lines",
                  value: t.legend.hasShape,
                  section: "legend",
                  fieldName: "hasShape",
                  label: "Shapes",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                ht,
                {
                  display: !t.legend.hide && t.legend.style === "gradient",
                  value: t.legend.subStyle,
                  section: "legend",
                  fieldName: "subStyle",
                  label: "Gradient Style",
                  updateField: Ne,
                  options: Yt("subStyle")
                }
              ),
              /* @__PURE__ */ a(
                $e,
                {
                  display: t.legend.style === "gradient" && !t.legend.hide,
                  className: "number-narrow",
                  type: "number",
                  value: t.legend.tickRotation,
                  section: "legend",
                  fieldName: "tickRotation",
                  label: "Tick Rotation (Degrees)",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  display: (pe = t.preliminaryData) == null ? void 0 : pe.some((K) => K.label && K.type === "suppression" && K.value),
                  value: t.legend.hideSuppressedLabels,
                  section: "legend",
                  fieldName: "hideSuppressedLabels",
                  label: "Hide Suppressed Labels",
                  updateField: Ne,
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.` }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  display: (we = t.preliminaryData) == null ? void 0 : we.some((K) => K.label && K.type === "suppression" && K.value),
                  value: t.legend.hideSuppressionLink,
                  section: "legend",
                  fieldName: "hideSuppressionLink",
                  label: "Hide Suppression Definition Link",
                  updateField: Ne,
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting this option will hide the suppression definition link from display." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                ht,
                {
                  display: Hn || Jt,
                  value: t.legend.behavior,
                  section: "legend",
                  fieldName: "behavior",
                  label: "Legend Behavior (When clicked)",
                  updateField: (...[K, , X, le]) => nn(K, X, le),
                  options: ["highlight", "isolate"]
                }
              ),
              /* @__PURE__ */ a(
                ht,
                {
                  display: j(),
                  value: t.legend.colorCode,
                  section: "legend",
                  fieldName: "colorCode",
                  label: "Color code by category",
                  initial: "Select",
                  updateField: Ne,
                  options: tn(i)
                }
              ),
              re() && /* @__PURE__ */ a(
                Ge,
                {
                  value: t.legend.axisAlign,
                  fieldName: "axisAlign",
                  section: "legend",
                  label: "Align to Axis on Isolate",
                  updateField: Ne
                }
              ),
              t.legend.behavior === "highlight" && t.tooltips.singleSeries && /* @__PURE__ */ a(
                Ge,
                {
                  value: t.legend.highlightOnHover,
                  section: "legend",
                  fieldName: "highlightOnHover",
                  label: "HIGHLIGHT DATA SERIES ON HOVER",
                  updateField: Ne
                }
              ),
              de && t.legend.behavior === "isolate" && !Nn && /* @__PURE__ */ O("fieldset", { className: "primary-fieldset edit-block", children: [
                /* @__PURE__ */ a("label", { children: /* @__PURE__ */ O("span", { className: "edit-label", children: [
                  "Isolate Data Series",
                  /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend." }) })
                  ] })
                ] }) }),
                t.legend.seriesHighlight && t.legend.seriesHighlight.map((K, X) => /* @__PURE__ */ O("fieldset", { className: "edit-block", children: [
                  /* @__PURE__ */ a(
                    "button",
                    {
                      className: "btn btn-danger",
                      onClick: (le) => {
                        le.preventDefault();
                        const be = [...t.legend.seriesHighlight];
                        be.splice(X, 1), Ne("legend", null, "seriesHighlight", be), be.length || R();
                      },
                      children: "Remove"
                    }
                  ),
                  /* @__PURE__ */ a(
                    ht,
                    {
                      value: t.legend.seriesHighlight[X],
                      fieldName: "seriesHighlight",
                      label: "Isolate Value",
                      onChange: (le) => {
                        const be = [...t.legend.seriesHighlight];
                        be.includes(le.target.value) || (be[X] = le.target.value, Dt([...be]));
                      },
                      options: Sn()
                    }
                  )
                ] }, `${K}-${X}`)),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (K) => {
                      K.preventDefault();
                      const X = Sn(), le = [...t.legend.seriesHighlight];
                      if (le.length < X.length) {
                        const [Ue] = X.filter((Ft) => !le.includes(Ft));
                        le.push(Ue), Dt([...le]);
                      }
                    },
                    children: "Add Isolate Value"
                  }
                )
              ] }, "additional-highlight-values"),
              /* @__PURE__ */ a(
                Ge,
                {
                  display: !t.legend.hide && t.legend.style !== "gradient",
                  value: t.legend.reverseLabelOrder,
                  section: "legend",
                  fieldName: "reverseLabelOrder",
                  label: "Reverse Labels",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  display: !t.legend.hide,
                  value: ["left", "right"].includes(t.legend.position) ? t.legend.hideBorder.side : t.legend.hideBorder.topBottom,
                  section: "legend",
                  subsection: "hideBorder",
                  fieldName: ["left", "right"].includes(t.legend.position) ? "side" : "topBottom",
                  label: "Hide Legend Box",
                  updateField: Ne,
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Default option for top and bottom legends is ‘No Box.’." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  display: !t.legend.hide && !["left", "right"].includes(t.legend.position) && t.legend.style !== "gradient",
                  value: t.legend.singleRow,
                  section: "legend",
                  fieldName: "singleRow",
                  label: "Single Row Legend",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  display: ["bottom", "top"].includes(t.legend.position) && !t.legend.hide && t.legend.style !== "gradient" && !t.legend.singleRow && !t.legend.singleRow,
                  value: t.legend.verticalSorted,
                  section: "legend",
                  fieldName: "verticalSorted",
                  label: "Vertical sorted Legend",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: !!t.legend.hide,
                  section: "legend",
                  fieldName: "hide",
                  label: "Hide Legend",
                  updateField: Ne,
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "With a single-series chart, consider hiding the legend to reduce visual clutter." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                $e,
                {
                  value: t.legend.label,
                  section: "legend",
                  fieldName: "label",
                  label: "Title",
                  updateField: Ne
                }
              ),
              /* @__PURE__ */ a(
                $e,
                {
                  type: "textarea",
                  value: t.legend.description,
                  updateField: Ne,
                  section: "legend",
                  fieldName: "description",
                  label: "Legend Description"
                }
              ),
              /* @__PURE__ */ a(
                Ge,
                {
                  value: t.legend.unified,
                  section: "legend",
                  fieldName: "unified",
                  label: "Unified Legend",
                  updateField: Ne,
                  tooltip: /* @__PURE__ */ O(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "For a chart with filters, check this option if you want the legend to contain an item for every series in the data set, including those that are filtered." }) })
                  ] })
                }
              )
            ] })
          ] }),
          Fe() && /* @__PURE__ */ O(ze, { children: [
            /* @__PURE__ */ O(Tn, { children: [
              /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: "Filters" }) }),
              /* @__PURE__ */ a(Ln, { children: /* @__PURE__ */ a(
                Zg,
                {
                  config: t,
                  updateField: rn,
                  rawData: S,
                  hasFootnotes: g
                }
              ) })
            ] }),
            /* @__PURE__ */ O(Tn, { children: [
              /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: "Footnotes" }) }),
              /* @__PURE__ */ a(Ln, { children: /* @__PURE__ */ a(wv, { config: t, updateField: rn, datasets: e }) })
            ] })
          ] }),
          /* @__PURE__ */ a(wi.Visual, { name: "Visual" }),
          t.visualizationType !== "Spark Line" && /* @__PURE__ */ O(Tn, { children: [
            /* @__PURE__ */ a(Cn, { children: /* @__PURE__ */ a(An, { children: "Data Table" }) }),
            /* @__PURE__ */ O(Ln, { children: [
              /* @__PURE__ */ a(
                oT,
                {
                  config: t,
                  columns: Object.keys(i[0] || {}),
                  updateField: Ne,
                  isDashboard: g,
                  isLoadedFromUrl: et
                }
              ),
              " "
            ] })
          ] }),
          /* @__PURE__ */ a(wi.Annotate, { name: "Text Annotations" })
        ] }),
        t.type !== "Spark Line" && /* @__PURE__ */ a(Qg, { loadConfig: n, config: t, convertStateToConfig: $t })
      ]
    }
  ) }) });
}, Am = (e) => {
  let t = "", n = Math.abs(e);
  return n >= 1e9 ? (t = "B", e = e / 1e9) : n >= 1e6 ? (t = "M", e = e / 1e6) : n >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, cl = (e, t) => {
  var n;
  return e ? (n = e.legend) != null && n.hide ? e != null && e.title ? `dataTableSection__${e.title.replace(/\s/g, "")}` : "dataTableSection" : t : "dataTableSection";
}, OT = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], Lm = (e) => typeof e == "string" ? parseFloat(e.replace(/,/g, "")) : Number(e), FT = (e, t) => {
  if (t.rankByValue) {
    const n = t.series[0].dataKey, r = e.sort((i, o) => Lm(i[n]) - Lm(o[n]));
    return t.rankByValue === "asc" ? r : r.reverse();
  }
  return e;
}, Em = (e = "#000000", t = !1) => {
  let n = Qi(e), r = t ? n.brighten(0.5).hex() : n.saturate(1.3).hex();
  return [e, r, n.darken(0.3).hex()];
}, MT = (e, t) => {
  const { allowLineToBarGraph: n, series: r, visualizationType: i, xAxis: o } = e;
  if (!n)
    return !1;
  const h = i === "Line" && (t == null ? void 0 : t.length) < 3, d = (r == null ? void 0 : r.some((p) => p.dynamicCategory)) && Ke.uniq(t == null ? void 0 : t.map((p) => p[o.dataKey])).length <= 2;
  return h || d;
}, IT = (e, t) => {
  const n = t, r = Ke.uniq(Ke.map(n, e.xAxis.dataKey)), i = Ke.map(e.series, "dataKey"), o = [];
  r.forEach((u) => {
    i.forEach((d) => {
      try {
        if (!u)
          throw new Error("No groups resolved in box plots");
        const { count: p, sortedData: m } = Ke.chain(n).filter((S) => S[e.xAxis.dataKey] === u).thru((S) => ({
          count: S.length,
          sortedData: Ke.map(S, (B) => Number(B[d])).sort()
        })).value();
        if (!m)
          throw new Error("boxplots dont have data yet");
        if (!o)
          throw new Error("boxplots dont have plots yet");
        const g = kl(m, 0.25), x = kl(m, 0.75), A = x - g, k = g - 1.5 * A, y = x + 1.5 * A, v = m.filter((S) => S >= k && S <= y);
        o.push({
          columnCategory: u,
          columnMax: Pm(v),
          columnThirdQuartile: Ke.round(x, e.dataFormat.roundTo),
          columnMedian: Number(Ym(m)).toFixed(e.dataFormat.roundTo),
          columnFirstQuartile: Ke.round(g, e.dataFormat.roundTo),
          columnMin: Ke.min(v),
          columnCount: p,
          columnSd: Number(Lv(m)).toFixed(e.dataFormat.roundTo),
          columnMean: Number(Nv(m)).toFixed(e.dataFormat.roundTo),
          columnIqr: Ke.round(A, e.dataFormat.roundTo),
          values: m,
          columnLowerBounds: k,
          columnUpperBounds: y,
          columnOutliers: Ke.filter(m, (S) => S < k || S > y),
          columnNonOutliers: Ke.filter(m, (S) => S >= k && S <= y)
        });
      } catch (p) {
        console.error("COVE: ", p.message);
      }
    });
  });
  const h = i.length > 1 ? Ke.flatMap(r, (u) => Ke.map(i, (d) => `${Ke.capitalize(d)} - ${Ke.capitalize(u)}`)) : r;
  return [o, h];
}, BT = (e) => {
  if (e.visualizationType !== "Combo" || !e.series)
    return;
  const t = {
    barSeriesKeys: [],
    lineSeriesKeys: [],
    areaSeriesKeys: [],
    forecastingSeriesKeys: []
  }, n = /* @__PURE__ */ new Map([
    ["Area Chart", "areaSeriesKeys"],
    ["Forecasting", "forecastingSeriesKeys"],
    ["Bar", "barSeriesKeys"],
    ["Combo", "barSeriesKeys"],
    ["Line", "lineSeriesKeys"],
    ["dashed-sm", "lineSeriesKeys"],
    ["dashed-md", "lineSeriesKeys"],
    ["dashed-lg", "lineSeriesKeys"]
  ]);
  return e.series.forEach((r) => {
    const i = n.get(r.type);
    if (i) {
      const o = i === "barSeriesKeys" || i === "lineSeriesKeys" ? r.dataKey : r;
      t[i].push(o);
    }
    r.type === "Combo" && (r.type = "Bar");
  }), { ...e.runtime, ...t };
}, zT = (e, t) => {
  var r;
  let n = t;
  if (e.exclusions && e.exclusions.active)
    if (e.xAxis.type === "categorical" && ((r = e.exclusions.keys) == null ? void 0 : r.length) > 0)
      n = t.filter((i) => !e.exclusions.keys.includes(i[e.xAxis.dataKey]));
    else if (En(e.xAxis) && (e.exclusions.dateStart || e.exclusions.dateEnd) && e.xAxis.dateParseFormat) {
      const i = (p) => new Date(p).getTime();
      let o = i(e.exclusions.dateStart), h = i(e.exclusions.dateEnd) + 86399999, u = typeof o !== void 0 && isNaN(o) === !1, d = typeof h !== void 0 && isNaN(h) === !1;
      u && d ? n = t.filter(
        (p) => i(p[e.xAxis.dataKey]) >= o && i(p[e.xAxis.dataKey]) <= h
      ) : u ? n = t.filter((p) => i(p[e.xAxis.dataKey]) >= o) : d && (n = t.filter((p) => i(p[e.xAxis.dataKey]) <= h));
    } else
      n = t;
  return n;
}, $T = (e) => {
  const t = ["Paired Bar", "Deviation Bar"].includes(e.visualizationType) ? e.twoColor.palette : e.palette, n = { ...Lr, ...Fc };
  let r = e.customColors || n[t], i = e.runtime.seriesKeys.length;
  for (; i > r.length; )
    r = r.concat(r);
  return r = r.slice(0, i), Df({
    domain: e.runtime.seriesLabelsAll,
    range: r,
    unknown: null
  });
};
const HT = (e) => {
  var t, n, r;
  return {
    isLoading: !0,
    config: nc,
    stateData: Ke.cloneDeep(e == null ? void 0 : e.data) || [],
    colorScale: null,
    excludedData: void 0,
    filteredData: void 0,
    seriesHighlight: e && ((n = (t = e == null ? void 0 : e.legend) == null ? void 0 : t.seriesHighlight) != null && n.length) ? [...(r = e == null ? void 0 : e.legend) == null ? void 0 : r.seriesHighlight] : [],
    currentViewport: "lg",
    dimensions: [0, 0],
    container: null,
    coveLoadedEventRan: !1,
    isDraggingAnnotation: !1,
    imageId: `cove-${Math.random().toString(16).slice(-4)}`,
    brushConfig: {
      data: [],
      isActive: !1,
      isBrushing: !1
    }
  };
}, VT = (e, t) => {
  switch (t.type) {
    case "SET_LOADING":
      return { ...e, isLoading: t.payload };
    case "SET_CONFIG":
      return { ...e, config: t.payload };
    case "UPDATE_CONFIG":
      return { ...e, config: t.payload };
    case "SET_COLOR_SCALE":
      return { ...e, colorScale: t.payload };
    case "SET_STATE_DATA":
      return { ...e, stateData: t.payload };
    case "SET_EXCLUDED_DATA":
      return { ...e, excludedData: t.payload };
    case "SET_FILTERED_DATA":
      return { ...e, filteredData: t.payload };
    case "SET_SERIES_HIGHLIGHT":
      return { ...e, seriesHighlight: t.payload };
    case "SET_VIEWPORT":
      return { ...e, currentViewport: t.payload };
    case "SET_DIMENSIONS":
      return { ...e, dimensions: t.payload };
    case "SET_CONTAINER":
      return { ...e, container: t.payload };
    case "SET_LOADED_EVENT":
      return { ...e, coveLoadedEventRan: t.payload };
    case "SET_DRAG_ANNOTATIONS":
      return { ...e, isDraggingAnnotation: t.payload };
    case "SET_BRUSH_CONFIG":
      return { ...e, brushConfig: t.payload };
  }
}, WT = (e, t) => {
  const n = Ke.cloneDeep(e.runtime) || {};
  n.series = [], n.seriesLabels = {}, n.seriesLabelsAll = [];
  const { filters: r, columns: i, dynamicSeriesType: o, dynamicSeriesLineType: h, xAxis: u } = e;
  return t != null && t.length && Object.keys(t[0]).forEach((p) => {
    const m = u.dataKey !== p, g = !r || !(r != null && r.find((A) => A.columnName === p)), x = !i || Object.keys(i).indexOf(p) === -1;
    m && g && x && n.series.push({
      dataKey: p,
      type: o,
      lineType: h,
      tooltip: !0
    });
  }), n.seriesKeys = n.series ? n.series.map((d) => (n.seriesLabels[d.dataKey] = d.name || d.label || d.dataKey, n.seriesLabelsAll.push(d.name || d.dataKey), d.dataKey)) : [], n;
}, jT = ({
  config: e,
  isEditor: t = !1,
  isDebug: n = !1,
  isDashboard: r = !1,
  setConfig: i,
  setEditing: o,
  link: h,
  setSharedFilter: u,
  setSharedFilterValue: d,
  dashboardConfig: p,
  datasets: m
}) => {
  var Nt, Yt, tn, zt, It, $t, Ze, mt, Kt;
  const g = new Gm(), x = HT(e), [A, k] = he.useReducer(VT, x), {
    config: y,
    stateData: v,
    excludedData: S,
    filteredData: B,
    currentViewport: R,
    isLoading: N,
    dimensions: D,
    container: L,
    coveLoadedEventRan: q,
    imageId: V,
    seriesHighlight: ae,
    colorScale: Y,
    brushConfig: Q
  } = A, { description: se, visualizationType: ie } = y, M = he.useRef(null), U = he.useContext(Jg), [re, j] = he.useState(), de = (Pe) => {
    k({ type: "SET_CONFIG", payload: Pe }), t && !r && U.setTempConfig(Pe);
  }, Z = he.useRef(null), ge = he.useRef(null), ne = (Pe) => {
    k({ type: "SET_DRAG_ANNOTATIONS", payload: Pe });
  };
  let { legend: G, title: me } = y;
  t && (!me || me === "") && (me = "Chart Title"), y.table && (!((Nt = y.table) != null && Nt.label) || ((Yt = y.table) == null ? void 0 : Yt.label) === "") && (y.table.label = "Data Table");
  const { lineDatapointClass: ye, contentClasses: Se, sparkLineStyles: ce } = nv(y), ke = he.useId(), Le = (y.xAxis || y.yAxis) && ["date-time", "date"].includes((y.xAxis || y.yAxis).type) && y.xAxis.dataKey, Fe = MT(y, B), Xe = (Pe) => {
    let _e = Ke.defaultsDeep(Pe, nc);
    return Ke.defaultsDeep(_e, {
      table: { showVertical: !1 }
    }), Ke.set(_e, "table.show", Ke.get(_e, "table.show", !r)), Ke.forEach(_e.series, (xe) => {
      Ke.defaults(xe, {
        tooltip: !0,
        axis: "Left"
      });
    }), _e.visualizationType === "Bump Chart" && _e.xAxis.type, r ? _e : Tv(_e);
  }, Be = (Pe, _e) => {
    var At, Xt;
    const xe = Ke.cloneDeep(Pe);
    let ut = _e || v;
    ut = FT(ut, xe), Object.keys(nc).forEach((tt) => {
      xe[tt] && typeof xe[tt] == "object" && !Array.isArray(xe[tt]) && (xe[tt] = { ...nc[tt], ...xe[tt] });
    });
    const et = zT(xe, _e || v);
    k({ type: "SET_EXCLUDED_DATA", payload: et });
    let rt = [];
    if (xe.filters) {
      const tt = sp(xe.filters, et);
      rt = ol(tt, et), k({ type: "SET_FILTERED_DATA", payload: rt });
    }
    if (xe.xAxis.type === "date-time" && y.orientation === "horizontal" && (xe.xAxis.type = "date"), xe.runtime = {}, xe.runtime.series = Ke.cloneDeep(xe.series), xe.runtime.seriesLabels = {}, xe.runtime.seriesLabelsAll = [], xe.runtime.originalXAxis = xe.xAxis, xe.visualizationType === "Pie")
      xe.runtime.seriesKeys = (_e || ut).map((tt) => tt[xe.xAxis.dataKey]), xe.runtime.seriesLabelsAll = xe.runtime.seriesKeys;
    else {
      const tt = _e || xe.formattedData || xe.data;
      xe.runtime.seriesKeys = (xe.runtime.series || []).flatMap((_t) => {
        if (_t.dynamicCategory) {
          Ke.remove(xe.runtime.seriesLabelsAll, (vt) => vt === _t.dataKey), Ke.remove(xe.runtime.series, (vt) => vt.dataKey === _t.dataKey);
          const yn = Ke.uniq(tt.map((vt) => vt[_t.dynamicCategory]));
          return yn.forEach((vt) => {
            xe.runtime.seriesLabels[vt] = vt, xe.runtime.seriesLabelsAll.push(vt), xe.runtime.series.push({
              dataKey: vt,
              type: _t.type,
              lineType: _t.lineType,
              originalDataKey: _t.dataKey,
              dynamicCategory: _t.dynamicCategory,
              tooltip: !0
            });
          }), yn;
        } else
          return xe.runtime.seriesLabels[_t.dataKey] = _t.name || _t.label || _t.dataKey, xe.runtime.seriesLabelsAll.push(_t.name || _t.dataKey), [_t.dataKey];
      });
    }
    if (xe.visualizationType === "Box Plot" && xe.series) {
      const [tt, _t] = IT(xe, v);
      xe.boxplot.categories = _t, xe.boxplot.plots = tt;
    }
    xe.visualizationType === "Combo" && xe.series && (xe.runtime = BT(xe)), xe.visualizationType === "Forecasting" && xe.series && (xe.runtime.forecastingSeriesKeys = [], xe.series.forEach((tt) => {
      tt.type === "Forecasting" && xe.runtime.forecastingSeriesKeys.push(tt);
    })), xe.visualizationType === "Area Chart" && xe.series && (xe.runtime.areaSeriesKeys = [], xe.series.forEach((tt) => {
      xe.runtime.areaSeriesKeys.push({ ...tt, type: "Area Chart" });
    }), xe.visualizationSubType = "stacked"), xe.visualizationType === "Bar" && xe.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(xe.visualizationType) ? (xe.runtime.xAxis = xe.yAxis.yAxis ? xe.yAxis.yAxis : xe.yAxis, xe.runtime.yAxis = xe.xAxis.xAxis ? xe.xAxis.xAxis : xe.xAxis, xe.runtime.yAxis.labelOffset *= -1, xe.runtime.horizontal = !1, xe.orientation = "horizontal", xe.yAxis.type = xe.yAxis.type === "categorical" ? "linear" : xe.yAxis.type) : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(xe.visualizationType) && !Fe ? (xe.runtime.xAxis = xe.xAxis, xe.runtime.yAxis = xe.yAxis, xe.runtime.horizontal = !1, xe.orientation = "vertical") : (xe.runtime.xAxis = xe.xAxis, xe.runtime.yAxis = xe.yAxis, xe.runtime.horizontal = !1), xe.runtime.uniqueId = Date.now(), xe.runtime.editorErrorMessage = xe.visualizationType === "Pie" && !xe.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", xe.runtime.editorErrorMessage = "", (At = xe.legend.seriesHighlight) != null && At.length && k({ type: "SET_SERIES_HIGHLIGHT", payload: (Xt = xe.legend) == null ? void 0 : Xt.seriesHighlight }), de(xe);
  }, ot = (Pe, _e) => {
    let xe = y.visualizationType === "Bar" && y.visualizationSubType === "horizontal" ? y.xAxis.dataKey : y.yAxis.sortKey, ut = parseFloat(Pe[xe]), et = parseFloat(_e[xe]);
    return ut < et ? y.sortData === "ascending" ? 1 : -1 : ut > et ? y.sortData === "ascending" ? -1 : 1 : 0;
  }, gt = (Pe) => {
    if (!y.dynamicSeries) {
      const _e = sp(Pe, S);
      de({
        ...y,
        filters: _e
      });
    }
    if (y.filterBehavior === "Filter Change") {
      const _e = ol(Pe, S);
      if (k({ type: "SET_FILTERED_DATA", payload: _e }), y.dynamicSeries) {
        const xe = WT(y, _e);
        de({
          ...y,
          filters: Pe,
          runtime: xe
        });
      }
    }
  }, st = new Pg((Pe) => {
    for (let _e of Pe) {
      let { width: xe, height: ut } = _e.contentRect;
      xe = t ? xe - Om : xe;
      const et = Ng(xe);
      k({ type: "SET_VIEWPORT", payload: et }), _e.target.dataset.lollipop === "true" && (xe = xe - 2.5), xe = xe, k({ type: "SET_DIMENSIONS", payload: [xe, ut] });
    }
  }), dt = he.useCallback((Pe) => {
    Pe !== null && st.observe(Pe), k({ type: "SET_CONTAINER", payload: Pe });
  }, []);
  he.useEffect(() => {
    try {
      if (e) {
        const Pe = Xe(Ke.cloneDeep(e)), { formattedData: _e } = Pe;
        Pe.data = _e, k({ type: "SET_STATE_DATA", payload: _e }), k({ type: "SET_EXCLUDED_DATA", payload: _e }), Be(Pe, _e);
      }
    } catch {
      console.error("Could not Load!");
    }
  }, [(tn = e == null ? void 0 : e.data) != null && tn.length ? e.data : null]), he.useEffect(() => {
    L && !N && !Ke.isEmpty(y) && !q && (rv("cove_loaded", { config: y }), k({ type: "SET_LOADED_EVENT", payload: !0 }));
  }, [L, y, N]), he.useEffect(() => {
    const Pe = (_e) => {
      let xe = [];
      xe.push(_e.detail), j(xe);
    };
    return iv("cove_filterData", (_e) => Pe(_e)), () => {
      av("cove_filterData", Pe);
    };
  }, [y]), he.useEffect(() => {
    if (re && re[0] && !re[0].hasOwnProperty("active")) {
      let _e = { ...y };
      delete _e.filters, de(_e), k({ type: "SET_FILTERED_DATA", payload: ol(re, S) });
    }
    if (re && re.length > 0 && re.length > 0 && re[0].hasOwnProperty("active")) {
      let Pe = { ...y, filters: re };
      de(Pe), k({ type: "SET_FILTERED_DATA", payload: ol(re, S) });
    }
  }, [re]), he.useEffect(() => {
    var Pe;
    if (v && y.xAxis && ((Pe = y.runtime) != null && Pe.seriesKeys)) {
      const _e = $T(y);
      k({ type: "SET_COLOR_SCALE", payload: _e }), k({ type: "SET_LOADING", payload: !1 });
    }
    y && v && y.sortData && v.sort(ot);
  }, [y, v]);
  const Ye = (Pe) => {
    if (ae.length + 1 === y.runtime.seriesKeys.length && y.visualizationType !== "Forecasting")
      return Je();
    const _e = Ke.findKey(y.runtime.seriesLabels, (ut) => ut === Pe.datum) || Pe.datum, xe = Ke.xor(ae, [_e]);
    k({ type: "SET_SERIES_HIGHLIGHT", payload: xe });
  }, Je = () => {
    try {
      const Pe = Z.current;
      if (!Pe)
        throw new Gd("No legend available to set previous focus on.");
      Pe.focus();
    } catch (Pe) {
      console.error("COVE:", Pe.message);
    }
    k({ type: "SET_SERIES_HIGHLIGHT", payload: [] });
  }, yt = y.orientation === "horizontal" ? "yAxis" : "xAxis", nt = (Pe, _e = !0) => {
    let xe = sv(y.runtime[yt].dateParseFormat)(Pe);
    return xe || (_e && (y.runtime.editorErrorMessage = `Error parsing date "${Pe}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, lt = (Pe, _e, xe) => {
    var et, rt;
    let ut = Xu(y.runtime[yt].dateDisplayFormat)(Pe);
    if ((et = y.runtime[yt].dateDisplayFormat) != null && et.includes("%b.") && ut.includes("May.") && (ut = ut.replace(/May\./g, "May")), y.xAxis.showYearsOnce && ((rt = y.runtime[yt].dateDisplayFormat) != null && rt.includes("%Y")) && xe) {
      const At = xe[_e - 1] ? xe[_e - 1].value : null, Xt = Xu(y.runtime[yt].dateDisplayFormat)(At), tt = ut.match(/\d{4}/), _t = Xt.match(/\d{4}/);
      tt && _t && tt[0] === _t[0] && (ut = ut.replace(tt, ""));
    }
    return ut;
  }, je = (Pe) => Xu(y.tooltips.dateDisplayFormat)(Pe), at = (Pe, _e, xe = !1, ut, et, rt, { index: At, length: Xt } = { index: null, length: null }) => {
    if (Pe === "")
      return "N/A";
    if (isNaN(Pe) || !Pe)
      return Pe;
    const tt = Pe < 0;
    (_e === void 0 || !_e) && (_e = "left"), tt && (Pe = Math.abs(Pe));
    let {
      dataFormat: {
        commas: _t,
        abbreviated: yn,
        roundTo: vt,
        prefix: St,
        suffix: gn,
        rightRoundTo: xn,
        bottomRoundTo: On,
        rightPrefix: Fn,
        rightSuffix: Pn,
        bottomPrefix: ir,
        bottomSuffix: Nn,
        bottomAbbreviated: Sn,
        onlyShowTopPrefixSuffix: Dt
      }
    } = y;
    String(Pe).indexOf(",") !== -1 && (Pe = Pe.replaceAll(",", ""));
    let nn = Pe, dn = {
      useGrouping: !!_t
      // for old chart data table to work right cant just leave this to undefined
    };
    if (_e === "left" || _e === void 0) {
      let qt;
      rt !== void 0 ? qt = rt ? Number(rt) : 0 : qt = vt ? Number(vt) : 0, dn = {
        useGrouping: rt ? !0 : !!y.dataFormat.commas,
        minimumFractionDigits: qt,
        maximumFractionDigits: qt
      };
    }
    _e === "right" && (dn = {
      useGrouping: !!y.dataFormat.rightCommas,
      minimumFractionDigits: xn ? Number(xn) : 0,
      maximumFractionDigits: xn ? Number(xn) : 0
    });
    const Hn = () => y.forestPlot.type === "Logarithmic" && !On ? 2 : Number(On) ? Number(On) : 0;
    if (_e === "bottom" && (dn = {
      useGrouping: !!y.dataFormat.bottomCommas,
      minimumFractionDigits: Hn(),
      maximumFractionDigits: Hn()
    }), Pe = np(Pe), isNaN(Pe))
      return y.runtime.editorErrorMessage = `Unable to parse number from data ${nn}. Try reviewing your data and selections in the Data Series section.`, nn;
    if (!y.dataFormat)
      return Pe;
    if (y.dataCutoff) {
      let qt = np(y.dataCutoff);
      Pe < qt && (Pe = qt);
    }
    _e === "left" && _t && yn && xe || _e === "bottom" && _t && yn && xe ? Pe = Pe : Pe = Pe.toLocaleString("en-US", dn);
    let Jt = "";
    if (yn && _e === "left" && xe && (Pe = Am(parseFloat(Pe))), Sn && _e === "bottom" && xe && (Pe = Am(parseFloat(Pe))), ut && _e === "left")
      Jt = ut + Jt;
    else {
      const qt = Dt && Xt - 1 !== At;
      St && _e === "left" && !qt && (Jt += St);
    }
    return Fn && _e === "right" && (Jt += Fn), ir && _e === "bottom" && (Jt += ir), Jt += Pe, et && _e === "left" ? Jt += et : gn && _e === "left" && !Dt && (Jt += gn), Pn && _e === "right" && (Jt += Pn), Nn && _e === "bottom" && (Jt += Nn), tt && (Jt = "-" + Jt), String(Jt);
  }, ct = (Pe) => {
    try {
      if (!Pe)
        throw new Gd("COVE: No rowObj in applyLegendToRow");
      if (y.type === "navigation") {
        let _e = Lr[y.color] || Lr.bluegreenreverse;
        return Em(_e[3]);
      }
      return Em();
    } catch (_e) {
      console.error("COVE: ", _e);
    }
  }, wt = (Pe) => {
    var rt;
    if (!Array.isArray(Pe))
      return [];
    if (y.visualizationType === "Forecasting")
      return Pe;
    const _e = Object.values(Ke.get(y, "confidenceKeys", {})), ut = [...Ke.get(y, "series", []).map((At) => At.dataKey) ?? [], ..._e ?? []], et = y.xAxis.dataKey;
    return (rt = y == null ? void 0 : y.xAxis) != null && rt.dataKey ? g.cleanData(Pe, et, ut) : Pe;
  }, rn = () => {
    var ut, et, rt;
    if (ie === "Sankey")
      return (et = (ut = y == null ? void 0 : y.data) == null ? void 0 : ut[0]) == null ? void 0 : et.tableData;
    const Pe = B || S, _e = y.series.find((At) => !!At.dynamicCategory);
    if (!_e)
      return Pe;
    const xe = Object.values(y.columns).filter((At) => At.dataTable).map((At) => At.name).concat([_e.dynamicCategory, _e.dataKey]);
    return (rt = y.xAxis) != null && rt.dataKey && xe.push(y.xAxis.dataKey), Pe.map((At) => Ke.pick(At, xe));
  }, Ne = (Pe) => {
    const _e = Ke.cloneDeep(Pe), xe = _e.series.find((ut) => !!ut.dynamicCategory);
    if (xe) {
      const ut = { columnName: xe.dynamicCategory, valueColumns: [xe.dataKey] };
      _e.table.pivot = ut;
    }
    return _e;
  };
  let Ct = /* @__PURE__ */ a(ev, {});
  const bn = (Pe) => {
    if (Ke.isString(Pe))
      return Ke.kebabCase(Pe);
  }, Zt = () => {
    var xe;
    const Pe = (G == null ? void 0 : G.position) === "bottom" || Yi(R), _e = ["chart-container", "p-relative"];
    return G != null && G.position && (Yi(R) && (G == null ? void 0 : G.position) !== "top" ? _e.push("legend-bottom") : _e.push(`legend-${G.position}`)), G != null && G.hide && _e.push("legend-hidden"), ye && _e.push(ye), y.barHasBorder || _e.push("chart-bar--no-border"), (xe = y.brush) != null && xe.active && (p == null ? void 0 : p.type) === "dashboard" && (!Pe || G.hide) && _e.push("dashboard-brush"), _e.push(...Se), _e;
  }, jt = () => {
    var xe, ut;
    const Pe = ["subtext mt-4"], _e = (G == null ? void 0 : G.position) === "bottom" || Yi(R);
    return y.isResponsiveTicks && Pe.push("subtext--responsive-ticks "), (xe = y.brush) != null && xe.active && !_e && Pe.push("subtext--brush-active "), (ut = y.brush) != null && ut.active && y.legend.hide && Pe.push("subtext--brush-active "), Pe;
  };
  if (!N) {
    const Pe = /* @__PURE__ */ O("a", { href: `#data-table-${y.dataKey}`, className: "margin-left-href", children: [
      y.dataKey,
      " (Go to Table)"
    ] });
    Ct = /* @__PURE__ */ O(ze, { children: [
      t && /* @__PURE__ */ a(DT, { datasets: m }),
      /* @__PURE__ */ O(yh.Responsive, { isEditor: t, children: [
        y.newViz && /* @__PURE__ */ a(Cv, { updateConfig: Be, config: y }),
        y.newViz === void 0 && t && y.runtime && ((zt = y.runtime) == null ? void 0 : zt.editorErrorMessage) && /* @__PURE__ */ a(Gd, { errorMessage: y.runtime.editorErrorMessage }),
        !vh(y) && !y.newViz && /* @__PURE__ */ O(
          "div",
          {
            className: `cdc-chart-inner-container cove-component__content type-${bn(
              y.visualizationType
            )}`,
            "aria-label": jh(y),
            tabIndex: 0,
            children: [
              /* @__PURE__ */ a(
                lv,
                {
                  showTitle: y.showTitle,
                  isDashboard: r,
                  title: me,
                  superTitle: y.superTitle,
                  classes: ["chart-title", `${y.theme}`, "cove-component__header", "mb-3"],
                  style: void 0
                }
              ),
              /* @__PURE__ */ O("div", { className: Zt().join(" "), children: [
                (y == null ? void 0 : y.introText) && y.visualizationType !== "Spark Line" && /* @__PURE__ */ a("section", { className: "introText mb-4", children: Gi(y.introText) }),
                y.filters && !re && y.visualizationType !== "Spark Line" && /* @__PURE__ */ a(
                  op,
                  {
                    config: y,
                    setFilters: gt,
                    excludedData: S,
                    dimensions: D
                  }
                ),
                /* @__PURE__ */ a(Zf, { skipId: cl(y, ke), skipMessage: "Skip Over Chart Container" }),
                ((It = y.annotations) == null ? void 0 : It.length) > 0 && /* @__PURE__ */ a(
                  Zf,
                  {
                    skipId: cl(y, ke),
                    skipMessage: "Skip over annotations"
                  },
                  "skip-annotations"
                ),
                /* @__PURE__ */ O(Mv, { children: [
                  /* @__PURE__ */ O(
                    "div",
                    {
                      className: G.hide || Yi(R) || G.position === "bottom" || G.position === "top" || ie === "Sankey" || ie === "Spark Line" ? "w-100" : "w-75",
                      children: [
                        !["Spark Line", "Line", "Sankey", "Pie", "Sankey"].includes(y.visualizationType) && /* @__PURE__ */ a("div", { ref: ge, style: { width: "100%" }, children: /* @__PURE__ */ a(Ko, { children: (_e) => /* @__PURE__ */ a(fh, { ref: M, parentWidth: _e.width, parentHeight: _e.height }) }) }),
                        y.visualizationType === "Pie" && /* @__PURE__ */ a(Ko, { className: "justify-content-center d-flex", style: { width: "100%" }, children: (_e) => /* @__PURE__ */ a(PS, { ref: M, parentWidth: _e.width, parentHeight: _e.height }) }),
                        y.visualizationType === "Line" && (Fe ? /* @__PURE__ */ a("div", { ref: ge, style: { width: "100%" }, children: /* @__PURE__ */ a(Ko, { children: (_e) => /* @__PURE__ */ a(fh, { ref: M, parentWidth: _e.width, parentHeight: _e.height }) }) }) : /* @__PURE__ */ a("div", { ref: ge, style: { width: "100%" }, children: /* @__PURE__ */ a(Ko, { children: (_e) => {
                          const ut = y.showLineSeriesLabels && (y.legend.position !== "right" || y.legend.hide) ? 120 : 0;
                          return /* @__PURE__ */ a(
                            fh,
                            {
                              ref: M,
                              parentWidth: _e.width - ut,
                              parentHeight: _e.height
                            }
                          );
                        } }) })),
                        y.visualizationType === "Spark Line" && /* @__PURE__ */ O(ze, { children: [
                          /* @__PURE__ */ a(
                            op,
                            {
                              config: y,
                              setFilters: gt,
                              excludedData: S,
                              dimensions: D
                            }
                          ),
                          (y == null ? void 0 : y.introText) && /* @__PURE__ */ a("section", { className: "introText mb-4", style: { padding: "0px 0 35px" }, children: Gi(y.introText) }),
                          /* @__PURE__ */ a("div", { style: { height: "100px", width: "100%", ...ce }, children: /* @__PURE__ */ a(Ko, { children: (_e) => /* @__PURE__ */ a(Dk, { width: _e.width, height: _e.height }) }) }),
                          se && /* @__PURE__ */ a("div", { className: "subtext", style: { padding: "35px 0 15px" }, children: Gi(se) })
                        ] }),
                        y.visualizationType === "Sankey" && /* @__PURE__ */ a(Ko, { "aria-hidden": "true", children: (_e) => /* @__PURE__ */ a(GS, { runtime: y.runtime, width: _e.width, height: _e.height }) })
                      ]
                    }
                  ),
                  !y.legend.hide && y.visualizationType !== "Spark Line" && y.visualizationType !== "Sankey" && /* @__PURE__ */ a(rT, { ref: Z, skipId: cl(y, ke) })
                ] }),
                r && y.table && y.table.show && y.table.showDataTableLink ? Pe : h && h,
                y.description && y.visualizationType !== "Spark Line" && /* @__PURE__ */ a("div", { className: jt().join(" "), children: Gi(y.description) }),
                /* @__PURE__ */ O(Kd.Section, { classes: ["download-buttons"], children: [
                  y.table.showDownloadImgButton && /* @__PURE__ */ a(
                    Kd.Button,
                    {
                      text: "Download Image",
                      title: "Download Chart as Image",
                      type: "image",
                      state: y,
                      elementToCapture: V
                    }
                  ),
                  y.table.showDownloadPdfButton && /* @__PURE__ */ a(
                    Kd.Button,
                    {
                      text: "Download PDF",
                      title: "Download Chart as PDF",
                      type: "pdf",
                      state: y,
                      elementToCapture: V
                    }
                  )
                ] }),
                (y.xAxis.dataKey && y.table.show && y.visualizationType !== "Spark Line" && y.visualizationType !== "Sankey" || y.visualizationType === "Sankey" && y.table.show) && /* @__PURE__ */ a(
                  ov,
                  {
                    config: Ne(y),
                    rawData: y.visualizationType === "Sankey" ? (Ze = ($t = y == null ? void 0 : y.data) == null ? void 0 : $t[0]) == null ? void 0 : Ze.tableData : y.table.customTableConfig ? ol(y.filters, y.data) : y.data,
                    runtimeData: rn(),
                    expandDataTable: y.table.expanded,
                    columns: y.columns,
                    defaultSortBy: Le,
                    displayGeoName: (_e) => _e,
                    applyLegendToRow: ct,
                    tableTitle: y.table.label,
                    indexTitle: y.table.indexLabel,
                    vizTitle: me,
                    viewport: R,
                    tabbingId: cl(y, ke),
                    colorScale: Y
                  },
                  Le
                ),
                ((mt = y == null ? void 0 : y.annotations) == null ? void 0 : mt.length) > 0 && /* @__PURE__ */ a(If.Dropdown, {}),
                (y == null ? void 0 : y.legacyFootnotes) && /* @__PURE__ */ a("section", { className: "footnotes pt-2 mt-4", children: Gi(y.legacyFootnotes) })
              ] }),
              /* @__PURE__ */ a(
                kv,
                {
                  config: e.footnotes,
                  filters: (Kt = y.filters) == null ? void 0 : Kt.filter((_e) => _e.filterFootnotes)
                }
              )
            ]
          }
        )
      ] })
    ] });
  }
  const fn = {
    ...A,
    brushConfig: Q,
    capitalize: (Pe) => Pe.charAt(0).toUpperCase() + Pe.slice(1),
    convertLineToBarGraph: Fe,
    clean: wt,
    colorPalettes: Lr,
    dashboardConfig: p,
    debugSvg: n,
    formatDate: lt,
    formatNumber: at,
    formatTooltipsDate: je,
    getXAxisData: (Pe) => En(y.runtime.xAxis) ? nt(Pe[y.runtime.originalXAxis.dataKey]).getTime() : Pe[y.runtime.originalXAxis.dataKey],
    getYAxisData: (Pe, _e) => Pe[_e],
    handleChartAriaLabels: jh,
    handleLineType: Ag,
    handleChartTabbing: cl,
    highlight: Ye,
    handleShowAll: Je,
    isDashboard: r,
    isDebug: n,
    handleDragStateChange: ne,
    isEditor: t,
    isNumber: Wa,
    legend: G,
    legendId: ke,
    legendRef: Z,
    lineOptions: OT,
    missingRequiredSections: vh,
    outerContainerRef: dt,
    parentRef: ge,
    parseDate: nt,
    rawData: Ke.cloneDeep(v) ?? {},
    setConfig: de,
    setEditing: o,
    setParentConfig: i,
    setSharedFilter: u,
    setSharedFilterValue: d,
    svgRef: M,
    tableData: B || S,
    transformedData: wt(B || S),
    twoColorPalette: Fc,
    unfilteredData: Ke.cloneDeep(v),
    updateConfig: Be
  };
  return /* @__PURE__ */ a(pt.Provider, { value: fn, children: /* @__PURE__ */ a(ef.Provider, { value: k, children: /* @__PURE__ */ a(
    yh.VisualizationWrapper,
    {
      config: y,
      isEditor: t,
      currentViewport: R,
      ref: dt,
      imageId: V,
      showEditorPanel: y == null ? void 0 : y.showEditorPanel,
      children: Ct
    }
  ) }) });
}, TC = jT;
export {
  TC as C,
  oT as D,
  aT as a
};
