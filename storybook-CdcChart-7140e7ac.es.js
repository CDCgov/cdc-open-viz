import { r as ce, R as i } from "./storybook-index-45401197.es.js";
import { v as Oh, a as yy, i as Mh, b as _h, g as vy } from "./storybook-isSolr-cb863e7a.es.js";
import { _ as Xr, P as xy, D as by, C as Sy, A as Ey, F as Nh, g as ky } from "./storybook-Filters-d0b59c22.es.js";
import { L as tf, a as wy } from "./storybook-coveUpdateWorker-86b5b065.es.js";
import { B as Vf } from "./storybook-Button-d74e310e.es.js";
import { p as bm, P as he } from "./storybook-index-43433e35.es.js";
import { d as Ty } from "./storybook-debounce-cc216a80.es.js";
import { a as jf } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { P as Fh } from "./storybook-papaparse.min-b07ddc33.es.js";
import { H as Mi, T as Cy } from "./storybook-index-e5bf02db.es.js";
import { _ as pn } from "./storybook-extends-70f3d2a3.es.js";
import { p as zh, d as Ti, s as Wr, c as Wt, h as $h, a as wc, e as Gn, t as Bu, f as Ko, m as Rd, i as Bh, j as qn, k as Ih, l as Ay, n as Py, G as Ly, o as Ku, q as dr, r as Yu, g as Zo, T as Tt, I as Hh } from "./storybook-InputToggle-388019bd.es.js";
import { t as Ry, a as Cn, f as Sm, L as Wh, b as rs, g as Ci, S as Dy, M as Dd, D as Oy } from "./storybook-DataTable-b1fffc08.es.js";
import { E as Nr, L as My } from "./storybook-Loading-f180d060.es.js";
import { b as Tc, t as _y, e as Em, f as Vh, g as Ny, h as Fy, j as zy, k as jh, m as $y, G as at, c as Pn } from "./storybook-Group-e6c0d0df.es.js";
import { s as us, t as km, a as wm, b as Tm, d as Ps, B as gr, c as Kn, C as By } from "./storybook-Circle-c4db6c75.es.js";
import { R as Iy } from "./storybook-index-633d712d.es.js";
import { e as Es, a as Dn, b as On, c as Mn, d as _n, A as _i } from "./storybook-index-66852bf6.es.js";
import { _ as Ni } from "./storybook-lodash-c15d8e1c.es.js";
import { i as Cm, m as Od, c as Am, j as Eu, k as ku, l as wu, n as Uh, o as Hy, p as Kh, b as Pm, d as Lm } from "./storybook-year-bedc547d.es.js";
import { a as mt } from "./storybook-Icon-48ed169f.es.js";
import { C as Wy, V as Vy, a as Yh } from "./storybook-footnoteSymbols-166b967a.es.js";
import { S as Lt, T as Je, C as ct, D as jy } from "./storybook-DataTableEditor-f2f7b65f.es.js";
import { T as be } from "./storybook-Tooltip-edc0f7ab.es.js";
import { I as Ha } from "./storybook-InputSelect-20478396.es.js";
import { S as Rm } from "./storybook-icon-check-0ef17e76.es.js";
import { u as Uy, p as Ky, s as Yy, a as Xy } from "./storybook-useDataVizClasses-707a8d8e.es.js";
import { n as Xh } from "./storybook-numberFromString-24623c03.es.js";
import { D as qy } from "./storybook-DataTransform-e292f51b.es.js";
import { c as qh } from "./storybook-cacheBustingString-7a3dd9ba.es.js";
function Dm(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Gh(e) {
  let t = e, n = e;
  e.length === 1 && (t = (f, u) => e(f) - u, n = Gy(e));
  function a(f, u, s, d) {
    for (s == null && (s = 0), d == null && (d = f.length); s < d; ) {
      const m = s + d >>> 1;
      n(f[m], u) < 0 ? s = m + 1 : d = m;
    }
    return s;
  }
  function r(f, u, s, d) {
    for (s == null && (s = 0), d == null && (d = f.length); s < d; ) {
      const m = s + d >>> 1;
      n(f[m], u) > 0 ? d = m : s = m + 1;
    }
    return s;
  }
  function o(f, u, s, d) {
    s == null && (s = 0), d == null && (d = f.length);
    const m = a(f, u, s, d - 1);
    return m > s && t(f[m - 1], u) > -t(f[m], u) ? m - 1 : m;
  }
  return { left: a, center: o, right: r };
}
function Gy(e) {
  return (t, n) => Dm(e(t), n);
}
function* Zy(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let a of e)
      (a = t(a, ++n, e)) != null && (a = +a) >= a && (yield a);
  }
}
function Qy(e, t) {
  let n = 0, a, r = 0, o = 0;
  if (t === void 0)
    for (let f of e)
      f != null && (f = +f) >= f && (a = f - r, r += a / ++n, o += a * (f - r));
  else {
    let f = -1;
    for (let u of e)
      (u = t(u, ++f, e)) != null && (u = +u) >= u && (a = u - r, r += a / ++n, o += a * (u - r));
  }
  if (n > 1)
    return o / (n - 1);
}
function Jy(e, t) {
  const n = Qy(e, t);
  return n && Math.sqrt(n);
}
function cs(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n < a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function ds(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n > a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function Om(e, t, n = 0, a = e.length - 1, r = Dm) {
  for (; a > n; ) {
    if (a - n > 600) {
      const s = a - n + 1, d = t - n + 1, m = Math.log(s), y = 0.5 * Math.exp(2 * m / 3), v = 0.5 * Math.sqrt(m * y * (s - y) / s) * (d - s / 2 < 0 ? -1 : 1), w = Math.max(n, Math.floor(t - d * y / s + v)), E = Math.min(a, Math.floor(t + (s - d) * y / s + v));
      Om(e, t, w, E, r);
    }
    const o = e[t];
    let f = n, u = a;
    for (as(e, n, t), r(e[a], o) > 0 && as(e, n, a); f < u; ) {
      for (as(e, f, u), ++f, --u; r(e[f], o) < 0; )
        ++f;
      for (; r(e[u], o) > 0; )
        --u;
    }
    r(e[n], o) === 0 ? as(e, n, u) : (++u, as(e, u, a)), u <= t && (n = u + 1), t <= u && (a = u - 1);
  }
  return e;
}
function as(e, t, n) {
  const a = e[t];
  e[t] = e[n], e[n] = a;
}
function ev(e, t, n) {
  if (e = Float64Array.from(Zy(e, n)), !!(a = e.length)) {
    if ((t = +t) <= 0 || a < 2)
      return ds(e);
    if (t >= 1)
      return cs(e);
    var a, r = (a - 1) * t, o = Math.floor(r), f = cs(Om(e, o).subarray(0, o + 1)), u = ds(e.subarray(o + 1));
    return f + (u - f) * (r - o);
  }
}
function tv(e, t) {
  let n = 0, a = 0;
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && (++n, a += r);
  else {
    let r = -1;
    for (let o of e)
      (o = t(o, ++r, e)) != null && (o = +o) >= o && (++n, a += o);
  }
  if (n)
    return a / n;
}
function nv(e, t) {
  return ev(e, 0.5, t);
}
class Zh extends Map {
  constructor(t, n = iv) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [a, r] of t)
        this.set(a, r);
  }
  get(t) {
    return super.get(Qh(this, t));
  }
  has(t) {
    return super.has(Qh(this, t));
  }
  set(t, n) {
    return super.set(rv(this, t), n);
  }
  delete(t) {
    return super.delete(av(this, t));
  }
}
function Qh({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : n;
}
function rv({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : (e.set(a, n), n);
}
function av({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) && (n = e.get(a), e.delete(a)), n;
}
function iv(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function ov(e, t, n) {
  e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
  for (var a = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(r); ++a < r; )
    o[a] = e + a * n;
  return o;
}
const Jh = Symbol("implicit");
function Uf() {
  var e = new Zh(), t = [], n = [], a = Jh;
  function r(o) {
    let f = e.get(o);
    if (f === void 0) {
      if (a !== Jh)
        return a;
      e.set(o, f = t.push(o) - 1);
    }
    return n[f % n.length];
  }
  return r.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new Zh();
    for (const f of o)
      e.has(f) || e.set(f, t.push(f) - 1);
    return r;
  }, r.range = function(o) {
    return arguments.length ? (n = Array.from(o), r) : n.slice();
  }, r.unknown = function(o) {
    return arguments.length ? (a = o, r) : a;
  }, r.copy = function() {
    return Uf(t, n).unknown(a);
  }, Tc.apply(r, arguments), r;
}
function Kf() {
  var e = Uf().unknown(void 0), t = e.domain, n = e.range, a = 0, r = 1, o, f, u = !1, s = 0, d = 0, m = 0.5;
  delete e.unknown;
  function y() {
    var v = t().length, w = r < a, E = w ? r : a, O = w ? a : r;
    o = (O - E) / Math.max(1, v - s + d * 2), u && (o = Math.floor(o)), E += (O - E - o * (v - s)) * m, f = o * (1 - s), u && (E = Math.round(E), f = Math.round(f));
    var T = ov(v).map(function(g) {
      return E + o * g;
    });
    return n(w ? T.reverse() : T);
  }
  return e.domain = function(v) {
    return arguments.length ? (t(v), y()) : t();
  }, e.range = function(v) {
    return arguments.length ? ([a, r] = v, a = +a, r = +r, y()) : [a, r];
  }, e.rangeRound = function(v) {
    return [a, r] = v, a = +a, r = +r, u = !0, y();
  }, e.bandwidth = function() {
    return f;
  }, e.step = function() {
    return o;
  }, e.round = function(v) {
    return arguments.length ? (u = !!v, y()) : u;
  }, e.padding = function(v) {
    return arguments.length ? (s = Math.min(1, d = +v), y()) : s;
  }, e.paddingInner = function(v) {
    return arguments.length ? (s = Math.min(1, v), y()) : s;
  }, e.paddingOuter = function(v) {
    return arguments.length ? (d = +v, y()) : d;
  }, e.align = function(v) {
    return arguments.length ? (m = Math.max(0, Math.min(1, v)), y()) : m;
  }, e.copy = function() {
    return Kf(t(), [a, r]).round(u).paddingInner(s).paddingOuter(d).align(m);
  }, Tc.apply(y(), arguments);
}
function Mm(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return Mm(t());
  }, e;
}
function lv() {
  return Mm(Kf.apply(null, arguments).paddingInner(1));
}
function _m(e, t) {
  e = e.slice();
  var n = 0, a = e.length - 1, r = e[n], o = e[a], f;
  return o < r && (f = n, n = a, a = f, f = r, r = o, o = f), e[n] = t.floor(r), e[a] = t.ceil(o), e;
}
function ep(e) {
  return Math.log(e);
}
function tp(e) {
  return Math.exp(e);
}
function sv(e) {
  return -Math.log(-e);
}
function uv(e) {
  return -Math.exp(-e);
}
function cv(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function dv(e) {
  return e === 10 ? cv : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function fv(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function np(e) {
  return (t, n) => -e(-t, n);
}
function hv(e) {
  const t = e(ep, tp), n = t.domain;
  let a = 10, r, o;
  function f() {
    return r = fv(a), o = dv(a), n()[0] < 0 ? (r = np(r), o = np(o), e(sv, uv)) : e(ep, tp), t;
  }
  return t.base = function(u) {
    return arguments.length ? (a = +u, f()) : a;
  }, t.domain = function(u) {
    return arguments.length ? (n(u), f()) : n();
  }, t.ticks = (u) => {
    const s = n();
    let d = s[0], m = s[s.length - 1];
    const y = m < d;
    y && ([d, m] = [m, d]);
    let v = r(d), w = r(m), E, O;
    const T = u == null ? 10 : +u;
    let g = [];
    if (!(a % 1) && w - v < T) {
      if (v = Math.floor(v), w = Math.ceil(w), d > 0) {
        for (; v <= w; ++v)
          for (E = 1; E < a; ++E)
            if (O = v < 0 ? E / o(-v) : E * o(v), !(O < d)) {
              if (O > m)
                break;
              g.push(O);
            }
      } else
        for (; v <= w; ++v)
          for (E = a - 1; E >= 1; --E)
            if (O = v > 0 ? E / o(-v) : E * o(v), !(O < d)) {
              if (O > m)
                break;
              g.push(O);
            }
      g.length * 2 < T && (g = Vh(d, m, T));
    } else
      g = Vh(v, w, Math.min(w - v, T)).map(o);
    return y ? g.reverse() : g;
  }, t.tickFormat = (u, s) => {
    if (u == null && (u = 10), s == null && (s = a === 10 ? "s" : ","), typeof s != "function" && (!(a % 1) && (s = Ny(s)).precision == null && (s.trim = !0), s = Fy(s)), u === 1 / 0)
      return s;
    const d = Math.max(1, a * u / t.ticks().length);
    return (m) => {
      let y = m / o(Math.round(r(m)));
      return y * a < a - 0.5 && (y *= a), y <= d ? s(m) : "";
    };
  }, t.nice = () => n(_m(n(), {
    floor: (u) => o(Math.floor(r(u))),
    ceil: (u) => o(Math.ceil(r(u)))
  })), t;
}
function Nm() {
  const e = hv(_y()).domain([1, 10]);
  return e.copy = () => Em(e, Nm()).base(e.base()), Tc.apply(e, arguments), e;
}
const Xu = Cm(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Xu.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Cm((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : Xu);
Xu.range;
function pv(e, t, n, a, r, o) {
  const f = [
    [us, 1, Eu],
    [us, 5, 5 * Eu],
    [us, 15, 15 * Eu],
    [us, 30, 30 * Eu],
    [o, 1, ku],
    [o, 5, 5 * ku],
    [o, 15, 15 * ku],
    [o, 30, 30 * ku],
    [r, 1, wu],
    [r, 3, 3 * wu],
    [r, 6, 6 * wu],
    [r, 12, 12 * wu],
    [a, 1, Uh],
    [a, 2, 2 * Uh],
    [n, 1, Hy],
    [t, 1, Kh],
    [t, 3, 3 * Kh],
    [e, 1, Od]
  ];
  function u(d, m, y) {
    const v = m < d;
    v && ([d, m] = [m, d]);
    const w = y && typeof y.range == "function" ? y : s(d, m, y), E = w ? w.range(d, +m + 1) : [];
    return v ? E.reverse() : E;
  }
  function s(d, m, y) {
    const v = Math.abs(m - d) / y, w = zy(([, , T]) => T).right(f, v);
    if (w === f.length)
      return e.every(jh(d / Od, m / Od, y));
    if (w === 0)
      return Xu.every(Math.max(jh(d, m, y), 1));
    const [E, O] = f[v / f[w - 1][2] < f[w][2] / v ? w - 1 : w];
    return E.every(O);
  }
  return [u, s];
}
const [mv, gv] = pv(Am, Tm, Lm, Pm, wm, km);
function yv(e) {
  return new Date(e);
}
function vv(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Fm(e, t, n, a, r, o, f, u, s, d) {
  var m = $y(), y = m.invert, v = m.domain, w = d(".%L"), E = d(":%S"), O = d("%I:%M"), T = d("%I %p"), g = d("%a %d"), N = d("%b %d"), L = d("%B"), M = d("%Y");
  function _(C) {
    return (s(C) < C ? w : u(C) < C ? E : f(C) < C ? O : o(C) < C ? T : a(C) < C ? r(C) < C ? g : N : n(C) < C ? L : M)(C);
  }
  return m.invert = function(C) {
    return new Date(y(C));
  }, m.domain = function(C) {
    return arguments.length ? v(Array.from(C, vv)) : v().map(yv);
  }, m.ticks = function(C) {
    var H = v();
    return e(H[0], H[H.length - 1], C ?? 10);
  }, m.tickFormat = function(C, H) {
    return H == null ? _ : d(H);
  }, m.nice = function(C) {
    var H = v();
    return (!C || typeof C.range != "function") && (C = t(H[0], H[H.length - 1], C ?? 10)), C ? v(_m(H, C)) : m;
  }, m.copy = function() {
    return Em(m, Fm(e, t, n, a, r, o, f, u, s, d));
  }, m;
}
function xv() {
  return Tc.apply(Fm(mv, gv, Am, Tm, Lm, Pm, wm, km, us, Ry).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var bv = Ps("domain", "range", "reverse", "align", "padding", "round");
function nf(e) {
  return bv(Kf(), e);
}
var Sv = Ps("domain", "range", "reverse", "align", "padding", "round");
function Yo(e) {
  return Sv(lv(), e);
}
var Ev = Ps("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function kv(e) {
  return Ev(xv(), e);
}
var wv = Ps("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function qu(e) {
  return wv(Nm(), e);
}
var Tv = Ps("domain", "range", "reverse", "unknown");
function zm(e) {
  return Tv(Uf(), e);
}
function Cv(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function Av(e, t) {
  var n = e;
  return "ticks" in n ? n.ticks(t) : n.domain().filter(function(a, r, o) {
    return t == null || o.length <= t || r % Math.round((o.length - 1) / t) === 0;
  });
}
function Pv(e) {
  return e == null ? void 0 : e.toString();
}
var Fi = [], Lv = function() {
  return Fi.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Rv = function() {
  return Fi.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, rp = "ResizeObserver loop completed with undelivered notifications.", Dv = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: rp
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = rp), window.dispatchEvent(e);
}, ks;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(ks || (ks = {}));
var zi = function(e) {
  return Object.freeze(e);
}, $m = function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, zi(this);
  }
  return e;
}(), Bm = function() {
  function e(t, n, a, r) {
    return this.x = t, this.y = n, this.width = a, this.height = r, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, zi(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, a = t.y, r = t.top, o = t.right, f = t.bottom, u = t.left, s = t.width, d = t.height;
    return { x: n, y: a, top: r, right: o, bottom: f, left: u, width: s, height: d };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Yf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Im = function(e) {
  if (Yf(e)) {
    var t = e.getBBox(), n = t.width, a = t.height;
    return !n && !a;
  }
  var r = e, o = r.offsetWidth, f = r.offsetHeight;
  return !(o || f || e.getClientRects().length);
}, ap = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, Ov = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, fs = typeof window < "u" ? window : {}, Tu = /* @__PURE__ */ new WeakMap(), ip = /auto|scroll/, Mv = /^tb|vertical/, _v = /msie|trident/i.test(fs.navigator && fs.navigator.userAgent), Vr = function(e) {
  return parseFloat(e || "0");
}, qo = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new $m((n ? t : e) || 0, (n ? e : t) || 0);
}, op = zi({
  devicePixelContentBoxSize: qo(),
  borderBoxSize: qo(),
  contentBoxSize: qo(),
  contentRect: new Bm(0, 0, 0, 0)
}), Hm = function(e, t) {
  if (t === void 0 && (t = !1), Tu.has(e) && !t)
    return Tu.get(e);
  if (Im(e))
    return Tu.set(e, op), op;
  var n = getComputedStyle(e), a = Yf(e) && e.ownerSVGElement && e.getBBox(), r = !_v && n.boxSizing === "border-box", o = Mv.test(n.writingMode || ""), f = !a && ip.test(n.overflowY || ""), u = !a && ip.test(n.overflowX || ""), s = a ? 0 : Vr(n.paddingTop), d = a ? 0 : Vr(n.paddingRight), m = a ? 0 : Vr(n.paddingBottom), y = a ? 0 : Vr(n.paddingLeft), v = a ? 0 : Vr(n.borderTopWidth), w = a ? 0 : Vr(n.borderRightWidth), E = a ? 0 : Vr(n.borderBottomWidth), O = a ? 0 : Vr(n.borderLeftWidth), T = y + d, g = s + m, N = O + w, L = v + E, M = u ? e.offsetHeight - L - e.clientHeight : 0, _ = f ? e.offsetWidth - N - e.clientWidth : 0, C = r ? T + N : 0, H = r ? g + L : 0, I = a ? a.width : Vr(n.width) - C - _, X = a ? a.height : Vr(n.height) - H - M, te = I + T + _ + N, G = X + g + M + L, F = zi({
    devicePixelContentBoxSize: qo(Math.round(I * devicePixelRatio), Math.round(X * devicePixelRatio), o),
    borderBoxSize: qo(te, G, o),
    contentBoxSize: qo(I, X, o),
    contentRect: new Bm(y, s, I, X)
  });
  return Tu.set(e, F), F;
}, Wm = function(e, t, n) {
  var a = Hm(e, n), r = a.borderBoxSize, o = a.contentBoxSize, f = a.devicePixelContentBoxSize;
  switch (t) {
    case ks.DEVICE_PIXEL_CONTENT_BOX:
      return f;
    case ks.BORDER_BOX:
      return r;
    default:
      return o;
  }
}, Vm = function() {
  function e(t) {
    var n = Hm(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = zi([n.borderBoxSize]), this.contentBoxSize = zi([n.contentBoxSize]), this.devicePixelContentBoxSize = zi([n.devicePixelContentBoxSize]);
  }
  return e;
}(), jm = function(e) {
  if (Im(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Nv = function() {
  var e = 1 / 0, t = [];
  Fi.forEach(function(f) {
    if (f.activeTargets.length !== 0) {
      var u = [];
      f.activeTargets.forEach(function(d) {
        var m = new Vm(d.target), y = jm(d.target);
        u.push(m), d.lastReportedSize = Wm(d.target, d.observedBox), y < e && (e = y);
      }), t.push(function() {
        f.callback.call(f.observer, u, f.observer);
      }), f.activeTargets.splice(0, f.activeTargets.length);
    }
  });
  for (var n = 0, a = t; n < a.length; n++) {
    var r = a[n];
    r();
  }
  return e;
}, lp = function(e) {
  Fi.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(r) {
      r.isActive() && (jm(r.target) > e ? n.activeTargets.push(r) : n.skippedTargets.push(r));
    });
  });
}, Fv = function() {
  var e = 0;
  for (lp(e); Lv(); )
    e = Nv(), lp(e);
  return Rv() && Dv(), e > 0;
}, Md, Um = [], zv = function() {
  return Um.splice(0).forEach(function(e) {
    return e();
  });
}, $v = function(e) {
  if (!Md) {
    var t = 0, n = document.createTextNode(""), a = { characterData: !0 };
    new MutationObserver(function() {
      return zv();
    }).observe(n, a), Md = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  Um.push(e), Md();
}, Bv = function(e) {
  $v(function() {
    requestAnimationFrame(e);
  });
}, Iu = 0, Iv = function() {
  return !!Iu;
}, Hv = 250, Wv = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, sp = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], up = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, _d = !1, Vv = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Hv), !_d) {
      _d = !0;
      var a = up(t);
      Bv(function() {
        var r = !1;
        try {
          r = Fv();
        } finally {
          if (_d = !1, t = a - up(), !Iv())
            return;
          r ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, Wv);
    };
    document.body ? n() : fs.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), sp.forEach(function(n) {
      return fs.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), sp.forEach(function(n) {
      return fs.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), rf = new Vv(), cp = function(e) {
  !Iu && e > 0 && rf.start(), Iu += e, !Iu && rf.stop();
}, jv = function(e) {
  return !Yf(e) && !Ov(e) && getComputedStyle(e).display === "inline";
}, Uv = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || ks.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Wm(this.target, this.observedBox, !0);
    return jv(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Kv = function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Cu = /* @__PURE__ */ new WeakMap(), dp = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Au = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var a = new Kv(t, n);
    Cu.set(t, a);
  }, e.observe = function(t, n, a) {
    var r = Cu.get(t), o = r.observationTargets.length === 0;
    dp(r.observationTargets, n) < 0 && (o && Fi.push(r), r.observationTargets.push(new Uv(n, a && a.box)), cp(1), rf.schedule());
  }, e.unobserve = function(t, n) {
    var a = Cu.get(t), r = dp(a.observationTargets, n), o = a.observationTargets.length === 1;
    r >= 0 && (o && Fi.splice(Fi.indexOf(a), 1), a.observationTargets.splice(r, 1), cp(-1));
  }, e.disconnect = function(t) {
    var n = this, a = Cu.get(t);
    a.observationTargets.slice().forEach(function(r) {
      return n.unobserve(t, r.target);
    }), a.activeTargets.splice(0, a.activeTargets.length);
  }, e;
}(), Yv = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Au.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!ap(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Au.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!ap(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Au.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Au.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const Xv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: Yv,
  ResizeObserverEntry: Vm,
  ResizeObserverSize: $m
}, Symbol.toStringTag, { value: "Module" })), qv = /* @__PURE__ */ jf(Xv);
var fp = Xm, _a = Ym(bm), Gv = Ym(Ty), Wo = Jv(ce), Zv = qv, Qv = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function Km(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (Km = function(r) {
    return r ? n : t;
  })(e);
}
function Jv(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = Km(t);
  if (n && n.has(e))
    return n.get(e);
  var a = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var f = r ? Object.getOwnPropertyDescriptor(e, o) : null;
      f && (f.get || f.set) ? Object.defineProperty(a, o, f) : a[o] = e[o];
    }
  return a.default = e, n && n.set(e, a), a;
}
function Ym(e) {
  return e && e.__esModule ? e : { default: e };
}
function Gu() {
  return Gu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Gu.apply(this, arguments);
}
function ex(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var tx = [];
function Xm(e) {
  var t = e.className, n = e.children, a = e.debounceTime, r = a === void 0 ? 300 : a, o = e.ignoreDimensions, f = o === void 0 ? tx : o, u = e.parentSizeStyles, s = u === void 0 ? {
    width: "100%",
    height: "100%"
  } : u, d = e.enableDebounceLeadingCall, m = d === void 0 ? !0 : d, y = ex(e, Qv), v = (0, Wo.useRef)(null), w = (0, Wo.useRef)(0), E = (0, Wo.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), O = E[0], T = E[1], g = (0, Wo.useMemo)(function() {
    var N = Array.isArray(f) ? f : [f];
    return (0, Gv.default)(function(L) {
      T(function(M) {
        var _ = Object.keys(M), C = _.filter(function(I) {
          return M[I] !== L[I];
        }), H = C.every(function(I) {
          return N.includes(I);
        });
        return H ? M : L;
      });
    }, r, {
      leading: m
    });
  }, [r, m, f]);
  return (0, Wo.useEffect)(function() {
    var N = new Zv.ResizeObserver(function(L) {
      L === void 0 && (L = []), L.forEach(function(M) {
        var _ = M.contentRect, C = _.left, H = _.top, I = _.width, X = _.height;
        w.current = window.requestAnimationFrame(function() {
          g({
            width: I,
            height: X,
            top: H,
            left: C
          });
        });
      });
    });
    return v.current && N.observe(v.current), function() {
      window.cancelAnimationFrame(w.current), N.disconnect(), g != null && g.cancel && g.cancel();
    };
  }, [g]), /* @__PURE__ */ Wo.default.createElement("div", Gu({
    style: s,
    ref: v,
    className: t
  }, y), n(Gu({}, O, {
    ref: v.current,
    resize: g
  })));
}
Xm.propTypes = {
  className: _a.default.string,
  debounceTime: _a.default.number,
  enableDebounceLeadingCall: _a.default.bool,
  ignoreDimensions: _a.default.oneOfType([_a.default.any, _a.default.arrayOf(_a.default.any)]),
  children: _a.default.func.isRequired
};
var Nd = /* @__PURE__ */ new Date(), Fd = /* @__PURE__ */ new Date();
function ha(e, t, n, a) {
  function r(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return r.floor = function(o) {
    return e(o = /* @__PURE__ */ new Date(+o)), o;
  }, r.ceil = function(o) {
    return e(o = new Date(o - 1)), t(o, 1), e(o), o;
  }, r.round = function(o) {
    var f = r(o), u = r.ceil(o);
    return o - f < u - o ? f : u;
  }, r.offset = function(o, f) {
    return t(o = /* @__PURE__ */ new Date(+o), f == null ? 1 : Math.floor(f)), o;
  }, r.range = function(o, f, u) {
    var s = [], d;
    if (o = r.ceil(o), u = u == null ? 1 : Math.floor(u), !(o < f) || !(u > 0))
      return s;
    do
      s.push(d = /* @__PURE__ */ new Date(+o)), t(o, u), e(o);
    while (d < o && o < f);
    return s;
  }, r.filter = function(o) {
    return ha(function(f) {
      if (f >= f)
        for (; e(f), !o(f); )
          f.setTime(f - 1);
    }, function(f, u) {
      if (f >= f)
        if (u < 0)
          for (; ++u <= 0; )
            for (; t(f, -1), !o(f); )
              ;
        else
          for (; --u >= 0; )
            for (; t(f, 1), !o(f); )
              ;
    });
  }, n && (r.count = function(o, f) {
    return Nd.setTime(+o), Fd.setTime(+f), e(Nd), e(Fd), Math.floor(n(Nd, Fd));
  }, r.every = function(o) {
    return o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? r.filter(a ? function(f) {
      return a(f) % o === 0;
    } : function(f) {
      return r.count(0, f) % o === 0;
    }) : r;
  }), r;
}
const nx = 1e3, Xf = nx * 60, rx = Xf * 60, qf = rx * 24, qm = qf * 7;
var Gm = ha(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Xf) / qf,
  (e) => e.getDate() - 1
);
const Zm = Gm;
Gm.range;
function Wi(e) {
  return ha(function(t) {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setDate(t.getDate() + n * 7);
  }, function(t, n) {
    return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Xf) / qm;
  });
}
var Qm = Wi(0), Zu = Wi(1), ax = Wi(2), ix = Wi(3), Qo = Wi(4), ox = Wi(5), lx = Wi(6);
Qm.range;
Zu.range;
ax.range;
ix.range;
Qo.range;
ox.range;
lx.range;
var Gf = ha(function(e) {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setFullYear(e.getFullYear() + t);
}, function(e, t) {
  return t.getFullYear() - e.getFullYear();
}, function(e) {
  return e.getFullYear();
});
Gf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ha(function(t) {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setFullYear(t.getFullYear() + n * e);
  });
};
const ws = Gf;
Gf.range;
var Jm = ha(function(e) {
  e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCDate(e.getUTCDate() + t);
}, function(e, t) {
  return (t - e) / qf;
}, function(e) {
  return e.getUTCDate() - 1;
});
const eg = Jm;
Jm.range;
function Vi(e) {
  return ha(function(t) {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, function(t, n) {
    return (n - t) / qm;
  });
}
var tg = Vi(0), Qu = Vi(1), sx = Vi(2), ux = Vi(3), Jo = Vi(4), cx = Vi(5), dx = Vi(6);
tg.range;
Qu.range;
sx.range;
ux.range;
Jo.range;
cx.range;
dx.range;
var Zf = ha(function(e) {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, function(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}, function(e) {
  return e.getUTCFullYear();
});
Zf.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ha(function(t) {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function(t, n) {
    t.setUTCFullYear(t.getUTCFullYear() + n * e);
  });
};
const Ts = Zf;
Zf.range;
function zd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function $d(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function is(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function fx(e) {
  var t = e.dateTime, n = e.date, a = e.time, r = e.periods, o = e.days, f = e.shortDays, u = e.months, s = e.shortMonths, d = os(r), m = ls(r), y = os(o), v = ls(o), w = os(f), E = ls(f), O = os(u), T = ls(u), g = os(s), N = ls(s), L = {
    a: J,
    A: ue,
    b: ee,
    B: Z,
    c: null,
    d: vp,
    e: vp,
    f: Nx,
    g: Ux,
    G: Yx,
    H: Ox,
    I: Mx,
    j: _x,
    L: ng,
    m: Fx,
    M: zx,
    p: se,
    q: ye,
    Q: Sp,
    s: Ep,
    S: $x,
    u: Bx,
    U: Ix,
    V: Hx,
    w: Wx,
    W: Vx,
    x: null,
    X: null,
    y: jx,
    Y: Kx,
    Z: Xx,
    "%": bp
  }, M = {
    a: me,
    A: Le,
    b: de,
    B: ie,
    c: null,
    d: xp,
    e: xp,
    f: Qx,
    g: sb,
    G: cb,
    H: qx,
    I: Gx,
    j: Zx,
    L: ag,
    m: Jx,
    M: eb,
    p: Ce,
    q: He,
    Q: Sp,
    s: Ep,
    S: tb,
    u: nb,
    U: rb,
    V: ab,
    w: ib,
    W: ob,
    x: null,
    X: null,
    y: lb,
    Y: ub,
    Z: db,
    "%": bp
  }, _ = {
    a: te,
    A: G,
    b: F,
    B: j,
    c: U,
    d: gp,
    e: gp,
    f: Px,
    g: mp,
    G: pp,
    H: yp,
    I: yp,
    j: wx,
    L: Ax,
    m: kx,
    M: Tx,
    p: X,
    q: Ex,
    Q: Rx,
    s: Dx,
    S: Cx,
    u: yx,
    U: vx,
    V: xx,
    w: gx,
    W: bx,
    x: W,
    X: re,
    y: mp,
    Y: pp,
    Z: Sx,
    "%": Lx
  };
  L.x = C(n, L), L.X = C(a, L), L.c = C(t, L), M.x = C(n, M), M.X = C(a, M), M.c = C(t, M);
  function C(we, ge) {
    return function(ke) {
      var ne = [], Pe = -1, $e = 0, qe = we.length, Ge, Xe, We;
      for (ke instanceof Date || (ke = /* @__PURE__ */ new Date(+ke)); ++Pe < qe; )
        we.charCodeAt(Pe) === 37 && (ne.push(we.slice($e, Pe)), (Xe = hp[Ge = we.charAt(++Pe)]) != null ? Ge = we.charAt(++Pe) : Xe = Ge === "e" ? " " : "0", (We = ge[Ge]) && (Ge = We(ke, Xe)), ne.push(Ge), $e = Pe + 1);
      return ne.push(we.slice($e, Pe)), ne.join("");
    };
  }
  function H(we, ge) {
    return function(ke) {
      var ne = is(1900, void 0, 1), Pe = I(ne, we, ke += "", 0), $e, qe;
      if (Pe != ke.length)
        return null;
      if ("Q" in ne)
        return new Date(ne.Q);
      if ("s" in ne)
        return new Date(ne.s * 1e3 + ("L" in ne ? ne.L : 0));
      if (ge && !("Z" in ne) && (ne.Z = 0), "p" in ne && (ne.H = ne.H % 12 + ne.p * 12), ne.m === void 0 && (ne.m = "q" in ne ? ne.q : 0), "V" in ne) {
        if (ne.V < 1 || ne.V > 53)
          return null;
        "w" in ne || (ne.w = 1), "Z" in ne ? ($e = $d(is(ne.y, 0, 1)), qe = $e.getUTCDay(), $e = qe > 4 || qe === 0 ? Qu.ceil($e) : Qu($e), $e = eg.offset($e, (ne.V - 1) * 7), ne.y = $e.getUTCFullYear(), ne.m = $e.getUTCMonth(), ne.d = $e.getUTCDate() + (ne.w + 6) % 7) : ($e = zd(is(ne.y, 0, 1)), qe = $e.getDay(), $e = qe > 4 || qe === 0 ? Zu.ceil($e) : Zu($e), $e = Zm.offset($e, (ne.V - 1) * 7), ne.y = $e.getFullYear(), ne.m = $e.getMonth(), ne.d = $e.getDate() + (ne.w + 6) % 7);
      } else
        ("W" in ne || "U" in ne) && ("w" in ne || (ne.w = "u" in ne ? ne.u % 7 : "W" in ne ? 1 : 0), qe = "Z" in ne ? $d(is(ne.y, 0, 1)).getUTCDay() : zd(is(ne.y, 0, 1)).getDay(), ne.m = 0, ne.d = "W" in ne ? (ne.w + 6) % 7 + ne.W * 7 - (qe + 5) % 7 : ne.w + ne.U * 7 - (qe + 6) % 7);
      return "Z" in ne ? (ne.H += ne.Z / 100 | 0, ne.M += ne.Z % 100, $d(ne)) : zd(ne);
    };
  }
  function I(we, ge, ke, ne) {
    for (var Pe = 0, $e = ge.length, qe = ke.length, Ge, Xe; Pe < $e; ) {
      if (ne >= qe)
        return -1;
      if (Ge = ge.charCodeAt(Pe++), Ge === 37) {
        if (Ge = ge.charAt(Pe++), Xe = _[Ge in hp ? ge.charAt(Pe++) : Ge], !Xe || (ne = Xe(we, ke, ne)) < 0)
          return -1;
      } else if (Ge != ke.charCodeAt(ne++))
        return -1;
    }
    return ne;
  }
  function X(we, ge, ke) {
    var ne = d.exec(ge.slice(ke));
    return ne ? (we.p = m.get(ne[0].toLowerCase()), ke + ne[0].length) : -1;
  }
  function te(we, ge, ke) {
    var ne = w.exec(ge.slice(ke));
    return ne ? (we.w = E.get(ne[0].toLowerCase()), ke + ne[0].length) : -1;
  }
  function G(we, ge, ke) {
    var ne = y.exec(ge.slice(ke));
    return ne ? (we.w = v.get(ne[0].toLowerCase()), ke + ne[0].length) : -1;
  }
  function F(we, ge, ke) {
    var ne = g.exec(ge.slice(ke));
    return ne ? (we.m = N.get(ne[0].toLowerCase()), ke + ne[0].length) : -1;
  }
  function j(we, ge, ke) {
    var ne = O.exec(ge.slice(ke));
    return ne ? (we.m = T.get(ne[0].toLowerCase()), ke + ne[0].length) : -1;
  }
  function U(we, ge, ke) {
    return I(we, t, ge, ke);
  }
  function W(we, ge, ke) {
    return I(we, n, ge, ke);
  }
  function re(we, ge, ke) {
    return I(we, a, ge, ke);
  }
  function J(we) {
    return f[we.getDay()];
  }
  function ue(we) {
    return o[we.getDay()];
  }
  function ee(we) {
    return s[we.getMonth()];
  }
  function Z(we) {
    return u[we.getMonth()];
  }
  function se(we) {
    return r[+(we.getHours() >= 12)];
  }
  function ye(we) {
    return 1 + ~~(we.getMonth() / 3);
  }
  function me(we) {
    return f[we.getUTCDay()];
  }
  function Le(we) {
    return o[we.getUTCDay()];
  }
  function de(we) {
    return s[we.getUTCMonth()];
  }
  function ie(we) {
    return u[we.getUTCMonth()];
  }
  function Ce(we) {
    return r[+(we.getUTCHours() >= 12)];
  }
  function He(we) {
    return 1 + ~~(we.getUTCMonth() / 3);
  }
  return {
    format: function(we) {
      var ge = C(we += "", L);
      return ge.toString = function() {
        return we;
      }, ge;
    },
    parse: function(we) {
      var ge = H(we += "", !1);
      return ge.toString = function() {
        return we;
      }, ge;
    },
    utcFormat: function(we) {
      var ge = C(we += "", M);
      return ge.toString = function() {
        return we;
      }, ge;
    },
    utcParse: function(we) {
      var ge = H(we += "", !0);
      return ge.toString = function() {
        return we;
      }, ge;
    }
  };
}
var hp = { "-": "", _: " ", 0: "0" }, Wn = /^\s*\d+/, hx = /^%/, px = /[\\^$*+?|[\]().{}]/g;
function Yt(e, t, n) {
  var a = e < 0 ? "-" : "", r = (a ? -e : e) + "", o = r.length;
  return a + (o < n ? new Array(n - o + 1).join(t) + r : r);
}
function mx(e) {
  return e.replace(px, "\\$&");
}
function os(e) {
  return new RegExp("^(?:" + e.map(mx).join("|") + ")", "i");
}
function ls(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function gx(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 1));
  return a ? (e.w = +a[0], n + a[0].length) : -1;
}
function yx(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 1));
  return a ? (e.u = +a[0], n + a[0].length) : -1;
}
function vx(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 2));
  return a ? (e.U = +a[0], n + a[0].length) : -1;
}
function xx(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 2));
  return a ? (e.V = +a[0], n + a[0].length) : -1;
}
function bx(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 2));
  return a ? (e.W = +a[0], n + a[0].length) : -1;
}
function pp(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 4));
  return a ? (e.y = +a[0], n + a[0].length) : -1;
}
function mp(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), n + a[0].length) : -1;
}
function Sx(e, t, n) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), n + a[0].length) : -1;
}
function Ex(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 1));
  return a ? (e.q = a[0] * 3 - 3, n + a[0].length) : -1;
}
function kx(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 2));
  return a ? (e.m = a[0] - 1, n + a[0].length) : -1;
}
function gp(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 2));
  return a ? (e.d = +a[0], n + a[0].length) : -1;
}
function wx(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 3));
  return a ? (e.m = 0, e.d = +a[0], n + a[0].length) : -1;
}
function yp(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 2));
  return a ? (e.H = +a[0], n + a[0].length) : -1;
}
function Tx(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 2));
  return a ? (e.M = +a[0], n + a[0].length) : -1;
}
function Cx(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 2));
  return a ? (e.S = +a[0], n + a[0].length) : -1;
}
function Ax(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 3));
  return a ? (e.L = +a[0], n + a[0].length) : -1;
}
function Px(e, t, n) {
  var a = Wn.exec(t.slice(n, n + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), n + a[0].length) : -1;
}
function Lx(e, t, n) {
  var a = hx.exec(t.slice(n, n + 1));
  return a ? n + a[0].length : -1;
}
function Rx(e, t, n) {
  var a = Wn.exec(t.slice(n));
  return a ? (e.Q = +a[0], n + a[0].length) : -1;
}
function Dx(e, t, n) {
  var a = Wn.exec(t.slice(n));
  return a ? (e.s = +a[0], n + a[0].length) : -1;
}
function vp(e, t) {
  return Yt(e.getDate(), t, 2);
}
function Ox(e, t) {
  return Yt(e.getHours(), t, 2);
}
function Mx(e, t) {
  return Yt(e.getHours() % 12 || 12, t, 2);
}
function _x(e, t) {
  return Yt(1 + Zm.count(ws(e), e), t, 3);
}
function ng(e, t) {
  return Yt(e.getMilliseconds(), t, 3);
}
function Nx(e, t) {
  return ng(e, t) + "000";
}
function Fx(e, t) {
  return Yt(e.getMonth() + 1, t, 2);
}
function zx(e, t) {
  return Yt(e.getMinutes(), t, 2);
}
function $x(e, t) {
  return Yt(e.getSeconds(), t, 2);
}
function Bx(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function Ix(e, t) {
  return Yt(Qm.count(ws(e) - 1, e), t, 2);
}
function rg(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Qo(e) : Qo.ceil(e);
}
function Hx(e, t) {
  return e = rg(e), Yt(Qo.count(ws(e), e) + (ws(e).getDay() === 4), t, 2);
}
function Wx(e) {
  return e.getDay();
}
function Vx(e, t) {
  return Yt(Zu.count(ws(e) - 1, e), t, 2);
}
function jx(e, t) {
  return Yt(e.getFullYear() % 100, t, 2);
}
function Ux(e, t) {
  return e = rg(e), Yt(e.getFullYear() % 100, t, 2);
}
function Kx(e, t) {
  return Yt(e.getFullYear() % 1e4, t, 4);
}
function Yx(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? Qo(e) : Qo.ceil(e), Yt(e.getFullYear() % 1e4, t, 4);
}
function Xx(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Yt(t / 60 | 0, "0", 2) + Yt(t % 60, "0", 2);
}
function xp(e, t) {
  return Yt(e.getUTCDate(), t, 2);
}
function qx(e, t) {
  return Yt(e.getUTCHours(), t, 2);
}
function Gx(e, t) {
  return Yt(e.getUTCHours() % 12 || 12, t, 2);
}
function Zx(e, t) {
  return Yt(1 + eg.count(Ts(e), e), t, 3);
}
function ag(e, t) {
  return Yt(e.getUTCMilliseconds(), t, 3);
}
function Qx(e, t) {
  return ag(e, t) + "000";
}
function Jx(e, t) {
  return Yt(e.getUTCMonth() + 1, t, 2);
}
function eb(e, t) {
  return Yt(e.getUTCMinutes(), t, 2);
}
function tb(e, t) {
  return Yt(e.getUTCSeconds(), t, 2);
}
function nb(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function rb(e, t) {
  return Yt(tg.count(Ts(e) - 1, e), t, 2);
}
function ig(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Jo(e) : Jo.ceil(e);
}
function ab(e, t) {
  return e = ig(e), Yt(Jo.count(Ts(e), e) + (Ts(e).getUTCDay() === 4), t, 2);
}
function ib(e) {
  return e.getUTCDay();
}
function ob(e, t) {
  return Yt(Qu.count(Ts(e) - 1, e), t, 2);
}
function lb(e, t) {
  return Yt(e.getUTCFullYear() % 100, t, 2);
}
function sb(e, t) {
  return e = ig(e), Yt(e.getUTCFullYear() % 100, t, 2);
}
function ub(e, t) {
  return Yt(e.getUTCFullYear() % 1e4, t, 4);
}
function cb(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? Jo(e) : Jo.ceil(e), Yt(e.getUTCFullYear() % 1e4, t, 4);
}
function db() {
  return "+0000";
}
function bp() {
  return "%";
}
function Sp(e) {
  return +e;
}
function Ep(e) {
  return Math.floor(+e / 1e3);
}
var Vo, af, og;
fb({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function fb(e) {
  return Vo = fx(e), af = Vo.format, og = Vo.parse, Vo.utcFormat, Vo.utcParse, Vo;
}
const Pt = ce.createContext({}), Bt = {
  arr: Array.isArray,
  obj: (e) => Object.prototype.toString.call(e) === "[object Object]",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0,
  nul: (e) => e === null,
  set: (e) => e instanceof Set,
  map: (e) => e instanceof Map,
  equ(e, t) {
    if (typeof e != typeof t)
      return !1;
    if (Bt.str(e) || Bt.num(e))
      return e === t;
    if (Bt.obj(e) && Bt.obj(t) && Object.keys(e).length + Object.keys(t).length === 0)
      return !0;
    let n;
    for (n in e)
      if (!(n in t))
        return !1;
    for (n in t)
      if (e[n] !== t[n])
        return !1;
    return Bt.und(n) ? e === t : !0;
  }
};
function hb(e, t) {
  return t === void 0 && (t = !0), (n) => (Bt.arr(n) ? n : Object.keys(n)).reduce((a, r) => {
    const o = t ? r[0].toLowerCase() + r.substring(1) : r;
    return a[o] = e(o), a;
  }, e);
}
function lg() {
  const e = ce.useState(!1), t = e[1];
  return ce.useCallback(() => t((a) => !a), []);
}
function Ai(e, t) {
  return Bt.und(e) || Bt.nul(e) ? t : e;
}
function Xo(e) {
  return Bt.und(e) ? [] : Bt.arr(e) ? e : [e];
}
function Or(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    n[a - 1] = arguments[a];
  return Bt.fun(e) ? e(...n) : e;
}
function pb(e) {
  return e.to, e.from, e.config, e.onStart, e.onRest, e.onFrame, e.children, e.reset, e.reverse, e.force, e.immediate, e.delay, e.attach, e.destroyed, e.interpolateTo, e.ref, e.lazy, Xr(e, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
}
function Bd(e) {
  const t = pb(e);
  if (Bt.und(t))
    return pn({
      to: t
    }, e);
  const n = Object.keys(e).reduce((a, r) => Bt.und(t[r]) ? pn({}, a, {
    [r]: e[r]
  }) : a, {});
  return pn({
    to: t
  }, n);
}
function mb(e, t) {
  return t && (Bt.fun(t) ? t(e) : Bt.obj(t) && (t.current = e)), e;
}
class Mr {
  constructor() {
    this.payload = void 0, this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(t) {
    this.children.length === 0 && this.attach(), this.children.push(t);
  }
  removeChild(t) {
    const n = this.children.indexOf(t);
    this.children.splice(n, 1), this.children.length === 0 && this.detach();
  }
}
class of extends Mr {
  constructor() {
    super(...arguments), this.payload = [], this.attach = () => this.payload.forEach((t) => t instanceof Mr && t.addChild(this)), this.detach = () => this.payload.forEach((t) => t instanceof Mr && t.removeChild(this));
  }
}
class sg extends Mr {
  constructor() {
    super(...arguments), this.payload = {}, this.attach = () => Object.values(this.payload).forEach((t) => t instanceof Mr && t.addChild(this)), this.detach = () => Object.values(this.payload).forEach((t) => t instanceof Mr && t.removeChild(this));
  }
  getValue(t) {
    t === void 0 && (t = !1);
    const n = {};
    for (const a in this.payload) {
      const r = this.payload[a];
      t && !(r instanceof Mr) || (n[a] = r instanceof Mr ? r[t ? "getAnimatedValue" : "getValue"]() : r);
    }
    return n;
  }
  getAnimatedValue() {
    return this.getValue(!0);
  }
}
let Qf;
function gb(e, t) {
  Qf = {
    fn: e,
    transform: t
  };
}
let ug;
function yb(e) {
  ug = e;
}
let cg = (e) => typeof window < "u" ? window.requestAnimationFrame(e) : -1, Ju;
function vb(e) {
  Ju = e;
}
let dg = () => Date.now(), xb = (e) => e.current, fg;
function bb(e) {
  fg = e;
}
class Sb extends sg {
  constructor(t, n) {
    super(), this.update = void 0, this.payload = t.style ? pn({}, t, {
      style: fg(t.style)
    }) : t, this.update = n, this.attach();
  }
}
const Eb = (e) => Bt.fun(e) && !(e.prototype instanceof i.Component), kb = (e) => ce.forwardRef((n, a) => {
  const r = lg(), o = ce.useRef(!0), f = ce.useRef(null), u = ce.useRef(null), s = ce.useCallback((v) => {
    const w = f.current, E = () => {
      let O = !1;
      u.current && (O = Qf.fn(u.current, f.current.getAnimatedValue())), (!u.current || O === !1) && r();
    };
    f.current = new Sb(v, E), w && w.detach();
  }, []);
  ce.useEffect(() => () => {
    o.current = !1, f.current && f.current.detach();
  }, []), ce.useImperativeHandle(a, () => xb(u)), s(n);
  const d = f.current.getValue();
  d.scrollTop, d.scrollLeft;
  const m = Xr(d, ["scrollTop", "scrollLeft"]), y = Eb(e) ? void 0 : (v) => u.current = mb(v, a);
  return i.createElement(e, pn({}, m, {
    ref: y
  }));
});
let hs = !1;
const $i = /* @__PURE__ */ new Set(), hg = () => {
  if (!hs)
    return !1;
  let e = dg();
  for (let t of $i) {
    let n = !1;
    for (let a = 0; a < t.configs.length; a++) {
      let r = t.configs[a], o, f;
      for (let u = 0; u < r.animatedValues.length; u++) {
        let s = r.animatedValues[u];
        if (s.done)
          continue;
        let d = r.fromValues[u], m = r.toValues[u], y = s.lastPosition, v = m instanceof Mr, w = Array.isArray(r.initialVelocity) ? r.initialVelocity[u] : r.initialVelocity;
        if (v && (m = m.getValue()), r.immediate) {
          s.setValue(m), s.done = !0;
          continue;
        }
        if (typeof d == "string" || typeof m == "string") {
          s.setValue(m), s.done = !0;
          continue;
        }
        if (r.duration !== void 0)
          y = d + r.easing((e - s.startTime) / r.duration) * (m - d), o = e >= s.startTime + r.duration;
        else if (r.decay)
          y = d + w / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (e - s.startTime))), o = Math.abs(s.lastPosition - y) < 0.1, o && (m = y);
        else {
          f = s.lastTime !== void 0 ? s.lastTime : e, w = s.lastVelocity !== void 0 ? s.lastVelocity : r.initialVelocity, e > f + 64 && (f = e);
          let E = Math.floor(e - f);
          for (let N = 0; N < E; ++N) {
            let L = -r.tension * (y - m), M = -r.friction * w, _ = (L + M) / r.mass;
            w = w + _ * 1 / 1e3, y = y + w * 1 / 1e3;
          }
          let O = r.clamp && r.tension !== 0 ? d < m ? y > m : y < m : !1, T = Math.abs(w) <= r.precision, g = r.tension !== 0 ? Math.abs(m - y) <= r.precision : !0;
          o = O || T && g, s.lastVelocity = w, s.lastTime = e;
        }
        v && !r.toValues[u].done && (o = !1), o ? (s.value !== m && (y = m), s.done = !0) : n = !0, s.setValue(y), s.lastPosition = y;
      }
      t.props.onFrame && (t.values[r.name] = r.interpolation.getValue());
    }
    t.props.onFrame && t.props.onFrame(t.values), n || ($i.delete(t), t.stop(!0));
  }
  return $i.size ? cg(hg) : hs = !1, hs;
}, wb = (e) => {
  $i.has(e) || $i.add(e), hs || (hs = !0, cg(hg));
}, Tb = (e) => {
  $i.has(e) && $i.delete(e);
};
function ec(e, t, n) {
  if (typeof e == "function")
    return e;
  if (Array.isArray(e))
    return ec({
      range: e,
      output: t,
      extrapolate: n
    });
  if (Ju && typeof e.output[0] == "string")
    return Ju(e);
  const a = e, r = a.output, o = a.range || [0, 1], f = a.extrapolateLeft || a.extrapolate || "extend", u = a.extrapolateRight || a.extrapolate || "extend", s = a.easing || ((d) => d);
  return (d) => {
    const m = Ab(d, o);
    return Cb(d, o[m], o[m + 1], r[m], r[m + 1], s, f, u, a.map);
  };
}
function Cb(e, t, n, a, r, o, f, u, s) {
  let d = s ? s(e) : e;
  if (d < t) {
    if (f === "identity")
      return d;
    f === "clamp" && (d = t);
  }
  if (d > n) {
    if (u === "identity")
      return d;
    u === "clamp" && (d = n);
  }
  return a === r ? a : t === n ? e <= t ? a : r : (t === -1 / 0 ? d = -d : n === 1 / 0 ? d = d - t : d = (d - t) / (n - t), d = o(d), a === -1 / 0 ? d = -d : r === 1 / 0 ? d = d + a : d = d * (r - a) + a, d);
}
function Ab(e, t) {
  for (var n = 1; n < t.length - 1 && !(t[n] >= e); ++n)
    ;
  return n - 1;
}
class el extends of {
  constructor(t, n, a, r) {
    super(), this.calc = void 0, this.payload = t instanceof of && !(t instanceof el) ? t.getPayload() : Array.isArray(t) ? t : [t], this.calc = ec(n, a, r);
  }
  getValue() {
    return this.calc(...this.payload.map((t) => t.getValue()));
  }
  updateConfig(t, n, a) {
    this.calc = ec(t, n, a);
  }
  interpolate(t, n, a) {
    return new el(this, t, n, a);
  }
}
const Pb = (e, t, n) => e && new el(e, t, n);
function pg(e, t) {
  "update" in e ? t.add(e) : e.getChildren().forEach((n) => pg(n, t));
}
class lf extends Mr {
  constructor(t) {
    var n;
    super(), n = this, this.animatedStyles = /* @__PURE__ */ new Set(), this.value = void 0, this.startPosition = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.startTime = void 0, this.lastTime = void 0, this.done = !1, this.setValue = function(a, r) {
      r === void 0 && (r = !0), n.value = a, r && n.flush();
    }, this.value = t, this.startPosition = t, this.lastPosition = t;
  }
  flush() {
    this.animatedStyles.size === 0 && pg(this, this.animatedStyles), this.animatedStyles.forEach((t) => t.update());
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  getValue() {
    return this.value;
  }
  interpolate(t, n, a) {
    return new el(this, t, n, a);
  }
}
class Lb extends of {
  constructor(t) {
    super(), this.payload = t.map((n) => new lf(n));
  }
  setValue(t, n) {
    n === void 0 && (n = !0), Array.isArray(t) ? t.length === this.payload.length && t.forEach((a, r) => this.payload[r].setValue(a, n)) : this.payload.forEach((a) => a.setValue(t, n));
  }
  getValue() {
    return this.payload.map((t) => t.getValue());
  }
  interpolate(t, n) {
    return new el(this, t, n);
  }
}
let Rb = 0;
class Db {
  constructor() {
    this.id = void 0, this.idle = !0, this.hasChanged = !1, this.guid = 0, this.local = 0, this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.listeners = [], this.queue = [], this.localQueue = void 0, this.getValues = () => this.interpolations, this.id = Rb++;
  }
  /** update(props)
   *  This function filters input props and creates an array of tasks which are executed in .start()
   *  Each task is allowed to carry a delay, which means it can execute asnychroneously */
  update(t) {
    if (!t)
      return this;
    const n = Bd(t), a = n.delay, r = a === void 0 ? 0 : a, o = n.to, f = Xr(n, ["delay", "to"]);
    if (Bt.arr(o) || Bt.fun(o))
      this.queue.push(pn({}, f, {
        delay: r,
        to: o
      }));
    else if (o) {
      let u = {};
      Object.entries(o).forEach((s) => {
        let d = s[0], m = s[1];
        const y = pn({
          to: {
            [d]: m
          },
          delay: Or(r, d)
        }, f), v = u[y.delay] && u[y.delay].to;
        u[y.delay] = pn({}, u[y.delay], y, {
          to: pn({}, v, y.to)
        });
      }), this.queue = Object.values(u);
    }
    return this.queue = this.queue.sort((u, s) => u.delay - s.delay), this.diff(f), this;
  }
  /** start(onEnd)
   *  This function either executes a queue, if present, or starts the frameloop, which animates */
  start(t) {
    if (this.queue.length) {
      this.idle = !1, this.localQueue && this.localQueue.forEach((r) => {
        let o = r.from, f = o === void 0 ? {} : o, u = r.to, s = u === void 0 ? {} : u;
        Bt.obj(f) && (this.merged = pn({}, f, this.merged)), Bt.obj(s) && (this.merged = pn({}, this.merged, s));
      });
      const n = this.local = ++this.guid, a = this.localQueue = this.queue;
      this.queue = [], a.forEach((r, o) => {
        let f = r.delay, u = Xr(r, ["delay"]);
        const s = (m) => {
          o === a.length - 1 && n === this.guid && m && (this.idle = !0, this.props.onRest && this.props.onRest(this.merged)), t && t();
        };
        let d = Bt.arr(u.to) || Bt.fun(u.to);
        f ? setTimeout(() => {
          n === this.guid && (d ? this.runAsync(u, s) : this.diff(u).start(s));
        }, f) : d ? this.runAsync(u, s) : this.diff(u).start(s);
      });
    } else
      Bt.fun(t) && this.listeners.push(t), this.props.onStart && this.props.onStart(), wb(this);
    return this;
  }
  stop(t) {
    return this.listeners.forEach((n) => n(t)), this.listeners = [], this;
  }
  /** Pause sets onEnd listeners free, but also removes the controller from the frameloop */
  pause(t) {
    return this.stop(!0), t && Tb(this), this;
  }
  runAsync(t, n) {
    var a = this;
    t.delay;
    let r = Xr(t, ["delay"]);
    const o = this.local;
    let f = Promise.resolve(void 0);
    if (Bt.arr(r.to))
      for (let u = 0; u < r.to.length; u++) {
        const s = u, d = pn({}, r, Bd(r.to[s]));
        Bt.arr(d.config) && (d.config = d.config[s]), f = f.then(() => {
          if (o === this.guid)
            return new Promise((m) => this.diff(d).start(m));
        });
      }
    else if (Bt.fun(r.to)) {
      let u = 0, s;
      f = f.then(() => r.to(
        // next(props)
        (d) => {
          const m = pn({}, r, Bd(d));
          if (Bt.arr(m.config) && (m.config = m.config[u]), u++, o === this.guid)
            return s = new Promise((y) => this.diff(m).start(y));
        },
        // cancel()
        function(d) {
          return d === void 0 && (d = !0), a.stop(d);
        }
      ).then(() => s));
    }
    f.then(n);
  }
  diff(t) {
    this.props = pn({}, this.props, t);
    let n = this.props, a = n.from, r = a === void 0 ? {} : a, o = n.to, f = o === void 0 ? {} : o, u = n.config, s = u === void 0 ? {} : u, d = n.reverse, m = n.attach, y = n.reset, v = n.immediate;
    if (d) {
      var w = [f, r];
      r = w[0], f = w[1];
    }
    this.merged = pn({}, r, this.merged, f), this.hasChanged = !1;
    let E = m && m(this);
    if (this.animations = Object.entries(this.merged).reduce((O, T) => {
      let g = T[0], N = T[1], L = O[g] || {};
      const M = Bt.num(N), _ = Bt.str(N) && !N.startsWith("#") && !/\d/.test(N) && !ug[N], C = Bt.arr(N), H = !M && !C && !_;
      let I = Bt.und(r[g]) ? N : r[g], X = M || C || _ ? N : 1, te = Or(s, g);
      E && (X = E.animations[g].parent);
      let G = L.parent, F = L.interpolation, j = Xo(E ? X.getPayload() : X), U, W = N;
      H && (W = Ju({
        range: [0, 1],
        output: [N, N]
      })(1));
      let re = F && F.getValue();
      const ue = !Bt.und(G) && L.animatedValues.some((ye) => !ye.done), ee = !Bt.equ(W, re), Z = !Bt.equ(W, L.previous), se = !Bt.equ(te, L.config);
      if (y || Z && ee || se) {
        if (M || _)
          G = F = L.parent || new lf(I);
        else if (C)
          G = F = L.parent || new Lb(I);
        else if (H) {
          let ye = L.interpolation && L.interpolation.calc(L.parent.value);
          ye = ye !== void 0 && !y ? ye : I, L.parent ? (G = L.parent, G.setValue(0, !1)) : G = new lf(0);
          const me = {
            output: [ye, N]
          };
          L.interpolation ? (F = L.interpolation, L.interpolation.updateConfig(me)) : F = G.interpolate(me);
        }
        return j = Xo(E ? X.getPayload() : X), U = Xo(G.getPayload()), y && !H && G.setValue(I, !1), this.hasChanged = !0, U.forEach((ye) => {
          ye.startPosition = ye.value, ye.lastPosition = ye.value, ye.lastVelocity = ue ? ye.lastVelocity : void 0, ye.lastTime = ue ? ye.lastTime : void 0, ye.startTime = dg(), ye.done = !1, ye.animatedStyles.clear();
        }), Or(v, g) && G.setValue(H ? X : N, !1), pn({}, O, {
          [g]: pn({}, L, {
            name: g,
            parent: G,
            interpolation: F,
            animatedValues: U,
            toValues: j,
            previous: W,
            config: te,
            fromValues: Xo(G.getValue()),
            immediate: Or(v, g),
            initialVelocity: Ai(te.velocity, 0),
            clamp: Ai(te.clamp, !1),
            precision: Ai(te.precision, 0.01),
            tension: Ai(te.tension, 170),
            friction: Ai(te.friction, 26),
            mass: Ai(te.mass, 1),
            duration: te.duration,
            easing: Ai(te.easing, (ye) => ye),
            decay: te.decay
          })
        });
      } else
        return ee ? O : (H && (G.setValue(1, !1), F.updateConfig({
          output: [W, W]
        })), G.done = !0, this.hasChanged = !0, pn({}, O, {
          [g]: pn({}, O[g], {
            previous: W
          })
        }));
    }, this.animations), this.hasChanged) {
      this.configs = Object.values(this.animations), this.values = {}, this.interpolations = {};
      for (let O in this.animations)
        this.interpolations[O] = this.animations[O].interpolation, this.values[O] = this.animations[O].interpolation.getValue();
    }
    return this;
  }
  destroy() {
    this.stop(), this.props = {}, this.merged = {}, this.animations = {}, this.interpolations = {}, this.values = {}, this.configs = [], this.local = 0;
  }
}
let Ob = 0;
const Hu = "enter", Id = "leave", Hd = "update", Mb = (e, t) => (typeof t == "function" ? e.map(t) : Xo(t)).map(String), sf = (e) => {
  let t = e.items, n = e.keys, a = n === void 0 ? (o) => o : n, r = Xr(e, ["items", "keys"]);
  return t = Xo(t !== void 0 ? t : null), pn({
    items: t,
    keys: Mb(t, a)
  }, r);
};
function _b(e, t, n) {
  const a = pn({
    items: e,
    keys: t || ((N) => N)
  }, n), r = sf(a), o = r.lazy, f = o === void 0 ? !1 : o;
  r.unique;
  const u = r.reset, s = u === void 0 ? !1 : u;
  r.enter, r.leave, r.update;
  const d = r.onDestroyed;
  r.keys, r.items;
  const m = r.onFrame, y = r.onRest, v = r.onStart, w = r.ref, E = Xr(r, ["lazy", "unique", "reset", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]), O = lg(), T = ce.useRef(!1), g = ce.useRef({
    mounted: !1,
    first: !0,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!a.ref,
    instances: !T.current && /* @__PURE__ */ new Map(),
    forceUpdate: O
  });
  return ce.useImperativeHandle(a.ref, () => ({
    start: () => Promise.all(Array.from(g.current.instances).map((N) => {
      let L = N[1];
      return new Promise((M) => L.start(M));
    })),
    stop: (N) => Array.from(g.current.instances).forEach((L) => L[1].stop(N)),
    get controllers() {
      return Array.from(g.current.instances).map((N) => N[1]);
    }
  })), g.current = Nb(g.current, a), g.current.changed && g.current.transitions.forEach((N) => {
    const L = N.slot, M = N.from, _ = N.to, C = N.config, H = N.trail, I = N.key, X = N.item;
    g.current.instances.has(I) || g.current.instances.set(I, new Db());
    const te = g.current.instances.get(I), G = pn({}, E, {
      to: _,
      from: M,
      config: C,
      ref: w,
      onRest: (F) => {
        g.current.mounted && (N.destroyed && (!w && !f && kp(g, I), d && d(X)), !Array.from(g.current.instances).some((W) => !W[1].idle) && (w || f) && g.current.deleted.length > 0 && kp(g), y && y(X, L, F));
      },
      onStart: v && (() => v(X, L)),
      onFrame: m && ((F) => m(X, L, F)),
      delay: H,
      reset: s && L === Hu
      // Update controller
    });
    te.update(G), g.current.paused || te.start();
  }), ce.useEffect(() => (g.current.mounted = T.current = !0, () => {
    g.current.mounted = T.current = !1, Array.from(g.current.instances).map((N) => N[1].destroy()), g.current.instances.clear();
  }), []), g.current.transitions.map((N) => {
    let L = N.item, M = N.slot, _ = N.key;
    return {
      item: L,
      key: _,
      state: M,
      props: g.current.instances.get(_).getValues()
    };
  });
}
function kp(e, t) {
  const n = e.current.deleted;
  for (let a of n) {
    let r = a.key;
    const o = (f) => f.key !== r;
    (Bt.und(t) || t === r) && (e.current.instances.delete(r), e.current.transitions = e.current.transitions.filter(o), e.current.deleted = e.current.deleted.filter(o));
  }
  e.current.forceUpdate();
}
function Nb(e, t) {
  let n = e.first, a = e.prevProps, r = Xr(e, ["first", "prevProps"]), o = sf(t), f = o.items, u = o.keys, s = o.initial, d = o.from, m = o.enter, y = o.leave, v = o.update, w = o.trail, E = w === void 0 ? 0 : w, O = o.unique, T = o.config, g = o.order, N = g === void 0 ? [Hu, Id, Hd] : g, L = sf(a), M = L.keys, _ = L.items, C = pn({}, r.current), H = [...r.deleted], I = Object.keys(C), X = new Set(I), te = new Set(u), G = u.filter((re) => !X.has(re)), F = r.transitions.filter((re) => !re.destroyed && !te.has(re.originalKey)).map((re) => re.originalKey), j = u.filter((re) => X.has(re)), U = -E;
  for (; N.length; )
    switch (N.shift()) {
      case Hu: {
        G.forEach((J, ue) => {
          O && H.find((ye) => ye.originalKey === J) && (H = H.filter((ye) => ye.originalKey !== J));
          const ee = u.indexOf(J), Z = f[ee], se = n && s !== void 0 ? "initial" : Hu;
          C[J] = {
            slot: se,
            originalKey: J,
            key: O ? String(J) : Ob++,
            item: Z,
            trail: U = U + E,
            config: Or(T, Z, se),
            from: Or(n && s !== void 0 ? s || {} : d, Z),
            to: Or(m, Z)
          };
        });
        break;
      }
      case Id: {
        F.forEach((J) => {
          const ue = M.indexOf(J), ee = _[ue], Z = Id;
          H.unshift(pn({}, C[J], {
            slot: Z,
            destroyed: !0,
            left: M[Math.max(0, ue - 1)],
            right: M[Math.min(M.length, ue + 1)],
            trail: U = U + E,
            config: Or(T, ee, Z),
            to: Or(y, ee)
          })), delete C[J];
        });
        break;
      }
      case Hd: {
        j.forEach((J) => {
          const ue = u.indexOf(J), ee = f[ue], Z = Hd;
          C[J] = pn({}, C[J], {
            item: ee,
            slot: Z,
            trail: U = U + E,
            config: Or(T, ee, Z),
            to: Or(v, ee)
          });
        });
        break;
      }
    }
  let W = u.map((re) => C[re]);
  return H.forEach((re) => {
    let J = re.left;
    re.right;
    let ue = Xr(re, ["left", "right"]), ee;
    (ee = W.findIndex((Z) => Z.originalKey === J)) !== -1 && (ee += 1), ee = Math.max(0, ee), W = [...W.slice(0, ee), ue, ...W.slice(ee)];
  }), pn({}, r, {
    changed: G.length || F.length || j.length,
    first: n && G.length === 0,
    transitions: W,
    current: C,
    deleted: H,
    prevProps: t
  });
}
class Fb extends sg {
  constructor(t) {
    t === void 0 && (t = {}), super(), t.transform && !(t.transform instanceof Mr) && (t = Qf.transform(t)), this.payload = t;
  }
}
const tc = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, _r = "[-+]?\\d*\\.?\\d+", nc = _r + "%";
function Cc() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const zb = new RegExp("rgb" + Cc(_r, _r, _r)), $b = new RegExp("rgba" + Cc(_r, _r, _r, _r)), Bb = new RegExp("hsl" + Cc(_r, nc, nc)), Ib = new RegExp("hsla" + Cc(_r, nc, nc, _r)), Hb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Wb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Vb = /^#([0-9a-fA-F]{6})$/, jb = /^#([0-9a-fA-F]{8})$/;
function Ub(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = Vb.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : tc.hasOwnProperty(e) ? tc[e] : (t = zb.exec(e)) ? (jo(t[1]) << 24 | // r
  jo(t[2]) << 16 | // g
  jo(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = $b.exec(e)) ? (jo(t[1]) << 24 | // r
  jo(t[2]) << 16 | // g
  jo(t[3]) << 8 | // b
  Cp(t[4])) >>> // a
  0 : (t = Hb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = jb.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = Wb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = Bb.exec(e)) ? (wp(
    Tp(t[1]),
    // h
    Pu(t[2]),
    // s
    Pu(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = Ib.exec(e)) ? (wp(
    Tp(t[1]),
    // h
    Pu(t[2]),
    // s
    Pu(t[3])
    // l
  ) | Cp(t[4])) >>> // a
  0 : null;
}
function Wd(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function wp(e, t, n) {
  const a = n < 0.5 ? n * (1 + t) : n + t - n * t, r = 2 * n - a, o = Wd(r, a, e + 1 / 3), f = Wd(r, a, e), u = Wd(r, a, e - 1 / 3);
  return Math.round(o * 255) << 24 | Math.round(f * 255) << 16 | Math.round(u * 255) << 8;
}
function jo(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function Tp(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function Cp(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function Pu(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function Ap(e) {
  let t = Ub(e);
  if (t === null)
    return e;
  t = t || 0;
  let n = (t & 4278190080) >>> 24, a = (t & 16711680) >>> 16, r = (t & 65280) >>> 8, o = (t & 255) / 255;
  return `rgba(${n}, ${a}, ${r}, ${o})`;
}
const Lu = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Kb = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Yb = new RegExp(`(${Object.keys(tc).join("|")})`, "g"), Xb = (e) => {
  const t = e.output.map((r) => r.replace(Kb, Ap)).map((r) => r.replace(Yb, Ap)), n = t[0].match(Lu).map(() => []);
  t.forEach((r) => {
    r.match(Lu).forEach((o, f) => n[f].push(+o));
  });
  const a = t[0].match(Lu).map((r, o) => ec(pn({}, e, {
    output: n[o]
  })));
  return (r) => {
    let o = 0;
    return t[0].replace(Lu, () => a[o++](r)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (f, u, s, d, m) => `rgba(${Math.round(u)}, ${Math.round(s)}, ${Math.round(d)}, ${m})`);
  };
};
let ps = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const qb = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), Gb = ["Webkit", "Ms", "Moz", "O"];
ps = Object.keys(ps).reduce((e, t) => (Gb.forEach((n) => e[qb(n, t)] = e[t]), e), ps);
function Zb(e, t, n) {
  return t == null || typeof t == "boolean" || t === "" ? "" : !n && typeof t == "number" && t !== 0 && !(ps.hasOwnProperty(e) && ps[e]) ? t + "px" : ("" + t).trim();
}
const Pp = {};
bb((e) => new Fb(e));
vb(Xb);
yb(tc);
gb((e, t) => {
  if (e.nodeType && e.setAttribute !== void 0) {
    const r = t.style, o = t.children, f = t.scrollTop, u = t.scrollLeft, s = Xr(t, ["style", "children", "scrollTop", "scrollLeft"]), d = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter";
    f !== void 0 && (e.scrollTop = f), u !== void 0 && (e.scrollLeft = u), o !== void 0 && (e.textContent = o);
    for (let m in r)
      if (r.hasOwnProperty(m)) {
        var n = m.indexOf("--") === 0, a = Zb(m, r[m], n);
        m === "float" && (m = "cssFloat"), n ? e.style.setProperty(m, a) : e.style[m] = a;
      }
    for (let m in s) {
      const y = d ? m : Pp[m] || (Pp[m] = m.replace(/([A-Z])/g, (v) => "-" + v.toLowerCase()));
      typeof e.getAttribute(y) < "u" && e.setAttribute(y, s[m]);
    }
    return;
  } else
    return !1;
}, (e) => e);
const Qb = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Jb = hb(kb, !1), Lp = Jb(Qb);
function e0(e) {
  return e.innerRadius;
}
function t0(e) {
  return e.outerRadius;
}
function n0(e) {
  return e.startAngle;
}
function r0(e) {
  return e.endAngle;
}
function a0(e) {
  return e && e.padAngle;
}
function i0(e, t, n, a, r, o, f, u) {
  var s = n - e, d = a - t, m = f - r, y = u - o, v = y * s - m * d;
  if (!(v * v < Gn))
    return v = (m * (t - o) - y * (e - r)) / v, [e + v * s, t + v * d];
}
function Ru(e, t, n, a, r, o, f) {
  var u = e - n, s = t - a, d = (f ? o : -o) / Ko(u * u + s * s), m = d * s, y = -d * u, v = e + m, w = t + y, E = n + m, O = a + y, T = (v + E) / 2, g = (w + O) / 2, N = E - v, L = O - w, M = N * N + L * L, _ = r - o, C = v * O - E * w, H = (L < 0 ? -1 : 1) * Ko(Py(0, _ * _ * M - C * C)), I = (C * L - N * H) / M, X = (-C * N - L * H) / M, te = (C * L + N * H) / M, G = (-C * N + L * H) / M, F = I - T, j = X - g, U = te - T, W = G - g;
  return F * F + j * j > U * U + W * W && (I = te, X = G), {
    cx: I,
    cy: X,
    x01: -m,
    y01: -y,
    x11: I * (r / _ - 1),
    y11: X * (r / _ - 1)
  };
}
function o0() {
  var e = e0, t = t0, n = Wt(0), a = null, r = n0, o = r0, f = a0, u = null;
  function s() {
    var d, m, y = +e.apply(this, arguments), v = +t.apply(this, arguments), w = r.apply(this, arguments) - $h, E = o.apply(this, arguments) - $h, O = Bh(E - w), T = E > w;
    if (u || (u = d = wc()), v < y && (m = v, v = y, y = m), !(v > Gn))
      u.moveTo(0, 0);
    else if (O > Bu - Gn)
      u.moveTo(v * Ti(w), v * Wr(w)), u.arc(0, 0, v, w, E, !T), y > Gn && (u.moveTo(y * Ti(E), y * Wr(E)), u.arc(0, 0, y, E, w, T));
    else {
      var g = w, N = E, L = w, M = E, _ = O, C = O, H = f.apply(this, arguments) / 2, I = H > Gn && (a ? +a.apply(this, arguments) : Ko(y * y + v * v)), X = Rd(Bh(v - y) / 2, +n.apply(this, arguments)), te = X, G = X, F, j;
      if (I > Gn) {
        var U = Ih(I / y * Wr(H)), W = Ih(I / v * Wr(H));
        (_ -= U * 2) > Gn ? (U *= T ? 1 : -1, L += U, M -= U) : (_ = 0, L = M = (w + E) / 2), (C -= W * 2) > Gn ? (W *= T ? 1 : -1, g += W, N -= W) : (C = 0, g = N = (w + E) / 2);
      }
      var re = v * Ti(g), J = v * Wr(g), ue = y * Ti(M), ee = y * Wr(M);
      if (X > Gn) {
        var Z = v * Ti(N), se = v * Wr(N), ye = y * Ti(L), me = y * Wr(L), Le;
        if (O < zh && (Le = i0(re, J, ye, me, Z, se, ue, ee))) {
          var de = re - Le[0], ie = J - Le[1], Ce = Z - Le[0], He = se - Le[1], we = 1 / Wr(Ay((de * Ce + ie * He) / (Ko(de * de + ie * ie) * Ko(Ce * Ce + He * He))) / 2), ge = Ko(Le[0] * Le[0] + Le[1] * Le[1]);
          te = Rd(X, (y - ge) / (we - 1)), G = Rd(X, (v - ge) / (we + 1));
        }
      }
      C > Gn ? G > Gn ? (F = Ru(ye, me, re, J, v, G, T), j = Ru(Z, se, ue, ee, v, G, T), u.moveTo(F.cx + F.x01, F.cy + F.y01), G < X ? u.arc(F.cx, F.cy, G, qn(F.y01, F.x01), qn(j.y01, j.x01), !T) : (u.arc(F.cx, F.cy, G, qn(F.y01, F.x01), qn(F.y11, F.x11), !T), u.arc(0, 0, v, qn(F.cy + F.y11, F.cx + F.x11), qn(j.cy + j.y11, j.cx + j.x11), !T), u.arc(j.cx, j.cy, G, qn(j.y11, j.x11), qn(j.y01, j.x01), !T))) : (u.moveTo(re, J), u.arc(0, 0, v, g, N, !T)) : u.moveTo(re, J), !(y > Gn) || !(_ > Gn) ? u.lineTo(ue, ee) : te > Gn ? (F = Ru(ue, ee, Z, se, y, -te, T), j = Ru(re, J, ye, me, y, -te, T), u.lineTo(F.cx + F.x01, F.cy + F.y01), te < X ? u.arc(F.cx, F.cy, te, qn(F.y01, F.x01), qn(j.y01, j.x01), !T) : (u.arc(F.cx, F.cy, te, qn(F.y01, F.x01), qn(F.y11, F.x11), !T), u.arc(0, 0, y, qn(F.cy + F.y11, F.cx + F.x11), qn(j.cy + j.y11, j.cx + j.x11), T), u.arc(j.cx, j.cy, te, qn(j.y11, j.x11), qn(j.y01, j.x01), !T))) : u.arc(0, 0, y, M, L, T);
    }
    if (u.closePath(), d)
      return u = null, d + "" || null;
  }
  return s.centroid = function() {
    var d = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, m = (+r.apply(this, arguments) + +o.apply(this, arguments)) / 2 - zh / 2;
    return [Ti(m) * d, Wr(m) * d];
  }, s.innerRadius = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : Wt(+d), s) : e;
  }, s.outerRadius = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : Wt(+d), s) : t;
  }, s.cornerRadius = function(d) {
    return arguments.length ? (n = typeof d == "function" ? d : Wt(+d), s) : n;
  }, s.padRadius = function(d) {
    return arguments.length ? (a = d == null ? null : typeof d == "function" ? d : Wt(+d), s) : a;
  }, s.startAngle = function(d) {
    return arguments.length ? (r = typeof d == "function" ? d : Wt(+d), s) : r;
  }, s.endAngle = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : Wt(+d), s) : o;
  }, s.padAngle = function(d) {
    return arguments.length ? (f = typeof d == "function" ? d : Wt(+d), s) : f;
  }, s.context = function(d) {
    return arguments.length ? (u = d ?? null, s) : u;
  }, s;
}
function mg(e) {
  this._context = e;
}
mg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Ac(e) {
  return new mg(e);
}
function Jf(e) {
  return e[0];
}
function eh(e) {
  return e[1];
}
function gg() {
  var e = Jf, t = eh, n = Wt(!0), a = null, r = Ac, o = null;
  function f(u) {
    var s, d = u.length, m, y = !1, v;
    for (a == null && (o = r(v = wc())), s = 0; s <= d; ++s)
      !(s < d && n(m = u[s], s, u)) === y && ((y = !y) ? o.lineStart() : o.lineEnd()), y && o.point(+e(m, s, u), +t(m, s, u));
    if (v)
      return o = null, v + "" || null;
  }
  return f.x = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Wt(+u), f) : e;
  }, f.y = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Wt(+u), f) : t;
  }, f.defined = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : Wt(!!u), f) : n;
  }, f.curve = function(u) {
    return arguments.length ? (r = u, a != null && (o = r(a)), f) : r;
  }, f.context = function(u) {
    return arguments.length ? (u == null ? a = o = null : o = r(a = u), f) : a;
  }, f;
}
function l0() {
  var e = Jf, t = null, n = Wt(0), a = eh, r = Wt(!0), o = null, f = Ac, u = null;
  function s(m) {
    var y, v, w, E = m.length, O, T = !1, g, N = new Array(E), L = new Array(E);
    for (o == null && (u = f(g = wc())), y = 0; y <= E; ++y) {
      if (!(y < E && r(O = m[y], y, m)) === T)
        if (T = !T)
          v = y, u.areaStart(), u.lineStart();
        else {
          for (u.lineEnd(), u.lineStart(), w = y - 1; w >= v; --w)
            u.point(N[w], L[w]);
          u.lineEnd(), u.areaEnd();
        }
      T && (N[y] = +e(O, y, m), L[y] = +n(O, y, m), u.point(t ? +t(O, y, m) : N[y], a ? +a(O, y, m) : L[y]));
    }
    if (g)
      return u = null, g + "" || null;
  }
  function d() {
    return gg().defined(r).curve(f).context(o);
  }
  return s.x = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Wt(+m), t = null, s) : e;
  }, s.x0 = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Wt(+m), s) : e;
  }, s.x1 = function(m) {
    return arguments.length ? (t = m == null ? null : typeof m == "function" ? m : Wt(+m), s) : t;
  }, s.y = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Wt(+m), a = null, s) : n;
  }, s.y0 = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Wt(+m), s) : n;
  }, s.y1 = function(m) {
    return arguments.length ? (a = m == null ? null : typeof m == "function" ? m : Wt(+m), s) : a;
  }, s.lineX0 = s.lineY0 = function() {
    return d().x(e).y(n);
  }, s.lineY1 = function() {
    return d().x(e).y(a);
  }, s.lineX1 = function() {
    return d().x(t).y(n);
  }, s.defined = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : Wt(!!m), s) : r;
  }, s.curve = function(m) {
    return arguments.length ? (f = m, o != null && (u = f(o)), s) : f;
  }, s.context = function(m) {
    return arguments.length ? (m == null ? o = u = null : u = f(o = m), s) : o;
  }, s;
}
function s0(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function u0(e) {
  return e;
}
function c0() {
  var e = u0, t = s0, n = null, a = Wt(0), r = Wt(Bu), o = Wt(0);
  function f(u) {
    var s, d = u.length, m, y, v = 0, w = new Array(d), E = new Array(d), O = +a.apply(this, arguments), T = Math.min(Bu, Math.max(-Bu, r.apply(this, arguments) - O)), g, N = Math.min(Math.abs(T) / d, o.apply(this, arguments)), L = N * (T < 0 ? -1 : 1), M;
    for (s = 0; s < d; ++s)
      (M = E[w[s] = s] = +e(u[s], s, u)) > 0 && (v += M);
    for (t != null ? w.sort(function(_, C) {
      return t(E[_], E[C]);
    }) : n != null && w.sort(function(_, C) {
      return n(u[_], u[C]);
    }), s = 0, y = v ? (T - d * L) / v : 0; s < d; ++s, O = g)
      m = w[s], M = E[m], g = O + (M > 0 ? M * y : 0) + L, E[m] = {
        data: u[m],
        index: s,
        value: M,
        startAngle: O,
        endAngle: g,
        padAngle: N
      };
    return E;
  }
  return f.value = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Wt(+u), f) : e;
  }, f.sortValues = function(u) {
    return arguments.length ? (t = u, n = null, f) : t;
  }, f.sort = function(u) {
    return arguments.length ? (n = u, t = null, f) : n;
  }, f.startAngle = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : Wt(+u), f) : a;
  }, f.endAngle = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Wt(+u), f) : r;
  }, f.padAngle = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : Wt(+u), f) : o;
  }, f;
}
var uf = Array.prototype.slice;
function d0(e) {
  return e.source;
}
function f0(e) {
  return e.target;
}
function h0(e) {
  var t = d0, n = f0, a = Jf, r = eh, o = null;
  function f() {
    var u, s = uf.call(arguments), d = t.apply(this, s), m = n.apply(this, s);
    if (o || (o = u = wc()), e(o, +a.apply(this, (s[0] = d, s)), +r.apply(this, s), +a.apply(this, (s[0] = m, s)), +r.apply(this, s)), u)
      return o = null, u + "" || null;
  }
  return f.source = function(u) {
    return arguments.length ? (t = u, f) : t;
  }, f.target = function(u) {
    return arguments.length ? (n = u, f) : n;
  }, f.x = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : Wt(+u), f) : a;
  }, f.y = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Wt(+u), f) : r;
  }, f.context = function(u) {
    return arguments.length ? (o = u ?? null, f) : o;
  }, f;
}
function p0(e, t, n, a, r) {
  e.moveTo(t, n), e.bezierCurveTo(t = (t + a) / 2, n, t, r, a, r);
}
function m0() {
  return h0(p0);
}
function Wa() {
}
function rc(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function Pc(e) {
  this._context = e;
}
Pc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        rc(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        rc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function g0(e) {
  return new Pc(e);
}
function yg(e) {
  this._context = e;
}
yg.prototype = {
  areaStart: Wa,
  areaEnd: Wa,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        rc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function y0(e) {
  return new yg(e);
}
function vg(e) {
  this._context = e;
}
vg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, a = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, a) : this._context.moveTo(n, a);
        break;
      case 3:
        this._point = 4;
      default:
        rc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function v0(e) {
  return new vg(e);
}
function xg(e, t) {
  this._basis = new Pc(e), this._beta = t;
}
xg.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var a = e[0], r = t[0], o = e[n] - a, f = t[n] - r, u = -1, s; ++u <= n; )
        s = u / n, this._basis.point(
          this._beta * e[u] + (1 - this._beta) * (a + s * o),
          this._beta * t[u] + (1 - this._beta) * (r + s * f)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const x0 = function e(t) {
  function n(a) {
    return t === 1 ? new Pc(a) : new xg(a, t);
  }
  return n.beta = function(a) {
    return e(+a);
  }, n;
}(0.85);
function ac(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function th(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
th.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        ac(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        ac(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const b0 = function e(t) {
  function n(a) {
    return new th(a, t);
  }
  return n.tension = function(a) {
    return e(+a);
  }, n;
}(0);
function nh(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
nh.prototype = {
  areaStart: Wa,
  areaEnd: Wa,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        ac(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const S0 = function e(t) {
  function n(a) {
    return new nh(a, t);
  }
  return n.tension = function(a) {
    return e(+a);
  }, n;
}(0);
function rh(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
rh.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        ac(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const E0 = function e(t) {
  function n(a) {
    return new rh(a, t);
  }
  return n.tension = function(a) {
    return e(+a);
  }, n;
}(0);
function ah(e, t, n) {
  var a = e._x1, r = e._y1, o = e._x2, f = e._y2;
  if (e._l01_a > Gn) {
    var u = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, s = 3 * e._l01_a * (e._l01_a + e._l12_a);
    a = (a * u - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / s, r = (r * u - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / s;
  }
  if (e._l23_a > Gn) {
    var d = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, m = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * d + e._x1 * e._l23_2a - t * e._l12_2a) / m, f = (f * d + e._y1 * e._l23_2a - n * e._l12_2a) / m;
  }
  e._context.bezierCurveTo(a, r, o, f, e._x2, e._y2);
}
function bg(e, t) {
  this._context = e, this._alpha = t;
}
bg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        ah(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const k0 = function e(t) {
  function n(a) {
    return t ? new bg(a, t) : new th(a, 0);
  }
  return n.alpha = function(a) {
    return e(+a);
  }, n;
}(0.5);
function Sg(e, t) {
  this._context = e, this._alpha = t;
}
Sg.prototype = {
  areaStart: Wa,
  areaEnd: Wa,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        ah(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const w0 = function e(t) {
  function n(a) {
    return t ? new Sg(a, t) : new nh(a, 0);
  }
  return n.alpha = function(a) {
    return e(+a);
  }, n;
}(0.5);
function Eg(e, t) {
  this._context = e, this._alpha = t;
}
Eg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, a = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + a * a, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        ah(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const T0 = function e(t) {
  function n(a) {
    return t ? new Eg(a, t) : new rh(a, 0);
  }
  return n.alpha = function(a) {
    return e(+a);
  }, n;
}(0.5);
function kg(e) {
  this._context = e;
}
kg.prototype = {
  areaStart: Wa,
  areaEnd: Wa,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function cf(e) {
  return new kg(e);
}
function Rp(e) {
  return e < 0 ? -1 : 1;
}
function Dp(e, t, n) {
  var a = e._x1 - e._x0, r = t - e._x1, o = (e._y1 - e._y0) / (a || r < 0 && -0), f = (n - e._y1) / (r || a < 0 && -0), u = (o * r + f * a) / (a + r);
  return (Rp(o) + Rp(f)) * Math.min(Math.abs(o), Math.abs(f), 0.5 * Math.abs(u)) || 0;
}
function Op(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function Vd(e, t, n) {
  var a = e._x0, r = e._y0, o = e._x1, f = e._y1, u = (o - a) / 3;
  e._context.bezierCurveTo(a + u, r + u * t, o - u, f - u * n, o, f);
}
function ic(e) {
  this._context = e;
}
ic.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Vd(this, this._t0, Op(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Vd(this, Op(this, n = Dp(this, e, t)), n);
          break;
        default:
          Vd(this, this._t0, n = Dp(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function wg(e) {
  this._context = new Tg(e);
}
(wg.prototype = Object.create(ic.prototype)).point = function(e, t) {
  ic.prototype.point.call(this, t, e);
};
function Tg(e) {
  this._context = e;
}
Tg.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, a, r, o) {
    this._context.bezierCurveTo(t, e, a, n, o, r);
  }
};
function Wu(e) {
  return new ic(e);
}
function C0(e) {
  return new wg(e);
}
function Cg(e) {
  this._context = e;
}
Cg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var a = Mp(e), r = Mp(t), o = 0, f = 1; f < n; ++o, ++f)
          this._context.bezierCurveTo(a[0][o], r[0][o], a[1][o], r[1][o], e[f], t[f]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Mp(e) {
  var t, n = e.length - 1, a, r = new Array(n), o = new Array(n), f = new Array(n);
  for (r[0] = 0, o[0] = 2, f[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    r[t] = 1, o[t] = 4, f[t] = 4 * e[t] + 2 * e[t + 1];
  for (r[n - 1] = 2, o[n - 1] = 7, f[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    a = r[t] / o[t - 1], o[t] -= a, f[t] -= a * f[t - 1];
  for (r[n - 1] = f[n - 1] / o[n - 1], t = n - 2; t >= 0; --t)
    r[t] = (f[t] - r[t + 1]) / o[t];
  for (o[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t)
    o[t] = 2 * e[t + 1] - r[t + 1];
  return [r, o];
}
function A0(e) {
  return new Cg(e);
}
function Lc(e, t) {
  this._context = e, this._t = t;
}
Lc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function P0(e) {
  return new Lc(e, 0.5);
}
function L0(e) {
  return new Lc(e, 0);
}
function R0(e) {
  return new Lc(e, 1);
}
function tl(e, t) {
  if ((f = e.length) > 1)
    for (var n = 1, a, r, o = e[t[0]], f, u = o.length; n < f; ++n)
      for (r = o, o = e[t[n]], a = 0; a < u; ++a)
        o[a][1] += o[a][0] = isNaN(r[a][1]) ? r[a][0] : r[a][1];
}
function nl(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; )
    n[t] = t;
  return n;
}
function D0(e, t) {
  return e[t];
}
function ih() {
  var e = Wt([]), t = nl, n = tl, a = D0;
  function r(o) {
    var f = e.apply(this, arguments), u, s = o.length, d = f.length, m = new Array(d), y;
    for (u = 0; u < d; ++u) {
      for (var v = f[u], w = m[u] = new Array(s), E = 0, O; E < s; ++E)
        w[E] = O = [0, +a(o[E], v, E, o)], O.data = o[E];
      w.key = v;
    }
    for (u = 0, y = t(m); u < d; ++u)
      m[y[u]].index = u;
    return n(m, y), m;
  }
  return r.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Wt(uf.call(o)), r) : e;
  }, r.value = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : Wt(+o), r) : a;
  }, r.order = function(o) {
    return arguments.length ? (t = o == null ? nl : typeof o == "function" ? o : Wt(uf.call(o)), r) : t;
  }, r.offset = function(o) {
    return arguments.length ? (n = o ?? tl, r) : n;
  }, r;
}
function O0(e, t) {
  if ((a = e.length) > 0) {
    for (var n, a, r = 0, o = e[0].length, f; r < o; ++r) {
      for (f = n = 0; n < a; ++n)
        f += e[n][r][1] || 0;
      if (f)
        for (n = 0; n < a; ++n)
          e[n][r][1] /= f;
    }
    tl(e, t);
  }
}
function M0(e, t) {
  if ((s = e.length) > 0)
    for (var n, a = 0, r, o, f, u, s, d = e[t[0]].length; a < d; ++a)
      for (f = u = 0, n = 0; n < s; ++n)
        (o = (r = e[t[n]][a])[1] - r[0]) > 0 ? (r[0] = f, r[1] = f += o) : o < 0 ? (r[1] = u, r[0] = u += o) : (r[0] = 0, r[1] = o);
}
function _0(e, t) {
  if ((r = e.length) > 0) {
    for (var n = 0, a = e[t[0]], r, o = a.length; n < o; ++n) {
      for (var f = 0, u = 0; f < r; ++f)
        u += e[f][n][1] || 0;
      a[n][1] += a[n][0] = -u / 2;
    }
    tl(e, t);
  }
}
function N0(e, t) {
  if (!(!((f = e.length) > 0) || !((o = (r = e[t[0]]).length) > 0))) {
    for (var n = 0, a = 1, r, o, f; a < o; ++a) {
      for (var u = 0, s = 0, d = 0; u < f; ++u) {
        for (var m = e[t[u]], y = m[a][1] || 0, v = m[a - 1][1] || 0, w = (y - v) / 2, E = 0; E < u; ++E) {
          var O = e[t[E]], T = O[a][1] || 0, g = O[a - 1][1] || 0;
          w += T - g;
        }
        s += y, d += w * y;
      }
      r[a - 1][1] += r[a - 1][0] = n, s && (n -= d / s);
    }
    r[a - 1][1] += r[a - 1][0] = n, tl(e, t);
  }
}
function F0(e) {
  var t = e.map(z0);
  return nl(e).sort(function(n, a) {
    return t[n] - t[a];
  });
}
function z0(e) {
  for (var t = -1, n = 0, a = e.length, r, o = -1 / 0; ++t < a; )
    (r = +e[t][1]) > o && (o = r, n = t);
  return n;
}
function Ag(e) {
  var t = e.map(Pg);
  return nl(e).sort(function(n, a) {
    return t[n] - t[a];
  });
}
function Pg(e) {
  for (var t = 0, n = -1, a = e.length, r; ++n < a; )
    (r = +e[n][1]) && (t += r);
  return t;
}
function $0(e) {
  return Ag(e).reverse();
}
function B0(e) {
  var t = e.length, n, a, r = e.map(Pg), o = F0(e), f = 0, u = 0, s = [], d = [];
  for (n = 0; n < t; ++n)
    a = o[n], f < u ? (f += r[a], s.push(a)) : (u += r[a], d.push(a));
  return d.reverse().concat(s);
}
function I0(e) {
  return nl(e).reverse();
}
function kn(e, t) {
  e(t);
}
var _p = {
  ascending: Ag,
  descending: $0,
  insideout: B0,
  none: nl,
  reverse: I0
};
function oh(e) {
  return e && _p[e] || _p.none;
}
var Np = {
  expand: O0,
  diverging: M0,
  none: tl,
  silhouette: _0,
  wiggle: N0
};
function lh(e) {
  return e && Np[e] || Np.none;
}
function H0(e) {
  var t = e === void 0 ? {} : e, n = t.innerRadius, a = t.outerRadius, r = t.cornerRadius, o = t.startAngle, f = t.endAngle, u = t.padAngle, s = t.padRadius, d = o0();
  return n != null && kn(d.innerRadius, n), a != null && kn(d.outerRadius, a), r != null && kn(d.cornerRadius, r), o != null && kn(d.startAngle, o), f != null && kn(d.endAngle, f), u != null && kn(d.padAngle, u), s != null && kn(d.padRadius, s), d;
}
function sh(e) {
  var t = e === void 0 ? {} : e, n = t.x, a = t.x0, r = t.x1, o = t.y, f = t.y0, u = t.y1, s = t.defined, d = t.curve, m = l0();
  return n && kn(m.x, n), a && kn(m.x0, a), r && kn(m.x1, r), o && kn(m.y, o), f && kn(m.y0, f), u && kn(m.y1, u), s && m.defined(s), d && m.curve(d), m;
}
function Lg(e) {
  var t = e === void 0 ? {} : e, n = t.x, a = t.y, r = t.defined, o = t.curve, f = gg();
  return n && kn(f.x, n), a && kn(f.y, a), r && f.defined(r), o && f.curve(o), f;
}
function W0(e) {
  var t = e === void 0 ? {} : e, n = t.startAngle, a = t.endAngle, r = t.padAngle, o = t.value, f = t.sort, u = t.sortValues, s = c0();
  return (f === null || f != null) && s.sort(f), (u === null || u != null) && s.sortValues(u), o != null && s.value(o), r != null && kn(s.padAngle, r), n != null && kn(s.startAngle, n), a != null && kn(s.endAngle, a), s;
}
function V0(e) {
  var t = e.keys, n = e.value, a = e.order, r = e.offset, o = ih();
  return t && o.keys(t), n && kn(o.value, n), a && o.order(oh(a)), r && o.offset(lh(r)), o;
}
var j0 = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function df() {
  return df = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, df.apply(this, arguments);
}
function U0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function K0(e) {
  var t = e.className, n = e.top, a = e.left, r = e.data, o = r === void 0 ? [] : r, f = e.centroid, u = e.innerRadius, s = u === void 0 ? 0 : u, d = e.outerRadius, m = e.cornerRadius, y = e.startAngle, v = e.endAngle, w = e.padAngle, E = e.padRadius, O = e.pieSort, T = e.pieSortValues, g = e.pieValue, N = e.children, L = e.fill, M = L === void 0 ? "" : L, _ = U0(e, j0), C = H0({
    innerRadius: s,
    outerRadius: d,
    cornerRadius: m,
    padRadius: E
  }), H = W0({
    startAngle: y,
    endAngle: v,
    padAngle: w,
    value: g,
    sort: O,
    sortValues: T
  }), I = H(o);
  return N ? /* @__PURE__ */ i.createElement(i.Fragment, null, N({
    arcs: I,
    path: C,
    pie: H
  })) : /* @__PURE__ */ i.createElement(at, {
    className: "visx-pie-arcs-group",
    top: n,
    left: a
  }, I.map(function(X, te) {
    return /* @__PURE__ */ i.createElement("g", {
      key: "pie-arc-" + te
    }, /* @__PURE__ */ i.createElement("path", df({
      className: Pn("visx-pie-arc", t),
      d: C(X) || "",
      fill: M == null || typeof M == "string" ? M : M(X)
    }, _)), f == null ? void 0 : f(C.centroid(X), X));
  }));
}
var Y0 = ["from", "to", "fill", "className", "innerRef"];
function ff() {
  return ff = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, ff.apply(this, arguments);
}
function X0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function an(e) {
  var t = e.from, n = t === void 0 ? {
    x: 0,
    y: 0
  } : t, a = e.to, r = a === void 0 ? {
    x: 1,
    y: 1
  } : a, o = e.fill, f = o === void 0 ? "transparent" : o, u = e.className, s = e.innerRef, d = X0(e, Y0), m = n.x === r.x || n.y === r.y;
  return /* @__PURE__ */ i.createElement("line", ff({
    ref: s,
    className: Pn("visx-line", u),
    x1: n.x,
    y1: n.y,
    x2: r.x,
    y2: r.y,
    fill: f,
    shapeRendering: m ? "crispEdges" : "auto"
  }, d));
}
var q0 = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function hf() {
  return hf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, hf.apply(this, arguments);
}
function G0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function qr(e) {
  var t = e.children, n = e.data, a = n === void 0 ? [] : n, r = e.x, o = e.y, f = e.fill, u = f === void 0 ? "transparent" : f, s = e.className, d = e.curve, m = e.innerRef, y = e.defined, v = y === void 0 ? function() {
    return !0;
  } : y, w = G0(e, q0), E = Lg({
    x: r,
    y: o,
    defined: v,
    curve: d
  });
  return t ? /* @__PURE__ */ i.createElement(i.Fragment, null, t({
    path: E
  })) : /* @__PURE__ */ i.createElement("path", hf({
    ref: m,
    className: Pn("visx-linepath", s),
    d: E(a) || "",
    fill: u,
    strokeLinecap: "round"
  }, w));
}
var Z0 = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function pf() {
  return pf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, pf.apply(this, arguments);
}
function Q0(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function J0(e) {
  var t = e.children, n = e.x, a = e.x0, r = e.x1, o = e.y, f = e.y0, u = e.y1, s = e.data, d = s === void 0 ? [] : s, m = e.defined, y = m === void 0 ? function() {
    return !0;
  } : m, v = e.className, w = e.curve, E = e.innerRef, O = Q0(e, Z0), T = sh({
    x: n,
    x0: a,
    x1: r,
    y: o,
    y0: f,
    y1: u,
    defined: y,
    curve: w
  });
  return t ? /* @__PURE__ */ i.createElement(i.Fragment, null, t({
    path: T
  })) : /* @__PURE__ */ i.createElement("path", pf({
    ref: E,
    className: Pn("visx-area", v),
    d: T(d) || ""
  }, O));
}
var eS = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function mf() {
  return mf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, mf.apply(this, arguments);
}
function tS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function nS(e) {
  var t = e.x, n = e.x0, a = e.x1, r = e.y, o = e.y1, f = e.y0, u = e.yScale, s = e.data, d = s === void 0 ? [] : s, m = e.defined, y = m === void 0 ? function() {
    return !0;
  } : m, v = e.className, w = e.curve, E = e.innerRef, O = e.children, T = tS(e, eS), g = sh({
    x: t,
    x0: n,
    x1: a,
    defined: y,
    curve: w
  });
  return f == null ? g.y0(u.range()[0]) : kn(g.y0, f), r && !o && kn(g.y1, r), o && !r && kn(g.y1, o), O ? /* @__PURE__ */ i.createElement(i.Fragment, null, O({
    path: g
  })) : /* @__PURE__ */ i.createElement("path", mf({
    ref: E,
    className: Pn("visx-area-closed", v),
    d: g(d) || ""
  }, T));
}
var rS = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function gf() {
  return gf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, gf.apply(this, arguments);
}
function aS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function iS(e) {
  var t = e.className, n = e.top, a = e.left, r = e.keys, o = e.data, f = e.curve, u = e.defined, s = e.x, d = e.x0, m = e.x1, y = e.y0, v = e.y1, w = e.value, E = e.order, O = e.offset, T = e.color, g = e.children, N = aS(e, rS), L = V0({
    keys: r,
    value: w,
    order: E,
    offset: O
  }), M = sh({
    x: s,
    x0: d,
    x1: m,
    y0: y,
    y1: v,
    curve: f,
    defined: u
  }), _ = L(o);
  return g ? /* @__PURE__ */ i.createElement(i.Fragment, null, g({
    stacks: _,
    path: M,
    stack: L
  })) : /* @__PURE__ */ i.createElement(at, {
    top: n,
    left: a
  }, _.map(function(C, H) {
    return /* @__PURE__ */ i.createElement("path", gf({
      className: Pn("visx-stack", t),
      key: "stack-" + H + "-" + (C.key || ""),
      d: M(C) || "",
      fill: T == null ? void 0 : T(C.key, H)
    }, N));
  }));
}
var oS = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function oc() {
  return oc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, oc.apply(this, arguments);
}
function lS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function sS(e) {
  var t = e.className, n = e.top, a = e.left, r = e.keys, o = e.data, f = e.curve, u = e.defined, s = e.x, d = e.x0, m = e.x1, y = e.y0, v = e.y1, w = e.value, E = e.order, O = e.offset, T = e.color, g = e.children, N = lS(e, oS);
  return /* @__PURE__ */ i.createElement(iS, oc({
    className: t,
    top: n,
    left: a,
    keys: r,
    data: o,
    curve: f,
    defined: u,
    x: s,
    x0: d,
    x1: m,
    y0: y,
    y1: v,
    value: w,
    order: E,
    offset: O,
    color: T
  }, N), g || function(L) {
    var M = L.stacks, _ = L.path;
    return M.map(function(C, H) {
      return /* @__PURE__ */ i.createElement("path", oc({
        className: Pn("visx-area-stack", t),
        key: "area-stack-" + H + "-" + (C.key || ""),
        d: _(C) || "",
        fill: T == null ? void 0 : T(C.key, H)
      }, N));
    });
  });
}
function uh(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), n = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / n.length;
}
var uS = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function yf() {
  return yf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, yf.apply(this, arguments);
}
function cS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function Rg(e) {
  var t = e.data, n = e.className, a = e.top, r = e.left, o = e.x0, f = e.x0Scale, u = e.x1Scale, s = e.yScale, d = e.color, m = e.keys, y = e.height, v = e.children, w = cS(e, uS), E = uh(u), O = t.map(function(T, g) {
    return {
      index: g,
      x0: f(o(T)),
      bars: m.map(function(N, L) {
        var M = T[N];
        return {
          index: L,
          key: N,
          value: M,
          width: E,
          x: u(N) || 0,
          y: s(M) || 0,
          color: d(N, L),
          height: y - (s(M) || 0)
        };
      })
    };
  });
  return v ? /* @__PURE__ */ i.createElement(i.Fragment, null, v(O)) : /* @__PURE__ */ i.createElement(at, {
    className: Pn("visx-bar-group", n),
    top: a,
    left: r
  }, O.map(function(T) {
    return /* @__PURE__ */ i.createElement(at, {
      key: "bar-group-" + T.index + "-" + T.x0,
      left: T.x0
    }, T.bars.map(function(g) {
      return /* @__PURE__ */ i.createElement(gr, yf({
        key: "bar-group-bar-" + T.index + "-" + g.index + "-" + g.value + "-" + g.key,
        x: g.x,
        y: g.y,
        width: g.width,
        height: g.height,
        fill: g.color
      }, w));
    }));
  }));
}
function Dg(e) {
  return e == null ? void 0 : e[0];
}
function Og(e) {
  return e == null ? void 0 : e[1];
}
var dS = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function vf() {
  return vf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, vf.apply(this, arguments);
}
function fS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function hS(e) {
  var t = e.data, n = e.className, a = e.top, r = e.left, o = e.x, f = e.y0, u = f === void 0 ? Dg : f, s = e.y1, d = s === void 0 ? Og : s, m = e.xScale, y = e.yScale, v = e.color, w = e.keys, E = e.value, O = e.order, T = e.offset, g = e.children, N = fS(e, dS), L = ih();
  w && L.keys(w), E && kn(L.value, E), O && L.order(oh(O)), T && L.offset(lh(T));
  var M = L(t), _ = uh(m), C = M.map(function(H, I) {
    var X = H.key;
    return {
      index: I,
      key: X,
      bars: H.map(function(te, G) {
        var F = (y(u(te)) || 0) - (y(d(te)) || 0), j = y(d(te)), U = "bandwidth" in m ? m(o(te.data)) : Math.max((m(o(te.data)) || 0) - _ / 2);
        return {
          bar: te,
          key: X,
          index: G,
          height: F,
          width: _,
          x: U || 0,
          y: j || 0,
          color: v(H.key, G)
        };
      })
    };
  });
  return g ? /* @__PURE__ */ i.createElement(i.Fragment, null, g(C)) : /* @__PURE__ */ i.createElement(at, {
    className: Pn("visx-bar-stack", n),
    top: a,
    left: r
  }, C.map(function(H) {
    return H.bars.map(function(I) {
      return /* @__PURE__ */ i.createElement(gr, vf({
        key: "bar-stack-" + H.index + "-" + I.index,
        x: I.x,
        y: I.y,
        height: I.height,
        width: I.width,
        fill: I.color
      }, N));
    });
  }));
}
var pS = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function xf() {
  return xf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, xf.apply(this, arguments);
}
function mS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function gS(e) {
  var t = e.data, n = e.className, a = e.top, r = e.left, o = e.y, f = e.x0, u = f === void 0 ? Dg : f, s = e.x1, d = s === void 0 ? Og : s, m = e.xScale, y = e.yScale, v = e.color, w = e.keys, E = e.value, O = e.order, T = e.offset, g = e.children, N = mS(e, pS), L = ih();
  w && L.keys(w), E && kn(L.value, E), O && L.order(oh(O)), T && L.offset(lh(T));
  var M = L(t), _ = uh(y), C = M.map(function(H, I) {
    var X = H.key;
    return {
      index: I,
      key: X,
      bars: H.map(function(te, G) {
        var F = (m(d(te)) || 0) - (m(u(te)) || 0), j = m(u(te)), U = "bandwidth" in y ? y(o(te.data)) : Math.max((y(o(te.data)) || 0) - F / 2);
        return {
          bar: te,
          key: X,
          index: G,
          height: _,
          width: F,
          x: j || 0,
          y: U || 0,
          color: v(H.key, G)
        };
      })
    };
  });
  return g ? /* @__PURE__ */ i.createElement(i.Fragment, null, g(C)) : /* @__PURE__ */ i.createElement(at, {
    className: Pn("visx-bar-stack-horizontal", n),
    top: a,
    left: r
  }, C.map(function(H) {
    return H.bars.map(function(I) {
      return /* @__PURE__ */ i.createElement(gr, xf({
        key: "bar-stack-" + H.index + "-" + I.index,
        x: I.x,
        y: I.y,
        height: I.height,
        width: I.width,
        fill: I.color
      }, N));
    });
  }));
}
var Fp = "http://www.w3.org/2000/svg";
function yS(e) {
  var t = document.getElementById(e);
  if (!t) {
    var n = document.createElementNS(Fp, "svg");
    n.setAttribute("aria-hidden", "true"), n.style.opacity = "0", n.style.width = "0", n.style.height = "0", n.style.position = "absolute", n.style.top = "-100%", n.style.left = "-100%", n.style.pointerEvents = "none", t = document.createElementNS(Fp, "path"), t.setAttribute("id", e), n.appendChild(t), document.body.appendChild(n);
  }
  return t;
}
var vS = "__visx_splitpath_svg_path_measurement_id", zp = function() {
  return !0;
};
function xS(e) {
  var t = e.path, n = e.pointsInSegments, a = e.segmentation, r = a === void 0 ? "x" : a, o = e.sampleRate, f = o === void 0 ? 1 : o;
  try {
    var u = yS(vS);
    u.setAttribute("d", t);
    var s = u.getTotalLength(), d = n.length, m = n.map(function() {
      return [];
    });
    if (r === "x" || r === "y")
      for (var y = n.map(function(j) {
        var U;
        return (U = j.find(function(W) {
          return typeof W[r] == "number";
        })) == null ? void 0 : U[r];
      }), v = u.getPointAtLength(0), w = u.getPointAtLength(s), E = w[r] > v[r], O = E ? y.map(function(j) {
        return typeof j > "u" ? zp : function(U) {
          return U >= j;
        };
      }) : y.map(function(j) {
        return typeof j > "u" ? zp : function(U) {
          return U <= j;
        };
      }), T = 0, g = 0; g <= s; g += f) {
        for (var N = u.getPointAtLength(g), L = N[r]; T < d - 1 && O[T + 1](L); )
          T += 1;
        m[T].push(N);
      }
    else {
      var M = n.map(function(j) {
        return j.length;
      }), _ = M.reduce(function(j, U) {
        return j + U;
      }, 0), C = s / Math.max(1, _ - 1), H = M.slice(0, d - 1);
      H.unshift(0);
      for (var I = 2; I < d; I += 1)
        H[I] += H[I - 1];
      for (var X = 0; X < d; X += 1)
        H[X] *= C;
      for (var te = 0, G = 0; G <= s; G += f) {
        for (var F = u.getPointAtLength(G); te < d - 1 && G >= H[te + 1]; )
          te += 1;
        m[te].push(F);
      }
    }
    return m;
  } catch {
    return [];
  }
}
function bf() {
  return bf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, bf.apply(this, arguments);
}
var bS = function(t) {
  return t.x || 0;
}, SS = function(t) {
  return t.y || 0;
};
function Mg(e) {
  var t = e.children, n = e.className, a = e.curve, r = e.defined, o = e.segmentation, f = e.sampleRate, u = e.segments, s = e.x, d = e.y, m = e.styles, y = ce.useMemo(function() {
    var E = typeof s == "number" || typeof s > "u" ? function() {
      return s;
    } : s, O = typeof d == "number" || typeof d > "u" ? function() {
      return d;
    } : d;
    return u.map(function(T) {
      return T.map(function(g, N) {
        return {
          x: E(g, N, T),
          y: O(g, N, T)
        };
      });
    });
  }, [s, d, u]), v = ce.useMemo(function() {
    var E = Lg({
      x: s,
      y: d,
      defined: r,
      curve: a
    });
    return E(u.flat()) || "";
  }, [s, d, r, a, u]), w = ce.useMemo(function() {
    return xS({
      path: v,
      segmentation: o,
      pointsInSegments: y,
      sampleRate: f
    });
  }, [v, o, y, f]);
  return /* @__PURE__ */ i.createElement("g", null, w.map(function(E, O) {
    return t ? /* @__PURE__ */ i.createElement(i.Fragment, {
      key: O
    }, t({
      index: O,
      segment: E,
      styles: m[O] || m[O % m.length]
    })) : /* @__PURE__ */ i.createElement(qr, bf({
      key: O,
      className: n,
      data: E,
      x: bS,
      y: SS
    }, m[O] || m[O % m.length]));
  }));
}
Mg.propTypes = {
  segments: he.arrayOf(he.array).isRequired,
  styles: he.array.isRequired,
  children: he.func,
  className: he.string
};
var ES = ["tooltipOpen"];
function kS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function lc() {
  return lc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, lc.apply(this, arguments);
}
function _g(e) {
  var t = ce.useState(lc({
    tooltipOpen: !1
  }, e)), n = t[0], a = t[1], r = ce.useCallback(function(f) {
    return a(typeof f == "function" ? function(u) {
      u.tooltipOpen;
      var s = kS(u, ES);
      return lc({}, f(s), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: f.tooltipLeft,
      tooltipTop: f.tooltipTop,
      tooltipData: f.tooltipData
    });
  }, [a]), o = ce.useCallback(function() {
    return a({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [a]);
  return {
    tooltipOpen: n.tooltipOpen,
    tooltipLeft: n.tooltipLeft,
    tooltipTop: n.tooltipTop,
    tooltipData: n.tooltipData,
    updateTooltip: a,
    showTooltip: r,
    hideTooltip: o
  };
}
var wS = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function sc() {
  return sc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, sc.apply(this, arguments);
}
function TS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var Ng = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, ch = /* @__PURE__ */ i.forwardRef(function(e, t) {
  var n = e.className, a = e.top, r = e.left, o = e.offsetLeft, f = o === void 0 ? 10 : o, u = e.offsetTop, s = u === void 0 ? 10 : u, d = e.style, m = d === void 0 ? Ng : d, y = e.children, v = e.unstyled, w = v === void 0 ? !1 : v, E = e.applyPositionStyle, O = E === void 0 ? !1 : E, T = TS(e, wS);
  return /* @__PURE__ */ i.createElement("div", sc({
    ref: t,
    className: Pn("visx-tooltip", n),
    style: sc({
      top: a == null || s == null ? a : a + s,
      left: r == null || f == null ? r : r + f
    }, O && {
      position: "absolute"
    }, !w && m)
  }, T), y);
});
ch.propTypes = {
  children: he.node,
  className: he.string,
  left: he.number,
  offsetLeft: he.number,
  offsetTop: he.number,
  top: he.number,
  applyPositionStyle: he.bool,
  unstyled: he.bool
};
ch.displayName = "Tooltip";
const CS = ch;
function Sf() {
  return Sf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Sf.apply(this, arguments);
}
function AS(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function PS(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Ef(e, t);
}
function Ef(e, t) {
  return Ef = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, r) {
    return a.__proto__ = r, a;
  }, Ef(e, t);
}
var $p = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function LS(e) {
  var t;
  return t = /* @__PURE__ */ function(n) {
    PS(a, n);
    function a(o) {
      var f;
      return f = n.call(this, o) || this, f.state = {
        rect: void 0,
        parentRect: void 0
      }, f.nodeRef = /* @__PURE__ */ i.createRef(), f.getRects = f.getRects.bind(AS(f)), f;
    }
    var r = a.prototype;
    return r.componentDidMount = function() {
      var f, u = this;
      this.node = (f = this.nodeRef) != null && f.current ? this.nodeRef.current : Iy.findDOMNode(this), this.setState(function() {
        return u.getRects();
      });
    }, r.getRects = function() {
      if (!this.node)
        return this.state;
      var f = this.node, u = f.parentNode, s = f.getBoundingClientRect ? f.getBoundingClientRect() : $p, d = u != null && u.getBoundingClientRect ? u.getBoundingClientRect() : $p;
      return {
        rect: s,
        parentRect: d
      };
    }, r.render = function() {
      return /* @__PURE__ */ i.createElement(e, Sf({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, a;
  }(i.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var Fg = /* @__PURE__ */ ce.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), RS = Fg.Provider;
Fg.Consumer;
var DS = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function uc() {
  return uc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, uc.apply(this, arguments);
}
function OS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function zg(e) {
  var t = e.children;
  e.getRects;
  var n = e.left, a = n === void 0 ? 0 : n, r = e.offsetLeft, o = r === void 0 ? 10 : r, f = e.offsetTop, u = f === void 0 ? 10 : f, s = e.parentRect, d = e.rect, m = e.style, y = m === void 0 ? Ng : m, v = e.top, w = v === void 0 ? 0 : v, E = e.unstyled, O = E === void 0 ? !1 : E, T = e.nodeRef, g = OS(e, DS), N, L = !1, M = !1;
  if (d && s) {
    var _ = a, C = w;
    if (s.width) {
      var H = _ + o + d.width - s.width, I = d.width - _ - o;
      L = H > 0 && H > I;
    } else {
      var X = _ + o + d.width - window.innerWidth, te = d.width - _ - o;
      L = X > 0 && X > te;
    }
    if (s.height) {
      var G = C + u + d.height - s.height, F = d.height - C - u;
      M = G > 0 && G > F;
    } else
      M = C + u + d.height > window.innerHeight;
    _ = L ? _ - d.width - o : _ + o, C = M ? C - d.height - u : C + u, _ = Math.round(_), C = Math.round(C), N = "translate(" + _ + "px, " + C + "px)";
  }
  return /* @__PURE__ */ i.createElement(CS, uc({
    ref: T,
    style: uc({
      left: 0,
      top: 0,
      transform: N
    }, !O && y)
  }, g), /* @__PURE__ */ i.createElement(RS, {
    value: {
      isFlippedVertically: !M,
      isFlippedHorizontally: !L
    }
  }, t));
}
zg.propTypes = {
  nodeRef: he.oneOfType([he.string, he.func, he.object])
};
const $g = LS(zg);
var rl = /* @__PURE__ */ function() {
  function e(n) {
    var a = n.x, r = a === void 0 ? 0 : a, o = n.y, f = o === void 0 ? 0 : o;
    this.x = 0, this.y = 0, this.x = r, this.y = f;
  }
  var t = e.prototype;
  return t.value = function() {
    return {
      x: this.x,
      y: this.y
    };
  }, t.toArray = function() {
    return [this.x, this.y];
  }, e;
}();
function MS(e, t) {
  return new rl({
    x: e.x + t.x,
    y: e.y + t.y
  });
}
function _S(e, t) {
  return new rl({
    x: e.x - t.x,
    y: e.y - t.y
  });
}
const NS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Point: rl,
  subtractPoints: _S,
  sumPoints: MS
}, Symbol.toStringTag, { value: "Module" }));
function FS(e) {
  return !!e && e instanceof Element;
}
function zS(e) {
  return !!e && (e instanceof SVGElement || "ownerSVGElement" in e);
}
function $S(e) {
  return !!e && "createSVGPoint" in e;
}
function BS(e) {
  return !!e && "getScreenCTM" in e;
}
function IS(e) {
  return !!e && "changedTouches" in e;
}
function HS(e) {
  return !!e && "clientX" in e;
}
function WS(e) {
  return !!e && (e instanceof Event || "nativeEvent" in e && e.nativeEvent instanceof Event);
}
function ms() {
  return ms = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, ms.apply(this, arguments);
}
var jd = {
  x: 0,
  y: 0
};
function VS(e) {
  if (!e)
    return ms({}, jd);
  if (IS(e))
    return e.changedTouches.length > 0 ? {
      x: e.changedTouches[0].clientX,
      y: e.changedTouches[0].clientY
    } : ms({}, jd);
  if (HS(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  var t = e == null ? void 0 : e.target, n = t && "getBoundingClientRect" in t ? t.getBoundingClientRect() : null;
  return n ? {
    x: n.x + n.width / 2,
    y: n.y + n.height / 2
  } : ms({}, jd);
}
function kf(e, t) {
  if (!e || !t)
    return null;
  var n = VS(t), a = zS(e) ? e.ownerSVGElement : e, r = BS(a) ? a.getScreenCTM() : null;
  if ($S(a) && r) {
    var o = a.createSVGPoint();
    return o.x = n.x, o.y = n.y, o = o.matrixTransform(r.inverse()), new rl({
      x: o.x,
      y: o.y
    });
  }
  var f = e.getBoundingClientRect();
  return new rl({
    x: n.x - f.left - e.clientLeft,
    y: n.y - f.top - e.clientTop
  });
}
function wf(e, t) {
  if (FS(e) && t)
    return kf(e, t);
  if (WS(e)) {
    var n = e, a = n.target;
    if (a)
      return kf(a, n);
  }
  return null;
}
const jS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  localPoint: wf,
  touchPoint: kf
}, Symbol.toStringTag, { value: "Module" })), Bg = (e) => {
  const { tableData: t, config: n, formatNumber: a, capitalize: r, formatDate: o, formatTooltipsDate: f, parseDate: u, setSharedFilter: s } = ce.useContext(Pt), { xScale: d, yScale: m, showTooltip: y, hideTooltip: v } = e, { xAxis: w, visualizationType: E, orientation: O, yAxis: T, runtime: g } = n, N = (U, W) => {
    const { x: re, y: J } = W, ee = {
      data: U || {},
      dataXPosition: re + 10,
      dataYPosition: J
    };
    return {
      tooltipLeft: ee.dataXPosition,
      tooltipTop: ee.dataYPosition,
      tooltipData: ee
    };
  }, L = (U, W) => {
    U.stopPropagation();
    const re = wf(U), { x: J, y: ue } = re, { data: ee, arc: Z } = W ?? {}, se = C(J - Number(n.yAxis.size || 0)), ye = E !== "Pie" ? n.series.filter((ke) => ke.tooltip === !0).map((ke) => ke.dataKey) : n.series.map((ke) => ke.dataKey);
    ye.push(n.xAxis.dataKey), n.visualizationType === "Forecasting" && n.series.map((ke) => {
      ke.confidenceIntervals.map((ne) => {
        ne.showInTooltip && (ye.push(ne.high), ye.push(ne.low));
      });
    });
    function me(ke) {
      let ne = [];
      for (let Pe in ke)
        ke.hasOwnProperty(Pe) && ne.push(ke[Pe].name);
      return ne;
    }
    ye.push(...me(n.columns)), ye.push(...me(n.columns));
    const Le = X(se, ye), de = t.filter((ke) => ke[w.dataKey] === H(ue)), ie = O === "vertical" ? Le : de, Ce = (ke) => {
      const ne = n.series.filter(($e) => $e.dataKey === ke)[0];
      return ne != null && ne.axis ? String(ne.axis).toLowerCase() : "left";
    }, we = (() => {
      var qe, Ge, Xe;
      const ke = n.columns, ne = [], Pe = [];
      for (const [We, vt] of Object.entries(ke)) {
        const et = {
          addColPrefix: n.columns[We].prefix,
          addColSuffix: n.columns[We].suffix,
          addColRoundTo: n.columns[We].roundToPlace ? n.columns[We].roundToPlace : "",
          addColCommas: n.columns[We].commas
        };
        let Ke = null;
        n.visualizationType === "Pie" ? Ke = Z == null ? void 0 : Z.data[vt.name] : Ke = (qe = ie[0]) == null ? void 0 : qe[vt.name];
        const Be = Sm(Ke, "left", !0, n, et);
        vt.tooltips && ne.push([vt.label, Be]);
      }
      const $e = [];
      return ne.forEach((We) => {
        $e.push([We[0], We[1]]);
      }), E === "Pie" && Pe.push(
        // ignore
        [n.xAxis.dataKey, ee],
        [n.runtime.yAxis.dataKey, a(Z == null ? void 0 : Z.data[n.runtime.yAxis.dataKey])],
        ["Percent", `${Math.round(((Z == null ? void 0 : Z.endAngle) - (Z == null ? void 0 : Z.startAngle)) * 180 / Math.PI / 360 * 100) + "%"}`]
      ), E === "Forest Plot" && Pe.push([n.xAxis.dataKey, H(ue)]), E !== "Pie" && E !== "Forest Plot" && Pe.push(
        ...(Xe = (Ge = te()) == null ? void 0 : Ge.filter((We) => {
          var vt, et;
          return ((vt = n.series) == null ? void 0 : vt.find((Ke) => Ke.dataKey === We && (Ke == null ? void 0 : Ke.tooltip))) || ((et = n.xAxis) == null ? void 0 : et.dataKey) == We;
        })) == null ? void 0 : Xe.flatMap((We) => {
          var Ke, Be, ze, gt;
          let vt = We === n.xAxis.dataKey ? (Ke = ie[0]) == null ? void 0 : Ke[We] : a((Be = ie[0]) == null ? void 0 : Be[We], Ce(We));
          const et = (ze = n.preliminaryData) == null ? void 0 : ze.find((Ye) => {
            var dt;
            return Ye.label && Ye.type === "suppression" && Ye.displayTooltip && ((dt = ie[0]) == null ? void 0 : dt[We]) === Ye.value && (!Ye.column || We === Ye.column);
          });
          return et && (vt = et.label), (gt = ie == null ? void 0 : ie[0]) != null && gt[We] ? [[We, vt, Ce(We)]] : [];
        })
      ), [...Pe, ...$e];
    })();
    if (!we)
      return;
    const ge = N(we, re);
    y(ge);
  }, M = () => {
    n.visualizationType === "Area Chart" ? setTimeout(() => {
      v();
    }, 3e3) : v();
  }, _ = (U) => {
    if (n.xAxis.type === "categorical" || n.visualizationType === "Combo") {
      let W = d.step();
      const J = Math.floor(Number(U) / W);
      return d.domain()[J - 1];
    }
    if (Cn(n.xAxis) && n.visualizationType !== "Combo") {
      const W = Gh((ee) => u(ee[n.xAxis.dataKey])).left, re = d.invert(d(U)), J = W(n.data, re, 1);
      return u(n.data[J - 1][n.xAxis.dataKey]);
    }
  }, C = (U, W = !1) => {
    if (E !== "Pie" && O !== "horizontal") {
      if (d.type === "point" || w.type === "continuous" || Cn(w)) {
        let re = null, J = Number.MAX_VALUE, ue = U;
        return t.forEach((ee) => {
          const Z = Cn(w) ? d(u(ee[w.dataKey])) : d(ee[w.dataKey]);
          let se = n.barHeight;
          const ye = Math.abs(Number(Z - ue + (W ? se * 2 : 0)));
          ye <= J && (J = ye, re = (Cn(w), ee[w.dataKey]));
        }), re;
      }
      if (n.xAxis.type === "categorical" || E === "Combo" && O !== "horizontal" && E !== "Forest Plot") {
        let J = (d.range()[1] - d.range()[0]) / (d.domain().length + 1);
        const ee = Math.floor((Number(U) - J / 2) / J);
        return d.domain()[ee];
      }
      if (Cn(w) && E !== "Combo" && O !== "horizontal") {
        const re = Gh((Z) => u(Z[n.xAxis.dataKey])).left, J = d.invert(U), ue = re(n.data, J, 1);
        return u(n.data[ue - 1][n.xAxis.dataKey]);
      }
    }
  }, H = (U, W) => {
    if (E === "Pie")
      return;
    let re = Number.MAX_VALUE, J = null;
    return t.forEach((ue, ee) => {
      const Z = m(E !== "Forest Plot" ? ue[n.xAxis.dataKey] : ee), se = Math.abs(Z - U);
      se < re && (re = se, J = W ? ue[W] : ue[n.xAxis.dataKey]);
    }), J;
  }, I = (U) => {
    var W, re;
    try {
      const J = wf(U), { x: ue } = J;
      if (!ue)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let ee = C(ue, !0), Z = (W = n.data) == null ? void 0 : W.filter((se) => se[n.xAxis.dataKey] === ee);
      if (!ee)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (Cn(w) && ee && (ee = new Date(ee), ee = o(ee), Z = (re = n.data) == null ? void 0 : re.filter((se) => o(new Date(se[n.xAxis.dataKey])) === ee)), !Z[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${ee}`);
      s && (n != null && n.uid) && (Z != null && Z[0]) && s(n.uid, Z[0]);
    } catch (J) {
      console.error(J.message);
    }
  }, X = (U, W) => {
    try {
      let re;
      return w.type === "categorical" ? re = t.filter((ue) => ue[w.dataKey] === U) : re = t.filter((ue) => ue[w.dataKey] === U), !re || re.length === 0 ? [] : re.map((ue) => Object.fromEntries(Object.entries(ue).filter(([ee, Z]) => W.includes(ee))));
    } catch (re) {
      console.error("COVE", re);
    }
  }, te = () => {
    var U;
    try {
      let W, re = [], J = [];
      if ((U = n.series) == null || U.forEach((ue) => {
        ue.type === "Forecasting" && (re.push(ue.stageColumn), ue == null || ue.confidenceIntervals.forEach((ee) => {
          ee.showInTooltip === !0 && (J.push(ee.low), J.push(ee.high));
        }));
      }), !n.dashboard)
        switch (E) {
          case "Combo":
            W = [g.xAxis.dataKey, ...g == null ? void 0 : g.seriesKeys, ...J];
            break;
          case "Forecasting":
            W = [g.xAxis.dataKey, ...re, ...J];
            break;
          case "Line":
            W = [g.xAxis.dataKey, ...g == null ? void 0 : g.seriesKeys];
            break;
          case "Area Chart":
            W = [g.xAxis.dataKey, ...g == null ? void 0 : g.seriesKeys];
            break;
          case "Bar":
            W = O === "vertical" ? [g.xAxis.dataKey, ...g == null ? void 0 : g.seriesKeys] : [g.yAxis.dataKey, ...g == null ? void 0 : g.seriesKeys];
            break;
          case "Pie":
            W = [g.xAxis.dataKey, ...g == null ? void 0 : g.seriesKeys];
          default:
            throw new Error("No visualization type found in handleTooltipMouseOver");
        }
      return n.dashboard && (W = [g.xAxis.dataKey, ...g == null ? void 0 : g.barSeriesKeys, ...g == null ? void 0 : g.lineSeriesKeys, ...re, ...J]), W;
    } catch (W) {
      console.error("COVE", W);
    }
  }, G = (U) => {
    const { dataXPosition: W, dataYPosition: re } = U;
    return {
      opacity: n.tooltips.opacity ? n.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${W}px, ${Number(re)}px)`
    };
  }, F = (U) => {
    var re, J;
    let W = n.series.filter((ue) => ue.dataKey === U);
    return (re = W[0]) != null && re.name ? (J = W[0]) == null ? void 0 : J.name : U;
  };
  return {
    getIncludedTooltipSeries: te,
    getXValueFromCoordinate: C,
    getXValueFromCoordinateDate: _,
    getYScaleValues: X,
    handleTooltipClick: I,
    handleTooltipMouseOff: M,
    handleTooltipMouseOver: L,
    TooltipListItem: ({ item: U }) => {
      const [W, re] = U, [J, ue, ee] = re;
      if (E === "Forest Plot")
        return J === n.xAxis.dataKey ? /* @__PURE__ */ i.createElement("li", { className: "tooltip-heading" }, `${r(n.xAxis.dataKey ? `${n.xAxis.dataKey}: ` : "")} ${Cn(T) ? o(u(J, !1)) : ue}`) : /* @__PURE__ */ i.createElement("li", { className: "tooltip-body" }, `${F(J)}: ${a(ue, "left")}`);
      const Z = n.tooltips.dateDisplayFormat ? f(u(ue, !1)) : o(u(ue, !1));
      return E === "Bar" && O === "horizontal" && J === n.xAxis.dataKey ? /* @__PURE__ */ i.createElement("li", { className: "tooltip-heading" }, `${r(n.runtime.yAxis.label ? `${n.runtime.yAxis.label}: ` : "")} ${n.xAxis.type === "date" ? Z : ue}`) : J === n.xAxis.dataKey ? /* @__PURE__ */ i.createElement("li", { className: "tooltip-heading" }, `${r(n.runtime.xAxis.label ? `${n.runtime.xAxis.label}: ` : "")} ${Cn(w) ? Z : ue}`) : /* @__PURE__ */ i.createElement("li", { className: "tooltip-body" }, `${F(J)}: ${ue}`);
    },
    tooltipStyles: G
  };
};
function dh(e, { threshold: t = 0, root: n = null, rootMargin: a = "0%", freezeOnceVisible: r = !1 }) {
  const [o, f] = ce.useState(), u = (o == null ? void 0 : o.isIntersecting) && r, s = ([d]) => {
    f(d);
  };
  return ce.useEffect(() => {
    setTimeout(() => {
      const d = e == null ? void 0 : e.current;
      if (!!!window.IntersectionObserver || u || !d)
        return;
      const y = { threshold: t, root: n, rootMargin: a }, v = new IntersectionObserver(s, y);
      return v.observe(d), () => v.disconnect();
    }, 500);
  }, [e, t, n, a, u]), o;
}
const Tf = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let n = "";
    return e.visualizationType && (n += `${e.visualizationType} chart`), e.title && e.visualizationType && (n += ` with the title: ${e.title}`), n;
  } catch (n) {
    console.error("COVE: ", n.message);
  }
};
var US = ["flexDirection", "alignItems", "margin", "display", "children"];
function Cf() {
  return Cf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Cf.apply(this, arguments);
}
function KS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function cc(e) {
  var t = e.flexDirection, n = t === void 0 ? "row" : t, a = e.alignItems, r = a === void 0 ? "center" : a, o = e.margin, f = o === void 0 ? "0" : o, u = e.display, s = u === void 0 ? "flex" : u, d = e.children, m = KS(e, US);
  return /* @__PURE__ */ i.createElement("div", Cf({
    className: "visx-legend-item",
    style: {
      display: s,
      alignItems: r,
      flexDirection: n,
      margin: f
    }
  }, m), d);
}
cc.propTypes = {
  alignItems: he.string,
  margin: he.oneOfType([he.string, he.number]),
  children: he.node,
  display: he.string
};
var YS = ["flex", "label", "margin", "align", "children"];
function Af() {
  return Af = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Af.apply(this, arguments);
}
function XS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function dc(e) {
  var t = e.flex, n = t === void 0 ? "1" : t, a = e.label, r = e.margin, o = r === void 0 ? "5px 0" : r, f = e.align, u = f === void 0 ? "left" : f, s = e.children, d = XS(e, YS);
  return /* @__PURE__ */ i.createElement("div", Af({
    className: "visx-legend-label",
    style: {
      justifyContent: u,
      display: "flex",
      flex: n,
      margin: o
    }
  }, d), s || a);
}
dc.propTypes = {
  align: he.string,
  label: he.node,
  flex: he.oneOfType([he.string, he.number]),
  margin: he.oneOfType([he.string, he.number]),
  children: he.node
};
function Pf() {
  return Pf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Pf.apply(this, arguments);
}
function fh(e) {
  var t = e.fill, n = e.width, a = e.height, r = e.style;
  return /* @__PURE__ */ i.createElement("div", {
    style: Pf({
      width: n,
      height: a,
      background: t
    }, r)
  });
}
fh.propTypes = {
  fill: he.string,
  width: he.oneOfType([he.string, he.number]),
  height: he.oneOfType([he.string, he.number])
};
function Ig(e) {
  var t = e.fill, n = e.width, a = e.height, r = e.style, o = typeof n == "string" || typeof n > "u" ? 0 : n, f = typeof a == "string" || typeof a > "u" ? 0 : a, u = Math.max(o, f), s = u / 2;
  return /* @__PURE__ */ i.createElement("svg", {
    width: u,
    height: u
  }, /* @__PURE__ */ i.createElement(at, {
    top: s,
    left: s
  }, /* @__PURE__ */ i.createElement("circle", {
    r: s,
    fill: t,
    style: r
  })));
}
Ig.propTypes = {
  fill: he.string,
  width: he.oneOfType([he.string, he.number]),
  height: he.oneOfType([he.string, he.number])
};
function Hg(e) {
  var t = e.fill, n = e.width, a = e.height, r = e.style, o = typeof a == "string" || typeof a > "u" ? 0 : a, f = typeof (r == null ? void 0 : r.strokeWidth) == "number" ? r == null ? void 0 : r.strokeWidth : 2;
  return /* @__PURE__ */ i.createElement("svg", {
    width: n,
    height: a
  }, /* @__PURE__ */ i.createElement(at, {
    top: o / 2 - f / 2
  }, /* @__PURE__ */ i.createElement("line", {
    x1: 0,
    x2: n,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: f,
    style: r
  })));
}
Hg.propTypes = {
  fill: he.string,
  width: he.oneOfType([he.string, he.number]),
  height: he.oneOfType([he.string, he.number])
};
function gs() {
  return gs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, gs.apply(this, arguments);
}
var Ud = function() {
};
function qS(e) {
  var t = e.shape, n = t === void 0 ? "rect" : t, a = e.fill, r = a === void 0 ? Ud : a, o = e.size, f = o === void 0 ? Ud : o, u = e.width, s = e.height, d = e.label, m = e.item, y = e.itemIndex, v = e.shapeStyle, w = v === void 0 ? Ud : v, E = {
    width: u,
    height: s,
    item: m,
    itemIndex: y,
    label: d,
    fill: r(gs({}, d)),
    size: f(gs({}, d)),
    style: w(gs({}, d))
  };
  return typeof n == "string" ? n === "circle" ? /* @__PURE__ */ i.createElement(Ig, E) : n === "line" ? /* @__PURE__ */ i.createElement(Hg, E) : /* @__PURE__ */ i.createElement(fh, E) : /* @__PURE__ */ i.isValidElement(n) ? /* @__PURE__ */ i.cloneElement(n, E) : n ? /* @__PURE__ */ i.createElement(n, E) : null;
}
function fc() {
  return fc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, fc.apply(this, arguments);
}
function Wg(e) {
  var t = e.shape, n = t === void 0 ? fh : t, a = e.width, r = e.height, o = e.margin, f = e.label, u = e.item, s = e.itemIndex, d = e.fill, m = e.size, y = e.shapeStyle;
  return /* @__PURE__ */ i.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: m ? m(fc({}, f)) : a,
      height: m ? m(fc({}, f)) : r,
      margin: o
    }
  }, qS({
    shape: n,
    item: u,
    itemIndex: s,
    label: f,
    width: a,
    height: r,
    fill: d,
    shapeStyle: y
  }));
}
Wg.propTypes = {
  itemIndex: he.number.isRequired,
  margin: he.oneOfType([he.string, he.number]),
  width: he.oneOfType([he.string, he.number]),
  height: he.oneOfType([he.string, he.number])
};
function Vg(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function Bp(e) {
  return String(Vg(e));
}
function GS(e) {
  var t = e.scale, n = e.labelFormat;
  return function(a, r) {
    return {
      datum: a,
      index: r,
      text: "" + n(a, r),
      value: t(a)
    };
  };
}
var ZS = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function ys() {
  return ys = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, ys.apply(this, arguments);
}
function QS(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var JS = {
  display: "flex"
};
function jg(e) {
  var t = e.className, n = e.style, a = n === void 0 ? JS : n, r = e.scale, o = e.shape, f = e.domain, u = e.fill, s = u === void 0 ? Bp : u, d = e.size, m = d === void 0 ? Bp : d, y = e.labelFormat, v = y === void 0 ? Vg : y, w = e.labelTransform, E = w === void 0 ? GS : w, O = e.shapeWidth, T = O === void 0 ? 15 : O, g = e.shapeHeight, N = g === void 0 ? 15 : g, L = e.shapeMargin, M = L === void 0 ? "2px 4px 2px 0" : L, _ = e.shapeStyle, C = e.labelAlign, H = C === void 0 ? "left" : C, I = e.labelFlex, X = I === void 0 ? "1" : I, te = e.labelMargin, G = te === void 0 ? "0 4px" : te, F = e.itemMargin, j = F === void 0 ? "0" : F, U = e.direction, W = U === void 0 ? "column" : U, re = e.itemDirection, J = re === void 0 ? "row" : re, ue = e.legendLabelProps, ee = e.children, Z = QS(e, ZS), se = f || ("domain" in r ? r.domain() : []), ye = E({
    scale: r,
    labelFormat: v
  }), me = se.map(ye);
  return ee ? /* @__PURE__ */ i.createElement(i.Fragment, null, ee(me)) : /* @__PURE__ */ i.createElement("div", {
    className: Pn("visx-legend", t),
    style: ys({}, a, {
      flexDirection: W
    })
  }, me.map(function(Le, de) {
    return /* @__PURE__ */ i.createElement(cc, ys({
      key: "legend-" + Le.text + "-" + de,
      margin: j,
      flexDirection: J
    }, Z), /* @__PURE__ */ i.createElement(Wg, {
      shape: o,
      height: N,
      width: T,
      margin: M,
      item: se[de],
      itemIndex: de,
      label: Le,
      fill: s,
      size: m,
      shapeStyle: _
    }), /* @__PURE__ */ i.createElement(dc, ys({
      label: Le.text,
      flex: X,
      margin: G,
      align: H
    }, ue)));
  }));
}
jg.propTypes = {
  children: he.func,
  className: he.string,
  domain: he.array,
  shapeWidth: he.oneOfType([he.string, he.number]),
  shapeHeight: he.oneOfType([he.string, he.number]),
  shapeMargin: he.oneOfType([he.string, he.number]),
  labelAlign: he.string,
  labelFlex: he.oneOfType([he.string, he.number]),
  labelMargin: he.oneOfType([he.string, he.number]),
  itemMargin: he.oneOfType([he.string, he.number]),
  fill: he.func,
  size: he.func,
  shapeStyle: he.func
};
function eE(e) {
  return /* @__PURE__ */ i.createElement(jg, e);
}
function tE(e) {
  let t = ["legend-container"], n = ["legend-container__inner"];
  return e.legend.position === "left" && t.push("left"), e.legend.position === "bottom" && (t.push("bottom"), n.push("bottom")), e.legend.position === "bottom" && e.legend.singleRow && n.push("single-row"), e.legend.reverseLabelOrder && (n.push("d-flex"), n.push("flex-column-reverse")), e.legend.position === "bottom" && e.legend.verticalSorted && n.push("vertical-sorted"), {
    containerClasses: t,
    innerClasses: n
  };
}
const Rc = (e, t) => {
  var O;
  const { formatDate: n, parseDate: a } = ce.useContext(Pt);
  let r = [], o = "", f = [], u = [];
  ((O = e.series) == null ? void 0 : O.length) > 0 && e.data ? (r = e.series[0], o = e.series[0].dataKey, f = e.highlightedBarValues, u = e.data.map((T) => T[e.xAxis.dataKey])) : (r = [], o = "", f = [], u = []);
  const s = (T, g) => {
    const N = [...e.highlightedBarValues];
    N[g].borderWidth = T.target.value, t({
      ...e,
      highlightedBarValues: N
    });
  }, d = (T, g) => {
    T.preventDefault();
    const N = [...e.highlightedBarValues];
    N[g].value = T.target.value, N[g].dataKey = o, t({
      ...e,
      highlightedBarValues: N
    });
  }, m = (T, g) => {
    T.preventDefault();
    const N = [...e.highlightedBarValues];
    N.push({ dataKey: o }), t({
      ...e,
      highlightedBarValues: N
    });
  }, y = (T, g) => {
    T.preventDefault();
    const N = [...e.highlightedBarValues];
    N.splice(g, 1), t({
      ...e,
      highlightedBarValues: N
    });
  }, v = (T, g) => {
    const N = [...e.highlightedBarValues];
    N[g].color = T.target.value, t({
      ...e
    });
  }, w = (T, g) => {
    const N = [...e.highlightedBarValues];
    N[g].legendLabel = T.target.value, t({
      ...e,
      copyOfHighlightedBarValues: N
    });
  }, E = () => {
  };
  return E.checkFontColor = (T, g, N) => {
    if (e.xAxis.type === "date") {
      if (E.formatDates(g).includes(T))
        return "#000";
    } else if (g.includes(T))
      return "#000";
    return N;
  }, E.formatDates = (T) => T.map((g) => g ? n(a(g)) : !1), E.findDuplicates = (T) => {
    const g = {};
    return T == null ? void 0 : T.filter((L) => {
      const { legendLabel: M } = L;
      return g[M] ? !1 : (g[M] = !0, !0);
    });
  }, {
    HighLightedBarUtils: E,
    highlightedSeries: r,
    highlightedSeriesKey: o,
    highlightedBarValues: f,
    highlightedSeriesValues: u,
    handleUpdateHighlightedBar: d,
    handleAddNewHighlightedBar: m,
    handleRemoveHighlightedBar: y,
    handleUpdateHighlightedBarColor: v,
    handleHighlightedBarLegendLabel: w,
    handleUpdateHighlightedBorderWidth: s
  };
}, Ug = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, Kg = ce.forwardRef(({ config: e, colorScale: t, seriesHighlight: n, highlight: a, highlightReset: r, currentViewport: o, formatLabels: f, skipId: u = "legend" }, s) => {
  const { innerClasses: d, containerClasses: m } = tE(e), { runtime: y, legend: v } = e;
  if (!v)
    return null;
  const w = (v == null ? void 0 : v.position) === "bottom" || ["sm", "xs", "xxs"].includes(o) && !v.hide, E = {
    marginBottom: w ? "15px" : "0px",
    marginTop: w && orientation === "horizontal" ? `${e.yAxis.label && e.isResponsiveTicks ? e.dynamicMarginTop : e.runtime.xAxis.size}px` : `${w ? (e.dynamicMarginTop || 0) + 15 : 0}px`
  }, { HighLightedBarUtils: O } = Rc(e);
  let T = O.findDuplicates(e.highlightedBarValues);
  return /* @__PURE__ */ i.createElement("aside", { ref: s, style: E, id: u || "legend", className: m.join(" "), role: "region", "aria-label": "legend", tabIndex: 0 }, v.label && /* @__PURE__ */ i.createElement("h3", null, Mi(v.label)), v.description && /* @__PURE__ */ i.createElement("p", null, Mi(v.description)), /* @__PURE__ */ i.createElement(eE, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0" }, (g) => {
    var N, L, M, _;
    return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("div", { className: d.join(" ") }, f(g).map((C, H) => {
      var te, G, F, j;
      let I = ["legend-item", `legend-text--${C.text.replace(" ", "").toLowerCase()}`], X = C.datum;
      if (e.exclusions.active && ((te = e.exclusions.keys) != null && te.includes(X)))
        return null;
      if (y.seriesLabels) {
        let U = e.runtime.seriesLabelsAll.indexOf(X);
        X = e.runtime.seriesKeys[U], ((G = y == null ? void 0 : y.forecastingSeriesKeys) == null ? void 0 : G.length) > 0 && (X = C.text);
      }
      return n.length > 0 && n.includes(X) === !1 && I.push("inactive"), /* @__PURE__ */ i.createElement(
        cc,
        {
          className: I.join(" "),
          tabIndex: 0,
          key: `legend-quantile-${H}`,
          onKeyDown: (U) => {
            U.key === "Enter" && (U.preventDefault(), a(C));
          },
          onClick: (U) => {
            U.preventDefault(), a(C);
          },
          role: "button"
        },
        /* @__PURE__ */ i.createElement("div", null, e.visualizationType === "Line" && e.legend.lineMode ? /* @__PURE__ */ i.createElement("svg", { width: 40, height: 20 }, /* @__PURE__ */ i.createElement(an, { from: { x: 10, y: 10 }, to: { x: 40, y: 10 }, stroke: C.value, strokeWidth: 2, strokeDasharray: Ug((F = e.series[H]) != null && F.type ? (j = e.series[H]) == null ? void 0 : j.type : "") })) : /* @__PURE__ */ i.createElement("div", { style: { display: "flex", flexDirection: "column" } }, /* @__PURE__ */ i.createElement(Wh, { viewport: o, margin: "0", fill: C.value, display: !0 }))),
        /* @__PURE__ */ i.createElement(dc, { align: "left", margin: "0 0 0 4px" }, C.text)
      );
    }), T.map((C, H) => {
      let I = "legend-item", X = C.legendLabel;
      return X ? (n.length > 0 && n.includes(X) === !1 && (I += " inactive"), /* @__PURE__ */ i.createElement(
        cc,
        {
          className: I,
          tabIndex: 0,
          key: `legend-quantile-${H}`,
          onKeyDown: (te) => {
            te.key === "Enter" && (te.preventDefault(), a(C.legendLabel));
          },
          onClick: (te) => {
            te.preventDefault(), a(C.legendLabel);
          }
        },
        /* @__PURE__ */ i.createElement(Wh, { fill: "transparent", borderColor: C.color ? C.color : "rgba(255, 102, 1)" }),
        " ",
        /* @__PURE__ */ i.createElement(dc, { align: "left", margin: "0 0 0 4px" }, C.legendLabel ? C.legendLabel : C.value)
      )) : !1;
    })), /* @__PURE__ */ i.createElement(i.Fragment, null, ((N = e == null ? void 0 : e.preliminaryData) == null ? void 0 : N.some((C) => C.label && C.type === "effect" && C.style)) && ["Line", "Combo"].includes(e.visualizationType) && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("hr", null), /* @__PURE__ */ i.createElement("div", { className: e.legend.singleRow && w ? "legend-container__inner bottom single-row" : "" }, (L = e == null ? void 0 : e.preliminaryData) == null ? void 0 : L.map((C, H) => /* @__PURE__ */ i.createElement(i.Fragment, null, C.label && C.type === "effect" && C.style && /* @__PURE__ */ i.createElement("div", { key: H, className: "legend-preliminary" }, /* @__PURE__ */ i.createElement("span", { className: C.symbol }, C.lineCode), /* @__PURE__ */ i.createElement("p", null, " ", C.label)))))), !e.legend.hideSuppressedLabels && ((M = e == null ? void 0 : e.preliminaryData) == null ? void 0 : M.some((C) => C.label && C.displayLegend && C.type === "suppression" && C.value && ((C == null ? void 0 : C.style) || C.symbol))) && (e.visualizationType === "Bar" && e.visualizationSubType === "regular" || e.visualizationType === "Line" || e.visualizationType === "Combo") && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("hr", null), /* @__PURE__ */ i.createElement("div", { className: e.legend.singleRow && w ? "legend-container__inner bottom single-row" : "" }, (_ = e == null ? void 0 : e.preliminaryData) == null ? void 0 : _.map(
      (C, H) => C.displayLegend && C.type === "suppression" && /* @__PURE__ */ i.createElement(i.Fragment, null, e.visualizationType === "Bar" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("div", { key: H + "Bar", className: `legend-preliminary ${C.symbol}` }, /* @__PURE__ */ i.createElement("span", { className: C.symbol }, C.iconCode), /* @__PURE__ */ i.createElement("p", { className: C.type }, C.label))), e.visualizationType === "Line" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("div", { key: H + "Line", className: "legend-preliminary " }, /* @__PURE__ */ i.createElement("span", null, C.lineCode), /* @__PURE__ */ i.createElement("p", { className: C.type }, C.label))), e.visualizationType === "Combo" && /* @__PURE__ */ i.createElement(i.Fragment, null, C.symbol && C.iconCode && /* @__PURE__ */ i.createElement("div", { key: H + "Combo", className: `legend-preliminary ${C.symbol}` }, /* @__PURE__ */ i.createElement("span", { className: C.symbol }, C.iconCode), /* @__PURE__ */ i.createElement("p", { className: C.type }, C.label)), C.style && C.lineCode && /* @__PURE__ */ i.createElement("div", { key: H + "Combo", className: "legend-preliminary" }, /* @__PURE__ */ i.createElement("span", null, C.lineCode), /* @__PURE__ */ i.createElement("p", null, C.label))))
    )))));
  }), n.length > 0 && /* @__PURE__ */ i.createElement(Vf, { onClick: (g) => r(g), style: { marginTop: "1rem" } }, "Reset"));
});
function nE(e) {
  return Ly({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" } }] })(e);
}
const Yg = (e, t, n, a) => (r) => {
  var v, w, E, O, T;
  const { visualizationType: o, visualizationSubType: f, series: u, runtime: s } = e, d = (g) => {
    var N;
    return e.legend.reverseLabelOrder && ((N = e.legend) == null ? void 0 : N.position) === "bottom" ? g.reverse() : g;
  }, m = (v = e.legend) == null ? void 0 : v.colorCode;
  if (o === "Deviation Bar") {
    const [g, N] = Ku[e.twoColor.palette], L = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: g
    }, M = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: N
    };
    return d([L, M]);
  }
  if (o === "Bar" && f === "regular" && m && (u == null ? void 0 : u.length) === 1) {
    let g = dr[e.palette];
    for (; t.length > g.length; )
      g = g.concat(g);
    g = g.slice(0, n.length);
    const N = /* @__PURE__ */ new Set();
    t.forEach((M) => N.add(M[m]));
    const L = Array.from(N).map((M, _) => ({
      datum: M,
      index: _,
      text: M,
      value: g[_]
    }));
    return d(L);
  }
  if (((w = s == null ? void 0 : s.forecastingSeriesKeys) == null ? void 0 : w.length) > 0) {
    let g = [];
    return (O = (E = e.runtime) == null ? void 0 : E.forecastingSeriesKeys) == null || O.map((N, L) => {
      var M;
      return (M = N == null ? void 0 : N.stages) == null ? void 0 : M.map((_, C) => {
        var X, te, G, F;
        let H = (X = Yu[_.color]) != null && X[2] ? (te = Yu[_.color]) == null ? void 0 : te[2] : (G = dr[_.color]) != null && G[2] ? (F = dr[_.color]) == null ? void 0 : F[2] : "#ccc";
        const I = {
          datum: _.key,
          index: C,
          text: _.key,
          value: H
        };
        g.push(I);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((N, L) => {
      let M = dr[e.palette][L] ? dr[e.palette][L] : "#ccc";
      const _ = {
        datum: N,
        index: L,
        text: N,
        value: M
      };
      g.push(_);
    }), d(g);
  }
  if (e.series.filter((g) => !!g.name).length > 0) {
    const g = /* @__PURE__ */ new Set();
    e.series.forEach((L) => {
      g.add(L.name || L.dataKey);
    });
    const N = Array.from(g).map((L, M) => ({
      datum: L,
      index: M,
      text: L,
      value: a(L)
    }));
    return d(N);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const g = r.length - 1;
    let N = [];
    return (T = e.suppressedData) == null || T.forEach(({ label: L, icon: M }, _) => {
      if (L && M) {
        const C = {
          datum: L,
          index: g + _,
          text: L,
          icon: /* @__PURE__ */ i.createElement(nE, { color: "#000", size: 15 })
        };
        N.push(C);
      }
    }), [...r, ...N];
  }
  return d(r);
}, Du = ({ startAngle: e, endAngle: t }) => ({
  startAngle: e,
  endAngle: t
}), rE = (e) => {
  const { transformedData: t, config: n, colorScale: a, currentViewport: r, dimensions: o, highlight: f, highlightReset: u, seriesHighlight: s } = ce.useContext(Pt), { tooltipData: d, showTooltip: m, hideTooltip: y, tooltipOpen: v, tooltipLeft: w, tooltipTop: E } = _g(), { handleTooltipMouseOver: O, handleTooltipMouseOff: T, TooltipListItem: g } = Bg({
    xScale: !1,
    yScale: !1,
    showTooltip: m,
    hideTooltip: y
  }), [N, L] = ce.useState(void 0), [M, _] = ce.useState(!1), C = Object.values(n.columns).filter((Z) => Z.showInViz), H = C.length > 0, I = H ? "pivotColumn" : void 0, X = ce.useMemo(() => {
    if (H) {
      let Z = [];
      const se = n.yAxis.dataKey, ye = C.map((de) => de.name), me = [se, ...ye], Le = n.xAxis.dataKey;
      return t.forEach((de) => {
        me.forEach((ie) => {
          const Ce = de[ie];
          Ce && Z.push({
            [I]: Ce,
            [Le]: `${de[Le]} - ${ie}`
          });
        });
      }), Z;
    }
    return t;
  }, [t, H]), te = ce.useMemo(() => {
    if (H) {
      const Z = {};
      X.forEach((me) => {
        Z[me[n.xAxis.dataKey]] || (Z[me[n.xAxis.dataKey]] = !0);
      });
      const se = Object.entries(Z).length;
      let ye = n.customColors || dr[n.palette];
      return ye = ye.slice(0, se), zm({
        domain: Object.keys(Z),
        range: ye,
        unknown: null
      });
    }
    return a;
  }, [a, H]), G = ce.useRef(), F = dh(G, {
    freezeOnceVisible: !1
  });
  ce.useEffect(() => {
    document.querySelector(".isEditor") && _((se) => !0);
  }), ce.useEffect(() => {
    F != null && F.isIntersecting && n.animate && !M && setTimeout(() => {
      _(!0);
    }, 500);
  }, [F == null ? void 0 : F.isIntersecting, n.animate]);
  const j = ({ arcs: Z, path: se, getKey: ye }) => {
    const me = _b(Z, ye, {
      from: Du,
      enter: Du,
      update: Du,
      leave: Du
    });
    return ce.useEffect(() => {
      const Le = setTimeout(() => {
        y();
      }, 500);
      return () => {
        clearTimeout(Le);
      };
    }, [d]), /* @__PURE__ */ i.createElement(i.Fragment, null, me.map(({ item: Le, props: de, key: ie }, Ce) => /* @__PURE__ */ i.createElement(at, { className: Le.data[n.xAxis.dataKey], key: `${ie}-${Ce}`, style: { opacity: n.legend.behavior === "highlight" && s.length > 0 && s.indexOf(Le.data[n.runtime.xAxis.dataKey]) === -1 ? 0.5 : 1 } }, /* @__PURE__ */ i.createElement(
      Lp.path,
      {
        d: Pb(
          [de.startAngle, de.endAngle],
          (He, we) => se({
            ...Le,
            startAngle: He,
            endAngle: we
          })
        ),
        fill: te(Le.data[n.runtime.xAxis.dataKey]),
        onMouseEnter: (He) => O(He, { data: Le.data[n.runtime.xAxis.dataKey], arc: Le }),
        onMouseLeave: (He) => T()
      }
    ))), me.map(({ item: Le, key: de }, ie) => {
      const [Ce, He] = se.centroid(Le), we = Le.endAngle - Le.startAngle >= 0.1;
      let ge = "#FFF";
      return te(Le.data[n.runtime.xAxis.dataKey]) && (ge = Zo(ge, te(Le.data[n.runtime.xAxis.dataKey]))), /* @__PURE__ */ i.createElement(Lp.g, { key: `${de}${ie}` }, we && /* @__PURE__ */ i.createElement(Tt, { style: { fill: ge }, x: Ce, y: He, dy: ".33em", textAnchor: "middle", pointerEvents: "none" }, Math.round((Le.endAngle - Le.startAngle) * 180 / Math.PI / 360 * 100) + "%"));
    }));
  };
  let [U] = o;
  n && n.legend && !n.legend.hide && r === "lg" && (U = U * 0.73);
  const W = n.heights.vertical, re = Math.min(U, W) / 2, J = W / 2, ue = n.pieType === "Donut" ? 75 : re;
  ce.useEffect(() => {
    if (s.length > 0 && n.legend.behavior !== "highlight") {
      let Z = [];
      X.forEach((se) => {
        s.indexOf(se[n.runtime.xAxis.dataKey]) !== -1 && Z.push(se);
      }), L(Z);
    } else
      L(void 0);
  }, [s]);
  const ee = Yg(n, [], X, te);
  return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Nr, { component: "PieChart" }, /* @__PURE__ */ i.createElement("svg", { width: re * 2, height: W, className: `animated-pie group ${n.animate === !1 || M ? "animated" : ""}`, role: "img", "aria-label": Tf(n) }, /* @__PURE__ */ i.createElement(at, { top: J, left: re }, /* @__PURE__ */ i.createElement(
    K0,
    {
      data: N || X,
      pieValue: (Z) => Z[I || n.runtime.yAxis.dataKey],
      pieSortValues: () => -1,
      innerRadius: re - ue,
      outerRadius: re
    },
    (Z) => /* @__PURE__ */ i.createElement(j, { ...Z, getKey: (se) => se.data[n.runtime.xAxis.dataKey] })
  ))), /* @__PURE__ */ i.createElement("div", { ref: G }), d && Object.entries(d.data).length > 0 && v && m && d.dataYPosition && d.dataXPosition && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${n.tooltips.opacity / 100}) !important`), /* @__PURE__ */ i.createElement($g, { key: Math.random(), className: "tooltip cdc-open-viz-module", left: w, top: E }, /* @__PURE__ */ i.createElement("ul", null, typeof d == "object" && Object.entries(d.data).map((Z, se) => /* @__PURE__ */ i.createElement(g, { item: Z, key: se })))))), /* @__PURE__ */ i.createElement(Kg, { config: n, colorScale: te, seriesHighlight: s, highlight: f, highlightReset: u, currentViewport: r, formatLabels: ee }));
};
function Ls(e) {
  return e.split("-")[1];
}
function hh(e) {
  return e === "y" ? "height" : "width";
}
function Bi(e) {
  return e.split("-")[0];
}
function Rs(e) {
  return ["top", "bottom"].includes(Bi(e)) ? "x" : "y";
}
function Ip(e, t, n) {
  let { reference: a, floating: r } = e;
  const o = a.x + a.width / 2 - r.width / 2, f = a.y + a.height / 2 - r.height / 2, u = Rs(t), s = hh(u), d = a[s] / 2 - r[s] / 2, m = u === "x";
  let y;
  switch (Bi(t)) {
    case "top":
      y = { x: o, y: a.y - r.height };
      break;
    case "bottom":
      y = { x: o, y: a.y + a.height };
      break;
    case "right":
      y = { x: a.x + a.width, y: f };
      break;
    case "left":
      y = { x: a.x - r.width, y: f };
      break;
    default:
      y = { x: a.x, y: a.y };
  }
  switch (Ls(t)) {
    case "start":
      y[u] -= d * (n && m ? -1 : 1);
      break;
    case "end":
      y[u] += d * (n && m ? -1 : 1);
  }
  return y;
}
function Xg(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function vs(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function qg(e, t) {
  var n;
  t === void 0 && (t = {});
  const { x: a, y: r, platform: o, rects: f, elements: u, strategy: s } = e, { boundary: d = "clippingAncestors", rootBoundary: m = "viewport", elementContext: y = "floating", altBoundary: v = !1, padding: w = 0 } = t, E = Xg(w), O = u[v ? y === "floating" ? "reference" : "floating" : y], T = vs(await o.getClippingRect({ element: (n = await (o.isElement == null ? void 0 : o.isElement(O))) == null || n ? O : O.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(u.floating)), boundary: d, rootBoundary: m, strategy: s })), g = y === "floating" ? { ...f.floating, x: a, y: r } : f.reference, N = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(u.floating)), L = await (o.isElement == null ? void 0 : o.isElement(N)) && await (o.getScale == null ? void 0 : o.getScale(N)) || { x: 1, y: 1 }, M = vs(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: g, offsetParent: N, strategy: s }) : g);
  return { top: (T.top - M.top + E.top) / L.y, bottom: (M.bottom - T.bottom + E.bottom) / L.y, left: (T.left - M.left + E.left) / L.x, right: (M.right - T.right + E.right) / L.x };
}
const aE = Math.min, iE = Math.max;
function Lf(e, t, n) {
  return iE(e, aE(t, n));
}
["top", "right", "bottom", "left"].reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const oE = { left: "right", right: "left", bottom: "top", top: "bottom" };
function hc(e) {
  return e.replace(/left|right|bottom|top/g, (t) => oE[t]);
}
function lE(e, t, n) {
  n === void 0 && (n = !1);
  const a = Ls(e), r = Rs(e), o = hh(r);
  let f = r === "x" ? a === (n ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (f = hc(f)), { main: f, cross: hc(f) };
}
const sE = { start: "end", end: "start" };
function Kd(e) {
  return e.replace(/start|end/g, (t) => sE[t]);
}
const uE = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var n;
    const { placement: a, middlewareData: r, rects: o, initialPlacement: f, platform: u, elements: s } = t, { mainAxis: d = !0, crossAxis: m = !0, fallbackPlacements: y, fallbackStrategy: v = "bestFit", fallbackAxisSideDirection: w = "none", flipAlignment: E = !0, ...O } = e, T = Bi(a), g = Bi(f) === f, N = await (u.isRTL == null ? void 0 : u.isRTL(s.floating)), L = y || (g || !E ? [hc(f)] : function(G) {
      const F = hc(G);
      return [Kd(G), F, Kd(F)];
    }(f));
    y || w === "none" || L.push(...function(G, F, j, U) {
      const W = Ls(G);
      let re = function(J, ue, ee) {
        const Z = ["left", "right"], se = ["right", "left"], ye = ["top", "bottom"], me = ["bottom", "top"];
        switch (J) {
          case "top":
          case "bottom":
            return ee ? ue ? se : Z : ue ? Z : se;
          case "left":
          case "right":
            return ue ? ye : me;
          default:
            return [];
        }
      }(Bi(G), j === "start", U);
      return W && (re = re.map((J) => J + "-" + W), F && (re = re.concat(re.map(Kd)))), re;
    }(f, E, w, N));
    const M = [f, ...L], _ = await qg(t, O), C = [];
    let H = ((n = r.flip) == null ? void 0 : n.overflows) || [];
    if (d && C.push(_[T]), m) {
      const { main: G, cross: F } = lE(a, o, N);
      C.push(_[G], _[F]);
    }
    if (H = [...H, { placement: a, overflows: C }], !C.every((G) => G <= 0)) {
      var I, X;
      const G = (((I = r.flip) == null ? void 0 : I.index) || 0) + 1, F = M[G];
      if (F)
        return { data: { index: G, overflows: H }, reset: { placement: F } };
      let j = (X = H.find((U) => U.overflows[0] <= 0)) == null ? void 0 : X.placement;
      if (!j)
        switch (v) {
          case "bestFit": {
            var te;
            const U = (te = H.map((W) => [W.placement, W.overflows.filter((re) => re > 0).reduce((re, J) => re + J, 0)]).sort((W, re) => W[1] - re[1])[0]) == null ? void 0 : te[0];
            U && (j = U);
            break;
          }
          case "initialPlacement":
            j = f;
        }
      if (a !== j)
        return { reset: { placement: j } };
    }
    return {};
  } };
}, cE = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: n, y: a } = t, r = await async function(o, f) {
      const { placement: u, platform: s, elements: d } = o, m = await (s.isRTL == null ? void 0 : s.isRTL(d.floating)), y = Bi(u), v = Ls(u), w = Rs(u) === "x", E = ["left", "top"].includes(y) ? -1 : 1, O = m && w ? -1 : 1, T = typeof f == "function" ? f(o) : f;
      let { mainAxis: g, crossAxis: N, alignmentAxis: L } = typeof T == "number" ? { mainAxis: T, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...T };
      return v && typeof L == "number" && (N = v === "end" ? -1 * L : L), w ? { x: N * O, y: g * E } : { x: g * E, y: N * O };
    }(t, e);
    return { x: n + r.x, y: a + r.y, data: r };
  } };
}, dE = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: n, y: a, placement: r } = t, { mainAxis: o = !0, crossAxis: f = !1, limiter: u = { fn: (T) => {
      let { x: g, y: N } = T;
      return { x: g, y: N };
    } }, ...s } = e, d = { x: n, y: a }, m = await qg(t, s), y = Rs(Bi(r)), v = y === "x" ? "y" : "x";
    let w = d[y], E = d[v];
    if (o) {
      const T = y === "y" ? "bottom" : "right";
      w = Lf(w + m[y === "y" ? "top" : "left"], w, w - m[T]);
    }
    if (f) {
      const T = v === "y" ? "bottom" : "right";
      E = Lf(E + m[v === "y" ? "top" : "left"], E, E - m[T]);
    }
    const O = u.fn({ ...t, [y]: w, [v]: E });
    return { ...O, data: { x: O.x - n, y: O.y - a } };
  } };
};
function Tr(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Gr(e) {
  return Tr(e).getComputedStyle(e);
}
const Hp = Math.min, xs = Math.max, pc = Math.round;
function Gg(e) {
  const t = Gr(e);
  let n = parseFloat(t.width), a = parseFloat(t.height);
  const r = e.offsetWidth, o = e.offsetHeight, f = pc(n) !== r || pc(a) !== o;
  return f && (n = r, a = o), { width: n, height: a, fallback: f };
}
function Va(e) {
  return Qg(e) ? (e.nodeName || "").toLowerCase() : "";
}
let Ou;
function Zg() {
  if (Ou)
    return Ou;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (Ou = e.brands.map((t) => t.brand + "/" + t.version).join(" "), Ou) : navigator.userAgent;
}
function Zr(e) {
  return e instanceof Tr(e).HTMLElement;
}
function Ba(e) {
  return e instanceof Tr(e).Element;
}
function Qg(e) {
  return e instanceof Tr(e).Node;
}
function Wp(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Tr(e).ShadowRoot || e instanceof ShadowRoot;
}
function Dc(e) {
  const { overflow: t, overflowX: n, overflowY: a, display: r } = Gr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + n) && !["inline", "contents"].includes(r);
}
function fE(e) {
  return ["table", "td", "th"].includes(Va(e));
}
function Rf(e) {
  const t = /firefox/i.test(Zg()), n = Gr(e), a = n.backdropFilter || n.WebkitBackdropFilter;
  return n.transform !== "none" || n.perspective !== "none" || !!a && a !== "none" || t && n.willChange === "filter" || t && !!n.filter && n.filter !== "none" || ["transform", "perspective"].some((r) => n.willChange.includes(r)) || ["paint", "layout", "strict", "content"].some((r) => {
    const o = n.contain;
    return o != null && o.includes(r);
  });
}
function Jg() {
  return !/^((?!chrome|android).)*safari/i.test(Zg());
}
function ph(e) {
  return ["html", "body", "#document"].includes(Va(e));
}
function ey(e) {
  return Ba(e) ? e : e.contextElement;
}
const ty = { x: 1, y: 1 };
function Go(e) {
  const t = ey(e);
  if (!Zr(t))
    return ty;
  const n = t.getBoundingClientRect(), { width: a, height: r, fallback: o } = Gg(t);
  let f = (o ? pc(n.width) : n.width) / a, u = (o ? pc(n.height) : n.height) / r;
  return f && Number.isFinite(f) || (f = 1), u && Number.isFinite(u) || (u = 1), { x: f, y: u };
}
function Cs(e, t, n, a) {
  var r, o;
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const f = e.getBoundingClientRect(), u = ey(e);
  let s = ty;
  t && (a ? Ba(a) && (s = Go(a)) : s = Go(e));
  const d = u ? Tr(u) : window, m = !Jg() && n;
  let y = (f.left + (m && ((r = d.visualViewport) == null ? void 0 : r.offsetLeft) || 0)) / s.x, v = (f.top + (m && ((o = d.visualViewport) == null ? void 0 : o.offsetTop) || 0)) / s.y, w = f.width / s.x, E = f.height / s.y;
  if (u) {
    const O = Tr(u), T = a && Ba(a) ? Tr(a) : a;
    let g = O.frameElement;
    for (; g && a && T !== O; ) {
      const N = Go(g), L = g.getBoundingClientRect(), M = getComputedStyle(g);
      L.x += (g.clientLeft + parseFloat(M.paddingLeft)) * N.x, L.y += (g.clientTop + parseFloat(M.paddingTop)) * N.y, y *= N.x, v *= N.y, w *= N.x, E *= N.y, y += L.x, v += L.y, g = Tr(g).frameElement;
    }
  }
  return { width: w, height: E, top: v, right: y + w, bottom: v + E, left: y, x: y, y: v };
}
function Ia(e) {
  return ((Qg(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function Oc(e) {
  return Ba(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function ny(e) {
  return Cs(Ia(e)).left + Oc(e).scrollLeft;
}
function As(e) {
  if (Va(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || Wp(e) && e.host || Ia(e);
  return Wp(t) ? t.host : t;
}
function ry(e) {
  const t = As(e);
  return ph(t) ? t.ownerDocument.body : Zr(t) && Dc(t) ? t : ry(t);
}
function ay(e, t) {
  var n;
  t === void 0 && (t = []);
  const a = ry(e), r = a === ((n = e.ownerDocument) == null ? void 0 : n.body), o = Tr(a);
  return r ? t.concat(o, o.visualViewport || [], Dc(a) ? a : []) : t.concat(a, ay(a));
}
function Vp(e, t, n) {
  return t === "viewport" ? vs(function(a, r) {
    const o = Tr(a), f = Ia(a), u = o.visualViewport;
    let s = f.clientWidth, d = f.clientHeight, m = 0, y = 0;
    if (u) {
      s = u.width, d = u.height;
      const v = Jg();
      (v || !v && r === "fixed") && (m = u.offsetLeft, y = u.offsetTop);
    }
    return { width: s, height: d, x: m, y };
  }(e, n)) : Ba(t) ? vs(function(a, r) {
    const o = Cs(a, !0, r === "fixed"), f = o.top + a.clientTop, u = o.left + a.clientLeft, s = Zr(a) ? Go(a) : { x: 1, y: 1 };
    return { width: a.clientWidth * s.x, height: a.clientHeight * s.y, x: u * s.x, y: f * s.y };
  }(t, n)) : vs(function(a) {
    const r = Ia(a), o = Oc(a), f = a.ownerDocument.body, u = xs(r.scrollWidth, r.clientWidth, f.scrollWidth, f.clientWidth), s = xs(r.scrollHeight, r.clientHeight, f.scrollHeight, f.clientHeight);
    let d = -o.scrollLeft + ny(a);
    const m = -o.scrollTop;
    return Gr(f).direction === "rtl" && (d += xs(r.clientWidth, f.clientWidth) - u), { width: u, height: s, x: d, y: m };
  }(Ia(e)));
}
function jp(e) {
  return Zr(e) && Gr(e).position !== "fixed" ? e.offsetParent : null;
}
function Up(e) {
  const t = Tr(e);
  let n = jp(e);
  for (; n && fE(n) && Gr(n).position === "static"; )
    n = jp(n);
  return n && (Va(n) === "html" || Va(n) === "body" && Gr(n).position === "static" && !Rf(n)) ? t : n || function(a) {
    let r = As(a);
    for (; Zr(r) && !ph(r); ) {
      if (Rf(r))
        return r;
      r = As(r);
    }
    return null;
  }(e) || t;
}
function hE(e, t, n) {
  const a = Zr(t), r = Ia(t), o = Cs(e, !0, n === "fixed", t);
  let f = { scrollLeft: 0, scrollTop: 0 };
  const u = { x: 0, y: 0 };
  if (a || !a && n !== "fixed")
    if ((Va(t) !== "body" || Dc(r)) && (f = Oc(t)), Zr(t)) {
      const s = Cs(t, !0);
      u.x = s.x + t.clientLeft, u.y = s.y + t.clientTop;
    } else
      r && (u.x = ny(r));
  return { x: o.left + f.scrollLeft - u.x, y: o.top + f.scrollTop - u.y, width: o.width, height: o.height };
}
const pE = { getClippingRect: function(e) {
  let { element: t, boundary: n, rootBoundary: a, strategy: r } = e;
  const o = n === "clippingAncestors" ? function(d, m) {
    const y = m.get(d);
    if (y)
      return y;
    let v = ay(d).filter((T) => Ba(T) && Va(T) !== "body"), w = null;
    const E = Gr(d).position === "fixed";
    let O = E ? As(d) : d;
    for (; Ba(O) && !ph(O); ) {
      const T = Gr(O), g = Rf(O);
      (E ? g || w : g || T.position !== "static" || !w || !["absolute", "fixed"].includes(w.position)) ? w = T : v = v.filter((N) => N !== O), O = As(O);
    }
    return m.set(d, v), v;
  }(t, this._c) : [].concat(n), f = [...o, a], u = f[0], s = f.reduce((d, m) => {
    const y = Vp(t, m, r);
    return d.top = xs(y.top, d.top), d.right = Hp(y.right, d.right), d.bottom = Hp(y.bottom, d.bottom), d.left = xs(y.left, d.left), d;
  }, Vp(t, u, r));
  return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: n, strategy: a } = e;
  const r = Zr(n), o = Ia(n);
  if (n === o)
    return t;
  let f = { scrollLeft: 0, scrollTop: 0 }, u = { x: 1, y: 1 };
  const s = { x: 0, y: 0 };
  if ((r || !r && a !== "fixed") && ((Va(n) !== "body" || Dc(o)) && (f = Oc(n)), Zr(n))) {
    const d = Cs(n);
    u = Go(n), s.x = d.x + n.clientLeft, s.y = d.y + n.clientTop;
  }
  return { width: t.width * u.x, height: t.height * u.y, x: t.x * u.x - f.scrollLeft * u.x + s.x, y: t.y * u.y - f.scrollTop * u.y + s.y };
}, isElement: Ba, getDimensions: function(e) {
  return Zr(e) ? Gg(e) : e.getBoundingClientRect();
}, getOffsetParent: Up, getDocumentElement: Ia, getScale: Go, async getElementRects(e) {
  let { reference: t, floating: n, strategy: a } = e;
  const r = this.getOffsetParent || Up, o = this.getDimensions;
  return { reference: hE(t, await r(n), a), floating: { x: 0, y: 0, ...await o(n) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => Gr(e).direction === "rtl" }, Kp = (e, t, n) => {
  const a = /* @__PURE__ */ new Map(), r = { platform: pE, ...n }, o = { ...r.platform, _c: a };
  return (async (f, u, s) => {
    const { placement: d = "bottom", strategy: m = "absolute", middleware: y = [], platform: v } = s, w = y.filter(Boolean), E = await (v.isRTL == null ? void 0 : v.isRTL(u));
    if (v == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")), w.filter((_) => {
      let { name: C } = _;
      return C === "autoPlacement" || C === "flip";
    }).length > 1)
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    f && u || console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    let O = await v.getElementRects({ reference: f, floating: u, strategy: m }), { x: T, y: g } = Ip(O, d, E), N = d, L = {}, M = 0;
    for (let _ = 0; _ < w.length; _++) {
      const { name: C, fn: H } = w[_], { x: I, y: X, data: te, reset: G } = await H({ x: T, y: g, initialPlacement: d, placement: N, strategy: m, middlewareData: L, rects: O, platform: v, elements: { reference: f, floating: u } });
      T = I ?? T, g = X ?? g, L = { ...L, [C]: { ...L[C], ...te } }, M > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")), G && M <= 50 && (M++, typeof G == "object" && (G.placement && (N = G.placement), G.rects && (O = G.rects === !0 ? await v.getElementRects({ reference: f, floating: u, strategy: m }) : G.rects), { x: T, y: g } = Ip(O, N, E)), _ = -1);
    }
    return { x: T, y: g, placement: N, strategy: m, middlewareData: L };
  })(e, t, { ...r, platform: o });
};
var Na, Ii = { exports: {} }, Yp = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Na = Yp, function() {
  var e = i, t = 60103, n = 60106;
  Na.Fragment = 60107;
  var a = 60108, r = 60114, o = 60109, f = 60110, u = 60112, s = 60113, d = 60120, m = 60115, y = 60116, v = 60121, w = 60122, E = 60117, O = 60129, T = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var g = Symbol.for;
    t = g("react.element"), n = g("react.portal"), Na.Fragment = g("react.fragment"), a = g("react.strict_mode"), r = g("react.profiler"), o = g("react.provider"), f = g("react.context"), u = g("react.forward_ref"), s = g("react.suspense"), d = g("react.suspense_list"), m = g("react.memo"), y = g("react.lazy"), v = g("react.block"), w = g("react.server.block"), E = g("react.fundamental"), g("react.scope"), g("react.opaque.id"), O = g("react.debug_trace_mode"), g("react.offscreen"), T = g("react.legacy_hidden");
  }
  var N = typeof Symbol == "function" && Symbol.iterator, L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  function M(ge) {
    for (var ke = arguments.length, ne = new Array(ke > 1 ? ke - 1 : 0), Pe = 1; Pe < ke; Pe++)
      ne[Pe - 1] = arguments[Pe];
    _("error", ge, ne);
  }
  function _(ge, ke, ne) {
    var Pe = L.ReactDebugCurrentFrame, $e = "";
    if (X) {
      var qe = H(X.type), Ge = X._owner;
      $e += function(We, vt, et) {
        var Ke = "";
        if (vt) {
          var Be = vt.fileName, ze = Be.replace(C, "");
          if (/^index\./.test(ze)) {
            var gt = Be.match(C);
            if (gt) {
              var Ye = gt[1];
              Ye && (ze = Ye.replace(C, "") + "/" + ze);
            }
          }
          Ke = " (at " + ze + ":" + vt.lineNumber + ")";
        } else
          et && (Ke = " (created by " + et + ")");
        return `
    in ` + (We || "Unknown") + Ke;
      }(qe, X._source, Ge && H(Ge.type));
    }
    ($e += Pe.getStackAddendum()) !== "" && (ke += "%s", ne = ne.concat([$e]));
    var Xe = ne.map(function(We) {
      return "" + We;
    });
    Xe.unshift("Warning: " + ke), Function.prototype.apply.call(console[ge], console, Xe);
  }
  var C = /^(.*)[\\\/]/;
  function H(ge) {
    if (ge == null)
      return null;
    if (typeof ge.tag == "number" && M("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof ge == "function")
      return ge.displayName || ge.name || null;
    if (typeof ge == "string")
      return ge;
    switch (ge) {
      case Na.Fragment:
        return "Fragment";
      case n:
        return "Portal";
      case r:
        return "Profiler";
      case a:
        return "StrictMode";
      case s:
        return "Suspense";
      case d:
        return "SuspenseList";
    }
    if (typeof ge == "object")
      switch (ge.$$typeof) {
        case f:
          return "Context.Consumer";
        case o:
          return "Context.Provider";
        case u:
          return Pe = ge, $e = ge.render, qe = "ForwardRef", Ge = $e.displayName || $e.name || "", Pe.displayName || (Ge !== "" ? qe + "(" + Ge + ")" : qe);
        case m:
          return H(ge.type);
        case v:
          return H(ge.render);
        case y:
          var ke = (ne = ge)._status === 1 ? ne._result : null;
          if (ke)
            return H(ke);
      }
    var ne, Pe, $e, qe, Ge;
    return null;
  }
  var I = {};
  L.ReactDebugCurrentFrame;
  var X = null;
  function te(ge) {
    X = ge;
  }
  var G, F, j, U = L.ReactCurrentOwner, W = Object.prototype.hasOwnProperty, re = { key: !0, ref: !0, __self: !0, __source: !0 };
  function J(ge, ke, ne, Pe, $e) {
    var qe, Ge = {}, Xe = null, We = null;
    for (qe in ne !== void 0 && (Xe = "" + ne), function(Ke) {
      if (W.call(Ke, "key")) {
        var Be = Object.getOwnPropertyDescriptor(Ke, "key").get;
        if (Be && Be.isReactWarning)
          return !1;
      }
      return Ke.key !== void 0;
    }(ke) && (Xe = "" + ke.key), function(Ke) {
      if (W.call(Ke, "ref")) {
        var Be = Object.getOwnPropertyDescriptor(Ke, "ref").get;
        if (Be && Be.isReactWarning)
          return !1;
      }
      return Ke.ref !== void 0;
    }(ke) && (We = ke.ref, function(Ke, Be) {
      if (typeof Ke.ref == "string" && U.current && Be && U.current.stateNode !== Be) {
        var ze = H(U.current.type);
        j[ze] || (M('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', H(U.current.type), Ke.ref), j[ze] = !0);
      }
    }(ke, $e)), ke)
      W.call(ke, qe) && !re.hasOwnProperty(qe) && (Ge[qe] = ke[qe]);
    if (ge && ge.defaultProps) {
      var vt = ge.defaultProps;
      for (qe in vt)
        Ge[qe] === void 0 && (Ge[qe] = vt[qe]);
    }
    if (Xe || We) {
      var et = typeof ge == "function" ? ge.displayName || ge.name || "Unknown" : ge;
      Xe && function(Ke, Be) {
        var ze = function() {
          G || (G = !0, M("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Be));
        };
        ze.isReactWarning = !0, Object.defineProperty(Ke, "key", { get: ze, configurable: !0 });
      }(Ge, et), We && function(Ke, Be) {
        var ze = function() {
          F || (F = !0, M("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Be));
        };
        ze.isReactWarning = !0, Object.defineProperty(Ke, "ref", { get: ze, configurable: !0 });
      }(Ge, et);
    }
    return function(Ke, Be, ze, gt, Ye, dt, xt) {
      var ft = { $$typeof: t, type: Ke, key: Be, ref: ze, props: xt, _owner: dt, _store: {} };
      return Object.defineProperty(ft._store, "validated", { configurable: !1, enumerable: !1, writable: !0, value: !1 }), Object.defineProperty(ft, "_self", { configurable: !1, enumerable: !1, writable: !1, value: gt }), Object.defineProperty(ft, "_source", { configurable: !1, enumerable: !1, writable: !1, value: Ye }), Object.freeze && (Object.freeze(ft.props), Object.freeze(ft)), ft;
    }(ge, Xe, We, $e, Pe, U.current, Ge);
  }
  j = {};
  var ue, ee = L.ReactCurrentOwner;
  function Z(ge) {
    X = ge;
  }
  function se(ge) {
    return typeof ge == "object" && ge !== null && ge.$$typeof === t;
  }
  function ye() {
    if (ee.current) {
      var ge = H(ee.current.type);
      if (ge)
        return `

Check the render method of \`` + ge + "`.";
    }
    return "";
  }
  L.ReactDebugCurrentFrame, ue = !1;
  var me = {};
  function Le(ge, ke) {
    if (ge._store && !ge._store.validated && ge.key == null) {
      ge._store.validated = !0;
      var ne = function($e) {
        var qe = ye();
        if (!qe) {
          var Ge = typeof $e == "string" ? $e : $e.displayName || $e.name;
          Ge && (qe = `

Check the top-level render call using <` + Ge + ">.");
        }
        return qe;
      }(ke);
      if (!me[ne]) {
        me[ne] = !0;
        var Pe = "";
        ge && ge._owner && ge._owner !== ee.current && (Pe = " It was passed a child from " + H(ge._owner.type) + "."), Z(ge), M('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ne, Pe), Z(null);
      }
    }
  }
  function de(ge, ke) {
    if (typeof ge == "object") {
      if (Array.isArray(ge))
        for (var ne = 0; ne < ge.length; ne++) {
          var Pe = ge[ne];
          se(Pe) && Le(Pe, ke);
        }
      else if (se(ge))
        ge._store && (ge._store.validated = !0);
      else if (ge) {
        var $e = function(Xe) {
          if (Xe === null || typeof Xe != "object")
            return null;
          var We = N && Xe[N] || Xe["@@iterator"];
          return typeof We == "function" ? We : null;
        }(ge);
        if (typeof $e == "function" && $e !== ge.entries)
          for (var qe, Ge = $e.call(ge); !(qe = Ge.next()).done; )
            se(qe.value) && Le(qe.value, ke);
      }
    }
  }
  function ie(ge) {
    var ke, ne = ge.type;
    if (ne != null && typeof ne != "string") {
      if (typeof ne == "function")
        ke = ne.propTypes;
      else {
        if (typeof ne != "object" || ne.$$typeof !== u && ne.$$typeof !== m)
          return;
        ke = ne.propTypes;
      }
      if (ke) {
        var Pe = H(ne);
        (function($e, qe, Ge, Xe, We) {
          var vt = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var et in $e)
            if (vt($e, et)) {
              var Ke = void 0;
              try {
                if (typeof $e[et] != "function") {
                  var Be = Error((Xe || "React class") + ": " + Ge + " type `" + et + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof $e[et] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Be.name = "Invariant Violation", Be;
                }
                Ke = $e[et](qe, et, Xe, Ge, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ze) {
                Ke = ze;
              }
              !Ke || Ke instanceof Error || (te(We), M("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Xe || "React class", Ge, et, typeof Ke), te(null)), Ke instanceof Error && !(Ke.message in I) && (I[Ke.message] = !0, te(We), M("Failed %s type: %s", Ge, Ke.message), te(null));
            }
        })(ke, ge.props, "prop", Pe, ge);
      } else
        ne.PropTypes === void 0 || ue || (ue = !0, M("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", H(ne) || "Unknown"));
      typeof ne.getDefaultProps != "function" || ne.getDefaultProps.isReactClassApproved || M("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
  }
  function Ce(ge, ke, ne, Pe, $e, qe) {
    var Ge = function(ze) {
      return typeof ze == "string" || typeof ze == "function" || ze === Na.Fragment || ze === r || ze === O || ze === a || ze === s || ze === d || ze === T || typeof ze == "object" && ze !== null && (ze.$$typeof === y || ze.$$typeof === m || ze.$$typeof === o || ze.$$typeof === f || ze.$$typeof === u || ze.$$typeof === E || ze.$$typeof === v || ze[0] === w);
    }(ge);
    if (!Ge) {
      var Xe = "";
      (ge === void 0 || typeof ge == "object" && ge !== null && Object.keys(ge).length === 0) && (Xe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
      var We, vt = function(ze) {
        return ze !== void 0 ? `

Check your code at ` + ze.fileName.replace(/^.*[\\\/]/, "") + ":" + ze.lineNumber + "." : "";
      }($e);
      Xe += vt || ye(), ge === null ? We = "null" : Array.isArray(ge) ? We = "array" : ge !== void 0 && ge.$$typeof === t ? (We = "<" + (H(ge.type) || "Unknown") + " />", Xe = " Did you accidentally export a JSX literal instead of a component?") : We = typeof ge, M("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", We, Xe);
    }
    var et = J(ge, ke, ne, $e, qe);
    if (et == null)
      return et;
    if (Ge) {
      var Ke = ke.children;
      if (Ke !== void 0)
        if (Pe)
          if (Array.isArray(Ke)) {
            for (var Be = 0; Be < Ke.length; Be++)
              de(Ke[Be], ge);
            Object.freeze && Object.freeze(Ke);
          } else
            M("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          de(Ke, ge);
    }
    return ge === Na.Fragment ? function(ze) {
      for (var gt = Object.keys(ze.props), Ye = 0; Ye < gt.length; Ye++) {
        var dt = gt[Ye];
        if (dt !== "children" && dt !== "key") {
          Z(ze), M("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", dt), Z(null);
          break;
        }
      }
      ze.ref !== null && (Z(ze), M("Invalid attribute `ref` supplied to `React.Fragment`."), Z(null));
    }(et) : ie(et), et;
  }
  var He = function(ge, ke, ne) {
    return Ce(ge, ke, ne, !1);
  }, we = function(ge, ke, ne) {
    return Ce(ge, ke, ne, !0);
  };
  Na.jsx = He, Na.jsxs = we;
}(), Ii.exports = Yp;
var Yd, iy = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
Yd = iy, function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var n = [], a = 0; a < arguments.length; a++) {
      var r = arguments[a];
      if (r) {
        var o = typeof r;
        if (o === "string" || o === "number")
          n.push(r);
        else if (Array.isArray(r)) {
          if (r.length) {
            var f = t.apply(null, r);
            f && n.push(f);
          }
        } else if (o === "object") {
          if (r.toString !== Object.prototype.toString && !r.toString.toString().includes("[native code]")) {
            n.push(r.toString());
            continue;
          }
          for (var u in r)
            e.call(r, u) && r[u] && n.push(u);
        }
      }
    }
    return n.join(" ");
  }
  Yd.exports ? (t.default = t, Yd.exports = t) : window.classNames = t;
}();
var Xp = iy.exports;
const qp = (e, t, n) => {
  let a = null;
  return function(...r) {
    a && clearTimeout(a), a = setTimeout(() => {
      a = null, n || e.apply(this, r);
    }, t);
  };
}, mE = ({ content: e }) => Ii.exports.jsx("span", { dangerouslySetInnerHTML: { __html: e } }), gE = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} }, yE = ce.createContext({ getTooltipData: () => gE });
function oy(e = "DEFAULT_TOOLTIP_ID") {
  return ce.useContext(yE).getTooltipData(e);
}
const Gp = async ({ elementReference: e = null, tooltipReference: t = null, tooltipArrowReference: n = null, place: a = "top", offset: r = 10, strategy: o = "absolute", middlewares: f = [cE(Number(r)), uE(), dE({ padding: 5 })] }) => {
  if (!e)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  if (t === null)
    return { tooltipStyles: {}, tooltipArrowStyles: {} };
  const u = f;
  return n ? (u.push({ name: "arrow", options: s = { element: n, padding: 5 }, async fn(d) {
    const { element: m, padding: y = 0 } = s || {}, { x: v, y: w, placement: E, rects: O, platform: T } = d;
    if (m == null)
      return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."), {};
    const g = Xg(y), N = { x: v, y: w }, L = Rs(E), M = hh(L), _ = await T.getDimensions(m), C = L === "y" ? "top" : "left", H = L === "y" ? "bottom" : "right", I = O.reference[M] + O.reference[L] - N[L] - O.floating[M], X = N[L] - O.reference[L], te = await (T.getOffsetParent == null ? void 0 : T.getOffsetParent(m));
    let G = te ? L === "y" ? te.clientHeight || 0 : te.clientWidth || 0 : 0;
    G === 0 && (G = O.floating[M]);
    const F = I / 2 - X / 2, j = g[C], U = G - _[M] - g[H], W = G / 2 - _[M] / 2 + F, re = Lf(j, W, U), J = Ls(E) != null && W != re && O.reference[M] / 2 - (W < j ? g[C] : g[H]) - _[M] / 2 < 0;
    return { [L]: N[L] - (J ? W < j ? j - W : U - W : 0), data: { [L]: re, centerOffset: W - re } };
  } }), Kp(e, t, { placement: a, strategy: o, middleware: u }).then(({ x: d, y: m, placement: y, middlewareData: v }) => {
    var w, E;
    const O = { left: `${d}px`, top: `${m}px` }, { x: T, y: g } = (w = v.arrow) !== null && w !== void 0 ? w : { x: 0, y: 0 };
    return { tooltipStyles: O, tooltipArrowStyles: { left: T != null ? `${T}px` : "", top: g != null ? `${g}px` : "", right: "", bottom: "", [(E = { top: "bottom", right: "left", bottom: "top", left: "right" }[y.split("-")[0]]) !== null && E !== void 0 ? E : "bottom"]: "-4px" } };
  })) : Kp(e, t, { placement: "bottom", strategy: o, middleware: u }).then(({ x: d, y: m }) => ({ tooltipStyles: { left: `${d}px`, top: `${m}px` }, tooltipArrowStyles: {} }));
  var s;
};
var Pi = { tooltip: "styles-module_tooltip__mnnfp", fixed: "styles-module_fixed__7ciUi", arrow: "styles-module_arrow__K0L3T", "no-arrow": "styles-module_no-arrow__KcFZN", clickable: "styles-module_clickable__Bv9o7", show: "styles-module_show__2NboJ", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
const Zp = ({ id: e, className: t, classNameArrow: n, variant: a = "dark", anchorId: r, anchorSelect: o, place: f = "top", offset: u = 10, events: s = ["hover"], positionStrategy: d = "absolute", middlewares: m, wrapper: y, children: v = null, delayShow: w = 0, delayHide: E = 0, float: O = !1, noArrow: T = !1, clickable: g = !1, closeOnEsc: N = !1, style: L, position: M, afterShow: _, afterHide: C, content: H, html: I, isOpen: X, setIsOpen: te, activeAnchor: G, setActiveAnchor: F }) => {
  const j = ce.useRef(null), U = ce.useRef(null), W = ce.useRef(null), re = ce.useRef(null), [J, ue] = ce.useState({}), [ee, Z] = ce.useState({}), [se, ye] = ce.useState(!1), [me, Le] = ce.useState(!1), de = ce.useRef(!1), ie = ce.useRef(null), { anchorRefs: Ce, setActiveAnchor: He } = oy(e), we = ce.useRef(!1), [ge, ke] = ce.useState([]), ne = ce.useRef(!1);
  ce.useLayoutEffect(() => (ne.current = !0, () => {
    ne.current = !1;
  }), []), ce.useEffect(() => {
    if (!se) {
      const Ye = setTimeout(() => {
        Le(!1);
      }, 150);
      return () => {
        clearTimeout(Ye);
      };
    }
    return () => null;
  }, [se]);
  const Pe = (Ye) => {
    ne.current && (Ye && Le(!0), setTimeout(() => {
      ne.current && (te == null || te(Ye), X === void 0 && ye(Ye));
    }, 10));
  };
  ce.useEffect(() => {
    if (X === void 0)
      return () => null;
    X && Le(!0);
    const Ye = setTimeout(() => {
      ye(X);
    }, 10);
    return () => {
      clearTimeout(Ye);
    };
  }, [X]), ce.useEffect(() => {
    se !== de.current && (de.current = se, se ? _ == null || _() : C == null || C());
  }, [se]);
  const $e = (Ye = E) => {
    re.current && clearTimeout(re.current), re.current = setTimeout(() => {
      we.current || Pe(!1);
    }, Ye);
  }, qe = (Ye) => {
    var dt;
    if (!Ye)
      return;
    w ? (W.current && clearTimeout(W.current), W.current = setTimeout(() => {
      Pe(!0);
    }, w)) : Pe(!0);
    const xt = (dt = Ye.currentTarget) !== null && dt !== void 0 ? dt : Ye.target;
    F(xt), He({ current: xt }), re.current && clearTimeout(re.current);
  }, Ge = () => {
    g ? $e(E || 100) : E ? $e() : Pe(!1), W.current && clearTimeout(W.current);
  }, Xe = ({ x: Ye, y: dt }) => {
    Gp({ place: f, offset: u, elementReference: { getBoundingClientRect: () => ({ x: Ye, y: dt, width: 0, height: 0, top: dt, left: Ye, right: Ye, bottom: dt }) }, tooltipReference: j.current, tooltipArrowReference: U.current, strategy: d, middlewares: m }).then((xt) => {
      Object.keys(xt.tooltipStyles).length && ue(xt.tooltipStyles), Object.keys(xt.tooltipArrowStyles).length && Z(xt.tooltipArrowStyles);
    });
  }, We = (Ye) => {
    if (!Ye)
      return;
    const dt = Ye, xt = { x: dt.clientX, y: dt.clientY };
    Xe(xt), ie.current = xt;
  }, vt = (Ye) => {
    qe(Ye), E && $e();
  }, et = (Ye) => {
    const dt = document.querySelector(`[id='${r}']`);
    dt != null && dt.contains(Ye.target) || ge.some((xt) => xt.contains(Ye.target)) || Pe(!1);
  }, Ke = (Ye) => {
    Ye.key === "Escape" && Pe(!1);
  }, Be = qp(qe, 50), ze = qp(Ge, 50);
  ce.useEffect(() => {
    var Ye, dt;
    const xt = new Set(Ce);
    ge.forEach((Xt) => {
      xt.add({ current: Xt });
    });
    const ft = document.querySelector(`[id='${r}']`);
    ft && xt.add({ current: ft }), N && window.addEventListener("keydown", Ke);
    const lt = [];
    s.find((Xt) => Xt === "click") && (window.addEventListener("click", et), lt.push({ event: "click", listener: vt })), s.find((Xt) => Xt === "hover") && (lt.push({ event: "mouseenter", listener: Be }, { event: "mouseleave", listener: ze }, { event: "focus", listener: Be }, { event: "blur", listener: ze }), O && lt.push({ event: "mousemove", listener: We }));
    const Dt = () => {
      we.current = !0;
    }, on = () => {
      we.current = !1, Ge();
    };
    return g && ((Ye = j.current) === null || Ye === void 0 || Ye.addEventListener("mouseenter", Dt), (dt = j.current) === null || dt === void 0 || dt.addEventListener("mouseleave", on)), lt.forEach(({ event: Xt, listener: tn }) => {
      xt.forEach((mn) => {
        var zt;
        (zt = mn.current) === null || zt === void 0 || zt.addEventListener(Xt, tn);
      });
    }), () => {
      var Xt, tn;
      s.find((mn) => mn === "click") && window.removeEventListener("click", et), N && window.removeEventListener("keydown", Ke), g && ((Xt = j.current) === null || Xt === void 0 || Xt.removeEventListener("mouseenter", Dt), (tn = j.current) === null || tn === void 0 || tn.removeEventListener("mouseleave", on)), lt.forEach(({ event: mn, listener: zt }) => {
        xt.forEach((Vt) => {
          var _e;
          (_e = Vt.current) === null || _e === void 0 || _e.removeEventListener(mn, zt);
        });
      });
    };
  }, [me, Ce, ge, N, s]), ce.useEffect(() => {
    let Ye = o ?? "";
    !Ye && e && (Ye = `[data-tooltip-id='${e}']`);
    const dt = new MutationObserver((xt) => {
      const ft = [];
      xt.forEach((lt) => {
        if (lt.type === "attributes" && lt.attributeName === "data-tooltip-id" && lt.target.getAttribute("data-tooltip-id") === e && ft.push(lt.target), lt.type === "childList" && (G && [...lt.removedNodes].some((Dt) => !!Dt.contains(G) && (Le(!1), Pe(!1), F(null), !0)), Ye))
          try {
            const Dt = [...lt.addedNodes].filter((on) => on.nodeType === 1);
            ft.push(...Dt.filter((on) => on.matches(Ye))), ft.push(...Dt.flatMap((on) => [...on.querySelectorAll(Ye)]));
          } catch {
          }
      }), ft.length && ke((lt) => [...lt, ...ft]);
    });
    return dt.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"] }), () => {
      dt.disconnect();
    };
  }, [e, o, G]), ce.useEffect(() => {
    M ? Xe(M) : O ? ie.current && Xe(ie.current) : Gp({ place: f, offset: u, elementReference: G, tooltipReference: j.current, tooltipArrowReference: U.current, strategy: d, middlewares: m }).then((Ye) => {
      ne.current && (Object.keys(Ye.tooltipStyles).length && ue(Ye.tooltipStyles), Object.keys(Ye.tooltipArrowStyles).length && Z(Ye.tooltipArrowStyles));
    });
  }, [se, G, H, I, f, u, d, M]), ce.useEffect(() => {
    var Ye;
    const dt = document.querySelector(`[id='${r}']`), xt = [...ge, dt];
    G && xt.includes(G) || F((Ye = ge[0]) !== null && Ye !== void 0 ? Ye : dt);
  }, [r, ge, G]), ce.useEffect(() => () => {
    W.current && clearTimeout(W.current), re.current && clearTimeout(re.current);
  }, []), ce.useEffect(() => {
    let Ye = o;
    if (!Ye && e && (Ye = `[data-tooltip-id='${e}']`), Ye)
      try {
        const dt = Array.from(document.querySelectorAll(Ye));
        ke(dt);
      } catch {
        ke([]);
      }
  }, [e, o]);
  const gt = !!(I || H || v) && se && Object.keys(J).length > 0;
  return me ? Ii.exports.jsxs(y, { id: e, role: "tooltip", className: Xp("react-tooltip", Pi.tooltip, Pi[a], t, { [Pi.show]: gt, [Pi.fixed]: d === "fixed", [Pi.clickable]: g }), style: { ...L, ...J }, ref: j, children: [I && Ii.exports.jsx(mE, { content: I }) || H || v, Ii.exports.jsx(y, { className: Xp("react-tooltip-arrow", Pi.arrow, n, { [Pi["no-arrow"]]: T }), style: ee, ref: U })] }) : null;
}, ly = ({ id: e, anchorId: t, anchorSelect: n, content: a, html: r, className: o, classNameArrow: f, variant: u = "dark", place: s = "top", offset: d = 10, wrapper: m = "div", children: y = null, events: v = ["hover"], positionStrategy: w = "absolute", middlewares: E, delayShow: O = 0, delayHide: T = 0, float: g = !1, noArrow: N = !1, clickable: L = !1, closeOnEsc: M = !1, style: _, position: C, isOpen: H, setIsOpen: I, afterShow: X, afterHide: te }) => {
  const [G, F] = ce.useState(a), [j, U] = ce.useState(r), [W, re] = ce.useState(s), [J, ue] = ce.useState(u), [ee, Z] = ce.useState(d), [se, ye] = ce.useState(O), [me, Le] = ce.useState(T), [de, ie] = ce.useState(g), [Ce, He] = ce.useState(m), [we, ge] = ce.useState(v), [ke, ne] = ce.useState(w), [Pe, $e] = ce.useState(null), { anchorRefs: qe, activeAnchor: Ge } = oy(e), Xe = (et) => et == null ? void 0 : et.getAttributeNames().reduce((Ke, Be) => {
    var ze;
    return Be.startsWith("data-tooltip-") && (Ke[Be.replace(/^data-tooltip-/, "")] = (ze = et == null ? void 0 : et.getAttribute(Be)) !== null && ze !== void 0 ? ze : null), Ke;
  }, {}), We = (et) => {
    const Ke = { place: (Be) => {
      var ze;
      re((ze = Be) !== null && ze !== void 0 ? ze : s);
    }, content: (Be) => {
      F(Be ?? a);
    }, html: (Be) => {
      U(Be ?? r);
    }, variant: (Be) => {
      var ze;
      ue((ze = Be) !== null && ze !== void 0 ? ze : u);
    }, offset: (Be) => {
      Z(Be === null ? d : Number(Be));
    }, wrapper: (Be) => {
      var ze;
      He((ze = Be) !== null && ze !== void 0 ? ze : m);
    }, events: (Be) => {
      const ze = Be == null ? void 0 : Be.split(" ");
      ge(ze ?? v);
    }, "position-strategy": (Be) => {
      var ze;
      ne((ze = Be) !== null && ze !== void 0 ? ze : w);
    }, "delay-show": (Be) => {
      ye(Be === null ? O : Number(Be));
    }, "delay-hide": (Be) => {
      Le(Be === null ? T : Number(Be));
    }, float: (Be) => {
      ie(Be === null ? g : !!Be);
    } };
    Object.values(Ke).forEach((Be) => Be(null)), Object.entries(et).forEach(([Be, ze]) => {
      var gt;
      (gt = Ke[Be]) === null || gt === void 0 || gt.call(Ke, ze);
    });
  };
  ce.useEffect(() => {
    F(a);
  }, [a]), ce.useEffect(() => {
    U(r);
  }, [r]), ce.useEffect(() => {
    re(s);
  }, [s]), ce.useEffect(() => {
    var et;
    const Ke = new Set(qe);
    let Be = n;
    if (!Be && e && (Be = `[data-tooltip-id='${e}']`), Be)
      try {
        document.querySelectorAll(Be).forEach((xt) => {
          Ke.add({ current: xt });
        });
      } catch {
        console.warn(`[react-tooltip] "${n}" is not a valid CSS selector`);
      }
    const ze = document.querySelector(`[id='${t}']`);
    if (ze && Ke.add({ current: ze }), !Ke.size)
      return () => null;
    const gt = (et = Pe ?? ze) !== null && et !== void 0 ? et : Ge.current, Ye = new MutationObserver((xt) => {
      xt.forEach((ft) => {
        var lt;
        if (!gt || ft.type !== "attributes" || !(!((lt = ft.attributeName) === null || lt === void 0) && lt.startsWith("data-tooltip-")))
          return;
        const Dt = Xe(gt);
        We(Dt);
      });
    }), dt = { attributes: !0, childList: !1, subtree: !1 };
    if (gt) {
      const xt = Xe(gt);
      We(xt), Ye.observe(gt, dt);
    }
    return () => {
      Ye.disconnect();
    };
  }, [qe, Ge, Pe, t, n]);
  const vt = { id: e, anchorId: t, anchorSelect: n, className: o, classNameArrow: f, content: G, html: j, place: W, variant: J, offset: ee, wrapper: Ce, events: we, positionStrategy: ke, middlewares: E, delayShow: se, delayHide: me, float: de, noArrow: N, clickable: L, closeOnEsc: M, style: _, position: C, isOpen: H, setIsOpen: I, afterShow: X, afterHide: te, activeAnchor: Pe, setActiveAnchor: (et) => $e(et) };
  return y ? Ii.exports.jsx(Zp, { ...vt, children: y }) : Ii.exports.jsx(Zp, { ...vt });
};
function Qp(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n < a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function vE(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n > a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function Xd(e, t) {
  let n = 0;
  if (t === void 0)
    for (let a of e)
      (a = +a) && (n += a);
  else {
    let a = -1;
    for (let r of e)
      (r = +t(r, ++a, e)) && (n += r);
  }
  return n;
}
function xE(e) {
  return e.depth;
}
function bE(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function Mu(e) {
  return function() {
    return e;
  };
}
function Jp(e, t) {
  return mc(e.source, t.source) || e.index - t.index;
}
function em(e, t) {
  return mc(e.target, t.target) || e.index - t.index;
}
function mc(e, t) {
  return e.y0 - t.y0;
}
function qd(e) {
  return e.value;
}
function SE(e) {
  return e.index;
}
function EE(e) {
  return e.nodes;
}
function kE(e) {
  return e.links;
}
function tm(e, t) {
  const n = e.get(t);
  if (!n)
    throw new Error("missing: " + t);
  return n;
}
function nm({ nodes: e }) {
  for (const t of e) {
    let n = t.y0, a = n;
    for (const r of t.sourceLinks)
      r.y0 = n + r.width / 2, n += r.width;
    for (const r of t.targetLinks)
      r.y1 = a + r.width / 2, a += r.width;
  }
}
function wE() {
  let e = 0, t = 0, n = 1, a = 1, r = 24, o = 8, f, u = SE, s = bE, d, m, y = EE, v = kE, w = 6;
  function E() {
    const W = { nodes: y.apply(null, arguments), links: v.apply(null, arguments) };
    return O(W), T(W), g(W), N(W), _(W), nm(W), W;
  }
  E.update = function(W) {
    return nm(W), W;
  }, E.nodeId = function(W) {
    return arguments.length ? (u = typeof W == "function" ? W : Mu(W), E) : u;
  }, E.nodeAlign = function(W) {
    return arguments.length ? (s = typeof W == "function" ? W : Mu(W), E) : s;
  }, E.nodeSort = function(W) {
    return arguments.length ? (d = W, E) : d;
  }, E.nodeWidth = function(W) {
    return arguments.length ? (r = +W, E) : r;
  }, E.nodePadding = function(W) {
    return arguments.length ? (o = f = +W, E) : o;
  }, E.nodes = function(W) {
    return arguments.length ? (y = typeof W == "function" ? W : Mu(W), E) : y;
  }, E.links = function(W) {
    return arguments.length ? (v = typeof W == "function" ? W : Mu(W), E) : v;
  }, E.linkSort = function(W) {
    return arguments.length ? (m = W, E) : m;
  }, E.size = function(W) {
    return arguments.length ? (e = t = 0, n = +W[0], a = +W[1], E) : [n - e, a - t];
  }, E.extent = function(W) {
    return arguments.length ? (e = +W[0][0], n = +W[1][0], t = +W[0][1], a = +W[1][1], E) : [[e, t], [n, a]];
  }, E.iterations = function(W) {
    return arguments.length ? (w = +W, E) : w;
  };
  function O({ nodes: W, links: re }) {
    for (const [ue, ee] of W.entries())
      ee.index = ue, ee.sourceLinks = [], ee.targetLinks = [];
    const J = new Map(W.map((ue, ee) => [u(ue, ee, W), ue]));
    for (const [ue, ee] of re.entries()) {
      ee.index = ue;
      let { source: Z, target: se } = ee;
      typeof Z != "object" && (Z = ee.source = tm(J, Z)), typeof se != "object" && (se = ee.target = tm(J, se)), Z.sourceLinks.push(ee), se.targetLinks.push(ee);
    }
    if (m != null)
      for (const { sourceLinks: ue, targetLinks: ee } of W)
        ue.sort(m), ee.sort(m);
  }
  function T({ nodes: W }) {
    for (const re of W)
      re.value = re.fixedValue === void 0 ? Math.max(Xd(re.sourceLinks, qd), Xd(re.targetLinks, qd)) : re.fixedValue;
  }
  function g({ nodes: W }) {
    const re = W.length;
    let J = new Set(W), ue = /* @__PURE__ */ new Set(), ee = 0;
    for (; J.size; ) {
      for (const Z of J) {
        Z.depth = ee;
        for (const { target: se } of Z.sourceLinks)
          ue.add(se);
      }
      if (++ee > re)
        throw new Error("circular link");
      J = ue, ue = /* @__PURE__ */ new Set();
    }
  }
  function N({ nodes: W }) {
    const re = W.length;
    let J = new Set(W), ue = /* @__PURE__ */ new Set(), ee = 0;
    for (; J.size; ) {
      for (const Z of J) {
        Z.height = ee;
        for (const { source: se } of Z.targetLinks)
          ue.add(se);
      }
      if (++ee > re)
        throw new Error("circular link");
      J = ue, ue = /* @__PURE__ */ new Set();
    }
  }
  function L({ nodes: W }) {
    const re = Qp(W, (ee) => ee.depth) + 1, J = (n - e - r) / (re - 1), ue = new Array(re);
    for (const ee of W) {
      const Z = Math.max(0, Math.min(re - 1, Math.floor(s.call(null, ee, re))));
      ee.layer = Z, ee.x0 = e + Z * J, ee.x1 = ee.x0 + r, ue[Z] ? ue[Z].push(ee) : ue[Z] = [ee];
    }
    if (d)
      for (const ee of ue)
        ee.sort(d);
    return ue;
  }
  function M(W) {
    const re = vE(W, (J) => (a - t - (J.length - 1) * f) / Xd(J, qd));
    for (const J of W) {
      let ue = t;
      for (const ee of J) {
        ee.y0 = ue, ee.y1 = ue + ee.value * re, ue = ee.y1 + f;
        for (const Z of ee.sourceLinks)
          Z.width = Z.value * re;
      }
      ue = (a - ue + f) / (J.length + 1);
      for (let ee = 0; ee < J.length; ++ee) {
        const Z = J[ee];
        Z.y0 += ue * (ee + 1), Z.y1 += ue * (ee + 1);
      }
      F(J);
    }
  }
  function _(W) {
    const re = L(W);
    f = Math.min(o, (a - t) / (Qp(re, (J) => J.length) - 1)), M(re);
    for (let J = 0; J < w; ++J) {
      const ue = Math.pow(0.99, J), ee = Math.max(1 - ue, (J + 1) / w);
      H(re, ue, ee), C(re, ue, ee);
    }
  }
  function C(W, re, J) {
    for (let ue = 1, ee = W.length; ue < ee; ++ue) {
      const Z = W[ue];
      for (const se of Z) {
        let ye = 0, me = 0;
        for (const { source: de, value: ie } of se.targetLinks) {
          let Ce = ie * (se.layer - de.layer);
          ye += j(de, se) * Ce, me += Ce;
        }
        if (!(me > 0))
          continue;
        let Le = (ye / me - se.y0) * re;
        se.y0 += Le, se.y1 += Le, G(se);
      }
      d === void 0 && Z.sort(mc), I(Z, J);
    }
  }
  function H(W, re, J) {
    for (let ue = W.length, ee = ue - 2; ee >= 0; --ee) {
      const Z = W[ee];
      for (const se of Z) {
        let ye = 0, me = 0;
        for (const { target: de, value: ie } of se.sourceLinks) {
          let Ce = ie * (de.layer - se.layer);
          ye += U(se, de) * Ce, me += Ce;
        }
        if (!(me > 0))
          continue;
        let Le = (ye / me - se.y0) * re;
        se.y0 += Le, se.y1 += Le, G(se);
      }
      d === void 0 && Z.sort(mc), I(Z, J);
    }
  }
  function I(W, re) {
    const J = W.length >> 1, ue = W[J];
    te(W, ue.y0 - f, J - 1, re), X(W, ue.y1 + f, J + 1, re), te(W, a, W.length - 1, re), X(W, t, 0, re);
  }
  function X(W, re, J, ue) {
    for (; J < W.length; ++J) {
      const ee = W[J], Z = (re - ee.y0) * ue;
      Z > 1e-6 && (ee.y0 += Z, ee.y1 += Z), re = ee.y1 + f;
    }
  }
  function te(W, re, J, ue) {
    for (; J >= 0; --J) {
      const ee = W[J], Z = (ee.y1 - re) * ue;
      Z > 1e-6 && (ee.y0 -= Z, ee.y1 -= Z), re = ee.y0 - f;
    }
  }
  function G({ sourceLinks: W, targetLinks: re }) {
    if (m === void 0) {
      for (const { source: { sourceLinks: J } } of re)
        J.sort(em);
      for (const { target: { targetLinks: J } } of W)
        J.sort(Jp);
    }
  }
  function F(W) {
    if (m === void 0)
      for (const { sourceLinks: re, targetLinks: J } of W)
        re.sort(em), J.sort(Jp);
  }
  function j(W, re) {
    let J = W.y0 - (W.sourceLinks.length - 1) * f / 2;
    for (const { target: ue, width: ee } of W.sourceLinks) {
      if (ue === re)
        break;
      J += ee + f;
    }
    for (const { source: ue, width: ee } of re.targetLinks) {
      if (ue === W)
        break;
      J -= ee;
    }
    return J;
  }
  function U(W, re) {
    let J = re.y0 - (re.targetLinks.length - 1) * f / 2;
    for (const { source: ue, width: ee } of re.targetLinks) {
      if (ue === W)
        break;
      J += ee + f;
    }
    for (const { target: ue, width: ee } of W.sourceLinks) {
      if (ue === re)
        break;
      J -= ee;
    }
    return J;
  }
  return E;
}
function TE(e) {
  return [e.source.x1, e.y0];
}
function CE(e) {
  return [e.target.x0, e.y1];
}
function AE() {
  return m0().source(TE).target(CE);
}
var ja = {}, Li = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rm;
function PE() {
  if (rm)
    return Li;
  rm = 1;
  var e = ce;
  function t(x) {
    for (var P = "https://reactjs.org/docs/error-decoder.html?invariant=" + x, B = 1; B < arguments.length; B++)
      P += "&args[]=" + encodeURIComponent(arguments[B]);
    return "Minified React error #" + x + "; visit " + P + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = Object.prototype.hasOwnProperty, a = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, r = {}, o = {};
  function f(x) {
    return n.call(o, x) ? !0 : n.call(r, x) ? !1 : a.test(x) ? o[x] = !0 : (r[x] = !0, !1);
  }
  function u(x, P, B, Y, Ee, xe, De) {
    this.acceptsBooleans = P === 2 || P === 3 || P === 4, this.attributeName = Y, this.attributeNamespace = Ee, this.mustUseProperty = B, this.propertyName = x, this.type = P, this.sanitizeURL = xe, this.removeEmptyString = De;
  }
  var s = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(x) {
    s[x] = new u(x, 0, !1, x, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(x) {
    var P = x[0];
    s[P] = new u(P, 1, !1, x[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(x) {
    s[x] = new u(x, 2, !1, x.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(x) {
    s[x] = new u(x, 2, !1, x, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(x) {
    s[x] = new u(x, 3, !1, x.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(x) {
    s[x] = new u(x, 3, !0, x, null, !1, !1);
  }), ["capture", "download"].forEach(function(x) {
    s[x] = new u(x, 4, !1, x, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(x) {
    s[x] = new u(x, 6, !1, x, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(x) {
    s[x] = new u(x, 5, !1, x.toLowerCase(), null, !1, !1);
  });
  var d = /[\-:]([a-z])/g;
  function m(x) {
    return x[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(x) {
    var P = x.replace(
      d,
      m
    );
    s[P] = new u(P, 1, !1, x, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(x) {
    var P = x.replace(d, m);
    s[P] = new u(P, 1, !1, x, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(x) {
    var P = x.replace(d, m);
    s[P] = new u(P, 1, !1, x, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(x) {
    s[x] = new u(x, 1, !1, x.toLowerCase(), null, !1, !1);
  }), s.xlinkHref = new u("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(x) {
    s[x] = new u(x, 1, !1, x.toLowerCase(), null, !0, !0);
  });
  var y = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, v = ["Webkit", "ms", "Moz", "O"];
  Object.keys(y).forEach(function(x) {
    v.forEach(function(P) {
      P = P + x.charAt(0).toUpperCase() + x.substring(1), y[P] = y[x];
    });
  });
  var w = /["'&<>]/;
  function E(x) {
    if (typeof x == "boolean" || typeof x == "number")
      return "" + x;
    x = "" + x;
    var P = w.exec(x);
    if (P) {
      var B = "", Y, Ee = 0;
      for (Y = P.index; Y < x.length; Y++) {
        switch (x.charCodeAt(Y)) {
          case 34:
            P = "&quot;";
            break;
          case 38:
            P = "&amp;";
            break;
          case 39:
            P = "&#x27;";
            break;
          case 60:
            P = "&lt;";
            break;
          case 62:
            P = "&gt;";
            break;
          default:
            continue;
        }
        Ee !== Y && (B += x.substring(Ee, Y)), Ee = Y + 1, B += P;
      }
      x = Ee !== Y ? B + x.substring(Ee, Y) : B;
    }
    return x;
  }
  var O = /([A-Z])/g, T = /^ms-/, g = Array.isArray;
  function N(x, P) {
    return { insertionMode: x, selectedValue: P };
  }
  function L(x, P, B) {
    switch (P) {
      case "select":
        return N(1, B.value != null ? B.value : B.defaultValue);
      case "svg":
        return N(2, null);
      case "math":
        return N(3, null);
      case "foreignObject":
        return N(1, null);
      case "table":
        return N(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return N(5, null);
      case "colgroup":
        return N(7, null);
      case "tr":
        return N(6, null);
    }
    return 4 <= x.insertionMode || x.insertionMode === 0 ? N(1, null) : x;
  }
  var M = /* @__PURE__ */ new Map();
  function _(x, P, B) {
    if (typeof B != "object")
      throw Error(t(62));
    P = !0;
    for (var Y in B)
      if (n.call(B, Y)) {
        var Ee = B[Y];
        if (Ee != null && typeof Ee != "boolean" && Ee !== "") {
          if (Y.indexOf("--") === 0) {
            var xe = E(Y);
            Ee = E(("" + Ee).trim());
          } else {
            xe = Y;
            var De = M.get(xe);
            De !== void 0 || (De = E(xe.replace(O, "-$1").toLowerCase().replace(T, "-ms-")), M.set(xe, De)), xe = De, Ee = typeof Ee == "number" ? Ee === 0 || n.call(y, Y) ? "" + Ee : Ee + "px" : E(("" + Ee).trim());
          }
          P ? (P = !1, x.push(' style="', xe, ":", Ee)) : x.push(";", xe, ":", Ee);
        }
      }
    P || x.push('"');
  }
  function C(x, P, B, Y) {
    switch (B) {
      case "style":
        _(x, P, Y);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < B.length) || B[0] !== "o" && B[0] !== "O" || B[1] !== "n" && B[1] !== "N") {
      if (P = s.hasOwnProperty(B) ? s[B] : null, P !== null) {
        switch (typeof Y) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!P.acceptsBooleans)
              return;
        }
        switch (B = P.attributeName, P.type) {
          case 3:
            Y && x.push(" ", B, '=""');
            break;
          case 4:
            Y === !0 ? x.push(" ", B, '=""') : Y !== !1 && x.push(" ", B, '="', E(Y), '"');
            break;
          case 5:
            isNaN(Y) || x.push(" ", B, '="', E(Y), '"');
            break;
          case 6:
            !isNaN(Y) && 1 <= Y && x.push(" ", B, '="', E(Y), '"');
            break;
          default:
            P.sanitizeURL && (Y = "" + Y), x.push(" ", B, '="', E(Y), '"');
        }
      } else if (f(B)) {
        switch (typeof Y) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (P = B.toLowerCase().slice(0, 5), P !== "data-" && P !== "aria-")
              return;
        }
        x.push(" ", B, '="', E(Y), '"');
      }
    }
  }
  function H(x, P, B) {
    if (P != null) {
      if (B != null)
        throw Error(t(60));
      if (typeof P != "object" || !("__html" in P))
        throw Error(t(61));
      P = P.__html, P != null && x.push("" + P);
    }
  }
  function I(x) {
    var P = "";
    return e.Children.forEach(x, function(B) {
      B != null && (P += B);
    }), P;
  }
  function X(x, P, B, Y) {
    x.push(F(B));
    var Ee = B = null, xe;
    for (xe in P)
      if (n.call(P, xe)) {
        var De = P[xe];
        if (De != null)
          switch (xe) {
            case "children":
              B = De;
              break;
            case "dangerouslySetInnerHTML":
              Ee = De;
              break;
            default:
              C(x, Y, xe, De);
          }
      }
    return x.push(">"), H(x, Ee, B), typeof B == "string" ? (x.push(E(B)), null) : B;
  }
  var te = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, G = /* @__PURE__ */ new Map();
  function F(x) {
    var P = G.get(x);
    if (P === void 0) {
      if (!te.test(x))
        throw Error(t(65, x));
      P = "<" + x, G.set(x, P);
    }
    return P;
  }
  function j(x, P, B, Y, Ee) {
    switch (P) {
      case "select":
        x.push(F("select"));
        var xe = null, De = null;
        for (oe in B)
          if (n.call(B, oe)) {
            var Ve = B[oe];
            if (Ve != null)
              switch (oe) {
                case "children":
                  xe = Ve;
                  break;
                case "dangerouslySetInnerHTML":
                  De = Ve;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  C(x, Y, oe, Ve);
              }
          }
        return x.push(">"), H(x, De, xe), xe;
      case "option":
        De = Ee.selectedValue, x.push(F("option"));
        var ot = Ve = null, yt = null, oe = null;
        for (xe in B)
          if (n.call(B, xe)) {
            var le = B[xe];
            if (le != null)
              switch (xe) {
                case "children":
                  Ve = le;
                  break;
                case "selected":
                  yt = le;
                  break;
                case "dangerouslySetInnerHTML":
                  oe = le;
                  break;
                case "value":
                  ot = le;
                default:
                  C(x, Y, xe, le);
              }
          }
        if (De != null)
          if (B = ot !== null ? "" + ot : I(Ve), g(De)) {
            for (Y = 0; Y < De.length; Y++)
              if ("" + De[Y] === B) {
                x.push(' selected=""');
                break;
              }
          } else
            "" + De === B && x.push(' selected=""');
        else
          yt && x.push(' selected=""');
        return x.push(">"), H(x, oe, Ve), Ve;
      case "textarea":
        x.push(F("textarea")), oe = De = xe = null;
        for (Ve in B)
          if (n.call(B, Ve) && (ot = B[Ve], ot != null))
            switch (Ve) {
              case "children":
                oe = ot;
                break;
              case "value":
                xe = ot;
                break;
              case "defaultValue":
                De = ot;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                C(
                  x,
                  Y,
                  Ve,
                  ot
                );
            }
        if (xe === null && De !== null && (xe = De), x.push(">"), oe != null) {
          if (xe != null)
            throw Error(t(92));
          if (g(oe) && 1 < oe.length)
            throw Error(t(93));
          xe = "" + oe;
        }
        return typeof xe == "string" && xe[0] === `
` && x.push(`
`), xe !== null && x.push(E("" + xe)), null;
      case "input":
        x.push(F("input")), ot = oe = Ve = xe = null;
        for (De in B)
          if (n.call(B, De) && (yt = B[De], yt != null))
            switch (De) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                ot = yt;
                break;
              case "defaultValue":
                Ve = yt;
                break;
              case "checked":
                oe = yt;
                break;
              case "value":
                xe = yt;
                break;
              default:
                C(x, Y, De, yt);
            }
        return oe !== null ? C(x, Y, "checked", oe) : ot !== null && C(x, Y, "checked", ot), xe !== null ? C(x, Y, "value", xe) : Ve !== null && C(x, Y, "value", Ve), x.push("/>"), null;
      case "menuitem":
        x.push(F("menuitem"));
        for (var ve in B)
          if (n.call(B, ve) && (xe = B[ve], xe != null))
            switch (ve) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                C(x, Y, ve, xe);
            }
        return x.push(">"), null;
      case "title":
        x.push(F("title")), xe = null;
        for (le in B)
          if (n.call(B, le) && (De = B[le], De != null))
            switch (le) {
              case "children":
                xe = De;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                C(x, Y, le, De);
            }
        return x.push(">"), xe;
      case "listing":
      case "pre":
        x.push(F(P)), De = xe = null;
        for (ot in B)
          if (n.call(B, ot) && (Ve = B[ot], Ve != null))
            switch (ot) {
              case "children":
                xe = Ve;
                break;
              case "dangerouslySetInnerHTML":
                De = Ve;
                break;
              default:
                C(x, Y, ot, Ve);
            }
        if (x.push(">"), De != null) {
          if (xe != null)
            throw Error(t(60));
          if (typeof De != "object" || !("__html" in De))
            throw Error(t(61));
          B = De.__html, B != null && (typeof B == "string" && 0 < B.length && B[0] === `
` ? x.push(`
`, B) : x.push("" + B));
        }
        return typeof xe == "string" && xe[0] === `
` && x.push(`
`), xe;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        x.push(F(P));
        for (var Me in B)
          if (n.call(B, Me) && (xe = B[Me], xe != null))
            switch (Me) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, P));
              default:
                C(x, Y, Me, xe);
            }
        return x.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return X(
          x,
          B,
          P,
          Y
        );
      case "html":
        return Ee.insertionMode === 0 && x.push("<!DOCTYPE html>"), X(x, B, P, Y);
      default:
        if (P.indexOf("-") === -1 && typeof B.is != "string")
          return X(x, B, P, Y);
        x.push(F(P)), De = xe = null;
        for (yt in B)
          if (n.call(B, yt) && (Ve = B[yt], Ve != null))
            switch (yt) {
              case "children":
                xe = Ve;
                break;
              case "dangerouslySetInnerHTML":
                De = Ve;
                break;
              case "style":
                _(x, Y, Ve);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                f(yt) && typeof Ve != "function" && typeof Ve != "symbol" && x.push(" ", yt, '="', E(Ve), '"');
            }
        return x.push(">"), H(x, De, xe), xe;
    }
  }
  function U(x, P, B) {
    if (x.push('<!--$?--><template id="'), B === null)
      throw Error(t(395));
    return x.push(B), x.push('"></template>');
  }
  function W(x, P, B, Y) {
    switch (B.insertionMode) {
      case 0:
      case 1:
        return x.push('<div hidden id="'), x.push(P.segmentPrefix), P = Y.toString(16), x.push(P), x.push('">');
      case 2:
        return x.push('<svg aria-hidden="true" style="display:none" id="'), x.push(P.segmentPrefix), P = Y.toString(16), x.push(P), x.push('">');
      case 3:
        return x.push('<math aria-hidden="true" style="display:none" id="'), x.push(P.segmentPrefix), P = Y.toString(16), x.push(P), x.push('">');
      case 4:
        return x.push('<table hidden id="'), x.push(P.segmentPrefix), P = Y.toString(16), x.push(P), x.push('">');
      case 5:
        return x.push('<table hidden><tbody id="'), x.push(P.segmentPrefix), P = Y.toString(16), x.push(P), x.push('">');
      case 6:
        return x.push('<table hidden><tr id="'), x.push(P.segmentPrefix), P = Y.toString(16), x.push(P), x.push('">');
      case 7:
        return x.push('<table hidden><colgroup id="'), x.push(P.segmentPrefix), P = Y.toString(16), x.push(P), x.push('">');
      default:
        throw Error(t(397));
    }
  }
  function re(x, P) {
    switch (P.insertionMode) {
      case 0:
      case 1:
        return x.push("</div>");
      case 2:
        return x.push("</svg>");
      case 3:
        return x.push("</math>");
      case 4:
        return x.push("</table>");
      case 5:
        return x.push("</tbody></table>");
      case 6:
        return x.push("</tr></table>");
      case 7:
        return x.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var J = /[<\u2028\u2029]/g;
  function ue(x) {
    return JSON.stringify(x).replace(J, function(P) {
      switch (P) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function ee(x, P) {
    return P = P === void 0 ? "" : P, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: P + "P:", segmentPrefix: P + "S:", boundaryPrefix: P + "B:", idPrefix: P, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: x };
  }
  function Z(x, P, B, Y) {
    return B.generateStaticMarkup ? (x.push(E(P)), !1) : (P === "" ? x = Y : (Y && x.push("<!-- -->"), x.push(E(P)), x = !0), x);
  }
  var se = Object.assign, ye = Symbol.for("react.element"), me = Symbol.for("react.portal"), Le = Symbol.for("react.fragment"), de = Symbol.for("react.strict_mode"), ie = Symbol.for("react.profiler"), Ce = Symbol.for("react.provider"), He = Symbol.for("react.context"), we = Symbol.for("react.forward_ref"), ge = Symbol.for("react.suspense"), ke = Symbol.for("react.suspense_list"), ne = Symbol.for("react.memo"), Pe = Symbol.for("react.lazy"), $e = Symbol.for("react.scope"), qe = Symbol.for("react.debug_trace_mode"), Ge = Symbol.for("react.legacy_hidden"), Xe = Symbol.for("react.default_value"), We = Symbol.iterator;
  function vt(x) {
    if (x == null)
      return null;
    if (typeof x == "function")
      return x.displayName || x.name || null;
    if (typeof x == "string")
      return x;
    switch (x) {
      case Le:
        return "Fragment";
      case me:
        return "Portal";
      case ie:
        return "Profiler";
      case de:
        return "StrictMode";
      case ge:
        return "Suspense";
      case ke:
        return "SuspenseList";
    }
    if (typeof x == "object")
      switch (x.$$typeof) {
        case He:
          return (x.displayName || "Context") + ".Consumer";
        case Ce:
          return (x._context.displayName || "Context") + ".Provider";
        case we:
          var P = x.render;
          return x = x.displayName, x || (x = P.displayName || P.name || "", x = x !== "" ? "ForwardRef(" + x + ")" : "ForwardRef"), x;
        case ne:
          return P = x.displayName || null, P !== null ? P : vt(x.type) || "Memo";
        case Pe:
          P = x._payload, x = x._init;
          try {
            return vt(x(P));
          } catch {
          }
      }
    return null;
  }
  var et = {};
  function Ke(x, P) {
    if (x = x.contextTypes, !x)
      return et;
    var B = {}, Y;
    for (Y in x)
      B[Y] = P[Y];
    return B;
  }
  var Be = null;
  function ze(x, P) {
    if (x !== P) {
      x.context._currentValue2 = x.parentValue, x = x.parent;
      var B = P.parent;
      if (x === null) {
        if (B !== null)
          throw Error(t(401));
      } else {
        if (B === null)
          throw Error(t(401));
        ze(x, B);
      }
      P.context._currentValue2 = P.value;
    }
  }
  function gt(x) {
    x.context._currentValue2 = x.parentValue, x = x.parent, x !== null && gt(x);
  }
  function Ye(x) {
    var P = x.parent;
    P !== null && Ye(P), x.context._currentValue2 = x.value;
  }
  function dt(x, P) {
    if (x.context._currentValue2 = x.parentValue, x = x.parent, x === null)
      throw Error(t(402));
    x.depth === P.depth ? ze(x, P) : dt(x, P);
  }
  function xt(x, P) {
    var B = P.parent;
    if (B === null)
      throw Error(t(402));
    x.depth === B.depth ? ze(x, B) : xt(x, B), P.context._currentValue2 = P.value;
  }
  function ft(x) {
    var P = Be;
    P !== x && (P === null ? Ye(x) : x === null ? gt(P) : P.depth === x.depth ? ze(P, x) : P.depth > x.depth ? dt(P, x) : xt(P, x), Be = x);
  }
  var lt = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(x, P) {
    x = x._reactInternals, x.queue !== null && x.queue.push(P);
  }, enqueueReplaceState: function(x, P) {
    x = x._reactInternals, x.replace = !0, x.queue = [P];
  }, enqueueForceUpdate: function() {
  } };
  function Dt(x, P, B, Y) {
    var Ee = x.state !== void 0 ? x.state : null;
    x.updater = lt, x.props = B, x.state = Ee;
    var xe = { queue: [], replace: !1 };
    x._reactInternals = xe;
    var De = P.contextType;
    if (x.context = typeof De == "object" && De !== null ? De._currentValue2 : Y, De = P.getDerivedStateFromProps, typeof De == "function" && (De = De(B, Ee), Ee = De == null ? Ee : se({}, Ee, De), x.state = Ee), typeof P.getDerivedStateFromProps != "function" && typeof x.getSnapshotBeforeUpdate != "function" && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function"))
      if (P = x.state, typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount(), P !== x.state && lt.enqueueReplaceState(x, x.state, null), xe.queue !== null && 0 < xe.queue.length)
        if (P = xe.queue, De = xe.replace, xe.queue = null, xe.replace = !1, De && P.length === 1)
          x.state = P[0];
        else {
          for (xe = De ? P[0] : x.state, Ee = !0, De = De ? 1 : 0; De < P.length; De++) {
            var Ve = P[De];
            Ve = typeof Ve == "function" ? Ve.call(x, xe, B, Y) : Ve, Ve != null && (Ee ? (Ee = !1, xe = se({}, xe, Ve)) : se(xe, Ve));
          }
          x.state = xe;
        }
      else
        xe.queue = null;
  }
  var on = { id: 1, overflow: "" };
  function Xt(x, P, B) {
    var Y = x.id;
    x = x.overflow;
    var Ee = 32 - tn(Y) - 1;
    Y &= ~(1 << Ee), B += 1;
    var xe = 32 - tn(P) + Ee;
    if (30 < xe) {
      var De = Ee - Ee % 5;
      return xe = (Y & (1 << De) - 1).toString(32), Y >>= De, Ee -= De, { id: 1 << 32 - tn(P) + Ee | B << Ee | Y, overflow: xe + x };
    }
    return { id: 1 << xe | B << Ee | Y, overflow: x };
  }
  var tn = Math.clz32 ? Math.clz32 : Vt, mn = Math.log, zt = Math.LN2;
  function Vt(x) {
    return x >>>= 0, x === 0 ? 32 : 31 - (mn(x) / zt | 0) | 0;
  }
  function _e(x, P) {
    return x === P && (x !== 0 || 1 / x === 1 / P) || x !== x && P !== P;
  }
  var En = typeof Object.is == "function" ? Object.is : _e, nn = null, Kt = null, wn = null, ut = null, dn = !1, It = !1, vn = 0, xn = null, qt = 0;
  function fn() {
    if (nn === null)
      throw Error(t(321));
    return nn;
  }
  function Et() {
    if (0 < qt)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function Nn() {
    return ut === null ? wn === null ? (dn = !1, wn = ut = Et()) : (dn = !0, ut = wn) : ut.next === null ? (dn = !1, ut = ut.next = Et()) : (dn = !0, ut = ut.next), ut;
  }
  function Ln() {
    Kt = nn = null, It = !1, wn = null, qt = 0, ut = xn = null;
  }
  function Bn(x, P) {
    return typeof P == "function" ? P(x) : P;
  }
  function Ht(x, P, B) {
    if (nn = fn(), ut = Nn(), dn) {
      var Y = ut.queue;
      if (P = Y.dispatch, xn !== null && (B = xn.get(Y), B !== void 0)) {
        xn.delete(Y), Y = ut.memoizedState;
        do
          Y = x(Y, B.action), B = B.next;
        while (B !== null);
        return ut.memoizedState = Y, [Y, P];
      }
      return [ut.memoizedState, P];
    }
    return x = x === Bn ? typeof P == "function" ? P() : P : B !== void 0 ? B(P) : P, ut.memoizedState = x, x = ut.queue = { last: null, dispatch: null }, x = x.dispatch = Oe.bind(null, nn, x), [ut.memoizedState, x];
  }
  function Fn(x, P) {
    if (nn = fn(), ut = Nn(), P = P === void 0 ? null : P, ut !== null) {
      var B = ut.memoizedState;
      if (B !== null && P !== null) {
        var Y = B[1];
        e:
          if (Y === null)
            Y = !1;
          else {
            for (var Ee = 0; Ee < Y.length && Ee < P.length; Ee++)
              if (!En(P[Ee], Y[Ee])) {
                Y = !1;
                break e;
              }
            Y = !0;
          }
        if (Y)
          return B[0];
      }
    }
    return x = x(), ut.memoizedState = [x, P], x;
  }
  function Oe(x, P, B) {
    if (25 <= qt)
      throw Error(t(301));
    if (x === nn)
      if (It = !0, x = { action: B, next: null }, xn === null && (xn = /* @__PURE__ */ new Map()), B = xn.get(P), B === void 0)
        xn.set(P, x);
      else {
        for (P = B; P.next !== null; )
          P = P.next;
        P.next = x;
      }
  }
  function ht() {
    throw Error(t(394));
  }
  function it() {
  }
  var nt = { readContext: function(x) {
    return x._currentValue2;
  }, useContext: function(x) {
    return fn(), x._currentValue2;
  }, useMemo: Fn, useReducer: Ht, useRef: function(x) {
    nn = fn(), ut = Nn();
    var P = ut.memoizedState;
    return P === null ? (x = { current: x }, ut.memoizedState = x) : P;
  }, useState: function(x) {
    return Ht(Bn, x);
  }, useInsertionEffect: it, useLayoutEffect: function() {
  }, useCallback: function(x, P) {
    return Fn(function() {
      return x;
    }, P);
  }, useImperativeHandle: it, useEffect: it, useDebugValue: it, useDeferredValue: function(x) {
    return fn(), x;
  }, useTransition: function() {
    return fn(), [
      !1,
      ht
    ];
  }, useId: function() {
    var x = Kt.treeContext, P = x.overflow;
    x = x.id, x = (x & ~(1 << 32 - tn(x) - 1)).toString(32) + P;
    var B = ln;
    if (B === null)
      throw Error(t(404));
    return P = vn++, x = ":" + B.idPrefix + "R" + x, 0 < P && (x += "H" + P.toString(32)), x + ":";
  }, useMutableSource: function(x, P) {
    return fn(), P(x._source);
  }, useSyncExternalStore: function(x, P, B) {
    if (B === void 0)
      throw Error(t(407));
    return B();
  } }, ln = null, Gt = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function K(x) {
    return console.error(x), null;
  }
  function Ne() {
  }
  function Ze(x, P, B, Y, Ee, xe, De, Ve, ot) {
    var yt = [], oe = /* @__PURE__ */ new Set();
    return P = { destination: null, responseState: P, progressiveChunkSize: Y === void 0 ? 12800 : Y, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: oe, pingedTasks: yt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Ee === void 0 ? K : Ee, onAllReady: xe === void 0 ? Ne : xe, onShellReady: De === void 0 ? Ne : De, onShellError: Ve === void 0 ? Ne : Ve, onFatalError: ot === void 0 ? Ne : ot }, B = kt(P, 0, null, B, !1, !1), B.parentFlushed = !0, x = je(P, x, null, B, oe, et, null, on), yt.push(x), P;
  }
  function je(x, P, B, Y, Ee, xe, De, Ve) {
    x.allPendingTasks++, B === null ? x.pendingRootTasks++ : B.pendingTasks++;
    var ot = { node: P, ping: function() {
      var yt = x.pingedTasks;
      yt.push(ot), yt.length === 1 && sn(x);
    }, blockedBoundary: B, blockedSegment: Y, abortSet: Ee, legacyContext: xe, context: De, treeContext: Ve };
    return Ee.add(ot), ot;
  }
  function kt(x, P, B, Y, Ee, xe) {
    return { status: 0, id: -1, index: P, parentFlushed: !1, chunks: [], children: [], formatContext: Y, boundary: B, lastPushedText: Ee, textEmbedded: xe };
  }
  function rt(x, P) {
    if (x = x.onError(P), x != null && typeof x != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof x + '" instead');
    return x;
  }
  function wt(x, P) {
    var B = x.onShellError;
    B(P), B = x.onFatalError, B(P), x.destination !== null ? (x.status = 2, x.destination.destroy(P)) : (x.status = 1, x.fatalError = P);
  }
  function Mt(x, P, B, Y, Ee) {
    for (nn = {}, Kt = P, vn = 0, x = B(Y, Ee); It; )
      It = !1, vn = 0, qt += 1, ut = null, x = B(Y, Ee);
    return Ln(), x;
  }
  function Qe(x, P, B, Y) {
    var Ee = B.render(), xe = Y.childContextTypes;
    if (xe != null) {
      var De = P.legacyContext;
      if (typeof B.getChildContext != "function")
        Y = De;
      else {
        B = B.getChildContext();
        for (var Ve in B)
          if (!(Ve in xe))
            throw Error(t(108, vt(Y) || "Unknown", Ve));
        Y = se({}, De, B);
      }
      P.legacyContext = Y, _t(x, P, Ee), P.legacyContext = De;
    } else
      _t(x, P, Ee);
  }
  function pt(x, P) {
    if (x && x.defaultProps) {
      P = se({}, P), x = x.defaultProps;
      for (var B in x)
        P[B] === void 0 && (P[B] = x[B]);
      return P;
    }
    return P;
  }
  function Nt(x, P, B, Y, Ee) {
    if (typeof B == "function")
      if (B.prototype && B.prototype.isReactComponent) {
        Ee = Ke(B, P.legacyContext);
        var xe = B.contextType;
        xe = new B(Y, typeof xe == "object" && xe !== null ? xe._currentValue2 : Ee), Dt(xe, B, Y, Ee), Qe(x, P, xe, B);
      } else {
        xe = Ke(B, P.legacyContext), Ee = Mt(x, P, B, Y, xe);
        var De = vn !== 0;
        if (typeof Ee == "object" && Ee !== null && typeof Ee.render == "function" && Ee.$$typeof === void 0)
          Dt(Ee, B, Y, xe), Qe(x, P, Ee, B);
        else if (De) {
          Y = P.treeContext, P.treeContext = Xt(Y, 1, 0);
          try {
            _t(x, P, Ee);
          } finally {
            P.treeContext = Y;
          }
        } else
          _t(x, P, Ee);
      }
    else if (typeof B == "string") {
      switch (Ee = P.blockedSegment, xe = j(Ee.chunks, B, Y, x.responseState, Ee.formatContext), Ee.lastPushedText = !1, De = Ee.formatContext, Ee.formatContext = L(De, B, Y), Ft(x, P, xe), Ee.formatContext = De, B) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Ee.chunks.push("</", B, ">");
      }
      Ee.lastPushedText = !1;
    } else {
      switch (B) {
        case Ge:
        case qe:
        case de:
        case ie:
        case Le:
          _t(x, P, Y.children);
          return;
        case ke:
          _t(x, P, Y.children);
          return;
        case $e:
          throw Error(t(343));
        case ge:
          e: {
            B = P.blockedBoundary, Ee = P.blockedSegment, xe = Y.fallback, Y = Y.children, De = /* @__PURE__ */ new Set();
            var Ve = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: De, errorDigest: null }, ot = kt(x, Ee.chunks.length, Ve, Ee.formatContext, !1, !1);
            Ee.children.push(ot), Ee.lastPushedText = !1;
            var yt = kt(x, 0, null, Ee.formatContext, !1, !1);
            yt.parentFlushed = !0, P.blockedBoundary = Ve, P.blockedSegment = yt;
            try {
              if (Ft(
                x,
                P,
                Y
              ), x.responseState.generateStaticMarkup || yt.lastPushedText && yt.textEmbedded && yt.chunks.push("<!-- -->"), yt.status = 1, Ut(Ve, yt), Ve.pendingTasks === 0)
                break e;
            } catch (oe) {
              yt.status = 4, Ve.forceClientRender = !0, Ve.errorDigest = rt(x, oe);
            } finally {
              P.blockedBoundary = B, P.blockedSegment = Ee;
            }
            P = je(x, xe, B, ot, De, P.legacyContext, P.context, P.treeContext), x.pingedTasks.push(P);
          }
          return;
      }
      if (typeof B == "object" && B !== null)
        switch (B.$$typeof) {
          case we:
            if (Y = Mt(x, P, B.render, Y, Ee), vn !== 0) {
              B = P.treeContext, P.treeContext = Xt(B, 1, 0);
              try {
                _t(x, P, Y);
              } finally {
                P.treeContext = B;
              }
            } else
              _t(x, P, Y);
            return;
          case ne:
            B = B.type, Y = pt(B, Y), Nt(x, P, B, Y, Ee);
            return;
          case Ce:
            if (Ee = Y.children, B = B._context, Y = Y.value, xe = B._currentValue2, B._currentValue2 = Y, De = Be, Be = Y = { parent: De, depth: De === null ? 0 : De.depth + 1, context: B, parentValue: xe, value: Y }, P.context = Y, _t(x, P, Ee), x = Be, x === null)
              throw Error(t(403));
            Y = x.parentValue, x.context._currentValue2 = Y === Xe ? x.context._defaultValue : Y, x = Be = x.parent, P.context = x;
            return;
          case He:
            Y = Y.children, Y = Y(B._currentValue2), _t(x, P, Y);
            return;
          case Pe:
            Ee = B._init, B = Ee(B._payload), Y = pt(B, Y), Nt(
              x,
              P,
              B,
              Y,
              void 0
            );
            return;
        }
      throw Error(t(130, B == null ? B : typeof B, ""));
    }
  }
  function _t(x, P, B) {
    if (P.node = B, typeof B == "object" && B !== null) {
      switch (B.$$typeof) {
        case ye:
          Nt(x, P, B.type, B.props, B.ref);
          return;
        case me:
          throw Error(t(257));
        case Pe:
          var Y = B._init;
          B = Y(B._payload), _t(x, P, B);
          return;
      }
      if (g(B)) {
        jt(x, P, B);
        return;
      }
      if (B === null || typeof B != "object" ? Y = null : (Y = We && B[We] || B["@@iterator"], Y = typeof Y == "function" ? Y : null), Y && (Y = Y.call(B))) {
        if (B = Y.next(), !B.done) {
          var Ee = [];
          do
            Ee.push(B.value), B = Y.next();
          while (!B.done);
          jt(x, P, Ee);
        }
        return;
      }
      throw x = Object.prototype.toString.call(B), Error(t(31, x === "[object Object]" ? "object with keys {" + Object.keys(B).join(", ") + "}" : x));
    }
    typeof B == "string" ? (Y = P.blockedSegment, Y.lastPushedText = Z(P.blockedSegment.chunks, B, x.responseState, Y.lastPushedText)) : typeof B == "number" && (Y = P.blockedSegment, Y.lastPushedText = Z(P.blockedSegment.chunks, "" + B, x.responseState, Y.lastPushedText));
  }
  function jt(x, P, B) {
    for (var Y = B.length, Ee = 0; Ee < Y; Ee++) {
      var xe = P.treeContext;
      P.treeContext = Xt(xe, Y, Ee);
      try {
        Ft(x, P, B[Ee]);
      } finally {
        P.treeContext = xe;
      }
    }
  }
  function Ft(x, P, B) {
    var Y = P.blockedSegment.formatContext, Ee = P.legacyContext, xe = P.context;
    try {
      return _t(x, P, B);
    } catch (ot) {
      if (Ln(), typeof ot == "object" && ot !== null && typeof ot.then == "function") {
        B = ot;
        var De = P.blockedSegment, Ve = kt(x, De.chunks.length, null, De.formatContext, De.lastPushedText, !0);
        De.children.push(Ve), De.lastPushedText = !1, x = je(x, P.node, P.blockedBoundary, Ve, P.abortSet, P.legacyContext, P.context, P.treeContext).ping, B.then(x, x), P.blockedSegment.formatContext = Y, P.legacyContext = Ee, P.context = xe, ft(xe);
      } else
        throw P.blockedSegment.formatContext = Y, P.legacyContext = Ee, P.context = xe, ft(xe), ot;
    }
  }
  function Ct(x) {
    var P = x.blockedBoundary;
    x = x.blockedSegment, x.status = 3, Qt(this, P, x);
  }
  function Zt(x, P, B) {
    var Y = x.blockedBoundary;
    x.blockedSegment.status = 3, Y === null ? (P.allPendingTasks--, P.status !== 2 && (P.status = 2, P.destination !== null && P.destination.push(null))) : (Y.pendingTasks--, Y.forceClientRender || (Y.forceClientRender = !0, x = B === void 0 ? Error(t(432)) : B, Y.errorDigest = P.onError(x), Y.parentFlushed && P.clientRenderedBoundaries.push(Y)), Y.fallbackAbortableTasks.forEach(function(Ee) {
      return Zt(Ee, P, B);
    }), Y.fallbackAbortableTasks.clear(), P.allPendingTasks--, P.allPendingTasks === 0 && (Y = P.onAllReady, Y()));
  }
  function Ut(x, P) {
    if (P.chunks.length === 0 && P.children.length === 1 && P.children[0].boundary === null) {
      var B = P.children[0];
      B.id = P.id, B.parentFlushed = !0, B.status === 1 && Ut(x, B);
    } else
      x.completedSegments.push(P);
  }
  function Qt(x, P, B) {
    if (P === null) {
      if (B.parentFlushed) {
        if (x.completedRootSegment !== null)
          throw Error(t(389));
        x.completedRootSegment = B;
      }
      x.pendingRootTasks--, x.pendingRootTasks === 0 && (x.onShellError = Ne, P = x.onShellReady, P());
    } else
      P.pendingTasks--, P.forceClientRender || (P.pendingTasks === 0 ? (B.parentFlushed && B.status === 1 && Ut(P, B), P.parentFlushed && x.completedBoundaries.push(P), P.fallbackAbortableTasks.forEach(Ct, x), P.fallbackAbortableTasks.clear()) : B.parentFlushed && B.status === 1 && (Ut(P, B), P.completedSegments.length === 1 && P.parentFlushed && x.partialBoundaries.push(P)));
    x.allPendingTasks--, x.allPendingTasks === 0 && (x = x.onAllReady, x());
  }
  function sn(x) {
    if (x.status !== 2) {
      var P = Be, B = Gt.current;
      Gt.current = nt;
      var Y = ln;
      ln = x.responseState;
      try {
        var Ee = x.pingedTasks, xe;
        for (xe = 0; xe < Ee.length; xe++) {
          var De = Ee[xe], Ve = x, ot = De.blockedSegment;
          if (ot.status === 0) {
            ft(De.context);
            try {
              _t(Ve, De, De.node), Ve.responseState.generateStaticMarkup || ot.lastPushedText && ot.textEmbedded && ot.chunks.push("<!-- -->"), De.abortSet.delete(De), ot.status = 1, Qt(Ve, De.blockedBoundary, ot);
            } catch (bt) {
              if (Ln(), typeof bt == "object" && bt !== null && typeof bt.then == "function") {
                var yt = De.ping;
                bt.then(yt, yt);
              } else {
                De.abortSet.delete(De), ot.status = 4;
                var oe = De.blockedBoundary, le = bt, ve = rt(Ve, le);
                if (oe === null ? wt(Ve, le) : (oe.pendingTasks--, oe.forceClientRender || (oe.forceClientRender = !0, oe.errorDigest = ve, oe.parentFlushed && Ve.clientRenderedBoundaries.push(oe))), Ve.allPendingTasks--, Ve.allPendingTasks === 0) {
                  var Me = Ve.onAllReady;
                  Me();
                }
              }
            } finally {
            }
          }
        }
        Ee.splice(0, xe), x.destination !== null && In(x, x.destination);
      } catch (bt) {
        rt(x, bt), wt(x, bt);
      } finally {
        ln = Y, Gt.current = B, B === nt && ft(P);
      }
    }
  }
  function un(x, P, B) {
    switch (B.parentFlushed = !0, B.status) {
      case 0:
        var Y = B.id = x.nextSegmentId++;
        return B.lastPushedText = !1, B.textEmbedded = !1, x = x.responseState, P.push('<template id="'), P.push(x.placeholderPrefix), x = Y.toString(16), P.push(x), P.push('"></template>');
      case 1:
        B.status = 2;
        var Ee = !0;
        Y = B.chunks;
        var xe = 0;
        B = B.children;
        for (var De = 0; De < B.length; De++) {
          for (Ee = B[De]; xe < Ee.index; xe++)
            P.push(Y[xe]);
          Ee = gn(x, P, Ee);
        }
        for (; xe < Y.length - 1; xe++)
          P.push(Y[xe]);
        return xe < Y.length && (Ee = P.push(Y[xe])), Ee;
      default:
        throw Error(t(390));
    }
  }
  function gn(x, P, B) {
    var Y = B.boundary;
    if (Y === null)
      return un(x, P, B);
    if (Y.parentFlushed = !0, Y.forceClientRender)
      return x.responseState.generateStaticMarkup || (Y = Y.errorDigest, P.push("<!--$!-->"), P.push("<template"), Y && (P.push(' data-dgst="'), Y = E(Y), P.push(Y), P.push('"')), P.push("></template>")), un(x, P, B), x = x.responseState.generateStaticMarkup ? !0 : P.push("<!--/$-->"), x;
    if (0 < Y.pendingTasks) {
      Y.rootSegmentID = x.nextSegmentId++, 0 < Y.completedSegments.length && x.partialBoundaries.push(Y);
      var Ee = x.responseState, xe = Ee.nextSuspenseID++;
      return Ee = Ee.boundaryPrefix + xe.toString(16), Y = Y.id = Ee, U(P, x.responseState, Y), un(x, P, B), P.push("<!--/$-->");
    }
    if (Y.byteSize > x.progressiveChunkSize)
      return Y.rootSegmentID = x.nextSegmentId++, x.completedBoundaries.push(Y), U(P, x.responseState, Y.id), un(x, P, B), P.push("<!--/$-->");
    if (x.responseState.generateStaticMarkup || P.push("<!--$-->"), B = Y.completedSegments, B.length !== 1)
      throw Error(t(391));
    return gn(x, P, B[0]), x = x.responseState.generateStaticMarkup ? !0 : P.push("<!--/$-->"), x;
  }
  function Rn(x, P, B) {
    return W(P, x.responseState, B.formatContext, B.id), gn(x, P, B), re(P, B.formatContext);
  }
  function cn(x, P, B) {
    for (var Y = B.completedSegments, Ee = 0; Ee < Y.length; Ee++)
      Tn(x, P, B, Y[Ee]);
    if (Y.length = 0, x = x.responseState, Y = B.id, B = B.rootSegmentID, P.push(x.startInlineScript), x.sentCompleteBoundaryFunction ? P.push('$RC("') : (x.sentCompleteBoundaryFunction = !0, P.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), Y === null)
      throw Error(t(395));
    return B = B.toString(16), P.push(Y), P.push('","'), P.push(x.segmentPrefix), P.push(B), P.push('")<\/script>');
  }
  function Tn(x, P, B, Y) {
    if (Y.status === 2)
      return !0;
    var Ee = Y.id;
    if (Ee === -1) {
      if ((Y.id = B.rootSegmentID) === -1)
        throw Error(t(392));
      return Rn(x, P, Y);
    }
    return Rn(x, P, Y), x = x.responseState, P.push(x.startInlineScript), x.sentCompleteSegmentFunction ? P.push('$RS("') : (x.sentCompleteSegmentFunction = !0, P.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), P.push(x.segmentPrefix), Ee = Ee.toString(16), P.push(Ee), P.push('","'), P.push(x.placeholderPrefix), P.push(Ee), P.push('")<\/script>');
  }
  function In(x, P) {
    try {
      var B = x.completedRootSegment;
      if (B !== null && x.pendingRootTasks === 0) {
        gn(x, P, B), x.completedRootSegment = null;
        var Y = x.responseState.bootstrapChunks;
        for (B = 0; B < Y.length - 1; B++)
          P.push(Y[B]);
        B < Y.length && P.push(Y[B]);
      }
      var Ee = x.clientRenderedBoundaries, xe;
      for (xe = 0; xe < Ee.length; xe++) {
        var De = Ee[xe];
        Y = P;
        var Ve = x.responseState, ot = De.id, yt = De.errorDigest, oe = De.errorMessage, le = De.errorComponentStack;
        if (Y.push(Ve.startInlineScript), Ve.sentClientRenderFunction ? Y.push('$RX("') : (Ve.sentClientRenderFunction = !0, Y.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), ot === null)
          throw Error(t(395));
        if (Y.push(ot), Y.push('"'), yt || oe || le) {
          Y.push(",");
          var ve = ue(yt || "");
          Y.push(ve);
        }
        if (oe || le) {
          Y.push(",");
          var Me = ue(oe || "");
          Y.push(Me);
        }
        if (le) {
          Y.push(",");
          var bt = ue(le);
          Y.push(bt);
        }
        if (!Y.push(")<\/script>")) {
          x.destination = null, xe++, Ee.splice(0, xe);
          return;
        }
      }
      Ee.splice(0, xe);
      var bn = x.completedBoundaries;
      for (xe = 0; xe < bn.length; xe++)
        if (!cn(x, P, bn[xe])) {
          x.destination = null, xe++, bn.splice(0, xe);
          return;
        }
      bn.splice(0, xe);
      var An = x.partialBoundaries;
      for (xe = 0; xe < An.length; xe++) {
        var fr = An[xe];
        e: {
          Ee = x, De = P;
          var Hn = fr.completedSegments;
          for (Ve = 0; Ve < Hn.length; Ve++)
            if (!Tn(Ee, De, fr, Hn[Ve])) {
              Ve++, Hn.splice(0, Ve);
              var Cr = !1;
              break e;
            }
          Hn.splice(0, Ve), Cr = !0;
        }
        if (!Cr) {
          x.destination = null, xe++, An.splice(0, xe);
          return;
        }
      }
      An.splice(0, xe);
      var hr = x.completedBoundaries;
      for (xe = 0; xe < hr.length; xe++)
        if (!cn(x, P, hr[xe])) {
          x.destination = null, xe++, hr.splice(0, xe);
          return;
        }
      hr.splice(0, xe);
    } finally {
      x.allPendingTasks === 0 && x.pingedTasks.length === 0 && x.clientRenderedBoundaries.length === 0 && x.completedBoundaries.length === 0 && P.push(null);
    }
  }
  function Yn(x, P) {
    try {
      var B = x.abortableTasks;
      B.forEach(function(Y) {
        return Zt(Y, x, P);
      }), B.clear(), x.destination !== null && In(x, x.destination);
    } catch (Y) {
      rt(x, Y), wt(x, Y);
    }
  }
  function Zn() {
  }
  function Xn(x, P, B, Y) {
    var Ee = !1, xe = null, De = "", Ve = { push: function(yt) {
      return yt !== null && (De += yt), !0;
    }, destroy: function(yt) {
      Ee = !0, xe = yt;
    } }, ot = !1;
    if (x = Ze(x, ee(B, P ? P.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, Zn, void 0, function() {
      ot = !0;
    }, void 0, void 0), sn(x), Yn(x, Y), x.status === 1)
      x.status = 2, Ve.destroy(x.fatalError);
    else if (x.status !== 2 && x.destination === null) {
      x.destination = Ve;
      try {
        In(x, Ve);
      } catch (yt) {
        rt(x, yt), wt(x, yt);
      }
    }
    if (Ee)
      throw xe;
    if (!ot)
      throw Error(t(426));
    return De;
  }
  return Li.renderToNodeStream = function() {
    throw Error(t(207));
  }, Li.renderToStaticMarkup = function(x, P) {
    return Xn(x, P, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Li.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, Li.renderToString = function(x, P) {
    return Xn(x, P, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Li.version = "18.2.0", Li;
}
var _u = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var am;
function LE() {
  if (am)
    return _u;
  am = 1;
  var e = ce;
  function t(b) {
    for (var R = "https://reactjs.org/docs/error-decoder.html?invariant=" + b, $ = 1; $ < arguments.length; $++)
      R += "&args[]=" + encodeURIComponent(arguments[$]);
    return "Minified React error #" + b + "; visit " + R + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = null, a = 0;
  function r(b, R) {
    if (R.length !== 0)
      if (512 < R.length)
        0 < a && (b.enqueue(new Uint8Array(n.buffer, 0, a)), n = new Uint8Array(512), a = 0), b.enqueue(R);
      else {
        var $ = n.length - a;
        $ < R.length && ($ === 0 ? b.enqueue(n) : (n.set(R.subarray(0, $), a), b.enqueue(n), R = R.subarray($)), n = new Uint8Array(512), a = 0), n.set(R, a), a += R.length;
      }
  }
  function o(b, R) {
    return r(b, R), !0;
  }
  function f(b) {
    n && 0 < a && (b.enqueue(new Uint8Array(n.buffer, 0, a)), n = null, a = 0);
  }
  var u = new TextEncoder();
  function s(b) {
    return u.encode(b);
  }
  function d(b) {
    return u.encode(b);
  }
  function m(b, R) {
    typeof b.error == "function" ? b.error(R) : b.close();
  }
  var y = Object.prototype.hasOwnProperty, v = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, w = {}, E = {};
  function O(b) {
    return y.call(E, b) ? !0 : y.call(w, b) ? !1 : v.test(b) ? E[b] = !0 : (w[b] = !0, !1);
  }
  function T(b, R, $, q, Te, Se, Fe) {
    this.acceptsBooleans = R === 2 || R === 3 || R === 4, this.attributeName = q, this.attributeNamespace = Te, this.mustUseProperty = $, this.propertyName = b, this.type = R, this.sanitizeURL = Se, this.removeEmptyString = Fe;
  }
  var g = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(b) {
    g[b] = new T(b, 0, !1, b, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(b) {
    var R = b[0];
    g[R] = new T(R, 1, !1, b[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(b) {
    g[b] = new T(b, 2, !1, b.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(b) {
    g[b] = new T(b, 2, !1, b, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(b) {
    g[b] = new T(b, 3, !1, b.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(b) {
    g[b] = new T(b, 3, !0, b, null, !1, !1);
  }), ["capture", "download"].forEach(function(b) {
    g[b] = new T(b, 4, !1, b, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(b) {
    g[b] = new T(b, 6, !1, b, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(b) {
    g[b] = new T(b, 5, !1, b.toLowerCase(), null, !1, !1);
  });
  var N = /[\-:]([a-z])/g;
  function L(b) {
    return b[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(b) {
    var R = b.replace(
      N,
      L
    );
    g[R] = new T(R, 1, !1, b, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(b) {
    var R = b.replace(N, L);
    g[R] = new T(R, 1, !1, b, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(b) {
    var R = b.replace(N, L);
    g[R] = new T(R, 1, !1, b, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(b) {
    g[b] = new T(b, 1, !1, b.toLowerCase(), null, !1, !1);
  }), g.xlinkHref = new T("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(b) {
    g[b] = new T(b, 1, !1, b.toLowerCase(), null, !0, !0);
  });
  var M = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, _ = ["Webkit", "ms", "Moz", "O"];
  Object.keys(M).forEach(function(b) {
    _.forEach(function(R) {
      R = R + b.charAt(0).toUpperCase() + b.substring(1), M[R] = M[b];
    });
  });
  var C = /["'&<>]/;
  function H(b) {
    if (typeof b == "boolean" || typeof b == "number")
      return "" + b;
    b = "" + b;
    var R = C.exec(b);
    if (R) {
      var $ = "", q, Te = 0;
      for (q = R.index; q < b.length; q++) {
        switch (b.charCodeAt(q)) {
          case 34:
            R = "&quot;";
            break;
          case 38:
            R = "&amp;";
            break;
          case 39:
            R = "&#x27;";
            break;
          case 60:
            R = "&lt;";
            break;
          case 62:
            R = "&gt;";
            break;
          default:
            continue;
        }
        Te !== q && ($ += b.substring(Te, q)), Te = q + 1, $ += R;
      }
      b = Te !== q ? $ + b.substring(Te, q) : $;
    }
    return b;
  }
  var I = /([A-Z])/g, X = /^ms-/, te = Array.isArray, G = d("<script>"), F = d("<\/script>"), j = d('<script src="'), U = d('<script type="module" src="'), W = d('" async=""><\/script>'), re = /(<\/|<)(s)(cript)/gi;
  function J(b, R, $, q) {
    return "" + R + ($ === "s" ? "\\u0073" : "\\u0053") + q;
  }
  function ue(b, R, $, q, Te) {
    b = b === void 0 ? "" : b, R = R === void 0 ? G : d('<script nonce="' + H(R) + '">');
    var Se = [];
    if ($ !== void 0 && Se.push(R, s(("" + $).replace(re, J)), F), q !== void 0)
      for ($ = 0; $ < q.length; $++)
        Se.push(j, s(H(q[$])), W);
    if (Te !== void 0)
      for (q = 0; q < Te.length; q++)
        Se.push(U, s(H(Te[q])), W);
    return { bootstrapChunks: Se, startInlineScript: R, placeholderPrefix: d(b + "P:"), segmentPrefix: d(b + "S:"), boundaryPrefix: b + "B:", idPrefix: b, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function ee(b, R) {
    return { insertionMode: b, selectedValue: R };
  }
  function Z(b) {
    return ee(b === "http://www.w3.org/2000/svg" ? 2 : b === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function se(b, R, $) {
    switch (R) {
      case "select":
        return ee(1, $.value != null ? $.value : $.defaultValue);
      case "svg":
        return ee(2, null);
      case "math":
        return ee(3, null);
      case "foreignObject":
        return ee(1, null);
      case "table":
        return ee(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return ee(5, null);
      case "colgroup":
        return ee(7, null);
      case "tr":
        return ee(6, null);
    }
    return 4 <= b.insertionMode || b.insertionMode === 0 ? ee(1, null) : b;
  }
  var ye = d("<!-- -->");
  function me(b, R, $, q) {
    return R === "" ? q : (q && b.push(ye), b.push(s(H(R))), !0);
  }
  var Le = /* @__PURE__ */ new Map(), de = d(' style="'), ie = d(":"), Ce = d(";");
  function He(b, R, $) {
    if (typeof $ != "object")
      throw Error(t(62));
    R = !0;
    for (var q in $)
      if (y.call($, q)) {
        var Te = $[q];
        if (Te != null && typeof Te != "boolean" && Te !== "") {
          if (q.indexOf("--") === 0) {
            var Se = s(H(q));
            Te = s(H(("" + Te).trim()));
          } else {
            Se = q;
            var Fe = Le.get(Se);
            Fe !== void 0 || (Fe = d(H(Se.replace(I, "-$1").toLowerCase().replace(X, "-ms-"))), Le.set(Se, Fe)), Se = Fe, Te = typeof Te == "number" ? Te === 0 || y.call(M, q) ? s("" + Te) : s(Te + "px") : s(H(("" + Te).trim()));
          }
          R ? (R = !1, b.push(de, Se, ie, Te)) : b.push(Ce, Se, ie, Te);
        }
      }
    R || b.push(ke);
  }
  var we = d(" "), ge = d('="'), ke = d('"'), ne = d('=""');
  function Pe(b, R, $, q) {
    switch ($) {
      case "style":
        He(b, R, q);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < $.length) || $[0] !== "o" && $[0] !== "O" || $[1] !== "n" && $[1] !== "N") {
      if (R = g.hasOwnProperty($) ? g[$] : null, R !== null) {
        switch (typeof q) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!R.acceptsBooleans)
              return;
        }
        switch ($ = s(R.attributeName), R.type) {
          case 3:
            q && b.push(we, $, ne);
            break;
          case 4:
            q === !0 ? b.push(we, $, ne) : q !== !1 && b.push(we, $, ge, s(H(q)), ke);
            break;
          case 5:
            isNaN(q) || b.push(we, $, ge, s(H(q)), ke);
            break;
          case 6:
            !isNaN(q) && 1 <= q && b.push(we, $, ge, s(H(q)), ke);
            break;
          default:
            R.sanitizeURL && (q = "" + q), b.push(we, $, ge, s(H(q)), ke);
        }
      } else if (O($)) {
        switch (typeof q) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (R = $.toLowerCase().slice(0, 5), R !== "data-" && R !== "aria-")
              return;
        }
        b.push(we, s($), ge, s(H(q)), ke);
      }
    }
  }
  var $e = d(">"), qe = d("/>");
  function Ge(b, R, $) {
    if (R != null) {
      if ($ != null)
        throw Error(t(60));
      if (typeof R != "object" || !("__html" in R))
        throw Error(t(61));
      R = R.__html, R != null && b.push(s("" + R));
    }
  }
  function Xe(b) {
    var R = "";
    return e.Children.forEach(b, function($) {
      $ != null && (R += $);
    }), R;
  }
  var We = d(' selected=""');
  function vt(b, R, $, q) {
    b.push(ze($));
    var Te = $ = null, Se;
    for (Se in R)
      if (y.call(R, Se)) {
        var Fe = R[Se];
        if (Fe != null)
          switch (Se) {
            case "children":
              $ = Fe;
              break;
            case "dangerouslySetInnerHTML":
              Te = Fe;
              break;
            default:
              Pe(b, q, Se, Fe);
          }
      }
    return b.push($e), Ge(b, Te, $), typeof $ == "string" ? (b.push(s(H($))), null) : $;
  }
  var et = d(`
`), Ke = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Be = /* @__PURE__ */ new Map();
  function ze(b) {
    var R = Be.get(b);
    if (R === void 0) {
      if (!Ke.test(b))
        throw Error(t(65, b));
      R = d("<" + b), Be.set(b, R);
    }
    return R;
  }
  var gt = d("<!DOCTYPE html>");
  function Ye(b, R, $, q, Te) {
    switch (R) {
      case "select":
        b.push(ze("select"));
        var Se = null, Fe = null;
        for (Rt in $)
          if (y.call($, Rt)) {
            var Ue = $[Rt];
            if (Ue != null)
              switch (Rt) {
                case "children":
                  Se = Ue;
                  break;
                case "dangerouslySetInnerHTML":
                  Fe = Ue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  Pe(b, q, Rt, Ue);
              }
          }
        return b.push($e), Ge(b, Fe, Se), Se;
      case "option":
        Fe = Te.selectedValue, b.push(ze("option"));
        var St = Ue = null, Ot = null, Rt = null;
        for (Se in $)
          if (y.call($, Se)) {
            var rn = $[Se];
            if (rn != null)
              switch (Se) {
                case "children":
                  Ue = rn;
                  break;
                case "selected":
                  Ot = rn;
                  break;
                case "dangerouslySetInnerHTML":
                  Rt = rn;
                  break;
                case "value":
                  St = rn;
                default:
                  Pe(b, q, Se, rn);
              }
          }
        if (Fe != null)
          if ($ = St !== null ? "" + St : Xe(Ue), te(Fe)) {
            for (q = 0; q < Fe.length; q++)
              if ("" + Fe[q] === $) {
                b.push(We);
                break;
              }
          } else
            "" + Fe === $ && b.push(We);
        else
          Ot && b.push(We);
        return b.push($e), Ge(b, Rt, Ue), Ue;
      case "textarea":
        b.push(ze("textarea")), Rt = Fe = Se = null;
        for (Ue in $)
          if (y.call($, Ue) && (St = $[Ue], St != null))
            switch (Ue) {
              case "children":
                Rt = St;
                break;
              case "value":
                Se = St;
                break;
              case "defaultValue":
                Fe = St;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                Pe(b, q, Ue, St);
            }
        if (Se === null && Fe !== null && (Se = Fe), b.push($e), Rt != null) {
          if (Se != null)
            throw Error(t(92));
          if (te(Rt) && 1 < Rt.length)
            throw Error(t(93));
          Se = "" + Rt;
        }
        return typeof Se == "string" && Se[0] === `
` && b.push(et), Se !== null && b.push(s(H("" + Se))), null;
      case "input":
        b.push(ze("input")), St = Rt = Ue = Se = null;
        for (Fe in $)
          if (y.call($, Fe) && (Ot = $[Fe], Ot != null))
            switch (Fe) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                St = Ot;
                break;
              case "defaultValue":
                Ue = Ot;
                break;
              case "checked":
                Rt = Ot;
                break;
              case "value":
                Se = Ot;
                break;
              default:
                Pe(b, q, Fe, Ot);
            }
        return Rt !== null ? Pe(
          b,
          q,
          "checked",
          Rt
        ) : St !== null && Pe(b, q, "checked", St), Se !== null ? Pe(b, q, "value", Se) : Ue !== null && Pe(b, q, "value", Ue), b.push(qe), null;
      case "menuitem":
        b.push(ze("menuitem"));
        for (var Un in $)
          if (y.call($, Un) && (Se = $[Un], Se != null))
            switch (Un) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                Pe(b, q, Un, Se);
            }
        return b.push($e), null;
      case "title":
        b.push(ze("title")), Se = null;
        for (rn in $)
          if (y.call($, rn) && (Fe = $[rn], Fe != null))
            switch (rn) {
              case "children":
                Se = Fe;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                Pe(b, q, rn, Fe);
            }
        return b.push($e), Se;
      case "listing":
      case "pre":
        b.push(ze(R)), Fe = Se = null;
        for (St in $)
          if (y.call($, St) && (Ue = $[St], Ue != null))
            switch (St) {
              case "children":
                Se = Ue;
                break;
              case "dangerouslySetInnerHTML":
                Fe = Ue;
                break;
              default:
                Pe(b, q, St, Ue);
            }
        if (b.push($e), Fe != null) {
          if (Se != null)
            throw Error(t(60));
          if (typeof Fe != "object" || !("__html" in Fe))
            throw Error(t(61));
          $ = Fe.__html, $ != null && (typeof $ == "string" && 0 < $.length && $[0] === `
` ? b.push(et, s($)) : b.push(s("" + $)));
        }
        return typeof Se == "string" && Se[0] === `
` && b.push(et), Se;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        b.push(ze(R));
        for (var Jn in $)
          if (y.call($, Jn) && (Se = $[Jn], Se != null))
            switch (Jn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, R));
              default:
                Pe(b, q, Jn, Se);
            }
        return b.push(qe), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return vt(b, $, R, q);
      case "html":
        return Te.insertionMode === 0 && b.push(gt), vt(b, $, R, q);
      default:
        if (R.indexOf("-") === -1 && typeof $.is != "string")
          return vt(b, $, R, q);
        b.push(ze(R)), Fe = Se = null;
        for (Ot in $)
          if (y.call($, Ot) && (Ue = $[Ot], Ue != null))
            switch (Ot) {
              case "children":
                Se = Ue;
                break;
              case "dangerouslySetInnerHTML":
                Fe = Ue;
                break;
              case "style":
                He(b, q, Ue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                O(Ot) && typeof Ue != "function" && typeof Ue != "symbol" && b.push(we, s(Ot), ge, s(H(Ue)), ke);
            }
        return b.push($e), Ge(b, Fe, Se), Se;
    }
  }
  var dt = d("</"), xt = d(">"), ft = d('<template id="'), lt = d('"></template>'), Dt = d("<!--$-->"), on = d('<!--$?--><template id="'), Xt = d('"></template>'), tn = d("<!--$!-->"), mn = d("<!--/$-->"), zt = d("<template"), Vt = d('"'), _e = d(' data-dgst="');
  d(' data-msg="'), d(' data-stck="');
  var En = d("></template>");
  function nn(b, R, $) {
    if (r(b, on), $ === null)
      throw Error(t(395));
    return r(b, $), o(b, Xt);
  }
  var Kt = d('<div hidden id="'), wn = d('">'), ut = d("</div>"), dn = d('<svg aria-hidden="true" style="display:none" id="'), It = d('">'), vn = d("</svg>"), xn = d('<math aria-hidden="true" style="display:none" id="'), qt = d('">'), fn = d("</math>"), Et = d('<table hidden id="'), Nn = d('">'), Ln = d("</table>"), Bn = d('<table hidden><tbody id="'), Ht = d('">'), Fn = d("</tbody></table>"), Oe = d('<table hidden><tr id="'), ht = d('">'), it = d("</tr></table>"), nt = d('<table hidden><colgroup id="'), ln = d('">'), Gt = d("</colgroup></table>");
  function K(b, R, $, q) {
    switch ($.insertionMode) {
      case 0:
      case 1:
        return r(b, Kt), r(b, R.segmentPrefix), r(b, s(q.toString(16))), o(b, wn);
      case 2:
        return r(b, dn), r(b, R.segmentPrefix), r(b, s(q.toString(16))), o(b, It);
      case 3:
        return r(b, xn), r(b, R.segmentPrefix), r(b, s(q.toString(16))), o(b, qt);
      case 4:
        return r(b, Et), r(b, R.segmentPrefix), r(b, s(q.toString(16))), o(b, Nn);
      case 5:
        return r(b, Bn), r(b, R.segmentPrefix), r(b, s(q.toString(16))), o(b, Ht);
      case 6:
        return r(b, Oe), r(b, R.segmentPrefix), r(b, s(q.toString(16))), o(b, ht);
      case 7:
        return r(
          b,
          nt
        ), r(b, R.segmentPrefix), r(b, s(q.toString(16))), o(b, ln);
      default:
        throw Error(t(397));
    }
  }
  function Ne(b, R) {
    switch (R.insertionMode) {
      case 0:
      case 1:
        return o(b, ut);
      case 2:
        return o(b, vn);
      case 3:
        return o(b, fn);
      case 4:
        return o(b, Ln);
      case 5:
        return o(b, Fn);
      case 6:
        return o(b, it);
      case 7:
        return o(b, Gt);
      default:
        throw Error(t(397));
    }
  }
  var Ze = d('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), je = d('$RS("'), kt = d('","'), rt = d('")<\/script>'), wt = d('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Mt = d('$RC("'), Qe = d('","'), pt = d('")<\/script>'), Nt = d('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), _t = d('$RX("'), jt = d('"'), Ft = d(")<\/script>"), Ct = d(","), Zt = /[<\u2028\u2029]/g;
  function Ut(b) {
    return JSON.stringify(b).replace(Zt, function(R) {
      switch (R) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var Qt = Object.assign, sn = Symbol.for("react.element"), un = Symbol.for("react.portal"), gn = Symbol.for("react.fragment"), Rn = Symbol.for("react.strict_mode"), cn = Symbol.for("react.profiler"), Tn = Symbol.for("react.provider"), In = Symbol.for("react.context"), Yn = Symbol.for("react.forward_ref"), Zn = Symbol.for("react.suspense"), Xn = Symbol.for("react.suspense_list"), x = Symbol.for("react.memo"), P = Symbol.for("react.lazy"), B = Symbol.for("react.scope"), Y = Symbol.for("react.debug_trace_mode"), Ee = Symbol.for("react.legacy_hidden"), xe = Symbol.for("react.default_value"), De = Symbol.iterator;
  function Ve(b) {
    if (b == null)
      return null;
    if (typeof b == "function")
      return b.displayName || b.name || null;
    if (typeof b == "string")
      return b;
    switch (b) {
      case gn:
        return "Fragment";
      case un:
        return "Portal";
      case cn:
        return "Profiler";
      case Rn:
        return "StrictMode";
      case Zn:
        return "Suspense";
      case Xn:
        return "SuspenseList";
    }
    if (typeof b == "object")
      switch (b.$$typeof) {
        case In:
          return (b.displayName || "Context") + ".Consumer";
        case Tn:
          return (b._context.displayName || "Context") + ".Provider";
        case Yn:
          var R = b.render;
          return b = b.displayName, b || (b = R.displayName || R.name || "", b = b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef"), b;
        case x:
          return R = b.displayName || null, R !== null ? R : Ve(b.type) || "Memo";
        case P:
          R = b._payload, b = b._init;
          try {
            return Ve(b(R));
          } catch {
          }
      }
    return null;
  }
  var ot = {};
  function yt(b, R) {
    if (b = b.contextTypes, !b)
      return ot;
    var $ = {}, q;
    for (q in b)
      $[q] = R[q];
    return $;
  }
  var oe = null;
  function le(b, R) {
    if (b !== R) {
      b.context._currentValue = b.parentValue, b = b.parent;
      var $ = R.parent;
      if (b === null) {
        if ($ !== null)
          throw Error(t(401));
      } else {
        if ($ === null)
          throw Error(t(401));
        le(b, $);
      }
      R.context._currentValue = R.value;
    }
  }
  function ve(b) {
    b.context._currentValue = b.parentValue, b = b.parent, b !== null && ve(b);
  }
  function Me(b) {
    var R = b.parent;
    R !== null && Me(R), b.context._currentValue = b.value;
  }
  function bt(b, R) {
    if (b.context._currentValue = b.parentValue, b = b.parent, b === null)
      throw Error(t(402));
    b.depth === R.depth ? le(b, R) : bt(b, R);
  }
  function bn(b, R) {
    var $ = R.parent;
    if ($ === null)
      throw Error(t(402));
    b.depth === $.depth ? le(b, $) : bn(b, $), R.context._currentValue = R.value;
  }
  function An(b) {
    var R = oe;
    R !== b && (R === null ? Me(b) : b === null ? ve(R) : R.depth === b.depth ? le(R, b) : R.depth > b.depth ? bt(R, b) : bn(R, b), oe = b);
  }
  var fr = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(b, R) {
    b = b._reactInternals, b.queue !== null && b.queue.push(R);
  }, enqueueReplaceState: function(b, R) {
    b = b._reactInternals, b.replace = !0, b.queue = [R];
  }, enqueueForceUpdate: function() {
  } };
  function Hn(b, R, $, q) {
    var Te = b.state !== void 0 ? b.state : null;
    b.updater = fr, b.props = $, b.state = Te;
    var Se = { queue: [], replace: !1 };
    b._reactInternals = Se;
    var Fe = R.contextType;
    if (b.context = typeof Fe == "object" && Fe !== null ? Fe._currentValue : q, Fe = R.getDerivedStateFromProps, typeof Fe == "function" && (Fe = Fe($, Te), Te = Fe == null ? Te : Qt({}, Te, Fe), b.state = Te), typeof R.getDerivedStateFromProps != "function" && typeof b.getSnapshotBeforeUpdate != "function" && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function"))
      if (R = b.state, typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(), R !== b.state && fr.enqueueReplaceState(b, b.state, null), Se.queue !== null && 0 < Se.queue.length)
        if (R = Se.queue, Fe = Se.replace, Se.queue = null, Se.replace = !1, Fe && R.length === 1)
          b.state = R[0];
        else {
          for (Se = Fe ? R[0] : b.state, Te = !0, Fe = Fe ? 1 : 0; Fe < R.length; Fe++) {
            var Ue = R[Fe];
            Ue = typeof Ue == "function" ? Ue.call(b, Se, $, q) : Ue, Ue != null && (Te ? (Te = !1, Se = Qt({}, Se, Ue)) : Qt(Se, Ue));
          }
          b.state = Se;
        }
      else
        Se.queue = null;
  }
  var Cr = { id: 1, overflow: "" };
  function hr(b, R, $) {
    var q = b.id;
    b = b.overflow;
    var Te = 32 - Qr(q) - 1;
    q &= ~(1 << Te), $ += 1;
    var Se = 32 - Qr(R) + Te;
    if (30 < Se) {
      var Fe = Te - Te % 5;
      return Se = (q & (1 << Fe) - 1).toString(32), q >>= Fe, Te -= Fe, { id: 1 << 32 - Qr(R) + Te | $ << Te | q, overflow: Se + b };
    }
    return { id: 1 << Se | $ << Te | q, overflow: b };
  }
  var Qr = Math.clz32 ? Math.clz32 : Ua, ol = Math.log, ll = Math.LN2;
  function Ua(b) {
    return b >>>= 0, b === 0 ? 32 : 31 - (ol(b) / ll | 0) | 0;
  }
  function sl(b, R) {
    return b === R && (b !== 0 || 1 / b === 1 / R) || b !== b && R !== R;
  }
  var Ka = typeof Object.is == "function" ? Object.is : sl, pr = null, Jr = null, pa = null, en = null, yr = !1, Vn = !1, Ar = 0, vr = null, ma = 0;
  function xr() {
    if (pr === null)
      throw Error(t(321));
    return pr;
  }
  function Qn() {
    if (0 < ma)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function Ya() {
    return en === null ? pa === null ? (yr = !1, pa = en = Qn()) : (yr = !0, en = pa) : en.next === null ? (yr = !1, en = en.next = Qn()) : (yr = !0, en = en.next), en;
  }
  function Xa() {
    Jr = pr = null, Vn = !1, pa = null, ma = 0, en = vr = null;
  }
  function ji(b, R) {
    return typeof R == "function" ? R(b) : R;
  }
  function Ui(b, R, $) {
    if (pr = xr(), en = Ya(), yr) {
      var q = en.queue;
      if (R = q.dispatch, vr !== null && ($ = vr.get(q), $ !== void 0)) {
        vr.delete(q), q = en.memoizedState;
        do
          q = b(q, $.action), $ = $.next;
        while ($ !== null);
        return en.memoizedState = q, [q, R];
      }
      return [en.memoizedState, R];
    }
    return b = b === ji ? typeof R == "function" ? R() : R : $ !== void 0 ? $(R) : R, en.memoizedState = b, b = en.queue = { last: null, dispatch: null }, b = b.dispatch = ul.bind(null, pr, b), [en.memoizedState, b];
  }
  function Ki(b, R) {
    if (pr = xr(), en = Ya(), R = R === void 0 ? null : R, en !== null) {
      var $ = en.memoizedState;
      if ($ !== null && R !== null) {
        var q = $[1];
        e:
          if (q === null)
            q = !1;
          else {
            for (var Te = 0; Te < q.length && Te < R.length; Te++)
              if (!Ka(R[Te], q[Te])) {
                q = !1;
                break e;
              }
            q = !0;
          }
        if (q)
          return $[0];
      }
    }
    return b = b(), en.memoizedState = [b, R], b;
  }
  function ul(b, R, $) {
    if (25 <= ma)
      throw Error(t(301));
    if (b === pr)
      if (Vn = !0, b = { action: $, next: null }, vr === null && (vr = /* @__PURE__ */ new Map()), $ = vr.get(R), $ === void 0)
        vr.set(R, b);
      else {
        for (R = $; R.next !== null; )
          R = R.next;
        R.next = b;
      }
  }
  function cl() {
    throw Error(t(394));
  }
  function ga() {
  }
  var ya = { readContext: function(b) {
    return b._currentValue;
  }, useContext: function(b) {
    return xr(), b._currentValue;
  }, useMemo: Ki, useReducer: Ui, useRef: function(b) {
    pr = xr(), en = Ya();
    var R = en.memoizedState;
    return R === null ? (b = { current: b }, en.memoizedState = b) : R;
  }, useState: function(b) {
    return Ui(ji, b);
  }, useInsertionEffect: ga, useLayoutEffect: function() {
  }, useCallback: function(b, R) {
    return Ki(function() {
      return b;
    }, R);
  }, useImperativeHandle: ga, useEffect: ga, useDebugValue: ga, useDeferredValue: function(b) {
    return xr(), b;
  }, useTransition: function() {
    return xr(), [!1, cl];
  }, useId: function() {
    var b = Jr.treeContext, R = b.overflow;
    b = b.id, b = (b & ~(1 << 32 - Qr(b) - 1)).toString(32) + R;
    var $ = va;
    if ($ === null)
      throw Error(t(404));
    return R = Ar++, b = ":" + $.idPrefix + "R" + b, 0 < R && (b += "H" + R.toString(32)), b + ":";
  }, useMutableSource: function(b, R) {
    return xr(), R(b._source);
  }, useSyncExternalStore: function(b, R, $) {
    if ($ === void 0)
      throw Error(t(407));
    return $();
  } }, va = null, ea = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function dl(b) {
    return console.error(b), null;
  }
  function ta() {
  }
  function qa(b, R, $, q, Te, Se, Fe, Ue, St) {
    var Ot = [], Rt = /* @__PURE__ */ new Set();
    return R = { destination: null, responseState: R, progressiveChunkSize: q === void 0 ? 12800 : q, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Rt, pingedTasks: Ot, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Te === void 0 ? dl : Te, onAllReady: Se === void 0 ? ta : Se, onShellReady: Fe === void 0 ? ta : Fe, onShellError: Ue === void 0 ? ta : Ue, onFatalError: St === void 0 ? ta : St }, $ = Fr(R, 0, null, $, !1, !1), $.parentFlushed = !0, b = Ga(R, b, null, $, Rt, ot, null, Cr), Ot.push(b), R;
  }
  function Ga(b, R, $, q, Te, Se, Fe, Ue) {
    b.allPendingTasks++, $ === null ? b.pendingRootTasks++ : $.pendingTasks++;
    var St = { node: R, ping: function() {
      var Ot = b.pingedTasks;
      Ot.push(St), Ot.length === 1 && Qi(b);
    }, blockedBoundary: $, blockedSegment: q, abortSet: Te, legacyContext: Se, context: Fe, treeContext: Ue };
    return Te.add(St), St;
  }
  function Fr(b, R, $, q, Te, Se) {
    return { status: 0, id: -1, index: R, parentFlushed: !1, chunks: [], children: [], formatContext: q, boundary: $, lastPushedText: Te, textEmbedded: Se };
  }
  function zr(b, R) {
    if (b = b.onError(R), b != null && typeof b != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof b + '" instead');
    return b;
  }
  function xa(b, R) {
    var $ = b.onShellError;
    $(R), $ = b.onFatalError, $(R), b.destination !== null ? (b.status = 2, m(b.destination, R)) : (b.status = 1, b.fatalError = R);
  }
  function Yi(b, R, $, q, Te) {
    for (pr = {}, Jr = R, Ar = 0, b = $(q, Te); Vn; )
      Vn = !1, Ar = 0, ma += 1, en = null, b = $(q, Te);
    return Xa(), b;
  }
  function Za(b, R, $, q) {
    var Te = $.render(), Se = q.childContextTypes;
    if (Se != null) {
      var Fe = R.legacyContext;
      if (typeof $.getChildContext != "function")
        q = Fe;
      else {
        $ = $.getChildContext();
        for (var Ue in $)
          if (!(Ue in Se))
            throw Error(t(108, Ve(q) || "Unknown", Ue));
        q = Qt({}, Fe, $);
      }
      R.legacyContext = q, jn(b, R, Te), R.legacyContext = Fe;
    } else
      jn(b, R, Te);
  }
  function Xi(b, R) {
    if (b && b.defaultProps) {
      R = Qt({}, R), b = b.defaultProps;
      for (var $ in b)
        R[$] === void 0 && (R[$] = b[$]);
      return R;
    }
    return R;
  }
  function ba(b, R, $, q, Te) {
    if (typeof $ == "function")
      if ($.prototype && $.prototype.isReactComponent) {
        Te = yt($, R.legacyContext);
        var Se = $.contextType;
        Se = new $(q, typeof Se == "object" && Se !== null ? Se._currentValue : Te), Hn(Se, $, q, Te), Za(b, R, Se, $);
      } else {
        Se = yt($, R.legacyContext), Te = Yi(b, R, $, q, Se);
        var Fe = Ar !== 0;
        if (typeof Te == "object" && Te !== null && typeof Te.render == "function" && Te.$$typeof === void 0)
          Hn(Te, $, q, Se), Za(b, R, Te, $);
        else if (Fe) {
          q = R.treeContext, R.treeContext = hr(q, 1, 0);
          try {
            jn(b, R, Te);
          } finally {
            R.treeContext = q;
          }
        } else
          jn(b, R, Te);
      }
    else if (typeof $ == "string") {
      switch (Te = R.blockedSegment, Se = Ye(Te.chunks, $, q, b.responseState, Te.formatContext), Te.lastPushedText = !1, Fe = Te.formatContext, Te.formatContext = se(Fe, $, q), Sa(b, R, Se), Te.formatContext = Fe, $) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Te.chunks.push(dt, s($), xt);
      }
      Te.lastPushedText = !1;
    } else {
      switch ($) {
        case Ee:
        case Y:
        case Rn:
        case cn:
        case gn:
          jn(b, R, q.children);
          return;
        case Xn:
          jn(b, R, q.children);
          return;
        case B:
          throw Error(t(343));
        case Zn:
          e: {
            $ = R.blockedBoundary, Te = R.blockedSegment, Se = q.fallback, q = q.children, Fe = /* @__PURE__ */ new Set();
            var Ue = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Fe, errorDigest: null }, St = Fr(b, Te.chunks.length, Ue, Te.formatContext, !1, !1);
            Te.children.push(St), Te.lastPushedText = !1;
            var Ot = Fr(b, 0, null, Te.formatContext, !1, !1);
            Ot.parentFlushed = !0, R.blockedBoundary = Ue, R.blockedSegment = Ot;
            try {
              if (Sa(
                b,
                R,
                q
              ), Ot.lastPushedText && Ot.textEmbedded && Ot.chunks.push(ye), Ot.status = 1, Ea(Ue, Ot), Ue.pendingTasks === 0)
                break e;
            } catch (Rt) {
              Ot.status = 4, Ue.forceClientRender = !0, Ue.errorDigest = zr(b, Rt);
            } finally {
              R.blockedBoundary = $, R.blockedSegment = Te;
            }
            R = Ga(b, Se, $, St, Fe, R.legacyContext, R.context, R.treeContext), b.pingedTasks.push(R);
          }
          return;
      }
      if (typeof $ == "object" && $ !== null)
        switch ($.$$typeof) {
          case Yn:
            if (q = Yi(b, R, $.render, q, Te), Ar !== 0) {
              $ = R.treeContext, R.treeContext = hr($, 1, 0);
              try {
                jn(b, R, q);
              } finally {
                R.treeContext = $;
              }
            } else
              jn(b, R, q);
            return;
          case x:
            $ = $.type, q = Xi($, q), ba(b, R, $, q, Te);
            return;
          case Tn:
            if (Te = q.children, $ = $._context, q = q.value, Se = $._currentValue, $._currentValue = q, Fe = oe, oe = q = { parent: Fe, depth: Fe === null ? 0 : Fe.depth + 1, context: $, parentValue: Se, value: q }, R.context = q, jn(b, R, Te), b = oe, b === null)
              throw Error(t(403));
            q = b.parentValue, b.context._currentValue = q === xe ? b.context._defaultValue : q, b = oe = b.parent, R.context = b;
            return;
          case In:
            q = q.children, q = q($._currentValue), jn(b, R, q);
            return;
          case P:
            Te = $._init, $ = Te($._payload), q = Xi($, q), ba(b, R, $, q, void 0);
            return;
        }
      throw Error(t(
        130,
        $ == null ? $ : typeof $,
        ""
      ));
    }
  }
  function jn(b, R, $) {
    if (R.node = $, typeof $ == "object" && $ !== null) {
      switch ($.$$typeof) {
        case sn:
          ba(b, R, $.type, $.props, $.ref);
          return;
        case un:
          throw Error(t(257));
        case P:
          var q = $._init;
          $ = q($._payload), jn(b, R, $);
          return;
      }
      if (te($)) {
        qi(b, R, $);
        return;
      }
      if ($ === null || typeof $ != "object" ? q = null : (q = De && $[De] || $["@@iterator"], q = typeof q == "function" ? q : null), q && (q = q.call($))) {
        if ($ = q.next(), !$.done) {
          var Te = [];
          do
            Te.push($.value), $ = q.next();
          while (!$.done);
          qi(b, R, Te);
        }
        return;
      }
      throw b = Object.prototype.toString.call($), Error(t(31, b === "[object Object]" ? "object with keys {" + Object.keys($).join(", ") + "}" : b));
    }
    typeof $ == "string" ? (q = R.blockedSegment, q.lastPushedText = me(R.blockedSegment.chunks, $, b.responseState, q.lastPushedText)) : typeof $ == "number" && (q = R.blockedSegment, q.lastPushedText = me(R.blockedSegment.chunks, "" + $, b.responseState, q.lastPushedText));
  }
  function qi(b, R, $) {
    for (var q = $.length, Te = 0; Te < q; Te++) {
      var Se = R.treeContext;
      R.treeContext = hr(Se, q, Te);
      try {
        Sa(b, R, $[Te]);
      } finally {
        R.treeContext = Se;
      }
    }
  }
  function Sa(b, R, $) {
    var q = R.blockedSegment.formatContext, Te = R.legacyContext, Se = R.context;
    try {
      return jn(b, R, $);
    } catch (St) {
      if (Xa(), typeof St == "object" && St !== null && typeof St.then == "function") {
        $ = St;
        var Fe = R.blockedSegment, Ue = Fr(b, Fe.chunks.length, null, Fe.formatContext, Fe.lastPushedText, !0);
        Fe.children.push(Ue), Fe.lastPushedText = !1, b = Ga(b, R.node, R.blockedBoundary, Ue, R.abortSet, R.legacyContext, R.context, R.treeContext).ping, $.then(b, b), R.blockedSegment.formatContext = q, R.legacyContext = Te, R.context = Se, An(Se);
      } else
        throw R.blockedSegment.formatContext = q, R.legacyContext = Te, R.context = Se, An(Se), St;
    }
  }
  function fl(b) {
    var R = b.blockedBoundary;
    b = b.blockedSegment, b.status = 3, Zi(this, R, b);
  }
  function Gi(b, R, $) {
    var q = b.blockedBoundary;
    b.blockedSegment.status = 3, q === null ? (R.allPendingTasks--, R.status !== 2 && (R.status = 2, R.destination !== null && R.destination.close())) : (q.pendingTasks--, q.forceClientRender || (q.forceClientRender = !0, b = $ === void 0 ? Error(t(432)) : $, q.errorDigest = R.onError(b), q.parentFlushed && R.clientRenderedBoundaries.push(q)), q.fallbackAbortableTasks.forEach(function(Te) {
      return Gi(Te, R, $);
    }), q.fallbackAbortableTasks.clear(), R.allPendingTasks--, R.allPendingTasks === 0 && (q = R.onAllReady, q()));
  }
  function Ea(b, R) {
    if (R.chunks.length === 0 && R.children.length === 1 && R.children[0].boundary === null) {
      var $ = R.children[0];
      $.id = R.id, $.parentFlushed = !0, $.status === 1 && Ea(b, $);
    } else
      b.completedSegments.push(R);
  }
  function Zi(b, R, $) {
    if (R === null) {
      if ($.parentFlushed) {
        if (b.completedRootSegment !== null)
          throw Error(t(389));
        b.completedRootSegment = $;
      }
      b.pendingRootTasks--, b.pendingRootTasks === 0 && (b.onShellError = ta, R = b.onShellReady, R());
    } else
      R.pendingTasks--, R.forceClientRender || (R.pendingTasks === 0 ? ($.parentFlushed && $.status === 1 && Ea(R, $), R.parentFlushed && b.completedBoundaries.push(R), R.fallbackAbortableTasks.forEach(fl, b), R.fallbackAbortableTasks.clear()) : $.parentFlushed && $.status === 1 && (Ea(R, $), R.completedSegments.length === 1 && R.parentFlushed && b.partialBoundaries.push(R)));
    b.allPendingTasks--, b.allPendingTasks === 0 && (b = b.onAllReady, b());
  }
  function Qi(b) {
    if (b.status !== 2) {
      var R = oe, $ = ea.current;
      ea.current = ya;
      var q = va;
      va = b.responseState;
      try {
        var Te = b.pingedTasks, Se;
        for (Se = 0; Se < Te.length; Se++) {
          var Fe = Te[Se], Ue = b, St = Fe.blockedSegment;
          if (St.status === 0) {
            An(Fe.context);
            try {
              jn(Ue, Fe, Fe.node), St.lastPushedText && St.textEmbedded && St.chunks.push(ye), Fe.abortSet.delete(Fe), St.status = 1, Zi(Ue, Fe.blockedBoundary, St);
            } catch (er) {
              if (Xa(), typeof er == "object" && er !== null && typeof er.then == "function") {
                var Ot = Fe.ping;
                er.then(Ot, Ot);
              } else {
                Fe.abortSet.delete(Fe), St.status = 4;
                var Rt = Fe.blockedBoundary, rn = er, Un = zr(Ue, rn);
                if (Rt === null ? xa(Ue, rn) : (Rt.pendingTasks--, Rt.forceClientRender || (Rt.forceClientRender = !0, Rt.errorDigest = Un, Rt.parentFlushed && Ue.clientRenderedBoundaries.push(Rt))), Ue.allPendingTasks--, Ue.allPendingTasks === 0) {
                  var Jn = Ue.onAllReady;
                  Jn();
                }
              }
            } finally {
            }
          }
        }
        Te.splice(0, Se), b.destination !== null && Qa(b, b.destination);
      } catch (er) {
        zr(b, er), xa(b, er);
      } finally {
        va = q, ea.current = $, $ === ya && An(R);
      }
    }
  }
  function ka(b, R, $) {
    switch ($.parentFlushed = !0, $.status) {
      case 0:
        var q = $.id = b.nextSegmentId++;
        return $.lastPushedText = !1, $.textEmbedded = !1, b = b.responseState, r(R, ft), r(R, b.placeholderPrefix), b = s(q.toString(16)), r(R, b), o(R, lt);
      case 1:
        $.status = 2;
        var Te = !0;
        q = $.chunks;
        var Se = 0;
        $ = $.children;
        for (var Fe = 0; Fe < $.length; Fe++) {
          for (Te = $[Fe]; Se < Te.index; Se++)
            r(R, q[Se]);
          Te = wa(b, R, Te);
        }
        for (; Se < q.length - 1; Se++)
          r(R, q[Se]);
        return Se < q.length && (Te = o(R, q[Se])), Te;
      default:
        throw Error(t(390));
    }
  }
  function wa(b, R, $) {
    var q = $.boundary;
    if (q === null)
      return ka(b, R, $);
    if (q.parentFlushed = !0, q.forceClientRender)
      q = q.errorDigest, o(R, tn), r(R, zt), q && (r(R, _e), r(R, s(H(q))), r(R, Vt)), o(R, En), ka(b, R, $);
    else if (0 < q.pendingTasks) {
      q.rootSegmentID = b.nextSegmentId++, 0 < q.completedSegments.length && b.partialBoundaries.push(q);
      var Te = b.responseState, Se = Te.nextSuspenseID++;
      Te = d(Te.boundaryPrefix + Se.toString(16)), q = q.id = Te, nn(R, b.responseState, q), ka(b, R, $);
    } else if (q.byteSize > b.progressiveChunkSize)
      q.rootSegmentID = b.nextSegmentId++, b.completedBoundaries.push(q), nn(R, b.responseState, q.id), ka(b, R, $);
    else {
      if (o(R, Dt), $ = q.completedSegments, $.length !== 1)
        throw Error(t(391));
      wa(b, R, $[0]);
    }
    return o(R, mn);
  }
  function Ji(b, R, $) {
    return K(R, b.responseState, $.formatContext, $.id), wa(b, R, $), Ne(R, $.formatContext);
  }
  function eo(b, R, $) {
    for (var q = $.completedSegments, Te = 0; Te < q.length; Te++)
      to(b, R, $, q[Te]);
    if (q.length = 0, b = b.responseState, q = $.id, $ = $.rootSegmentID, r(R, b.startInlineScript), b.sentCompleteBoundaryFunction ? r(R, Mt) : (b.sentCompleteBoundaryFunction = !0, r(R, wt)), q === null)
      throw Error(t(395));
    return $ = s($.toString(16)), r(R, q), r(R, Qe), r(R, b.segmentPrefix), r(R, $), o(R, pt);
  }
  function to(b, R, $, q) {
    if (q.status === 2)
      return !0;
    var Te = q.id;
    if (Te === -1) {
      if ((q.id = $.rootSegmentID) === -1)
        throw Error(t(392));
      return Ji(b, R, q);
    }
    return Ji(b, R, q), b = b.responseState, r(R, b.startInlineScript), b.sentCompleteSegmentFunction ? r(R, je) : (b.sentCompleteSegmentFunction = !0, r(R, Ze)), r(R, b.segmentPrefix), Te = s(Te.toString(16)), r(R, Te), r(R, kt), r(R, b.placeholderPrefix), r(R, Te), o(R, rt);
  }
  function Qa(b, R) {
    n = new Uint8Array(512), a = 0;
    try {
      var $ = b.completedRootSegment;
      if ($ !== null && b.pendingRootTasks === 0) {
        wa(b, R, $), b.completedRootSegment = null;
        var q = b.responseState.bootstrapChunks;
        for ($ = 0; $ < q.length - 1; $++)
          r(R, q[$]);
        $ < q.length && o(R, q[$]);
      }
      var Te = b.clientRenderedBoundaries, Se;
      for (Se = 0; Se < Te.length; Se++) {
        var Fe = Te[Se];
        q = R;
        var Ue = b.responseState, St = Fe.id, Ot = Fe.errorDigest, Rt = Fe.errorMessage, rn = Fe.errorComponentStack;
        if (r(q, Ue.startInlineScript), Ue.sentClientRenderFunction ? r(q, _t) : (Ue.sentClientRenderFunction = !0, r(
          q,
          Nt
        )), St === null)
          throw Error(t(395));
        r(q, St), r(q, jt), (Ot || Rt || rn) && (r(q, Ct), r(q, s(Ut(Ot || "")))), (Rt || rn) && (r(q, Ct), r(q, s(Ut(Rt || "")))), rn && (r(q, Ct), r(q, s(Ut(rn)))), o(q, Ft);
      }
      Te.splice(0, Se);
      var Un = b.completedBoundaries;
      for (Se = 0; Se < Un.length; Se++)
        eo(b, R, Un[Se]);
      Un.splice(0, Se), f(R), n = new Uint8Array(512), a = 0;
      var Jn = b.partialBoundaries;
      for (Se = 0; Se < Jn.length; Se++) {
        var er = Jn[Se];
        e: {
          Te = b, Fe = R;
          var Ta = er.completedSegments;
          for (Ue = 0; Ue < Ta.length; Ue++)
            if (!to(
              Te,
              Fe,
              er,
              Ta[Ue]
            )) {
              Ue++, Ta.splice(0, Ue);
              var ro = !1;
              break e;
            }
          Ta.splice(0, Ue), ro = !0;
        }
        if (!ro) {
          b.destination = null, Se++, Jn.splice(0, Se);
          return;
        }
      }
      Jn.splice(0, Se);
      var Ja = b.completedBoundaries;
      for (Se = 0; Se < Ja.length; Se++)
        eo(b, R, Ja[Se]);
      Ja.splice(0, Se);
    } finally {
      f(R), b.allPendingTasks === 0 && b.pingedTasks.length === 0 && b.clientRenderedBoundaries.length === 0 && b.completedBoundaries.length === 0 && R.close();
    }
  }
  function no(b, R) {
    try {
      var $ = b.abortableTasks;
      $.forEach(function(q) {
        return Gi(q, b, R);
      }), $.clear(), b.destination !== null && Qa(b, b.destination);
    } catch (q) {
      zr(b, q), xa(b, q);
    }
  }
  return _u.renderToReadableStream = function(b, R) {
    return new Promise(function($, q) {
      var Te, Se, Fe = new Promise(function(Rt, rn) {
        Se = Rt, Te = rn;
      }), Ue = qa(b, ue(R ? R.identifierPrefix : void 0, R ? R.nonce : void 0, R ? R.bootstrapScriptContent : void 0, R ? R.bootstrapScripts : void 0, R ? R.bootstrapModules : void 0), Z(R ? R.namespaceURI : void 0), R ? R.progressiveChunkSize : void 0, R ? R.onError : void 0, Se, function() {
        var Rt = new ReadableStream({ type: "bytes", pull: function(rn) {
          if (Ue.status === 1)
            Ue.status = 2, m(rn, Ue.fatalError);
          else if (Ue.status !== 2 && Ue.destination === null) {
            Ue.destination = rn;
            try {
              Qa(Ue, rn);
            } catch (Un) {
              zr(Ue, Un), xa(Ue, Un);
            }
          }
        }, cancel: function() {
          no(Ue);
        } }, { highWaterMark: 0 });
        Rt.allReady = Fe, $(Rt);
      }, function(Rt) {
        Fe.catch(function() {
        }), q(Rt);
      }, Te);
      if (R && R.signal) {
        var St = R.signal, Ot = function() {
          no(Ue, St.reason), St.removeEventListener("abort", Ot);
        };
        St.addEventListener("abort", Ot);
      }
      Qi(Ue);
    });
  }, _u.version = "18.2.0", _u;
}
var Ri = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var im;
function RE() {
  return im || (im = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ce, t = "18.2.0", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(l) {
      {
        for (var h = arguments.length, S = new Array(h > 1 ? h - 1 : 0), A = 1; A < h; A++)
          S[A - 1] = arguments[A];
        o("warn", l, S);
      }
    }
    function r(l) {
      {
        for (var h = arguments.length, S = new Array(h > 1 ? h - 1 : 0), A = 1; A < h; A++)
          S[A - 1] = arguments[A];
        o("error", l, S);
      }
    }
    function o(l, h, S) {
      {
        var A = n.ReactDebugCurrentFrame, z = A.getStackAddendum();
        z !== "" && (h += "%s", S = S.concat([z]));
        var Q = S.map(function(fe) {
          return String(fe);
        });
        Q.unshift("Warning: " + h), Function.prototype.apply.call(console[l], console, Q);
      }
    }
    function f(l) {
      l();
    }
    function u(l) {
    }
    function s(l, h) {
      d(l, h);
    }
    function d(l, h) {
      return l.push(h);
    }
    function m(l) {
    }
    function y(l) {
      l.push(null);
    }
    function v(l) {
      return l;
    }
    function w(l) {
      return l;
    }
    function E(l, h) {
      l.destroy(h);
    }
    function O(l) {
      {
        var h = typeof Symbol == "function" && Symbol.toStringTag, S = h && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return S;
      }
    }
    function T(l) {
      try {
        return g(l), !1;
      } catch {
        return !0;
      }
    }
    function g(l) {
      return "" + l;
    }
    function N(l, h) {
      if (T(l))
        return r("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", h, O(l)), g(l);
    }
    function L(l, h) {
      if (T(l))
        return r("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", h, O(l)), g(l);
    }
    function M(l) {
      if (T(l))
        return r("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", O(l)), g(l);
    }
    var _ = Object.prototype.hasOwnProperty, C = 0, H = 1, I = 2, X = 3, te = 4, G = 5, F = 6, j = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", U = j + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", W = new RegExp("^[" + j + "][" + U + "]*$"), re = {}, J = {};
    function ue(l) {
      return _.call(J, l) ? !0 : _.call(re, l) ? !1 : W.test(l) ? (J[l] = !0, !0) : (re[l] = !0, r("Invalid attribute name: `%s`", l), !1);
    }
    function ee(l, h, S, A) {
      if (S !== null && S.type === C)
        return !1;
      switch (typeof h) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (A)
            return !1;
          if (S !== null)
            return !S.acceptsBooleans;
          var z = l.toLowerCase().slice(0, 5);
          return z !== "data-" && z !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Z(l) {
      return ye.hasOwnProperty(l) ? ye[l] : null;
    }
    function se(l, h, S, A, z, Q, fe) {
      this.acceptsBooleans = h === I || h === X || h === te, this.attributeName = A, this.attributeNamespace = z, this.mustUseProperty = S, this.propertyName = l, this.type = h, this.sanitizeURL = Q, this.removeEmptyString = fe;
    }
    var ye = {}, me = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    me.forEach(function(l) {
      ye[l] = new se(
        l,
        C,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
      var h = l[0], S = l[1];
      ye[h] = new se(
        h,
        H,
        !1,
        // mustUseProperty
        S,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
      ye[l] = new se(
        l,
        I,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
      ye[l] = new se(
        l,
        I,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(l) {
      ye[l] = new se(
        l,
        X,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ye[l] = new se(
        l,
        X,
        !0,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ye[l] = new se(
        l,
        te,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ye[l] = new se(
        l,
        F,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(l) {
      ye[l] = new se(
        l,
        G,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Le = /[\-\:]([a-z])/g, de = function(l) {
      return l[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var h = l.replace(Le, de);
      ye[h] = new se(
        h,
        H,
        !1,
        // mustUseProperty
        l,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var h = l.replace(Le, de);
      ye[h] = new se(
        h,
        H,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var h = l.replace(Le, de);
      ye[h] = new se(
        h,
        H,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(l) {
      ye[l] = new se(
        l,
        H,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ie = "xlinkHref";
    ye[ie] = new se(
      "xlinkHref",
      H,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(l) {
      ye[l] = new se(
        l,
        H,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ce = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function He(l, h) {
      return l + h.charAt(0).toUpperCase() + h.substring(1);
    }
    var we = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Ce).forEach(function(l) {
      we.forEach(function(h) {
        Ce[He(h, l)] = Ce[l];
      });
    });
    var ge = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function ke(l, h) {
      ge[h.type] || h.onChange || h.onInput || h.readOnly || h.disabled || h.value == null || r("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), h.onChange || h.readOnly || h.disabled || h.checked == null || r("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function ne(l, h) {
      if (l.indexOf("-") === -1)
        return typeof h.is == "string";
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Pe = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, $e = {}, qe = new RegExp("^(aria)-[" + U + "]*$"), Ge = new RegExp("^(aria)[A-Z][" + U + "]*$");
    function Xe(l, h) {
      {
        if (_.call($e, h) && $e[h])
          return !0;
        if (Ge.test(h)) {
          var S = "aria-" + h.slice(4).toLowerCase(), A = Pe.hasOwnProperty(S) ? S : null;
          if (A == null)
            return r("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", h), $e[h] = !0, !0;
          if (h !== A)
            return r("Invalid ARIA attribute `%s`. Did you mean `%s`?", h, A), $e[h] = !0, !0;
        }
        if (qe.test(h)) {
          var z = h.toLowerCase(), Q = Pe.hasOwnProperty(z) ? z : null;
          if (Q == null)
            return $e[h] = !0, !1;
          if (h !== Q)
            return r("Unknown ARIA attribute `%s`. Did you mean `%s`?", h, Q), $e[h] = !0, !0;
        }
      }
      return !0;
    }
    function We(l, h) {
      {
        var S = [];
        for (var A in h) {
          var z = Xe(l, A);
          z || S.push(A);
        }
        var Q = S.map(function(fe) {
          return "`" + fe + "`";
        }).join(", ");
        S.length === 1 ? r("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", Q, l) : S.length > 1 && r("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", Q, l);
      }
    }
    function vt(l, h) {
      ne(l, h) || We(l, h);
    }
    var et = !1;
    function Ke(l, h) {
      {
        if (l !== "input" && l !== "textarea" && l !== "select")
          return;
        h != null && h.value === null && !et && (et = !0, l === "select" && h.multiple ? r("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", l) : r("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", l));
      }
    }
    var Be = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, ze = function() {
    };
    {
      var gt = {}, Ye = /^on./, dt = /^on[^A-Z]/, xt = new RegExp("^(aria)-[" + U + "]*$"), ft = new RegExp("^(aria)[A-Z][" + U + "]*$");
      ze = function(l, h, S, A) {
        if (_.call(gt, h) && gt[h])
          return !0;
        var z = h.toLowerCase();
        if (z === "onfocusin" || z === "onfocusout")
          return r("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), gt[h] = !0, !0;
        if (A != null) {
          var Q = A.registrationNameDependencies, fe = A.possibleRegistrationNames;
          if (Q.hasOwnProperty(h))
            return !0;
          var Ae = fe.hasOwnProperty(z) ? fe[z] : null;
          if (Ae != null)
            return r("Invalid event handler property `%s`. Did you mean `%s`?", h, Ae), gt[h] = !0, !0;
          if (Ye.test(h))
            return r("Unknown event handler property `%s`. It will be ignored.", h), gt[h] = !0, !0;
        } else if (Ye.test(h))
          return dt.test(h) && r("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", h), gt[h] = !0, !0;
        if (xt.test(h) || ft.test(h))
          return !0;
        if (z === "innerhtml")
          return r("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), gt[h] = !0, !0;
        if (z === "aria")
          return r("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), gt[h] = !0, !0;
        if (z === "is" && S !== null && S !== void 0 && typeof S != "string")
          return r("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof S), gt[h] = !0, !0;
        if (typeof S == "number" && isNaN(S))
          return r("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", h), gt[h] = !0, !0;
        var Ie = Z(h), tt = Ie !== null && Ie.type === C;
        if (Be.hasOwnProperty(z)) {
          var st = Be[z];
          if (st !== h)
            return r("Invalid DOM property `%s`. Did you mean `%s`?", h, st), gt[h] = !0, !0;
        } else if (!tt && h !== z)
          return r("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", h, z), gt[h] = !0, !0;
        return typeof S == "boolean" && ee(h, S, Ie, !1) ? (S ? r('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', S, h, h, S, h) : r('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', S, h, h, S, h, h, h), gt[h] = !0, !0) : tt ? !0 : ee(h, S, Ie, !1) ? (gt[h] = !0, !1) : ((S === "false" || S === "true") && Ie !== null && Ie.type === X && (r("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", S, h, S === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', h, S), gt[h] = !0), !0);
      };
    }
    var lt = function(l, h, S) {
      {
        var A = [];
        for (var z in h) {
          var Q = ze(l, z, h[z], S);
          Q || A.push(z);
        }
        var fe = A.map(function(Ae) {
          return "`" + Ae + "`";
        }).join(", ");
        A.length === 1 ? r("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", fe, l) : A.length > 1 && r("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", fe, l);
      }
    };
    function Dt(l, h, S) {
      ne(l, h) || lt(l, h, S);
    }
    var on = function() {
    };
    {
      var Xt = /^(?:webkit|moz|o)[A-Z]/, tn = /^-ms-/, mn = /-(.)/g, zt = /;\s*$/, Vt = {}, _e = {}, En = !1, nn = !1, Kt = function(l) {
        return l.replace(mn, function(h, S) {
          return S.toUpperCase();
        });
      }, wn = function(l) {
        Vt.hasOwnProperty(l) && Vt[l] || (Vt[l] = !0, r(
          "Unsupported style property %s. Did you mean %s?",
          l,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Kt(l.replace(tn, "ms-"))
        ));
      }, ut = function(l) {
        Vt.hasOwnProperty(l) && Vt[l] || (Vt[l] = !0, r("Unsupported vendor-prefixed style property %s. Did you mean %s?", l, l.charAt(0).toUpperCase() + l.slice(1)));
      }, dn = function(l, h) {
        _e.hasOwnProperty(h) && _e[h] || (_e[h] = !0, r(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, l, h.replace(zt, "")));
      }, It = function(l, h) {
        En || (En = !0, r("`NaN` is an invalid value for the `%s` css style property.", l));
      }, vn = function(l, h) {
        nn || (nn = !0, r("`Infinity` is an invalid value for the `%s` css style property.", l));
      };
      on = function(l, h) {
        l.indexOf("-") > -1 ? wn(l) : Xt.test(l) ? ut(l) : zt.test(h) && dn(l, h), typeof h == "number" && (isNaN(h) ? It(l, h) : isFinite(h) || vn(l, h));
      };
    }
    var xn = on, qt = /["'&<>]/;
    function fn(l) {
      M(l);
      var h = "" + l, S = qt.exec(h);
      if (!S)
        return h;
      var A, z = "", Q, fe = 0;
      for (Q = S.index; Q < h.length; Q++) {
        switch (h.charCodeAt(Q)) {
          case 34:
            A = "&quot;";
            break;
          case 38:
            A = "&amp;";
            break;
          case 39:
            A = "&#x27;";
            break;
          case 60:
            A = "&lt;";
            break;
          case 62:
            A = "&gt;";
            break;
          default:
            continue;
        }
        fe !== Q && (z += h.substring(fe, Q)), fe = Q + 1, z += A;
      }
      return fe !== Q ? z + h.substring(fe, Q) : z;
    }
    function Et(l) {
      return typeof l == "boolean" || typeof l == "number" ? "" + l : fn(l);
    }
    var Nn = /([A-Z])/g, Ln = /^ms-/;
    function Bn(l) {
      return l.replace(Nn, "-$1").toLowerCase().replace(Ln, "-ms-");
    }
    var Ht = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Fn = !1;
    function Oe(l) {
      !Fn && Ht.test(l) && (Fn = !0, r("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(l)));
    }
    var ht = Array.isArray;
    function it(l) {
      return ht(l);
    }
    var nt = "<script>", ln = "<\/script>", Gt = '<script src="', K = '<script type="module" src="', Ne = '" async=""><\/script>';
    function Ze(l) {
      return M(l), ("" + l).replace(je, kt);
    }
    var je = /(<\/|<)(s)(cript)/gi, kt = function(l, h, S, A) {
      return "" + h + (S === "s" ? "\\u0073" : "\\u0053") + A;
    };
    function rt(l, h, S, A, z) {
      var Q = l === void 0 ? "" : l, fe = h === void 0 ? nt : '<script nonce="' + Et(h) + '">', Ae = [];
      if (S !== void 0 && Ae.push(fe, Ze(S), ln), A !== void 0)
        for (var Ie = 0; Ie < A.length; Ie++)
          Ae.push(Gt, Et(A[Ie]), Ne);
      if (z !== void 0)
        for (var tt = 0; tt < z.length; tt++)
          Ae.push(K, Et(z[tt]), Ne);
      return {
        bootstrapChunks: Ae,
        startInlineScript: fe,
        placeholderPrefix: Q + "P:",
        segmentPrefix: Q + "S:",
        boundaryPrefix: Q + "B:",
        idPrefix: Q,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var wt = 0, Mt = 1, Qe = 2, pt = 3, Nt = 4, _t = 5, jt = 6, Ft = 7;
    function Ct(l, h) {
      return {
        insertionMode: l,
        selectedValue: h
      };
    }
    function Zt(l, h, S) {
      switch (h) {
        case "select":
          return Ct(Mt, S.value != null ? S.value : S.defaultValue);
        case "svg":
          return Ct(Qe, null);
        case "math":
          return Ct(pt, null);
        case "foreignObject":
          return Ct(Mt, null);
        case "table":
          return Ct(Nt, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return Ct(_t, null);
        case "colgroup":
          return Ct(Ft, null);
        case "tr":
          return Ct(jt, null);
      }
      return l.insertionMode >= Nt || l.insertionMode === wt ? Ct(Mt, null) : l;
    }
    var Ut = null;
    function Qt(l) {
      var h = l.nextSuspenseID++;
      return l.boundaryPrefix + h.toString(16);
    }
    function sn(l, h, S) {
      var A = l.idPrefix, z = ":" + A + "R" + h;
      return S > 0 && (z += "H" + S.toString(32)), z + ":";
    }
    function un(l) {
      return Et(l);
    }
    var gn = "<!-- -->";
    function Rn(l, h, S, A) {
      return h === "" ? A : (A && l.push(gn), l.push(un(h)), !0);
    }
    function cn(l, h, S, A) {
      S && A && l.push(gn);
    }
    var Tn = /* @__PURE__ */ new Map();
    function In(l) {
      var h = Tn.get(l);
      if (h !== void 0)
        return h;
      var S = Et(Bn(l));
      return Tn.set(l, S), S;
    }
    var Yn = ' style="', Zn = ":", Xn = ";";
    function x(l, h, S) {
      if (typeof S != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var A = !0;
      for (var z in S)
        if (_.call(S, z)) {
          var Q = S[z];
          if (!(Q == null || typeof Q == "boolean" || Q === "")) {
            var fe = void 0, Ae = void 0, Ie = z.indexOf("--") === 0;
            Ie ? (fe = Et(z), L(Q, z), Ae = Et(("" + Q).trim())) : (xn(z, Q), fe = In(z), typeof Q == "number" ? Q !== 0 && !_.call(Ce, z) ? Ae = Q + "px" : Ae = "" + Q : (L(Q, z), Ae = Et(("" + Q).trim()))), A ? (A = !1, l.push(Yn, fe, Zn, Ae)) : l.push(Xn, fe, Zn, Ae);
          }
        }
      A || l.push(Y);
    }
    var P = " ", B = '="', Y = '"', Ee = '=""';
    function xe(l, h, S, A) {
      switch (S) {
        case "style": {
          x(l, h, A);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(S.length > 2 && (S[0] === "o" || S[0] === "O") && (S[1] === "n" || S[1] === "N"))
      ) {
        var z = Z(S);
        if (z !== null) {
          switch (typeof A) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!z.acceptsBooleans)
                return;
          }
          var Q = z.attributeName, fe = Q;
          switch (z.type) {
            case X:
              A && l.push(P, fe, Ee);
              return;
            case te:
              A === !0 ? l.push(P, fe, Ee) : A === !1 || l.push(P, fe, B, Et(A), Y);
              return;
            case G:
              isNaN(A) || l.push(P, fe, B, Et(A), Y);
              break;
            case F:
              !isNaN(A) && A >= 1 && l.push(P, fe, B, Et(A), Y);
              break;
            default:
              z.sanitizeURL && (N(A, Q), A = "" + A, Oe(A)), l.push(P, fe, B, Et(A), Y);
          }
        } else if (ue(S)) {
          switch (typeof A) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Ae = S.toLowerCase().slice(0, 5);
              if (Ae !== "data-" && Ae !== "aria-")
                return;
            }
          }
          l.push(P, S, B, Et(A), Y);
        }
      }
    }
    var De = ">", Ve = "/>";
    function ot(l, h, S) {
      if (h != null) {
        if (S != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof h != "object" || !("__html" in h))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var A = h.__html;
        A != null && (M(A), l.push("" + A));
      }
    }
    var yt = !1, oe = !1, le = !1, ve = !1, Me = !1, bt = !1, bn = !1;
    function An(l, h) {
      {
        var S = l[h];
        if (S != null) {
          var A = it(S);
          l.multiple && !A ? r("The `%s` prop supplied to <select> must be an array if `multiple` is true.", h) : !l.multiple && A && r("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", h);
        }
      }
    }
    function fr(l, h, S) {
      ke("select", h), An(h, "value"), An(h, "defaultValue"), h.value !== void 0 && h.defaultValue !== void 0 && !le && (r("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), le = !0), l.push(Vn("select"));
      var A = null, z = null;
      for (var Q in h)
        if (_.call(h, Q)) {
          var fe = h[Q];
          if (fe == null)
            continue;
          switch (Q) {
            case "children":
              A = fe;
              break;
            case "dangerouslySetInnerHTML":
              z = fe;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              xe(l, S, Q, fe);
              break;
          }
        }
      return l.push(De), ot(l, z, A), A;
    }
    function Hn(l) {
      var h = "";
      return e.Children.forEach(l, function(S) {
        S != null && (h += S, !Me && typeof S != "string" && typeof S != "number" && (Me = !0, r("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), h;
    }
    var Cr = ' selected=""';
    function hr(l, h, S, A) {
      var z = A.selectedValue;
      l.push(Vn("option"));
      var Q = null, fe = null, Ae = null, Ie = null;
      for (var tt in h)
        if (_.call(h, tt)) {
          var st = h[tt];
          if (st == null)
            continue;
          switch (tt) {
            case "children":
              Q = st;
              break;
            case "selected":
              Ae = st, bn || (r("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), bn = !0);
              break;
            case "dangerouslySetInnerHTML":
              Ie = st;
              break;
            case "value":
              fe = st;
            default:
              xe(l, S, tt, st);
              break;
          }
        }
      if (z != null) {
        var At;
        if (fe !== null ? (N(fe, "value"), At = "" + fe) : (Ie !== null && (bt || (bt = !0, r("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), At = Hn(Q)), it(z))
          for (var hn = 0; hn < z.length; hn++) {
            N(z[hn], "value");
            var $n = "" + z[hn];
            if ($n === At) {
              l.push(Cr);
              break;
            }
          }
        else
          N(z, "select.value"), "" + z === At && l.push(Cr);
      } else
        Ae && l.push(Cr);
      return l.push(De), ot(l, Ie, Q), Q;
    }
    function Qr(l, h, S) {
      ke("input", h), h.checked !== void 0 && h.defaultChecked !== void 0 && !oe && (r("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), oe = !0), h.value !== void 0 && h.defaultValue !== void 0 && !yt && (r("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), yt = !0), l.push(Vn("input"));
      var A = null, z = null, Q = null, fe = null;
      for (var Ae in h)
        if (_.call(h, Ae)) {
          var Ie = h[Ae];
          if (Ie == null)
            continue;
          switch (Ae) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              fe = Ie;
              break;
            case "defaultValue":
              z = Ie;
              break;
            case "checked":
              Q = Ie;
              break;
            case "value":
              A = Ie;
              break;
            default:
              xe(l, S, Ae, Ie);
              break;
          }
        }
      return Q !== null ? xe(l, S, "checked", Q) : fe !== null && xe(l, S, "checked", fe), A !== null ? xe(l, S, "value", A) : z !== null && xe(l, S, "value", z), l.push(Ve), null;
    }
    function ol(l, h, S) {
      ke("textarea", h), h.value !== void 0 && h.defaultValue !== void 0 && !ve && (r("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), ve = !0), l.push(Vn("textarea"));
      var A = null, z = null, Q = null;
      for (var fe in h)
        if (_.call(h, fe)) {
          var Ae = h[fe];
          if (Ae == null)
            continue;
          switch (fe) {
            case "children":
              Q = Ae;
              break;
            case "value":
              A = Ae;
              break;
            case "defaultValue":
              z = Ae;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              xe(l, S, fe, Ae);
              break;
          }
        }
      if (A === null && z !== null && (A = z), l.push(De), Q != null) {
        if (r("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), A != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (it(Q)) {
          if (Q.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          M(Q[0]), A = "" + Q[0];
        }
        M(Q), A = "" + Q;
      }
      return typeof A == "string" && A[0] === `
` && l.push(Jr), A !== null && (N(A, "value"), l.push(un("" + A))), null;
    }
    function ll(l, h, S, A) {
      l.push(Vn(S));
      for (var z in h)
        if (_.call(h, z)) {
          var Q = h[z];
          if (Q == null)
            continue;
          switch (z) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(S + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              xe(l, A, z, Q);
              break;
          }
        }
      return l.push(Ve), null;
    }
    function Ua(l, h, S) {
      l.push(Vn("menuitem"));
      for (var A in h)
        if (_.call(h, A)) {
          var z = h[A];
          if (z == null)
            continue;
          switch (A) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              xe(l, S, A, z);
              break;
          }
        }
      return l.push(De), null;
    }
    function sl(l, h, S) {
      l.push(Vn("title"));
      var A = null;
      for (var z in h)
        if (_.call(h, z)) {
          var Q = h[z];
          if (Q == null)
            continue;
          switch (z) {
            case "children":
              A = Q;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              xe(l, S, z, Q);
              break;
          }
        }
      l.push(De);
      {
        var fe = Array.isArray(A) && A.length < 2 ? A[0] || null : A;
        Array.isArray(A) && A.length > 1 ? r("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : fe != null && fe.$$typeof != null ? r("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : fe != null && typeof fe != "string" && typeof fe != "number" && r("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return A;
    }
    function Ka(l, h, S, A) {
      l.push(Vn(S));
      var z = null, Q = null;
      for (var fe in h)
        if (_.call(h, fe)) {
          var Ae = h[fe];
          if (Ae == null)
            continue;
          switch (fe) {
            case "children":
              z = Ae;
              break;
            case "dangerouslySetInnerHTML":
              Q = Ae;
              break;
            default:
              xe(l, A, fe, Ae);
              break;
          }
        }
      return l.push(De), ot(l, Q, z), typeof z == "string" ? (l.push(un(z)), null) : z;
    }
    function pr(l, h, S, A) {
      l.push(Vn(S));
      var z = null, Q = null;
      for (var fe in h)
        if (_.call(h, fe)) {
          var Ae = h[fe];
          if (Ae == null)
            continue;
          switch (fe) {
            case "children":
              z = Ae;
              break;
            case "dangerouslySetInnerHTML":
              Q = Ae;
              break;
            case "style":
              x(l, A, Ae);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              ue(fe) && typeof Ae != "function" && typeof Ae != "symbol" && l.push(P, fe, B, Et(Ae), Y);
              break;
          }
        }
      return l.push(De), ot(l, Q, z), z;
    }
    var Jr = `
`;
    function pa(l, h, S, A) {
      l.push(Vn(S));
      var z = null, Q = null;
      for (var fe in h)
        if (_.call(h, fe)) {
          var Ae = h[fe];
          if (Ae == null)
            continue;
          switch (fe) {
            case "children":
              z = Ae;
              break;
            case "dangerouslySetInnerHTML":
              Q = Ae;
              break;
            default:
              xe(l, A, fe, Ae);
              break;
          }
        }
      if (l.push(De), Q != null) {
        if (z != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof Q != "object" || !("__html" in Q))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var Ie = Q.__html;
        Ie != null && (typeof Ie == "string" && Ie.length > 0 && Ie[0] === `
` ? l.push(Jr, Ie) : (M(Ie), l.push("" + Ie)));
      }
      return typeof z == "string" && z[0] === `
` && l.push(Jr), z;
    }
    var en = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, yr = /* @__PURE__ */ new Map();
    function Vn(l) {
      var h = yr.get(l);
      if (h === void 0) {
        if (!en.test(l))
          throw new Error("Invalid tag: " + l);
        h = "<" + l, yr.set(l, h);
      }
      return h;
    }
    var Ar = "<!DOCTYPE html>";
    function vr(l, h, S, A, z) {
      switch (vt(h, S), Ke(h, S), Dt(h, S, null), !S.suppressContentEditableWarning && S.contentEditable && S.children != null && r("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), z.insertionMode !== Qe && z.insertionMode !== pt && h.indexOf("-") === -1 && typeof S.is != "string" && h.toLowerCase() !== h && r("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", h), h) {
        case "select":
          return fr(l, S, A);
        case "option":
          return hr(l, S, A, z);
        case "textarea":
          return ol(l, S, A);
        case "input":
          return Qr(l, S, A);
        case "menuitem":
          return Ua(l, S, A);
        case "title":
          return sl(l, S, A);
        case "listing":
        case "pre":
          return pa(l, S, h, A);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return ll(l, S, h, A);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Ka(l, S, h, A);
        case "html":
          return z.insertionMode === wt && l.push(Ar), Ka(l, S, h, A);
        default:
          return h.indexOf("-") === -1 && typeof S.is != "string" ? Ka(l, S, h, A) : pr(l, S, h, A);
      }
    }
    var ma = "</", xr = ">";
    function Qn(l, h, S) {
      switch (h) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          l.push(ma, h, xr);
      }
    }
    function Ya(l, h) {
      for (var S = h.bootstrapChunks, A = 0; A < S.length - 1; A++)
        s(l, S[A]);
      return A < S.length ? d(l, S[A]) : !0;
    }
    var Xa = '<template id="', ji = '"></template>';
    function Ui(l, h, S) {
      s(l, Xa), s(l, h.placeholderPrefix);
      var A = S.toString(16);
      return s(l, A), d(l, ji);
    }
    var Ki = "<!--$-->", ul = '<!--$?--><template id="', cl = '"></template>', ga = "<!--$!-->", ya = "<!--/$-->", va = "<template", ea = '"', dl = ' data-dgst="', ta = ' data-msg="', qa = ' data-stck="', Ga = "></template>";
    function Fr(l, h) {
      return d(l, Ki);
    }
    function zr(l, h, S) {
      if (s(l, ul), S === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, S), d(l, cl);
    }
    function xa(l, h, S, A, z) {
      var Q;
      return Q = d(l, ga), s(l, va), S && (s(l, dl), s(l, Et(S)), s(l, ea)), A && (s(l, ta), s(l, Et(A)), s(l, ea)), z && (s(l, qa), s(l, Et(z)), s(l, ea)), Q = d(l, Ga), Q;
    }
    function Yi(l, h) {
      return d(l, ya);
    }
    function Za(l, h) {
      return d(l, ya);
    }
    function Xi(l, h) {
      return d(l, ya);
    }
    var ba = '<div hidden id="', jn = '">', qi = "</div>", Sa = '<svg aria-hidden="true" style="display:none" id="', fl = '">', Gi = "</svg>", Ea = '<math aria-hidden="true" style="display:none" id="', Zi = '">', Qi = "</math>", ka = '<table hidden id="', wa = '">', Ji = "</table>", eo = '<table hidden><tbody id="', to = '">', Qa = "</tbody></table>", no = '<table hidden><tr id="', b = '">', R = "</tr></table>", $ = '<table hidden><colgroup id="', q = '">', Te = "</colgroup></table>";
    function Se(l, h, S, A) {
      switch (S.insertionMode) {
        case wt:
        case Mt:
          return s(l, ba), s(l, h.segmentPrefix), s(l, A.toString(16)), d(l, jn);
        case Qe:
          return s(l, Sa), s(l, h.segmentPrefix), s(l, A.toString(16)), d(l, fl);
        case pt:
          return s(l, Ea), s(l, h.segmentPrefix), s(l, A.toString(16)), d(l, Zi);
        case Nt:
          return s(l, ka), s(l, h.segmentPrefix), s(l, A.toString(16)), d(l, wa);
        case _t:
          return s(l, eo), s(l, h.segmentPrefix), s(l, A.toString(16)), d(l, to);
        case jt:
          return s(l, no), s(l, h.segmentPrefix), s(l, A.toString(16)), d(l, b);
        case Ft:
          return s(l, $), s(l, h.segmentPrefix), s(l, A.toString(16)), d(l, q);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Fe(l, h) {
      switch (h.insertionMode) {
        case wt:
        case Mt:
          return d(l, qi);
        case Qe:
          return d(l, Gi);
        case pt:
          return d(l, Qi);
        case Nt:
          return d(l, Ji);
        case _t:
          return d(l, Qa);
        case jt:
          return d(l, R);
        case Ft:
          return d(l, Te);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Ue = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", St = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Ot = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Rt = Ue + ';$RS("', rn = '$RS("', Un = '","', Jn = '")<\/script>';
    function er(l, h, S) {
      s(l, h.startInlineScript), h.sentCompleteSegmentFunction ? s(l, rn) : (h.sentCompleteSegmentFunction = !0, s(l, Rt)), s(l, h.segmentPrefix);
      var A = S.toString(16);
      return s(l, A), s(l, Un), s(l, h.placeholderPrefix), s(l, A), d(l, Jn);
    }
    var Ta = St + ';$RC("', ro = '$RC("', Ja = '","', zc = '")<\/script>';
    function $c(l, h, S, A) {
      if (s(l, h.startInlineScript), h.sentCompleteBoundaryFunction ? s(l, ro) : (h.sentCompleteBoundaryFunction = !0, s(l, Ta)), S === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var z = A.toString(16);
      return s(l, S), s(l, Ja), s(l, h.segmentPrefix), s(l, z), d(l, zc);
    }
    var Bc = Ot + ';$RX("', Ic = '$RX("', Hc = '"', Wc = ")<\/script>", hl = ",";
    function Vc(l, h, S, A, z, Q) {
      if (s(l, h.startInlineScript), h.sentClientRenderFunction ? s(l, Ic) : (h.sentClientRenderFunction = !0, s(l, Bc)), S === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return s(l, S), s(l, Hc), (A || z || Q) && (s(l, hl), s(l, pl(A || ""))), (z || Q) && (s(l, hl), s(l, pl(z || ""))), Q && (s(l, hl), s(l, pl(Q))), d(l, Wc);
    }
    var jc = /[<\u2028\u2029]/g;
    function pl(l) {
      var h = JSON.stringify(l);
      return h.replace(jc, function(S) {
        switch (S) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Uc(l, h) {
      var S = rt(h, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: S.bootstrapChunks,
        startInlineScript: S.startInlineScript,
        placeholderPrefix: S.placeholderPrefix,
        segmentPrefix: S.segmentPrefix,
        boundaryPrefix: S.boundaryPrefix,
        idPrefix: S.idPrefix,
        nextSuspenseID: S.nextSuspenseID,
        sentCompleteSegmentFunction: S.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: S.sentCompleteBoundaryFunction,
        sentClientRenderFunction: S.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: l
      };
    }
    function ml() {
      return {
        insertionMode: Mt,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function _s(l, h, S, A) {
      return S.generateStaticMarkup ? (l.push(Et(h)), !1) : Rn(l, h, S, A);
    }
    function Ns(l, h, S, A) {
      if (!h.generateStaticMarkup)
        return cn(l, h, S, A);
    }
    function gl(l, h) {
      return h.generateStaticMarkup ? !0 : Fr(l);
    }
    function or(l, h, S, A, z) {
      return h.generateStaticMarkup ? !0 : xa(l, h, S, A, z);
    }
    function Kc(l, h) {
      return h.generateStaticMarkup ? !0 : Yi(l);
    }
    function Fs(l, h) {
      return h.generateStaticMarkup ? !0 : Xi(l);
    }
    var tr = Object.assign, zs = Symbol.for("react.element"), yl = Symbol.for("react.portal"), ao = Symbol.for("react.fragment"), io = Symbol.for("react.strict_mode"), oo = Symbol.for("react.profiler"), ei = Symbol.for("react.provider"), ti = Symbol.for("react.context"), ni = Symbol.for("react.forward_ref"), Ca = Symbol.for("react.suspense"), vl = Symbol.for("react.suspense_list"), xl = Symbol.for("react.memo"), lo = Symbol.for("react.lazy"), Yc = Symbol.for("react.scope"), $s = Symbol.for("react.debug_trace_mode"), Xc = Symbol.for("react.legacy_hidden"), qc = Symbol.for("react.default_value"), Bs = Symbol.iterator, Is = "@@iterator";
    function Sn(l) {
      if (l === null || typeof l != "object")
        return null;
      var h = Bs && l[Bs] || l[Is];
      return typeof h == "function" ? h : null;
    }
    function ri(l, h, S) {
      var A = l.displayName;
      if (A)
        return A;
      var z = h.displayName || h.name || "";
      return z !== "" ? S + "(" + z + ")" : S;
    }
    function bl(l) {
      return l.displayName || "Context";
    }
    function yn(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && r("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case ao:
          return "Fragment";
        case yl:
          return "Portal";
        case oo:
          return "Profiler";
        case io:
          return "StrictMode";
        case Ca:
          return "Suspense";
        case vl:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ti:
            var h = l;
            return bl(h) + ".Consumer";
          case ei:
            var S = l;
            return bl(S._context) + ".Provider";
          case ni:
            return ri(l, l.render, "ForwardRef");
          case xl:
            var A = l.displayName || null;
            return A !== null ? A : yn(l.type) || "Memo";
          case lo: {
            var z = l, Q = z._payload, fe = z._init;
            try {
              return yn(fe(Q));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Aa = 0, Sl, El, kl, wl, Tl, Hs, Ws;
    function so() {
    }
    so.__reactDisabledLog = !0;
    function Cl() {
      {
        if (Aa === 0) {
          Sl = console.log, El = console.info, kl = console.warn, wl = console.error, Tl = console.group, Hs = console.groupCollapsed, Ws = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: so,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        Aa++;
      }
    }
    function ai() {
      {
        if (Aa--, Aa === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: tr({}, l, {
              value: Sl
            }),
            info: tr({}, l, {
              value: El
            }),
            warn: tr({}, l, {
              value: kl
            }),
            error: tr({}, l, {
              value: wl
            }),
            group: tr({}, l, {
              value: Tl
            }),
            groupCollapsed: tr({}, l, {
              value: Hs
            }),
            groupEnd: tr({}, l, {
              value: Ws
            })
          });
        }
        Aa < 0 && r("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ii = n.ReactCurrentDispatcher, Pa;
    function oi(l, h, S) {
      {
        if (Pa === void 0)
          try {
            throw Error();
          } catch (z) {
            var A = z.stack.trim().match(/\n( *(at )?)/);
            Pa = A && A[1] || "";
          }
        return `
` + Pa + l;
      }
    }
    var li = !1, uo;
    {
      var Vs = typeof WeakMap == "function" ? WeakMap : Map;
      uo = new Vs();
    }
    function Al(l, h) {
      if (!l || li)
        return "";
      {
        var S = uo.get(l);
        if (S !== void 0)
          return S;
      }
      var A;
      li = !0;
      var z = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Q;
      Q = ii.current, ii.current = null, Cl();
      try {
        if (h) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (cr) {
              A = cr;
            }
            Reflect.construct(l, [], fe);
          } else {
            try {
              fe.call();
            } catch (cr) {
              A = cr;
            }
            l.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (cr) {
            A = cr;
          }
          l();
        }
      } catch (cr) {
        if (cr && A && typeof cr.stack == "string") {
          for (var Ae = cr.stack.split(`
`), Ie = A.stack.split(`
`), tt = Ae.length - 1, st = Ie.length - 1; tt >= 1 && st >= 0 && Ae[tt] !== Ie[st]; )
            st--;
          for (; tt >= 1 && st >= 0; tt--, st--)
            if (Ae[tt] !== Ie[st]) {
              if (tt !== 1 || st !== 1)
                do
                  if (tt--, st--, st < 0 || Ae[tt] !== Ie[st]) {
                    var At = `
` + Ae[tt].replace(" at new ", " at ");
                    return l.displayName && At.includes("<anonymous>") && (At = At.replace("<anonymous>", l.displayName)), typeof l == "function" && uo.set(l, At), At;
                  }
                while (tt >= 1 && st >= 0);
              break;
            }
        }
      } finally {
        li = !1, ii.current = Q, ai(), Error.prepareStackTrace = z;
      }
      var hn = l ? l.displayName || l.name : "", $n = hn ? oi(hn) : "";
      return typeof l == "function" && uo.set(l, $n), $n;
    }
    function Pl(l, h, S) {
      return Al(l, !0);
    }
    function Ll(l, h, S) {
      return Al(l, !1);
    }
    function js(l) {
      var h = l.prototype;
      return !!(h && h.isReactComponent);
    }
    function La(l, h, S) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return Al(l, js(l));
      if (typeof l == "string")
        return oi(l);
      switch (l) {
        case Ca:
          return oi("Suspense");
        case vl:
          return oi("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case ni:
            return Ll(l.render);
          case xl:
            return La(l.type, h, S);
          case lo: {
            var A = l, z = A._payload, Q = A._init;
            try {
              return La(Q(z), h, S);
            } catch {
            }
          }
        }
      return "";
    }
    var Rl = {}, co = n.ReactDebugCurrentFrame;
    function na(l) {
      if (l) {
        var h = l._owner, S = La(l.type, l._source, h ? h.type : null);
        co.setExtraStackFrame(S);
      } else
        co.setExtraStackFrame(null);
    }
    function Dl(l, h, S, A, z) {
      {
        var Q = Function.call.bind(_);
        for (var fe in l)
          if (Q(l, fe)) {
            var Ae = void 0;
            try {
              if (typeof l[fe] != "function") {
                var Ie = Error((A || "React class") + ": " + S + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ie.name = "Invariant Violation", Ie;
              }
              Ae = l[fe](h, fe, A, S, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (tt) {
              Ae = tt;
            }
            Ae && !(Ae instanceof Error) && (na(z), r("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", A || "React class", S, fe, typeof Ae), na(null)), Ae instanceof Error && !(Ae.message in Rl) && (Rl[Ae.message] = !0, na(z), r("Failed %s type: %s", S, Ae.message), na(null));
          }
      }
    }
    var Ol;
    Ol = {};
    var $r = {};
    Object.freeze($r);
    function Us(l, h) {
      {
        var S = l.contextTypes;
        if (!S)
          return $r;
        var A = {};
        for (var z in S)
          A[z] = h[z];
        {
          var Q = yn(l) || "Unknown";
          Dl(S, A, "context", Q);
        }
        return A;
      }
    }
    function ra(l, h, S, A) {
      {
        if (typeof l.getChildContext != "function") {
          {
            var z = yn(h) || "Unknown";
            Ol[z] || (Ol[z] = !0, r("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", z, z));
          }
          return S;
        }
        var Q = l.getChildContext();
        for (var fe in Q)
          if (!(fe in A))
            throw new Error((yn(h) || "Unknown") + '.getChildContext(): key "' + fe + '" is not defined in childContextTypes.');
        {
          var Ae = yn(h) || "Unknown";
          Dl(A, Q, "child context", Ae);
        }
        return tr({}, S, Q);
      }
    }
    var aa;
    aa = {};
    var Ml = null, br = null;
    function fo(l) {
      l.context._currentValue2 = l.parentValue;
    }
    function ho(l) {
      l.context._currentValue2 = l.value;
    }
    function si(l, h) {
      if (l !== h) {
        fo(l);
        var S = l.parent, A = h.parent;
        if (S === null) {
          if (A !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (A === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          si(S, A);
        }
        ho(h);
      }
    }
    function _l(l) {
      fo(l);
      var h = l.parent;
      h !== null && _l(h);
    }
    function ui(l) {
      var h = l.parent;
      h !== null && ui(h), ho(l);
    }
    function Ks(l, h) {
      fo(l);
      var S = l.parent;
      if (S === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      S.depth === h.depth ? si(S, h) : Ks(S, h);
    }
    function Ys(l, h) {
      var S = h.parent;
      if (S === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      l.depth === S.depth ? si(l, S) : Ys(l, S), ho(h);
    }
    function po(l) {
      var h = br, S = l;
      h !== S && (h === null ? ui(S) : S === null ? _l(h) : h.depth === S.depth ? si(h, S) : h.depth > S.depth ? Ks(h, S) : Ys(h, S), br = S);
    }
    function ci(l, h) {
      var S;
      S = l._currentValue2, l._currentValue2 = h, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== aa && r("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = aa;
      var A = br, z = {
        parent: A,
        depth: A === null ? 0 : A.depth + 1,
        context: l,
        parentValue: S,
        value: h
      };
      return br = z, z;
    }
    function Nl(l) {
      var h = br;
      if (h === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      h.context !== l && r("The parent context is not the expected context. This is probably a bug in React.");
      {
        var S = h.parentValue;
        S === qc ? h.context._currentValue2 = h.context._defaultValue : h.context._currentValue2 = S, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== aa && r("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = aa;
      }
      return br = h.parent;
    }
    function Gc() {
      return br;
    }
    function Ra(l) {
      var h = l._currentValue2;
      return h;
    }
    function mo(l) {
      return l._reactInternals;
    }
    function Fl(l, h) {
      l._reactInternals = h;
    }
    var go = {}, yo = {}, di, vo, Da, fi, xo, Oa, bo, So, Eo;
    {
      di = /* @__PURE__ */ new Set(), vo = /* @__PURE__ */ new Set(), Da = /* @__PURE__ */ new Set(), bo = /* @__PURE__ */ new Set(), fi = /* @__PURE__ */ new Set(), So = /* @__PURE__ */ new Set(), Eo = /* @__PURE__ */ new Set();
      var Xs = /* @__PURE__ */ new Set();
      Oa = function(l, h) {
        if (!(l === null || typeof l == "function")) {
          var S = h + "_" + l;
          Xs.has(S) || (Xs.add(S), r("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", h, l));
        }
      }, xo = function(l, h) {
        if (h === void 0) {
          var S = yn(l) || "Component";
          fi.has(S) || (fi.add(S), r("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", S));
        }
      };
    }
    function qs(l, h) {
      {
        var S = l.constructor, A = S && yn(S) || "ReactClass", z = A + "." + h;
        if (go[z])
          return;
        r(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, h, h, A), go[z] = !0;
      }
    }
    var Gs = {
      isMounted: function(l) {
        return !1;
      },
      enqueueSetState: function(l, h, S) {
        var A = mo(l);
        A.queue === null ? qs(l, "setState") : (A.queue.push(h), S != null && Oa(S, "setState"));
      },
      enqueueReplaceState: function(l, h, S) {
        var A = mo(l);
        A.replace = !0, A.queue = [h], S != null && Oa(S, "setState");
      },
      enqueueForceUpdate: function(l, h) {
        var S = mo(l);
        S.queue === null ? qs(l, "forceUpdate") : h != null && Oa(h, "setState");
      }
    };
    function Zc(l, h, S, A, z) {
      var Q = S(z, A);
      xo(h, Q);
      var fe = Q == null ? A : tr({}, A, Q);
      return fe;
    }
    function Qc(l, h, S) {
      var A = $r, z = l.contextType;
      if ("contextType" in l) {
        var Q = (
          // Allow null for conditional declaration
          z === null || z !== void 0 && z.$$typeof === ti && z._context === void 0
        );
        if (!Q && !Eo.has(l)) {
          Eo.add(l);
          var fe = "";
          z === void 0 ? fe = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof z != "object" ? fe = " However, it is set to a " + typeof z + "." : z.$$typeof === ei ? fe = " Did you accidentally pass the Context.Provider instead?" : z._context !== void 0 ? fe = " Did you accidentally pass the Context.Consumer instead?" : fe = " However, it is set to an object with keys {" + Object.keys(z).join(", ") + "}.", r("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", yn(l) || "Component", fe);
        }
      }
      typeof z == "object" && z !== null ? A = Ra(z) : A = S;
      var Ae = new l(h, A);
      {
        if (typeof l.getDerivedStateFromProps == "function" && (Ae.state === null || Ae.state === void 0)) {
          var Ie = yn(l) || "Component";
          di.has(Ie) || (di.add(Ie), r("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Ie, Ae.state === null ? "null" : "undefined", Ie));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof Ae.getSnapshotBeforeUpdate == "function") {
          var tt = null, st = null, At = null;
          if (typeof Ae.componentWillMount == "function" && Ae.componentWillMount.__suppressDeprecationWarning !== !0 ? tt = "componentWillMount" : typeof Ae.UNSAFE_componentWillMount == "function" && (tt = "UNSAFE_componentWillMount"), typeof Ae.componentWillReceiveProps == "function" && Ae.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? st = "componentWillReceiveProps" : typeof Ae.UNSAFE_componentWillReceiveProps == "function" && (st = "UNSAFE_componentWillReceiveProps"), typeof Ae.componentWillUpdate == "function" && Ae.componentWillUpdate.__suppressDeprecationWarning !== !0 ? At = "componentWillUpdate" : typeof Ae.UNSAFE_componentWillUpdate == "function" && (At = "UNSAFE_componentWillUpdate"), tt !== null || st !== null || At !== null) {
            var hn = yn(l) || "Component", $n = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Da.has(hn) || (Da.add(hn), r(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, hn, $n, tt !== null ? `
  ` + tt : "", st !== null ? `
  ` + st : "", At !== null ? `
  ` + At : ""));
          }
        }
      }
      return Ae;
    }
    function Zs(l, h, S) {
      {
        var A = yn(h) || "Component", z = l.render;
        z || (h.prototype && typeof h.prototype.render == "function" ? r("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", A) : r("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", A)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && r("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", A), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && r("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", A), l.propTypes && r("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", A), l.contextType && r("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", A), l.contextTypes && r("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", A), h.contextType && h.contextTypes && !So.has(h) && (So.add(h), r("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", A)), typeof l.componentShouldUpdate == "function" && r("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", A), h.prototype && h.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && r("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", yn(h) || "A pure component"), typeof l.componentDidUnmount == "function" && r("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", A), typeof l.componentDidReceiveProps == "function" && r("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", A), typeof l.componentWillRecieveProps == "function" && r("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", A), typeof l.UNSAFE_componentWillRecieveProps == "function" && r("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", A);
        var Q = l.props !== S;
        l.props !== void 0 && Q && r("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", A, A), l.defaultProps && r("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", A, A), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !vo.has(h) && (vo.add(h), r("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", yn(h))), typeof l.getDerivedStateFromProps == "function" && r("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", A), typeof l.getDerivedStateFromError == "function" && r("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", A), typeof h.getSnapshotBeforeUpdate == "function" && r("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", A);
        var fe = l.state;
        fe && (typeof fe != "object" || it(fe)) && r("%s.state: must be set to an object or null", A), typeof l.getChildContext == "function" && typeof h.childContextTypes != "object" && r("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", A);
      }
    }
    function Jc(l, h) {
      var S = h.state;
      if (typeof h.componentWillMount == "function") {
        if (h.componentWillMount.__suppressDeprecationWarning !== !0) {
          var A = yn(l) || "Unknown";
          yo[A] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            A
          ), yo[A] = !0);
        }
        h.componentWillMount();
      }
      typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(), S !== h.state && (r("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", yn(l) || "Component"), Gs.enqueueReplaceState(h, h.state, null));
    }
    function ed(l, h, S, A) {
      if (l.queue !== null && l.queue.length > 0) {
        var z = l.queue, Q = l.replace;
        if (l.queue = null, l.replace = !1, Q && z.length === 1)
          h.state = z[0];
        else {
          for (var fe = Q ? z[0] : h.state, Ae = !0, Ie = Q ? 1 : 0; Ie < z.length; Ie++) {
            var tt = z[Ie], st = typeof tt == "function" ? tt.call(h, fe, S, A) : tt;
            st != null && (Ae ? (Ae = !1, fe = tr({}, fe, st)) : tr(fe, st));
          }
          h.state = fe;
        }
      } else
        l.queue = null;
    }
    function ko(l, h, S, A) {
      Zs(l, h, S);
      var z = l.state !== void 0 ? l.state : null;
      l.updater = Gs, l.props = S, l.state = z;
      var Q = {
        queue: [],
        replace: !1
      };
      Fl(l, Q);
      var fe = h.contextType;
      if (typeof fe == "object" && fe !== null ? l.context = Ra(fe) : l.context = A, l.state === S) {
        var Ae = yn(h) || "Component";
        bo.has(Ae) || (bo.add(Ae), r("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Ae));
      }
      var Ie = h.getDerivedStateFromProps;
      typeof Ie == "function" && (l.state = Zc(l, h, Ie, z, S)), typeof h.getDerivedStateFromProps != "function" && typeof l.getSnapshotBeforeUpdate != "function" && (typeof l.UNSAFE_componentWillMount == "function" || typeof l.componentWillMount == "function") && (Jc(h, l), ed(Q, l, S, A));
    }
    var wo = {
      id: 1,
      overflow: ""
    };
    function td(l) {
      var h = l.overflow, S = l.id, A = S & ~nd(S);
      return A.toString(32) + h;
    }
    function zl(l, h, S) {
      var A = l.id, z = l.overflow, Q = To(A) - 1, fe = A & ~(1 << Q), Ae = S + 1, Ie = To(h) + Q;
      if (Ie > 30) {
        var tt = Q - Q % 5, st = (1 << tt) - 1, At = (fe & st).toString(32), hn = fe >> tt, $n = Q - tt, cr = To(h) + $n, xu = Ae << $n, bu = xu | hn, Su = At + z;
        return {
          id: 1 << cr | bu,
          overflow: Su
        };
      } else {
        var Ho = Ae << Q, my = Ho | fe, gy = z;
        return {
          id: 1 << Ie | my,
          overflow: gy
        };
      }
    }
    function To(l) {
      return 32 - rd(l);
    }
    function nd(l) {
      return 1 << To(l) - 1;
    }
    var rd = Math.clz32 ? Math.clz32 : Pr, ad = Math.log, id = Math.LN2;
    function Pr(l) {
      var h = l >>> 0;
      return h === 0 ? 32 : 31 - (ad(h) / id | 0) | 0;
    }
    function $l(l, h) {
      return l === h && (l !== 0 || 1 / l === 1 / h) || l !== l && h !== h;
    }
    var Co = typeof Object.is == "function" ? Object.is : $l, $t = null, ia = null, oa = null, Jt = null, lr = !1, la = !1, Ao = 0, zn = null, Lr = 0, sa = 25, Sr = !1, ua;
    function Rr() {
      if ($t === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Sr && r("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), $t;
    }
    function od(l, h) {
      if (h === null)
        return r("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", ua), !1;
      l.length !== h.length && r(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, ua, "[" + l.join(", ") + "]", "[" + h.join(", ") + "]");
      for (var S = 0; S < h.length && S < l.length; S++)
        if (!Co(l[S], h[S]))
          return !1;
      return !0;
    }
    function Qs() {
      if (Lr > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Po() {
      return Jt === null ? oa === null ? (lr = !1, oa = Jt = Qs()) : (lr = !0, Jt = oa) : Jt.next === null ? (lr = !1, Jt = Jt.next = Qs()) : (lr = !0, Jt = Jt.next), Jt;
    }
    function Bl(l, h) {
      $t = h, ia = l, Sr = !1, Ao = 0;
    }
    function ld(l, h, S, A) {
      for (; la; )
        la = !1, Ao = 0, Lr += 1, Jt = null, S = l(h, A);
      return hi(), S;
    }
    function Js() {
      var l = Ao !== 0;
      return l;
    }
    function hi() {
      Sr = !1, $t = null, ia = null, la = !1, oa = null, Lr = 0, zn = null, Jt = null;
    }
    function sd(l) {
      return Sr && r("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Ra(l);
    }
    function eu(l) {
      return ua = "useContext", Rr(), Ra(l);
    }
    function Lo(l, h) {
      return typeof h == "function" ? h(l) : h;
    }
    function ud(l) {
      return ua = "useState", tu(
        Lo,
        // useReducer has a special case to support lazy useState initializers
        l
      );
    }
    function tu(l, h, S) {
      if (l !== Lo && (ua = "useReducer"), $t = Rr(), Jt = Po(), lr) {
        var A = Jt.queue, z = A.dispatch;
        if (zn !== null) {
          var Q = zn.get(A);
          if (Q !== void 0) {
            zn.delete(A);
            var fe = Jt.memoizedState, Ae = Q;
            do {
              var Ie = Ae.action;
              Sr = !0, fe = l(fe, Ie), Sr = !1, Ae = Ae.next;
            } while (Ae !== null);
            return Jt.memoizedState = fe, [fe, z];
          }
        }
        return [Jt.memoizedState, z];
      } else {
        Sr = !0;
        var tt;
        l === Lo ? tt = typeof h == "function" ? h() : h : tt = S !== void 0 ? S(h) : h, Sr = !1, Jt.memoizedState = tt;
        var st = Jt.queue = {
          last: null,
          dispatch: null
        }, At = st.dispatch = fd.bind(null, $t, st);
        return [Jt.memoizedState, At];
      }
    }
    function nu(l, h) {
      $t = Rr(), Jt = Po();
      var S = h === void 0 ? null : h;
      if (Jt !== null) {
        var A = Jt.memoizedState;
        if (A !== null && S !== null) {
          var z = A[1];
          if (od(S, z))
            return A[0];
        }
      }
      Sr = !0;
      var Q = l();
      return Sr = !1, Jt.memoizedState = [Q, S], Q;
    }
    function cd(l) {
      $t = Rr(), Jt = Po();
      var h = Jt.memoizedState;
      if (h === null) {
        var S = {
          current: l
        };
        return Object.seal(S), Jt.memoizedState = S, S;
      } else
        return h;
    }
    function dd(l, h) {
      ua = "useLayoutEffect", r("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function fd(l, h, S) {
      if (Lr >= sa)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (l === $t) {
        la = !0;
        var A = {
          action: S,
          next: null
        };
        zn === null && (zn = /* @__PURE__ */ new Map());
        var z = zn.get(h);
        if (z === void 0)
          zn.set(h, A);
        else {
          for (var Q = z; Q.next !== null; )
            Q = Q.next;
          Q.next = A;
        }
      }
    }
    function hd(l, h) {
      return nu(function() {
        return l;
      }, h);
    }
    function pd(l, h, S) {
      return Rr(), h(l._source);
    }
    function md(l, h, S) {
      if (S === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return S();
    }
    function gd(l) {
      return Rr(), l;
    }
    function Ro() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function ru() {
      return Rr(), [!1, Ro];
    }
    function Il() {
      var l = ia, h = td(l.treeContext), S = mi;
      if (S === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var A = Ao++;
      return sn(S, h, A);
    }
    function pi() {
    }
    var au = {
      readContext: sd,
      useContext: eu,
      useMemo: nu,
      useReducer: tu,
      useRef: cd,
      useState: ud,
      useInsertionEffect: pi,
      useLayoutEffect: dd,
      useCallback: hd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: pi,
      // Effects are not run in the server environment.
      useEffect: pi,
      // Debugging effect
      useDebugValue: pi,
      useDeferredValue: gd,
      useTransition: ru,
      useId: Il,
      // Subscriptions are not setup in a server environment.
      useMutableSource: pd,
      useSyncExternalStore: md
    }, mi = null;
    function Do(l) {
      mi = l;
    }
    function Hl(l) {
      try {
        var h = "", S = l;
        do {
          switch (S.tag) {
            case 0:
              h += oi(S.type, null, null);
              break;
            case 1:
              h += Ll(S.type, null, null);
              break;
            case 2:
              h += Pl(S.type, null, null);
              break;
          }
          S = S.parent;
        } while (S);
        return h;
      } catch (A) {
        return `
Error generating stack: ` + A.message + `
` + A.stack;
      }
    }
    var Br = n.ReactCurrentDispatcher, Oo = n.ReactDebugCurrentFrame, Mo = 0, ca = 1, iu = 2, Wl = 3, da = 4, yd = 0, ou = 1, Er = 2, vd = 12800;
    function xd(l) {
      return console.error(l), null;
    }
    function gi() {
    }
    function Vl(l, h, S, A, z, Q, fe, Ae, Ie) {
      var tt = [], st = /* @__PURE__ */ new Set(), At = {
        destination: null,
        responseState: h,
        progressiveChunkSize: A === void 0 ? vd : A,
        status: yd,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: st,
        pingedTasks: tt,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: z === void 0 ? xd : z,
        onAllReady: Q === void 0 ? gi : Q,
        onShellReady: fe === void 0 ? gi : fe,
        onShellError: Ae === void 0 ? gi : Ae,
        onFatalError: Ie === void 0 ? gi : Ie
      }, hn = Ir(
        At,
        0,
        null,
        S,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      hn.parentFlushed = !0;
      var $n = yi(At, l, null, hn, st, $r, Ml, wo);
      return tt.push($n), At;
    }
    function _o(l, h) {
      var S = l.pingedTasks;
      S.push(h), S.length === 1 && f(function() {
        return yu(l);
      });
    }
    function Dr(l, h) {
      return {
        id: Ut,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: h,
        errorDigest: null
      };
    }
    function yi(l, h, S, A, z, Q, fe, Ae) {
      l.allPendingTasks++, S === null ? l.pendingRootTasks++ : S.pendingTasks++;
      var Ie = {
        node: h,
        ping: function() {
          return _o(l, Ie);
        },
        blockedBoundary: S,
        blockedSegment: A,
        abortSet: z,
        legacyContext: Q,
        context: fe,
        treeContext: Ae
      };
      return Ie.componentStack = null, z.add(Ie), Ie;
    }
    function Ir(l, h, S, A, z, Q) {
      return {
        status: Mo,
        id: -1,
        // lazily assigned later
        index: h,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: A,
        boundary: S,
        lastPushedText: z,
        textEmbedded: Q
      };
    }
    var kr = null;
    function jl() {
      return kr === null || kr.componentStack === null ? "" : Hl(kr.componentStack);
    }
    function sr(l, h) {
      l.componentStack = {
        tag: 0,
        parent: l.componentStack,
        type: h
      };
    }
    function Ma(l, h) {
      l.componentStack = {
        tag: 1,
        parent: l.componentStack,
        type: h
      };
    }
    function Ul(l, h) {
      l.componentStack = {
        tag: 2,
        parent: l.componentStack,
        type: h
      };
    }
    function ur(l) {
      l.componentStack === null ? r("Unexpectedly popped too many stack frames. This is a bug in React.") : l.componentStack = l.componentStack.parent;
    }
    var Hr = null;
    function Kl(l, h) {
      {
        var S;
        typeof h == "string" ? S = h : h && typeof h.message == "string" ? S = h.message : S = String(h);
        var A = Hr || jl();
        Hr = null, l.errorMessage = S, l.errorComponentStack = A;
      }
    }
    function vi(l, h) {
      var S = l.onError(h);
      if (S != null && typeof S != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof S + '" instead');
      return S;
    }
    function No(l, h) {
      var S = l.onShellError;
      S(h);
      var A = l.onFatalError;
      A(h), l.destination !== null ? (l.status = Er, E(l.destination, h)) : (l.status = ou, l.fatalError = h);
    }
    function lu(l, h, S) {
      sr(h, "Suspense");
      var A = h.blockedBoundary, z = h.blockedSegment, Q = S.fallback, fe = S.children, Ae = /* @__PURE__ */ new Set(), Ie = Dr(l, Ae), tt = z.chunks.length, st = Ir(
        l,
        tt,
        Ie,
        z.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      z.children.push(st), z.lastPushedText = !1;
      var At = Ir(
        l,
        0,
        null,
        z.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      At.parentFlushed = !0, h.blockedBoundary = Ie, h.blockedSegment = At;
      try {
        if (Fo(l, h, fe), Ns(At.chunks, l.responseState, At.lastPushedText, At.textEmbedded), At.status = ca, Si(Ie, At), Ie.pendingTasks === 0) {
          ur(h);
          return;
        }
      } catch ($n) {
        At.status = da, Ie.forceClientRender = !0, Ie.errorDigest = vi(l, $n), Kl(Ie, $n);
      } finally {
        h.blockedBoundary = A, h.blockedSegment = z;
      }
      var hn = yi(l, Q, A, st, Ae, h.legacyContext, h.context, h.treeContext);
      hn.componentStack = h.componentStack, l.pingedTasks.push(hn), ur(h);
    }
    function su(l, h, S, A) {
      sr(h, S);
      var z = h.blockedSegment, Q = vr(z.chunks, S, A, l.responseState, z.formatContext);
      z.lastPushedText = !1;
      var fe = z.formatContext;
      z.formatContext = Zt(fe, S, A), Fo(l, h, Q), z.formatContext = fe, Qn(z.chunks, S), z.lastPushedText = !1, ur(h);
    }
    function bd(l) {
      return l.prototype && l.prototype.isReactComponent;
    }
    function Yl(l, h, S, A, z) {
      var Q = {};
      Bl(h, Q);
      var fe = S(A, z);
      return ld(S, A, fe, z);
    }
    function xi(l, h, S, A, z) {
      var Q = S.render();
      S.props !== z && (Zl || r("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", yn(A) || "a component"), Zl = !0);
      {
        var fe = A.childContextTypes;
        if (fe != null) {
          var Ae = h.legacyContext, Ie = ra(S, A, Ae, fe);
          h.legacyContext = Ie, rr(l, h, Q), h.legacyContext = Ae;
          return;
        }
      }
      rr(l, h, Q);
    }
    function uu(l, h, S, A) {
      Ul(h, S);
      var z = Us(S, h.legacyContext), Q = Qc(S, A, z);
      ko(Q, S, A, z), xi(l, h, Q, S, A), ur(h);
    }
    var Xl = {}, bi = {}, ql = {}, Gl = {}, Zl = !1, cu = !1, du = !1, Ql = !1;
    function Sd(l, h, S, A) {
      var z;
      if (z = Us(S, h.legacyContext), Ma(h, S), S.prototype && typeof S.prototype.render == "function") {
        var Q = yn(S) || "Unknown";
        Xl[Q] || (r("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Q, Q), Xl[Q] = !0);
      }
      var fe = Yl(l, h, S, A, z), Ae = Js();
      if (typeof fe == "object" && fe !== null && typeof fe.render == "function" && fe.$$typeof === void 0) {
        var Ie = yn(S) || "Unknown";
        bi[Ie] || (r("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ie, Ie, Ie), bi[Ie] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof fe == "object" && fe !== null && typeof fe.render == "function" && fe.$$typeof === void 0
      ) {
        {
          var tt = yn(S) || "Unknown";
          bi[tt] || (r("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", tt, tt, tt), bi[tt] = !0);
        }
        ko(fe, S, A, z), xi(l, h, fe, S, A);
      } else if (Ed(S), Ae) {
        var st = h.treeContext, At = 1, hn = 0;
        h.treeContext = zl(st, At, hn);
        try {
          rr(l, h, fe);
        } finally {
          h.treeContext = st;
        }
      } else
        rr(l, h, fe);
      ur(h);
    }
    function Ed(l) {
      {
        if (l && l.childContextTypes && r("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), typeof l.getDerivedStateFromProps == "function") {
          var h = yn(l) || "Unknown";
          Gl[h] || (r("%s: Function components do not support getDerivedStateFromProps.", h), Gl[h] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var S = yn(l) || "Unknown";
          ql[S] || (r("%s: Function components do not support contextType.", S), ql[S] = !0);
        }
      }
    }
    function fu(l, h) {
      if (l && l.defaultProps) {
        var S = tr({}, h), A = l.defaultProps;
        for (var z in A)
          S[z] === void 0 && (S[z] = A[z]);
        return S;
      }
      return h;
    }
    function kd(l, h, S, A, z) {
      Ma(h, S.render);
      var Q = Yl(l, h, S.render, A, z), fe = Js();
      if (fe) {
        var Ae = h.treeContext, Ie = 1, tt = 0;
        h.treeContext = zl(Ae, Ie, tt);
        try {
          rr(l, h, Q);
        } finally {
          h.treeContext = Ae;
        }
      } else
        rr(l, h, Q);
      ur(h);
    }
    function wd(l, h, S, A, z) {
      var Q = S.type, fe = fu(Q, A);
      es(l, h, Q, fe, z);
    }
    function Jl(l, h, S, A) {
      S._context === void 0 ? S !== S.Consumer && (Ql || (Ql = !0, r("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : S = S._context;
      var z = A.children;
      typeof z != "function" && r("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var Q = Ra(S), fe = z(Q);
      rr(l, h, fe);
    }
    function Td(l, h, S, A) {
      var z = S._context, Q = A.value, fe = A.children, Ae;
      Ae = h.context, h.context = ci(z, Q), rr(l, h, fe), h.context = Nl(z), Ae !== h.context && r("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function nr(l, h, S, A, z) {
      sr(h, "Lazy");
      var Q = S._payload, fe = S._init, Ae = fe(Q), Ie = fu(Ae, A);
      es(l, h, Ae, Ie, z), ur(h);
    }
    function es(l, h, S, A, z) {
      if (typeof S == "function")
        if (bd(S)) {
          uu(l, h, S, A);
          return;
        } else {
          Sd(l, h, S, A);
          return;
        }
      if (typeof S == "string") {
        su(l, h, S, A);
        return;
      }
      switch (S) {
        case Xc:
        case $s:
        case io:
        case oo:
        case ao: {
          rr(l, h, A.children);
          return;
        }
        case vl: {
          sr(h, "SuspenseList"), rr(l, h, A.children), ur(h);
          return;
        }
        case Yc:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Ca: {
          lu(l, h, A);
          return;
        }
      }
      if (typeof S == "object" && S !== null)
        switch (S.$$typeof) {
          case ni: {
            kd(l, h, S, A, z);
            return;
          }
          case xl: {
            wd(l, h, S, A, z);
            return;
          }
          case ei: {
            Td(l, h, S, A);
            return;
          }
          case ti: {
            Jl(l, h, S, A);
            return;
          }
          case lo: {
            nr(l, h, S, A);
            return;
          }
        }
      var Q = "";
      throw (S === void 0 || typeof S == "object" && S !== null && Object.keys(S).length === 0) && (Q += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (S == null ? S : typeof S) + "." + Q));
    }
    function hu(l, h) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      l[Symbol.toStringTag] === "Generator" && (cu || r("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), cu = !0), l.entries === h && (du || r("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), du = !0);
    }
    function rr(l, h, S) {
      try {
        return ts(l, h, S);
      } catch (A) {
        throw typeof A == "object" && A !== null && typeof A.then == "function" || (Hr = Hr !== null ? Hr : jl()), A;
      }
    }
    function ts(l, h, S) {
      if (h.node = S, typeof S == "object" && S !== null) {
        switch (S.$$typeof) {
          case zs: {
            var A = S, z = A.type, Q = A.props, fe = A.ref;
            es(l, h, z, Q, fe);
            return;
          }
          case yl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case lo: {
            var Ae = S, Ie = Ae._payload, tt = Ae._init, st;
            try {
              st = tt(Ie);
            } catch (Ho) {
              throw typeof Ho == "object" && Ho !== null && typeof Ho.then == "function" && sr(h, "Lazy"), Ho;
            }
            rr(l, h, st);
            return;
          }
        }
        if (it(S)) {
          pu(l, h, S);
          return;
        }
        var At = Sn(S);
        if (At) {
          hu(S, At);
          var hn = At.call(S);
          if (hn) {
            var $n = hn.next();
            if (!$n.done) {
              var cr = [];
              do
                cr.push($n.value), $n = hn.next();
              while (!$n.done);
              pu(l, h, cr);
              return;
            }
            return;
          }
        }
        var xu = Object.prototype.toString.call(S);
        throw new Error("Objects are not valid as a React child (found: " + (xu === "[object Object]" ? "object with keys {" + Object.keys(S).join(", ") + "}" : xu) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof S == "string") {
        var bu = h.blockedSegment;
        bu.lastPushedText = _s(h.blockedSegment.chunks, S, l.responseState, bu.lastPushedText);
        return;
      }
      if (typeof S == "number") {
        var Su = h.blockedSegment;
        Su.lastPushedText = _s(h.blockedSegment.chunks, "" + S, l.responseState, Su.lastPushedText);
        return;
      }
      typeof S == "function" && r("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function pu(l, h, S) {
      for (var A = S.length, z = 0; z < A; z++) {
        var Q = h.treeContext;
        h.treeContext = zl(Q, A, z);
        try {
          Fo(l, h, S[z]);
        } finally {
          h.treeContext = Q;
        }
      }
    }
    function Cd(l, h, S) {
      var A = h.blockedSegment, z = A.chunks.length, Q = Ir(
        l,
        z,
        null,
        A.formatContext,
        // Adopt the parent segment's leading text embed
        A.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      A.children.push(Q), A.lastPushedText = !1;
      var fe = yi(l, h.node, h.blockedBoundary, Q, h.abortSet, h.legacyContext, h.context, h.treeContext);
      h.componentStack !== null && (fe.componentStack = h.componentStack.parent);
      var Ae = fe.ping;
      S.then(Ae, Ae);
    }
    function Fo(l, h, S) {
      var A = h.blockedSegment.formatContext, z = h.legacyContext, Q = h.context, fe = null;
      fe = h.componentStack;
      try {
        return rr(l, h, S);
      } catch (Ae) {
        if (hi(), typeof Ae == "object" && Ae !== null && typeof Ae.then == "function") {
          Cd(l, h, Ae), h.blockedSegment.formatContext = A, h.legacyContext = z, h.context = Q, po(Q), h.componentStack = fe;
          return;
        } else
          throw h.blockedSegment.formatContext = A, h.legacyContext = z, h.context = Q, po(Q), h.componentStack = fe, Ae;
      }
    }
    function zo(l, h, S, A) {
      var z = vi(l, A);
      if (h === null ? No(l, A) : (h.pendingTasks--, h.forceClientRender || (h.forceClientRender = !0, h.errorDigest = z, Kl(h, A), h.parentFlushed && l.clientRenderedBoundaries.push(h))), l.allPendingTasks--, l.allPendingTasks === 0) {
        var Q = l.onAllReady;
        Q();
      }
    }
    function mu(l) {
      var h = this, S = l.blockedBoundary, A = l.blockedSegment;
      A.status = Wl, Ei(h, S, A);
    }
    function gu(l, h, S) {
      var A = l.blockedBoundary, z = l.blockedSegment;
      if (z.status = Wl, A === null)
        h.allPendingTasks--, h.status !== Er && (h.status = Er, h.destination !== null && y(h.destination));
      else {
        if (A.pendingTasks--, !A.forceClientRender) {
          A.forceClientRender = !0;
          var Q = S === void 0 ? new Error("The render was aborted by the server without a reason.") : S;
          A.errorDigest = h.onError(Q);
          {
            var fe = "The server did not finish this Suspense boundary: ";
            Q && typeof Q.message == "string" ? Q = fe + Q.message : Q = fe + String(Q);
            var Ae = kr;
            kr = l;
            try {
              Kl(A, Q);
            } finally {
              kr = Ae;
            }
          }
          A.parentFlushed && h.clientRenderedBoundaries.push(A);
        }
        if (A.fallbackAbortableTasks.forEach(function(tt) {
          return gu(tt, h, S);
        }), A.fallbackAbortableTasks.clear(), h.allPendingTasks--, h.allPendingTasks === 0) {
          var Ie = h.onAllReady;
          Ie();
        }
      }
    }
    function Si(l, h) {
      if (h.chunks.length === 0 && h.children.length === 1 && h.children[0].boundary === null) {
        var S = h.children[0];
        S.id = h.id, S.parentFlushed = !0, S.status === ca && Si(l, S);
      } else {
        var A = l.completedSegments;
        A.push(h);
      }
    }
    function Ei(l, h, S) {
      if (h === null) {
        if (S.parentFlushed) {
          if (l.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          l.completedRootSegment = S;
        }
        if (l.pendingRootTasks--, l.pendingRootTasks === 0) {
          l.onShellError = gi;
          var A = l.onShellReady;
          A();
        }
      } else if (h.pendingTasks--, !h.forceClientRender) {
        if (h.pendingTasks === 0)
          S.parentFlushed && S.status === ca && Si(h, S), h.parentFlushed && l.completedBoundaries.push(h), h.fallbackAbortableTasks.forEach(mu, l), h.fallbackAbortableTasks.clear();
        else if (S.parentFlushed && S.status === ca) {
          Si(h, S);
          var z = h.completedSegments;
          z.length === 1 && h.parentFlushed && l.partialBoundaries.push(h);
        }
      }
      if (l.allPendingTasks--, l.allPendingTasks === 0) {
        var Q = l.onAllReady;
        Q();
      }
    }
    function $o(l, h) {
      var S = h.blockedSegment;
      if (S.status === Mo) {
        po(h.context);
        var A = null;
        A = kr, kr = h;
        try {
          rr(l, h, h.node), Ns(S.chunks, l.responseState, S.lastPushedText, S.textEmbedded), h.abortSet.delete(h), S.status = ca, Ei(l, h.blockedBoundary, S);
        } catch (Q) {
          if (hi(), typeof Q == "object" && Q !== null && typeof Q.then == "function") {
            var z = h.ping;
            Q.then(z, z);
          } else
            h.abortSet.delete(h), S.status = da, zo(l, h.blockedBoundary, S, Q);
        } finally {
          kr = A;
        }
      }
    }
    function yu(l) {
      if (l.status !== Er) {
        var h = Gc(), S = Br.current;
        Br.current = au;
        var A;
        A = Oo.getCurrentStack, Oo.getCurrentStack = jl;
        var z = mi;
        Do(l.responseState);
        try {
          var Q = l.pingedTasks, fe;
          for (fe = 0; fe < Q.length; fe++) {
            var Ae = Q[fe];
            $o(l, Ae);
          }
          Q.splice(0, fe), l.destination !== null && Io(l, l.destination);
        } catch (Ie) {
          vi(l, Ie), No(l, Ie);
        } finally {
          Do(z), Br.current = S, Oo.getCurrentStack = A, S === au && po(h);
        }
      }
    }
    function ki(l, h, S) {
      switch (S.parentFlushed = !0, S.status) {
        case Mo: {
          var A = S.id = l.nextSegmentId++;
          return S.lastPushedText = !1, S.textEmbedded = !1, Ui(h, l.responseState, A);
        }
        case ca: {
          S.status = iu;
          for (var z = !0, Q = S.chunks, fe = 0, Ae = S.children, Ie = 0; Ie < Ae.length; Ie++) {
            for (var tt = Ae[Ie]; fe < tt.index; fe++)
              s(h, Q[fe]);
            z = wi(l, h, tt);
          }
          for (; fe < Q.length - 1; fe++)
            s(h, Q[fe]);
          return fe < Q.length && (z = d(h, Q[fe])), z;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function wi(l, h, S) {
      var A = S.boundary;
      if (A === null)
        return ki(l, h, S);
      if (A.parentFlushed = !0, A.forceClientRender)
        return or(h, l.responseState, A.errorDigest, A.errorMessage, A.errorComponentStack), ki(l, h, S), Fs(h, l.responseState);
      if (A.pendingTasks > 0) {
        A.rootSegmentID = l.nextSegmentId++, A.completedSegments.length > 0 && l.partialBoundaries.push(A);
        var z = A.id = Qt(l.responseState);
        return zr(h, l.responseState, z), ki(l, h, S), Za(h, l.responseState);
      } else {
        if (A.byteSize > l.progressiveChunkSize)
          return A.rootSegmentID = l.nextSegmentId++, l.completedBoundaries.push(A), zr(h, l.responseState, A.id), ki(l, h, S), Za(h, l.responseState);
        gl(h, l.responseState);
        var Q = A.completedSegments;
        if (Q.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var fe = Q[0];
        return wi(l, h, fe), Kc(h, l.responseState);
      }
    }
    function Ad(l, h, S) {
      return Vc(h, l.responseState, S.id, S.errorDigest, S.errorMessage, S.errorComponentStack);
    }
    function ns(l, h, S) {
      return Se(h, l.responseState, S.formatContext, S.id), wi(l, h, S), Fe(h, S.formatContext);
    }
    function Bo(l, h, S) {
      for (var A = S.completedSegments, z = 0; z < A.length; z++) {
        var Q = A[z];
        vu(l, h, S, Q);
      }
      return A.length = 0, $c(h, l.responseState, S.id, S.rootSegmentID);
    }
    function Pd(l, h, S) {
      for (var A = S.completedSegments, z = 0; z < A.length; z++) {
        var Q = A[z];
        if (!vu(l, h, S, Q))
          return z++, A.splice(0, z), !1;
      }
      return A.splice(0, z), !0;
    }
    function vu(l, h, S, A) {
      if (A.status === iu)
        return !0;
      var z = A.id;
      if (z === -1) {
        var Q = A.id = S.rootSegmentID;
        if (Q === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return ns(l, h, A);
      } else
        return ns(l, h, A), er(h, l.responseState, z);
    }
    function Io(l, h) {
      try {
        var S = l.completedRootSegment;
        S !== null && l.pendingRootTasks === 0 && (wi(l, h, S), l.completedRootSegment = null, Ya(h, l.responseState));
        var A = l.clientRenderedBoundaries, z;
        for (z = 0; z < A.length; z++) {
          var Q = A[z];
          if (!Ad(l, h, Q)) {
            l.destination = null, z++, A.splice(0, z);
            return;
          }
        }
        A.splice(0, z);
        var fe = l.completedBoundaries;
        for (z = 0; z < fe.length; z++) {
          var Ae = fe[z];
          if (!Bo(l, h, Ae)) {
            l.destination = null, z++, fe.splice(0, z);
            return;
          }
        }
        fe.splice(0, z);
        var Ie = l.partialBoundaries;
        for (z = 0; z < Ie.length; z++) {
          var tt = Ie[z];
          if (!Pd(l, h, tt)) {
            l.destination = null, z++, Ie.splice(0, z);
            return;
          }
        }
        Ie.splice(0, z);
        var st = l.completedBoundaries;
        for (z = 0; z < st.length; z++) {
          var At = st[z];
          if (!Bo(l, h, At)) {
            l.destination = null, z++, st.splice(0, z);
            return;
          }
        }
        st.splice(0, z);
      } finally {
        l.allPendingTasks === 0 && l.pingedTasks.length === 0 && l.clientRenderedBoundaries.length === 0 && l.completedBoundaries.length === 0 && (l.abortableTasks.size !== 0 && r("There was still abortable task at the root when we closed. This is a bug in React."), y(h));
      }
    }
    function Ld(l) {
      f(function() {
        return yu(l);
      });
    }
    function c(l, h) {
      if (l.status === ou) {
        l.status = Er, E(h, l.fatalError);
        return;
      }
      if (l.status !== Er && l.destination === null) {
        l.destination = h;
        try {
          Io(l, h);
        } catch (S) {
          vi(l, S), No(l, S);
        }
      }
    }
    function p(l, h) {
      try {
        var S = l.abortableTasks;
        S.forEach(function(A) {
          return gu(A, l, h);
        }), S.clear(), l.destination !== null && Io(l, l.destination);
      } catch (A) {
        vi(l, A), No(l, A);
      }
    }
    function k() {
    }
    function D(l, h, S, A) {
      var z = !1, Q = null, fe = "", Ae = {
        push: function(At) {
          return At !== null && (fe += At), !0;
        },
        destroy: function(At) {
          z = !0, Q = At;
        }
      }, Ie = !1;
      function tt() {
        Ie = !0;
      }
      var st = Vl(l, Uc(S, h ? h.identifierPrefix : void 0), ml(), 1 / 0, k, void 0, tt, void 0, void 0);
      if (Ld(st), p(st, A), c(st, Ae), z)
        throw Q;
      if (!Ie)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return fe;
    }
    function V(l, h) {
      return D(l, h, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function ae(l, h) {
      return D(l, h, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function pe() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Re() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Ri.renderToNodeStream = pe, Ri.renderToStaticMarkup = ae, Ri.renderToStaticNodeStream = Re, Ri.renderToString = V, Ri.version = t;
  }()), Ri;
}
var Nu = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var om;
function DE() {
  return om || (om = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ce, t = "18.2.0", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function a(c) {
      {
        for (var p = arguments.length, k = new Array(p > 1 ? p - 1 : 0), D = 1; D < p; D++)
          k[D - 1] = arguments[D];
        o("warn", c, k);
      }
    }
    function r(c) {
      {
        for (var p = arguments.length, k = new Array(p > 1 ? p - 1 : 0), D = 1; D < p; D++)
          k[D - 1] = arguments[D];
        o("error", c, k);
      }
    }
    function o(c, p, k) {
      {
        var D = n.ReactDebugCurrentFrame, V = D.getStackAddendum();
        V !== "" && (p += "%s", k = k.concat([V]));
        var ae = k.map(function(pe) {
          return String(pe);
        });
        ae.unshift("Warning: " + p), Function.prototype.apply.call(console[c], console, ae);
      }
    }
    function f(c) {
      c();
    }
    var u = 512, s = null, d = 0;
    function m(c) {
      s = new Uint8Array(u), d = 0;
    }
    function y(c, p) {
      if (p.length !== 0) {
        if (p.length > u) {
          d > 0 && (c.enqueue(new Uint8Array(s.buffer, 0, d)), s = new Uint8Array(u), d = 0), c.enqueue(p);
          return;
        }
        var k = p, D = s.length - d;
        D < k.length && (D === 0 ? c.enqueue(s) : (s.set(k.subarray(0, D), d), c.enqueue(s), k = k.subarray(D)), s = new Uint8Array(u), d = 0), s.set(k, d), d += k.length;
      }
    }
    function v(c, p) {
      return y(c, p), !0;
    }
    function w(c) {
      s && d > 0 && (c.enqueue(new Uint8Array(s.buffer, 0, d)), s = null, d = 0);
    }
    function E(c) {
      c.close();
    }
    var O = new TextEncoder();
    function T(c) {
      return O.encode(c);
    }
    function g(c) {
      return O.encode(c);
    }
    function N(c, p) {
      typeof c.error == "function" ? c.error(p) : c.close();
    }
    function L(c) {
      {
        var p = typeof Symbol == "function" && Symbol.toStringTag, k = p && c[Symbol.toStringTag] || c.constructor.name || "Object";
        return k;
      }
    }
    function M(c) {
      try {
        return _(c), !1;
      } catch {
        return !0;
      }
    }
    function _(c) {
      return "" + c;
    }
    function C(c, p) {
      if (M(c))
        return r("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", p, L(c)), _(c);
    }
    function H(c, p) {
      if (M(c))
        return r("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", p, L(c)), _(c);
    }
    function I(c) {
      if (M(c))
        return r("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", L(c)), _(c);
    }
    var X = Object.prototype.hasOwnProperty, te = 0, G = 1, F = 2, j = 3, U = 4, W = 5, re = 6, J = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ue = J + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ee = new RegExp("^[" + J + "][" + ue + "]*$"), Z = {}, se = {};
    function ye(c) {
      return X.call(se, c) ? !0 : X.call(Z, c) ? !1 : ee.test(c) ? (se[c] = !0, !0) : (Z[c] = !0, r("Invalid attribute name: `%s`", c), !1);
    }
    function me(c, p, k, D) {
      if (k !== null && k.type === te)
        return !1;
      switch (typeof p) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (D)
            return !1;
          if (k !== null)
            return !k.acceptsBooleans;
          var V = c.toLowerCase().slice(0, 5);
          return V !== "data-" && V !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Le(c) {
      return ie.hasOwnProperty(c) ? ie[c] : null;
    }
    function de(c, p, k, D, V, ae, pe) {
      this.acceptsBooleans = p === F || p === j || p === U, this.attributeName = D, this.attributeNamespace = V, this.mustUseProperty = k, this.propertyName = c, this.type = p, this.sanitizeURL = ae, this.removeEmptyString = pe;
    }
    var ie = {}, Ce = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Ce.forEach(function(c) {
      ie[c] = new de(
        c,
        te,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(c) {
      var p = c[0], k = c[1];
      ie[p] = new de(
        p,
        G,
        !1,
        // mustUseProperty
        k,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(c) {
      ie[c] = new de(
        c,
        F,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(c) {
      ie[c] = new de(
        c,
        F,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(c) {
      ie[c] = new de(
        c,
        j,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      ie[c] = new de(
        c,
        j,
        !0,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      ie[c] = new de(
        c,
        U,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      ie[c] = new de(
        c,
        re,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(c) {
      ie[c] = new de(
        c,
        W,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var He = /[\-\:]([a-z])/g, we = function(c) {
      return c[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var p = c.replace(He, we);
      ie[p] = new de(
        p,
        G,
        !1,
        // mustUseProperty
        c,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var p = c.replace(He, we);
      ie[p] = new de(
        p,
        G,
        !1,
        // mustUseProperty
        c,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var p = c.replace(He, we);
      ie[p] = new de(
        p,
        G,
        !1,
        // mustUseProperty
        c,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(c) {
      ie[c] = new de(
        c,
        G,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ge = "xlinkHref";
    ie[ge] = new de(
      "xlinkHref",
      G,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(c) {
      ie[c] = new de(
        c,
        G,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var ke = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function ne(c, p) {
      return c + p.charAt(0).toUpperCase() + p.substring(1);
    }
    var Pe = ["Webkit", "ms", "Moz", "O"];
    Object.keys(ke).forEach(function(c) {
      Pe.forEach(function(p) {
        ke[ne(p, c)] = ke[c];
      });
    });
    var $e = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function qe(c, p) {
      $e[p.type] || p.onChange || p.onInput || p.readOnly || p.disabled || p.value == null || r("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), p.onChange || p.readOnly || p.disabled || p.checked == null || r("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ge(c, p) {
      if (c.indexOf("-") === -1)
        return typeof p.is == "string";
      switch (c) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Xe = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, We = {}, vt = new RegExp("^(aria)-[" + ue + "]*$"), et = new RegExp("^(aria)[A-Z][" + ue + "]*$");
    function Ke(c, p) {
      {
        if (X.call(We, p) && We[p])
          return !0;
        if (et.test(p)) {
          var k = "aria-" + p.slice(4).toLowerCase(), D = Xe.hasOwnProperty(k) ? k : null;
          if (D == null)
            return r("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", p), We[p] = !0, !0;
          if (p !== D)
            return r("Invalid ARIA attribute `%s`. Did you mean `%s`?", p, D), We[p] = !0, !0;
        }
        if (vt.test(p)) {
          var V = p.toLowerCase(), ae = Xe.hasOwnProperty(V) ? V : null;
          if (ae == null)
            return We[p] = !0, !1;
          if (p !== ae)
            return r("Unknown ARIA attribute `%s`. Did you mean `%s`?", p, ae), We[p] = !0, !0;
        }
      }
      return !0;
    }
    function Be(c, p) {
      {
        var k = [];
        for (var D in p) {
          var V = Ke(c, D);
          V || k.push(D);
        }
        var ae = k.map(function(pe) {
          return "`" + pe + "`";
        }).join(", ");
        k.length === 1 ? r("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ae, c) : k.length > 1 && r("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ae, c);
      }
    }
    function ze(c, p) {
      Ge(c, p) || Be(c, p);
    }
    var gt = !1;
    function Ye(c, p) {
      {
        if (c !== "input" && c !== "textarea" && c !== "select")
          return;
        p != null && p.value === null && !gt && (gt = !0, c === "select" && p.multiple ? r("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", c) : r("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", c));
      }
    }
    var dt = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, xt = function() {
    };
    {
      var ft = {}, lt = /^on./, Dt = /^on[^A-Z]/, on = new RegExp("^(aria)-[" + ue + "]*$"), Xt = new RegExp("^(aria)[A-Z][" + ue + "]*$");
      xt = function(c, p, k, D) {
        if (X.call(ft, p) && ft[p])
          return !0;
        var V = p.toLowerCase();
        if (V === "onfocusin" || V === "onfocusout")
          return r("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), ft[p] = !0, !0;
        if (D != null) {
          var ae = D.registrationNameDependencies, pe = D.possibleRegistrationNames;
          if (ae.hasOwnProperty(p))
            return !0;
          var Re = pe.hasOwnProperty(V) ? pe[V] : null;
          if (Re != null)
            return r("Invalid event handler property `%s`. Did you mean `%s`?", p, Re), ft[p] = !0, !0;
          if (lt.test(p))
            return r("Unknown event handler property `%s`. It will be ignored.", p), ft[p] = !0, !0;
        } else if (lt.test(p))
          return Dt.test(p) && r("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", p), ft[p] = !0, !0;
        if (on.test(p) || Xt.test(p))
          return !0;
        if (V === "innerhtml")
          return r("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), ft[p] = !0, !0;
        if (V === "aria")
          return r("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), ft[p] = !0, !0;
        if (V === "is" && k !== null && k !== void 0 && typeof k != "string")
          return r("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof k), ft[p] = !0, !0;
        if (typeof k == "number" && isNaN(k))
          return r("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", p), ft[p] = !0, !0;
        var l = Le(p), h = l !== null && l.type === te;
        if (dt.hasOwnProperty(V)) {
          var S = dt[V];
          if (S !== p)
            return r("Invalid DOM property `%s`. Did you mean `%s`?", p, S), ft[p] = !0, !0;
        } else if (!h && p !== V)
          return r("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", p, V), ft[p] = !0, !0;
        return typeof k == "boolean" && me(p, k, l, !1) ? (k ? r('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', k, p, p, k, p) : r('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', k, p, p, k, p, p, p), ft[p] = !0, !0) : h ? !0 : me(p, k, l, !1) ? (ft[p] = !0, !1) : ((k === "false" || k === "true") && l !== null && l.type === j && (r("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", k, p, k === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', p, k), ft[p] = !0), !0);
      };
    }
    var tn = function(c, p, k) {
      {
        var D = [];
        for (var V in p) {
          var ae = xt(c, V, p[V], k);
          ae || D.push(V);
        }
        var pe = D.map(function(Re) {
          return "`" + Re + "`";
        }).join(", ");
        D.length === 1 ? r("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", pe, c) : D.length > 1 && r("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", pe, c);
      }
    };
    function mn(c, p, k) {
      Ge(c, p) || tn(c, p, k);
    }
    var zt = function() {
    };
    {
      var Vt = /^(?:webkit|moz|o)[A-Z]/, _e = /^-ms-/, En = /-(.)/g, nn = /;\s*$/, Kt = {}, wn = {}, ut = !1, dn = !1, It = function(c) {
        return c.replace(En, function(p, k) {
          return k.toUpperCase();
        });
      }, vn = function(c) {
        Kt.hasOwnProperty(c) && Kt[c] || (Kt[c] = !0, r(
          "Unsupported style property %s. Did you mean %s?",
          c,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          It(c.replace(_e, "ms-"))
        ));
      }, xn = function(c) {
        Kt.hasOwnProperty(c) && Kt[c] || (Kt[c] = !0, r("Unsupported vendor-prefixed style property %s. Did you mean %s?", c, c.charAt(0).toUpperCase() + c.slice(1)));
      }, qt = function(c, p) {
        wn.hasOwnProperty(p) && wn[p] || (wn[p] = !0, r(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, c, p.replace(nn, "")));
      }, fn = function(c, p) {
        ut || (ut = !0, r("`NaN` is an invalid value for the `%s` css style property.", c));
      }, Et = function(c, p) {
        dn || (dn = !0, r("`Infinity` is an invalid value for the `%s` css style property.", c));
      };
      zt = function(c, p) {
        c.indexOf("-") > -1 ? vn(c) : Vt.test(c) ? xn(c) : nn.test(p) && qt(c, p), typeof p == "number" && (isNaN(p) ? fn(c, p) : isFinite(p) || Et(c, p));
      };
    }
    var Nn = zt, Ln = /["'&<>]/;
    function Bn(c) {
      I(c);
      var p = "" + c, k = Ln.exec(p);
      if (!k)
        return p;
      var D, V = "", ae, pe = 0;
      for (ae = k.index; ae < p.length; ae++) {
        switch (p.charCodeAt(ae)) {
          case 34:
            D = "&quot;";
            break;
          case 38:
            D = "&amp;";
            break;
          case 39:
            D = "&#x27;";
            break;
          case 60:
            D = "&lt;";
            break;
          case 62:
            D = "&gt;";
            break;
          default:
            continue;
        }
        pe !== ae && (V += p.substring(pe, ae)), pe = ae + 1, V += D;
      }
      return pe !== ae ? V + p.substring(pe, ae) : V;
    }
    function Ht(c) {
      return typeof c == "boolean" || typeof c == "number" ? "" + c : Bn(c);
    }
    var Fn = /([A-Z])/g, Oe = /^ms-/;
    function ht(c) {
      return c.replace(Fn, "-$1").toLowerCase().replace(Oe, "-ms-");
    }
    var it = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, nt = !1;
    function ln(c) {
      !nt && it.test(c) && (nt = !0, r("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(c)));
    }
    var Gt = Array.isArray;
    function K(c) {
      return Gt(c);
    }
    var Ne = g("<script>"), Ze = g("<\/script>"), je = g('<script src="'), kt = g('<script type="module" src="'), rt = g('" async=""><\/script>');
    function wt(c) {
      return I(c), ("" + c).replace(Mt, Qe);
    }
    var Mt = /(<\/|<)(s)(cript)/gi, Qe = function(c, p, k, D) {
      return "" + p + (k === "s" ? "\\u0073" : "\\u0053") + D;
    };
    function pt(c, p, k, D, V) {
      var ae = c === void 0 ? "" : c, pe = p === void 0 ? Ne : g('<script nonce="' + Ht(p) + '">'), Re = [];
      if (k !== void 0 && Re.push(pe, T(wt(k)), Ze), D !== void 0)
        for (var l = 0; l < D.length; l++)
          Re.push(je, T(Ht(D[l])), rt);
      if (V !== void 0)
        for (var h = 0; h < V.length; h++)
          Re.push(kt, T(Ht(V[h])), rt);
      return {
        bootstrapChunks: Re,
        startInlineScript: pe,
        placeholderPrefix: g(ae + "P:"),
        segmentPrefix: g(ae + "S:"),
        boundaryPrefix: ae + "B:",
        idPrefix: ae,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var Nt = 0, _t = 1, jt = 2, Ft = 3, Ct = 4, Zt = 5, Ut = 6, Qt = 7;
    function sn(c, p) {
      return {
        insertionMode: c,
        selectedValue: p
      };
    }
    function un(c) {
      var p = c === "http://www.w3.org/2000/svg" ? jt : c === "http://www.w3.org/1998/Math/MathML" ? Ft : Nt;
      return sn(p, null);
    }
    function gn(c, p, k) {
      switch (p) {
        case "select":
          return sn(_t, k.value != null ? k.value : k.defaultValue);
        case "svg":
          return sn(jt, null);
        case "math":
          return sn(Ft, null);
        case "foreignObject":
          return sn(_t, null);
        case "table":
          return sn(Ct, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return sn(Zt, null);
        case "colgroup":
          return sn(Qt, null);
        case "tr":
          return sn(Ut, null);
      }
      return c.insertionMode >= Ct || c.insertionMode === Nt ? sn(_t, null) : c;
    }
    var Rn = null;
    function cn(c) {
      var p = c.nextSuspenseID++;
      return g(c.boundaryPrefix + p.toString(16));
    }
    function Tn(c, p, k) {
      var D = c.idPrefix, V = ":" + D + "R" + p;
      return k > 0 && (V += "H" + k.toString(32)), V + ":";
    }
    function In(c) {
      return Ht(c);
    }
    var Yn = g("<!-- -->");
    function Zn(c, p, k, D) {
      return p === "" ? D : (D && c.push(Yn), c.push(T(In(p))), !0);
    }
    function Xn(c, p, k, D) {
      k && D && c.push(Yn);
    }
    var x = /* @__PURE__ */ new Map();
    function P(c) {
      var p = x.get(c);
      if (p !== void 0)
        return p;
      var k = g(Ht(ht(c)));
      return x.set(c, k), k;
    }
    var B = g(' style="'), Y = g(":"), Ee = g(";");
    function xe(c, p, k) {
      if (typeof k != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var D = !0;
      for (var V in k)
        if (X.call(k, V)) {
          var ae = k[V];
          if (!(ae == null || typeof ae == "boolean" || ae === "")) {
            var pe = void 0, Re = void 0, l = V.indexOf("--") === 0;
            l ? (pe = T(Ht(V)), H(ae, V), Re = T(Ht(("" + ae).trim()))) : (Nn(V, ae), pe = P(V), typeof ae == "number" ? ae !== 0 && !X.call(ke, V) ? Re = T(ae + "px") : Re = T("" + ae) : (H(ae, V), Re = T(Ht(("" + ae).trim())))), D ? (D = !1, c.push(B, pe, Y, Re)) : c.push(Ee, pe, Y, Re);
          }
        }
      D || c.push(ot);
    }
    var De = g(" "), Ve = g('="'), ot = g('"'), yt = g('=""');
    function oe(c, p, k, D) {
      switch (k) {
        case "style": {
          xe(c, p, D);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(k.length > 2 && (k[0] === "o" || k[0] === "O") && (k[1] === "n" || k[1] === "N"))
      ) {
        var V = Le(k);
        if (V !== null) {
          switch (typeof D) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!V.acceptsBooleans)
                return;
          }
          var ae = V.attributeName, pe = T(ae);
          switch (V.type) {
            case j:
              D && c.push(De, pe, yt);
              return;
            case U:
              D === !0 ? c.push(De, pe, yt) : D === !1 || c.push(De, pe, Ve, T(Ht(D)), ot);
              return;
            case W:
              isNaN(D) || c.push(De, pe, Ve, T(Ht(D)), ot);
              break;
            case re:
              !isNaN(D) && D >= 1 && c.push(De, pe, Ve, T(Ht(D)), ot);
              break;
            default:
              V.sanitizeURL && (C(D, ae), D = "" + D, ln(D)), c.push(De, pe, Ve, T(Ht(D)), ot);
          }
        } else if (ye(k)) {
          switch (typeof D) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Re = k.toLowerCase().slice(0, 5);
              if (Re !== "data-" && Re !== "aria-")
                return;
            }
          }
          c.push(De, T(k), Ve, T(Ht(D)), ot);
        }
      }
    }
    var le = g(">"), ve = g("/>");
    function Me(c, p, k) {
      if (p != null) {
        if (k != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof p != "object" || !("__html" in p))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var D = p.__html;
        D != null && (I(D), c.push(T("" + D)));
      }
    }
    var bt = !1, bn = !1, An = !1, fr = !1, Hn = !1, Cr = !1, hr = !1;
    function Qr(c, p) {
      {
        var k = c[p];
        if (k != null) {
          var D = K(k);
          c.multiple && !D ? r("The `%s` prop supplied to <select> must be an array if `multiple` is true.", p) : !c.multiple && D && r("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", p);
        }
      }
    }
    function ol(c, p, k) {
      qe("select", p), Qr(p, "value"), Qr(p, "defaultValue"), p.value !== void 0 && p.defaultValue !== void 0 && !An && (r("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), An = !0), c.push(Qn("select"));
      var D = null, V = null;
      for (var ae in p)
        if (X.call(p, ae)) {
          var pe = p[ae];
          if (pe == null)
            continue;
          switch (ae) {
            case "children":
              D = pe;
              break;
            case "dangerouslySetInnerHTML":
              V = pe;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              oe(c, k, ae, pe);
              break;
          }
        }
      return c.push(le), Me(c, V, D), D;
    }
    function ll(c) {
      var p = "";
      return e.Children.forEach(c, function(k) {
        k != null && (p += k, !Hn && typeof k != "string" && typeof k != "number" && (Hn = !0, r("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), p;
    }
    var Ua = g(' selected=""');
    function sl(c, p, k, D) {
      var V = D.selectedValue;
      c.push(Qn("option"));
      var ae = null, pe = null, Re = null, l = null;
      for (var h in p)
        if (X.call(p, h)) {
          var S = p[h];
          if (S == null)
            continue;
          switch (h) {
            case "children":
              ae = S;
              break;
            case "selected":
              Re = S, hr || (r("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), hr = !0);
              break;
            case "dangerouslySetInnerHTML":
              l = S;
              break;
            case "value":
              pe = S;
            default:
              oe(c, k, h, S);
              break;
          }
        }
      if (V != null) {
        var A;
        if (pe !== null ? (C(pe, "value"), A = "" + pe) : (l !== null && (Cr || (Cr = !0, r("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), A = ll(ae)), K(V))
          for (var z = 0; z < V.length; z++) {
            C(V[z], "value");
            var Q = "" + V[z];
            if (Q === A) {
              c.push(Ua);
              break;
            }
          }
        else
          C(V, "select.value"), "" + V === A && c.push(Ua);
      } else
        Re && c.push(Ua);
      return c.push(le), Me(c, l, ae), ae;
    }
    function Ka(c, p, k) {
      qe("input", p), p.checked !== void 0 && p.defaultChecked !== void 0 && !bn && (r("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", p.type), bn = !0), p.value !== void 0 && p.defaultValue !== void 0 && !bt && (r("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", p.type), bt = !0), c.push(Qn("input"));
      var D = null, V = null, ae = null, pe = null;
      for (var Re in p)
        if (X.call(p, Re)) {
          var l = p[Re];
          if (l == null)
            continue;
          switch (Re) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              pe = l;
              break;
            case "defaultValue":
              V = l;
              break;
            case "checked":
              ae = l;
              break;
            case "value":
              D = l;
              break;
            default:
              oe(c, k, Re, l);
              break;
          }
        }
      return ae !== null ? oe(c, k, "checked", ae) : pe !== null && oe(c, k, "checked", pe), D !== null ? oe(c, k, "value", D) : V !== null && oe(c, k, "value", V), c.push(ve), null;
    }
    function pr(c, p, k) {
      qe("textarea", p), p.value !== void 0 && p.defaultValue !== void 0 && !fr && (r("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), fr = !0), c.push(Qn("textarea"));
      var D = null, V = null, ae = null;
      for (var pe in p)
        if (X.call(p, pe)) {
          var Re = p[pe];
          if (Re == null)
            continue;
          switch (pe) {
            case "children":
              ae = Re;
              break;
            case "value":
              D = Re;
              break;
            case "defaultValue":
              V = Re;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              oe(c, k, pe, Re);
              break;
          }
        }
      if (D === null && V !== null && (D = V), c.push(le), ae != null) {
        if (r("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), D != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (K(ae)) {
          if (ae.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          I(ae[0]), D = "" + ae[0];
        }
        I(ae), D = "" + ae;
      }
      return typeof D == "string" && D[0] === `
` && c.push(Ar), D !== null && (C(D, "value"), c.push(T(In("" + D)))), null;
    }
    function Jr(c, p, k, D) {
      c.push(Qn(k));
      for (var V in p)
        if (X.call(p, V)) {
          var ae = p[V];
          if (ae == null)
            continue;
          switch (V) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(k + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              oe(c, D, V, ae);
              break;
          }
        }
      return c.push(ve), null;
    }
    function pa(c, p, k) {
      c.push(Qn("menuitem"));
      for (var D in p)
        if (X.call(p, D)) {
          var V = p[D];
          if (V == null)
            continue;
          switch (D) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              oe(c, k, D, V);
              break;
          }
        }
      return c.push(le), null;
    }
    function en(c, p, k) {
      c.push(Qn("title"));
      var D = null;
      for (var V in p)
        if (X.call(p, V)) {
          var ae = p[V];
          if (ae == null)
            continue;
          switch (V) {
            case "children":
              D = ae;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              oe(c, k, V, ae);
              break;
          }
        }
      c.push(le);
      {
        var pe = Array.isArray(D) && D.length < 2 ? D[0] || null : D;
        Array.isArray(D) && D.length > 1 ? r("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : pe != null && pe.$$typeof != null ? r("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : pe != null && typeof pe != "string" && typeof pe != "number" && r("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return D;
    }
    function yr(c, p, k, D) {
      c.push(Qn(k));
      var V = null, ae = null;
      for (var pe in p)
        if (X.call(p, pe)) {
          var Re = p[pe];
          if (Re == null)
            continue;
          switch (pe) {
            case "children":
              V = Re;
              break;
            case "dangerouslySetInnerHTML":
              ae = Re;
              break;
            default:
              oe(c, D, pe, Re);
              break;
          }
        }
      return c.push(le), Me(c, ae, V), typeof V == "string" ? (c.push(T(In(V))), null) : V;
    }
    function Vn(c, p, k, D) {
      c.push(Qn(k));
      var V = null, ae = null;
      for (var pe in p)
        if (X.call(p, pe)) {
          var Re = p[pe];
          if (Re == null)
            continue;
          switch (pe) {
            case "children":
              V = Re;
              break;
            case "dangerouslySetInnerHTML":
              ae = Re;
              break;
            case "style":
              xe(c, D, Re);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              ye(pe) && typeof Re != "function" && typeof Re != "symbol" && c.push(De, T(pe), Ve, T(Ht(Re)), ot);
              break;
          }
        }
      return c.push(le), Me(c, ae, V), V;
    }
    var Ar = g(`
`);
    function vr(c, p, k, D) {
      c.push(Qn(k));
      var V = null, ae = null;
      for (var pe in p)
        if (X.call(p, pe)) {
          var Re = p[pe];
          if (Re == null)
            continue;
          switch (pe) {
            case "children":
              V = Re;
              break;
            case "dangerouslySetInnerHTML":
              ae = Re;
              break;
            default:
              oe(c, D, pe, Re);
              break;
          }
        }
      if (c.push(le), ae != null) {
        if (V != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof ae != "object" || !("__html" in ae))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var l = ae.__html;
        l != null && (typeof l == "string" && l.length > 0 && l[0] === `
` ? c.push(Ar, T(l)) : (I(l), c.push(T("" + l))));
      }
      return typeof V == "string" && V[0] === `
` && c.push(Ar), V;
    }
    var ma = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, xr = /* @__PURE__ */ new Map();
    function Qn(c) {
      var p = xr.get(c);
      if (p === void 0) {
        if (!ma.test(c))
          throw new Error("Invalid tag: " + c);
        p = g("<" + c), xr.set(c, p);
      }
      return p;
    }
    var Ya = g("<!DOCTYPE html>");
    function Xa(c, p, k, D, V) {
      switch (ze(p, k), Ye(p, k), mn(p, k, null), !k.suppressContentEditableWarning && k.contentEditable && k.children != null && r("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), V.insertionMode !== jt && V.insertionMode !== Ft && p.indexOf("-") === -1 && typeof k.is != "string" && p.toLowerCase() !== p && r("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", p), p) {
        case "select":
          return ol(c, k, D);
        case "option":
          return sl(c, k, D, V);
        case "textarea":
          return pr(c, k, D);
        case "input":
          return Ka(c, k, D);
        case "menuitem":
          return pa(c, k, D);
        case "title":
          return en(c, k, D);
        case "listing":
        case "pre":
          return vr(c, k, p, D);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Jr(c, k, p, D);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return yr(c, k, p, D);
        case "html":
          return V.insertionMode === Nt && c.push(Ya), yr(c, k, p, D);
        default:
          return p.indexOf("-") === -1 && typeof k.is != "string" ? yr(c, k, p, D) : Vn(c, k, p, D);
      }
    }
    var ji = g("</"), Ui = g(">");
    function Ki(c, p, k) {
      switch (p) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          c.push(ji, T(p), Ui);
      }
    }
    function ul(c, p) {
      for (var k = p.bootstrapChunks, D = 0; D < k.length - 1; D++)
        y(c, k[D]);
      return D < k.length ? v(c, k[D]) : !0;
    }
    var cl = g('<template id="'), ga = g('"></template>');
    function ya(c, p, k) {
      y(c, cl), y(c, p.placeholderPrefix);
      var D = T(k.toString(16));
      return y(c, D), v(c, ga);
    }
    var va = g("<!--$-->"), ea = g('<!--$?--><template id="'), dl = g('"></template>'), ta = g("<!--$!-->"), qa = g("<!--/$-->"), Ga = g("<template"), Fr = g('"'), zr = g(' data-dgst="'), xa = g(' data-msg="'), Yi = g(' data-stck="'), Za = g("></template>");
    function Xi(c, p) {
      return v(c, va);
    }
    function ba(c, p, k) {
      if (y(c, ea), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return y(c, k), v(c, dl);
    }
    function jn(c, p, k, D, V) {
      var ae;
      return ae = v(c, ta), y(c, Ga), k && (y(c, zr), y(c, T(Ht(k))), y(c, Fr)), D && (y(c, xa), y(c, T(Ht(D))), y(c, Fr)), V && (y(c, Yi), y(c, T(Ht(V))), y(c, Fr)), ae = v(c, Za), ae;
    }
    function qi(c, p) {
      return v(c, qa);
    }
    function Sa(c, p) {
      return v(c, qa);
    }
    function fl(c, p) {
      return v(c, qa);
    }
    var Gi = g('<div hidden id="'), Ea = g('">'), Zi = g("</div>"), Qi = g('<svg aria-hidden="true" style="display:none" id="'), ka = g('">'), wa = g("</svg>"), Ji = g('<math aria-hidden="true" style="display:none" id="'), eo = g('">'), to = g("</math>"), Qa = g('<table hidden id="'), no = g('">'), b = g("</table>"), R = g('<table hidden><tbody id="'), $ = g('">'), q = g("</tbody></table>"), Te = g('<table hidden><tr id="'), Se = g('">'), Fe = g("</tr></table>"), Ue = g('<table hidden><colgroup id="'), St = g('">'), Ot = g("</colgroup></table>");
    function Rt(c, p, k, D) {
      switch (k.insertionMode) {
        case Nt:
        case _t:
          return y(c, Gi), y(c, p.segmentPrefix), y(c, T(D.toString(16))), v(c, Ea);
        case jt:
          return y(c, Qi), y(c, p.segmentPrefix), y(c, T(D.toString(16))), v(c, ka);
        case Ft:
          return y(c, Ji), y(c, p.segmentPrefix), y(c, T(D.toString(16))), v(c, eo);
        case Ct:
          return y(c, Qa), y(c, p.segmentPrefix), y(c, T(D.toString(16))), v(c, no);
        case Zt:
          return y(c, R), y(c, p.segmentPrefix), y(c, T(D.toString(16))), v(c, $);
        case Ut:
          return y(c, Te), y(c, p.segmentPrefix), y(c, T(D.toString(16))), v(c, Se);
        case Qt:
          return y(c, Ue), y(c, p.segmentPrefix), y(c, T(D.toString(16))), v(c, St);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function rn(c, p) {
      switch (p.insertionMode) {
        case Nt:
        case _t:
          return v(c, Zi);
        case jt:
          return v(c, wa);
        case Ft:
          return v(c, to);
        case Ct:
          return v(c, b);
        case Zt:
          return v(c, q);
        case Ut:
          return v(c, Fe);
        case Qt:
          return v(c, Ot);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Un = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", Jn = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', er = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Ta = g(Un + ';$RS("'), ro = g('$RS("'), Ja = g('","'), zc = g('")<\/script>');
    function $c(c, p, k) {
      y(c, p.startInlineScript), p.sentCompleteSegmentFunction ? y(c, ro) : (p.sentCompleteSegmentFunction = !0, y(c, Ta)), y(c, p.segmentPrefix);
      var D = T(k.toString(16));
      return y(c, D), y(c, Ja), y(c, p.placeholderPrefix), y(c, D), v(c, zc);
    }
    var Bc = g(Jn + ';$RC("'), Ic = g('$RC("'), Hc = g('","'), Wc = g('")<\/script>');
    function hl(c, p, k, D) {
      if (y(c, p.startInlineScript), p.sentCompleteBoundaryFunction ? y(c, Ic) : (p.sentCompleteBoundaryFunction = !0, y(c, Bc)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var V = T(D.toString(16));
      return y(c, k), y(c, Hc), y(c, p.segmentPrefix), y(c, V), v(c, Wc);
    }
    var Vc = g(er + ';$RX("'), jc = g('$RX("'), pl = g('"'), Uc = g(")<\/script>"), ml = g(",");
    function _s(c, p, k, D, V, ae) {
      if (y(c, p.startInlineScript), p.sentClientRenderFunction ? y(c, jc) : (p.sentClientRenderFunction = !0, y(c, Vc)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return y(c, k), y(c, pl), (D || V || ae) && (y(c, ml), y(c, T(gl(D || "")))), (V || ae) && (y(c, ml), y(c, T(gl(V || "")))), ae && (y(c, ml), y(c, T(gl(ae)))), v(c, Uc);
    }
    var Ns = /[<\u2028\u2029]/g;
    function gl(c) {
      var p = JSON.stringify(c);
      return p.replace(Ns, function(k) {
        switch (k) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var or = Object.assign, Kc = Symbol.for("react.element"), Fs = Symbol.for("react.portal"), tr = Symbol.for("react.fragment"), zs = Symbol.for("react.strict_mode"), yl = Symbol.for("react.profiler"), ao = Symbol.for("react.provider"), io = Symbol.for("react.context"), oo = Symbol.for("react.forward_ref"), ei = Symbol.for("react.suspense"), ti = Symbol.for("react.suspense_list"), ni = Symbol.for("react.memo"), Ca = Symbol.for("react.lazy"), vl = Symbol.for("react.scope"), xl = Symbol.for("react.debug_trace_mode"), lo = Symbol.for("react.legacy_hidden"), Yc = Symbol.for("react.default_value"), $s = Symbol.iterator, Xc = "@@iterator";
    function qc(c) {
      if (c === null || typeof c != "object")
        return null;
      var p = $s && c[$s] || c[Xc];
      return typeof p == "function" ? p : null;
    }
    function Bs(c, p, k) {
      var D = c.displayName;
      if (D)
        return D;
      var V = p.displayName || p.name || "";
      return V !== "" ? k + "(" + V + ")" : k;
    }
    function Is(c) {
      return c.displayName || "Context";
    }
    function Sn(c) {
      if (c == null)
        return null;
      if (typeof c.tag == "number" && r("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof c == "function")
        return c.displayName || c.name || null;
      if (typeof c == "string")
        return c;
      switch (c) {
        case tr:
          return "Fragment";
        case Fs:
          return "Portal";
        case yl:
          return "Profiler";
        case zs:
          return "StrictMode";
        case ei:
          return "Suspense";
        case ti:
          return "SuspenseList";
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case io:
            var p = c;
            return Is(p) + ".Consumer";
          case ao:
            var k = c;
            return Is(k._context) + ".Provider";
          case oo:
            return Bs(c, c.render, "ForwardRef");
          case ni:
            var D = c.displayName || null;
            return D !== null ? D : Sn(c.type) || "Memo";
          case Ca: {
            var V = c, ae = V._payload, pe = V._init;
            try {
              return Sn(pe(ae));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ri = 0, bl, yn, Aa, Sl, El, kl, wl;
    function Tl() {
    }
    Tl.__reactDisabledLog = !0;
    function Hs() {
      {
        if (ri === 0) {
          bl = console.log, yn = console.info, Aa = console.warn, Sl = console.error, El = console.group, kl = console.groupCollapsed, wl = console.groupEnd;
          var c = {
            configurable: !0,
            enumerable: !0,
            value: Tl,
            writable: !0
          };
          Object.defineProperties(console, {
            info: c,
            log: c,
            warn: c,
            error: c,
            group: c,
            groupCollapsed: c,
            groupEnd: c
          });
        }
        ri++;
      }
    }
    function Ws() {
      {
        if (ri--, ri === 0) {
          var c = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: or({}, c, {
              value: bl
            }),
            info: or({}, c, {
              value: yn
            }),
            warn: or({}, c, {
              value: Aa
            }),
            error: or({}, c, {
              value: Sl
            }),
            group: or({}, c, {
              value: El
            }),
            groupCollapsed: or({}, c, {
              value: kl
            }),
            groupEnd: or({}, c, {
              value: wl
            })
          });
        }
        ri < 0 && r("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var so = n.ReactCurrentDispatcher, Cl;
    function ai(c, p, k) {
      {
        if (Cl === void 0)
          try {
            throw Error();
          } catch (V) {
            var D = V.stack.trim().match(/\n( *(at )?)/);
            Cl = D && D[1] || "";
          }
        return `
` + Cl + c;
      }
    }
    var ii = !1, Pa;
    {
      var oi = typeof WeakMap == "function" ? WeakMap : Map;
      Pa = new oi();
    }
    function li(c, p) {
      if (!c || ii)
        return "";
      {
        var k = Pa.get(c);
        if (k !== void 0)
          return k;
      }
      var D;
      ii = !0;
      var V = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ae;
      ae = so.current, so.current = null, Hs();
      try {
        if (p) {
          var pe = function() {
            throw Error();
          };
          if (Object.defineProperty(pe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(pe, []);
            } catch (fe) {
              D = fe;
            }
            Reflect.construct(c, [], pe);
          } else {
            try {
              pe.call();
            } catch (fe) {
              D = fe;
            }
            c.call(pe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (fe) {
            D = fe;
          }
          c();
        }
      } catch (fe) {
        if (fe && D && typeof fe.stack == "string") {
          for (var Re = fe.stack.split(`
`), l = D.stack.split(`
`), h = Re.length - 1, S = l.length - 1; h >= 1 && S >= 0 && Re[h] !== l[S]; )
            S--;
          for (; h >= 1 && S >= 0; h--, S--)
            if (Re[h] !== l[S]) {
              if (h !== 1 || S !== 1)
                do
                  if (h--, S--, S < 0 || Re[h] !== l[S]) {
                    var A = `
` + Re[h].replace(" at new ", " at ");
                    return c.displayName && A.includes("<anonymous>") && (A = A.replace("<anonymous>", c.displayName)), typeof c == "function" && Pa.set(c, A), A;
                  }
                while (h >= 1 && S >= 0);
              break;
            }
        }
      } finally {
        ii = !1, so.current = ae, Ws(), Error.prepareStackTrace = V;
      }
      var z = c ? c.displayName || c.name : "", Q = z ? ai(z) : "";
      return typeof c == "function" && Pa.set(c, Q), Q;
    }
    function uo(c, p, k) {
      return li(c, !0);
    }
    function Vs(c, p, k) {
      return li(c, !1);
    }
    function Al(c) {
      var p = c.prototype;
      return !!(p && p.isReactComponent);
    }
    function Pl(c, p, k) {
      if (c == null)
        return "";
      if (typeof c == "function")
        return li(c, Al(c));
      if (typeof c == "string")
        return ai(c);
      switch (c) {
        case ei:
          return ai("Suspense");
        case ti:
          return ai("SuspenseList");
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case oo:
            return Vs(c.render);
          case ni:
            return Pl(c.type, p, k);
          case Ca: {
            var D = c, V = D._payload, ae = D._init;
            try {
              return Pl(ae(V), p, k);
            } catch {
            }
          }
        }
      return "";
    }
    var Ll = {}, js = n.ReactDebugCurrentFrame;
    function La(c) {
      if (c) {
        var p = c._owner, k = Pl(c.type, c._source, p ? p.type : null);
        js.setExtraStackFrame(k);
      } else
        js.setExtraStackFrame(null);
    }
    function Rl(c, p, k, D, V) {
      {
        var ae = Function.call.bind(X);
        for (var pe in c)
          if (ae(c, pe)) {
            var Re = void 0;
            try {
              if (typeof c[pe] != "function") {
                var l = Error((D || "React class") + ": " + k + " type `" + pe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof c[pe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw l.name = "Invariant Violation", l;
              }
              Re = c[pe](p, pe, D, k, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (h) {
              Re = h;
            }
            Re && !(Re instanceof Error) && (La(V), r("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", D || "React class", k, pe, typeof Re), La(null)), Re instanceof Error && !(Re.message in Ll) && (Ll[Re.message] = !0, La(V), r("Failed %s type: %s", k, Re.message), La(null));
          }
      }
    }
    var co;
    co = {};
    var na = {};
    Object.freeze(na);
    function Dl(c, p) {
      {
        var k = c.contextTypes;
        if (!k)
          return na;
        var D = {};
        for (var V in k)
          D[V] = p[V];
        {
          var ae = Sn(c) || "Unknown";
          Rl(k, D, "context", ae);
        }
        return D;
      }
    }
    function Ol(c, p, k, D) {
      {
        if (typeof c.getChildContext != "function") {
          {
            var V = Sn(p) || "Unknown";
            co[V] || (co[V] = !0, r("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", V, V));
          }
          return k;
        }
        var ae = c.getChildContext();
        for (var pe in ae)
          if (!(pe in D))
            throw new Error((Sn(p) || "Unknown") + '.getChildContext(): key "' + pe + '" is not defined in childContextTypes.');
        {
          var Re = Sn(p) || "Unknown";
          Rl(D, ae, "child context", Re);
        }
        return or({}, k, ae);
      }
    }
    var $r;
    $r = {};
    var Us = null, ra = null;
    function aa(c) {
      c.context._currentValue = c.parentValue;
    }
    function Ml(c) {
      c.context._currentValue = c.value;
    }
    function br(c, p) {
      if (c !== p) {
        aa(c);
        var k = c.parent, D = p.parent;
        if (k === null) {
          if (D !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (D === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          br(k, D);
        }
        Ml(p);
      }
    }
    function fo(c) {
      aa(c);
      var p = c.parent;
      p !== null && fo(p);
    }
    function ho(c) {
      var p = c.parent;
      p !== null && ho(p), Ml(c);
    }
    function si(c, p) {
      aa(c);
      var k = c.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      k.depth === p.depth ? br(k, p) : si(k, p);
    }
    function _l(c, p) {
      var k = p.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      c.depth === k.depth ? br(c, k) : _l(c, k), Ml(p);
    }
    function ui(c) {
      var p = ra, k = c;
      p !== k && (p === null ? ho(k) : k === null ? fo(p) : p.depth === k.depth ? br(p, k) : p.depth > k.depth ? si(p, k) : _l(p, k), ra = k);
    }
    function Ks(c, p) {
      var k;
      k = c._currentValue, c._currentValue = p, c._currentRenderer !== void 0 && c._currentRenderer !== null && c._currentRenderer !== $r && r("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), c._currentRenderer = $r;
      var D = ra, V = {
        parent: D,
        depth: D === null ? 0 : D.depth + 1,
        context: c,
        parentValue: k,
        value: p
      };
      return ra = V, V;
    }
    function Ys(c) {
      var p = ra;
      if (p === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      p.context !== c && r("The parent context is not the expected context. This is probably a bug in React.");
      {
        var k = p.parentValue;
        k === Yc ? p.context._currentValue = p.context._defaultValue : p.context._currentValue = k, c._currentRenderer !== void 0 && c._currentRenderer !== null && c._currentRenderer !== $r && r("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), c._currentRenderer = $r;
      }
      return ra = p.parent;
    }
    function po() {
      return ra;
    }
    function ci(c) {
      var p = c._currentValue;
      return p;
    }
    function Nl(c) {
      return c._reactInternals;
    }
    function Gc(c, p) {
      c._reactInternals = p;
    }
    var Ra = {}, mo = {}, Fl, go, yo, di, vo, Da, fi, xo, Oa;
    {
      Fl = /* @__PURE__ */ new Set(), go = /* @__PURE__ */ new Set(), yo = /* @__PURE__ */ new Set(), fi = /* @__PURE__ */ new Set(), di = /* @__PURE__ */ new Set(), xo = /* @__PURE__ */ new Set(), Oa = /* @__PURE__ */ new Set();
      var bo = /* @__PURE__ */ new Set();
      Da = function(c, p) {
        if (!(c === null || typeof c == "function")) {
          var k = p + "_" + c;
          bo.has(k) || (bo.add(k), r("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", p, c));
        }
      }, vo = function(c, p) {
        if (p === void 0) {
          var k = Sn(c) || "Component";
          di.has(k) || (di.add(k), r("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", k));
        }
      };
    }
    function So(c, p) {
      {
        var k = c.constructor, D = k && Sn(k) || "ReactClass", V = D + "." + p;
        if (Ra[V])
          return;
        r(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, p, p, D), Ra[V] = !0;
      }
    }
    var Eo = {
      isMounted: function(c) {
        return !1;
      },
      enqueueSetState: function(c, p, k) {
        var D = Nl(c);
        D.queue === null ? So(c, "setState") : (D.queue.push(p), k != null && Da(k, "setState"));
      },
      enqueueReplaceState: function(c, p, k) {
        var D = Nl(c);
        D.replace = !0, D.queue = [p], k != null && Da(k, "setState");
      },
      enqueueForceUpdate: function(c, p) {
        var k = Nl(c);
        k.queue === null ? So(c, "forceUpdate") : p != null && Da(p, "setState");
      }
    };
    function Xs(c, p, k, D, V) {
      var ae = k(V, D);
      vo(p, ae);
      var pe = ae == null ? D : or({}, D, ae);
      return pe;
    }
    function qs(c, p, k) {
      var D = na, V = c.contextType;
      if ("contextType" in c) {
        var ae = (
          // Allow null for conditional declaration
          V === null || V !== void 0 && V.$$typeof === io && V._context === void 0
        );
        if (!ae && !Oa.has(c)) {
          Oa.add(c);
          var pe = "";
          V === void 0 ? pe = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof V != "object" ? pe = " However, it is set to a " + typeof V + "." : V.$$typeof === ao ? pe = " Did you accidentally pass the Context.Provider instead?" : V._context !== void 0 ? pe = " Did you accidentally pass the Context.Consumer instead?" : pe = " However, it is set to an object with keys {" + Object.keys(V).join(", ") + "}.", r("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Sn(c) || "Component", pe);
        }
      }
      typeof V == "object" && V !== null ? D = ci(V) : D = k;
      var Re = new c(p, D);
      {
        if (typeof c.getDerivedStateFromProps == "function" && (Re.state === null || Re.state === void 0)) {
          var l = Sn(c) || "Component";
          Fl.has(l) || (Fl.add(l), r("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", l, Re.state === null ? "null" : "undefined", l));
        }
        if (typeof c.getDerivedStateFromProps == "function" || typeof Re.getSnapshotBeforeUpdate == "function") {
          var h = null, S = null, A = null;
          if (typeof Re.componentWillMount == "function" && Re.componentWillMount.__suppressDeprecationWarning !== !0 ? h = "componentWillMount" : typeof Re.UNSAFE_componentWillMount == "function" && (h = "UNSAFE_componentWillMount"), typeof Re.componentWillReceiveProps == "function" && Re.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? S = "componentWillReceiveProps" : typeof Re.UNSAFE_componentWillReceiveProps == "function" && (S = "UNSAFE_componentWillReceiveProps"), typeof Re.componentWillUpdate == "function" && Re.componentWillUpdate.__suppressDeprecationWarning !== !0 ? A = "componentWillUpdate" : typeof Re.UNSAFE_componentWillUpdate == "function" && (A = "UNSAFE_componentWillUpdate"), h !== null || S !== null || A !== null) {
            var z = Sn(c) || "Component", Q = typeof c.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            yo.has(z) || (yo.add(z), r(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, z, Q, h !== null ? `
  ` + h : "", S !== null ? `
  ` + S : "", A !== null ? `
  ` + A : ""));
          }
        }
      }
      return Re;
    }
    function Gs(c, p, k) {
      {
        var D = Sn(p) || "Component", V = c.render;
        V || (p.prototype && typeof p.prototype.render == "function" ? r("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", D) : r("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", D)), c.getInitialState && !c.getInitialState.isReactClassApproved && !c.state && r("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", D), c.getDefaultProps && !c.getDefaultProps.isReactClassApproved && r("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", D), c.propTypes && r("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", D), c.contextType && r("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", D), c.contextTypes && r("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", D), p.contextType && p.contextTypes && !xo.has(p) && (xo.add(p), r("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", D)), typeof c.componentShouldUpdate == "function" && r("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", D), p.prototype && p.prototype.isPureReactComponent && typeof c.shouldComponentUpdate < "u" && r("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Sn(p) || "A pure component"), typeof c.componentDidUnmount == "function" && r("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", D), typeof c.componentDidReceiveProps == "function" && r("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", D), typeof c.componentWillRecieveProps == "function" && r("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", D), typeof c.UNSAFE_componentWillRecieveProps == "function" && r("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", D);
        var ae = c.props !== k;
        c.props !== void 0 && ae && r("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", D, D), c.defaultProps && r("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", D, D), typeof c.getSnapshotBeforeUpdate == "function" && typeof c.componentDidUpdate != "function" && !go.has(p) && (go.add(p), r("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Sn(p))), typeof c.getDerivedStateFromProps == "function" && r("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", D), typeof c.getDerivedStateFromError == "function" && r("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", D), typeof p.getSnapshotBeforeUpdate == "function" && r("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", D);
        var pe = c.state;
        pe && (typeof pe != "object" || K(pe)) && r("%s.state: must be set to an object or null", D), typeof c.getChildContext == "function" && typeof p.childContextTypes != "object" && r("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", D);
      }
    }
    function Zc(c, p) {
      var k = p.state;
      if (typeof p.componentWillMount == "function") {
        if (p.componentWillMount.__suppressDeprecationWarning !== !0) {
          var D = Sn(c) || "Unknown";
          mo[D] || (a(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            D
          ), mo[D] = !0);
        }
        p.componentWillMount();
      }
      typeof p.UNSAFE_componentWillMount == "function" && p.UNSAFE_componentWillMount(), k !== p.state && (r("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Sn(c) || "Component"), Eo.enqueueReplaceState(p, p.state, null));
    }
    function Qc(c, p, k, D) {
      if (c.queue !== null && c.queue.length > 0) {
        var V = c.queue, ae = c.replace;
        if (c.queue = null, c.replace = !1, ae && V.length === 1)
          p.state = V[0];
        else {
          for (var pe = ae ? V[0] : p.state, Re = !0, l = ae ? 1 : 0; l < V.length; l++) {
            var h = V[l], S = typeof h == "function" ? h.call(p, pe, k, D) : h;
            S != null && (Re ? (Re = !1, pe = or({}, pe, S)) : or(pe, S));
          }
          p.state = pe;
        }
      } else
        c.queue = null;
    }
    function Zs(c, p, k, D) {
      Gs(c, p, k);
      var V = c.state !== void 0 ? c.state : null;
      c.updater = Eo, c.props = k, c.state = V;
      var ae = {
        queue: [],
        replace: !1
      };
      Gc(c, ae);
      var pe = p.contextType;
      if (typeof pe == "object" && pe !== null ? c.context = ci(pe) : c.context = D, c.state === k) {
        var Re = Sn(p) || "Component";
        fi.has(Re) || (fi.add(Re), r("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Re));
      }
      var l = p.getDerivedStateFromProps;
      typeof l == "function" && (c.state = Xs(c, p, l, V, k)), typeof p.getDerivedStateFromProps != "function" && typeof c.getSnapshotBeforeUpdate != "function" && (typeof c.UNSAFE_componentWillMount == "function" || typeof c.componentWillMount == "function") && (Zc(p, c), Qc(ae, c, k, D));
    }
    var Jc = {
      id: 1,
      overflow: ""
    };
    function ed(c) {
      var p = c.overflow, k = c.id, D = k & ~td(k);
      return D.toString(32) + p;
    }
    function ko(c, p, k) {
      var D = c.id, V = c.overflow, ae = wo(D) - 1, pe = D & ~(1 << ae), Re = k + 1, l = wo(p) + ae;
      if (l > 30) {
        var h = ae - ae % 5, S = (1 << h) - 1, A = (pe & S).toString(32), z = pe >> h, Q = ae - h, fe = wo(p) + Q, Ae = Re << Q, Ie = Ae | z, tt = A + V;
        return {
          id: 1 << fe | Ie,
          overflow: tt
        };
      } else {
        var st = Re << ae, At = st | pe, hn = V;
        return {
          id: 1 << l | At,
          overflow: hn
        };
      }
    }
    function wo(c) {
      return 32 - zl(c);
    }
    function td(c) {
      return 1 << wo(c) - 1;
    }
    var zl = Math.clz32 ? Math.clz32 : rd, To = Math.log, nd = Math.LN2;
    function rd(c) {
      var p = c >>> 0;
      return p === 0 ? 32 : 31 - (To(p) / nd | 0) | 0;
    }
    function ad(c, p) {
      return c === p && (c !== 0 || 1 / c === 1 / p) || c !== c && p !== p;
    }
    var id = typeof Object.is == "function" ? Object.is : ad, Pr = null, $l = null, Co = null, $t = null, ia = !1, oa = !1, Jt = 0, lr = null, la = 0, Ao = 25, zn = !1, Lr;
    function sa() {
      if (Pr === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return zn && r("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Pr;
    }
    function Sr(c, p) {
      if (p === null)
        return r("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Lr), !1;
      c.length !== p.length && r(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Lr, "[" + c.join(", ") + "]", "[" + p.join(", ") + "]");
      for (var k = 0; k < p.length && k < c.length; k++)
        if (!id(c[k], p[k]))
          return !1;
      return !0;
    }
    function ua() {
      if (la > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Rr() {
      return $t === null ? Co === null ? (ia = !1, Co = $t = ua()) : (ia = !0, $t = Co) : $t.next === null ? (ia = !1, $t = $t.next = ua()) : (ia = !0, $t = $t.next), $t;
    }
    function od(c, p) {
      Pr = p, $l = c, zn = !1, Jt = 0;
    }
    function Qs(c, p, k, D) {
      for (; oa; )
        oa = !1, Jt = 0, la += 1, $t = null, k = c(p, D);
      return Bl(), k;
    }
    function Po() {
      var c = Jt !== 0;
      return c;
    }
    function Bl() {
      zn = !1, Pr = null, $l = null, oa = !1, Co = null, la = 0, lr = null, $t = null;
    }
    function ld(c) {
      return zn && r("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), ci(c);
    }
    function Js(c) {
      return Lr = "useContext", sa(), ci(c);
    }
    function hi(c, p) {
      return typeof p == "function" ? p(c) : p;
    }
    function sd(c) {
      return Lr = "useState", eu(
        hi,
        // useReducer has a special case to support lazy useState initializers
        c
      );
    }
    function eu(c, p, k) {
      if (c !== hi && (Lr = "useReducer"), Pr = sa(), $t = Rr(), ia) {
        var D = $t.queue, V = D.dispatch;
        if (lr !== null) {
          var ae = lr.get(D);
          if (ae !== void 0) {
            lr.delete(D);
            var pe = $t.memoizedState, Re = ae;
            do {
              var l = Re.action;
              zn = !0, pe = c(pe, l), zn = !1, Re = Re.next;
            } while (Re !== null);
            return $t.memoizedState = pe, [pe, V];
          }
        }
        return [$t.memoizedState, V];
      } else {
        zn = !0;
        var h;
        c === hi ? h = typeof p == "function" ? p() : p : h = k !== void 0 ? k(p) : p, zn = !1, $t.memoizedState = h;
        var S = $t.queue = {
          last: null,
          dispatch: null
        }, A = S.dispatch = nu.bind(null, Pr, S);
        return [$t.memoizedState, A];
      }
    }
    function Lo(c, p) {
      Pr = sa(), $t = Rr();
      var k = p === void 0 ? null : p;
      if ($t !== null) {
        var D = $t.memoizedState;
        if (D !== null && k !== null) {
          var V = D[1];
          if (Sr(k, V))
            return D[0];
        }
      }
      zn = !0;
      var ae = c();
      return zn = !1, $t.memoizedState = [ae, k], ae;
    }
    function ud(c) {
      Pr = sa(), $t = Rr();
      var p = $t.memoizedState;
      if (p === null) {
        var k = {
          current: c
        };
        return Object.seal(k), $t.memoizedState = k, k;
      } else
        return p;
    }
    function tu(c, p) {
      Lr = "useLayoutEffect", r("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function nu(c, p, k) {
      if (la >= Ao)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (c === Pr) {
        oa = !0;
        var D = {
          action: k,
          next: null
        };
        lr === null && (lr = /* @__PURE__ */ new Map());
        var V = lr.get(p);
        if (V === void 0)
          lr.set(p, D);
        else {
          for (var ae = V; ae.next !== null; )
            ae = ae.next;
          ae.next = D;
        }
      }
    }
    function cd(c, p) {
      return Lo(function() {
        return c;
      }, p);
    }
    function dd(c, p, k) {
      return sa(), p(c._source);
    }
    function fd(c, p, k) {
      if (k === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return k();
    }
    function hd(c) {
      return sa(), c;
    }
    function pd() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function md() {
      return sa(), [!1, pd];
    }
    function gd() {
      var c = $l, p = ed(c.treeContext), k = Il;
      if (k === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var D = Jt++;
      return Tn(k, p, D);
    }
    function Ro() {
    }
    var ru = {
      readContext: ld,
      useContext: Js,
      useMemo: Lo,
      useReducer: eu,
      useRef: ud,
      useState: sd,
      useInsertionEffect: Ro,
      useLayoutEffect: tu,
      useCallback: cd,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: Ro,
      // Effects are not run in the server environment.
      useEffect: Ro,
      // Debugging effect
      useDebugValue: Ro,
      useDeferredValue: hd,
      useTransition: md,
      useId: gd,
      // Subscriptions are not setup in a server environment.
      useMutableSource: dd,
      useSyncExternalStore: fd
    }, Il = null;
    function pi(c) {
      Il = c;
    }
    function au(c) {
      try {
        var p = "", k = c;
        do {
          switch (k.tag) {
            case 0:
              p += ai(k.type, null, null);
              break;
            case 1:
              p += Vs(k.type, null, null);
              break;
            case 2:
              p += uo(k.type, null, null);
              break;
          }
          k = k.parent;
        } while (k);
        return p;
      } catch (D) {
        return `
Error generating stack: ` + D.message + `
` + D.stack;
      }
    }
    var mi = n.ReactCurrentDispatcher, Do = n.ReactDebugCurrentFrame, Hl = 0, Br = 1, Oo = 2, Mo = 3, ca = 4, iu = 0, Wl = 1, da = 2, yd = 12800;
    function ou(c) {
      return console.error(c), null;
    }
    function Er() {
    }
    function vd(c, p, k, D, V, ae, pe, Re, l) {
      var h = [], S = /* @__PURE__ */ new Set(), A = {
        destination: null,
        responseState: p,
        progressiveChunkSize: D === void 0 ? yd : D,
        status: iu,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: S,
        pingedTasks: h,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: V === void 0 ? ou : V,
        onAllReady: ae === void 0 ? Er : ae,
        onShellReady: pe === void 0 ? Er : pe,
        onShellError: Re === void 0 ? Er : Re,
        onFatalError: l === void 0 ? Er : l
      }, z = _o(
        A,
        0,
        null,
        k,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      z.parentFlushed = !0;
      var Q = Vl(A, c, null, z, S, na, Us, Jc);
      return h.push(Q), A;
    }
    function xd(c, p) {
      var k = c.pingedTasks;
      k.push(p), k.length === 1 && f(function() {
        return Si(c);
      });
    }
    function gi(c, p) {
      return {
        id: Rn,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: p,
        errorDigest: null
      };
    }
    function Vl(c, p, k, D, V, ae, pe, Re) {
      c.allPendingTasks++, k === null ? c.pendingRootTasks++ : k.pendingTasks++;
      var l = {
        node: p,
        ping: function() {
          return xd(c, l);
        },
        blockedBoundary: k,
        blockedSegment: D,
        abortSet: V,
        legacyContext: ae,
        context: pe,
        treeContext: Re
      };
      return l.componentStack = null, V.add(l), l;
    }
    function _o(c, p, k, D, V, ae) {
      return {
        status: Hl,
        id: -1,
        // lazily assigned later
        index: p,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: D,
        boundary: k,
        lastPushedText: V,
        textEmbedded: ae
      };
    }
    var Dr = null;
    function yi() {
      return Dr === null || Dr.componentStack === null ? "" : au(Dr.componentStack);
    }
    function Ir(c, p) {
      c.componentStack = {
        tag: 0,
        parent: c.componentStack,
        type: p
      };
    }
    function kr(c, p) {
      c.componentStack = {
        tag: 1,
        parent: c.componentStack,
        type: p
      };
    }
    function jl(c, p) {
      c.componentStack = {
        tag: 2,
        parent: c.componentStack,
        type: p
      };
    }
    function sr(c) {
      c.componentStack === null ? r("Unexpectedly popped too many stack frames. This is a bug in React.") : c.componentStack = c.componentStack.parent;
    }
    var Ma = null;
    function Ul(c, p) {
      {
        var k;
        typeof p == "string" ? k = p : p && typeof p.message == "string" ? k = p.message : k = String(p);
        var D = Ma || yi();
        Ma = null, c.errorMessage = k, c.errorComponentStack = D;
      }
    }
    function ur(c, p) {
      var k = c.onError(p);
      if (k != null && typeof k != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof k + '" instead');
      return k;
    }
    function Hr(c, p) {
      var k = c.onShellError;
      k(p);
      var D = c.onFatalError;
      D(p), c.destination !== null ? (c.status = da, N(c.destination, p)) : (c.status = Wl, c.fatalError = p);
    }
    function Kl(c, p, k) {
      Ir(p, "Suspense");
      var D = p.blockedBoundary, V = p.blockedSegment, ae = k.fallback, pe = k.children, Re = /* @__PURE__ */ new Set(), l = gi(c, Re), h = V.chunks.length, S = _o(
        c,
        h,
        l,
        V.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      V.children.push(S), V.lastPushedText = !1;
      var A = _o(
        c,
        0,
        null,
        V.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      A.parentFlushed = !0, p.blockedBoundary = l, p.blockedSegment = A;
      try {
        if (ts(c, p, pe), Xn(A.chunks, c.responseState, A.lastPushedText, A.textEmbedded), A.status = Br, zo(l, A), l.pendingTasks === 0) {
          sr(p);
          return;
        }
      } catch (Q) {
        A.status = ca, l.forceClientRender = !0, l.errorDigest = ur(c, Q), Ul(l, Q);
      } finally {
        p.blockedBoundary = D, p.blockedSegment = V;
      }
      var z = Vl(c, ae, D, S, Re, p.legacyContext, p.context, p.treeContext);
      z.componentStack = p.componentStack, c.pingedTasks.push(z), sr(p);
    }
    function vi(c, p, k, D) {
      Ir(p, k);
      var V = p.blockedSegment, ae = Xa(V.chunks, k, D, c.responseState, V.formatContext);
      V.lastPushedText = !1;
      var pe = V.formatContext;
      V.formatContext = gn(pe, k, D), ts(c, p, ae), V.formatContext = pe, Ki(V.chunks, k), V.lastPushedText = !1, sr(p);
    }
    function No(c) {
      return c.prototype && c.prototype.isReactComponent;
    }
    function lu(c, p, k, D, V) {
      var ae = {};
      od(p, ae);
      var pe = k(D, V);
      return Qs(k, D, pe, V);
    }
    function su(c, p, k, D, V) {
      var ae = k.render();
      k.props !== V && (bi || r("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Sn(D) || "a component"), bi = !0);
      {
        var pe = D.childContextTypes;
        if (pe != null) {
          var Re = p.legacyContext, l = Ol(k, D, Re, pe);
          p.legacyContext = l, nr(c, p, ae), p.legacyContext = Re;
          return;
        }
      }
      nr(c, p, ae);
    }
    function bd(c, p, k, D) {
      jl(p, k);
      var V = Dl(k, p.legacyContext), ae = qs(k, D, V);
      Zs(ae, k, D, V), su(c, p, ae, k, D), sr(p);
    }
    var Yl = {}, xi = {}, uu = {}, Xl = {}, bi = !1, ql = !1, Gl = !1, Zl = !1;
    function cu(c, p, k, D) {
      var V;
      if (V = Dl(k, p.legacyContext), kr(p, k), k.prototype && typeof k.prototype.render == "function") {
        var ae = Sn(k) || "Unknown";
        Yl[ae] || (r("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", ae, ae), Yl[ae] = !0);
      }
      var pe = lu(c, p, k, D, V), Re = Po();
      if (typeof pe == "object" && pe !== null && typeof pe.render == "function" && pe.$$typeof === void 0) {
        var l = Sn(k) || "Unknown";
        xi[l] || (r("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", l, l, l), xi[l] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof pe == "object" && pe !== null && typeof pe.render == "function" && pe.$$typeof === void 0
      ) {
        {
          var h = Sn(k) || "Unknown";
          xi[h] || (r("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", h, h, h), xi[h] = !0);
        }
        Zs(pe, k, D, V), su(c, p, pe, k, D);
      } else if (du(k), Re) {
        var S = p.treeContext, A = 1, z = 0;
        p.treeContext = ko(S, A, z);
        try {
          nr(c, p, pe);
        } finally {
          p.treeContext = S;
        }
      } else
        nr(c, p, pe);
      sr(p);
    }
    function du(c) {
      {
        if (c && c.childContextTypes && r("%s(...): childContextTypes cannot be defined on a function component.", c.displayName || c.name || "Component"), typeof c.getDerivedStateFromProps == "function") {
          var p = Sn(c) || "Unknown";
          Xl[p] || (r("%s: Function components do not support getDerivedStateFromProps.", p), Xl[p] = !0);
        }
        if (typeof c.contextType == "object" && c.contextType !== null) {
          var k = Sn(c) || "Unknown";
          uu[k] || (r("%s: Function components do not support contextType.", k), uu[k] = !0);
        }
      }
    }
    function Ql(c, p) {
      if (c && c.defaultProps) {
        var k = or({}, p), D = c.defaultProps;
        for (var V in D)
          k[V] === void 0 && (k[V] = D[V]);
        return k;
      }
      return p;
    }
    function Sd(c, p, k, D, V) {
      kr(p, k.render);
      var ae = lu(c, p, k.render, D, V), pe = Po();
      if (pe) {
        var Re = p.treeContext, l = 1, h = 0;
        p.treeContext = ko(Re, l, h);
        try {
          nr(c, p, ae);
        } finally {
          p.treeContext = Re;
        }
      } else
        nr(c, p, ae);
      sr(p);
    }
    function Ed(c, p, k, D, V) {
      var ae = k.type, pe = Ql(ae, D);
      Jl(c, p, ae, pe, V);
    }
    function fu(c, p, k, D) {
      k._context === void 0 ? k !== k.Consumer && (Zl || (Zl = !0, r("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : k = k._context;
      var V = D.children;
      typeof V != "function" && r("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var ae = ci(k), pe = V(ae);
      nr(c, p, pe);
    }
    function kd(c, p, k, D) {
      var V = k._context, ae = D.value, pe = D.children, Re;
      Re = p.context, p.context = Ks(V, ae), nr(c, p, pe), p.context = Ys(V), Re !== p.context && r("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function wd(c, p, k, D, V) {
      Ir(p, "Lazy");
      var ae = k._payload, pe = k._init, Re = pe(ae), l = Ql(Re, D);
      Jl(c, p, Re, l, V), sr(p);
    }
    function Jl(c, p, k, D, V) {
      if (typeof k == "function")
        if (No(k)) {
          bd(c, p, k, D);
          return;
        } else {
          cu(c, p, k, D);
          return;
        }
      if (typeof k == "string") {
        vi(c, p, k, D);
        return;
      }
      switch (k) {
        case lo:
        case xl:
        case zs:
        case yl:
        case tr: {
          nr(c, p, D.children);
          return;
        }
        case ti: {
          Ir(p, "SuspenseList"), nr(c, p, D.children), sr(p);
          return;
        }
        case vl:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case ei: {
          Kl(c, p, D);
          return;
        }
      }
      if (typeof k == "object" && k !== null)
        switch (k.$$typeof) {
          case oo: {
            Sd(c, p, k, D, V);
            return;
          }
          case ni: {
            Ed(c, p, k, D, V);
            return;
          }
          case ao: {
            kd(c, p, k, D);
            return;
          }
          case io: {
            fu(c, p, k, D);
            return;
          }
          case Ca: {
            wd(c, p, k, D);
            return;
          }
        }
      var ae = "";
      throw (k === void 0 || typeof k == "object" && k !== null && Object.keys(k).length === 0) && (ae += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (k == null ? k : typeof k) + "." + ae));
    }
    function Td(c, p) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      c[Symbol.toStringTag] === "Generator" && (ql || r("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), ql = !0), c.entries === p && (Gl || r("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Gl = !0);
    }
    function nr(c, p, k) {
      try {
        return es(c, p, k);
      } catch (D) {
        throw typeof D == "object" && D !== null && typeof D.then == "function" || (Ma = Ma !== null ? Ma : yi()), D;
      }
    }
    function es(c, p, k) {
      if (p.node = k, typeof k == "object" && k !== null) {
        switch (k.$$typeof) {
          case Kc: {
            var D = k, V = D.type, ae = D.props, pe = D.ref;
            Jl(c, p, V, ae, pe);
            return;
          }
          case Fs:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Ca: {
            var Re = k, l = Re._payload, h = Re._init, S;
            try {
              S = h(l);
            } catch (st) {
              throw typeof st == "object" && st !== null && typeof st.then == "function" && Ir(p, "Lazy"), st;
            }
            nr(c, p, S);
            return;
          }
        }
        if (K(k)) {
          hu(c, p, k);
          return;
        }
        var A = qc(k);
        if (A) {
          Td(k, A);
          var z = A.call(k);
          if (z) {
            var Q = z.next();
            if (!Q.done) {
              var fe = [];
              do
                fe.push(Q.value), Q = z.next();
              while (!Q.done);
              hu(c, p, fe);
              return;
            }
            return;
          }
        }
        var Ae = Object.prototype.toString.call(k);
        throw new Error("Objects are not valid as a React child (found: " + (Ae === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : Ae) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof k == "string") {
        var Ie = p.blockedSegment;
        Ie.lastPushedText = Zn(p.blockedSegment.chunks, k, c.responseState, Ie.lastPushedText);
        return;
      }
      if (typeof k == "number") {
        var tt = p.blockedSegment;
        tt.lastPushedText = Zn(p.blockedSegment.chunks, "" + k, c.responseState, tt.lastPushedText);
        return;
      }
      typeof k == "function" && r("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function hu(c, p, k) {
      for (var D = k.length, V = 0; V < D; V++) {
        var ae = p.treeContext;
        p.treeContext = ko(ae, D, V);
        try {
          ts(c, p, k[V]);
        } finally {
          p.treeContext = ae;
        }
      }
    }
    function rr(c, p, k) {
      var D = p.blockedSegment, V = D.chunks.length, ae = _o(
        c,
        V,
        null,
        D.formatContext,
        // Adopt the parent segment's leading text embed
        D.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      D.children.push(ae), D.lastPushedText = !1;
      var pe = Vl(c, p.node, p.blockedBoundary, ae, p.abortSet, p.legacyContext, p.context, p.treeContext);
      p.componentStack !== null && (pe.componentStack = p.componentStack.parent);
      var Re = pe.ping;
      k.then(Re, Re);
    }
    function ts(c, p, k) {
      var D = p.blockedSegment.formatContext, V = p.legacyContext, ae = p.context, pe = null;
      pe = p.componentStack;
      try {
        return nr(c, p, k);
      } catch (Re) {
        if (Bl(), typeof Re == "object" && Re !== null && typeof Re.then == "function") {
          rr(c, p, Re), p.blockedSegment.formatContext = D, p.legacyContext = V, p.context = ae, ui(ae), p.componentStack = pe;
          return;
        } else
          throw p.blockedSegment.formatContext = D, p.legacyContext = V, p.context = ae, ui(ae), p.componentStack = pe, Re;
      }
    }
    function pu(c, p, k, D) {
      var V = ur(c, D);
      if (p === null ? Hr(c, D) : (p.pendingTasks--, p.forceClientRender || (p.forceClientRender = !0, p.errorDigest = V, Ul(p, D), p.parentFlushed && c.clientRenderedBoundaries.push(p))), c.allPendingTasks--, c.allPendingTasks === 0) {
        var ae = c.onAllReady;
        ae();
      }
    }
    function Cd(c) {
      var p = this, k = c.blockedBoundary, D = c.blockedSegment;
      D.status = Mo, mu(p, k, D);
    }
    function Fo(c, p, k) {
      var D = c.blockedBoundary, V = c.blockedSegment;
      if (V.status = Mo, D === null)
        p.allPendingTasks--, p.status !== da && (p.status = da, p.destination !== null && E(p.destination));
      else {
        if (D.pendingTasks--, !D.forceClientRender) {
          D.forceClientRender = !0;
          var ae = k === void 0 ? new Error("The render was aborted by the server without a reason.") : k;
          D.errorDigest = p.onError(ae);
          {
            var pe = "The server did not finish this Suspense boundary: ";
            ae && typeof ae.message == "string" ? ae = pe + ae.message : ae = pe + String(ae);
            var Re = Dr;
            Dr = c;
            try {
              Ul(D, ae);
            } finally {
              Dr = Re;
            }
          }
          D.parentFlushed && p.clientRenderedBoundaries.push(D);
        }
        if (D.fallbackAbortableTasks.forEach(function(h) {
          return Fo(h, p, k);
        }), D.fallbackAbortableTasks.clear(), p.allPendingTasks--, p.allPendingTasks === 0) {
          var l = p.onAllReady;
          l();
        }
      }
    }
    function zo(c, p) {
      if (p.chunks.length === 0 && p.children.length === 1 && p.children[0].boundary === null) {
        var k = p.children[0];
        k.id = p.id, k.parentFlushed = !0, k.status === Br && zo(c, k);
      } else {
        var D = c.completedSegments;
        D.push(p);
      }
    }
    function mu(c, p, k) {
      if (p === null) {
        if (k.parentFlushed) {
          if (c.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          c.completedRootSegment = k;
        }
        if (c.pendingRootTasks--, c.pendingRootTasks === 0) {
          c.onShellError = Er;
          var D = c.onShellReady;
          D();
        }
      } else if (p.pendingTasks--, !p.forceClientRender) {
        if (p.pendingTasks === 0)
          k.parentFlushed && k.status === Br && zo(p, k), p.parentFlushed && c.completedBoundaries.push(p), p.fallbackAbortableTasks.forEach(Cd, c), p.fallbackAbortableTasks.clear();
        else if (k.parentFlushed && k.status === Br) {
          zo(p, k);
          var V = p.completedSegments;
          V.length === 1 && p.parentFlushed && c.partialBoundaries.push(p);
        }
      }
      if (c.allPendingTasks--, c.allPendingTasks === 0) {
        var ae = c.onAllReady;
        ae();
      }
    }
    function gu(c, p) {
      var k = p.blockedSegment;
      if (k.status === Hl) {
        ui(p.context);
        var D = null;
        D = Dr, Dr = p;
        try {
          nr(c, p, p.node), Xn(k.chunks, c.responseState, k.lastPushedText, k.textEmbedded), p.abortSet.delete(p), k.status = Br, mu(c, p.blockedBoundary, k);
        } catch (ae) {
          if (Bl(), typeof ae == "object" && ae !== null && typeof ae.then == "function") {
            var V = p.ping;
            ae.then(V, V);
          } else
            p.abortSet.delete(p), k.status = ca, pu(c, p.blockedBoundary, k, ae);
        } finally {
          Dr = D;
        }
      }
    }
    function Si(c) {
      if (c.status !== da) {
        var p = po(), k = mi.current;
        mi.current = ru;
        var D;
        D = Do.getCurrentStack, Do.getCurrentStack = yi;
        var V = Il;
        pi(c.responseState);
        try {
          var ae = c.pingedTasks, pe;
          for (pe = 0; pe < ae.length; pe++) {
            var Re = ae[pe];
            gu(c, Re);
          }
          ae.splice(0, pe), c.destination !== null && Bo(c, c.destination);
        } catch (l) {
          ur(c, l), Hr(c, l);
        } finally {
          pi(V), mi.current = k, Do.getCurrentStack = D, k === ru && ui(p);
        }
      }
    }
    function Ei(c, p, k) {
      switch (k.parentFlushed = !0, k.status) {
        case Hl: {
          var D = k.id = c.nextSegmentId++;
          return k.lastPushedText = !1, k.textEmbedded = !1, ya(p, c.responseState, D);
        }
        case Br: {
          k.status = Oo;
          for (var V = !0, ae = k.chunks, pe = 0, Re = k.children, l = 0; l < Re.length; l++) {
            for (var h = Re[l]; pe < h.index; pe++)
              y(p, ae[pe]);
            V = $o(c, p, h);
          }
          for (; pe < ae.length - 1; pe++)
            y(p, ae[pe]);
          return pe < ae.length && (V = v(p, ae[pe])), V;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function $o(c, p, k) {
      var D = k.boundary;
      if (D === null)
        return Ei(c, p, k);
      if (D.parentFlushed = !0, D.forceClientRender)
        return jn(p, c.responseState, D.errorDigest, D.errorMessage, D.errorComponentStack), Ei(c, p, k), fl(p, c.responseState);
      if (D.pendingTasks > 0) {
        D.rootSegmentID = c.nextSegmentId++, D.completedSegments.length > 0 && c.partialBoundaries.push(D);
        var V = D.id = cn(c.responseState);
        return ba(p, c.responseState, V), Ei(c, p, k), Sa(p, c.responseState);
      } else {
        if (D.byteSize > c.progressiveChunkSize)
          return D.rootSegmentID = c.nextSegmentId++, c.completedBoundaries.push(D), ba(p, c.responseState, D.id), Ei(c, p, k), Sa(p, c.responseState);
        Xi(p, c.responseState);
        var ae = D.completedSegments;
        if (ae.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var pe = ae[0];
        return $o(c, p, pe), qi(p, c.responseState);
      }
    }
    function yu(c, p, k) {
      return _s(p, c.responseState, k.id, k.errorDigest, k.errorMessage, k.errorComponentStack);
    }
    function ki(c, p, k) {
      return Rt(p, c.responseState, k.formatContext, k.id), $o(c, p, k), rn(p, k.formatContext);
    }
    function wi(c, p, k) {
      for (var D = k.completedSegments, V = 0; V < D.length; V++) {
        var ae = D[V];
        ns(c, p, k, ae);
      }
      return D.length = 0, hl(p, c.responseState, k.id, k.rootSegmentID);
    }
    function Ad(c, p, k) {
      for (var D = k.completedSegments, V = 0; V < D.length; V++) {
        var ae = D[V];
        if (!ns(c, p, k, ae))
          return V++, D.splice(0, V), !1;
      }
      return D.splice(0, V), !0;
    }
    function ns(c, p, k, D) {
      if (D.status === Oo)
        return !0;
      var V = D.id;
      if (V === -1) {
        var ae = D.id = k.rootSegmentID;
        if (ae === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return ki(c, p, D);
      } else
        return ki(c, p, D), $c(p, c.responseState, V);
    }
    function Bo(c, p) {
      m();
      try {
        var k = c.completedRootSegment;
        k !== null && c.pendingRootTasks === 0 && ($o(c, p, k), c.completedRootSegment = null, ul(p, c.responseState));
        var D = c.clientRenderedBoundaries, V;
        for (V = 0; V < D.length; V++) {
          var ae = D[V];
          yu(c, p, ae);
        }
        D.splice(0, V);
        var pe = c.completedBoundaries;
        for (V = 0; V < pe.length; V++) {
          var Re = pe[V];
          wi(c, p, Re);
        }
        pe.splice(0, V), w(p), m(p);
        var l = c.partialBoundaries;
        for (V = 0; V < l.length; V++) {
          var h = l[V];
          if (!Ad(c, p, h)) {
            c.destination = null, V++, l.splice(0, V);
            return;
          }
        }
        l.splice(0, V);
        var S = c.completedBoundaries;
        for (V = 0; V < S.length; V++) {
          var A = S[V];
          wi(c, p, A);
        }
        S.splice(0, V);
      } finally {
        w(p), c.allPendingTasks === 0 && c.pingedTasks.length === 0 && c.clientRenderedBoundaries.length === 0 && c.completedBoundaries.length === 0 && (c.abortableTasks.size !== 0 && r("There was still abortable task at the root when we closed. This is a bug in React."), E(p));
      }
    }
    function Pd(c) {
      f(function() {
        return Si(c);
      });
    }
    function vu(c, p) {
      if (c.status === Wl) {
        c.status = da, N(p, c.fatalError);
        return;
      }
      if (c.status !== da && c.destination === null) {
        c.destination = p;
        try {
          Bo(c, p);
        } catch (k) {
          ur(c, k), Hr(c, k);
        }
      }
    }
    function Io(c, p) {
      try {
        var k = c.abortableTasks;
        k.forEach(function(D) {
          return Fo(D, c, p);
        }), k.clear(), c.destination !== null && Bo(c, c.destination);
      } catch (D) {
        ur(c, D), Hr(c, D);
      }
    }
    function Ld(c, p) {
      return new Promise(function(k, D) {
        var V, ae, pe = new Promise(function(z, Q) {
          ae = z, V = Q;
        });
        function Re() {
          var z = new ReadableStream(
            {
              type: "bytes",
              pull: function(Q) {
                vu(h, Q);
              },
              cancel: function(Q) {
                Io(h);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          z.allReady = pe, k(z);
        }
        function l(z) {
          pe.catch(function() {
          }), D(z);
        }
        var h = vd(c, pt(p ? p.identifierPrefix : void 0, p ? p.nonce : void 0, p ? p.bootstrapScriptContent : void 0, p ? p.bootstrapScripts : void 0, p ? p.bootstrapModules : void 0), un(p ? p.namespaceURI : void 0), p ? p.progressiveChunkSize : void 0, p ? p.onError : void 0, ae, Re, l, V);
        if (p && p.signal) {
          var S = p.signal, A = function() {
            Io(h, S.reason), S.removeEventListener("abort", A);
          };
          S.addEventListener("abort", A);
        }
        Pd(h);
      });
    }
    Nu.renderToReadableStream = Ld, Nu.version = t;
  }()), Nu;
}
var Hi, Df;
process.env.NODE_ENV === "production" ? (Hi = PE(), Df = LE()) : (Hi = RE(), Df = DE());
ja.version = Hi.version;
ja.renderToString = Hi.renderToString;
ja.renderToStaticMarkup = Hi.renderToStaticMarkup;
ja.renderToNodeStream = Hi.renderToNodeStream;
ja.renderToStaticNodeStream = Hi.renderToStaticNodeStream;
ja.renderToReadableStream = Df.renderToReadableStream;
const OE = ({ width: e, height: t, runtime: n }) => {
  var Le, de;
  const { config: a } = ce.useContext(Pt), { sankey: r } = a, o = a == null ? void 0 : a.data[0], [f, u] = ce.useState(0), s = ce.useRef([]), [d, m] = ce.useState(""), y = (ie) => {
    m(ie);
  }, v = () => {
    m("");
  }, [w, E] = ce.useState(!1);
  ce.useEffect(() => {
    window.innerWidth < 768 && window.innerHeight > window.innerWidth && E(!0);
  }, [window.innerWidth]);
  const O = () => {
    E(!1);
  };
  ce.useEffect(() => {
    var Ce;
    let ie = 0;
    (Ce = s == null ? void 0 : s.current) == null || Ce.map((He) => {
      const we = He == null ? void 0 : He.getBoundingClientRect().width;
      we > ie && (ie = we);
    }), u(ie);
  }, [s, r, window.innerWidth]);
  const T = Array.from(new Set((Le = o == null ? void 0 : o.links) == null ? void 0 : Le.flatMap((ie) => [ie.source, ie.target]))), g = {
    nodes: T.map((ie) => ({ id: ie })),
    links: (de = o == null ? void 0 : o.links) == null ? void 0 : de.map((ie) => ({
      source: T.findIndex((Ce) => Ce === ie.source),
      target: T.findIndex((Ce) => Ce === ie.target),
      value: ie.value
    }))
  };
  let N = 5;
  const L = 50, M = wE().nodeWidth(r.nodeSize.nodeWidth).nodePadding(r.nodePadding).iterations(r.iterations).nodeAlign(xE).extent([
    [r.margin.margin_x, Number(r.margin.margin_y)],
    [e - N - f, a.heights.vertical - L]
  ]), { nodes: _, links: C } = M(g), H = (ie) => {
    var ke;
    let Ce = 30, He = 0, we = "node-value--storynode", ge = !0;
    return (ke = o == null ? void 0 : o.storyNodeText) != null && ke.every((ne) => ne.StoryNode !== ie) && (ge = !1, He = 10, Ce = 8, we = "node-value"), { textPositionHorizontal: Ce, textPositionVertical: He, classStyle: we, storyNodes: ge };
  }, I = (ie) => {
    const Ce = g.nodes.find((ge) => ge.id === ie), He = [], we = [];
    return Ce && (C.forEach((ge) => {
      const ke = ge.target, ne = ge.source;
      ke.id === ie && He.push(ne.id);
    }), He.forEach((ge) => {
      C.forEach((ke) => {
        const ne = ke.target, Pe = ke.source;
        ne.id === d && Pe.id === ge && we.push(ke);
      });
    })), { sourceNodes: He, activeLinks: we };
  }, X = `${((o == null ? void 0 : o.tooltips.find((ie) => ie.node === d)) || {}).value}`, te = `${((o == null ? void 0 : o.tooltips.find((ie) => ie.node === d)) || {}).summary}`, G = ((o == null ? void 0 : o.tooltips.find((ie) => ie.node === d)) || {}).column1Label, F = ((o == null ? void 0 : o.tooltips.find((ie) => ie.node === d)) || {}).column2Label, j = ((o == null ? void 0 : o.tooltips.find((ie) => ie.node === d)) || {}).column1, U = ((o == null ? void 0 : o.tooltips.find((ie) => ie.node === d)) || {}).column2, W = ({ columnData: ie }) => /* @__PURE__ */ i.createElement("ul", null, ie == null ? void 0 : ie.map((Ce, He) => /* @__PURE__ */ i.createElement("li", { key: He }, Ce.label, ": ", Ce.value, " (", Ce.additional_info, "%)"))), re = ja.renderToString(/* @__PURE__ */ i.createElement(W, { columnData: j })), J = ja.renderToString(/* @__PURE__ */ i.createElement(W, { columnData: U })), ue = `<div class="sankey-chart__tooltip">
                    <span class="sankey-chart__tooltip--tooltip-header">${d}</span>
                    <span class="sankey-chart__tooltip--tooltip-header">${X}</span>
                    <div class="divider"></div>
                    <span><strong>Summary: </strong>${te}</span>
                    <div class="divider"></div>
                      <div class="sankey-chart__tooltip--info-section">
                        <div>
                          <span><strong>${G}<strong></span>
                          ${re}
                        </div>
                        <div>
                          <span><strong>${F}<strong></span>
                          ${J}
                        </div>
                      </div>
                    </div>`, ee = g.nodes.map((ie, Ce) => {
    var qe, Ge;
    let { textPositionHorizontal: He, textPositionVertical: we, classStyle: ge, storyNodes: ke } = H(ie.id), { sourceNodes: ne } = I(d), Pe = r.opacity.nodeOpacityDefault, $e = r.nodeColor.default;
    return d !== ie.id && d !== "" && !ne.includes(ie.id) && ($e = r.nodeColor.inactive, Pe = r.opacity.nodeOpacityInactive), /* @__PURE__ */ i.createElement(at, { className: "", key: Ce }, /* @__PURE__ */ i.createElement(
      "rect",
      {
        height: ie.y1 - ie.y0 + 2,
        width: M.nodeWidth(),
        x: ie.x0,
        y: ie.y0 - 1,
        fill: $e,
        fillOpacity: Pe,
        rx: r.rxValue,
        "data-tooltip-html": o.tooltips && a.enableTooltips ? ue : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
        onClick: () => y(ie.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), ke ? /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
      Tt,
      {
        x: ie.x0 + He,
        textAnchor: g.nodes.length - 1 === Ce ? "end" : "start",
        verticalAnchor: "end",
        y: (ie.y1 + ie.y0) / 2 - 30,
        fill: r.nodeFontColor,
        fontWeight: "bold",
        style: { pointerEvents: "none" },
        className: "node-text"
      },
      (((qe = o == null ? void 0 : o.storyNodeText) == null ? void 0 : qe.find((Xe) => Xe.StoryNode === ie.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ i.createElement(Tt, { verticalAnchor: "end", className: ge, x: ie.x0 + He, y: (ie.y1 + ie.y0 + 25) / 2, fill: r.storyNodeFontColor || r.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, typeof ie.value == "number" ? ie.value.toLocaleString() : ie.value), /* @__PURE__ */ i.createElement(
      Tt,
      {
        x: ie.x0 + He,
        y: (ie.y1 + ie.y0) / 2 + 50,
        fill: r.nodeFontColor,
        fontWeight: "bold",
        textAnchor: g.nodes.length === Ce ? "end" : "start",
        style: { pointerEvents: "none" },
        className: "node-text",
        verticalAnchor: "end"
      },
      (((Ge = o == null ? void 0 : o.storyNodeText) == null ? void 0 : Ge.find((Xe) => Xe.StoryNode === ie.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("text", { x: ie.x0 + He, y: (ie.y1 + ie.y0) / 2 + we, dominantBaseline: "text-before-edge", fill: r.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, /* @__PURE__ */ i.createElement("tspan", { id: ie.id, className: "node-id" }, ie.id)), /* @__PURE__ */ i.createElement(
      "text",
      {
        x: ie.x0 + He,
        y: (ie.y1 + ie.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: r.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ i.createElement("tspan", { className: ge }, r.nodeValueStyle.textBefore + (typeof ie.value == "number" ? ie.value.toLocaleString() : ie.value) + r.nodeValueStyle.textAfter)
    )));
  }), Z = C.map((ie, Ce) => {
    const we = AE()(ie);
    let ge = r.opacity.LinkOpacityDefault, ke = r.linkColor.default, { activeLinks: ne } = I(d);
    return !ne.includes(ie) && d !== "" && (ke = r.linkColor.inactive, ge = r.opacity.LinkOpacityInactive), /* @__PURE__ */ i.createElement("path", { key: Ce, d: we, stroke: ke, fill: "none", strokeOpacity: ge, strokeWidth: ie.width + 2 });
  }), se = g.nodes.reduce((ie, Ce) => Math.max(ie, Ce.depth), -1), me = g.nodes.filter((ie) => ie.depth === se).map((ie, Ce) => {
    var qe, Ge;
    let { textPositionHorizontal: He, textPositionVertical: we, classStyle: ge, storyNodes: ke } = H(ie.id), { sourceNodes: ne } = I(d), Pe = r.opacity.nodeOpacityDefault, $e = r.nodeColor.default;
    return d !== ie.id && d !== "" && !ne.includes(ie.id) && ($e = r.nodeColor.inactive, Pe = r.opacity.nodeOpacityInactive), /* @__PURE__ */ i.createElement(at, { className: "", key: Ce, innerRef: (Xe) => s.current[Ce] = Xe }, /* @__PURE__ */ i.createElement(
      "rect",
      {
        height: ie.y1 - ie.y0 + 2,
        width: M.nodeWidth(),
        x: ie.x0,
        y: ie.y0 - 1,
        fill: $e,
        fillOpacity: Pe,
        rx: r.rxValue,
        "data-tooltip-html": o.tooltips && a.enableTooltips ? ue : null,
        "data-tooltip-id": "tooltip",
        onClick: () => y(ie.id),
        style: { pointerEvents: "visible", cursor: "pointer" }
      }
    ), ke ? /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
      Tt,
      {
        x: ie.x0 + He,
        textAnchor: g.nodes.length - 1 === Ce ? "end" : "start",
        verticalAnchor: "end",
        y: (ie.y1 + ie.y0) / 2 - 30,
        fill: r.nodeFontColor,
        fontWeight: "bold",
        style: { pointerEvents: "none" },
        className: "node-text"
      },
      (((qe = o == null ? void 0 : o.storyNodeText) == null ? void 0 : qe.find((Xe) => Xe.StoryNode === ie.id)) || {}).segmentTextBefore
    ), /* @__PURE__ */ i.createElement(Tt, { verticalAnchor: "end", className: ge, x: ie.x0 + He, y: (ie.y1 + ie.y0 + 25) / 2, fill: r.storyNodeFontColor || r.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, typeof ie.value == "number" ? ie.value.toLocaleString() : ie.value), /* @__PURE__ */ i.createElement(
      Tt,
      {
        x: ie.x0 + He,
        y: (ie.y1 + ie.y0) / 2 + 50,
        fill: r.nodeFontColor,
        fontWeight: "bold",
        textAnchor: g.nodes.length === Ce ? "end" : "start",
        style: { pointerEvents: "none" },
        className: "node-text",
        verticalAnchor: "end"
      },
      (((Ge = o == null ? void 0 : o.storyNodeText) == null ? void 0 : Ge.find((Xe) => Xe.StoryNode === ie.id)) || {}).segmentTextAfter
    )) : /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("text", { x: ie.x0 + He, y: (ie.y1 + ie.y0) / 2 + we, dominantBaseline: "text-before-edge", fill: r.nodeFontColor, fontWeight: "bold", textAnchor: "start", style: { pointerEvents: "none" } }, /* @__PURE__ */ i.createElement("tspan", { id: ie.id, className: "node-id" }, ie.id)), /* @__PURE__ */ i.createElement(
      "text",
      {
        x: ie.x0 + He,
        y: (ie.y1 + ie.y0) / 2 + 30,
        dominantBaseline: "text-before-edge",
        fill: r.nodeFontColor,
        fontWeight: "bold",
        textAnchor: "start",
        style: { pointerEvents: "none" }
      },
      /* @__PURE__ */ i.createElement("tspan", { className: ge }, r.nodeValueStyle.textBefore + (typeof ie.value == "number" ? ie.value.toLocaleString() : ie.value) + r.nodeValueStyle.textAfter)
    )));
  });
  return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("div", { className: "sankey-chart" }, /* @__PURE__ */ i.createElement("svg", { className: "sankey-chart__diagram", width: e, height: Number(a.heights.vertical), style: { overflow: "visible" } }, /* @__PURE__ */ i.createElement(at, { className: "links" }, Z), /* @__PURE__ */ i.createElement(at, { className: "nodes" }, ee), /* @__PURE__ */ i.createElement(at, { className: "finalNodes", style: { display: "none" } }, me)), /* @__PURE__ */ i.createElement(ly, { id: `cdc-open-viz-tooltip-${n.uniqueId}-sankey`, afterHide: () => v(), events: ["click"], place: "bottom", style: { backgroundColor: "rgba(238, 238, 238, 1)", color: "black", boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)" } }), w && /* @__PURE__ */ i.createElement("div", { className: "popup" }, /* @__PURE__ */ i.createElement("div", { className: "popup-content" }, /* @__PURE__ */ i.createElement("button", { className: "visually-hidden", onClick: O }, "Select for accessible version."), /* @__PURE__ */ i.createElement("p", null, /* @__PURE__ */ i.createElement("strong", null, "Please change the orientation of your screen or increase the size of your browser to view the diagram better."))))));
};
var ME = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const ir = ME;
function _E(e) {
  var t = e.labelOffset, n = e.labelProps, a = e.orientation, r = e.range, o = e.tickLabelFontSize, f = e.tickLength, u = a === ir.left || a === ir.top ? -1 : 1, s, d, m;
  if (a === ir.top || a === ir.bottom) {
    var y = a === ir.bottom && typeof n.fontSize == "number" ? n.fontSize : 0;
    s = (Number(r[0]) + Number(r[r.length - 1])) / 2, d = u * (f + t + o + y);
  } else
    s = u * ((Number(r[0]) + Number(r[r.length - 1])) / 2), d = -(f + t), m = "rotate(" + u * 90 + ")";
  return {
    x: s,
    y: d,
    transform: m
  };
}
function bs() {
  return bs = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, bs.apply(this, arguments);
}
function NE(e) {
  var t = e.hideTicks, n = e.horizontal, a = e.orientation, r = e.tickClassName, o = e.tickComponent, f = e.tickLabelProps, u = e.tickStroke, s = u === void 0 ? "#222" : u, d = e.tickTransform, m = e.ticks, y = e.strokeWidth, v = e.tickLineProps;
  return m.map(function(w) {
    var E, O = w.value, T = w.index, g = w.from, N = w.to, L = w.formattedValue, M = (E = f[T]) != null ? E : {}, _ = Math.max(10, typeof M.fontSize == "number" && M.fontSize || 0), C = N.y + (n && a !== ir.top ? _ : 0);
    return /* @__PURE__ */ i.createElement(at, {
      key: "visx-tick-" + O + "-" + T,
      className: Pn("visx-axis-tick", r),
      transform: d
    }, !t && /* @__PURE__ */ i.createElement(an, bs({
      from: g,
      to: N,
      stroke: s,
      strokeWidth: y,
      strokeLinecap: "square"
    }, v)), o ? o(bs({}, M, {
      x: N.x,
      y: C,
      formattedValue: L
    })) : /* @__PURE__ */ i.createElement(Tt, bs({
      x: N.x,
      y: C
    }, M), L));
  });
}
function gc() {
  return gc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, gc.apply(this, arguments);
}
var lm = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function FE(e) {
  var t = e.axisFromPoint, n = e.axisLineClassName, a = e.axisToPoint, r = e.hideAxisLine, o = e.hideTicks, f = e.horizontal, u = e.label, s = u === void 0 ? "" : u, d = e.labelClassName, m = e.labelOffset, y = m === void 0 ? 14 : m, v = e.labelProps, w = v === void 0 ? lm : v, E = e.orientation, O = E === void 0 ? ir.bottom : E, T = e.scale, g = e.stroke, N = g === void 0 ? "#222" : g, L = e.strokeDasharray, M = e.strokeWidth, _ = M === void 0 ? 1 : M, C = e.tickClassName, H = e.tickComponent, I = e.tickLineProps, X = e.tickLabelProps, te = e.tickLength, G = te === void 0 ? 8 : te, F = e.tickStroke, j = F === void 0 ? "#222" : F, U = e.tickTransform, W = e.ticks, re = e.ticksComponent, J = re === void 0 ? NE : re, ue = gc({}, lm, typeof X == "object" ? X : null), ee = W.map(function(se) {
    var ye = se.value, me = se.index;
    return typeof X == "function" ? X(ye, me, W) : ue;
  }), Z = Math.max.apply(Math, [10].concat(ee.map(function(se) {
    return typeof se.fontSize == "number" ? se.fontSize : 0;
  })));
  return /* @__PURE__ */ i.createElement(i.Fragment, null, J({
    hideTicks: o,
    horizontal: f,
    orientation: O,
    scale: T,
    tickClassName: C,
    tickComponent: H,
    tickLabelProps: ee,
    tickStroke: j,
    tickTransform: U,
    ticks: W,
    strokeWidth: _,
    tickLineProps: I
  }), !r && /* @__PURE__ */ i.createElement(an, {
    className: Pn("visx-axis-line", n),
    from: t,
    to: a,
    stroke: N,
    strokeWidth: _,
    strokeDasharray: L
  }), s && /* @__PURE__ */ i.createElement(Tt, gc({
    className: Pn("visx-axis-label", d)
  }, _E({
    labelOffset: y,
    labelProps: w,
    orientation: O,
    range: T.range(),
    tickLabelFontSize: Z,
    tickLength: G
  }), w), s));
}
function zE(e, t) {
  t === void 0 && (t = "center");
  var n = e;
  if (t !== "start" && "bandwidth" in n) {
    var a = n.bandwidth();
    return t === "center" && (a /= 2), n.round() && (a = Math.round(a)), function(r) {
      var o = n(r);
      return typeof o == "number" ? o + a : o;
    };
  }
  return e;
}
function $E(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : Pv;
}
function Fu(e, t) {
  var n = e.x, a = e.y;
  return new rl(t ? {
    x: n,
    y: a
  } : {
    x: a,
    y: n
  });
}
function Of() {
  return Of = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Of.apply(this, arguments);
}
var Gd = 0;
function BE(e) {
  return e === void 0 && (e = Gd), typeof e == "number" ? {
    start: e,
    end: e
  } : Of({
    start: Gd,
    end: Gd
  }, e);
}
var IE = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Mf() {
  return Mf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Mf.apply(this, arguments);
}
function HE(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function Mc(e) {
  var t = e.children, n = t === void 0 ? FE : t, a = e.axisClassName, r = e.hideAxisLine, o = r === void 0 ? !1 : r, f = e.hideTicks, u = f === void 0 ? !1 : f, s = e.hideZero, d = s === void 0 ? !1 : s, m = e.innerRef, y = e.left, v = y === void 0 ? 0 : y, w = e.numTicks, E = w === void 0 ? 10 : w, O = e.orientation, T = O === void 0 ? ir.bottom : O, g = e.rangePadding, N = g === void 0 ? 0 : g, L = e.scale, M = e.tickFormat, _ = e.tickLength, C = _ === void 0 ? 8 : _, H = e.tickValues, I = e.top, X = I === void 0 ? 0 : I, te = HE(e, IE), G = M ?? $E(L), F = T === ir.left, j = T === ir.top, U = j || T === ir.bottom, W = zE(L), re = F || j ? -1 : 1, J = L.range(), ue = BE(N), ee = Fu({
    x: Number(J[0]) + 0.5 - ue.start,
    y: 0
  }, U), Z = Fu({
    x: Number(J[J.length - 1]) + 0.5 + ue.end,
    y: 0
  }, U), se = (H ?? Av(L, E)).filter(function(me) {
    return !d || me !== 0 && me !== "0";
  }).map(function(me, Le) {
    return {
      value: me,
      index: Le
    };
  }), ye = se.map(function(me) {
    var Le = me.value, de = me.index, ie = Cv(W(Le));
    return {
      value: Le,
      index: de,
      from: Fu({
        x: ie,
        y: 0
      }, U),
      to: Fu({
        x: ie,
        y: C * re
      }, U),
      formattedValue: G(Le, de, se)
    };
  });
  return /* @__PURE__ */ i.createElement(at, {
    className: Pn("visx-axis", a),
    innerRef: m,
    top: X,
    left: v
  }, n(Mf({}, te, {
    axisFromPoint: ee,
    axisToPoint: Z,
    hideAxisLine: o,
    hideTicks: u,
    hideZero: d,
    horizontal: U,
    numTicks: E,
    orientation: T,
    rangePadding: N,
    scale: L,
    tickFormat: G,
    tickLength: C,
    tickPosition: W,
    tickSign: re,
    ticks: ye
  })));
}
var WE = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function yc() {
  return yc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, yc.apply(this, arguments);
}
function VE(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var jE = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function UE(e) {
  var t = e.axisClassName, n = e.labelOffset, a = n === void 0 ? 36 : n, r = e.tickLength, o = r === void 0 ? 8 : r, f = e.tickLabelProps, u = VE(e, WE), s = typeof f == "function" ? f : yc({}, jE, f);
  return /* @__PURE__ */ i.createElement(Mc, yc({
    axisClassName: Pn("visx-axis-left", t),
    labelOffset: a,
    orientation: ir.left,
    tickLabelProps: s,
    tickLength: o
  }, u));
}
var KE = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function vc() {
  return vc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, vc.apply(this, arguments);
}
function YE(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var XE = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function qE(e) {
  var t = e.axisClassName, n = e.labelOffset, a = n === void 0 ? 36 : n, r = e.tickLength, o = r === void 0 ? 8 : r, f = e.tickLabelProps, u = YE(e, KE), s = typeof f == "function" ? f : vc({}, XE, f);
  return /* @__PURE__ */ i.createElement(Mc, vc({
    axisClassName: Pn("visx-axis-right", t),
    labelOffset: a,
    orientation: ir.right,
    tickLabelProps: s,
    tickLength: o
  }, u));
}
var GE = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function xc() {
  return xc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, xc.apply(this, arguments);
}
function ZE(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var QE = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function JE(e) {
  var t = e.axisClassName, n = e.labelOffset, a = n === void 0 ? 8 : n, r = e.tickLength, o = r === void 0 ? 8 : r, f = e.tickLabelProps, u = ZE(e, GE), s = typeof f == "function" ? f : xc({}, QE, f);
  return /* @__PURE__ */ i.createElement(Mc, xc({
    axisClassName: Pn("visx-axis-top", t),
    labelOffset: a,
    orientation: ir.top,
    tickLabelProps: s,
    tickLength: o
  }, u));
}
var ek = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function bc() {
  return bc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, bc.apply(this, arguments);
}
function tk(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
var nk = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function Vu(e) {
  var t = e.axisClassName, n = e.labelOffset, a = n === void 0 ? 8 : n, r = e.tickLength, o = r === void 0 ? 8 : r, f = e.tickLabelProps, u = tk(e, ek), s = typeof f == "function" ? f : bc({}, nk, f);
  return /* @__PURE__ */ i.createElement(Mc, bc({
    axisClassName: Pn("visx-axis-bottom", t),
    labelOffset: a,
    orientation: ir.bottom,
    tickLabelProps: s,
    tickLength: o
  }, u));
}
const Ss = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: g0,
  curveBasisClosed: y0,
  curveBasisOpen: v0,
  curveBundle: x0,
  curveCardinal: b0,
  curveCardinalClosed: S0,
  curveCardinalOpen: E0,
  curveCatmullRom: k0,
  curveCatmullRomClosed: w0,
  curveCatmullRomOpen: T0,
  curveLinear: Ac,
  curveLinearClosed: cf,
  curveMonotoneX: Wu,
  curveMonotoneY: C0,
  curveNatural: A0,
  curveStep: P0,
  curveStepAfter: R0,
  curveStepBefore: L0
}, Symbol.toStringTag, { value: "Module" })), rk = (e) => {
  var C, H;
  const { xScale: t, yScale: n, yMax: a, xMax: r, handleTooltipMouseOver: o, handleTooltipMouseOff: f, isDebug: u, children: s } = e;
  let { transformedData: d, config: m, handleLineType: y, parseDate: v, formatDate: w, formatNumber: E, seriesHighlight: O, colorScale: T, rawData: g, brushConfig: N } = ce.useContext(Pt);
  const L = (C = m.brush) != null && C.active && ((H = N.data) != null && H.length) ? N.data : d;
  if (!L)
    return;
  const M = (I) => (Cn(m.xAxis) ? t(v(I[m.xAxis.dataKey], !1)) : t(I[m.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), _ = (I, X, te = void 0) => n(I[te.dataKey]);
  return L && /* @__PURE__ */ i.createElement("svg", null, /* @__PURE__ */ i.createElement(Nr, { component: "AreaChart" }, /* @__PURE__ */ i.createElement(at, { className: "area-chart", key: "area-wrapper", left: Number(m.yAxis.size) }, (m.runtime.areaSeriesKeys || m.series).map((I, X) => {
    let te = L.map((U) => ({
      [m.xAxis.dataKey]: U[m.xAxis.dataKey],
      [I.dataKey]: U[I.dataKey]
    })), G = Ss[I.lineType], F = m.legend.behavior === "highlight" && O.length > 0 && O.indexOf(I.dataKey) === -1, j = m.legend.behavior === "highlight" || O.length === 0 || O.indexOf(I.dataKey) !== -1;
    return /* @__PURE__ */ i.createElement(i.Fragment, { key: X }, /* @__PURE__ */ i.createElement(
      qr,
      {
        data: te,
        x: (U) => M(U),
        y: (U) => _(U, X, I),
        stroke: j ? T ? T(m.runtime.seriesLabels ? m.runtime.seriesLabels[I.dataKey] : I.dataKey) : "#000" : "transparent",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        curve: G,
        strokeDasharray: I.type ? y(I.type) : 0
      }
    ), /* @__PURE__ */ i.createElement(
      nS,
      {
        key: "area-chart",
        fill: j ? T ? T(m.runtime.seriesLabels ? m.runtime.seriesLabels[I.dataKey] : I.dataKey) : "#000" : "transparent",
        fillOpacity: F ? 0.25 : 0.5,
        data: te,
        x: (U) => M(U),
        y: (U) => _(U, X, I),
        yScale: n,
        curve: G,
        strokeDasharray: I.type ? y(I.type) : 0
      }
    ));
  }), /* @__PURE__ */ i.createElement(gr, { width: Number(r), height: Number(a), fill: "transparent", fillOpacity: 0.05, onMouseMove: (I) => o(I, g), onMouseLeave: f }))));
}, ak = ce.memo(rk), Sc = {
  Linear: "curveLinear",
  Cardinal: "curveCardinal",
  Natural: "curveNatural",
  "Monotone X": "curveMonotoneX",
  Step: "curveStep"
}, ik = ({ xScale: e, yScale: t, yMax: n, xMax: a, handleTooltipMouseOver: r, handleTooltipMouseOff: o, isDebug: f }) => {
  var O, T;
  let { transformedData: u, config: s, seriesHighlight: d, colorScale: m, rawData: y } = ce.useContext(Pt);
  const v = (O = s.brush) != null && O.active && ((T = s.brush.data) != null && T.length) ? s.brush.data : u;
  if (!v)
    return;
  const w = (g) => {
    if (s.xAxis.type === "categorical")
      return e(g);
    if (Cn(s.xAxis)) {
      let N = new Date(g);
      return e(N);
    }
  }, E = 2;
  return v && /* @__PURE__ */ i.createElement("svg", { height: Number(n) }, /* @__PURE__ */ i.createElement(Nr, { component: "AreaChartStacked" }, /* @__PURE__ */ i.createElement(at, { className: "area-chart", key: "area-wrapper", left: Number(s.yAxis.size) + E / 2, height: Number(n), style: { overflow: "hidden" } }, /* @__PURE__ */ i.createElement(
    sS,
    {
      data: v,
      keys: s.runtime.areaSeriesKeys.map((g) => g.dataKey) || s.series.map((g) => g.dataKey),
      x0: (g) => w(g.data[s.xAxis.dataKey]),
      y0: (g) => Number(t(g[0])),
      y1: (g) => Number(t(g[1])),
      curve: Ss[Sc[s.stackedAreaChartLineType]]
    },
    ({ stacks: g, path: N }) => g.map((L, M) => {
      let _ = s.legend.behavior === "highlight" && d.length > 0 && d.indexOf(L.key) === -1, C = s.legend.behavior === "highlight" || d.length === 0 || d.indexOf(L.key) !== -1;
      return (
        // prettier-ignore
        /* @__PURE__ */ i.createElement(
          "path",
          {
            key: L.key,
            d: N(L) || "",
            strokeWidth: 2,
            stroke: C ? m ? m(s.runtime.seriesLabels ? s.runtime.seriesLabels[L.key] : L.key) : "#000" : "transparent",
            fillOpacity: _ ? 0.2 : 1,
            fill: C ? m ? m(s.runtime.seriesLabels ? s.runtime.seriesLabels[L.key] : L.key) : "#000" : "transparent"
          }
        )
      );
    })
  ), /* @__PURE__ */ i.createElement(gr, { width: Number(a), height: Number(n), fill: "transparent", onMouseMove: (g) => r(g, y), onMouseLeave: o }))));
}, ok = ce.memo(ik), Ds = () => {
  const { config: e, colorPalettes: t, tableData: n, updateConfig: a, parseDate: r, formatDate: o, setSeriesHighlight: f, seriesHighlight: u } = ce.useContext(Pt), { orientation: s } = e, [d, m] = ce.useState(null), y = s === "horizontal", v = 1, w = e.lollipopSize === "large" ? 7 : e.lollipopSize === "medium" ? 6 : 5, E = e.lollipopSize === "large" ? 14 : e.lollipopSize === "medium" ? 12 : 10, O = e.yAxis.labelPlacement === "Below Bar", T = e.yAxis.displayNumbersOnBar, g = e.orientation === "horizontal" ? "yAxis" : "xAxis", N = e.barStyle === "rounded", L = e.visualizationSubType === "stacked", M = e.tipRounding, _ = e.roundingStyle === "standard" ? "8px" : e.roundingStyle === "shallow" ? "5px" : e.roundingStyle === "finger" ? "15px" : "0px", C = e.runtime.seriesKeys.length, H = { small: 16, medium: 18, large: 20 }, I = Object.keys(e.runtime.seriesLabels).length > 1, te = e.visualizationType === "Bar" && e.legend.behavior === "isolate" && e.legend.axisAlign && (u != null && u.length) ? u : e.runtime.barSeriesKeys || e.runtime.seriesKeys;
  return ce.useEffect(() => {
    s === "horizontal" && !e.yAxis.labelPlacement && a({
      ...e,
      yAxis: {
        ...e,
        labelPlacement: "Below Bar"
      }
    });
  }, [e, a]), ce.useEffect(() => {
    e.isLollipopChart === !1 && e.barHeight < 25 && a({ ...e, barHeight: 25 });
  }, [e.isLollipopChart]), ce.useEffect(() => {
    e.visualizationSubType === "horizontal" && a({
      ...e,
      orientation: "horizontal"
    });
  }, []), ce.useEffect(() => {
    e.barStyle === "lollipop" && !e.isLollipopChart && a({ ...e, isLollipopChart: !0 }), (N || e.barStyle === "flat") && a({ ...e, isLollipopChart: !1 });
  }, [e.barStyle]), {
    isHorizontal: y,
    barBorderWidth: v,
    lollipopBarWidth: w,
    lollipopShapeSize: E,
    isLabelBelowBar: O,
    displayNumbersOnBar: T,
    shouldSuppress: (se) => {
      var ye;
      return (ye = e.preliminaryData) == null ? void 0 : ye.some((me) => {
        const Le = me.column ? me.column === se.key : !0, de = String(se.value) === String(me.value) && me.value !== "";
        return Le && de && me.symbol && me.type === "suppression";
      });
    },
    section: g,
    isRounded: N,
    isStacked: L,
    tipRounding: M,
    radius: _,
    stackCount: C,
    barStackedSeriesKeys: te,
    fontSize: H,
    hasMultipleSeries: I,
    applyRadius: (se) => {
      if (se == null || !N)
        return {};
      let ye = {};
      return (L && se + 1 === C || !L) && (ye = y ? { borderRadius: `0 ${_}  ${_}  0` } : { borderRadius: `${_} ${_} 0 0` }), !L && se === -1 && (ye = y ? { borderRadius: `${_} 0  0 ${_} ` } : { borderRadius: ` 0  0 ${_} ${_}` }), M === "full" && L && se === 0 && C > 1 && (ye = y ? { borderRadius: `${_} 0 0 ${_}` } : { borderRadius: `0 0 ${_} ${_}` }), M === "full" && (L && se === 0 && C === 1 || !L) && (ye = { borderRadius: _ }), ye;
    },
    updateBars: (se) => {
      if (e.visualizationType !== "Bar" && !y)
        return se;
      const ye = [...se];
      let me;
      const Le = {
        stacked: e.barHeight,
        lollipop: w
      };
      L ? me = Le.stacked : me = Le[e.isLollipopChart ? "lollipop" : "stacked"] * C;
      const de = O ? H[e.fontSize] * 1.2 : 0;
      let ie = Number(e.barSpace), Ce = ye.length * (me + de + ie);
      return y && (e.heights.horizontal = Ce), ye.map((He, we) => {
        let ge = 0;
        return He.index !== 0 && (ge = (me + ie + de) * we), { ...He, y: ge, height: me };
      });
    },
    assignColorsToValues: (se, ye, me) => {
      if (!e.legend.colorCode && e.series.length > 1)
        return me;
      const Le = e.customColors ?? t[e.palette], de = n.map((we) => we[e.legend.colorCode]);
      let ie = /* @__PURE__ */ new Map(), Ce = [];
      for (let we = 0; we < de.length; we++)
        ie.has(de[we]) || ie.set(de[we], Le[ie.size % Le.length]), Ce.push(ie.get(de[we]));
      for (; Ce.length < se; )
        Ce = Ce.concat(Ce);
      return Ce[ye];
    },
    getHighlightedBarColorByValue: (se) => {
      const ye = e == null ? void 0 : e.highlightedBarValues.find((me) => {
        if (me.value)
          return e.xAxis.type === "date" ? o(r(me.value)) === se : me.value === se;
      });
      return ye != null && ye.color ? ye.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (se) => {
      const ye = e == null ? void 0 : e.highlightedBarValues.filter((me) => {
        if (me.value)
          return e.xAxis.type === "date" ? o(r(me.value)) === se : me.value === se;
      })[0];
      return ye != null && ye.color ? ye : !1;
    },
    getAdditionalColumn: (se, ye) => {
      if (!ye)
        return "";
      const me = e.columns, Le = [];
      let de = "";
      const ie = n.find((Ce) => Ce[e.xAxis.dataKey] === ye) || {};
      return Object.keys(me).forEach((Ce) => {
        if (se && e.columns[Ce].series && e.columns[Ce].series !== se)
          return;
        const He = {
          addColPrefix: e.columns[Ce].prefix,
          addColSuffix: e.columns[Ce].suffix,
          addColRoundTo: e.columns[Ce].roundToPlace ? e.columns[Ce].roundToPlace : "",
          addColCommas: e.columns[Ce].commas
        }, we = Sm(ie[e.columns[Ce].name], "left", !0, e, He);
        e.columns[Ce].tooltips && Le.push([e.columns[Ce].label, we]);
      }), Le.forEach((Ce) => {
        de += `${Ce[0]} : ${Ce[1]} <br/>`;
      }), de;
    },
    hoveredBar: d,
    setHoveredBar: m,
    onMouseOverBar: (se, ye) => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && ye && f([ye]), m(se);
    },
    onMouseLeaveBar: () => {
      e.legend.highlightOnHover && e.legend.behavior === "highlight" && f([]);
    },
    composeSuppressionBars: ({ bar: se }) => {
      const ye = e.xAxis.showSuppressedLine ? 3 : 0, me = "Asterisk", Le = (He) => String(He).includes(me) ? -5 : -ye * 3, de = (He) => String(He).includes(me) ? "middle" : "end", ie = (He, we) => {
        switch (He) {
          case me:
            return we * 1.2;
          case "Double " + me:
            return we;
          default:
            return we / 1.5;
        }
      };
      function Ce() {
        return e.preliminaryData.some((we) => {
          const ge = !we.column || we.column === se.key;
          return String(we.value) === String(se.value) && we.value !== "" && we.type === "suppression" && ge;
        }) && e.xAxis.showSuppressedSymbol;
      }
      return {
        suppresedBarHeight: ye,
        getIconSize: ie,
        getIconPadding: Le,
        getVerticalAnchor: de,
        isSuppressed: Ce()
      };
    }
  };
}, Os = ce.createContext(null), mh = ({ xScale: e, barWidth: t = 0, totalBarsInGroup: n = 1, yMax: a, handleTooltipMouseOff: r, handleTooltipMouseOver: o, handleTooltipClick: f, tooltipData: u, showTooltip: s, hideTooltip: d }) => {
  const { parseDate: m, config: y } = ce.useContext(Pt), { runtime: v, regions: w, visualizationType: E, orientation: O, xAxis: T } = y, g = e.domain(), N = (_) => {
    let C;
    if (!(_ != null && _.fromType) || _.fromType === "Fixed") {
      const H = new Date(_.from), I = m(rs(y.xAxis.dateParseFormat, H)).getTime();
      C = e(I), E === "Bar" && T.type === "date-time" && (C = C - t * n / 2);
    }
    if (_.fromType === "Previous Days") {
      const H = Number(_.from) || 0;
      g.map((G) => rs(y.xAxis.dateParseFormat, new Date(G)));
      const I = _.toType === "Last Date" ? new Date(g[g.length - 1]).getTime() : new Date(_.to), X = y.xAxis.type === "categorical" ? rs(y.xAxis.dateParseFormat, I) : rs(y.xAxis.dateParseFormat, I), te = new Date(X);
      if (C = new Date(te.setDate(te.getDate() - Number(H))), T.type === "date") {
        C = new Date(rs(T.dateParseFormat, C)).getTime();
        let G = g[0], F = Math.abs(C - G);
        for (let j = 1; j < g.length; j++) {
          const U = Math.abs(C - g[j]);
          U < F && (F = U, G = g[j]);
        }
        C = G;
      }
      if (T.type === "categorical") {
        let G = g[0], F = Math.abs(new Date(C).getTime() - new Date(G).getTime());
        for (let j = 1; j < g.length; j++) {
          const U = Math.abs(new Date(C).getTime() - new Date(g[j]).getTime());
          U < F && (F = U, G = g[j]);
        }
        C = G;
      }
      C = e(C);
    }
    if (T.type === "categorical" && _.fromType !== "Previous Days" && (C = e(_.from)), E === "Line" || E === "Area Chart") {
      let H = Number(y.yAxis.size);
      e.bandwidth && (H += e.bandwidth() / 2), C = C + H;
    }
    return E === "Bar" && y.xAxis.type === "date-time" && _.fromType === "Previous Days" && (C = C - t * n / 2), C;
  }, L = (_) => {
    let C;
    if (T.type === "categorical" && (C = e(_.to)), Cn(T) && ((!(_ != null && _.toType) || _.toType === "Fixed") && (C = e(m(_.to).getTime())), (E === "Bar" || y.visualizationType === "Combo") && (C = _.toType !== "Last Date" ? e(m(_.to).getTime()) + t * n : C)), _.toType === "Last Date") {
      const H = g[g.length - 1];
      C = Number(e(H) + ((E === "Bar" || E === "Combo") && y.xAxis.type === "date" ? t * n : 0));
    }
    if (E === "Line" || E === "Area Chart") {
      let H = Number(y.yAxis.size);
      e.bandwidth && (H += e.bandwidth() / 2), C = C + H;
    }
    return E === "Bar" && y.xAxis.type === "date-time" && _.toType !== "Last Date" && (C = C - t * n / 2), (E === "Bar" || E === "Combo") && T.type === "categorical" && (C = C + (E === "Bar" || E === "Combo" ? t * n : 0)), C;
  }, M = (_, C) => _ - C;
  if (w && O === "vertical")
    return w.map((_) => {
      const C = N(_), H = L(_), I = M(H, C);
      if (!C || !H)
        return null;
      const X = () => /* @__PURE__ */ i.createElement(
        "path",
        {
          stroke: "#333",
          d: `M${C} -5
                L${C} 5
                M${C} 0
                L${H} 0
                M${H} -5
                L${H} 5`
        }
      ), te = () => /* @__PURE__ */ i.createElement("rect", { x: C, y: 0, width: I, height: a, fill: _.background, opacity: 0.3 });
      return /* @__PURE__ */ i.createElement(at, { height: 100, fill: "red", className: "regions regions-group--line zzz", key: _.label, onMouseMove: o, onMouseLeave: r, handleTooltipClick: f, tooltipData: JSON.stringify(u), showTooltip: s }, /* @__PURE__ */ i.createElement(X, null), /* @__PURE__ */ i.createElement(te, null), /* @__PURE__ */ i.createElement(Tt, { x: C + I / 2, y: 5, fill: _.color, verticalAnchor: "start", textAnchor: "middle" }, _.label));
    });
};
function _c(e) {
  var se, ye;
  const { config: t, index: n, id: a, className: r, background: o, borderColor: f, borderWidth: u, width: s, height: d, x: m, y, onMouseOver: v, onMouseLeave: w, onClick: E, tooltipHtml: O, tooltipId: T, styleOverrides: g, seriesHighlight: N } = e, L = Math.max(0, s), M = Math.max(0, d), _ = t.orientation === "horizontal", C = t.barStyle === "rounded", H = t.visualizationSubType === "stacked", I = t.tipRounding, X = t.visualizationType === "Combo" && ((ye = (se = t.runtime) == null ? void 0 : se.barSeriesKeys) == null ? void 0 : ye.length), te = t.runtime.seriesKeys.length, G = t.visualizationType === "Bar" && t.legend.axisAlign && (N != null && N.length) ? N == null ? void 0 : N.length : 0, F = X || G || te;
  let j = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  (j > L / 2 || j > M / 2) && (j = Math.min(L / 2, M / 2));
  const U = () => `M${m},${y + M}
      L${m},${y + j}
      Q${m},${y} ${m + j},${y}
      L${m + L - j},${y}
      Q${m + L},${y} ${m + L},${y + j}
      L${m + L},${y + M}
      L${m},${y + M}`, W = () => `M${m},${y + M}
      L${m},${y}
      L${m + L - j},${y}
      Q${m + L},${y} ${m + L},${y + j}
      L${m + L},${y + M - j}
      Q${m + L},${y + M} ${m + L - j},${y + M}
      L${m},${y + M}`, re = () => `M${m + j},${y + M}
      Q${m},${y + M} ${m},${y + M - j}
      L${m},${y}
      L${m + L},${y}
      L${m + L},${y + M - j}
      Q${m + L},${y + M} ${m + L - j},${y + M}
      L${m + j},${y + M}`, J = () => `M${m + j},${y + M}
      Q${m},${y + M} ${m},${y + M - j}
      L${m},${y + j}
      Q${m},${y} ${m + j},${y}
      L${m + L},${y}
      L${m + L},${y + M}
      L${m + j},${y + M}`, ue = () => `M${m + j},${y + M}
      Q${m},${y + M} ${m},${y + M - j}
      L${m},${y + j}
      Q${m},${y} ${m + j},${y}
      L${m + L - j},${y}
      Q${m + L},${y} ${m + L},${y + j}
      L${m + L},${y + M - j}
      Q${m + L},${y + M} ${m + L - j},${y + M}
      L${m + j},${y + M}`, ee = () => `M${m},${y}
      L${m + L},${y}
      L${m + L},${y + M}
      L${m},${y + M}
      L${m},${y}`;
  let Z;
  return n == null || !C ? Z = ee() : (Z = ee(), (H && n + 1 === F || !H) && (Z = _ ? W() : U()), !H && n === -1 && (Z = _ ? J() : re()), I === "full" && H && n === 0 && F > 1 && (Z = _ ? J() : re()), I === "full" && (H && n === 0 && F === 1 || !H) && (Z = ue())), /* @__PURE__ */ i.createElement(
    "path",
    {
      id: a,
      className: r,
      d: Z,
      fill: o,
      stroke: f,
      strokeWidth: u,
      onMouseOver: v,
      onMouseLeave: w,
      onClick: E,
      "data-tooltip-html": O,
      "data-tooltip-id": T,
      style: {
        transition: "all 0.2s linear",
        ...g
      }
    }
  );
}
const lk = () => {
  var I, X;
  const [e, t] = ce.useState(0), { xScale: n, yScale: a, xMax: r, yMax: o } = ce.useContext(Os), { transformedData: f, colorScale: u, seriesHighlight: s, config: d, formatNumber: m, formatDate: y, parseDate: v, setSharedFilter: w } = ce.useContext(Pt), { isHorizontal: E, barBorderWidth: O, applyRadius: T, hoveredBar: g, getAdditionalColumn: N, onMouseLeaveBar: L, onMouseOverBar: M, barStackedSeriesKeys: _ } = Ds(), { orientation: C } = d, H = (I = d.brush) != null && I.active && ((X = d.brush.data) != null && X.length) ? d.brush.data : f;
  return d.visualizationSubType === "stacked" && !E && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(hS, { data: H, keys: _, x: (te) => te[d.runtime.xAxis.dataKey], xScale: n, yScale: a, color: u }, (te) => te.reverse().map(
    (G) => G.bars.map((F) => {
      let j = d.legend.behavior === "highlight" && s.length > 0 && s.indexOf(F.key) === -1, U = d.legend.behavior === "highlight" || s.length === 0 || s.indexOf(F.key) !== -1, W = d.xAxis.type === "date-time" ? d.barThickness * (n.range()[1] - n.range()[0]) : r / G.bars.length, re = W * (d.xAxis.type === "date-time" ? 1 : d.barThickness || 0.8);
      W * (1 - (d.barThickness || 0.8)) / 2;
      const J = F.bar.data[d.runtime.xAxis.dataKey], ue = d.runtime.xAxis.type === "date" ? y(v(J)) : J, ee = m(F.bar ? F.bar.data[F.key] : 0, "left");
      if (!ee)
        return;
      const Z = n(d.runtime.xAxis.type === "date" ? v(J) : J) - (d.xAxis.type === "date" && d.xAxis.sortDates ? re / 2 : 0);
      T(G.index);
      const se = d.runtime.xAxis.label ? `${d.runtime.xAxis.label}: ${ue}` : ue, ye = N(g), me = `${d.runtime.seriesLabels[F.key]}: ${ee}`, Le = `<ul>
                  <li class="tooltip-heading"">${se}</li>
                  <li class="tooltip-body ">${me}</li>
                  <li class="tooltip-body ">${ye}</li>
                    </li></ul>`;
      return t(re), /* @__PURE__ */ i.createElement(at, { key: `${G.index}--${F.index}--${C}` }, /* @__PURE__ */ i.createElement(at, { key: `bar-stack-${G.index}-${F.index}`, id: `barStack${G.index}-${F.index}`, className: "stack vertical" }, /* @__PURE__ */ i.createElement(Tt, { display: d.labels && U ? "block" : "none", opacity: j ? 0.5 : 1, x: Z + e / 2, y: F.y - 5, fill: "#000", textAnchor: "middle" }, ee), _c({
        config: d,
        seriesHighlight: s,
        index: G.index,
        background: u(d.runtime.seriesLabels[F.key]),
        borderColor: "#333",
        borderStyle: "solid",
        borderWidth: `${d.barHasBorder === "true" ? O : 0}px`,
        width: re,
        height: F.height,
        x: Z,
        y: F.y,
        onMouseOver: () => M(ue, F.key),
        onMouseLeave: L,
        tooltipHtml: Le,
        tooltipId: `cdc-open-viz-tooltip-${d.runtime.uniqueId}`,
        onClick: (de) => {
          de.preventDefault(), w && (F[d.xAxis.dataKey] = ue, w(d.uid, F));
        },
        styleOverrides: {
          animationDelay: `${G.index * 0.5}s`,
          transformOrigin: `${re / 2}px ${F.y + F.height}px`,
          opacity: j ? 0.2 : 1,
          display: U ? "block" : "none"
        }
      })));
    })
  )), /* @__PURE__ */ i.createElement(mh, { xScale: n, yMax: o, barWidth: e, totalBarsInGroup: 1 }));
}, sk = () => {
  const { yMax: e, yScale: t, xScale: n } = ce.useContext(Os), {
    animatedChart: a,
    colorScale: r,
    config: o,
    formatDate: f,
    formatNumber: u,
    getTextWidth: s,
    parseDate: d,
    seriesHighlight: m,
    setSharedFilter: y,
    transformedData: v
  } = ce.useContext(Pt), { barBorderWidth: w, displayNumbersOnBar: E, fontSize: O, getAdditionalColumn: T, hoveredBar: g, isHorizontal: N, isLabelBelowBar: L, onMouseLeaveBar: M, onMouseOverBar: _, updateBars: C, barStackedSeriesKeys: H } = Ds(), { orientation: I, visualizationSubType: X } = o;
  return o.visualizationSubType === "stacked" && N && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(gS, { data: v, keys: H, height: e, y: (te) => te[o.runtime.yAxis.dataKey], xScale: n, yScale: t, color: r, offset: "none" }, (te) => te.map(
    (G) => C(G.bars).map((F, j) => {
      const U = o.legend.behavior === "highlight" && m.length > 0 && m.indexOf(F.key) === -1, W = o.legend.behavior === "highlight" || m.length === 0 || m.indexOf(F.key) !== -1;
      o.barHeight = Number(o.barHeight);
      const re = Zo("#000", r(o.runtime.seriesLabels[F.key])), J = u(v[F.index][F.key], "left"), ue = o.runtime.yAxis.type === "date" ? f(d(v[F.index][o.runtime.originalXAxis.dataKey])) : v[F.index][o.runtime.originalXAxis.dataKey], ee = o.runtime.yAxis.label ? `${o.runtime.yAxis.label}: ${ue}` : ue, Z = s(J, `normal ${O[o.fontSize]}px sans-serif`), se = T(g), ye = `${o.runtime.seriesLabels[F.key]}: ${J}`, me = `<ul>
                  <li class="tooltip-heading"">${ee}</li>
                  <li class="tooltip-body ">${ye}</li>
                  <li class="tooltip-body ">${se}</li>
                    </li></ul>`;
      return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(at, { key: j, id: `barStack${G.index}-${F.index}`, className: "stack horizontal" }, _c({
        config: o,
        seriesHighlight: m,
        index: G.index,
        className: `animated-chart group ${a ? "animated" : ""}`,
        background: r(o.runtime.seriesLabels[F.key]),
        borderColor: "#333",
        borderStyle: "solid",
        borderWidth: `${o.barHasBorder === "true" ? w : 0}px`,
        width: F.width,
        height: F.height,
        x: F.x,
        y: F.y,
        onMouseOver: () => _(ue, F.key),
        onMouseLeave: M,
        tooltipHtml: me,
        tooltipId: `cdc-open-viz-tooltip-${o.runtime.uniqueId}`,
        onClick: (Le) => {
          Le.preventDefault(), y && (F[o.xAxis.dataKey] = J, y(o.uid, F));
        },
        styleOverrides: {
          animationDelay: `${G.index * 0.5}s`,
          transformOrigin: `${F.x}px 0`,
          opacity: U ? 0.2 : 1,
          display: W ? "block" : "none"
        }
      }), I === "horizontal" && X === "stacked" && L && G.index === 0 && !o.yAxis.hideLabel && /* @__PURE__ */ i.createElement(
        Tt,
        {
          x: `${F.x + (o.isLollipopChart ? 15 : 5)}`,
          y: F.y + F.height * 1.2,
          fill: "#000000",
          textAnchor: "start",
          verticalAnchor: "start"
        },
        ue
      ), E && Z < F.width && /* @__PURE__ */ i.createElement(
        Tt,
        {
          display: W ? "block" : "none",
          x: F.x + G.bars[F.index].width / 2,
          y: F.y + F.height / 2,
          fill: re,
          textAnchor: "middle",
          verticalAnchor: "middle"
        },
        J
      )));
    })
  )));
}, al = (e, t, n) => !!(e === "Line" && t.length < 3 && n), uk = () => {
  const { xScale: e, yScale: t, xMax: n, yMax: a, seriesScale: r } = ce.useContext(Os), [o, f] = ce.useState(0), [u, s] = ce.useState(0), { assignColorsToValues: d, barBorderWidth: m, getAdditionalColumn: y, getHighlightedBarByValue: v, getHighlightedBarColorByValue: w, lollipopBarWidth: E, lollipopShapeSize: O, onMouseLeaveBar: T, onMouseOverBar: g, section: N, composeSuppressionBars: L, shouldSuppress: M } = Ds(), { colorScale: _, config: C, dashboardConfig: H, tableData: I, formatDate: X, formatNumber: te, getXAxisData: G, getYAxisData: F, isNumber: j, parseDate: U, seriesHighlight: W, setSharedFilter: re, transformedData: J, brushConfig: ue } = ce.useContext(Pt), { HighLightedBarUtils: ee } = Rc(C);
  let Z = J;
  return C.preliminaryData.some((ye) => ye.value && ye.type === "suppression") && (Z = I), ue.data.length && (Z = ue.data), C.visualizationSubType !== "stacked" && (C.visualizationType === "Bar" || C.visualizationType === "Combo" || al(C.visualizationType, Z, C.allowLineToBarGraph)) && C.orientation === "vertical" && /* @__PURE__ */ i.createElement(at, null, /* @__PURE__ */ i.createElement(
    Rg,
    {
      data: Z,
      keys: C.runtime.barSeriesKeys || C.runtime.seriesKeys,
      height: a,
      x0: (ye) => {
        const me = ye[C.runtime.originalXAxis.dataKey];
        return Cn(C.runtime.xAxis) ? U(me) : me;
      },
      x0Scale: e,
      x1Scale: r,
      yScale: t,
      color: () => ""
    },
    (ye) => ye.map((me, Le) => /* @__PURE__ */ i.createElement(at, { className: `bar-group-${me.index}-${me.x0}--${Le} ${C.orientation}`, key: `bar-group-${me.index}-${me.x0}--${Le}`, id: `bar-group-${me.index}-${me.x0}--${Le}`, left: me.x0 }, me.bars.map((de, ie) => {
      const { suppresedBarHeight: Ce, getIconSize: He, getIconPadding: we, getVerticalAnchor: ge, isSuppressed: ke } = L({ bar: de }), ne = C.useLogScale ? 0.1 : 0;
      let Pe = C.highlightedBarValues.map((ut) => ut.value).filter((ut) => ut !== void 0);
      Pe = C.xAxis.type === "date" ? ee.formatDates(Pe) : Pe;
      const $e = C.legend.behavior === "highlight" && W.length > 0 && W.indexOf(de.key) === -1, qe = C.legend.behavior === "highlight" || W.length === 0 || W.indexOf(de.key) !== -1, Ge = Math.abs(t(de.value) - t(ne)), Xe = de.value >= 0 && j(de.value) ? de.y : t(0), We = ke ? t(ne) - Ce : Xe;
      let vt = r.range()[1], et = C.isLollipopChart ? E : vt / me.bars.length, Ke = de.x + (C.isLollipopChart ? (vt / me.bars.length - E) / 2 : 0) - (C.xAxis.type === "date-time" ? vt / 2 : 0);
      f(et), s(me.bars.length);
      const Be = te(/[a-zA-Z]/.test(String(de.value)) ? "" : de.value, "left"), ze = C.runtime[N].type === "date" ? X(U(Z[me.index][C.runtime.originalXAxis.dataKey])) : Z[me.index][C.runtime.originalXAxis.dataKey], gt = de.value < 0 ? -1 : ie, Ye = y(de.key, Z[me.index][C.runtime.originalXAxis.dataKey]);
      let dt = C.runtime.xAxis.label ? `${C.runtime.xAxis.label}: ${ze}` : ze;
      const xt = `${C.runtime.seriesLabels[de.key]}: ${Be}`, ft = `<ul>
                  <li class="tooltip-heading">${dt}</li>
                  <li class="tooltip-body ">${xt}</li>
                  ${Ye ? '<li class="tooltip-body ">' + Ye + "</li>" : ""}
                    </li></ul>`;
      let lt = "#000000";
      lt = ee.checkFontColor(Be, Pe, lt);
      let Dt = C.runtime.seriesLabels && C.runtime.seriesLabels[de.key] ? _(C.runtime.seriesLabels[de.key]) : _(de.key);
      Dt = d(ye.length, me.index, Dt);
      const on = C.isLollipopChart && C.lollipopColorStyle === "regular", Xt = C.isLollipopChart && C.lollipopColorStyle === "two-tone", tn = Pe == null ? void 0 : Pe.includes(ze), mn = w(ze), zt = v(ze), Vt = tn ? mn : C.barHasBorder === "true" ? "#000" : "transparent", _e = tn ? zt.borderWidth : C.isLollipopChart ? 0 : C.barHasBorder === "true" ? m : 0, En = ke ? "" : Be, nn = ke ? Ce : Ge, Kt = ke ? "none" : "block", wn = (ut, dn) => {
        var xn;
        let It = ut, vn = dn || "#f2f2f2";
        if (H && ((xn = H.dashboard.sharedFilters) == null ? void 0 : xn.length) !== 0) {
          const { sharedFilters: qt } = H.dashboard;
          return It = qt ? qt.map((fn) => fn.setBy === C.uid ? fn.resetLabel === fn.active || fn.active === J[me.index][C.xAxis.dataKey] ? _(C.runtime.seriesLabels[de.key]) : vn : _(C.runtime.seriesLabels[de.key]))[0] : _(C.runtime.seriesLabels[de.key]), on && (It = ut), Xt && (It = Es(ut).brighten(1)), tn && (It = "transparent"), It;
        }
        return Xt && (It = Es(ut).brighten(1)), tn && (It = "transparent"), It;
      };
      return /* @__PURE__ */ i.createElement(at, { key: `${me.index}--${ie}` }, /* @__PURE__ */ i.createElement(at, { key: `bar-sub-group-${me.index}-${me.x0}-${We}--${ie}` }, _c({
        config: C,
        index: gt,
        id: `barGroup${me.index}`,
        background: wn(_(C.runtime.seriesLabels[de.key])),
        borderColor: Vt,
        borderStyle: "solid",
        borderWidth: `${_e}px`,
        width: et,
        height: nn,
        x: Ke,
        y: We,
        onMouseOver: () => g(ze, de.key),
        onMouseLeave: T,
        tooltipHtml: ft,
        tooltipId: `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
        onClick: (ut) => {
          ut.preventDefault(), re && (de[C.xAxis.dataKey] = ze, re(C.uid, de));
        },
        styleOverrides: {
          transformOrigin: `0 ${We + nn}px`,
          opacity: $e ? 0.2 : 1,
          display: qe ? "block" : "none",
          cursor: H ? "pointer" : "default"
        }
      }), C.preliminaryData.map((ut, dn) => {
        const It = !ut.column || ut.column === de.key;
        if (!(!(String(ut.value) === String(de.value) && ut.value !== "" && It) || et < 10 || !C.xAxis.showSuppressedSymbol))
          return /* @__PURE__ */ i.createElement(
            Tt,
            {
              key: dn,
              dy: we(ut.symbol),
              display: qe ? "block" : "none",
              opacity: $e ? 0.5 : 1,
              x: Ke + et / 2,
              y: We,
              verticalAnchor: ge(ut.symbol),
              fill: lt,
              textAnchor: "middle",
              fontSize: `${He(ut.symbol, et)}px`
            },
            ut.iconCode
          );
      }), /* @__PURE__ */ i.createElement(
        Tt,
        {
          display: C.labels && qe ? "block" : "none",
          opacity: $e ? 0.5 : 1,
          x: Ke + et / 2,
          y: We - 5,
          fill: lt,
          textAnchor: "middle"
        },
        En
      ), C.isLollipopChart && C.lollipopShape === "circle" && /* @__PURE__ */ i.createElement(
        "circle",
        {
          display: Kt,
          cx: Ke + O / 3.5,
          cy: de.y,
          r: O / 2,
          fill: Dt,
          key: `circle--${de.index}`,
          "data-tooltip-html": ft,
          "data-tooltip-id": `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
          style: { filter: "unset", opacity: 1 }
        }
      ), C.isLollipopChart && C.lollipopShape === "square" && /* @__PURE__ */ i.createElement(
        "rect",
        {
          display: Kt,
          x: Ke - E / 2,
          y: We,
          width: O,
          height: O,
          fill: Dt,
          key: `circle--${de.index}`,
          "data-tooltip-html": ft,
          "data-tooltip-id": `cdc-open-viz-tooltip-${C.runtime.uniqueId}`,
          style: { opacity: 1, filter: "unset" }
        },
        /* @__PURE__ */ i.createElement("animate", { attributeName: "height", values: `0, ${O}`, dur: "2.5s" })
      )));
    })))
  ), Object.keys(C.confidenceKeys).length > 0 ? Z.map((ye) => {
    let me, Le, de, ie, Ce = 5;
    return me = e(G(ye)) + (C.xAxis.type !== "date" || C.xAxis.type !== "date-time" ? r.range()[1] / 2 : 0), de = t(F(ye, C.confidenceKeys.lower)), ie = t(F(ye, C.confidenceKeys.upper)), /* @__PURE__ */ i.createElement(
      "path",
      {
        key: `confidence-interval-v-${Le}-${ye[C.runtime.originalXAxis.dataKey]}`,
        stroke: "#333",
        strokeWidth: "px",
        d: `
                    M${me - Ce} ${de}
                    L${me + Ce} ${de}
                    M${me} ${de}
                    L${me} ${ie}
                    M${me - Ce} ${ie}
                    L${me + Ce} ${ie}`
      }
    );
  }) : "", /* @__PURE__ */ i.createElement(mh, { xScale: e, yMax: a, barWidth: o, totalBarsInGroup: u }));
}, ck = () => {
  var ee;
  const { xScale: e, yScale: t, yMax: n, seriesScale: a } = ce.useContext(Os), { transformedData: r, tableData: o, colorScale: f, seriesHighlight: u, config: s, formatNumber: d, formatDate: m, parseDate: y, setSharedFilter: v, isNumber: w, getTextWidth: E, getYAxisData: O, getXAxisData: T } = ce.useContext(Pt), {
    isHorizontal: g,
    barBorderWidth: N,
    updateBars: L,
    assignColorsToValues: M,
    section: _,
    fontSize: C,
    isLabelBelowBar: H,
    displayNumbersOnBar: I,
    lollipopBarWidth: X,
    lollipopShapeSize: te,
    getHighlightedBarColorByValue: G,
    getHighlightedBarByValue: F,
    getAdditionalColumn: j,
    hoveredBar: U,
    onMouseLeaveBar: W,
    onMouseOverBar: re,
    composeSuppressionBars: J
  } = Ds(), { HighLightedBarUtils: ue } = Rc(s);
  return s.visualizationSubType !== "stacked" && s.visualizationType === "Bar" && s.orientation === "horizontal" && /* @__PURE__ */ i.createElement(at, null, /* @__PURE__ */ i.createElement(
    Rg,
    {
      data: (ee = s.preliminaryData) != null && ee.some((Z) => Z.value && Z.type === "suppression") ? o : r,
      keys: s.runtime.barSeriesKeys || s.runtime.seriesKeys,
      height: n,
      x0: (Z) => Z[s.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: a,
      yScale: e,
      color: () => ""
    },
    (Z) => L(Z).map((se, ye) => /* @__PURE__ */ i.createElement(at, { className: `bar-group-${se.index}-${se.x0}--${ye} ${s.orientation}`, key: `bar-group-${se.index}-${se.x0}--${ye}`, id: `bar-group-${se.index}-${se.x0}--${ye}`, top: se.y }, se.bars.map((me, Le) => {
      var fn;
      const de = s.useLogScale ? 0.1 : 0, { suppresedBarHeight: ie, getIconSize: Ce, getIconPadding: He, getVerticalAnchor: we, isSuppressed: ge } = J({ bar: me });
      let ke = s.highlightedBarValues.map((Et) => Et.value).filter((Et) => Et !== void 0);
      ke = s.xAxis.type === "date" ? ue.formatDates(ke) : ke;
      let ne = s.legend.behavior === "highlight" && u.length > 0 && u.indexOf(me.key) === -1, Pe = s.legend.behavior === "highlight" || u.length === 0 || u.indexOf(me.key) !== -1, $e = s.barHeight, qe = parseInt(s.isLollipopChart ? X : $e);
      isNaN(qe) && (qe = 25);
      let Ge = me.value >= 0 && w(me.value) ? me.y : t(de);
      const Xe = Math.abs(e(me.value) - e(de)), We = me.value >= 0 && w(me.value);
      let vt = ge ? ie : Xe;
      const et = me.value < 0 ? Math.abs(e(me.value)) : e(de), Ke = d(me.value, "left"), Be = s.runtime[_].type === "date" ? m(y(r[se.index][s.runtime.originalXAxis.dataKey])) : r[se.index][s.runtime.originalXAxis.dataKey], ze = We ? "above" : "below", gt = ge ? "" : Ke;
      let Ye = E(Be, `normal ${C[s.fontSize]}px sans-serif`), dt = Number(Ye) < Xe - 5, xt = dt ? "end" : "start", ft = "start", lt = dt ? -5 : 5, Dt = 10;
      ze === "below" && (xt = dt ? "start" : "end", lt = dt ? 5 : -5, s.isLollipopChart && (ft = "end", Dt = -10));
      const on = me.value < 0 ? -1 : Le;
      let Xt = s.runtime.yAxis.label ? `${s.runtime.yAxis.label}: ${Be}` : Be;
      const tn = j(U), mn = `${s.runtime.seriesLabels[me.key]}: ${Ke}`, zt = `<ul>
                  <li class="tooltip-heading"">${Xt}</li>
                  <li class="tooltip-body ">${mn}</li>
                  <li class="tooltip-body ">${tn}</li>
                    </li></ul>`;
      let Vt = "#000000";
      Vt = ue.checkFontColor(Ke, ke, Vt);
      let _e = s.runtime.seriesLabels && s.runtime.seriesLabels[me.key] ? f(s.runtime.seriesLabels[me.key]) : f(me.key);
      _e = M(Z.length, se.index, _e);
      const En = s.isLollipopChart && s.lollipopColorStyle === "regular", nn = s.isLollipopChart && s.lollipopColorStyle === "two-tone", Kt = ke == null ? void 0 : ke.includes(Be), wn = G(Be), ut = F(Be), dn = Kt ? wn : s.barHasBorder === "true" ? "#000" : "transparent", It = Kt ? ut.borderWidth : s.isLollipopChart ? 0 : s.barHasBorder === "true" ? N : 0, vn = ge ? "none" : "block";
      _e && Vt && dt && (Vt = Zo("#000", _e));
      const xn = () => En ? _e : nn ? Es(_e).brighten(1) : Kt ? "transparent" : _e, qt = (Et) => Et === "Asterisk" ? "3px" : Et === "Double Asterisks" ? "4px" : "12px";
      return /* @__PURE__ */ i.createElement(at, { key: `${se.index}--${Le}` }, /* @__PURE__ */ i.createElement(at, { key: `bar-sub-group-${se.index}-${se.x0}-${Ge}--${Le}` }, _c({
        config: s,
        index: on,
        id: `barGroup${se.index}`,
        background: xn(),
        borderColor: dn,
        borderStyle: "solid",
        borderWidth: `${It}px`,
        width: vt,
        height: qe,
        x: et,
        y: $e * me.index,
        onMouseOver: () => re(Be, me.key),
        onMouseLeave: W,
        tooltipHtml: zt,
        tooltipId: `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
        onClick: (Et) => {
          Et.preventDefault(), v && (me[s.xAxis.dataKey] = Ke, v(s.uid, me));
        },
        styleOverrides: {
          transformOrigin: `0 ${Ge + $e}px`,
          opacity: ne ? 0.2 : 1,
          display: Pe ? "block" : "none"
        }
      }), (fn = s.preliminaryData) == null ? void 0 : fn.map((Et, Nn) => {
        const Ln = !Et.column || Et.column === me.key;
        if (!(!(String(Et.value) === String(o[se.index][me.key]) && Et.value !== "" && Ln) || $e < 10 || !s.xAxis.showSuppressedSymbol))
          return /* @__PURE__ */ i.createElement(
            Tt,
            {
              key: Nn,
              fontSize: Ce(Et.symbol, $e),
              angle: 90,
              display: Pe ? "block" : "none",
              opacity: ne ? 0.5 : 1,
              x: et,
              y: s.barHeight / 2 + s.barHeight * me.index,
              fill: "#000",
              dx: qt(Et.symbol),
              verticalAnchor: we(Et.symbol),
              textAnchor: "middle"
            },
            Et.iconCode
          );
      }), !s.isLollipopChart && I && /* @__PURE__ */ i.createElement(
        Tt,
        {
          display: Pe ? "block" : "none",
          x: me.y,
          y: s.barHeight / 2 + s.barHeight * me.index,
          fill: Vt,
          dx: lt,
          verticalAnchor: "middle",
          textAnchor: xt
        },
        gt
      ), s.isLollipopChart && I && /* @__PURE__ */ i.createElement(
        Tt,
        {
          display: Pe ? "block" : "none",
          x: me.y,
          y: 0,
          fill: "#000000",
          dx: Dt,
          textAnchor: ft,
          verticalAnchor: "middle",
          fontWeight: "normal"
        },
        gt
      ), H && !s.yAxis.hideLabel && /* @__PURE__ */ i.createElement(Tt, { x: s.yAxis.hideAxis ? 0 : 5, y: se.height, dy: 4, verticalAnchor: "start", textAnchor: "start" }, s.runtime.yAxis.type === "date" ? m(y(r[se.index][s.runtime.originalXAxis.dataKey])) : g ? r[se.index][s.runtime.originalXAxis.dataKey] : d(r[se.index][s.runtime.originalXAxis.dataKey])), s.isLollipopChart && s.lollipopShape === "circle" && /* @__PURE__ */ i.createElement(
        "circle",
        {
          display: vn,
          cx: me.y,
          cy: $e * me.index + X / 2,
          r: te / 2,
          fill: _e,
          key: `circle--${me.index}`,
          "data-tooltip-html": zt,
          "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
          style: { filter: "unset", opacity: 1 }
        }
      ), s.isLollipopChart && s.lollipopShape === "square" && /* @__PURE__ */ i.createElement(
        "rect",
        {
          display: vn,
          x: me.y > 10 ? me.y - te / 2 : 0,
          y: 0 - X / 2,
          width: te,
          height: te,
          fill: _e,
          key: `circle--${me.index}`,
          "data-tooltip-html": zt,
          "data-tooltip-id": `cdc-open-viz-tooltip-${s.runtime.uniqueId}`,
          style: { opacity: 1, filter: "unset" }
        },
        /* @__PURE__ */ i.createElement("animate", { attributeName: "height", values: `0, ${te}`, dur: "2.5s" })
      )));
    })))
  ), Object.keys(s.confidenceKeys).length > 0 ? r.map((Z) => {
    let se, ye, me, Le = 5;
    return se = t(T(Z)) - 0.75 * s.barHeight, ye = e(O(Z, s.confidenceKeys.upper)), me = e(O(Z, s.confidenceKeys.lower)), /* @__PURE__ */ i.createElement(
      "path",
      {
        key: `confidence-interval-h-${se}-${Z[s.runtime.originalXAxis.dataKey]}`,
        stroke: "#333",
        strokeWidth: "px",
        d: `
                    M${me} ${se - Le}
                    L${me} ${se + Le}
                    M${me} ${se}
                    L${ye} ${se}
                    M${ye} ${se - Le}
                    L${ye} ${se + Le} `
      }
    );
  }) : "");
}, zu = {
  Vertical: uk,
  Horizontal: ck,
  StackedVertical: lk,
  StackedHorizontal: sk
}, dk = ({ xScale: e, yScale: t, seriesScale: n, xMax: a, yMax: r, handleTooltipMouseOver: o, handleTooltipMouseOff: f, handleTooltipClick: u }) => {
  const { transformedData: s, config: d } = ce.useContext(Pt), m = {
    xScale: e,
    yScale: t,
    xMax: a,
    yMax: r,
    seriesScale: n
  };
  return /* @__PURE__ */ i.createElement(Nr, { component: "BarChart" }, /* @__PURE__ */ i.createElement(Os.Provider, { value: m }, /* @__PURE__ */ i.createElement(at, { left: parseFloat(d.runtime.yAxis.size) }, /* @__PURE__ */ i.createElement(zu.StackedVertical, null), /* @__PURE__ */ i.createElement(zu.StackedHorizontal, null), /* @__PURE__ */ i.createElement(zu.Vertical, null), /* @__PURE__ */ i.createElement(zu.Horizontal, null), /* @__PURE__ */ i.createElement(gr, { key: "bars", display: d.tooltips.singleSeries ? "none" : "block", width: Number(a), height: Number(r), fill: "transparent", fillOpacity: 0.05, onMouseMove: (y) => o(y, s), onMouseOut: f, onClick: (y) => u(y, s) }))));
};
function za() {
  return za = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, za.apply(this, arguments);
}
function Di(e) {
  var t = e.x1, n = e.x2, a = e.y1, r = e.y2;
  return {
    x1: a,
    x2: r,
    y1: t,
    y2: n
  };
}
function sy(e) {
  var t = e.left, n = t === void 0 ? 0 : t, a = e.top, r = a === void 0 ? 0 : a, o = e.className, f = e.max, u = e.min, s = e.firstQuartile, d = e.thirdQuartile, m = e.median, y = e.boxWidth, v = y === void 0 ? 10 : y, w = e.fill, E = e.fillOpacity, O = e.stroke, T = e.strokeWidth, g = e.rx, N = g === void 0 ? 2 : g, L = e.ry, M = L === void 0 ? 2 : L, _ = e.valueScale, C = e.outliers, H = C === void 0 ? [] : C, I = e.horizontal, X = e.medianProps, te = X === void 0 ? {} : X, G = e.maxProps, F = G === void 0 ? {} : G, j = e.minProps, U = j === void 0 ? {} : j, W = e.boxProps, re = W === void 0 ? {} : W, J = e.outlierProps, ue = J === void 0 ? {} : J, ee = e.container, Z = ee === void 0 ? !1 : ee, se = e.containerProps, ye = se === void 0 ? {} : se, me = e.children, Le = I ? r : n, de = Le + (v || 0) / 2, ie = _.range(), Ce = _(u ?? 0), He = _(s ?? 0), we = _(m ?? 0), ge = _(d ?? 0), ke = _(f ?? 0), ne = {
    valueRange: ie,
    center: de,
    offset: Le,
    boxWidth: v,
    max: {
      x1: de - (v || 0) / 4,
      x2: de + (v || 0) / 4,
      y1: ke,
      y2: ke
    },
    maxToThird: {
      x1: de,
      x2: de,
      y1: ke,
      y2: ge
    },
    median: {
      x1: Le,
      x2: Le + (v || 0),
      y1: we,
      y2: we
    },
    minToFirst: {
      x1: de,
      x2: de,
      y1: He,
      y2: Ce
    },
    min: {
      x1: de - (v || 0) / 4,
      x2: de + (v || 0) / 4,
      y1: Ce,
      y2: Ce
    },
    box: {
      x1: Le,
      x2: v || 0,
      y1: ge,
      y2: Math.abs(ge - He)
    },
    container: {
      x1: Le,
      x2: v || 0,
      y1: Math.min.apply(Math, ie),
      y2: Math.abs(ie[0] - ie[1])
    }
  };
  return I && (ne.max = Di(ne.max), ne.maxToThird = Di(ne.maxToThird), ne.box.y1 = He, ne.box = Di(ne.box), ne.median = Di(ne.median), ne.minToFirst = Di(ne.minToFirst), ne.min = Di(ne.min), ne.container = Di(ne.container), ne.container.y1 = Math.min.apply(Math, ie)), me ? /* @__PURE__ */ i.createElement(i.Fragment, null, me(ne)) : /* @__PURE__ */ i.createElement(at, {
    className: Pn("visx-boxplot", o)
  }, H.map(function(Pe, $e) {
    var qe = I ? _(Pe) : de, Ge = I ? de : _(Pe);
    return /* @__PURE__ */ i.createElement("circle", za({
      key: "visx-boxplot-outlier-" + $e,
      className: "visx-boxplot-outlier",
      cx: qe,
      cy: Ge,
      r: 4,
      stroke: O,
      strokeWidth: T,
      fill: w,
      fillOpacity: E
    }, ue));
  }), /* @__PURE__ */ i.createElement("line", za({
    className: "visx-boxplot-max",
    x1: ne.max.x1,
    y1: ne.max.y1,
    x2: ne.max.x2,
    y2: ne.max.y2,
    stroke: O,
    strokeWidth: T
  }, F)), /* @__PURE__ */ i.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: ne.maxToThird.x1,
    y1: ne.maxToThird.y1,
    x2: ne.maxToThird.x2,
    y2: ne.maxToThird.y2,
    stroke: O,
    strokeWidth: T
  }), /* @__PURE__ */ i.createElement("rect", za({
    className: "visx-boxplot-box",
    x: ne.box.x1,
    y: ne.box.y1,
    width: ne.box.x2,
    height: ne.box.y2,
    stroke: O,
    strokeWidth: T,
    fill: w,
    fillOpacity: E,
    rx: N,
    ry: M
  }, re)), /* @__PURE__ */ i.createElement("line", za({
    className: "visx-boxplot-median",
    x1: ne.median.x1,
    y1: ne.median.y1,
    x2: ne.median.x2,
    y2: ne.median.y2,
    stroke: O,
    strokeWidth: T
  }, te)), /* @__PURE__ */ i.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: ne.minToFirst.x1,
    y1: ne.minToFirst.y1,
    x2: ne.minToFirst.x2,
    y2: ne.minToFirst.y2,
    stroke: O,
    strokeWidth: T
  }), /* @__PURE__ */ i.createElement("line", za({
    className: "visx-boxplot-min",
    x1: ne.min.x1,
    y1: ne.min.y1,
    x2: ne.min.x2,
    y2: ne.min.y2,
    stroke: O,
    strokeWidth: T
  }, U)), Z && /* @__PURE__ */ i.createElement("rect", za({
    x: ne.container.x1,
    y: ne.container.y1,
    width: ne.container.x2,
    height: ne.container.y2,
    fillOpacity: "0"
  }, ye)));
}
sy.propTypes = {
  max: he.number,
  min: he.number,
  firstQuartile: he.number,
  thirdQuartile: he.number,
  median: he.number,
  boxWidth: he.number,
  fill: he.string,
  fillOpacity: he.oneOfType([he.number, he.string]),
  stroke: he.string,
  strokeWidth: he.oneOfType([he.number, he.string]),
  rx: he.number,
  ry: he.number,
  outliers: he.arrayOf(he.number),
  container: he.bool,
  children: he.func
};
const fk = ({ xScale: e, yScale: t }) => {
  const { config: n, setConfig: a } = ce.useContext(Pt), { boxplot: r } = n;
  ce.useEffect(() => {
    n.legend.hide === !1 && a({
      ...n,
      legend: {
        ...n.legend,
        hide: !0
      }
    });
  }, []);
  const o = `cdc-open-viz-tooltip-${n.runtime.uniqueId}`, f = (T) => `
      <strong>${T.columnCategory}</strong></br>
      ${r.labels.q1}: ${T.columnFirstQuartile}<br/>
      ${r.labels.q3}: ${T.columnThirdQuartile}<br/>
      ${r.labels.iqr}: ${T.columnIqr}<br/>
      ${r.labels.median}: ${T.columnMedian}
    `, u = (T) => Number(T.columnMax), s = (T) => Number(T.columnMin), d = (T) => Number(T.columnMedian), m = (T) => Number(T.columnThirdQuartile), y = (T) => Number(T.columnFirstQuartile), v = 0.5, w = e.bandwidth(), E = Math.min(40, w), O = dr[n == null ? void 0 : n.palette][0] ? dr[n == null ? void 0 : n.palette][0] : "#000";
  return /* @__PURE__ */ i.createElement(Nr, { component: "BoxPlot" }, /* @__PURE__ */ i.createElement(at, { className: "boxplot", key: "boxplot-group" }, r.plots.map((T, g) => {
    const N = w - E, L = 4;
    return /* @__PURE__ */ i.createElement(at, { key: `boxplotplot-${g}` }, r.plotNonOutlierValues && T.nonOutlierValues.map((M, _) => /* @__PURE__ */ i.createElement("circle", { cx: e(T.columnCategory) + Number(n.yAxis.size) + w / 2, cy: t(M), r: L, fill: "#ccc", style: { opacity: 1, fillOpacity: 1, stroke: "black" }, key: `boxplot-${g}--circle-${_}` })), /* @__PURE__ */ i.createElement(
      sy,
      {
        "data-left": e(T.columnCategory) + n.yAxis.size + N / 2 + 0.5,
        key: `box-plot-${g}`,
        min: s(T),
        max: u(T),
        left: Number(e(T.columnCategory)) + Number(n.yAxis.size) + N / 2 + 0.5,
        firstQuartile: y(T),
        thirdQuartile: m(T),
        median: d(T),
        boxWidth: E,
        fill: O,
        fillOpacity: v,
        stroke: "black",
        valueScale: t,
        outliers: r.plotOutlierValues ? T.columnOutliers : [],
        outlierProps: {
          style: {
            fill: `${O}`,
            opacity: 1
          }
        },
        medianProps: {
          style: {
            stroke: "black"
          }
        },
        boxProps: {
          style: {
            stroke: "black",
            strokeWidth: r.borders === "true" ? 1 : 0
          }
        },
        maxProps: {
          style: {
            stroke: "black"
          }
        },
        container: !0,
        containerProps: {
          "data-tooltip-html": f(T),
          "data-tooltip-id": o,
          tabIndex: -1
        }
      }
    ));
  })));
}, hk = ({ xScale: e, yScale: t, getXAxisData: n, getYAxisData: a }) => {
  const { colorScale: r, transformedData: o, config: f, formatNumber: u, seriesHighlight: s, colorPalettes: d } = ce.useContext(Pt), m = 4.5, y = Object.keys(f.runtime.seriesLabels).length > 1, v = Object.entries(f.columns).filter(([E, O]) => O.tooltips).map(([E, O]) => [O.label || O.name, O.name]), w = (E, O) => `<div>
    ${f.legend.showLegendValuesTooltip && f.runtime.seriesLabels && y ? `${f.runtime.seriesLabels[O] || ""}<br/>` : ""}
    ${f.xAxis.label}: ${u(E[f.xAxis.dataKey], "bottom")} <br/>
    ${f.yAxis.label}: ${u(E[O], "left")}<br/>
   ${v.map(([T, g]) => `${T} : ${u(E[g], "left")}<br/>`).join("")}
</div>`;
  return /* @__PURE__ */ i.createElement(at, { className: "scatter-plot", left: f.yAxis.size }, o.map((E, O) => f.runtime.seriesKeys.map((T, g) => {
    const N = f.legend.behavior === "highlight" && s.length > 0 && s.indexOf(T) === -1, L = f.legend.behavior === "highlight" || s.length === 0 || s.indexOf(T) !== -1, M = f.palette ? d[f.palette][g] : "#000";
    let _ = {
      filter: "unset",
      opacity: 1,
      stroke: L ? "black" : ""
    };
    return /* @__PURE__ */ i.createElement(
      "circle",
      {
        key: `${O}-${g}`,
        r: m,
        cx: e(E[f.xAxis.dataKey]),
        cy: t(E[T]),
        fill: L ? M : "transparent",
        fillOpacity: N ? 0.25 : 1,
        style: _,
        "data-tooltip-html": w(E, T),
        "data-tooltip-id": `cdc-open-viz-tooltip-${f.runtime.uniqueId}`,
        tabIndex: -1
      }
    );
  })));
};
function pk({ height: e, xScale: t }) {
  const { transformedData: n, config: a, formatNumber: r, twoColorPalette: o, getTextWidth: f, updateConfig: u, parseDate: s, formatDate: d, currentViewport: m } = ce.useContext(Pt), { barStyle: y, tipRounding: v, roundingStyle: w, twoColor: E } = a, O = ce.useRef([]), [T, g] = ce.useState(window.innerWidth), N = w === "standard" ? "8px" : w === "shallow" ? "5px" : w === "finger" ? "15px" : "0px", L = { small: 16, medium: 18, large: 20 };
  a.barStyle;
  const M = Number(a.xAxis.target), _ = a.series[0].dataKey, C = Number(t.domain()[1]), I = n.some((ee) => ee[_] < 0) || M > 0 || t.domain()[0] < 0, X = a.barHasBorder === "true" ? 1 : 0, te = a.lollipopSize === "large" ? 7 : a.lollipopSize === "medium" ? 6 : 5, G = a.lollipopSize === "large" ? 14 : a.lollipopSize === "medium" ? 12 : 10, F = Math.max(t(0), Math.min(t(M), t(C))), j = (ee) => {
    if (ee == null || y !== "rounded")
      return;
    let Z = {};
    return ee === "left" && (Z = { borderRadius: `${N} 0 0 ${N}` }), ee === "right" && (Z = { borderRadius: `0 ${N} ${N} 0` }), v === "full" && (Z = { borderRadius: N }), Z;
  }, U = {
    calculate: function() {
      const Z = n[0][_] < M ? "left" : "right", se = `${a.xAxis.targetLabel} ${r(a.xAxis.target || 0, "left")}`, ye = f(se, `bold ${L[a.fontSize]}px sans-serif`);
      let me = a.isLollipopChart ? te / 2 : Number(a.barHeight) / 2, Le = 0, de = 0, ie = !1;
      Z === "right" && (Le = -10, ie = ye - Le < F, de = F - ye), Z === "left" && (Le = 10, ie = t(C) - F > ye + Le, de = F), this.text = se, this.y = me, this.x = de, this.padding = Le, this.showLabel = a.xAxis.showTargetLabel ? ie : !1;
    }
  };
  U.calculate();
  const W = ce.useRef(null), re = dh(W, {});
  ce.useEffect(() => {
    const ee = () => {
      var Z;
      g(window.innerWidth), (Z = O.current) == null || Z.forEach((se) => {
        !se || !se.style || (se.style.transition = "none", se.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", ee), () => {
      window.removeEventListener("resize", ee);
    };
  }, []);
  const [J, ue] = ce.useState(!1);
  return ce.useEffect(() => {
    re != null && re.isIntersecting && setTimeout(() => {
      ue(!0);
    }, 100);
  }, [re == null ? void 0 : re.isIntersecting, a.animate]), ce.useEffect(() => {
    var ee;
    (ee = O.current) == null || ee.forEach((Z, se) => {
      if (!(!Z || !Z.style)) {
        if (a.animate) {
          const ye = M / C * 100;
          Z.style.opacity = "0", Z.style.transform = `translate(${ye / 1.07}%) scale(0, 1)`, setTimeout(() => {
            Z.style.opacity = "1", Z.style.transform = "translate(0) scale(1)", Z.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          Z.style.transition = "none", Z.style.opacity = "0";
        a.animate || (Z.style.transition = "none", Z.style.opacity = "1");
      }
    });
  }, [a.animate, a, J]), /* @__PURE__ */ i.createElement(Nr, { component: "Deviation Bar" }, /* @__PURE__ */ i.createElement(at, { left: Number(a.xAxis.size) }, n.map((ee, Z) => {
    const se = Number(ee[_]), ye = a.isLollipopChart ? te : Number(a.barHeight), me = Number(a.barSpace), Le = Math.abs(t(se) - F), de = t(se), ie = se > M ? F : de, Ce = se < M ? "left" : "right";
    let He = 0;
    He = Z !== 0 ? (me + ye + X) * Z : He;
    const we = (me + ye + X) * n.length;
    a.heights.horizontal = we;
    const ke = f(r(se, "left"), `normal ${L[a.fontSize]}px sans-serif`) < Le - 6, ne = de, Pe = He + ye / 2, $e = de, qe = He + ye / 2, Ge = de, Xe = He - ye / 2, We = j(Ce), [vt, et] = o[E.palette], Ke = { left: vt, right: et }, Be = Zo("#000", Ke[Ce]);
    let ze = mk(a.isLollipopChart, ke, G, Be);
    const gt = r(se, "left"), Ye = a.runtime.yAxis.type === "date" ? d(s(n[Z][a.runtime.originalXAxis.dataKey])) : n[Z][a.runtime.originalXAxis.dataKey];
    let dt = a.runtime.yAxis.label ? `${a.runtime.yAxis.label}: ${Ye}` : Ye, xt = a.runtime.xAxis.label ? `${a.runtime.xAxis.label}: ${gt}` : gt;
    const ft = `<div>
          ${dt}<br />
          ${xt}
            </div>`;
    return /* @__PURE__ */ i.createElement(at, { key: `deviation-bar-${a.orientation}-${_}-${Z}` }, /* @__PURE__ */ i.createElement(
      "foreignObject",
      {
        ref: (lt) => {
          O.current[Z] = lt;
        },
        x: ie,
        y: He,
        width: Le,
        height: ye,
        "data-tooltip-html": ft,
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        tabIndex: -1
      },
      /* @__PURE__ */ i.createElement("div", { style: { width: Le, height: ye, border: `${X}px solid #333`, backgroundColor: Ke[Ce], ...We } })
    ), a.yAxis.displayNumbersOnBar && /* @__PURE__ */ i.createElement(Tt, { verticalAnchor: "middle", x: ne, y: Pe, ...ze[Ce] }, r(ee[_], "left")), a.isLollipopChart && a.lollipopShape === "circle" && /* @__PURE__ */ i.createElement("circle", { cx: $e, cy: qe, r: G / 2, fill: Ke[Ce], style: { filter: "unset", opacity: 1 } }), a.isLollipopChart && a.lollipopShape === "square" && /* @__PURE__ */ i.createElement("rect", { x: Ge, y: Xe, width: G, height: G, fill: Ke[Ce], style: { opacity: 1, filter: "unset" } }));
  }), U.showLabel && /* @__PURE__ */ i.createElement(Tt, { fontWeight: "bold", dx: U.padding, verticalAnchor: "middle", x: U.x, y: U.y }, U.text), I && /* @__PURE__ */ i.createElement(an, { from: { x: F, y: 0 }, to: { x: F, y: e }, stroke: "#333", strokeWidth: 2 })), /* @__PURE__ */ i.createElement("foreignObject", { y: e / 2, ref: W }));
}
function mk(e, t, n, a) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: n + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -n,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? a : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? a : "#000000"
    }
  };
}
const gk = ({ xScale: e, yScale: t, height: n, width: a, handleTooltipMouseOver: r, handleTooltipMouseOff: o }) => {
  var E;
  const { transformedData: f, rawData: u, config: s, seriesHighlight: d } = ce.useContext(Pt), { xAxis: m, yAxis: y, legend: v, runtime: w } = s;
  return f && /* @__PURE__ */ i.createElement(Nr, { component: "ForecastingChart" }, /* @__PURE__ */ i.createElement(at, { className: "forecasting-items", key: "forecasting-items-wrapper", left: Number(y.size) }, (E = w.forecastingSeriesKeys) == null ? void 0 : E.map((O, T) => !O || !O.stages ? !1 : O.stages.map((g, N) => {
    var H;
    const { behavior: L } = v, M = u.filter((I) => I[O.stageColumn] === g.key);
    let _ = L === "highlight" && d.length > 0 && d.indexOf(g.key) === -1, C = L === "highlight" || d.length === 0 || d.indexOf(g.key) !== -1;
    return /* @__PURE__ */ i.createElement(at, { className: `forecasting-areas-combo-${T}`, key: `forecasting-areas--stage-${g.key.replaceAll(" ", "-")}-${T}` }, (H = O.confidenceIntervals) == null ? void 0 : H.map((I, X) => {
      const te = Yu[g.color] || dr[g.color] || !1, G = () => C && te[2] ? te[2] : "transparent", F = () => C && te[1] ? te[1] : "transparent";
      if (!(I.high === "" || I.low === ""))
        return /* @__PURE__ */ i.createElement(at, { key: `forecasting-areas--stage-${g.key.replaceAll(" ", "-")}--group-${N}-${X}` }, /* @__PURE__ */ i.createElement(
          J0,
          {
            curve: Wu,
            data: M,
            fill: G(),
            opacity: _ ? 0.1 : 0.5,
            x: (j) => e(Date.parse(j[m.dataKey])),
            y0: (j) => t(j[I.low]),
            y1: (j) => t(j[I.high])
          }
        ), X === 0 && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(qr, { data: M, x: (j) => Number(e(Date.parse(j[m.dataKey]))), y: (j) => Number(t(j[I.high])), curve: Wu, stroke: F(), strokeWidth: 1, strokeOpacity: 1 }), /* @__PURE__ */ i.createElement(qr, { data: M, x: (j) => Number(e(Date.parse(j[m.dataKey]))), y: (j) => Number(t(j[I.low])), curve: Wu, stroke: F(), strokeWidth: 1, strokeOpacity: 1 })));
    }));
  })), /* @__PURE__ */ i.createElement(at, { key: "tooltip-hover-section" }, /* @__PURE__ */ i.createElement(gr, { key: "bars", width: Number(a), height: Number(n), fill: "transparent", fillOpacity: 0.05, onMouseMove: (O) => r(O, f), onMouseOut: o }))));
};
function ju(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
function Nc(e, t) {
  const n = e.series.every(({ type: v }) => v === "Bar"), a = e.series.every(({ type: v }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(v)), r = (v) => (w) => v.reduce((E, O) => isNaN(Number(w[O])) ? E : E + Number(w[O]), 0), o = () => {
    let v = Math.max(...t.map((w) => Math.max(...e.runtime.seriesKeys.map((E) => ju(w[E]) ? Number(s(w[E])) : 0))));
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && n) && e.visualizationSubType === "stacked") {
      const w = t.map(r(e.runtime.seriesKeys)).filter((E) => !isNaN(E));
      v = Math.max(...w);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const w = t.map(r(e.runtime.seriesKeys));
      v = Math.max(...w);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (v = Math.max(...t.map((w) => ju(w[e.series.dataKey]) ? Number(s(w[e.series.dataKey])) : 0))), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !n && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const w = t.map(r(e.runtime.barSeriesKeys)), E = Math.max(...t.map((T) => Math.max(...e.runtime.lineSeriesKeys.map((g) => Number(s(T[g])))))), O = Math.max(...w);
      v = Math.max(O, E);
    }
    return v;
  }, f = () => {
    const v = Math.min(...t.map((w) => Math.min(...e.runtime.seriesKeys.map((E) => ju(w[E]) ? Number(s(w[E])) : 1 / 0))));
    return String(v);
  }, u = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((v) => t.some((w) => w[v] >= 0)) : !1, s = (v) => v === null || v === "" ? "" : typeof v == "string" ? v.replace(/[,$]/g, "") : v, d = Number(o()), m = Number(f()), y = u();
  return { minValue: m, maxValue: d, existPositiveValue: y, isAllLine: a };
}
function gh({ config: e, yMax: t = 0, data: n = [], updateConfig: a }) {
  var v, w, E, O;
  const r = e.visualizationType === "Combo" && e.orientation === "vertical", o = e.series && e.series.filter((T) => T.axis === "Right").map((T) => T.dataKey);
  let { minValue: f } = Nc(e, n);
  const u = (T) => {
    if (!T)
      return [0];
    let g = [];
    return T.map((N, L) => g = [...g, ...n.map((M) => Number(M[N]))]), g;
  };
  let s = Math.max.apply(null, u(o));
  e.yAxis.rightMax > s && (s = e.yAxis.rightMax), e.yAxis.rightMin < f && (f = e.yAxis.rightMin);
  const d = ((w = (v = e.runtime) == null ? void 0 : v.barSeriesKeys) == null ? void 0 : w.length) > 0, m = ((O = (E = e.runtime) == null ? void 0 : E.lineSeriesKeys) == null ? void 0 : O.length) > 0;
  return (d || m) && f > 0 && (f = 0), { yScaleRight: Kn({
    domain: [f, s],
    range: [t, 0]
  }), hasRightAxis: r };
}
const yk = (e) => {
  const { preliminaryData: t, data: n, stroke: a, strokeWidth: r, handleLineType: o, lineType: f, seriesKey: u } = e, s = t.filter((v) => v.seriesKey && v.column && v.value && v.type && v.style && v.type === "effect"), d = (v) => s.find((w) => w.seriesKey === u && v[w.column] === w.value && w.type === "effect" && w.style !== "Open Circles");
  let m = [];
  const y = (v) => ({
    stroke: a,
    strokeWidth: r,
    strokeDasharray: v
  });
  return n.forEach((v, w) => {
    let E = d(v), O = y(o(E ? E.style : f));
    m.push(O), E && w > 0 && (m[w - 1] = y(o(E.style)));
  }), m;
}, vk = (e, t, n) => {
  const a = e == null ? void 0 : e.filter((o) => o.style === "Open Circles" && o.type === "effect").map((o) => ({ column: o.column, value: o.value, seriesKey: o.seriesKey })), r = [];
  return t.forEach((o) => {
    a.forEach((f) => {
      o[f.column] === f.value && f.seriesKey === n && r.push(o);
    });
  }), r;
}, Ec = (e) => !isNaN(parseFloat(e)) && isFinite(e), xk = (e, t, n) => {
  const a = {
    data: [],
    style: ""
  };
  if (!e.length)
    return a;
  const r = e[0], o = (u) => {
    if (u.type !== "effect")
      return u.type == "suppression" && u.value === r[t] && (!u.column || u.column === t);
  }, f = n.find(o);
  if (f && f.style) {
    const u = { ...r, [t]: 0 };
    a.data.push(u), a.style = f.style;
    let s = 1;
    for (; s < e.length && !Ec(e[s][t]); )
      s++;
    s < e.length && a.data.push(e[s]);
  } else
    a.data.push(r);
  return a;
}, bk = (e, t, n) => {
  const a = {
    data: [],
    style: ""
  };
  let r = -1;
  return n == null || n.forEach((o) => {
    if (o.type !== "effect" && e[e.length - 1][t] === o.value && o.style && (!o.column || o.column === t) && o.type == "suppression") {
      const f = e.length - 1, u = { ...e[f], [t]: 0 };
      a.data.push(u);
      let s = f - 1;
      for (; s >= 0 && !Ec(e[s][t]); )
        s--;
      s >= 0 && r !== s && (a.data.push(e[s]), r = s), a.style = o.style;
    }
  }), a;
};
function Sk(e, t, n, a) {
  const r = {
    data: [],
    style: ""
  }, o = (f) => f > 0 && f < e.length - 1;
  return a == null || a.forEach((f) => {
    if (f.type === "effect")
      return;
    const u = f.value;
    e.reduce((d, m, y) => (m[t] === u && o(y) && (!f.column || f.column === t) && d.push(y), d), []).forEach((d) => {
      r.style = f.style, Ec(e[d - 1][t]) && r.data.push(e[d - 1]);
      const m = e.slice(d + 1).findIndex((y) => y[t] !== u && Ec(y[t]));
      m !== -1 && r.data.push(e[d + 1 + m]);
    });
  }), r.data = Ni.uniqWith(r.data, (f, u) => f[n] === u[n] && f[t] === u[t]), r;
}
const Ek = (e, t, n, a) => {
  const r = xk(e, t, n), o = bk(e, t, n), f = Sk(e, t, a, n);
  return [r, f, o].filter((u) => u.data.length > 0 && u.style !== "");
}, Zd = (e) => {
  var M, _, C, H, I, X, te, G;
  const { config: t, d: n, tableData: a, displayArea: r, seriesKey: o, tooltipData: f, xScale: u, yScale: s, colorScale: d, parseDate: m, yScaleRight: y, data: v, circleData: w, dataIndex: E, mode: O } = e, { lineDatapointStyle: T } = t, g = (M = t == null ? void 0 : t.series.filter((F) => F.dataKey === o)) == null ? void 0 : M[0], N = (F, j, U, W, re) => {
    const J = U.runtime.seriesLabels || [];
    let ue;
    return F ? ue = j(J[W] || re) : ue = "transparent", U.lineDatapointColor === "Lighter than Line" && ue !== "transparent" && ue && (ue = Es(ue).brighten(1)), ue;
  }, L = (F) => (t.xAxis.type === "categorical" ? u(F) : u(m(F))) + (u.bandwidth ? u.bandwidth() / 2 : 0);
  if (O === "ALWAYS_SHOW_POINTS") {
    if (T === "hidden")
      return /* @__PURE__ */ i.createElement(i.Fragment, null);
    if (T === "always show")
      return (w == null ? void 0 : w.some((j) => j[t.xAxis.dataKey] === n[t.xAxis.dataKey] && j[o] === n[o])) ? /* @__PURE__ */ i.createElement(i.Fragment, null) : /* @__PURE__ */ i.createElement(
        "circle",
        {
          cx: L(n[t.xAxis.dataKey]),
          cy: g.axis === "Right" ? y(n[g.dataKey]) : s(n[g.dataKey]),
          r: 4.5,
          opacity: n[o] ? 1 : 0,
          fillOpacity: 1,
          fill: N(r, d, t, o, o),
          style: { filter: "unset", opacity: 1 }
        }
      );
  }
  if (O === "HOVER_POINTS" && T === "hover") {
    if (!f || !o || !f.data)
      return;
    let F = (C = (_ = f == null ? void 0 : f.data) == null ? void 0 : _[0]) == null ? void 0 : C[1];
    if (!F)
      return;
    let j, U = f.data.filter((J) => J[0] === o), W = (H = U == null ? void 0 : U[0]) == null ? void 0 : H[0], re = (I = U == null ? void 0 : U[0]) == null ? void 0 : I[2];
    return W ? (f == null || f.data.indexOf(W), j = (X = a == null ? void 0 : a.find((J) => J[t == null ? void 0 : t.xAxis.dataKey] === F)) == null ? void 0 : X[o], f == null ? void 0 : f.data.map((J, ue) => (t.runtime.seriesLabelsAll.indexOf(F), isNaN(j) ? /* @__PURE__ */ i.createElement(i.Fragment, null) : (w == null ? void 0 : w.some((Z) => Z[t.xAxis.dataKey] === F)) ? /* @__PURE__ */ i.createElement(i.Fragment, null) : /* @__PURE__ */ i.createElement(
      "circle",
      {
        cx: L(F),
        cy: re === "right" ? y(j) : s(j),
        r: 4.5,
        opacity: 1,
        fillOpacity: 1,
        fill: N(r, d, t, W, o),
        style: { filter: "unset", opacity: 1 },
        key: `line-chart-circle--${JSON.stringify(J)}--${ue}`
      }
    )))) : void 0;
  }
  return O === "ISOLATED_POINTS" && O && ((j, U) => {
    const W = v[j], re = j > 0 ? v[j - 1] : null, J = j < v.length - 1 ? v[j + 1] : null;
    let ue = !1;
    return j === 0 && J && !J[U] && (ue = !0), j === v.length - 1 && re && !re[U] && (ue = !0), j > 0 && j < v.length - 1 && W && W[U] && (!re || !re[U]) && (!J || !J[U]) && (ue = !0), ue;
  })(E, o) ? /* @__PURE__ */ i.createElement("circle", { cx: L(n[(te = t.xAxis) == null ? void 0 : te.dataKey]), cy: g.axis === "Right" ? y(n[g.dataKey]) : s(n[g == null ? void 0 : g.dataKey]), r: 5.3, strokeWidth: 2, stroke: d(t.runtime.seriesLabels[o]), fill: d((G = t.runtime) == null ? void 0 : G.seriesLabels[o]) }) : null;
}, sm = (e) => {
  var j;
  const {
    getXAxisData: t,
    getYAxisData: n,
    handleTooltipClick: a,
    handleTooltipMouseOff: r,
    handleTooltipMouseOver: o,
    tooltipData: f,
    xMax: u,
    xScale: s,
    yMax: d,
    yScale: m
  } = e, { colorScale: y, config: v, formatNumber: w, handleLineType: E, isNumber: O, parseDate: T, seriesHighlight: g, tableData: N, transformedData: L, updateConfig: M, brushConfig: _, clean: C } = ce.useContext(Pt), { yScaleRight: H } = gh({ config: v, yMax: d, data: L, updateConfig: M });
  if (!o)
    return;
  const { lineDatapointStyle: I, showLineSeriesLabels: X, legend: te } = v;
  let G = L, F = N;
  return _.data.length > 0 && ((j = v.brush) != null && j.active) && (G = C(_.data), F = C(_.data)), /* @__PURE__ */ i.createElement(Nr, { component: "LineChart" }, /* @__PURE__ */ i.createElement(at, { left: Number(v.runtime.yAxis.size) }, " ", (v.runtime.lineSeriesKeys || v.runtime.seriesKeys).map((U, W) => {
    var Le;
    let re = v.series.filter((de) => de.dataKey === U)[0].type;
    const J = v.series.filter((de) => de.dataKey === U), ue = J[0].axis ? J[0].axis : "left";
    let ee = te.behavior === "highlight" || g.length === 0 || g.indexOf(U) !== -1;
    const Z = vk(v == null ? void 0 : v.preliminaryData, F, U);
    let se = yk({ preliminaryData: v.preliminaryData, data: F, stroke: y(v.runtime.seriesLabels[U]), strokeWidth: J[0].weight || 2, handleLineType: E, lineType: re, seriesKey: U });
    const ye = Ek(N, U, v.preliminaryData, v.xAxis.dataKey);
    let me = (de) => s(t(de)) + (s.bandwidth ? s.bandwidth() / 2 : 0);
    return /* @__PURE__ */ i.createElement(
      at,
      {
        key: `series-${U}`,
        opacity: te.behavior === "highlight" && g.length > 0 && g.indexOf(U) === -1 ? 0.5 : 1,
        display: te.behavior === "highlight" || g.length === 0 && !te.dynamicLegend || g.indexOf(U) !== -1 ? "block" : "none"
      },
      G.map((de, ie) => {
        const Ce = v.series.find(({ dataKey: ne }) => ne === U), { axis: He } = Ce, we = Object.keys(v.runtime.seriesLabels).length > 1, ge = He === "Right" ? "rightLabel" : "label";
        let ke = v.runtime.yAxis[ge];
        return we || (ke = v.isLegendValue ? v.runtime.seriesLabels[U] : ke), de[U] !== void 0 && de[U] !== "" && de[U] !== null && O(de[U]) && /* @__PURE__ */ i.createElement(at, { key: `series-${U}-point-${ie}`, className: "checkwidth" }, /* @__PURE__ */ i.createElement(gr, { key: "bars", width: Number(u), height: Number(d), fill: "transparent", fillOpacity: 0.05, onMouseMove: (ne) => o(ne, N), onMouseOut: r, onClick: (ne) => a(ne, G) }), /* @__PURE__ */ i.createElement(Tt, { display: v.labels ? "block" : "none", x: me(de), y: ue === "Right" ? H(n(de, U)) : m(n(de, U)), fill: "#000", textAnchor: "middle" }, w(de[U], "left")), (I === "hidden" || I === "always show") && /* @__PURE__ */ i.createElement(
          Zd,
          {
            mode: "ALWAYS_SHOW_POINTS",
            dataIndex: ie,
            circleData: Z,
            tableData: N,
            data: G,
            d: de,
            config: v,
            seriesKey: U,
            displayArea: ee,
            tooltipData: f,
            xScale: s,
            yScale: m,
            colorScale: y,
            parseDate: T,
            yScaleRight: H,
            seriesAxis: ue,
            key: `line-circle--${ie}`
          }
        ), /* @__PURE__ */ i.createElement(
          Zd,
          {
            mode: "ISOLATED_POINTS",
            dataIndex: ie,
            tableData: N,
            circleData: Z,
            data: G,
            d: de,
            config: v,
            seriesKey: U,
            displayArea: ee,
            tooltipData: f,
            xScale: s,
            yScale: m,
            colorScale: y,
            parseDate: T,
            yScaleRight: H,
            seriesAxis: ue,
            key: `isolated-circle-${ie}`
          }
        ));
      }),
      /* @__PURE__ */ i.createElement(i.Fragment, null, I === "hover" && /* @__PURE__ */ i.createElement(
        Zd,
        {
          tableData: N,
          dataIndex: 0,
          mode: "HOVER_POINTS",
          circleData: Z,
          data: G,
          config: v,
          seriesKey: U,
          displayArea: ee,
          tooltipData: f,
          xScale: s,
          yScale: m,
          colorScale: y,
          parseDate: T,
          yScaleRight: H,
          seriesAxis: ue
        }
      )),
      (Le = v == null ? void 0 : v.preliminaryData) != null && Le.some((de) => de.value && de.type) ? /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
        Mg,
        {
          curve: Ss[J[0].lineType],
          segments: G.map((de) => [de]),
          segmentation: "x",
          x: (de) => me(de),
          y: (de) => ue === "Right" ? H(n(de, U)) : m(Number(n(de, U))),
          styles: se,
          defined: (de, ie) => de[U] !== "" && de[U] !== null && de[U] !== void 0
        }
      ), ye.map((de, ie) => /* @__PURE__ */ i.createElement(
        qr,
        {
          key: ie,
          data: de.data,
          x: (Ce) => me(Ce),
          y: (Ce) => ue === "Right" ? H(n(Ce, U)) : m(Number(n(Ce, U))),
          stroke: y(v.runtime.seriesLabels[U]),
          strokeWidth: J[0].weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: E(de.style),
          defined: (Ce, He) => Ce[U] !== "" && Ce[U] !== null && Ce[U] !== void 0
        }
      ))) : /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
        qr,
        {
          curve: Ss[J[0].lineType],
          data: v.xAxis.type === "date-time" ? G.sort((de, ie) => {
            let Ce = t(de), He = t(ie);
            return Ce < He ? -1 : He < Ce ? 1 : 0;
          }) : G,
          x: (de) => me(de),
          y: (de) => ue === "Right" ? H(n(de, U)) : m(Number(n(de, U))),
          stroke: y(v.runtime.seriesLabels[U]),
          strokeWidth: J[0].weight || 2,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: re ? E(re) : 0,
          defined: (de, ie) => de[U] !== "" && de[U] !== null && de[U] !== void 0
        }
      )),
      Z.map((de, ie) => /* @__PURE__ */ i.createElement(
        "circle",
        {
          key: ie,
          cx: me(de),
          cy: ue === "Right" ? H(n(de, U)) : m(Number(n(de, U))),
          r: 6,
          strokeWidth: J[0].weight || 2,
          stroke: y ? y(v.runtime.seriesLabels[U]) : "#000",
          fill: "#fff"
        }
      )),
      v.animate && /* @__PURE__ */ i.createElement(
        qr,
        {
          className: "animation",
          curve: Ss[J[0].lineType],
          data: G,
          x: (de) => me(de),
          y: (de) => ue === "Right" ? H(n(de, U)) : m(Number(n(de, U))),
          stroke: "#fff",
          strokeWidth: 3,
          strokeOpacity: 1,
          shapeRendering: "geometricPrecision",
          strokeDasharray: re ? E(re) : 0,
          defined: (de, ie) => de[U] !== "" && de[U] !== null && de[U] !== void 0
        }
      ),
      X && (v.runtime.lineSeriesKeys || v.runtime.seriesKeys).map((de) => {
        let ie;
        for (let Ce = G.length - 1; Ce >= 0; Ce--)
          if (G[Ce][de]) {
            ie = G[Ce];
            break;
          }
        return ie ? /* @__PURE__ */ i.createElement("text", { x: me(ie) + 5, y: m(n(ie, de)), alignmentBaseline: "middle", fill: v.colorMatchLineSeriesLabels && y ? y(v.runtime.seriesLabels[de] || de) : "black" }, v.runtime.seriesLabels[de] || de) : /* @__PURE__ */ i.createElement(i.Fragment, null);
      })
    );
  }), v.legend.dynamicLegend && g.length === 0 && /* @__PURE__ */ i.createElement(Tt, { x: u / 2, y: d / 2, fill: "black", textAnchor: "middle", color: "black" }, v.legend.dynamicLegendChartMessage)));
}, kk = (e) => {
  const { rawData: t, updateConfig: n } = ce.useContext(Pt), { xScale: a, yScale: r, config: o, height: f, width: u, handleTooltipMouseOff: s, handleTooltipMouseOver: d } = e, { forestPlot: m } = o, y = o.xAxis.tickWidthMax + 10, [v, w] = ce.useState(!1);
  ce.useEffect(() => {
    try {
      const M = ["estimateField", "lower", "upper", "estimateRadius"], _ = o, C = 10;
      for (let H = 0; H < C; H++)
        M.forEach((I) => {
          var X;
          o.forestPlot[I] && o.forestPlot[I] !== ((X = _.columns[o.forestPlot[`additionalColumn${H}`]]) == null ? void 0 : X.name) && (delete _.columns[`additionalColumn${H}`], _.columns[o.forestPlot[I]] = {}, _.columns[o.forestPlot[I]].dataKey = _.forestPlot[I], _.columns[o.forestPlot[I]].name = _.forestPlot[I], _.columns[o.forestPlot[I]].dataTable = !0, _.columns[o.forestPlot[I]].tooltips = !0, _.columns[o.forestPlot[I]].label = _.forestPlot[I]);
        });
      o.forestPlot.radius.scalingColumn && (_.columns[o.forestPlot.radius.scalingColumn] = {}, _.columns[o.forestPlot.radius.scalingColumn].dataKey = _.forestPlot.radius.scalingColumn, _.columns[o.forestPlot.radius.scalingColumn].name = _.forestPlot.radius.scalingColumn, _.columns[o.forestPlot.radius.scalingColumn].label = _.forestPlot.radius.scalingColumn, _.columns[o.forestPlot.radius.scalingColumn].dataTable = !0, _.columns[o.forestPlot.radius.scalingColumn].tooltips = !0), _.table.showVertical && (_.table.indexLabel = o.xAxis.dataKey), n(_);
    } catch (M) {
      console.log(M.message);
    }
  }, []), ce.useEffect(() => {
    !v && o.forestPlot.type === "Logarithmic" && (n({
      ...o,
      dataFormat: {
        ...o.dataFormat,
        roundTo: 2
      }
    }), w(!0));
  }, [o.forestPlot.type]);
  const E = o.data.find((M) => M[o.xAxis.dataKey] === o.forestPlot.pooledResult.column), O = E ? [
    { x: a(E[o.forestPlot.lower]), y: f - Number(o.forestPlot.rowHeight) },
    { x: a(E[o.forestPlot.estimateField]), y: f - m.pooledResult.diamondHeight - Number(o.forestPlot.rowHeight) },
    { x: a(E[o.forestPlot.upper]), y: f - Number(o.forestPlot.rowHeight) },
    { x: a(E[o.forestPlot.estimateField]), y: f + m.pooledResult.diamondHeight - Number(o.forestPlot.rowHeight) },
    { x: a(E[o.forestPlot.lower]), y: f - Number(o.forestPlot.rowHeight) }
  ] : [], T = o.forestPlot.rowHeight, g = [
    { x: 0, y: T },
    { x: u, y: T }
  ], N = [
    { x: 0, y: f },
    { x: u, y: f }
  ], L = Object.entries(o.columns).map((M) => M[1]).filter((M) => M.forestPlot === !0);
  return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(at, { width: u }, m.title && /* @__PURE__ */ i.createElement(Tt, { className: "forest-plot--title", x: m.type === "Linear" ? a(0) : a(1), y: 0, textAnchor: "middle", verticalAnchor: "start", fontSize: Ci(o.fontSize), fill: "black" }, m.title), m.lineOfNoEffect.show && m.type === "Linear" && /* @__PURE__ */ i.createElement(an, { from: { x: a(0), y: 0 + T }, to: { x: a(0), y: f }, className: "forestplot__line-of-no-effect", stroke: m.regression.baseLineColor || "black" }), m.lineOfNoEffect.show && m.type === "Logarithmic" && /* @__PURE__ */ i.createElement(an, { from: { x: a(1), y: 0 + T }, to: { x: a(1), y: f }, className: "forestplot__line-of-no-effect", stroke: m.regression.baseLineColor || "black" }), t.map((M, _) => {
    const C = Kn({
      domain: t.map((F) => F[m.radius.scalingColumn]),
      range: [m.radius.min, m.radius.max]
    }), H = m.radius.scalingColumn !== "" ? C(t[_][m.radius.scalingColumn]) : 4, I = m.colors.shape ? m.colors.shape : "black", X = m.colors.line ? m.colors.line : "black", te = 4;
    return M[o.xAxis.dataKey] === m.pooledResult.column ? /* @__PURE__ */ i.createElement(qr, { data: O, x: (F) => F.x, y: (F) => F.y - Ci(o.fontSize) / 2, stroke: "black", strokeWidth: 2, fill: "black", curve: cf }) : /* @__PURE__ */ i.createElement(at, null, /* @__PURE__ */ i.createElement(
      "path",
      {
        stroke: X,
        strokeWidth: 1,
        className: "lower-ci",
        d: `
                    M${a(M[m.lower])} ${r(_) - Number(te)}
                    L${a(M[m.lower])} ${r(_) + Number(te)}
                `
      }
    ), /* @__PURE__ */ i.createElement(
      "path",
      {
        stroke: X,
        strokeWidth: 1,
        className: "upper-ci",
        d: `
                    M${a(M[m.upper])} ${r(_) - Number(te)}
                    L${a(M[m.upper])} ${r(_) + Number(te)}
                `
      }
    ), /* @__PURE__ */ i.createElement("line", { stroke: X, className: `line-${M[o.yAxis.dataKey]}`, key: _, x1: a(M[m.lower]), x2: a(M[m.upper]), y1: r(_), y2: r(_) }), m.shape === "circle" && /* @__PURE__ */ i.createElement(By, { className: "forest-plot--circle", cx: a(Number(M[m.estimateField])), cy: r(_), r: m.radius.scalingColumn !== "" ? C(t[_][m.radius.scalingColumn]) : 4, fill: I, style: { opacity: 1, filter: "unset" } }), m.shape === "square" && /* @__PURE__ */ i.createElement("rect", { className: "forest-plot--square", x: a(Number(M[m.estimateField])), y: r(_) - H / 2, width: H, height: H, fill: I, style: { opacity: 1, filter: "unset" } }), m.shape === "text" && /* @__PURE__ */ i.createElement(Tt, { className: "forest-plot--text", x: a(Number(M[m.estimateField])), y: r(_), textAnchor: "middle", verticalAnchor: "middle", fontSize: Ci(o.fontSize), fill: I }, M[m.estimateField]));
  }), O && m.regression.showDiamond && /* @__PURE__ */ i.createElement(qr, { data: O, x: (M) => M.x, y: (M) => M.y, stroke: "black", strokeWidth: 2, fill: m.regression.baseLineColor, curve: cf }), m.regression.description && /* @__PURE__ */ i.createElement(Tt, { x: 0 - Number(o.xAxis.size), width: u, y: f - o.forestPlot.rowHeight - Number(m.rowHeight) / 3, verticalAnchor: "start", textAnchor: "start", style: { fontWeight: "bold", fontSize: 12 } }, m.regression.description), /* @__PURE__ */ i.createElement(gr, { key: "forest-plot-tooltip-area", className: "forest-plot-tooltip-area", width: u, height: f, fill: "transparent", fillOpacity: 0.5, onMouseMove: (M) => d(M, t), onMouseOut: s })), /* @__PURE__ */ i.createElement(an, { from: g[0], to: g[1], style: { stroke: "black", strokeWidth: 2 }, className: "forestplot__top-line" }), /* @__PURE__ */ i.createElement(an, { from: N[0], to: N[1], style: { stroke: "black", strokeWidth: 2 }, className: "forestplot__bottom-line" }), L.map((M) => t.map((_, C) => /* @__PURE__ */ i.createElement(Tt, { className: `${_[M.name]}`, x: M.forestPlotAlignRight ? u : M.forestPlotStartingPoint, y: r(C), textAnchor: M.forestPlotAlignRight ? "end" : "start", verticalAnchor: "middle", fontSize: Ci(o.fontSize), fill: "black" }, _[M.name]))), !m.hideDateCategoryCol && t.map((M, _) => /* @__PURE__ */ i.createElement(Tt, { className: `${M[o.xAxis.dataKey]}`, x: 0, y: r(_), textAnchor: "start", verticalAnchor: "middle", fontSize: Ci(o.fontSize), fill: "black" }, M[o.xAxis.dataKey])), !m.hideDateCategoryCol && o.xAxis.dataKey && /* @__PURE__ */ i.createElement(Tt, { className: o.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fontSize: Ci(o.fontSize), fill: "black" }, o.xAxis.dataKey), L.map((M) => /* @__PURE__ */ i.createElement(Tt, { className: `${M.label}`, x: M.forestPlotAlignRight ? u : M.forestPlotStartingPoint, y: 0, textAnchor: M.forestPlotAlignRight ? "end" : "start", verticalAnchor: "start", fontSize: Ci(o.fontSize), fill: "black" }, M.label)), m.leftLabel && /* @__PURE__ */ i.createElement(Tt, { className: "forest-plot__left-label", x: m.type === "Linear" ? a(0) - 25 : a(1) - 25, y: f + y, textAnchor: "end", verticalAnchor: "start" }, m.leftLabel), m.rightLabel && /* @__PURE__ */ i.createElement(Tt, { className: "forest-plot__right-label", x: m.type === "Linear" ? a(0) + 25 : a(1) + 25, y: f + y, textAnchor: "start", verticalAnchor: "start" }, m.rightLabel));
}, wk = ({ width: e, height: t, originalWidth: n }) => {
  var L;
  const { config: a, colorScale: r, transformedData: o, formatNumber: f, seriesHighlight: u, getTextWidth: s } = ce.useContext(Pt);
  if (!a || ((L = a == null ? void 0 : a.series) == null ? void 0 : L.length) < 2)
    return;
  const d = a.barHasBorder === "true" ? 1 : 0, m = e / 2, y = { small: 16, medium: 18, large: 20 }, v = 1.02, w = {
    parentKey: a.dataDescription.seriesKey,
    dataKey: a.series[0].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[0].dataKey] || a.series[0].dataKey,
    color: r(a.runtime.seriesLabels[a.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((M) => M[a.series[0].dataKey])
    ),
    labelColor: ""
  }, E = {
    parentKey: a.dataDescription.seriesKey,
    dataKey: a.series[1].dataKey,
    dataKeyLabel: a.runtime.seriesLabels[a.series[1].dataKey] || a.series[1].dataKey,
    color: r(a.runtime.seriesLabels[a.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((M) => M[a.series[1].dataKey])
    ),
    labelColor: ""
  }, O = Kn({
    domain: [0, Math.max(w.max * v, E.max * 1.1)],
    range: [0, m]
  });
  w.labelColor = w.color ? Zo("#000", w.color) : "#000", E.labelColor = E.color ? Zo("#000", E.color) : "#000";
  const T = a.yAxis.label ? `${a.yAxis.label}: ` : "", g = (M) => `<p>
				${a.dataDescription.seriesKey}: ${w.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${M[a.xAxis.dataKey]}<br/>
				${T}${f(M[w.dataKey], "left")}
			</p>`, N = (M) => `<p>
				${a.dataDescription.seriesKey}: ${E.dataKeyLabel}<br/>
				${a.xAxis.dataKey}: ${M[a.xAxis.dataKey]}<br/>
				${T}${f(M[E.dataKey], "left")}
			</p>`;
  return e > 0 && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("style", null, `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				`), /* @__PURE__ */ i.createElement("svg", { id: "cdc-visualization__paired-bar-chart", width: n, height: t, viewBox: `0 0 ${e + Number(a.runtime.yAxis.size)} ${t}`, role: "img", tabIndex: 0 }, /* @__PURE__ */ i.createElement("title", null, `Paired bar chart graphic with the title ${a.title ? a.title : "No Title Found"}`), /* @__PURE__ */ i.createElement(at, { top: 0, left: Number(a.xAxis.size) }, o.filter((M) => a.series[0].dataKey === w.dataKey).map((M, _) => {
    let C = a.legend.behavior === "highlight" && u.length > 0 && u.indexOf(a.series[0].dataKey) === -1, H = a.legend.behavior === "highlight" || u.length === 0 || u.indexOf(a.series[0].dataKey) !== -1, I = O(M[a.series[0].dataKey]), X = Number(a.barHeight) ? Number(a.barHeight) : 25, te = 0;
    te = _ !== 0 ? (Number(a.barSpace) + X + d) * _ : te;
    const G = (Number(a.barSpace) + X + d) * o.length;
    a.heights.horizontal = G;
    const j = s(f(M[w.dataKey], "left"), `normal ${y[a.fontSize]}px sans-serif`) < I - 5;
    return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(at, { key: `group-${w.dataKey}-${M[a.xAxis.dataKey]}`, className: "horizontal" }, /* @__PURE__ */ i.createElement(
      gr,
      {
        id: `bar-${w.dataKey}-${M[a.dataDescription.xKey]}`,
        className: "bar group-1",
        key: `bar-${w.dataKey}-${M[a.dataDescription.xKey]}`,
        x: m - I,
        y: te,
        width: O(M[a.series[0].dataKey]),
        height: X,
        fill: w.color,
        "data-tooltip-html": g(M),
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        stroke: "#333",
        strokeWidth: d,
        opacity: C ? 0.5 : 1,
        display: H ? "block" : "none",
        tabIndex: -1
      }
    ), a.yAxis.displayNumbersOnBar && H && /* @__PURE__ */ i.createElement(Tt, { textAnchor: j ? "start" : "end", dx: j ? 5 : -5, verticalAnchor: "middle", x: m - I, y: te + a.barHeight / 2, fill: j ? w.labelColor : "#000" }, f(M[w.dataKey], "left"))));
  }), o.filter((M) => a.series[1].dataKey === E.dataKey).map((M, _) => {
    let C = O(M[a.series[1].dataKey]), H = a.legend.behavior === "highlight" && u.length > 0 && u.indexOf(a.series[1].dataKey) === -1, I = a.legend.behavior === "highlight" || u.length === 0 || u.indexOf(a.series[1].dataKey) !== -1, X = a.barHeight ? Number(a.barHeight) : 25, te = 0;
    te = _ !== 0 ? (Number(a.barSpace) + X + d) * _ : te;
    const G = (Number(a.barSpace) + X + d) * o.length;
    a.heights.horizontal = G;
    const j = s(f(M[E.dataKey], "left"), `normal ${y[a.fontSize]}px sans-serif`) < C - 5;
    return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("style", null, `
                      .bar-${E.dataKey}-${M[a.xAxis.dataKey]} {
                          transform-origin: ${m}px ${te}px
                      }
							      `), /* @__PURE__ */ i.createElement(at, { key: `group-${E.dataKey}-${M[a.dataDescription.xKey]}`, className: "horizontal" }, /* @__PURE__ */ i.createElement(
      gr,
      {
        id: `bar-${E.dataKey}-${M[a.dataDescription.xKey]}`,
        className: "bar group-2",
        key: `bar-${E.dataKey}-${M[a.dataDescription.xKey]}`,
        x: m,
        y: te,
        width: O(M[a.series[1].dataKey]),
        height: X,
        fill: E.color,
        "data-tooltip-html": N(M),
        "data-tooltip-id": `cdc-open-viz-tooltip-${a.runtime.uniqueId}`,
        strokeWidth: d,
        stroke: "#333",
        opacity: H ? 0.5 : 1,
        display: I ? "block" : "none",
        tabIndex: -1
      }
    ), a.yAxis.displayNumbersOnBar && I && /* @__PURE__ */ i.createElement(Tt, { textAnchor: j ? "end" : "start", dx: j ? -5 : 5, verticalAnchor: "middle", x: m + C, y: te + a.barHeight / 2, fill: j ? E.labelColor : "#000" }, f(M[E.dataKey], "left"))));
  }))));
}, uy = ({ config: e, minValue: t, maxValue: n, existPositiveValue: a, data: r, isAllLine: o, tableData: f }) => {
  let u = 0, s = 0, d = 0, m = 0;
  if (!r)
    return { min: u, max: s };
  const y = () => al(e.visualizationType, r, e.allowLineToBarGraph), { visualizationType: v, series: w } = e, { max: E, min: O } = e.runtime.yAxis, T = a ? E >= n : E >= 0, g = e.useLogScale ? O >= 0 : O <= 0 && t >= 0 || O <= t && t < 0;
  u = O && g ? O : t, s = E && T ? E : Number.MIN_VALUE;
  const { lower: N, upper: L } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (N && L && e.visualizationType === "Bar") {
    const M = u < 0 ? 1.1 : 0;
    s = Math.max(n, Math.max(...r.flatMap((_) => [_[L], _[N]])) * 1.15), u = Math.min(t, Math.min(...r.flatMap((_) => [_[L], _[N]])) * 1.15) * M;
  }
  if (e.series.filter((M) => (M == null ? void 0 : M.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: M }
    } = e;
    if ((M == null ? void 0 : M.length) > 0) {
      let _ = [];
      M.forEach((X) => {
        var te;
        (te = X.confidenceIntervals) == null || te.map((G) => {
          _.push(G.high), _.push(G.low);
        });
      });
      const C = r.map((X) => _.map((te) => X[te])), H = Math.max.apply(
        null,
        C.map((X) => X[0])
      ), I = Math.min.apply(
        null,
        C.map((X) => X[1])
      );
      H > s && (s = H), I < u && (u = I);
    }
  }
  if (v === "Combo")
    try {
      if (!r)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let M = w.filter((H) => H.axis === "Left"), _ = w.filter((H) => H.axis === "Right");
      const C = (H, I, X, te = "left") => {
        let G = 0;
        return (I.map((j) => j.dataKey) || []).forEach((j) => {
          let U = I.find((J) => J.dataKey === j), W = H.map((J) => J[j]), re = Math.max.apply(null, W);
          e.visualizationSubType === "stacked" && te === "left" && U.type === "Bar" && (G += re), re > X && (X = re), X < G && (X = G);
        }), X;
      };
      d = C(r, M, d, "left"), m = C(r, _, m, "right"), d < E && (d = E);
    } catch (M) {
      console.error(M.message);
    }
  if ((v === "Bar" || y() || v === "Combo" && !o) && u > 0 && (u = 0), (e.visualizationType === "Bar" || y() || e.visualizationType === "Combo" && !o) && u < 0 && (u = u * 1.1), e.visualizationType === "Combo" && o && ((O == null || O === "") && u > 0 && (u = 0), O)) {
    const M = e.useLogScale ? O >= 0 && O < t : O < t;
    u = O && M ? O : t;
  }
  if (e.visualizationType === "Deviation Bar" && u > 0) {
    const M = Number(O) < Math.min(t, Number(e.xAxis.target));
    u = O && M ? O : 0;
  }
  if (e.visualizationType === "Line" && !y()) {
    const M = e.useLogScale ? O >= 0 && O < t : O < t, _ = f == null ? void 0 : f.some((C, H) => {
      var I;
      return (I = e.preliminaryData) == null ? void 0 : I.some((X) => {
        var j;
        if (X.type !== "suppression" || !X.style)
          return !1;
        const te = Ni.pick(C, (j = e.runtime) == null ? void 0 : j.seriesKeys), G = Ni.values(te).includes(X.value);
        return (X.column ? C[X.column] === X.value : G) && (H === 0 || H === f.length - 1);
      });
    });
    u = O && M ? O : _ ? 0 : t;
  }
  if (s === Number.MIN_VALUE && (s = a ? n : 0), e.runtime.yAxis.paddingPercent) {
    let M = (s - u) * e.runtime.yAxis.paddingPercent;
    u -= M, s += M;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const M = r.map((C) => C[e.series[0].dataKey]), _ = Math.max(...M).toString().length;
    switch (!0) {
      case (_ > 8 && _ <= 12):
        s = s * 1.3;
        break;
      case (_ > 4 && _ <= 7):
        s = s * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (u < 0 ? (s *= 1 + e.yAxis.scalePadding * 2 / 100, u *= 1 + e.yAxis.scalePadding * 2 / 100) : s *= 1 + e.yAxis.scalePadding / 100), { min: u, max: s, leftMax: d, rightMax: m };
}, jr = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, Tk = (e) => {
  let { xAxisDataMapped: t, xMax: n, yMax: a, min: r, max: o, config: f, data: u } = e;
  const { rawData: s, dimensions: d } = ce.useContext(Pt), [m, y] = d, v = f.runtime.barSeriesKeys || f.runtime.seriesKeys, w = f.runtime.xAxis.type, E = f.orientation === "horizontal", O = (X) => X[f.runtime.originalXAxis.dataKey], T = u.map((X) => O(X)), { visualizationType: g } = f;
  let N = null, L = null, M = null, _ = null, C = null, H = null, I = null;
  if (E && (N = Ak({ min: r * 1.03, ...e }), N.type = f.useLogScale ? jr.LOG : jr.LINEAR, L = Lk(w, t), L.rangeRound([0, a]), C = um(v, [0, a])), E || (I = um(T, [0, n], 0.5), N = Qd(t, [0, n], 1 - f.barThickness), L = Pk(e), C = Qd(v, [0, N.bandwidth()], 0)), f.xAxis.type === "date-time") {
    let X = Math.min(...t), te = Math.max(...t);
    X -= (f.xAxis.padding ? f.xAxis.padding * 0.01 : 0) * (te - X), te += (f.xAxis.padding ? f.xAxis.padding * 0.01 : 0) * (te - X), N = kv({
      domain: [X, te],
      range: [0, n]
    }), N.type = jr.TIME, C = Qd(v, [0, f.barThickness * n], 0);
  }
  if (f.visualizationType === "Deviation Bar") {
    const X = f.isLollipopChart ? 1.05 : 1.03;
    L = nf({
      domain: t,
      range: [0, a]
    }), N = Kn({
      domain: [r * X, Math.max(Number(f.xAxis.target), o)],
      range: [0, n],
      round: !0,
      nice: !0
    }), N.type = jr.LINEAR;
  }
  if (f.visualizationType === "Scatter Plot" && f.xAxis.type === "continuous" && (N = Kn({
    domain: [0, Math.max.apply(null, N.domain())],
    range: [0, n]
  }), N.type = jr.LINEAR), g === "Box Plot") {
    const X = [];
    if (f.boxplot.plots.map((j) => j.columnOutliers.map((U) => X.push(U))) && !f.boxplot.hideOutliers) {
      let j = Math.min(...X), U = Math.max(...X);
      j < r && (r = j), U > o && (o = U);
    }
    let G = Math.min(...f.boxplot.plots.map((j) => j.columnLowerBounds)), F = Math.max(...f.boxplot.plots.map((j) => j.columnUpperBounds));
    G < r && (r = G), F > o && (o = F), L = Kn({
      range: [a, 0],
      round: !0,
      domain: [r, o]
    }), N = nf({
      range: [0, n],
      round: !0,
      domain: f.boxplot.categories,
      padding: 0.4
    }), N.type = jr.BAND;
  }
  if (g === "Paired Bar") {
    let te = Math.max.apply(
      Math,
      u.map((F) => {
        var j;
        return F[(j = f.series[0]) == null ? void 0 : j.dataKey];
      })
    ), G = Math.max.apply(
      Math,
      u.map((F) => {
        var j;
        return F[(j = f.series[1]) == null ? void 0 : j.dataKey];
      })
    );
    _ = Kn({
      domain: [0, Math.max(te, G) * 1.02],
      range: [n / 2, 0]
    }), M = Kn({
      domain: _.domain(),
      range: [n / 2, n],
      nice: !0
    });
  }
  if (g === "Forest Plot") {
    const X = () => f.forestPlot.regression.showDiamond || f.forestPlot.regression.description ? [0 + f.forestPlot.rowHeight * 2, a - f.forestPlot.rowHeight] : [0 + f.forestPlot.rowHeight * 2, a];
    L = Kn({
      domain: [0, s.length],
      range: X()
    });
    const te = 5, G = Number(f.forestPlot.leftWidthOffset) / 100 * n, F = Number(f.forestPlot.rightWidthOffset) / 100 * n, j = Number(f.forestPlot.rightWidthOffsetMobile) / 100 * n, U = Number(f.forestPlot.leftWidthOffsetMobile) / 100 * n;
    if (m > 480) {
      if (f.forestPlot.type === "Linear" && (N = Kn({
        domain: [Math.min(...u.map((W) => parseFloat(W[f.forestPlot.lower]))) - te, Math.max(...u.map((W) => parseFloat(W[f.forestPlot.upper]))) + te],
        range: [G, d[0] - F]
      }), N.type = jr.LINEAR), f.forestPlot.type === "Logarithmic") {
        let W = Math.max(...u.map((J) => parseFloat(J[f.forestPlot.upper]))), re = Math.min(...u.map((J) => parseFloat(J[f.forestPlot.lower])));
        N = qu({
          domain: [re, W],
          range: [G, n - F],
          nice: !0
        }), N.type = jr.LOG;
      }
    } else if (f.forestPlot.type === "Linear" && (N = Kn({
      domain: [Math.min(...u.map((W) => parseFloat(W[f.forestPlot.lower]))) - te, Math.max(...u.map((W) => parseFloat(W[f.forestPlot.upper]))) + te],
      range: [U, n - j],
      type: jr.LINEAR
    })), f.forestPlot.type === "Logarithmic") {
      let W = Math.max(...u.map((J) => parseFloat(J[f.forestPlot.upper]))), re = Math.min(...u.map((J) => parseFloat(J[f.forestPlot.lower])));
      N = qu({
        domain: [re, W],
        range: [G, n - F],
        nice: !0,
        base: W > 1 ? 10 : 2,
        round: !1,
        type: jr.LOG
      });
    }
  }
  return { xScale: N, yScale: L, seriesScale: C, g1xScale: _, g2xScale: M, xScaleNoPadding: H, xScaleBrush: I };
}, Ck = (e, t, n) => {
  const a = t.domain();
  if (t.type === "time") {
    const r = e[e.length - 1], o = e[0], f = (r - o) / (n - 1), u = [];
    for (let s = r; s >= o; s -= f)
      u.push(s);
    return u[u.length - 1] !== o && u.push(o), u.reverse(), u;
  }
  if (a.length > 2) {
    const r = n || 1, o = [];
    for (let f = a.length; f > 0; f -= r) {
      const u = Math.max(Math.round(f) - 1, 0);
      o.push(a[u]);
    }
    return o.reverse(), o;
  }
}, Ak = ({ min: e, max: t, xMax: n, config: a }) => (e = a.useLogScale && e >= 0 && e < 1 ? e + 0.1 : e, (a.useLogScale ? qu : Kn)({
  domain: [e, t],
  range: [0, n],
  nice: a.useLogScale,
  zero: a.useLogScale
})), Pk = ({ min: e, max: t, yMax: n, config: a, leftMax: r }) => {
  e = a.useLogScale && e >= 0 && e < 1 ? e + 0.1 : e;
  const o = a.useLogScale ? qu : Kn;
  return a.visualizationType === "Combo" && (t = r), o({
    domain: [e, t],
    range: [n, 0],
    nice: a.useLogScale,
    zero: a.useLogScale
  });
}, Lk = (e, t) => e === "date" ? Kn({
  domain: [Math.min(...t), Math.max(...t)]
}) : Yo({ domain: t, padding: 0.5 }), um = (e, t, n = 0) => Yo({
  domain: e,
  range: t,
  padding: n
}), Qd = (e, t, n = 0) => nf({
  domain: e,
  range: t,
  padding: n
});
function Rk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const Ms = () => {
  const { config: e } = ce.useContext(Pt), { visualizationType: t, series: n, orientation: a, visualizationSubType: r } = e, o = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], f = ["theme-blue", "theme-purple", "theme-brown", "theme-teal", "theme-pink", "theme-orange", "theme-slate", "theme-indigo", "theme-cyan", "theme-green", "theme-amber"], u = () => !["Forest Plot", "Sankey"].includes(t), s = () => !["Spark Line"].includes(t), d = () => !["Spark Line"].includes(t), m = () => !["Area Chart", "Box Plot", "Pie", "Scatter Plot", "Forest Plot", "Spark Line", "Sankey"].includes(t), y = () => !["Area Chart", "Scatter Plot", "Box Plot", "Forest Plot", "Spark Line", "Sankey"].includes(t), v = () => {
    switch (t) {
      case "Box Plot":
        return !1;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, w = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), E = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, O = () => {
    if ((t === "Bar" || "Combo") && r === "regular")
      return !0;
  }, T = () => ["Line", "Bar", "Area Chart", "Combo"].includes(t) && a === "vertical", g = () => ["Box Plot", "Scatter Plot", "Pie"].includes(t) ? !1 : n == null ? void 0 : n.some(($e) => $e.type === "Bar" || $e.type === "Paired Bar" || $e.type === "Deviation Bar"), N = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, L = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: o,
    headerColors: f,
    visCanAnimate: y,
    visHasAnchors: E,
    visHasBarBorders: g,
    visHasDataCutoff: N,
    visHasLabelOnData: m,
    visHasDataSuppression: O,
    visHasLegend: v,
    visHasLegendAxisAlign: () => t === "Bar" && r === "stacked" && e.legend.behavior === "isolate",
    visHasBrushChart: T,
    visHasNumbersOnBars: w,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : a === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxis: u,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: d,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => (e == null || e.series.some((Pe) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(Pe == null ? void 0 : Pe.type)), t === "Line" || t === "Bar" && r === "regular" || t === "Combo"),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: s,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: L,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const Pe = ["Forest Plot"];
      return !(a === "horizontal" || Pe.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t) || t === "Bar" && e.tooltips.singleSeries)
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t)
  };
};
var yh = {};
const Dk = /* @__PURE__ */ jf(NS), Ok = /* @__PURE__ */ jf(jS);
var vh = {};
vh.__esModule = !0;
vh.default = Mk;
var $u = ce;
function Mk(e) {
  var t = (0, $u.useState)(e), n = t[0], a = t[1], r = (0, $u.useRef)(null), o = (0, $u.useCallback)(function(f, u) {
    r.current = u || null, a(f);
  }, [a]);
  return (0, $u.useLayoutEffect)(function() {
    r.current && (r.current(n), r.current = null);
  }, [n]), [n, o];
}
var xh = {}, bh = {};
bh.__esModule = !0;
bh.default = _k;
function _k(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
var Sh = {};
Sh.__esModule = !0;
Sh.default = zk;
function Nk(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n)
    return (n = n.call(e)).next.bind(n);
  if (Array.isArray(e) || (n = Fk(e)) || t && e && typeof e.length == "number") {
    n && (e = n);
    var a = 0;
    return function() {
      return a >= e.length ? { done: !0 } : { done: !1, value: e[a++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Fk(e, t) {
  if (e) {
    if (typeof e == "string")
      return cm(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return cm(e, t);
  }
}
function cm(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, a = new Array(t); n < t; n++)
    a[n] = e[n];
  return a;
}
function zk(e, t) {
  for (var n = e, a = 1 / 0, r = Nk(t), o; !(o = r()).done; ) {
    var f = o.value, u = Math.sqrt(Math.pow(f.x - e.x, 2) + Math.pow(f.y - e.y, 2));
    u < a && (a = u, n = {
      x: f.x,
      y: f.y
    });
  }
  return n;
}
xh.__esModule = !0;
xh.default = Bk;
var dm = cy(bh), $k = cy(Sh);
function cy(e) {
  return e && e.__esModule ? e : { default: e };
}
function Bk(e, t, n) {
  var a, r, o, f;
  return n === void 0 && (n = {}), t.length > 0 ? (0, $k.default)(e, t) : {
    x: (0, dm.default)(e.x, (a = n.xMin) != null ? a : -1 / 0, (r = n.xMax) != null ? r : 1 / 0),
    y: (0, dm.default)(e.y, (o = n.yMin) != null ? o : -1 / 0, (f = n.yMax) != null ? f : 1 / 0)
  };
}
var Eh = {};
Eh.__esModule = !0;
Eh.default = Wk;
var Ik = ce;
function Hk(e, t, n) {
  if (n === void 0 && (n = 1), !e)
    return [];
  for (var a = [], r = e.getTotalLength(), o = 0; o <= r; o += n) {
    var f = e.getPointAtLength(o), u = f.matrixTransform(t);
    a.push(u);
  }
  return a;
}
function Wk(e) {
  var t = (0, Ik.useMemo)(function() {
    if (!e)
      return [];
    var n = e.getCTM() || new DOMMatrix();
    return Hk(e, n);
  }, [e == null ? void 0 : e.getTotalLength()]);
  return t;
}
yh.__esModule = !0;
yh.default = Uk;
var Oi = ce, Uo = Dk, fm = Ok, Vk = kh(vh), hm = kh(xh), jk = kh(Eh);
function kh(e) {
  return e && e.__esModule ? e : { default: e };
}
function Yr() {
  return Yr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Yr.apply(this, arguments);
}
function Uk(e) {
  var t = e === void 0 ? {} : e, n = t.resetOnStart, a = n === void 0 ? !1 : n, r = t.snapToPointer, o = r === void 0 ? !0 : r, f = t.onDragEnd, u = t.onDragMove, s = t.onDragStart, d = t.x, m = t.y, y = t.dx, v = t.dy, w = t.isDragging, E = t.restrict, O = E === void 0 ? {} : E, T = t.restrictToPath, g = (0, Oi.useRef)({
    x: d,
    y: m,
    dx: y,
    dy: v
  }), N = (0, Vk.default)({
    x: d,
    y: m,
    dx: y ?? 0,
    dy: v ?? 0,
    isDragging: !1
  }), L = N[0], M = N[1], _ = (0, Oi.useState)(new Uo.Point({
    x: 0,
    y: 0
  })), C = _[0], H = _[1];
  (0, Oi.useEffect)(function() {
    (g.current.x !== d || g.current.y !== m || g.current.dx !== y || g.current.dy !== v) && (g.current = {
      x: d,
      y: m,
      dx: y,
      dy: v
    }, M(function(F) {
      return Yr({}, F, {
        x: d,
        y: m,
        dx: y ?? 0,
        dy: v ?? 0
      });
    }));
  }), (0, Oi.useEffect)(function() {
    w !== void 0 && L.isDragging !== w && M(function(F) {
      return Yr({}, F, {
        isDragging: w
      });
    });
  }, [L.isDragging, w, M]);
  var I = (0, jk.default)(T), X = (0, Oi.useCallback)(function(F) {
    F.persist(), M(function(j) {
      var U = j.x, W = U === void 0 ? 0 : U, re = j.y, J = re === void 0 ? 0 : re, ue = j.dx, ee = j.dy, Z = new Uo.Point({
        x: (W || 0) + ue,
        y: (J || 0) + ee
      }), se = (0, fm.localPoint)(F) || new Uo.Point({
        x: 0,
        y: 0
      }), ye = o ? se : Z, me = (0, hm.default)(ye, I, O);
      return H((0, Uo.subtractPoints)(Z, se)), {
        isDragging: !0,
        dx: a ? 0 : j.dx,
        dy: a ? 0 : j.dy,
        x: a ? me.x : me.x - j.dx,
        y: a ? me.y : me.y - j.dy
      };
    }, s && function(j) {
      s(Yr({}, j, {
        event: F
      }));
    });
  }, [s, a, O, I, M, o]), te = (0, Oi.useCallback)(function(F) {
    F.persist(), M(function(j) {
      if (!j.isDragging)
        return j;
      var U = j.x, W = U === void 0 ? 0 : U, re = j.y, J = re === void 0 ? 0 : re, ue = (0, fm.localPoint)(F) || new Uo.Point({
        x: 0,
        y: 0
      }), ee = o ? ue : (0, Uo.sumPoints)(ue, C), Z = (0, hm.default)(ee, I, O);
      return Yr({}, j, {
        dx: Z.x - W,
        dy: Z.y - J
      });
    }, u && function(j) {
      j.isDragging && u(Yr({}, j, {
        event: F
      }));
    });
  }, [M, u, o, C, I, O]), G = (0, Oi.useCallback)(function(F) {
    F.persist(), M(function(j) {
      return Yr({}, j, {
        isDragging: !1
      });
    }, f && function(j) {
      f(Yr({}, j, {
        event: F
      }));
    });
  }, [f, M]);
  return Yr({}, L, {
    dragEnd: G,
    dragMove: te,
    dragStart: X
  });
}
var Fc = dy, ss = wh(bm), Jd = wh(ce), Kk = wh(yh);
function wh(e) {
  return e && e.__esModule ? e : { default: e };
}
function dy(e) {
  var t = e.captureDragArea, n = t === void 0 ? !0 : t, a = e.snapToPointer, r = a === void 0 ? !0 : a, o = e.children, f = e.dx, u = e.dy, s = e.height, d = e.onDragEnd, m = e.onDragMove, y = e.onDragStart, v = e.resetOnStart, w = e.width, E = e.x, O = e.y, T = e.isDragging, g = e.restrict, N = e.restrictToPath, L = (0, Kk.default)({
    resetOnStart: v,
    snapToPointer: r,
    onDragEnd: d,
    onDragMove: m,
    onDragStart: y,
    x: E,
    y: O,
    dx: f,
    dy: u,
    isDragging: T,
    restrict: g,
    restrictToPath: N
  });
  return /* @__PURE__ */ Jd.default.createElement(Jd.default.Fragment, null, L.isDragging && n && /* @__PURE__ */ Jd.default.createElement("rect", {
    width: w,
    height: s,
    onPointerDown: L.dragStart,
    onPointerMove: L.dragMove,
    onPointerUp: L.dragEnd,
    fill: "transparent"
  }), o(L));
}
dy.propTypes = {
  children: ss.default.func.isRequired,
  width: ss.default.number.isRequired,
  height: ss.default.number.isRequired,
  captureDragArea: ss.default.bool,
  isDragging: ss.default.bool
};
function kc(e, t) {
  if ("invert" in e && typeof e.invert < "u")
    return e.invert(t).valueOf();
  var n = e.range(), a = n[0], r = n[1], o = 0, f = "step" in e && typeof e.step < "u" ? e.step() : 1, u = f * (r - a) / Math.abs(r - a);
  if (u > 0)
    for (; t > a + u * (o + 1); )
      o += 1;
  else
    for (; t < a + u * (o + 1); )
      o += 1;
  return o;
}
function pm(e, t, n, a) {
  var r, o = kc(e, t + (t < n ? -a : a)), f = kc(e, n + (n < t ? -a : a)), u = Math.min(o, f), s = Math.max(o, f);
  if ("invert" in e && typeof e.invert < "u")
    r = {
      start: u,
      end: s
    };
  else {
    for (var d = [], m = e.domain(), y = u; y <= s; y += 1)
      d.push(m[y]);
    r = {
      values: d
    };
  }
  return r;
}
function Th(e) {
  if (typeof window < "u" && window.TouchEvent && e instanceof TouchEvent)
    return {
      pageX: e.touches[0].pageX,
      pageY: e.touches[0].pageY
    };
  var t = e;
  return {
    pageX: t.pageX,
    pageY: t.pageY
  };
}
function wr() {
  return wr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, wr.apply(this, arguments);
}
function Yk(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, _f(e, t);
}
function _f(e, t) {
  return _f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, r) {
    return a.__proto__ = r, a;
  }, _f(e, t);
}
var fy = /* @__PURE__ */ function(e) {
  Yk(t, e);
  function t() {
    for (var a, r = arguments.length, o = new Array(r), f = 0; f < r; f++)
      o[f] = arguments[f];
    return a = e.call.apply(e, [this].concat(o)) || this, a.handleDragStart = function(u) {
      var s = a.props, d = s.onBrushHandleChange, m = s.type, y = s.onBrushStart;
      d && d(m, Th(u.event)), y && y(u);
    }, a.handleDragMove = function(u) {
      var s = a.props, d = s.updateBrush, m = s.type, y = s.isControlled;
      !u.isDragging || y || d(function(v) {
        var w = v.start, E = v.end, O = 0, T = Math.max(w.x, E.x), g = Math.min(w.x, E.x), N = Math.max(w.y, E.y), L = Math.min(w.y, E.y);
        switch (m) {
          case "right":
            return O = T + u.dx, wr({}, v, {
              activeHandle: m,
              extent: wr({}, v.extent, {
                x0: Math.max(Math.min(O, w.x), v.bounds.x0),
                x1: Math.min(Math.max(O, w.x), v.bounds.x1)
              })
            });
          case "left":
            return O = g + u.dx, wr({}, v, {
              activeHandle: m,
              extent: wr({}, v.extent, {
                x0: Math.min(O, E.x),
                x1: Math.max(O, E.x)
              })
            });
          case "bottom":
            return O = N + u.dy, wr({}, v, {
              activeHandle: m,
              extent: wr({}, v.extent, {
                y0: Math.min(O, w.y),
                y1: Math.max(O, w.y)
              })
            });
          case "top":
            return O = L + u.dy, wr({}, v, {
              activeHandle: m,
              extent: wr({}, v.extent, {
                y0: Math.min(O, E.y),
                y1: Math.max(O, E.y)
              })
            });
          default:
            return v;
        }
      });
    }, a.handleDragEnd = function() {
      var u = a.props, s = u.updateBrush, d = u.onBrushEnd, m = u.onBrushHandleChange, y = u.isControlled;
      y || s(function(v) {
        var w = v.start, E = v.end, O = v.extent;
        w.x = Math.min(O.x0, O.x1), w.y = Math.min(O.y0, O.y0), E.x = Math.max(O.x0, O.x1), E.y = Math.max(O.y0, O.y1);
        var T = wr({}, v, {
          start: w,
          end: E,
          activeHandle: null,
          isBrushing: !1,
          extent: {
            x0: Math.min(w.x, E.x),
            x1: Math.max(w.x, E.x),
            y0: Math.min(w.y, E.y),
            y1: Math.max(w.y, E.y)
          }
        });
        return d && d(T), T;
      }), m && m();
    }, a;
  }
  var n = t.prototype;
  return n.render = function() {
    var r = this, o = this.props, f = o.stageWidth, u = o.stageHeight, s = o.brush, d = o.type, m = o.handle, y = o.isControlled, v = o.isDragInProgress, w = o.renderBrushHandle, E = m.x, O = m.y, T = m.width, g = m.height, N = d === "right" || d === "left" ? "ew-resize" : "ns-resize";
    return /* @__PURE__ */ i.createElement(Fc, {
      width: f,
      height: u,
      onDragStart: this.handleDragStart,
      onDragMove: this.handleDragMove,
      onDragEnd: this.handleDragEnd,
      resetOnStart: !0,
      isDragging: y ? v : void 0
    }, function(L) {
      var M = L.dragStart, _ = L.dragEnd, C = L.dragMove, H = L.isDragging;
      return /* @__PURE__ */ i.createElement("g", null, H && /* @__PURE__ */ i.createElement("rect", {
        fill: "transparent",
        width: f,
        height: u,
        style: {
          cursor: N
        },
        onPointerMove: C,
        onPointerUp: y ? void 0 : _,
        onPointerLeave: y ? void 0 : _
      }), !w && /* @__PURE__ */ i.createElement("rect", {
        x: E,
        y: O,
        width: T,
        height: g,
        fill: "transparent",
        className: "visx-brush-handle-" + d,
        onPointerDown: M,
        onPointerMove: C,
        onPointerUp: y ? void 0 : _,
        style: {
          cursor: N,
          pointerEvents: s.activeHandle || s.isBrushing ? "none" : "all"
        }
      }), w && /* @__PURE__ */ i.createElement("g", {
        onPointerDown: M,
        onPointerMove: C,
        onPointerUp: y ? void 0 : _
      }, w(wr({}, r.props.handle, {
        height: u,
        className: "visx-brush-handle-" + d,
        isBrushActive: s.extent.x0 !== -1 && s.extent.x1 !== -1
      }))));
    });
  }, t;
}(i.Component);
fy.propTypes = {
  stageWidth: he.number.isRequired,
  stageHeight: he.number.isRequired,
  updateBrush: he.func.isRequired,
  onBrushStart: he.func,
  onBrushEnd: he.func,
  handle: he.shape({
    x: he.number.isRequired,
    y: he.number.isRequired,
    width: he.number.isRequired,
    height: he.number.isRequired
  }).isRequired,
  isControlled: he.bool,
  isDragInProgress: he.bool,
  onBrushHandleChange: he.func,
  renderBrushHandle: he.func
};
function mr() {
  return mr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, mr.apply(this, arguments);
}
function Xk(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Nf(e, t);
}
function Nf(e, t) {
  return Nf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, r) {
    return a.__proto__ = r, a;
  }, Nf(e, t);
}
var Ch = /* @__PURE__ */ function(e) {
  Xk(t, e);
  function t() {
    for (var a, r = arguments.length, o = new Array(r), f = 0; f < r; f++)
      o[f] = arguments[f];
    return a = e.call.apply(e, [this].concat(o)) || this, a.cornerDragMove = function(u) {
      var s = a.props, d = s.updateBrush, m = s.type;
      u.isDragging && d(function(y) {
        var v = y.start, w = y.end, E = Math.max(v.x, w.x), O = Math.min(v.x, w.x), T = Math.max(v.y, w.y), g = Math.min(v.y, w.y), N = 0, L = 0;
        switch (m) {
          case "topRight":
            return N = E + u.dx, L = g + u.dy, mr({}, y, {
              activeHandle: m,
              extent: mr({}, y.extent, {
                x0: Math.max(Math.min(N, v.x), y.bounds.x0),
                x1: Math.min(Math.max(N, v.x), y.bounds.x1),
                y0: Math.max(Math.min(L, w.y), y.bounds.y0),
                y1: Math.min(Math.max(L, w.y), y.bounds.y1)
              })
            });
          case "topLeft":
            return N = O + u.dx, L = g + u.dy, mr({}, y, {
              activeHandle: m,
              extent: mr({}, y.extent, {
                x0: Math.max(Math.min(N, w.x), y.bounds.x0),
                x1: Math.min(Math.max(N, w.x), y.bounds.x1),
                y0: Math.max(Math.min(L, w.y), y.bounds.y0),
                y1: Math.min(Math.max(L, w.y), y.bounds.y1)
              })
            });
          case "bottomLeft":
            return N = O + u.dx, L = T + u.dy, mr({}, y, {
              activeHandle: m,
              extent: mr({}, y.extent, {
                x0: Math.max(Math.min(N, w.x), y.bounds.x0),
                x1: Math.min(Math.max(N, w.x), y.bounds.x1),
                y0: Math.max(Math.min(L, v.y), y.bounds.y0),
                y1: Math.min(Math.max(L, v.y), y.bounds.y1)
              })
            });
          case "bottomRight":
            return N = E + u.dx, L = T + u.dy, mr({}, y, {
              activeHandle: m,
              extent: mr({}, y.extent, {
                x0: Math.max(Math.min(N, v.x), y.bounds.x0),
                x1: Math.min(Math.max(N, v.x), y.bounds.x1),
                y0: Math.max(Math.min(L, v.y), y.bounds.y0),
                y1: Math.min(Math.max(L, v.y), y.bounds.y1)
              })
            });
          default:
            return y;
        }
      });
    }, a.cornerDragEnd = function() {
      var u = a.props, s = u.updateBrush, d = u.onBrushEnd;
      s(function(m) {
        var y = m.start, v = m.end, w = m.extent;
        y.x = Math.min(w.x0, w.x1), y.y = Math.min(w.y0, w.y0), v.x = Math.max(w.x0, w.x1), v.y = Math.max(w.y0, w.y1);
        var E = mr({}, m, {
          start: y,
          end: v,
          activeHandle: null,
          domain: {
            x0: Math.min(y.x, v.x),
            x1: Math.max(y.x, v.x),
            y0: Math.min(y.y, v.y),
            y1: Math.max(y.y, v.y)
          }
        });
        return d && d(E), E;
      });
    }, a;
  }
  var n = t.prototype;
  return n.render = function() {
    var r = this.props, o = r.type, f = r.brush, u = r.stageWidth, s = r.stageHeight, d = r.style, m = r.corner, y = (d == null ? void 0 : d.cursor) || (o === "topLeft" || o === "bottomRight" ? "nwse-resize" : "nesw-resize"), v = f.activeHandle || f.isBrushing ? "none" : "all";
    return /* @__PURE__ */ i.createElement(Fc, {
      width: u,
      height: s,
      onDragMove: this.cornerDragMove,
      onDragEnd: this.cornerDragEnd,
      resetOnStart: !0
    }, function(w) {
      var E = w.dragMove, O = w.dragEnd, T = w.dragStart, g = w.isDragging;
      return /* @__PURE__ */ i.createElement("g", null, g && /* @__PURE__ */ i.createElement("rect", {
        fill: "transparent",
        width: u,
        height: s,
        style: {
          cursor: y
        },
        onPointerMove: E,
        onPointerUp: O
      }), /* @__PURE__ */ i.createElement("rect", mr({
        fill: "transparent",
        onPointerDown: T,
        onPointerMove: E,
        onPointerUp: O,
        className: "visx-brush-corner-" + o,
        style: mr({
          cursor: y,
          pointerEvents: v
        }, d)
      }, m)));
    });
  }, t;
}(i.Component);
Ch.propTypes = {
  stageWidth: he.number.isRequired,
  stageHeight: he.number.isRequired,
  updateBrush: he.func.isRequired,
  onBrushEnd: he.func,
  corner: he.shape({
    x: he.number.isRequired,
    y: he.number.isRequired,
    width: he.number.isRequired,
    height: he.number.isRequired
  }).isRequired
};
Ch.defaultProps = {
  style: {}
};
function $a() {
  return $a = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, $a.apply(this, arguments);
}
function qk(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Ff(e, t);
}
function Ff(e, t) {
  return Ff = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, r) {
    return a.__proto__ = r, a;
  }, Ff(e, t);
}
var Gk = {
  cursor: "move"
}, Ah = /* @__PURE__ */ function(e) {
  qk(t, e);
  function t() {
    for (var a, r = arguments.length, o = new Array(r), f = 0; f < r; f++)
      o[f] = arguments[f];
    return a = e.call.apply(e, [this].concat(o)) || this, a.selectionDragStart = function(u) {
      var s = a.props, d = s.onMoveSelectionChange, m = s.onBrushStart;
      d && d("move", Th(u.event)), m && m(u);
    }, a.selectionDragMove = function(u) {
      var s = a.props, d = s.updateBrush, m = s.isControlled;
      m || d(function(y) {
        var v = y.start, w = v.x, E = v.y, O = y.end, T = O.x, g = O.y, N = u.dx > 0 ? Math.min(u.dx, y.bounds.x1 - T) : Math.max(u.dx, y.bounds.x0 - w), L = u.dy > 0 ? Math.min(u.dy, y.bounds.y1 - g) : Math.max(u.dy, y.bounds.y0 - E);
        return $a({}, y, {
          isBrushing: !0,
          extent: $a({}, y.extent, {
            x0: w + N,
            x1: T + N,
            y0: E + L,
            y1: g + L
          })
        });
      });
    }, a.selectionDragEnd = function() {
      var u = a.props, s = u.updateBrush, d = u.onBrushEnd, m = u.onMoveSelectionChange, y = u.isControlled;
      y || s(function(v) {
        var w = $a({}, v, {
          isBrushing: !1,
          start: $a({}, v.start, {
            x: Math.min(v.extent.x0, v.extent.x1),
            y: Math.min(v.extent.y0, v.extent.y1)
          }),
          end: $a({}, v.end, {
            x: Math.max(v.extent.x0, v.extent.x1),
            y: Math.max(v.extent.y0, v.extent.y1)
          })
        });
        return d && d(w), w;
      }), m && m();
    }, a;
  }
  var n = t.prototype;
  return n.render = function() {
    var r = this.props, o = r.width, f = r.height, u = r.stageWidth, s = r.stageHeight, d = r.brush, m = r.disableDraggingSelection, y = r.onMouseLeave, v = r.onMouseMove, w = r.onMouseUp, E = r.onClick, O = r.selectedBoxStyle, T = r.isControlled, g = r.isDragInProgress;
    return /* @__PURE__ */ i.createElement(Fc, {
      width: o,
      height: f,
      resetOnStart: !0,
      onDragStart: this.selectionDragStart,
      onDragMove: this.selectionDragMove,
      onDragEnd: this.selectionDragEnd,
      isDragging: T ? g : void 0
    }, function(N) {
      var L = N.isDragging, M = N.dragStart, _ = N.dragEnd, C = N.dragMove;
      return /* @__PURE__ */ i.createElement("g", null, L && /* @__PURE__ */ i.createElement("rect", {
        width: u,
        height: s,
        fill: "transparent",
        onPointerUp: T ? void 0 : _,
        onPointerMove: C,
        onPointerLeave: T ? void 0 : _,
        style: Gk
      }), /* @__PURE__ */ i.createElement("rect", $a({
        x: Math.min(d.extent.x0, d.extent.x1),
        y: Math.min(d.extent.y0, d.extent.y1),
        width: o,
        height: f,
        className: "visx-brush-selection",
        onPointerDown: m ? void 0 : M,
        onPointerLeave: function(I) {
          y && y(I);
        },
        onPointerMove: function(I) {
          C(I), v && v(I);
        },
        onPointerUp: function(I) {
          T || _(I), w && w(I);
        },
        onClick: function(I) {
          E && E(I);
        },
        style: {
          pointerEvents: d.isBrushing || d.activeHandle ? "none" : "all",
          cursor: m ? void 0 : "move"
        }
      }, O)));
    });
  }, t;
}(i.Component);
Ah.propTypes = {
  width: he.number.isRequired,
  height: he.number.isRequired,
  stageWidth: he.number.isRequired,
  stageHeight: he.number.isRequired,
  updateBrush: he.func.isRequired,
  onMoveSelectionChange: he.func,
  onBrushStart: he.func,
  onBrushEnd: he.func,
  disableDraggingSelection: he.bool.isRequired,
  onMouseLeave: he.func,
  onMouseMove: he.func,
  onMouseUp: he.func,
  onClick: he.func,
  isControlled: he.bool,
  isDragInProgress: he.bool
};
Ah.defaultProps = {
  onMouseLeave: null,
  onMouseUp: null,
  onMouseMove: null,
  onClick: null
};
function zf() {
  return zf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, zf.apply(this, arguments);
}
function $f(e) {
  return /* @__PURE__ */ i.createElement(gr, zf({
    className: "visx-brush-overlay",
    fill: "transparent",
    x: 0,
    y: 0
  }, e));
}
$f.propTypes = {
  width: he.number.isRequired,
  height: he.number.isRequired,
  onClick: he.func,
  onDoubleClick: he.func,
  onPointerDown: he.func,
  onPointerLeave: he.func,
  onPointerMove: he.func,
  onPointerUp: he.func
};
function ar() {
  return ar = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, ar.apply(this, arguments);
}
function Zk(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Bf(e, t);
}
function Bf(e, t) {
  return Bf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, r) {
    return a.__proto__ = r, a;
  }, Bf(e, t);
}
var Ph = /* @__PURE__ */ function(e) {
  Zk(t, e);
  function t(a) {
    var r;
    r = e.call(this, a) || this, r.mouseUpTime = 0, r.mouseDownTime = 0, r.getIdleState = function() {
      var u = r.props, s = u.width, d = u.height;
      return {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: 0
        },
        extent: {
          x0: -1,
          x1: -1,
          y0: -1,
          y1: -1
        },
        bounds: {
          x0: 0,
          x1: s,
          y0: 0,
          y1: d
        },
        isBrushing: !1,
        brushPageOffset: void 0,
        activeHandle: null,
        brushingType: void 0
      };
    }, r.handleWindowPointerUp = function() {
      var u = r.props, s = u.useWindowMoveEvents, d = u.onBrushEnd, m = u.resetOnEnd, y = r.state.brushingType;
      s && y && r.updateBrush(function(v) {
        var w = v.start, E = v.end, O = v.extent;
        w.x = Math.min(O.x0, O.x1), w.y = Math.min(O.y0, O.y0), E.x = Math.max(O.x0, O.x1), E.y = Math.max(O.y0, O.y1);
        var T = ar({}, v, {
          activeHandle: null,
          isBrushing: !1,
          brushingType: void 0
        });
        return d && d(T), m && (T = ar({}, T, r.getIdleState())), T;
      });
    }, r.handleWindowPointerMove = function(u) {
      var s = r.props.useWindowMoveEvents, d = r.state, m = d.brushingType, y = d.isBrushing, v = d.brushPageOffset, w = d.start;
      if (!(!s || !y)) {
        var E = u.pageX - ((v == null ? void 0 : v.pageX) || 0), O = u.pageY - ((v == null ? void 0 : v.pageY) || 0);
        ["left", "right", "top", "bottom"].includes(m ?? "") && r.updateBrush(function(T) {
          var g = T.start, N = g.x, L = g.y, M = T.end, _ = M.x, C = M.y;
          return ar({}, T, {
            isBrushing: !0,
            extent: ar({}, T.extent, r.getExtent({
              x: m === "left" ? Math.min(Math.max(N + E, T.bounds.x0), T.bounds.x1) : N,
              y: m === "top" ? Math.min(Math.max(L + O, T.bounds.y0), T.bounds.y1) : L
            }, {
              x: m === "right" ? Math.min(Math.max(_ + E, T.bounds.x0), T.bounds.x1) : _,
              y: m === "bottom" ? Math.min(Math.max(C + O, T.bounds.y0), T.bounds.y1) : C
            }))
          });
        }), m === "move" && r.updateBrush(function(T) {
          var g = T.start, N = g.x, L = g.y, M = T.end, _ = M.x, C = M.y, H = E > 0 ? Math.min(E, T.bounds.x1 - _) : Math.max(E, T.bounds.x0 - N), I = O > 0 ? Math.min(O, T.bounds.y1 - C) : Math.max(O, T.bounds.y0 - L);
          return ar({}, T, {
            isBrushing: !0,
            extent: ar({}, T.extent, {
              x0: N + H,
              y0: L + I,
              x1: _ + H,
              y1: C + I
            })
          });
        }), m === "select" && r.updateBrush(function(T) {
          var g = T.start, N = g.x, L = g.y, M = {
            x: Math.min(Math.max(N + E, T.bounds.x0), T.bounds.x1),
            y: Math.min(Math.max(L + O, T.bounds.y0), T.bounds.y1)
          }, _ = r.getExtent(w, M), C = ar({}, T, {
            end: M,
            extent: _
          });
          return C;
        });
      }
    }, r.getExtent = function(u, s) {
      var d = r.props, m = d.brushDirection, y = d.width, v = d.height, w = m === "vertical" ? 0 : Math.min(u.x || 0, s.x || 0), E = m === "vertical" ? y : Math.max(u.x || 0, s.x || 0), O = m === "horizontal" ? 0 : Math.min(u.y || 0, s.y || 0), T = m === "horizontal" ? v : Math.max(u.y || 0, s.y || 0);
      return {
        x0: w,
        x1: E,
        y0: O,
        y1: T
      };
    }, r.handleDragStart = function(u) {
      var s = r.props, d = s.onBrushStart, m = s.left, y = s.top, v = s.inheritedMargin, w = s.useWindowMoveEvents, E = v != null && v.left ? v.left : 0, O = v != null && v.top ? v.top : 0, T = {
        x: (u.x || 0) + u.dx - m - E,
        y: (u.y || 0) + u.dy - y - O
      }, g = ar({}, T);
      d && d(T), r.updateBrush(function(N) {
        return ar({}, N, {
          start: T,
          end: g,
          extent: {
            x0: -1,
            x1: -1,
            y0: -1,
            y1: -1
          },
          isBrushing: !0,
          brushingType: "select",
          brushPageOffset: w ? Th(u.event) : void 0
        });
      });
    }, r.handleBrushStart = function(u) {
      var s = r.props, d = s.onBrushStart, m = s.left, y = s.top, v = s.inheritedMargin;
      if (d) {
        var w = v != null && v.left ? v.left : 0, E = v != null && v.top ? v.top : 0, O = {
          x: (u.x || 0) + u.dx - m - w,
          y: (u.y || 0) + u.dy - y - E
        };
        d(O);
      }
    }, r.handleDragMove = function(u) {
      var s = r.props, d = s.left, m = s.top, y = s.inheritedMargin, v = s.useWindowMoveEvents;
      if (!(!u.isDragging || v)) {
        var w = (y == null ? void 0 : y.left) || 0, E = (y == null ? void 0 : y.top) || 0, O = {
          x: (u.x || 0) + u.dx - d - w,
          y: (u.y || 0) + u.dy - m - E
        };
        r.updateBrush(function(T) {
          var g = T.start, N = r.getExtent(g, O);
          return ar({}, T, {
            end: O,
            extent: N
          });
        });
      }
    }, r.handleDragEnd = function() {
      var u = r.props, s = u.onBrushEnd, d = u.resetOnEnd, m = u.useWindowMoveEvents;
      m || r.updateBrush(function(y) {
        var v = y.extent, w = ar({}, y, {
          start: {
            x: v.x0,
            y: v.y0
          },
          end: {
            x: v.x1,
            y: v.y1
          },
          isBrushing: !1,
          brushingType: void 0,
          activeHandle: null
        });
        return s && s(w), d && (w = ar({}, w, r.getIdleState())), w;
      });
    }, r.getBrushWidth = function() {
      var u = r.state.extent, s = u.x0, d = u.x1;
      return Math.max(Math.max(s, d) - Math.min(s, d), 0);
    }, r.getBrushHeight = function() {
      var u = r.state.extent, s = u.y1, d = u.y0;
      return Math.max(Math.max(d, s) - Math.min(d, s), 0);
    }, r.handles = function() {
      var u = r.props.handleSize, s = r.state.extent, d = s.x0, m = s.x1, y = s.y0, v = s.y1, w = u / 2, E = r.getBrushWidth(), O = r.getBrushHeight();
      return {
        top: {
          x: d - w,
          y: y - w,
          height: u,
          width: E + u
        },
        bottom: {
          x: d - w,
          y: v - w,
          height: u,
          width: E + u
        },
        right: {
          x: m - w,
          y: y - w,
          height: O + u,
          width: u
        },
        left: {
          x: d - w,
          y: y - w,
          height: O + u,
          width: u
        }
      };
    }, r.corners = function() {
      var u = r.props.handleSize, s = r.state.extent, d = s.x0, m = s.x1, y = s.y0, v = s.y1, w = u / 2, E = u, O = u;
      return {
        topLeft: {
          x: Math.min(d, m) - w,
          y: Math.min(y, v) - w,
          width: E,
          height: O
        },
        topRight: {
          x: Math.max(d, m) - w,
          y: Math.min(y, v) - w,
          width: E,
          height: O
        },
        bottomLeft: {
          x: Math.min(d, m) - w,
          y: Math.max(y, v) - w,
          width: E,
          height: O
        },
        bottomRight: {
          x: Math.max(d, m) - w,
          y: Math.max(y, v) - w,
          width: E,
          height: O
        }
      };
    }, r.updateBrush = function(u) {
      var s = r.props.onChange;
      r.setState(u, function() {
        s && s(r.state);
      });
    }, r.reset = function() {
      return r.updateBrush(function() {
        return r.getIdleState();
      });
    }, r.handleBrushingTypeChange = function(u, s) {
      r.updateBrush(function(d) {
        var m = ar({}, d, {
          brushingType: u,
          isBrushing: u !== void 0
        });
        return (s || u === void 0) && (m.brushPageOffset = s), m;
      });
    };
    var o = a.initialBrushPosition, f = o ? r.getExtent(o.start, o.end) : {
      x0: -1,
      x1: -1,
      y0: -1,
      y1: -1
    };
    return r.state = {
      start: {
        x: Math.max(0, f.x0),
        y: Math.max(0, f.y0)
      },
      end: {
        x: Math.max(0, f.x1),
        y: Math.max(0, f.y1)
      },
      extent: f,
      bounds: {
        x0: 0,
        x1: r.props.width,
        y0: 0,
        y1: r.props.height
      },
      isBrushing: !1,
      brushingType: void 0,
      activeHandle: null
    }, r;
  }
  var n = t.prototype;
  return n.componentDidUpdate = function(r) {
    var o = this;
    (this.props.width !== r.width || this.props.height !== r.height) && this.setState(function(f) {
      var u = f.start, s = f.end, d = f.extent;
      if (!(d.x0 === -1 && d.x1 === -1 && d.y0 === -1 && d.y1 === -1)) {
        var m = o.props.width / r.width, y = o.props.height / r.height;
        u = {
          x: m * d.x0,
          y: y * d.y0
        }, s = {
          x: m * d.x1,
          y: y * d.y1
        }, d = o.getExtent(u, s);
      }
      return {
        start: u,
        end: s,
        extent: d,
        bounds: {
          x0: 0,
          x1: o.props.width,
          y0: 0,
          y1: o.props.height
        }
      };
    });
  }, n.componentDidMount = function() {
    this.props.useWindowMoveEvents && (window.addEventListener("mouseup", this.handleWindowPointerUp), window.addEventListener("mousemove", this.handleWindowPointerMove));
  }, n.componentWillUnmount = function() {
    this.props.useWindowMoveEvents && (window.removeEventListener("mouseup", this.handleWindowPointerUp), window.removeEventListener("mousemove", this.handleWindowPointerMove));
  }, n.render = function() {
    var r = this, o = this.state, f = o.start, u = o.end, s = this.props, d = s.top, m = s.left, y = s.width, v = s.height, w = s.onMouseLeave, E = s.onMouseUp, O = s.onMouseMove, T = s.onBrushEnd, g = s.onClick, N = s.resizeTriggerAreas, L = s.selectedBoxStyle, M = s.disableDraggingSelection, _ = s.disableDraggingOverlay, C = s.clickSensitivity, H = s.useWindowMoveEvents, I = s.renderBrushHandle, X = this.state.brushingType, te = this.handles(), G = this.corners(), F = this.getBrushWidth(), j = this.getBrushHeight(), U = new Set(N);
    return /* @__PURE__ */ i.createElement(at, {
      className: "visx-brush",
      top: d,
      left: m
    }, _ ? /* @__PURE__ */ i.createElement($f, {
      width: y,
      height: v,
      onClick: function(re) {
        var J = r.mouseUpTime - r.mouseDownTime;
        g && J < C && g(re);
      },
      style: {
        cursor: "default"
      }
    }) : /* @__PURE__ */ i.createElement(Fc, {
      width: y,
      height: v,
      resetOnStart: !0,
      onDragStart: this.handleDragStart,
      onDragMove: this.handleDragMove,
      onDragEnd: this.handleDragEnd,
      isDragging: H ? X === "select" : void 0
    }, function(W) {
      var re = W.dragStart, J = W.isDragging, ue = W.dragMove, ee = W.dragEnd;
      return /* @__PURE__ */ i.createElement($f, {
        width: y,
        height: v,
        onDoubleClick: function() {
          return r.reset();
        },
        onClick: function(se) {
          var ye = r.mouseUpTime - r.mouseDownTime;
          g && ye < C && g(se);
        },
        onPointerDown: function(se) {
          r.mouseDownTime = Date.now(), re(se);
        },
        onPointerLeave: function(se) {
          w && w(se);
        },
        onPointerMove: function(se) {
          !J && O && O(se), J && ue(se);
        },
        onPointerUp: function(se) {
          r.mouseUpTime = Date.now(), E && E(se), ee(se);
        },
        style: {
          cursor: "crosshair"
        }
      });
    }), f && u && /* @__PURE__ */ i.createElement(Ah, {
      updateBrush: this.updateBrush,
      width: F,
      height: j,
      stageWidth: y,
      stageHeight: v,
      brush: this.state,
      disableDraggingSelection: M,
      onBrushEnd: T,
      onBrushStart: this.handleBrushStart,
      onMouseLeave: w,
      onMouseMove: O,
      onMouseUp: E,
      onMoveSelectionChange: this.handleBrushingTypeChange,
      onClick: g,
      selectedBoxStyle: L,
      isControlled: H,
      isDragInProgress: H ? X === "move" : void 0
    }), f && u && Object.keys(te).filter(function(W) {
      return U.has(W);
    }).map(function(W) {
      var re = te[W];
      return re && /* @__PURE__ */ i.createElement(fy, {
        key: "handle-" + W,
        type: W,
        handle: re,
        stageWidth: y,
        stageHeight: v,
        updateBrush: r.updateBrush,
        brush: r.state,
        onBrushStart: r.handleBrushStart,
        onBrushEnd: T,
        isControlled: H,
        isDragInProgress: H ? X === W : void 0,
        onBrushHandleChange: r.handleBrushingTypeChange,
        renderBrushHandle: I
      });
    }), f && u && Object.keys(G).filter(function(W) {
      return U.has(W);
    }).map(function(W) {
      var re = G[W];
      return re && /* @__PURE__ */ i.createElement(Ch, {
        key: "corner-" + W,
        type: W,
        brush: r.state,
        updateBrush: r.updateBrush,
        stageWidth: y,
        stageHeight: v,
        corner: re,
        onBrushEnd: T
      });
    }));
  }, t;
}(i.Component);
Ph.propTypes = {
  brushDirection: he.oneOf(["horizontal", "vertical", "both"]),
  width: he.number.isRequired,
  height: he.number.isRequired,
  left: he.number.isRequired,
  top: he.number.isRequired,
  onChange: he.func,
  handleSize: he.number,
  resizeTriggerAreas: he.array,
  onBrushStart: he.func,
  onBrushEnd: he.func,
  onMouseLeave: he.func,
  onMouseUp: he.func,
  onMouseMove: he.func,
  onClick: he.func,
  clickSensitivity: he.number,
  disableDraggingSelection: he.bool,
  disableDraggingOverlay: he.bool,
  resetOnEnd: he.bool,
  useWindowMoveEvents: he.bool,
  renderBrushHandle: he.func
};
Ph.defaultProps = {
  brushDirection: "both",
  inheritedMargin: {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  },
  onChange: null,
  handleSize: 4,
  resizeTriggerAreas: ["left", "right"],
  onBrushStart: null,
  onBrushEnd: null,
  onMouseLeave: null,
  onMouseUp: null,
  onMouseMove: null,
  onClick: null,
  disableDraggingSelection: !1,
  disableDraggingOverlay: !1,
  clickSensitivity: 200,
  resetOnEnd: !1,
  initialBrushPosition: null,
  useWindowMoveEvents: !1,
  renderBrushHandles: null
};
function Qk(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, If(e, t);
}
function If(e, t) {
  return If = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, r) {
    return a.__proto__ = r, a;
  }, If(e, t);
}
var mm = 2, gm = "steelblue", Lh = /* @__PURE__ */ function(e) {
  Qk(t, e);
  function t() {
    for (var a, r = arguments.length, o = new Array(r), f = 0; f < r; f++)
      o[f] = arguments[f];
    return a = e.call.apply(e, [this].concat(o)) || this, a.handleChange = function(u) {
      var s = a.props.onChange;
      if (s) {
        var d = u.extent.x0;
        if (typeof d > "u" || d < 0) {
          s(null);
          return;
        }
        var m = a.convertRangeToDomain(u);
        s(m);
      }
    }, a.handleBrushStart = function(u) {
      var s = a.props.onBrushStart;
      if (s) {
        var d = u.x, m = u.y, y = a.props, v = y.xScale, w = y.yScale, E = kc(v, d), O = kc(w, m);
        s({
          x: "invert" in v && typeof v.invert < "u" ? E : v.domain()[E],
          y: "invert" in w && typeof w.invert < "u" ? O : w.domain()[O]
        });
      }
    }, a.handleBrushEnd = function(u) {
      var s = a.props.onBrushEnd;
      if (s) {
        var d = u.extent.x0;
        if (typeof d > "u" || d < 0) {
          s(null);
          return;
        }
        var m = a.convertRangeToDomain(u);
        s(m);
      }
    }, a;
  }
  var n = t.prototype;
  return n.convertRangeToDomain = function(r) {
    var o = this.props, f = o.xScale, u = o.yScale, s = r.extent, d = s.x0, m = s.x1, y = s.y0, v = s.y1, w = pm(f, d || 0, m || 0, mm), E = pm(u, y || 0, v || 0, mm), O = {
      x0: w.start || 0,
      x1: w.end || 0,
      xValues: w.values,
      y0: E.start || 0,
      y1: E.end || 0,
      yValues: E.values
    };
    return O;
  }, n.render = function() {
    var r = this.props, o = r.xScale, f = r.yScale, u = r.height, s = r.width, d = r.margin, m = r.brushDirection, y = r.initialBrushPosition, v = r.innerRef, w = r.resizeTriggerAreas, E = r.brushRegion, O = r.yAxisOrientation, T = r.xAxisOrientation, g = r.selectedBoxStyle, N = r.disableDraggingSelection, L = r.disableDraggingOverlay, M = r.resetOnEnd, _ = r.onMouseLeave, C = r.onMouseMove, H = r.onClick, I = r.handleSize, X = r.useWindowMoveEvents, te = r.renderBrushHandle;
    if (!o || !f)
      return null;
    var G, F, j, U, W = d != null && d.left ? d.left : 0, re = d != null && d.top ? d.top : 0, J = d != null && d.right ? d.right : 0, ue = d != null && d.bottom ? d.bottom : 0;
    return E === "chart" ? (j = 0, U = 0, G = s, F = u) : E === "yAxis" ? (U = 0, F = u, O === "right" ? (j = s, G = J) : (j = -W, G = W)) : (j = 0, G = s, T === "bottom" ? (U = u, F = ue) : (U = -re, F = re)), /* @__PURE__ */ i.createElement(Ph, {
      width: G,
      height: F,
      left: j,
      top: U,
      brushDirection: m,
      disableDraggingSelection: N,
      disableDraggingOverlay: L,
      handleSize: I,
      inheritedMargin: d,
      initialBrushPosition: y,
      ref: v,
      resetOnEnd: M,
      resizeTriggerAreas: w,
      selectedBoxStyle: g,
      onBrushEnd: this.handleBrushEnd,
      onBrushStart: this.handleBrushStart,
      onChange: this.handleChange,
      onClick: H,
      onMouseLeave: _,
      onMouseMove: C,
      useWindowMoveEvents: X,
      renderBrushHandle: te
    });
  }, t;
}(ce.Component);
Lh.propTypes = {
  height: he.number,
  width: he.number,
  onChange: he.func,
  onBrushEnd: he.func,
  brushDirection: he.oneOf(["vertical", "horizontal", "both"]),
  resizeTriggerAreas: he.array,
  brushRegion: he.oneOf(["xAxis", "yAxis", "chart"]),
  yAxisOrientation: he.oneOf(["left", "right"]),
  xAxisOrientation: he.oneOf(["top", "bottom"]),
  disableDraggingSelection: he.bool,
  disableDraggingOverlay: he.bool,
  resetOnEnd: he.bool,
  handleSize: he.number,
  useWindowMoveEvents: he.bool,
  renderBrushHandle: he.func
};
Lh.defaultProps = {
  xScale: null,
  yScale: null,
  onChange: null,
  height: 0,
  width: 0,
  selectedBoxStyle: {
    fill: gm,
    fillOpacity: 0.2,
    stroke: gm,
    strokeWidth: 1,
    strokeOpacity: 0.8
  },
  margin: {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  },
  handleSize: 4,
  brushDirection: "horizontal",
  initialBrushPosition: null,
  resizeTriggerAreas: ["left", "right"],
  brushRegion: "chart",
  yAxisOrientation: "right",
  xAxisOrientation: "bottom",
  onBrushStart: null,
  onBrushEnd: null,
  disableDraggingSelection: !1,
  resetOnEnd: !1,
  onMouseMove: null,
  onMouseLeave: null,
  onClick: null,
  useWindowMoveEvents: !1,
  renderBrushHandles: null
};
const Jk = Lh, ew = (e) => {
  var N, L, M;
  const { tableData: t, config: n, parseDate: a, formatDate: r, setBrushConfig: o, getTextWidth: f } = ce.useContext(Pt), { fontSize: u } = Ds(), [s, d] = ce.useState(0), m = ce.useRef(null), y = 15, [v, w] = ce.useState({
    startPosition: 0,
    endPosition: 0,
    startValue: "",
    endValue: ""
  });
  console.log(v, "text");
  const E = {
    start: { x: 0 },
    end: { x: e.xMax }
  }, O = {
    fill: "#AFA6A5 ",
    stroke: "blue",
    fillOpacity: 0.8,
    strokeOpacity: 0,
    rx: y
  }, T = (_) => {
    var F;
    if (!_ || !_.xValues)
      return;
    const { xValues: C } = _, H = (F = n.xAxis) == null ? void 0 : F.dataKey, I = t.filter((j) => C.includes(j[H])), X = C.slice().reverse().find((j) => j !== void 0), te = C.find((j) => j !== void 0), G = (j) => Cn(n.runtime.xAxis) ? r(a(j)) : j;
    w((j) => {
      var U, W;
      return {
        ...j,
        startPosition: (U = m.current) == null ? void 0 : U.state.start.x,
        endPosition: (W = m.current) == null ? void 0 : W.state.end.x,
        endValue: G(X),
        startValue: G(te)
      };
    }), o((j) => {
      var U;
      return {
        ...j,
        isBrushing: (U = m.current) == null ? void 0 : U.state.isBrushing,
        data: I
      };
    });
  };
  ce.useEffect(() => {
    var _;
    (_ = n.brush) != null && _.active || (d((C) => C + 1), o({
      data: [],
      isActive: !1,
      isBrushing: !1
    }));
  }, [(N = n.brush) == null ? void 0 : N.active]), ce.useEffect(() => {
    var H, I, X;
    const _ = (H = n.filters) == null ? void 0 : H.some((te) => te.active), C = (I = n.exclusions) == null ? void 0 : I.active;
    return (_ || C) && ((X = n.brush) != null && X.active) && (d((te) => te + 1), o((te) => ({
      ...te,
      data: t
    }))), () => o((te) => ({
      ...te,
      data: []
    }));
  }, [n.filters, n.exclusions, (L = n.brush) == null ? void 0 : L.active]);
  const g = () => {
    const _ = Number(n.xAxis.tickRotation) > 0 ? Number(n.xAxis.tickRotation) : 0;
    let C = 0;
    const H = 20;
    return n.xAxis.label || (!n.isResponsiveTicks && _ && (C = Number(_ + n.xAxis.tickWidthMax) / 1.6), !n.isResponsiveTicks && !_ && (C = Number(n.xAxis.labelOffset) - H), n.isResponsiveTicks && n.dynamicMarginTop && (C = Number(n.xAxis.labelOffset + n.xAxis.tickWidthMax / 1.6)), n.isResponsiveTicks && !n.dynamicMarginTop && (C = Number(n.xAxis.labelOffset - H))), n.xAxis.label && (!n.isResponsiveTicks && _ && (C = Number(n.xAxis.tickWidthMax + _)), !n.isResponsiveTicks && !_ && (C = n.xAxis.labelOffset + H), n.isResponsiveTicks && !_ && (C = Number(n.dynamicMarginTop ? n.dynamicMarginTop : n.xAxis.labelOffset) + H)), C;
  };
  if (["Line", "Bar", "Area Chart", "Combo"].includes(n.visualizationType))
    return /* @__PURE__ */ i.createElement(at, { display: (M = n.brush) != null && M.active ? "block" : "none", top: Number(e.yMax) + g(), left: Number(n.runtime.yAxis.size), pointerEvents: "fill" }, /* @__PURE__ */ i.createElement("rect", { fill: "#F7F7F7  ", width: e.xMax, height: n.brush.height, rx: y }), /* @__PURE__ */ i.createElement(
      Jk,
      {
        key: s,
        disableDraggingOverlay: !0,
        renderBrushHandle: (_) => {
          var C;
          return /* @__PURE__ */ i.createElement(tw, { getTextWidth: f, pixelDistance: v.endPosition - v.startPosition, textProps: v, fontSize: u[n.fontSize], ..._, isBrushing: (C = m.current) == null ? void 0 : C.state.isBrushing });
        },
        innerRef: m,
        useWindowMoveEvents: !0,
        selectedBoxStyle: O,
        xScale: e.xScaleBrush,
        yScale: e.yScale,
        width: e.xMax,
        resizeTriggerAreas: ["left", "right"],
        height: n.brush.height,
        handleSize: 8,
        brushDirection: "horizontal",
        initialBrushPosition: E,
        onChange: T
      }
    ));
}, tw = (e) => {
  const { x: t, isBrushActive: n, isBrushing: a, className: r, textProps: o, pixelDistance: f, getTextWidth: u, fontSize: s } = e, d = 8;
  if (!n)
    return null;
  const m = r.includes("left"), y = m ? "scale(-1, 1)" : "translate(0,0)", v = m ? "end" : "start";
  return u(o.startValue, `normal ${e.fontSize / 1.4}px sans-serif`), /* @__PURE__ */ i.createElement(at, { left: t + d / 2, top: -2 }, /* @__PURE__ */ i.createElement(Tt, { pointerEvents: "visiblePainted", dominantBaseline: "hanging", x: m ? 55 : -50, y: 30, verticalAnchor: "start", textAnchor: v, fontSize: s / 1.4 }, m ? o.startValue : o.endValue), /* @__PURE__ */ i.createElement("path", { cursor: "ew-resize", d: "M0.5,10A6,6 0 0 1 6.5,16V14A6,6 0 0 1 0.5,20ZM2.5,18V12M4.5,18V12", fill: a ? "#297EF1" : "#000", strokeWidth: "1", transform: y }));
}, Ur = (e) => {
  var Et, Nn, Ln, Bn, Ht, Fn;
  const { transformedData: t, tableData: n, dimensions: a, config: r, parseDate: o, formatDate: f, currentViewport: u, formatNumber: s, handleChartAriaLabels: d, updateConfig: m, handleLineType: y, getTextWidth: v, brushConfig: w } = ce.useContext(Pt), { visualizationType: E, visualizationSubType: O, orientation: T, xAxis: g, yAxis: N, runtime: L, debugSvg: M } = r, _ = () => al(r.visualizationType, t, r.allowLineToBarGraph);
  let [C] = a;
  r && r.legend && !r.legend.hide && ((Et = r.legend) == null ? void 0 : Et.position) !== "bottom" && ["lg", "md"].includes(u) && (C = C * 0.73);
  const { horizontal: H } = r.heights, I = T === "horizontal" || r.visualizationType === "Forest Plot", X = !0;
  let te = r.aspectRatio ? C * r.aspectRatio : r.visualizationType === "Forest Plot" ? r.heights.vertical : r.heights[T];
  const G = C - L.yAxis.size - (E === "Combo" ? r.yAxis.rightAxisSize : 0);
  let F = te - (T === "horizontal" ? 0 : L.xAxis.padding || 0);
  r.visualizationType === "Forest Plot" && (te = te + r.data.length * r.forestPlot.rowHeight, F = F + r.data.length * r.forestPlot.rowHeight, C = a[0]), (Nn = r.brush) != null && Nn.active && (te = te + ((Ln = r.brush) == null ? void 0 : Ln.height));
  const { minValue: j, maxValue: U, existPositiveValue: W, isAllLine: re } = Nc(r, t), { visSupportsReactTooltip: J } = Ms(), { hasTopAxis: ue } = Rk(r), [ee, Z] = ce.useState(!1), [se, ye] = ce.useState({ x: 0, y: 0 }), me = ce.useRef(), Le = ce.useRef(), de = dh(me, {
    freezeOnceVisible: !1
  }), ie = (Oe) => Cn(r.runtime.xAxis) ? o(Oe[r.runtime.originalXAxis.dataKey]).getTime() : Oe[r.runtime.originalXAxis.dataKey], Ce = (Oe, ht) => Oe[ht], He = (Bn = r.brush) != null && Bn.active && ((Ht = w.data) != null && Ht.length) ? w.data.map((Oe) => ie(Oe)) : t.map((Oe) => ie(Oe)), we = r.orientation === "horizontal" || r.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", ge = { data: t, tableData: n, config: r, minValue: j, maxValue: U, isAllLine: re, existPositiveValue: W, xAxisDataMapped: He, xMax: G, yMax: F }, { min: ke, max: ne, leftMax: Pe, rightMax: $e } = uy(ge), { yScaleRight: qe, hasRightAxis: Ge } = gh({ config: r, yMax: F, data: t, updateConfig: m }), { xScale: Xe, yScale: We, seriesScale: vt, g1xScale: et, g2xScale: Ke, xScaleNoPadding: Be, xScaleBrush: ze } = Tk({ ...ge, min: ke, max: ne, leftMax: Pe, rightMax: $e, dimensions: a }), [gt, Ye] = ce.useState(null);
  ce.useEffect(() => {
    var Oe;
    Ye((Oe = Le == null ? void 0 : Le.current) == null ? void 0 : Oe.getBoundingClientRect());
  }, [Le, r.legend]);
  const dt = (Oe, ht) => {
    if (r.useLogScale && Oe === 0.1 && (Oe = 0), !(r.data && !r.data[ht] && E === "Forest Plot"))
      return r.visualizationType === "Forest Plot" ? r.data[ht][r.xAxis.dataKey] : Cn(L.yAxis) ? f(o(Oe)) : T === "vertical" && ne - ke < 3 ? s(Oe, "left", X, !1, !1, "1") : T === "vertical" ? s(Oe, "left", X) : Oe;
  }, xt = (Oe) => (r.useLogScale && Oe === 0.1 && (Oe = 0), Cn(L.xAxis) && r.visualizationType !== "Forest Plot" ? f(Oe) : T === "horizontal" && r.visualizationType !== "Forest Plot" ? s(Oe, "left", X) : r.xAxis.type === "continuous" && r.visualizationType !== "Forest Plot" ? s(Oe, "bottom", X) : r.visualizationType === "Forest Plot" ? s(Oe, "left", r.dataFormat.abbreviated, r.runtime.xAxis.prefix, r.runtime.xAxis.suffix, Number(r.dataFormat.roundTo)) : Oe), ft = (Oe) => {
    let { numTicks: ht } = L[Oe];
    L[Oe].viewportNumTicks && L[Oe].viewportNumTicks[u] && (ht = L[Oe].viewportNumTicks[u]);
    let it;
    return Oe === "yAxis" && (it = I && !ht ? t.length : I && ht ? ht : !I && !ht ? void 0 : !I && ht && ht, it === void 0 && !r.dataFormat.roundTo && (Number(ne) <= 3 ? it = 2 : it = 4), Number(it) > Number(ne) && (it = Number(ke) < 0 ? Math.round(ne) * 2 : Math.round(ne))), Oe === "xAxis" && (it = I && !ht ? void 0 : I && ht ? ht : !I && !ht ? void 0 : !I && ht && ht, I && it === void 0 && !r.dataFormat.roundTo && (ne <= 3 ? it = 2 : it = 4), r.visualizationType === "Forest Plot" && (it = r.yAxis.numTicks !== "" ? r.yAxis.numTicks : 4)), it;
  }, { tooltipData: lt, showTooltip: Dt, hideTooltip: on, tooltipOpen: Xt, tooltipLeft: tn, tooltipTop: mn } = _g(), {
    handleTooltipMouseOver: zt,
    handleTooltipClick: Vt,
    handleTooltipMouseOff: _e,
    tooltipStyles: En,
    TooltipListItem: nn,
    getXValueFromCoordinateDate: Kt,
    getXValueFromCoordinate: wn
  } = Bg({
    xScale: Xe,
    yScale: We,
    showTooltip: Dt,
    hideTooltip: on
  });
  ce.useEffect(() => {
    document.querySelector(".isEditor") && Z((ht) => !0);
  }), ce.useEffect(() => {
    (de == null ? void 0 : de.isIntersecting) === !0 && r.animate && setTimeout(() => {
      Z((Oe) => !0);
    }, 500);
  }, [de == null ? void 0 : de.isIntersecting, r.animate]);
  const ut = () => {
    const { visualizationType: Oe } = r;
    return Oe === "Combo" && L.forecastingSeriesKeys > 0 || Oe === "Area Chart" || Oe === "Line" || Oe === "Bar";
  }, dn = Number(T === "horizontal" ? r.xAxis.padding : r.yAxis.size), It = { small: 16, medium: 18, large: 20 }, vn = () => r.visualizationType === "Forest Plot" ? r.data.length : ft("yAxis"), xn = () => {
    let Oe = r.xAxis.manualStep;
    return r.xAxis.viewportStepCount && r.xAxis.viewportStepCount[u] && (Oe = r.xAxis.viewportStepCount[u]), Oe;
  }, qt = (Oe) => {
    const ht = Oe.currentTarget.getBoundingClientRect(), it = Oe.clientX - ht.left, nt = Oe.clientY - ht.top;
    ye({
      x: it,
      y: nt
    });
  }, fn = () => {
    let Oe = 40;
    return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Vu, { top: F, left: Number(L.yAxis.size), label: L.xAxis.label, tickFormat: Cn(L.xAxis) ? f : s, scale: et, stroke: "#333", tickStroke: "#333", numTicks: L.xAxis.numTicks || void 0 }, (ht) => /* @__PURE__ */ i.createElement(at, { className: "bottom-axis" }, ht.ticks.map((it, nt) => {
      const ln = it.index !== 0 ? r.yAxis.tickRotation : 0, Gt = it.index !== 0 && r.yAxis.tickRotation && r.yAxis.tickRotation > 0 ? "end" : "middle", Ne = v(it.value, `normal ${It[r.fontSize]}px sans-serif`) * Math.sin(ln * (Math.PI / 180)) + 25;
      return Ne > Oe && (Oe = Ne), /* @__PURE__ */ i.createElement(at, { key: `vx-tick-${it.value}-${nt}`, className: "vx-axis-tick" }, !L.yAxis.hideTicks && /* @__PURE__ */ i.createElement(an, { from: it.from, to: it.to, stroke: "#333" }), !L.yAxis.hideLabel && /* @__PURE__ */ i.createElement(Tt, { x: it.to.x, y: it.to.y, angle: -ln, verticalAnchor: "start", textAnchor: Gt }, s(it.value, "left")));
    }), !L.yAxis.hideAxis && /* @__PURE__ */ i.createElement(an, { from: ht.axisFromPoint, to: ht.axisToPoint, stroke: "#333" }))), /* @__PURE__ */ i.createElement(
      Vu,
      {
        top: F,
        left: Number(L.yAxis.size),
        label: L.xAxis.label,
        tickFormat: Cn(L.xAxis) ? f : L.xAxis.dataKey !== "Year" ? s : (ht) => ht,
        scale: Ke,
        stroke: "#333",
        tickStroke: "#333",
        numTicks: L.xAxis.numTicks || void 0
      },
      (ht) => /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(at, { className: "bottom-axis" }, ht.ticks.map((it, nt) => {
        const ln = it.index !== 0 ? r.yAxis.tickRotation : 0, Gt = it.index !== 0 && r.yAxis.tickRotation && r.yAxis.tickRotation > 0 ? "end" : "middle", Ne = v(it.value, `normal ${It[r.fontSize]}px sans-serif`) * Math.sin(ln * (Math.PI / 180)) + 25;
        return Ne > Oe && (Oe = Ne), /* @__PURE__ */ i.createElement(at, { key: `vx-tick-${it.value}-${nt}`, className: "vx-axis-tick" }, !L.yAxis.hideTicks && /* @__PURE__ */ i.createElement(an, { from: it.from, to: it.to, stroke: "#333" }), !L.yAxis.hideLabel && /* @__PURE__ */ i.createElement(Tt, { x: it.to.x, y: it.to.y, angle: -ln, verticalAnchor: "start", textAnchor: Gt }, s(it.value, "left")));
      }), !L.yAxis.hideAxis && /* @__PURE__ */ i.createElement(an, { from: ht.axisFromPoint, to: ht.axisToPoint, stroke: "#333" })), /* @__PURE__ */ i.createElement(at, null, /* @__PURE__ */ i.createElement(Tt, { x: G / 2, y: Oe + 20, stroke: "#333", textAnchor: "middle", verticalAnchor: "start" }, L.xAxis.label)), Le.current ? Le.current.setAttribute("height", Number(te) + Number(Oe) + (L.xAxis.label ? 50 : 0) + "px") : "")
    ));
  };
  return isNaN(C) ? /* @__PURE__ */ i.createElement(i.Fragment, null) : /* @__PURE__ */ i.createElement(Nr, { component: "LinearChart" }, /* @__PURE__ */ i.createElement("div", { style: { width: `${C}px`, overflow: "visible" }, className: "tooltip-boundary" }, /* @__PURE__ */ i.createElement(
    "svg",
    {
      onMouseMove: qt,
      width: "100%",
      height: te,
      className: `linear ${r.animate ? "animated" : ""} ${ee && r.animate ? "animate" : ""} ${M && "debug"}`,
      role: "img",
      "aria-label": d(r),
      ref: Le,
      style: { overflow: "visible" }
    },
    /* @__PURE__ */ i.createElement(gr, { width: C, height: te, fill: "transparent" }),
    " ",
    !["Spark Line", "Forest Plot"].includes(E) && /* @__PURE__ */ i.createElement(UE, { scale: We, tickLength: r.useLogScale ? 6 : 8, left: Number(L.yAxis.size) - r.yAxis.axisPadding, label: L.yAxis.label || L.yAxis.label, stroke: "#333", tickFormat: (Oe, ht) => dt(Oe, ht), numTicks: vn() }, (Oe) => {
      const ht = r.orientation === "horizontal" ? (Oe.axisToPoint.y - Oe.axisFromPoint.y) / 2 : (Oe.axisFromPoint.y - Oe.axisToPoint.y) / 2, it = F / Oe.ticks.length / 2 - F / Oe.ticks.length * (1 - r.barThickness) + 5;
      return /* @__PURE__ */ i.createElement(at, { className: "left-axis" }, Oe.ticks.map((nt, ln) => {
        const Gt = Oe.ticks[0].to.y, K = 15, Ne = String(nt.value).startsWith("1") || nt.value === 0.1 ? "block" : "none", Ze = Ne === "block" ? 7 : 0, je = { x: nt.to.x - Ze, y: nt.to.y };
        return /* @__PURE__ */ i.createElement(at, { key: `vx-tick-${nt.value}-${ln}`, className: "vx-axis-tick" }, !L.yAxis.hideTicks && /* @__PURE__ */ i.createElement(an, { key: `${nt.value}--hide-hideTicks`, from: nt.from, to: r.useLogScale ? je : nt.to, stroke: r.yAxis.tickColor, display: T === "horizontal" ? "none" : "block" }), L.yAxis.gridLines ? /* @__PURE__ */ i.createElement(an, { key: `${nt.value}--hide-hideGridLines`, display: (r.useLogScale && Ne).toString(), from: { x: nt.from.x + G, y: nt.from.y }, to: nt.from, stroke: "rgba(0,0,0,0.3)" }) : "", T === "horizontal" && O !== "stacked" && r.yAxis.labelPlacement === "On Date/Category Axis" && !r.yAxis.hideLabel && /* @__PURE__ */ i.createElement(
          Tt,
          {
            transform: `translate(${nt.to.x - 5}, ${r.isLollipopChart ? nt.to.y - Gt : nt.to.y - Gt + (Number(r.barHeight * r.series.length) - K) / 2}) rotate(-${r.runtime.horizontal && r.runtime.yAxis.tickRotation || 0})`,
            verticalAnchor: "start",
            textAnchor: "end"
          },
          nt.formattedValue
        ), T === "horizontal" && O === "stacked" && r.yAxis.labelPlacement === "On Date/Category Axis" && !r.yAxis.hideLabel && /* @__PURE__ */ i.createElement(Tt, { transform: `translate(${nt.to.x - 5}, ${nt.to.y - Gt + (Number(r.barHeight) - K) / 2}) rotate(-${L.horizontal ? L.yAxis.tickRotation : 0})`, verticalAnchor: "start", textAnchor: "end" }, nt.formattedValue), T === "horizontal" && E === "Paired Bar" && !r.yAxis.hideLabel && /* @__PURE__ */ i.createElement(Tt, { transform: `translate(${nt.to.x - 5}, ${nt.to.y - Gt + Number(r.barHeight) / 2}) rotate(-${L.horizontal ? L.yAxis.tickRotation : 0})`, textAnchor: "end", verticalAnchor: "middle" }, nt.formattedValue), T === "horizontal" && E === "Deviation Bar" && !r.yAxis.hideLabel && /* @__PURE__ */ i.createElement(Tt, { transform: `translate(${nt.to.x - 5}, ${r.isLollipopChart ? nt.to.y - Gt + 2 : nt.to.y - Gt + Number(r.barHeight) / 2}) rotate(-${L.horizontal ? L.yAxis.tickRotation : 0})`, textAnchor: "end", verticalAnchor: "middle" }, nt.formattedValue), T === "vertical" && E !== "Paired Bar" && !r.yAxis.hideLabel && /* @__PURE__ */ i.createElement(
          Tt,
          {
            display: r.useLogScale ? Ne : "block",
            dx: r.useLogScale ? -6 : 0,
            x: r.runtime.horizontal ? nt.from.x + 2 : nt.to.x,
            y: nt.to.y + (r.runtime.horizontal ? it : 0),
            angle: -Number(r.yAxis.tickRotation) || 0,
            verticalAnchor: r.runtime.horizontal ? "start" : "middle",
            textAnchor: r.runtime.horizontal ? "start" : "end",
            fill: r.yAxis.tickLabelColor
          },
          nt.formattedValue
        ));
      }), !r.yAxis.hideAxis && /* @__PURE__ */ i.createElement(an, { from: Oe.axisFromPoint, to: L.horizontal ? { x: 0, y: r.visualizationType === "Forest Plot" ? te : Number(H) } : Oe.axisToPoint, stroke: "#000" }), We.domain()[0] < 0 && /* @__PURE__ */ i.createElement(an, { from: { x: Oe.axisFromPoint.x, y: We(0) }, to: { x: G, y: We(0) }, stroke: "#333" }), E === "Bar" && T === "horizontal" && Xe.domain()[0] < 0 && /* @__PURE__ */ i.createElement(an, { from: { x: Xe(0), y: 0 }, to: { x: Xe(0), y: F }, stroke: "#333", strokeWidth: 2 }), /* @__PURE__ */ i.createElement(Tt, { className: "y-label", textAnchor: "middle", verticalAnchor: "start", transform: `translate(${-1 * L.yAxis.size}, ${ht}) rotate(-90)`, fontWeight: "bold", fill: r.yAxis.labelColor }, Oe.label));
    }),
    Ge && /* @__PURE__ */ i.createElement(qE, { scale: qe, left: Number(C - r.yAxis.rightAxisSize), label: r.yAxis.rightLabel, tickFormat: (Oe) => s(Oe, "right"), numTicks: L.yAxis.rightNumTicks || void 0, labelOffset: 45 }, (Oe) => {
      const ht = r.orientation === "horizontal" ? (Oe.axisToPoint.y - Oe.axisFromPoint.y) / 2 : (Oe.axisFromPoint.y - Oe.axisToPoint.y) / 2, it = F / Oe.ticks.length / 2 - F / Oe.ticks.length * (1 - r.barThickness) + 5;
      return /* @__PURE__ */ i.createElement(at, { className: "right-axis" }, Oe.ticks.map((nt, ln) => /* @__PURE__ */ i.createElement(at, { key: `vx-tick-${nt.value}-${ln}`, className: "vx-axis-tick" }, !L.yAxis.rightHideTicks && /* @__PURE__ */ i.createElement(an, { from: nt.from, to: nt.to, display: L.horizontal ? "none" : "block", stroke: r.yAxis.rightAxisTickColor }), L.yAxis.rightGridLines ? /* @__PURE__ */ i.createElement(an, { from: { x: nt.from.x + G, y: nt.from.y }, to: nt.from, stroke: "rgba(0,0,0,0.3)" }) : "", !r.yAxis.rightHideLabel && /* @__PURE__ */ i.createElement(Tt, { x: nt.to.x, y: nt.to.y + (L.horizontal ? it : 0), verticalAnchor: L.horizontal ? "start" : "middle", textAnchor: "start", fill: r.yAxis.rightAxisTickLabelColor }, nt.formattedValue))), !r.yAxis.rightHideAxis && /* @__PURE__ */ i.createElement(an, { from: Oe.axisFromPoint, to: Oe.axisToPoint, stroke: "#333" }), /* @__PURE__ */ i.createElement(Tt, { className: "y-label", textAnchor: "middle", verticalAnchor: "start", transform: `translate(${r.yAxis.rightLabelOffsetSize ? r.yAxis.rightLabelOffsetSize : 0}, ${ht}) rotate(-90)`, fontWeight: "bold", fill: r.yAxis.rightAxisLabelColor }, Oe.label));
    }),
    ue && r.topAxis.hasLine && /* @__PURE__ */ i.createElement(
      JE,
      {
        stroke: "#333",
        left: Number(L.yAxis.size),
        scale: Xe,
        hideTicks: !0,
        hideZero: !0,
        tickLabelProps: () => ({
          fill: "transparent"
        })
      }
    ),
    E !== "Paired Bar" && E !== "Spark Line" && /* @__PURE__ */ i.createElement(
      Vu,
      {
        top: L.horizontal && r.visualizationType !== "Forest Plot" ? Number(H) + Number(r.xAxis.axisPadding) : r.visualizationType === "Forest Plot" ? F + Number(r.xAxis.axisPadding) : F,
        left: r.visualizationType !== "Forest Plot" ? Number(L.yAxis.size) : 0,
        label: r[we].label,
        tickFormat: xt,
        scale: Xe,
        stroke: "#333",
        numTicks: ft("xAxis"),
        tickStroke: "#333",
        tickValues: r.xAxis.manual ? Ck(He, Xe, r.xAxis.type === "date-time" ? ft("xAxis") : xn()) : void 0
      },
      (Oe) => {
        const ht = r.visualizationType !== "Forest Plot" ? (Oe.axisToPoint.x - Oe.axisFromPoint.x) / 2 : a[0] / 2, it = (pt) => /\s/.test(pt), nt = Oe.ticks.some((pt) => it(pt.value)), ln = 8, Gt = Math.max(...Oe.ticks.map((pt) => v(pt.formattedValue, `normal ${It[r.fontSize]}px sans-serif`))), K = nt ? 180 : 100, Ne = Oe.ticks.map((pt) => v(pt.formattedValue, `normal ${It[r.fontSize]}px sans-serif`)), Ze = Ne.reduce((pt, Nt) => pt + Nt, K), je = (G - Ze) / (Oe.ticks.length - 1);
        let kt = [0];
        for (let pt = 1; pt < Ne.length; pt++)
          kt[pt] = kt[pt - 1] + Ne[pt - 1] + je;
        let rt = !1;
        Ne.forEach((pt, Nt) => {
          if (kt[Nt] + Ne[Nt] > kt[Nt + 1]) {
            rt = !0;
            return;
          }
        });
        const wt = rt && r.isResponsiveTicks ? Gt + ln + 20 : 0;
        Number(r.xAxis.tickRotation) > 0 && Number(r.xAxis.tickRotation), r.dynamicMarginTop = wt, r.xAxis.tickWidthMax = Gt;
        let Mt = 40;
        const Qe = /* @__PURE__ */ i.createElement(at, { className: "bottom-axis", width: a[0] }, Oe.ticks.map((pt, Nt, _t) => {
          const jt = String(pt.value).startsWith("1") || pt.value === 0.1 ? "block" : "none", Ft = jt === "block" ? 16 : ln, Ct = { x: pt.to.x, y: Ft }, Zt = v(pt.formattedValue, `normal ${It[r.fontSize]}px sans-serif`), Ut = 100 / _t.length;
          r.yAxis.tickRotation = r.isResponsiveTicks && r.orientation === "horizontal" ? 0 : r.yAxis.tickRotation, r.xAxis.tickRotation = r.isResponsiveTicks && r.orientation === "vertical" ? 0 : r.xAxis.tickRotation;
          const Qt = r.isResponsiveTicks && rt ? -Number(r.xAxis.maxTickRotation) || -90 : -Number(r.runtime.xAxis.tickRotation), sn = Zt * Math.sin(Qt * -1 * (Math.PI / 180)) + 25;
          return sn > Mt && (Mt = sn), /* @__PURE__ */ i.createElement(at, { key: `vx-tick-${pt.value}-${Nt}`, className: "vx-axis-tick" }, !r.xAxis.hideTicks && /* @__PURE__ */ i.createElement(an, { from: pt.from, to: T === "horizontal" && r.useLogScale ? Ct : pt.to, stroke: r.xAxis.tickColor, strokeWidth: jt === "block" && r.useLogScale ? 1.3 : 1 }), !r.xAxis.hideLabel && /* @__PURE__ */ i.createElement(
            Tt,
            {
              dy: r.orientation === "horizontal" && r.useLogScale ? 8 : 0,
              display: r.orientation === "horizontal" && r.useLogScale ? jt : "block",
              x: pt.to.x,
              y: pt.to.y,
              angle: Qt,
              verticalAnchor: Qt < -50 ? "middle" : "start",
              textAnchor: Qt ? "end" : "middle",
              width: rt && !r.isResponsiveTicks && !Number(r[we].tickRotation) ? Ut : void 0,
              fill: r.xAxis.tickLabelColor
            },
            pt.formattedValue
          ));
        }), !r.xAxis.hideAxis && /* @__PURE__ */ i.createElement(an, { from: Oe.axisFromPoint, to: Oe.axisToPoint, stroke: "#333" }), /* @__PURE__ */ i.createElement(Tt, { x: ht, y: Mt + 20, textAnchor: "middle", verticalAnchor: "start", fontWeight: "bold", fill: r.xAxis.labelColor }, Oe.label));
        return Le.current && Le.current.setAttribute("height", Number(te) + Number(Mt) + (L.xAxis.label ? 50 : 0) + "px"), Qe;
      }
    ),
    E === "Paired Bar" && fn(),
    E === "Deviation Bar" && ((Fn = r.series) == null ? void 0 : Fn.length) === 1 && /* @__PURE__ */ i.createElement(pk, { animatedChart: ee, xScale: Xe, yScale: We, width: G, height: F }),
    E === "Paired Bar" && /* @__PURE__ */ i.createElement(wk, { originalWidth: C, width: G, height: F }),
    E === "Scatter Plot" && /* @__PURE__ */ i.createElement(
      hk,
      {
        xScale: Xe,
        yScale: We,
        getXAxisData: ie,
        getYAxisData: Ce,
        xMax: G,
        yMax: F,
        handleTooltipMouseOver: zt,
        handleTooltipMouseOff: _e,
        handleTooltipClick: Vt,
        tooltipData: lt,
        showTooltip: Dt
      }
    ),
    E === "Box Plot" && /* @__PURE__ */ i.createElement(fk, { xScale: Xe, yScale: We }),
    (E === "Area Chart" && r.visualizationSubType === "regular" || E === "Combo") && /* @__PURE__ */ i.createElement(ak, { xScale: Xe, yScale: We, yMax: F, xMax: G, chartRef: Le, width: G, height: F, handleTooltipMouseOver: zt, handleTooltipMouseOff: _e, tooltipData: lt, showTooltip: Dt }),
    (E === "Area Chart" && r.visualizationSubType === "stacked" || E === "Combo") && /* @__PURE__ */ i.createElement(ok, { xScale: Xe, yScale: We, yMax: F, xMax: G, chartRef: Le, width: G, height: F, handleTooltipMouseOver: zt, handleTooltipMouseOff: _e, tooltipData: lt, showTooltip: Dt }),
    (E === "Bar" || E === "Combo" || _()) && /* @__PURE__ */ i.createElement(
      dk,
      {
        xScale: Xe,
        yScale: We,
        seriesScale: vt,
        xMax: G,
        yMax: F,
        getXAxisData: ie,
        getYAxisData: Ce,
        animatedChart: ee,
        visible: ee,
        handleTooltipMouseOver: zt,
        handleTooltipMouseOff: _e,
        handleTooltipClick: Vt,
        tooltipData: lt,
        showTooltip: Dt,
        chartRef: Le
      }
    ),
    (E === "Line" && !_() || E === "Combo") && /* @__PURE__ */ i.createElement(
      sm,
      {
        xScale: Xe,
        yScale: We,
        getXAxisData: ie,
        getYAxisData: Ce,
        xMax: G,
        yMax: F,
        seriesStyle: r.series,
        handleTooltipMouseOver: zt,
        handleTooltipMouseOff: _e,
        handleTooltipClick: Vt,
        tooltipData: lt,
        showTooltip: Dt,
        chartRef: Le
      }
    ),
    (E === "Forecasting" || E === "Combo") && /* @__PURE__ */ i.createElement(
      gk,
      {
        showTooltip: Dt,
        tooltipData: lt,
        xScale: Xe,
        yScale: We,
        width: G,
        le: !0,
        height: F,
        xScaleNoPadding: Be,
        chartRef: Le,
        getXValueFromCoordinate: wn,
        handleTooltipMouseOver: zt,
        handleTooltipMouseOff: _e,
        isBrush: !1
      }
    ),
    r.yAxis.anchors && r.yAxis.anchors.map((Oe) => /* @__PURE__ */ i.createElement(an, { strokeDasharray: y(Oe.lineStyle), stroke: "rgba(0,0,0,1)", className: "customAnchor", from: { x: 0 + r.yAxis.size, y: We(Oe.value) }, to: { x: G, y: We(Oe.value) }, display: L.horizontal ? "none" : "block" })),
    E === "Forest Plot" && /* @__PURE__ */ i.createElement(
      kk,
      {
        xScale: Xe,
        yScale: We,
        seriesScale: vt,
        width: C,
        height: te,
        getXAxisData: ie,
        getYAxisData: Ce,
        animatedChart: ee,
        visible: ee,
        handleTooltipMouseOver: zt,
        handleTooltipMouseOff: _e,
        handleTooltipClick: Vt,
        tooltipData: lt,
        showTooltip: Dt,
        chartRef: Le,
        config: r
      }
    ),
    ["Line", "Bar", "Combo", "Area Chart"].includes(r.visualizationType) && !I && /* @__PURE__ */ i.createElement(ew, { xScaleBrush: ze, yScale: We, xMax: G, yMax: F }),
    !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(E) && !_() && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(sm, { xScale: Xe, yScale: We, getXAxisData: ie, getYAxisData: Ce, xMax: G, yMax: F, seriesStyle: r.series })),
    r.yAxis.anchors && r.yAxis.anchors.map((Oe, ht) => {
      let it = We(Oe.value);
      if (!Oe.value)
        return;
      const nt = T === "horizontal" && E === "Bar" ? r.barHeight / 4 : 0;
      if (it)
        return (
          // prettier-ignore
          /* @__PURE__ */ i.createElement(
            an,
            {
              key: `yAxis-${Oe.value}--${ht}`,
              strokeDasharray: y(Oe.lineStyle),
              stroke: Oe.color ? Oe.color : "rgba(0,0,0,1)",
              className: "anchor-y",
              from: { x: 0 + dn, y: it - nt },
              to: { x: C - r.yAxis.rightAxisSize, y: it - nt }
            }
          )
        );
    }),
    r.xAxis.anchors && r.xAxis.anchors.map((Oe, ht) => {
      let it = g;
      T === "horizontal" && (it = N);
      let nt = Cn(it) ? Xe(o(Oe.value, !1)) : Xe(Oe.value);
      if (nt)
        return (
          // prettier-ignore
          /* @__PURE__ */ i.createElement(
            an,
            {
              key: `xAxis-${Oe.value}--${ht}`,
              strokeDasharray: y(Oe.lineStyle),
              stroke: Oe.color ? Oe.color : "rgba(0,0,0,1)",
              fill: Oe.color ? Oe.color : "rgba(0,0,0,1)",
              className: "anchor-x",
              from: { x: Number(nt) + Number(dn), y: 0 },
              to: { x: Number(nt) + Number(dn), y: F }
            }
          )
        );
    }),
    (r.visualizationType !== "Bar" || !_()) && r.visualizationType !== "Combo" && /* @__PURE__ */ i.createElement(mh, { xScale: Xe, handleTooltipClick: Vt, handleTooltipMouseOff: _e, handleTooltipMouseOver: zt, showTooltip: Dt, hideTooltip: on, tooltipData: lt, yMax: F, width: C }),
    ut && Dt && lt && r.visual.verticalHoverLine && /* @__PURE__ */ i.createElement(at, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ i.createElement(an, { from: { x: lt.dataXPosition - 10, y: 0 }, to: { x: lt.dataXPosition - 10, y: F }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "vertical-tooltip-line" })),
    ut && Dt && lt && r.visual.horizontalHoverLine && /* @__PURE__ */ i.createElement(at, { key: "tooltipLine-horizontal", className: "horizontal-tooltip-line", left: r.yAxis.size ? r.yAxis.size : 0 }, /* @__PURE__ */ i.createElement(an, { from: { x: 0, y: lt.dataYPosition }, to: { x: G, y: lt.dataYPosition }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "horizontal-tooltip-line" })),
    r.filters && r.filters.values.length === 0 && t.length === 0 && /* @__PURE__ */ i.createElement(Tt, { x: Number(r.yAxis.size) + Number(G / 2), y: te / 2 - r.xAxis.padding / 2, textAnchor: "middle" }, r.chartMessage.noData),
    (r.visualizationType === "Bar" || _()) && r.tooltips.singleSeries && r.visual.horizontalHoverLine && /* @__PURE__ */ i.createElement(at, { key: "tooltipLine-horizontal", className: "horizontal-tooltip-line", left: r.yAxis.size ? r.yAxis.size : 0 }, /* @__PURE__ */ i.createElement(an, { from: { x: 0, y: se.y }, to: { x: G, y: se.y }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "horizontal-tooltip-line" })),
    (r.visualizationType === "Bar" || _()) && r.tooltips.singleSeries && r.visual.verticalHoverLine && /* @__PURE__ */ i.createElement(at, { key: "tooltipLine-vertical", className: "vertical-tooltip-line" }, /* @__PURE__ */ i.createElement(an, { from: { x: se.x, y: 0 }, to: { x: se.x, y: F }, stroke: "black", strokeWidth: 1, pointerEvents: "none", strokeDasharray: "5,5", className: "vertical-tooltip-line" }))
  ), lt && Object.entries(lt.data).length > 0 && Xt && Dt && lt.dataYPosition && lt.dataXPosition && !r.tooltips.singleSeries && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("style", null, `.tooltip {background-color: rgba(255,255,255, ${r.tooltips.opacity / 100}) !important;`), /* @__PURE__ */ i.createElement("style", null, ".tooltip {max-width:300px} !important; word-wrap: break-word; "), /* @__PURE__ */ i.createElement($g, { key: Math.random(), className: "tooltip cdc-open-viz-module", left: tn, top: mn }, /* @__PURE__ */ i.createElement("ul", null, typeof lt == "object" && Object.entries(lt.data).map((Oe, ht) => /* @__PURE__ */ i.createElement(nn, { item: Oe, key: ht }))))), J() && /* @__PURE__ */ i.createElement(ly, { id: `cdc-open-viz-tooltip-${L.uniqueId}`, variant: "light", arrowColor: "rgba(0,0,0,0)", className: "tooltip", style: { background: `rgba(255,255,255, ${r.tooltips.opacity / 100})`, color: "black" } }), /* @__PURE__ */ i.createElement("div", { className: "animation-trigger", ref: me })));
};
var nw = ["id", "markerWidth", "markerHeight", "markerUnits", "children"];
function Hf() {
  return Hf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Hf.apply(this, arguments);
}
function rw(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function hy(e) {
  var t = e.id, n = e.markerWidth, a = n === void 0 ? 3 : n, r = e.markerHeight, o = r === void 0 ? 3 : r, f = e.markerUnits, u = f === void 0 ? "userSpaceOnUse" : f, s = e.children, d = rw(e, nw);
  return /* @__PURE__ */ i.createElement("defs", null, /* @__PURE__ */ i.createElement("marker", Hf({
    id: t,
    markerWidth: a,
    markerHeight: o,
    markerUnits: u
  }, d), s));
}
hy.propTypes = {
  id: he.string.isRequired,
  size: he.number,
  markerWidth: he.oneOfType([he.string, he.number]),
  markerHeight: he.oneOfType([he.string, he.number]),
  markerUnits: he.string,
  refX: he.oneOfType([he.string, he.number]),
  refY: he.oneOfType([he.string, he.number]),
  strokeWidth: he.number,
  children: he.node.isRequired
};
var aw = ["id", "size", "strokeWidth"];
function Wf() {
  return Wf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    }
    return e;
  }, Wf.apply(this, arguments);
}
function iw(e, t) {
  if (e == null)
    return {};
  var n = {}, a = Object.keys(e), r, o;
  for (o = 0; o < a.length; o++)
    r = a[o], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function ow(e) {
  var t = e.id, n = e.size, a = n === void 0 ? 9 : n, r = e.strokeWidth, o = r === void 0 ? 1 : r, f = iw(e, aw), u = a + o * 2, s = a, d = u / 2, m = "0 0, " + a + " " + a / 2 + ", 0 " + a;
  return /* @__PURE__ */ i.createElement(hy, Wf({
    id: t,
    markerWidth: u,
    markerHeight: u,
    refX: s,
    refY: d,
    orient: "auto",
    markerUnits: "strokeWidth",
    fill: "none",
    strokeWidth: o
  }, f), /* @__PURE__ */ i.createElement("g", {
    transform: "translate(" + o + ", " + o + ")"
  }, /* @__PURE__ */ i.createElement("polyline", {
    points: m
  })));
}
const lw = (e) => {
  var G;
  const { width: t, height: n } = e, { transformedData: a, config: r, parseDate: o, formatDate: f, seriesHighlight: u, formatNumber: s, colorScale: d, handleChartAriaLabels: m } = ce.useContext(Pt);
  let y = Number(t);
  const { minValue: v, maxValue: w } = Nc(r, a), E = { top: 5, right: 10, bottom: 10, left: 10 }, O = Number(n), T = y - r.runtime.yAxis.size, g = O - E.top - 20, N = (F) => r.runtime.xAxis.type === "date" ? o(F[r.runtime.originalXAxis.dataKey]).getTime() : F[r.runtime.originalXAxis.dataKey], L = (F, j) => F[j];
  let M, _;
  const { max: C, min: H } = r.runtime.yAxis, I = Number(C) >= Number(w), X = Number(H) <= Number(v);
  if (a) {
    let F = Number(H && X ? H : v), j = Number(C && I ? C : Number.MIN_VALUE);
    if (j === Number.MIN_VALUE && (j = w), r.runtime.yAxis.paddingPercent) {
      let W = (j - F) * r.runtime.yAxis.paddingPercent;
      F -= W, j += W;
    }
    let U = a.map((W) => N(W));
    r.runtime.horizontal ? (M = Kn({
      domain: [F, j],
      range: [0, T]
    }), _ = r.runtime.xAxis.type === "date" ? Kn({ domain: [Math.min(...U), Math.max(...U)] }) : Yo({ domain: U, padding: 0.5 }), Yo({
      domain: r.runtime.barSeriesKeys || r.runtime.seriesKeys,
      range: [0, g]
    }), _.rangeRound([0, g])) : (F = F < 0 ? F * 1.11 : F, _ = Kn({
      domain: [F, j],
      range: [g - E.bottom, E.top]
    }), M = Yo({
      domain: U,
      range: [E.left, y - E.right]
    }), Yo({
      domain: r.runtime.barSeriesKeys || r.runtime.seriesKeys,
      range: [0, T]
    }));
  }
  const te = [M.domain()[0], M.domain()[M.domain().length - 1]];
  return /* @__PURE__ */ i.createElement(Nr, { component: "SparkLine" }, /* @__PURE__ */ i.createElement("svg", { role: "img", "aria-label": m(r), width: t, height: 100, className: "sparkline", tabIndex: 0 }, /* @__PURE__ */ i.createElement("title", null, `Spark line graphic with the title ${r.title ? r.title : "No Title Found"}`), ((G = r.runtime.lineSeriesKeys) == null ? void 0 : G.length) > 0 ? r.runtime.lineSeriesKeys : r.runtime.seriesKeys.map((F, j) => /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
    at,
    {
      style: { width: y },
      className: "sparkline-group",
      key: `series-${F}`,
      opacity: r.legend.behavior === "highlight" && u.length > 0 && u.indexOf(F) === -1 ? 0.5 : 1,
      display: r.legend.behavior === "highlight" || u.length === 0 || u.indexOf(F) !== -1 ? "block" : "none"
    },
    a.map((U, W) => /* @__PURE__ */ i.createElement(at, { key: `series-${F}-point-${W}` }, /* @__PURE__ */ i.createElement(Tt, { display: r.labels ? "block" : "none", x: M(N(U)), y: _(L(U, F)), fill: d ? d(r.runtime.seriesLabels ? r.runtime.seriesLabels[F] : F) : "#000", textAnchor: "middle" }, s(U[F])))),
    /* @__PURE__ */ i.createElement(
      qr,
      {
        curve: Ac,
        data: a,
        x: (U) => M(N(U)),
        y: (U) => _(L(U, F)),
        stroke: d ? d(r.runtime.seriesLabels ? r.runtime.seriesLabels[F] : F) : "#000",
        strokeWidth: 2,
        strokeOpacity: 1,
        shapeRendering: "geometricPrecision",
        markerEnd: `url(#arrow--${j})`
      }
    ),
    /* @__PURE__ */ i.createElement(ow, { id: `arrow--${j}`, refX: 2, size: 6, markerEnd: `url(#arrow--${j})`, strokeOpacity: 1, fillOpacity: 1, fill: d ? d(r.runtime.seriesLabels ? r.runtime.seriesLabels[F] : F) : "#000" })
  ), /* @__PURE__ */ i.createElement(
    Vu,
    {
      top: g + E.top,
      hideAxisLine: !0,
      hideTicks: !0,
      scale: M,
      tickValues: te,
      tickFormat: (U) => r.xAxis.type === "date" ? f(U) : null,
      stroke: "black",
      tickStroke: "black",
      tickLabelProps: () => ({
        fill: "black",
        fontSize: 11,
        textAnchor: "middle"
      })
    }
  )))));
}, sw = ce.forwardRef((e, t) => {
  const {
    config: n,
    colorScale: a,
    seriesHighlight: r,
    highlight: o,
    tableData: f,
    highlightReset: u,
    transformedData: s,
    currentViewport: d
  } = ce.useContext(Pt);
  if (!n.legend)
    return null;
  const m = Yg(n, f, s, a);
  return !["Box Plot", "Pie"].includes(n.visualizationType) && /* @__PURE__ */ i.createElement(Kg, { ref: t, skipId: e.skipId || "legend", config: n, colorScale: a, seriesHighlight: r, highlight: o, highlightReset: u, currentViewport: d, formatLabels: m });
}), ef = {
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  fontSize: "medium",
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "false",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    showDownloadButton: !1
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !0,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: []
  },
  boxplot: {
    plots: [],
    borders: "true",
    firstQuartilePercentage: 25,
    thirdQuartilePercentage: 75,
    boxWidthPercentage: 40,
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    legend: {
      showHowToReadText: !1,
      howToReadText: ""
    },
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      total: "Total",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 65,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0,
    showSuppressedSymbol: !0,
    showSuppressedLine: !0
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: ""
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    seriesHighlight: []
  },
  brush: {
    height: 25,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, Uu = (e) => /* @__PURE__ */ ce.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ ce.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), uw = ({ name: e }) => {
  var u, s, d, m, y;
  const { config: t, rawData: n, updateConfig: a } = ce.useContext(Pt);
  if (t.visualizationType !== "Forest Plot")
    return;
  const r = (v) => {
    v.orientation === "horizontal" && (v.labels = !1), v.table.show === void 0 && (v.table.show = !isDashboard), v.visualizationType === "Combo" && (v.orientation = "vertical");
  }, o = (v = !0) => {
    let w = {};
    return n.forEach((E) => {
      Object.keys(E).forEach((O) => w[O] = !0);
    }), v && Object.keys(w).forEach((E) => {
      (t.series && t.series.filter((O) => O.dataKey === E).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(E)) && delete w[E];
    }), Object.keys(w);
  }, f = (v, w, E, O) => {
    if (v === "boxplot" && w === "legend") {
      a({
        ...t,
        [v]: {
          ...t[v],
          [w]: {
            ...t.boxplot[w],
            [E]: O
          }
        }
      });
      return;
    }
    if (v === "boxplot" && w === "labels") {
      a({
        ...t,
        [v]: {
          ...t[v],
          [w]: {
            ...t.boxplot[w],
            [E]: O
          }
        }
      });
      return;
    }
    if (v === "forestPlot" && w) {
      let L = {
        ...t,
        [v]: {
          ...t[v],
          [w]: {
            ...t.forestPlot[w],
            [E]: O
          }
        }
      };
      a(L);
      return;
    }
    if (v === "columns" && w !== "" && E !== "") {
      a({
        ...t,
        [v]: {
          ...t[v],
          [w]: {
            ...t[v][w],
            [E]: O
          }
        }
      });
      return;
    }
    if (v === null && w === null) {
      let L = { ...t, [E]: O };
      r(L), a(L);
      return;
    }
    const T = Array.isArray(t[v]);
    let g = T ? [...t[v], O] : { ...t[v], [E]: O };
    w !== null && (T ? (g = [...t[v]], g[w] = { ...g[w], [E]: O }) : typeof O == "string" ? g[w] = O : g = { ...t[v], [w]: { ...t[v][w], [E]: O } });
    let N = { ...t, [v]: g };
    r(N), a(N);
  };
  return /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, e, (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ i.createElement(Uu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: t.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Study Column",
      initial: "Select",
      required: !0,
      updateField: f,
      options: o(!1),
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  ), /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: t.forestPlot.type,
      label: "Forest Plot Type",
      initial: "Select",
      required: !0,
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            type: v.target.value
          }
        }), v.target.value = "";
      },
      options: ["Linear", "Logarithmic"],
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ", /* @__PURE__ */ i.createElement("br", null), /* @__PURE__ */ i.createElement("br", null), " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1.")))
    }
  ), /* @__PURE__ */ i.createElement(Je, { type: "text", value: ((u = t.forestPlot) == null ? void 0 : u.title) || "", updateField: f, section: "forestPlot", fieldName: "title", label: "Plot Title" }), /* @__PURE__ */ i.createElement("br", null), /* @__PURE__ */ i.createElement("hr", null), /* @__PURE__ */ i.createElement("br", null), /* @__PURE__ */ i.createElement("h4", null, "Column Settings"), /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: t.forestPlot.estimateField,
      label: "Point Estimate Column",
      initial: t.forestPlot.estimateField || "Select",
      required: !0,
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            estimateField: v.target.value
          }
        }), v.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: t.forestPlot.shape,
      label: "Point Estimate Shape",
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            shape: v.target.value
          }
        }), v.target.value = "";
      },
      options: ["text", "circle", "square"]
    }
  ), /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: t.forestPlot.lower,
      label: "Lower CI Column",
      required: !0,
      initial: t.forestPlot.lower || "Select",
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            lower: v.target.value
          }
        }), v.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: t.forestPlot.upper,
      label: "Upper CI Column",
      initial: t.forestPlot.upper || "Select",
      required: !0,
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            upper: v.target.value
          }
        }), v.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Pooled Result Column", /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      value: t.forestPlot.pooledResult.column || "",
      label: "Pooled Result Row",
      onChange: (v) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            pooledResult: {
              ...t.forestPlot.pooledResult,
              column: v.target.value
            }
          }
        }), v.target.value = "";
      }
    }
  ))), /* @__PURE__ */ i.createElement(ct, { value: ((d = (s = t.forestPlot) == null ? void 0 : s.lineOfNoEffect) == null ? void 0 : d.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: f }), /* @__PURE__ */ i.createElement("br", null), /* @__PURE__ */ i.createElement("hr", null), /* @__PURE__ */ i.createElement("br", null), /* @__PURE__ */ i.createElement("h4", null, "Width Settings"), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left (%)"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffset || 0,
      onChange: (v) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffset: v.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Left Mobile(%)"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.leftWidthOffsetMobile || 0,
      onChange: (v) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            leftWidthOffsetMobile: v.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right (%)"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffset || 0,
      onChange: (v) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffset: v.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Chart Offset Right Mobile(%)"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "number",
      min: 0,
      max: 100,
      value: t.forestPlot.rightWidthOffsetMobile || 0,
      onChange: (v) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            rightWidthOffsetMobile: v.target.value
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement(Je, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: f, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }), /* @__PURE__ */ i.createElement("br", null), /* @__PURE__ */ i.createElement("hr", null), /* @__PURE__ */ i.createElement("br", null), /* @__PURE__ */ i.createElement("h4", null, "Labels Settings"), /* @__PURE__ */ i.createElement(Je, { type: "text", value: ((m = t.forestPlot) == null ? void 0 : m.leftLabel) || "", updateField: f, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }), /* @__PURE__ */ i.createElement(Je, { type: "text", value: ((y = t.forestPlot) == null ? void 0 : y.rightLabel) || "", updateField: f, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }), /* @__PURE__ */ i.createElement("br", null), /* @__PURE__ */ i.createElement("hr", null), /* @__PURE__ */ i.createElement("br", null), /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: t.forestPlot.radius.scalingColumn,
      label: "Weight Column",
      initial: "Select",
      onChange: (v) => {
        v.target.value !== "" && v.target.value !== "Select" && a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              scalingColumn: v.target.value
            }
          }
        }), v.target.value = "";
      },
      options: o(!1)
    }
  ), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Radius Minimum Size"), /* @__PURE__ */ i.createElement(
    "input",
    {
      min: 3,
      max: 6,
      value: t.forestPlot.radius.min || 3,
      onChange: (v) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              min: Number(v.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  )), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Radius Maximum Size"), /* @__PURE__ */ i.createElement(
    "input",
    {
      min: 7,
      max: 10,
      value: t.forestPlot.radius.max,
      onChange: (v) => {
        a({
          ...t,
          forestPlot: {
            ...t.forestPlot,
            radius: {
              ...t.forestPlot.radius,
              max: Number(v.target.value)
            }
          }
        });
      },
      type: "number",
      label: "Radius Minimum",
      placeholder: " 1"
    }
  ))));
}, il = i.createContext({}), cw = (e) => {
  const { updateConfig: t, config: n, rawData: a } = ce.useContext(Pt), { getColumns: r, selectComponent: o } = e, f = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], u = (s, d, m) => {
    let y = [...n.series];
    if (y[s][m] = d, m === "type" && d === "Bar" && (y[s].axis = "Left"), y[s].type === "Forecasting") {
      let v = Array.from(new Set(a.map((E) => E[y[s].dataKey]))), w = [];
      v.forEach((E) => {
        w.push({ key: E });
      }), y[s].stages = w, y[s].stageColumn = y[s].dataKey;
    }
    t({ ...n, series: y });
  };
  return /* @__PURE__ */ i.createElement(il.Provider, { value: { updateSeries: u, supportedRightAxisTypes: f, getColumns: r, selectComponent: o } }, e.children);
}, dw = (e) => {
  const { config: t, updateConfig: n } = ce.useContext(Pt), { series: a, index: r } = e;
  if (!(() => {
    let s = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart"].some((m) => m.includes(a.type)) && (s = !0), s;
  })())
    return;
  const f = (s, d) => {
    let m = [...t.series];
    m[s].lineType = d, n({ ...t, series: m });
  };
  let u = [];
  return Object.keys(Sc).map((s) => u.push(Sc[s])), /* @__PURE__ */ i.createElement(
    Ha,
    {
      initial: "Select an option",
      value: a.lineType ? a.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (s) => {
        f(r, s.target.value);
      },
      options: u
    }
  );
}, fw = (e) => {
  const { config: t } = ce.useContext(Pt), { updateSeries: n } = ce.useContext(il), { index: a, series: r } = e, o = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo"].includes(t.visualizationType))
    return /* @__PURE__ */ i.createElement(
      Ha,
      {
        initial: "Select an option",
        value: r.type,
        label: "Series Type",
        onChange: (f) => {
          n(a, f.target.value, "type");
        },
        options: o()
      }
    );
}, hw = (e) => {
  const { config: t, updateConfig: n, rawData: a } = ce.useContext(Pt), { updateSeries: r, getColumns: o } = ce.useContext(il), { index: f, series: u } = e;
  return /* @__PURE__ */ i.createElement(
    Ha,
    {
      initial: "Select an option",
      value: u.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (s) => {
        let d = [], m = new Set(a == null ? void 0 : a.map((v) => v[s.target.value]));
        m = Array.from(m), m = m.filter((v) => v !== void 0), m.forEach((v) => d.push({ key: v }));
        const y = [...t.series];
        y[f] = { ...y[f], stages: d, stageColumn: s.target.value }, n({
          ...t,
          series: y
        });
      },
      options: o(!1)
    }
  );
}, pw = (e) => {
  const { config: t, rawData: n } = ce.useContext(Pt), { updateSeries: a } = ce.useContext(il), { index: r, series: o } = e;
  if (o.type !== "Forecasting" || !n || !o.stageColumn)
    return;
  let f = new Set(n.map((u) => u[o.stageColumn]));
  return f = Array.from(f), f = f.filter((u) => u !== void 0), /* @__PURE__ */ i.createElement(
    Ha,
    {
      initial: "Select an option",
      value: o.stageItem,
      label: "Forecasting Item Column",
      onChange: (u) => {
        a(r, u.target.value, "stageItem");
      },
      options: f
    }
  );
}, mw = (e) => {
  const { config: t } = ce.useContext(Pt), { updateSeries: n, supportedRightAxisTypes: a } = ce.useContext(il), { index: r, series: o } = e;
  if (!(t.visualizationType !== "Combo" || !o) && a.includes(o.type))
    return /* @__PURE__ */ i.createElement(
      Ha,
      {
        initial: "Select an option",
        value: o.axis ? o.axis : "Left",
        label: "Series Axis",
        onChange: (f) => {
          n(r, f.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, gw = (e) => {
  var o;
  const { config: t, updateConfig: n } = ce.useContext(Pt), { index: a, series: r } = e;
  if (r.type === "Forecasting" && r)
    return (o = r == null ? void 0 : r.stages) == null ? void 0 : o.map((f, u) => {
      var s, d, m, y;
      return /* @__PURE__ */ i.createElement(
        Ha,
        {
          key: `${f}--${u}`,
          initial: "Select an option",
          value: (d = (s = t.series) == null ? void 0 : s[a].stages) != null && d[u].color ? (y = (m = t.series) == null ? void 0 : m[a].stages) == null ? void 0 : y[u].color : "Select",
          label: `${f.key} Series Color`,
          onChange: (v) => {
            const w = [...t.series], E = w[a].stages;
            E[u].color = v.target.value, w[a] = { ...w[a], stages: E }, n({
              ...t,
              series: w
            });
          },
          options: Object.keys(Yu)
        }
      );
    });
}, yw = (e) => {
  var f;
  const { config: t, updateConfig: n } = ce.useContext(Pt), { series: a, index: r } = e, { getColumns: o } = ce.useContext(il);
  if (a.type === "Forecasting")
    return /* @__PURE__ */ i.createElement("div", { className: "edit-block" }, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Confidence Interval Groups"), /* @__PURE__ */ i.createElement("fieldset", null, /* @__PURE__ */ i.createElement(_i, { allowZeroExpanded: !0 }, (f = a == null ? void 0 : a.confidenceIntervals) == null ? void 0 : f.map((u, s) => {
      const d = u.showInTooltip ? u.showInTooltip : !1, m = (y, v, w) => {
        y.preventDefault();
        let E = [...t.series];
        E[v].confidenceIntervals[w].showInTooltip = !d, n({
          ...t,
          series: E
        });
      };
      return /* @__PURE__ */ i.createElement(Dn, { className: "series-item series-item--chart", key: `${s}` }, /* @__PURE__ */ i.createElement(On, { className: "series-item__title" }, /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Mn, { className: "accordion__button accordion__button" }, "Group ", s + 1, /* @__PURE__ */ i.createElement(
        "button",
        {
          className: "series-list__remove",
          onClick: (y) => {
            y.preventDefault();
            const v = [...t.series[r].confidenceIntervals];
            v.splice(s, 1);
            const w = [...t.series];
            w[r] = { ...w[r], confidenceIntervals: [...v] }, n({
              ...t,
              series: w
            });
          }
        },
        "Remove"
      )))), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement("div", { className: "input-group" }, /* @__PURE__ */ i.createElement("label", { htmlFor: "showInTooltip" }, "Show In Tooltip"), /* @__PURE__ */ i.createElement("div", { className: "cove-input__checkbox--small", onClick: (y) => m(y, r, s) }, /* @__PURE__ */ i.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, d && /* @__PURE__ */ i.createElement(Rm, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ i.createElement("input", { className: "cove-input--hidden", type: "checkbox", name: "showInTooltip", checked: d || !1, readOnly: !0 }))), /* @__PURE__ */ i.createElement(
        Ha,
        {
          initial: "Select an option",
          value: t.series[r].confidenceIntervals[s].low ? t.series[r].confidenceIntervals[s].low : "Select",
          label: "Low Confidence Interval",
          onChange: (y) => {
            const v = [...t.series[r].confidenceIntervals];
            v[s].low = y.target.value;
            const w = [...t.series];
            w[r] = { ...w[r], confidenceIntervals: v }, n({
              ...t,
              series: w
            });
          },
          options: o()
        }
      ), /* @__PURE__ */ i.createElement(
        Ha,
        {
          initial: "Select an option",
          value: t.series[r].confidenceIntervals[s].high ? t.series[r].confidenceIntervals[s].high : "Select",
          label: "High Confidence Interval",
          onChange: (y) => {
            const v = [...t.series[r].confidenceIntervals];
            v[s].high = y.target.value;
            const w = [...t.series];
            w[r] = { ...w[r], confidenceIntervals: v }, n({
              ...t,
              series: w
            });
          },
          options: o()
        }
      )));
    })), /* @__PURE__ */ i.createElement(
      "button",
      {
        className: "btn full-width",
        onClick: (u) => {
          u.preventDefault();
          let s = null;
          t.series[r].confidenceIntervals ? s = [...t.series[r].confidenceIntervals] : s = [];
          const d = [...t.series];
          d[r] = { ...d[r], confidenceIntervals: [...s, { high: "", low: "" }] }, n({
            ...t,
            series: d
          });
        }
      },
      "Add Confidence Interval Group"
    )));
}, vw = (e) => {
  const { series: t, index: n } = e, { config: a, updateConfig: r } = ce.useContext(Pt);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const f = (u, s, d, m) => {
    let y = [...a.series], v = { ...a.runtime.seriesLabels };
    y[u].weight = s && Math.max(Number(d), Math.min(Number(m), Number(s))), v[y[u].dataKey] = y[u].weight ? y[u].weight : y[u].dataKey;
    const w = {
      ...a,
      series: y,
      runtime: {
        ...a.runtime,
        seriesLabels: v
      }
    };
    r(w);
  };
  return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("label", { htmlFor: "series-weight" }, "Line Weight"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "number",
      key: `series-weight-${n}`,
      value: t.weight ? t.weight : "",
      min: "1",
      max: "9",
      onChange: (u) => {
        f(n, u.target.value, u.target.min, u.target.max);
      }
    }
  ));
}, xw = (e) => {
  const { series: t, index: n } = e, { config: a, updateConfig: r } = ce.useContext(Pt);
  if (!["Bar", "Line", "Area Chart", "Combo", "Deviation Bar", "Paired Bar", "Scatter Plot", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const f = (u, s) => {
    let d = [...a.series], m = { ...a.runtime.seriesLabels };
    d[u].name = s, m[d[u].dataKey] = d[u].name ? d[u].name : d[u].dataKey;
    let y = {
      ...a,
      series: d,
      runtime: {
        ...a.runtime,
        seriesLabels: m
      }
    };
    r(y);
  };
  return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("label", { htmlFor: "series-name" }, "Series Name"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      key: `series-name-${n}`,
      value: t.name ? t.name : "",
      onChange: (u) => {
        f(n, u.target.value);
      }
    }
  ));
}, bw = (e) => {
  const { series: t, index: n } = e, { config: a, updateConfig: r } = ce.useContext(Pt);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(a.visualizationType))
    return;
  const o = (f) => {
    let u = [...a.series];
    u[f].tooltip && u[f].tooltip, u[f].tooltip = !u[f].tooltip, r({
      ...a,
      series: u
    });
  };
  return /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("div", { className: "input-group" }, /* @__PURE__ */ i.createElement("label", { htmlFor: `series-tooltip--${n}` }, "Show In Tooltip"), /* @__PURE__ */ i.createElement("div", { className: "cove-input__checkbox--small", onClick: (f) => o(n) }, /* @__PURE__ */ i.createElement("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" } }, t.tooltip && /* @__PURE__ */ i.createElement(Rm, { className: "", style: { fill: "#025eaa" } })), /* @__PURE__ */ i.createElement("input", { className: "cove-input--hidden", type: "checkbox", name: `series-tooltip--${n}`, checked: t.tooltip ? t.tooltip : !1, readOnly: !0 }))));
}, Sw = (e) => {
  const { config: t, updateConfig: n } = ce.useContext(Pt), { series: a, index: r } = e, o = (u) => {
    let s = [...t.series], d = -1;
    for (let m = 0; m < s.length; m++)
      if (s[m].dataKey === u) {
        d = m;
        break;
      }
    if (d !== -1) {
      s.splice(d, 1);
      let m = { ...t, series: s };
      s.length === 0 && delete m.series, n(m);
    }
    t.visualizationType === "Paired Bar" && n({
      ...t,
      series: []
    });
  }, f = (u, s, d) => {
    u.preventDefault(), o(s.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ i.createElement("button", { className: "series-list__remove", onClick: (u) => f(u, a) }, "Remove");
}, py = (e) => {
  const { config: t } = ce.useContext(Pt), { series: n, getItemStyle: a, sortableItemStyles: r, chartsWithOptions: o, index: f } = e;
  return /* @__PURE__ */ i.createElement(xy, { key: n.dataKey, draggableId: `draggableFilter-${n.dataKey}`, index: f }, (u, s) => /* @__PURE__ */ i.createElement("div", { key: f, className: s.isDragging ? "currently-dragging" : "", style: a(s.isDragging, u.draggableProps.style, r), ref: u.innerRef, ...u.draggableProps, ...u.dragHandleProps }, /* @__PURE__ */ i.createElement(_i, { allowZeroExpanded: !0 }, /* @__PURE__ */ i.createElement(Dn, { className: "series-item series-item--chart" }, /* @__PURE__ */ i.createElement(On, { className: "series-item__title" }, /* @__PURE__ */ i.createElement(Mn, { className: o.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow" }, /* @__PURE__ */ i.createElement(mt, { display: "move", size: 15, style: { cursor: "default" } }), n.dataKey, /* @__PURE__ */ i.createElement(Kr.Button.Remove, { series: n, index: f }))), o.includes(t.visualizationType) && /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement(Kr.Input.Name, { series: n, index: f }), /* @__PURE__ */ i.createElement(Kr.Input.Weight, { series: n, index: f }), /* @__PURE__ */ i.createElement(Kr.Dropdown.SeriesType, { series: n, index: f }), /* @__PURE__ */ i.createElement(Kr.Dropdown.AxisPosition, { series: n, index: f }), /* @__PURE__ */ i.createElement(Kr.Dropdown.LineType, { series: n, index: f }), /* @__PURE__ */ i.createElement(Kr.Dropdown.ForecastingColor, { series: n, index: f }), /* @__PURE__ */ i.createElement(Kr.Dropdown.ConfidenceInterval, { series: n, index: f }), /* @__PURE__ */ i.createElement(Kr.Checkbox.DisplayInTooltip, { series: n, index: f }))))));
}, Ew = (e) => {
  const { series: t, getItemStyle: n, sortableItemStyles: a, chartsWithOptions: r } = e;
  return t.map((o, f) => /* @__PURE__ */ i.createElement(py, { getItemStyle: n, sortableItemStyles: a, chartsWithOptions: r, series: o, index: f, key: `series-list-${f}` }));
}, Kr = {
  Wrapper: cw,
  Dropdown: {
    SeriesType: fw,
    AxisPosition: mw,
    ConfidenceInterval: yw,
    LineType: dw,
    ForecastingStage: hw,
    ForecastingColumn: pw,
    ForecastingColor: gw
  },
  Input: {
    Name: xw,
    Weight: vw
  },
  Checkbox: {
    DisplayInTooltip: bw
  },
  Button: {
    Remove: Sw
  },
  Item: py,
  List: Ew
}, kw = ce.memo(({ config: e, updateConfig: t }) => {
  let n = (s, d, m) => {
    let y = [];
    e.regions && (y = [...e.regions]), y[m][s] = d, t({ ...e, regions: y });
  }, a = (s, d, m, y, v) => n(m, y, v), r = (s) => {
    let d = [];
    e.regions && (d = [...e.regions]), d.splice(s, 1), t({ ...e, regions: d });
  }, o = () => {
    let s = [];
    e.regions && (s = [...e.regions]), s.push({}), t({ ...e, regions: s });
  };
  const f = ["Fixed", "Previous Days"], u = ["Last Date", "Fixed"];
  return /* @__PURE__ */ i.createElement(i.Fragment, null, e.regions && e.regions.map(({ label: s, color: d, from: m, to: y, background: v, range: w = "Custom" }, E) => {
    var O;
    return /* @__PURE__ */ i.createElement("div", { className: "edit-block", key: `region-${E}` }, /* @__PURE__ */ i.createElement(
      "button",
      {
        type: "button",
        className: "remove-column",
        onClick: (T) => {
          T.preventDefault(), r(E);
        }
      },
      "Remove"
    ), /* @__PURE__ */ i.createElement(Je, { value: s, label: "Region Label", fieldName: "label", i: E, updateField: a }), /* @__PURE__ */ i.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ i.createElement(Je, { value: d, label: "Text Color", fieldName: "color", updateField: (T, g, N, L) => n(N, L, E) }), /* @__PURE__ */ i.createElement(Je, { value: v, label: "Background", fieldName: "background", updateField: (T, g, N, L) => n(N, L, E) })), /* @__PURE__ */ i.createElement(
      Lt,
      {
        value: e.regions[E].fromType ?? "Fixed",
        label: "Minimum Region Type",
        initial: "Select",
        required: !0,
        onChange: (T) => {
          if (T.target.value !== "" && T.target.value !== "Select") {
            const g = [...e.regions];
            g[E].fromType = T.target.value, t({
              ...e,
              regions: g
            });
          }
          T.target.value = "";
        },
        options: f
      }
    ), (e.regions[E].fromType === "Fixed" || e.regions[E].fromType === "Previous Days" || !e.regions[E].fromType) && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
      Je,
      {
        value: m,
        label: e.regions[E].fromType === "Fixed" || !((O = e.regions[E]) != null && O.fromType) ? "From Value" : "Previous Number of Days",
        fieldName: "from",
        updateField: (T, g, N, L) => n(N, L, E),
        tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value.")))
      }
    )), /* @__PURE__ */ i.createElement(
      Lt,
      {
        value: e.regions[E].toType ?? "Fixed",
        label: "Maximum Region Type",
        initial: "Select",
        required: !0,
        onChange: (T) => {
          if (T.target.value !== "" && T.target.value !== "Select") {
            const g = [...e.regions];
            g[E].toType = T.target.value, t({
              ...e,
              regions: g
            });
          }
          T.target.value = "";
        },
        options: u
      }
    ), (e.regions[E].toType === "Fixed" || !e.regions[E].toType) && /* @__PURE__ */ i.createElement(Je, { value: y, label: "To Value", fieldName: "to", updateField: (T, g, N, L) => n(N, L, E) }));
  }), !e.regions && /* @__PURE__ */ i.createElement("p", { style: { textAlign: "center" } }, "There are currently no regions."), /* @__PURE__ */ i.createElement(
    "button",
    {
      type: "button",
      className: "btn full-width",
      onClick: (s) => {
        s.preventDefault(), o();
      }
    },
    "Add Region"
  ));
}), ww = ({ name: e }) => {
  const { visSupportsRegions: t } = Ms(), { config: n, updateConfig: a } = ce.useContext(Pt);
  return t() ? /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, e)), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement(kw, { config: n, updateConfig: a }))) : null;
}, Rh = ce.createContext(null), Dh = () => {
  const e = ce.useContext(Rh);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, Tw = (e) => {
  const { config: t } = ce.useContext(Pt), { updateField: n } = Dh(), { enabledChartTypes: a, visHasNumbersOnBars: r, visHasLabelOnData: o, visSupportsChartHeight: f, visSupportsSuperTitle: u, visSupportsFootnotes: s } = Ms(), { visualizationType: d, visualizationSubType: m, barStyle: y } = t, v = () => (d === "Bar" || d === "Deviation Bar") && m !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ i.createElement(Dn, null, " ", /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, "General")), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement(Lt, { value: d, fieldName: "visualizationType", label: "Chart Type", updateField: n, options: a }), (d === "Bar" || d === "Combo" || d === "Area Chart") && /* @__PURE__ */ i.createElement(Lt, { value: m || "Regular", fieldName: "visualizationSubType", label: "Chart Subtype", updateField: n, options: ["regular", "stacked"] }), d === "Area Chart" && m === "stacked" && /* @__PURE__ */ i.createElement(Lt, { value: t.stackedAreaChartLineType || "Linear", fieldName: "stackedAreaChartLineType", label: "Stacked Area Chart Line Type", updateField: n, options: Object.keys(Sc) }), d === "Bar" && /* @__PURE__ */ i.createElement(Lt, { value: t.orientation || "vertical", fieldName: "orientation", label: "Orientation", updateField: n, options: ["vertical", "horizontal"] }), d === "Deviation Bar" && /* @__PURE__ */ i.createElement(Lt, { label: "Orientation", options: ["horizontal"] }), (d === "Bar" || d === "Deviation Bar") && /* @__PURE__ */ i.createElement(Lt, { value: t.isLollipopChart ? "lollipop" : y || "flat", fieldName: "barStyle", label: "bar style", updateField: n, options: v() }), (d === "Bar" || d === "Deviation Bar") && y === "rounded" && /* @__PURE__ */ i.createElement(Lt, { value: t.tipRounding || "top", fieldName: "tipRounding", label: "tip rounding", updateField: n, options: ["top", "full"] }), (d === "Bar" || d === "Deviation Bar") && y === "rounded" && /* @__PURE__ */ i.createElement(Lt, { value: t.roundingStyle || "standard", fieldName: "roundingStyle", label: "rounding style", updateField: n, options: ["standard", "shallow", "finger"] }), d === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ i.createElement(Lt, { value: t.yAxis.labelPlacement || "Below Bar", section: "yAxis", fieldName: "labelPlacement", label: "Label Placement", updateField: n, options: ["Below Bar", "On Date/Category Axis"] }), r() ? /* @__PURE__ */ i.createElement(ct, { value: t.yAxis.displayNumbersOnBar, section: "yAxis", fieldName: "displayNumbersOnBar", label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar", updateField: n }) : o() && /* @__PURE__ */ i.createElement(
    ct,
    {
      value: t.labels,
      fieldName: "labels",
      label: "Display label on data",
      updateField: n,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'Selecting this option will not hide the display of "zero value", "suppressed data", or "no data" indicators on the chart (if applicable).')))
    }
  ), d === "Pie" && /* @__PURE__ */ i.createElement(Lt, { fieldName: "pieType", label: "Pie Chart Type", updateField: n, options: ["Regular", "Donut"] }), d === "Line" && /* @__PURE__ */ i.createElement(
    ct,
    {
      value: t.allowLineToBarGraph,
      fieldName: "allowLineToBarGraph",
      label: "Convert to Bar Graph",
      updateField: n,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Switch to bar graph when less than 3 data points available.")))
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      value: t.title || "Chart Title",
      fieldName: "title",
      id: "title",
      label: "Title",
      placeholder: "Chart Title",
      updateField: n,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Title is required to set the name of the download file but can be hidden using the option below.")))
    }
  ), /* @__PURE__ */ i.createElement(ct, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: n }), u() && /* @__PURE__ */ i.createElement(
    Je,
    {
      value: t.superTitle,
      updateField: n,
      fieldName: "superTitle",
      label: "Super Title",
      placeholder: "Super Title",
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Super Title")))
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      type: "textarea",
      value: t.introText,
      updateField: n,
      fieldName: "introText",
      label: "Message",
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Intro Text")))
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      type: "textarea",
      value: t.description,
      fieldName: "description",
      label: "Subtext/Citation",
      updateField: n,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub.")))
    }
  ), s() && /* @__PURE__ */ i.createElement(
    Je,
    {
      type: "textarea",
      value: t.footnotes,
      updateField: n,
      fieldName: "footnotes",
      label: "Footnotes",
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data.")))
    }
  ), f() && t.orientation === "vertical" && /* @__PURE__ */ i.createElement(Je, { type: "number", value: t.heights.vertical, section: "heights", fieldName: "vertical", label: "Chart Height", updateField: n })));
}, Cw = (e) => {
  const { config: t } = ce.useContext(Pt), { boxplot: n } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: a } = Dh();
  return /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, e.name)), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement("h4", { style: { fontSize: "18px" } }, "Labels for 5-Number Summary"), /* @__PURE__ */ i.createElement(
    Je,
    {
      type: "text",
      value: n.labels.maximum,
      fieldName: "maximum",
      section: "boxplot",
      subsection: "labels",
      label: "Maximum",
      updateField: a,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Highest value, excluding outliers")))
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      type: "text",
      value: n.labels.q3,
      fieldName: "q3",
      section: "boxplot",
      subsection: "labels",
      label: "Upper Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Represented by top line of box. 25% of data are higher.")))
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      type: "text",
      value: n.labels.median,
      fieldName: "median",
      section: "boxplot",
      subsection: "labels",
      label: "Median",
      updateField: a,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Middle data point. Half of data are higher value.")))
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      type: "text",
      value: n.labels.q1,
      fieldName: "q1",
      section: "boxplot",
      subsection: "labels",
      label: "Lower Quartile",
      updateField: a,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Represented by bottom line of box. 25% of data are lower.")))
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      type: "text",
      value: n.labels.minimum,
      fieldName: "minimum",
      section: "boxplot",
      subsection: "labels",
      label: "Minimum",
      updateField: a,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Lowest value, excluding outliers")))
    }
  ), /* @__PURE__ */ i.createElement("br", null), /* @__PURE__ */ i.createElement("h4", { style: { fontSize: "18px" } }, "Labels for Additional Measures"), /* @__PURE__ */ i.createElement(Je, { type: "text", value: n.labels.iqr, fieldName: "iqr", section: "boxplot", subsection: "labels", label: "Interquartile Range", updateField: a }), /* @__PURE__ */ i.createElement(Je, { type: "text", value: n.labels.total, fieldName: "total", section: "boxplot", subsection: "labels", label: "Total", updateField: a }), /* @__PURE__ */ i.createElement(Je, { type: "text", value: n.labels.mean, fieldName: "mean", section: "boxplot", subsection: "labels", label: "Mean", updateField: a }), /* @__PURE__ */ i.createElement(Je, { type: "text", value: n.labels.outliers, fieldName: "outliers", section: "boxplot", subsection: "labels", label: "Outliers", updateField: a }), /* @__PURE__ */ i.createElement(Je, { type: "text", value: n.labels.values, fieldName: "values", section: "boxplot", subsection: "labels", label: "Values", updateField: a })));
}, Aw = (e, t) => {
  let n = [], a = [], r = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const o = e.twoColor.isPaletteReversed;
    n = Object.keys(Ku).filter((f) => o ? f.endsWith("reverse") : !f.endsWith("reverse"));
  } else {
    const o = [], f = [];
    for (const u in dr) {
      const s = u.startsWith("sequential"), d = u.startsWith("qualitative"), m = u.endsWith("reverse");
      s && (!e.isPaletteReversed && !m || e.isPaletteReversed && m) && o.push(u), d && (!e.isPaletteReversed && !m || e.isPaletteReversed && m) && f.push(u);
    }
    a = o, r = f;
  }
  return ce.useEffect(() => {
    let o = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (o = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (o = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: o } });
  }, [e.twoColor.isPaletteReversed]), ce.useEffect(() => {
    let o = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (o = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (o = e.palette.slice(0, -7)), t({ ...e, palette: o });
  }, [e.isPaletteReversed]), { twoColorPalettes: n, sequential: a, nonSequential: r };
}, Pw = (e) => {
  var H;
  const { config: t, updateConfig: n, colorPalettes: a, twoColorPalette: r } = ce.useContext(Pt), { visual: o } = t, { setLollipopShape: f, updateField: u } = Dh(), { visHasBarBorders: s, visCanAnimate: d, visSupportsNonSequentialPallete: m, headerColors: y, visSupportsTooltipOpacity: v, visSupportsTooltipLines: w, visSupportsBarSpace: E, visSupportsBarThickness: O, visHasDataCutoff: T, visSupportsSequentialPallete: g, visSupportsReverseColorPalette: N } = Ms(), { twoColorPalettes: L, sequential: M, nonSequential: _ } = Aw(t, n), C = (I, X) => {
    if (console.log("value", X), I === "storyNodeFontColor") {
      n({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: X
        }
      });
      return;
    } else
      n({
        ...t,
        sankey: {
          ...t.sankey,
          [I]: {
            ...t.sankey[I],
            default: X
          }
        }
      });
  };
  return /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, "Visual")), /* @__PURE__ */ i.createElement(_n, null, t.isLollipopChart && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("fieldset", { className: "header" }, /* @__PURE__ */ i.createElement("legend", { className: "edit-label" }, "Lollipop Shape"), /* @__PURE__ */ i.createElement(
    "div",
    {
      onChange: (I) => {
        f(I.target.value);
      }
    },
    /* @__PURE__ */ i.createElement("label", { className: "radio-label" }, /* @__PURE__ */ i.createElement("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }), "Circle"),
    /* @__PURE__ */ i.createElement("label", { className: "radio-label" }, /* @__PURE__ */ i.createElement("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }), "Square")
  )), /* @__PURE__ */ i.createElement(Lt, { value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone", fieldName: "lollipopColorStyle", label: "Lollipop Color Style", updateField: u, options: ["regular", "two-tone"] }), /* @__PURE__ */ i.createElement(Lt, { value: t.lollipopSize ? t.lollipopSize : "small", fieldName: "lollipopSize", label: "Lollipop Size", updateField: u, options: ["small", "medium", "large"] })), t.visualizationType === "Box Plot" && /* @__PURE__ */ i.createElement("fieldset", { className: "fieldset fieldset--boxplot" }, /* @__PURE__ */ i.createElement("legend", { className: "" }, "Box Plot Settings"), /* @__PURE__ */ i.createElement(Lt, { value: t.boxplot.borders, fieldName: "borders", section: "boxplot", label: "Box Plot Borders", updateField: u, options: ["true", "false"] }), /* @__PURE__ */ i.createElement(ct, { value: t.boxplot.plotOutlierValues, fieldName: "plotOutlierValues", section: "boxplot", label: "Plot Outliers", updateField: u }), /* @__PURE__ */ i.createElement(ct, { value: t.boxplot.plotNonOutlierValues, fieldName: "plotNonOutlierValues", section: "boxplot", label: "Plot non-outlier values", updateField: u })), /* @__PURE__ */ i.createElement(Lt, { value: t.fontSize, fieldName: "fontSize", label: "Font Size", updateField: u, options: ["small", "medium", "large"] }), s() && /* @__PURE__ */ i.createElement(Lt, { value: t.barHasBorder, fieldName: "barHasBorder", label: "Bar Borders", updateField: u, options: ["true", "false"] }), d() && /* @__PURE__ */ i.createElement(ct, { value: t.animate, fieldName: "animate", label: "Animate Visualization", updateField: u }), (((H = t.series) == null ? void 0 : H.some((I) => I.type === "Line" || I.type === "dashed-lg" || I.type === "dashed-sm" || I.type === "dashed-md")) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Lt, { value: t.lineDatapointStyle, fieldName: "lineDatapointStyle", label: "Line Datapoint Style", updateField: u, options: ["hidden", "hover", "always show"] }), /* @__PURE__ */ i.createElement(Lt, { value: t.lineDatapointColor, fieldName: "lineDatapointColor", label: "Line Datapoint Color", updateField: u, options: ["Same as Line", "Lighter than Line"] })), /* @__PURE__ */ i.createElement("label", { className: "header" }, /* @__PURE__ */ i.createElement("span", { className: "edit-label" }, "Header Theme"), /* @__PURE__ */ i.createElement("ul", { className: "color-palette" }, y.map((I) => /* @__PURE__ */ i.createElement(
    "button",
    {
      title: I,
      key: I,
      onClick: (X) => {
        X.preventDefault(), n({ ...t, theme: I });
      },
      className: t.theme === I ? "selected " + I : I
    }
  )))), (m() || m()) && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label" }, "Chart Color Palette")), N() && /* @__PURE__ */ i.createElement(Hh, { fieldName: "isPaletteReversed", size: "small", label: "Use selected palette in reverse order", updateField: u, value: t.isPaletteReversed }), g() && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("span", null, "Sequential"), /* @__PURE__ */ i.createElement("ul", { className: "color-palette" }, M.map((I) => {
    const X = {
      backgroundColor: a[I][2]
    }, te = {
      backgroundColor: a[I][3]
    }, G = {
      backgroundColor: a[I][5]
    };
    return /* @__PURE__ */ i.createElement(
      "button",
      {
        title: I,
        key: I,
        onClick: (F) => {
          F.preventDefault(), n({ ...t, palette: I });
        },
        className: t.palette === I ? "selected" : ""
      },
      /* @__PURE__ */ i.createElement("span", { style: X }),
      /* @__PURE__ */ i.createElement("span", { style: te }),
      /* @__PURE__ */ i.createElement("span", { style: G })
    );
  }))), m() && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("span", null, "Non-Sequential"), /* @__PURE__ */ i.createElement("ul", { className: "color-palette" }, _.map((I) => {
    const X = {
      backgroundColor: a[I][2]
    }, te = {
      backgroundColor: a[I][4]
    }, G = {
      backgroundColor: a[I][6]
    };
    return /* @__PURE__ */ i.createElement(
      "button",
      {
        title: I,
        key: I,
        onClick: (F) => {
          F.preventDefault(), n({ ...t, palette: I });
        },
        className: t.palette === I ? "selected" : ""
      },
      /* @__PURE__ */ i.createElement("span", { style: X }),
      /* @__PURE__ */ i.createElement("span", { style: te }),
      /* @__PURE__ */ i.createElement("span", { style: G })
    );
  })))), t.visualizationType === "Sankey" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ i.createElement("input", { type: "color", value: t.sankey.nodeColor.default, id: "storyNodeColor", name: "storyNodeColor", onChange: (I) => C("nodeColor", I.target.value) }), /* @__PURE__ */ i.createElement("label", { htmlFor: "storyNodeColor" }, "Story Node Color")), /* @__PURE__ */ i.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ i.createElement("input", { type: "color", value: t.sankey.storyNodeFontColor || "red", id: "storyNodeFontColor", name: "storyNodeFontColor", onChange: (I) => C("storyNodeFontColor", I.target.value) }), /* @__PURE__ */ i.createElement("label", { htmlFor: "storyNodeFontColor" }, "Story Node Font Color")), /* @__PURE__ */ i.createElement("span", { className: "sankey__color-input" }, /* @__PURE__ */ i.createElement("input", { type: "color", value: t.sankey.linkColor.default, id: "linkColor", name: "linkColor", onChange: (I) => C("linkColor", I.target.value) }), /* @__PURE__ */ i.createElement("label", { htmlFor: "linkColor" }, "Link Color"))), (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Hh, { section: "twoColor", fieldName: "isPaletteReversed", size: "small", label: "Use selected palette in reverse order", updateField: u, value: t.twoColor.isPaletteReversed }), /* @__PURE__ */ i.createElement("ul", { className: "color-palette" }, L.map((I) => {
    const X = {
      backgroundColor: r[I][0]
    }, te = {
      backgroundColor: r[I][1]
    };
    return /* @__PURE__ */ i.createElement(
      "button",
      {
        title: I,
        key: I,
        onClick: (G) => {
          G.preventDefault(), n({ ...t, twoColor: { ...t.twoColor, palette: I } });
        },
        className: t.twoColor.palette === I ? "selected" : ""
      },
      /* @__PURE__ */ i.createElement("span", { className: "two-color", style: X }),
      /* @__PURE__ */ i.createElement("span", { className: "two-color", style: te })
    );
  }))), T() && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
    Je,
    {
      value: t.dataCutoff,
      type: "number",
      fieldName: "dataCutoff",
      className: "number-narrow",
      label: "Data Cutoff",
      updateField: u,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.')))
    }
  )), O() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ i.createElement(Je, { type: "number", value: t.barHeight || "25", fieldName: "barHeight", label: " Bar Thickness", updateField: u, min: 15 }), (t.visualizationType === "Bar" && t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ i.createElement(Je, { value: t.barThickness, type: "number", fieldName: "barThickness", label: "Bar Thickness", updateField: u }), E() && /* @__PURE__ */ i.createElement(Je, { type: "number", value: t.barSpace || "15", fieldName: "barSpace", label: "Bar Space", updateField: u, min: 0 }), (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ i.createElement(ct, { value: t.topAxis.hasLine, section: "topAxis", fieldName: "hasLine", label: "Add Top Axis Line", updateField: u }), t.visualizationType === "Spark Line" && /* @__PURE__ */ i.createElement("div", { className: "cove-accordion__panel-section checkbox-group" }, /* @__PURE__ */ i.createElement(ct, { value: o == null ? void 0 : o.border, section: "visual", fieldName: "border", label: "Show Border", updateField: u }), /* @__PURE__ */ i.createElement(ct, { value: o == null ? void 0 : o.borderColorTheme, section: "visual", fieldName: "borderColorTheme", label: "Use Border Color Theme", updateField: u }), /* @__PURE__ */ i.createElement(ct, { value: o == null ? void 0 : o.accent, section: "visual", fieldName: "accent", label: "Use Accent Style", updateField: u }), /* @__PURE__ */ i.createElement(ct, { value: o == null ? void 0 : o.background, section: "visual", fieldName: "background", label: "Use Theme Background Color", updateField: u }), /* @__PURE__ */ i.createElement(ct, { value: o == null ? void 0 : o.hideBackgroundColor, section: "visual", fieldName: "hideBackgroundColor", label: "Hide Background Color", updateField: u })), (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ i.createElement(ct, { value: t.showLineSeriesLabels, fieldName: "showLineSeriesLabels", label: "Append Series Name to End of Line Charts", updateField: u }), (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ i.createElement(ct, { value: t.colorMatchLineSeriesLabels, fieldName: "colorMatchLineSeriesLabels", label: "Match Series Color to Name at End of Line Charts", updateField: u }), w() && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(ct, { value: o.verticalHoverLine, fieldName: "verticalHoverLine", section: "visual", label: "Vertical Hover Line", updateField: u }), /* @__PURE__ */ i.createElement(ct, { value: o.horizontalHoverLine, fieldName: "horizontalHoverLine", section: "visual", label: "Horizontal Hover Line", updateField: u })), v() && /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Tooltip Opacity"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "number",
      value: t.tooltips.opacity ? t.tooltips.opacity : 100,
      onChange: (I) => n({
        ...t,
        tooltips: {
          ...t.tooltips,
          opacity: I.target.value
        }
      })
    }
  )), t.visualizationType === "Bar" && /* @__PURE__ */ i.createElement(ct, { value: t.tooltips.singleSeries, fieldName: "singleSeries", section: "tooltips", label: "SHOW HOVER FOR SINGLE DATA SERIES", updateField: u }), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "No Data Message"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      value: t.chartMessage.noData ? t.chartMessage.noData : "",
      onChange: (I) => n({
        ...t,
        chartMessage: {
          ...t.chartMessage,
          noData: I.target.value
        }
      })
    }
  ))));
}, Lw = () => {
  var u, s, d;
  const { config: e, updateConfig: t } = ce.useContext(Pt), n = (u = e.data) == null ? void 0 : u[0], { updateField: a } = ce.useContext(Rh);
  if (e.visualizationType !== "Sankey")
    return;
  const r = (m, y, v) => {
    let w = [];
    n != null && n.storyNodeText && (w = [...n == null ? void 0 : n.storyNodeText]), w[v][m] = y, t({
      ...e,
      sankey: {
        ...e.sankey,
        data: {
          ...e.sankey.data,
          storyNodeText: w
        }
      }
    });
  }, o = () => {
    const m = n;
    m.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), t({
      ...e,
      sankey: {
        ...e.sankey,
        data: [{ ...m }]
      }
    });
  }, f = (m) => {
    const y = n;
    y.storyNodeText.splice(m, 1), t({ ...e, sankey: { ...e.sankey, data: { ...y } } });
  };
  return /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, "Sankey Settings")), /* @__PURE__ */ i.createElement(_n, null, (n == null ? void 0 : n.storyNodeText) && (n == null ? void 0 : n.storyNodeText.map(({ StoryNode: m, segmentTextBefore: y, segmentTextAfter: v }, w) => /* @__PURE__ */ i.createElement("div", { key: w, style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" } }, /* @__PURE__ */ i.createElement("label", null, "Story Node Text", /* @__PURE__ */ i.createElement("input", { type: "text", value: m, fieldName: "StoryNode", label: "StoryNode", onChange: (E) => r("StoryNode", E.target.value, w) })), /* @__PURE__ */ i.createElement("label", null, "Story Text Before", /* @__PURE__ */ i.createElement("input", { type: "text", value: y, fieldName: "segmentTextBefore", label: "Segment Text Before", onChange: (E) => r("segmentTextBefore", E.target.value, w) })), /* @__PURE__ */ i.createElement("label", null, "Story Text After", /* @__PURE__ */ i.createElement("input", { type: "text", value: v, fieldName: "segmentTextAfter", label: "Segment Text After", onChange: (E) => r("segmentTextAfter", E.target.value, w) })), /* @__PURE__ */ i.createElement(Vf, { onClick: (E) => f(w), className: "btn", style: { background: "tomato" } }, "Remove Story Node")))), `Total Story Nodes: ${(s = n == null ? void 0 : n.storyNodeText) == null ? void 0 : s.length}`, ((d = n == null ? void 0 : n.storyNodeText) == null ? void 0 : d.length) < 3 && /* @__PURE__ */ i.createElement(
    "button",
    {
      type: "button",
      className: "btn full-width",
      onClick: (m) => {
        m.preventDefault(), o();
      }
    },
    "Add StoryNode"
  ), /* @__PURE__ */ i.createElement(ct, { value: e.enableTooltips, fieldName: "enableTooltips", label: "Enable Tooltips", updateField: a })));
}, Fa = {
  ForestPlot: uw,
  Series: Kr,
  Regions: ww,
  General: Tw,
  BoxPlot: Cw,
  Visual: Pw,
  Sankey: Lw
};
const Rw = ({ config: e, updateConfig: t, data: n }) => {
  var g, N, L;
  const a = e.visualizationType === "Combo", r = ((g = e.runtime.lineSeriesKeys) == null ? void 0 : g.length) > 0, o = ((N = e.runtime.barSeriesKeys) == null ? void 0 : N.length) > 0, f = a && r, u = a && o, s = () => al(e.visualizationType, n, e.allowLineToBarGraph), d = () => Ni.uniq(Ni.flatMap(n, Ni.keys)), m = () => e.visualizationType === "Line" && !s() || f ? ["effect", "suppression"] : ["suppression"], y = {
    "Dashed Small": "- - -",
    "Dashed Medium": " ",
    "Dashed Large": " ",
    "Open Circles": ""
  }, v = (M) => {
    if (e.visualizationType === "Line" && !s() || a) {
      const _ = Object.keys(y);
      return M === "suppression" ? _.slice(0, -1) : _;
    }
  }, w = () => {
    if (e.visualizationType === "Bar" && s() || u)
      return Object.keys(Yh);
  };
  let E = (M) => {
    let _ = [];
    e.preliminaryData && (_ = [...e.preliminaryData]), _.splice(M, 1), t({ ...e, preliminaryData: _ });
  }, O = () => {
    const M = e.visualizationType === "Line" ? "effect" : "suppression";
    let _ = e.preliminaryData ? [...e.preliminaryData] : [];
    const C = {
      type: M,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: ""
    };
    _.push(C), t({ ...e, preliminaryData: _ });
  }, T = (M, _, C) => {
    let H = [];
    e.preliminaryData && (H = [...e.preliminaryData]), H[C][M] = _, M === "symbol" && (H[C].iconCode = Yh[_]), M === "style" && (H[C].lineCode = y[_]), t({ ...e, preliminaryData: H });
  };
  return /* @__PURE__ */ i.createElement(i.Fragment, null, e.preliminaryData && ((L = e.preliminaryData) == null ? void 0 : L.map(({ column: M, displayLegend: _, displayTable: C, displayTooltip: H, label: I, seriesKey: X, style: te, symbol: G, type: F, value: j }, U) => {
    var W, re;
    return /* @__PURE__ */ i.createElement("div", { key: `preliminaryData-${U}`, className: "edit-block" }, /* @__PURE__ */ i.createElement("p", null, " ", F === "suppression" ? "Suppressed" : "Effect", " Data"), /* @__PURE__ */ i.createElement(
      "button",
      {
        type: "button",
        className: "remove-column",
        onClick: (J) => {
          J.preventDefault(), E(U);
        }
      },
      "Remove"
    ), /* @__PURE__ */ i.createElement(Lt, { value: F, initial: e.visualizationType == "Bar" ? "" : "Select", fieldName: "type", label: "Type", updateField: (J, ue, ee, Z) => T(ee, Z, U), options: m() }), F === "suppression" ? /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
      Lt,
      {
        tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'If no Data Series" is selected, the symbol will be applied to "all" suppressed values indicated in the dataset.'))),
        value: M,
        initial: "Select",
        fieldName: "column",
        label: "Add Data Series",
        updateField: (J, ue, ee, Z) => T(ee, Z, U),
        options: (W = e.runtime) == null ? void 0 : W.seriesKeys
      }
    ), /* @__PURE__ */ i.createElement(Je, { value: j, fieldName: "value", label: "Suppressed Data  Value", updateField: (J, ue, ee, Z) => T(ee, Z, U) }), (f || e.visualizationType === "Line") && /* @__PURE__ */ i.createElement(
      Lt,
      {
        tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "The recommended approach for presenting data is to include a footnote indicating any data suppression."))),
        value: te,
        initial: "Select",
        fieldName: "style",
        label: "suppression line style",
        updateField: (J, ue, ee, Z) => T(ee, Z, U),
        options: v(F)
      }
    ), (u || e.visualizationType === "Bar") && /* @__PURE__ */ i.createElement(
      Lt,
      {
        tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'The suggested method for presenting suppressed data is to use "double asterisks". If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'))),
        value: G,
        initial: "Select",
        fieldName: "symbol",
        label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
        updateField: (J, ue, ee, Z) => T(ee, Z, U),
        options: w()
      }
    ), /* @__PURE__ */ i.createElement(
      Je,
      {
        tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "This label will display in the tooltip and legend."))),
        value: I || "Suppressed",
        fieldName: "label",
        label: "Suppressed Data Label",
        placeholder: "",
        updateField: (J, ue, ee, Z) => T(ee, Z, U)
      }
    ), /* @__PURE__ */ i.createElement(
      ct,
      {
        tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Enabling this tooltip will provide a clearer indication of 'suppressed' or 'zero data' values, whichever is applicable. Deselecting 'Display In Tooltip' indicates that you do not want to display 'suppressed' or 'zero data' values in tooltips when hovering over them."))),
        value: H,
        fieldName: "displayTooltip",
        label: "Display in tooltips",
        updateField: (J, ue, ee, Z) => T(ee, Z, U)
      }
    ), /* @__PURE__ */ i.createElement(
      ct,
      {
        tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.'))),
        value: _,
        fieldName: "displayLegend",
        label: "Display in legend",
        updateField: (J, ue, ee, Z) => T(ee, Z, U)
      }
    ), /* @__PURE__ */ i.createElement(
      ct,
      {
        tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.'))),
        value: C,
        fieldName: "displayTable",
        label: "Display in table",
        updateField: (J, ue, ee, Z) => T(ee, Z, U)
      }
    )) : /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Lt, { value: X, initial: "Select", fieldName: "seriesKey", label: "ASSOCIATE TO SERIES", updateField: (J, ue, ee, Z) => T(ee, Z, U), options: e.runtime.lineSeriesKeys ?? ((re = e.runtime) == null ? void 0 : re.seriesKeys) }), /* @__PURE__ */ i.createElement(Lt, { value: M, initial: "Select", fieldName: "column", label: "COLUMN WITH CONFIGURATION VALUE", updateField: (J, ue, ee, Z) => T(ee, Z, U), options: d() }), /* @__PURE__ */ i.createElement(Je, { value: j, fieldName: "value", label: "VALUE TO TRIGGER", updateField: (J, ue, ee, Z) => T(ee, Z, U) }), /* @__PURE__ */ i.createElement(Lt, { value: te, initial: "Select", fieldName: "style", label: "Style", updateField: (J, ue, ee, Z) => T(ee, Z, U), options: v(F) }), /* @__PURE__ */ i.createElement(Je, { value: I, fieldName: "label", label: "Label", placeholder: "", updateField: (J, ue, ee, Z) => T(ee, Z, U) })));
  })), /* @__PURE__ */ i.createElement("button", { type: "button", onClick: O, className: "btn full-width" }, e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line"));
}, Dw = () => {
  var un, gn, Rn, cn, Tn, In, Yn, Zn, Xn, x, P, B, Y, Ee, xe, De, Ve, ot, yt;
  const {
    config: e,
    updateConfig: t,
    tableData: n,
    transformedData: a,
    loading: r,
    colorScale: o,
    colorPalettes: f,
    twoColorPalette: u,
    unfilteredData: s,
    excludedData: d,
    isDashboard: m,
    setParentConfig: y,
    missingRequiredSections: v,
    isDebug: w,
    setFilteredData: E,
    lineOptions: O,
    rawData: T,
    highlight: g,
    highlightReset: N
  } = ce.useContext(Pt), { minValue: L, maxValue: M, existPositiveValue: _, isAllLine: C } = Nc(e, s), H = { data: a, config: e }, { leftMax: I, rightMax: X } = uy(H), {
    headerColors: te,
    visSupportsTooltipLines: G,
    visSupportsNonSequentialPallete: F,
    visSupportsSequentialPallete: j,
    visSupportsReverseColorPalette: U,
    visHasLabelOnData: W,
    visHasNumbersOnBars: re,
    visHasAnchors: J,
    visHasBarBorders: ue,
    visHasDataCutoff: ee,
    visHasSelectableLegendValues: Z,
    visCanAnimate: se,
    visHasLegend: ye,
    visHasLegendAxisAlign: me,
    visHasBrushChart: Le,
    visSupportsDateCategoryAxis: de,
    visSupportsValueAxisMin: ie,
    visSupportsValueAxisMax: Ce,
    visSupportsDateCategoryAxisLabel: He,
    visSupportsDateCategoryAxisLine: we,
    visSupportsDateCategoryAxisTicks: ge,
    visSupportsDateCategoryTickRotation: ke,
    visSupportsDateCategoryNumTicks: ne,
    visSupportsDateCategoryAxisPadding: Pe,
    visSupportsRegions: $e,
    visSupportsFilters: qe,
    visSupportsPreliminaryData: Ge,
    visSupportsValueAxisGridLines: Xe,
    visSupportsValueAxisLine: We,
    visSupportsValueAxisTicks: vt,
    visSupportsValueAxisLabels: et,
    visSupportsBarSpace: Ke,
    visSupportsBarThickness: Be,
    visSupportsFootnotes: ze,
    visSupportsSuperTitle: gt,
    visSupportsDataCutoff: Ye,
    visSupportsChartHeight: dt,
    visSupportsLeftValueAxis: xt,
    visSupportsTooltipOpacity: ft,
    visSupportsRankByValue: lt,
    visSupportsResponsiveTicks: Dt,
    visSupportsDateCategoryHeight: on,
    visHasDataSuppression: Xt
  } = Ms();
  ce.useEffect(() => {
    let oe = [];
    e.series && (oe = e.series.map((le) => ({
      ...le,
      type: e.visualizationType === "Combo" || al(e.visualizationType, a, e.allowLineToBarGraph) ? "Bar" : e.visualizationType ? e.visualizationType : "Bar",
      axis: "Left"
    }))), t({
      ...e,
      series: oe
    });
  }, [e.visualizationType]), ce.useEffect(() => {
    e.visualizationType === "Scatter Plot" && t({
      ...e,
      xAxis: {
        ...e.xAxis,
        type: "continuous"
      }
    });
  }, []), ce.useEffect(() => {
    e.visualizationType !== "Bar" && t({ ...e, tooltips: { ...e.tooltips, singleSeries: !1 } });
  }, [e.visualizationType]);
  const { hasRightAxis: tn } = gh({ config: e, yMax: e.yAxis.size, data: e.data, updateConfig: t }), mn = (oe, le) => ({
    ...le
  }), zt = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, Vt = (oe) => {
    oe.orientation === "horizontal" && (oe.labels = !1), oe.table.show === void 0 && (oe.table.show = !m), oe.visualizationType === "Combo" && (oe.orientation = "vertical"), Cn(oe.xAxis) && !oe.xAxis.padding && (oe.xAxis.padding = 6), oe.visualizationType === "Line" && (oe.visualizationSubType = "regular", oe.barStyle = "flat", oe.isLollipopChart = !1);
  }, _e = (oe, le, ve, Me) => {
    if (w && console.log("#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue", oe, le, ve, Me), oe === "boxplot" && le === "legend") {
      t({
        ...e,
        [oe]: {
          ...e[oe],
          [le]: {
            ...e.boxplot[le],
            [ve]: Me
          }
        }
      });
      return;
    }
    if (oe === "boxplot" && le === "labels") {
      t({
        ...e,
        [oe]: {
          ...e[oe],
          [le]: {
            ...e.boxplot[le],
            [ve]: Me
          }
        }
      });
      return;
    }
    const bt = (Hn) => Hn === 0 ? !0 : !!Hn;
    if (oe === "columns" && bt(le) && bt(ve)) {
      t({
        ...e,
        columns: {
          ...e.columns,
          [le]: {
            ...e.columns[le],
            [ve]: Me
          }
        }
      });
      return;
    }
    if (oe === null && le === null) {
      bt(ve) || console.error("fieldName is required");
      let Hn = { ...e, [ve]: Me };
      Vt(Hn), t(Hn);
      return;
    }
    const bn = Array.isArray(e[oe]);
    let An = bn ? [...e[oe], Me] : { ...e[oe], [ve]: Me };
    bt(le) && (bn ? (An = [...e[oe]], An[le] = { ...An[le], [ve]: Me }) : typeof Me == "string" ? An[le] = Me : bt(ve) && (An = { ...e[oe], [le]: { ...e[oe][le], [ve]: Me } }));
    let fr = { ...e, [oe]: An };
    Vt(fr), t(fr);
  }, [En, nn] = ce.useState(!0), [Kt, wn] = ce.useState(!1);
  if (r)
    return null;
  ce.useEffect(() => {
    var oe;
    (oe = e.general) != null && oe.boxplot && (e.general.boxplot.firstQuartilePercentage || t({
      ...e,
      boxplot: {
        ...e.boxplot,
        firstQuartilePercentage: 25
      }
    }));
  }, [e]);
  const ut = (oe) => {
    t({
      ...e,
      lollipopShape: oe
    });
  }, dn = (oe) => {
    let le = e.series ? [...e.series] : [], ve = Array.from(new Set(a.map((bt) => bt[oe]))), Me = [];
    ve.forEach((bt) => {
      Me.push({ key: bt });
    }), e.visualizationType === "Forecasting" ? le.push({ dataKey: oe, type: e.visualizationType, stages: Me, stageColumn: oe, axis: "Left", tooltip: !0 }) : le.push({ dataKey: oe, type: e.visualizationType, axis: "Left", tooltip: !0 }), t({ ...e, series: le });
  }, It = (oe) => {
    const le = e.series[0].dataKey, ve = a.sort((bt, bn) => bt[le] - bn[le]), Me = oe === "asc" ? ve : ve.reverse();
    t({ ...e }, Me);
  }, vn = (oe) => {
    let le = [...e.exclusions.keys];
    le.push(oe);
    let ve = { ...e.exclusions, keys: le };
    t({ ...e, exclusions: ve });
  }, xn = (oe) => {
    let le = -1, ve = [...e.exclusions.keys];
    for (let Me = 0; Me < ve.length; Me++)
      if (ve[Me] === oe) {
        le = Me;
        break;
      }
    if (le !== -1) {
      ve.splice(le, 1);
      let Me = { ...e.exclusions, keys: ve }, bt = { ...e, exclusions: Me };
      ve.length === 0 && delete bt.exclusions.keys, t(bt);
    }
  }, qt = (oe = !0) => {
    let le = {};
    if (s.forEach((ve) => {
      Object.keys(ve).forEach((Me) => le[Me] = !0);
    }), oe) {
      const { lower: ve, upper: Me } = e.confidenceKeys || {};
      Object.keys(le).forEach((bt) => {
        (e.series && e.series.filter((bn) => bn.dataKey === bt).length > 0 || e.confidenceKeys && Object.keys(e.confidenceKeys).includes(bt) && (ve && Me || ve || Me) && bt !== ve && bt !== Me) && delete le[bt];
      });
    }
    return Object.keys(le);
  }, fn = (oe) => {
    if (!oe)
      return [];
    const le = /* @__PURE__ */ new Set();
    for (let ve = 0; ve < oe.length; ve++)
      for (const [Me] of Object.entries(oe[ve]))
        le.add(Me);
    return Array.from(le);
  }, Et = (oe, le = !1) => {
    let ve = [];
    return d.forEach((Me) => {
      ve.push(Me[oe]);
    }), le ? [...new Set(ve)] : ve;
  }, Nn = () => {
    nn(!En), t({
      ...e,
      showEditorPanel: !En
    });
  }, Ln = () => {
    let oe = JSON.parse(JSON.stringify(e));
    return v() === !1 && delete oe.newViz, delete oe.runtime, oe;
  };
  ce.useEffect(() => {
    if (y) {
      const oe = Ln();
      y(oe);
    }
  }, [e]), ce.useEffect(() => {
    const oe = e.xAxis.anchors.length > 0 ? e.xAxis.anchors : [], le = e.yAxis.anchors.length > 0 ? e.yAxis.anchors : [];
    t({
      ...e,
      xAxis: {
        ...e.xAxis,
        anchors: le
      },
      yAxis: {
        ...e.yAxis,
        anchors: oe
      }
    });
  }, [e.orientation]), ce.useEffect(() => {
    e.visualizationType === "Paired Bar" && t({
      ...e,
      orientation: "horizontal"
    });
  }, []), ce.useEffect(() => {
    e.orientation === "horizontal" && t({
      ...e,
      lollipopShape: e.lollipopShape
    });
  }, [e.isLollipopChart, e.lollipopShape]), ce.useEffect(() => {
    e.visualizationType === "Deviation Bar" && t({ ...e, orientation: "horizontal" });
  }, [e.visualizationType]);
  const Bn = ce.useCallback(() => {
    const oe = [...e.exclusions.keys];
    return /* @__PURE__ */ i.createElement("ul", { className: "series-list" }, oe.map((le, ve) => /* @__PURE__ */ i.createElement("li", { key: le }, /* @__PURE__ */ i.createElement("div", { className: "series-list__name", "data-title": le }, /* @__PURE__ */ i.createElement("div", { className: "series-list__name--text" }, le)), /* @__PURE__ */ i.createElement("button", { className: "series-list__remove", onClick: () => xn(le) }, ""))));
  }, [e]), Ht = (oe, le) => {
    let ve = e.series, [Me] = ve.splice(oe, 1);
    ve.splice(le, 0, Me), t({ ...e, series: ve });
  };
  e.isLollipopChart && ((un = e == null ? void 0 : e.series) == null ? void 0 : un.length) > 1 && (e.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), e.visualizationType === "Paired Bar" && ((gn = e == null ? void 0 : e.series) == null ? void 0 : gn.length) !== 2 && (e.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), e.visualizationType === "Deviation Bar" && ((Rn = e == null ? void 0 : e.series) == null ? void 0 : Rn.length) !== 1 && (e.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), e.isLollipopChart && ((cn = e == null ? void 0 : e.series) == null ? void 0 : cn.length) === 0 && (e.runtime.editorErrorMessage = "Add a data series");
  const Fn = e.orientation === "horizontal" ? "xAxis" : "yAxis", [Oe, ht] = ce.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), it = () => {
    const oe = e[Fn].max, le = e[Fn].rightMax;
    let ve = "", Me = "";
    if (e.visualizationType !== "Combo")
      switch (!0) {
        case (oe && parseFloat(oe) < parseFloat(M) && _):
          ve = "Max value must be more than " + M;
          break;
        case (oe && parseFloat(oe) < 0 && !_):
          ve = "Value must be more than or equal to 0";
          break;
        default:
          ve = "";
      }
    if (e.visualizationType === "Combo")
      switch (!0) {
        case (oe && parseFloat(oe) < I):
          ve = "Max value must be more than " + I;
          break;
        case (le && parseFloat(le) < X):
          Me = "Max value must be more than " + X;
          break;
        case (oe && parseFloat(oe) < 0 && !_):
          ve = "Value must be more than or equal to 0";
          break;
        default:
          ve = "";
      }
    ht((bt) => ({ ...bt, maxMsg: ve, rightMaxMessage: Me }));
  }, nt = () => {
    const oe = parseFloat(e[Fn].min);
    let le = Number(L), ve = "";
    switch (!0) {
      case (e.useLogScale && ["Line", "Combo", "Bar"].includes(e.visualizationType) && oe < 0):
        ve = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((e.visualizationType === "Line" || e.visualizationType === "Spark Line") && oe > le):
        ve = "Value should not exceed " + L;
        break;
      case (e.visualizationType === "Combo" && C && oe > le):
        ve = "Value should not exceed " + L;
        break;
      case ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && !C) && le > 0 && oe > 0):
        ve = e.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (e.visualizationType === "Deviation Bar" && oe >= Math.min(le, e.xAxis.target)):
        ve = "Value must be less than " + Math.min(le, e.xAxis.target);
        break;
      case (e.visualizationType !== "Deviation Bar" && oe && le < 0 && oe > le):
        ve = "Value should not exceed " + L;
        break;
      default:
        ve = "";
    }
    ht((Me) => ({ ...Me, minMsg: ve }));
  };
  ce.useEffect(() => {
    nt(), it();
  }, [L, M, e]);
  const ln = ((Tn = e == null ? void 0 : e.dataKey) == null ? void 0 : Tn.includes("http://")) || ((In = e == null ? void 0 : e.dataKey) == null ? void 0 : In.includes("https://")), Gt = () => {
    var oe, le;
    if (w !== void 0 && w && !((oe = e == null ? void 0 : e.xAxis) != null && oe.dataKey)) {
      let ve = qt(!1);
      if (ve.includes("Date"))
        return "Date";
      if (ve.includes("Race"))
        return "Race";
      if (ve.includes("Month"))
        return "Month";
    }
    return ((le = e == null ? void 0 : e.xAxis) == null ? void 0 : le.dataKey) || "";
  }, K = () => {
    if (w !== void 0 && w && qt(!1).length > 0) {
      let oe = qt(!1).filter((le) => le !== Gt());
      if (oe.length > 0)
        return oe[0];
    }
    return "";
  };
  if (w && !e.xAxis.dataKey && (e.xAxis.dataKey = Gt()), w && ((Yn = e == null ? void 0 : e.series) == null ? void 0 : Yn.length) === 0) {
    let oe = K();
    oe !== "" && dn(oe), w && console.log("### COVE DEBUG: Chart: Setting default datacol=", oe);
  }
  const Ne = ["Area Chart", "Combo", "Line", "Bar", "Forecasting", "Scatter Plot", "Paired Bar", "Deviation Bar"], Ze = [
    /* @__PURE__ */ i.createElement("option", { value: "", key: "Select Option" }, "- Select Option -")
  ];
  if (e.data && e.series) {
    Object.keys(((Zn = e.data) == null ? void 0 : Zn[0]) || []).map((le) => {
      const ve = e == null ? void 0 : e.series.some((Me) => Me.dataKey === le);
      if (le !== e.xAxis.dataKey && !ve)
        return Ze.push(
          /* @__PURE__ */ i.createElement("option", { value: le, key: le }, le)
        );
    });
    let oe = {};
    e.data.forEach((le) => {
      Object.keys(le).forEach((ve) => {
        oe[ve] = oe[ve] || [];
        const Me = typeof le[ve] == "number" ? le[ve].toString() : le[ve];
        oe[ve].indexOf(Me) === -1 && oe[ve].push(Me);
      });
    });
  }
  if (!e.data && a) {
    if (!a[0])
      return;
    Object.keys(a[0]).map((le) => {
      const ve = a.some((Me) => Me.dataKey === le);
      if (le !== e.xAxis.dataKey && !ve)
        return Ze.push(
          /* @__PURE__ */ i.createElement("option", { value: le, key: le }, le)
        );
    });
    let oe = {};
    a.forEach((le) => {
      Object.keys(le).forEach((ve) => {
        oe[ve] = oe[ve] || [];
        const Me = typeof le[ve] == "number" ? le[ve].toString() : le[ve];
        oe[ve].indexOf(Me) === -1 && oe[ve].push(Me);
      });
    });
  }
  const je = (oe) => {
    const le = Ni.cloneDeep(e.columns);
    delete le[oe], t({
      ...e,
      columns: le
    });
  }, kt = async (oe, le, ve) => {
    switch (le) {
      case "name":
        t({
          ...e,
          columns: {
            ...e.columns,
            [oe]: {
              ...e.columns[oe],
              [le]: ve
            }
          }
        });
        break;
      default:
        t({
          ...e,
          columns: {
            ...e.columns,
            [oe]: {
              ...e.columns[oe],
              [le]: ve
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: rt,
    highlightedSeriesValues: wt,
    handleUpdateHighlightedBar: Mt,
    handleAddNewHighlightedBar: Qe,
    handleRemoveHighlightedBar: pt,
    handleUpdateHighlightedBarColor: Nt,
    handleHighlightedBarLegendLabel: _t,
    handleUpdateHighlightedBorderWidth: jt
  } = Rc(e, t), Ft = e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1, Ct = () => {
    const oe = a.map((le) => le[e.legend.colorCode]);
    return Ft ? oe : qt(!1).filter((le) => le !== e.xAxis.dataKey);
  }, Zt = (oe) => {
    t({ ...e, legend: { ...e.legend, seriesHighlight: oe } });
  }, Ut = (oe, le, ve) => {
    var bn;
    const Me = { ...e[oe], [le]: ve }, bt = { ...e, [oe]: Me };
    ve === "highlight" && ((bn = e.legend.seriesHighlight) != null && bn.length) && (bt.legend.seriesHighlight.length = 0), t(bt);
  }, Qt = (oe, le, ve) => {
    const Me = { ...e.xAxis[oe] };
    Me[le] = ve;
    const bt = { ...e, xAxis: { ...e.xAxis, [oe]: Me } };
    t(bt);
  }, sn = {
    addNewExclusion: vn,
    data: a,
    editColumn: kt,
    getColumns: qt,
    getDataValueOptions: fn,
    getDataValues: Et,
    getItemStyle: mn,
    handleSeriesChange: Ht,
    handleAddNewHighlightedBar: Qe,
    setCategoryAxis: Gt,
    sortSeries: It,
    updateField: _e,
    warningMsg: Oe,
    highlightedBarValues: rt,
    handleHighlightedBarLegendLabel: _t,
    handleUpdateHighlightedBar: Mt,
    handleRemoveHighlightedBar: pt,
    isPaletteReversed: e.isPaletteReversed,
    highlightedSeriesValues: wt,
    handleUpdateHighlightedBorderWidth: jt,
    handleUpdateHighlightedBarColor: Nt,
    setLollipopShape: ut
  };
  return /* @__PURE__ */ i.createElement(Rh.Provider, { value: sn }, /* @__PURE__ */ i.createElement(Nr, { component: "EditorPanel" }, /* @__PURE__ */ i.createElement(tf.Sidebar, { displayPanel: En, isDashboard: m, title: "Configure Chart", onBackClick: Nn }, /* @__PURE__ */ i.createElement(_i, { allowZeroExpanded: !0 }, /* @__PURE__ */ i.createElement(Fa.General, { name: "General" }), /* @__PURE__ */ i.createElement(Fa.ForestPlot, { name: "Forest Plot Settings" }), /* @__PURE__ */ i.createElement(Fa.Sankey, { name: "Sankey" }), e.visualizationType !== "Pie" && e.visualizationType !== "Forest Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, "Data Series ", (!e.series || e.series.length === 0 || e.visualizationType === "Paired Bar" && e.series.length < 2) && /* @__PURE__ */ i.createElement(Uu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ i.createElement(_n, null, (!e.series || e.series.length === 0) && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ i.createElement("p", { className: "warning" }, "At least one series is required"), (!e.series || e.series.length === 0 || e.series.length < 2) && e.visualizationType === "Paired Bar" && /* @__PURE__ */ i.createElement("p", { className: "warning" }, "Select two data series for paired bar chart (e.g., Male and Female)."), /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
    Lt,
    {
      fieldName: "visualizationType",
      label: "Add Data Series",
      initial: "Select",
      onChange: (oe) => {
        oe.target.value !== "" && oe.target.value !== "Select" && dn(oe.target.value), oe.target.value = "";
      },
      options: qt()
    }
  ), e.series && e.series.length !== 0 && /* @__PURE__ */ i.createElement(Fa.Series.Wrapper, { getColumns: qt }, /* @__PURE__ */ i.createElement("fieldset", null, /* @__PURE__ */ i.createElement("legend", { className: "edit-label float-left" }, "Displaying"), /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "A data series is a set of related data points plotted in a chart and typically represented in the chart legend.")))), /* @__PURE__ */ i.createElement(by, { onDragEnd: ({ source: oe, destination: le }) => Ht(oe.index, le.index) }, /* @__PURE__ */ i.createElement(Sy, { droppableId: "filter_order" }, (oe) => /* @__PURE__ */ i.createElement("ul", { ...oe.droppableProps, className: "series-list", ref: oe.innerRef }, /* @__PURE__ */ i.createElement(Fa.Series.List, { series: e.series, getItemStyle: mn, sortableItemStyles: zt, chartsWithOptions: Ne }), oe.placeholder))))), e.series && e.series.length <= 1 && e.visualizationType === "Bar" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("span", { className: "divider-heading" }, "Confidence Keys"), /* @__PURE__ */ i.createElement(Lt, { value: e.confidenceKeys.upper || "", section: "confidenceKeys", fieldName: "upper", label: "Upper", updateField: _e, initial: "Select", options: qt() }), /* @__PURE__ */ i.createElement(Lt, { value: e.confidenceKeys.lower || "", section: "confidenceKeys", fieldName: "lower", label: "Lower", updateField: _e, initial: "Select", options: qt() })), lt() && e.series && e.series.length === 1 && /* @__PURE__ */ i.createElement(Lt, { fieldName: "visualizationType", label: "Rank by Value", initial: "Select", onChange: (oe) => It(oe.target.value), options: ["asc", "desc"] }), Ge() && /* @__PURE__ */ i.createElement(Rw, { config: e, updateConfig: t, data: a }))), /* @__PURE__ */ i.createElement(Fa.BoxPlot, { name: "Measures" }), xt() && /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, e.visualizationType === "Pie" ? "Data Format" : e.orientation === "vertical" ? "Left Value Axis" : "Value Axis", e.visualizationType === "Pie" && !e.yAxis.dataKey && /* @__PURE__ */ i.createElement(Uu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ i.createElement(_n, null, e.visualizationType === "Pie" && /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: e.yAxis.dataKey || "",
      section: "yAxis",
      fieldName: "dataKey",
      label: "Data Column",
      initial: "Select",
      required: !0,
      updateField: _e,
      options: qt(!1),
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Select the source data to be visually represented.")))
    }
  ), e.visualizationType !== "Pie" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.label, section: "yAxis", fieldName: "label", label: "Label ", updateField: _e }), e.runtime.seriesKeys && e.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(e.visualizationType) && /* @__PURE__ */ i.createElement(ct, { value: e.isLegendValue, fieldName: "isLegendValue", label: "Use Legend Value in Hover", updateField: _e }), /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.numTicks, placeholder: "Auto", type: "number", section: "yAxis", fieldName: "numTicks", label: "Number of ticks", className: "number-narrow", updateField: _e }), /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.yAxis.size,
      type: "number",
      section: "yAxis",
      fieldName: "size",
      label: e.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, `Increase the size if elements in the ${e.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.`)))
    }
  ), e.orientation === "horizontal" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ i.createElement(ct, { value: e.isResponsiveTicks, fieldName: "isResponsiveTicks", label: "Use Responsive Ticks", updateField: _e }), (e.orientation === "vertical" || !e.isResponsiveTicks) && /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.tickRotation || 0, type: "number", min: 0, section: "yAxis", fieldName: "tickRotation", label: "Tick rotation (Degrees)", className: "number-narrow", updateField: _e }), e.isResponsiveTicks && e.orientation === "horizontal" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.xAxis.maxTickRotation,
      type: "number",
      min: 0,
      section: "xAxis",
      fieldName: "maxTickRotation",
      label: "Max Tick Rotation",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
    }
  ), e.orientation === "horizontal" && /* @__PURE__ */ i.createElement(Je, { value: e.xAxis.labelOffset, section: "xAxis", fieldName: "labelOffset", label: "Label offset", type: "number", className: "number-narrow", updateField: _e }), Xe() && /* @__PURE__ */ i.createElement(ct, { value: e.yAxis.gridLines, section: "yAxis", fieldName: "gridLines", label: "Show Gridlines", updateField: _e }), /* @__PURE__ */ i.createElement(ct, { value: e.yAxis.enablePadding, section: "yAxis", fieldName: "enablePadding", label: "Add Padding to Value Axis Scale", updateField: _e }), e.yAxis.enablePadding && /* @__PURE__ */ i.createElement(Je, { type: "number", section: "yAxis", fieldName: "scalePadding", label: "Padding Percentage", className: "number-narrow", updateField: _e, value: e.yAxis.scalePadding }), e.visualizationSubType === "regular" && e.visualizationType !== "Forest Plot" && /* @__PURE__ */ i.createElement(ct, { value: e.useLogScale, fieldName: "useLogScale", label: "use logarithmic scale", updateField: _e })), /* @__PURE__ */ i.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ i.createElement(
    ct,
    {
      value: e.dataFormat.commas,
      section: "dataFormat",
      fieldName: "commas",
      label: "Add commas",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Selecting this option will add commas to the left value axis, tooltip hover, and data table.")))
    }
  ), /* @__PURE__ */ i.createElement(
    ct,
    {
      value: e.dataFormat.abbreviated,
      section: "dataFormat",
      fieldName: "abbreviated",
      label: "Abbreviate Axis Values",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
    }
  ), /* @__PURE__ */ i.createElement(Je, { value: e.dataFormat.roundTo ? e.dataFormat.roundTo : 0, type: "number", section: "dataFormat", fieldName: "roundTo", label: "Round to decimal point", className: "number-narrow", updateField: _e, min: 0 }), /* @__PURE__ */ i.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.dataFormat.prefix,
      section: "dataFormat",
      fieldName: "prefix",
      label: "Prefix",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ i.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ i.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.dataFormat.suffix,
      section: "dataFormat",
      fieldName: "suffix",
      label: "Suffix",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ i.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ i.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
    }
  )), e.orientation === "horizontal" ? (
    // horizontal - x is vertical y is horizontal
    /* @__PURE__ */ i.createElement(i.Fragment, null, We() && /* @__PURE__ */ i.createElement(ct, { value: e.xAxis.hideAxis, section: "xAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: _e }), et() && /* @__PURE__ */ i.createElement(ct, { value: e.xAxis.hideLabel, section: "xAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: _e }), vt() && /* @__PURE__ */ i.createElement(ct, { value: e.xAxis.hideTicks, section: "xAxis", fieldName: "hideTicks", label: "Hide Ticks", updateField: _e }), Ce() && /* @__PURE__ */ i.createElement(Je, { value: e.xAxis.max, section: "xAxis", fieldName: "max", label: "max value", type: "number", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ i.createElement("span", { style: { color: "red", display: "block" } }, Oe.maxMsg), ie() && /* @__PURE__ */ i.createElement(Je, { value: e.xAxis.min, section: "xAxis", fieldName: "min", type: "number", label: "min value", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ i.createElement("span", { style: { color: "red", display: "block" } }, Oe.minMsg), e.visualizationType === "Deviation Bar" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Je, { value: e.xAxis.target, section: "xAxis", fieldName: "target", type: "number", label: "Deviation point", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ i.createElement(Je, { value: e.xAxis.targetLabel || "Target", section: "xAxis", fieldName: "targetLabel", type: "text", label: "Deviation point Label", updateField: _e }), /* @__PURE__ */ i.createElement(ct, { value: e.xAxis.showTargetLabel, section: "xAxis", fieldName: "showTargetLabel", label: "Show Deviation point label", updateField: _e })))
  ) : e.visualizationType !== "Pie" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(ct, { value: e.yAxis.hideAxis, section: "yAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: _e }), /* @__PURE__ */ i.createElement(ct, { value: e.yAxis.hideLabel, section: "yAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: _e }), /* @__PURE__ */ i.createElement(ct, { value: e.yAxis.hideTicks, section: "yAxis", fieldName: "hideTicks", label: "Hide Ticks", updateField: _e }), /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.max, section: "yAxis", fieldName: "max", type: "number", label: "left axis max value", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ i.createElement("span", { style: { color: "red", display: "block" } }, Oe.maxMsg), /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.min, section: "yAxis", fieldName: "min", type: "number", label: "left axis min value", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ i.createElement("span", { style: { color: "red", display: "block" } }, Oe.minMsg)), J() && e.orientation !== "horizontal" && /* @__PURE__ */ i.createElement("div", { className: "edit-block" }, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ i.createElement(_i, { allowZeroExpanded: !0 }, (x = (Xn = e.yAxis) == null ? void 0 : Xn.anchors) == null ? void 0 : x.map((oe, le) => /* @__PURE__ */ i.createElement(Dn, { className: "series-item series-item--chart", key: `yaxis-anchors-2-${le}` }, /* @__PURE__ */ i.createElement(On, { className: "series-item__title" }, /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Mn, { className: "accordion__button accordion__button" }, "Anchor ", le + 1, /* @__PURE__ */ i.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (ve) => {
        ve.preventDefault();
        const Me = [...e.yAxis.anchors];
        Me.splice(le, 1), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Me
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", null, "Anchor Value"), /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[le].value ? e.yAxis.anchors[le].value : "",
      onChange: (ve) => {
        ve.preventDefault();
        const Me = [...e.yAxis.anchors];
        Me[le].value = ve.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Me
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", null, "Anchor Color"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[le].color ? e.yAxis.anchors[le].color : "",
      onChange: (ve) => {
        ve.preventDefault();
        const Me = [...e.yAxis.anchors];
        Me[le].color = ve.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Me
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ i.createElement(
    "select",
    {
      value: e.yAxis.anchors[le].lineStyle || "",
      onChange: (ve) => {
        const Me = [...e.yAxis.anchors];
        Me[le].lineStyle = ve.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Me
          }
        });
      }
    },
    /* @__PURE__ */ i.createElement("option", null, "Select"),
    O.map((ve) => /* @__PURE__ */ i.createElement("option", { key: ve.key }, ve.value))
  )))))), /* @__PURE__ */ i.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (oe) => {
        oe.preventDefault();
        const le = [...e.yAxis.anchors];
        le.push({}), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: le
          }
        });
      }
    },
    "Add Anchor"
  )), J() && e.orientation === "horizontal" && /* @__PURE__ */ i.createElement("div", { className: "edit-block" }, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ i.createElement(_i, { allowZeroExpanded: !0 }, (B = (P = e.xAxis) == null ? void 0 : P.anchors) == null ? void 0 : B.map((oe, le) => /* @__PURE__ */ i.createElement(Dn, { className: "series-item series-item--chart", key: `xaxis-anchors-${le}` }, /* @__PURE__ */ i.createElement(On, { className: "series-item__title" }, /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Mn, { className: "accordion__button accordion__button" }, "Anchor ", le + 1, /* @__PURE__ */ i.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (ve) => {
        ve.preventDefault();
        const Me = [...e.xAxis.anchors];
        Me.splice(le, 1), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Me
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", null, "Anchor Value"), /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[le].value ? e.xAxis.anchors[le].value : "",
      onChange: (ve) => {
        ve.preventDefault();
        const Me = [...e.xAxis.anchors];
        Me[le].value = ve.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Me
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", null, "Anchor Color"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[le].color ? e.xAxis.anchors[le].color : "",
      onChange: (ve) => {
        ve.preventDefault();
        const Me = [...e.xAxis.anchors];
        Me[le].color = ve.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Me
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ i.createElement(
    "select",
    {
      value: e.xAxis.anchors[le].lineStyle || "",
      onChange: (ve) => {
        const Me = [...e.xAxis.anchors];
        Me[le].lineStyle = ve.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Me
          }
        });
      }
    },
    /* @__PURE__ */ i.createElement("option", null, "Select"),
    O.map((ve) => /* @__PURE__ */ i.createElement("option", { key: ve.key }, ve.value))
  )))))), /* @__PURE__ */ i.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (oe) => {
        oe.preventDefault();
        const le = [...e.xAxis.anchors];
        le.push({}), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: le
          }
        });
      }
    },
    "Add Anchor"
  )))), tn && /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, "Right Value Axis")), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.rightLabel, section: "yAxis", fieldName: "rightLabel", label: "Label", updateField: _e }), /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.rightNumTicks, placeholder: "Auto", type: "number", section: "yAxis", fieldName: "rightNumTicks", label: "Number of ticks", className: "number-narrow", updateField: _e }), /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.rightAxisSize, type: "number", section: "yAxis", fieldName: "rightAxisSize", label: "Size (Width)", className: "number-narrow", updateField: _e }), /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.rightLabelOffsetSize, type: "number", section: "yAxis", fieldName: "rightLabelOffsetSize", label: "Label Offset", className: "number-narrow", updateField: _e }), /* @__PURE__ */ i.createElement("span", { className: "divider-heading" }, "Number Formatting"), /* @__PURE__ */ i.createElement(ct, { value: e.dataFormat.rightCommas, section: "dataFormat", fieldName: "rightCommas", label: "Add commas", updateField: _e }), /* @__PURE__ */ i.createElement(Je, { value: e.dataFormat.rightRoundTo, type: "number", section: "dataFormat", fieldName: "rightRoundTo", label: "Round to decimal point", className: "number-narrow", updateField: _e, min: 0 }), /* @__PURE__ */ i.createElement("div", { className: "two-col-inputs" }, /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.dataFormat.rightPrefix,
      section: "dataFormat",
      fieldName: "rightPrefix",
      label: "Prefix",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ i.createElement("p", null, "Enter a data prefix to display in the data table and chart tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ i.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.dataFormat.rightSuffix,
      section: "dataFormat",
      fieldName: "rightSuffix",
      label: "Suffix",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, e.visualizationType === "Pie" && /* @__PURE__ */ i.createElement("p", null, "Enter a data suffix to display in the data table and tooltips, if applicable."), e.visualizationType !== "Pie" && /* @__PURE__ */ i.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
    }
  )), /* @__PURE__ */ i.createElement(ct, { value: e.yAxis.rightHideAxis, section: "yAxis", fieldName: "rightHideAxis", label: "Hide Axis", updateField: _e }), /* @__PURE__ */ i.createElement(ct, { value: e.yAxis.rightHideLabel, section: "yAxis", fieldName: "rightHideLabel", label: "Hide Tick Labels", updateField: _e }), /* @__PURE__ */ i.createElement(ct, { value: e.yAxis.rightHideTicks, section: "yAxis", fieldName: "rightHideTicks", label: "Hide Ticks", updateField: _e }), /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.max, section: "yAxis", fieldName: "rightMax", type: "number", label: "right axis max value", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ i.createElement("span", { style: { color: "red", display: "block" } }, Oe.rightMaxMessage), /* @__PURE__ */ i.createElement(Je, { value: e.yAxis.min, section: "yAxis", fieldName: "rightMin", type: "number", label: "right axis min value", placeholder: "Auto", updateField: _e }), /* @__PURE__ */ i.createElement("span", { style: { color: "red", display: "block" } }, Oe.minMsg))), de() && /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, e.visualizationType === "Pie" ? "Segments" : "Date/Category Axis", !e.xAxis.dataKey && /* @__PURE__ */ i.createElement(Uu, { width: "25", className: "warning-icon" }))), /* @__PURE__ */ i.createElement(_n, null, e.visualizationType !== "Pie" && /* @__PURE__ */ i.createElement(i.Fragment, null, e.visualizationType !== "Forest Plot" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label" }, "Data Scaling Type", /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none", display: "inline-block" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, "Linear scales are employed for quantitative data, while time scales are used for time-series data."))), /* @__PURE__ */ i.createElement(
    "select",
    {
      value: e.xAxis.type,
      onChange: (oe) => t({
        ...e,
        xAxis: {
          ...e.xAxis,
          type: oe.target.value
        }
      })
    },
    /* @__PURE__ */ i.createElement("option", { value: "categorical" }, "Categorical (Linear Scale)"),
    /* @__PURE__ */ i.createElement("option", { value: "date" }, "Date (Linear Scale)"),
    /* @__PURE__ */ i.createElement("option", { value: "date-time" }, "Date (Date Time Scale)"),
    e.visualizationType === "Scatter Plot" && /* @__PURE__ */ i.createElement("option", { value: "continuous" }, "Continuous")
  )), /* @__PURE__ */ i.createElement(ct, { value: e.xAxis.manual, section: "xAxis", fieldName: "manual", label: "Manual Ticks", updateField: _e }), Pe() && /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.xAxis.padding,
      type: "number",
      min: 0,
      section: "xAxis",
      fieldName: "padding",
      label: "Padding (Percent)",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified.")))
    }
  )), /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: e.xAxis.dataKey || Gt() || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Data Key",
      initial: "Select",
      required: !0,
      updateField: _e,
      options: qt(!1),
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Select the column or row containing the categories or dates for this axis. ")))
    }
  )), e.visualizationType === "Pie" && /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: e.xAxis.dataKey || "",
      section: "xAxis",
      fieldName: "dataKey",
      label: "Segment Labels",
      initial: "Select",
      required: !0,
      updateField: _e,
      options: qt(!1),
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."')))
    }
  ), e.visualizationType !== "Pie" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Je, { value: e.xAxis.label, section: "xAxis", fieldName: "label", label: "Label", updateField: _e }), e.xAxis.type === "continuous" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.dataFormat.bottomPrefix,
      section: "dataFormat",
      fieldName: "bottomPrefix",
      label: "Prefix",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'Enter a data prefix (such as "$"), if applicable.')))
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.dataFormat.bottomSuffix,
      section: "dataFormat",
      fieldName: "bottomSuffix",
      label: "Suffix",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'Enter a data suffix (such as "%"), if applicable.')))
    }
  ), /* @__PURE__ */ i.createElement(
    ct,
    {
      value: e.dataFormat.bottomAbbreviated,
      section: "dataFormat",
      fieldName: "bottomAbbreviated",
      label: "Abbreviate Axis Values",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "This option abbreviates very large or very small numbers on the value axis")))
    }
  )), Cn(e.xAxis) && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" } }, "Format how charts should parse and display your dates using", " ", /* @__PURE__ */ i.createElement("a", { href: "https://github.com/d3/d3-time-format#locale_format", target: "_blank", rel: "noreferrer" }, "these guidelines"), "."), /* @__PURE__ */ i.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed. "))),
      value: e.xAxis.dateParseFormat,
      section: "xAxis",
      fieldName: "dateParseFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "Date Parse Format",
      updateField: _e
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, " Adjusts the date display format on the axis for clear, visual date representation."))),
      value: e.xAxis.dateDisplayFormat,
      section: "xAxis",
      fieldName: "dateDisplayFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "AXIS DATE DISPLAY FORMAT",
      updateField: _e
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format. "))),
      value: e.table.dateDisplayFormat,
      section: "table",
      fieldName: "dateDisplayFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "DATA TABLE DATE DISPLAY FORMAT",
      updateField: _e
    }
  ), /* @__PURE__ */ i.createElement(
    Je,
    {
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format. "))),
      value: e.tooltips.dateDisplayFormat,
      section: "tooltips",
      fieldName: "dateDisplayFormat",
      placeholder: "Ex. %Y-%m-%d",
      label: "HOVER DATE DISPLAY FORMAT",
      updateField: _e
    }
  )), /* @__PURE__ */ i.createElement(
    ct,
    {
      value: e.exclusions.active,
      section: "exclusions",
      fieldName: "active",
      label: e.xAxis.type === "date" ? "Limit by start and/or end dates" : "Exclude one or more values",
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "When this option is checked, you can select source-file values for exclusion from the date/category axis. "))),
      updateField: _e
    }
  ), Le && /* @__PURE__ */ i.createElement(ct, { value: (Y = e.brush) == null ? void 0 : Y.active, section: "brush", fieldName: "active", label: "Brush Slider ", updateField: _e }), e.exclusions.active && /* @__PURE__ */ i.createElement(i.Fragment, null, e.xAxis.type === "categorical" && /* @__PURE__ */ i.createElement(i.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("fieldset", null, /* @__PURE__ */ i.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ i.createElement(Bn, null)), /* @__PURE__ */ i.createElement(
    Lt,
    {
      fieldName: "visualizationType",
      label: "Add Exclusion",
      initial: "Select",
      onChange: (oe) => {
        oe.target.value !== "" && oe.target.value !== "Select" && vn(oe.target.value), oe.target.value = "";
      },
      options: Et(e.xAxis.dataKey, !0)
    }
  )), e.xAxis.type === "date" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Je, { type: "date", section: "exclusions", fieldName: "dateStart", label: "Start Date", updateField: _e, value: e.exclusions.dateStart || "" }), /* @__PURE__ */ i.createElement(Je, { type: "date", section: "exclusions", fieldName: "dateEnd", label: "End Date", updateField: _e, value: e.exclusions.dateEnd || "" }))), ne() && e.xAxis.type !== "date-time" && e.xAxis.manual && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.xAxis.manualStep,
      placeholder: "Auto",
      type: "number",
      min: 1,
      section: "xAxis",
      fieldName: "manualStep",
      label: "Step count",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc.")))
    }
  ), /* @__PURE__ */ i.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("button", { onClick: () => wn(!Kt), className: "edit-label" }, "Step Count: viewport overrides ", /* @__PURE__ */ i.createElement("span", { style: { transform: `rotate(${Kt ? "90deg" : "0deg"})` } }, ">"))), Kt && /* @__PURE__ */ i.createElement("div", { className: "edit-block" }, Object.keys(Oh).map((oe) => /* @__PURE__ */ i.createElement(Je, { key: `viewport-step-count-input-${oe}`, value: e.xAxis.viewportStepCount ? e.xAxis.viewportStepCount[oe] : void 0, placeholder: "Auto", type: "number", label: oe, className: "number-narrow", updateField: (le, ve, Me, bt) => Qt("viewportStepCount", oe, bt) }))))), ne() && (e.xAxis.type === "date-time" || !e.xAxis.manual) && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.xAxis.numTicks,
      placeholder: "Auto",
      type: "number",
      min: 1,
      section: "xAxis",
      fieldName: "numTicks",
      label: "Number of ticks",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.')))
    }
  ), /* @__PURE__ */ i.createElement("div", { className: "viewport-overrides" }, /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("button", { onClick: () => wn(!Kt), className: "edit-label" }, "Number of ticks: viewport overrides ", /* @__PURE__ */ i.createElement("span", { style: { transform: `rotate(${Kt ? "90deg" : "0deg"})` } }, ">"))), Kt && /* @__PURE__ */ i.createElement("div", { className: "edit-block" }, Object.keys(Oh).map((oe) => /* @__PURE__ */ i.createElement(Je, { key: `viewport-num-ticks-input-${oe}`, value: e.xAxis.viewportNumTicks ? e.xAxis.viewportNumTicks[oe] : void 0, placeholder: "Auto", type: "number", label: oe, className: "number-narrow", updateField: (le, ve, Me, bt) => Qt("viewportNumTicks", oe, bt) }))))), on() && /* @__PURE__ */ i.createElement(Je, { value: e.xAxis.padding, type: "number", min: 0, section: "xAxis", fieldName: "padding", label: e.orientation === "horizontal" ? "Size (Width)" : "Size (Height)", className: "number-narrow", updateField: _e }), (e.xAxis.type === "continuous" || e.forestPlot.type === "Logarithmic") && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(ct, { value: e.dataFormat.bottomCommas, section: "dataFormat", fieldName: "bottomCommas", label: "Add commas", updateField: _e }), /* @__PURE__ */ i.createElement(Je, { value: e.dataFormat.bottomRoundTo, type: "number", section: "dataFormat", fieldName: "bottomRoundTo", label: "Round to decimal point", className: "number-narrow", updateField: _e, min: 0 })), Dt() && e.orientation === "vertical" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ i.createElement(ct, { value: e.isResponsiveTicks, fieldName: "isResponsiveTicks", label: "Use Responsive Ticks", updateField: _e }), (e.orientation === "horizontal" || !e.isResponsiveTicks) && ke() && /* @__PURE__ */ i.createElement(Je, { value: e.xAxis.tickRotation, type: "number", min: 0, section: "xAxis", fieldName: "tickRotation", label: "Tick rotation (Degrees)", className: "number-narrow", updateField: _e }), e.orientation === "vertical" && e.isResponsiveTicks && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ i.createElement(
    Je,
    {
      value: e.xAxis.maxTickRotation,
      type: "number",
      min: 0,
      section: "xAxis",
      fieldName: "maxTickRotation",
      label: "Max Tick Rotation",
      className: "number-narrow",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Degrees ticks will be rotated if values overlap, especially in smaller viewports.")))
    }
  ), e.orientation === "horizontal" ? /* @__PURE__ */ i.createElement(i.Fragment, null, we() && /* @__PURE__ */ i.createElement(ct, { value: e.yAxis.hideAxis, section: "yAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: _e }), He() && /* @__PURE__ */ i.createElement(ct, { value: e.yAxis.hideLabel, section: "yAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: _e })) : /* @__PURE__ */ i.createElement(i.Fragment, null, we() && /* @__PURE__ */ i.createElement(ct, { value: e.xAxis.hideAxis, section: "xAxis", fieldName: "hideAxis", label: "Hide Axis", updateField: _e }), He() && /* @__PURE__ */ i.createElement(ct, { value: e.xAxis.hideLabel, section: "xAxis", fieldName: "hideLabel", label: "Hide Tick Labels", updateField: _e }), ge() && /* @__PURE__ */ i.createElement(ct, { value: e.xAxis.hideTicks, section: "xAxis", fieldName: "hideTicks", label: "Hide Ticks", updateField: _e })), /* @__PURE__ */ i.createElement(
    ct,
    {
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'Selecting this option will display a "thin line" slightly above the Date/Category Axis to indicate "suppressed data" where "suppressed data" values are indicated in the Data Series.'))),
      value: e.xAxis.showSuppressedLine,
      section: "xAxis",
      fieldName: "showSuppressedLine",
      label: "Display  suppressed data line",
      updateField: _e
    }
  ), /* @__PURE__ */ i.createElement(
    ct,
    {
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, 'Selecting this option will display "suppressed data symbol" on the Date/Category Axis where suppressed data values are indicated in the Data Series, unless a different symbol was chosen from the data series (e.g., suppression symbol) menu.'))),
      value: e.xAxis.showSuppressedSymbol,
      section: "xAxis",
      fieldName: "showSuppressedSymbol",
      label: "Display  suppressed data symbol",
      updateField: _e
    }
  ), ((Ee = e.series) == null ? void 0 : Ee.length) === 1 && e.visualizationType === "Bar" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("label", { htmlFor: "barHighlight" }, "Bar Highlighting"), e.series.length === 1 && rt.map((oe, le) => /* @__PURE__ */ i.createElement("fieldset", null, /* @__PURE__ */ i.createElement("div", { className: "edit-block", key: `highlighted-bar-${le}` }, /* @__PURE__ */ i.createElement("button", { className: "remove-column", onClick: (ve) => pt(ve, le) }, "Remove"), /* @__PURE__ */ i.createElement("p", null, "Highlighted Bar ", le + 1), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Value"), /* @__PURE__ */ i.createElement("select", { value: e.highlightedBarValues[le].value, onChange: (ve) => Mt(ve, le) }, /* @__PURE__ */ i.createElement("option", { value: "" }, "- Select Value -"), wt && [...new Set(wt)].sort().map((ve) => /* @__PURE__ */ i.createElement("option", { key: `special-class-value-option-${le}-${ve}` }, ve)))), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Color"), /* @__PURE__ */ i.createElement("input", { type: "text", value: e.highlightedBarValues[le].color ? e.highlightedBarValues[le].color : "", onChange: (ve) => Nt(ve, le) })), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Border Width"), /* @__PURE__ */ i.createElement("input", { max: "5", min: "0", type: "number", value: e.highlightedBarValues[le].borderWidth ? e.highlightedBarValues[le].borderWidth : "", onChange: (ve) => jt(ve, le) })), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Legend Label"), /* @__PURE__ */ i.createElement("input", { type: "text", value: e.highlightedBarValues[le].legendLabel ? e.highlightedBarValues[le].legendLabel : "", onChange: (ve) => _t(ve, le) }))))), /* @__PURE__ */ i.createElement("button", { className: "btn full-width", onClick: (oe) => Qe(oe) }, "Add Highlighted Bar"))), e.visualizationType === "Pie" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
    ct,
    {
      value: e.exclusions.active,
      section: "exclusions",
      fieldName: "active",
      label: "Exclude one or more values",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "When this option is checked, you can select values for exclusion from the pie segments.")))
    }
  ), e.exclusions.active && /* @__PURE__ */ i.createElement(i.Fragment, null, e.exclusions.keys.length > 0 && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement("fieldset", null, /* @__PURE__ */ i.createElement("legend", { className: "edit-label" }, "Excluded Keys")), /* @__PURE__ */ i.createElement(Bn, null)), /* @__PURE__ */ i.createElement(
    Lt,
    {
      fieldName: "visualizationType",
      label: "Add Exclusion",
      initial: "Select",
      onChange: (oe) => {
        oe.target.value !== "" && oe.target.value !== "Select" && vn(oe.target.value), oe.target.value = "";
      },
      options: Et(e.xAxis.dataKey, !0)
    }
  ))), J() && e.orientation !== "horizontal" && /* @__PURE__ */ i.createElement("div", { className: "edit-block" }, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ i.createElement(_i, { allowZeroExpanded: !0 }, (De = (xe = e.xAxis) == null ? void 0 : xe.anchors) == null ? void 0 : De.map((oe, le) => /* @__PURE__ */ i.createElement(Dn, { className: "series-item series-item--chart", key: `xaxis-anchors-2-${le}` }, /* @__PURE__ */ i.createElement(On, { className: "series-item__title" }, /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Mn, { className: "accordion__button accordion__button" }, "Anchor ", le + 1, /* @__PURE__ */ i.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (ve) => {
        ve.preventDefault();
        const Me = [...e.xAxis.anchors];
        Me.splice(le, 1), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Me
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", null, "Anchor Value"), /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[le].value ? e.xAxis.anchors[le].value : "",
      onChange: (ve) => {
        ve.preventDefault();
        const Me = [...e.xAxis.anchors];
        Me[le].value = ve.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Me
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", null, "Anchor Color"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      value: e.xAxis.anchors[le].color ? e.xAxis.anchors[le].color : "",
      onChange: (ve) => {
        ve.preventDefault();
        const Me = [...e.xAxis.anchors];
        Me[le].color = ve.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Me
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ i.createElement(
    "select",
    {
      value: e.xAxis.anchors[le].lineStyle || "",
      onChange: (ve) => {
        const Me = [...e.xAxis.anchors];
        Me[le].lineStyle = ve.target.value, t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: Me
          }
        });
      }
    },
    /* @__PURE__ */ i.createElement("option", null, "Select"),
    O.map((ve) => /* @__PURE__ */ i.createElement("option", { key: ve.key }, ve.value))
  )))))), /* @__PURE__ */ i.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (oe) => {
        oe.preventDefault();
        const le = [...e.xAxis.anchors];
        le.push({}), t({
          ...e,
          xAxis: {
            ...e.xAxis,
            anchors: le
          }
        });
      }
    },
    "Add Anchor"
  )), J() && e.orientation === "horizontal" && /* @__PURE__ */ i.createElement("div", { className: "edit-block" }, /* @__PURE__ */ i.createElement("span", { className: "edit-label column-heading" }, "Anchors"), /* @__PURE__ */ i.createElement(_i, { allowZeroExpanded: !0 }, (ot = (Ve = e.yAxis) == null ? void 0 : Ve.anchors) == null ? void 0 : ot.map((oe, le) => /* @__PURE__ */ i.createElement(Dn, { className: "series-item series-item--chart", key: `accordion-yaxis-anchors-${le}` }, /* @__PURE__ */ i.createElement(On, { className: "series-item__title" }, /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Mn, { className: "accordion__button accordion__button" }, "Anchor ", le + 1, /* @__PURE__ */ i.createElement(
    "button",
    {
      className: "series-list__remove",
      onClick: (ve) => {
        ve.preventDefault();
        const Me = [...e.yAxis.anchors];
        Me.splice(le, 1), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Me
          }
        });
      }
    },
    "Remove"
  )))), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", null, "Anchor Value"), /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "Enter the value as its shown in the data column"))), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[le].value ? e.yAxis.anchors[le].value : "",
      onChange: (ve) => {
        ve.preventDefault();
        const Me = [...e.yAxis.anchors];
        Me[le].value = ve.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Me
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", null, "Anchor Color"), /* @__PURE__ */ i.createElement(
    "input",
    {
      type: "text",
      value: e.yAxis.anchors[le].color ? e.yAxis.anchors[le].color : "",
      onChange: (ve) => {
        ve.preventDefault();
        const Me = [...e.yAxis.anchors];
        Me[le].color = ve.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Me
          }
        });
      }
    }
  )), /* @__PURE__ */ i.createElement("label", null, "Anchor Line Style", /* @__PURE__ */ i.createElement(
    "select",
    {
      value: e.yAxis.anchors[le].lineStyle || "",
      onChange: (ve) => {
        const Me = [...e.yAxis.anchors];
        Me[le].lineStyle = ve.target.value, t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: Me
          }
        });
      }
    },
    /* @__PURE__ */ i.createElement("option", null, "Select"),
    O.map((ve) => /* @__PURE__ */ i.createElement("option", { key: ve.key }, ve.value))
  )))))), /* @__PURE__ */ i.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (oe) => {
        oe.preventDefault();
        const le = [...e.yAxis.anchors];
        le.push({}), t({
          ...e,
          yAxis: {
            ...e.yAxis,
            anchors: le
          }
        });
      }
    },
    "Add Anchor"
  )))), /* @__PURE__ */ i.createElement(Fa.Regions, { name: "Regions" }), e.visualizationType !== "Box Plot" && /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, "Columns")), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement(Wy, { config: e, updateField: _e, deleteColumn: je }), " ")), ye() && /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, "Legend")), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement(ct, { value: e.legend.reverseLabelOrder, section: "legend", fieldName: "reverseLabelOrder", label: "Reverse Labels", updateField: _e }), /* @__PURE__ */ i.createElement(
    ct,
    {
      value: !!e.legend.hide,
      section: "legend",
      fieldName: "hide",
      label: "Hide Legend",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "With a single-series chart, consider hiding the legend to reduce visual clutter.")))
    }
  ), /* @__PURE__ */ i.createElement(
    ct,
    {
      value: e.legend.hideSuppressedLabels,
      section: "legend",
      fieldName: "hideSuppressedLabels",
      label: "Hide Suppressed Labels",
      updateField: _e,
      tooltip: /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.`)))
    }
  ), e.visualizationType === "Line" && /* @__PURE__ */ i.createElement(ct, { value: e.legend.lineMode, section: "legend", fieldName: "lineMode", label: "Show Lined Style Legend", updateField: _e }), e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1 && /* @__PURE__ */ i.createElement(Lt, { value: e.legend.colorCode, section: "legend", fieldName: "colorCode", label: "Color code by category", initial: "Select", updateField: _e, options: fn(a) }), /* @__PURE__ */ i.createElement(Lt, { value: e.legend.behavior, section: "legend", fieldName: "behavior", label: "Legend Behavior (When clicked)", updateField: (...[oe, , le, ve]) => Ut(oe, le, ve), options: ["highlight", "isolate"] }), me() && /* @__PURE__ */ i.createElement(ct, { value: e.legend.axisAlign, fieldName: "axisAlign", section: "legend", label: "Align to Axis on Isolate", updateField: _e }), e.legend.behavior === "highlight" && e.tooltips.singleSeries && /* @__PURE__ */ i.createElement(ct, { value: e.legend.highlightOnHover, section: "legend", fieldName: "highlightOnHover", label: "HIGHLIGHT DATA SERIES ON HOVER", updateField: _e }), Z && e.legend.behavior === "isolate" && !Ft && /* @__PURE__ */ i.createElement("fieldset", { className: "primary-fieldset edit-block", key: "additional-highlight-values" }, /* @__PURE__ */ i.createElement("label", null, /* @__PURE__ */ i.createElement("span", { className: "edit-label" }, "Isolate Data Series", /* @__PURE__ */ i.createElement(be, { style: { textTransform: "none" } }, /* @__PURE__ */ i.createElement(be.Target, null, /* @__PURE__ */ i.createElement(mt, { display: "question", style: { marginLeft: "0.5rem" } })), /* @__PURE__ */ i.createElement(be.Content, null, /* @__PURE__ */ i.createElement("p", null, "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend."))))), e.legend.seriesHighlight && e.legend.seriesHighlight.map((oe, le) => /* @__PURE__ */ i.createElement("fieldset", { className: "edit-block", key: `${oe}-${le}` }, /* @__PURE__ */ i.createElement(
    "button",
    {
      className: "remove-column",
      onClick: (ve) => {
        ve.preventDefault();
        const Me = [...e.legend.seriesHighlight];
        Me.splice(le, 1), _e("legend", null, "seriesHighlight", Me), Me.length || N();
      }
    },
    "Remove"
  ), /* @__PURE__ */ i.createElement(
    Lt,
    {
      value: e.legend.seriesHighlight[le],
      fieldName: "seriesHighlight",
      label: "Isolate Value",
      onChange: (ve) => {
        const Me = [...e.legend.seriesHighlight];
        Me.includes(ve.target.value) || (Me[le] = ve.target.value, Zt([...Me]));
      },
      options: Ct()
    }
  ))), /* @__PURE__ */ i.createElement(
    "button",
    {
      className: "btn full-width",
      onClick: (oe) => {
        oe.preventDefault();
        const le = Ct(), ve = [...e.legend.seriesHighlight];
        if (ve.length < le.length) {
          const [bt] = le.filter((bn) => !ve.includes(bn));
          ve.push(bt), Zt([...ve]);
        }
      }
    },
    "Add Isolate Value"
  )), /* @__PURE__ */ i.createElement(Je, { value: e.legend.label, section: "legend", fieldName: "label", label: "Title", updateField: _e }), /* @__PURE__ */ i.createElement(Lt, { value: (yt = e.legend) == null ? void 0 : yt.position, section: "legend", fieldName: "position", label: "Position", updateField: _e, options: ["right", "left", "bottom"] }), e.legend.position === "bottom" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(ct, { value: e.legend.singleRow, section: "legend", fieldName: "singleRow", label: "Single Row Legend", updateField: _e }), /* @__PURE__ */ i.createElement(ct, { value: e.legend.verticalSorted, section: "legend", fieldName: "verticalSorted", label: "Vertical sorted Legend", updateField: _e })), /* @__PURE__ */ i.createElement(Je, { type: "textarea", value: e.legend.description, updateField: _e, section: "legend", fieldName: "description", label: "Legend Description" }))), qe() && /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, "Filters")), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement(Vy, { config: e, updateField: _e, rawData: T }))), /* @__PURE__ */ i.createElement(Fa.Visual, { name: "Visual" }), e.visualizationType !== "Spark Line" && /* @__PURE__ */ i.createElement(Dn, null, /* @__PURE__ */ i.createElement(On, null, /* @__PURE__ */ i.createElement(Mn, null, "Data Table")), /* @__PURE__ */ i.createElement(_n, null, /* @__PURE__ */ i.createElement(jy, { config: e, columns: Object.keys(a[0] || {}), updateField: _e, isDashboard: m, isLoadedFromUrl: ln }), " "))), e.type !== "Spark Line" && /* @__PURE__ */ i.createElement(Ey, { loadConfig: t, state: e, convertStateToConfig: Ln }))));
}, ym = (e) => {
  let t = "", n = Math.abs(e);
  return n >= 1e9 ? (t = "B", e = e / 1e9) : n >= 1e6 ? (t = "M", e = e / 1e6) : n >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, Ow = (e) => {
  e.sort((d, m) => d - m);
  const t = Math.floor(e.length / 2), n = e.length % 2 === 0, a = n ? e.slice(0, t) : e.slice(0, t + 1), r = n ? e.slice(t) : e.slice(t + 1), o = Math.floor(a.length / 2), f = n ? (a[o - 1] + a[o]) / 2 : a[o], u = Math.floor(r.length / 2), s = n ? (r[u - 1] + r[u]) / 2 : r[u];
  return { q1: f, q3: s };
}, Mw = (e, t) => e.toString().localeCompare(t.toString(), "en", { numeric: !0 }), _w = (e, t) => t.toString().localeCompare(e.toString(), "en", { numeric: !0 }), fa = (e, t) => {
  let n = [];
  return t.forEach((a) => {
    let r = !0;
    e.filter((o) => o.type !== "url").forEach((o) => {
      a[o.columnName] != o.active && (r = !1);
    }), r && n.push(a);
  }), n;
}, Nw = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], vm = (e = "#000000", t = !1) => {
  let n = Es(e), a = t ? n.brighten(0.5).hex() : n.saturate(1.3).hex();
  return [e, a, n.darken(0.3).hex()];
};
const xm = (e) => {
  const t = /(?:\.([^.]+))$/, n = /[?&]wt=(csv|json)(?:&|$)/, a = new URL(e, window.location.origin), r = a.pathname, o = a.search, f = t.exec(r);
  if (f && f[1])
    return f[1];
  const u = n.exec(o);
  return u && u[1] ? u[1] : "";
};
function fT({ configUrl: e, config: t, isEditor: n = !1, isDebug: a = !1, isDashboard: r = !1, setConfig: o, setEditing: f, hostname: u, link: s, setSharedFilter: d, setSharedFilterValue: m, dashboardConfig: y }) {
  var Nn, Ln, Bn, Ht, Fn, Oe, ht, it, nt, ln, Gt;
  const v = new qy(), [w, E] = ce.useState(!0), [O, T] = ce.useState(null), [g, N] = ce.useState({}), [L, M] = ce.useState(g.data || []), [_, C] = ce.useState(void 0), [H, I] = ce.useState(void 0), [X, te] = ce.useState(t && ((Ln = (Nn = t == null ? void 0 : t.legend) == null ? void 0 : Nn.seriesHighlight) != null && Ln.length) ? [...(Bn = t == null ? void 0 : t.legend) == null ? void 0 : Bn.seriesHighlight] : []), [G, F] = ce.useState("lg"), [j, U] = ce.useState([]), [W, re] = ce.useState(), [J, ue] = ce.useState(), [ee, Z] = ce.useState(!1), [se, ye] = ce.useState([]), [me] = ce.useState(`cove-${Math.random().toString(16).slice(-4)}`), [Le, de] = ce.useState({
    data: [],
    isActive: !1,
    isBrushing: !1
  });
  ce.useRef(/* @__PURE__ */ new Map()), ce.useRef();
  const ie = ce.useRef(null);
  a && console.log("Chart config, isEditor", g, n);
  let { legend: Ce, title: He, description: we, visualizationType: ge } = g;
  n && (!He || He === "") && (He = "Chart Title"), g.table && (!((Ht = g.table) != null && Ht.label) || ((Fn = g.table) == null ? void 0 : Fn.label) === "") && (g.table.label = "Data Table");
  const { barBorderClass: ke, lineDatapointClass: ne, contentClasses: Pe, sparkLineStyles: $e } = Uy(g), qe = ce.useId(), Ge = (Oe = g.legend) != null && Oe.hide ? g != null && g.title ? `dataTableSection__${g.title.replace(/\s/g, "")}` : "dataTableSection" : qe, Xe = () => al(g.visualizationType, fa, g.allowLineToBarGraph), We = async () => {
    var K;
    if (g.dataUrl) {
      const Ne = new URL(g.runtimeDataUrl || g.dataUrl, window.location.origin);
      let Ze = Object.fromEntries(new URLSearchParams(Ne.search)), je = !1;
      if ((K = g.filters) == null || K.forEach((wt) => {
        wt.type === "url" && Ze[wt.queryParameter] !== decodeURIComponent(wt.active) && (Ze[wt.queryParameter] = wt.active, je = !0);
      }), (!g.formattedData || g.formattedData.urlFiltered) && !je)
        return;
      let kt = `${Ne.origin}${Ne.pathname}${Object.keys(Ze).map((wt, Mt) => {
        let Qe = Mt === 0 ? "?" : "&";
        return Qe += wt + "=", Qe += Ze[wt], Qe;
      }).join("")}`, rt = [];
      try {
        const wt = xm(Ne.href);
        wt === "csv" || Mh(kt) ? rt = await fetch(kt).then((Mt) => Mt.text()).then((Mt) => Fh.parse(Mt, {
          header: !0,
          dynamicTyping: !0,
          skipEmptyLines: !0
        }).data) : wt === "json" || _h(kt) ? rt = await fetch(kt).then((Mt) => Mt.json()) : rt = [];
      } catch {
        console.error(`Cannot parse URL: ${kt}`), rt = [];
      }
      g.dataDescription && (rt = v.autoStandardize(rt), rt = v.developerStandardize(rt, g.dataDescription)), Object.assign(rt, { urlFiltered: !0 }), et({ ...g, runtimeDataUrl: kt, data: rt, formattedData: rt }), rt && (M(rt), C(rt), I(fa(g.filters, rt)));
    }
  }, vt = async () => {
    let K = t || await (await fetch(e)).json(), Ne = K.data || [];
    const Ze = K.filters ? K.filters.filter((rt) => rt.type === "url").length > 0 : !1;
    if (K.dataUrl && !Ze)
      try {
        const rt = xm(K.dataUrl);
        (rt === "csv" || Mh(K.dataUrl)) && (Ne = await fetch(K.dataUrl + `?v=${qh()}`).then((wt) => wt.text()).then((wt) => (wt = wt.replace(/(".*?")|,/g, (...Qe) => Qe[1] || "|"), wt = wt.replace(/["]+/g, ""), Fh.parse(wt, {
          //quotes: "true",  // dont need these
          //quoteChar: "'",  // has no effect that I can tell
          header: !0,
          dynamicTyping: !0,
          skipEmptyLines: !0,
          delimiter: "|"
          // we are using pipe symbol as delimiter so setting this explicitly for Papa.parse
        }).data))), (rt === "json" || _h(K.dataUrl)) && (Ne = await fetch(K.dataUrl + `?v=${qh()}`).then((wt) => wt.json()));
      } catch {
        console.error(`COVE: Cannot parse URL: ${K.dataUrl}`), Ne = [];
      }
    K.dataDescription && (Ne = v.autoStandardize(Ne), Ne = v.developerStandardize(Ne, K.dataDescription)), Ne && (M(Ne), C(Ne)), K !== void 0 && K.table !== void 0 && (!K.table || !K.table.showVertical) && (K.table = K.table || {}, K.table.showVertical = !1);
    let je = { ...ef, ...K };
    je.filters && je.filters.forEach((rt, wt) => {
      const Mt = ky(rt);
      Mt && (je.filters[wt].active = Mt);
    }), je.visualizationType === "Box Plot" && (je.legend.hide = !0), je.table.show === void 0 && (je.table.show = !r), je.series.forEach((rt) => {
      (rt.tooltip === void 0 || rt.tooltip === null) && (rt.tooltip = !0), rt.axis || (rt.axis = "Left");
    }), !je.data && Ne && (je.data = Ne);
    const kt = { ...await wy(je) };
    et(kt, Ne);
  }, et = (K, Ne) => {
    var rt, wt, Mt;
    let Ze = Ne || L;
    Object.keys(ef).forEach((Qe) => {
      K[Qe] && typeof K[Qe] == "object" && !Array.isArray(K[Qe]) && (K[Qe] = { ...ef[Qe], ...K[Qe] });
    });
    let je = [];
    if (K.exclusions && K.exclusions.active)
      if (K.xAxis.type === "categorical" && ((rt = K.exclusions.keys) == null ? void 0 : rt.length) > 0)
        je = Ze.filter((Qe) => !K.exclusions.keys.includes(Qe[K.xAxis.dataKey]));
      else if (Cn(K.xAxis) && (K.exclusions.dateStart || K.exclusions.dateEnd) && K.xAxis.dateParseFormat) {
        const Qe = (Ft) => new Date(Ft).getTime();
        let pt = Qe(K.exclusions.dateStart), Nt = Qe(K.exclusions.dateEnd) + 86399999, _t = typeof pt !== void 0 && isNaN(pt) === !1, jt = typeof Nt !== void 0 && isNaN(Nt) === !1;
        _t && jt ? je = Ze.filter((Ft) => Qe(Ft[K.xAxis.dataKey]) >= pt && Qe(Ft[K.xAxis.dataKey]) <= Nt) : _t ? je = Ze.filter((Ft) => Qe(Ft[K.xAxis.dataKey]) >= pt) : jt && (je = Ze.filter((Ft) => Qe(Ft[K.xAxis.dataKey]) <= Nt));
      } else
        je = Ne || L;
    else
      je = Ne || L;
    C(je);
    let kt = [];
    if (K.filters && (K.filters.forEach((Qe, pt) => {
      let Nt = [];
      Nt = Qe.orderedValues || Ke(Qe.columnName, je).sort(Qe.order === "desc" ? _w : Mw), K.filters[pt].values = Nt, K.filters[pt].active = K.filters[pt].active || Nt[0], K.filters[pt].filterStyle = K.filters[pt].filterStyle ? K.filters[pt].filterStyle : "dropdown";
    }), kt = fa(K.filters, je), I(kt)), K.xAxis.type === "date-time" && K.barThickness > 0.1 ? K.barThickness = 0.035 : K.xAxis.type !== "date-time" && K.barThickness < 0.1 && (K.barThickness = 0.35), K.runtime = {}, K.runtime.seriesLabels = {}, K.runtime.seriesLabelsAll = [], K.runtime.originalXAxis = K.xAxis, K.visualizationType === "Pie" ? (K.runtime.seriesKeys = (Ne || Ze).map((Qe) => Qe[K.xAxis.dataKey]), K.runtime.seriesLabelsAll = K.runtime.seriesKeys) : K.runtime.seriesKeys = K.series ? K.series.map((Qe) => (K.runtime.seriesLabels[Qe.dataKey] = Qe.name || Qe.label || Qe.dataKey, K.runtime.seriesLabelsAll.push(Qe.name || Qe.dataKey), Qe.dataKey)) : [], K.visualizationType === "Box Plot" && K.series) {
      let Qe = je ? je.map((Ct) => Ct[K.xAxis.dataKey]) : Ze.map((Ct) => Ct[K.xAxis.dataKey]), pt = je ? je.map((Ct) => {
        var Zt;
        return Number(Ct[(Zt = K == null ? void 0 : K.series[0]) == null ? void 0 : Zt.dataKey]);
      }) : Ze.map((Ct) => {
        var Zt;
        return Number(Ct[(Zt = K == null ? void 0 : K.series[0]) == null ? void 0 : Zt.dataKey]);
      });
      const _t = function(Ct) {
        return Ct.filter(function(Zt, Ut, Qt) {
          return Qt.indexOf(Zt) === Ut;
        });
      }(Qe);
      let jt = [];
      const Ft = [];
      if (!_t)
        return;
      _t.forEach((Ct) => {
        try {
          if (!Ct)
            throw new En("No groups resolved in box plots");
          let Zt = je ? je.filter((x) => x[K.xAxis.dataKey] === Ct) : Ze.filter((x) => x[K.xAxis.dataKey] === Ct), Ut = Zt.map((x) => {
            var P;
            return Number(x[(P = K == null ? void 0 : K.series[0]) == null ? void 0 : P.dataKey]);
          }), Qt = Ut.sort((x, P) => x - P);
          const sn = Ow(Qt);
          if (!Zt)
            throw new En("boxplots dont have data yet");
          if (!Ft)
            throw new En("boxplots dont have plots yet");
          K.boxplot.firstQuartilePercentage === "" && (K.boxplot.firstQuartilePercentage = 0), K.boxplot.thirdQuartilePercentage === "" && (K.boxplot.thirdQuartilePercentage = 0);
          const un = sn.q1, gn = sn.q3, Rn = gn - un, cn = un - (gn - un) * 1.5, Tn = gn + (gn - un) * 1.5, In = Qt.filter((x) => x < cn || x > Tn);
          let Yn = Ut;
          Yn = Yn.filter((x) => !In.includes(x));
          const Zn = ds(Ut) || 0, Xn = cs([Zn, un - 1.5 * Rn]);
          Ft.push({
            columnCategory: Ct,
            columnMax: ds([cs(Ut), un + 1.5 * Rn]),
            columnThirdQuartile: Number(gn).toFixed(K.dataFormat.roundTo),
            columnMedian: Number(nv(Ut)).toFixed(K.dataFormat.roundTo),
            columnFirstQuartile: un.toFixed(K.dataFormat.roundTo),
            columnMin: Xn,
            columnTotal: Ut.reduce((x, P) => x + P, 0),
            columnSd: Number(Jy(Ut)).toFixed(K.dataFormat.roundTo),
            columnMean: Number(tv(Ut)).toFixed(K.dataFormat.roundTo),
            columnIqr: Number(Rn).toFixed(K.dataFormat.roundTo),
            columnLowerBounds: Xn,
            columnUpperBounds: ds([cs(Qt), un + 1.5 * Rn]),
            columnOutliers: In,
            values: Ut,
            nonOutlierValues: Yn
          });
        } catch (Zt) {
          console.error("COVE: ", Zt.message);
        }
      }), jt = JSON.parse(JSON.stringify(Ft)), jt.map((Ct) => (Ct.columnIqr = void 0, Ct.nonOutlierValues = void 0, Ct.columnLowerBounds = void 0, Ct.columnUpperBounds = void 0, null)), K.boxplot.allValues = pt, K.boxplot.categories = _t, K.boxplot.plots = Ft, K.boxplot.tableData = jt;
    }
    K.visualizationType === "Combo" && K.series && (K.runtime.barSeriesKeys = [], K.runtime.lineSeriesKeys = [], K.runtime.areaSeriesKeys = [], K.runtime.forecastingSeriesKeys = [], K.series.forEach((Qe) => {
      Qe.type === "Area Chart" && K.runtime.areaSeriesKeys.push(Qe), Qe.type === "Forecasting" && K.runtime.forecastingSeriesKeys.push(Qe), (Qe.type === "Bar" || Qe.type === "Combo") && K.runtime.barSeriesKeys.push(Qe.dataKey), (Qe.type === "Line" || Qe.type === "dashed-sm" || Qe.type === "dashed-md" || Qe.type === "dashed-lg") && K.runtime.lineSeriesKeys.push(Qe.dataKey), Qe.type === "Combo" && (Qe.type = "Bar");
    })), K.visualizationType === "Forecasting" && K.series && (K.runtime.forecastingSeriesKeys = [], K.series.forEach((Qe) => {
      Qe.type === "Forecasting" && K.runtime.forecastingSeriesKeys.push(Qe);
    })), K.visualizationType === "Area Chart" && K.series && (K.runtime.areaSeriesKeys = [], K.series.forEach((Qe) => {
      K.runtime.areaSeriesKeys.push({ ...Qe, type: "Area Chart" });
    })), K.visualizationType === "Bar" && K.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(K.visualizationType) ? (K.runtime.xAxis = K.yAxis.yAxis ? K.yAxis.yAxis : K.yAxis, K.runtime.yAxis = K.xAxis.xAxis ? K.xAxis.xAxis : K.xAxis, K.runtime.horizontal = !1, K.orientation = "horizontal") : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(K.visualizationType) && !Xe() ? (K.runtime.xAxis = K.xAxis, K.runtime.yAxis = K.yAxis, K.runtime.horizontal = !1, K.orientation = "vertical") : (K.runtime.xAxis = K.xAxis, K.runtime.yAxis = K.yAxis, K.runtime.horizontal = !1), K.runtime.uniqueId = Date.now(), K.runtime.editorErrorMessage = K.visualizationType === "Pie" && !K.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", K.runtime.editorErrorMessage = K.visualizationType === "Sankey" && !K.description ? "SUBTEXT/CITATION field is empty: A description of the Sankey Diagram data must be inputted." : "", (wt = K.legend.seriesHighlight) != null && wt.length && te((Mt = K.legend) == null ? void 0 : Mt.seriesHighlight), N(K);
  }, Ke = (K, Ne = this.state.data) => {
    const Ze = [];
    return Ne.forEach((je) => {
      const kt = je[K];
      kt && Ze.includes(kt) === !1 && Ze.push(kt);
    }), Ze;
  }, Be = (K, Ne) => {
    let Ze = g.visualizationType === "Bar" && g.visualizationSubType === "horizontal" ? g.xAxis.dataKey : g.yAxis.sortKey, je = parseFloat(K[Ze]), kt = parseFloat(Ne[Ze]);
    return je < kt ? g.sortData === "ascending" ? 1 : -1 : je > kt ? g.sortData === "ascending" ? -1 : 1 : 0;
  }, ze = new yy((K) => {
    for (let Ne of K) {
      let { width: Ze, height: je } = Ne.contentRect, kt = vy(Ze), rt = 32, wt = 350;
      F(kt), n && (Ze = Ze - wt), Ne.target.dataset.lollipop === "true" && (Ze = Ze - 2.5), Ze = Ze - rt, U([Ze, je]);
    }
  }), gt = ce.useCallback((K) => {
    K !== null && ze.observe(K), ue(K);
  }, []);
  function Ye(K) {
    return Object.keys(K).length === 0;
  }
  ce.useEffect(() => {
    vt();
  }, []), ce.useEffect(() => {
    We();
  }, [JSON.stringify(g.filters)]), ce.useEffect(() => {
    J && !Ye(g) && !ee && (Ky("cove_loaded", { config: g }), Z(!0));
  }, [J, g]), ce.useEffect(() => {
    const K = (Ne) => {
      let Ze = [];
      Ze.push(Ne.detail), re(Ze);
    };
    return Yy("cove_filterData", (Ne) => K(Ne)), () => {
      Xy("cove_filterData", K);
    };
  }, [g]), ce.useEffect(() => {
    if (W && W[0] && !W[0].hasOwnProperty("active")) {
      let Ne = { ...g };
      delete Ne.filters, N(Ne), I(fa(W, _));
    }
    if (W && W.length > 0 && W.length > 0 && W[0].hasOwnProperty("active")) {
      let K = { ...g, filters: W };
      N(K), I(fa(W, _));
    }
  }, [W]), t && ce.useEffect(() => {
    vt();
  }, [t.data]), ce.useEffect(() => {
    var K;
    if (L && g.xAxis && ((K = g.runtime) != null && K.seriesKeys)) {
      const Ne = ["Paired Bar", "Deviation Bar"].includes(g.visualizationType) ? g.twoColor.palette : g.palette, Ze = { ...dr, ...Ku };
      let je = g.customColors || Ze[Ne], kt = g.runtime.seriesKeys.length, rt;
      for (; kt > je.length; )
        je = je.concat(je);
      je = je.slice(0, kt), rt = () => zm({
        domain: g.runtime.seriesLabelsAll,
        range: je,
        unknown: null
      }), T(rt), E(!1);
    }
    g && L && g.sortData && L.sort(Be);
  }, [g, L]);
  const dt = (K) => {
    if (X.length + 1 === g.runtime.seriesKeys.length && g.visualizationType !== "Forecasting") {
      xt();
      return;
    }
    const Ne = [...X];
    let Ze = K.datum;
    g.runtime.seriesLabels && g.runtime.seriesKeys.forEach((je) => {
      g.runtime.seriesLabels[je] === K.datum && (Ze = je);
    }), Ne.indexOf(Ze) !== -1 ? Ne.splice(Ne.indexOf(Ze), 1) : Ne.push(Ze), te(Ne);
  }, xt = () => {
    try {
      const K = ie.current;
      if (!K)
        throw new En("No legend available to set previous focus on.");
      K.focus();
    } catch (K) {
      console.error("COVE:", K.message);
    }
    te([]);
  }, ft = g.orientation === "horizontal" ? "yAxis" : "xAxis", lt = (K, Ne = !0) => {
    let Ze = og(g.runtime[ft].dateParseFormat)(K);
    return Ze || (Ne && (g.runtime.editorErrorMessage = `Error parsing date "${K}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, Dt = (K) => af(g.runtime[ft].dateDisplayFormat)(K), on = (K) => af(g.tooltips.dateDisplayFormat)(K);
  function Xt(K, Ne) {
    const je = document.createElement("canvas").getContext("2d");
    if (!je) {
      console.error("2d context not found");
      return;
    }
    return je.font = Ne || getComputedStyle(document.body).font, Math.ceil(je.measureText(K).width);
  }
  const tn = (K, Ne, Ze = !1, je, kt, rt) => {
    if (isNaN(K) || !K)
      return K;
    const wt = K < 0;
    (Ne === void 0 || !Ne) && (Ne = "left"), wt && (K = Math.abs(K));
    let {
      dataFormat: { commas: Mt, abbreviated: Qe, roundTo: pt, prefix: Nt, suffix: _t, rightRoundTo: jt, bottomRoundTo: Ft, rightPrefix: Ct, rightSuffix: Zt, bottomPrefix: Ut, bottomSuffix: Qt, bottomAbbreviated: sn }
    } = g;
    String(K).indexOf(",") !== -1 && (K = K.replaceAll(",", ""));
    let un = K, gn = {
      useGrouping: !!Mt
      // for old chart data table to work right cant just leave this to undefined
    };
    if (Ne === "left" || Ne === void 0) {
      let Tn;
      rt !== void 0 ? Tn = rt ? Number(rt) : 0 : Tn = pt ? Number(pt) : 0, gn = {
        useGrouping: rt ? !0 : !!g.dataFormat.commas,
        minimumFractionDigits: Tn,
        maximumFractionDigits: Tn
      };
    }
    Ne === "right" && (gn = {
      useGrouping: !!g.dataFormat.rightCommas,
      minimumFractionDigits: jt ? Number(jt) : 0,
      maximumFractionDigits: jt ? Number(jt) : 0
    });
    const Rn = () => g.forestPlot.type === "Logarithmic" && !Ft ? 2 : Number(Ft) ? Number(Ft) : 0;
    if (Ne === "bottom" && (gn = {
      useGrouping: !!g.dataFormat.bottomCommas,
      minimumFractionDigits: Rn(),
      maximumFractionDigits: Rn()
    }), K = Xh(K), isNaN(K))
      return g.runtime.editorErrorMessage = `Unable to parse number from data ${un}. Try reviewing your data and selections in the Data Series section.`, un;
    if (!g.dataFormat)
      return K;
    if (g.dataCutoff) {
      let Tn = Xh(g.dataCutoff);
      K < Tn && (K = Tn);
    }
    Ne === "left" && Mt && Qe && Ze || Ne === "bottom" && Mt && Qe && Ze ? K = K : K = K.toLocaleString("en-US", gn);
    let cn = "";
    return Qe && Ne === "left" && Ze && (K = ym(parseFloat(K))), sn && Ne === "bottom" && Ze && (K = ym(parseFloat(K))), je && Ne === "left" ? cn = je + cn : Nt && Ne === "left" && (cn += Nt), Ct && Ne === "right" && (cn += Ct), Ut && Ne === "bottom" && (cn += Ut), cn += K, kt && Ne === "left" ? cn += kt : _t && Ne === "left" && (cn += _t), Zt && Ne === "right" && (cn += Zt), Qt && Ne === "bottom" && (cn += Qt), wt && (cn = "-" + cn), String(cn);
  }, mn = {
    "Paired Bar": /* @__PURE__ */ i.createElement(Ur, null),
    Forecasting: /* @__PURE__ */ i.createElement(Ur, null),
    Bar: /* @__PURE__ */ i.createElement(Ur, null),
    Line: /* @__PURE__ */ i.createElement(Ur, null),
    Combo: /* @__PURE__ */ i.createElement(Ur, null),
    Pie: /* @__PURE__ */ i.createElement(rE, null),
    "Box Plot": /* @__PURE__ */ i.createElement(Ur, null),
    "Area Chart": /* @__PURE__ */ i.createElement(Ur, null),
    "Scatter Plot": /* @__PURE__ */ i.createElement(Ur, null),
    "Deviation Bar": /* @__PURE__ */ i.createElement(Ur, null),
    "Forest Plot": /* @__PURE__ */ i.createElement(Ur, null)
  }, zt = () => {
    if (g.visualizationType === "Sankey" || g.visualizationType === "Forecasting" || g.visualizationType === "Forest Plot")
      return !1;
    if (g.visualizationType === "Pie") {
      if ((g == null ? void 0 : g.yAxis.dataKey) === void 0)
        return !0;
    } else if ((g == null ? void 0 : g.series) === void 0 || !((g == null ? void 0 : g.series.length) > 0))
      return !0;
    return !g.xAxis.dataKey;
  }, Vt = (K, Ne) => {
    if (K === null || K === "" || K === void 0)
      return "";
    if (typeof K == "string" && K.length > 0 && g.legend.type === "equalnumber")
      return K;
    let Ze = K, je;
    if (Object.keys(g.columns).length > 0 && Object.keys(g.columns).forEach(function(kt) {
      var rt = g.columns[kt];
      rt.name === Ne && (je = rt);
    }), je === void 0 && (je = g.type === "chart" ? g.dataFormat : g.primary, je.useCommas = je.commas, je.roundToPlace = je.roundTo ? je.roundTo : ""), je) {
      let kt = !1, rt = 0;
      Number(K) && (je.roundToPlace >= 0 && (kt = je.roundToPlace ? je.roundToPlace !== "" || je.roundToPlace !== null : !1, rt = je.roundToPlace ? Number(je.roundToPlace) : 0, je.hasOwnProperty("roundToPlace") && kt && (Ze = Number(K).toFixed(rt))), je.hasOwnProperty("useCommas") && je.useCommas === !0 && (Ze = Number(K).toLocaleString("en-US", {
        style: "decimal",
        minimumFractionDigits: kt ? rt : 0,
        maximumFractionDigits: kt ? rt : 5
      }))), Ze = (je.prefix || "") + Ze + (je.suffix || "");
    }
    return Ze;
  }, _e = () => {
    const K = (Ze) => {
      Ze && Ze.preventDefault();
      let je = { ...g };
      delete je.newViz, et(je);
    }, Ne = {
      position: "relative",
      height: "100vh",
      width: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gridArea: "content"
    };
    return /* @__PURE__ */ i.createElement("section", { className: "waiting", style: Ne }, /* @__PURE__ */ i.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ i.createElement("h3", null, "Finish Configuring"), /* @__PURE__ */ i.createElement("p", null, "Set all required options to the left and confirm below to display a preview of the chart."), /* @__PURE__ */ i.createElement(Vf, { className: "btn", style: { margin: "1em auto" }, disabled: zt(), onClick: (Ze) => K(Ze) }, "I'm Done")));
  }, En = () => {
    const K = {
      position: "absolute",
      background: "white",
      zIndex: "999",
      height: "100vh",
      width: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gridArea: "content"
    };
    return /* @__PURE__ */ i.createElement("section", { className: "waiting", style: K }, /* @__PURE__ */ i.createElement("section", { className: "waiting-container" }, /* @__PURE__ */ i.createElement("h3", null, "Error With Configuration"), /* @__PURE__ */ i.createElement("p", null, g.runtime.editorErrorMessage)));
  }, nn = (K) => {
    try {
      if (!K)
        throw new En("COVE: No rowObj in applyLegendToRow");
      if (g.type === "navigation") {
        let Ne = dr[g.color] || dr.bluegreenreverse;
        return vm(Ne[3]);
      }
      return vm();
    } catch (Ne) {
      console.error("COVE: ", Ne);
    }
  }, Kt = (K) => {
    var Ne;
    return Array.isArray(K) ? g.visualizationType === "Forecasting" ? K : (Ne = g == null ? void 0 : g.xAxis) != null && Ne.dataKey ? v.cleanData(K, g.xAxis.dataKey) : K : [];
  }, wn = (K) => K;
  let ut = /* @__PURE__ */ i.createElement(My, null);
  const dn = (K) => {
    if (!(!K || !K.toLowerCase))
      return K.toLowerCase().replaceAll(/ /g, "-");
  }, It = () => {
    var Ne, Ze;
    const K = ["chart-container", "p-relative"];
    return ((Ne = g.legend) == null ? void 0 : Ne.position) === "bottom" && K.push("bottom"), (Ze = g.legend) != null && Ze.hide && K.push("legend-hidden"), ne && K.push(ne), g.barHasBorder || K.push("chart-bar--no-border"), a && K.push("debug"), K.push(...Pe), K;
  }, vn = () => {
    var Ze, je;
    const K = ["subtext "], Ne = (Ce == null ? void 0 : Ce.position) === "bottom" || ["sm", "xs", "xxs"].includes(G);
    return g.isResponsiveTicks && K.push("subtext--responsive-ticks "), (Ze = g.brush) != null && Ze.active && !Ne && K.push("subtext--brush-active "), (je = g.brush) != null && je.active && g.legend.hide && K.push("subtext--brush-active "), K;
  };
  if (!w) {
    const K = /* @__PURE__ */ i.createElement("a", { href: `#data-table-${g.dataKey}`, className: "margin-left-href" }, g.dataKey, " (Go to Table)");
    ut = /* @__PURE__ */ i.createElement(i.Fragment, null, n && /* @__PURE__ */ i.createElement(Dw, null), /* @__PURE__ */ i.createElement(tf.Responsive, { isEditor: n }, g.newViz && /* @__PURE__ */ i.createElement(_e, null), g.newViz === void 0 && n && g.runtime && ((ht = g.runtime) == null ? void 0 : ht.editorErrorMessage) && /* @__PURE__ */ i.createElement(En, null), !zt() && !g.newViz && /* @__PURE__ */ i.createElement("div", { className: `cdc-chart-inner-container cove-component__content type-${dn(g.visualizationType)}`, "aria-label": Tf(g), tabIndex: 0 }, /* @__PURE__ */ i.createElement(Cy, { showTitle: g.showTitle, isDashboard: r, title: He, superTitle: g.superTitle, classes: ["chart-title", `${g.theme}`, "cove-component__header"], style: void 0 }), g.filters && !W && g.visualizationType !== "Spark Line" && /* @__PURE__ */ i.createElement(Nh, { config: g, setConfig: N, setFilteredData: I, filteredData: H, excludedData: _, filterData: fa, dimensions: j }), /* @__PURE__ */ i.createElement(Dy, { skipId: Ge, skipMessage: "Skip Over Chart Container" }), (g == null ? void 0 : g.introText) && g.visualizationType !== "Spark Line" && /* @__PURE__ */ i.createElement("section", { className: "introText" }, Mi(g.introText)), /* @__PURE__ */ i.createElement("div", { className: It().join(" ") }, g.visualizationType !== "Spark Line" && g.visualizationType !== "Line" && mn[g.visualizationType], g.visualizationType === "Line" && (Xe() ? mn.Bar : mn.Line), g.visualizationType === "Spark Line" && /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(Nh, { config: g, setConfig: N, setFilteredData: I, filteredData: H, excludedData: _, filterData: fa, dimensions: j }), (g == null ? void 0 : g.introText) && /* @__PURE__ */ i.createElement("section", { className: "introText", style: { padding: "0px 0 35px" } }, Mi(g.introText)), /* @__PURE__ */ i.createElement("div", { style: { height: "100px", width: "100%", ...$e } }, /* @__PURE__ */ i.createElement(fp, null, (Ne) => /* @__PURE__ */ i.createElement(lw, { width: Ne.width, height: Ne.height }))), we && /* @__PURE__ */ i.createElement("div", { className: "subtext", style: { padding: "35px 0 15px" } }, Mi(we))), g.visualizationType === "Sankey" && /* @__PURE__ */ i.createElement(fp, { "aria-hidden": "true" }, (Ne) => /* @__PURE__ */ i.createElement(OE, { runtime: g.runtime, width: Ne.width, height: Ne.height })), !g.legend.hide && g.visualizationType !== "Spark Line" && g.visualizationType !== "Sankey" && /* @__PURE__ */ i.createElement(sw, { ref: ie })), r && g.table && g.table.show && g.table.showDataTableLink ? K : s && s, we && g.visualizationType !== "Spark Line" && /* @__PURE__ */ i.createElement("div", { className: vn().join("") }, Mi(we)), /* @__PURE__ */ i.createElement(Dd.Section, { classes: ["download-buttons"] }, g.table.showDownloadImgButton && /* @__PURE__ */ i.createElement(Dd.Button, { text: "Download Image", title: "Download Chart as Image", type: "image", state: g, elementToCapture: me }), g.table.showDownloadPdfButton && /* @__PURE__ */ i.createElement(Dd.Button, { text: "Download PDF", title: "Download Chart as PDF", type: "pdf", state: g, elementToCapture: me })), (g.xAxis.dataKey && g.table.show && g.visualizationType !== "Spark Line" && g.visualizationType !== "Sankey" || g.visualizationType === "Sankey" && g.table.show) && /* @__PURE__ */ i.createElement(
      Oy,
      {
        config: g,
        rawData: g.visualizationType === "Sankey" ? (nt = (it = g == null ? void 0 : g.data) == null ? void 0 : it[0]) == null ? void 0 : nt.tableData : g.table.customTableConfig ? fa(g.filters, g.data) : g.data,
        runtimeData: g.visualizationType === "Sankey" ? (Gt = (ln = g == null ? void 0 : g.data) == null ? void 0 : ln[0]) == null ? void 0 : Gt.tableData : H || _,
        expandDataTable: g.table.expanded,
        columns: g.columns,
        displayDataAsText: Vt,
        displayGeoName: wn,
        applyLegendToRow: nn,
        tableTitle: g.table.label,
        indexTitle: g.table.indexLabel,
        vizTitle: He,
        viewport: G,
        tabbingId: Ge,
        colorScale: O
      }
    ), (g == null ? void 0 : g.footnotes) && /* @__PURE__ */ i.createElement("section", { className: "footnotes" }, Mi(g.footnotes)))));
  }
  const Et = {
    brushConfig: Le,
    setBrushConfig: de,
    capitalize: (K) => K.charAt(0).toUpperCase() + K.slice(1),
    getXAxisData: (K) => Cn(g.runtime.xAxis) ? lt(K[g.runtime.originalXAxis.dataKey]).getTime() : K[g.runtime.originalXAxis.dataKey],
    getYAxisData: (K, Ne) => K[Ne],
    config: g,
    setConfig: N,
    rawData: L ?? {},
    excludedData: _,
    transformedData: Kt(H || _),
    // do this right before passing to components
    tableData: H || _,
    // do not clean table data
    unfilteredData: L,
    seriesHighlight: X,
    colorScale: O,
    dimensions: j,
    currentViewport: G,
    parseDate: lt,
    formatDate: Dt,
    formatTooltipsDate: on,
    formatNumber: tn,
    loading: w,
    updateConfig: et,
    colorPalettes: dr,
    isDashboard: r,
    setParentConfig: o,
    missingRequiredSections: zt,
    setEditing: f,
    setFilteredData: I,
    handleChartAriaLabels: Tf,
    highlight: dt,
    highlightReset: xt,
    legend: Ce,
    setSeriesHighlight: te,
    dynamicLegendItems: se,
    setDynamicLegendItems: ye,
    filterData: fa,
    imageId: me,
    handleLineType: Ug,
    lineOptions: Nw,
    isNumber: ju,
    getTextWidth: Xt,
    twoColorPalette: Ku,
    isEditor: n,
    isDebug: a,
    setSharedFilter: d,
    setSharedFilterValue: m,
    dashboardConfig: y,
    debugSvg: a,
    clean: Kt
  };
  return /* @__PURE__ */ i.createElement(Pt.Provider, { value: Et }, /* @__PURE__ */ i.createElement(tf.VisualizationWrapper, { config: g, isEditor: n, currentViewport: G, ref: gt, imageId: me, showEditorPanel: g == null ? void 0 : g.showEditorPanel }, ut));
}
export {
  fT as C
};
