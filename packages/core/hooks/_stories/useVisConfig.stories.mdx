import { Meta, Story, ArgsTable } from '@storybook/blocks';

<Meta
  title="Hooks/useVisConfig"
/>

export const Template = ({ ...args }) => {
  return (
    <div className="example-wrapper">
    </div>
  )
}

# useVisConfig Hook
The `useVisConfig()` hook is used to access and update the configuration data for a visualization. It provides the following:
- An exported object of values that can be destructured and used for accessing, setting, and updating, the store's config values.
- A Context wrapper, `<VisConfigProvider/>`, that provides a uniformed loader, processor, and setter for all visualization config settings and data. This Context provides proxied access to the config values on the Zustand store (where the processed settings and data is registered).

&nbsp;
## Exports
<br/>

### **\{ config \} = useVisConfig()**
Returns the `<VisConfigProvider/>` config values, retrieved from the store.

&nbsp;
### **\{ visualizationKey \} = useVisConfig()**
Returns the `visualizationKey` of the current component/visualization. If the component is a:
  - **standalone visualization**, or **dashboard** - `visualizationKey` returns `__default__`.
  - **visualization displayed on a dashboard** - `visualizationKey` returns the `UID` assigned to it by the dashboard.

&nbsp;
### **\{ updateVisConfig \} = useVisConfig()**
Returns a function used to update the store's config object.

**Syntax**
```js
updateVisConfig(config)
```

**Arguments**
<Story name="updateVisConfig" argTypes={{
  config: {
    description: 'An `{object}` containing the key/value pairs that you want to update the store\'s config object with.',
    control: false,
  },
}}>
  {Template.bind({})}
</Story>

<ArgsTable story="updateVisConfig"/>

&nbsp;
### **\{ updateVisConfigField \} = useVisConfig()**
Returns a function used to update a specific, targeted key in the store's config object. Uses the [setConfigKeyValue()](./?path=/docs/helpers-confighelpers--docs) helper function to update the key.

**Syntax**
```js
updateVisConfigField(configKeyArray, setValue, merge = true)
```

**Arguments**
<Story name="updateVisConfigField" argTypes={{
  configKeyArray: {
    description: 'An `[array]` of strings, or a single `"string"`, that identifies (or traverses to) the key in the config object that you want to update.',
    control: false,
  },
  setValue: {
    description: 'The value that you want to update the key to.',
    control: false,
  },
  merge: {
    description: '(Optional) A `boolean`; if `true`, updates the field using a deep merge, instead of a simple assignment. This is useful for updating nested objects, or arrays, without overwriting the entire object. <br/><br/>Default: `true`',
    control: false,
  },
}}>
  {Template.bind({})}
</Story>

<ArgsTable story="updateVisConfigField"/>

  **Example**
```js
config = {
  foo: {
    bar: {
      baz: 'This is old...'
    }
  }
}

updateConfigField(['foo', 'bar', 'baz'], 'A new value!')

// Sets the following:
config = {
  foo: {
    bar: {
      baz: 'A new value!'
    }
  }
}

updateConfigField('foo', { qux: 'A new, merged key!'})

// Sets the following:
config = {
  foo: {
    bar: {
      baz: 'A new value!'
    },
    qux: 'A new, merged key!'
  }
}
```

&nbsp;
## \<VisConfigProvider/\> Context
The `<VisConfigProvider/>` is a Context Provider that provides loading and processing functions for config settings, as well as proxied access to configuration settings and data on the store. This context makes stored config  values
accessible to any of its children when using the `useVisConfig()` hook.

`<VisConfigProvider/>` receives the following props:

<Story name="VisConfigProvider" argTypes={{
  visualizationKey: {
    description: 'A string key annotating either a visualization key for a dashboard config, or a root level config. The `__default__` key is used to annotate the root level config on the store, and is used for standalone visualizations, and dashboards.<br/><br/> This key is used to retrieve - and update - a visualization\'s config in its dashboard `config.visualizations[visualizationKey]` object.',
    control: false,
  },
  config: {
    description: 'A JSON object containing the configuration settings for a visualization.',
    control: false,
  },
  configUrl: {
    description: 'A URL to a JSON file containing the configuration settings for a visualization.',
    control: false,
  },
  defaultConfig: {
    description: 'A JSON object containing the default configuration settings for a specific visualization.',
    control: false,
  },
  transformConfig: {
    description: 'A function to be processed on a config - this "runtime" provides a way to dynamically update the config based on the current state/config settings of the visualization. This can be necessary in certain circumstances, where you need a transitional state to be applied to a display, but the original config itself should not be updated to reflect these values.',
    control: false,
  }
}}>
  {Template.bind({})}
</Story>

<ArgsTable story="VisConfigProvider"/>

  &nbsp;
  ## Config Processing
  `<VisConfigProvider/>` processes the supplied config entries using the following steps:
  1. `initConfig()` is initiated on mount of the `<VisConfigProvider/>`, and performs the following procedures:

  2. A config object is resolved from one of the following sources, in the following order:
      - (2a.) **dashboardStoredConfig**: A pre-existing object retrieved from a dashboard's config, residing on `config.visualizations['visualizationKey']`.
      - (2b.) **config as configObj**: If a **dashboardStoredConfig** is not found, the **configObj** (an object directly supplied to the visualization) is used.
      - (2c.) **configUrl**: if a **configObj** is not found, the **configUrl** link is fetched to retrieve an object from an external JSON file.
     <br/>
  3. The resolved config object is then deep merged with the `defaultConfig` property object with lodash merge; the resolved config object values take precedence over `defaultConfig`.

  4. The now-resolved config (`resolvedConfig`), containing any defaults, is then processed using the [coveUpdateWorker](./?path=/docs/helpers-coveupdateworker--docs), which adds/removes/updates any config key/values that might have been modified during versioned updates.

  5. The config object is then set in the store:
      - If working with a dashboard config, the config is _**updated**_, using its `visualizationKey`, on the `config.visualizations['visualizationKey']` entry. This ensures that the config is stored in the dashboard, and can be retrieved on subsequent page loads.
      - If working with a standalone visualization, the config is _**set**_ on the root config entry, and is immediately available to the visualization through the store.

  6. The `getData()` store function is run, which retrieves the data from either `config.data`, or the `config.dataUrl` source, and registers the returned values on the store. This function also processes the provided data
  with the [autoStandardize](./?path=/docs/helpers-datatransform-autostandardize--docs) and [developerStandardize](./?path=/docs/helpers-datatransform-developerstandardize--docs) [DataTransform](./?path=/docs/helpers-datatransform-datatransform-class--docs) functions.

  &nbsp;
  ## Runtime Processing (transformConfig)
  While the config is being processed, the `finalConfig()` callback listens for a resolved config. Once a config object has been resolved,
  the `transformConfig()` function is then run on that resolved config object. Depending on the behavior defined, this can result in a variety of different outputs.
  Most commonly, the `transformConfig()` function is used to dynamically update the config object based on the current state of the visualization, and creates `config.runtime` values
  that can be used for a visualization. This can be used to address a variety of situational needs.

  **[Example]**

  If you change a Bar Chart from Horizontal, to Vertical, you may want to swap the values of the `xAxisLabel` to `yAxisLabel`.
  Approaching this could prove to be a bit tricky:

  **Without transformConfig:**
  ```js
  // Without a runtime transformConfig, the following code will not work as expected:
  if (config.orientation = 'vertical') {
    config.xAxisLabel = config.yAxisLabel // After changing the 'xAxisLabel' value, the original value of 'xAxisLabel' is lost
    config.yAxisLabel = config.xAxisLabel // Since the original value of 'xAxisLabel' is now lost, the 'yAxisLabel' value cannot be updated properly - it retains it's original value
  }
  ```

  **With transformConfig:**
  ```js
    // With a runtime transformConfig, the following code will work as expected:
  // The 'config.runtime' object is used to store transitional values, leaving the initial config values intact

  config.runtime = {}

  if (config.orientation = 'vertical') {
    config.runtime.xAxisLabel = config.yAxisLabel
    config.runtime.yAxisLabel = config.xAxisLabel
  }
  ```
