import { j as a, a as F, F as Be } from "./storybook-jsx-runtime-ea6e0d87.es.js";
import { r as fe, R as Ie } from "./storybook-index-f2fed736.es.js";
import { v as Hf, b as Pg, g as Ng } from "./storybook-getViewport-cf99c09b.es.js";
import { Z as kl, p as Vf, _ as Ma, $ as ii, a0 as It, a1 as Wf, a2 as Rc, a3 as tr, t as Xu, a4 as Jo, a5 as jd, a6 as jf, a7 as Qn, a8 as Uf, a9 as Rg, aa as Dg, d as Dc, m as Kf, z as as, P as Og, e as Mg, g as Qo, j as Gf, h as Yf, k as Ig, y as Fg, Y as Bg, ab as mr, x as os, B as zr, I as Lm, ac as zg, ad as Em, s as $g, l as Qh, Q as _m, R as Pm, U as ac, S as Nm, X as Rm, H as Hg, C as Xf, u as Vg, M as Dm, E as Wg, v as jg, w as Om, O as Ug, G as Kg, b as Gg, N as Yg, L as qf, J as Xg, K as qg, V as Zg, A as Qg } from "./storybook-InputToggle-5cfd438e.es.js";
import { f as Jg } from "./storybook-fetchRemoteData-d0119f0b.es.js";
import { L as mh, u as ev, p as tv, s as nv, a as rv } from "./storybook-useDataVizClasses-3bf30247.es.js";
import { B as Oc } from "./storybook-Button-f953e457.es.js";
import { t as Jh, u as Tn, v as qu, w as ol, L as yh, x as Zf, r as Qf, M as Ud, D as iv, y as av } from "./storybook-DataTable-577422ab.es.js";
import { T as ov } from "./storybook-index-4a64ea6e.es.js";
import { a as Yi, E as Xr, b as gh, L as sv } from "./storybook-viewports-61111b6b.es.js";
import { p as lv, P as Re } from "./storybook-index-43433e35.es.js";
import { d as uv } from "./storybook-debounce-cc216a80.es.js";
import { a as cv } from "./storybook-_commonjsHelpers-c5d32002.es.js";
import { p as Gi } from "./storybook-index-31bf6905.es.js";
import { _ as Ke, l as dv } from "./storybook-lodash-a4231e1c.es.js";
import { r as hv, R as fv } from "./storybook-index-8cf78369.es.js";
import { a as _r, s as oc, t as Mc } from "./storybook-colorPalettes-bc80e395.es.js";
import { t as Mm, u as Jf, G as qe, q as Ic, v as pv, w as Im, x as ep, y as mv, z as yv, A as gv, B as vv } from "./storybook-linear-5c281d48.es.js";
import { s as dl, t as Fm, a as Bm, b as zm, B as Pr, d as Ml, c as zn, C as bv } from "./storybook-linear-7d6b225d.es.js";
import { c as Sn, M as $m, T as ee } from "./storybook-Tooltip-7cf39805.es.js";
import { T as dt } from "./storybook-Text-0ce4510d.es.js";
import { t as Hm, m as Kd, f as Vm, d as Pu, a as Nu, b as Ru, n as tp, o as xv, p as np, c as Wm, e as jm } from "./storybook-year-24bd1dc7.es.js";
import { c as Qi, n as rp } from "./storybook-index-80cf478c.es.js";
import { a as Ve, S as Um } from "./storybook-Icon-e250778e.es.js";
import { B as ip } from "./storybook-BlurStrokeText-f87cf8cc.es.js";
import { a as Nn, b as Rn, c as Dn, d as On, A as za, D as Km } from "./storybook-DataTransform-d4bb56a2.es.js";
import { T as ze, S as ct, C as Ue } from "./storybook-Inputs-f2c63984.es.js";
import { M as ap } from "./storybook-MultiSelect-cda00383.es.js";
import { I as Ji } from "./storybook-InputSelect-368b8698.es.js";
import { A as Du } from "./storybook-Accordion-e71370da.es.js";
import { f as Uo, F as op, a as Sv } from "./storybook-Filters-caf19344.es.js";
import { c as wv } from "./storybook-coveUpdateWorker-2b7600bb.es.js";
import { C as kv } from "./storybook-ConfigContext-04a7c3c3.es.js";
const vh = (e) => {
  if (e.visualizationType === "Sankey" || e.visualizationType === "Forecasting" || e.visualizationType === "Forest Plot")
    return !1;
  if (e.visualizationType === "Pie") {
    if ((e == null ? void 0 : e.yAxis.dataKey) === void 0)
      return !0;
  } else if (((e == null ? void 0 : e.series) === void 0 || !((e == null ? void 0 : e.series.length) > 0)) && !(e != null && e.dynamicSeries))
    return !0;
  return !e.xAxis.dataKey;
}, Tv = (e) => {
  const { updateConfig: t, config: n } = e, r = (o) => {
    o && o.preventDefault();
    let h = { ...n };
    delete h.newViz, t(h);
  };
  return /* @__PURE__ */ a("section", { className: "waiting", style: {
    position: "relative",
    height: "100vh",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gridArea: "content"
  }, children: /* @__PURE__ */ F("section", { className: "waiting-container", children: [
    /* @__PURE__ */ a("h3", { children: "Finish Configuring" }),
    /* @__PURE__ */ a("p", { children: "Set all required options to the left and confirm below to display a preview of the chart." }),
    /* @__PURE__ */ a(
      Oc,
      {
        className: "btn btn-primary",
        style: { margin: "1em auto" },
        disabled: vh(n),
        onClick: (o) => r(o),
        children: "I'm Done"
      }
    )
  ] }) });
}, Gd = ({ errorMessage: e }) => /* @__PURE__ */ a("section", { className: "waiting", style: {
  position: "absolute",
  background: "white",
  zIndex: "999",
  height: "100vh",
  width: "100%",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  gridArea: "content"
}, children: /* @__PURE__ */ F("section", { className: "waiting-container", children: [
  /* @__PURE__ */ a("h3", { children: "Error With Configuration" }),
  /* @__PURE__ */ a("p", { children: e })
] }) }), sc = Hm(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
sc.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Hm((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : sc);
sc.range;
function Cv(e, t) {
  let n = 0, r, i = 0, o = 0;
  if (t === void 0)
    for (let h of e)
      h != null && (h = +h) >= h && (r = h - i, i += r / ++n, o += r * (h - i));
  else {
    let h = -1;
    for (let d of e)
      (d = t(d, ++h, e)) != null && (d = +d) >= d && (r = d - i, i += r / ++n, o += r * (d - i));
  }
  if (n > 1)
    return o / (n - 1);
}
function Av(e, t) {
  const n = Cv(e, t);
  return n && Math.sqrt(n);
}
class sp extends Map {
  constructor(t, n = _v) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [r, i] of t)
        this.set(r, i);
  }
  get(t) {
    return super.get(lp(this, t));
  }
  has(t) {
    return super.has(lp(this, t));
  }
  set(t, n) {
    return super.set(Lv(this, t), n);
  }
  delete(t) {
    return super.delete(Ev(this, t));
  }
}
function lp({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function Lv({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function Ev({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function _v(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function Pv(e, t) {
  let n = 0, r = 0;
  if (t === void 0)
    for (let i of e)
      i != null && (i = +i) >= i && (++n, r += i);
  else {
    let i = -1;
    for (let o of e)
      (o = t(o, ++i, e)) != null && (o = +o) >= o && (++n, r += o);
  }
  if (n)
    return r / n;
}
function Gm(e, t) {
  return kl(e, 0.5, t);
}
function Nv(e, t, n) {
  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(i); ++r < i; )
    o[r] = e + r * n;
  return o;
}
function Rv(e, t, n, r, i, o) {
  const h = [
    [dl, 1, Pu],
    [dl, 5, 5 * Pu],
    [dl, 15, 15 * Pu],
    [dl, 30, 30 * Pu],
    [o, 1, Nu],
    [o, 5, 5 * Nu],
    [o, 15, 15 * Nu],
    [o, 30, 30 * Nu],
    [i, 1, Ru],
    [i, 3, 3 * Ru],
    [i, 6, 6 * Ru],
    [i, 12, 12 * Ru],
    [r, 1, tp],
    [r, 2, 2 * tp],
    [n, 1, xv],
    [t, 1, np],
    [t, 3, 3 * np],
    [e, 1, Kd]
  ];
  function d(p, y, g) {
    const b = y < p;
    b && ([p, y] = [y, p]);
    const T = g && typeof g.range == "function" ? g : c(p, y, g), m = T ? T.range(p, +y + 1) : [];
    return b ? m.reverse() : m;
  }
  function c(p, y, g) {
    const b = Math.abs(y - p) / g, T = Mm(([, , w]) => w).right(h, b);
    if (T === h.length)
      return e.every(Jf(p / Kd, y / Kd, g));
    if (T === 0)
      return sc.every(Math.max(Jf(p, y, g), 1));
    const [m, C] = h[b / h[T - 1][2] < h[T][2] / b ? T - 1 : T];
    return m.every(C);
  }
  return [d, c];
}
const [Dv, Ov] = Rv(Vm, zm, jm, Wm, Bm, Fm), ef = fe.createContext(() => {
}), ft = fe.createContext({}), Mv = (e) => {
  const { children: t } = e, { config: n, currentViewport: r } = fe.useContext(ft);
  return /* @__PURE__ */ F("div", { className: (() => {
    let o = ["legend-wrapper", "d-flex", "flex-nowrap", "w-100"];
    const { legend: h } = n;
    return (h.position === "bottom" || h.position === "top" || Yi(r)) && (o = o.filter((d) => d !== "flex-nowrap"), o.push("flex-wrap")), o.join(" ");
  })(), children: [
    ...t
  ] });
};
var Ha = [], Iv = function() {
  return Ha.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Fv = function() {
  return Ha.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, up = "ResizeObserver loop completed with undelivered notifications.", Bv = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: up
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = up), window.dispatchEvent(e);
}, Tl;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Tl || (Tl = {}));
var Va = function(e) {
  return Object.freeze(e);
}, Ym = function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Va(this);
  }
  return e;
}(), Xm = function() {
  function e(t, n, r, i) {
    return this.x = t, this.y = n, this.width = r, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Va(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, i = t.top, o = t.right, h = t.bottom, d = t.left, c = t.width, p = t.height;
    return { x: n, y: r, top: i, right: o, bottom: h, left: d, width: c, height: p };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), tf = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, qm = function(e) {
  if (tf(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var i = e, o = i.offsetWidth, h = i.offsetHeight;
  return !(o || h || e.getClientRects().length);
}, cp = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, zv = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, fl = typeof window < "u" ? window : {}, Ou = /* @__PURE__ */ new WeakMap(), dp = /auto|scroll/, $v = /^tb|vertical/, Hv = /msie|trident/i.test(fl.navigator && fl.navigator.userAgent), ai = function(e) {
  return parseFloat(e || "0");
}, ns = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Ym((n ? t : e) || 0, (n ? e : t) || 0);
}, hp = Va({
  devicePixelContentBoxSize: ns(),
  borderBoxSize: ns(),
  contentBoxSize: ns(),
  contentRect: new Xm(0, 0, 0, 0)
}), Zm = function(e, t) {
  if (t === void 0 && (t = !1), Ou.has(e) && !t)
    return Ou.get(e);
  if (qm(e))
    return Ou.set(e, hp), hp;
  var n = getComputedStyle(e), r = tf(e) && e.ownerSVGElement && e.getBBox(), i = !Hv && n.boxSizing === "border-box", o = $v.test(n.writingMode || ""), h = !r && dp.test(n.overflowY || ""), d = !r && dp.test(n.overflowX || ""), c = r ? 0 : ai(n.paddingTop), p = r ? 0 : ai(n.paddingRight), y = r ? 0 : ai(n.paddingBottom), g = r ? 0 : ai(n.paddingLeft), b = r ? 0 : ai(n.borderTopWidth), T = r ? 0 : ai(n.borderRightWidth), m = r ? 0 : ai(n.borderBottomWidth), C = r ? 0 : ai(n.borderLeftWidth), w = g + p, S = c + y, B = C + T, M = b + m, D = d ? e.offsetHeight - M - e.clientHeight : 0, O = h ? e.offsetWidth - B - e.clientWidth : 0, L = i ? w + B : 0, U = i ? S + M : 0, X = r ? r.width : ai(n.width) - L - O, ne = r ? r.height : ai(n.height) - U - D, G = X + w + O + B, ce = ne + S + D + M, q = Va({
    devicePixelContentBoxSize: ns(Math.round(X * devicePixelRatio), Math.round(ne * devicePixelRatio), o),
    borderBoxSize: ns(G, ce, o),
    contentBoxSize: ns(X, ne, o),
    contentRect: new Xm(g, c, X, ne)
  });
  return Ou.set(e, q), q;
}, Qm = function(e, t, n) {
  var r = Zm(e, n), i = r.borderBoxSize, o = r.contentBoxSize, h = r.devicePixelContentBoxSize;
  switch (t) {
    case Tl.DEVICE_PIXEL_CONTENT_BOX:
      return h;
    case Tl.BORDER_BOX:
      return i;
    default:
      return o;
  }
}, Jm = function() {
  function e(t) {
    var n = Zm(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Va([n.borderBoxSize]), this.contentBoxSize = Va([n.contentBoxSize]), this.devicePixelContentBoxSize = Va([n.devicePixelContentBoxSize]);
  }
  return e;
}(), ey = function(e) {
  if (qm(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Vv = function() {
  var e = 1 / 0, t = [];
  Ha.forEach(function(h) {
    if (h.activeTargets.length !== 0) {
      var d = [];
      h.activeTargets.forEach(function(p) {
        var y = new Jm(p.target), g = ey(p.target);
        d.push(y), p.lastReportedSize = Qm(p.target, p.observedBox), g < e && (e = g);
      }), t.push(function() {
        h.callback.call(h.observer, d, h.observer);
      }), h.activeTargets.splice(0, h.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var i = r[n];
    i();
  }
  return e;
}, fp = function(e) {
  Ha.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(i) {
      i.isActive() && (ey(i.target) > e ? n.activeTargets.push(i) : n.skippedTargets.push(i));
    });
  });
}, Wv = function() {
  var e = 0;
  for (fp(e); Iv(); )
    e = Vv(), fp(e);
  return Fv() && Bv(), e > 0;
}, Yd, ty = [], jv = function() {
  return ty.splice(0).forEach(function(e) {
    return e();
  });
}, Uv = function(e) {
  if (!Yd) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return jv();
    }).observe(n, r), Yd = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  ty.push(e), Yd();
}, Kv = function(e) {
  Uv(function() {
    requestAnimationFrame(e);
  });
}, Zu = 0, Gv = function() {
  return !!Zu;
}, Yv = 250, Xv = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, pp = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], mp = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Xd = !1, qv = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Yv), !Xd) {
      Xd = !0;
      var r = mp(t);
      Kv(function() {
        var i = !1;
        try {
          i = Wv();
        } finally {
          if (Xd = !1, t = r - mp(), !Gv())
            return;
          i ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, Xv);
    };
    document.body ? n() : fl.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), pp.forEach(function(n) {
      return fl.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), pp.forEach(function(n) {
      return fl.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), bh = new qv(), yp = function(e) {
  !Zu && e > 0 && bh.start(), Zu += e, !Zu && bh.stop();
}, Zv = function(e) {
  return !tf(e) && !zv(e) && getComputedStyle(e).display === "inline";
}, Qv = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Tl.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = Qm(this.target, this.observedBox, !0);
    return Zv(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Jv = function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Mu = /* @__PURE__ */ new WeakMap(), gp = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Iu = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new Jv(t, n);
    Mu.set(t, r);
  }, e.observe = function(t, n, r) {
    var i = Mu.get(t), o = i.observationTargets.length === 0;
    gp(i.observationTargets, n) < 0 && (o && Ha.push(i), i.observationTargets.push(new Qv(n, r && r.box)), yp(1), bh.schedule());
  }, e.unobserve = function(t, n) {
    var r = Mu.get(t), i = gp(r.observationTargets, n), o = r.observationTargets.length === 1;
    i >= 0 && (o && Ha.splice(Ha.indexOf(r), 1), r.observationTargets.splice(i, 1), yp(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Mu.get(t);
    r.observationTargets.slice().forEach(function(i) {
      return n.unobserve(t, i.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), eb = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Iu.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!cp(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Iu.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!cp(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Iu.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Iu.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const tb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ResizeObserver: eb,
  ResizeObserverEntry: Jm,
  ResizeObserverSize: Ym
}, Symbol.toStringTag, { value: "Module" })), nb = /* @__PURE__ */ cv(tb);
var Ko = iy, ji = ry(lv), rb = ry(uv), Go = ob(fe), ib = nb, ab = ["className", "children", "debounceTime", "ignoreDimensions", "parentSizeStyles", "enableDebounceLeadingCall"];
function ny(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (ny = function(i) {
    return i ? n : t;
  })(e);
}
function ob(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = ny(t);
  if (n && n.has(e))
    return n.get(e);
  var r = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var h = i ? Object.getOwnPropertyDescriptor(e, o) : null;
      h && (h.get || h.set) ? Object.defineProperty(r, o, h) : r[o] = e[o];
    }
  return r.default = e, n && n.set(e, r), r;
}
function ry(e) {
  return e && e.__esModule ? e : { default: e };
}
function lc() {
  return lc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, lc.apply(this, arguments);
}
function sb(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var lb = [];
function iy(e) {
  var t = e.className, n = e.children, r = e.debounceTime, i = r === void 0 ? 300 : r, o = e.ignoreDimensions, h = o === void 0 ? lb : o, d = e.parentSizeStyles, c = d === void 0 ? {
    width: "100%",
    height: "100%"
  } : d, p = e.enableDebounceLeadingCall, y = p === void 0 ? !0 : p, g = sb(e, ab), b = (0, Go.useRef)(null), T = (0, Go.useRef)(0), m = (0, Go.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), C = m[0], w = m[1], S = (0, Go.useMemo)(function() {
    var B = Array.isArray(h) ? h : [h];
    return (0, rb.default)(function(M) {
      w(function(D) {
        var O = Object.keys(D), L = O.filter(function(X) {
          return D[X] !== M[X];
        }), U = L.every(function(X) {
          return B.includes(X);
        });
        return U ? D : M;
      });
    }, i, {
      leading: y
    });
  }, [i, y, h]);
  return (0, Go.useEffect)(function() {
    var B = new ib.ResizeObserver(function(M) {
      M === void 0 && (M = []), M.forEach(function(D) {
        var O = D.contentRect, L = O.left, U = O.top, X = O.width, ne = O.height;
        T.current = window.requestAnimationFrame(function() {
          S({
            width: X,
            height: ne,
            top: U,
            left: L
          });
        });
      });
    });
    return b.current && B.observe(b.current), function() {
      window.cancelAnimationFrame(T.current), B.disconnect(), S != null && S.cancel && S.cancel();
    };
  }, [S]), /* @__PURE__ */ Go.default.createElement("div", lc({
    style: c,
    ref: b,
    className: t
  }, g), n(lc({}, C, {
    ref: b.current,
    resize: S
  })));
}
iy.propTypes = {
  className: ji.default.string,
  debounceTime: ji.default.number,
  enableDebounceLeadingCall: ji.default.bool,
  ignoreDimensions: ji.default.oneOfType([ji.default.any, ji.default.arrayOf(ji.default.any)]),
  children: ji.default.func.isRequired
};
var nf = Fl(), At = (e) => Il(e, nf), rf = Fl();
At.write = (e) => Il(e, rf);
var Fc = Fl();
At.onStart = (e) => Il(e, Fc);
var af = Fl();
At.onFrame = (e) => Il(e, af);
var of = Fl();
At.onFinish = (e) => Il(e, of);
var rs = [];
At.setTimeout = (e, t) => {
  const n = At.now() + t, r = () => {
    const o = rs.findIndex((h) => h.cancel == r);
    ~o && rs.splice(o, 1), qi -= ~o ? 1 : 0;
  }, i = { time: n, handler: e, cancel: r };
  return rs.splice(ay(n), 0, i), qi += 1, oy(), i;
};
var ay = (e) => ~(~rs.findIndex((t) => t.time > e) || ~rs.length);
At.cancel = (e) => {
  Fc.delete(e), af.delete(e), of.delete(e), nf.delete(e), rf.delete(e);
};
At.sync = (e) => {
  xh = !0, At.batchedUpdates(e), xh = !1;
};
At.throttle = (e) => {
  let t;
  function n() {
    try {
      e(...t);
    } finally {
      t = null;
    }
  }
  function r(...i) {
    t = i, At.onStart(n);
  }
  return r.handler = e, r.cancel = () => {
    Fc.delete(n), t = null;
  }, r;
};
var sf = typeof window < "u" ? window.requestAnimationFrame : (
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  () => {
  }
);
At.use = (e) => sf = e;
At.now = typeof performance < "u" ? () => performance.now() : Date.now;
At.batchedUpdates = (e) => e();
At.catch = console.error;
At.frameLoop = "always";
At.advance = () => {
  At.frameLoop !== "demand" ? console.warn(
    "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
  ) : ly();
};
var Xi = -1, qi = 0, xh = !1;
function Il(e, t) {
  xh ? (t.delete(e), e(0)) : (t.add(e), oy());
}
function oy() {
  Xi < 0 && (Xi = 0, At.frameLoop !== "demand" && sf(sy));
}
function ub() {
  Xi = -1;
}
function sy() {
  ~Xi && (sf(sy), At.batchedUpdates(ly));
}
function ly() {
  const e = Xi;
  Xi = At.now();
  const t = ay(Xi);
  if (t && (uy(rs.splice(0, t), (n) => n.handler()), qi -= t), !qi) {
    ub();
    return;
  }
  Fc.flush(), nf.flush(e ? Math.min(64, Xi - e) : 16.667), af.flush(), rf.flush(), of.flush();
}
function Fl() {
  let e = /* @__PURE__ */ new Set(), t = e;
  return {
    add(n) {
      qi += t == e && !e.has(n) ? 1 : 0, e.add(n);
    },
    delete(n) {
      return qi -= t == e && e.has(n) ? 1 : 0, e.delete(n);
    },
    flush(n) {
      t.size && (e = /* @__PURE__ */ new Set(), qi -= t.size, uy(t, (r) => r(n) && e.add(r)), qi += e.size, t = e);
    }
  };
}
function uy(e, t) {
  e.forEach((n) => {
    try {
      t(n);
    } catch (r) {
      At.catch(r);
    }
  });
}
var cb = Object.defineProperty, db = (e, t) => {
  for (var n in t)
    cb(e, n, { get: t[n], enumerable: !0 });
}, Yr = {};
db(Yr, {
  assign: () => fb,
  colors: () => Zi,
  createStringInterpolator: () => uf,
  skipAnimation: () => dy,
  to: () => cy,
  willAdvance: () => cf
});
function Sh() {
}
var hb = (e, t, n) => Object.defineProperty(e, t, { value: n, writable: !0, configurable: !0 }), je = {
  arr: Array.isArray,
  obj: (e) => !!e && e.constructor.name === "Object",
  fun: (e) => typeof e == "function",
  str: (e) => typeof e == "string",
  num: (e) => typeof e == "number",
  und: (e) => e === void 0
};
function Ti(e, t) {
  if (je.arr(e)) {
    if (!je.arr(t) || e.length !== t.length)
      return !1;
    for (let n = 0; n < e.length; n++)
      if (e[n] !== t[n])
        return !1;
    return !0;
  }
  return e === t;
}
var Et = (e, t) => e.forEach(t);
function li(e, t, n) {
  if (je.arr(e)) {
    for (let r = 0; r < e.length; r++)
      t.call(n, e[r], `${r}`);
    return;
  }
  for (const r in e)
    e.hasOwnProperty(r) && t.call(n, e[r], r);
}
var pr = (e) => je.und(e) ? [] : je.arr(e) ? e : [e];
function pl(e, t) {
  if (e.size) {
    const n = Array.from(e);
    e.clear(), Et(n, t);
  }
}
var hl = (e, ...t) => pl(e, (n) => n(...t)), lf = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), uf, cy, Zi = null, dy = !1, cf = Sh, fb = (e) => {
  e.to && (cy = e.to), e.now && (At.now = e.now), e.colors !== void 0 && (Zi = e.colors), e.skipAnimation != null && (dy = e.skipAnimation), e.createStringInterpolator && (uf = e.createStringInterpolator), e.requestAnimationFrame && At.use(e.requestAnimationFrame), e.batchedUpdates && (At.batchedUpdates = e.batchedUpdates), e.willAdvance && (cf = e.willAdvance), e.frameLoop && (At.frameLoop = e.frameLoop);
}, ml = /* @__PURE__ */ new Set(), Br = [], qd = [], uc = 0, Bc = {
  get idle() {
    return !ml.size && !Br.length;
  },
  /** Advance the given animation on every frame until idle. */
  start(e) {
    uc > e.priority ? (ml.add(e), At.onStart(pb)) : (hy(e), At(wh));
  },
  /** Advance all animations by the given time. */
  advance: wh,
  /** Call this when an animation's priority changes. */
  sort(e) {
    if (uc)
      At.onFrame(() => Bc.sort(e));
    else {
      const t = Br.indexOf(e);
      ~t && (Br.splice(t, 1), fy(e));
    }
  },
  /**
   * Clear all animations. For testing purposes.
   *
   * ☠️ Never call this from within the frameloop.
   */
  clear() {
    Br = [], ml.clear();
  }
};
function pb() {
  ml.forEach(hy), ml.clear(), At(wh);
}
function hy(e) {
  Br.includes(e) || fy(e);
}
function fy(e) {
  Br.splice(
    mb(Br, (t) => t.priority > e.priority),
    0,
    e
  );
}
function wh(e) {
  const t = qd;
  for (let n = 0; n < Br.length; n++) {
    const r = Br[n];
    uc = r.priority, r.idle || (cf(r), r.advance(e), r.idle || t.push(r));
  }
  return uc = 0, qd = Br, qd.length = 0, Br = t, Br.length > 0;
}
function mb(e, t) {
  const n = e.findIndex(t);
  return n < 0 ? e.length : n;
}
var yb = (e, t, n) => Math.min(Math.max(n, e), t), gb = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, Kr = "[-+]?\\d*\\.?\\d+", cc = Kr + "%";
function zc(...e) {
  return "\\(\\s*(" + e.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var vb = new RegExp("rgb" + zc(Kr, Kr, Kr)), bb = new RegExp("rgba" + zc(Kr, Kr, Kr, Kr)), xb = new RegExp("hsl" + zc(Kr, cc, cc)), Sb = new RegExp(
  "hsla" + zc(Kr, cc, cc, Kr)
), wb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, kb = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Tb = /^#([0-9a-fA-F]{6})$/, Cb = /^#([0-9a-fA-F]{8})$/;
function Ab(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = Tb.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : Zi && Zi[e] !== void 0 ? Zi[e] : (t = vb.exec(e)) ? (Yo(t[1]) << 24 | // r
  Yo(t[2]) << 16 | // g
  Yo(t[3]) << 8 | // b
  255) >>> // a
  0 : (t = bb.exec(e)) ? (Yo(t[1]) << 24 | // r
  Yo(t[2]) << 16 | // g
  Yo(t[3]) << 8 | // b
  xp(t[4])) >>> // a
  0 : (t = wb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    "ff",
    // a
    16
  ) >>> 0 : (t = Cb.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = kb.exec(e)) ? parseInt(
    t[1] + t[1] + // r
    t[2] + t[2] + // g
    t[3] + t[3] + // b
    t[4] + t[4],
    // a
    16
  ) >>> 0 : (t = xb.exec(e)) ? (vp(
    bp(t[1]),
    // h
    Fu(t[2]),
    // s
    Fu(t[3])
    // l
  ) | 255) >>> // a
  0 : (t = Sb.exec(e)) ? (vp(
    bp(t[1]),
    // h
    Fu(t[2]),
    // s
    Fu(t[3])
    // l
  ) | xp(t[4])) >>> // a
  0 : null;
}
function Zd(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function vp(e, t, n) {
  const r = n < 0.5 ? n * (1 + t) : n + t - n * t, i = 2 * n - r, o = Zd(i, r, e + 1 / 3), h = Zd(i, r, e), d = Zd(i, r, e - 1 / 3);
  return Math.round(o * 255) << 24 | Math.round(h * 255) << 16 | Math.round(d * 255) << 8;
}
function Yo(e) {
  const t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function bp(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function xp(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function Fu(e) {
  const t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function Sp(e) {
  let t = Ab(e);
  if (t === null)
    return e;
  t = t || 0;
  const n = (t & 4278190080) >>> 24, r = (t & 16711680) >>> 16, i = (t & 65280) >>> 8, o = (t & 255) / 255;
  return `rgba(${n}, ${r}, ${i}, ${o})`;
}
var Cl = (e, t, n) => {
  if (je.fun(e))
    return e;
  if (je.arr(e))
    return Cl({
      range: e,
      output: t,
      extrapolate: n
    });
  if (je.str(e.output[0]))
    return uf(e);
  const r = e, i = r.output, o = r.range || [0, 1], h = r.extrapolateLeft || r.extrapolate || "extend", d = r.extrapolateRight || r.extrapolate || "extend", c = r.easing || ((p) => p);
  return (p) => {
    const y = Eb(p, o);
    return Lb(
      p,
      o[y],
      o[y + 1],
      i[y],
      i[y + 1],
      c,
      h,
      d,
      r.map
    );
  };
};
function Lb(e, t, n, r, i, o, h, d, c) {
  let p = c ? c(e) : e;
  if (p < t) {
    if (h === "identity")
      return p;
    h === "clamp" && (p = t);
  }
  if (p > n) {
    if (d === "identity")
      return p;
    d === "clamp" && (p = n);
  }
  return r === i ? r : t === n ? e <= t ? r : i : (t === -1 / 0 ? p = -p : n === 1 / 0 ? p = p - t : p = (p - t) / (n - t), p = o(p), r === -1 / 0 ? p = -p : i === 1 / 0 ? p = p + r : p = p * (i - r) + r, p);
}
function Eb(e, t) {
  for (var n = 1; n < t.length - 1 && !(t[n] >= e); ++n)
    ;
  return n - 1;
}
var _b = (e, t = "end") => (n) => {
  n = t === "end" ? Math.min(n, 0.999) : Math.max(n, 1e-3);
  const r = n * e, i = t === "end" ? Math.floor(r) : Math.ceil(r);
  return yb(0, 1, i / e);
}, dc = 1.70158, Bu = dc * 1.525, wp = dc + 1, kp = 2 * Math.PI / 3, Tp = 2 * Math.PI / 4.5, zu = (e) => e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375, Pb = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => 1 - (1 - e) * (1 - e),
  easeInOutQuad: (e) => e < 0.5 ? 2 * e * e : 1 - Math.pow(-2 * e + 2, 2) / 2,
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => 1 - Math.pow(1 - e, 3),
  easeInOutCubic: (e) => e < 0.5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2,
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => 1 - Math.pow(1 - e, 4),
  easeInOutQuart: (e) => e < 0.5 ? 8 * e * e * e * e : 1 - Math.pow(-2 * e + 2, 4) / 2,
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => 1 - Math.pow(1 - e, 5),
  easeInOutQuint: (e) => e < 0.5 ? 16 * e * e * e * e * e : 1 - Math.pow(-2 * e + 2, 5) / 2,
  easeInSine: (e) => 1 - Math.cos(e * Math.PI / 2),
  easeOutSine: (e) => Math.sin(e * Math.PI / 2),
  easeInOutSine: (e) => -(Math.cos(Math.PI * e) - 1) / 2,
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * e - 10),
  easeOutExpo: (e) => e === 1 ? 1 : 1 - Math.pow(2, -10 * e),
  easeInOutExpo: (e) => e === 0 ? 0 : e === 1 ? 1 : e < 0.5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2,
  easeInCirc: (e) => 1 - Math.sqrt(1 - Math.pow(e, 2)),
  easeOutCirc: (e) => Math.sqrt(1 - Math.pow(e - 1, 2)),
  easeInOutCirc: (e) => e < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * e, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * e + 2, 2)) + 1) / 2,
  easeInBack: (e) => wp * e * e * e - dc * e * e,
  easeOutBack: (e) => 1 + wp * Math.pow(e - 1, 3) + dc * Math.pow(e - 1, 2),
  easeInOutBack: (e) => e < 0.5 ? Math.pow(2 * e, 2) * ((Bu + 1) * 2 * e - Bu) / 2 : (Math.pow(2 * e - 2, 2) * ((Bu + 1) * (e * 2 - 2) + Bu) + 2) / 2,
  easeInElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : -Math.pow(2, 10 * e - 10) * Math.sin((e * 10 - 10.75) * kp),
  easeOutElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : Math.pow(2, -10 * e) * Math.sin((e * 10 - 0.75) * kp) + 1,
  easeInOutElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : e < 0.5 ? -(Math.pow(2, 20 * e - 10) * Math.sin((20 * e - 11.125) * Tp)) / 2 : Math.pow(2, -20 * e + 10) * Math.sin((20 * e - 11.125) * Tp) / 2 + 1,
  easeInBounce: (e) => 1 - zu(1 - e),
  easeOutBounce: zu,
  easeInOutBounce: (e) => e < 0.5 ? (1 - zu(1 - 2 * e)) / 2 : (1 + zu(2 * e - 1)) / 2,
  steps: _b
}, Al = Symbol.for("FluidValue.get"), ss = Symbol.for("FluidValue.observers"), Fr = (e) => !!(e && e[Al]), Tr = (e) => e && e[Al] ? e[Al]() : e, Cp = (e) => e[ss] || null;
function Nb(e, t) {
  e.eventObserved ? e.eventObserved(t) : e(t);
}
function Ll(e, t) {
  const n = e[ss];
  n && n.forEach((r) => {
    Nb(r, t);
  });
}
var py = class {
  constructor(e) {
    if (!e && !(e = this.get))
      throw Error("Unknown getter");
    Rb(this, e);
  }
}, Rb = (e, t) => my(e, Al, t);
function cs(e, t) {
  if (e[Al]) {
    let n = e[ss];
    n || my(e, ss, n = /* @__PURE__ */ new Set()), n.has(t) || (n.add(t), e.observerAdded && e.observerAdded(n.size, t));
  }
  return t;
}
function El(e, t) {
  const n = e[ss];
  if (n && n.has(t)) {
    const r = n.size - 1;
    r ? n.delete(t) : e[ss] = null, e.observerRemoved && e.observerRemoved(r, t);
  }
}
var my = (e, t, n) => Object.defineProperty(e, t, {
  value: n,
  writable: !0,
  configurable: !0
}), Qu = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Db = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Ap = new RegExp(`(${Qu.source})(%|[a-z]+)`, "i"), Ob = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, $c = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/, yy = (e) => {
  const [t, n] = Mb(e);
  if (!t || lf())
    return e;
  const r = window.getComputedStyle(document.documentElement).getPropertyValue(t);
  if (r)
    return r.trim();
  if (n && n.startsWith("--")) {
    const i = window.getComputedStyle(document.documentElement).getPropertyValue(n);
    return i || e;
  } else {
    if (n && $c.test(n))
      return yy(n);
    if (n)
      return n;
  }
  return e;
}, Mb = (e) => {
  const t = $c.exec(e);
  if (!t)
    return [,];
  const [, n, r] = t;
  return [n, r];
}, Qd, Ib = (e, t, n, r, i) => `rgba(${Math.round(t)}, ${Math.round(n)}, ${Math.round(r)}, ${i})`, gy = (e) => {
  Qd || (Qd = Zi ? (
    // match color names, ignore partial matches
    new RegExp(`(${Object.keys(Zi).join("|")})(?!\\w)`, "g")
  ) : (
    // never match
    /^\b$/
  ));
  const t = e.output.map((o) => Tr(o).replace($c, yy).replace(Db, Sp).replace(Qd, Sp)), n = t.map((o) => o.match(Qu).map(Number)), i = n[0].map(
    (o, h) => n.map((d) => {
      if (!(h in d))
        throw Error('The arity of each "output" value must be equal');
      return d[h];
    })
  ).map(
    (o) => Cl({ ...e, output: o })
  );
  return (o) => {
    var c;
    const h = !Ap.test(t[0]) && ((c = t.find((p) => Ap.test(p))) == null ? void 0 : c.replace(Qu, ""));
    let d = 0;
    return t[0].replace(
      Qu,
      () => `${i[d++](o)}${h || ""}`
    ).replace(Ob, Ib);
  };
}, df = "react-spring: ", vy = (e) => {
  const t = e;
  let n = !1;
  if (typeof t != "function")
    throw new TypeError(`${df}once requires a function parameter`);
  return (...r) => {
    n || (t(...r), n = !0);
  };
}, Fb = vy(console.warn);
function by() {
  Fb(
    `${df}The "interpolate" function is deprecated in v9 (use "to" instead)`
  );
}
var Bb = vy(console.warn);
function zb() {
  Bb(
    `${df}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
  );
}
function Hc(e) {
  return je.str(e) && (e[0] == "#" || /\d/.test(e) || // Do not identify a CSS variable as an AnimatedString if its SSR
  !lf() && $c.test(e) || e in (Zi || {}));
}
var es = lf() ? fe.useEffect : fe.useLayoutEffect, $b = () => {
  const e = fe.useRef(!1);
  return es(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
};
function xy() {
  const e = fe.useState()[1], t = $b();
  return () => {
    t.current && e(Math.random());
  };
}
function Hb(e, t) {
  const [n] = fe.useState(
    () => ({
      inputs: t,
      result: e()
    })
  ), r = fe.useRef(), i = r.current;
  let o = i;
  return o ? t && o.inputs && Vb(t, o.inputs) || (o = {
    inputs: t,
    result: e()
  }) : o = n, fe.useEffect(() => {
    r.current = o, i == n && (n.inputs = n.result = void 0);
  }, [o]), o.result;
}
function Vb(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
var Sy = (e) => fe.useEffect(e, Wb), Wb = [];
function jb(e) {
  const t = fe.useRef();
  return fe.useEffect(() => {
    t.current = e;
  }), t.current;
}
var _l = Symbol.for("Animated:node"), Ub = (e) => !!e && e[_l] === e, si = (e) => e && e[_l], hf = (e, t) => hb(e, _l, t), Vc = (e) => e && e[_l] && e[_l].getPayload(), wy = class {
  constructor() {
    hf(this, this);
  }
  /** Get every `AnimatedValue` used by this node. */
  getPayload() {
    return this.payload || [];
  }
}, Bl = class extends wy {
  constructor(e) {
    super(), this._value = e, this.done = !0, this.durationProgress = 0, je.num(this._value) && (this.lastPosition = this._value);
  }
  /** @internal */
  static create(e) {
    return new Bl(e);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(e, t) {
    return je.num(e) && (this.lastPosition = e, t && (e = Math.round(e / t) * t, this.done && (this.lastPosition = e))), this._value === e ? !1 : (this._value = e, !0);
  }
  reset() {
    const { done: e } = this;
    this.done = !1, je.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null);
  }
}, Pl = class extends Bl {
  constructor(e) {
    super(0), this._string = null, this._toString = Cl({
      output: [e, e]
    });
  }
  /** @internal */
  static create(e) {
    return new Pl(e);
  }
  getValue() {
    const e = this._string;
    return e ?? (this._string = this._toString(this._value));
  }
  setValue(e) {
    if (je.str(e)) {
      if (e == this._string)
        return !1;
      this._string = e, this._value = 1;
    } else if (super.setValue(e))
      this._string = null;
    else
      return !1;
    return !0;
  }
  reset(e) {
    e && (this._toString = Cl({
      output: [this.getValue(), e]
    })), this._value = 0, super.reset();
  }
}, hc = { dependencies: null }, Wc = class extends wy {
  constructor(e) {
    super(), this.source = e, this.setValue(e);
  }
  getValue(e) {
    const t = {};
    return li(this.source, (n, r) => {
      Ub(n) ? t[r] = n.getValue(e) : Fr(n) ? t[r] = Tr(n) : e || (t[r] = n);
    }), t;
  }
  /** Replace the raw object data */
  setValue(e) {
    this.source = e, this.payload = this._makePayload(e);
  }
  reset() {
    this.payload && Et(this.payload, (e) => e.reset());
  }
  /** Create a payload set. */
  _makePayload(e) {
    if (e) {
      const t = /* @__PURE__ */ new Set();
      return li(e, this._addToPayload, t), Array.from(t);
    }
  }
  /** Add to a payload set. */
  _addToPayload(e) {
    hc.dependencies && Fr(e) && hc.dependencies.add(e);
    const t = Vc(e);
    t && Et(t, (n) => this.add(n));
  }
}, ky = class extends Wc {
  constructor(e) {
    super(e);
  }
  /** @internal */
  static create(e) {
    return new ky(e);
  }
  getValue() {
    return this.source.map((e) => e.getValue());
  }
  setValue(e) {
    const t = this.getPayload();
    return e.length == t.length ? t.map((n, r) => n.setValue(e[r])).some(Boolean) : (super.setValue(e.map(Kb)), !0);
  }
};
function Kb(e) {
  return (Hc(e) ? Pl : Bl).create(e);
}
function kh(e) {
  const t = si(e);
  return t ? t.constructor : je.arr(e) ? ky : Hc(e) ? Pl : Bl;
}
var Lp = (e, t) => {
  const n = (
    // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !je.fun(e) || e.prototype && e.prototype.isReactComponent
  );
  return fe.forwardRef((r, i) => {
    const o = fe.useRef(null), h = n && // eslint-disable-next-line react-hooks/rules-of-hooks
    fe.useCallback(
      (m) => {
        o.current = Xb(i, m);
      },
      [i]
    ), [d, c] = Yb(r, t), p = xy(), y = () => {
      const m = o.current;
      if (n && !m)
        return;
      (m ? t.applyAnimatedValues(m, d.getValue(!0)) : !1) === !1 && p();
    }, g = new Gb(y, c), b = fe.useRef();
    es(() => (b.current = g, Et(c, (m) => cs(m, g)), () => {
      b.current && (Et(
        b.current.deps,
        (m) => El(m, b.current)
      ), At.cancel(b.current.update));
    })), fe.useEffect(y, []), Sy(() => () => {
      const m = b.current;
      Et(m.deps, (C) => El(C, m));
    });
    const T = t.getComponentProps(d.getValue());
    return /* @__PURE__ */ fe.createElement(e, { ...T, ref: h });
  });
}, Gb = class {
  constructor(e, t) {
    this.update = e, this.deps = t;
  }
  eventObserved(e) {
    e.type == "change" && At.write(this.update);
  }
};
function Yb(e, t) {
  const n = /* @__PURE__ */ new Set();
  return hc.dependencies = n, e.style && (e = {
    ...e,
    style: t.createAnimatedStyle(e.style)
  }), e = new Wc(e), hc.dependencies = null, [e, n];
}
function Xb(e, t) {
  return e && (je.fun(e) ? e(t) : e.current = t), t;
}
var Ep = Symbol.for("AnimatedComponent"), qb = (e, {
  applyAnimatedValues: t = () => !1,
  createAnimatedStyle: n = (i) => new Wc(i),
  getComponentProps: r = (i) => i
} = {}) => {
  const i = {
    applyAnimatedValues: t,
    createAnimatedStyle: n,
    getComponentProps: r
  }, o = (h) => {
    const d = _p(h) || "Anonymous";
    return je.str(h) ? h = o[h] || (o[h] = Lp(h, i)) : h = h[Ep] || (h[Ep] = Lp(h, i)), h.displayName = `Animated(${d})`, h;
  };
  return li(e, (h, d) => {
    je.arr(e) && (d = _p(h)), o[d] = o(h);
  }), {
    animated: o
  };
}, _p = (e) => je.str(e) ? e : e && je.str(e.displayName) ? e.displayName : je.fun(e) && e.name || null;
function Cr(e, ...t) {
  return je.fun(e) ? e(...t) : e;
}
var yl = (e, t) => e === !0 || !!(t && e && (je.fun(e) ? e(t) : pr(e).includes(t))), Ty = (e, t) => je.obj(e) ? t && e[t] : e, Cy = (e, t) => e.default === !0 ? e[t] : e.default ? e.default[t] : void 0, Zb = (e) => e, ff = (e, t = Zb) => {
  let n = Qb;
  e.default && e.default !== !0 && (e = e.default, n = Object.keys(e));
  const r = {};
  for (const i of n) {
    const o = t(e[i], i);
    je.und(o) || (r[i] = o);
  }
  return r;
}, Qb = [
  "config",
  "onProps",
  "onStart",
  "onChange",
  "onPause",
  "onResume",
  "onRest"
], Jb = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  // Transition props
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  // Internal props
  keys: 1,
  callId: 1,
  parentId: 1
};
function ex(e) {
  const t = {};
  let n = 0;
  if (li(e, (r, i) => {
    Jb[i] || (t[i] = r, n++);
  }), n)
    return t;
}
function pf(e) {
  const t = ex(e);
  if (t) {
    const n = { to: t };
    return li(e, (r, i) => i in t || (n[i] = r)), n;
  }
  return { ...e };
}
function Nl(e) {
  return e = Tr(e), je.arr(e) ? e.map(Nl) : Hc(e) ? Yr.createStringInterpolator({
    range: [0, 1],
    output: [e, e]
  })(1) : e;
}
function tx(e) {
  for (const t in e)
    return !0;
  return !1;
}
function Th(e) {
  return je.fun(e) || je.arr(e) && je.obj(e[0]);
}
function Pp(e, t) {
  var n;
  (n = e.ref) == null || n.delete(e), t == null || t.delete(e);
}
function nx(e, t) {
  var n;
  t && e.ref !== t && ((n = e.ref) == null || n.delete(e), t.add(e), e.ref = t);
}
var rx = {
  default: { tension: 170, friction: 26 },
  gentle: { tension: 120, friction: 14 },
  wobbly: { tension: 180, friction: 12 },
  stiff: { tension: 210, friction: 20 },
  slow: { tension: 280, friction: 60 },
  molasses: { tension: 280, friction: 120 }
}, Ch = {
  ...rx.default,
  mass: 1,
  damping: 1,
  easing: Pb.linear,
  clamp: !1
}, ix = class {
  constructor() {
    this.velocity = 0, Object.assign(this, Ch);
  }
};
function ax(e, t, n) {
  n && (n = { ...n }, Np(n, t), t = { ...n, ...t }), Np(e, t), Object.assign(e, t);
  for (const h in Ch)
    e[h] == null && (e[h] = Ch[h]);
  let { frequency: r, damping: i } = e;
  const { mass: o } = e;
  return je.und(r) || (r < 0.01 && (r = 0.01), i < 0 && (i = 0), e.tension = Math.pow(2 * Math.PI / r, 2) * o, e.friction = 4 * Math.PI * i * o / r), e;
}
function Np(e, t) {
  if (!je.und(t.decay))
    e.duration = void 0;
  else {
    const n = !je.und(t.tension) || !je.und(t.friction);
    (n || !je.und(t.frequency) || !je.und(t.damping) || !je.und(t.mass)) && (e.duration = void 0, e.decay = void 0), n && (e.frequency = void 0);
  }
}
var Rp = [], ox = class {
  constructor() {
    this.changed = !1, this.values = Rp, this.toValues = null, this.fromValues = Rp, this.config = new ix(), this.immediate = !1;
  }
};
function Ay(e, { key: t, props: n, defaultProps: r, state: i, actions: o }) {
  return new Promise((h, d) => {
    let c, p, y = yl(n.cancel ?? (r == null ? void 0 : r.cancel), t);
    if (y)
      T();
    else {
      je.und(n.pause) || (i.paused = yl(n.pause, t));
      let m = r == null ? void 0 : r.pause;
      m !== !0 && (m = i.paused || yl(m, t)), c = Cr(n.delay || 0, t), m ? (i.resumeQueue.add(b), o.pause()) : (o.resume(), b());
    }
    function g() {
      i.resumeQueue.add(b), i.timeouts.delete(p), p.cancel(), c = p.time - At.now();
    }
    function b() {
      c > 0 && !Yr.skipAnimation ? (i.delayed = !0, p = At.setTimeout(T, c), i.pauseQueue.add(g), i.timeouts.add(p)) : T();
    }
    function T() {
      i.delayed && (i.delayed = !1), i.pauseQueue.delete(g), i.timeouts.delete(p), e <= (i.cancelId || 0) && (y = !0);
      try {
        o.start({ ...n, callId: e, cancel: y }, h);
      } catch (m) {
        d(m);
      }
    }
  });
}
var mf = (e, t) => t.length == 1 ? t[0] : t.some((n) => n.cancelled) ? is(e.get()) : t.every((n) => n.noop) ? Ly(e.get()) : Ur(
  e.get(),
  t.every((n) => n.finished)
), Ly = (e) => ({
  value: e,
  noop: !0,
  finished: !0,
  cancelled: !1
}), Ur = (e, t, n = !1) => ({
  value: e,
  finished: t,
  cancelled: n
}), is = (e) => ({
  value: e,
  cancelled: !0,
  finished: !1
});
function Ey(e, t, n, r) {
  const { callId: i, parentId: o, onRest: h } = t, { asyncTo: d, promise: c } = n;
  return !o && e === d && !t.reset ? c : n.promise = (async () => {
    n.asyncId = i, n.asyncTo = e;
    const p = ff(
      t,
      (w, S) => (
        // The `onRest` prop is only called when the `runAsync` promise is resolved.
        S === "onRest" ? void 0 : w
      )
    );
    let y, g;
    const b = new Promise(
      (w, S) => (y = w, g = S)
    ), T = (w) => {
      const S = (
        // The `cancel` prop or `stop` method was used.
        i <= (n.cancelId || 0) && is(r) || // The async `to` prop was replaced.
        i !== n.asyncId && Ur(r, !1)
      );
      if (S)
        throw w.result = S, g(w), w;
    }, m = (w, S) => {
      const B = new Dp(), M = new Op();
      return (async () => {
        if (Yr.skipAnimation)
          throw Rl(n), M.result = Ur(r, !1), g(M), M;
        T(B);
        const D = je.obj(w) ? { ...w } : { ...S, to: w };
        D.parentId = i, li(p, (L, U) => {
          je.und(D[U]) && (D[U] = L);
        });
        const O = await r.start(D);
        return T(B), n.paused && await new Promise((L) => {
          n.resumeQueue.add(L);
        }), O;
      })();
    };
    let C;
    if (Yr.skipAnimation)
      return Rl(n), Ur(r, !1);
    try {
      let w;
      je.arr(e) ? w = (async (S) => {
        for (const B of S)
          await m(B);
      })(e) : w = Promise.resolve(e(m, r.stop.bind(r))), await Promise.all([w.then(y), b]), C = Ur(r.get(), !0, !1);
    } catch (w) {
      if (w instanceof Dp)
        C = w.result;
      else if (w instanceof Op)
        C = w.result;
      else
        throw w;
    } finally {
      i == n.asyncId && (n.asyncId = o, n.asyncTo = o ? d : void 0, n.promise = o ? c : void 0);
    }
    return je.fun(h) && At.batchedUpdates(() => {
      h(C, r, r.item);
    }), C;
  })();
}
function Rl(e, t) {
  pl(e.timeouts, (n) => n.cancel()), e.pauseQueue.clear(), e.resumeQueue.clear(), e.asyncId = e.asyncTo = e.promise = void 0, t && (e.cancelId = t);
}
var Dp = class extends Error {
  constructor() {
    super(
      "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
    );
  }
}, Op = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
}, Ah = (e) => e instanceof yf, sx = 1, yf = class extends py {
  constructor() {
    super(...arguments), this.id = sx++, this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(e) {
    this._priority != e && (this._priority = e, this._onPriorityChange(e));
  }
  /** Get the current value */
  get() {
    const e = si(this);
    return e && e.getValue();
  }
  /** Create a spring that maps our value to another value */
  to(...e) {
    return Yr.to(this, e);
  }
  /** @deprecated Use the `to` method instead. */
  interpolate(...e) {
    return by(), Yr.to(this, e);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(e) {
    e == 1 && this._attach();
  }
  observerRemoved(e) {
    e == 0 && this._detach();
  }
  /** Called when the first child is added. */
  _attach() {
  }
  /** Called when the last child is removed. */
  _detach() {
  }
  /** Tell our children about our new value */
  _onChange(e, t = !1) {
    Ll(this, {
      type: "change",
      parent: this,
      value: e,
      idle: t
    });
  }
  /** Tell our children about our new priority */
  _onPriorityChange(e) {
    this.idle || Bc.sort(this), Ll(this, {
      type: "priority",
      parent: this,
      priority: e
    });
  }
}, ja = Symbol.for("SpringPhase"), _y = 1, Lh = 2, Eh = 4, Jd = (e) => (e[ja] & _y) > 0, Ui = (e) => (e[ja] & Lh) > 0, sl = (e) => (e[ja] & Eh) > 0, Mp = (e, t) => t ? e[ja] |= Lh | _y : e[ja] &= ~Lh, Ip = (e, t) => t ? e[ja] |= Eh : e[ja] &= ~Eh, lx = class extends yf {
  constructor(e, t) {
    if (super(), this.animation = new ox(), this.defaultProps = {}, this._state = {
      paused: !1,
      delayed: !1,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._pendingCalls = /* @__PURE__ */ new Set(), this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !je.und(e) || !je.und(t)) {
      const n = je.obj(e) ? { ...e } : { ...t, from: e };
      je.und(n.default) && (n.default = !0), this.start(n);
    }
  }
  /** Equals true when not advancing on each frame. */
  get idle() {
    return !(Ui(this) || this._state.asyncTo) || sl(this);
  }
  get goal() {
    return Tr(this.animation.to);
  }
  get velocity() {
    const e = si(this);
    return e instanceof Bl ? e.lastVelocity || 0 : e.getPayload().map((t) => t.lastVelocity || 0);
  }
  /**
   * When true, this value has been animated at least once.
   */
  get hasAnimated() {
    return Jd(this);
  }
  /**
   * When true, this value has an unfinished animation,
   * which is either active or paused.
   */
  get isAnimating() {
    return Ui(this);
  }
  /**
   * When true, all current and future animations are paused.
   */
  get isPaused() {
    return sl(this);
  }
  /**
   *
   *
   */
  get isDelayed() {
    return this._state.delayed;
  }
  /** Advance the current animation by a number of milliseconds */
  advance(e) {
    let t = !0, n = !1;
    const r = this.animation;
    let { toValues: i } = r;
    const { config: o } = r, h = Vc(r.to);
    !h && Fr(r.to) && (i = pr(Tr(r.to))), r.values.forEach((p, y) => {
      if (p.done)
        return;
      const g = (
        // Animated strings always go from 0 to 1.
        p.constructor == Pl ? 1 : h ? h[y].lastPosition : i[y]
      );
      let b = r.immediate, T = g;
      if (!b) {
        if (T = p.lastPosition, o.tension <= 0) {
          p.done = !0;
          return;
        }
        let m = p.elapsedTime += e;
        const C = r.fromValues[y], w = p.v0 != null ? p.v0 : p.v0 = je.arr(o.velocity) ? o.velocity[y] : o.velocity;
        let S;
        const B = o.precision || (C == g ? 5e-3 : Math.min(1, Math.abs(g - C) * 1e-3));
        if (je.und(o.duration))
          if (o.decay) {
            const M = o.decay === !0 ? 0.998 : o.decay, D = Math.exp(-(1 - M) * m);
            T = C + w / (1 - M) * (1 - D), b = Math.abs(p.lastPosition - T) <= B, S = w * D;
          } else {
            S = p.lastVelocity == null ? w : p.lastVelocity;
            const M = o.restVelocity || B / 10, D = o.clamp ? 0 : o.bounce, O = !je.und(D), L = C == g ? p.v0 > 0 : C < g;
            let U, X = !1;
            const ne = 1, G = Math.ceil(e / ne);
            for (let ce = 0; ce < G && (U = Math.abs(S) > M, !(!U && (b = Math.abs(g - T) <= B, b))); ++ce) {
              O && (X = T == g || T > g == L, X && (S = -S * D, T = g));
              const q = -o.tension * 1e-6 * (T - g), re = -o.friction * 1e-3 * S, $ = (q + re) / o.mass;
              S = S + $ * ne, T = T + S * ne;
            }
          }
        else {
          let M = 1;
          o.duration > 0 && (this._memoizedDuration !== o.duration && (this._memoizedDuration = o.duration, p.durationProgress > 0 && (p.elapsedTime = o.duration * p.durationProgress, m = p.elapsedTime += e)), M = (o.progress || 0) + m / this._memoizedDuration, M = M > 1 ? 1 : M < 0 ? 0 : M, p.durationProgress = M), T = C + o.easing(M) * (g - C), S = (T - p.lastPosition) / e, b = M == 1;
        }
        p.lastVelocity = S, Number.isNaN(T) && (console.warn("Got NaN while animating:", this), b = !0);
      }
      h && !h[y].done && (b = !1), b ? p.done = !0 : t = !1, p.setValue(T, o.round) && (n = !0);
    });
    const d = si(this), c = d.getValue();
    if (t) {
      const p = Tr(r.to);
      (c !== p || n) && !o.decay ? (d.setValue(p), this._onChange(p)) : n && o.decay && this._onChange(c), this._stop();
    } else
      n && this._onChange(c);
  }
  /** Set the current value, while stopping the current animation */
  set(e) {
    return At.batchedUpdates(() => {
      this._stop(), this._focus(e), this._set(e);
    }), this;
  }
  /**
   * Freeze the active animation in time, as well as any updates merged
   * before `resume` is called.
   */
  pause() {
    this._update({ pause: !0 });
  }
  /** Resume the animation if paused. */
  resume() {
    this._update({ pause: !1 });
  }
  /** Skip to the end of the current animation. */
  finish() {
    if (Ui(this)) {
      const { to: e, config: t } = this.animation;
      At.batchedUpdates(() => {
        this._onStart(), t.decay || this._set(e, !1), this._stop();
      });
    }
    return this;
  }
  /** Push props into the pending queue. */
  update(e) {
    return (this.queue || (this.queue = [])).push(e), this;
  }
  start(e, t) {
    let n;
    return je.und(e) ? (n = this.queue || [], this.queue = []) : n = [je.obj(e) ? e : { ...t, to: e }], Promise.all(
      n.map((r) => this._update(r))
    ).then((r) => mf(this, r));
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   *
   * Pass `true` to call `onRest` with `cancelled: true`.
   */
  stop(e) {
    const { to: t } = this.animation;
    return this._focus(this.get()), Rl(this._state, e && this._lastCallId), At.batchedUpdates(() => this._stop(t, e)), this;
  }
  /** Restart the animation. */
  reset() {
    this._update({ reset: !0 });
  }
  /** @internal */
  eventObserved(e) {
    e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1);
  }
  /**
   * Parse the `to` and `from` range from the given `props` object.
   *
   * This also ensures the initial value is available to animated components
   * during the render phase.
   */
  _prepareNode(e) {
    const t = this.key || "";
    let { to: n, from: r } = e;
    n = je.obj(n) ? n[t] : n, (n == null || Th(n)) && (n = void 0), r = je.obj(r) ? r[t] : r, r == null && (r = void 0);
    const i = { to: n, from: r };
    return Jd(this) || (e.reverse && ([n, r] = [r, n]), r = Tr(r), je.und(r) ? si(this) || this._set(n) : this._set(r)), i;
  }
  /** Every update is processed by this method before merging. */
  _update({ ...e }, t) {
    const { key: n, defaultProps: r } = this;
    e.default && Object.assign(
      r,
      ff(
        e,
        (h, d) => /^on/.test(d) ? Ty(h, n) : h
      )
    ), Bp(this, e, "onProps"), ul(this, "onProps", e, this);
    const i = this._prepareNode(e);
    if (Object.isFrozen(this))
      throw Error(
        "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
      );
    const o = this._state;
    return Ay(++this._lastCallId, {
      key: n,
      props: e,
      defaultProps: r,
      state: o,
      actions: {
        pause: () => {
          sl(this) || (Ip(this, !0), hl(o.pauseQueue), ul(
            this,
            "onPause",
            Ur(this, ll(this, this.animation.to)),
            this
          ));
        },
        resume: () => {
          sl(this) && (Ip(this, !1), Ui(this) && this._resume(), hl(o.resumeQueue), ul(
            this,
            "onResume",
            Ur(this, ll(this, this.animation.to)),
            this
          ));
        },
        start: this._merge.bind(this, i)
      }
    }).then((h) => {
      if (e.loop && h.finished && !(t && h.noop)) {
        const d = Py(e);
        if (d)
          return this._update(d, !0);
      }
      return h;
    });
  }
  /** Merge props into the current animation */
  _merge(e, t, n) {
    if (t.cancel)
      return this.stop(!0), n(is(this));
    const r = !je.und(e.to), i = !je.und(e.from);
    if (r || i)
      if (t.callId > this._lastToId)
        this._lastToId = t.callId;
      else
        return n(is(this));
    const { key: o, defaultProps: h, animation: d } = this, { to: c, from: p } = d;
    let { to: y = c, from: g = p } = e;
    i && !r && (!t.default || je.und(y)) && (y = g), t.reverse && ([y, g] = [g, y]);
    const b = !Ti(g, p);
    b && (d.from = g), g = Tr(g);
    const T = !Ti(y, c);
    T && this._focus(y);
    const m = Th(t.to), { config: C } = d, { decay: w, velocity: S } = C;
    (r || i) && (C.velocity = 0), t.config && !m && ax(
      C,
      Cr(t.config, o),
      // Avoid calling the same "config" prop twice.
      t.config !== h.config ? Cr(h.config, o) : void 0
    );
    let B = si(this);
    if (!B || je.und(y))
      return n(Ur(this, !0));
    const M = (
      // When `reset` is undefined, the `from` prop implies `reset: true`,
      // except for declarative updates. When `reset` is defined, there
      // must exist a value to animate from.
      je.und(t.reset) ? i && !t.default : !je.und(g) && yl(t.reset, o)
    ), D = M ? g : this.get(), O = Nl(y), L = je.num(O) || je.arr(O) || Hc(O), U = !m && (!L || yl(h.immediate || t.immediate, o));
    if (T) {
      const ce = kh(y);
      if (ce !== B.constructor)
        if (U)
          B = this._set(O);
        else
          throw Error(
            `Cannot animate between ${B.constructor.name} and ${ce.name}, as the "to" prop suggests`
          );
    }
    const X = B.constructor;
    let ne = Fr(y), G = !1;
    if (!ne) {
      const ce = M || !Jd(this) && b;
      (T || ce) && (G = Ti(Nl(D), O), ne = !G), (!Ti(d.immediate, U) && !U || !Ti(C.decay, w) || !Ti(C.velocity, S)) && (ne = !0);
    }
    if (G && Ui(this) && (d.changed && !M ? ne = !0 : ne || this._stop(c)), !m && ((ne || Fr(c)) && (d.values = B.getPayload(), d.toValues = Fr(y) ? null : X == Pl ? [1] : pr(O)), d.immediate != U && (d.immediate = U, !U && !M && this._set(c)), ne)) {
      const { onRest: ce } = d;
      Et(ux, (re) => Bp(this, t, re));
      const q = Ur(this, ll(this, c));
      hl(this._pendingCalls, q), this._pendingCalls.add(n), d.changed && At.batchedUpdates(() => {
        var re;
        d.changed = !M, ce == null || ce(q, this), M ? Cr(h.onRest, q) : (re = d.onStart) == null || re.call(d, q, this);
      });
    }
    M && this._set(D), m ? n(Ey(t.to, t, this._state, this)) : ne ? this._start() : Ui(this) && !T ? this._pendingCalls.add(n) : n(Ly(D));
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  _focus(e) {
    const t = this.animation;
    e !== t.to && (Cp(this) && this._detach(), t.to = e, Cp(this) && this._attach());
  }
  _attach() {
    let e = 0;
    const { to: t } = this.animation;
    Fr(t) && (cs(t, this), Ah(t) && (e = t.priority + 1)), this.priority = e;
  }
  _detach() {
    const { to: e } = this.animation;
    Fr(e) && El(e, this);
  }
  /**
   * Update the current value from outside the frameloop,
   * and return the `Animated` node.
   */
  _set(e, t = !0) {
    const n = Tr(e);
    if (!je.und(n)) {
      const r = si(this);
      if (!r || !Ti(n, r.getValue())) {
        const i = kh(n);
        !r || r.constructor != i ? hf(this, i.create(n)) : r.setValue(n), r && At.batchedUpdates(() => {
          this._onChange(n, t);
        });
      }
    }
    return si(this);
  }
  _onStart() {
    const e = this.animation;
    e.changed || (e.changed = !0, ul(
      this,
      "onStart",
      Ur(this, ll(this, e.to)),
      this
    ));
  }
  _onChange(e, t) {
    t || (this._onStart(), Cr(this.animation.onChange, e, this)), Cr(this.defaultProps.onChange, e, this), super._onChange(e, t);
  }
  // This method resets the animation state (even if already animating) to
  // ensure the latest from/to range is used, and it also ensures this spring
  // is added to the frameloop.
  _start() {
    const e = this.animation;
    si(this).reset(Tr(e.to)), e.immediate || (e.fromValues = e.values.map((t) => t.lastPosition)), Ui(this) || (Mp(this, !0), sl(this) || this._resume());
  }
  _resume() {
    Yr.skipAnimation ? this.finish() : Bc.start(this);
  }
  /**
   * Exit the frameloop and notify `onRest` listeners.
   *
   * Always wrap `_stop` calls with `batchedUpdates`.
   */
  _stop(e, t) {
    if (Ui(this)) {
      Mp(this, !1);
      const n = this.animation;
      Et(n.values, (i) => {
        i.done = !0;
      }), n.toValues && (n.onChange = n.onPause = n.onResume = void 0), Ll(this, {
        type: "idle",
        parent: this
      });
      const r = t ? is(this.get()) : Ur(this.get(), ll(this, e ?? n.to));
      hl(this._pendingCalls, r), n.changed && (n.changed = !1, ul(this, "onRest", r, this));
    }
  }
};
function ll(e, t) {
  const n = Nl(t), r = Nl(e.get());
  return Ti(r, n);
}
function Py(e, t = e.loop, n = e.to) {
  const r = Cr(t);
  if (r) {
    const i = r !== !0 && pf(r), o = (i || e).reverse, h = !i || i.reset;
    return fc({
      ...e,
      loop: t,
      // Avoid updating default props when looping.
      default: !1,
      // Never loop the `pause` prop.
      pause: void 0,
      // For the "reverse" prop to loop as expected, the "to" prop
      // must be undefined. The "reverse" prop is ignored when the
      // "to" prop is an array or function.
      to: !o || Th(n) ? n : void 0,
      // Ignore the "from" prop except on reset.
      from: h ? e.from : void 0,
      reset: h,
      // The "loop" prop can return a "useSpring" props object to
      // override any of the original props.
      ...i
    });
  }
}
function fc(e) {
  const { to: t, from: n } = e = pf(e), r = /* @__PURE__ */ new Set();
  return je.obj(t) && Fp(t, r), je.obj(n) && Fp(n, r), e.keys = r.size ? Array.from(r) : null, e;
}
function Fp(e, t) {
  li(e, (n, r) => n != null && t.add(r));
}
var ux = [
  "onStart",
  "onRest",
  "onChange",
  "onPause",
  "onResume"
];
function Bp(e, t, n) {
  e.animation[n] = t[n] !== Cy(t, n) ? Ty(t[n], e.key) : void 0;
}
function ul(e, t, ...n) {
  var r, i, o, h;
  (i = (r = e.animation)[t]) == null || i.call(r, ...n), (h = (o = e.defaultProps)[t]) == null || h.call(o, ...n);
}
var cx = ["onStart", "onChange", "onRest"], dx = 1, hx = class {
  constructor(e, t) {
    this.id = dx++, this.springs = {}, this.queue = [], this._lastAsyncId = 0, this._active = /* @__PURE__ */ new Set(), this._changed = /* @__PURE__ */ new Set(), this._started = !1, this._state = {
      paused: !1,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    }, this._onFrame = this._onFrame.bind(this), t && (this._flush = t), e && this.start({ default: !0, ...e });
  }
  /**
   * Equals `true` when no spring values are in the frameloop, and
   * no async animation is currently active.
   */
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((e) => e.idle && !e.isDelayed && !e.isPaused);
  }
  get item() {
    return this._item;
  }
  set item(e) {
    this._item = e;
  }
  /** Get the current values of our springs */
  get() {
    const e = {};
    return this.each((t, n) => e[n] = t.get()), e;
  }
  /** Set the current values without animating. */
  set(e) {
    for (const t in e) {
      const n = e[t];
      je.und(n) || this.springs[t].set(n);
    }
  }
  /** Push an update onto the queue of each value. */
  update(e) {
    return e && this.queue.push(fc(e)), this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  start(e) {
    let { queue: t } = this;
    return e ? t = pr(e).map(fc) : this.queue = [], this._flush ? this._flush(this, t) : (Oy(this, t), fx(this, t));
  }
  /** @internal */
  stop(e, t) {
    if (e !== !!e && (t = e), t) {
      const n = this.springs;
      Et(pr(t), (r) => n[r].stop(!!e));
    } else
      Rl(this._state, this._lastAsyncId), this.each((n) => n.stop(!!e));
    return this;
  }
  /** Freeze the active animation in time */
  pause(e) {
    if (je.und(e))
      this.start({ pause: !0 });
    else {
      const t = this.springs;
      Et(pr(e), (n) => t[n].pause());
    }
    return this;
  }
  /** Resume the animation if paused. */
  resume(e) {
    if (je.und(e))
      this.start({ pause: !1 });
    else {
      const t = this.springs;
      Et(pr(e), (n) => t[n].resume());
    }
    return this;
  }
  /** Call a function once per spring value */
  each(e) {
    li(this.springs, e);
  }
  /** @internal Called at the end of every animation frame */
  _onFrame() {
    const { onStart: e, onChange: t, onRest: n } = this._events, r = this._active.size > 0, i = this._changed.size > 0;
    (r && !this._started || i && !this._started) && (this._started = !0, pl(e, ([d, c]) => {
      c.value = this.get(), d(c, this, this._item);
    }));
    const o = !r && this._started, h = i || o && n.size ? this.get() : null;
    i && t.size && pl(t, ([d, c]) => {
      c.value = h, d(c, this, this._item);
    }), o && (this._started = !1, pl(n, ([d, c]) => {
      c.value = h, d(c, this, this._item);
    }));
  }
  /** @internal */
  eventObserved(e) {
    if (e.type == "change")
      this._changed.add(e.parent), e.idle || this._active.add(e.parent);
    else if (e.type == "idle")
      this._active.delete(e.parent);
    else
      return;
    At.onFrame(this._onFrame);
  }
};
function fx(e, t) {
  return Promise.all(t.map((n) => Ny(e, n))).then(
    (n) => mf(e, n)
  );
}
async function Ny(e, t, n) {
  const { keys: r, to: i, from: o, loop: h, onRest: d, onResolve: c } = t, p = je.obj(t.default) && t.default;
  h && (t.loop = !1), i === !1 && (t.to = null), o === !1 && (t.from = null);
  const y = je.arr(i) || je.fun(i) ? i : void 0;
  y ? (t.to = void 0, t.onRest = void 0, p && (p.onRest = void 0)) : Et(cx, (C) => {
    const w = t[C];
    if (je.fun(w)) {
      const S = e._events[C];
      t[C] = ({ finished: B, cancelled: M }) => {
        const D = S.get(w);
        D ? (B || (D.finished = !1), M && (D.cancelled = !0)) : S.set(w, {
          value: null,
          finished: B || !1,
          cancelled: M || !1
        });
      }, p && (p[C] = t[C]);
    }
  });
  const g = e._state;
  t.pause === !g.paused ? (g.paused = t.pause, hl(t.pause ? g.pauseQueue : g.resumeQueue)) : g.paused && (t.pause = !0);
  const b = (r || Object.keys(e.springs)).map(
    (C) => e.springs[C].start(t)
  ), T = t.cancel === !0 || Cy(t, "cancel") === !0;
  (y || T && g.asyncId) && b.push(
    Ay(++e._lastAsyncId, {
      props: t,
      state: g,
      actions: {
        pause: Sh,
        resume: Sh,
        start(C, w) {
          T ? (Rl(g, e._lastAsyncId), w(is(e))) : (C.onRest = d, w(
            Ey(
              y,
              C,
              g,
              e
            )
          ));
        }
      }
    })
  ), g.paused && await new Promise((C) => {
    g.resumeQueue.add(C);
  });
  const m = mf(e, await Promise.all(b));
  if (h && m.finished && !(n && m.noop)) {
    const C = Py(t, h, i);
    if (C)
      return Oy(e, [C]), Ny(e, C, !0);
  }
  return c && At.batchedUpdates(() => c(m, e, e.item)), m;
}
function px(e, t) {
  const n = { ...e.springs };
  return t && Et(pr(t), (r) => {
    je.und(r.keys) && (r = fc(r)), je.obj(r.to) || (r = { ...r, to: void 0 }), Dy(n, r, (i) => Ry(i));
  }), mx(e, n), n;
}
function mx(e, t) {
  li(t, (n, r) => {
    e.springs[r] || (e.springs[r] = n, cs(n, e));
  });
}
function Ry(e, t) {
  const n = new lx();
  return n.key = e, t && cs(n, t), n;
}
function Dy(e, t, n) {
  t.keys && Et(t.keys, (r) => {
    (e[r] || (e[r] = n(r)))._prepareNode(t);
  });
}
function Oy(e, t) {
  Et(t, (n) => {
    Dy(e.springs, n, (r) => Ry(r, e));
  });
}
var jc = ({
  children: e,
  ...t
}) => {
  const n = fe.useContext(pc), r = t.pause || !!n.pause, i = t.immediate || !!n.immediate;
  t = Hb(() => ({ pause: r, immediate: i }), [r, i]);
  const { Provider: o } = pc;
  return /* @__PURE__ */ fe.createElement(o, { value: t }, e);
}, pc = yx(jc, {});
jc.Provider = pc.Provider;
jc.Consumer = pc.Consumer;
function yx(e, t) {
  return Object.assign(e, fe.createContext(t)), e.Provider._context = e, e.Consumer._context = e, e;
}
var gx = () => {
  const e = [], t = function(r) {
    zb();
    const i = [];
    return Et(e, (o, h) => {
      if (je.und(r))
        i.push(o.start());
      else {
        const d = n(r, o, h);
        d && i.push(o.start(d));
      }
    }), i;
  };
  t.current = e, t.add = function(r) {
    e.includes(r) || e.push(r);
  }, t.delete = function(r) {
    const i = e.indexOf(r);
    ~i && e.splice(i, 1);
  }, t.pause = function() {
    return Et(e, (r) => r.pause(...arguments)), this;
  }, t.resume = function() {
    return Et(e, (r) => r.resume(...arguments)), this;
  }, t.set = function(r) {
    Et(e, (i, o) => {
      const h = je.fun(r) ? r(o, i) : r;
      h && i.set(h);
    });
  }, t.start = function(r) {
    const i = [];
    return Et(e, (o, h) => {
      if (je.und(r))
        i.push(o.start());
      else {
        const d = this._getProps(r, o, h);
        d && i.push(o.start(d));
      }
    }), i;
  }, t.stop = function() {
    return Et(e, (r) => r.stop(...arguments)), this;
  }, t.update = function(r) {
    return Et(e, (i, o) => i.update(this._getProps(r, i, o))), this;
  };
  const n = function(r, i, o) {
    return je.fun(r) ? r(o, i) : r;
  };
  return t._getProps = n, t;
};
function vx(e, t, n) {
  const r = je.fun(t) && t, {
    reset: i,
    sort: o,
    trail: h = 0,
    expires: d = !0,
    exitBeforeEnter: c = !1,
    onDestroyed: p,
    ref: y,
    config: g
  } = r ? r() : t, b = fe.useMemo(
    () => r || arguments.length == 3 ? gx() : void 0,
    []
  ), T = pr(e), m = [], C = fe.useRef(null), w = i ? null : C.current;
  es(() => {
    C.current = m;
  }), Sy(() => (Et(m, ($) => {
    b == null || b.add($.ctrl), $.ctrl.ref = b;
  }), () => {
    Et(C.current, ($) => {
      $.expired && clearTimeout($.expirationId), Pp($.ctrl, b), $.ctrl.stop(!0);
    });
  }));
  const S = xx(T, r ? r() : t, w), B = i && C.current || [];
  es(
    () => Et(B, ({ ctrl: $, item: j, key: oe }) => {
      Pp($, b), Cr(p, j, oe);
    })
  );
  const M = [];
  if (w && Et(w, ($, j) => {
    $.expired ? (clearTimeout($.expirationId), B.push($)) : (j = M[j] = S.indexOf($.key), ~j && (m[j] = $));
  }), Et(T, ($, j) => {
    m[j] || (m[j] = {
      key: S[j],
      item: $,
      phase: "mount",
      ctrl: new hx()
    }, m[j].ctrl.item = $);
  }), M.length) {
    let $ = -1;
    const { leave: j } = r ? r() : t;
    Et(M, (oe, ie) => {
      const le = w[ie];
      ~oe ? ($ = m.indexOf(le), m[$] = { ...le, item: T[oe] }) : j && m.splice(++$, 0, le);
    });
  }
  je.fun(o) && m.sort(($, j) => o($.item, j.item));
  let D = -h;
  const O = xy(), L = ff(t), U = /* @__PURE__ */ new Map(), X = fe.useRef(/* @__PURE__ */ new Map()), ne = fe.useRef(!1);
  Et(m, ($, j) => {
    const oe = $.key, ie = $.phase, le = r ? r() : t;
    let J, de;
    const ae = Cr(le.delay || 0, oe);
    if (ie == "mount")
      J = le.enter, de = "enter";
    else {
      const ve = S.indexOf(oe) < 0;
      if (ie != "leave")
        if (ve)
          J = le.leave, de = "leave";
        else if (J = le.update)
          de = "update";
        else
          return;
      else if (!ve)
        J = le.enter, de = "enter";
      else
        return;
    }
    if (J = Cr(J, $.item, j), J = je.obj(J) ? pf(J) : { to: J }, !J.config) {
      const ve = g || L.config;
      J.config = Cr(ve, $.item, j, de);
    }
    D += h;
    const Z = {
      ...L,
      // we need to add our props.delay value you here.
      delay: ae + D,
      ref: y,
      immediate: le.immediate,
      // This prevents implied resets.
      reset: !1,
      // Merge any phase-specific props.
      ...J
    };
    if (de == "enter" && je.und(Z.from)) {
      const ve = r ? r() : t, ke = je.und(ve.initial) || w ? ve.from : ve.initial;
      Z.from = Cr(ke, $.item, j);
    }
    const { onResolve: ye } = Z;
    Z.onResolve = (ve) => {
      Cr(ye, ve);
      const ke = C.current, me = ke.find((Ne) => Ne.key === oe);
      if (me && !(ve.cancelled && me.phase != "update") && me.ctrl.idle) {
        const Ne = ke.every((Ee) => Ee.ctrl.idle);
        if (me.phase == "leave") {
          const Ee = Cr(d, me.item);
          if (Ee !== !1) {
            const De = Ee === !0 ? 0 : Ee;
            if (me.expired = !0, !Ne && De > 0) {
              De <= 2147483647 && (me.expirationId = setTimeout(O, De));
              return;
            }
          }
        }
        Ne && ke.some((Ee) => Ee.expired) && (X.current.delete(me), c && (ne.current = !0), O());
      }
    };
    const ue = px($.ctrl, Z);
    de === "leave" && c ? X.current.set($, { phase: de, springs: ue, payload: Z }) : U.set($, { phase: de, springs: ue, payload: Z });
  });
  const G = fe.useContext(jc), ce = jb(G), q = G !== ce && tx(G);
  es(() => {
    q && Et(m, ($) => {
      $.ctrl.start({ default: G });
    });
  }, [G]), Et(U, ($, j) => {
    if (X.current.size) {
      const oe = m.findIndex((ie) => ie.key === j.key);
      m.splice(oe, 1);
    }
  }), es(
    () => {
      Et(
        X.current.size ? X.current : U,
        ({ phase: $, payload: j }, oe) => {
          const { ctrl: ie } = oe;
          oe.phase = $, b == null || b.add(ie), q && $ == "enter" && ie.start({ default: G }), j && (nx(ie, j.ref), (ie.ref || b) && !ne.current ? ie.update(j) : (ie.start(j), ne.current && (ne.current = !1)));
        }
      );
    },
    i ? void 0 : n
  );
  const re = ($) => /* @__PURE__ */ fe.createElement(fe.Fragment, null, m.map((j, oe) => {
    const { springs: ie } = U.get(j) || j.ctrl, le = $({ ...ie }, j.item, j, oe);
    return le && le.type ? /* @__PURE__ */ fe.createElement(
      le.type,
      {
        ...le.props,
        key: je.str(j.key) || je.num(j.key) ? j.key : j.ctrl.id,
        ref: le.ref
      }
    ) : le;
  }));
  return b ? [re, b] : re;
}
var bx = 1;
function xx(e, { key: t, keys: n = t }, r) {
  if (n === null) {
    const i = /* @__PURE__ */ new Set();
    return e.map((o) => {
      const h = r && r.find(
        (d) => d.item === o && d.phase !== "leave" && !i.has(d)
      );
      return h ? (i.add(h), h.key) : bx++;
    });
  }
  return je.und(n) ? e : je.fun(n) ? e.map(n) : pr(n);
}
var My = class extends yf {
  constructor(e, t) {
    super(), this.source = e, this.idle = !0, this._active = /* @__PURE__ */ new Set(), this.calc = Cl(...t);
    const n = this._get(), r = kh(n);
    hf(this, r.create(n));
  }
  advance(e) {
    const t = this._get(), n = this.get();
    Ti(t, n) || (si(this).setValue(t), this._onChange(t, this.idle)), !this.idle && zp(this._active) && eh(this);
  }
  _get() {
    const e = je.arr(this.source) ? this.source.map(Tr) : pr(Tr(this.source));
    return this.calc(...e);
  }
  _start() {
    this.idle && !zp(this._active) && (this.idle = !1, Et(Vc(this), (e) => {
      e.done = !1;
    }), Yr.skipAnimation ? (At.batchedUpdates(() => this.advance()), eh(this)) : Bc.start(this));
  }
  // Observe our sources only when we're observed.
  _attach() {
    let e = 1;
    Et(pr(this.source), (t) => {
      Fr(t) && cs(t, this), Ah(t) && (t.idle || this._active.add(t), e = Math.max(e, t.priority + 1));
    }), this.priority = e, this._start();
  }
  // Stop observing our sources once we have no observers.
  _detach() {
    Et(pr(this.source), (e) => {
      Fr(e) && El(e, this);
    }), this._active.clear(), eh(this);
  }
  /** @internal */
  eventObserved(e) {
    e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = pr(this.source).reduce(
      (t, n) => Math.max(t, (Ah(n) ? n.priority : 0) + 1),
      0
    ));
  }
};
function Sx(e) {
  return e.idle !== !1;
}
function zp(e) {
  return !e.size || Array.from(e).every(Sx);
}
function eh(e) {
  e.idle || (e.idle = !0, Et(Vc(e), (t) => {
    t.done = !0;
  }), Ll(e, {
    type: "idle",
    parent: e
  }));
}
var wx = (e, ...t) => (by(), new My(e, t));
Yr.assign({
  createStringInterpolator: gy,
  to: (e, t) => new My(e, t)
});
var Iy = /^--/;
function kx(e, t) {
  return t == null || typeof t == "boolean" || t === "" ? "" : typeof t == "number" && t !== 0 && !Iy.test(e) && !(gl.hasOwnProperty(e) && gl[e]) ? t + "px" : ("" + t).trim();
}
var $p = {};
function Tx(e, t) {
  if (!e.nodeType || !e.setAttribute)
    return !1;
  const n = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter", {
    className: r,
    style: i,
    children: o,
    scrollTop: h,
    scrollLeft: d,
    viewBox: c,
    ...p
  } = t, y = Object.values(p), g = Object.keys(p).map(
    (b) => n || e.hasAttribute(b) ? b : $p[b] || ($p[b] = b.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (T) => "-" + T.toLowerCase()
    ))
  );
  o !== void 0 && (e.textContent = o);
  for (const b in i)
    if (i.hasOwnProperty(b)) {
      const T = kx(b, i[b]);
      Iy.test(b) ? e.style.setProperty(b, T) : e.style[b] = T;
    }
  g.forEach((b, T) => {
    e.setAttribute(b, y[T]);
  }), r !== void 0 && (e.className = r), h !== void 0 && (e.scrollTop = h), d !== void 0 && (e.scrollLeft = d), c !== void 0 && e.setAttribute("viewBox", c);
}
var gl = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  // SVG-related properties
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, Cx = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1), Ax = ["Webkit", "Ms", "Moz", "O"];
gl = Object.keys(gl).reduce((e, t) => (Ax.forEach((n) => e[Cx(n, t)] = e[t]), e), gl);
var Lx = /^(matrix|translate|scale|rotate|skew)/, Ex = /^(translate)/, _x = /^(rotate|skew)/, th = (e, t) => je.num(e) && e !== 0 ? e + t : e, Ju = (e, t) => je.arr(e) ? e.every((n) => Ju(n, t)) : je.num(e) ? e === t : parseFloat(e) === t, Px = class extends Wc {
  constructor({ x: e, y: t, z: n, ...r }) {
    const i = [], o = [];
    (e || t || n) && (i.push([e || 0, t || 0, n || 0]), o.push((h) => [
      `translate3d(${h.map((d) => th(d, "px")).join(",")})`,
      // prettier-ignore
      Ju(h, 0)
    ])), li(r, (h, d) => {
      if (d === "transform")
        i.push([h || ""]), o.push((c) => [c, c === ""]);
      else if (Lx.test(d)) {
        if (delete r[d], je.und(h))
          return;
        const c = Ex.test(d) ? "px" : _x.test(d) ? "deg" : "";
        i.push(pr(h)), o.push(
          d === "rotate3d" ? ([p, y, g, b]) => [
            `rotate3d(${p},${y},${g},${th(b, c)})`,
            Ju(b, 0)
          ] : (p) => [
            `${d}(${p.map((y) => th(y, c)).join(",")})`,
            Ju(p, d.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    }), i.length && (r.transform = new Nx(i, o)), super(r);
  }
}, Nx = class extends py {
  constructor(e, t) {
    super(), this.inputs = e, this.transforms = t, this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let e = "", t = !0;
    return Et(this.inputs, (n, r) => {
      const i = Tr(n[0]), [o, h] = this.transforms[r](
        je.arr(i) ? i : n.map(Tr)
      );
      e += " " + o, t = t && h;
    }), t ? "none" : e;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(e) {
    e == 1 && Et(
      this.inputs,
      (t) => Et(
        t,
        (n) => Fr(n) && cs(n, this)
      )
    );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(e) {
    e == 0 && Et(
      this.inputs,
      (t) => Et(
        t,
        (n) => Fr(n) && El(n, this)
      )
    );
  }
  eventObserved(e) {
    e.type == "change" && (this._value = null), Ll(this, e);
  }
}, Rx = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
Yr.assign({
  batchedUpdates: hv.unstable_batchedUpdates,
  createStringInterpolator: gy,
  colors: gb
});
var Dx = qb(Rx, {
  applyAnimatedValues: Tx,
  createAnimatedStyle: (e) => new Px(e),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop: e, scrollLeft: t, ...n }) => n
}), Hp = Dx.animated;
function Ox(e) {
  return e.innerRadius;
}
function Mx(e) {
  return e.outerRadius;
}
function Ix(e) {
  return e.startAngle;
}
function Fx(e) {
  return e.endAngle;
}
function Bx(e) {
  return e && e.padAngle;
}
function zx(e, t, n, r, i, o, h, d) {
  var c = n - e, p = r - t, y = h - i, g = d - o, b = g * c - y * p;
  if (!(b * b < tr))
    return b = (y * (t - o) - g * (e - i)) / b, [e + b * c, t + b * p];
}
function $u(e, t, n, r, i, o, h) {
  var d = e - n, c = t - r, p = (h ? o : -o) / Jo(d * d + c * c), y = p * c, g = -p * d, b = e + y, T = t + g, m = n + y, C = r + g, w = (b + m) / 2, S = (T + C) / 2, B = m - b, M = C - T, D = B * B + M * M, O = i - o, L = b * C - m * T, U = (M < 0 ? -1 : 1) * Jo(Dg(0, O * O * D - L * L)), X = (L * M - B * U) / D, ne = (-L * B - M * U) / D, G = (L * M + B * U) / D, ce = (-L * B + M * U) / D, q = X - w, re = ne - S, $ = G - w, j = ce - S;
  return q * q + re * re > $ * $ + j * j && (X = G, ne = ce), {
    cx: X,
    cy: ne,
    x01: -y,
    y01: -g,
    x11: X * (i / O - 1),
    y11: ne * (i / O - 1)
  };
}
function $x() {
  var e = Ox, t = Mx, n = It(0), r = null, i = Ix, o = Fx, h = Bx, d = null;
  function c() {
    var p, y, g = +e.apply(this, arguments), b = +t.apply(this, arguments), T = i.apply(this, arguments) - Wf, m = o.apply(this, arguments) - Wf, C = jf(m - T), w = m > T;
    if (d || (d = p = Rc()), b < g && (y = b, b = g, g = y), !(b > tr))
      d.moveTo(0, 0);
    else if (C > Xu - tr)
      d.moveTo(b * Ma(T), b * ii(T)), d.arc(0, 0, b, T, m, !w), g > tr && (d.moveTo(g * Ma(m), g * ii(m)), d.arc(0, 0, g, m, T, w));
    else {
      var S = T, B = m, M = T, D = m, O = C, L = C, U = h.apply(this, arguments) / 2, X = U > tr && (r ? +r.apply(this, arguments) : Jo(g * g + b * b)), ne = jd(jf(b - g) / 2, +n.apply(this, arguments)), G = ne, ce = ne, q, re;
      if (X > tr) {
        var $ = Uf(X / g * ii(U)), j = Uf(X / b * ii(U));
        (O -= $ * 2) > tr ? ($ *= w ? 1 : -1, M += $, D -= $) : (O = 0, M = D = (T + m) / 2), (L -= j * 2) > tr ? (j *= w ? 1 : -1, S += j, B -= j) : (L = 0, S = B = (T + m) / 2);
      }
      var oe = b * Ma(S), ie = b * ii(S), le = g * Ma(D), J = g * ii(D);
      if (ne > tr) {
        var de = b * Ma(B), ae = b * ii(B), Z = g * Ma(M), ye = g * ii(M), ue;
        if (C < Vf && (ue = zx(oe, ie, Z, ye, de, ae, le, J))) {
          var ve = oe - ue[0], ke = ie - ue[1], me = de - ue[0], Ne = ae - ue[1], Ee = 1 / ii(Rg((ve * me + ke * Ne) / (Jo(ve * ve + ke * ke) * Jo(me * me + Ne * Ne))) / 2), De = Jo(ue[0] * ue[0] + ue[1] * ue[1]);
          G = jd(ne, (g - De) / (Ee - 1)), ce = jd(ne, (b - De) / (Ee + 1));
        }
      }
      L > tr ? ce > tr ? (q = $u(Z, ye, oe, ie, b, ce, w), re = $u(de, ae, le, J, b, ce, w), d.moveTo(q.cx + q.x01, q.cy + q.y01), ce < ne ? d.arc(q.cx, q.cy, ce, Qn(q.y01, q.x01), Qn(re.y01, re.x01), !w) : (d.arc(q.cx, q.cy, ce, Qn(q.y01, q.x01), Qn(q.y11, q.x11), !w), d.arc(0, 0, b, Qn(q.cy + q.y11, q.cx + q.x11), Qn(re.cy + re.y11, re.cx + re.x11), !w), d.arc(re.cx, re.cy, ce, Qn(re.y11, re.x11), Qn(re.y01, re.x01), !w))) : (d.moveTo(oe, ie), d.arc(0, 0, b, S, B, !w)) : d.moveTo(oe, ie), !(g > tr) || !(O > tr) ? d.lineTo(le, J) : G > tr ? (q = $u(le, J, de, ae, g, -G, w), re = $u(oe, ie, Z, ye, g, -G, w), d.lineTo(q.cx + q.x01, q.cy + q.y01), G < ne ? d.arc(q.cx, q.cy, G, Qn(q.y01, q.x01), Qn(re.y01, re.x01), !w) : (d.arc(q.cx, q.cy, G, Qn(q.y01, q.x01), Qn(q.y11, q.x11), !w), d.arc(0, 0, g, Qn(q.cy + q.y11, q.cx + q.x11), Qn(re.cy + re.y11, re.cx + re.x11), w), d.arc(re.cx, re.cy, G, Qn(re.y11, re.x11), Qn(re.y01, re.x01), !w))) : d.arc(0, 0, g, D, M, w);
    }
    if (d.closePath(), p)
      return d = null, p + "" || null;
  }
  return c.centroid = function() {
    var p = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, y = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Vf / 2;
    return [Ma(y) * p, ii(y) * p];
  }, c.innerRadius = function(p) {
    return arguments.length ? (e = typeof p == "function" ? p : It(+p), c) : e;
  }, c.outerRadius = function(p) {
    return arguments.length ? (t = typeof p == "function" ? p : It(+p), c) : t;
  }, c.cornerRadius = function(p) {
    return arguments.length ? (n = typeof p == "function" ? p : It(+p), c) : n;
  }, c.padRadius = function(p) {
    return arguments.length ? (r = p == null ? null : typeof p == "function" ? p : It(+p), c) : r;
  }, c.startAngle = function(p) {
    return arguments.length ? (i = typeof p == "function" ? p : It(+p), c) : i;
  }, c.endAngle = function(p) {
    return arguments.length ? (o = typeof p == "function" ? p : It(+p), c) : o;
  }, c.padAngle = function(p) {
    return arguments.length ? (h = typeof p == "function" ? p : It(+p), c) : h;
  }, c.context = function(p) {
    return arguments.length ? (d = p ?? null, c) : d;
  }, c;
}
function Fy(e) {
  this._context = e;
}
Fy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Uc(e) {
  return new Fy(e);
}
function gf(e) {
  return e[0];
}
function vf(e) {
  return e[1];
}
function By() {
  var e = gf, t = vf, n = It(!0), r = null, i = Uc, o = null;
  function h(d) {
    var c, p = d.length, y, g = !1, b;
    for (r == null && (o = i(b = Rc())), c = 0; c <= p; ++c)
      !(c < p && n(y = d[c], c, d)) === g && ((g = !g) ? o.lineStart() : o.lineEnd()), g && o.point(+e(y, c, d), +t(y, c, d));
    if (b)
      return o = null, b + "" || null;
  }
  return h.x = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : It(+d), h) : e;
  }, h.y = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : It(+d), h) : t;
  }, h.defined = function(d) {
    return arguments.length ? (n = typeof d == "function" ? d : It(!!d), h) : n;
  }, h.curve = function(d) {
    return arguments.length ? (i = d, r != null && (o = i(r)), h) : i;
  }, h.context = function(d) {
    return arguments.length ? (d == null ? r = o = null : o = i(r = d), h) : r;
  }, h;
}
function Hx() {
  var e = gf, t = null, n = It(0), r = vf, i = It(!0), o = null, h = Uc, d = null;
  function c(y) {
    var g, b, T, m = y.length, C, w = !1, S, B = new Array(m), M = new Array(m);
    for (o == null && (d = h(S = Rc())), g = 0; g <= m; ++g) {
      if (!(g < m && i(C = y[g], g, y)) === w)
        if (w = !w)
          b = g, d.areaStart(), d.lineStart();
        else {
          for (d.lineEnd(), d.lineStart(), T = g - 1; T >= b; --T)
            d.point(B[T], M[T]);
          d.lineEnd(), d.areaEnd();
        }
      w && (B[g] = +e(C, g, y), M[g] = +n(C, g, y), d.point(t ? +t(C, g, y) : B[g], r ? +r(C, g, y) : M[g]));
    }
    if (S)
      return d = null, S + "" || null;
  }
  function p() {
    return By().defined(i).curve(h).context(o);
  }
  return c.x = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : It(+y), t = null, c) : e;
  }, c.x0 = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : It(+y), c) : e;
  }, c.x1 = function(y) {
    return arguments.length ? (t = y == null ? null : typeof y == "function" ? y : It(+y), c) : t;
  }, c.y = function(y) {
    return arguments.length ? (n = typeof y == "function" ? y : It(+y), r = null, c) : n;
  }, c.y0 = function(y) {
    return arguments.length ? (n = typeof y == "function" ? y : It(+y), c) : n;
  }, c.y1 = function(y) {
    return arguments.length ? (r = y == null ? null : typeof y == "function" ? y : It(+y), c) : r;
  }, c.lineX0 = c.lineY0 = function() {
    return p().x(e).y(n);
  }, c.lineY1 = function() {
    return p().x(e).y(r);
  }, c.lineX1 = function() {
    return p().x(t).y(n);
  }, c.defined = function(y) {
    return arguments.length ? (i = typeof y == "function" ? y : It(!!y), c) : i;
  }, c.curve = function(y) {
    return arguments.length ? (h = y, o != null && (d = h(o)), c) : h;
  }, c.context = function(y) {
    return arguments.length ? (y == null ? o = d = null : d = h(o = y), c) : o;
  }, c;
}
function Vx(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Wx(e) {
  return e;
}
function jx() {
  var e = Wx, t = Vx, n = null, r = It(0), i = It(Xu), o = It(0);
  function h(d) {
    var c, p = d.length, y, g, b = 0, T = new Array(p), m = new Array(p), C = +r.apply(this, arguments), w = Math.min(Xu, Math.max(-Xu, i.apply(this, arguments) - C)), S, B = Math.min(Math.abs(w) / p, o.apply(this, arguments)), M = B * (w < 0 ? -1 : 1), D;
    for (c = 0; c < p; ++c)
      (D = m[T[c] = c] = +e(d[c], c, d)) > 0 && (b += D);
    for (t != null ? T.sort(function(O, L) {
      return t(m[O], m[L]);
    }) : n != null && T.sort(function(O, L) {
      return n(d[O], d[L]);
    }), c = 0, g = b ? (w - p * M) / b : 0; c < p; ++c, C = S)
      y = T[c], D = m[y], S = C + (D > 0 ? D * g : 0) + M, m[y] = {
        data: d[y],
        index: c,
        value: D,
        startAngle: C,
        endAngle: S,
        padAngle: B
      };
    return m;
  }
  return h.value = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : It(+d), h) : e;
  }, h.sortValues = function(d) {
    return arguments.length ? (t = d, n = null, h) : t;
  }, h.sort = function(d) {
    return arguments.length ? (n = d, t = null, h) : n;
  }, h.startAngle = function(d) {
    return arguments.length ? (r = typeof d == "function" ? d : It(+d), h) : r;
  }, h.endAngle = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : It(+d), h) : i;
  }, h.padAngle = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : It(+d), h) : o;
  }, h;
}
var _h = Array.prototype.slice;
function Ux(e) {
  return e.source;
}
function Kx(e) {
  return e.target;
}
function Gx(e) {
  var t = Ux, n = Kx, r = gf, i = vf, o = null;
  function h() {
    var d, c = _h.call(arguments), p = t.apply(this, c), y = n.apply(this, c);
    if (o || (o = d = Rc()), e(o, +r.apply(this, (c[0] = p, c)), +i.apply(this, c), +r.apply(this, (c[0] = y, c)), +i.apply(this, c)), d)
      return o = null, d + "" || null;
  }
  return h.source = function(d) {
    return arguments.length ? (t = d, h) : t;
  }, h.target = function(d) {
    return arguments.length ? (n = d, h) : n;
  }, h.x = function(d) {
    return arguments.length ? (r = typeof d == "function" ? d : It(+d), h) : r;
  }, h.y = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : It(+d), h) : i;
  }, h.context = function(d) {
    return arguments.length ? (o = d ?? null, h) : o;
  }, h;
}
function Yx(e, t, n, r, i) {
  e.moveTo(t, n), e.bezierCurveTo(t = (t + r) / 2, n, t, i, r, i);
}
function Xx() {
  return Gx(Yx);
}
const qx = {
  draw: function(e, t) {
    var n = Math.sqrt(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
};
function ea() {
}
function mc(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function Kc(e) {
  this._context = e;
}
Kc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        mc(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        mc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function Zx(e) {
  return new Kc(e);
}
function zy(e) {
  this._context = e;
}
zy.prototype = {
  areaStart: ea,
  areaEnd: ea,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        mc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function Qx(e) {
  return new zy(e);
}
function $y(e) {
  this._context = e;
}
$y.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      default:
        mc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function Jx(e) {
  return new $y(e);
}
function Hy(e, t) {
  this._basis = new Kc(e), this._beta = t;
}
Hy.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var r = e[0], i = t[0], o = e[n] - r, h = t[n] - i, d = -1, c; ++d <= n; )
        c = d / n, this._basis.point(
          this._beta * e[d] + (1 - this._beta) * (r + c * o),
          this._beta * t[d] + (1 - this._beta) * (i + c * h)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const e0 = function e(t) {
  function n(r) {
    return t === 1 ? new Kc(r) : new Hy(r, t);
  }
  return n.beta = function(r) {
    return e(+r);
  }, n;
}(0.85);
function yc(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function bf(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
bf.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        yc(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        yc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const t0 = function e(t) {
  function n(r) {
    return new bf(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function xf(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
xf.prototype = {
  areaStart: ea,
  areaEnd: ea,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        yc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const n0 = function e(t) {
  function n(r) {
    return new xf(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function Sf(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Sf.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        yc(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const r0 = function e(t) {
  function n(r) {
    return new Sf(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function wf(e, t, n) {
  var r = e._x1, i = e._y1, o = e._x2, h = e._y2;
  if (e._l01_a > tr) {
    var d = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, c = 3 * e._l01_a * (e._l01_a + e._l12_a);
    r = (r * d - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / c, i = (i * d - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / c;
  }
  if (e._l23_a > tr) {
    var p = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, y = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * p + e._x1 * e._l23_2a - t * e._l12_2a) / y, h = (h * p + e._y1 * e._l23_2a - n * e._l12_2a) / y;
  }
  e._context.bezierCurveTo(r, i, o, h, e._x2, e._y2);
}
function Vy(e, t) {
  this._context = e, this._alpha = t;
}
Vy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        wf(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const i0 = function e(t) {
  function n(r) {
    return t ? new Vy(r, t) : new bf(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Wy(e, t) {
  this._context = e, this._alpha = t;
}
Wy.prototype = {
  areaStart: ea,
  areaEnd: ea,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        wf(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const a0 = function e(t) {
  function n(r) {
    return t ? new Wy(r, t) : new xf(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function jy(e, t) {
  this._context = e, this._alpha = t;
}
jy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        wf(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const o0 = function e(t) {
  function n(r) {
    return t ? new jy(r, t) : new Sf(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Uy(e) {
  this._context = e;
}
Uy.prototype = {
  areaStart: ea,
  areaEnd: ea,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function Ph(e) {
  return new Uy(e);
}
function Vp(e) {
  return e < 0 ? -1 : 1;
}
function Wp(e, t, n) {
  var r = e._x1 - e._x0, i = t - e._x1, o = (e._y1 - e._y0) / (r || i < 0 && -0), h = (n - e._y1) / (i || r < 0 && -0), d = (o * i + h * r) / (r + i);
  return (Vp(o) + Vp(h)) * Math.min(Math.abs(o), Math.abs(h), 0.5 * Math.abs(d)) || 0;
}
function jp(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function nh(e, t, n) {
  var r = e._x0, i = e._y0, o = e._x1, h = e._y1, d = (o - r) / 3;
  e._context.bezierCurveTo(r + d, i + d * t, o - d, h - d * n, o, h);
}
function gc(e) {
  this._context = e;
}
gc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        nh(this, this._t0, jp(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, nh(this, jp(this, n = Wp(this, e, t)), n);
          break;
        default:
          nh(this, this._t0, n = Wp(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function Ky(e) {
  this._context = new Gy(e);
}
(Ky.prototype = Object.create(gc.prototype)).point = function(e, t) {
  gc.prototype.point.call(this, t, e);
};
function Gy(e) {
  this._context = e;
}
Gy.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, i, o) {
    this._context.bezierCurveTo(t, e, r, n, o, i);
  }
};
function ec(e) {
  return new gc(e);
}
function s0(e) {
  return new Ky(e);
}
function Yy(e) {
  this._context = e;
}
Yy.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = Up(e), i = Up(t), o = 0, h = 1; h < n; ++o, ++h)
          this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], e[h], t[h]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Up(e) {
  var t, n = e.length - 1, r, i = new Array(n), o = new Array(n), h = new Array(n);
  for (i[0] = 0, o[0] = 2, h[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    i[t] = 1, o[t] = 4, h[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, o[n - 1] = 7, h[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    r = i[t] / o[t - 1], o[t] -= r, h[t] -= r * h[t - 1];
  for (i[n - 1] = h[n - 1] / o[n - 1], t = n - 2; t >= 0; --t)
    i[t] = (h[t] - i[t + 1]) / o[t];
  for (o[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)
    o[t] = 2 * e[t + 1] - i[t + 1];
  return [i, o];
}
function l0(e) {
  return new Yy(e);
}
function Gc(e, t) {
  this._context = e, this._t = t;
}
Gc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function u0(e) {
  return new Gc(e, 0.5);
}
function c0(e) {
  return new Gc(e, 0);
}
function d0(e) {
  return new Gc(e, 1);
}
function ls(e, t) {
  if ((h = e.length) > 1)
    for (var n = 1, r, i, o = e[t[0]], h, d = o.length; n < h; ++n)
      for (i = o, o = e[t[n]], r = 0; r < d; ++r)
        o[r][1] += o[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1];
}
function us(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; )
    n[t] = t;
  return n;
}
function h0(e, t) {
  return e[t];
}
function kf() {
  var e = It([]), t = us, n = ls, r = h0;
  function i(o) {
    var h = e.apply(this, arguments), d, c = o.length, p = h.length, y = new Array(p), g;
    for (d = 0; d < p; ++d) {
      for (var b = h[d], T = y[d] = new Array(c), m = 0, C; m < c; ++m)
        T[m] = C = [0, +r(o[m], b, m, o)], C.data = o[m];
      T.key = b;
    }
    for (d = 0, g = t(y); d < p; ++d)
      y[g[d]].index = d;
    return n(y, g), y;
  }
  return i.keys = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : It(_h.call(o)), i) : e;
  }, i.value = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : It(+o), i) : r;
  }, i.order = function(o) {
    return arguments.length ? (t = o == null ? us : typeof o == "function" ? o : It(_h.call(o)), i) : t;
  }, i.offset = function(o) {
    return arguments.length ? (n = o ?? ls, i) : n;
  }, i;
}
function f0(e, t) {
  if ((r = e.length) > 0) {
    for (var n, r, i = 0, o = e[0].length, h; i < o; ++i) {
      for (h = n = 0; n < r; ++n)
        h += e[n][i][1] || 0;
      if (h)
        for (n = 0; n < r; ++n)
          e[n][i][1] /= h;
    }
    ls(e, t);
  }
}
function p0(e, t) {
  if ((c = e.length) > 0)
    for (var n, r = 0, i, o, h, d, c, p = e[t[0]].length; r < p; ++r)
      for (h = d = 0, n = 0; n < c; ++n)
        (o = (i = e[t[n]][r])[1] - i[0]) > 0 ? (i[0] = h, i[1] = h += o) : o < 0 ? (i[1] = d, i[0] = d += o) : (i[0] = 0, i[1] = o);
}
function m0(e, t) {
  if ((i = e.length) > 0) {
    for (var n = 0, r = e[t[0]], i, o = r.length; n < o; ++n) {
      for (var h = 0, d = 0; h < i; ++h)
        d += e[h][n][1] || 0;
      r[n][1] += r[n][0] = -d / 2;
    }
    ls(e, t);
  }
}
function y0(e, t) {
  if (!(!((h = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var n = 0, r = 1, i, o, h; r < o; ++r) {
      for (var d = 0, c = 0, p = 0; d < h; ++d) {
        for (var y = e[t[d]], g = y[r][1] || 0, b = y[r - 1][1] || 0, T = (g - b) / 2, m = 0; m < d; ++m) {
          var C = e[t[m]], w = C[r][1] || 0, S = C[r - 1][1] || 0;
          T += w - S;
        }
        c += g, p += T * g;
      }
      i[r - 1][1] += i[r - 1][0] = n, c && (n -= p / c);
    }
    i[r - 1][1] += i[r - 1][0] = n, ls(e, t);
  }
}
function g0(e) {
  var t = e.map(v0);
  return us(e).sort(function(n, r) {
    return t[n] - t[r];
  });
}
function v0(e) {
  for (var t = -1, n = 0, r = e.length, i, o = -1 / 0; ++t < r; )
    (i = +e[t][1]) > o && (o = i, n = t);
  return n;
}
function Xy(e) {
  var t = e.map(qy);
  return us(e).sort(function(n, r) {
    return t[n] - t[r];
  });
}
function qy(e) {
  for (var t = 0, n = -1, r = e.length, i; ++n < r; )
    (i = +e[n][1]) && (t += i);
  return t;
}
function b0(e) {
  return Xy(e).reverse();
}
function x0(e) {
  var t = e.length, n, r, i = e.map(qy), o = g0(e), h = 0, d = 0, c = [], p = [];
  for (n = 0; n < t; ++n)
    r = o[n], h < d ? (h += i[r], c.push(r)) : (d += i[r], p.push(r));
  return p.reverse().concat(c);
}
function S0(e) {
  return us(e).reverse();
}
function mn(e, t) {
  e(t);
}
var Kp = {
  ascending: Xy,
  descending: b0,
  insideout: x0,
  none: us,
  reverse: S0
};
function Tf(e) {
  return e && Kp[e] || Kp.none;
}
var Gp = {
  expand: f0,
  diverging: p0,
  none: ls,
  silhouette: m0,
  wiggle: y0
};
function Cf(e) {
  return e && Gp[e] || Gp.none;
}
function w0(e) {
  var t = e === void 0 ? {} : e, n = t.innerRadius, r = t.outerRadius, i = t.cornerRadius, o = t.startAngle, h = t.endAngle, d = t.padAngle, c = t.padRadius, p = $x();
  return n != null && mn(p.innerRadius, n), r != null && mn(p.outerRadius, r), i != null && mn(p.cornerRadius, i), o != null && mn(p.startAngle, o), h != null && mn(p.endAngle, h), d != null && mn(p.padAngle, d), c != null && mn(p.padRadius, c), p;
}
function Af(e) {
  var t = e === void 0 ? {} : e, n = t.x, r = t.x0, i = t.x1, o = t.y, h = t.y0, d = t.y1, c = t.defined, p = t.curve, y = Hx();
  return n && mn(y.x, n), r && mn(y.x0, r), i && mn(y.x1, i), o && mn(y.y, o), h && mn(y.y0, h), d && mn(y.y1, d), c && y.defined(c), p && y.curve(p), y;
}
function Zy(e) {
  var t = e === void 0 ? {} : e, n = t.x, r = t.y, i = t.defined, o = t.curve, h = By();
  return n && mn(h.x, n), r && mn(h.y, r), i && h.defined(i), o && h.curve(o), h;
}
function k0(e) {
  var t = e === void 0 ? {} : e, n = t.startAngle, r = t.endAngle, i = t.padAngle, o = t.value, h = t.sort, d = t.sortValues, c = jx();
  return (h === null || h != null) && c.sort(h), (d === null || d != null) && c.sortValues(d), o != null && c.value(o), i != null && mn(c.padAngle, i), n != null && mn(c.startAngle, n), r != null && mn(c.endAngle, r), c;
}
function T0(e) {
  var t = e.keys, n = e.value, r = e.order, i = e.offset, o = kf();
  return t && o.keys(t), n && mn(o.value, n), r && o.order(Tf(r)), i && o.offset(Cf(i)), o;
}
var C0 = ["className", "top", "left", "data", "centroid", "innerRadius", "outerRadius", "cornerRadius", "startAngle", "endAngle", "padAngle", "padRadius", "pieSort", "pieSortValues", "pieValue", "children", "fill"];
function Nh() {
  return Nh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Nh.apply(this, arguments);
}
function A0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function L0(e) {
  var t = e.className, n = e.top, r = e.left, i = e.data, o = i === void 0 ? [] : i, h = e.centroid, d = e.innerRadius, c = d === void 0 ? 0 : d, p = e.outerRadius, y = e.cornerRadius, g = e.startAngle, b = e.endAngle, T = e.padAngle, m = e.padRadius, C = e.pieSort, w = e.pieSortValues, S = e.pieValue, B = e.children, M = e.fill, D = M === void 0 ? "" : M, O = A0(e, C0), L = w0({
    innerRadius: c,
    outerRadius: p,
    cornerRadius: y,
    padRadius: m
  }), U = k0({
    startAngle: g,
    endAngle: b,
    padAngle: T,
    value: S,
    sort: C,
    sortValues: w
  }), X = U(o);
  return B ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, B({
    arcs: X,
    path: L,
    pie: U
  })) : /* @__PURE__ */ Ie.createElement(qe, {
    className: "visx-pie-arcs-group",
    top: n,
    left: r
  }, X.map(function(ne, G) {
    return /* @__PURE__ */ Ie.createElement("g", {
      key: "pie-arc-" + G
    }, /* @__PURE__ */ Ie.createElement("path", Nh({
      className: Sn("visx-pie-arc", t),
      d: L(ne) || "",
      fill: D == null || typeof D == "string" ? D : D(ne)
    }, O)), h == null ? void 0 : h(L.centroid(ne), ne));
  }));
}
var E0 = ["from", "to", "fill", "className", "innerRef"];
function Rh() {
  return Rh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Rh.apply(this, arguments);
}
function _0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function an(e) {
  var t = e.from, n = t === void 0 ? {
    x: 0,
    y: 0
  } : t, r = e.to, i = r === void 0 ? {
    x: 1,
    y: 1
  } : r, o = e.fill, h = o === void 0 ? "transparent" : o, d = e.className, c = e.innerRef, p = _0(e, E0), y = n.x === i.x || n.y === i.y;
  return /* @__PURE__ */ Ie.createElement("line", Rh({
    ref: c,
    className: Sn("visx-line", d),
    x1: n.x,
    y1: n.y,
    x2: i.x,
    y2: i.y,
    fill: h,
    shapeRendering: y ? "crispEdges" : "auto"
  }, p));
}
var P0 = ["children", "data", "x", "y", "fill", "className", "curve", "innerRef", "defined"];
function Dh() {
  return Dh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Dh.apply(this, arguments);
}
function N0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Gr(e) {
  var t = e.children, n = e.data, r = n === void 0 ? [] : n, i = e.x, o = e.y, h = e.fill, d = h === void 0 ? "transparent" : h, c = e.className, p = e.curve, y = e.innerRef, g = e.defined, b = g === void 0 ? function() {
    return !0;
  } : g, T = N0(e, P0), m = Zy({
    x: i,
    y: o,
    defined: b,
    curve: p
  });
  return t ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, t({
    path: m
  })) : /* @__PURE__ */ Ie.createElement("path", Dh({
    ref: y,
    className: Sn("visx-linepath", c),
    d: m(r) || "",
    fill: d,
    strokeLinecap: "round"
  }, T));
}
var R0 = ["children", "x", "x0", "x1", "y", "y0", "y1", "data", "defined", "className", "curve", "innerRef"];
function Oh() {
  return Oh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Oh.apply(this, arguments);
}
function D0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function O0(e) {
  var t = e.children, n = e.x, r = e.x0, i = e.x1, o = e.y, h = e.y0, d = e.y1, c = e.data, p = c === void 0 ? [] : c, y = e.defined, g = y === void 0 ? function() {
    return !0;
  } : y, b = e.className, T = e.curve, m = e.innerRef, C = D0(e, R0), w = Af({
    x: n,
    x0: r,
    x1: i,
    y: o,
    y0: h,
    y1: d,
    defined: g,
    curve: T
  });
  return t ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, t({
    path: w
  })) : /* @__PURE__ */ Ie.createElement("path", Oh({
    ref: m,
    className: Sn("visx-area", b),
    d: w(p) || ""
  }, C));
}
var M0 = ["x", "x0", "x1", "y", "y1", "y0", "yScale", "data", "defined", "className", "curve", "innerRef", "children"];
function Mh() {
  return Mh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Mh.apply(this, arguments);
}
function I0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Ih(e) {
  var t = e.x, n = e.x0, r = e.x1, i = e.y, o = e.y1, h = e.y0, d = e.yScale, c = e.data, p = c === void 0 ? [] : c, y = e.defined, g = y === void 0 ? function() {
    return !0;
  } : y, b = e.className, T = e.curve, m = e.innerRef, C = e.children, w = I0(e, M0), S = Af({
    x: t,
    x0: n,
    x1: r,
    defined: g,
    curve: T
  });
  return h == null ? S.y0(d.range()[0]) : mn(S.y0, h), i && !o && mn(S.y1, i), o && !i && mn(S.y1, o), C ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, C({
    path: S
  })) : /* @__PURE__ */ Ie.createElement("path", Mh({
    ref: m,
    className: Sn("visx-area-closed", b),
    d: S(p) || ""
  }, w));
}
var F0 = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function Fh() {
  return Fh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Fh.apply(this, arguments);
}
function B0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function z0(e) {
  var t = e.className, n = e.top, r = e.left, i = e.keys, o = e.data, h = e.curve, d = e.defined, c = e.x, p = e.x0, y = e.x1, g = e.y0, b = e.y1, T = e.value, m = e.order, C = e.offset, w = e.color, S = e.children, B = B0(e, F0), M = T0({
    keys: i,
    value: T,
    order: m,
    offset: C
  }), D = Af({
    x: c,
    x0: p,
    x1: y,
    y0: g,
    y1: b,
    curve: h,
    defined: d
  }), O = M(o);
  return S ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, S({
    stacks: O,
    path: D,
    stack: M
  })) : /* @__PURE__ */ Ie.createElement(qe, {
    top: n,
    left: r
  }, O.map(function(L, U) {
    return /* @__PURE__ */ Ie.createElement("path", Fh({
      className: Sn("visx-stack", t),
      key: "stack-" + U + "-" + (L.key || ""),
      d: D(L) || "",
      fill: w == null ? void 0 : w(L.key, U)
    }, B));
  }));
}
var $0 = ["className", "top", "left", "keys", "data", "curve", "defined", "x", "x0", "x1", "y0", "y1", "value", "order", "offset", "color", "children"];
function vc() {
  return vc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, vc.apply(this, arguments);
}
function H0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function V0(e) {
  var t = e.className, n = e.top, r = e.left, i = e.keys, o = e.data, h = e.curve, d = e.defined, c = e.x, p = e.x0, y = e.x1, g = e.y0, b = e.y1, T = e.value, m = e.order, C = e.offset, w = e.color, S = e.children, B = H0(e, $0);
  return /* @__PURE__ */ Ie.createElement(z0, vc({
    className: t,
    top: n,
    left: r,
    keys: i,
    data: o,
    curve: h,
    defined: d,
    x: c,
    x0: p,
    x1: y,
    y0: g,
    y1: b,
    value: T,
    order: m,
    offset: C,
    color: w
  }, B), S || function(M) {
    var D = M.stacks, O = M.path;
    return D.map(function(L, U) {
      return /* @__PURE__ */ Ie.createElement("path", vc({
        className: Sn("visx-area-stack", t),
        key: "area-stack-" + U + "-" + (L.key || ""),
        d: O(L) || "",
        fill: w == null ? void 0 : w(L.key, U)
      }, B));
    });
  });
}
function Lf(e) {
  if ("bandwidth" in e)
    return e.bandwidth();
  var t = e.range(), n = e.domain();
  return Math.abs(t[t.length - 1] - t[0]) / n.length;
}
var W0 = ["data", "className", "top", "left", "x0", "x0Scale", "x1Scale", "yScale", "color", "keys", "height", "children"];
function Bh() {
  return Bh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Bh.apply(this, arguments);
}
function j0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Qy(e) {
  var t = e.data, n = e.className, r = e.top, i = e.left, o = e.x0, h = e.x0Scale, d = e.x1Scale, c = e.yScale, p = e.color, y = e.keys, g = e.height, b = e.children, T = j0(e, W0), m = Lf(d), C = t.map(function(w, S) {
    return {
      index: S,
      x0: h(o(w)),
      bars: y.map(function(B, M) {
        var D = w[B];
        return {
          index: M,
          key: B,
          value: D,
          width: m,
          x: d(B) || 0,
          y: c(D) || 0,
          color: p(B, M),
          height: g - (c(D) || 0)
        };
      })
    };
  });
  return b ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, b(C)) : /* @__PURE__ */ Ie.createElement(qe, {
    className: Sn("visx-bar-group", n),
    top: r,
    left: i
  }, C.map(function(w) {
    return /* @__PURE__ */ Ie.createElement(qe, {
      key: "bar-group-" + w.index + "-" + w.x0,
      left: w.x0
    }, w.bars.map(function(S) {
      return /* @__PURE__ */ Ie.createElement(Pr, Bh({
        key: "bar-group-bar-" + w.index + "-" + S.index + "-" + S.value + "-" + S.key,
        x: S.x,
        y: S.y,
        width: S.width,
        height: S.height,
        fill: S.color
      }, T));
    }));
  }));
}
function Jy(e) {
  return e == null ? void 0 : e[0];
}
function eg(e) {
  return e == null ? void 0 : e[1];
}
var U0 = ["data", "className", "top", "left", "x", "y0", "y1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function zh() {
  return zh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, zh.apply(this, arguments);
}
function K0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function tg(e) {
  var t = e.data, n = e.className, r = e.top, i = e.left, o = e.x, h = e.y0, d = h === void 0 ? Jy : h, c = e.y1, p = c === void 0 ? eg : c, y = e.xScale, g = e.yScale, b = e.color, T = e.keys, m = e.value, C = e.order, w = e.offset, S = e.children, B = K0(e, U0), M = kf();
  T && M.keys(T), m && mn(M.value, m), C && M.order(Tf(C)), w && M.offset(Cf(w));
  var D = M(t), O = Lf(y), L = D.map(function(U, X) {
    var ne = U.key;
    return {
      index: X,
      key: ne,
      bars: U.map(function(G, ce) {
        var q = (g(d(G)) || 0) - (g(p(G)) || 0), re = g(p(G)), $ = "bandwidth" in y ? y(o(G.data)) : Math.max((y(o(G.data)) || 0) - O / 2);
        return {
          bar: G,
          key: ne,
          index: ce,
          height: q,
          width: O,
          x: $ || 0,
          y: re || 0,
          color: b(U.key, ce)
        };
      })
    };
  });
  return S ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, S(L)) : /* @__PURE__ */ Ie.createElement(qe, {
    className: Sn("visx-bar-stack", n),
    top: r,
    left: i
  }, L.map(function(U) {
    return U.bars.map(function(X) {
      return /* @__PURE__ */ Ie.createElement(Pr, zh({
        key: "bar-stack-" + U.index + "-" + X.index,
        x: X.x,
        y: X.y,
        height: X.height,
        width: X.width,
        fill: X.color
      }, B));
    });
  }));
}
var G0 = ["data", "className", "top", "left", "y", "x0", "x1", "xScale", "yScale", "color", "keys", "value", "order", "offset", "children"];
function $h() {
  return $h = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, $h.apply(this, arguments);
}
function Y0(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function X0(e) {
  var t = e.data, n = e.className, r = e.top, i = e.left, o = e.y, h = e.x0, d = h === void 0 ? Jy : h, c = e.x1, p = c === void 0 ? eg : c, y = e.xScale, g = e.yScale, b = e.color, T = e.keys, m = e.value, C = e.order, w = e.offset, S = e.children, B = Y0(e, G0), M = kf();
  T && M.keys(T), m && mn(M.value, m), C && M.order(Tf(C)), w && M.offset(Cf(w));
  var D = M(t), O = Lf(g), L = D.map(function(U, X) {
    var ne = U.key;
    return {
      index: X,
      key: ne,
      bars: U.map(function(G, ce) {
        var q = (y(p(G)) || 0) - (y(d(G)) || 0), re = y(d(G)), $ = "bandwidth" in g ? g(o(G.data)) : Math.max((g(o(G.data)) || 0) - q / 2);
        return {
          bar: G,
          key: ne,
          index: ce,
          height: O,
          width: q,
          x: re || 0,
          y: $ || 0,
          color: b(U.key, ce)
        };
      })
    };
  });
  return S ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, S(L)) : /* @__PURE__ */ Ie.createElement(qe, {
    className: Sn("visx-bar-stack-horizontal", n),
    top: r,
    left: i
  }, L.map(function(U) {
    return U.bars.map(function(X) {
      return /* @__PURE__ */ Ie.createElement(Pr, $h({
        key: "bar-stack-" + U.index + "-" + X.index,
        x: X.x,
        y: X.y,
        height: X.height,
        width: X.width,
        fill: X.color
      }, B));
    });
  }));
}
var Yp = "http://www.w3.org/2000/svg";
function q0(e) {
  var t = document.getElementById(e);
  if (!t) {
    var n = document.createElementNS(Yp, "svg");
    n.setAttribute("aria-hidden", "true"), n.style.opacity = "0", n.style.width = "0", n.style.height = "0", n.style.position = "absolute", n.style.top = "-100%", n.style.left = "-100%", n.style.pointerEvents = "none", t = document.createElementNS(Yp, "path"), t.setAttribute("id", e), n.appendChild(t), document.body.appendChild(n);
  }
  return t;
}
var Z0 = "__visx_splitpath_svg_path_measurement_id", Xp = function() {
  return !0;
};
function Q0(e) {
  var t = e.path, n = e.pointsInSegments, r = e.segmentation, i = r === void 0 ? "x" : r, o = e.sampleRate, h = o === void 0 ? 1 : o;
  try {
    var d = q0(Z0);
    d.setAttribute("d", t);
    var c = d.getTotalLength(), p = n.length, y = n.map(function() {
      return [];
    });
    if (i === "x" || i === "y")
      for (var g = n.map(function(re) {
        var $;
        return ($ = re.find(function(j) {
          return typeof j[i] == "number";
        })) == null ? void 0 : $[i];
      }), b = d.getPointAtLength(0), T = d.getPointAtLength(c), m = T[i] > b[i], C = m ? g.map(function(re) {
        return typeof re > "u" ? Xp : function($) {
          return $ >= re;
        };
      }) : g.map(function(re) {
        return typeof re > "u" ? Xp : function($) {
          return $ <= re;
        };
      }), w = 0, S = 0; S <= c; S += h) {
        for (var B = d.getPointAtLength(S), M = B[i]; w < p - 1 && C[w + 1](M); )
          w += 1;
        y[w].push(B);
      }
    else {
      var D = n.map(function(re) {
        return re.length;
      }), O = D.reduce(function(re, $) {
        return re + $;
      }, 0), L = c / Math.max(1, O - 1), U = D.slice(0, p - 1);
      U.unshift(0);
      for (var X = 2; X < p; X += 1)
        U[X] += U[X - 1];
      for (var ne = 0; ne < p; ne += 1)
        U[ne] *= L;
      for (var G = 0, ce = 0; ce <= c; ce += h) {
        for (var q = d.getPointAtLength(ce); G < p - 1 && ce >= U[G + 1]; )
          G += 1;
        y[G].push(q);
      }
    }
    return y;
  } catch {
    return [];
  }
}
function Hh() {
  return Hh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Hh.apply(this, arguments);
}
var J0 = function(t) {
  return t.x || 0;
}, eS = function(t) {
  return t.y || 0;
};
function ng(e) {
  var t = e.children, n = e.className, r = e.curve, i = e.defined, o = e.segmentation, h = e.sampleRate, d = e.segments, c = e.x, p = e.y, y = e.styles, g = fe.useMemo(function() {
    var m = typeof c == "number" || typeof c > "u" ? function() {
      return c;
    } : c, C = typeof p == "number" || typeof p > "u" ? function() {
      return p;
    } : p;
    return d.map(function(w) {
      return w.map(function(S, B) {
        return {
          x: m(S, B, w),
          y: C(S, B, w)
        };
      });
    });
  }, [c, p, d]), b = fe.useMemo(function() {
    var m = Zy({
      x: c,
      y: p,
      defined: i,
      curve: r
    });
    return m(d.flat()) || "";
  }, [c, p, i, r, d]), T = fe.useMemo(function() {
    return Q0({
      path: b,
      segmentation: o,
      pointsInSegments: g,
      sampleRate: h
    });
  }, [b, o, g, h]);
  return /* @__PURE__ */ Ie.createElement("g", null, T.map(function(m, C) {
    return t ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, {
      key: C
    }, t({
      index: C,
      segment: m,
      styles: y[C] || y[C % y.length]
    })) : /* @__PURE__ */ Ie.createElement(Gr, Hh({
      key: C,
      className: n,
      data: m,
      x: J0,
      y: eS
    }, y[C] || y[C % y.length]));
  }));
}
ng.propTypes = {
  segments: Re.arrayOf(Re.array).isRequired,
  styles: Re.array.isRequired,
  children: Re.func,
  className: Re.string
};
var tS = ["tooltipOpen"];
function nS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function bc() {
  return bc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, bc.apply(this, arguments);
}
function rg(e) {
  var t = fe.useState(bc({
    tooltipOpen: !1
  }, e)), n = t[0], r = t[1], i = fe.useCallback(function(h) {
    return r(typeof h == "function" ? function(d) {
      d.tooltipOpen;
      var c = nS(d, tS);
      return bc({}, h(c), {
        tooltipOpen: !0
      });
    } : {
      tooltipOpen: !0,
      tooltipLeft: h.tooltipLeft,
      tooltipTop: h.tooltipTop,
      tooltipData: h.tooltipData
    });
  }, [r]), o = fe.useCallback(function() {
    return r({
      tooltipOpen: !1,
      tooltipLeft: void 0,
      tooltipTop: void 0,
      tooltipData: void 0
    });
  }, [r]);
  return {
    tooltipOpen: n.tooltipOpen,
    tooltipLeft: n.tooltipLeft,
    tooltipTop: n.tooltipTop,
    tooltipData: n.tooltipData,
    updateTooltip: r,
    showTooltip: i,
    hideTooltip: o
  };
}
var rS = ["className", "top", "left", "offsetLeft", "offsetTop", "style", "children", "unstyled", "applyPositionStyle"];
function xc() {
  return xc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, xc.apply(this, arguments);
}
function iS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var ig = {
  position: "absolute",
  backgroundColor: "white",
  color: "#666666",
  padding: ".3rem .5rem",
  borderRadius: "3px",
  fontSize: "14px",
  boxShadow: "0 1px 2px rgba(33,33,33,0.2)",
  lineHeight: "1em",
  pointerEvents: "none"
}, Ef = /* @__PURE__ */ Ie.forwardRef(function(e, t) {
  var n = e.className, r = e.top, i = e.left, o = e.offsetLeft, h = o === void 0 ? 10 : o, d = e.offsetTop, c = d === void 0 ? 10 : d, p = e.style, y = p === void 0 ? ig : p, g = e.children, b = e.unstyled, T = b === void 0 ? !1 : b, m = e.applyPositionStyle, C = m === void 0 ? !1 : m, w = iS(e, rS);
  return /* @__PURE__ */ Ie.createElement("div", xc({
    ref: t,
    className: Sn("visx-tooltip", n),
    style: xc({
      top: r == null || c == null ? r : r + c,
      left: i == null || h == null ? i : i + h
    }, C && {
      position: "absolute"
    }, !T && y)
  }, w), g);
});
Ef.propTypes = {
  children: Re.node,
  className: Re.string,
  left: Re.number,
  offsetLeft: Re.number,
  offsetTop: Re.number,
  top: Re.number,
  applyPositionStyle: Re.bool,
  unstyled: Re.bool
};
Ef.displayName = "Tooltip";
const aS = Ef;
function Vh() {
  return Vh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Vh.apply(this, arguments);
}
function oS(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function sS(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Wh(e, t);
}
function Wh(e, t) {
  return Wh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, Wh(e, t);
}
var qp = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0
};
function lS(e) {
  var t;
  return t = /* @__PURE__ */ function(n) {
    sS(r, n);
    function r(o) {
      var h;
      return h = n.call(this, o) || this, h.state = {
        rect: void 0,
        parentRect: void 0
      }, h.nodeRef = /* @__PURE__ */ Ie.createRef(), h.getRects = h.getRects.bind(oS(h)), h;
    }
    var i = r.prototype;
    return i.componentDidMount = function() {
      var h, d = this;
      this.node = (h = this.nodeRef) != null && h.current ? this.nodeRef.current : fv.findDOMNode(this), this.setState(function() {
        return d.getRects();
      });
    }, i.getRects = function() {
      if (!this.node)
        return this.state;
      var h = this.node, d = h.parentNode, c = h.getBoundingClientRect ? h.getBoundingClientRect() : qp, p = d != null && d.getBoundingClientRect ? d.getBoundingClientRect() : qp;
      return {
        rect: c,
        parentRect: p
      };
    }, i.render = function() {
      return /* @__PURE__ */ Ie.createElement(e, Vh({
        nodeRef: this.nodeRef,
        getRects: this.getRects
      }, this.state, this.props));
    }, r;
  }(Ie.PureComponent), t.displayName = "withBoundingRects(" + (e.displayName || "") + ")", t;
}
var ag = /* @__PURE__ */ fe.createContext({
  isFlippedVertically: !1,
  isFlippedHorizontally: !1
}), uS = ag.Provider;
ag.Consumer;
var cS = ["children", "getRects", "left", "offsetLeft", "offsetTop", "parentRect", "rect", "style", "top", "unstyled", "nodeRef"];
function Sc() {
  return Sc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Sc.apply(this, arguments);
}
function dS(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function og(e) {
  var t = e.children;
  e.getRects;
  var n = e.left, r = n === void 0 ? 0 : n, i = e.offsetLeft, o = i === void 0 ? 10 : i, h = e.offsetTop, d = h === void 0 ? 10 : h, c = e.parentRect, p = e.rect, y = e.style, g = y === void 0 ? ig : y, b = e.top, T = b === void 0 ? 0 : b, m = e.unstyled, C = m === void 0 ? !1 : m, w = e.nodeRef, S = dS(e, cS), B, M = !1, D = !1;
  if (p && c) {
    var O = r, L = T;
    if (c.width) {
      var U = O + o + p.width - c.width, X = p.width - O - o;
      M = U > 0 && U > X;
    } else {
      var ne = O + o + p.width - window.innerWidth, G = p.width - O - o;
      M = ne > 0 && ne > G;
    }
    if (c.height) {
      var ce = L + d + p.height - c.height, q = p.height - L - d;
      D = ce > 0 && ce > q;
    } else
      D = L + d + p.height > window.innerHeight;
    O = M ? O - p.width - o : O + o, L = D ? L - p.height - d : L + d, O = Math.round(O), L = Math.round(L), B = "translate(" + O + "px, " + L + "px)";
  }
  return /* @__PURE__ */ Ie.createElement(aS, Sc({
    ref: w,
    style: Sc({
      left: 0,
      top: 0,
      transform: B
    }, !C && g)
  }, S), /* @__PURE__ */ Ie.createElement(uS, {
    value: {
      isFlippedVertically: !D,
      isFlippedHorizontally: !M
    }
  }, t));
}
og.propTypes = {
  nodeRef: Re.oneOfType([Re.string, Re.func, Re.object])
};
const sg = lS(og), _f = (e, t) => {
  const n = e.orientation === "horizontal", r = e.visualizationSubType === "stacked";
  let i;
  if (r)
    i = e.barHeight;
  else {
    const c = e.runtime.seriesKeys.length;
    e.isLollipopChart ? i = ({
      large: 7,
      medium: 6,
      small: 5
    }[e.lollipopSize] || 5) * c : i = e.barHeight * c;
  }
  const o = Dc * 1.2, h = e.yAxis.labelPlacement === "Below Bar" ? o : 0, d = i + h + Number(e.barSpace);
  if (n) {
    const c = t.length * d;
    e.heights || (e.heights = {}), e.heights.horizontal = c;
  }
  return t.map((c, p) => {
    const y = c.index === 0 ? 0 : Ke.round(d * p);
    return { ...c, y, height: i };
  });
}, lg = (e) => {
  const {
    tableData: t,
    config: n,
    formatNumber: r,
    capitalize: i,
    formatDate: o,
    formatTooltipsDate: h,
    parseDate: d,
    setSharedFilter: c,
    isDraggingAnnotation: p
  } = fe.useContext(ft), { xScale: y, yScale: g, seriesScale: b, showTooltip: T, hideTooltip: m } = e, { xAxis: C, visualizationType: w, orientation: S, yAxis: B, runtime: M } = n, D = Number(n.yAxis.size || 0), O = (ae, Z) => {
    var ke;
    let ye = null, ue = null;
    const ve = n.series.find((me) => me.dynamicCategory);
    if (ve)
      ye = Z[ve.dynamicCategory], ue = Z[ve.dataKey];
    else {
      let me = 0, Ne;
      try {
        Ne = Number(g.invert(ae));
      } catch {
        return [];
      }
      for (let Ee of (ke = n.runtime) == null ? void 0 : ke.seriesKeys)
        if (Z.hasOwnProperty(Ee) && (me += Number(Z[Ee]), me >= Ne)) {
          ue = Z[Ee], ye = Ee;
          break;
        }
    }
    return [ye, ue];
  }, L = (ae, Z, ye, ue) => {
    const ve = ye.general.showMissingDataLabel && (!Z || Z === "null"), ke = ae === ye.xAxis.dataKey ? Z : r(Z, ue(ae));
    return ve ? "N/A" : ke;
  }, U = (ae, Z) => {
    var mt, yt, Ye, ot;
    if (w === "Bump Chart" || p)
      return;
    const ye = Kf(ae), { x: ue, y: ve } = ye, ke = oe([ue, ve]), me = q(ve, ke), Ne = [], Ee = [];
    for (const [ut, st] of Object.entries(n.columns)) {
      const tt = {
        addColPrefix: st.prefix,
        addColSuffix: st.suffix,
        addColRoundTo: st.roundToPlace || "",
        addColCommas: st.commas
      }, $e = (mt = Z == null ? void 0 : Z.arc) == null ? void 0 : mt.data[st.name], it = n.tooltips.singleSeries && w === "Line" ? ke.filter(
        (Ht) => Ht[n.runtime.series[0].dynamicCategory] === me
      )[0][ut] : (yt = ke[0]) == null ? void 0 : yt[ut], ht = n.visualizationType === "Pie" ? $e : it, Ce = Jh(ht, "left", !0, n, tt);
      st.tooltips && Ne.push([st.label, Ce]);
    }
    const De = [];
    if (Ne.forEach((ut) => {
      De.push([ut[0], ut[1]]);
    }), w === "Pie") {
      const ut = Number(n.dataFormat.roundTo) || 0, { endAngle: st, startAngle: tt, data: $e } = (Z == null ? void 0 : Z.arc) || {}, Ce = ((st - tt) * 180 / Math.PI / 360 * 100).toFixed(ut);
      Ee.push(
        // ignore
        [n.xAxis.dataKey, $e],
        [n.runtime.yAxis.dataKey, r($e[n.runtime.yAxis.dataKey])],
        ["Percent", `${Ce + "%"}`]
      );
    }
    if (w === "Forest Plot" && Ee.push([n.xAxis.dataKey, $(ve)]), !["Pie", "Forest Plot"].includes(w)) {
      const ut = (st) => {
        const tt = n.runtime.series.filter((it) => it.dataKey === st)[0];
        return tt != null && tt.axis ? String(tt.axis).toLowerCase() : "left";
      };
      if (!n.tooltips.singleSeries || w === "Line") {
        Ee.push(
          ...(ot = (Ye = ie()) == null ? void 0 : Ye.filter((tt) => {
            var it, ht;
            return ((it = n.runtime.series) == null ? void 0 : it.find(
              (Ce) => Ce.dataKey === tt && (Ce == null ? void 0 : Ce.tooltip) && !Ce.dynamicCategory
            )) || ((ht = n.xAxis) == null ? void 0 : ht.dataKey) == tt || w === "Forecasting";
          })) == null ? void 0 : ot.flatMap((tt) => {
            var Ce;
            const $e = (Ce = ke[0]) == null ? void 0 : Ce[tt], it = L(tt, $e, n, ut), ht = n.runtime.series.find(
              (Ht) => Ht.dataKey === tt && Ht.name !== void 0
            );
            return ($e == null || $e === "" || it === "N/A") && n.general.hideNullValue ? [] : ht && ht.name === "" ? [["", it, ut(tt)]] : [[tt, it, ut(tt)]];
          })
        );
        const st = n.tooltips.singleSeries && w === "Line" ? [Ke.find(n.runtime.series, (tt) => tt.dataKey === me)] : n.runtime.series;
        st == null || st.forEach((tt) => {
          if (tt != null && tt.dynamicCategory) {
            const $e = tt.dataKey, it = ke.find((ht) => ht[tt.dynamicCategory] === $e);
            if (it) {
              const ht = it[tt.originalDataKey], Ce = L($e, ht, n, ut);
              Ee.push([$e, Ce, ut($e)]);
            }
          }
        });
      } else {
        const st = ke[0], [tt, $e] = O(ve, st);
        if (tt && $e) {
          const it = st[n.xAxis.dataKey], ht = G(ue - D);
          Ee.push([n.xAxis.dataKey, ht || it]);
          const Ce = L(tt, $e, n, ut);
          Ee.push([tt, Ce]);
        } else
          Object.keys(st).forEach((it) => {
            Ee.push([it, st[it]]);
          });
      }
    }
    const Fe = ye.x + 10, Je = ye.y, gt = {
      tooltipLeft: Fe,
      tooltipTop: Je,
      tooltipData: {
        data: [...Ee, ...De],
        dataXPosition: Fe,
        dataYPosition: Je
      }
    };
    T(gt);
  }, X = () => {
    n.visualizationType === "Area Chart" ? setTimeout(() => {
      m();
    }, 3e3) : m();
  }, ne = (ae) => {
    if (n.xAxis.type === "categorical" || n.visualizationType === "Combo") {
      let Z = y.step();
      const ue = Math.floor(Number(ae) / Z);
      return y.domain()[ue - 1];
    }
    if (Tn(n.xAxis) && n.visualizationType !== "Combo") {
      const Z = Mm((ke) => d(ke[n.xAxis.dataKey])).left, ye = y.invert(y(ae)), ue = Z(n.data, ye, 1);
      return d(n.data[ue - 1][n.xAxis.dataKey]);
    }
  }, G = (ae, Z = !1) => {
    if (w !== "Pie" && S !== "horizontal") {
      if (y.type === "point" || C.type === "continuous" || Tn(C)) {
        let ye = null, ue = Number.MAX_VALUE, ve = ae;
        return t.forEach((ke) => {
          const me = Tn(C) ? y(d(ke[C.dataKey])) : y(ke[C.dataKey]);
          let Ne = n.barHeight;
          const Ee = Math.abs(Number(me - ve + (Z ? Ne * 2 : 0)));
          Ee <= ue && (ue = Ee, ye = (Tn(C), ke[C.dataKey]));
        }), ye;
      }
      if (n.xAxis.type === "categorical" || w === "Combo") {
        let ue = (y.range()[1] - y.range()[0]) / (y.domain().length + 1);
        const ke = Math.floor((Number(ae) - ue / 2) / ue);
        return y.domain()[ke];
      }
    }
  }, ce = (ae, Z) => {
    let ye;
    return ae.find(([ue, ve]) => {
      if (ve > Z)
        return !0;
      ye = ue;
    }), ye;
  }, q = (ae, Z) => {
    let ye = null, ue = Number.MAX_VALUE, ve = ae;
    return Z.forEach((ke) => {
      const me = g(ke[n.runtime.series[0].originalDataKey]), Ne = Math.abs(Number(me - ve));
      Ne <= ue && (ue = Ne, ye = ke[n.runtime.series[0].dynamicCategory]);
    }), ye;
  }, re = (ae) => {
    const Z = g.domain().map((me, Ne) => ({ group: me, index: Ne })), ye = _f(n, Z), ue = ce(
      ye.map((me) => [me, Ke.round(me.y)]),
      ae
    ), ve = ae - ue.y, ke = t.filter((me) => me[n.xAxis.dataKey] === ue.group);
    if (n.series.length > 1 && !n.series.find((me) => me.dynamicCategory)) {
      const me = n.series.map((Xe, Fe) => [Xe, n.barHeight * Fe]), Ne = ce(me, ve), Ee = n.series.filter((Xe) => Xe.dataKey !== Ne.dataKey).map((Xe) => Xe.dataKey);
      return Ke.omit(ke[0], Ee);
    } else {
      const me = ke.map((Ee, De) => [Ee, n.barHeight * De]);
      return ce(me, ve);
    }
  }, $ = (ae, Z = "") => {
    if (w === "Pie")
      return;
    let ye = Number.MAX_VALUE, ue = null;
    return t.forEach((ve, ke) => {
      const me = g(w !== "Forest Plot" ? ve[n.xAxis.dataKey] : ke), Ne = Math.abs(me - ae);
      Ne < ye && (ye = Ne, ue = Z ? ve[Z] : ve[n.xAxis.dataKey]);
    }), ue;
  }, j = (ae) => {
    var Z, ye;
    try {
      if (n.visualizationType === "Bump Chart")
        return;
      const ue = Kf(ae), { x: ve } = ue;
      if (!ve)
        throw new Error("COVE: no x value in handleTooltipClick.");
      let ke = G(ve, !0), me = (Z = n.data) == null ? void 0 : Z.filter((Ne) => Ne[n.xAxis.dataKey] === ke);
      if (!ke)
        throw new Error("COVE: no closest x scale value in handleTooltipClick");
      if (Tn(C) && ke && (ke = new Date(ke), ke = o(ke), me = (ye = n.data) == null ? void 0 : ye.filter((Ne) => o(new Date(Ne[n.xAxis.dataKey])) === ke)), !me[0])
        throw new Error(`COVE: no data found matching the closest xScale value: ${ke}`);
      c && (n != null && n.uid) && (me != null && me[0]) && c(n.uid, me[0]);
    } catch (ue) {
      console.error(ue.message);
    }
  }, oe = ([ae, Z]) => {
    if (S !== "vertical")
      return n.visualizationType === "Bar" && n.tooltips.singleSeries ? [re(Z)] : t.filter((Ee) => Ee[C.dataKey] === $(Z));
    const ue = n.runtime.series.filter(
      (Ee) => w === "Pie" || Ee.tooltip === !0 && !Ee.dynamicCategory
    ).map((Ee) => Ee.dataKey);
    ue.push(n.xAxis.dataKey);
    const ve = Ke.uniq(
      n.runtime.series.flatMap((Ee) => {
        if (Ee.dynamicCategory)
          return [Ee.dynamicCategory, Ee.originalDataKey];
      })
    );
    ue.push(...ve), n.visualizationType === "Forecasting" && n.runtime.series.map((Ee) => {
      Ee.confidenceIntervals.map((De) => {
        De.showInTooltip && (ue.push(De.high), ue.push(De.low));
      });
    });
    const ke = Object.values(n.columns).map((Ee) => Ee.name);
    ue.push(...ke, ...ke);
    const me = G(ae - D);
    let Ne = (t || []).filter((Ee) => Ee[C.dataKey] === me);
    if (n.tooltips.singleSeries && n.visualizationType !== "Line") {
      const Ee = n.series.find((De) => De.dynamicCategory);
      if (Ee) {
        const De = Ne.map(
          (Fe) => [Fe, b(Fe[Ee.dynamicCategory])]
        ), Xe = ae - D - y(me);
        Ne = [ce(De, Xe)];
      }
    }
    return Ne.map((Ee) => Ke.pick(Ee, ue));
  }, ie = () => {
    const ae = n.runtime.series.filter((ve) => ve.type === "Forecasting"), Z = ae.map((ve) => ve.stageColumn), ye = ae.flatMap(
      (ve) => {
        var ke;
        return (ke = ve.confidenceIntervals) == null ? void 0 : ke.filter((me) => me.showInTooltip).map((me) => [me.low, me.high]);
      }
    ), ue = [M.xAxis.dataKey, ...M == null ? void 0 : M.seriesKeys];
    switch (w) {
      case "Line":
      case "Area Chart":
      case "Pie":
        return ue;
      case "Combo":
        return [...ue, ...ye];
      case "Forecasting":
        return [M.xAxis.dataKey, ...Z, ...ye];
      case "Bar":
        return S === "vertical" ? ue : [M.yAxis.dataKey, ...M == null ? void 0 : M.seriesKeys];
      default:
        throw new Error("No visualization type found in handleTooltipMouseOver");
    }
  }, le = (ae) => {
    const { dataXPosition: Z, dataYPosition: ye } = ae;
    return {
      opacity: n.tooltips.opacity ? n.tooltips.opacity / 100 : 1,
      position: "absolute",
      backgroundColor: "white",
      borderRadius: "4px",
      transform: `translate(${Z}px, ${Number(ye)}px)`
    };
  }, J = (ae) => {
    var ye, ue;
    let Z = n.runtime.series.filter((ve) => ve.dataKey === ae);
    return (ye = Z[0]) != null && ye.name ? (ue = Z[0]) == null ? void 0 : ue.name : ae;
  };
  return {
    getIncludedTooltipSeries: ie,
    getXValueFromCoordinate: G,
    getXValueFromCoordinateDate: ne,
    handleTooltipClick: j,
    handleTooltipMouseOff: X,
    handleTooltipMouseOver: U,
    TooltipListItem: ({ item: ae }) => {
      var gt;
      const [Z, ye] = ae, [ue, ve, ke] = ye;
      if (w === "Forest Plot")
        return ue === n.xAxis.dataKey ? /* @__PURE__ */ a("li", { className: "tooltip-heading", children: `${i(n.xAxis.dataKey ? `${n.xAxis.dataKey}: ` : "")} ${Tn(B) ? o(d(ue, !1)) : ve}` }) : /* @__PURE__ */ a("li", { className: "tooltip-body", children: `${J(ue)}: ${r(ve, "left")}` });
      const me = n.tooltips.dateDisplayFormat ? h(d(ve, !1)) : o(d(ve, !1));
      if (w === "Bar" && S === "horizontal" && ue === n.xAxis.dataKey)
        return /* @__PURE__ */ a("li", { className: "tooltip-heading", children: `${i(
          n.runtime.yAxis.label ? `${n.runtime.yAxis.label}: ` : ""
        )} ${n.xAxis.type === "date" ? me : ve}` });
      if (ue === n.xAxis.dataKey)
        return /* @__PURE__ */ a("li", { className: "tooltip-heading", children: `${i(
          n.runtime.xAxis.label ? `${n.runtime.xAxis.label}: ` : ""
        )} ${Tn(C) ? me : ve}` });
      const { label: Ne, displayGray: Ee } = n.visualizationSubType !== "stacked" && n.general.showSuppressedSymbol && ((gt = n.preliminaryData) == null ? void 0 : gt.find(
        (mt) => mt.label && mt.type === "suppression" && mt.displayTooltip && ve === mt.value && (!mt.column || ue === mt.column)
      )) || {};
      let De = Ne || ve;
      const Xe = Ee ? { color: "#8b8b8a" } : {};
      Z == 1 && n.dataFormat.onlyShowTopPrefixSuffix && (De = `${n.dataFormat.prefix}${De}${n.dataFormat.suffix}`);
      const Fe = J(ue), Je = Fe ? `${Fe}: ${De}` : De;
      return /* @__PURE__ */ a("li", { style: Xe, className: "tooltip-body", children: Je });
    },
    tooltipStyles: le
  };
};
function Pf(e, { threshold: t = 0, root: n = null, rootMargin: r = "0%", freezeOnceVisible: i = !1 }) {
  const [o, h] = fe.useState(), d = (o == null ? void 0 : o.isIntersecting) && i, c = ([p]) => {
    h(p);
  };
  return fe.useEffect(() => {
    const p = e == null ? void 0 : e.current;
    if (!!!window.IntersectionObserver || d || !p)
      return;
    const g = { threshold: t, root: n, rootMargin: r }, b = new IntersectionObserver(c, g);
    return b.observe(p), () => b.disconnect();
  }, [e, t, n, r, d]), o;
}
const jh = (e, t = !1) => {
  t && console.log("handleChartAriaLabels Testing On:", e);
  try {
    if (!e.visualizationType)
      throw Error("handleChartAriaLabels: no visualization type found in state");
    let n = "";
    return e.visualizationType && (n += `${e.visualizationType} chart`), e.title && e.visualizationType && (n += ` with the title: ${e.title}`), n;
  } catch (n) {
    console.error("COVE: ", n.message);
  }
}, Zp = Symbol("implicit");
function Nf() {
  var e = new sp(), t = [], n = [], r = Zp;
  function i(o) {
    let h = e.get(o);
    if (h === void 0) {
      if (r !== Zp)
        return r;
      e.set(o, h = t.push(o) - 1);
    }
    return n[h % n.length];
  }
  return i.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new sp();
    for (const h of o)
      e.has(h) || e.set(h, t.push(h) - 1);
    return i;
  }, i.range = function(o) {
    return arguments.length ? (n = Array.from(o), i) : n.slice();
  }, i.unknown = function(o) {
    return arguments.length ? (r = o, i) : r;
  }, i.copy = function() {
    return Nf(t, n).unknown(r);
  }, Ic.apply(i, arguments), i;
}
function Rf() {
  var e = Nf().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, o, h, d = !1, c = 0, p = 0, y = 0.5;
  delete e.unknown;
  function g() {
    var b = t().length, T = i < r, m = T ? i : r, C = T ? r : i;
    o = (C - m) / Math.max(1, b - c + p * 2), d && (o = Math.floor(o)), m += (C - m - o * (b - c)) * y, h = o * (1 - c), d && (m = Math.round(m), h = Math.round(h));
    var w = Nv(b).map(function(S) {
      return m + o * S;
    });
    return n(T ? w.reverse() : w);
  }
  return e.domain = function(b) {
    return arguments.length ? (t(b), g()) : t();
  }, e.range = function(b) {
    return arguments.length ? ([r, i] = b, r = +r, i = +i, g()) : [r, i];
  }, e.rangeRound = function(b) {
    return [r, i] = b, r = +r, i = +i, d = !0, g();
  }, e.bandwidth = function() {
    return h;
  }, e.step = function() {
    return o;
  }, e.round = function(b) {
    return arguments.length ? (d = !!b, g()) : d;
  }, e.padding = function(b) {
    return arguments.length ? (c = Math.min(1, p = +b), g()) : c;
  }, e.paddingInner = function(b) {
    return arguments.length ? (c = Math.min(1, b), g()) : c;
  }, e.paddingOuter = function(b) {
    return arguments.length ? (p = +b, g()) : p;
  }, e.align = function(b) {
    return arguments.length ? (y = Math.max(0, Math.min(1, b)), g()) : y;
  }, e.copy = function() {
    return Rf(t(), [r, i]).round(d).paddingInner(c).paddingOuter(p).align(y);
  }, Ic.apply(g(), arguments);
}
function ug(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return ug(t());
  }, e;
}
function hS() {
  return ug(Rf.apply(null, arguments).paddingInner(1));
}
function cg(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, i = e[n], o = e[r], h;
  return o < i && (h = n, n = r, r = h, h = i, i = o, o = h), e[n] = t.floor(i), e[r] = t.ceil(o), e;
}
function Qp(e) {
  return Math.log(e);
}
function Jp(e) {
  return Math.exp(e);
}
function fS(e) {
  return -Math.log(-e);
}
function pS(e) {
  return -Math.exp(-e);
}
function mS(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function yS(e) {
  return e === 10 ? mS : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function gS(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function em(e) {
  return (t, n) => -e(-t, n);
}
function vS(e) {
  const t = e(Qp, Jp), n = t.domain;
  let r = 10, i, o;
  function h() {
    return i = gS(r), o = yS(r), n()[0] < 0 ? (i = em(i), o = em(o), e(fS, pS)) : e(Qp, Jp), t;
  }
  return t.base = function(d) {
    return arguments.length ? (r = +d, h()) : r;
  }, t.domain = function(d) {
    return arguments.length ? (n(d), h()) : n();
  }, t.ticks = (d) => {
    const c = n();
    let p = c[0], y = c[c.length - 1];
    const g = y < p;
    g && ([p, y] = [y, p]);
    let b = i(p), T = i(y), m, C;
    const w = d == null ? 10 : +d;
    let S = [];
    if (!(r % 1) && T - b < w) {
      if (b = Math.floor(b), T = Math.ceil(T), p > 0) {
        for (; b <= T; ++b)
          for (m = 1; m < r; ++m)
            if (C = b < 0 ? m / o(-b) : m * o(b), !(C < p)) {
              if (C > y)
                break;
              S.push(C);
            }
      } else
        for (; b <= T; ++b)
          for (m = r - 1; m >= 1; --m)
            if (C = b > 0 ? m / o(-b) : m * o(b), !(C < p)) {
              if (C > y)
                break;
              S.push(C);
            }
      S.length * 2 < w && (S = ep(p, y, w));
    } else
      S = ep(b, T, Math.min(T - b, w)).map(o);
    return g ? S.reverse() : S;
  }, t.tickFormat = (d, c) => {
    if (d == null && (d = 10), c == null && (c = r === 10 ? "s" : ","), typeof c != "function" && (!(r % 1) && (c = mv(c)).precision == null && (c.trim = !0), c = yv(c)), d === 1 / 0)
      return c;
    const p = Math.max(1, r * d / t.ticks().length);
    return (y) => {
      let g = y / o(Math.round(i(y)));
      return g * r < r - 0.5 && (g *= r), g <= p ? c(y) : "";
    };
  }, t.nice = () => n(cg(n(), {
    floor: (d) => o(Math.floor(i(d))),
    ceil: (d) => o(Math.ceil(i(d)))
  })), t;
}
function dg() {
  const e = vS(pv()).domain([1, 10]);
  return e.copy = () => Im(e, dg()).base(e.base()), Ic.apply(e, arguments), e;
}
function bS(e) {
  return new Date(e);
}
function xS(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function hg(e, t, n, r, i, o, h, d, c, p) {
  var y = gv(), g = y.invert, b = y.domain, T = p(".%L"), m = p(":%S"), C = p("%I:%M"), w = p("%I %p"), S = p("%a %d"), B = p("%b %d"), M = p("%B"), D = p("%Y");
  function O(L) {
    return (c(L) < L ? T : d(L) < L ? m : h(L) < L ? C : o(L) < L ? w : r(L) < L ? i(L) < L ? S : B : n(L) < L ? M : D)(L);
  }
  return y.invert = function(L) {
    return new Date(g(L));
  }, y.domain = function(L) {
    return arguments.length ? b(Array.from(L, xS)) : b().map(bS);
  }, y.ticks = function(L) {
    var U = b();
    return e(U[0], U[U.length - 1], L ?? 10);
  }, y.tickFormat = function(L, U) {
    return U == null ? O : p(U);
  }, y.nice = function(L) {
    var U = b();
    return (!L || typeof L.range != "function") && (L = t(U[0], U[U.length - 1], L ?? 10)), L ? b(cg(U, L)) : y;
  }, y.copy = function() {
    return Im(y, hg(e, t, n, r, i, o, h, d, c, p));
  }, y;
}
function fg() {
  return Ic.apply(hg(Dv, Ov, Vm, zm, jm, Wm, Bm, Fm, dl, qu).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var SS = Ml("domain", "range", "reverse", "align", "padding", "round");
function wc(e) {
  return SS(Rf(), e);
}
var wS = Ml("domain", "range", "reverse", "align", "padding", "round");
function ts(e) {
  return wS(hS(), e);
}
var kS = Ml("domain", "range", "reverse", "clamp", "interpolate", "nice", "round");
function TS(e) {
  return kS(fg(), e);
}
var CS = Ml("domain", "range", "reverse", "base", "clamp", "interpolate", "nice", "round");
function kc(e) {
  return CS(dg(), e);
}
var AS = Ml("domain", "range", "reverse", "unknown");
function Df(e) {
  return AS(Nf(), e);
}
function LS(e) {
  if ((typeof e == "function" || typeof e == "object" && e) && "valueOf" in e) {
    var t = e.valueOf();
    if (typeof t == "number")
      return t;
  }
  return e;
}
function pg(e, t) {
  var n = e;
  return "ticks" in n ? n.ticks(t) : n.domain().filter(function(r, i, o) {
    return t == null || o.length <= t || i % Math.round((o.length - 1) / t) === 0;
  });
}
function ES(e) {
  return e == null ? void 0 : e.toString();
}
const Hu = ({ startAngle: e, endAngle: t }) => ({
  startAngle: e,
  endAngle: t
}), _S = (e) => {
  const {
    transformedData: t,
    config: n,
    colorScale: r,
    currentViewport: i,
    seriesHighlight: o,
    isDraggingAnnotation: h
  } = fe.useContext(ft), { tooltipData: d, showTooltip: c, hideTooltip: p, tooltipOpen: y, tooltipLeft: g, tooltipTop: b } = rg(), { handleTooltipMouseOver: T, handleTooltipMouseOff: m, TooltipListItem: C } = lg({
    xScale: !1,
    yScale: !1,
    showTooltip: c,
    hideTooltip: p
  }), [w, S] = fe.useState(void 0), [B, M] = fe.useState(!1), D = Object.values(n.columns).filter((de) => de.showInViz), O = D.length > 0, L = O ? "pivotColumn" : void 0, U = fe.useMemo(() => {
    if (O) {
      let de = [];
      const ae = n.yAxis.dataKey, Z = D.map((ve) => ve.name), ye = [ae, ...Z], ue = n.xAxis.dataKey;
      return t.forEach((ve) => {
        ye.forEach((ke) => {
          const me = ve[ke];
          me && de.push({
            [L]: me,
            [ue]: `${ve[ue]} - ${ke}`
          });
        });
      }), de;
    }
    return t;
  }, [t, O]), X = fe.useMemo(() => {
    if (O) {
      const de = {};
      U.forEach((ye) => {
        de[ye[n.xAxis.dataKey]] || (de[ye[n.xAxis.dataKey]] = !0);
      });
      const ae = Object.entries(de).length;
      let Z = n.customColors || _r[n.palette];
      return Z = Z.slice(0, ae), Df({
        domain: Object.keys(de),
        range: Z,
        unknown: null
      });
    }
    return r;
  }, [r, O]), ne = fe.useRef(), G = Pf(ne, {
    freezeOnceVisible: !1
  });
  fe.useEffect(() => {
    document.querySelector(".isEditor") && M((ae) => !0);
  }), fe.useEffect(() => {
    G != null && G.isIntersecting && n.animate && !B && setTimeout(() => {
      M(!0);
    }, 500);
  }, [G == null ? void 0 : G.isIntersecting, n.animate]);
  const ce = ({ arcs: de, path: ae, getKey: Z }) => {
    const ye = vx(de, Z, {
      from: Hu,
      enter: Hu,
      update: Hu,
      leave: Hu
    });
    return fe.useEffect(() => {
      const ue = setTimeout(() => {
        p();
      }, 500);
      return () => {
        clearTimeout(ue);
      };
    }, [d]), /* @__PURE__ */ F(Be, { children: [
      ye.map(({ item: ue, props: ve, key: ke }, me) => /* @__PURE__ */ a(
        qe,
        {
          className: ue.data[n.xAxis.dataKey],
          style: {
            opacity: n.legend.behavior === "highlight" && o.length > 0 && o.indexOf(ue.data[n.runtime.xAxis.dataKey]) === -1 ? 0.5 : 1
          },
          children: /* @__PURE__ */ a(
            Hp.path,
            {
              d: wx(
                [ve.startAngle, ve.endAngle],
                (Ne, Ee) => ae({
                  ...ue,
                  startAngle: Ne,
                  endAngle: Ee
                })
              ),
              fill: X(ue.data[n.runtime.xAxis.dataKey]),
              onMouseEnter: (Ne) => T(Ne, { data: ue.data[n.runtime.xAxis.dataKey], arc: ue }),
              onMouseLeave: (Ne) => m()
            }
          )
        },
        `${ke}-${me}`
      )),
      ye.map(({ item: ue, key: ve }, ke) => {
        const me = Number(n.dataFormat.roundTo) || 0, [Ne, Ee] = ae.centroid(ue), De = ue.endAngle - ue.startAngle >= 0.1;
        let Xe = "#FFF";
        X(ue.data[n.runtime.xAxis.dataKey]) && (Xe = as(Xe, X(ue.data[n.runtime.xAxis.dataKey])));
        const gt = ((ue.endAngle - ue.startAngle) * 180 / Math.PI / 360 * 100).toFixed(me);
        return /* @__PURE__ */ a(Hp.g, { children: De && /* @__PURE__ */ a(
          dt,
          {
            style: { fill: Xe },
            x: Ne,
            y: Ee,
            dy: ".33em",
            textAnchor: "middle",
            pointerEvents: "none",
            children: gt + "%"
          }
        ) }, `${ve}${ke}`);
      })
    ] });
  };
  let q = e.parentWidth, re = e.parentWidth;
  n && n.legend && !n.legend.hide && i === "lg" && (re = Number(q) * 0.73);
  const $ = n.heights.vertical, j = Math.min(re, $) / 2, oe = $ / 2, ie = e.parentWidth / 2, le = n.pieType === "Donut" ? 75 : j;
  fe.useEffect(() => {
    if (o.length > 0 && n.legend.behavior !== "highlight") {
      let de = [];
      U.forEach((ae) => {
        o.indexOf(ae[n.runtime.xAxis.dataKey]) !== -1 && de.push(ae);
      }), S(de);
    } else
      S(void 0);
  }, [o]);
  const J = () => {
    let de = ["animated-pie", "group"];
    return (n.animate === !1 || B) && de.push("animated"), de.join(" ");
  };
  return /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F(Xr, { component: "PieChart", children: [
    /* @__PURE__ */ a(
      "svg",
      {
        width: j * 2,
        height: $,
        className: J(),
        role: "img",
        "aria-label": jh(n),
        children: /* @__PURE__ */ a(qe, { top: oe, left: j, children: /* @__PURE__ */ a(
          L0,
          {
            data: w || U,
            pieValue: (de) => de[L || n.runtime.yAxis.dataKey],
            pieSortValues: () => -1,
            innerRadius: j - le,
            outerRadius: j,
            children: (de) => /* @__PURE__ */ a(ce, { ...de, getKey: (ae) => ae.data[n.runtime.xAxis.dataKey] })
          }
        ) })
      }
    ),
    /* @__PURE__ */ a("div", { ref: ne }),
    !h && d && Object.entries(d.data).length > 0 && y && c && d.dataYPosition && d.dataXPosition && /* @__PURE__ */ F(Be, { children: [
      /* @__PURE__ */ a("style", { children: `.tooltip {background-color: rgba(255,255,255, ${n.tooltips.opacity / 100}) !important` }),
      /* @__PURE__ */ a(
        sg,
        {
          className: "tooltip cdc-open-viz-module",
          left: g + ie - j,
          top: b,
          children: /* @__PURE__ */ a("ul", { children: typeof d == "object" && Object.entries(d.data).map((de, ae) => /* @__PURE__ */ a(C, { item: de }, ae)) })
        },
        Math.random()
      )
    ] })
  ] }) });
};
function tm(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function PS(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function rh(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      (r = +r) && (n += r);
  else {
    let r = -1;
    for (let i of e)
      (i = +t(i, ++r, e)) && (n += i);
  }
  return n;
}
function NS(e) {
  return e.depth;
}
function RS(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function Vu(e) {
  return function() {
    return e;
  };
}
function nm(e, t) {
  return Tc(e.source, t.source) || e.index - t.index;
}
function rm(e, t) {
  return Tc(e.target, t.target) || e.index - t.index;
}
function Tc(e, t) {
  return e.y0 - t.y0;
}
function ih(e) {
  return e.value;
}
function DS(e) {
  return e.index;
}
function OS(e) {
  return e.nodes;
}
function MS(e) {
  return e.links;
}
function im(e, t) {
  const n = e.get(t);
  if (!n)
    throw new Error("missing: " + t);
  return n;
}
function am({ nodes: e }) {
  for (const t of e) {
    let n = t.y0, r = n;
    for (const i of t.sourceLinks)
      i.y0 = n + i.width / 2, n += i.width;
    for (const i of t.targetLinks)
      i.y1 = r + i.width / 2, r += i.width;
  }
}
function IS() {
  let e = 0, t = 0, n = 1, r = 1, i = 24, o = 8, h, d = DS, c = RS, p, y, g = OS, b = MS, T = 6;
  function m() {
    const j = { nodes: g.apply(null, arguments), links: b.apply(null, arguments) };
    return C(j), w(j), S(j), B(j), O(j), am(j), j;
  }
  m.update = function(j) {
    return am(j), j;
  }, m.nodeId = function(j) {
    return arguments.length ? (d = typeof j == "function" ? j : Vu(j), m) : d;
  }, m.nodeAlign = function(j) {
    return arguments.length ? (c = typeof j == "function" ? j : Vu(j), m) : c;
  }, m.nodeSort = function(j) {
    return arguments.length ? (p = j, m) : p;
  }, m.nodeWidth = function(j) {
    return arguments.length ? (i = +j, m) : i;
  }, m.nodePadding = function(j) {
    return arguments.length ? (o = h = +j, m) : o;
  }, m.nodes = function(j) {
    return arguments.length ? (g = typeof j == "function" ? j : Vu(j), m) : g;
  }, m.links = function(j) {
    return arguments.length ? (b = typeof j == "function" ? j : Vu(j), m) : b;
  }, m.linkSort = function(j) {
    return arguments.length ? (y = j, m) : y;
  }, m.size = function(j) {
    return arguments.length ? (e = t = 0, n = +j[0], r = +j[1], m) : [n - e, r - t];
  }, m.extent = function(j) {
    return arguments.length ? (e = +j[0][0], n = +j[1][0], t = +j[0][1], r = +j[1][1], m) : [[e, t], [n, r]];
  }, m.iterations = function(j) {
    return arguments.length ? (T = +j, m) : T;
  };
  function C({ nodes: j, links: oe }) {
    for (const [le, J] of j.entries())
      J.index = le, J.sourceLinks = [], J.targetLinks = [];
    const ie = new Map(j.map((le, J) => [d(le, J, j), le]));
    for (const [le, J] of oe.entries()) {
      J.index = le;
      let { source: de, target: ae } = J;
      typeof de != "object" && (de = J.source = im(ie, de)), typeof ae != "object" && (ae = J.target = im(ie, ae)), de.sourceLinks.push(J), ae.targetLinks.push(J);
    }
    if (y != null)
      for (const { sourceLinks: le, targetLinks: J } of j)
        le.sort(y), J.sort(y);
  }
  function w({ nodes: j }) {
    for (const oe of j)
      oe.value = oe.fixedValue === void 0 ? Math.max(rh(oe.sourceLinks, ih), rh(oe.targetLinks, ih)) : oe.fixedValue;
  }
  function S({ nodes: j }) {
    const oe = j.length;
    let ie = new Set(j), le = /* @__PURE__ */ new Set(), J = 0;
    for (; ie.size; ) {
      for (const de of ie) {
        de.depth = J;
        for (const { target: ae } of de.sourceLinks)
          le.add(ae);
      }
      if (++J > oe)
        throw new Error("circular link");
      ie = le, le = /* @__PURE__ */ new Set();
    }
  }
  function B({ nodes: j }) {
    const oe = j.length;
    let ie = new Set(j), le = /* @__PURE__ */ new Set(), J = 0;
    for (; ie.size; ) {
      for (const de of ie) {
        de.height = J;
        for (const { source: ae } of de.targetLinks)
          le.add(ae);
      }
      if (++J > oe)
        throw new Error("circular link");
      ie = le, le = /* @__PURE__ */ new Set();
    }
  }
  function M({ nodes: j }) {
    const oe = tm(j, (J) => J.depth) + 1, ie = (n - e - i) / (oe - 1), le = new Array(oe);
    for (const J of j) {
      const de = Math.max(0, Math.min(oe - 1, Math.floor(c.call(null, J, oe))));
      J.layer = de, J.x0 = e + de * ie, J.x1 = J.x0 + i, le[de] ? le[de].push(J) : le[de] = [J];
    }
    if (p)
      for (const J of le)
        J.sort(p);
    return le;
  }
  function D(j) {
    const oe = PS(j, (ie) => (r - t - (ie.length - 1) * h) / rh(ie, ih));
    for (const ie of j) {
      let le = t;
      for (const J of ie) {
        J.y0 = le, J.y1 = le + J.value * oe, le = J.y1 + h;
        for (const de of J.sourceLinks)
          de.width = de.value * oe;
      }
      le = (r - le + h) / (ie.length + 1);
      for (let J = 0; J < ie.length; ++J) {
        const de = ie[J];
        de.y0 += le * (J + 1), de.y1 += le * (J + 1);
      }
      q(ie);
    }
  }
  function O(j) {
    const oe = M(j);
    h = Math.min(o, (r - t) / (tm(oe, (ie) => ie.length) - 1)), D(oe);
    for (let ie = 0; ie < T; ++ie) {
      const le = Math.pow(0.99, ie), J = Math.max(1 - le, (ie + 1) / T);
      U(oe, le, J), L(oe, le, J);
    }
  }
  function L(j, oe, ie) {
    for (let le = 1, J = j.length; le < J; ++le) {
      const de = j[le];
      for (const ae of de) {
        let Z = 0, ye = 0;
        for (const { source: ve, value: ke } of ae.targetLinks) {
          let me = ke * (ae.layer - ve.layer);
          Z += re(ve, ae) * me, ye += me;
        }
        if (!(ye > 0))
          continue;
        let ue = (Z / ye - ae.y0) * oe;
        ae.y0 += ue, ae.y1 += ue, ce(ae);
      }
      p === void 0 && de.sort(Tc), X(de, ie);
    }
  }
  function U(j, oe, ie) {
    for (let le = j.length, J = le - 2; J >= 0; --J) {
      const de = j[J];
      for (const ae of de) {
        let Z = 0, ye = 0;
        for (const { target: ve, value: ke } of ae.sourceLinks) {
          let me = ke * (ve.layer - ae.layer);
          Z += $(ae, ve) * me, ye += me;
        }
        if (!(ye > 0))
          continue;
        let ue = (Z / ye - ae.y0) * oe;
        ae.y0 += ue, ae.y1 += ue, ce(ae);
      }
      p === void 0 && de.sort(Tc), X(de, ie);
    }
  }
  function X(j, oe) {
    const ie = j.length >> 1, le = j[ie];
    G(j, le.y0 - h, ie - 1, oe), ne(j, le.y1 + h, ie + 1, oe), G(j, r, j.length - 1, oe), ne(j, t, 0, oe);
  }
  function ne(j, oe, ie, le) {
    for (; ie < j.length; ++ie) {
      const J = j[ie], de = (oe - J.y0) * le;
      de > 1e-6 && (J.y0 += de, J.y1 += de), oe = J.y1 + h;
    }
  }
  function G(j, oe, ie, le) {
    for (; ie >= 0; --ie) {
      const J = j[ie], de = (J.y1 - oe) * le;
      de > 1e-6 && (J.y0 -= de, J.y1 -= de), oe = J.y0 - h;
    }
  }
  function ce({ sourceLinks: j, targetLinks: oe }) {
    if (y === void 0) {
      for (const { source: { sourceLinks: ie } } of oe)
        ie.sort(rm);
      for (const { target: { targetLinks: ie } } of j)
        ie.sort(nm);
    }
  }
  function q(j) {
    if (y === void 0)
      for (const { sourceLinks: oe, targetLinks: ie } of j)
        oe.sort(rm), ie.sort(nm);
  }
  function re(j, oe) {
    let ie = j.y0 - (j.sourceLinks.length - 1) * h / 2;
    for (const { target: le, width: J } of j.sourceLinks) {
      if (le === oe)
        break;
      ie += J + h;
    }
    for (const { source: le, width: J } of oe.targetLinks) {
      if (le === j)
        break;
      ie -= J;
    }
    return ie;
  }
  function $(j, oe) {
    let ie = oe.y0 - (oe.targetLinks.length - 1) * h / 2;
    for (const { source: le, width: J } of oe.targetLinks) {
      if (le === j)
        break;
      ie += J + h;
    }
    for (const { target: le, width: J } of j.sourceLinks) {
      if (le === oe)
        break;
      ie -= J;
    }
    return ie;
  }
  return m;
}
function FS(e) {
  return [e.source.x1, e.y0];
}
function BS(e) {
  return [e.target.x0, e.y1];
}
function zS() {
  return Xx().source(FS).target(BS);
}
const $S = () => {
  const { config: e, handleChartTabbing: t, legendId: n } = fe.useContext(ft), [r, i] = fe.useState(!1), o = /* @__PURE__ */ F(Be, { children: [
    "For best viewing we recommend portrait mode. If you are unable to put your device in portrait mode, please review the ",
    /* @__PURE__ */ a("a", { href: `#${t(e, n)}`, children: "data table" }),
    " below.",
    " ",
    /* @__PURE__ */ a("a", { onClick: () => i(!1), href: "#!", children: "Close this alert" }),
    " ",
    "to continue viewing the chart."
  ] }), h = () => {
    i(!1);
  }, d = r ? /* @__PURE__ */ F("div", { className: "alert alert-warning alert-dismissible", role: "alert", children: [
    /* @__PURE__ */ a("p", { style: { padding: "35px" }, children: o }),
    /* @__PURE__ */ a("button", { type: "button", className: "close", "data-dismiss": "alert", "aria-label": "Close", onClick: h, children: /* @__PURE__ */ a("span", { "aria-hidden": "true", children: "×" }) })
  ] }) : null;
  return fe.useEffect(() => {
    const c = () => {
      window.innerWidth < 768 && window.innerHeight > window.innerWidth ? i(!0) : i(!1);
    };
    return window.addEventListener("resize", c), c(), () => {
      window.removeEventListener("resize", c);
    };
  }, []), {
    setShowAlert: i,
    showAlert: r,
    handleCloseModal: h,
    alertMessage: o,
    alert: d
  };
};
var ta = {}, Ia = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var om;
function HS() {
  if (om)
    return Ia;
  om = 1;
  var e = fe;
  function t(v) {
    for (var P = "https://reactjs.org/docs/error-decoder.html?invariant=" + v, _ = 1; _ < arguments.length; _++)
      P += "&args[]=" + encodeURIComponent(arguments[_]);
    return "Minified React error #" + v + "; visit " + P + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = Object.prototype.hasOwnProperty, r = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, i = {}, o = {};
  function h(v) {
    return n.call(o, v) ? !0 : n.call(i, v) ? !1 : r.test(v) ? o[v] = !0 : (i[v] = !0, !1);
  }
  function d(v, P, _, W, he, N, z) {
    this.acceptsBooleans = P === 2 || P === 3 || P === 4, this.attributeName = W, this.attributeNamespace = he, this.mustUseProperty = _, this.propertyName = v, this.type = P, this.sanitizeURL = N, this.removeEmptyString = z;
  }
  var c = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(v) {
    c[v] = new d(v, 0, !1, v, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(v) {
    var P = v[0];
    c[P] = new d(P, 1, !1, v[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(v) {
    c[v] = new d(v, 2, !1, v.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(v) {
    c[v] = new d(v, 2, !1, v, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(v) {
    c[v] = new d(v, 3, !1, v.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(v) {
    c[v] = new d(v, 3, !0, v, null, !1, !1);
  }), ["capture", "download"].forEach(function(v) {
    c[v] = new d(v, 4, !1, v, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(v) {
    c[v] = new d(v, 6, !1, v, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(v) {
    c[v] = new d(v, 5, !1, v.toLowerCase(), null, !1, !1);
  });
  var p = /[\-:]([a-z])/g;
  function y(v) {
    return v[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(v) {
    var P = v.replace(
      p,
      y
    );
    c[P] = new d(P, 1, !1, v, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(v) {
    var P = v.replace(p, y);
    c[P] = new d(P, 1, !1, v, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(v) {
    var P = v.replace(p, y);
    c[P] = new d(P, 1, !1, v, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(v) {
    c[v] = new d(v, 1, !1, v.toLowerCase(), null, !1, !1);
  }), c.xlinkHref = new d("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(v) {
    c[v] = new d(v, 1, !1, v.toLowerCase(), null, !0, !0);
  });
  var g = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, b = ["Webkit", "ms", "Moz", "O"];
  Object.keys(g).forEach(function(v) {
    b.forEach(function(P) {
      P = P + v.charAt(0).toUpperCase() + v.substring(1), g[P] = g[v];
    });
  });
  var T = /["'&<>]/;
  function m(v) {
    if (typeof v == "boolean" || typeof v == "number")
      return "" + v;
    v = "" + v;
    var P = T.exec(v);
    if (P) {
      var _ = "", W, he = 0;
      for (W = P.index; W < v.length; W++) {
        switch (v.charCodeAt(W)) {
          case 34:
            P = "&quot;";
            break;
          case 38:
            P = "&amp;";
            break;
          case 39:
            P = "&#x27;";
            break;
          case 60:
            P = "&lt;";
            break;
          case 62:
            P = "&gt;";
            break;
          default:
            continue;
        }
        he !== W && (_ += v.substring(he, W)), he = W + 1, _ += P;
      }
      v = he !== W ? _ + v.substring(he, W) : _;
    }
    return v;
  }
  var C = /([A-Z])/g, w = /^ms-/, S = Array.isArray;
  function B(v, P) {
    return { insertionMode: v, selectedValue: P };
  }
  function M(v, P, _) {
    switch (P) {
      case "select":
        return B(1, _.value != null ? _.value : _.defaultValue);
      case "svg":
        return B(2, null);
      case "math":
        return B(3, null);
      case "foreignObject":
        return B(1, null);
      case "table":
        return B(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return B(5, null);
      case "colgroup":
        return B(7, null);
      case "tr":
        return B(6, null);
    }
    return 4 <= v.insertionMode || v.insertionMode === 0 ? B(1, null) : v;
  }
  var D = /* @__PURE__ */ new Map();
  function O(v, P, _) {
    if (typeof _ != "object")
      throw Error(t(62));
    P = !0;
    for (var W in _)
      if (n.call(_, W)) {
        var he = _[W];
        if (he != null && typeof he != "boolean" && he !== "") {
          if (W.indexOf("--") === 0) {
            var N = m(W);
            he = m(("" + he).trim());
          } else {
            N = W;
            var z = D.get(N);
            z !== void 0 || (z = m(N.replace(C, "-$1").toLowerCase().replace(w, "-ms-")), D.set(N, z)), N = z, he = typeof he == "number" ? he === 0 || n.call(g, W) ? "" + he : he + "px" : m(("" + he).trim());
          }
          P ? (P = !1, v.push(' style="', N, ":", he)) : v.push(";", N, ":", he);
        }
      }
    P || v.push('"');
  }
  function L(v, P, _, W) {
    switch (_) {
      case "style":
        O(v, P, W);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < _.length) || _[0] !== "o" && _[0] !== "O" || _[1] !== "n" && _[1] !== "N") {
      if (P = c.hasOwnProperty(_) ? c[_] : null, P !== null) {
        switch (typeof W) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!P.acceptsBooleans)
              return;
        }
        switch (_ = P.attributeName, P.type) {
          case 3:
            W && v.push(" ", _, '=""');
            break;
          case 4:
            W === !0 ? v.push(" ", _, '=""') : W !== !1 && v.push(" ", _, '="', m(W), '"');
            break;
          case 5:
            isNaN(W) || v.push(" ", _, '="', m(W), '"');
            break;
          case 6:
            !isNaN(W) && 1 <= W && v.push(" ", _, '="', m(W), '"');
            break;
          default:
            P.sanitizeURL && (W = "" + W), v.push(" ", _, '="', m(W), '"');
        }
      } else if (h(_)) {
        switch (typeof W) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (P = _.toLowerCase().slice(0, 5), P !== "data-" && P !== "aria-")
              return;
        }
        v.push(" ", _, '="', m(W), '"');
      }
    }
  }
  function U(v, P, _) {
    if (P != null) {
      if (_ != null)
        throw Error(t(60));
      if (typeof P != "object" || !("__html" in P))
        throw Error(t(61));
      P = P.__html, P != null && v.push("" + P);
    }
  }
  function X(v) {
    var P = "";
    return e.Children.forEach(v, function(_) {
      _ != null && (P += _);
    }), P;
  }
  function ne(v, P, _, W) {
    v.push(q(_));
    var he = _ = null, N;
    for (N in P)
      if (n.call(P, N)) {
        var z = P[N];
        if (z != null)
          switch (N) {
            case "children":
              _ = z;
              break;
            case "dangerouslySetInnerHTML":
              he = z;
              break;
            default:
              L(v, W, N, z);
          }
      }
    return v.push(">"), U(v, he, _), typeof _ == "string" ? (v.push(m(_)), null) : _;
  }
  var G = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, ce = /* @__PURE__ */ new Map();
  function q(v) {
    var P = ce.get(v);
    if (P === void 0) {
      if (!G.test(v))
        throw Error(t(65, v));
      P = "<" + v, ce.set(v, P);
    }
    return P;
  }
  function re(v, P, _, W, he) {
    switch (P) {
      case "select":
        v.push(q("select"));
        var N = null, z = null;
        for (We in _)
          if (n.call(_, We)) {
            var Y = _[We];
            if (Y != null)
              switch (We) {
                case "children":
                  N = Y;
                  break;
                case "dangerouslySetInnerHTML":
                  z = Y;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  L(v, W, We, Y);
              }
          }
        return v.push(">"), U(v, z, N), N;
      case "option":
        z = he.selectedValue, v.push(q("option"));
        var be = Y = null, Oe = null, We = null;
        for (N in _)
          if (n.call(_, N)) {
            var rt = _[N];
            if (rt != null)
              switch (N) {
                case "children":
                  Y = rt;
                  break;
                case "selected":
                  Oe = rt;
                  break;
                case "dangerouslySetInnerHTML":
                  We = rt;
                  break;
                case "value":
                  be = rt;
                default:
                  L(v, W, N, rt);
              }
          }
        if (z != null)
          if (_ = be !== null ? "" + be : X(Y), S(z)) {
            for (W = 0; W < z.length; W++)
              if ("" + z[W] === _) {
                v.push(' selected=""');
                break;
              }
          } else
            "" + z === _ && v.push(' selected=""');
        else
          Oe && v.push(' selected=""');
        return v.push(">"), U(v, We, Y), Y;
      case "textarea":
        v.push(q("textarea")), We = z = N = null;
        for (Y in _)
          if (n.call(_, Y) && (be = _[Y], be != null))
            switch (Y) {
              case "children":
                We = be;
                break;
              case "value":
                N = be;
                break;
              case "defaultValue":
                z = be;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                L(
                  v,
                  W,
                  Y,
                  be
                );
            }
        if (N === null && z !== null && (N = z), v.push(">"), We != null) {
          if (N != null)
            throw Error(t(92));
          if (S(We) && 1 < We.length)
            throw Error(t(93));
          N = "" + We;
        }
        return typeof N == "string" && N[0] === `
` && v.push(`
`), N !== null && v.push(m("" + N)), null;
      case "input":
        v.push(q("input")), be = We = Y = N = null;
        for (z in _)
          if (n.call(_, z) && (Oe = _[z], Oe != null))
            switch (z) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                be = Oe;
                break;
              case "defaultValue":
                Y = Oe;
                break;
              case "checked":
                We = Oe;
                break;
              case "value":
                N = Oe;
                break;
              default:
                L(v, W, z, Oe);
            }
        return We !== null ? L(v, W, "checked", We) : be !== null && L(v, W, "checked", be), N !== null ? L(v, W, "value", N) : Y !== null && L(v, W, "value", Y), v.push("/>"), null;
      case "menuitem":
        v.push(q("menuitem"));
        for (var Dt in _)
          if (n.call(_, Dt) && (N = _[Dt], N != null))
            switch (Dt) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                L(v, W, Dt, N);
            }
        return v.push(">"), null;
      case "title":
        v.push(q("title")), N = null;
        for (rt in _)
          if (n.call(_, rt) && (z = _[rt], z != null))
            switch (rt) {
              case "children":
                N = z;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                L(v, W, rt, z);
            }
        return v.push(">"), N;
      case "listing":
      case "pre":
        v.push(q(P)), z = N = null;
        for (be in _)
          if (n.call(_, be) && (Y = _[be], Y != null))
            switch (be) {
              case "children":
                N = Y;
                break;
              case "dangerouslySetInnerHTML":
                z = Y;
                break;
              default:
                L(v, W, be, Y);
            }
        if (v.push(">"), z != null) {
          if (N != null)
            throw Error(t(60));
          if (typeof z != "object" || !("__html" in z))
            throw Error(t(61));
          _ = z.__html, _ != null && (typeof _ == "string" && 0 < _.length && _[0] === `
` ? v.push(`
`, _) : v.push("" + _));
        }
        return typeof N == "string" && N[0] === `
` && v.push(`
`), N;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        v.push(q(P));
        for (var Mt in _)
          if (n.call(_, Mt) && (N = _[Mt], N != null))
            switch (Mt) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, P));
              default:
                L(v, W, Mt, N);
            }
        return v.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return ne(
          v,
          _,
          P,
          W
        );
      case "html":
        return he.insertionMode === 0 && v.push("<!DOCTYPE html>"), ne(v, _, P, W);
      default:
        if (P.indexOf("-") === -1 && typeof _.is != "string")
          return ne(v, _, P, W);
        v.push(q(P)), z = N = null;
        for (Oe in _)
          if (n.call(_, Oe) && (Y = _[Oe], Y != null))
            switch (Oe) {
              case "children":
                N = Y;
                break;
              case "dangerouslySetInnerHTML":
                z = Y;
                break;
              case "style":
                O(v, W, Y);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                h(Oe) && typeof Y != "function" && typeof Y != "symbol" && v.push(" ", Oe, '="', m(Y), '"');
            }
        return v.push(">"), U(v, z, N), N;
    }
  }
  function $(v, P, _) {
    if (v.push('<!--$?--><template id="'), _ === null)
      throw Error(t(395));
    return v.push(_), v.push('"></template>');
  }
  function j(v, P, _, W) {
    switch (_.insertionMode) {
      case 0:
      case 1:
        return v.push('<div hidden id="'), v.push(P.segmentPrefix), P = W.toString(16), v.push(P), v.push('">');
      case 2:
        return v.push('<svg aria-hidden="true" style="display:none" id="'), v.push(P.segmentPrefix), P = W.toString(16), v.push(P), v.push('">');
      case 3:
        return v.push('<math aria-hidden="true" style="display:none" id="'), v.push(P.segmentPrefix), P = W.toString(16), v.push(P), v.push('">');
      case 4:
        return v.push('<table hidden id="'), v.push(P.segmentPrefix), P = W.toString(16), v.push(P), v.push('">');
      case 5:
        return v.push('<table hidden><tbody id="'), v.push(P.segmentPrefix), P = W.toString(16), v.push(P), v.push('">');
      case 6:
        return v.push('<table hidden><tr id="'), v.push(P.segmentPrefix), P = W.toString(16), v.push(P), v.push('">');
      case 7:
        return v.push('<table hidden><colgroup id="'), v.push(P.segmentPrefix), P = W.toString(16), v.push(P), v.push('">');
      default:
        throw Error(t(397));
    }
  }
  function oe(v, P) {
    switch (P.insertionMode) {
      case 0:
      case 1:
        return v.push("</div>");
      case 2:
        return v.push("</svg>");
      case 3:
        return v.push("</math>");
      case 4:
        return v.push("</table>");
      case 5:
        return v.push("</tbody></table>");
      case 6:
        return v.push("</tr></table>");
      case 7:
        return v.push("</colgroup></table>");
      default:
        throw Error(t(397));
    }
  }
  var ie = /[<\u2028\u2029]/g;
  function le(v) {
    return JSON.stringify(v).replace(ie, function(P) {
      switch (P) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function J(v, P) {
    return P = P === void 0 ? "" : P, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: P + "P:", segmentPrefix: P + "S:", boundaryPrefix: P + "B:", idPrefix: P, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: v };
  }
  function de(v, P, _, W) {
    return _.generateStaticMarkup ? (v.push(m(P)), !1) : (P === "" ? v = W : (W && v.push("<!-- -->"), v.push(m(P)), v = !0), v);
  }
  var ae = Object.assign, Z = Symbol.for("react.element"), ye = Symbol.for("react.portal"), ue = Symbol.for("react.fragment"), ve = Symbol.for("react.strict_mode"), ke = Symbol.for("react.profiler"), me = Symbol.for("react.provider"), Ne = Symbol.for("react.context"), Ee = Symbol.for("react.forward_ref"), De = Symbol.for("react.suspense"), Xe = Symbol.for("react.suspense_list"), Fe = Symbol.for("react.memo"), Je = Symbol.for("react.lazy"), gt = Symbol.for("react.scope"), mt = Symbol.for("react.debug_trace_mode"), yt = Symbol.for("react.legacy_hidden"), Ye = Symbol.for("react.default_value"), ot = Symbol.iterator;
  function ut(v) {
    if (v == null)
      return null;
    if (typeof v == "function")
      return v.displayName || v.name || null;
    if (typeof v == "string")
      return v;
    switch (v) {
      case ue:
        return "Fragment";
      case ye:
        return "Portal";
      case ke:
        return "Profiler";
      case ve:
        return "StrictMode";
      case De:
        return "Suspense";
      case Xe:
        return "SuspenseList";
    }
    if (typeof v == "object")
      switch (v.$$typeof) {
        case Ne:
          return (v.displayName || "Context") + ".Consumer";
        case me:
          return (v._context.displayName || "Context") + ".Provider";
        case Ee:
          var P = v.render;
          return v = v.displayName, v || (v = P.displayName || P.name || "", v = v !== "" ? "ForwardRef(" + v + ")" : "ForwardRef"), v;
        case Fe:
          return P = v.displayName || null, P !== null ? P : ut(v.type) || "Memo";
        case Je:
          P = v._payload, v = v._init;
          try {
            return ut(v(P));
          } catch {
          }
      }
    return null;
  }
  var st = {};
  function tt(v, P) {
    if (v = v.contextTypes, !v)
      return st;
    var _ = {}, W;
    for (W in v)
      _[W] = P[W];
    return _;
  }
  var $e = null;
  function it(v, P) {
    if (v !== P) {
      v.context._currentValue2 = v.parentValue, v = v.parent;
      var _ = P.parent;
      if (v === null) {
        if (_ !== null)
          throw Error(t(401));
      } else {
        if (_ === null)
          throw Error(t(401));
        it(v, _);
      }
      P.context._currentValue2 = P.value;
    }
  }
  function ht(v) {
    v.context._currentValue2 = v.parentValue, v = v.parent, v !== null && ht(v);
  }
  function Ce(v) {
    var P = v.parent;
    P !== null && Ce(P), v.context._currentValue2 = v.value;
  }
  function Ht(v, P) {
    if (v.context._currentValue2 = v.parentValue, v = v.parent, v === null)
      throw Error(t(402));
    v.depth === P.depth ? it(v, P) : Ht(v, P);
  }
  function vn(v, P) {
    var _ = P.parent;
    if (_ === null)
      throw Error(t(402));
    v.depth === _.depth ? it(v, _) : vn(v, _), P.context._currentValue2 = P.value;
  }
  function pt(v) {
    var P = $e;
    P !== v && (P === null ? Ce(v) : v === null ? ht(P) : P.depth === v.depth ? it(P, v) : P.depth > v.depth ? Ht(P, v) : vn(P, v), $e = v);
  }
  var hn = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(v, P) {
    v = v._reactInternals, v.queue !== null && v.queue.push(P);
  }, enqueueReplaceState: function(v, P) {
    v = v._reactInternals, v.replace = !0, v.queue = [P];
  }, enqueueForceUpdate: function() {
  } };
  function yn(v, P, _, W) {
    var he = v.state !== void 0 ? v.state : null;
    v.updater = hn, v.props = _, v.state = he;
    var N = { queue: [], replace: !1 };
    v._reactInternals = N;
    var z = P.contextType;
    if (v.context = typeof z == "object" && z !== null ? z._currentValue2 : W, z = P.getDerivedStateFromProps, typeof z == "function" && (z = z(_, he), he = z == null ? he : ae({}, he, z), v.state = he), typeof P.getDerivedStateFromProps != "function" && typeof v.getSnapshotBeforeUpdate != "function" && (typeof v.UNSAFE_componentWillMount == "function" || typeof v.componentWillMount == "function"))
      if (P = v.state, typeof v.componentWillMount == "function" && v.componentWillMount(), typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount(), P !== v.state && hn.enqueueReplaceState(v, v.state, null), N.queue !== null && 0 < N.queue.length)
        if (P = N.queue, z = N.replace, N.queue = null, N.replace = !1, z && P.length === 1)
          v.state = P[0];
        else {
          for (N = z ? P[0] : v.state, he = !0, z = z ? 1 : 0; z < P.length; z++) {
            var Y = P[z];
            Y = typeof Y == "function" ? Y.call(v, N, _, W) : Y, Y != null && (he ? (he = !1, N = ae({}, N, Y)) : ae(N, Y));
          }
          v.state = N;
        }
      else
        N.queue = null;
  }
  var Vt = { id: 1, overflow: "" };
  function zt(v, P, _) {
    var W = v.id;
    v = v.overflow;
    var he = 32 - Cn(W) - 1;
    W &= ~(1 << he), _ += 1;
    var N = 32 - Cn(P) + he;
    if (30 < N) {
      var z = he - he % 5;
      return N = (W & (1 << z) - 1).toString(32), W >>= z, he -= z, { id: 1 << 32 - Cn(P) + he | _ << he | W, overflow: N + v };
    }
    return { id: 1 << N | _ << he | W, overflow: v };
  }
  var Cn = Math.clz32 ? Math.clz32 : Gt, qt = Math.log, Ft = Math.LN2;
  function Gt(v) {
    return v >>>= 0, v === 0 ? 32 : 31 - (qt(v) / Ft | 0) | 0;
  }
  function Zt(v, P) {
    return v === P && (v !== 0 || 1 / v === 1 / P) || v !== v && P !== P;
  }
  var gn = typeof Object.is == "function" ? Object.is : Zt, Pt = null, Qt = null, Rt = null, bt = null, lt = !1, Se = !1, _e = 0, xe = null, Ge = 0;
  function Ze() {
    if (Pt === null)
      throw Error(t(321));
    return Pt;
  }
  function et() {
    if (0 < Ge)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function Nt() {
    return bt === null ? Rt === null ? (lt = !1, Rt = bt = et()) : (lt = !0, bt = Rt) : bt.next === null ? (lt = !1, bt = bt.next = et()) : (lt = !0, bt = bt.next), bt;
  }
  function Wt() {
    Qt = Pt = null, Se = !1, Rt = null, Ge = 0, bt = xe = null;
  }
  function xt(v, P) {
    return typeof P == "function" ? P(v) : P;
  }
  function at(v, P, _) {
    if (Pt = Ze(), bt = Nt(), lt) {
      var W = bt.queue;
      if (P = W.dispatch, xe !== null && (_ = xe.get(W), _ !== void 0)) {
        xe.delete(W), W = bt.memoizedState;
        do
          W = v(W, _.action), _ = _.next;
        while (_ !== null);
        return bt.memoizedState = W, [W, P];
      }
      return [bt.memoizedState, P];
    }
    return v = v === xt ? typeof P == "function" ? P() : P : _ !== void 0 ? _(P) : P, bt.memoizedState = v, v = bt.queue = { last: null, dispatch: null }, v = v.dispatch = jt.bind(null, Pt, v), [bt.memoizedState, v];
  }
  function un(v, P) {
    if (Pt = Ze(), bt = Nt(), P = P === void 0 ? null : P, bt !== null) {
      var _ = bt.memoizedState;
      if (_ !== null && P !== null) {
        var W = _[1];
        e:
          if (W === null)
            W = !1;
          else {
            for (var he = 0; he < W.length && he < P.length; he++)
              if (!gn(P[he], W[he])) {
                W = !1;
                break e;
              }
            W = !0;
          }
        if (W)
          return _[0];
      }
    }
    return v = v(), bt.memoizedState = [v, P], v;
  }
  function jt(v, P, _) {
    if (25 <= Ge)
      throw Error(t(301));
    if (v === Pt)
      if (Se = !0, v = { action: _, next: null }, xe === null && (xe = /* @__PURE__ */ new Map()), _ = xe.get(P), _ === void 0)
        xe.set(P, v);
      else {
        for (P = _; P.next !== null; )
          P = P.next;
        P.next = v;
      }
  }
  function An() {
    throw Error(t(394));
  }
  function wt() {
  }
  var Lt = { readContext: function(v) {
    return v._currentValue2;
  }, useContext: function(v) {
    return Ze(), v._currentValue2;
  }, useMemo: un, useReducer: at, useRef: function(v) {
    Pt = Ze(), bt = Nt();
    var P = bt.memoizedState;
    return P === null ? (v = { current: v }, bt.memoizedState = v) : P;
  }, useState: function(v) {
    return at(xt, v);
  }, useInsertionEffect: wt, useLayoutEffect: function() {
  }, useCallback: function(v, P) {
    return un(function() {
      return v;
    }, P);
  }, useImperativeHandle: wt, useEffect: wt, useDebugValue: wt, useDeferredValue: function(v) {
    return Ze(), v;
  }, useTransition: function() {
    return Ze(), [
      !1,
      An
    ];
  }, useId: function() {
    var v = Qt.treeContext, P = v.overflow;
    v = v.id, v = (v & ~(1 << 32 - Cn(v) - 1)).toString(32) + P;
    var _ = bn;
    if (_ === null)
      throw Error(t(404));
    return P = _e++, v = ":" + _.idPrefix + "R" + v, 0 < P && (v += "H" + P.toString(32)), v + ":";
  }, useMutableSource: function(v, P) {
    return Ze(), P(v._source);
  }, useSyncExternalStore: function(v, P, _) {
    if (_ === void 0)
      throw Error(t(407));
    return _();
  } }, bn = null, $n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function Ln(v) {
    return console.error(v), null;
  }
  function En() {
  }
  function nr(v, P, _, W, he, N, z, Y, be) {
    var Oe = [], We = /* @__PURE__ */ new Set();
    return P = { destination: null, responseState: P, progressiveChunkSize: W === void 0 ? 12800 : W, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: We, pingedTasks: Oe, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: he === void 0 ? Ln : he, onAllReady: N === void 0 ? En : N, onShellReady: z === void 0 ? En : z, onShellError: Y === void 0 ? En : Y, onFatalError: be === void 0 ? En : be }, _ = _n(P, 0, null, _, !1, !1), _.parentFlushed = !0, v = Yn(P, v, null, _, We, st, null, Vt), Oe.push(v), P;
  }
  function Yn(v, P, _, W, he, N, z, Y) {
    v.allPendingTasks++, _ === null ? v.pendingRootTasks++ : _.pendingTasks++;
    var be = { node: P, ping: function() {
      var Oe = v.pingedTasks;
      Oe.push(be), Oe.length === 1 && cn(v);
    }, blockedBoundary: _, blockedSegment: W, abortSet: he, legacyContext: N, context: z, treeContext: Y };
    return he.add(be), be;
  }
  function _n(v, P, _, W, he, N) {
    return { status: 0, id: -1, index: P, parentFlushed: !1, chunks: [], children: [], formatContext: W, boundary: _, lastPushedText: he, textEmbedded: N };
  }
  function fn(v, P) {
    if (v = v.onError(P), v != null && typeof v != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof v + '" instead');
    return v;
  }
  function _t(v, P) {
    var _ = v.onShellError;
    _(P), _ = v.onFatalError, _(P), v.destination !== null ? (v.status = 2, v.destination.destroy(P)) : (v.status = 1, v.fatalError = P);
  }
  function Jt(v, P, _, W, he) {
    for (Pt = {}, Qt = P, _e = 0, v = _(W, he); Se; )
      Se = !1, _e = 0, Ge += 1, bt = null, v = _(W, he);
    return Wt(), v;
  }
  function Yt(v, P, _, W) {
    var he = _.render(), N = W.childContextTypes;
    if (N != null) {
      var z = P.legacyContext;
      if (typeof _.getChildContext != "function")
        W = z;
      else {
        _ = _.getChildContext();
        for (var Y in _)
          if (!(Y in N))
            throw Error(t(108, ut(W) || "Unknown", Y));
        W = ae({}, z, _);
      }
      P.legacyContext = W, Ut(v, P, he), P.legacyContext = z;
    } else
      Ut(v, P, he);
  }
  function on(v, P) {
    if (v && v.defaultProps) {
      P = ae({}, P), v = v.defaultProps;
      for (var _ in v)
        P[_] === void 0 && (P[_] = v[_]);
      return P;
    }
    return P;
  }
  function wn(v, P, _, W, he) {
    if (typeof _ == "function")
      if (_.prototype && _.prototype.isReactComponent) {
        he = tt(_, P.legacyContext);
        var N = _.contextType;
        N = new _(W, typeof N == "object" && N !== null ? N._currentValue2 : he), yn(N, _, W, he), Yt(v, P, N, _);
      } else {
        N = tt(_, P.legacyContext), he = Jt(v, P, _, W, N);
        var z = _e !== 0;
        if (typeof he == "object" && he !== null && typeof he.render == "function" && he.$$typeof === void 0)
          yn(he, _, W, N), Yt(v, P, he, _);
        else if (z) {
          W = P.treeContext, P.treeContext = zt(W, 1, 0);
          try {
            Ut(v, P, he);
          } finally {
            P.treeContext = W;
          }
        } else
          Ut(v, P, he);
      }
    else if (typeof _ == "string") {
      switch (he = P.blockedSegment, N = re(he.chunks, _, W, v.responseState, he.formatContext), he.lastPushedText = !1, z = he.formatContext, he.formatContext = M(z, _, W), pn(v, P, N), he.formatContext = z, _) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          he.chunks.push("</", _, ">");
      }
      he.lastPushedText = !1;
    } else {
      switch (_) {
        case yt:
        case mt:
        case ve:
        case ke:
        case ue:
          Ut(v, P, W.children);
          return;
        case Xe:
          Ut(v, P, W.children);
          return;
        case gt:
          throw Error(t(343));
        case De:
          e: {
            _ = P.blockedBoundary, he = P.blockedSegment, N = W.fallback, W = W.children, z = /* @__PURE__ */ new Set();
            var Y = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: z, errorDigest: null }, be = _n(v, he.chunks.length, Y, he.formatContext, !1, !1);
            he.children.push(be), he.lastPushedText = !1;
            var Oe = _n(v, 0, null, he.formatContext, !1, !1);
            Oe.parentFlushed = !0, P.blockedBoundary = Y, P.blockedSegment = Oe;
            try {
              if (pn(
                v,
                P,
                W
              ), v.responseState.generateStaticMarkup || Oe.lastPushedText && Oe.textEmbedded && Oe.chunks.push("<!-- -->"), Oe.status = 1, Mn(Y, Oe), Y.pendingTasks === 0)
                break e;
            } catch (We) {
              Oe.status = 4, Y.forceClientRender = !0, Y.errorDigest = fn(v, We);
            } finally {
              P.blockedBoundary = _, P.blockedSegment = he;
            }
            P = Yn(v, N, _, be, z, P.legacyContext, P.context, P.treeContext), v.pingedTasks.push(P);
          }
          return;
      }
      if (typeof _ == "object" && _ !== null)
        switch (_.$$typeof) {
          case Ee:
            if (W = Jt(v, P, _.render, W, he), _e !== 0) {
              _ = P.treeContext, P.treeContext = zt(_, 1, 0);
              try {
                Ut(v, P, W);
              } finally {
                P.treeContext = _;
              }
            } else
              Ut(v, P, W);
            return;
          case Fe:
            _ = _.type, W = on(_, W), wn(v, P, _, W, he);
            return;
          case me:
            if (he = W.children, _ = _._context, W = W.value, N = _._currentValue2, _._currentValue2 = W, z = $e, $e = W = { parent: z, depth: z === null ? 0 : z.depth + 1, context: _, parentValue: N, value: W }, P.context = W, Ut(v, P, he), v = $e, v === null)
              throw Error(t(403));
            W = v.parentValue, v.context._currentValue2 = W === Ye ? v.context._defaultValue : W, v = $e = v.parent, P.context = v;
            return;
          case Ne:
            W = W.children, W = W(_._currentValue2), Ut(v, P, W);
            return;
          case Je:
            he = _._init, _ = he(_._payload), W = on(_, W), wn(
              v,
              P,
              _,
              W,
              void 0
            );
            return;
        }
      throw Error(t(130, _ == null ? _ : typeof _, ""));
    }
  }
  function Ut(v, P, _) {
    if (P.node = _, typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case Z:
          wn(v, P, _.type, _.props, _.ref);
          return;
        case ye:
          throw Error(t(257));
        case Je:
          var W = _._init;
          _ = W(_._payload), Ut(v, P, _);
          return;
      }
      if (S(_)) {
        sn(v, P, _);
        return;
      }
      if (_ === null || typeof _ != "object" ? W = null : (W = ot && _[ot] || _["@@iterator"], W = typeof W == "function" ? W : null), W && (W = W.call(_))) {
        if (_ = W.next(), !_.done) {
          var he = [];
          do
            he.push(_.value), _ = W.next();
          while (!_.done);
          sn(v, P, he);
        }
        return;
      }
      throw v = Object.prototype.toString.call(_), Error(t(31, v === "[object Object]" ? "object with keys {" + Object.keys(_).join(", ") + "}" : v));
    }
    typeof _ == "string" ? (W = P.blockedSegment, W.lastPushedText = de(P.blockedSegment.chunks, _, v.responseState, W.lastPushedText)) : typeof _ == "number" && (W = P.blockedSegment, W.lastPushedText = de(P.blockedSegment.chunks, "" + _, v.responseState, W.lastPushedText));
  }
  function sn(v, P, _) {
    for (var W = _.length, he = 0; he < W; he++) {
      var N = P.treeContext;
      P.treeContext = zt(N, W, he);
      try {
        pn(v, P, _[he]);
      } finally {
        P.treeContext = N;
      }
    }
  }
  function pn(v, P, _) {
    var W = P.blockedSegment.formatContext, he = P.legacyContext, N = P.context;
    try {
      return Ut(v, P, _);
    } catch (be) {
      if (Wt(), typeof be == "object" && be !== null && typeof be.then == "function") {
        _ = be;
        var z = P.blockedSegment, Y = _n(v, z.chunks.length, null, z.formatContext, z.lastPushedText, !0);
        z.children.push(Y), z.lastPushedText = !1, v = Yn(v, P.node, P.blockedBoundary, Y, P.abortSet, P.legacyContext, P.context, P.treeContext).ping, _.then(v, v), P.blockedSegment.formatContext = W, P.legacyContext = he, P.context = N, pt(N);
      } else
        throw P.blockedSegment.formatContext = W, P.legacyContext = he, P.context = N, pt(N), be;
    }
  }
  function Bt(v) {
    var P = v.blockedBoundary;
    v = v.blockedSegment, v.status = 3, Pn(this, P, v);
  }
  function rr(v, P, _) {
    var W = v.blockedBoundary;
    v.blockedSegment.status = 3, W === null ? (P.allPendingTasks--, P.status !== 2 && (P.status = 2, P.destination !== null && P.destination.push(null))) : (W.pendingTasks--, W.forceClientRender || (W.forceClientRender = !0, v = _ === void 0 ? Error(t(432)) : _, W.errorDigest = P.onError(v), W.parentFlushed && P.clientRenderedBoundaries.push(W)), W.fallbackAbortableTasks.forEach(function(he) {
      return rr(he, P, _);
    }), W.fallbackAbortableTasks.clear(), P.allPendingTasks--, P.allPendingTasks === 0 && (W = P.onAllReady, W()));
  }
  function Mn(v, P) {
    if (P.chunks.length === 0 && P.children.length === 1 && P.children[0].boundary === null) {
      var _ = P.children[0];
      _.id = P.id, _.parentFlushed = !0, _.status === 1 && Mn(v, _);
    } else
      v.completedSegments.push(P);
  }
  function Pn(v, P, _) {
    if (P === null) {
      if (_.parentFlushed) {
        if (v.completedRootSegment !== null)
          throw Error(t(389));
        v.completedRootSegment = _;
      }
      v.pendingRootTasks--, v.pendingRootTasks === 0 && (v.onShellError = En, P = v.onShellReady, P());
    } else
      P.pendingTasks--, P.forceClientRender || (P.pendingTasks === 0 ? (_.parentFlushed && _.status === 1 && Mn(P, _), P.parentFlushed && v.completedBoundaries.push(P), P.fallbackAbortableTasks.forEach(Bt, v), P.fallbackAbortableTasks.clear()) : _.parentFlushed && _.status === 1 && (Mn(P, _), P.completedSegments.length === 1 && P.parentFlushed && v.partialBoundaries.push(P)));
    v.allPendingTasks--, v.allPendingTasks === 0 && (v = v.onAllReady, v());
  }
  function cn(v) {
    if (v.status !== 2) {
      var P = $e, _ = $n.current;
      $n.current = Lt;
      var W = bn;
      bn = v.responseState;
      try {
        var he = v.pingedTasks, N;
        for (N = 0; N < he.length; N++) {
          var z = he[N], Y = v, be = z.blockedSegment;
          if (be.status === 0) {
            pt(z.context);
            try {
              Ut(Y, z, z.node), Y.responseState.generateStaticMarkup || be.lastPushedText && be.textEmbedded && be.chunks.push("<!-- -->"), z.abortSet.delete(z), be.status = 1, Pn(Y, z.blockedBoundary, be);
            } catch (dn) {
              if (Wt(), typeof dn == "object" && dn !== null && typeof dn.then == "function") {
                var Oe = z.ping;
                dn.then(Oe, Oe);
              } else {
                z.abortSet.delete(z), be.status = 4;
                var We = z.blockedBoundary, rt = dn, Dt = fn(Y, rt);
                if (We === null ? _t(Y, rt) : (We.pendingTasks--, We.forceClientRender || (We.forceClientRender = !0, We.errorDigest = Dt, We.parentFlushed && Y.clientRenderedBoundaries.push(We))), Y.allPendingTasks--, Y.allPendingTasks === 0) {
                  var Mt = Y.onAllReady;
                  Mt();
                }
              }
            } finally {
            }
          }
        }
        he.splice(0, N), v.destination !== null && Wn(v, v.destination);
      } catch (dn) {
        fn(v, dn), _t(v, dn);
      } finally {
        bn = W, $n.current = _, _ === Lt && pt(P);
      }
    }
  }
  function Hn(v, P, _) {
    switch (_.parentFlushed = !0, _.status) {
      case 0:
        var W = _.id = v.nextSegmentId++;
        return _.lastPushedText = !1, _.textEmbedded = !1, v = v.responseState, P.push('<template id="'), P.push(v.placeholderPrefix), v = W.toString(16), P.push(v), P.push('"></template>');
      case 1:
        _.status = 2;
        var he = !0;
        W = _.chunks;
        var N = 0;
        _ = _.children;
        for (var z = 0; z < _.length; z++) {
          for (he = _[z]; N < he.index; N++)
            P.push(W[N]);
          he = Vn(v, P, he);
        }
        for (; N < W.length - 1; N++)
          P.push(W[N]);
        return N < W.length && (he = P.push(W[N])), he;
      default:
        throw Error(t(390));
    }
  }
  function Vn(v, P, _) {
    var W = _.boundary;
    if (W === null)
      return Hn(v, P, _);
    if (W.parentFlushed = !0, W.forceClientRender)
      return v.responseState.generateStaticMarkup || (W = W.errorDigest, P.push("<!--$!-->"), P.push("<template"), W && (P.push(' data-dgst="'), W = m(W), P.push(W), P.push('"')), P.push("></template>")), Hn(v, P, _), v = v.responseState.generateStaticMarkup ? !0 : P.push("<!--/$-->"), v;
    if (0 < W.pendingTasks) {
      W.rootSegmentID = v.nextSegmentId++, 0 < W.completedSegments.length && v.partialBoundaries.push(W);
      var he = v.responseState, N = he.nextSuspenseID++;
      return he = he.boundaryPrefix + N.toString(16), W = W.id = he, $(P, v.responseState, W), Hn(v, P, _), P.push("<!--/$-->");
    }
    if (W.byteSize > v.progressiveChunkSize)
      return W.rootSegmentID = v.nextSegmentId++, v.completedBoundaries.push(W), $(P, v.responseState, W.id), Hn(v, P, _), P.push("<!--/$-->");
    if (v.responseState.generateStaticMarkup || P.push("<!--$-->"), _ = W.completedSegments, _.length !== 1)
      throw Error(t(391));
    return Vn(v, P, _[0]), v = v.responseState.generateStaticMarkup ? !0 : P.push("<!--/$-->"), v;
  }
  function yr(v, P, _) {
    return j(P, v.responseState, _.formatContext, _.id), Vn(v, P, _), oe(P, _.formatContext);
  }
  function gr(v, P, _) {
    for (var W = _.completedSegments, he = 0; he < W.length; he++)
      ir(v, P, _, W[he]);
    if (W.length = 0, v = v.responseState, W = _.id, _ = _.rootSegmentID, P.push(v.startInlineScript), v.sentCompleteBoundaryFunction ? P.push('$RC("') : (v.sentCompleteBoundaryFunction = !0, P.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), W === null)
      throw Error(t(395));
    return _ = _.toString(16), P.push(W), P.push('","'), P.push(v.segmentPrefix), P.push(_), P.push('")<\/script>');
  }
  function ir(v, P, _, W) {
    if (W.status === 2)
      return !0;
    var he = W.id;
    if (he === -1) {
      if ((W.id = _.rootSegmentID) === -1)
        throw Error(t(392));
      return yr(v, P, W);
    }
    return yr(v, P, W), v = v.responseState, P.push(v.startInlineScript), v.sentCompleteSegmentFunction ? P.push('$RS("') : (v.sentCompleteSegmentFunction = !0, P.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), P.push(v.segmentPrefix), he = he.toString(16), P.push(he), P.push('","'), P.push(v.placeholderPrefix), P.push(he), P.push('")<\/script>');
  }
  function Wn(v, P) {
    try {
      var _ = v.completedRootSegment;
      if (_ !== null && v.pendingRootTasks === 0) {
        Vn(v, P, _), v.completedRootSegment = null;
        var W = v.responseState.bootstrapChunks;
        for (_ = 0; _ < W.length - 1; _++)
          P.push(W[_]);
        _ < W.length && P.push(W[_]);
      }
      var he = v.clientRenderedBoundaries, N;
      for (N = 0; N < he.length; N++) {
        var z = he[N];
        W = P;
        var Y = v.responseState, be = z.id, Oe = z.errorDigest, We = z.errorMessage, rt = z.errorComponentStack;
        if (W.push(Y.startInlineScript), Y.sentClientRenderFunction ? W.push('$RX("') : (Y.sentClientRenderFunction = !0, W.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), be === null)
          throw Error(t(395));
        if (W.push(be), W.push('"'), Oe || We || rt) {
          W.push(",");
          var Dt = le(Oe || "");
          W.push(Dt);
        }
        if (We || rt) {
          W.push(",");
          var Mt = le(We || "");
          W.push(Mt);
        }
        if (rt) {
          W.push(",");
          var dn = le(rt);
          W.push(dn);
        }
        if (!W.push(")<\/script>")) {
          v.destination = null, N++, he.splice(0, N);
          return;
        }
      }
      he.splice(0, N);
      var Xt = v.completedBoundaries;
      for (N = 0; N < Xt.length; N++)
        if (!gr(v, P, Xt[N])) {
          v.destination = null, N++, Xt.splice(0, N);
          return;
        }
      Xt.splice(0, N);
      var tn = v.partialBoundaries;
      for (N = 0; N < tn.length; N++) {
        var Zn = tn[N];
        e: {
          he = v, z = P;
          var In = Zn.completedSegments;
          for (Y = 0; Y < In.length; Y++)
            if (!ir(he, z, Zn, In[Y])) {
              Y++, In.splice(0, Y);
              var or = !1;
              break e;
            }
          In.splice(0, Y), or = !0;
        }
        if (!or) {
          v.destination = null, N++, tn.splice(0, N);
          return;
        }
      }
      tn.splice(0, N);
      var jn = v.completedBoundaries;
      for (N = 0; N < jn.length; N++)
        if (!gr(v, P, jn[N])) {
          v.destination = null, N++, jn.splice(0, N);
          return;
        }
      jn.splice(0, N);
    } finally {
      v.allPendingTasks === 0 && v.pingedTasks.length === 0 && v.clientRenderedBoundaries.length === 0 && v.completedBoundaries.length === 0 && P.push(null);
    }
  }
  function ar(v, P) {
    try {
      var _ = v.abortableTasks;
      _.forEach(function(W) {
        return rr(W, v, P);
      }), _.clear(), v.destination !== null && Wn(v, v.destination);
    } catch (W) {
      fn(v, W), _t(v, W);
    }
  }
  function Xn() {
  }
  function qn(v, P, _, W) {
    var he = !1, N = null, z = "", Y = { push: function(Oe) {
      return Oe !== null && (z += Oe), !0;
    }, destroy: function(Oe) {
      he = !0, N = Oe;
    } }, be = !1;
    if (v = nr(v, J(_, P ? P.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, Xn, void 0, function() {
      be = !0;
    }, void 0, void 0), cn(v), ar(v, W), v.status === 1)
      v.status = 2, Y.destroy(v.fatalError);
    else if (v.status !== 2 && v.destination === null) {
      v.destination = Y;
      try {
        Wn(v, Y);
      } catch (Oe) {
        fn(v, Oe), _t(v, Oe);
      }
    }
    if (he)
      throw N;
    if (!be)
      throw Error(t(426));
    return z;
  }
  return Ia.renderToNodeStream = function() {
    throw Error(t(207));
  }, Ia.renderToStaticMarkup = function(v, P) {
    return qn(v, P, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Ia.renderToStaticNodeStream = function() {
    throw Error(t(208));
  }, Ia.renderToString = function(v, P) {
    return qn(v, P, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Ia.version = "18.3.1", Ia;
}
var Wu = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sm;
function VS() {
  if (sm)
    return Wu;
  sm = 1;
  var e = fe;
  function t(x) {
    for (var R = "https://reactjs.org/docs/error-decoder.html?invariant=" + x, V = 1; V < arguments.length; V++)
      R += "&args[]=" + encodeURIComponent(arguments[V]);
    return "Minified React error #" + x + "; visit " + R + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = null, r = 0;
  function i(x, R) {
    if (R.length !== 0)
      if (512 < R.length)
        0 < r && (x.enqueue(new Uint8Array(n.buffer, 0, r)), n = new Uint8Array(512), r = 0), x.enqueue(R);
      else {
        var V = n.length - r;
        V < R.length && (V === 0 ? x.enqueue(n) : (n.set(R.subarray(0, V), r), x.enqueue(n), R = R.subarray(V)), n = new Uint8Array(512), r = 0), n.set(R, r), r += R.length;
      }
  }
  function o(x, R) {
    return i(x, R), !0;
  }
  function h(x) {
    n && 0 < r && (x.enqueue(new Uint8Array(n.buffer, 0, r)), n = null, r = 0);
  }
  var d = new TextEncoder();
  function c(x) {
    return d.encode(x);
  }
  function p(x) {
    return d.encode(x);
  }
  function y(x, R) {
    typeof x.error == "function" ? x.error(R) : x.close();
  }
  var g = Object.prototype.hasOwnProperty, b = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, T = {}, m = {};
  function C(x) {
    return g.call(m, x) ? !0 : g.call(T, x) ? !1 : b.test(x) ? m[x] = !0 : (T[x] = !0, !1);
  }
  function w(x, R, V, Q, Te, we, Pe) {
    this.acceptsBooleans = R === 2 || R === 3 || R === 4, this.attributeName = Q, this.attributeNamespace = Te, this.mustUseProperty = V, this.propertyName = x, this.type = R, this.sanitizeURL = we, this.removeEmptyString = Pe;
  }
  var S = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(x) {
    S[x] = new w(x, 0, !1, x, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(x) {
    var R = x[0];
    S[R] = new w(R, 1, !1, x[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(x) {
    S[x] = new w(x, 2, !1, x.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(x) {
    S[x] = new w(x, 2, !1, x, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(x) {
    S[x] = new w(x, 3, !1, x.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(x) {
    S[x] = new w(x, 3, !0, x, null, !1, !1);
  }), ["capture", "download"].forEach(function(x) {
    S[x] = new w(x, 4, !1, x, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(x) {
    S[x] = new w(x, 6, !1, x, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(x) {
    S[x] = new w(x, 5, !1, x.toLowerCase(), null, !1, !1);
  });
  var B = /[\-:]([a-z])/g;
  function M(x) {
    return x[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(x) {
    var R = x.replace(
      B,
      M
    );
    S[R] = new w(R, 1, !1, x, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(x) {
    var R = x.replace(B, M);
    S[R] = new w(R, 1, !1, x, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(x) {
    var R = x.replace(B, M);
    S[R] = new w(R, 1, !1, x, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(x) {
    S[x] = new w(x, 1, !1, x.toLowerCase(), null, !1, !1);
  }), S.xlinkHref = new w("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(x) {
    S[x] = new w(x, 1, !1, x.toLowerCase(), null, !0, !0);
  });
  var D = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, O = ["Webkit", "ms", "Moz", "O"];
  Object.keys(D).forEach(function(x) {
    O.forEach(function(R) {
      R = R + x.charAt(0).toUpperCase() + x.substring(1), D[R] = D[x];
    });
  });
  var L = /["'&<>]/;
  function U(x) {
    if (typeof x == "boolean" || typeof x == "number")
      return "" + x;
    x = "" + x;
    var R = L.exec(x);
    if (R) {
      var V = "", Q, Te = 0;
      for (Q = R.index; Q < x.length; Q++) {
        switch (x.charCodeAt(Q)) {
          case 34:
            R = "&quot;";
            break;
          case 38:
            R = "&amp;";
            break;
          case 39:
            R = "&#x27;";
            break;
          case 60:
            R = "&lt;";
            break;
          case 62:
            R = "&gt;";
            break;
          default:
            continue;
        }
        Te !== Q && (V += x.substring(Te, Q)), Te = Q + 1, V += R;
      }
      x = Te !== Q ? V + x.substring(Te, Q) : V;
    }
    return x;
  }
  var X = /([A-Z])/g, ne = /^ms-/, G = Array.isArray, ce = p("<script>"), q = p("<\/script>"), re = p('<script src="'), $ = p('<script type="module" src="'), j = p('" async=""><\/script>'), oe = /(<\/|<)(s)(cript)/gi;
  function ie(x, R, V, Q) {
    return "" + R + (V === "s" ? "\\u0073" : "\\u0053") + Q;
  }
  function le(x, R, V, Q, Te) {
    x = x === void 0 ? "" : x, R = R === void 0 ? ce : p('<script nonce="' + U(R) + '">');
    var we = [];
    if (V !== void 0 && we.push(R, c(("" + V).replace(oe, ie)), q), Q !== void 0)
      for (V = 0; V < Q.length; V++)
        we.push(re, c(U(Q[V])), j);
    if (Te !== void 0)
      for (Q = 0; Q < Te.length; Q++)
        we.push($, c(U(Te[Q])), j);
    return { bootstrapChunks: we, startInlineScript: R, placeholderPrefix: p(x + "P:"), segmentPrefix: p(x + "S:"), boundaryPrefix: x + "B:", idPrefix: x, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function J(x, R) {
    return { insertionMode: x, selectedValue: R };
  }
  function de(x) {
    return J(x === "http://www.w3.org/2000/svg" ? 2 : x === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function ae(x, R, V) {
    switch (R) {
      case "select":
        return J(1, V.value != null ? V.value : V.defaultValue);
      case "svg":
        return J(2, null);
      case "math":
        return J(3, null);
      case "foreignObject":
        return J(1, null);
      case "table":
        return J(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return J(5, null);
      case "colgroup":
        return J(7, null);
      case "tr":
        return J(6, null);
    }
    return 4 <= x.insertionMode || x.insertionMode === 0 ? J(1, null) : x;
  }
  var Z = p("<!-- -->");
  function ye(x, R, V, Q) {
    return R === "" ? Q : (Q && x.push(Z), x.push(c(U(R))), !0);
  }
  var ue = /* @__PURE__ */ new Map(), ve = p(' style="'), ke = p(":"), me = p(";");
  function Ne(x, R, V) {
    if (typeof V != "object")
      throw Error(t(62));
    R = !0;
    for (var Q in V)
      if (g.call(V, Q)) {
        var Te = V[Q];
        if (Te != null && typeof Te != "boolean" && Te !== "") {
          if (Q.indexOf("--") === 0) {
            var we = c(U(Q));
            Te = c(U(("" + Te).trim()));
          } else {
            we = Q;
            var Pe = ue.get(we);
            Pe !== void 0 || (Pe = p(U(we.replace(X, "-$1").toLowerCase().replace(ne, "-ms-"))), ue.set(we, Pe)), we = Pe, Te = typeof Te == "number" ? Te === 0 || g.call(D, Q) ? c("" + Te) : c(Te + "px") : c(U(("" + Te).trim()));
          }
          R ? (R = !1, x.push(ve, we, ke, Te)) : x.push(me, we, ke, Te);
        }
      }
    R || x.push(Xe);
  }
  var Ee = p(" "), De = p('="'), Xe = p('"'), Fe = p('=""');
  function Je(x, R, V, Q) {
    switch (V) {
      case "style":
        Ne(x, R, Q);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < V.length) || V[0] !== "o" && V[0] !== "O" || V[1] !== "n" && V[1] !== "N") {
      if (R = S.hasOwnProperty(V) ? S[V] : null, R !== null) {
        switch (typeof Q) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!R.acceptsBooleans)
              return;
        }
        switch (V = c(R.attributeName), R.type) {
          case 3:
            Q && x.push(Ee, V, Fe);
            break;
          case 4:
            Q === !0 ? x.push(Ee, V, Fe) : Q !== !1 && x.push(Ee, V, De, c(U(Q)), Xe);
            break;
          case 5:
            isNaN(Q) || x.push(Ee, V, De, c(U(Q)), Xe);
            break;
          case 6:
            !isNaN(Q) && 1 <= Q && x.push(Ee, V, De, c(U(Q)), Xe);
            break;
          default:
            R.sanitizeURL && (Q = "" + Q), x.push(Ee, V, De, c(U(Q)), Xe);
        }
      } else if (C(V)) {
        switch (typeof Q) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (R = V.toLowerCase().slice(0, 5), R !== "data-" && R !== "aria-")
              return;
        }
        x.push(Ee, c(V), De, c(U(Q)), Xe);
      }
    }
  }
  var gt = p(">"), mt = p("/>");
  function yt(x, R, V) {
    if (R != null) {
      if (V != null)
        throw Error(t(60));
      if (typeof R != "object" || !("__html" in R))
        throw Error(t(61));
      R = R.__html, R != null && x.push(c("" + R));
    }
  }
  function Ye(x) {
    var R = "";
    return e.Children.forEach(x, function(V) {
      V != null && (R += V);
    }), R;
  }
  var ot = p(' selected=""');
  function ut(x, R, V, Q) {
    x.push(it(V));
    var Te = V = null, we;
    for (we in R)
      if (g.call(R, we)) {
        var Pe = R[we];
        if (Pe != null)
          switch (we) {
            case "children":
              V = Pe;
              break;
            case "dangerouslySetInnerHTML":
              Te = Pe;
              break;
            default:
              Je(x, Q, we, Pe);
          }
      }
    return x.push(gt), yt(x, Te, V), typeof V == "string" ? (x.push(c(U(V))), null) : V;
  }
  var st = p(`
`), tt = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, $e = /* @__PURE__ */ new Map();
  function it(x) {
    var R = $e.get(x);
    if (R === void 0) {
      if (!tt.test(x))
        throw Error(t(65, x));
      R = p("<" + x), $e.set(x, R);
    }
    return R;
  }
  var ht = p("<!DOCTYPE html>");
  function Ce(x, R, V, Q, Te) {
    switch (R) {
      case "select":
        x.push(it("select"));
        var we = null, Pe = null;
        for (kt in V)
          if (g.call(V, kt)) {
            var He = V[kt];
            if (He != null)
              switch (kt) {
                case "children":
                  we = He;
                  break;
                case "dangerouslySetInnerHTML":
                  Pe = He;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  Je(x, Q, kt, He);
              }
          }
        return x.push(gt), yt(x, Pe, we), we;
      case "option":
        Pe = Te.selectedValue, x.push(it("option"));
        var vt = He = null, Ct = null, kt = null;
        for (we in V)
          if (g.call(V, we)) {
            var en = V[we];
            if (en != null)
              switch (we) {
                case "children":
                  He = en;
                  break;
                case "selected":
                  Ct = en;
                  break;
                case "dangerouslySetInnerHTML":
                  kt = en;
                  break;
                case "value":
                  vt = en;
                default:
                  Je(x, Q, we, en);
              }
          }
        if (Pe != null)
          if (V = vt !== null ? "" + vt : Ye(He), G(Pe)) {
            for (Q = 0; Q < Pe.length; Q++)
              if ("" + Pe[Q] === V) {
                x.push(ot);
                break;
              }
          } else
            "" + Pe === V && x.push(ot);
        else
          Ct && x.push(ot);
        return x.push(gt), yt(x, kt, He), He;
      case "textarea":
        x.push(it("textarea")), kt = Pe = we = null;
        for (He in V)
          if (g.call(V, He) && (vt = V[He], vt != null))
            switch (He) {
              case "children":
                kt = vt;
                break;
              case "value":
                we = vt;
                break;
              case "defaultValue":
                Pe = vt;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(91));
              default:
                Je(x, Q, He, vt);
            }
        if (we === null && Pe !== null && (we = Pe), x.push(gt), kt != null) {
          if (we != null)
            throw Error(t(92));
          if (G(kt) && 1 < kt.length)
            throw Error(t(93));
          we = "" + kt;
        }
        return typeof we == "string" && we[0] === `
` && x.push(st), we !== null && x.push(c(U("" + we))), null;
      case "input":
        x.push(it("input")), vt = kt = He = we = null;
        for (Pe in V)
          if (g.call(V, Pe) && (Ct = V[Pe], Ct != null))
            switch (Pe) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, "input"));
              case "defaultChecked":
                vt = Ct;
                break;
              case "defaultValue":
                He = Ct;
                break;
              case "checked":
                kt = Ct;
                break;
              case "value":
                we = Ct;
                break;
              default:
                Je(x, Q, Pe, Ct);
            }
        return kt !== null ? Je(
          x,
          Q,
          "checked",
          kt
        ) : vt !== null && Je(x, Q, "checked", vt), we !== null ? Je(x, Q, "value", we) : He !== null && Je(x, Q, "value", He), x.push(mt), null;
      case "menuitem":
        x.push(it("menuitem"));
        for (var Gn in V)
          if (g.call(V, Gn) && (we = V[Gn], we != null))
            switch (Gn) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(400));
              default:
                Je(x, Q, Gn, we);
            }
        return x.push(gt), null;
      case "title":
        x.push(it("title")), we = null;
        for (en in V)
          if (g.call(V, en) && (Pe = V[en], Pe != null))
            switch (en) {
              case "children":
                we = Pe;
                break;
              case "dangerouslySetInnerHTML":
                throw Error(t(434));
              default:
                Je(x, Q, en, Pe);
            }
        return x.push(gt), we;
      case "listing":
      case "pre":
        x.push(it(R)), Pe = we = null;
        for (vt in V)
          if (g.call(V, vt) && (He = V[vt], He != null))
            switch (vt) {
              case "children":
                we = He;
                break;
              case "dangerouslySetInnerHTML":
                Pe = He;
                break;
              default:
                Je(x, Q, vt, He);
            }
        if (x.push(gt), Pe != null) {
          if (we != null)
            throw Error(t(60));
          if (typeof Pe != "object" || !("__html" in Pe))
            throw Error(t(61));
          V = Pe.__html, V != null && (typeof V == "string" && 0 < V.length && V[0] === `
` ? x.push(st, c(V)) : x.push(c("" + V)));
        }
        return typeof we == "string" && we[0] === `
` && x.push(st), we;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        x.push(it(R));
        for (var lr in V)
          if (g.call(V, lr) && (we = V[lr], we != null))
            switch (lr) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(t(399, R));
              default:
                Je(x, Q, lr, we);
            }
        return x.push(mt), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return ut(x, V, R, Q);
      case "html":
        return Te.insertionMode === 0 && x.push(ht), ut(x, V, R, Q);
      default:
        if (R.indexOf("-") === -1 && typeof V.is != "string")
          return ut(x, V, R, Q);
        x.push(it(R)), Pe = we = null;
        for (Ct in V)
          if (g.call(V, Ct) && (He = V[Ct], He != null))
            switch (Ct) {
              case "children":
                we = He;
                break;
              case "dangerouslySetInnerHTML":
                Pe = He;
                break;
              case "style":
                Ne(x, Q, He);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                C(Ct) && typeof He != "function" && typeof He != "symbol" && x.push(Ee, c(Ct), De, c(U(He)), Xe);
            }
        return x.push(gt), yt(x, Pe, we), we;
    }
  }
  var Ht = p("</"), vn = p(">"), pt = p('<template id="'), hn = p('"></template>'), yn = p("<!--$-->"), Vt = p('<!--$?--><template id="'), zt = p('"></template>'), Cn = p("<!--$!-->"), qt = p("<!--/$-->"), Ft = p("<template"), Gt = p('"'), Zt = p(' data-dgst="');
  p(' data-msg="'), p(' data-stck="');
  var gn = p("></template>");
  function Pt(x, R, V) {
    if (i(x, Vt), V === null)
      throw Error(t(395));
    return i(x, V), o(x, zt);
  }
  var Qt = p('<div hidden id="'), Rt = p('">'), bt = p("</div>"), lt = p('<svg aria-hidden="true" style="display:none" id="'), Se = p('">'), _e = p("</svg>"), xe = p('<math aria-hidden="true" style="display:none" id="'), Ge = p('">'), Ze = p("</math>"), et = p('<table hidden id="'), Nt = p('">'), Wt = p("</table>"), xt = p('<table hidden><tbody id="'), at = p('">'), un = p("</tbody></table>"), jt = p('<table hidden><tr id="'), An = p('">'), wt = p("</tr></table>"), Lt = p('<table hidden><colgroup id="'), bn = p('">'), $n = p("</colgroup></table>");
  function Ln(x, R, V, Q) {
    switch (V.insertionMode) {
      case 0:
      case 1:
        return i(x, Qt), i(x, R.segmentPrefix), i(x, c(Q.toString(16))), o(x, Rt);
      case 2:
        return i(x, lt), i(x, R.segmentPrefix), i(x, c(Q.toString(16))), o(x, Se);
      case 3:
        return i(x, xe), i(x, R.segmentPrefix), i(x, c(Q.toString(16))), o(x, Ge);
      case 4:
        return i(x, et), i(x, R.segmentPrefix), i(x, c(Q.toString(16))), o(x, Nt);
      case 5:
        return i(x, xt), i(x, R.segmentPrefix), i(x, c(Q.toString(16))), o(x, at);
      case 6:
        return i(x, jt), i(x, R.segmentPrefix), i(x, c(Q.toString(16))), o(x, An);
      case 7:
        return i(
          x,
          Lt
        ), i(x, R.segmentPrefix), i(x, c(Q.toString(16))), o(x, bn);
      default:
        throw Error(t(397));
    }
  }
  function En(x, R) {
    switch (R.insertionMode) {
      case 0:
      case 1:
        return o(x, bt);
      case 2:
        return o(x, _e);
      case 3:
        return o(x, Ze);
      case 4:
        return o(x, Wt);
      case 5:
        return o(x, un);
      case 6:
        return o(x, wt);
      case 7:
        return o(x, $n);
      default:
        throw Error(t(397));
    }
  }
  var nr = p('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Yn = p('$RS("'), _n = p('","'), fn = p('")<\/script>'), _t = p('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Jt = p('$RC("'), Yt = p('","'), on = p('")<\/script>'), wn = p('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Ut = p('$RX("'), sn = p('"'), pn = p(")<\/script>"), Bt = p(","), rr = /[<\u2028\u2029]/g;
  function Mn(x) {
    return JSON.stringify(x).replace(rr, function(R) {
      switch (R) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var Pn = Object.assign, cn = Symbol.for("react.element"), Hn = Symbol.for("react.portal"), Vn = Symbol.for("react.fragment"), yr = Symbol.for("react.strict_mode"), gr = Symbol.for("react.profiler"), ir = Symbol.for("react.provider"), Wn = Symbol.for("react.context"), ar = Symbol.for("react.forward_ref"), Xn = Symbol.for("react.suspense"), qn = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), P = Symbol.for("react.lazy"), _ = Symbol.for("react.scope"), W = Symbol.for("react.debug_trace_mode"), he = Symbol.for("react.legacy_hidden"), N = Symbol.for("react.default_value"), z = Symbol.iterator;
  function Y(x) {
    if (x == null)
      return null;
    if (typeof x == "function")
      return x.displayName || x.name || null;
    if (typeof x == "string")
      return x;
    switch (x) {
      case Vn:
        return "Fragment";
      case Hn:
        return "Portal";
      case gr:
        return "Profiler";
      case yr:
        return "StrictMode";
      case Xn:
        return "Suspense";
      case qn:
        return "SuspenseList";
    }
    if (typeof x == "object")
      switch (x.$$typeof) {
        case Wn:
          return (x.displayName || "Context") + ".Consumer";
        case ir:
          return (x._context.displayName || "Context") + ".Provider";
        case ar:
          var R = x.render;
          return x = x.displayName, x || (x = R.displayName || R.name || "", x = x !== "" ? "ForwardRef(" + x + ")" : "ForwardRef"), x;
        case v:
          return R = x.displayName || null, R !== null ? R : Y(x.type) || "Memo";
        case P:
          R = x._payload, x = x._init;
          try {
            return Y(x(R));
          } catch {
          }
      }
    return null;
  }
  var be = {};
  function Oe(x, R) {
    if (x = x.contextTypes, !x)
      return be;
    var V = {}, Q;
    for (Q in x)
      V[Q] = R[Q];
    return V;
  }
  var We = null;
  function rt(x, R) {
    if (x !== R) {
      x.context._currentValue = x.parentValue, x = x.parent;
      var V = R.parent;
      if (x === null) {
        if (V !== null)
          throw Error(t(401));
      } else {
        if (V === null)
          throw Error(t(401));
        rt(x, V);
      }
      R.context._currentValue = R.value;
    }
  }
  function Dt(x) {
    x.context._currentValue = x.parentValue, x = x.parent, x !== null && Dt(x);
  }
  function Mt(x) {
    var R = x.parent;
    R !== null && Mt(R), x.context._currentValue = x.value;
  }
  function dn(x, R) {
    if (x.context._currentValue = x.parentValue, x = x.parent, x === null)
      throw Error(t(402));
    x.depth === R.depth ? rt(x, R) : dn(x, R);
  }
  function Xt(x, R) {
    var V = R.parent;
    if (V === null)
      throw Error(t(402));
    x.depth === V.depth ? rt(x, V) : Xt(x, V), R.context._currentValue = R.value;
  }
  function tn(x) {
    var R = We;
    R !== x && (R === null ? Mt(x) : x === null ? Dt(R) : R.depth === x.depth ? rt(R, x) : R.depth > x.depth ? dn(R, x) : Xt(R, x), We = x);
  }
  var Zn = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(x, R) {
    x = x._reactInternals, x.queue !== null && x.queue.push(R);
  }, enqueueReplaceState: function(x, R) {
    x = x._reactInternals, x.replace = !0, x.queue = [R];
  }, enqueueForceUpdate: function() {
  } };
  function In(x, R, V, Q) {
    var Te = x.state !== void 0 ? x.state : null;
    x.updater = Zn, x.props = V, x.state = Te;
    var we = { queue: [], replace: !1 };
    x._reactInternals = we;
    var Pe = R.contextType;
    if (x.context = typeof Pe == "object" && Pe !== null ? Pe._currentValue : Q, Pe = R.getDerivedStateFromProps, typeof Pe == "function" && (Pe = Pe(V, Te), Te = Pe == null ? Te : Pn({}, Te, Pe), x.state = Te), typeof R.getDerivedStateFromProps != "function" && typeof x.getSnapshotBeforeUpdate != "function" && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function"))
      if (R = x.state, typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount(), R !== x.state && Zn.enqueueReplaceState(x, x.state, null), we.queue !== null && 0 < we.queue.length)
        if (R = we.queue, Pe = we.replace, we.queue = null, we.replace = !1, Pe && R.length === 1)
          x.state = R[0];
        else {
          for (we = Pe ? R[0] : x.state, Te = !0, Pe = Pe ? 1 : 0; Pe < R.length; Pe++) {
            var He = R[Pe];
            He = typeof He == "function" ? He.call(x, we, V, Q) : He, He != null && (Te ? (Te = !1, we = Pn({}, we, He)) : Pn(we, He));
          }
          x.state = we;
        }
      else
        we.queue = null;
  }
  var or = { id: 1, overflow: "" };
  function jn(x, R, V) {
    var Q = x.id;
    x = x.overflow;
    var Te = 32 - Ar(Q) - 1;
    Q &= ~(1 << Te), V += 1;
    var we = 32 - Ar(R) + Te;
    if (30 < we) {
      var Pe = Te - Te % 5;
      return we = (Q & (1 << Pe) - 1).toString(32), Q >>= Pe, Te -= Pe, { id: 1 << 32 - Ar(R) + Te | V << Te | Q, overflow: we + x };
    }
    return { id: 1 << we | V << Te | Q, overflow: x };
  }
  var Ar = Math.clz32 ? Math.clz32 : qr, ui = Math.log, na = Math.LN2;
  function qr(x) {
    return x >>>= 0, x === 0 ? 32 : 31 - (ui(x) / na | 0) | 0;
  }
  function Tt(x, R) {
    return x === R && (x !== 0 || 1 / x === 1 / R) || x !== x && R !== R;
  }
  var xn = typeof Object.is == "function" ? Object.is : Tt, Un = null, Lr = null, Zr = null, $t = null, vr = !1, kn = !1, Er = 0, Nr = null, Ci = 0;
  function Rr() {
    if (Un === null)
      throw Error(t(321));
    return Un;
  }
  function sr() {
    if (0 < Ci)
      throw Error(t(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function ra() {
    return $t === null ? Zr === null ? (vr = !1, Zr = $t = sr()) : (vr = !0, $t = Zr) : $t.next === null ? (vr = !1, $t = $t.next = sr()) : (vr = !0, $t = $t.next), $t;
  }
  function ia() {
    Lr = Un = null, kn = !1, Zr = null, Ci = 0, $t = Nr = null;
  }
  function Ga(x, R) {
    return typeof R == "function" ? R(x) : R;
  }
  function Ya(x, R, V) {
    if (Un = Rr(), $t = ra(), vr) {
      var Q = $t.queue;
      if (R = Q.dispatch, Nr !== null && (V = Nr.get(Q), V !== void 0)) {
        Nr.delete(Q), Q = $t.memoizedState;
        do
          Q = x(Q, V.action), V = V.next;
        while (V !== null);
        return $t.memoizedState = Q, [Q, R];
      }
      return [$t.memoizedState, R];
    }
    return x = x === Ga ? typeof R == "function" ? R() : R : V !== void 0 ? V(R) : R, $t.memoizedState = x, x = $t.queue = { last: null, dispatch: null }, x = x.dispatch = ds.bind(null, Un, x), [$t.memoizedState, x];
  }
  function Xa(x, R) {
    if (Un = Rr(), $t = ra(), R = R === void 0 ? null : R, $t !== null) {
      var V = $t.memoizedState;
      if (V !== null && R !== null) {
        var Q = V[1];
        e:
          if (Q === null)
            Q = !1;
          else {
            for (var Te = 0; Te < Q.length && Te < R.length; Te++)
              if (!xn(R[Te], Q[Te])) {
                Q = !1;
                break e;
              }
            Q = !0;
          }
        if (Q)
          return V[0];
      }
    }
    return x = x(), $t.memoizedState = [x, R], x;
  }
  function ds(x, R, V) {
    if (25 <= Ci)
      throw Error(t(301));
    if (x === Un)
      if (kn = !0, x = { action: V, next: null }, Nr === null && (Nr = /* @__PURE__ */ new Map()), V = Nr.get(R), V === void 0)
        Nr.set(R, x);
      else {
        for (R = V; R.next !== null; )
          R = R.next;
        R.next = x;
      }
  }
  function hs() {
    throw Error(t(394));
  }
  function Ai() {
  }
  var Li = { readContext: function(x) {
    return x._currentValue;
  }, useContext: function(x) {
    return Rr(), x._currentValue;
  }, useMemo: Xa, useReducer: Ya, useRef: function(x) {
    Un = Rr(), $t = ra();
    var R = $t.memoizedState;
    return R === null ? (x = { current: x }, $t.memoizedState = x) : R;
  }, useState: function(x) {
    return Ya(Ga, x);
  }, useInsertionEffect: Ai, useLayoutEffect: function() {
  }, useCallback: function(x, R) {
    return Xa(function() {
      return x;
    }, R);
  }, useImperativeHandle: Ai, useEffect: Ai, useDebugValue: Ai, useDeferredValue: function(x) {
    return Rr(), x;
  }, useTransition: function() {
    return Rr(), [!1, hs];
  }, useId: function() {
    var x = Lr.treeContext, R = x.overflow;
    x = x.id, x = (x & ~(1 << 32 - Ar(x) - 1)).toString(32) + R;
    var V = Ei;
    if (V === null)
      throw Error(t(404));
    return R = Er++, x = ":" + V.idPrefix + "R" + x, 0 < R && (x += "H" + R.toString(32)), x + ":";
  }, useMutableSource: function(x, R) {
    return Rr(), R(x._source);
  }, useSyncExternalStore: function(x, R, V) {
    if (V === void 0)
      throw Error(t(407));
    return V();
  } }, Ei = null, ci = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function fs(x) {
    return console.error(x), null;
  }
  function di() {
  }
  function aa(x, R, V, Q, Te, we, Pe, He, vt) {
    var Ct = [], kt = /* @__PURE__ */ new Set();
    return R = { destination: null, responseState: R, progressiveChunkSize: Q === void 0 ? 12800 : Q, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: kt, pingedTasks: Ct, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Te === void 0 ? fs : Te, onAllReady: we === void 0 ? di : we, onShellReady: Pe === void 0 ? di : Pe, onShellError: He === void 0 ? di : He, onFatalError: vt === void 0 ? di : vt }, V = Qr(R, 0, null, V, !1, !1), V.parentFlushed = !0, x = oa(R, x, null, V, kt, be, null, or), Ct.push(x), R;
  }
  function oa(x, R, V, Q, Te, we, Pe, He) {
    x.allPendingTasks++, V === null ? x.pendingRootTasks++ : V.pendingTasks++;
    var vt = { node: R, ping: function() {
      var Ct = x.pingedTasks;
      Ct.push(vt), Ct.length === 1 && to(x);
    }, blockedBoundary: V, blockedSegment: Q, abortSet: Te, legacyContext: we, context: Pe, treeContext: He };
    return Te.add(vt), vt;
  }
  function Qr(x, R, V, Q, Te, we) {
    return { status: 0, id: -1, index: R, parentFlushed: !1, chunks: [], children: [], formatContext: Q, boundary: V, lastPushedText: Te, textEmbedded: we };
  }
  function Jr(x, R) {
    if (x = x.onError(R), x != null && typeof x != "string")
      throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof x + '" instead');
    return x;
  }
  function _i(x, R) {
    var V = x.onShellError;
    V(R), V = x.onFatalError, V(R), x.destination !== null ? (x.status = 2, y(x.destination, R)) : (x.status = 1, x.fatalError = R);
  }
  function qa(x, R, V, Q, Te) {
    for (Un = {}, Lr = R, Er = 0, x = V(Q, Te); kn; )
      kn = !1, Er = 0, Ci += 1, $t = null, x = V(Q, Te);
    return ia(), x;
  }
  function sa(x, R, V, Q) {
    var Te = V.render(), we = Q.childContextTypes;
    if (we != null) {
      var Pe = R.legacyContext;
      if (typeof V.getChildContext != "function")
        Q = Pe;
      else {
        V = V.getChildContext();
        for (var He in V)
          if (!(He in we))
            throw Error(t(108, Y(Q) || "Unknown", He));
        Q = Pn({}, Pe, V);
      }
      R.legacyContext = Q, Kn(x, R, Te), R.legacyContext = Pe;
    } else
      Kn(x, R, Te);
  }
  function Za(x, R) {
    if (x && x.defaultProps) {
      R = Pn({}, R), x = x.defaultProps;
      for (var V in x)
        R[V] === void 0 && (R[V] = x[V]);
      return R;
    }
    return R;
  }
  function Pi(x, R, V, Q, Te) {
    if (typeof V == "function")
      if (V.prototype && V.prototype.isReactComponent) {
        Te = Oe(V, R.legacyContext);
        var we = V.contextType;
        we = new V(Q, typeof we == "object" && we !== null ? we._currentValue : Te), In(we, V, Q, Te), sa(x, R, we, V);
      } else {
        we = Oe(V, R.legacyContext), Te = qa(x, R, V, Q, we);
        var Pe = Er !== 0;
        if (typeof Te == "object" && Te !== null && typeof Te.render == "function" && Te.$$typeof === void 0)
          In(Te, V, Q, we), sa(x, R, Te, V);
        else if (Pe) {
          Q = R.treeContext, R.treeContext = jn(Q, 1, 0);
          try {
            Kn(x, R, Te);
          } finally {
            R.treeContext = Q;
          }
        } else
          Kn(x, R, Te);
      }
    else if (typeof V == "string") {
      switch (Te = R.blockedSegment, we = Ce(Te.chunks, V, Q, x.responseState, Te.formatContext), Te.lastPushedText = !1, Pe = Te.formatContext, Te.formatContext = ae(Pe, V, Q), Ni(x, R, we), Te.formatContext = Pe, V) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Te.chunks.push(Ht, c(V), vn);
      }
      Te.lastPushedText = !1;
    } else {
      switch (V) {
        case he:
        case W:
        case yr:
        case gr:
        case Vn:
          Kn(x, R, Q.children);
          return;
        case qn:
          Kn(x, R, Q.children);
          return;
        case _:
          throw Error(t(343));
        case Xn:
          e: {
            V = R.blockedBoundary, Te = R.blockedSegment, we = Q.fallback, Q = Q.children, Pe = /* @__PURE__ */ new Set();
            var He = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Pe, errorDigest: null }, vt = Qr(x, Te.chunks.length, He, Te.formatContext, !1, !1);
            Te.children.push(vt), Te.lastPushedText = !1;
            var Ct = Qr(x, 0, null, Te.formatContext, !1, !1);
            Ct.parentFlushed = !0, R.blockedBoundary = He, R.blockedSegment = Ct;
            try {
              if (Ni(
                x,
                R,
                Q
              ), Ct.lastPushedText && Ct.textEmbedded && Ct.chunks.push(Z), Ct.status = 1, Ri(He, Ct), He.pendingTasks === 0)
                break e;
            } catch (kt) {
              Ct.status = 4, He.forceClientRender = !0, He.errorDigest = Jr(x, kt);
            } finally {
              R.blockedBoundary = V, R.blockedSegment = Te;
            }
            R = oa(x, we, V, vt, Pe, R.legacyContext, R.context, R.treeContext), x.pingedTasks.push(R);
          }
          return;
      }
      if (typeof V == "object" && V !== null)
        switch (V.$$typeof) {
          case ar:
            if (Q = qa(x, R, V.render, Q, Te), Er !== 0) {
              V = R.treeContext, R.treeContext = jn(V, 1, 0);
              try {
                Kn(x, R, Q);
              } finally {
                R.treeContext = V;
              }
            } else
              Kn(x, R, Q);
            return;
          case v:
            V = V.type, Q = Za(V, Q), Pi(x, R, V, Q, Te);
            return;
          case ir:
            if (Te = Q.children, V = V._context, Q = Q.value, we = V._currentValue, V._currentValue = Q, Pe = We, We = Q = { parent: Pe, depth: Pe === null ? 0 : Pe.depth + 1, context: V, parentValue: we, value: Q }, R.context = Q, Kn(x, R, Te), x = We, x === null)
              throw Error(t(403));
            Q = x.parentValue, x.context._currentValue = Q === N ? x.context._defaultValue : Q, x = We = x.parent, R.context = x;
            return;
          case Wn:
            Q = Q.children, Q = Q(V._currentValue), Kn(x, R, Q);
            return;
          case P:
            Te = V._init, V = Te(V._payload), Q = Za(V, Q), Pi(x, R, V, Q, void 0);
            return;
        }
      throw Error(t(
        130,
        V == null ? V : typeof V,
        ""
      ));
    }
  }
  function Kn(x, R, V) {
    if (R.node = V, typeof V == "object" && V !== null) {
      switch (V.$$typeof) {
        case cn:
          Pi(x, R, V.type, V.props, V.ref);
          return;
        case Hn:
          throw Error(t(257));
        case P:
          var Q = V._init;
          V = Q(V._payload), Kn(x, R, V);
          return;
      }
      if (G(V)) {
        Qa(x, R, V);
        return;
      }
      if (V === null || typeof V != "object" ? Q = null : (Q = z && V[z] || V["@@iterator"], Q = typeof Q == "function" ? Q : null), Q && (Q = Q.call(V))) {
        if (V = Q.next(), !V.done) {
          var Te = [];
          do
            Te.push(V.value), V = Q.next();
          while (!V.done);
          Qa(x, R, Te);
        }
        return;
      }
      throw x = Object.prototype.toString.call(V), Error(t(31, x === "[object Object]" ? "object with keys {" + Object.keys(V).join(", ") + "}" : x));
    }
    typeof V == "string" ? (Q = R.blockedSegment, Q.lastPushedText = ye(R.blockedSegment.chunks, V, x.responseState, Q.lastPushedText)) : typeof V == "number" && (Q = R.blockedSegment, Q.lastPushedText = ye(R.blockedSegment.chunks, "" + V, x.responseState, Q.lastPushedText));
  }
  function Qa(x, R, V) {
    for (var Q = V.length, Te = 0; Te < Q; Te++) {
      var we = R.treeContext;
      R.treeContext = jn(we, Q, Te);
      try {
        Ni(x, R, V[Te]);
      } finally {
        R.treeContext = we;
      }
    }
  }
  function Ni(x, R, V) {
    var Q = R.blockedSegment.formatContext, Te = R.legacyContext, we = R.context;
    try {
      return Kn(x, R, V);
    } catch (vt) {
      if (ia(), typeof vt == "object" && vt !== null && typeof vt.then == "function") {
        V = vt;
        var Pe = R.blockedSegment, He = Qr(x, Pe.chunks.length, null, Pe.formatContext, Pe.lastPushedText, !0);
        Pe.children.push(He), Pe.lastPushedText = !1, x = oa(x, R.node, R.blockedBoundary, He, R.abortSet, R.legacyContext, R.context, R.treeContext).ping, V.then(x, x), R.blockedSegment.formatContext = Q, R.legacyContext = Te, R.context = we, tn(we);
      } else
        throw R.blockedSegment.formatContext = Q, R.legacyContext = Te, R.context = we, tn(we), vt;
    }
  }
  function ps(x) {
    var R = x.blockedBoundary;
    x = x.blockedSegment, x.status = 3, eo(this, R, x);
  }
  function Ja(x, R, V) {
    var Q = x.blockedBoundary;
    x.blockedSegment.status = 3, Q === null ? (R.allPendingTasks--, R.status !== 2 && (R.status = 2, R.destination !== null && R.destination.close())) : (Q.pendingTasks--, Q.forceClientRender || (Q.forceClientRender = !0, x = V === void 0 ? Error(t(432)) : V, Q.errorDigest = R.onError(x), Q.parentFlushed && R.clientRenderedBoundaries.push(Q)), Q.fallbackAbortableTasks.forEach(function(Te) {
      return Ja(Te, R, V);
    }), Q.fallbackAbortableTasks.clear(), R.allPendingTasks--, R.allPendingTasks === 0 && (Q = R.onAllReady, Q()));
  }
  function Ri(x, R) {
    if (R.chunks.length === 0 && R.children.length === 1 && R.children[0].boundary === null) {
      var V = R.children[0];
      V.id = R.id, V.parentFlushed = !0, V.status === 1 && Ri(x, V);
    } else
      x.completedSegments.push(R);
  }
  function eo(x, R, V) {
    if (R === null) {
      if (V.parentFlushed) {
        if (x.completedRootSegment !== null)
          throw Error(t(389));
        x.completedRootSegment = V;
      }
      x.pendingRootTasks--, x.pendingRootTasks === 0 && (x.onShellError = di, R = x.onShellReady, R());
    } else
      R.pendingTasks--, R.forceClientRender || (R.pendingTasks === 0 ? (V.parentFlushed && V.status === 1 && Ri(R, V), R.parentFlushed && x.completedBoundaries.push(R), R.fallbackAbortableTasks.forEach(ps, x), R.fallbackAbortableTasks.clear()) : V.parentFlushed && V.status === 1 && (Ri(R, V), R.completedSegments.length === 1 && R.parentFlushed && x.partialBoundaries.push(R)));
    x.allPendingTasks--, x.allPendingTasks === 0 && (x = x.onAllReady, x());
  }
  function to(x) {
    if (x.status !== 2) {
      var R = We, V = ci.current;
      ci.current = Li;
      var Q = Ei;
      Ei = x.responseState;
      try {
        var Te = x.pingedTasks, we;
        for (we = 0; we < Te.length; we++) {
          var Pe = Te[we], He = x, vt = Pe.blockedSegment;
          if (vt.status === 0) {
            tn(Pe.context);
            try {
              Kn(He, Pe, Pe.node), vt.lastPushedText && vt.textEmbedded && vt.chunks.push(Z), Pe.abortSet.delete(Pe), vt.status = 1, eo(He, Pe.blockedBoundary, vt);
            } catch (ur) {
              if (ia(), typeof ur == "object" && ur !== null && typeof ur.then == "function") {
                var Ct = Pe.ping;
                ur.then(Ct, Ct);
              } else {
                Pe.abortSet.delete(Pe), vt.status = 4;
                var kt = Pe.blockedBoundary, en = ur, Gn = Jr(He, en);
                if (kt === null ? _i(He, en) : (kt.pendingTasks--, kt.forceClientRender || (kt.forceClientRender = !0, kt.errorDigest = Gn, kt.parentFlushed && He.clientRenderedBoundaries.push(kt))), He.allPendingTasks--, He.allPendingTasks === 0) {
                  var lr = He.onAllReady;
                  lr();
                }
              }
            } finally {
            }
          }
        }
        Te.splice(0, we), x.destination !== null && la(x, x.destination);
      } catch (ur) {
        Jr(x, ur), _i(x, ur);
      } finally {
        Ei = Q, ci.current = V, V === Li && tn(R);
      }
    }
  }
  function Di(x, R, V) {
    switch (V.parentFlushed = !0, V.status) {
      case 0:
        var Q = V.id = x.nextSegmentId++;
        return V.lastPushedText = !1, V.textEmbedded = !1, x = x.responseState, i(R, pt), i(R, x.placeholderPrefix), x = c(Q.toString(16)), i(R, x), o(R, hn);
      case 1:
        V.status = 2;
        var Te = !0;
        Q = V.chunks;
        var we = 0;
        V = V.children;
        for (var Pe = 0; Pe < V.length; Pe++) {
          for (Te = V[Pe]; we < Te.index; we++)
            i(R, Q[we]);
          Te = Oi(x, R, Te);
        }
        for (; we < Q.length - 1; we++)
          i(R, Q[we]);
        return we < Q.length && (Te = o(R, Q[we])), Te;
      default:
        throw Error(t(390));
    }
  }
  function Oi(x, R, V) {
    var Q = V.boundary;
    if (Q === null)
      return Di(x, R, V);
    if (Q.parentFlushed = !0, Q.forceClientRender)
      Q = Q.errorDigest, o(R, Cn), i(R, Ft), Q && (i(R, Zt), i(R, c(U(Q))), i(R, Gt)), o(R, gn), Di(x, R, V);
    else if (0 < Q.pendingTasks) {
      Q.rootSegmentID = x.nextSegmentId++, 0 < Q.completedSegments.length && x.partialBoundaries.push(Q);
      var Te = x.responseState, we = Te.nextSuspenseID++;
      Te = p(Te.boundaryPrefix + we.toString(16)), Q = Q.id = Te, Pt(R, x.responseState, Q), Di(x, R, V);
    } else if (Q.byteSize > x.progressiveChunkSize)
      Q.rootSegmentID = x.nextSegmentId++, x.completedBoundaries.push(Q), Pt(R, x.responseState, Q.id), Di(x, R, V);
    else {
      if (o(R, yn), V = Q.completedSegments, V.length !== 1)
        throw Error(t(391));
      Oi(x, R, V[0]);
    }
    return o(R, qt);
  }
  function no(x, R, V) {
    return Ln(R, x.responseState, V.formatContext, V.id), Oi(x, R, V), En(R, V.formatContext);
  }
  function ro(x, R, V) {
    for (var Q = V.completedSegments, Te = 0; Te < Q.length; Te++)
      io(x, R, V, Q[Te]);
    if (Q.length = 0, x = x.responseState, Q = V.id, V = V.rootSegmentID, i(R, x.startInlineScript), x.sentCompleteBoundaryFunction ? i(R, Jt) : (x.sentCompleteBoundaryFunction = !0, i(R, _t)), Q === null)
      throw Error(t(395));
    return V = c(V.toString(16)), i(R, Q), i(R, Yt), i(R, x.segmentPrefix), i(R, V), o(R, on);
  }
  function io(x, R, V, Q) {
    if (Q.status === 2)
      return !0;
    var Te = Q.id;
    if (Te === -1) {
      if ((Q.id = V.rootSegmentID) === -1)
        throw Error(t(392));
      return no(x, R, Q);
    }
    return no(x, R, Q), x = x.responseState, i(R, x.startInlineScript), x.sentCompleteSegmentFunction ? i(R, Yn) : (x.sentCompleteSegmentFunction = !0, i(R, nr)), i(R, x.segmentPrefix), Te = c(Te.toString(16)), i(R, Te), i(R, _n), i(R, x.placeholderPrefix), i(R, Te), o(R, fn);
  }
  function la(x, R) {
    n = new Uint8Array(512), r = 0;
    try {
      var V = x.completedRootSegment;
      if (V !== null && x.pendingRootTasks === 0) {
        Oi(x, R, V), x.completedRootSegment = null;
        var Q = x.responseState.bootstrapChunks;
        for (V = 0; V < Q.length - 1; V++)
          i(R, Q[V]);
        V < Q.length && o(R, Q[V]);
      }
      var Te = x.clientRenderedBoundaries, we;
      for (we = 0; we < Te.length; we++) {
        var Pe = Te[we];
        Q = R;
        var He = x.responseState, vt = Pe.id, Ct = Pe.errorDigest, kt = Pe.errorMessage, en = Pe.errorComponentStack;
        if (i(Q, He.startInlineScript), He.sentClientRenderFunction ? i(Q, Ut) : (He.sentClientRenderFunction = !0, i(
          Q,
          wn
        )), vt === null)
          throw Error(t(395));
        i(Q, vt), i(Q, sn), (Ct || kt || en) && (i(Q, Bt), i(Q, c(Mn(Ct || "")))), (kt || en) && (i(Q, Bt), i(Q, c(Mn(kt || "")))), en && (i(Q, Bt), i(Q, c(Mn(en)))), o(Q, pn);
      }
      Te.splice(0, we);
      var Gn = x.completedBoundaries;
      for (we = 0; we < Gn.length; we++)
        ro(x, R, Gn[we]);
      Gn.splice(0, we), h(R), n = new Uint8Array(512), r = 0;
      var lr = x.partialBoundaries;
      for (we = 0; we < lr.length; we++) {
        var ur = lr[we];
        e: {
          Te = x, Pe = R;
          var Mi = ur.completedSegments;
          for (He = 0; He < Mi.length; He++)
            if (!io(
              Te,
              Pe,
              ur,
              Mi[He]
            )) {
              He++, Mi.splice(0, He);
              var oo = !1;
              break e;
            }
          Mi.splice(0, He), oo = !0;
        }
        if (!oo) {
          x.destination = null, we++, lr.splice(0, we);
          return;
        }
      }
      lr.splice(0, we);
      var ua = x.completedBoundaries;
      for (we = 0; we < ua.length; we++)
        ro(x, R, ua[we]);
      ua.splice(0, we);
    } finally {
      h(R), x.allPendingTasks === 0 && x.pingedTasks.length === 0 && x.clientRenderedBoundaries.length === 0 && x.completedBoundaries.length === 0 && R.close();
    }
  }
  function ao(x, R) {
    try {
      var V = x.abortableTasks;
      V.forEach(function(Q) {
        return Ja(Q, x, R);
      }), V.clear(), x.destination !== null && la(x, x.destination);
    } catch (Q) {
      Jr(x, Q), _i(x, Q);
    }
  }
  return Wu.renderToReadableStream = function(x, R) {
    return new Promise(function(V, Q) {
      var Te, we, Pe = new Promise(function(kt, en) {
        we = kt, Te = en;
      }), He = aa(x, le(R ? R.identifierPrefix : void 0, R ? R.nonce : void 0, R ? R.bootstrapScriptContent : void 0, R ? R.bootstrapScripts : void 0, R ? R.bootstrapModules : void 0), de(R ? R.namespaceURI : void 0), R ? R.progressiveChunkSize : void 0, R ? R.onError : void 0, we, function() {
        var kt = new ReadableStream({ type: "bytes", pull: function(en) {
          if (He.status === 1)
            He.status = 2, y(en, He.fatalError);
          else if (He.status !== 2 && He.destination === null) {
            He.destination = en;
            try {
              la(He, en);
            } catch (Gn) {
              Jr(He, Gn), _i(He, Gn);
            }
          }
        }, cancel: function() {
          ao(He);
        } }, { highWaterMark: 0 });
        kt.allReady = Pe, V(kt);
      }, function(kt) {
        Pe.catch(function() {
        }), Q(kt);
      }, Te);
      if (R && R.signal) {
        var vt = R.signal, Ct = function() {
          ao(He, vt.reason), vt.removeEventListener("abort", Ct);
        };
        vt.addEventListener("abort", Ct);
      }
      to(He);
    });
  }, Wu.version = "18.3.1", Wu;
}
var Fa = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lm;
function WS() {
  return lm || (lm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = fe, t = "18.3.1", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(s) {
      {
        for (var u = arguments.length, k = new Array(u > 1 ? u - 1 : 0), E = 1; E < u; E++)
          k[E - 1] = arguments[E];
        o("warn", s, k);
      }
    }
    function i(s) {
      {
        for (var u = arguments.length, k = new Array(u > 1 ? u - 1 : 0), E = 1; E < u; E++)
          k[E - 1] = arguments[E];
        o("error", s, k);
      }
    }
    function o(s, u, k) {
      {
        var E = n.ReactDebugCurrentFrame, H = E.getStackAddendum();
        H !== "" && (u += "%s", k = k.concat([H]));
        var te = k.map(function(pe) {
          return String(pe);
        });
        te.unshift("Warning: " + u), Function.prototype.apply.call(console[s], console, te);
      }
    }
    function h(s) {
      s();
    }
    function d(s) {
    }
    function c(s, u) {
      p(s, u);
    }
    function p(s, u) {
      return s.push(u);
    }
    function y(s) {
    }
    function g(s) {
      s.push(null);
    }
    function b(s) {
      return s;
    }
    function T(s) {
      return s;
    }
    function m(s, u) {
      s.destroy(u);
    }
    function C(s) {
      {
        var u = typeof Symbol == "function" && Symbol.toStringTag, k = u && s[Symbol.toStringTag] || s.constructor.name || "Object";
        return k;
      }
    }
    function w(s) {
      try {
        return S(s), !1;
      } catch {
        return !0;
      }
    }
    function S(s) {
      return "" + s;
    }
    function B(s, u) {
      if (w(s))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", u, C(s)), S(s);
    }
    function M(s, u) {
      if (w(s))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", u, C(s)), S(s);
    }
    function D(s) {
      if (w(s))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", C(s)), S(s);
    }
    var O = Object.prototype.hasOwnProperty, L = 0, U = 1, X = 2, ne = 3, G = 4, ce = 5, q = 6, re = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", $ = re + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", j = new RegExp("^[" + re + "][" + $ + "]*$"), oe = {}, ie = {};
    function le(s) {
      return O.call(ie, s) ? !0 : O.call(oe, s) ? !1 : j.test(s) ? (ie[s] = !0, !0) : (oe[s] = !0, i("Invalid attribute name: `%s`", s), !1);
    }
    function J(s, u, k, E) {
      if (k !== null && k.type === L)
        return !1;
      switch (typeof u) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (E)
            return !1;
          if (k !== null)
            return !k.acceptsBooleans;
          var H = s.toLowerCase().slice(0, 5);
          return H !== "data-" && H !== "aria-";
        }
        default:
          return !1;
      }
    }
    function de(s) {
      return Z.hasOwnProperty(s) ? Z[s] : null;
    }
    function ae(s, u, k, E, H, te, pe) {
      this.acceptsBooleans = u === X || u === ne || u === G, this.attributeName = E, this.attributeNamespace = H, this.mustUseProperty = k, this.propertyName = s, this.type = u, this.sanitizeURL = te, this.removeEmptyString = pe;
    }
    var Z = {}, ye = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ye.forEach(function(s) {
      Z[s] = new ae(
        s,
        L,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(s) {
      var u = s[0], k = s[1];
      Z[u] = new ae(
        u,
        U,
        !1,
        // mustUseProperty
        k,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
      Z[s] = new ae(
        s,
        X,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
      Z[s] = new ae(
        s,
        X,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(s) {
      Z[s] = new ae(
        s,
        ne,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      Z[s] = new ae(
        s,
        ne,
        !0,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      Z[s] = new ae(
        s,
        G,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      Z[s] = new ae(
        s,
        q,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(s) {
      Z[s] = new ae(
        s,
        ce,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ue = /[\-\:]([a-z])/g, ve = function(s) {
      return s[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var u = s.replace(ue, ve);
      Z[u] = new ae(
        u,
        U,
        !1,
        // mustUseProperty
        s,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var u = s.replace(ue, ve);
      Z[u] = new ae(
        u,
        U,
        !1,
        // mustUseProperty
        s,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(s) {
      var u = s.replace(ue, ve);
      Z[u] = new ae(
        u,
        U,
        !1,
        // mustUseProperty
        s,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(s) {
      Z[s] = new ae(
        s,
        U,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ke = "xlinkHref";
    Z[ke] = new ae(
      "xlinkHref",
      U,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(s) {
      Z[s] = new ae(
        s,
        U,
        !1,
        // mustUseProperty
        s.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var me = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ne(s, u) {
      return s + u.charAt(0).toUpperCase() + u.substring(1);
    }
    var Ee = ["Webkit", "ms", "Moz", "O"];
    Object.keys(me).forEach(function(s) {
      Ee.forEach(function(u) {
        me[Ne(u, s)] = me[s];
      });
    });
    var De = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Xe(s, u) {
      De[u.type] || u.onChange || u.onInput || u.readOnly || u.disabled || u.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), u.onChange || u.readOnly || u.disabled || u.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Fe(s, u) {
      if (s.indexOf("-") === -1)
        return typeof u.is == "string";
      switch (s) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Je = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, gt = {}, mt = new RegExp("^(aria)-[" + $ + "]*$"), yt = new RegExp("^(aria)[A-Z][" + $ + "]*$");
    function Ye(s, u) {
      {
        if (O.call(gt, u) && gt[u])
          return !0;
        if (yt.test(u)) {
          var k = "aria-" + u.slice(4).toLowerCase(), E = Je.hasOwnProperty(k) ? k : null;
          if (E == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", u), gt[u] = !0, !0;
          if (u !== E)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", u, E), gt[u] = !0, !0;
        }
        if (mt.test(u)) {
          var H = u.toLowerCase(), te = Je.hasOwnProperty(H) ? H : null;
          if (te == null)
            return gt[u] = !0, !1;
          if (u !== te)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", u, te), gt[u] = !0, !0;
        }
      }
      return !0;
    }
    function ot(s, u) {
      {
        var k = [];
        for (var E in u) {
          var H = Ye(s, E);
          H || k.push(E);
        }
        var te = k.map(function(pe) {
          return "`" + pe + "`";
        }).join(", ");
        k.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", te, s) : k.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", te, s);
      }
    }
    function ut(s, u) {
      Fe(s, u) || ot(s, u);
    }
    var st = !1;
    function tt(s, u) {
      {
        if (s !== "input" && s !== "textarea" && s !== "select")
          return;
        u != null && u.value === null && !st && (st = !0, s === "select" && u.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", s) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", s));
      }
    }
    var $e = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, it = function() {
    };
    {
      var ht = {}, Ce = /^on./, Ht = /^on[^A-Z]/, vn = new RegExp("^(aria)-[" + $ + "]*$"), pt = new RegExp("^(aria)[A-Z][" + $ + "]*$");
      it = function(s, u, k, E) {
        if (O.call(ht, u) && ht[u])
          return !0;
        var H = u.toLowerCase();
        if (H === "onfocusin" || H === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), ht[u] = !0, !0;
        if (E != null) {
          var te = E.registrationNameDependencies, pe = E.possibleRegistrationNames;
          if (te.hasOwnProperty(u))
            return !0;
          var Ae = pe.hasOwnProperty(H) ? pe[H] : null;
          if (Ae != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", u, Ae), ht[u] = !0, !0;
          if (Ce.test(u))
            return i("Unknown event handler property `%s`. It will be ignored.", u), ht[u] = !0, !0;
        } else if (Ce.test(u))
          return Ht.test(u) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", u), ht[u] = !0, !0;
        if (vn.test(u) || pt.test(u))
          return !0;
        if (H === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), ht[u] = !0, !0;
        if (H === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), ht[u] = !0, !0;
        if (H === "is" && k !== null && k !== void 0 && typeof k != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof k), ht[u] = !0, !0;
        if (typeof k == "number" && isNaN(k))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", u), ht[u] = !0, !0;
        var Me = de(u), Qe = Me !== null && Me.type === L;
        if ($e.hasOwnProperty(H)) {
          var nt = $e[H];
          if (nt !== u)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", u, nt), ht[u] = !0, !0;
        } else if (!Qe && u !== H)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", u, H), ht[u] = !0, !0;
        return typeof k == "boolean" && J(u, k, Me, !1) ? (k ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', k, u, u, k, u) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', k, u, u, k, u, u, u), ht[u] = !0, !0) : Qe ? !0 : J(u, k, Me, !1) ? (ht[u] = !0, !1) : ((k === "false" || k === "true") && Me !== null && Me.type === ne && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", k, u, k === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', u, k), ht[u] = !0), !0);
      };
    }
    var hn = function(s, u, k) {
      {
        var E = [];
        for (var H in u) {
          var te = it(s, H, u[H], k);
          te || E.push(H);
        }
        var pe = E.map(function(Ae) {
          return "`" + Ae + "`";
        }).join(", ");
        E.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", pe, s) : E.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", pe, s);
      }
    };
    function yn(s, u, k) {
      Fe(s, u) || hn(s, u, k);
    }
    var Vt = function() {
    };
    {
      var zt = /^(?:webkit|moz|o)[A-Z]/, Cn = /^-ms-/, qt = /-(.)/g, Ft = /;\s*$/, Gt = {}, Zt = {}, gn = !1, Pt = !1, Qt = function(s) {
        return s.replace(qt, function(u, k) {
          return k.toUpperCase();
        });
      }, Rt = function(s) {
        Gt.hasOwnProperty(s) && Gt[s] || (Gt[s] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          s,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Qt(s.replace(Cn, "ms-"))
        ));
      }, bt = function(s) {
        Gt.hasOwnProperty(s) && Gt[s] || (Gt[s] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", s, s.charAt(0).toUpperCase() + s.slice(1)));
      }, lt = function(s, u) {
        Zt.hasOwnProperty(u) && Zt[u] || (Zt[u] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, s, u.replace(Ft, "")));
      }, Se = function(s, u) {
        gn || (gn = !0, i("`NaN` is an invalid value for the `%s` css style property.", s));
      }, _e = function(s, u) {
        Pt || (Pt = !0, i("`Infinity` is an invalid value for the `%s` css style property.", s));
      };
      Vt = function(s, u) {
        s.indexOf("-") > -1 ? Rt(s) : zt.test(s) ? bt(s) : Ft.test(u) && lt(s, u), typeof u == "number" && (isNaN(u) ? Se(s, u) : isFinite(u) || _e(s, u));
      };
    }
    var xe = Vt, Ge = /["'&<>]/;
    function Ze(s) {
      D(s);
      var u = "" + s, k = Ge.exec(u);
      if (!k)
        return u;
      var E, H = "", te, pe = 0;
      for (te = k.index; te < u.length; te++) {
        switch (u.charCodeAt(te)) {
          case 34:
            E = "&quot;";
            break;
          case 38:
            E = "&amp;";
            break;
          case 39:
            E = "&#x27;";
            break;
          case 60:
            E = "&lt;";
            break;
          case 62:
            E = "&gt;";
            break;
          default:
            continue;
        }
        pe !== te && (H += u.substring(pe, te)), pe = te + 1, H += E;
      }
      return pe !== te ? H + u.substring(pe, te) : H;
    }
    function et(s) {
      return typeof s == "boolean" || typeof s == "number" ? "" + s : Ze(s);
    }
    var Nt = /([A-Z])/g, Wt = /^ms-/;
    function xt(s) {
      return s.replace(Nt, "-$1").toLowerCase().replace(Wt, "-ms-");
    }
    var at = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, un = !1;
    function jt(s) {
      !un && at.test(s) && (un = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(s)));
    }
    var An = Array.isArray;
    function wt(s) {
      return An(s);
    }
    var Lt = "<script>", bn = "<\/script>", $n = '<script src="', Ln = '<script type="module" src="', En = '" async=""><\/script>';
    function nr(s) {
      return D(s), ("" + s).replace(Yn, _n);
    }
    var Yn = /(<\/|<)(s)(cript)/gi, _n = function(s, u, k, E) {
      return "" + u + (k === "s" ? "\\u0073" : "\\u0053") + E;
    };
    function fn(s, u, k, E, H) {
      var te = s === void 0 ? "" : s, pe = u === void 0 ? Lt : '<script nonce="' + et(u) + '">', Ae = [];
      if (k !== void 0 && Ae.push(pe, nr(k), bn), E !== void 0)
        for (var Me = 0; Me < E.length; Me++)
          Ae.push($n, et(E[Me]), En);
      if (H !== void 0)
        for (var Qe = 0; Qe < H.length; Qe++)
          Ae.push(Ln, et(H[Qe]), En);
      return {
        bootstrapChunks: Ae,
        startInlineScript: pe,
        placeholderPrefix: te + "P:",
        segmentPrefix: te + "S:",
        boundaryPrefix: te + "B:",
        idPrefix: te,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var _t = 0, Jt = 1, Yt = 2, on = 3, wn = 4, Ut = 5, sn = 6, pn = 7;
    function Bt(s, u) {
      return {
        insertionMode: s,
        selectedValue: u
      };
    }
    function rr(s, u, k) {
      switch (u) {
        case "select":
          return Bt(Jt, k.value != null ? k.value : k.defaultValue);
        case "svg":
          return Bt(Yt, null);
        case "math":
          return Bt(on, null);
        case "foreignObject":
          return Bt(Jt, null);
        case "table":
          return Bt(wn, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return Bt(Ut, null);
        case "colgroup":
          return Bt(pn, null);
        case "tr":
          return Bt(sn, null);
      }
      return s.insertionMode >= wn || s.insertionMode === _t ? Bt(Jt, null) : s;
    }
    var Mn = null;
    function Pn(s) {
      var u = s.nextSuspenseID++;
      return s.boundaryPrefix + u.toString(16);
    }
    function cn(s, u, k) {
      var E = s.idPrefix, H = ":" + E + "R" + u;
      return k > 0 && (H += "H" + k.toString(32)), H + ":";
    }
    function Hn(s) {
      return et(s);
    }
    var Vn = "<!-- -->";
    function yr(s, u, k, E) {
      return u === "" ? E : (E && s.push(Vn), s.push(Hn(u)), !0);
    }
    function gr(s, u, k, E) {
      k && E && s.push(Vn);
    }
    var ir = /* @__PURE__ */ new Map();
    function Wn(s) {
      var u = ir.get(s);
      if (u !== void 0)
        return u;
      var k = et(xt(s));
      return ir.set(s, k), k;
    }
    var ar = ' style="', Xn = ":", qn = ";";
    function v(s, u, k) {
      if (typeof k != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var E = !0;
      for (var H in k)
        if (O.call(k, H)) {
          var te = k[H];
          if (!(te == null || typeof te == "boolean" || te === "")) {
            var pe = void 0, Ae = void 0, Me = H.indexOf("--") === 0;
            Me ? (pe = et(H), M(te, H), Ae = et(("" + te).trim())) : (xe(H, te), pe = Wn(H), typeof te == "number" ? te !== 0 && !O.call(me, H) ? Ae = te + "px" : Ae = "" + te : (M(te, H), Ae = et(("" + te).trim()))), E ? (E = !1, s.push(ar, pe, Xn, Ae)) : s.push(qn, pe, Xn, Ae);
          }
        }
      E || s.push(W);
    }
    var P = " ", _ = '="', W = '"', he = '=""';
    function N(s, u, k, E) {
      switch (k) {
        case "style": {
          v(s, u, E);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(k.length > 2 && (k[0] === "o" || k[0] === "O") && (k[1] === "n" || k[1] === "N"))
      ) {
        var H = de(k);
        if (H !== null) {
          switch (typeof E) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!H.acceptsBooleans)
                return;
          }
          var te = H.attributeName, pe = te;
          switch (H.type) {
            case ne:
              E && s.push(P, pe, he);
              return;
            case G:
              E === !0 ? s.push(P, pe, he) : E === !1 || s.push(P, pe, _, et(E), W);
              return;
            case ce:
              isNaN(E) || s.push(P, pe, _, et(E), W);
              break;
            case q:
              !isNaN(E) && E >= 1 && s.push(P, pe, _, et(E), W);
              break;
            default:
              H.sanitizeURL && (B(E, te), E = "" + E, jt(E)), s.push(P, pe, _, et(E), W);
          }
        } else if (le(k)) {
          switch (typeof E) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Ae = k.toLowerCase().slice(0, 5);
              if (Ae !== "data-" && Ae !== "aria-")
                return;
            }
          }
          s.push(P, k, _, et(E), W);
        }
      }
    }
    var z = ">", Y = "/>";
    function be(s, u, k) {
      if (u != null) {
        if (k != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof u != "object" || !("__html" in u))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var E = u.__html;
        E != null && (D(E), s.push("" + E));
      }
    }
    var Oe = !1, We = !1, rt = !1, Dt = !1, Mt = !1, dn = !1, Xt = !1;
    function tn(s, u) {
      {
        var k = s[u];
        if (k != null) {
          var E = wt(k);
          s.multiple && !E ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", u) : !s.multiple && E && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", u);
        }
      }
    }
    function Zn(s, u, k) {
      Xe("select", u), tn(u, "value"), tn(u, "defaultValue"), u.value !== void 0 && u.defaultValue !== void 0 && !rt && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), rt = !0), s.push(kn("select"));
      var E = null, H = null;
      for (var te in u)
        if (O.call(u, te)) {
          var pe = u[te];
          if (pe == null)
            continue;
          switch (te) {
            case "children":
              E = pe;
              break;
            case "dangerouslySetInnerHTML":
              H = pe;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              N(s, k, te, pe);
              break;
          }
        }
      return s.push(z), be(s, H, E), E;
    }
    function In(s) {
      var u = "";
      return e.Children.forEach(s, function(k) {
        k != null && (u += k, !Mt && typeof k != "string" && typeof k != "number" && (Mt = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), u;
    }
    var or = ' selected=""';
    function jn(s, u, k, E) {
      var H = E.selectedValue;
      s.push(kn("option"));
      var te = null, pe = null, Ae = null, Me = null;
      for (var Qe in u)
        if (O.call(u, Qe)) {
          var nt = u[Qe];
          if (nt == null)
            continue;
          switch (Qe) {
            case "children":
              te = nt;
              break;
            case "selected":
              Ae = nt, Xt || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Xt = !0);
              break;
            case "dangerouslySetInnerHTML":
              Me = nt;
              break;
            case "value":
              pe = nt;
            default:
              N(s, k, Qe, nt);
              break;
          }
        }
      if (H != null) {
        var St;
        if (pe !== null ? (B(pe, "value"), St = "" + pe) : (Me !== null && (dn || (dn = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), St = In(te)), wt(H))
          for (var rn = 0; rn < H.length; rn++) {
            B(H[rn], "value");
            var Bn = "" + H[rn];
            if (Bn === St) {
              s.push(or);
              break;
            }
          }
        else
          B(H, "select.value"), "" + H === St && s.push(or);
      } else
        Ae && s.push(or);
      return s.push(z), be(s, Me, te), te;
    }
    function Ar(s, u, k) {
      Xe("input", u), u.checked !== void 0 && u.defaultChecked !== void 0 && !We && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", u.type), We = !0), u.value !== void 0 && u.defaultValue !== void 0 && !Oe && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", u.type), Oe = !0), s.push(kn("input"));
      var E = null, H = null, te = null, pe = null;
      for (var Ae in u)
        if (O.call(u, Ae)) {
          var Me = u[Ae];
          if (Me == null)
            continue;
          switch (Ae) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              pe = Me;
              break;
            case "defaultValue":
              H = Me;
              break;
            case "checked":
              te = Me;
              break;
            case "value":
              E = Me;
              break;
            default:
              N(s, k, Ae, Me);
              break;
          }
        }
      return te !== null ? N(s, k, "checked", te) : pe !== null && N(s, k, "checked", pe), E !== null ? N(s, k, "value", E) : H !== null && N(s, k, "value", H), s.push(Y), null;
    }
    function ui(s, u, k) {
      Xe("textarea", u), u.value !== void 0 && u.defaultValue !== void 0 && !Dt && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Dt = !0), s.push(kn("textarea"));
      var E = null, H = null, te = null;
      for (var pe in u)
        if (O.call(u, pe)) {
          var Ae = u[pe];
          if (Ae == null)
            continue;
          switch (pe) {
            case "children":
              te = Ae;
              break;
            case "value":
              E = Ae;
              break;
            case "defaultValue":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              N(s, k, pe, Ae);
              break;
          }
        }
      if (E === null && H !== null && (E = H), s.push(z), te != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), E != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (wt(te)) {
          if (te.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          D(te[0]), E = "" + te[0];
        }
        D(te), E = "" + te;
      }
      return typeof E == "string" && E[0] === `
` && s.push(Lr), E !== null && (B(E, "value"), s.push(Hn("" + E))), null;
    }
    function na(s, u, k, E) {
      s.push(kn(k));
      for (var H in u)
        if (O.call(u, H)) {
          var te = u[H];
          if (te == null)
            continue;
          switch (H) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(k + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              N(s, E, H, te);
              break;
          }
        }
      return s.push(Y), null;
    }
    function qr(s, u, k) {
      s.push(kn("menuitem"));
      for (var E in u)
        if (O.call(u, E)) {
          var H = u[E];
          if (H == null)
            continue;
          switch (E) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              N(s, k, E, H);
              break;
          }
        }
      return s.push(z), null;
    }
    function Tt(s, u, k) {
      s.push(kn("title"));
      var E = null;
      for (var H in u)
        if (O.call(u, H)) {
          var te = u[H];
          if (te == null)
            continue;
          switch (H) {
            case "children":
              E = te;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              N(s, k, H, te);
              break;
          }
        }
      s.push(z);
      {
        var pe = Array.isArray(E) && E.length < 2 ? E[0] || null : E;
        Array.isArray(E) && E.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : pe != null && pe.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : pe != null && typeof pe != "string" && typeof pe != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return E;
    }
    function xn(s, u, k, E) {
      s.push(kn(k));
      var H = null, te = null;
      for (var pe in u)
        if (O.call(u, pe)) {
          var Ae = u[pe];
          if (Ae == null)
            continue;
          switch (pe) {
            case "children":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              te = Ae;
              break;
            default:
              N(s, E, pe, Ae);
              break;
          }
        }
      return s.push(z), be(s, te, H), typeof H == "string" ? (s.push(Hn(H)), null) : H;
    }
    function Un(s, u, k, E) {
      s.push(kn(k));
      var H = null, te = null;
      for (var pe in u)
        if (O.call(u, pe)) {
          var Ae = u[pe];
          if (Ae == null)
            continue;
          switch (pe) {
            case "children":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              te = Ae;
              break;
            case "style":
              v(s, E, Ae);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              le(pe) && typeof Ae != "function" && typeof Ae != "symbol" && s.push(P, pe, _, et(Ae), W);
              break;
          }
        }
      return s.push(z), be(s, te, H), H;
    }
    var Lr = `
`;
    function Zr(s, u, k, E) {
      s.push(kn(k));
      var H = null, te = null;
      for (var pe in u)
        if (O.call(u, pe)) {
          var Ae = u[pe];
          if (Ae == null)
            continue;
          switch (pe) {
            case "children":
              H = Ae;
              break;
            case "dangerouslySetInnerHTML":
              te = Ae;
              break;
            default:
              N(s, E, pe, Ae);
              break;
          }
        }
      if (s.push(z), te != null) {
        if (H != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof te != "object" || !("__html" in te))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var Me = te.__html;
        Me != null && (typeof Me == "string" && Me.length > 0 && Me[0] === `
` ? s.push(Lr, Me) : (D(Me), s.push("" + Me)));
      }
      return typeof H == "string" && H[0] === `
` && s.push(Lr), H;
    }
    var $t = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, vr = /* @__PURE__ */ new Map();
    function kn(s) {
      var u = vr.get(s);
      if (u === void 0) {
        if (!$t.test(s))
          throw new Error("Invalid tag: " + s);
        u = "<" + s, vr.set(s, u);
      }
      return u;
    }
    var Er = "<!DOCTYPE html>";
    function Nr(s, u, k, E, H) {
      switch (ut(u, k), tt(u, k), yn(u, k, null), !k.suppressContentEditableWarning && k.contentEditable && k.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), H.insertionMode !== Yt && H.insertionMode !== on && u.indexOf("-") === -1 && typeof k.is != "string" && u.toLowerCase() !== u && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", u), u) {
        case "select":
          return Zn(s, k, E);
        case "option":
          return jn(s, k, E, H);
        case "textarea":
          return ui(s, k, E);
        case "input":
          return Ar(s, k, E);
        case "menuitem":
          return qr(s, k, E);
        case "title":
          return Tt(s, k, E);
        case "listing":
        case "pre":
          return Zr(s, k, u, E);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return na(s, k, u, E);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return xn(s, k, u, E);
        case "html":
          return H.insertionMode === _t && s.push(Er), xn(s, k, u, E);
        default:
          return u.indexOf("-") === -1 && typeof k.is != "string" ? xn(s, k, u, E) : Un(s, k, u, E);
      }
    }
    var Ci = "</", Rr = ">";
    function sr(s, u, k) {
      switch (u) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          s.push(Ci, u, Rr);
      }
    }
    function ra(s, u) {
      for (var k = u.bootstrapChunks, E = 0; E < k.length - 1; E++)
        c(s, k[E]);
      return E < k.length ? p(s, k[E]) : !0;
    }
    var ia = '<template id="', Ga = '"></template>';
    function Ya(s, u, k) {
      c(s, ia), c(s, u.placeholderPrefix);
      var E = k.toString(16);
      return c(s, E), p(s, Ga);
    }
    var Xa = "<!--$-->", ds = '<!--$?--><template id="', hs = '"></template>', Ai = "<!--$!-->", Li = "<!--/$-->", Ei = "<template", ci = '"', fs = ' data-dgst="', di = ' data-msg="', aa = ' data-stck="', oa = "></template>";
    function Qr(s, u) {
      return p(s, Xa);
    }
    function Jr(s, u, k) {
      if (c(s, ds), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return c(s, k), p(s, hs);
    }
    function _i(s, u, k, E, H) {
      var te;
      return te = p(s, Ai), c(s, Ei), k && (c(s, fs), c(s, et(k)), c(s, ci)), E && (c(s, di), c(s, et(E)), c(s, ci)), H && (c(s, aa), c(s, et(H)), c(s, ci)), te = p(s, oa), te;
    }
    function qa(s, u) {
      return p(s, Li);
    }
    function sa(s, u) {
      return p(s, Li);
    }
    function Za(s, u) {
      return p(s, Li);
    }
    var Pi = '<div hidden id="', Kn = '">', Qa = "</div>", Ni = '<svg aria-hidden="true" style="display:none" id="', ps = '">', Ja = "</svg>", Ri = '<math aria-hidden="true" style="display:none" id="', eo = '">', to = "</math>", Di = '<table hidden id="', Oi = '">', no = "</table>", ro = '<table hidden><tbody id="', io = '">', la = "</tbody></table>", ao = '<table hidden><tr id="', x = '">', R = "</tr></table>", V = '<table hidden><colgroup id="', Q = '">', Te = "</colgroup></table>";
    function we(s, u, k, E) {
      switch (k.insertionMode) {
        case _t:
        case Jt:
          return c(s, Pi), c(s, u.segmentPrefix), c(s, E.toString(16)), p(s, Kn);
        case Yt:
          return c(s, Ni), c(s, u.segmentPrefix), c(s, E.toString(16)), p(s, ps);
        case on:
          return c(s, Ri), c(s, u.segmentPrefix), c(s, E.toString(16)), p(s, eo);
        case wn:
          return c(s, Di), c(s, u.segmentPrefix), c(s, E.toString(16)), p(s, Oi);
        case Ut:
          return c(s, ro), c(s, u.segmentPrefix), c(s, E.toString(16)), p(s, io);
        case sn:
          return c(s, ao), c(s, u.segmentPrefix), c(s, E.toString(16)), p(s, x);
        case pn:
          return c(s, V), c(s, u.segmentPrefix), c(s, E.toString(16)), p(s, Q);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Pe(s, u) {
      switch (u.insertionMode) {
        case _t:
        case Jt:
          return p(s, Qa);
        case Yt:
          return p(s, Ja);
        case on:
          return p(s, to);
        case wn:
          return p(s, no);
        case Ut:
          return p(s, la);
        case sn:
          return p(s, R);
        case pn:
          return p(s, Te);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var He = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", vt = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Ct = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', kt = He + ';$RS("', en = '$RS("', Gn = '","', lr = '")<\/script>';
    function ur(s, u, k) {
      c(s, u.startInlineScript), u.sentCompleteSegmentFunction ? c(s, en) : (u.sentCompleteSegmentFunction = !0, c(s, kt)), c(s, u.segmentPrefix);
      var E = k.toString(16);
      return c(s, E), c(s, Gn), c(s, u.placeholderPrefix), c(s, E), p(s, lr);
    }
    var Mi = vt + ';$RC("', oo = '$RC("', ua = '","', Zc = '")<\/script>';
    function Qc(s, u, k, E) {
      if (c(s, u.startInlineScript), u.sentCompleteBoundaryFunction ? c(s, oo) : (u.sentCompleteBoundaryFunction = !0, c(s, Mi)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var H = E.toString(16);
      return c(s, k), c(s, ua), c(s, u.segmentPrefix), c(s, H), p(s, Zc);
    }
    var Jc = Ct + ';$RX("', ed = '$RX("', td = '"', nd = ")<\/script>", ms = ",";
    function rd(s, u, k, E, H, te) {
      if (c(s, u.startInlineScript), u.sentClientRenderFunction ? c(s, ed) : (u.sentClientRenderFunction = !0, c(s, Jc)), k === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return c(s, k), c(s, td), (E || H || te) && (c(s, ms), c(s, ys(E || ""))), (H || te) && (c(s, ms), c(s, ys(H || ""))), te && (c(s, ms), c(s, ys(te))), p(s, nd);
    }
    var id = /[<\u2028\u2029]/g;
    function ys(s) {
      var u = JSON.stringify(s);
      return u.replace(id, function(k) {
        switch (k) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function ad(s, u) {
      var k = fn(u, void 0);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: k.bootstrapChunks,
        startInlineScript: k.startInlineScript,
        placeholderPrefix: k.placeholderPrefix,
        segmentPrefix: k.segmentPrefix,
        boundaryPrefix: k.boundaryPrefix,
        idPrefix: k.idPrefix,
        nextSuspenseID: k.nextSuspenseID,
        sentCompleteSegmentFunction: k.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: k.sentCompleteBoundaryFunction,
        sentClientRenderFunction: k.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: s
      };
    }
    function gs() {
      return {
        insertionMode: Jt,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function Vl(s, u, k, E) {
      return k.generateStaticMarkup ? (s.push(et(u)), !1) : yr(s, u, k, E);
    }
    function Wl(s, u, k, E) {
      if (!u.generateStaticMarkup)
        return gr(s, u, k, E);
    }
    function vs(s, u) {
      return u.generateStaticMarkup ? !0 : Qr(s);
    }
    function br(s, u, k, E, H) {
      return u.generateStaticMarkup ? !0 : _i(s, u, k, E, H);
    }
    function od(s, u) {
      return u.generateStaticMarkup ? !0 : qa(s);
    }
    function jl(s, u) {
      return u.generateStaticMarkup ? !0 : Za(s);
    }
    var cr = Object.assign, Ul = Symbol.for("react.element"), bs = Symbol.for("react.portal"), so = Symbol.for("react.fragment"), lo = Symbol.for("react.strict_mode"), uo = Symbol.for("react.profiler"), ca = Symbol.for("react.provider"), da = Symbol.for("react.context"), ha = Symbol.for("react.forward_ref"), Ii = Symbol.for("react.suspense"), xs = Symbol.for("react.suspense_list"), Ss = Symbol.for("react.memo"), co = Symbol.for("react.lazy"), sd = Symbol.for("react.scope"), Kl = Symbol.for("react.debug_trace_mode"), ld = Symbol.for("react.legacy_hidden"), ud = Symbol.for("react.default_value"), Gl = Symbol.iterator, Yl = "@@iterator";
    function ln(s) {
      if (s === null || typeof s != "object")
        return null;
      var u = Gl && s[Gl] || s[Yl];
      return typeof u == "function" ? u : null;
    }
    function fa(s, u, k) {
      var E = s.displayName;
      if (E)
        return E;
      var H = u.displayName || u.name || "";
      return H !== "" ? k + "(" + H + ")" : k;
    }
    function ws(s) {
      return s.displayName || "Context";
    }
    function nn(s) {
      if (s == null)
        return null;
      if (typeof s.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof s == "function")
        return s.displayName || s.name || null;
      if (typeof s == "string")
        return s;
      switch (s) {
        case so:
          return "Fragment";
        case bs:
          return "Portal";
        case uo:
          return "Profiler";
        case lo:
          return "StrictMode";
        case Ii:
          return "Suspense";
        case xs:
          return "SuspenseList";
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case da:
            var u = s;
            return ws(u) + ".Consumer";
          case ca:
            var k = s;
            return ws(k._context) + ".Provider";
          case ha:
            return fa(s, s.render, "ForwardRef");
          case Ss:
            var E = s.displayName || null;
            return E !== null ? E : nn(s.type) || "Memo";
          case co: {
            var H = s, te = H._payload, pe = H._init;
            try {
              return nn(pe(te));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Fi = 0, ks, Ts, Cs, As, Ls, Xl, ql;
    function ho() {
    }
    ho.__reactDisabledLog = !0;
    function Es() {
      {
        if (Fi === 0) {
          ks = console.log, Ts = console.info, Cs = console.warn, As = console.error, Ls = console.group, Xl = console.groupCollapsed, ql = console.groupEnd;
          var s = {
            configurable: !0,
            enumerable: !0,
            value: ho,
            writable: !0
          };
          Object.defineProperties(console, {
            info: s,
            log: s,
            warn: s,
            error: s,
            group: s,
            groupCollapsed: s,
            groupEnd: s
          });
        }
        Fi++;
      }
    }
    function pa() {
      {
        if (Fi--, Fi === 0) {
          var s = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: cr({}, s, {
              value: ks
            }),
            info: cr({}, s, {
              value: Ts
            }),
            warn: cr({}, s, {
              value: Cs
            }),
            error: cr({}, s, {
              value: As
            }),
            group: cr({}, s, {
              value: Ls
            }),
            groupCollapsed: cr({}, s, {
              value: Xl
            }),
            groupEnd: cr({}, s, {
              value: ql
            })
          });
        }
        Fi < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ma = n.ReactCurrentDispatcher, Bi;
    function ya(s, u, k) {
      {
        if (Bi === void 0)
          try {
            throw Error();
          } catch (H) {
            var E = H.stack.trim().match(/\n( *(at )?)/);
            Bi = E && E[1] || "";
          }
        return `
` + Bi + s;
      }
    }
    var ga = !1, fo;
    {
      var Zl = typeof WeakMap == "function" ? WeakMap : Map;
      fo = new Zl();
    }
    function _s(s, u) {
      if (!s || ga)
        return "";
      {
        var k = fo.get(s);
        if (k !== void 0)
          return k;
      }
      var E;
      ga = !0;
      var H = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var te;
      te = ma.current, ma.current = null, Es();
      try {
        if (u) {
          var pe = function() {
            throw Error();
          };
          if (Object.defineProperty(pe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(pe, []);
            } catch (kr) {
              E = kr;
            }
            Reflect.construct(s, [], pe);
          } else {
            try {
              pe.call();
            } catch (kr) {
              E = kr;
            }
            s.call(pe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (kr) {
            E = kr;
          }
          s();
        }
      } catch (kr) {
        if (kr && E && typeof kr.stack == "string") {
          for (var Ae = kr.stack.split(`
`), Me = E.stack.split(`
`), Qe = Ae.length - 1, nt = Me.length - 1; Qe >= 1 && nt >= 0 && Ae[Qe] !== Me[nt]; )
            nt--;
          for (; Qe >= 1 && nt >= 0; Qe--, nt--)
            if (Ae[Qe] !== Me[nt]) {
              if (Qe !== 1 || nt !== 1)
                do
                  if (Qe--, nt--, nt < 0 || Ae[Qe] !== Me[nt]) {
                    var St = `
` + Ae[Qe].replace(" at new ", " at ");
                    return s.displayName && St.includes("<anonymous>") && (St = St.replace("<anonymous>", s.displayName)), typeof s == "function" && fo.set(s, St), St;
                  }
                while (Qe >= 1 && nt >= 0);
              break;
            }
        }
      } finally {
        ga = !1, ma.current = te, pa(), Error.prepareStackTrace = H;
      }
      var rn = s ? s.displayName || s.name : "", Bn = rn ? ya(rn) : "";
      return typeof s == "function" && fo.set(s, Bn), Bn;
    }
    function Ps(s, u, k) {
      return _s(s, !0);
    }
    function Ns(s, u, k) {
      return _s(s, !1);
    }
    function Ql(s) {
      var u = s.prototype;
      return !!(u && u.isReactComponent);
    }
    function zi(s, u, k) {
      if (s == null)
        return "";
      if (typeof s == "function")
        return _s(s, Ql(s));
      if (typeof s == "string")
        return ya(s);
      switch (s) {
        case Ii:
          return ya("Suspense");
        case xs:
          return ya("SuspenseList");
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case ha:
            return Ns(s.render);
          case Ss:
            return zi(s.type, u, k);
          case co: {
            var E = s, H = E._payload, te = E._init;
            try {
              return zi(te(H), u, k);
            } catch {
            }
          }
        }
      return "";
    }
    var Rs = {}, po = n.ReactDebugCurrentFrame;
    function hi(s) {
      if (s) {
        var u = s._owner, k = zi(s.type, s._source, u ? u.type : null);
        po.setExtraStackFrame(k);
      } else
        po.setExtraStackFrame(null);
    }
    function Ds(s, u, k, E, H) {
      {
        var te = Function.call.bind(O);
        for (var pe in s)
          if (te(s, pe)) {
            var Ae = void 0;
            try {
              if (typeof s[pe] != "function") {
                var Me = Error((E || "React class") + ": " + k + " type `" + pe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[pe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Me.name = "Invariant Violation", Me;
              }
              Ae = s[pe](u, pe, E, k, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Qe) {
              Ae = Qe;
            }
            Ae && !(Ae instanceof Error) && (hi(H), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", E || "React class", k, pe, typeof Ae), hi(null)), Ae instanceof Error && !(Ae.message in Rs) && (Rs[Ae.message] = !0, hi(H), i("Failed %s type: %s", k, Ae.message), hi(null));
          }
      }
    }
    var Os;
    Os = {};
    var ei = {};
    Object.freeze(ei);
    function Jl(s, u) {
      {
        var k = s.contextTypes;
        if (!k)
          return ei;
        var E = {};
        for (var H in k)
          E[H] = u[H];
        {
          var te = nn(s) || "Unknown";
          Ds(k, E, "context", te);
        }
        return E;
      }
    }
    function fi(s, u, k, E) {
      {
        if (typeof s.getChildContext != "function") {
          {
            var H = nn(u) || "Unknown";
            Os[H] || (Os[H] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", H, H));
          }
          return k;
        }
        var te = s.getChildContext();
        for (var pe in te)
          if (!(pe in E))
            throw new Error((nn(u) || "Unknown") + '.getChildContext(): key "' + pe + '" is not defined in childContextTypes.');
        {
          var Ae = nn(u) || "Unknown";
          Ds(E, te, "child context", Ae);
        }
        return cr({}, k, te);
      }
    }
    var pi;
    pi = {};
    var Ms = null, Dr = null;
    function mo(s) {
      s.context._currentValue2 = s.parentValue;
    }
    function yo(s) {
      s.context._currentValue2 = s.value;
    }
    function va(s, u) {
      if (s !== u) {
        mo(s);
        var k = s.parent, E = u.parent;
        if (k === null) {
          if (E !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (E === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          va(k, E);
        }
        yo(u);
      }
    }
    function Is(s) {
      mo(s);
      var u = s.parent;
      u !== null && Is(u);
    }
    function ba(s) {
      var u = s.parent;
      u !== null && ba(u), yo(s);
    }
    function eu(s, u) {
      mo(s);
      var k = s.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      k.depth === u.depth ? va(k, u) : eu(k, u);
    }
    function tu(s, u) {
      var k = u.parent;
      if (k === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      s.depth === k.depth ? va(s, k) : tu(s, k), yo(u);
    }
    function go(s) {
      var u = Dr, k = s;
      u !== k && (u === null ? ba(k) : k === null ? Is(u) : u.depth === k.depth ? va(u, k) : u.depth > k.depth ? eu(u, k) : tu(u, k), Dr = k);
    }
    function xa(s, u) {
      var k;
      k = s._currentValue2, s._currentValue2 = u, s._currentRenderer2 !== void 0 && s._currentRenderer2 !== null && s._currentRenderer2 !== pi && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer2 = pi;
      var E = Dr, H = {
        parent: E,
        depth: E === null ? 0 : E.depth + 1,
        context: s,
        parentValue: k,
        value: u
      };
      return Dr = H, H;
    }
    function Fs(s) {
      var u = Dr;
      if (u === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      u.context !== s && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var k = u.parentValue;
        k === ud ? u.context._currentValue2 = u.context._defaultValue : u.context._currentValue2 = k, s._currentRenderer2 !== void 0 && s._currentRenderer2 !== null && s._currentRenderer2 !== pi && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer2 = pi;
      }
      return Dr = u.parent;
    }
    function cd() {
      return Dr;
    }
    function $i(s) {
      var u = s._currentValue2;
      return u;
    }
    function vo(s) {
      return s._reactInternals;
    }
    function Bs(s, u) {
      s._reactInternals = u;
    }
    var bo = {}, xo = {}, Sa, So, Hi, wa, wo, Vi, ko, To, Co;
    {
      Sa = /* @__PURE__ */ new Set(), So = /* @__PURE__ */ new Set(), Hi = /* @__PURE__ */ new Set(), ko = /* @__PURE__ */ new Set(), wa = /* @__PURE__ */ new Set(), To = /* @__PURE__ */ new Set(), Co = /* @__PURE__ */ new Set();
      var nu = /* @__PURE__ */ new Set();
      Vi = function(s, u) {
        if (!(s === null || typeof s == "function")) {
          var k = u + "_" + s;
          nu.has(k) || (nu.add(k), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", u, s));
        }
      }, wo = function(s, u) {
        if (u === void 0) {
          var k = nn(s) || "Component";
          wa.has(k) || (wa.add(k), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", k));
        }
      };
    }
    function ru(s, u) {
      {
        var k = s.constructor, E = k && nn(k) || "ReactClass", H = E + "." + u;
        if (bo[H])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, u, u, E), bo[H] = !0;
      }
    }
    var iu = {
      isMounted: function(s) {
        return !1;
      },
      enqueueSetState: function(s, u, k) {
        var E = vo(s);
        E.queue === null ? ru(s, "setState") : (E.queue.push(u), k != null && Vi(k, "setState"));
      },
      enqueueReplaceState: function(s, u, k) {
        var E = vo(s);
        E.replace = !0, E.queue = [u], k != null && Vi(k, "setState");
      },
      enqueueForceUpdate: function(s, u) {
        var k = vo(s);
        k.queue === null ? ru(s, "forceUpdate") : u != null && Vi(u, "setState");
      }
    };
    function dd(s, u, k, E, H) {
      var te = k(H, E);
      wo(u, te);
      var pe = te == null ? E : cr({}, E, te);
      return pe;
    }
    function hd(s, u, k) {
      var E = ei, H = s.contextType;
      if ("contextType" in s) {
        var te = (
          // Allow null for conditional declaration
          H === null || H !== void 0 && H.$$typeof === da && H._context === void 0
        );
        if (!te && !Co.has(s)) {
          Co.add(s);
          var pe = "";
          H === void 0 ? pe = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof H != "object" ? pe = " However, it is set to a " + typeof H + "." : H.$$typeof === ca ? pe = " Did you accidentally pass the Context.Provider instead?" : H._context !== void 0 ? pe = " Did you accidentally pass the Context.Consumer instead?" : pe = " However, it is set to an object with keys {" + Object.keys(H).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", nn(s) || "Component", pe);
        }
      }
      typeof H == "object" && H !== null ? E = $i(H) : E = k;
      var Ae = new s(u, E);
      {
        if (typeof s.getDerivedStateFromProps == "function" && (Ae.state === null || Ae.state === void 0)) {
          var Me = nn(s) || "Component";
          Sa.has(Me) || (Sa.add(Me), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Me, Ae.state === null ? "null" : "undefined", Me));
        }
        if (typeof s.getDerivedStateFromProps == "function" || typeof Ae.getSnapshotBeforeUpdate == "function") {
          var Qe = null, nt = null, St = null;
          if (typeof Ae.componentWillMount == "function" && Ae.componentWillMount.__suppressDeprecationWarning !== !0 ? Qe = "componentWillMount" : typeof Ae.UNSAFE_componentWillMount == "function" && (Qe = "UNSAFE_componentWillMount"), typeof Ae.componentWillReceiveProps == "function" && Ae.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? nt = "componentWillReceiveProps" : typeof Ae.UNSAFE_componentWillReceiveProps == "function" && (nt = "UNSAFE_componentWillReceiveProps"), typeof Ae.componentWillUpdate == "function" && Ae.componentWillUpdate.__suppressDeprecationWarning !== !0 ? St = "componentWillUpdate" : typeof Ae.UNSAFE_componentWillUpdate == "function" && (St = "UNSAFE_componentWillUpdate"), Qe !== null || nt !== null || St !== null) {
            var rn = nn(s) || "Component", Bn = typeof s.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Hi.has(rn) || (Hi.add(rn), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, rn, Bn, Qe !== null ? `
  ` + Qe : "", nt !== null ? `
  ` + nt : "", St !== null ? `
  ` + St : ""));
          }
        }
      }
      return Ae;
    }
    function au(s, u, k) {
      {
        var E = nn(u) || "Component", H = s.render;
        H || (u.prototype && typeof u.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", E) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", E)), s.getInitialState && !s.getInitialState.isReactClassApproved && !s.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", E), s.getDefaultProps && !s.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", E), s.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", E), s.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", E), s.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", E), u.contextType && u.contextTypes && !To.has(u) && (To.add(u), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", E)), typeof s.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", E), u.prototype && u.prototype.isPureReactComponent && typeof s.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", nn(u) || "A pure component"), typeof s.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", E), typeof s.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", E), typeof s.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", E), typeof s.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", E);
        var te = s.props !== k;
        s.props !== void 0 && te && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", E, E), s.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", E, E), typeof s.getSnapshotBeforeUpdate == "function" && typeof s.componentDidUpdate != "function" && !So.has(u) && (So.add(u), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", nn(u))), typeof s.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", E), typeof s.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", E), typeof u.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", E);
        var pe = s.state;
        pe && (typeof pe != "object" || wt(pe)) && i("%s.state: must be set to an object or null", E), typeof s.getChildContext == "function" && typeof u.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", E);
      }
    }
    function fd(s, u) {
      var k = u.state;
      if (typeof u.componentWillMount == "function") {
        if (u.componentWillMount.__suppressDeprecationWarning !== !0) {
          var E = nn(s) || "Unknown";
          xo[E] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            E
          ), xo[E] = !0);
        }
        u.componentWillMount();
      }
      typeof u.UNSAFE_componentWillMount == "function" && u.UNSAFE_componentWillMount(), k !== u.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", nn(s) || "Component"), iu.enqueueReplaceState(u, u.state, null));
    }
    function pd(s, u, k, E) {
      if (s.queue !== null && s.queue.length > 0) {
        var H = s.queue, te = s.replace;
        if (s.queue = null, s.replace = !1, te && H.length === 1)
          u.state = H[0];
        else {
          for (var pe = te ? H[0] : u.state, Ae = !0, Me = te ? 1 : 0; Me < H.length; Me++) {
            var Qe = H[Me], nt = typeof Qe == "function" ? Qe.call(u, pe, k, E) : Qe;
            nt != null && (Ae ? (Ae = !1, pe = cr({}, pe, nt)) : cr(pe, nt));
          }
          u.state = pe;
        }
      } else
        s.queue = null;
    }
    function Ao(s, u, k, E) {
      au(s, u, k);
      var H = s.state !== void 0 ? s.state : null;
      s.updater = iu, s.props = k, s.state = H;
      var te = {
        queue: [],
        replace: !1
      };
      Bs(s, te);
      var pe = u.contextType;
      if (typeof pe == "object" && pe !== null ? s.context = $i(pe) : s.context = E, s.state === k) {
        var Ae = nn(u) || "Component";
        ko.has(Ae) || (ko.add(Ae), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Ae));
      }
      var Me = u.getDerivedStateFromProps;
      typeof Me == "function" && (s.state = dd(s, u, Me, H, k)), typeof u.getDerivedStateFromProps != "function" && typeof s.getSnapshotBeforeUpdate != "function" && (typeof s.UNSAFE_componentWillMount == "function" || typeof s.componentWillMount == "function") && (fd(u, s), pd(te, s, k, E));
    }
    var Lo = {
      id: 1,
      overflow: ""
    };
    function md(s) {
      var u = s.overflow, k = s.id, E = k & ~yd(k);
      return E.toString(32) + u;
    }
    function zs(s, u, k) {
      var E = s.id, H = s.overflow, te = Eo(E) - 1, pe = E & ~(1 << te), Ae = k + 1, Me = Eo(u) + te;
      if (Me > 30) {
        var Qe = te - te % 5, nt = (1 << Qe) - 1, St = (pe & nt).toString(32), rn = pe >> Qe, Bn = te - Qe, kr = Eo(u) + Bn, Lu = Ae << Bn, Eu = Lu | rn, _u = St + H;
        return {
          id: 1 << kr | Eu,
          overflow: _u
        };
      } else {
        var jo = Ae << te, Eg = jo | pe, _g = H;
        return {
          id: 1 << Me | Eg,
          overflow: _g
        };
      }
    }
    function Eo(s) {
      return 32 - gd(s);
    }
    function yd(s) {
      return 1 << Eo(s) - 1;
    }
    var gd = Math.clz32 ? Math.clz32 : $r, vd = Math.log, bd = Math.LN2;
    function $r(s) {
      var u = s >>> 0;
      return u === 0 ? 32 : 31 - (vd(u) / bd | 0) | 0;
    }
    function $s(s, u) {
      return s === u && (s !== 0 || 1 / s === 1 / u) || s !== s && u !== u;
    }
    var _o = typeof Object.is == "function" ? Object.is : $s, Ot = null, mi = null, yi = null, Kt = null, xr = !1, gi = !1, Po = 0, Fn = null, Hr = 0, vi = 25, Or = !1, bi;
    function Vr() {
      if (Ot === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Or && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Ot;
    }
    function xd(s, u) {
      if (u === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", bi), !1;
      s.length !== u.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, bi, "[" + s.join(", ") + "]", "[" + u.join(", ") + "]");
      for (var k = 0; k < u.length && k < s.length; k++)
        if (!_o(s[k], u[k]))
          return !1;
      return !0;
    }
    function ou() {
      if (Hr > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function No() {
      return Kt === null ? yi === null ? (xr = !1, yi = Kt = ou()) : (xr = !0, Kt = yi) : Kt.next === null ? (xr = !1, Kt = Kt.next = ou()) : (xr = !0, Kt = Kt.next), Kt;
    }
    function Hs(s, u) {
      Ot = u, mi = s, Or = !1, Po = 0;
    }
    function Sd(s, u, k, E) {
      for (; gi; )
        gi = !1, Po = 0, Hr += 1, Kt = null, k = s(u, E);
      return ka(), k;
    }
    function su() {
      var s = Po !== 0;
      return s;
    }
    function ka() {
      Or = !1, Ot = null, mi = null, gi = !1, yi = null, Hr = 0, Fn = null, Kt = null;
    }
    function wd(s) {
      return Or && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), $i(s);
    }
    function lu(s) {
      return bi = "useContext", Vr(), $i(s);
    }
    function Ro(s, u) {
      return typeof u == "function" ? u(s) : u;
    }
    function kd(s) {
      return bi = "useState", uu(
        Ro,
        // useReducer has a special case to support lazy useState initializers
        s
      );
    }
    function uu(s, u, k) {
      if (s !== Ro && (bi = "useReducer"), Ot = Vr(), Kt = No(), xr) {
        var E = Kt.queue, H = E.dispatch;
        if (Fn !== null) {
          var te = Fn.get(E);
          if (te !== void 0) {
            Fn.delete(E);
            var pe = Kt.memoizedState, Ae = te;
            do {
              var Me = Ae.action;
              Or = !0, pe = s(pe, Me), Or = !1, Ae = Ae.next;
            } while (Ae !== null);
            return Kt.memoizedState = pe, [pe, H];
          }
        }
        return [Kt.memoizedState, H];
      } else {
        Or = !0;
        var Qe;
        s === Ro ? Qe = typeof u == "function" ? u() : u : Qe = k !== void 0 ? k(u) : u, Or = !1, Kt.memoizedState = Qe;
        var nt = Kt.queue = {
          last: null,
          dispatch: null
        }, St = nt.dispatch = Ad.bind(null, Ot, nt);
        return [Kt.memoizedState, St];
      }
    }
    function cu(s, u) {
      Ot = Vr(), Kt = No();
      var k = u === void 0 ? null : u;
      if (Kt !== null) {
        var E = Kt.memoizedState;
        if (E !== null && k !== null) {
          var H = E[1];
          if (xd(k, H))
            return E[0];
        }
      }
      Or = !0;
      var te = s();
      return Or = !1, Kt.memoizedState = [te, k], te;
    }
    function Td(s) {
      Ot = Vr(), Kt = No();
      var u = Kt.memoizedState;
      if (u === null) {
        var k = {
          current: s
        };
        return Object.seal(k), Kt.memoizedState = k, k;
      } else
        return u;
    }
    function Cd(s, u) {
      bi = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function Ad(s, u, k) {
      if (Hr >= vi)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (s === Ot) {
        gi = !0;
        var E = {
          action: k,
          next: null
        };
        Fn === null && (Fn = /* @__PURE__ */ new Map());
        var H = Fn.get(u);
        if (H === void 0)
          Fn.set(u, E);
        else {
          for (var te = H; te.next !== null; )
            te = te.next;
          te.next = E;
        }
      }
    }
    function Ld(s, u) {
      return cu(function() {
        return s;
      }, u);
    }
    function Ed(s, u, k) {
      return Vr(), u(s._source);
    }
    function _d(s, u, k) {
      if (k === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return k();
    }
    function Pd(s) {
      return Vr(), s;
    }
    function Do() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function du() {
      return Vr(), [!1, Do];
    }
    function Vs() {
      var s = mi, u = md(s.treeContext), k = Ca;
      if (k === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var E = Po++;
      return cn(k, u, E);
    }
    function Ta() {
    }
    var hu = {
      readContext: wd,
      useContext: lu,
      useMemo: cu,
      useReducer: uu,
      useRef: Td,
      useState: kd,
      useInsertionEffect: Ta,
      useLayoutEffect: Cd,
      useCallback: Ld,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: Ta,
      // Effects are not run in the server environment.
      useEffect: Ta,
      // Debugging effect
      useDebugValue: Ta,
      useDeferredValue: Pd,
      useTransition: du,
      useId: Vs,
      // Subscriptions are not setup in a server environment.
      useMutableSource: Ed,
      useSyncExternalStore: _d
    }, Ca = null;
    function Oo(s) {
      Ca = s;
    }
    function Ws(s) {
      try {
        var u = "", k = s;
        do {
          switch (k.tag) {
            case 0:
              u += ya(k.type, null, null);
              break;
            case 1:
              u += Ns(k.type, null, null);
              break;
            case 2:
              u += Ps(k.type, null, null);
              break;
          }
          k = k.parent;
        } while (k);
        return u;
      } catch (E) {
        return `
Error generating stack: ` + E.message + `
` + E.stack;
      }
    }
    var ti = n.ReactCurrentDispatcher, Mo = n.ReactDebugCurrentFrame, Io = 0, xi = 1, fu = 2, js = 3, Si = 4, Nd = 0, pu = 1, Mr = 2, Rd = 12800;
    function Dd(s) {
      return console.error(s), null;
    }
    function Aa() {
    }
    function Us(s, u, k, E, H, te, pe, Ae, Me) {
      var Qe = [], nt = /* @__PURE__ */ new Set(), St = {
        destination: null,
        responseState: u,
        progressiveChunkSize: E === void 0 ? Rd : E,
        status: Nd,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: nt,
        pingedTasks: Qe,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: H === void 0 ? Dd : H,
        onAllReady: te === void 0 ? Aa : te,
        onShellReady: pe === void 0 ? Aa : pe,
        onShellError: Ae === void 0 ? Aa : Ae,
        onFatalError: Me === void 0 ? Aa : Me
      }, rn = ni(
        St,
        0,
        null,
        k,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      rn.parentFlushed = !0;
      var Bn = La(St, s, null, rn, nt, ei, Ms, Lo);
      return Qe.push(Bn), St;
    }
    function Fo(s, u) {
      var k = s.pingedTasks;
      k.push(u), k.length === 1 && h(function() {
        return Cu(s);
      });
    }
    function Wr(s, u) {
      return {
        id: Mn,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: u,
        errorDigest: null
      };
    }
    function La(s, u, k, E, H, te, pe, Ae) {
      s.allPendingTasks++, k === null ? s.pendingRootTasks++ : k.pendingTasks++;
      var Me = {
        node: u,
        ping: function() {
          return Fo(s, Me);
        },
        blockedBoundary: k,
        blockedSegment: E,
        abortSet: H,
        legacyContext: te,
        context: pe,
        treeContext: Ae
      };
      return Me.componentStack = null, H.add(Me), Me;
    }
    function ni(s, u, k, E, H, te) {
      return {
        status: Io,
        id: -1,
        // lazily assigned later
        index: u,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: E,
        boundary: k,
        lastPushedText: H,
        textEmbedded: te
      };
    }
    var Ir = null;
    function Ks() {
      return Ir === null || Ir.componentStack === null ? "" : Ws(Ir.componentStack);
    }
    function Sr(s, u) {
      s.componentStack = {
        tag: 0,
        parent: s.componentStack,
        type: u
      };
    }
    function Wi(s, u) {
      s.componentStack = {
        tag: 1,
        parent: s.componentStack,
        type: u
      };
    }
    function Gs(s, u) {
      s.componentStack = {
        tag: 2,
        parent: s.componentStack,
        type: u
      };
    }
    function wr(s) {
      s.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : s.componentStack = s.componentStack.parent;
    }
    var ri = null;
    function Ys(s, u) {
      {
        var k;
        typeof u == "string" ? k = u : u && typeof u.message == "string" ? k = u.message : k = String(u);
        var E = ri || Ks();
        ri = null, s.errorMessage = k, s.errorComponentStack = E;
      }
    }
    function Ea(s, u) {
      var k = s.onError(u);
      if (k != null && typeof k != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof k + '" instead');
      return k;
    }
    function Bo(s, u) {
      var k = s.onShellError;
      k(u);
      var E = s.onFatalError;
      E(u), s.destination !== null ? (s.status = Mr, m(s.destination, u)) : (s.status = pu, s.fatalError = u);
    }
    function mu(s, u, k) {
      Sr(u, "Suspense");
      var E = u.blockedBoundary, H = u.blockedSegment, te = k.fallback, pe = k.children, Ae = /* @__PURE__ */ new Set(), Me = Wr(s, Ae), Qe = H.chunks.length, nt = ni(
        s,
        Qe,
        Me,
        H.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      H.children.push(nt), H.lastPushedText = !1;
      var St = ni(
        s,
        0,
        null,
        H.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      St.parentFlushed = !0, u.blockedBoundary = Me, u.blockedSegment = St;
      try {
        if (zo(s, u, pe), Wl(St.chunks, s.responseState, St.lastPushedText, St.textEmbedded), St.status = xi, Na(Me, St), Me.pendingTasks === 0) {
          wr(u);
          return;
        }
      } catch (Bn) {
        St.status = Si, Me.forceClientRender = !0, Me.errorDigest = Ea(s, Bn), Ys(Me, Bn);
      } finally {
        u.blockedBoundary = E, u.blockedSegment = H;
      }
      var rn = La(s, te, E, nt, Ae, u.legacyContext, u.context, u.treeContext);
      rn.componentStack = u.componentStack, s.pingedTasks.push(rn), wr(u);
    }
    function yu(s, u, k, E) {
      Sr(u, k);
      var H = u.blockedSegment, te = Nr(H.chunks, k, E, s.responseState, H.formatContext);
      H.lastPushedText = !1;
      var pe = H.formatContext;
      H.formatContext = rr(pe, k, E), zo(s, u, te), H.formatContext = pe, sr(H.chunks, k), H.lastPushedText = !1, wr(u);
    }
    function Od(s) {
      return s.prototype && s.prototype.isReactComponent;
    }
    function Xs(s, u, k, E, H) {
      var te = {};
      Hs(u, te);
      var pe = k(E, H);
      return Sd(k, E, pe, H);
    }
    function _a(s, u, k, E, H) {
      var te = k.render();
      k.props !== H && (Js || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", nn(E) || "a component"), Js = !0);
      {
        var pe = E.childContextTypes;
        if (pe != null) {
          var Ae = u.legacyContext, Me = fi(k, E, Ae, pe);
          u.legacyContext = Me, hr(s, u, te), u.legacyContext = Ae;
          return;
        }
      }
      hr(s, u, te);
    }
    function gu(s, u, k, E) {
      Gs(u, k);
      var H = Jl(k, u.legacyContext), te = hd(k, E, H);
      Ao(te, k, E, H), _a(s, u, te, k, E), wr(u);
    }
    var qs = {}, Pa = {}, Zs = {}, Qs = {}, Js = !1, el = {}, vu = !1, bu = !1, tl = !1;
    function Md(s, u, k, E) {
      var H;
      if (H = Jl(k, u.legacyContext), Wi(u, k), k.prototype && typeof k.prototype.render == "function") {
        var te = nn(k) || "Unknown";
        qs[te] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", te, te), qs[te] = !0);
      }
      var pe = Xs(s, u, k, E, H), Ae = su();
      if (typeof pe == "object" && pe !== null && typeof pe.render == "function" && pe.$$typeof === void 0) {
        var Me = nn(k) || "Unknown";
        Pa[Me] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Me, Me, Me), Pa[Me] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof pe == "object" && pe !== null && typeof pe.render == "function" && pe.$$typeof === void 0
      ) {
        {
          var Qe = nn(k) || "Unknown";
          Pa[Qe] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Qe, Qe, Qe), Pa[Qe] = !0);
        }
        Ao(pe, k, E, H), _a(s, u, pe, k, E);
      } else if (Id(k), Ae) {
        var nt = u.treeContext, St = 1, rn = 0;
        u.treeContext = zs(nt, St, rn);
        try {
          hr(s, u, pe);
        } finally {
          u.treeContext = nt;
        }
      } else
        hr(s, u, pe);
      wr(u);
    }
    function Id(s) {
      {
        if (s && s.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", s.displayName || s.name || "Component"), s.defaultProps !== void 0) {
          var u = nn(s) || "Unknown";
          el[u] || (i("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", u), el[u] = !0);
        }
        if (typeof s.getDerivedStateFromProps == "function") {
          var k = nn(s) || "Unknown";
          Qs[k] || (i("%s: Function components do not support getDerivedStateFromProps.", k), Qs[k] = !0);
        }
        if (typeof s.contextType == "object" && s.contextType !== null) {
          var E = nn(s) || "Unknown";
          Zs[E] || (i("%s: Function components do not support contextType.", E), Zs[E] = !0);
        }
      }
    }
    function xu(s, u) {
      if (s && s.defaultProps) {
        var k = cr({}, u), E = s.defaultProps;
        for (var H in E)
          k[H] === void 0 && (k[H] = E[H]);
        return k;
      }
      return u;
    }
    function Fd(s, u, k, E, H) {
      Wi(u, k.render);
      var te = Xs(s, u, k.render, E, H), pe = su();
      if (pe) {
        var Ae = u.treeContext, Me = 1, Qe = 0;
        u.treeContext = zs(Ae, Me, Qe);
        try {
          hr(s, u, te);
        } finally {
          u.treeContext = Ae;
        }
      } else
        hr(s, u, te);
      wr(u);
    }
    function Bd(s, u, k, E, H) {
      var te = k.type, pe = xu(te, E);
      rl(s, u, te, pe, H);
    }
    function nl(s, u, k, E) {
      k._context === void 0 ? k !== k.Consumer && (tl || (tl = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : k = k._context;
      var H = E.children;
      typeof H != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var te = $i(k), pe = H(te);
      hr(s, u, pe);
    }
    function zd(s, u, k, E) {
      var H = k._context, te = E.value, pe = E.children, Ae;
      Ae = u.context, u.context = xa(H, te), hr(s, u, pe), u.context = Fs(H), Ae !== u.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function dr(s, u, k, E, H) {
      Sr(u, "Lazy");
      var te = k._payload, pe = k._init, Ae = pe(te), Me = xu(Ae, E);
      rl(s, u, Ae, Me, H), wr(u);
    }
    function rl(s, u, k, E, H) {
      if (typeof k == "function")
        if (Od(k)) {
          gu(s, u, k, E);
          return;
        } else {
          Md(s, u, k, E);
          return;
        }
      if (typeof k == "string") {
        yu(s, u, k, E);
        return;
      }
      switch (k) {
        case ld:
        case Kl:
        case lo:
        case uo:
        case so: {
          hr(s, u, E.children);
          return;
        }
        case xs: {
          Sr(u, "SuspenseList"), hr(s, u, E.children), wr(u);
          return;
        }
        case sd:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Ii: {
          mu(s, u, E);
          return;
        }
      }
      if (typeof k == "object" && k !== null)
        switch (k.$$typeof) {
          case ha: {
            Fd(s, u, k, E, H);
            return;
          }
          case Ss: {
            Bd(s, u, k, E, H);
            return;
          }
          case ca: {
            zd(s, u, k, E);
            return;
          }
          case da: {
            nl(s, u, k, E);
            return;
          }
          case co: {
            dr(s, u, k, E);
            return;
          }
        }
      var te = "";
      throw (k === void 0 || typeof k == "object" && k !== null && Object.keys(k).length === 0) && (te += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (k == null ? k : typeof k) + "." + te));
    }
    function Su(s, u) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      s[Symbol.toStringTag] === "Generator" && (vu || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), vu = !0), s.entries === u && (bu || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), bu = !0);
    }
    function hr(s, u, k) {
      try {
        return il(s, u, k);
      } catch (E) {
        throw typeof E == "object" && E !== null && typeof E.then == "function" || (ri = ri !== null ? ri : Ks()), E;
      }
    }
    function il(s, u, k) {
      if (u.node = k, typeof k == "object" && k !== null) {
        switch (k.$$typeof) {
          case Ul: {
            var E = k, H = E.type, te = E.props, pe = E.ref;
            rl(s, u, H, te, pe);
            return;
          }
          case bs:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case co: {
            var Ae = k, Me = Ae._payload, Qe = Ae._init, nt;
            try {
              nt = Qe(Me);
            } catch (jo) {
              throw typeof jo == "object" && jo !== null && typeof jo.then == "function" && Sr(u, "Lazy"), jo;
            }
            hr(s, u, nt);
            return;
          }
        }
        if (wt(k)) {
          wu(s, u, k);
          return;
        }
        var St = ln(k);
        if (St) {
          Su(k, St);
          var rn = St.call(k);
          if (rn) {
            var Bn = rn.next();
            if (!Bn.done) {
              var kr = [];
              do
                kr.push(Bn.value), Bn = rn.next();
              while (!Bn.done);
              wu(s, u, kr);
              return;
            }
            return;
          }
        }
        var Lu = Object.prototype.toString.call(k);
        throw new Error("Objects are not valid as a React child (found: " + (Lu === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : Lu) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof k == "string") {
        var Eu = u.blockedSegment;
        Eu.lastPushedText = Vl(u.blockedSegment.chunks, k, s.responseState, Eu.lastPushedText);
        return;
      }
      if (typeof k == "number") {
        var _u = u.blockedSegment;
        _u.lastPushedText = Vl(u.blockedSegment.chunks, "" + k, s.responseState, _u.lastPushedText);
        return;
      }
      typeof k == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function wu(s, u, k) {
      for (var E = k.length, H = 0; H < E; H++) {
        var te = u.treeContext;
        u.treeContext = zs(te, E, H);
        try {
          zo(s, u, k[H]);
        } finally {
          u.treeContext = te;
        }
      }
    }
    function $d(s, u, k) {
      var E = u.blockedSegment, H = E.chunks.length, te = ni(
        s,
        H,
        null,
        E.formatContext,
        // Adopt the parent segment's leading text embed
        E.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      E.children.push(te), E.lastPushedText = !1;
      var pe = La(s, u.node, u.blockedBoundary, te, u.abortSet, u.legacyContext, u.context, u.treeContext);
      u.componentStack !== null && (pe.componentStack = u.componentStack.parent);
      var Ae = pe.ping;
      k.then(Ae, Ae);
    }
    function zo(s, u, k) {
      var E = u.blockedSegment.formatContext, H = u.legacyContext, te = u.context, pe = null;
      pe = u.componentStack;
      try {
        return hr(s, u, k);
      } catch (Ae) {
        if (ka(), typeof Ae == "object" && Ae !== null && typeof Ae.then == "function") {
          $d(s, u, Ae), u.blockedSegment.formatContext = E, u.legacyContext = H, u.context = te, go(te), u.componentStack = pe;
          return;
        } else
          throw u.blockedSegment.formatContext = E, u.legacyContext = H, u.context = te, go(te), u.componentStack = pe, Ae;
      }
    }
    function $o(s, u, k, E) {
      var H = Ea(s, E);
      if (u === null ? Bo(s, E) : (u.pendingTasks--, u.forceClientRender || (u.forceClientRender = !0, u.errorDigest = H, Ys(u, E), u.parentFlushed && s.clientRenderedBoundaries.push(u))), s.allPendingTasks--, s.allPendingTasks === 0) {
        var te = s.onAllReady;
        te();
      }
    }
    function ku(s) {
      var u = this, k = s.blockedBoundary, E = s.blockedSegment;
      E.status = js, Ra(u, k, E);
    }
    function Tu(s, u, k) {
      var E = s.blockedBoundary, H = s.blockedSegment;
      if (H.status = js, E === null)
        u.allPendingTasks--, u.status !== Mr && (u.status = Mr, u.destination !== null && g(u.destination));
      else {
        if (E.pendingTasks--, !E.forceClientRender) {
          E.forceClientRender = !0;
          var te = k === void 0 ? new Error("The render was aborted by the server without a reason.") : k;
          E.errorDigest = u.onError(te);
          {
            var pe = "The server did not finish this Suspense boundary: ";
            te && typeof te.message == "string" ? te = pe + te.message : te = pe + String(te);
            var Ae = Ir;
            Ir = s;
            try {
              Ys(E, te);
            } finally {
              Ir = Ae;
            }
          }
          E.parentFlushed && u.clientRenderedBoundaries.push(E);
        }
        if (E.fallbackAbortableTasks.forEach(function(Qe) {
          return Tu(Qe, u, k);
        }), E.fallbackAbortableTasks.clear(), u.allPendingTasks--, u.allPendingTasks === 0) {
          var Me = u.onAllReady;
          Me();
        }
      }
    }
    function Na(s, u) {
      if (u.chunks.length === 0 && u.children.length === 1 && u.children[0].boundary === null) {
        var k = u.children[0];
        k.id = u.id, k.parentFlushed = !0, k.status === xi && Na(s, k);
      } else {
        var E = s.completedSegments;
        E.push(u);
      }
    }
    function Ra(s, u, k) {
      if (u === null) {
        if (k.parentFlushed) {
          if (s.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          s.completedRootSegment = k;
        }
        if (s.pendingRootTasks--, s.pendingRootTasks === 0) {
          s.onShellError = Aa;
          var E = s.onShellReady;
          E();
        }
      } else if (u.pendingTasks--, !u.forceClientRender) {
        if (u.pendingTasks === 0)
          k.parentFlushed && k.status === xi && Na(u, k), u.parentFlushed && s.completedBoundaries.push(u), u.fallbackAbortableTasks.forEach(ku, s), u.fallbackAbortableTasks.clear();
        else if (k.parentFlushed && k.status === xi) {
          Na(u, k);
          var H = u.completedSegments;
          H.length === 1 && u.parentFlushed && s.partialBoundaries.push(u);
        }
      }
      if (s.allPendingTasks--, s.allPendingTasks === 0) {
        var te = s.onAllReady;
        te();
      }
    }
    function Ho(s, u) {
      var k = u.blockedSegment;
      if (k.status === Io) {
        go(u.context);
        var E = null;
        E = Ir, Ir = u;
        try {
          hr(s, u, u.node), Wl(k.chunks, s.responseState, k.lastPushedText, k.textEmbedded), u.abortSet.delete(u), k.status = xi, Ra(s, u.blockedBoundary, k);
        } catch (te) {
          if (ka(), typeof te == "object" && te !== null && typeof te.then == "function") {
            var H = u.ping;
            te.then(H, H);
          } else
            u.abortSet.delete(u), k.status = Si, $o(s, u.blockedBoundary, k, te);
        } finally {
          Ir = E;
        }
      }
    }
    function Cu(s) {
      if (s.status !== Mr) {
        var u = cd(), k = ti.current;
        ti.current = hu;
        var E;
        E = Mo.getCurrentStack, Mo.getCurrentStack = Ks;
        var H = Ca;
        Oo(s.responseState);
        try {
          var te = s.pingedTasks, pe;
          for (pe = 0; pe < te.length; pe++) {
            var Ae = te[pe];
            Ho(s, Ae);
          }
          te.splice(0, pe), s.destination !== null && Wo(s, s.destination);
        } catch (Me) {
          Ea(s, Me), Bo(s, Me);
        } finally {
          Oo(H), ti.current = k, Mo.getCurrentStack = E, k === hu && go(u);
        }
      }
    }
    function Da(s, u, k) {
      switch (k.parentFlushed = !0, k.status) {
        case Io: {
          var E = k.id = s.nextSegmentId++;
          return k.lastPushedText = !1, k.textEmbedded = !1, Ya(u, s.responseState, E);
        }
        case xi: {
          k.status = fu;
          for (var H = !0, te = k.chunks, pe = 0, Ae = k.children, Me = 0; Me < Ae.length; Me++) {
            for (var Qe = Ae[Me]; pe < Qe.index; pe++)
              c(u, te[pe]);
            H = Oa(s, u, Qe);
          }
          for (; pe < te.length - 1; pe++)
            c(u, te[pe]);
          return pe < te.length && (H = p(u, te[pe])), H;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Oa(s, u, k) {
      var E = k.boundary;
      if (E === null)
        return Da(s, u, k);
      if (E.parentFlushed = !0, E.forceClientRender)
        return br(u, s.responseState, E.errorDigest, E.errorMessage, E.errorComponentStack), Da(s, u, k), jl(u, s.responseState);
      if (E.pendingTasks > 0) {
        E.rootSegmentID = s.nextSegmentId++, E.completedSegments.length > 0 && s.partialBoundaries.push(E);
        var H = E.id = Pn(s.responseState);
        return Jr(u, s.responseState, H), Da(s, u, k), sa(u, s.responseState);
      } else {
        if (E.byteSize > s.progressiveChunkSize)
          return E.rootSegmentID = s.nextSegmentId++, s.completedBoundaries.push(E), Jr(u, s.responseState, E.id), Da(s, u, k), sa(u, s.responseState);
        vs(u, s.responseState);
        var te = E.completedSegments;
        if (te.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var pe = te[0];
        return Oa(s, u, pe), od(u, s.responseState);
      }
    }
    function Hd(s, u, k) {
      return rd(u, s.responseState, k.id, k.errorDigest, k.errorMessage, k.errorComponentStack);
    }
    function al(s, u, k) {
      return we(u, s.responseState, k.formatContext, k.id), Oa(s, u, k), Pe(u, k.formatContext);
    }
    function Vo(s, u, k) {
      for (var E = k.completedSegments, H = 0; H < E.length; H++) {
        var te = E[H];
        Au(s, u, k, te);
      }
      return E.length = 0, Qc(u, s.responseState, k.id, k.rootSegmentID);
    }
    function Vd(s, u, k) {
      for (var E = k.completedSegments, H = 0; H < E.length; H++) {
        var te = E[H];
        if (!Au(s, u, k, te))
          return H++, E.splice(0, H), !1;
      }
      return E.splice(0, H), !0;
    }
    function Au(s, u, k, E) {
      if (E.status === fu)
        return !0;
      var H = E.id;
      if (H === -1) {
        var te = E.id = k.rootSegmentID;
        if (te === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return al(s, u, E);
      } else
        return al(s, u, E), ur(u, s.responseState, H);
    }
    function Wo(s, u) {
      try {
        var k = s.completedRootSegment;
        k !== null && s.pendingRootTasks === 0 && (Oa(s, u, k), s.completedRootSegment = null, ra(u, s.responseState));
        var E = s.clientRenderedBoundaries, H;
        for (H = 0; H < E.length; H++) {
          var te = E[H];
          if (!Hd(s, u, te)) {
            s.destination = null, H++, E.splice(0, H);
            return;
          }
        }
        E.splice(0, H);
        var pe = s.completedBoundaries;
        for (H = 0; H < pe.length; H++) {
          var Ae = pe[H];
          if (!Vo(s, u, Ae)) {
            s.destination = null, H++, pe.splice(0, H);
            return;
          }
        }
        pe.splice(0, H);
        var Me = s.partialBoundaries;
        for (H = 0; H < Me.length; H++) {
          var Qe = Me[H];
          if (!Vd(s, u, Qe)) {
            s.destination = null, H++, Me.splice(0, H);
            return;
          }
        }
        Me.splice(0, H);
        var nt = s.completedBoundaries;
        for (H = 0; H < nt.length; H++) {
          var St = nt[H];
          if (!Vo(s, u, St)) {
            s.destination = null, H++, nt.splice(0, H);
            return;
          }
        }
        nt.splice(0, H);
      } finally {
        s.allPendingTasks === 0 && s.pingedTasks.length === 0 && s.clientRenderedBoundaries.length === 0 && s.completedBoundaries.length === 0 && (s.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), g(u));
      }
    }
    function Wd(s) {
      h(function() {
        return Cu(s);
      });
    }
    function l(s, u) {
      if (s.status === pu) {
        s.status = Mr, m(u, s.fatalError);
        return;
      }
      if (s.status !== Mr && s.destination === null) {
        s.destination = u;
        try {
          Wo(s, u);
        } catch (k) {
          Ea(s, k), Bo(s, k);
        }
      }
    }
    function f(s, u) {
      try {
        var k = s.abortableTasks;
        k.forEach(function(E) {
          return Tu(E, s, u);
        }), k.clear(), s.destination !== null && Wo(s, s.destination);
      } catch (E) {
        Ea(s, E), Bo(s, E);
      }
    }
    function A() {
    }
    function I(s, u, k, E) {
      var H = !1, te = null, pe = "", Ae = {
        push: function(St) {
          return St !== null && (pe += St), !0;
        },
        destroy: function(St) {
          H = !0, te = St;
        }
      }, Me = !1;
      function Qe() {
        Me = !0;
      }
      var nt = Us(s, ad(k, u ? u.identifierPrefix : void 0), gs(), 1 / 0, A, void 0, Qe, void 0, void 0);
      if (Wd(nt), f(nt, E), l(nt, Ae), H)
        throw te;
      if (!Me)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return pe;
    }
    function K(s, u) {
      return I(s, u, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function se(s, u) {
      return I(s, u, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function ge() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function Le() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Fa.renderToNodeStream = ge, Fa.renderToStaticMarkup = se, Fa.renderToStaticNodeStream = Le, Fa.renderToString = K, Fa.version = t;
  }()), Fa;
}
var ju = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var um;
function jS() {
  return um || (um = 1, process.env.NODE_ENV !== "production" && function() {
    var e = fe, t = "18.3.1", n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(l) {
      {
        for (var f = arguments.length, A = new Array(f > 1 ? f - 1 : 0), I = 1; I < f; I++)
          A[I - 1] = arguments[I];
        o("warn", l, A);
      }
    }
    function i(l) {
      {
        for (var f = arguments.length, A = new Array(f > 1 ? f - 1 : 0), I = 1; I < f; I++)
          A[I - 1] = arguments[I];
        o("error", l, A);
      }
    }
    function o(l, f, A) {
      {
        var I = n.ReactDebugCurrentFrame, K = I.getStackAddendum();
        K !== "" && (f += "%s", A = A.concat([K]));
        var se = A.map(function(ge) {
          return String(ge);
        });
        se.unshift("Warning: " + f), Function.prototype.apply.call(console[l], console, se);
      }
    }
    function h(l) {
      l();
    }
    var d = 512, c = null, p = 0;
    function y(l) {
      c = new Uint8Array(d), p = 0;
    }
    function g(l, f) {
      if (f.length !== 0) {
        if (f.length > d) {
          p > 0 && (l.enqueue(new Uint8Array(c.buffer, 0, p)), c = new Uint8Array(d), p = 0), l.enqueue(f);
          return;
        }
        var A = f, I = c.length - p;
        I < A.length && (I === 0 ? l.enqueue(c) : (c.set(A.subarray(0, I), p), l.enqueue(c), A = A.subarray(I)), c = new Uint8Array(d), p = 0), c.set(A, p), p += A.length;
      }
    }
    function b(l, f) {
      return g(l, f), !0;
    }
    function T(l) {
      c && p > 0 && (l.enqueue(new Uint8Array(c.buffer, 0, p)), c = null, p = 0);
    }
    function m(l) {
      l.close();
    }
    var C = new TextEncoder();
    function w(l) {
      return C.encode(l);
    }
    function S(l) {
      return C.encode(l);
    }
    function B(l, f) {
      typeof l.error == "function" ? l.error(f) : l.close();
    }
    function M(l) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, A = f && l[Symbol.toStringTag] || l.constructor.name || "Object";
        return A;
      }
    }
    function D(l) {
      try {
        return O(l), !1;
      } catch {
        return !0;
      }
    }
    function O(l) {
      return "" + l;
    }
    function L(l, f) {
      if (D(l))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", f, M(l)), O(l);
    }
    function U(l, f) {
      if (D(l))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", f, M(l)), O(l);
    }
    function X(l) {
      if (D(l))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", M(l)), O(l);
    }
    var ne = Object.prototype.hasOwnProperty, G = 0, ce = 1, q = 2, re = 3, $ = 4, j = 5, oe = 6, ie = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", le = ie + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", J = new RegExp("^[" + ie + "][" + le + "]*$"), de = {}, ae = {};
    function Z(l) {
      return ne.call(ae, l) ? !0 : ne.call(de, l) ? !1 : J.test(l) ? (ae[l] = !0, !0) : (de[l] = !0, i("Invalid attribute name: `%s`", l), !1);
    }
    function ye(l, f, A, I) {
      if (A !== null && A.type === G)
        return !1;
      switch (typeof f) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (I)
            return !1;
          if (A !== null)
            return !A.acceptsBooleans;
          var K = l.toLowerCase().slice(0, 5);
          return K !== "data-" && K !== "aria-";
        }
        default:
          return !1;
      }
    }
    function ue(l) {
      return ke.hasOwnProperty(l) ? ke[l] : null;
    }
    function ve(l, f, A, I, K, se, ge) {
      this.acceptsBooleans = f === q || f === re || f === $, this.attributeName = I, this.attributeNamespace = K, this.mustUseProperty = A, this.propertyName = l, this.type = f, this.sanitizeURL = se, this.removeEmptyString = ge;
    }
    var ke = {}, me = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    me.forEach(function(l) {
      ke[l] = new ve(
        l,
        G,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
      var f = l[0], A = l[1];
      ke[f] = new ve(
        f,
        ce,
        !1,
        // mustUseProperty
        A,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
      ke[l] = new ve(
        l,
        q,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
      ke[l] = new ve(
        l,
        q,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(l) {
      ke[l] = new ve(
        l,
        re,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ke[l] = new ve(
        l,
        re,
        !0,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ke[l] = new ve(
        l,
        $,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      ke[l] = new ve(
        l,
        oe,
        !1,
        // mustUseProperty
        l,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(l) {
      ke[l] = new ve(
        l,
        j,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Ne = /[\-\:]([a-z])/g, Ee = function(l) {
      return l[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(Ne, Ee);
      ke[f] = new ve(
        f,
        ce,
        !1,
        // mustUseProperty
        l,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(Ne, Ee);
      ke[f] = new ve(
        f,
        ce,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(l) {
      var f = l.replace(Ne, Ee);
      ke[f] = new ve(
        f,
        ce,
        !1,
        // mustUseProperty
        l,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(l) {
      ke[l] = new ve(
        l,
        ce,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var De = "xlinkHref";
    ke[De] = new ve(
      "xlinkHref",
      ce,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(l) {
      ke[l] = new ve(
        l,
        ce,
        !1,
        // mustUseProperty
        l.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Xe = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Fe(l, f) {
      return l + f.charAt(0).toUpperCase() + f.substring(1);
    }
    var Je = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Xe).forEach(function(l) {
      Je.forEach(function(f) {
        Xe[Fe(f, l)] = Xe[l];
      });
    });
    var gt = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function mt(l, f) {
      gt[f.type] || f.onChange || f.onInput || f.readOnly || f.disabled || f.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), f.onChange || f.readOnly || f.disabled || f.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function yt(l, f) {
      if (l.indexOf("-") === -1)
        return typeof f.is == "string";
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Ye = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, ot = {}, ut = new RegExp("^(aria)-[" + le + "]*$"), st = new RegExp("^(aria)[A-Z][" + le + "]*$");
    function tt(l, f) {
      {
        if (ne.call(ot, f) && ot[f])
          return !0;
        if (st.test(f)) {
          var A = "aria-" + f.slice(4).toLowerCase(), I = Ye.hasOwnProperty(A) ? A : null;
          if (I == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", f), ot[f] = !0, !0;
          if (f !== I)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", f, I), ot[f] = !0, !0;
        }
        if (ut.test(f)) {
          var K = f.toLowerCase(), se = Ye.hasOwnProperty(K) ? K : null;
          if (se == null)
            return ot[f] = !0, !1;
          if (f !== se)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", f, se), ot[f] = !0, !0;
        }
      }
      return !0;
    }
    function $e(l, f) {
      {
        var A = [];
        for (var I in f) {
          var K = tt(l, I);
          K || A.push(I);
        }
        var se = A.map(function(ge) {
          return "`" + ge + "`";
        }).join(", ");
        A.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", se, l) : A.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", se, l);
      }
    }
    function it(l, f) {
      yt(l, f) || $e(l, f);
    }
    var ht = !1;
    function Ce(l, f) {
      {
        if (l !== "input" && l !== "textarea" && l !== "select")
          return;
        f != null && f.value === null && !ht && (ht = !0, l === "select" && f.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", l) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", l));
      }
    }
    var Ht = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, vn = function() {
    };
    {
      var pt = {}, hn = /^on./, yn = /^on[^A-Z]/, Vt = new RegExp("^(aria)-[" + le + "]*$"), zt = new RegExp("^(aria)[A-Z][" + le + "]*$");
      vn = function(l, f, A, I) {
        if (ne.call(pt, f) && pt[f])
          return !0;
        var K = f.toLowerCase();
        if (K === "onfocusin" || K === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), pt[f] = !0, !0;
        if (I != null) {
          var se = I.registrationNameDependencies, ge = I.possibleRegistrationNames;
          if (se.hasOwnProperty(f))
            return !0;
          var Le = ge.hasOwnProperty(K) ? ge[K] : null;
          if (Le != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", f, Le), pt[f] = !0, !0;
          if (hn.test(f))
            return i("Unknown event handler property `%s`. It will be ignored.", f), pt[f] = !0, !0;
        } else if (hn.test(f))
          return yn.test(f) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", f), pt[f] = !0, !0;
        if (Vt.test(f) || zt.test(f))
          return !0;
        if (K === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), pt[f] = !0, !0;
        if (K === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), pt[f] = !0, !0;
        if (K === "is" && A !== null && A !== void 0 && typeof A != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof A), pt[f] = !0, !0;
        if (typeof A == "number" && isNaN(A))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", f), pt[f] = !0, !0;
        var s = ue(f), u = s !== null && s.type === G;
        if (Ht.hasOwnProperty(K)) {
          var k = Ht[K];
          if (k !== f)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", f, k), pt[f] = !0, !0;
        } else if (!u && f !== K)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", f, K), pt[f] = !0, !0;
        return typeof A == "boolean" && ye(f, A, s, !1) ? (A ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', A, f, f, A, f) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', A, f, f, A, f, f, f), pt[f] = !0, !0) : u ? !0 : ye(f, A, s, !1) ? (pt[f] = !0, !1) : ((A === "false" || A === "true") && s !== null && s.type === re && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", A, f, A === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', f, A), pt[f] = !0), !0);
      };
    }
    var Cn = function(l, f, A) {
      {
        var I = [];
        for (var K in f) {
          var se = vn(l, K, f[K], A);
          se || I.push(K);
        }
        var ge = I.map(function(Le) {
          return "`" + Le + "`";
        }).join(", ");
        I.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", ge, l) : I.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", ge, l);
      }
    };
    function qt(l, f, A) {
      yt(l, f) || Cn(l, f, A);
    }
    var Ft = function() {
    };
    {
      var Gt = /^(?:webkit|moz|o)[A-Z]/, Zt = /^-ms-/, gn = /-(.)/g, Pt = /;\s*$/, Qt = {}, Rt = {}, bt = !1, lt = !1, Se = function(l) {
        return l.replace(gn, function(f, A) {
          return A.toUpperCase();
        });
      }, _e = function(l) {
        Qt.hasOwnProperty(l) && Qt[l] || (Qt[l] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          l,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Se(l.replace(Zt, "ms-"))
        ));
      }, xe = function(l) {
        Qt.hasOwnProperty(l) && Qt[l] || (Qt[l] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", l, l.charAt(0).toUpperCase() + l.slice(1)));
      }, Ge = function(l, f) {
        Rt.hasOwnProperty(f) && Rt[f] || (Rt[f] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, l, f.replace(Pt, "")));
      }, Ze = function(l, f) {
        bt || (bt = !0, i("`NaN` is an invalid value for the `%s` css style property.", l));
      }, et = function(l, f) {
        lt || (lt = !0, i("`Infinity` is an invalid value for the `%s` css style property.", l));
      };
      Ft = function(l, f) {
        l.indexOf("-") > -1 ? _e(l) : Gt.test(l) ? xe(l) : Pt.test(f) && Ge(l, f), typeof f == "number" && (isNaN(f) ? Ze(l, f) : isFinite(f) || et(l, f));
      };
    }
    var Nt = Ft, Wt = /["'&<>]/;
    function xt(l) {
      X(l);
      var f = "" + l, A = Wt.exec(f);
      if (!A)
        return f;
      var I, K = "", se, ge = 0;
      for (se = A.index; se < f.length; se++) {
        switch (f.charCodeAt(se)) {
          case 34:
            I = "&quot;";
            break;
          case 38:
            I = "&amp;";
            break;
          case 39:
            I = "&#x27;";
            break;
          case 60:
            I = "&lt;";
            break;
          case 62:
            I = "&gt;";
            break;
          default:
            continue;
        }
        ge !== se && (K += f.substring(ge, se)), ge = se + 1, K += I;
      }
      return ge !== se ? K + f.substring(ge, se) : K;
    }
    function at(l) {
      return typeof l == "boolean" || typeof l == "number" ? "" + l : xt(l);
    }
    var un = /([A-Z])/g, jt = /^ms-/;
    function An(l) {
      return l.replace(un, "-$1").toLowerCase().replace(jt, "-ms-");
    }
    var wt = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Lt = !1;
    function bn(l) {
      !Lt && wt.test(l) && (Lt = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(l)));
    }
    var $n = Array.isArray;
    function Ln(l) {
      return $n(l);
    }
    var En = S("<script>"), nr = S("<\/script>"), Yn = S('<script src="'), _n = S('<script type="module" src="'), fn = S('" async=""><\/script>');
    function _t(l) {
      return X(l), ("" + l).replace(Jt, Yt);
    }
    var Jt = /(<\/|<)(s)(cript)/gi, Yt = function(l, f, A, I) {
      return "" + f + (A === "s" ? "\\u0073" : "\\u0053") + I;
    };
    function on(l, f, A, I, K) {
      var se = l === void 0 ? "" : l, ge = f === void 0 ? En : S('<script nonce="' + at(f) + '">'), Le = [];
      if (A !== void 0 && Le.push(ge, w(_t(A)), nr), I !== void 0)
        for (var s = 0; s < I.length; s++)
          Le.push(Yn, w(at(I[s])), fn);
      if (K !== void 0)
        for (var u = 0; u < K.length; u++)
          Le.push(_n, w(at(K[u])), fn);
      return {
        bootstrapChunks: Le,
        startInlineScript: ge,
        placeholderPrefix: S(se + "P:"),
        segmentPrefix: S(se + "S:"),
        boundaryPrefix: se + "B:",
        idPrefix: se,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var wn = 0, Ut = 1, sn = 2, pn = 3, Bt = 4, rr = 5, Mn = 6, Pn = 7;
    function cn(l, f) {
      return {
        insertionMode: l,
        selectedValue: f
      };
    }
    function Hn(l) {
      var f = l === "http://www.w3.org/2000/svg" ? sn : l === "http://www.w3.org/1998/Math/MathML" ? pn : wn;
      return cn(f, null);
    }
    function Vn(l, f, A) {
      switch (f) {
        case "select":
          return cn(Ut, A.value != null ? A.value : A.defaultValue);
        case "svg":
          return cn(sn, null);
        case "math":
          return cn(pn, null);
        case "foreignObject":
          return cn(Ut, null);
        case "table":
          return cn(Bt, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return cn(rr, null);
        case "colgroup":
          return cn(Pn, null);
        case "tr":
          return cn(Mn, null);
      }
      return l.insertionMode >= Bt || l.insertionMode === wn ? cn(Ut, null) : l;
    }
    var yr = null;
    function gr(l) {
      var f = l.nextSuspenseID++;
      return S(l.boundaryPrefix + f.toString(16));
    }
    function ir(l, f, A) {
      var I = l.idPrefix, K = ":" + I + "R" + f;
      return A > 0 && (K += "H" + A.toString(32)), K + ":";
    }
    function Wn(l) {
      return at(l);
    }
    var ar = S("<!-- -->");
    function Xn(l, f, A, I) {
      return f === "" ? I : (I && l.push(ar), l.push(w(Wn(f))), !0);
    }
    function qn(l, f, A, I) {
      A && I && l.push(ar);
    }
    var v = /* @__PURE__ */ new Map();
    function P(l) {
      var f = v.get(l);
      if (f !== void 0)
        return f;
      var A = S(at(An(l)));
      return v.set(l, A), A;
    }
    var _ = S(' style="'), W = S(":"), he = S(";");
    function N(l, f, A) {
      if (typeof A != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var I = !0;
      for (var K in A)
        if (ne.call(A, K)) {
          var se = A[K];
          if (!(se == null || typeof se == "boolean" || se === "")) {
            var ge = void 0, Le = void 0, s = K.indexOf("--") === 0;
            s ? (ge = w(at(K)), U(se, K), Le = w(at(("" + se).trim()))) : (Nt(K, se), ge = P(K), typeof se == "number" ? se !== 0 && !ne.call(Xe, K) ? Le = w(se + "px") : Le = w("" + se) : (U(se, K), Le = w(at(("" + se).trim())))), I ? (I = !1, l.push(_, ge, W, Le)) : l.push(he, ge, W, Le);
          }
        }
      I || l.push(be);
    }
    var z = S(" "), Y = S('="'), be = S('"'), Oe = S('=""');
    function We(l, f, A, I) {
      switch (A) {
        case "style": {
          N(l, f, I);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(A.length > 2 && (A[0] === "o" || A[0] === "O") && (A[1] === "n" || A[1] === "N"))
      ) {
        var K = ue(A);
        if (K !== null) {
          switch (typeof I) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!K.acceptsBooleans)
                return;
          }
          var se = K.attributeName, ge = w(se);
          switch (K.type) {
            case re:
              I && l.push(z, ge, Oe);
              return;
            case $:
              I === !0 ? l.push(z, ge, Oe) : I === !1 || l.push(z, ge, Y, w(at(I)), be);
              return;
            case j:
              isNaN(I) || l.push(z, ge, Y, w(at(I)), be);
              break;
            case oe:
              !isNaN(I) && I >= 1 && l.push(z, ge, Y, w(at(I)), be);
              break;
            default:
              K.sanitizeURL && (L(I, se), I = "" + I, bn(I)), l.push(z, ge, Y, w(at(I)), be);
          }
        } else if (Z(A)) {
          switch (typeof I) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Le = A.toLowerCase().slice(0, 5);
              if (Le !== "data-" && Le !== "aria-")
                return;
            }
          }
          l.push(z, w(A), Y, w(at(I)), be);
        }
      }
    }
    var rt = S(">"), Dt = S("/>");
    function Mt(l, f, A) {
      if (f != null) {
        if (A != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof f != "object" || !("__html" in f))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var I = f.__html;
        I != null && (X(I), l.push(w("" + I)));
      }
    }
    var dn = !1, Xt = !1, tn = !1, Zn = !1, In = !1, or = !1, jn = !1;
    function Ar(l, f) {
      {
        var A = l[f];
        if (A != null) {
          var I = Ln(A);
          l.multiple && !I ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", f) : !l.multiple && I && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", f);
        }
      }
    }
    function ui(l, f, A) {
      mt("select", f), Ar(f, "value"), Ar(f, "defaultValue"), f.value !== void 0 && f.defaultValue !== void 0 && !tn && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), tn = !0), l.push(sr("select"));
      var I = null, K = null;
      for (var se in f)
        if (ne.call(f, se)) {
          var ge = f[se];
          if (ge == null)
            continue;
          switch (se) {
            case "children":
              I = ge;
              break;
            case "dangerouslySetInnerHTML":
              K = ge;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              We(l, A, se, ge);
              break;
          }
        }
      return l.push(rt), Mt(l, K, I), I;
    }
    function na(l) {
      var f = "";
      return e.Children.forEach(l, function(A) {
        A != null && (f += A, !In && typeof A != "string" && typeof A != "number" && (In = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), f;
    }
    var qr = S(' selected=""');
    function Tt(l, f, A, I) {
      var K = I.selectedValue;
      l.push(sr("option"));
      var se = null, ge = null, Le = null, s = null;
      for (var u in f)
        if (ne.call(f, u)) {
          var k = f[u];
          if (k == null)
            continue;
          switch (u) {
            case "children":
              se = k;
              break;
            case "selected":
              Le = k, jn || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), jn = !0);
              break;
            case "dangerouslySetInnerHTML":
              s = k;
              break;
            case "value":
              ge = k;
            default:
              We(l, A, u, k);
              break;
          }
        }
      if (K != null) {
        var E;
        if (ge !== null ? (L(ge, "value"), E = "" + ge) : (s !== null && (or || (or = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), E = na(se)), Ln(K))
          for (var H = 0; H < K.length; H++) {
            L(K[H], "value");
            var te = "" + K[H];
            if (te === E) {
              l.push(qr);
              break;
            }
          }
        else
          L(K, "select.value"), "" + K === E && l.push(qr);
      } else
        Le && l.push(qr);
      return l.push(rt), Mt(l, s, se), se;
    }
    function xn(l, f, A) {
      mt("input", f), f.checked !== void 0 && f.defaultChecked !== void 0 && !Xt && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), Xt = !0), f.value !== void 0 && f.defaultValue !== void 0 && !dn && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", f.type), dn = !0), l.push(sr("input"));
      var I = null, K = null, se = null, ge = null;
      for (var Le in f)
        if (ne.call(f, Le)) {
          var s = f[Le];
          if (s == null)
            continue;
          switch (Le) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              ge = s;
              break;
            case "defaultValue":
              K = s;
              break;
            case "checked":
              se = s;
              break;
            case "value":
              I = s;
              break;
            default:
              We(l, A, Le, s);
              break;
          }
        }
      return se !== null ? We(l, A, "checked", se) : ge !== null && We(l, A, "checked", ge), I !== null ? We(l, A, "value", I) : K !== null && We(l, A, "value", K), l.push(Dt), null;
    }
    function Un(l, f, A) {
      mt("textarea", f), f.value !== void 0 && f.defaultValue !== void 0 && !Zn && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Zn = !0), l.push(sr("textarea"));
      var I = null, K = null, se = null;
      for (var ge in f)
        if (ne.call(f, ge)) {
          var Le = f[ge];
          if (Le == null)
            continue;
          switch (ge) {
            case "children":
              se = Le;
              break;
            case "value":
              I = Le;
              break;
            case "defaultValue":
              K = Le;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              We(l, A, ge, Le);
              break;
          }
        }
      if (I === null && K !== null && (I = K), l.push(rt), se != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), I != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (Ln(se)) {
          if (se.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          X(se[0]), I = "" + se[0];
        }
        X(se), I = "" + se;
      }
      return typeof I == "string" && I[0] === `
` && l.push(Er), I !== null && (L(I, "value"), l.push(w(Wn("" + I)))), null;
    }
    function Lr(l, f, A, I) {
      l.push(sr(A));
      for (var K in f)
        if (ne.call(f, K)) {
          var se = f[K];
          if (se == null)
            continue;
          switch (K) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(A + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              We(l, I, K, se);
              break;
          }
        }
      return l.push(Dt), null;
    }
    function Zr(l, f, A) {
      l.push(sr("menuitem"));
      for (var I in f)
        if (ne.call(f, I)) {
          var K = f[I];
          if (K == null)
            continue;
          switch (I) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              We(l, A, I, K);
              break;
          }
        }
      return l.push(rt), null;
    }
    function $t(l, f, A) {
      l.push(sr("title"));
      var I = null;
      for (var K in f)
        if (ne.call(f, K)) {
          var se = f[K];
          if (se == null)
            continue;
          switch (K) {
            case "children":
              I = se;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              We(l, A, K, se);
              break;
          }
        }
      l.push(rt);
      {
        var ge = Array.isArray(I) && I.length < 2 ? I[0] || null : I;
        Array.isArray(I) && I.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : ge != null && ge.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : ge != null && typeof ge != "string" && typeof ge != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return I;
    }
    function vr(l, f, A, I) {
      l.push(sr(A));
      var K = null, se = null;
      for (var ge in f)
        if (ne.call(f, ge)) {
          var Le = f[ge];
          if (Le == null)
            continue;
          switch (ge) {
            case "children":
              K = Le;
              break;
            case "dangerouslySetInnerHTML":
              se = Le;
              break;
            default:
              We(l, I, ge, Le);
              break;
          }
        }
      return l.push(rt), Mt(l, se, K), typeof K == "string" ? (l.push(w(Wn(K))), null) : K;
    }
    function kn(l, f, A, I) {
      l.push(sr(A));
      var K = null, se = null;
      for (var ge in f)
        if (ne.call(f, ge)) {
          var Le = f[ge];
          if (Le == null)
            continue;
          switch (ge) {
            case "children":
              K = Le;
              break;
            case "dangerouslySetInnerHTML":
              se = Le;
              break;
            case "style":
              N(l, I, Le);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              Z(ge) && typeof Le != "function" && typeof Le != "symbol" && l.push(z, w(ge), Y, w(at(Le)), be);
              break;
          }
        }
      return l.push(rt), Mt(l, se, K), K;
    }
    var Er = S(`
`);
    function Nr(l, f, A, I) {
      l.push(sr(A));
      var K = null, se = null;
      for (var ge in f)
        if (ne.call(f, ge)) {
          var Le = f[ge];
          if (Le == null)
            continue;
          switch (ge) {
            case "children":
              K = Le;
              break;
            case "dangerouslySetInnerHTML":
              se = Le;
              break;
            default:
              We(l, I, ge, Le);
              break;
          }
        }
      if (l.push(rt), se != null) {
        if (K != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof se != "object" || !("__html" in se))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var s = se.__html;
        s != null && (typeof s == "string" && s.length > 0 && s[0] === `
` ? l.push(Er, w(s)) : (X(s), l.push(w("" + s))));
      }
      return typeof K == "string" && K[0] === `
` && l.push(Er), K;
    }
    var Ci = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Rr = /* @__PURE__ */ new Map();
    function sr(l) {
      var f = Rr.get(l);
      if (f === void 0) {
        if (!Ci.test(l))
          throw new Error("Invalid tag: " + l);
        f = S("<" + l), Rr.set(l, f);
      }
      return f;
    }
    var ra = S("<!DOCTYPE html>");
    function ia(l, f, A, I, K) {
      switch (it(f, A), Ce(f, A), qt(f, A, null), !A.suppressContentEditableWarning && A.contentEditable && A.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), K.insertionMode !== sn && K.insertionMode !== pn && f.indexOf("-") === -1 && typeof A.is != "string" && f.toLowerCase() !== f && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", f), f) {
        case "select":
          return ui(l, A, I);
        case "option":
          return Tt(l, A, I, K);
        case "textarea":
          return Un(l, A, I);
        case "input":
          return xn(l, A, I);
        case "menuitem":
          return Zr(l, A, I);
        case "title":
          return $t(l, A, I);
        case "listing":
        case "pre":
          return Nr(l, A, f, I);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Lr(l, A, f, I);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return vr(l, A, f, I);
        case "html":
          return K.insertionMode === wn && l.push(ra), vr(l, A, f, I);
        default:
          return f.indexOf("-") === -1 && typeof A.is != "string" ? vr(l, A, f, I) : kn(l, A, f, I);
      }
    }
    var Ga = S("</"), Ya = S(">");
    function Xa(l, f, A) {
      switch (f) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          l.push(Ga, w(f), Ya);
      }
    }
    function ds(l, f) {
      for (var A = f.bootstrapChunks, I = 0; I < A.length - 1; I++)
        g(l, A[I]);
      return I < A.length ? b(l, A[I]) : !0;
    }
    var hs = S('<template id="'), Ai = S('"></template>');
    function Li(l, f, A) {
      g(l, hs), g(l, f.placeholderPrefix);
      var I = w(A.toString(16));
      return g(l, I), b(l, Ai);
    }
    var Ei = S("<!--$-->"), ci = S('<!--$?--><template id="'), fs = S('"></template>'), di = S("<!--$!-->"), aa = S("<!--/$-->"), oa = S("<template"), Qr = S('"'), Jr = S(' data-dgst="'), _i = S(' data-msg="'), qa = S(' data-stck="'), sa = S("></template>");
    function Za(l, f) {
      return b(l, Ei);
    }
    function Pi(l, f, A) {
      if (g(l, ci), A === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(l, A), b(l, fs);
    }
    function Kn(l, f, A, I, K) {
      var se;
      return se = b(l, di), g(l, oa), A && (g(l, Jr), g(l, w(at(A))), g(l, Qr)), I && (g(l, _i), g(l, w(at(I))), g(l, Qr)), K && (g(l, qa), g(l, w(at(K))), g(l, Qr)), se = b(l, sa), se;
    }
    function Qa(l, f) {
      return b(l, aa);
    }
    function Ni(l, f) {
      return b(l, aa);
    }
    function ps(l, f) {
      return b(l, aa);
    }
    var Ja = S('<div hidden id="'), Ri = S('">'), eo = S("</div>"), to = S('<svg aria-hidden="true" style="display:none" id="'), Di = S('">'), Oi = S("</svg>"), no = S('<math aria-hidden="true" style="display:none" id="'), ro = S('">'), io = S("</math>"), la = S('<table hidden id="'), ao = S('">'), x = S("</table>"), R = S('<table hidden><tbody id="'), V = S('">'), Q = S("</tbody></table>"), Te = S('<table hidden><tr id="'), we = S('">'), Pe = S("</tr></table>"), He = S('<table hidden><colgroup id="'), vt = S('">'), Ct = S("</colgroup></table>");
    function kt(l, f, A, I) {
      switch (A.insertionMode) {
        case wn:
        case Ut:
          return g(l, Ja), g(l, f.segmentPrefix), g(l, w(I.toString(16))), b(l, Ri);
        case sn:
          return g(l, to), g(l, f.segmentPrefix), g(l, w(I.toString(16))), b(l, Di);
        case pn:
          return g(l, no), g(l, f.segmentPrefix), g(l, w(I.toString(16))), b(l, ro);
        case Bt:
          return g(l, la), g(l, f.segmentPrefix), g(l, w(I.toString(16))), b(l, ao);
        case rr:
          return g(l, R), g(l, f.segmentPrefix), g(l, w(I.toString(16))), b(l, V);
        case Mn:
          return g(l, Te), g(l, f.segmentPrefix), g(l, w(I.toString(16))), b(l, we);
        case Pn:
          return g(l, He), g(l, f.segmentPrefix), g(l, w(I.toString(16))), b(l, vt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function en(l, f) {
      switch (f.insertionMode) {
        case wn:
        case Ut:
          return b(l, eo);
        case sn:
          return b(l, Oi);
        case pn:
          return b(l, io);
        case Bt:
          return b(l, x);
        case rr:
          return b(l, Q);
        case Mn:
          return b(l, Pe);
        case Pn:
          return b(l, Ct);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Gn = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", lr = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', ur = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Mi = S(Gn + ';$RS("'), oo = S('$RS("'), ua = S('","'), Zc = S('")<\/script>');
    function Qc(l, f, A) {
      g(l, f.startInlineScript), f.sentCompleteSegmentFunction ? g(l, oo) : (f.sentCompleteSegmentFunction = !0, g(l, Mi)), g(l, f.segmentPrefix);
      var I = w(A.toString(16));
      return g(l, I), g(l, ua), g(l, f.placeholderPrefix), g(l, I), b(l, Zc);
    }
    var Jc = S(lr + ';$RC("'), ed = S('$RC("'), td = S('","'), nd = S('")<\/script>');
    function ms(l, f, A, I) {
      if (g(l, f.startInlineScript), f.sentCompleteBoundaryFunction ? g(l, ed) : (f.sentCompleteBoundaryFunction = !0, g(l, Jc)), A === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var K = w(I.toString(16));
      return g(l, A), g(l, td), g(l, f.segmentPrefix), g(l, K), b(l, nd);
    }
    var rd = S(ur + ';$RX("'), id = S('$RX("'), ys = S('"'), ad = S(")<\/script>"), gs = S(",");
    function Vl(l, f, A, I, K, se) {
      if (g(l, f.startInlineScript), f.sentClientRenderFunction ? g(l, id) : (f.sentClientRenderFunction = !0, g(l, rd)), A === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return g(l, A), g(l, ys), (I || K || se) && (g(l, gs), g(l, w(vs(I || "")))), (K || se) && (g(l, gs), g(l, w(vs(K || "")))), se && (g(l, gs), g(l, w(vs(se)))), b(l, ad);
    }
    var Wl = /[<\u2028\u2029]/g;
    function vs(l) {
      var f = JSON.stringify(l);
      return f.replace(Wl, function(A) {
        switch (A) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var br = Object.assign, od = Symbol.for("react.element"), jl = Symbol.for("react.portal"), cr = Symbol.for("react.fragment"), Ul = Symbol.for("react.strict_mode"), bs = Symbol.for("react.profiler"), so = Symbol.for("react.provider"), lo = Symbol.for("react.context"), uo = Symbol.for("react.forward_ref"), ca = Symbol.for("react.suspense"), da = Symbol.for("react.suspense_list"), ha = Symbol.for("react.memo"), Ii = Symbol.for("react.lazy"), xs = Symbol.for("react.scope"), Ss = Symbol.for("react.debug_trace_mode"), co = Symbol.for("react.legacy_hidden"), sd = Symbol.for("react.default_value"), Kl = Symbol.iterator, ld = "@@iterator";
    function ud(l) {
      if (l === null || typeof l != "object")
        return null;
      var f = Kl && l[Kl] || l[ld];
      return typeof f == "function" ? f : null;
    }
    function Gl(l, f, A) {
      var I = l.displayName;
      if (I)
        return I;
      var K = f.displayName || f.name || "";
      return K !== "" ? A + "(" + K + ")" : A;
    }
    function Yl(l) {
      return l.displayName || "Context";
    }
    function ln(l) {
      if (l == null)
        return null;
      if (typeof l.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof l == "function")
        return l.displayName || l.name || null;
      if (typeof l == "string")
        return l;
      switch (l) {
        case cr:
          return "Fragment";
        case jl:
          return "Portal";
        case bs:
          return "Profiler";
        case Ul:
          return "StrictMode";
        case ca:
          return "Suspense";
        case da:
          return "SuspenseList";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case lo:
            var f = l;
            return Yl(f) + ".Consumer";
          case so:
            var A = l;
            return Yl(A._context) + ".Provider";
          case uo:
            return Gl(l, l.render, "ForwardRef");
          case ha:
            var I = l.displayName || null;
            return I !== null ? I : ln(l.type) || "Memo";
          case Ii: {
            var K = l, se = K._payload, ge = K._init;
            try {
              return ln(ge(se));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var fa = 0, ws, nn, Fi, ks, Ts, Cs, As;
    function Ls() {
    }
    Ls.__reactDisabledLog = !0;
    function Xl() {
      {
        if (fa === 0) {
          ws = console.log, nn = console.info, Fi = console.warn, ks = console.error, Ts = console.group, Cs = console.groupCollapsed, As = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: Ls,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        fa++;
      }
    }
    function ql() {
      {
        if (fa--, fa === 0) {
          var l = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: br({}, l, {
              value: ws
            }),
            info: br({}, l, {
              value: nn
            }),
            warn: br({}, l, {
              value: Fi
            }),
            error: br({}, l, {
              value: ks
            }),
            group: br({}, l, {
              value: Ts
            }),
            groupCollapsed: br({}, l, {
              value: Cs
            }),
            groupEnd: br({}, l, {
              value: As
            })
          });
        }
        fa < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ho = n.ReactCurrentDispatcher, Es;
    function pa(l, f, A) {
      {
        if (Es === void 0)
          try {
            throw Error();
          } catch (K) {
            var I = K.stack.trim().match(/\n( *(at )?)/);
            Es = I && I[1] || "";
          }
        return `
` + Es + l;
      }
    }
    var ma = !1, Bi;
    {
      var ya = typeof WeakMap == "function" ? WeakMap : Map;
      Bi = new ya();
    }
    function ga(l, f) {
      if (!l || ma)
        return "";
      {
        var A = Bi.get(l);
        if (A !== void 0)
          return A;
      }
      var I;
      ma = !0;
      var K = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var se;
      se = ho.current, ho.current = null, Xl();
      try {
        if (f) {
          var ge = function() {
            throw Error();
          };
          if (Object.defineProperty(ge.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ge, []);
            } catch (pe) {
              I = pe;
            }
            Reflect.construct(l, [], ge);
          } else {
            try {
              ge.call();
            } catch (pe) {
              I = pe;
            }
            l.call(ge.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (pe) {
            I = pe;
          }
          l();
        }
      } catch (pe) {
        if (pe && I && typeof pe.stack == "string") {
          for (var Le = pe.stack.split(`
`), s = I.stack.split(`
`), u = Le.length - 1, k = s.length - 1; u >= 1 && k >= 0 && Le[u] !== s[k]; )
            k--;
          for (; u >= 1 && k >= 0; u--, k--)
            if (Le[u] !== s[k]) {
              if (u !== 1 || k !== 1)
                do
                  if (u--, k--, k < 0 || Le[u] !== s[k]) {
                    var E = `
` + Le[u].replace(" at new ", " at ");
                    return l.displayName && E.includes("<anonymous>") && (E = E.replace("<anonymous>", l.displayName)), typeof l == "function" && Bi.set(l, E), E;
                  }
                while (u >= 1 && k >= 0);
              break;
            }
        }
      } finally {
        ma = !1, ho.current = se, ql(), Error.prepareStackTrace = K;
      }
      var H = l ? l.displayName || l.name : "", te = H ? pa(H) : "";
      return typeof l == "function" && Bi.set(l, te), te;
    }
    function fo(l, f, A) {
      return ga(l, !0);
    }
    function Zl(l, f, A) {
      return ga(l, !1);
    }
    function _s(l) {
      var f = l.prototype;
      return !!(f && f.isReactComponent);
    }
    function Ps(l, f, A) {
      if (l == null)
        return "";
      if (typeof l == "function")
        return ga(l, _s(l));
      if (typeof l == "string")
        return pa(l);
      switch (l) {
        case ca:
          return pa("Suspense");
        case da:
          return pa("SuspenseList");
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case uo:
            return Zl(l.render);
          case ha:
            return Ps(l.type, f, A);
          case Ii: {
            var I = l, K = I._payload, se = I._init;
            try {
              return Ps(se(K), f, A);
            } catch {
            }
          }
        }
      return "";
    }
    var Ns = {}, Ql = n.ReactDebugCurrentFrame;
    function zi(l) {
      if (l) {
        var f = l._owner, A = Ps(l.type, l._source, f ? f.type : null);
        Ql.setExtraStackFrame(A);
      } else
        Ql.setExtraStackFrame(null);
    }
    function Rs(l, f, A, I, K) {
      {
        var se = Function.call.bind(ne);
        for (var ge in l)
          if (se(l, ge)) {
            var Le = void 0;
            try {
              if (typeof l[ge] != "function") {
                var s = Error((I || "React class") + ": " + A + " type `" + ge + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[ge] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw s.name = "Invariant Violation", s;
              }
              Le = l[ge](f, ge, I, A, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (u) {
              Le = u;
            }
            Le && !(Le instanceof Error) && (zi(K), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", I || "React class", A, ge, typeof Le), zi(null)), Le instanceof Error && !(Le.message in Ns) && (Ns[Le.message] = !0, zi(K), i("Failed %s type: %s", A, Le.message), zi(null));
          }
      }
    }
    var po;
    po = {};
    var hi = {};
    Object.freeze(hi);
    function Ds(l, f) {
      {
        var A = l.contextTypes;
        if (!A)
          return hi;
        var I = {};
        for (var K in A)
          I[K] = f[K];
        {
          var se = ln(l) || "Unknown";
          Rs(A, I, "context", se);
        }
        return I;
      }
    }
    function Os(l, f, A, I) {
      {
        if (typeof l.getChildContext != "function") {
          {
            var K = ln(f) || "Unknown";
            po[K] || (po[K] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", K, K));
          }
          return A;
        }
        var se = l.getChildContext();
        for (var ge in se)
          if (!(ge in I))
            throw new Error((ln(f) || "Unknown") + '.getChildContext(): key "' + ge + '" is not defined in childContextTypes.');
        {
          var Le = ln(f) || "Unknown";
          Rs(I, se, "child context", Le);
        }
        return br({}, A, se);
      }
    }
    var ei;
    ei = {};
    var Jl = null, fi = null;
    function pi(l) {
      l.context._currentValue = l.parentValue;
    }
    function Ms(l) {
      l.context._currentValue = l.value;
    }
    function Dr(l, f) {
      if (l !== f) {
        pi(l);
        var A = l.parent, I = f.parent;
        if (A === null) {
          if (I !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (I === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          Dr(A, I);
        }
        Ms(f);
      }
    }
    function mo(l) {
      pi(l);
      var f = l.parent;
      f !== null && mo(f);
    }
    function yo(l) {
      var f = l.parent;
      f !== null && yo(f), Ms(l);
    }
    function va(l, f) {
      pi(l);
      var A = l.parent;
      if (A === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      A.depth === f.depth ? Dr(A, f) : va(A, f);
    }
    function Is(l, f) {
      var A = f.parent;
      if (A === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      l.depth === A.depth ? Dr(l, A) : Is(l, A), Ms(f);
    }
    function ba(l) {
      var f = fi, A = l;
      f !== A && (f === null ? yo(A) : A === null ? mo(f) : f.depth === A.depth ? Dr(f, A) : f.depth > A.depth ? va(f, A) : Is(f, A), fi = A);
    }
    function eu(l, f) {
      var A;
      A = l._currentValue, l._currentValue = f, l._currentRenderer !== void 0 && l._currentRenderer !== null && l._currentRenderer !== ei && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer = ei;
      var I = fi, K = {
        parent: I,
        depth: I === null ? 0 : I.depth + 1,
        context: l,
        parentValue: A,
        value: f
      };
      return fi = K, K;
    }
    function tu(l) {
      var f = fi;
      if (f === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      f.context !== l && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var A = f.parentValue;
        A === sd ? f.context._currentValue = f.context._defaultValue : f.context._currentValue = A, l._currentRenderer !== void 0 && l._currentRenderer !== null && l._currentRenderer !== ei && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer = ei;
      }
      return fi = f.parent;
    }
    function go() {
      return fi;
    }
    function xa(l) {
      var f = l._currentValue;
      return f;
    }
    function Fs(l) {
      return l._reactInternals;
    }
    function cd(l, f) {
      l._reactInternals = f;
    }
    var $i = {}, vo = {}, Bs, bo, xo, Sa, So, Hi, wa, wo, Vi;
    {
      Bs = /* @__PURE__ */ new Set(), bo = /* @__PURE__ */ new Set(), xo = /* @__PURE__ */ new Set(), wa = /* @__PURE__ */ new Set(), Sa = /* @__PURE__ */ new Set(), wo = /* @__PURE__ */ new Set(), Vi = /* @__PURE__ */ new Set();
      var ko = /* @__PURE__ */ new Set();
      Hi = function(l, f) {
        if (!(l === null || typeof l == "function")) {
          var A = f + "_" + l;
          ko.has(A) || (ko.add(A), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, l));
        }
      }, So = function(l, f) {
        if (f === void 0) {
          var A = ln(l) || "Component";
          Sa.has(A) || (Sa.add(A), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", A));
        }
      };
    }
    function To(l, f) {
      {
        var A = l.constructor, I = A && ln(A) || "ReactClass", K = I + "." + f;
        if ($i[K])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, f, f, I), $i[K] = !0;
      }
    }
    var Co = {
      isMounted: function(l) {
        return !1;
      },
      enqueueSetState: function(l, f, A) {
        var I = Fs(l);
        I.queue === null ? To(l, "setState") : (I.queue.push(f), A != null && Hi(A, "setState"));
      },
      enqueueReplaceState: function(l, f, A) {
        var I = Fs(l);
        I.replace = !0, I.queue = [f], A != null && Hi(A, "setState");
      },
      enqueueForceUpdate: function(l, f) {
        var A = Fs(l);
        A.queue === null ? To(l, "forceUpdate") : f != null && Hi(f, "setState");
      }
    };
    function nu(l, f, A, I, K) {
      var se = A(K, I);
      So(f, se);
      var ge = se == null ? I : br({}, I, se);
      return ge;
    }
    function ru(l, f, A) {
      var I = hi, K = l.contextType;
      if ("contextType" in l) {
        var se = (
          // Allow null for conditional declaration
          K === null || K !== void 0 && K.$$typeof === lo && K._context === void 0
        );
        if (!se && !Vi.has(l)) {
          Vi.add(l);
          var ge = "";
          K === void 0 ? ge = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof K != "object" ? ge = " However, it is set to a " + typeof K + "." : K.$$typeof === so ? ge = " Did you accidentally pass the Context.Provider instead?" : K._context !== void 0 ? ge = " Did you accidentally pass the Context.Consumer instead?" : ge = " However, it is set to an object with keys {" + Object.keys(K).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", ln(l) || "Component", ge);
        }
      }
      typeof K == "object" && K !== null ? I = xa(K) : I = A;
      var Le = new l(f, I);
      {
        if (typeof l.getDerivedStateFromProps == "function" && (Le.state === null || Le.state === void 0)) {
          var s = ln(l) || "Component";
          Bs.has(s) || (Bs.add(s), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", s, Le.state === null ? "null" : "undefined", s));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof Le.getSnapshotBeforeUpdate == "function") {
          var u = null, k = null, E = null;
          if (typeof Le.componentWillMount == "function" && Le.componentWillMount.__suppressDeprecationWarning !== !0 ? u = "componentWillMount" : typeof Le.UNSAFE_componentWillMount == "function" && (u = "UNSAFE_componentWillMount"), typeof Le.componentWillReceiveProps == "function" && Le.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? k = "componentWillReceiveProps" : typeof Le.UNSAFE_componentWillReceiveProps == "function" && (k = "UNSAFE_componentWillReceiveProps"), typeof Le.componentWillUpdate == "function" && Le.componentWillUpdate.__suppressDeprecationWarning !== !0 ? E = "componentWillUpdate" : typeof Le.UNSAFE_componentWillUpdate == "function" && (E = "UNSAFE_componentWillUpdate"), u !== null || k !== null || E !== null) {
            var H = ln(l) || "Component", te = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            xo.has(H) || (xo.add(H), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, H, te, u !== null ? `
  ` + u : "", k !== null ? `
  ` + k : "", E !== null ? `
  ` + E : ""));
          }
        }
      }
      return Le;
    }
    function iu(l, f, A) {
      {
        var I = ln(f) || "Component", K = l.render;
        K || (f.prototype && typeof f.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", I) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", I)), l.getInitialState && !l.getInitialState.isReactClassApproved && !l.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", I), l.getDefaultProps && !l.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", I), l.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", I), l.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", I), l.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", I), f.contextType && f.contextTypes && !wo.has(f) && (wo.add(f), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", I)), typeof l.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", I), f.prototype && f.prototype.isPureReactComponent && typeof l.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", ln(f) || "A pure component"), typeof l.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", I), typeof l.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", I), typeof l.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", I), typeof l.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", I);
        var se = l.props !== A;
        l.props !== void 0 && se && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", I, I), l.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", I, I), typeof l.getSnapshotBeforeUpdate == "function" && typeof l.componentDidUpdate != "function" && !bo.has(f) && (bo.add(f), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", ln(f))), typeof l.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", I), typeof l.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", I), typeof f.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", I);
        var ge = l.state;
        ge && (typeof ge != "object" || Ln(ge)) && i("%s.state: must be set to an object or null", I), typeof l.getChildContext == "function" && typeof f.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", I);
      }
    }
    function dd(l, f) {
      var A = f.state;
      if (typeof f.componentWillMount == "function") {
        if (f.componentWillMount.__suppressDeprecationWarning !== !0) {
          var I = ln(l) || "Unknown";
          vo[I] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            I
          ), vo[I] = !0);
        }
        f.componentWillMount();
      }
      typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), A !== f.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", ln(l) || "Component"), Co.enqueueReplaceState(f, f.state, null));
    }
    function hd(l, f, A, I) {
      if (l.queue !== null && l.queue.length > 0) {
        var K = l.queue, se = l.replace;
        if (l.queue = null, l.replace = !1, se && K.length === 1)
          f.state = K[0];
        else {
          for (var ge = se ? K[0] : f.state, Le = !0, s = se ? 1 : 0; s < K.length; s++) {
            var u = K[s], k = typeof u == "function" ? u.call(f, ge, A, I) : u;
            k != null && (Le ? (Le = !1, ge = br({}, ge, k)) : br(ge, k));
          }
          f.state = ge;
        }
      } else
        l.queue = null;
    }
    function au(l, f, A, I) {
      iu(l, f, A);
      var K = l.state !== void 0 ? l.state : null;
      l.updater = Co, l.props = A, l.state = K;
      var se = {
        queue: [],
        replace: !1
      };
      cd(l, se);
      var ge = f.contextType;
      if (typeof ge == "object" && ge !== null ? l.context = xa(ge) : l.context = I, l.state === A) {
        var Le = ln(f) || "Component";
        wa.has(Le) || (wa.add(Le), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Le));
      }
      var s = f.getDerivedStateFromProps;
      typeof s == "function" && (l.state = nu(l, f, s, K, A)), typeof f.getDerivedStateFromProps != "function" && typeof l.getSnapshotBeforeUpdate != "function" && (typeof l.UNSAFE_componentWillMount == "function" || typeof l.componentWillMount == "function") && (dd(f, l), hd(se, l, A, I));
    }
    var fd = {
      id: 1,
      overflow: ""
    };
    function pd(l) {
      var f = l.overflow, A = l.id, I = A & ~md(A);
      return I.toString(32) + f;
    }
    function Ao(l, f, A) {
      var I = l.id, K = l.overflow, se = Lo(I) - 1, ge = I & ~(1 << se), Le = A + 1, s = Lo(f) + se;
      if (s > 30) {
        var u = se - se % 5, k = (1 << u) - 1, E = (ge & k).toString(32), H = ge >> u, te = se - u, pe = Lo(f) + te, Ae = Le << te, Me = Ae | H, Qe = E + K;
        return {
          id: 1 << pe | Me,
          overflow: Qe
        };
      } else {
        var nt = Le << se, St = nt | ge, rn = K;
        return {
          id: 1 << s | St,
          overflow: rn
        };
      }
    }
    function Lo(l) {
      return 32 - zs(l);
    }
    function md(l) {
      return 1 << Lo(l) - 1;
    }
    var zs = Math.clz32 ? Math.clz32 : gd, Eo = Math.log, yd = Math.LN2;
    function gd(l) {
      var f = l >>> 0;
      return f === 0 ? 32 : 31 - (Eo(f) / yd | 0) | 0;
    }
    function vd(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var bd = typeof Object.is == "function" ? Object.is : vd, $r = null, $s = null, _o = null, Ot = null, mi = !1, yi = !1, Kt = 0, xr = null, gi = 0, Po = 25, Fn = !1, Hr;
    function vi() {
      if ($r === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Fn && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), $r;
    }
    function Or(l, f) {
      if (f === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Hr), !1;
      l.length !== f.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Hr, "[" + l.join(", ") + "]", "[" + f.join(", ") + "]");
      for (var A = 0; A < f.length && A < l.length; A++)
        if (!bd(l[A], f[A]))
          return !1;
      return !0;
    }
    function bi() {
      if (gi > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Vr() {
      return Ot === null ? _o === null ? (mi = !1, _o = Ot = bi()) : (mi = !0, Ot = _o) : Ot.next === null ? (mi = !1, Ot = Ot.next = bi()) : (mi = !0, Ot = Ot.next), Ot;
    }
    function xd(l, f) {
      $r = f, $s = l, Fn = !1, Kt = 0;
    }
    function ou(l, f, A, I) {
      for (; yi; )
        yi = !1, Kt = 0, gi += 1, Ot = null, A = l(f, I);
      return Hs(), A;
    }
    function No() {
      var l = Kt !== 0;
      return l;
    }
    function Hs() {
      Fn = !1, $r = null, $s = null, yi = !1, _o = null, gi = 0, xr = null, Ot = null;
    }
    function Sd(l) {
      return Fn && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), xa(l);
    }
    function su(l) {
      return Hr = "useContext", vi(), xa(l);
    }
    function ka(l, f) {
      return typeof f == "function" ? f(l) : f;
    }
    function wd(l) {
      return Hr = "useState", lu(
        ka,
        // useReducer has a special case to support lazy useState initializers
        l
      );
    }
    function lu(l, f, A) {
      if (l !== ka && (Hr = "useReducer"), $r = vi(), Ot = Vr(), mi) {
        var I = Ot.queue, K = I.dispatch;
        if (xr !== null) {
          var se = xr.get(I);
          if (se !== void 0) {
            xr.delete(I);
            var ge = Ot.memoizedState, Le = se;
            do {
              var s = Le.action;
              Fn = !0, ge = l(ge, s), Fn = !1, Le = Le.next;
            } while (Le !== null);
            return Ot.memoizedState = ge, [ge, K];
          }
        }
        return [Ot.memoizedState, K];
      } else {
        Fn = !0;
        var u;
        l === ka ? u = typeof f == "function" ? f() : f : u = A !== void 0 ? A(f) : f, Fn = !1, Ot.memoizedState = u;
        var k = Ot.queue = {
          last: null,
          dispatch: null
        }, E = k.dispatch = cu.bind(null, $r, k);
        return [Ot.memoizedState, E];
      }
    }
    function Ro(l, f) {
      $r = vi(), Ot = Vr();
      var A = f === void 0 ? null : f;
      if (Ot !== null) {
        var I = Ot.memoizedState;
        if (I !== null && A !== null) {
          var K = I[1];
          if (Or(A, K))
            return I[0];
        }
      }
      Fn = !0;
      var se = l();
      return Fn = !1, Ot.memoizedState = [se, A], se;
    }
    function kd(l) {
      $r = vi(), Ot = Vr();
      var f = Ot.memoizedState;
      if (f === null) {
        var A = {
          current: l
        };
        return Object.seal(A), Ot.memoizedState = A, A;
      } else
        return f;
    }
    function uu(l, f) {
      Hr = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function cu(l, f, A) {
      if (gi >= Po)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (l === $r) {
        yi = !0;
        var I = {
          action: A,
          next: null
        };
        xr === null && (xr = /* @__PURE__ */ new Map());
        var K = xr.get(f);
        if (K === void 0)
          xr.set(f, I);
        else {
          for (var se = K; se.next !== null; )
            se = se.next;
          se.next = I;
        }
      }
    }
    function Td(l, f) {
      return Ro(function() {
        return l;
      }, f);
    }
    function Cd(l, f, A) {
      return vi(), f(l._source);
    }
    function Ad(l, f, A) {
      if (A === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return A();
    }
    function Ld(l) {
      return vi(), l;
    }
    function Ed() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function _d() {
      return vi(), [!1, Ed];
    }
    function Pd() {
      var l = $s, f = pd(l.treeContext), A = Vs;
      if (A === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var I = Kt++;
      return ir(A, f, I);
    }
    function Do() {
    }
    var du = {
      readContext: Sd,
      useContext: su,
      useMemo: Ro,
      useReducer: lu,
      useRef: kd,
      useState: wd,
      useInsertionEffect: Do,
      useLayoutEffect: uu,
      useCallback: Td,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: Do,
      // Effects are not run in the server environment.
      useEffect: Do,
      // Debugging effect
      useDebugValue: Do,
      useDeferredValue: Ld,
      useTransition: _d,
      useId: Pd,
      // Subscriptions are not setup in a server environment.
      useMutableSource: Cd,
      useSyncExternalStore: Ad
    }, Vs = null;
    function Ta(l) {
      Vs = l;
    }
    function hu(l) {
      try {
        var f = "", A = l;
        do {
          switch (A.tag) {
            case 0:
              f += pa(A.type, null, null);
              break;
            case 1:
              f += Zl(A.type, null, null);
              break;
            case 2:
              f += fo(A.type, null, null);
              break;
          }
          A = A.parent;
        } while (A);
        return f;
      } catch (I) {
        return `
Error generating stack: ` + I.message + `
` + I.stack;
      }
    }
    var Ca = n.ReactCurrentDispatcher, Oo = n.ReactDebugCurrentFrame, Ws = 0, ti = 1, Mo = 2, Io = 3, xi = 4, fu = 0, js = 1, Si = 2, Nd = 12800;
    function pu(l) {
      return console.error(l), null;
    }
    function Mr() {
    }
    function Rd(l, f, A, I, K, se, ge, Le, s) {
      var u = [], k = /* @__PURE__ */ new Set(), E = {
        destination: null,
        responseState: f,
        progressiveChunkSize: I === void 0 ? Nd : I,
        status: fu,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: k,
        pingedTasks: u,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: K === void 0 ? pu : K,
        onAllReady: se === void 0 ? Mr : se,
        onShellReady: ge === void 0 ? Mr : ge,
        onShellError: Le === void 0 ? Mr : Le,
        onFatalError: s === void 0 ? Mr : s
      }, H = Fo(
        E,
        0,
        null,
        A,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      H.parentFlushed = !0;
      var te = Us(E, l, null, H, k, hi, Jl, fd);
      return u.push(te), E;
    }
    function Dd(l, f) {
      var A = l.pingedTasks;
      A.push(f), A.length === 1 && h(function() {
        return Na(l);
      });
    }
    function Aa(l, f) {
      return {
        id: yr,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: f,
        errorDigest: null
      };
    }
    function Us(l, f, A, I, K, se, ge, Le) {
      l.allPendingTasks++, A === null ? l.pendingRootTasks++ : A.pendingTasks++;
      var s = {
        node: f,
        ping: function() {
          return Dd(l, s);
        },
        blockedBoundary: A,
        blockedSegment: I,
        abortSet: K,
        legacyContext: se,
        context: ge,
        treeContext: Le
      };
      return s.componentStack = null, K.add(s), s;
    }
    function Fo(l, f, A, I, K, se) {
      return {
        status: Ws,
        id: -1,
        // lazily assigned later
        index: f,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: I,
        boundary: A,
        lastPushedText: K,
        textEmbedded: se
      };
    }
    var Wr = null;
    function La() {
      return Wr === null || Wr.componentStack === null ? "" : hu(Wr.componentStack);
    }
    function ni(l, f) {
      l.componentStack = {
        tag: 0,
        parent: l.componentStack,
        type: f
      };
    }
    function Ir(l, f) {
      l.componentStack = {
        tag: 1,
        parent: l.componentStack,
        type: f
      };
    }
    function Ks(l, f) {
      l.componentStack = {
        tag: 2,
        parent: l.componentStack,
        type: f
      };
    }
    function Sr(l) {
      l.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : l.componentStack = l.componentStack.parent;
    }
    var Wi = null;
    function Gs(l, f) {
      {
        var A;
        typeof f == "string" ? A = f : f && typeof f.message == "string" ? A = f.message : A = String(f);
        var I = Wi || La();
        Wi = null, l.errorMessage = A, l.errorComponentStack = I;
      }
    }
    function wr(l, f) {
      var A = l.onError(f);
      if (A != null && typeof A != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof A + '" instead');
      return A;
    }
    function ri(l, f) {
      var A = l.onShellError;
      A(f);
      var I = l.onFatalError;
      I(f), l.destination !== null ? (l.status = Si, B(l.destination, f)) : (l.status = js, l.fatalError = f);
    }
    function Ys(l, f, A) {
      ni(f, "Suspense");
      var I = f.blockedBoundary, K = f.blockedSegment, se = A.fallback, ge = A.children, Le = /* @__PURE__ */ new Set(), s = Aa(l, Le), u = K.chunks.length, k = Fo(
        l,
        u,
        s,
        K.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      K.children.push(k), K.lastPushedText = !1;
      var E = Fo(
        l,
        0,
        null,
        K.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      E.parentFlushed = !0, f.blockedBoundary = s, f.blockedSegment = E;
      try {
        if (il(l, f, ge), qn(E.chunks, l.responseState, E.lastPushedText, E.textEmbedded), E.status = ti, $o(s, E), s.pendingTasks === 0) {
          Sr(f);
          return;
        }
      } catch (te) {
        E.status = xi, s.forceClientRender = !0, s.errorDigest = wr(l, te), Gs(s, te);
      } finally {
        f.blockedBoundary = I, f.blockedSegment = K;
      }
      var H = Us(l, se, I, k, Le, f.legacyContext, f.context, f.treeContext);
      H.componentStack = f.componentStack, l.pingedTasks.push(H), Sr(f);
    }
    function Ea(l, f, A, I) {
      ni(f, A);
      var K = f.blockedSegment, se = ia(K.chunks, A, I, l.responseState, K.formatContext);
      K.lastPushedText = !1;
      var ge = K.formatContext;
      K.formatContext = Vn(ge, A, I), il(l, f, se), K.formatContext = ge, Xa(K.chunks, A), K.lastPushedText = !1, Sr(f);
    }
    function Bo(l) {
      return l.prototype && l.prototype.isReactComponent;
    }
    function mu(l, f, A, I, K) {
      var se = {};
      xd(f, se);
      var ge = A(I, K);
      return ou(A, I, ge, K);
    }
    function yu(l, f, A, I, K) {
      var se = A.render();
      A.props !== K && (Pa || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", ln(I) || "a component"), Pa = !0);
      {
        var ge = I.childContextTypes;
        if (ge != null) {
          var Le = f.legacyContext, s = Os(A, I, Le, ge);
          f.legacyContext = s, dr(l, f, se), f.legacyContext = Le;
          return;
        }
      }
      dr(l, f, se);
    }
    function Od(l, f, A, I) {
      Ks(f, A);
      var K = Ds(A, f.legacyContext), se = ru(A, I, K);
      au(se, A, I, K), yu(l, f, se, A, I), Sr(f);
    }
    var Xs = {}, _a = {}, gu = {}, qs = {}, Pa = !1, Zs = {}, Qs = !1, Js = !1, el = !1;
    function vu(l, f, A, I) {
      var K;
      if (K = Ds(A, f.legacyContext), Ir(f, A), A.prototype && typeof A.prototype.render == "function") {
        var se = ln(A) || "Unknown";
        Xs[se] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", se, se), Xs[se] = !0);
      }
      var ge = mu(l, f, A, I, K), Le = No();
      if (typeof ge == "object" && ge !== null && typeof ge.render == "function" && ge.$$typeof === void 0) {
        var s = ln(A) || "Unknown";
        _a[s] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", s, s, s), _a[s] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof ge == "object" && ge !== null && typeof ge.render == "function" && ge.$$typeof === void 0
      ) {
        {
          var u = ln(A) || "Unknown";
          _a[u] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", u, u, u), _a[u] = !0);
        }
        au(ge, A, I, K), yu(l, f, ge, A, I);
      } else if (bu(A), Le) {
        var k = f.treeContext, E = 1, H = 0;
        f.treeContext = Ao(k, E, H);
        try {
          dr(l, f, ge);
        } finally {
          f.treeContext = k;
        }
      } else
        dr(l, f, ge);
      Sr(f);
    }
    function bu(l) {
      {
        if (l && l.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), l.defaultProps !== void 0) {
          var f = ln(l) || "Unknown";
          Zs[f] || (i("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", f), Zs[f] = !0);
        }
        if (typeof l.getDerivedStateFromProps == "function") {
          var A = ln(l) || "Unknown";
          qs[A] || (i("%s: Function components do not support getDerivedStateFromProps.", A), qs[A] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var I = ln(l) || "Unknown";
          gu[I] || (i("%s: Function components do not support contextType.", I), gu[I] = !0);
        }
      }
    }
    function tl(l, f) {
      if (l && l.defaultProps) {
        var A = br({}, f), I = l.defaultProps;
        for (var K in I)
          A[K] === void 0 && (A[K] = I[K]);
        return A;
      }
      return f;
    }
    function Md(l, f, A, I, K) {
      Ir(f, A.render);
      var se = mu(l, f, A.render, I, K), ge = No();
      if (ge) {
        var Le = f.treeContext, s = 1, u = 0;
        f.treeContext = Ao(Le, s, u);
        try {
          dr(l, f, se);
        } finally {
          f.treeContext = Le;
        }
      } else
        dr(l, f, se);
      Sr(f);
    }
    function Id(l, f, A, I, K) {
      var se = A.type, ge = tl(se, I);
      nl(l, f, se, ge, K);
    }
    function xu(l, f, A, I) {
      A._context === void 0 ? A !== A.Consumer && (el || (el = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : A = A._context;
      var K = I.children;
      typeof K != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var se = xa(A), ge = K(se);
      dr(l, f, ge);
    }
    function Fd(l, f, A, I) {
      var K = A._context, se = I.value, ge = I.children, Le;
      Le = f.context, f.context = eu(K, se), dr(l, f, ge), f.context = tu(K), Le !== f.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function Bd(l, f, A, I, K) {
      ni(f, "Lazy");
      var se = A._payload, ge = A._init, Le = ge(se), s = tl(Le, I);
      nl(l, f, Le, s, K), Sr(f);
    }
    function nl(l, f, A, I, K) {
      if (typeof A == "function")
        if (Bo(A)) {
          Od(l, f, A, I);
          return;
        } else {
          vu(l, f, A, I);
          return;
        }
      if (typeof A == "string") {
        Ea(l, f, A, I);
        return;
      }
      switch (A) {
        case co:
        case Ss:
        case Ul:
        case bs:
        case cr: {
          dr(l, f, I.children);
          return;
        }
        case da: {
          ni(f, "SuspenseList"), dr(l, f, I.children), Sr(f);
          return;
        }
        case xs:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case ca: {
          Ys(l, f, I);
          return;
        }
      }
      if (typeof A == "object" && A !== null)
        switch (A.$$typeof) {
          case uo: {
            Md(l, f, A, I, K);
            return;
          }
          case ha: {
            Id(l, f, A, I, K);
            return;
          }
          case so: {
            Fd(l, f, A, I);
            return;
          }
          case lo: {
            xu(l, f, A, I);
            return;
          }
          case Ii: {
            Bd(l, f, A, I);
            return;
          }
        }
      var se = "";
      throw (A === void 0 || typeof A == "object" && A !== null && Object.keys(A).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (A == null ? A : typeof A) + "." + se));
    }
    function zd(l, f) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      l[Symbol.toStringTag] === "Generator" && (Qs || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Qs = !0), l.entries === f && (Js || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Js = !0);
    }
    function dr(l, f, A) {
      try {
        return rl(l, f, A);
      } catch (I) {
        throw typeof I == "object" && I !== null && typeof I.then == "function" || (Wi = Wi !== null ? Wi : La()), I;
      }
    }
    function rl(l, f, A) {
      if (f.node = A, typeof A == "object" && A !== null) {
        switch (A.$$typeof) {
          case od: {
            var I = A, K = I.type, se = I.props, ge = I.ref;
            nl(l, f, K, se, ge);
            return;
          }
          case jl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Ii: {
            var Le = A, s = Le._payload, u = Le._init, k;
            try {
              k = u(s);
            } catch (nt) {
              throw typeof nt == "object" && nt !== null && typeof nt.then == "function" && ni(f, "Lazy"), nt;
            }
            dr(l, f, k);
            return;
          }
        }
        if (Ln(A)) {
          Su(l, f, A);
          return;
        }
        var E = ud(A);
        if (E) {
          zd(A, E);
          var H = E.call(A);
          if (H) {
            var te = H.next();
            if (!te.done) {
              var pe = [];
              do
                pe.push(te.value), te = H.next();
              while (!te.done);
              Su(l, f, pe);
              return;
            }
            return;
          }
        }
        var Ae = Object.prototype.toString.call(A);
        throw new Error("Objects are not valid as a React child (found: " + (Ae === "[object Object]" ? "object with keys {" + Object.keys(A).join(", ") + "}" : Ae) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof A == "string") {
        var Me = f.blockedSegment;
        Me.lastPushedText = Xn(f.blockedSegment.chunks, A, l.responseState, Me.lastPushedText);
        return;
      }
      if (typeof A == "number") {
        var Qe = f.blockedSegment;
        Qe.lastPushedText = Xn(f.blockedSegment.chunks, "" + A, l.responseState, Qe.lastPushedText);
        return;
      }
      typeof A == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function Su(l, f, A) {
      for (var I = A.length, K = 0; K < I; K++) {
        var se = f.treeContext;
        f.treeContext = Ao(se, I, K);
        try {
          il(l, f, A[K]);
        } finally {
          f.treeContext = se;
        }
      }
    }
    function hr(l, f, A) {
      var I = f.blockedSegment, K = I.chunks.length, se = Fo(
        l,
        K,
        null,
        I.formatContext,
        // Adopt the parent segment's leading text embed
        I.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      I.children.push(se), I.lastPushedText = !1;
      var ge = Us(l, f.node, f.blockedBoundary, se, f.abortSet, f.legacyContext, f.context, f.treeContext);
      f.componentStack !== null && (ge.componentStack = f.componentStack.parent);
      var Le = ge.ping;
      A.then(Le, Le);
    }
    function il(l, f, A) {
      var I = f.blockedSegment.formatContext, K = f.legacyContext, se = f.context, ge = null;
      ge = f.componentStack;
      try {
        return dr(l, f, A);
      } catch (Le) {
        if (Hs(), typeof Le == "object" && Le !== null && typeof Le.then == "function") {
          hr(l, f, Le), f.blockedSegment.formatContext = I, f.legacyContext = K, f.context = se, ba(se), f.componentStack = ge;
          return;
        } else
          throw f.blockedSegment.formatContext = I, f.legacyContext = K, f.context = se, ba(se), f.componentStack = ge, Le;
      }
    }
    function wu(l, f, A, I) {
      var K = wr(l, I);
      if (f === null ? ri(l, I) : (f.pendingTasks--, f.forceClientRender || (f.forceClientRender = !0, f.errorDigest = K, Gs(f, I), f.parentFlushed && l.clientRenderedBoundaries.push(f))), l.allPendingTasks--, l.allPendingTasks === 0) {
        var se = l.onAllReady;
        se();
      }
    }
    function $d(l) {
      var f = this, A = l.blockedBoundary, I = l.blockedSegment;
      I.status = Io, ku(f, A, I);
    }
    function zo(l, f, A) {
      var I = l.blockedBoundary, K = l.blockedSegment;
      if (K.status = Io, I === null)
        f.allPendingTasks--, f.status !== Si && (f.status = Si, f.destination !== null && m(f.destination));
      else {
        if (I.pendingTasks--, !I.forceClientRender) {
          I.forceClientRender = !0;
          var se = A === void 0 ? new Error("The render was aborted by the server without a reason.") : A;
          I.errorDigest = f.onError(se);
          {
            var ge = "The server did not finish this Suspense boundary: ";
            se && typeof se.message == "string" ? se = ge + se.message : se = ge + String(se);
            var Le = Wr;
            Wr = l;
            try {
              Gs(I, se);
            } finally {
              Wr = Le;
            }
          }
          I.parentFlushed && f.clientRenderedBoundaries.push(I);
        }
        if (I.fallbackAbortableTasks.forEach(function(u) {
          return zo(u, f, A);
        }), I.fallbackAbortableTasks.clear(), f.allPendingTasks--, f.allPendingTasks === 0) {
          var s = f.onAllReady;
          s();
        }
      }
    }
    function $o(l, f) {
      if (f.chunks.length === 0 && f.children.length === 1 && f.children[0].boundary === null) {
        var A = f.children[0];
        A.id = f.id, A.parentFlushed = !0, A.status === ti && $o(l, A);
      } else {
        var I = l.completedSegments;
        I.push(f);
      }
    }
    function ku(l, f, A) {
      if (f === null) {
        if (A.parentFlushed) {
          if (l.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          l.completedRootSegment = A;
        }
        if (l.pendingRootTasks--, l.pendingRootTasks === 0) {
          l.onShellError = Mr;
          var I = l.onShellReady;
          I();
        }
      } else if (f.pendingTasks--, !f.forceClientRender) {
        if (f.pendingTasks === 0)
          A.parentFlushed && A.status === ti && $o(f, A), f.parentFlushed && l.completedBoundaries.push(f), f.fallbackAbortableTasks.forEach($d, l), f.fallbackAbortableTasks.clear();
        else if (A.parentFlushed && A.status === ti) {
          $o(f, A);
          var K = f.completedSegments;
          K.length === 1 && f.parentFlushed && l.partialBoundaries.push(f);
        }
      }
      if (l.allPendingTasks--, l.allPendingTasks === 0) {
        var se = l.onAllReady;
        se();
      }
    }
    function Tu(l, f) {
      var A = f.blockedSegment;
      if (A.status === Ws) {
        ba(f.context);
        var I = null;
        I = Wr, Wr = f;
        try {
          dr(l, f, f.node), qn(A.chunks, l.responseState, A.lastPushedText, A.textEmbedded), f.abortSet.delete(f), A.status = ti, ku(l, f.blockedBoundary, A);
        } catch (se) {
          if (Hs(), typeof se == "object" && se !== null && typeof se.then == "function") {
            var K = f.ping;
            se.then(K, K);
          } else
            f.abortSet.delete(f), A.status = xi, wu(l, f.blockedBoundary, A, se);
        } finally {
          Wr = I;
        }
      }
    }
    function Na(l) {
      if (l.status !== Si) {
        var f = go(), A = Ca.current;
        Ca.current = du;
        var I;
        I = Oo.getCurrentStack, Oo.getCurrentStack = La;
        var K = Vs;
        Ta(l.responseState);
        try {
          var se = l.pingedTasks, ge;
          for (ge = 0; ge < se.length; ge++) {
            var Le = se[ge];
            Tu(l, Le);
          }
          se.splice(0, ge), l.destination !== null && Vo(l, l.destination);
        } catch (s) {
          wr(l, s), ri(l, s);
        } finally {
          Ta(K), Ca.current = A, Oo.getCurrentStack = I, A === du && ba(f);
        }
      }
    }
    function Ra(l, f, A) {
      switch (A.parentFlushed = !0, A.status) {
        case Ws: {
          var I = A.id = l.nextSegmentId++;
          return A.lastPushedText = !1, A.textEmbedded = !1, Li(f, l.responseState, I);
        }
        case ti: {
          A.status = Mo;
          for (var K = !0, se = A.chunks, ge = 0, Le = A.children, s = 0; s < Le.length; s++) {
            for (var u = Le[s]; ge < u.index; ge++)
              g(f, se[ge]);
            K = Ho(l, f, u);
          }
          for (; ge < se.length - 1; ge++)
            g(f, se[ge]);
          return ge < se.length && (K = b(f, se[ge])), K;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Ho(l, f, A) {
      var I = A.boundary;
      if (I === null)
        return Ra(l, f, A);
      if (I.parentFlushed = !0, I.forceClientRender)
        return Kn(f, l.responseState, I.errorDigest, I.errorMessage, I.errorComponentStack), Ra(l, f, A), ps(f, l.responseState);
      if (I.pendingTasks > 0) {
        I.rootSegmentID = l.nextSegmentId++, I.completedSegments.length > 0 && l.partialBoundaries.push(I);
        var K = I.id = gr(l.responseState);
        return Pi(f, l.responseState, K), Ra(l, f, A), Ni(f, l.responseState);
      } else {
        if (I.byteSize > l.progressiveChunkSize)
          return I.rootSegmentID = l.nextSegmentId++, l.completedBoundaries.push(I), Pi(f, l.responseState, I.id), Ra(l, f, A), Ni(f, l.responseState);
        Za(f, l.responseState);
        var se = I.completedSegments;
        if (se.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var ge = se[0];
        return Ho(l, f, ge), Qa(f, l.responseState);
      }
    }
    function Cu(l, f, A) {
      return Vl(f, l.responseState, A.id, A.errorDigest, A.errorMessage, A.errorComponentStack);
    }
    function Da(l, f, A) {
      return kt(f, l.responseState, A.formatContext, A.id), Ho(l, f, A), en(f, A.formatContext);
    }
    function Oa(l, f, A) {
      for (var I = A.completedSegments, K = 0; K < I.length; K++) {
        var se = I[K];
        al(l, f, A, se);
      }
      return I.length = 0, ms(f, l.responseState, A.id, A.rootSegmentID);
    }
    function Hd(l, f, A) {
      for (var I = A.completedSegments, K = 0; K < I.length; K++) {
        var se = I[K];
        if (!al(l, f, A, se))
          return K++, I.splice(0, K), !1;
      }
      return I.splice(0, K), !0;
    }
    function al(l, f, A, I) {
      if (I.status === Mo)
        return !0;
      var K = I.id;
      if (K === -1) {
        var se = I.id = A.rootSegmentID;
        if (se === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Da(l, f, I);
      } else
        return Da(l, f, I), Qc(f, l.responseState, K);
    }
    function Vo(l, f) {
      y();
      try {
        var A = l.completedRootSegment;
        A !== null && l.pendingRootTasks === 0 && (Ho(l, f, A), l.completedRootSegment = null, ds(f, l.responseState));
        var I = l.clientRenderedBoundaries, K;
        for (K = 0; K < I.length; K++) {
          var se = I[K];
          Cu(l, f, se);
        }
        I.splice(0, K);
        var ge = l.completedBoundaries;
        for (K = 0; K < ge.length; K++) {
          var Le = ge[K];
          Oa(l, f, Le);
        }
        ge.splice(0, K), T(f), y(f);
        var s = l.partialBoundaries;
        for (K = 0; K < s.length; K++) {
          var u = s[K];
          if (!Hd(l, f, u)) {
            l.destination = null, K++, s.splice(0, K);
            return;
          }
        }
        s.splice(0, K);
        var k = l.completedBoundaries;
        for (K = 0; K < k.length; K++) {
          var E = k[K];
          Oa(l, f, E);
        }
        k.splice(0, K);
      } finally {
        T(f), l.allPendingTasks === 0 && l.pingedTasks.length === 0 && l.clientRenderedBoundaries.length === 0 && l.completedBoundaries.length === 0 && (l.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), m(f));
      }
    }
    function Vd(l) {
      h(function() {
        return Na(l);
      });
    }
    function Au(l, f) {
      if (l.status === js) {
        l.status = Si, B(f, l.fatalError);
        return;
      }
      if (l.status !== Si && l.destination === null) {
        l.destination = f;
        try {
          Vo(l, f);
        } catch (A) {
          wr(l, A), ri(l, A);
        }
      }
    }
    function Wo(l, f) {
      try {
        var A = l.abortableTasks;
        A.forEach(function(I) {
          return zo(I, l, f);
        }), A.clear(), l.destination !== null && Vo(l, l.destination);
      } catch (I) {
        wr(l, I), ri(l, I);
      }
    }
    function Wd(l, f) {
      return new Promise(function(A, I) {
        var K, se, ge = new Promise(function(H, te) {
          se = H, K = te;
        });
        function Le() {
          var H = new ReadableStream(
            {
              type: "bytes",
              pull: function(te) {
                Au(u, te);
              },
              cancel: function(te) {
                Wo(u);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          H.allReady = ge, A(H);
        }
        function s(H) {
          ge.catch(function() {
          }), I(H);
        }
        var u = Rd(l, on(f ? f.identifierPrefix : void 0, f ? f.nonce : void 0, f ? f.bootstrapScriptContent : void 0, f ? f.bootstrapScripts : void 0, f ? f.bootstrapModules : void 0), Hn(f ? f.namespaceURI : void 0), f ? f.progressiveChunkSize : void 0, f ? f.onError : void 0, se, Le, s, K);
        if (f && f.signal) {
          var k = f.signal, E = function() {
            Wo(u, k.reason), k.removeEventListener("abort", E);
          };
          k.addEventListener("abort", E);
        }
        Vd(u);
      });
    }
    ju.renderToReadableStream = Wd, ju.version = t;
  }()), ju;
}
var Ua, Uh;
process.env.NODE_ENV === "production" ? (Ua = HS(), Uh = VS()) : (Ua = WS(), Uh = jS());
ta.version = Ua.version;
ta.renderToString = Ua.renderToString;
ta.renderToStaticMarkup = Ua.renderToStaticMarkup;
ta.renderToNodeStream = Ua.renderToNodeStream;
ta.renderToStaticNodeStream = Ua.renderToStaticNodeStream;
ta.renderToReadableStream = Uh.renderToReadableStream;
const cm = ({ columnData: e }) => /* @__PURE__ */ a("ul", { children: e == null ? void 0 : e.map((t, n) => /* @__PURE__ */ F("li", { children: [
  t.label,
  ": ",
  t.value,
  " (",
  t.additional_info,
  "%)"
] }, n)) }), US = (e, t) => {
  var y, g, b, T, m, C;
  const n = `${(((y = e == null ? void 0 : e.tooltips) == null ? void 0 : y.find((w) => w.node === t)) || {}).value}`, r = `${(((g = e == null ? void 0 : e.tooltips) == null ? void 0 : g.find((w) => w.node === t)) || {}).summary}`, i = (((b = e == null ? void 0 : e.tooltips) == null ? void 0 : b.find((w) => w.node === t)) || {}).column1Label, o = (((T = e == null ? void 0 : e.tooltips) == null ? void 0 : T.find((w) => w.node === t)) || {}).column2Label, h = (((m = e == null ? void 0 : e.tooltips) == null ? void 0 : m.find((w) => w.node === t)) || {}).column1, d = (((C = e == null ? void 0 : e.tooltips) == null ? void 0 : C.find((w) => w.node === t)) || {}).column2, c = ta.renderToString(/* @__PURE__ */ a(cm, { columnData: h })), p = ta.renderToString(/* @__PURE__ */ a(cm, { columnData: d }));
  return `<div class="sankey-chart__tooltip">
    <span class="sankey-chart__tooltip--tooltip-header">${t}</span>
    <span class="sankey-chart__tooltip--tooltip-header">${n}</span>
    <div class="divider"></div>
    <span><strong>Summary: </strong>${r}</span>
    <div class="divider"></div>
    <div class="sankey-chart__tooltip--info-section">
      <div>
        <span><strong>${i}</strong></span>
        ${c}
      </div>
      <div>
        <span><strong>${o}</strong></span>
        ${p}
      </div>
    </div>
  </div>
`;
}, KS = ({ width: e, height: t, runtime: n }) => {
  var q, re;
  const { config: r } = fe.useContext(ft), { sankey: i } = r, [o, h] = fe.useState(0), [d, c] = fe.useState(""), { showAlert: p, alert: y } = $S(), g = fe.useRef([]), b = ($) => {
    const j = d;
    j && c(""), j !== $ && c($);
  };
  if (fe.useEffect(() => {
    var j;
    let $ = 0;
    (j = g == null ? void 0 : g.current) == null || j.map((oe) => {
      const ie = oe == null ? void 0 : oe.getBoundingClientRect().width;
      ie > $ && ($ = ie);
    }), h($);
  }, [g, i, window.innerWidth]), r.visualizationType !== "Sankey")
    return;
  const T = r == null ? void 0 : r.data[0], m = Array.from(new Set((q = T == null ? void 0 : T.links) == null ? void 0 : q.flatMap(($) => [$.source, $.target]))), C = {
    nodes: m.map(($) => ({ id: $ })),
    links: (re = T == null ? void 0 : T.links) == null ? void 0 : re.map(($) => ({
      source: m.findIndex((j) => j === $.source),
      target: m.findIndex((j) => j === $.target),
      value: $.value
    }))
  };
  let w = 5;
  const S = 50, B = IS().nodeWidth(i.nodeSize.nodeWidth).nodePadding(i.nodePadding).iterations(i.iterations).nodeAlign(NS).extent([
    [i.margin.margin_x, Number(i.margin.margin_y)],
    [e - w - o, r.heights.vertical - S]
  ]), { links: M } = B(C), D = ($) => {
    var J;
    let j = 30, oe = 0, ie = "node-value--storynode", le = !0;
    return (J = T == null ? void 0 : T.storyNodeText) != null && J.every((de) => de.StoryNode !== $) && (le = !1, oe = 10, j = 8, ie = "node-value"), { textPositionHorizontal: j, textPositionVertical: oe, classStyle: ie, storyNodes: le };
  }, O = ($) => {
    if (!(C != null && C.nodes))
      return { sourceNodes: [], activeLinks: [] };
    const j = C.nodes.find((le) => le.id === $), oe = [], ie = [];
    return j && (M.forEach((le) => {
      const J = le.target, de = le.source;
      J.id === $ && oe.push(de.id);
    }), oe.forEach((le) => {
      M.forEach((J) => {
        const de = J.target, ae = J.source;
        de.id === d && ae.id === le && ie.push(J);
      });
    })), { sourceNodes: oe, activeLinks: ie };
  }, L = US(T, d), U = C.nodes.map(($, j) => {
    var ve, ke;
    let { textPositionHorizontal: oe, textPositionVertical: ie, classStyle: le, storyNodes: J } = D($.id), { sourceNodes: de } = O(d), ae = i.opacity.nodeOpacityDefault, Z = i.nodeColor.default;
    d !== $.id && d !== "" && !de.includes($.id) && (Z = i.nodeColor.inactive, ae = i.opacity.nodeOpacityInactive);
    const ye = B.nodeWidth(), ue = () => Math.sqrt(
      Math.pow(M[0].target.x0 - M[0].source.x1, 2) + Math.pow(M[0].target.y0 - M[0].source.y1, 2)
    ) - o;
    return /* @__PURE__ */ F(qe, { className: "", children: [
      /* @__PURE__ */ a(
        "rect",
        {
          height: $.y1 - $.y0 + 2,
          width: ye,
          x: $.x0,
          y: $.y0 - 1,
          fill: Z,
          fillOpacity: ae,
          rx: i.rxValue,
          "data-tooltip-html": T.tooltips && r.enableTooltips && d !== "" ? L : null,
          "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
          onClick: () => b($.id),
          style: { pointerEvents: "visible", cursor: "pointer" }
        }
      ),
      J ? /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ a(
          dt,
          {
            width: ue(),
            x: $.x0 + oe,
            textAnchor: C.nodes.length - 1 === j ? "end" : "start",
            verticalAnchor: "end",
            y: ($.y1 + $.y0) / 2 - 30,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            className: "node-text",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => b($.id),
            "data-tooltip-html": T.tooltips && r.enableTooltips && d !== "" ? L : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: (((ve = T == null ? void 0 : T.storyNodeText) == null ? void 0 : ve.find((me) => me.StoryNode === $.id)) || {}).segmentTextBefore
          }
        ),
        /* @__PURE__ */ a(
          dt,
          {
            width: ue(),
            verticalAnchor: "middle",
            className: le,
            x: $.x0 + oe,
            y: ($.y1 + $.y0 + 25) / 2,
            fill: i.storyNodeFontColor || i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => b($.id),
            "data-tooltip-html": T.tooltips && r.enableTooltips && d !== "" ? L : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: typeof $.value == "number" ? $.value.toLocaleString() : $.value
          }
        ),
        /* @__PURE__ */ a(
          dt,
          {
            width: ue(),
            x: $.x0 + oe,
            y: ($.y1 + $.y0) / 2 + 50,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: C.nodes.length === j ? "end" : "start",
            className: "node-text",
            verticalAnchor: "start",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => b($.id),
            "data-tooltip-html": T.tooltips && r.enableTooltips && d !== "" ? L : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: (((ke = T == null ? void 0 : T.storyNodeText) == null ? void 0 : ke.find((me) => me.StoryNode === $.id)) || {}).segmentTextAfter
          }
        )
      ] }) : /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ a(
          dt,
          {
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => b($.id),
            "data-tooltip-html": T.tooltips && r.enableTooltips && d !== "" ? L : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            x: $.x0 + oe,
            y: ($.y1 + $.y0) / 2 + ie,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            children: $.id
          }
        ),
        /* @__PURE__ */ a(
          "text",
          {
            x: $.x0 + oe,
            y: ($.y1 + $.y0) / 2 + 30,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "auto", cursor: "pointer" },
            onClick: () => b($.id),
            "data-tooltip-html": T.tooltips && r.enableTooltips && d !== "" ? L : null,
            "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
            children: /* @__PURE__ */ a("tspan", { className: le, children: i.nodeValueStyle.textBefore + (typeof $.value == "number" ? $.value.toLocaleString() : $.value) + i.nodeValueStyle.textAfter })
          }
        )
      ] })
    ] }, j);
  }), X = M.map(($, j) => {
    const ie = zS()($);
    let le = i.opacity.LinkOpacityDefault, J = i.linkColor.default, { activeLinks: de } = O(d);
    return !de.includes($) && d !== "" && (J = i.linkColor.inactive, le = i.opacity.LinkOpacityInactive), /* @__PURE__ */ a(
      "path",
      {
        d: ie,
        stroke: J,
        fill: "none",
        strokeOpacity: le,
        strokeWidth: $.width + 2,
        style: { pointerEvents: "auto", cursor: "pointer" },
        onClick: () => b($.target.id || null),
        "data-tooltip-html": T.tooltips && r.enableTooltips && d !== "" ? L : null,
        "data-tooltip-id": `cdc-open-viz-tooltip-${n.uniqueId}-sankey`
      },
      j
    );
  }), ne = C.nodes.reduce(($, j) => Math.max($, j.depth), -1), ce = C.nodes.filter(($) => $.depth === ne).map(($, j) => {
    var ye, ue;
    let { textPositionHorizontal: oe, textPositionVertical: ie, classStyle: le, storyNodes: J } = D($.id), { sourceNodes: de } = O(d), ae = i.opacity.nodeOpacityDefault, Z = i.nodeColor.default;
    return d !== $.id && d !== "" && !de.includes($.id) && (Z = i.nodeColor.inactive, ae = i.opacity.nodeOpacityInactive), /* @__PURE__ */ F(qe, { className: "", innerRef: (ve) => g.current[j] = ve, children: [
      /* @__PURE__ */ a(
        "rect",
        {
          height: $.y1 - $.y0 + 2,
          width: B.nodeWidth(),
          x: $.x0,
          y: $.y0 - 1,
          fill: Z,
          fillOpacity: ae,
          rx: i.rxValue,
          "data-tooltip-html": T.tooltips && r.enableTooltips && d !== "" ? L : null,
          "data-tooltip-id": "tooltip",
          onClick: () => b($.id),
          style: { pointerEvents: "visible", cursor: "pointer" }
        }
      ),
      J ? /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ a(
          dt,
          {
            x: $.x0 + oe,
            textAnchor: C.nodes.length - 1 === j ? "end" : "start",
            verticalAnchor: "end",
            y: ($.y1 + $.y0) / 2 - 30,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            style: { pointerEvents: "none" },
            className: "node-text",
            children: (((ye = T == null ? void 0 : T.storyNodeText) == null ? void 0 : ye.find((ve) => ve.StoryNode === $.id)) || {}).segmentTextBefore
          }
        ),
        /* @__PURE__ */ a(
          dt,
          {
            verticalAnchor: "end",
            className: le,
            x: $.x0 + oe,
            y: ($.y1 + $.y0 + 25) / 2,
            fill: i.storyNodeFontColor || i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "none" },
            children: typeof $.value == "number" ? $.value.toLocaleString() : $.value
          }
        ),
        /* @__PURE__ */ a(
          dt,
          {
            x: $.x0 + oe,
            y: ($.y1 + $.y0) / 2 + 50,
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: C.nodes.length === j ? "end" : "start",
            style: { pointerEvents: "none" },
            className: "node-text",
            verticalAnchor: "end",
            children: (((ue = T == null ? void 0 : T.storyNodeText) == null ? void 0 : ue.find((ve) => ve.StoryNode === $.id)) || {}).segmentTextAfter
          }
        )
      ] }) : /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ a(
          "text",
          {
            x: $.x0 + oe,
            y: ($.y1 + $.y0) / 2 + ie,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "none" },
            children: /* @__PURE__ */ a("tspan", { id: $.id, className: "node-id", children: $.id })
          }
        ),
        /* @__PURE__ */ a(
          "text",
          {
            x: $.x0 + oe,
            y: ($.y1 + $.y0) / 2 + 30,
            dominantBaseline: "text-before-edge",
            fill: i.nodeFontColor,
            fontWeight: "bold",
            textAnchor: "start",
            style: { pointerEvents: "none" },
            children: /* @__PURE__ */ a("tspan", { onClick: () => b($.id), className: le, children: i.nodeValueStyle.textBefore + (typeof $.value == "number" ? $.value.toLocaleString() : $.value) + i.nodeValueStyle.textAfter })
          }
        )
      ] })
    ] }, j);
  });
  return p ? y : /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F("div", { className: "sankey-chart", children: [
    /* @__PURE__ */ F(
      "svg",
      {
        className: "sankey-chart__diagram",
        width: e,
        height: Number(r.heights.vertical),
        style: { overflow: "visible" },
        children: [
          /* @__PURE__ */ a(qe, { className: "links", children: X }),
          /* @__PURE__ */ a(qe, { className: "nodes", children: U }),
          /* @__PURE__ */ a(qe, { className: "finalNodes", style: { display: "none" }, children: ce })
        ]
      }
    ),
    /* @__PURE__ */ a(
      $m,
      {
        id: `cdc-open-viz-tooltip-${n.uniqueId}-sankey`,
        afterHide: () => c(""),
        events: ["click"],
        place: "bottom",
        style: {
          backgroundColor: "rgba(238, 238, 238, 1)",
          color: "black",
          boxShadow: "0 3px 10px rgb(0 0 0 / 0.2)"
        }
      }
    )
  ] }) });
};
var GS = {
  top: "top",
  left: "left",
  right: "right",
  bottom: "bottom"
};
const fr = GS;
function YS(e) {
  var t = e.labelOffset, n = e.labelProps, r = e.orientation, i = e.range, o = e.tickLabelFontSize, h = e.tickLength, d = r === fr.left || r === fr.top ? -1 : 1, c, p, y;
  if (r === fr.top || r === fr.bottom) {
    var g = r === fr.bottom && typeof n.fontSize == "number" ? n.fontSize : 0;
    c = (Number(i[0]) + Number(i[i.length - 1])) / 2, p = d * (h + t + o + g);
  } else
    c = d * ((Number(i[0]) + Number(i[i.length - 1])) / 2), p = -(h + t), y = "rotate(" + d * 90 + ")";
  return {
    x: c,
    y: p,
    transform: y
  };
}
function vl() {
  return vl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, vl.apply(this, arguments);
}
function XS(e) {
  var t = e.hideTicks, n = e.horizontal, r = e.orientation, i = e.tickClassName, o = e.tickComponent, h = e.tickLabelProps, d = e.tickStroke, c = d === void 0 ? "#222" : d, p = e.tickTransform, y = e.ticks, g = e.strokeWidth, b = e.tickLineProps;
  return y.map(function(T) {
    var m, C = T.value, w = T.index, S = T.from, B = T.to, M = T.formattedValue, D = (m = h[w]) != null ? m : {}, O = Math.max(10, typeof D.fontSize == "number" && D.fontSize || 0), L = B.y + (n && r !== fr.top ? O : 0);
    return /* @__PURE__ */ Ie.createElement(qe, {
      key: "visx-tick-" + C + "-" + w,
      className: Sn("visx-axis-tick", i),
      transform: p
    }, !t && /* @__PURE__ */ Ie.createElement(an, vl({
      from: S,
      to: B,
      stroke: c,
      strokeWidth: g,
      strokeLinecap: "square"
    }, b)), o ? o(vl({}, D, {
      x: B.x,
      y: L,
      formattedValue: M
    })) : /* @__PURE__ */ Ie.createElement(dt, vl({
      x: B.x,
      y: L
    }, D), M));
  });
}
function bl() {
  return bl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, bl.apply(this, arguments);
}
var dm = {
  textAnchor: "middle",
  fontFamily: "Arial",
  fontSize: 10,
  fill: "#222"
};
function qS(e) {
  var t = e.axisFromPoint, n = e.axisLineClassName, r = e.axisToPoint, i = e.hideAxisLine, o = e.hideTicks, h = e.horizontal, d = e.label, c = d === void 0 ? "" : d, p = e.labelClassName, y = e.labelOffset, g = y === void 0 ? 14 : y, b = e.labelProps, T = e.orientation, m = T === void 0 ? fr.bottom : T, C = e.scale, w = e.stroke, S = w === void 0 ? "#222" : w, B = e.strokeDasharray, M = e.strokeWidth, D = M === void 0 ? 1 : M, O = e.tickClassName, L = e.tickComponent, U = e.tickLineProps, X = e.tickLabelProps, ne = e.tickLength, G = ne === void 0 ? 8 : ne, ce = e.tickStroke, q = ce === void 0 ? "#222" : ce, re = e.tickTransform, $ = e.ticks, j = e.ticksComponent, oe = j === void 0 ? XS : j, ie = bl({}, dm, b), le = bl({}, dm, typeof X == "object" ? X : null), J = $.map(function(ae) {
    var Z = ae.value, ye = ae.index;
    return typeof X == "function" ? X(Z, ye, $) : le;
  }), de = Math.max.apply(Math, [10].concat(J.map(function(ae) {
    return typeof ae.fontSize == "number" ? ae.fontSize : 0;
  })));
  return /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, oe({
    hideTicks: o,
    horizontal: h,
    orientation: m,
    scale: C,
    tickClassName: O,
    tickComponent: L,
    tickLabelProps: J,
    tickStroke: q,
    tickTransform: re,
    ticks: $,
    strokeWidth: D,
    tickLineProps: U
  }), !i && /* @__PURE__ */ Ie.createElement(an, {
    className: Sn("visx-axis-line", n),
    from: t,
    to: r,
    stroke: S,
    strokeWidth: D,
    strokeDasharray: B
  }), c && /* @__PURE__ */ Ie.createElement(dt, bl({
    className: Sn("visx-axis-label", p)
  }, YS({
    labelOffset: g,
    labelProps: ie,
    orientation: m,
    range: C.range(),
    tickLabelFontSize: de,
    tickLength: G
  }), ie), c));
}
function ZS(e, t) {
  t === void 0 && (t = "center");
  var n = e;
  if (t !== "start" && "bandwidth" in n) {
    var r = n.bandwidth();
    return t === "center" && (r /= 2), n.round() && (r = Math.round(r)), function(i) {
      var o = n(i);
      return typeof o == "number" ? o + r : o;
    };
  }
  return e;
}
function QS(e) {
  var t = e;
  return "tickFormat" in t ? t.tickFormat() : ES;
}
function Uu(e, t) {
  var n = e.x, r = e.y;
  return new Og(t ? {
    x: n,
    y: r
  } : {
    x: r,
    y: n
  });
}
function Kh() {
  return Kh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Kh.apply(this, arguments);
}
var ah = 0;
function JS(e) {
  return e === void 0 && (e = ah), typeof e == "number" ? {
    start: e,
    end: e
  } : Kh({
    start: ah,
    end: ah
  }, e);
}
var ew = ["children", "axisClassName", "hideAxisLine", "hideTicks", "hideZero", "innerRef", "left", "numTicks", "orientation", "rangePadding", "scale", "tickFormat", "tickLength", "tickValues", "top"];
function Gh() {
  return Gh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Gh.apply(this, arguments);
}
function tw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Yc(e) {
  var t = e.children, n = t === void 0 ? qS : t, r = e.axisClassName, i = e.hideAxisLine, o = i === void 0 ? !1 : i, h = e.hideTicks, d = h === void 0 ? !1 : h, c = e.hideZero, p = c === void 0 ? !1 : c, y = e.innerRef, g = e.left, b = g === void 0 ? 0 : g, T = e.numTicks, m = T === void 0 ? 10 : T, C = e.orientation, w = C === void 0 ? fr.bottom : C, S = e.rangePadding, B = S === void 0 ? 0 : S, M = e.scale, D = e.tickFormat, O = e.tickLength, L = O === void 0 ? 8 : O, U = e.tickValues, X = e.top, ne = X === void 0 ? 0 : X, G = tw(e, ew), ce = D ?? QS(M), q = w === fr.left, re = w === fr.top, $ = re || w === fr.bottom, j = ZS(M), oe = q || re ? -1 : 1, ie = M.range(), le = JS(B), J = Uu({
    x: Number(ie[0]) + 0.5 - le.start,
    y: 0
  }, $), de = Uu({
    x: Number(ie[ie.length - 1]) + 0.5 + le.end,
    y: 0
  }, $), ae = (U ?? pg(M, m)).filter(function(ye) {
    return !p || ye !== 0 && ye !== "0";
  }).map(function(ye, ue) {
    return {
      value: ye,
      index: ue
    };
  }), Z = ae.map(function(ye) {
    var ue = ye.value, ve = ye.index, ke = LS(j(ue));
    return {
      value: ue,
      index: ve,
      from: Uu({
        x: ke,
        y: 0
      }, $),
      to: Uu({
        x: ke,
        y: L * oe
      }, $),
      formattedValue: ce(ue, ve, ae)
    };
  });
  return /* @__PURE__ */ Ie.createElement(qe, {
    className: Sn("visx-axis", r),
    innerRef: y,
    top: ne,
    left: b
  }, n(Gh({}, G, {
    axisFromPoint: J,
    axisToPoint: de,
    hideAxisLine: o,
    hideTicks: d,
    hideZero: p,
    horizontal: $,
    numTicks: m,
    orientation: w,
    rangePadding: B,
    scale: M,
    tickFormat: ce,
    tickLength: L,
    tickPosition: j,
    tickSign: oe,
    ticks: Z
  })));
}
var nw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Cc() {
  return Cc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Cc.apply(this, arguments);
}
function rw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var iw = {
  dx: "-0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "end"
};
function hm(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 36 : n, i = e.tickLength, o = i === void 0 ? 8 : i, h = e.tickLabelProps, d = rw(e, nw), c = typeof h == "function" ? h : Cc({}, iw, h);
  return /* @__PURE__ */ Ie.createElement(Yc, Cc({
    axisClassName: Sn("visx-axis-left", t),
    labelOffset: r,
    orientation: fr.left,
    tickLabelProps: c,
    tickLength: o
  }, d));
}
var aw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Ac() {
  return Ac = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ac.apply(this, arguments);
}
function ow(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var sw = {
  dx: "0.25em",
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "start"
};
function lw(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 36 : n, i = e.tickLength, o = i === void 0 ? 8 : i, h = e.tickLabelProps, d = ow(e, aw), c = typeof h == "function" ? h : Ac({}, sw, h);
  return /* @__PURE__ */ Ie.createElement(Yc, Ac({
    axisClassName: Sn("visx-axis-right", t),
    labelOffset: r,
    orientation: fr.right,
    tickLabelProps: c,
    tickLength: o
  }, d));
}
var uw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Lc() {
  return Lc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Lc.apply(this, arguments);
}
function cw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var dw = {
  dy: "-0.75em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function hw(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 8 : n, i = e.tickLength, o = i === void 0 ? 8 : i, h = e.tickLabelProps, d = cw(e, uw), c = typeof h == "function" ? h : Lc({}, dw, h);
  return /* @__PURE__ */ Ie.createElement(Yc, Lc({
    axisClassName: Sn("visx-axis-top", t),
    labelOffset: r,
    orientation: fr.top,
    tickLabelProps: c,
    tickLength: o
  }, d));
}
var fw = ["axisClassName", "labelOffset", "tickLength", "tickLabelProps"];
function Ec() {
  return Ec = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ec.apply(this, arguments);
}
function pw(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var mw = {
  dy: "0.25em",
  fill: "#222",
  fontFamily: "Arial",
  fontSize: 10,
  textAnchor: "middle"
};
function tc(e) {
  var t = e.axisClassName, n = e.labelOffset, r = n === void 0 ? 8 : n, i = e.tickLength, o = i === void 0 ? 8 : i, h = e.tickLabelProps, d = pw(e, fw), c = typeof h == "function" ? h : Ec({}, mw, h);
  return /* @__PURE__ */ Ie.createElement(Yc, Ec({
    axisClassName: Sn("visx-axis-bottom", t),
    labelOffset: r,
    orientation: fr.bottom,
    tickLabelProps: c,
    tickLength: o
  }, d));
}
const oh = (e) => () => e;
function yw(e, {
  sourceEvent: t,
  target: n,
  selection: r,
  mode: i,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    selection: { value: r, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function gw(e) {
  e.stopImmediatePropagation();
}
function sh(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var fm = { name: "drag" }, lh = { name: "space" }, Xo = { name: "handle" }, qo = { name: "center" };
const { abs: pm, max: Jn, min: er } = Math;
function mm(e) {
  return [+e[0], +e[1]];
}
function ym(e) {
  return [mm(e[0]), mm(e[1])];
}
var nc = {
  name: "x",
  handles: ["w", "e"].map(_c),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, uh = {
  name: "y",
  handles: ["n", "s"].map(_c),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, wi = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, gm = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, vm = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, vw = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, bw = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function _c(e) {
  return { type: e };
}
function xw(e) {
  return !e.ctrlKey && !e.button;
}
function Sw() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function ww() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function ch(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function kw(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function Tw() {
  return Cw(nc);
}
function Cw(e) {
  var t = Sw, n = xw, r = ww, i = !0, o = Mg("start", "brush", "end"), h = 6, d;
  function c(w) {
    var S = w.property("__brush", C).selectAll(".overlay").data([_c("overlay")]);
    S.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", wi.overlay).merge(S).each(function() {
      var M = ch(this).extent;
      Qo(this).attr("x", M[0][0]).attr("y", M[0][1]).attr("width", M[1][0] - M[0][0]).attr("height", M[1][1] - M[0][1]);
    }), w.selectAll(".selection").data([_c("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", wi.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var B = w.selectAll(".handle").data(e.handles, function(M) {
      return M.type;
    });
    B.exit().remove(), B.enter().append("rect").attr("class", function(M) {
      return "handle handle--" + M.type;
    }).attr("cursor", function(M) {
      return wi[M.type];
    }), w.each(p).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", b).filter(r).on("touchstart.brush", b).on("touchmove.brush", T).on("touchend.brush touchcancel.brush", m).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  c.move = function(w, S, B) {
    w.tween ? w.on("start.brush", function(M) {
      y(this, arguments).beforestart().start(M);
    }).on("interrupt.brush end.brush", function(M) {
      y(this, arguments).end(M);
    }).tween("brush", function() {
      var M = this, D = M.__brush, O = y(M, arguments), L = D.selection, U = e.input(typeof S == "function" ? S.apply(this, arguments) : S, D.extent), X = vv(L, U);
      function ne(G) {
        D.selection = G === 1 && U === null ? null : X(G), p.call(M), O.brush();
      }
      return L !== null && U !== null ? ne : ne(1);
    }) : w.each(function() {
      var M = this, D = arguments, O = M.__brush, L = e.input(typeof S == "function" ? S.apply(M, D) : S, O.extent), U = y(M, D).beforestart();
      Gf(M), O.selection = L === null ? null : L, p.call(M), U.start(B).brush(B).end(B);
    });
  }, c.clear = function(w, S) {
    c.move(w, null, S);
  };
  function p() {
    var w = Qo(this), S = ch(this).selection;
    S ? (w.selectAll(".selection").style("display", null).attr("x", S[0][0]).attr("y", S[0][1]).attr("width", S[1][0] - S[0][0]).attr("height", S[1][1] - S[0][1]), w.selectAll(".handle").style("display", null).attr("x", function(B) {
      return B.type[B.type.length - 1] === "e" ? S[1][0] - h / 2 : S[0][0] - h / 2;
    }).attr("y", function(B) {
      return B.type[0] === "s" ? S[1][1] - h / 2 : S[0][1] - h / 2;
    }).attr("width", function(B) {
      return B.type === "n" || B.type === "s" ? S[1][0] - S[0][0] + h : h;
    }).attr("height", function(B) {
      return B.type === "e" || B.type === "w" ? S[1][1] - S[0][1] + h : h;
    })) : w.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function y(w, S, B) {
    var M = w.__brush.emitter;
    return M && (!B || !M.clean) ? M : new g(w, S, B);
  }
  function g(w, S, B) {
    this.that = w, this.args = S, this.state = w.__brush, this.active = 0, this.clean = B;
  }
  g.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(w, S) {
      return this.starting ? (this.starting = !1, this.emit("start", w, S)) : this.emit("brush", w), this;
    },
    brush: function(w, S) {
      return this.emit("brush", w, S), this;
    },
    end: function(w, S) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", w, S)), this;
    },
    emit: function(w, S, B) {
      var M = Qo(this.that).datum();
      o.call(
        w,
        this.that,
        new yw(w, {
          sourceEvent: S,
          target: c,
          selection: e.output(this.state.selection),
          mode: B,
          dispatch: o
        }),
        M
      );
    }
  };
  function b(w) {
    if (d && !w.touches || !n.apply(this, arguments))
      return;
    var S = this, B = w.target.__data__.type, M = (i && w.metaKey ? B = "overlay" : B) === "selection" ? fm : i && w.altKey ? qo : Xo, D = e === uh ? null : vw[B], O = e === nc ? null : bw[B], L = ch(S), U = L.extent, X = L.selection, ne = U[0][0], G, ce, q = U[0][1], re, $, j = U[1][0], oe, ie, le = U[1][1], J, de, ae = 0, Z = 0, ye, ue = D && O && i && w.shiftKey, ve, ke, me = Array.from(w.touches || [w], (Ye) => {
      const ot = Ye.identifier;
      return Ye = Yf(Ye, S), Ye.point0 = Ye.slice(), Ye.identifier = ot, Ye;
    });
    Gf(S);
    var Ne = y(S, arguments, !0).beforestart();
    if (B === "overlay") {
      X && (ye = !0);
      const Ye = [me[0], me[1] || me[0]];
      L.selection = X = [[
        G = e === uh ? ne : er(Ye[0][0], Ye[1][0]),
        re = e === nc ? q : er(Ye[0][1], Ye[1][1])
      ], [
        oe = e === uh ? j : Jn(Ye[0][0], Ye[1][0]),
        J = e === nc ? le : Jn(Ye[0][1], Ye[1][1])
      ]], me.length > 1 && Je(w);
    } else
      G = X[0][0], re = X[0][1], oe = X[1][0], J = X[1][1];
    ce = G, $ = re, ie = oe, de = J;
    var Ee = Qo(S).attr("pointer-events", "none"), De = Ee.selectAll(".overlay").attr("cursor", wi[B]);
    if (w.touches)
      Ne.moved = Fe, Ne.ended = gt;
    else {
      var Xe = Qo(w.view).on("mousemove.brush", Fe, !0).on("mouseup.brush", gt, !0);
      i && Xe.on("keydown.brush", mt, !0).on("keyup.brush", yt, !0), Ig(w.view);
    }
    p.call(S), Ne.start(w, M.name);
    function Fe(Ye) {
      for (const ot of Ye.changedTouches || [Ye])
        for (const ut of me)
          ut.identifier === ot.identifier && (ut.cur = Yf(ot, S));
      if (ue && !ve && !ke && me.length === 1) {
        const ot = me[0];
        pm(ot.cur[0] - ot[0]) > pm(ot.cur[1] - ot[1]) ? ke = !0 : ve = !0;
      }
      for (const ot of me)
        ot.cur && (ot[0] = ot.cur[0], ot[1] = ot.cur[1]);
      ye = !0, sh(Ye), Je(Ye);
    }
    function Je(Ye) {
      const ot = me[0], ut = ot.point0;
      var st;
      switch (ae = ot[0] - ut[0], Z = ot[1] - ut[1], M) {
        case lh:
        case fm: {
          D && (ae = Jn(ne - G, er(j - oe, ae)), ce = G + ae, ie = oe + ae), O && (Z = Jn(q - re, er(le - J, Z)), $ = re + Z, de = J + Z);
          break;
        }
        case Xo: {
          me[1] ? (D && (ce = Jn(ne, er(j, me[0][0])), ie = Jn(ne, er(j, me[1][0])), D = 1), O && ($ = Jn(q, er(le, me[0][1])), de = Jn(q, er(le, me[1][1])), O = 1)) : (D < 0 ? (ae = Jn(ne - G, er(j - G, ae)), ce = G + ae, ie = oe) : D > 0 && (ae = Jn(ne - oe, er(j - oe, ae)), ce = G, ie = oe + ae), O < 0 ? (Z = Jn(q - re, er(le - re, Z)), $ = re + Z, de = J) : O > 0 && (Z = Jn(q - J, er(le - J, Z)), $ = re, de = J + Z));
          break;
        }
        case qo: {
          D && (ce = Jn(ne, er(j, G - ae * D)), ie = Jn(ne, er(j, oe + ae * D))), O && ($ = Jn(q, er(le, re - Z * O)), de = Jn(q, er(le, J + Z * O)));
          break;
        }
      }
      ie < ce && (D *= -1, st = G, G = oe, oe = st, st = ce, ce = ie, ie = st, B in gm && De.attr("cursor", wi[B = gm[B]])), de < $ && (O *= -1, st = re, re = J, J = st, st = $, $ = de, de = st, B in vm && De.attr("cursor", wi[B = vm[B]])), L.selection && (X = L.selection), ve && (ce = X[0][0], ie = X[1][0]), ke && ($ = X[0][1], de = X[1][1]), (X[0][0] !== ce || X[0][1] !== $ || X[1][0] !== ie || X[1][1] !== de) && (L.selection = [[ce, $], [ie, de]], p.call(S), Ne.brush(Ye, M.name));
    }
    function gt(Ye) {
      if (gw(Ye), Ye.touches) {
        if (Ye.touches.length)
          return;
        d && clearTimeout(d), d = setTimeout(function() {
          d = null;
        }, 500);
      } else
        Fg(Ye.view, ye), Xe.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      Ee.attr("pointer-events", "all"), De.attr("cursor", wi.overlay), L.selection && (X = L.selection), kw(X) && (L.selection = null, p.call(S)), Ne.end(Ye, M.name);
    }
    function mt(Ye) {
      switch (Ye.keyCode) {
        case 16: {
          ue = D && O;
          break;
        }
        case 18: {
          M === Xo && (D && (oe = ie - ae * D, G = ce + ae * D), O && (J = de - Z * O, re = $ + Z * O), M = qo, Je(Ye));
          break;
        }
        case 32: {
          (M === Xo || M === qo) && (D < 0 ? oe = ie - ae : D > 0 && (G = ce - ae), O < 0 ? J = de - Z : O > 0 && (re = $ - Z), M = lh, De.attr("cursor", wi.selection), Je(Ye));
          break;
        }
        default:
          return;
      }
      sh(Ye);
    }
    function yt(Ye) {
      switch (Ye.keyCode) {
        case 16: {
          ue && (ve = ke = ue = !1, Je(Ye));
          break;
        }
        case 18: {
          M === qo && (D < 0 ? oe = ie : D > 0 && (G = ce), O < 0 ? J = de : O > 0 && (re = $), M = Xo, Je(Ye));
          break;
        }
        case 32: {
          M === lh && (Ye.altKey ? (D && (oe = ie - ae * D, G = ce + ae * D), O && (J = de - Z * O, re = $ + Z * O), M = qo) : (D < 0 ? oe = ie : D > 0 && (G = ce), O < 0 ? J = de : O > 0 && (re = $), M = Xo), De.attr("cursor", wi[B]), Je(Ye));
          break;
        }
        default:
          return;
      }
      sh(Ye);
    }
  }
  function T(w) {
    y(this, arguments).moved(w);
  }
  function m(w) {
    y(this, arguments).ended(w);
  }
  function C() {
    var w = this.__brush || { selection: null };
    return w.extent = ym(t.apply(this, arguments)), w.dim = e, w;
  }
  return c.extent = function(w) {
    return arguments.length ? (t = typeof w == "function" ? w : oh(ym(w)), c) : t;
  }, c.filter = function(w) {
    return arguments.length ? (n = typeof w == "function" ? w : oh(!!w), c) : n;
  }, c.touchable = function(w) {
    return arguments.length ? (r = typeof w == "function" ? w : oh(!!w), c) : r;
  }, c.handleSize = function(w) {
    return arguments.length ? (h = +w, c) : h;
  }, c.keyModifiers = function(w) {
    return arguments.length ? (i = !!w, c) : i;
  }, c.on = function() {
    var w = o.on.apply(o, arguments);
    return w === o ? c : w;
  }, c;
}
const Aw = ({ xMax: e, yMax: t }) => {
  var $, j;
  const { tableData: n, config: r, dashboardConfig: i, formatDate: o, parseDate: h } = fe.useContext(ft), d = fe.useContext(ef), [c, p] = fe.useState({ isBrushing: !1, selection: [] }), [y, g] = fe.useState(0), b = (($ = i == null ? void 0 : i.dashboard) == null ? void 0 : $.sharedFilters) ?? [], T = (b == null ? void 0 : b.length) > 0, [m, C] = fe.useState(!1), w = fe.useRef(), S = 25, B = 15, M = Bg(n, (oe) => new Date(oe[r.runtime.originalXAxis.dataKey])), D = fg().domain(M).range([0, e]), L = mr("Drag edges to focus on a specific segment ", `normal ${16 / 1.1}px sans-serif`), U = 50, X = 1.5, ne = () => (i == null ? void 0 : i.type) === "dashboard" ? Number(t) + r.xAxis.axisBBox + S * X + U : Number(t) + r.xAxis.axisBBox + S * X, G = () => {
    c.selection[0] === 0 && e === c.selection[1] && C(!0);
  }, ce = () => {
    (c.selection[0] !== 0 || c.selection[1] !== e) && C(!1), C(!1);
  }, q = (oe, ie, le, J) => {
    const de = mr(le, `normal ${14.545454545454545}px sans-serif`), ae = ie[0] < de ? 0 : -de, Z = e - ie[1] < de ? -de : 0;
    return oe.selectAll(".handle--custom").data([{ side: "left" }, { side: "right" }]).join((ye) => {
      const ue = ye.append("g").attr("class", "handle--custom");
      return ue.append("text").attr("x", (ve) => ve.side === "left" ? ae : Z).attr("y", 30).text((ve) => ve.side === "left" ? le : J).attr("font-size", "13px"), ue;
    }).attr("display", "block").attr("transform", ie === null ? null : (ye, ue) => `translate(${ie[ue]},10)`);
  }, re = () => {
    const oe = Qo(w.current).attr("overflow", "visible");
    oe.append("rect").attr("fill", "#949494").attr("stroke", "#c5c5c5").attr("stroke-width", 2).attr("ry", B).attr("rx", B).attr("height", S).attr("width", e);
    const ie = (ae) => {
      const Z = ae == null ? void 0 : ae.selection;
      let ye = ae.type === "brush" && Z && Z.length > 0;
      const [ue, ve] = Z.map((yt) => D.invert(yt)), ke = Ke.filter(n, (yt) => {
        const Ye = new Date(yt[r.xAxis.dataKey]);
        return Ye && !isNaN(Ye.getTime()) && Ye >= ue && Ye <= ve;
      }), me = r.xAxis.sortByRecentDate, Ne = Ke.sortBy(ke, (yt) => new Date(yt[r.xAxis.dataKey])), Ee = me ? Ne.reverse() : Ne, De = Ke.get(Ke.first(Ee), r.xAxis.dataKey, ""), Xe = Ke.get(Ke.last(Ee), r.xAxis.dataKey, "");
      oe.selectAll(".handle--custom").remove();
      const Fe = (yt) => yt ? o(h(yt)) : "", Je = Fe(De), gt = Fe(Xe);
      oe.call(q, Z, Je, gt);
      const mt = {
        active: r.brush.active,
        isBrushing: ye,
        data: Ee
      };
      d({ type: "SET_BRUSH_CONFIG", payload: mt }), p({
        isBrushing: !0,
        selection: Z
      });
    }, le = Tw().extent([
      [0, 0],
      [e, 25]
    ]).on("start brush end", ie), J = [0, e];
    let de = oe.append("g").call(le).call(le.move, J);
    de.select(".overlay").style("pointer-events", "none"), de.selectAll(".selection").attr("fill", "#474747").attr("fill-opacity", 1).attr("rx", B).attr("ry", B);
  };
  return fe.useEffect(() => {
    var le, J, de;
    const oe = (le = r.filters) == null ? void 0 : le.some((ae) => ae.active), ie = (J = r.exclusions) == null ? void 0 : J.active;
    return (oe || ie || T) && ((de = r.brush) != null && de.active) && g((ae) => ae + 1), d({ type: "SET_BRUSH_CONFIG", payload: { ...r.brush, data: n } }), () => d({ type: "SET_BRUSH_CONFIG", payload: { ...r.brush, data: [] } });
  }, [r.filters, r.exclusions, (j = r.brush) == null ? void 0 : j.active, T]), fe.useEffect(() => {
    let oe = null;
    const ie = () => {
      e > 0 ? re() : (clearTimeout(oe), oe = setTimeout(ie, 500));
    };
    return ie(), () => {
      oe && clearTimeout(oe);
    };
  }, [e]), fe.useEffect(() => {
    y && re();
  }, [y]), c.isBrushing || re(), /* @__PURE__ */ F(
    qe,
    {
      onMouseLeave: ce,
      onMouseOver: G,
      className: "brush-container",
      left: Number(r.runtime.yAxis.size),
      top: ne(),
      children: [
        /* @__PURE__ */ a(
          dt,
          {
            pointerEvents: "visiblePainted",
            display: m ? "block" : "none",
            fontSize: 16,
            x: (Number(e) - Number(L)) / 2,
            y: -10,
            children: "Drag edges to focus on a specific segment"
          }
        ),
        /* @__PURE__ */ a("svg", { width: "100%", height: S * 3, ref: w })
      ]
    }
  );
}, $a = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  curveBasis: Zx,
  curveBasisClosed: Qx,
  curveBasisOpen: Jx,
  curveBundle: e0,
  curveCardinal: t0,
  curveCardinalClosed: n0,
  curveCardinalOpen: r0,
  curveCatmullRom: i0,
  curveCatmullRomClosed: a0,
  curveCatmullRomOpen: o0,
  curveLinear: Uc,
  curveLinearClosed: Ph,
  curveMonotoneX: ec,
  curveMonotoneY: s0,
  curveNatural: l0,
  curveStep: u0,
  curveStepAfter: d0,
  curveStepBefore: c0
}, Symbol.toStringTag, { value: "Module" })), Lw = (e) => {
  var L, U;
  const { xScale: t, yScale: n, yMax: r, xMax: i, handleTooltipMouseOver: o, handleTooltipMouseOff: h, isDebug: d, children: c } = e;
  let {
    transformedData: p,
    config: y,
    handleLineType: g,
    parseDate: b,
    formatDate: T,
    formatNumber: m,
    seriesHighlight: C,
    colorScale: w,
    rawData: S,
    brushConfig: B
  } = fe.useContext(ft);
  const M = (L = y.brush) != null && L.active && ((U = B.data) != null && U.length) ? B.data : p;
  if (!M)
    return;
  const D = (X) => (Tn(y.xAxis) ? t(b(X[y.xAxis.dataKey], !1)) : t(X[y.xAxis.dataKey])) + (t.bandwidth ? t.bandwidth() / 2 : 0), O = (X, ne, G = void 0) => n(X[G.dataKey]);
  return M && /* @__PURE__ */ a("svg", { children: /* @__PURE__ */ a(Xr, { component: "AreaChart", children: /* @__PURE__ */ F(qe, { className: "area-chart", left: Number(y.yAxis.size), children: [
    (y.runtime.areaSeriesKeys || y.series).map((X, ne) => {
      let G = M.map(($) => ({
        [y.xAxis.dataKey]: $[y.xAxis.dataKey],
        [X.dataKey]: $[X.dataKey]
      })), ce = $a[X.lineType], q = y.legend.behavior === "highlight" && C.length > 0 && C.indexOf(X.dataKey) === -1, re = y.legend.behavior === "highlight" || C.length === 0 || C.indexOf(X.dataKey) !== -1;
      return /* @__PURE__ */ F(Ie.Fragment, { children: [
        /* @__PURE__ */ a(
          Gr,
          {
            data: G,
            x: ($) => D($),
            y: ($) => O($, ne, X),
            stroke: re ? w ? w(y.runtime.seriesLabels ? y.runtime.seriesLabels[X.dataKey] : X.dataKey) : "#000" : "transparent",
            strokeWidth: 2,
            strokeOpacity: 1,
            shapeRendering: "geometricPrecision",
            curve: ce,
            strokeDasharray: X.type ? g(X.type) : 0
          }
        ),
        /* @__PURE__ */ a(
          Ih,
          {
            fill: re ? w ? w(y.runtime.seriesLabels ? y.runtime.seriesLabels[X.dataKey] : X.dataKey) : "#000" : "transparent",
            fillOpacity: q ? 0.25 : 0.5,
            data: G,
            x: ($) => D($),
            y: ($) => O($, ne, X),
            yScale: n,
            curve: ce,
            strokeDasharray: X.type ? g(X.type) : 0
          },
          "area-chart"
        )
      ] }, ne);
    }),
    /* @__PURE__ */ a(
      Pr,
      {
        width: Number(i),
        height: Number(r),
        fill: "transparent",
        fillOpacity: 0.05,
        onMouseMove: (X) => o(X, S),
        onMouseLeave: h
      }
    )
  ] }, "area-wrapper") }) });
};
fe.memo(Lw);
const Ew = ({ xScale: e, yScale: t, yMax: n, xMax: r, handleTooltipMouseOver: i, handleTooltipMouseOff: o, isDebug: h }) => {
  var C, w;
  let { transformedData: d, config: c, seriesHighlight: p, colorScale: y, rawData: g } = fe.useContext(ft);
  const b = (C = c.brush) != null && C.active && ((w = c.brush.data) != null && w.length) ? c.brush.data : d;
  if (!b)
    return;
  const T = (S) => {
    if (c.xAxis.type === "categorical")
      return e(S);
    if (Tn(c.xAxis)) {
      let B = new Date(S);
      return e(B);
    }
  }, m = 2;
  return b && /* @__PURE__ */ a("svg", { height: Number(n), children: /* @__PURE__ */ a(Xr, { component: "AreaChartStacked", children: /* @__PURE__ */ F(
    qe,
    {
      className: "area-chart",
      left: Number(c.yAxis.size) + m / 2,
      height: Number(n),
      style: { overflow: "hidden" },
      children: [
        /* @__PURE__ */ a(
          V0,
          {
            data: b,
            keys: c.runtime.areaSeriesKeys.map((S) => S.dataKey) || c.series.map((S) => S.dataKey),
            x0: (S) => T(S.data[c.xAxis.dataKey]),
            y0: (S) => Number(t(S[0])),
            y1: (S) => Number(t(S[1])),
            curve: $a[os[c.stackedAreaChartLineType]],
            children: ({ stacks: S, path: B }) => S.map((M, D) => {
              let O = c.legend.behavior === "highlight" && p.length > 0 && p.indexOf(M.key) === -1, L = c.legend.behavior === "highlight" || p.length === 0 || p.indexOf(M.key) !== -1;
              return (
                // prettier-ignore
                /* @__PURE__ */ a(
                  "path",
                  {
                    d: B(M) || "",
                    strokeWidth: 2,
                    stroke: L ? y ? y(c.runtime.seriesLabels ? c.runtime.seriesLabels[M.key] : M.key) : "#000" : "transparent",
                    fillOpacity: O ? 0.2 : 1,
                    fill: L ? y ? y(c.runtime.seriesLabels ? c.runtime.seriesLabels[M.key] : M.key) : "#000" : "transparent"
                  },
                  M.key
                )
              );
            })
          }
        ),
        /* @__PURE__ */ a(Pr, { width: Number(r), height: Number(n), fill: "transparent", onMouseMove: (S) => i(S, g), onMouseLeave: o })
      ]
    },
    "area-wrapper"
  ) }) });
}, _w = fe.memo(Ew), zl = fe.createContext(null), Of = ({
  xScale: e,
  barWidth: t = 0,
  totalBarsInGroup: n = 1,
  yMax: r,
  handleTooltipMouseOff: i,
  handleTooltipMouseOver: o,
  handleTooltipClick: h,
  tooltipData: d,
  showTooltip: c,
  hideTooltip: p
}) => {
  const { parseDate: y, config: g } = fe.useContext(ft), { runtime: b, regions: T, visualizationType: m, orientation: C, xAxis: w } = g, S = e.domain(), B = (O) => {
    let L;
    if (!(O != null && O.fromType) || O.fromType === "Fixed") {
      const U = new Date(O.from), X = y(ol(g.xAxis.dateParseFormat, U)).getTime();
      L = e(X), m === "Bar" && w.type === "date-time" && (L = L - t * n / 2);
    }
    if (O.fromType === "Previous Days") {
      const U = Number(O.from) || 0;
      S.map((ce) => ol(g.xAxis.dateParseFormat, new Date(ce)));
      const X = O.toType === "Last Date" ? new Date(S[S.length - 1]).getTime() : new Date(O.to), ne = g.xAxis.type === "categorical" ? ol(g.xAxis.dateParseFormat, X) : ol(g.xAxis.dateParseFormat, X), G = new Date(ne);
      if (L = new Date(G.setDate(G.getDate() - Number(U))), w.type === "date") {
        L = new Date(ol(w.dateParseFormat, L)).getTime();
        let ce = S[0], q = Math.abs(L - ce);
        for (let re = 1; re < S.length; re++) {
          const $ = Math.abs(L - S[re]);
          $ < q && (q = $, ce = S[re]);
        }
        L = ce;
      }
      if (w.type === "categorical") {
        let ce = S[0], q = Math.abs(new Date(L).getTime() - new Date(ce).getTime());
        for (let re = 1; re < S.length; re++) {
          const $ = Math.abs(new Date(L).getTime() - new Date(S[re]).getTime());
          $ < q && (q = $, ce = S[re]);
        }
        L = ce;
      }
      L = e(L);
    }
    if (w.type === "categorical" && O.fromType !== "Previous Days" && (L = e(O.from)), m === "Line" || m === "Area Chart") {
      let U = Number(g.yAxis.size);
      e.bandwidth && (U += e.bandwidth() / 2), L = L + U;
    }
    return m === "Bar" && g.xAxis.type === "date-time" && O.fromType === "Previous Days" && (L = L - t * n / 2), L;
  }, M = (O) => {
    let L;
    if (w.type === "categorical" && (L = e(O.to)), Tn(w) && ((!(O != null && O.toType) || O.toType === "Fixed") && (L = e(y(O.to).getTime())), (m === "Bar" || g.visualizationType === "Combo") && (L = O.toType !== "Last Date" ? e(y(O.to).getTime()) + t * n : L)), O.toType === "Last Date") {
      const U = S[S.length - 1];
      L = Number(
        e(U) + ((m === "Bar" || m === "Combo") && g.xAxis.type === "date" ? t * n : 0)
      );
    }
    if (m === "Line" || m === "Area Chart") {
      let U = Number(g.yAxis.size);
      e.bandwidth && (U += e.bandwidth() / 2), L = L + U;
    }
    return m === "Bar" && g.xAxis.type === "date-time" && O.toType !== "Last Date" && (L = L - t * n / 2), (m === "Bar" || m === "Combo") && w.type === "categorical" && (L = L + (m === "Bar" || m === "Combo" ? t * n : 0)), L;
  }, D = (O, L) => O - L;
  if (T && C === "vertical")
    return T.map((O) => {
      const L = B(O), U = M(O), X = D(U, L);
      if (!L || !U)
        return null;
      const ne = () => /* @__PURE__ */ a("rect", { x: L, y: 0, width: X, height: r, fill: O.background, opacity: 0.3 });
      return /* @__PURE__ */ F(
        qe,
        {
          height: 100,
          fill: "red",
          className: "regions regions-group--line zzz",
          onMouseMove: o,
          onMouseLeave: i,
          handleTooltipClick: h,
          tooltipData: JSON.stringify(d),
          showTooltip: c,
          children: [
            /* @__PURE__ */ a(ne, {}),
            /* @__PURE__ */ a(dt, { x: L + X / 2, y: 5, fill: O.color, verticalAnchor: "start", textAnchor: "middle", children: O.label })
          ]
        },
        O.label
      );
    });
};
function $l(e) {
  var Z, ye;
  const { config: t, index: n, id: r, className: i, background: o, borderColor: h, borderWidth: d, width: c, height: p, x: y, y: g, onMouseOver: b, onMouseLeave: T, onClick: m, tooltipHtml: C, tooltipId: w, styleOverrides: S, seriesHighlight: B, type: M } = e, D = Math.max(0, c), O = Math.max(0, p), L = t.orientation === "horizontal", U = t.barStyle === "rounded", X = t.visualizationSubType === "stacked", ne = t.tipRounding, G = t.visualizationType === "Combo" && ((ye = (Z = t.runtime) == null ? void 0 : Z.barSeriesKeys) == null ? void 0 : ye.length), ce = t.runtime.seriesKeys.length, q = t.visualizationType === "Bar" && t.legend.axisAlign && (B != null && B.length) ? B == null ? void 0 : B.length : 0, re = G || q || ce;
  let $ = t.roundingStyle === "standard" ? 8 : t.roundingStyle === "shallow" ? 5 : t.roundingStyle === "finger" ? 15 : 0;
  ($ > D / 2 || $ > O / 2) && ($ = Math.min(D / 2, O / 2));
  const j = () => `M${y},${g + O}
      L${y},${g + $}
      Q${y},${g} ${y + $},${g}
      L${y + D - $},${g}
      Q${y + D},${g} ${y + D},${g + $}
      L${y + D},${g + O}
      L${y},${g + O}`, oe = () => `M${y},${g + O}
      L${y},${g}
      L${y + D - $},${g}
      Q${y + D},${g} ${y + D},${g + $}
      L${y + D},${g + O - $}
      Q${y + D},${g + O} ${y + D - $},${g + O}
      L${y},${g + O}`, ie = () => `M${y + $},${g + O}
      Q${y},${g + O} ${y},${g + O - $}
      L${y},${g}
      L${y + D},${g}
      L${y + D},${g + O - $}
      Q${y + D},${g + O} ${y + D - $},${g + O}
      L${y + $},${g + O}`, le = () => `M${y + $},${g + O}
      Q${y},${g + O} ${y},${g + O - $}
      L${y},${g + $}
      Q${y},${g} ${y + $},${g}
      L${y + D},${g}
      L${y + D},${g + O}
      L${y + $},${g + O}`, J = () => `M${y + $},${g + O}
      Q${y},${g + O} ${y},${g + O - $}
      L${y},${g + $}
      Q${y},${g} ${y + $},${g}
      L${y + D - $},${g}
      Q${y + D},${g} ${y + D},${g + $}
      L${y + D},${g + O - $}
      Q${y + D},${g + O} ${y + D - $},${g + O}
      L${y + $},${g + O}`, de = () => `M${y},${g}
      L${y + D},${g}
      L${y + D},${g + O}
      L${y},${g + O}
      L${y},${g}`;
  let ae;
  return n == null || !U || M == "axisBar" ? ae = de() : (ae = de(), (X && n + 1 === re || !X) && (ae = L ? oe() : j()), !X && n === -1 && (ae = L ? le() : ie()), ne === "full" && X && n === 0 && re > 1 && (ae = L ? le() : ie()), ne === "full" && (X && n === 0 && re === 1 || !X) && (ae = J())), /* @__PURE__ */ a(
    "path",
    {
      id: r,
      className: i,
      d: ae,
      fill: o,
      stroke: h,
      strokeWidth: d,
      onMouseOver: b,
      onMouseLeave: T,
      onClick: m,
      "data-tooltip-html": C,
      "data-tooltip-id": w,
      style: {
        transition: "all 0.2s linear",
        ...S
      }
    }
  );
}
const Pw = () => {
  var ce, q;
  const [e, t] = fe.useState(0), { xScale: n, yScale: r, seriesScale: i, xMax: o, yMax: h, barChart: d } = fe.useContext(zl), {
    isHorizontal: c,
    barBorderWidth: p,
    hoveredBar: y,
    getAdditionalColumn: g,
    onMouseLeaveBar: b,
    onMouseOverBar: T,
    barStackedSeriesKeys: m
  } = d, { transformedData: C, colorScale: w, seriesHighlight: S, config: B, formatNumber: M, formatDate: D, parseDate: O, setSharedFilter: L } = fe.useContext(ft), { orientation: U } = B, X = (ce = B.brush) != null && ce.active && ((q = B.brush.data) != null && q.length) ? B.brush.data : C, ne = B.runtime.xAxis.type === "date-time" || B.runtime.xAxis.type === "date", G = B.runtime.xAxis.type === "date-time";
  return B.visualizationSubType === "stacked" && !c && /* @__PURE__ */ F(Be, { children: [
    /* @__PURE__ */ a(
      tg,
      {
        data: X,
        keys: m,
        x: (re) => re[B.runtime.xAxis.dataKey],
        xScale: n,
        yScale: r,
        color: w,
        children: (re) => re.reverse().map(
          ($) => $.bars.map((j) => {
            let oe = B.legend.behavior === "highlight" && S.length > 0 && S.indexOf(j.key) === -1, ie = B.legend.behavior === "highlight" || S.length === 0 || S.indexOf(j.key) !== -1, le = ne ? i.range()[1] - i.range()[0] : o / $.bars.length;
            B.runtime.xAxis.type !== "date" && (le = B.barThickness * le);
            const J = j.bar.data[B.runtime.xAxis.dataKey], de = ne ? D(O(J)) : J, ae = M(j.bar ? j.bar.data[j.key] : 0, "left");
            if (!ae)
              return;
            const Z = n(ne ? O(J) : J) - (G ? le / 2 : 0), ye = B.runtime.xAxis.label ? `${B.runtime.xAxis.label}: ${de}` : de, ue = g(j.key, y), ve = `${B.runtime.seriesLabels[j.key]}: ${ae}`, ke = `<ul>
                  <li class="tooltip-heading"">${ye}</li>
                  <li class="tooltip-body ">${ve}</li>
                  <li class="tooltip-body ">${ue}</li>
                    </li></ul>`;
            return t(le), /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ a(
              qe,
              {
                id: `barStack${$.index}-${j.index}`,
                className: "stack vertical",
                children: $l({
                  config: B,
                  seriesHighlight: S,
                  index: $.index,
                  background: w(B.runtime.seriesLabels[j.key]),
                  borderColor: "#333",
                  borderStyle: "solid",
                  borderWidth: `${B.barHasBorder === "true" ? p : 0}px`,
                  width: le,
                  height: j.height,
                  x: Z,
                  y: j.y,
                  onMouseOver: (me) => T(de, j.key, me, X),
                  onMouseLeave: b,
                  tooltipHtml: ke,
                  tooltipId: `cdc-open-viz-tooltip-${B.runtime.uniqueId}`,
                  onClick: (me) => {
                    me.preventDefault(), L && (j[B.xAxis.dataKey] = de, L(B.uid, j));
                  },
                  styleOverrides: {
                    animationDelay: `${$.index * 0.5}s`,
                    transformOrigin: `${le / 2}px ${j.y + j.height}px`,
                    opacity: oe ? 0.2 : 1,
                    display: ie ? "block" : "none"
                  }
                })
              },
              `bar-stack-${$.index}-${j.index}`
            ) }, `${$.index}--${j.index}--${U}`);
          })
        )
      }
    ),
    /* @__PURE__ */ a(Of, { xScale: n, yMax: h, barWidth: e, totalBarsInGroup: 1 })
  ] });
}, Nw = () => {
  const { yMax: e, yScale: t, xScale: n, barChart: r } = fe.useContext(zl), {
    animatedChart: i,
    colorScale: o,
    config: h,
    formatDate: d,
    formatNumber: c,
    parseDate: p,
    seriesHighlight: y,
    setSharedFilter: g,
    transformedData: b
  } = fe.useContext(ft), {
    barBorderWidth: T,
    displayNumbersOnBar: m,
    getAdditionalColumn: C,
    hoveredBar: w,
    isHorizontal: S,
    isLabelBelowBar: B,
    onMouseLeaveBar: M,
    onMouseOverBar: D,
    barStackedSeriesKeys: O
  } = r, { orientation: L, visualizationSubType: U } = h;
  return h.visualizationSubType === "stacked" && S && /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ a(
    X0,
    {
      data: b,
      keys: O,
      height: e,
      y: (X) => X[h.runtime.yAxis.dataKey],
      xScale: n,
      yScale: t,
      color: o,
      offset: "none",
      children: (X) => X.map(
        (ne) => _f(h, ne.bars).map((G, ce) => {
          const q = h.legend.behavior === "highlight" && y.length > 0 && y.indexOf(G.key) === -1, re = h.legend.behavior === "highlight" || y.length === 0 || y.indexOf(G.key) !== -1;
          h.barHeight = Number(h.barHeight);
          let $ = o(h.runtime.seriesLabels[G.key]), j = as(zr, $);
          Lm(zr, $) < 7 && (j = "#fff");
          const le = c(b[G.index][G.key], "left"), J = h.runtime.yAxis.type === "date" ? d(p(b[G.index][h.runtime.originalXAxis.dataKey])) : b[G.index][h.runtime.originalXAxis.dataKey], de = h.runtime.yAxis.label ? `${h.runtime.yAxis.label}: ${J}` : J, ae = mr(le), Z = C(G.key, w), ye = `${h.runtime.seriesLabels[G.key]}: ${le}`, ue = `<ul>
                  <li class="tooltip-heading"">${de}</li>
                  <li class="tooltip-body ">${ye}</li>
                  <li class="tooltip-body ">${Z}</li>
                    </li></ul>`;
          return /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F(qe, { id: `barStack${ne.index}-${G.index}`, className: "stack horizontal", children: [
            $l({
              config: h,
              seriesHighlight: y,
              index: ne.index,
              className: `animated-chart group ${i ? "animated" : ""}`,
              background: o(h.runtime.seriesLabels[G.key]),
              borderColor: "#333",
              borderStyle: "solid",
              borderWidth: `${h.barHasBorder === "true" ? T : 0}px`,
              width: G.width,
              height: G.height,
              x: G.x,
              y: G.y,
              onMouseOver: (ve) => D(J, G.key, ve, b),
              onMouseLeave: M,
              tooltipHtml: ue,
              tooltipId: `cdc-open-viz-tooltip-${h.runtime.uniqueId}`,
              onClick: (ve) => {
                ve.preventDefault(), g && (G[h.xAxis.dataKey] = le, g(h.uid, G));
              },
              styleOverrides: {
                animationDelay: `${ne.index * 0.5}s`,
                transformOrigin: `${G.x}px 0`,
                opacity: q ? 0.2 : 1,
                display: re ? "block" : "none"
              }
            }),
            L === "horizontal" && U === "stacked" && B && ne.index === 0 && !h.yAxis.hideLabel && /* @__PURE__ */ a(
              dt,
              {
                x: `${G.x + (h.isLollipopChart ? 15 : 5)}`,
                y: G.y + G.height * 1.2,
                fill: "#000000",
                textAnchor: "start",
                verticalAnchor: "start",
                children: J
              }
            ),
            m && ae < G.width && /* @__PURE__ */ a(
              dt,
              {
                display: re ? "block" : "none",
                x: G.x + ne.bars[G.index].width / 2,
                y: G.y + G.height / 2,
                fill: j,
                textAnchor: "middle",
                verticalAnchor: "middle",
                children: le
              }
            )
          ] }, ce) });
        })
      )
    }
  ) });
}, Xc = (e, t) => {
  var C;
  const { formatDate: n, parseDate: r } = fe.useContext(ft);
  let i = [], o = "", h = [], d = [];
  ((C = e.series) == null ? void 0 : C.length) > 0 && e.data ? (i = e.series[0], o = e.series[0].dataKey, h = e.highlightedBarValues, d = e.data.map((w) => w[e.xAxis.dataKey])) : (i = [], o = "", h = [], d = []);
  const c = (w, S) => {
    const B = [...e.highlightedBarValues];
    B[S].borderWidth = w.target.value, t({
      ...e,
      highlightedBarValues: B
    });
  }, p = (w, S) => {
    w.preventDefault();
    const B = [...e.highlightedBarValues];
    B[S].value = w.target.value, B[S].dataKey = o, t({
      ...e,
      highlightedBarValues: B
    });
  }, y = (w, S) => {
    w.preventDefault();
    const B = [...e.highlightedBarValues];
    B.push({ dataKey: o }), t({
      ...e,
      highlightedBarValues: B
    });
  }, g = (w, S) => {
    w.preventDefault();
    const B = [...e.highlightedBarValues];
    B.splice(S, 1), t({
      ...e,
      highlightedBarValues: B
    });
  }, b = (w, S) => {
    const B = [...e.highlightedBarValues];
    B[S].color = w.target.value, t({
      ...e
    });
  }, T = (w, S) => {
    const B = [...e.highlightedBarValues];
    B[S].legendLabel = w.target.value, t({
      ...e,
      copyOfHighlightedBarValues: B
    });
  }, m = () => {
  };
  return m.checkFontColor = (w, S, B) => {
    if (e.xAxis.type === "date") {
      if (m.formatDates(S).includes(w))
        return "#000";
    } else if (S.includes(w))
      return "#000";
    return B;
  }, m.formatDates = (w) => w.map((S) => S ? n(r(S)) : !1), m.findDuplicates = (w) => {
    const S = {};
    return w == null ? void 0 : w.filter((M) => {
      const { legendLabel: D } = M;
      return S[D] ? !1 : (S[D] = !0, !0);
    });
  }, {
    HighLightedBarUtils: m,
    highlightedSeries: i,
    highlightedSeriesKey: o,
    highlightedBarValues: h,
    highlightedSeriesValues: d,
    handleUpdateHighlightedBar: p,
    handleAddNewHighlightedBar: y,
    handleRemoveHighlightedBar: g,
    handleUpdateHighlightedBarColor: b,
    handleHighlightedBarLegendLabel: T,
    handleUpdateHighlightedBorderWidth: c
  };
};
function Wa(e = "") {
  return typeof e == "number" ? !Number.isNaN(e) : typeof e == "string" ? e !== null && e !== "" && /\d+\.?\d*/.test(e) : !1;
}
const mg = ({
  bar: e,
  defaultBarHeight: t,
  defaultBarWidth: n,
  config: r,
  barWidth: i,
  isVertical: o,
  yAxisValue: h
}) => {
  let c = t, p = n, y = "", g = !1, b = !1, T = !1;
  const m = r.general.showSuppressedSymbol;
  if (r.preliminaryData.forEach((B) => {
    (!B.column || B.column === e.key) && B.type === "suppression" && B.value && String(B.value) === String(e.value) && (!B.hideBarSymbol && m ? (c = i > 10 ? 3 : 0, p = 3, g = !0) : (c = 0, p = 0, g = !0));
  }), !g && !Wa(e.value) && r.general.showMissingDataLabel) {
    const B = mr(y, `normal ${i / 2}px sans-serif`), M = Number(B) < i && i > 10;
    b = !0, c = M ? 3 : 0, p = 3;
  }
  if (!g && e.value === "0" && r.general.showZeroValueData) {
    const B = mr("0", `normal ${i / 2}px sans-serif`), M = Number(B) < i && i > 10;
    T = !0, c = M ? 3 : 0, p = 3;
  }
  const C = (B, M) => g || b || T ? r.isLollipopChart ? M - 3 * 2 : M - 3 : B, S = ((B) => {
    let M = "";
    String(B) === "0" && (M = ""), g && (M = ""), b && (M = "N/A"), T && (M = "0");
    const D = mr(y, `normal ${i / 2}px sans-serif`), O = Number(D) < i && i > 10;
    return r.isLollipopChart || O && o ? M : o ? "" : M;
  })(h);
  return { barWidthHorizontal: p, barHeight: c, isSuppressed: g, showMissingDataLabel: b, getBarY: C, absentDataLabel: S };
}, xl = (e) => e == null ? void 0 : /^0(\.0)?$/.test(e.toString()), yg = (e, t, n) => {
  const r = e.series.find((c) => c.dynamicCategory);
  if (!r)
    return t;
  const { dynamicCategory: i, dataKey: o } = r, h = e.runtime.originalXAxis.dataKey, d = Ke.groupBy(t, h);
  return Object.values(d).map((c) => c.reduce((p, y) => {
    const g = y[o], b = y[i];
    if (n) {
      const { lower: T, upper: m } = e.confidenceKeys;
      p.CI || (p.CI = {});
      const C = y[T], w = y[m];
      p.CI[b] = { lower: C, upper: w };
    }
    return p[b] = g, p[h] = y[h], p.dynamicData = !0, p;
  }, {}));
}, Rw = () => {
  const { xScale: e, yScale: t, xMax: n, yMax: r, seriesScale: i, convertLineToBarGraph: o, barChart: h } = fe.useContext(zl), {
    assignColorsToValues: d,
    barBorderWidth: c,
    getAdditionalColumn: p,
    getHighlightedBarByValue: y,
    getHighlightedBarColorByValue: g,
    lollipopBarWidth: b,
    lollipopShapeSize: T,
    onMouseLeaveBar: m,
    onMouseOverBar: C,
    section: w
  } = h, [S, B] = fe.useState(0), [M, D] = fe.useState(0), {
    colorScale: O,
    config: L,
    dashboardConfig: U,
    tableData: X,
    formatDate: ne,
    formatNumber: G,
    parseDate: ce,
    seriesHighlight: q,
    setSharedFilter: re,
    transformedData: $,
    brushConfig: j
  } = fe.useContext(ft), { HighLightedBarUtils: oe } = Xc(L);
  let ie = $;
  L.preliminaryData.some((ae) => ae.value && ae.type === "suppression") && (ie = X), j.data.length && (ie = j.data);
  const J = L.confidenceKeys.upper && L.confidenceKeys.lower && L.confidenceKeys.upper !== "" && L.confidenceKeys.lower !== "", de = yg(L, ie, J);
  return L.visualizationSubType !== "stacked" && (L.visualizationType === "Bar" || L.visualizationType === "Combo" || o) && L.orientation === "vertical" && /* @__PURE__ */ F(qe, { children: [
    /* @__PURE__ */ a(
      Qy,
      {
        data: de,
        keys: L.runtime.barSeriesKeys || L.runtime.seriesKeys,
        height: r,
        x0: (ae) => {
          const Z = ae[L.runtime.originalXAxis.dataKey];
          return Tn(L.runtime.xAxis) ? ce(Z) : Z;
        },
        x0Scale: e,
        x1Scale: i,
        yScale: t,
        color: () => "",
        children: (ae) => ae.map((Z, ye) => /* @__PURE__ */ a(
          qe,
          {
            className: `bar-group-${Z.index}-${Z.x0}--${ye} ${L.orientation}`,
            id: `bar-group-${Z.index}-${Z.x0}--${ye}`,
            left: Z.x0,
            children: Z.bars.map((ue, ve) => {
              var _e, xe;
              const ke = de[Z.index], me = ke[L.runtime.originalXAxis.dataKey], Ne = L.yAxis.type === "logarithmic" ? 0.1 : 0;
              let Ee = L.highlightedBarValues.map((Ge) => Ge.value).filter((Ge) => Ge !== void 0);
              Ee = L.xAxis.type === "date" ? oe.formatDates(Ee) : Ee;
              const De = L.legend.behavior === "highlight" && q.length > 0 && q.indexOf(ue.key) === -1, Xe = L.legend.behavior === "highlight" || q.length === 0 || q.indexOf(ue.key) !== -1;
              let Fe = i.range()[1] - i.range()[0];
              const Je = Math.abs(t(ue.value) - t(Ne)), gt = ue.value >= 0 && Wa(ue.value) ? ue.y : t(0);
              let mt = L.isLollipopChart ? b : i.bandwidth(), yt = ue.x + (L.isLollipopChart ? (Fe / Z.bars.length - b) / 2 : 0) - (L.xAxis.type === "date-time" ? Fe / 2 : 0);
              B(mt), D(Z.bars.length);
              const Ye = G(/[a-zA-Z]/.test(String(ue.value)) ? "" : ue.value, "left"), ot = L.runtime[w].type === "date" ? ne(ce(me)) : me, ut = ue.value < 0 ? -1 : ve, st = p(ue.key, me);
              let tt = L.runtime.xAxis.label ? `${L.runtime.xAxis.label}: ${ot}` : ot;
              const $e = `${L.runtime.seriesLabels[ue.key]}: ${Ye}`, it = `<ul>
                  <li class="tooltip-heading">${tt}</li>
                  <li class="tooltip-body ">${$e}</li>
                  ${st ? '<li class="tooltip-body ">' + st + "</li>" : ""}
                    </li></ul>`, { barHeight: ht, isSuppressed: Ce, getBarY: Ht, absentDataLabel: vn } = mg({
                bar: ue,
                defaultBarHeight: Je,
                config: L,
                barWidth: mt,
                isVertical: !0,
                yAxisValue: Ye
              });
              let pt = "#000000";
              pt = oe.checkFontColor(Ye, Ee, pt);
              const hn = L.isLollipopChart && L.lollipopColorStyle === "regular", yn = L.isLollipopChart && L.lollipopColorStyle === "two-tone", Vt = Ee == null ? void 0 : Ee.includes(ot), zt = g(ot), Cn = y(ot), qt = Vt ? zt : L.barHasBorder === "true" ? "#000" : "transparent", Ft = Vt ? Cn.borderWidth : L.isLollipopChart ? 0 : L.barHasBorder === "true" && !vn && !Ce ? c : 0, Gt = Ce || !L.labels ? "" : Ye, Zt = Ht(gt, t(Ne)), gn = xl(ue.value) ? "none" : "block", Pt = (Ge, Ze) => {
                var Wt;
                let et = Ge, Nt = Ze || "#f2f2f2";
                if (U && ((Wt = U.dashboard.sharedFilters) == null ? void 0 : Wt.length) !== 0) {
                  const { sharedFilters: xt } = U.dashboard;
                  return et = xt ? xt.map((at) => at.setBy === L.uid ? at.resetLabel === at.active || at.active === $[Z.index][L.xAxis.dataKey] ? O(L.runtime.seriesLabels[ue.key]) : Nt : O(L.runtime.seriesLabels[ue.key]))[0] : O(L.runtime.seriesLabels[ue.key]), hn && (et = Ge), Vt && (et = "transparent"), L.legend.colorCode && (et = d(ae.length, Z.index, Ge)), yn && (et = Qi(Ge).brighten(1)), et;
                }
                return yn && (et = Qi(Ge).brighten(1)), L.legend.colorCode && (et = d(ae.length, Z.index, Ge)), Vt && (et = "transparent"), et;
              }, Qt = 5, Rt = yt + (L.xAxis.type !== "date-time" ? mt / 2 : 0), bt = t(
                ke.dynamicData && ((_e = ke == null ? void 0 : ke.CI) != null && _e[ue.key]) ? ke.CI[ue.key].upper : ke[L.confidenceKeys.upper]
              ), lt = t(
                ke.dynamicData && ((xe = ke == null ? void 0 : ke.CI) != null && xe[ue.key]) ? ke.CI[ue.key].lower : ke[L.confidenceKeys.lower]
              ), Se = 10;
              return /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ F(qe, { children: [
                $l({
                  config: L,
                  index: ut,
                  id: `barGroup${Z.index}`,
                  background: Pt(O(L.runtime.seriesLabels[ue.key])),
                  borderColor: qt,
                  borderStyle: "solid",
                  borderWidth: `${Ft}px`,
                  width: mt,
                  height: ht,
                  x: yt,
                  y: Zt,
                  onMouseOver: (Ge) => C(ot, ue.key, Ge, ie),
                  onMouseLeave: m,
                  tooltipHtml: it,
                  tooltipId: `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                  onClick: (Ge) => {
                    Ge.preventDefault(), re && (ue[L.xAxis.dataKey] = ot, re(L.uid, ue));
                  },
                  styleOverrides: {
                    transformOrigin: `0 ${Zt + ht}px`,
                    opacity: De ? 0.2 : 1,
                    display: Xe ? "block" : "none",
                    cursor: U ? "pointer" : "default"
                  }
                }),
                L.preliminaryData.map((Ge, Ze) => {
                  const et = !Ge.column || Ge.column === ue.key;
                  if (!(String(Ge.value) === String(ue.value) && Ge.value !== "" && et) || mt < 10 || !L.general.showSuppressedSymbol || Ge.hideBarSymbol)
                    return;
                  const xt = String(Ge.symbol).includes("Asterisk"), at = xt ? -5 : -8, un = xt ? "middle" : "end", jt = Ge.symbol === "Asterisk" ? mt * 1.2 : Ge.symbol === "Double Asterisk" ? mt : mt / 1.5, An = Ge.displayGray ? "#8b8b8a" : "#000";
                  return /* @__PURE__ */ a(
                    dt,
                    {
                      dy: at,
                      display: Xe ? "block" : "none",
                      opacity: De ? 0.5 : 1,
                      x: yt + mt / 2,
                      y: Zt,
                      verticalAnchor: un,
                      fill: An,
                      textAnchor: "middle",
                      fontSize: `${jt}px`,
                      children: Ge.iconCode
                    },
                    Ze
                  );
                }),
                /* @__PURE__ */ a(
                  dt,
                  {
                    display: Xe ? "block" : "none",
                    opacity: De ? 0.5 : 1,
                    x: J ? yt + mt : yt + mt / 2,
                    y: Zt - Se,
                    fill: pt,
                    textAnchor: "middle",
                    children: xl(ue.value) ? "" : Gt
                  }
                ),
                /* @__PURE__ */ a(
                  dt,
                  {
                    display: Xe ? "block" : "none",
                    opacity: De ? 0.5 : 1,
                    x: yt + mt / 2,
                    y: Zt - Se,
                    fill: pt,
                    textAnchor: "middle",
                    fontSize: L.isLollipopChart ? null : mt / 2,
                    children: vn
                  }
                ),
                L.isLollipopChart && L.lollipopShape === "circle" && /* @__PURE__ */ a(
                  "circle",
                  {
                    display: gn,
                    cx: yt + T / 3.5,
                    cy: ue.y,
                    r: T / 2,
                    fill: Pt(O(L.runtime.seriesLabels[ue.key])),
                    "data-tooltip-html": it,
                    "data-tooltip-id": `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                    style: { filter: "unset", opacity: 1 }
                  },
                  `circle--${ue.index}`
                ),
                L.isLollipopChart && L.lollipopShape === "square" && /* @__PURE__ */ a(
                  "rect",
                  {
                    display: gn,
                    x: yt - b / 2,
                    y: ue.y,
                    width: T,
                    height: T,
                    fill: Pt(O(L.runtime.seriesLabels[ue.key])),
                    "data-tooltip-html": it,
                    "data-tooltip-id": `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                    style: { opacity: 1, filter: "unset" },
                    children: /* @__PURE__ */ a("animate", { attributeName: "height", values: `0, ${T}`, dur: "2.5s" })
                  },
                  `circle--${ue.index}`
                ),
                J && ue.value !== void 0 && ke && /* @__PURE__ */ a(
                  "path",
                  {
                    stroke: zr,
                    strokeWidth: "px",
                    d: `M${Rt - Qt} ${bt}
                                L${Rt + Qt} ${bt}
                                M${Rt} ${bt}
                                L${Rt} ${lt}
                                M${Rt - Qt} ${lt}
                                L${Rt + Qt} ${lt}`
                  },
                  `confidence-interval-v-${ke[L.runtime.originalXAxis.dataKey]}`
                )
              ] }, `bar-sub-group-${Z.index}-${Z.x0}-${Zt}--${ve}`) }, `${Z.index}--${ve}`);
            })
          },
          `bar-group-${Z.index}-${Z.x0}--${ye}`
        ))
      }
    ),
    /* @__PURE__ */ a(Of, { xScale: e, yMax: r, barWidth: S, totalBarsInGroup: M })
  ] });
}, Dw = () => {
  var j;
  const { xScale: e, yScale: t, yMax: n, seriesScale: r, barChart: i } = fe.useContext(zl), {
    isHorizontal: o,
    barBorderWidth: h,
    assignColorsToValues: d,
    section: c,
    isLabelBelowBar: p,
    lollipopBarWidth: y,
    lollipopShapeSize: g,
    getHighlightedBarColorByValue: b,
    getHighlightedBarByValue: T,
    getAdditionalColumn: m,
    hoveredBar: C,
    onMouseLeaveBar: w,
    onMouseOverBar: S
  } = i, {
    transformedData: B,
    tableData: M,
    colorScale: D,
    seriesHighlight: O,
    config: L,
    formatNumber: U,
    formatDate: X,
    parseDate: ne,
    setSharedFilter: G,
    isNumber: ce
  } = fe.useContext(ft), { HighLightedBarUtils: q } = Xc(L), re = Object.keys(L.confidenceKeys).length > 0, $ = yg(L, B, re);
  return L.visualizationSubType !== "stacked" && L.visualizationType === "Bar" && L.orientation === "horizontal" && /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ a(
    Qy,
    {
      data: (j = L.preliminaryData) != null && j.some((oe) => oe.value && oe.type === "suppression") ? M : $,
      keys: L.runtime.barSeriesKeys || L.runtime.seriesKeys,
      height: n,
      x0: (oe) => oe[L.runtime.originalXAxis.dataKey],
      x0Scale: t,
      x1Scale: r,
      yScale: e,
      color: () => "",
      children: (oe) => _f(L, oe).map((ie, le) => /* @__PURE__ */ a(
        qe,
        {
          className: `bar-group-${ie.index}-${ie.x0}--${le} ${L.orientation}`,
          id: `bar-group-${ie.index}-${ie.x0}--${le}`,
          top: ie.y,
          children: ie.bars.map((J, de) => {
            var Ge;
            const ae = $[ie.index], Z = ae[L.runtime.originalXAxis.dataKey], ye = L.yAxis.type === "logarithmic" ? 0.1 : 0;
            let ue = L.highlightedBarValues.map((Ze) => Ze.value).filter((Ze) => Ze !== void 0);
            ue = L.xAxis.type === "date" ? q.formatDates(ue) : ue;
            let ve = L.legend.behavior === "highlight" && O.length > 0 && O.indexOf(J.key) === -1, ke = L.legend.behavior === "highlight" || O.length === 0 || O.indexOf(J.key) !== -1, me = L.barHeight, Ne = parseInt(L.isLollipopChart ? y : me);
            isNaN(Ne) && (Ne = 25);
            let Ee = J.value >= 0 && ce(J.value) ? J.y : t(ye);
            const De = Math.abs(e(J.value) - e(ye)), Xe = J.value >= 0 && ce(J.value), Fe = J.value < 0 ? Math.abs(e(J.value)) : e(ye), Je = U(J.value, "left"), gt = L.runtime[c].type === "date" ? X(ne(Z)) : Z, {
              barWidthHorizontal: mt,
              isSuppressed: yt,
              absentDataLabel: Ye
            } = mg({ bar: J, defaultBarWidth: De, config: L, isNumber: ce, isVertical: !1, yAxisValue: Je }), ot = Xe ? "above" : "below", ut = L.yAxis.displayNumbersOnBar ? Je : "", st = mr(ut), tt = Number(st) < De - 5;
            let $e = tt ? "end" : "start", it = "start", ht = tt ? -5 : 5, Ce = 10;
            ot === "below" && ($e = tt ? "start" : "end", ht = tt ? 5 : -5, L.isLollipopChart && (it = "end", Ce = -10));
            const Ht = J.value < 0 ? -1 : de;
            let vn = L.runtime.yAxis.label ? `${L.runtime.yAxis.label}: ${gt}` : gt;
            const pt = m(J.key, C), hn = `${L.runtime.seriesLabels[J.key]}: ${Je}`, yn = `<ul>
                  <li class="tooltip-heading"">${vn}</li>
                  <li class="tooltip-body ">${hn}</li>
                  <li class="tooltip-body ">${pt}</li>
                    </li></ul>`;
            let Vt = "#000000";
            Vt = q.checkFontColor(Je, ue, Vt);
            let zt = L.runtime.seriesLabels && L.runtime.seriesLabels[J.key] ? D(L.runtime.seriesLabels[J.key]) : D(J.key);
            L.series.find((Ze) => Ze.dynamicCategory) || (zt = d(oe.length, ie.index, zt));
            const qt = L.isLollipopChart && L.lollipopColorStyle === "regular", Ft = L.isLollipopChart && L.lollipopColorStyle === "two-tone", Gt = ue == null ? void 0 : ue.includes(gt), Zt = b(gt), gn = T(gt), Pt = Gt ? Zt : L.barHasBorder === "true" ? "#000" : "transparent", Qt = Gt ? gn.borderWidth : L.isLollipopChart ? 0 : L.barHasBorder === "true" && !Ye && !yt ? h : 0, Rt = xl(J.value) ? "none" : "block";
            zt && Vt && tt && (Vt = as(zr, zt), Lm(zr, zt) < 7 && (Vt = "#fff"));
            const bt = () => qt ? zt : Ft ? Qi(zt).brighten(1) : Gt ? "transparent" : zt, lt = 5, Se = me * J.index + me / 2, [_e, xe] = ["upper", "lower"].map((Ze) => {
              if (!re)
                return;
              if (ae.dynamicData) {
                const Nt = ae.CI[J.key];
                if (!Nt)
                  return;
                const Wt = Nt[Ze];
                return e(Wt);
              }
              const et = ae[L.confidenceKeys[Ze]];
              return e(et);
            });
            return /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ F(qe, { children: [
              $l({
                config: L,
                index: Ht,
                id: `barGroup${ie.index}`,
                background: bt(),
                borderColor: Pt,
                borderStyle: "solid",
                borderWidth: `${Qt}px`,
                width: mt,
                height: Ne,
                x: Fe,
                y: me * J.index,
                onMouseOver: (Ze) => S(gt, J.key, Ze, B),
                onMouseLeave: w,
                tooltipHtml: yn,
                tooltipId: `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                onClick: (Ze) => {
                  Ze.preventDefault(), G && (J[L.xAxis.dataKey] = Je, G(L.uid, J));
                },
                styleOverrides: {
                  transformOrigin: `0 ${Ee + me}px`,
                  opacity: ve ? 0.2 : 1,
                  display: ke ? "block" : "none"
                }
              }),
              (Ge = L.preliminaryData) == null ? void 0 : Ge.map((Ze, et) => {
                const Nt = !Ze.column || Ze.column === J.key;
                if (!(String(Ze.value) === String(J.value) && Ze.value !== "" && Nt) || Ze.hideBarSymbol || !L.general.showSuppressedSymbol)
                  return;
                const un = String(Ze.symbol).includes("Asterisk") ? "middle" : "end", jt = Ze.symbol === "Asterisk" ? me * 1.2 : Ze.symbol === "Double Asterisk" ? me : me / 1.5, An = Ze.displayGray ? "#8b8b8a" : "#000";
                return /* @__PURE__ */ a(
                  dt,
                  {
                    fontSize: jt,
                    display: ke ? "block" : "none",
                    opacity: ve ? 0.5 : 1,
                    x: Fe,
                    y: L.barHeight / 2 + L.barHeight * J.index,
                    fill: An,
                    dy: L.barHeight / 5,
                    dx: 10,
                    textAnchor: "start",
                    verticalAnchor: un,
                    children: Ze.iconCode
                  },
                  et
                );
              }),
              !L.isLollipopChart && /* @__PURE__ */ a(
                dt,
                {
                  display: ke ? "block" : "none",
                  x: J.y,
                  opacity: ve ? 0.5 : 1,
                  y: L.barHeight / 2 + L.barHeight * J.index,
                  fill: Vt,
                  dx: ht,
                  verticalAnchor: "middle",
                  textAnchor: $e,
                  children: xl(J.value) ? "" : ut
                }
              ),
              /* @__PURE__ */ a(
                dt,
                {
                  display: ke ? "block" : "none",
                  x: J.y,
                  opacity: ve ? 0.5 : 1,
                  y: L.barHeight / 2 + L.barHeight * J.index,
                  fill: Vt,
                  dx: Ye === "N/A" ? 20 : ht,
                  dy: L.isLollipopChart ? -10 : 0,
                  verticalAnchor: "middle",
                  textAnchor: Ye === "N/A" ? "middle" : $e,
                  children: Ye
                }
              ),
              L.isLollipopChart && /* @__PURE__ */ a(
                dt,
                {
                  display: ke ? "block" : "none",
                  x: J.y,
                  y: 0,
                  fill: "#000000",
                  dx: Ce,
                  textAnchor: it,
                  verticalAnchor: "middle",
                  fontWeight: "normal",
                  children: xl(J.value) ? "" : ut
                }
              ),
              p && !L.yAxis.hideLabel && /* @__PURE__ */ a(
                dt,
                {
                  x: L.yAxis.hideAxis ? 0 : 5,
                  y: ie.height,
                  dy: 4,
                  verticalAnchor: "start",
                  textAnchor: "start",
                  children: L.runtime.yAxis.type === "date" ? X(ne(Z)) : o ? Z : U(Z)
                }
              ),
              L.isLollipopChart && L.lollipopShape === "circle" && /* @__PURE__ */ a(
                "circle",
                {
                  display: Rt,
                  cx: J.y,
                  cy: me * J.index + y / 2,
                  r: g / 2,
                  fill: zt,
                  "data-tooltip-html": yn,
                  "data-tooltip-id": `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                  style: { filter: "unset", opacity: 1 }
                },
                `circle--${J.index}`
              ),
              L.isLollipopChart && L.lollipopShape === "square" && /* @__PURE__ */ a(
                "rect",
                {
                  display: Rt,
                  x: J.y > 10 ? J.y - g / 2 : 0,
                  y: 0 - y / 2,
                  width: g,
                  height: g,
                  fill: zt,
                  "data-tooltip-html": yn,
                  "data-tooltip-id": `cdc-open-viz-tooltip-${L.runtime.uniqueId}`,
                  style: { opacity: 1, filter: "unset" },
                  children: /* @__PURE__ */ a("animate", { attributeName: "height", values: `0, ${g}`, dur: "2.5s" })
                },
                `circle--${J.index}`
              ),
              re && /* @__PURE__ */ a(
                "path",
                {
                  stroke: zr,
                  strokeWidth: "px",
                  d: `
                                M${xe} ${Se - lt}
                                L${xe} ${Se + lt}
                                M${xe} ${Se}
                                L${_e} ${Se}
                                M${_e} ${Se - lt}
                                L${_e} ${Se + lt} `
                },
                `confidence-interval-h-${Se}-${ae[L.runtime.originalXAxis.dataKey]}`
              )
            ] }, `bar-sub-group-${ie.index}-${ie.x0}-${Ee}--${de}`) }, `${ie.index}--${de}`);
          })
        },
        `bar-group-${ie.index}-${ie.x0}--${le}`
      ))
    }
  ) });
}, Ku = {
  Vertical: Rw,
  Horizontal: Dw,
  StackedVertical: Pw,
  StackedHorizontal: Nw
}, Ow = (e, t, n) => {
  const { config: r, colorPalettes: i, tableData: o, updateConfig: h, parseDate: d, formatDate: c, seriesHighlight: p } = n, { orientation: y } = r, g = fe.useContext(ef), [b, T] = fe.useState(null), m = y === "horizontal", C = 1, w = r.lollipopSize === "large" ? 7 : r.lollipopSize === "medium" ? 6 : 5, S = r.lollipopSize === "large" ? 14 : r.lollipopSize === "medium" ? 12 : 10, B = r.yAxis.labelPlacement === "Below Bar", M = r.yAxis.displayNumbersOnBar, D = r.orientation === "horizontal" ? "yAxis" : "xAxis", O = r.barStyle === "rounded", L = r.visualizationSubType === "stacked", U = r.tipRounding, X = r.roundingStyle === "standard" ? "8px" : r.roundingStyle === "shallow" ? "5px" : r.roundingStyle === "finger" ? "15px" : "0px", ne = r.runtime.seriesKeys.length, G = Object.keys(r.runtime.seriesLabels).length > 1, q = r.visualizationType === "Bar" && r.legend.behavior === "isolate" && r.legend.axisAlign && (p != null && p.length) ? p : r.runtime.barSeriesKeys || r.runtime.seriesKeys;
  return fe.useEffect(() => {
    y === "horizontal" && !r.yAxis.labelPlacement && h({
      ...r,
      yAxis: {
        ...r.yAxis,
        labelPlacement: "Below Bar"
      }
    });
  }, [r, h]), fe.useEffect(() => {
    r.isLollipopChart === !1 && r.barHeight < 25 && h({ ...r, barHeight: 25 });
  }, [r.isLollipopChart]), fe.useEffect(() => {
    r.visualizationSubType === "horizontal" && h({
      ...r,
      orientation: "horizontal"
    });
  }, []), fe.useEffect(() => {
    r.barStyle === "lollipop" && !r.isLollipopChart && h({ ...r, isLollipopChart: !0 }), (O || r.barStyle === "flat") && h({ ...r, isLollipopChart: !1 });
  }, [r.barStyle]), {
    isHorizontal: m,
    barBorderWidth: C,
    lollipopBarWidth: w,
    lollipopShapeSize: S,
    isLabelBelowBar: B,
    displayNumbersOnBar: M,
    shouldSuppress: (ae) => {
      var Z;
      return (Z = r.preliminaryData) == null ? void 0 : Z.some((ye) => {
        const ue = ye.column ? ye.column === ae.key : !0, ve = String(ae.value) === String(ye.value) && ye.value !== "";
        return ue && ve && ye.symbol && ye.type === "suppression";
      });
    },
    section: D,
    isRounded: O,
    isStacked: L,
    tipRounding: U,
    radius: X,
    stackCount: ne,
    barStackedSeriesKeys: q,
    hasMultipleSeries: G,
    applyRadius: (ae) => {
      if (ae == null || !O)
        return {};
      let Z = {};
      return (L && ae + 1 === ne || !L) && (Z = m ? { borderRadius: `0 ${X}  ${X}  0` } : { borderRadius: `${X} ${X} 0 0` }), !L && ae === -1 && (Z = m ? { borderRadius: `${X} 0  0 ${X} ` } : { borderRadius: ` 0  0 ${X} ${X}` }), U === "full" && L && ae === 0 && ne > 1 && (Z = m ? { borderRadius: `${X} 0 0 ${X}` } : { borderRadius: `0 0 ${X} ${X}` }), U === "full" && (L && ae === 0 && ne === 1 || !L) && (Z = { borderRadius: X }), Z;
    },
    assignColorsToValues: (ae, Z, ye) => {
      if (!r.legend.colorCode && r.series.length > 1)
        return ye;
      const ue = r.customColors ?? i[r.palette], ve = o.map((Ee) => Ee[r.legend.colorCode]);
      let ke = /* @__PURE__ */ new Map(), me = [];
      for (let Ee = 0; Ee < ve.length; Ee++)
        ke.has(ve[Ee]) || ke.set(ve[Ee], ue[ke.size % ue.length]), me.push(ke.get(ve[Ee]));
      for (; me.length < ae; )
        me = me.concat(me);
      return me[Z];
    },
    getHighlightedBarColorByValue: (ae) => {
      const Z = r == null ? void 0 : r.highlightedBarValues.find((ye) => {
        if (ye.value)
          return r.xAxis.type === "date" ? c(d(ye.value)) === ae : ye.value === ae;
      });
      return Z != null && Z.color ? Z.color : "rgba(255, 102, 1)";
    },
    getHighlightedBarByValue: (ae) => {
      const Z = r == null ? void 0 : r.highlightedBarValues.filter((ye) => {
        if (ye.value)
          return r.xAxis.type === "date" ? c(d(ye.value)) === ae : ye.value === ae;
      })[0];
      return Z != null && Z.color ? Z : !1;
    },
    getAdditionalColumn: (ae, Z) => {
      var Ne, Ee;
      if (!Z)
        return "";
      const ye = r.columns, ue = [];
      let ve = "";
      const ke = (Ee = (Ne = r.runtime) == null ? void 0 : Ne.series) == null ? void 0 : Ee.find((De) => De == null ? void 0 : De.dynamicCategory), me = o.find((De) => {
        const Xe = ke ? De[ke.dynamicCategory] === ae : !0;
        return De[r.xAxis.dataKey] === Z && Xe;
      }) || {};
      return Object.keys(ye).forEach((De) => {
        const Xe = r.columns[De];
        if (ae && Xe.series && Xe.series !== ae && !Xe.tooltips)
          return;
        const Fe = {
          addColPrefix: r.columns[De].prefix,
          addColSuffix: r.columns[De].suffix,
          addColRoundTo: r.columns[De].roundToPlace ? r.columns[De].roundToPlace : "",
          addColCommas: r.columns[De].commas
        }, Je = Jh(
          me[r.columns[De].name],
          "left",
          !0,
          r,
          Fe
        );
        r.columns[De].tooltips && ue.push([r.columns[De].label, Je]);
      }), ue.forEach((De) => {
        ve += `${De[0]} : ${De[1]} <br/>`;
      }), ve;
    },
    hoveredBar: b,
    setHoveredBar: T,
    onMouseOverBar: (ae, Z, ye, ue) => {
      r.legend.highlightOnHover && r.legend.behavior === "highlight" && Z && g({ type: "SET_SERIES_HIGHLIGHT", payload: [Z] }), e(ye, ue), T(ae);
    },
    onMouseLeaveBar: () => {
      r.legend.highlightOnHover && r.legend.behavior === "highlight" && g({ type: "SET_SERIES_HIGHLIGHT", payload: [] }), t();
    }
  };
}, Mw = ({
  xScale: e,
  yScale: t,
  seriesScale: n,
  xMax: r,
  yMax: i,
  handleTooltipMouseOver: o,
  handleTooltipMouseOff: h,
  handleTooltipClick: d
}) => {
  const c = fe.useContext(ft), { transformedData: p, config: y, convertLineToBarGraph: g } = c, b = Ow(o, h, c), T = {
    xScale: e,
    yScale: t,
    xMax: r,
    yMax: i,
    seriesScale: n,
    convertLineToBarGraph: g,
    barChart: b
  };
  return /* @__PURE__ */ a(Xr, { component: "BarChart", children: /* @__PURE__ */ a(zl.Provider, { value: T, children: /* @__PURE__ */ F(qe, { left: parseFloat(y.runtime.yAxis.size), children: [
    /* @__PURE__ */ a(Ku.StackedVertical, {}),
    /* @__PURE__ */ a(Ku.StackedHorizontal, {}),
    /* @__PURE__ */ a(Ku.Vertical, {}),
    /* @__PURE__ */ a(Ku.Horizontal, {}),
    /* @__PURE__ */ a(
      Pr,
      {
        display: y.tooltips.singleSeries ? "none" : "block",
        width: Number(r),
        height: Number(i),
        fill: "transparent",
        fillOpacity: 0.05,
        onMouseMove: (m) => {
          o(m, p);
        },
        onMouseOut: h,
        onClick: (m) => d(m, p)
      },
      "bars"
    )
  ] }) }) });
};
function Ki() {
  return Ki = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ki.apply(this, arguments);
}
function Ba(e) {
  var t = e.x1, n = e.x2, r = e.y1, i = e.y2;
  return {
    x1: r,
    x2: i,
    y1: t,
    y2: n
  };
}
function gg(e) {
  var t = e.left, n = t === void 0 ? 0 : t, r = e.top, i = r === void 0 ? 0 : r, o = e.className, h = e.max, d = e.min, c = e.firstQuartile, p = e.thirdQuartile, y = e.median, g = e.boxWidth, b = g === void 0 ? 10 : g, T = e.fill, m = e.fillOpacity, C = e.stroke, w = e.strokeWidth, S = e.rx, B = S === void 0 ? 2 : S, M = e.ry, D = M === void 0 ? 2 : M, O = e.valueScale, L = e.outliers, U = L === void 0 ? [] : L, X = e.horizontal, ne = e.medianProps, G = ne === void 0 ? {} : ne, ce = e.maxProps, q = ce === void 0 ? {} : ce, re = e.minProps, $ = re === void 0 ? {} : re, j = e.boxProps, oe = j === void 0 ? {} : j, ie = e.outlierProps, le = ie === void 0 ? {} : ie, J = e.container, de = J === void 0 ? !1 : J, ae = e.containerProps, Z = ae === void 0 ? {} : ae, ye = e.children, ue = X ? i : n, ve = ue + (b || 0) / 2, ke = O.range(), me = O(d ?? 0), Ne = O(c ?? 0), Ee = O(y ?? 0), De = O(p ?? 0), Xe = O(h ?? 0), Fe = {
    valueRange: ke,
    center: ve,
    offset: ue,
    boxWidth: b,
    max: {
      x1: ve - (b || 0) / 4,
      x2: ve + (b || 0) / 4,
      y1: Xe,
      y2: Xe
    },
    maxToThird: {
      x1: ve,
      x2: ve,
      y1: Xe,
      y2: De
    },
    median: {
      x1: ue,
      x2: ue + (b || 0),
      y1: Ee,
      y2: Ee
    },
    minToFirst: {
      x1: ve,
      x2: ve,
      y1: Ne,
      y2: me
    },
    min: {
      x1: ve - (b || 0) / 4,
      x2: ve + (b || 0) / 4,
      y1: me,
      y2: me
    },
    box: {
      x1: ue,
      x2: b || 0,
      y1: De,
      y2: Math.abs(De - Ne)
    },
    container: {
      x1: ue,
      x2: b || 0,
      y1: Math.min.apply(Math, ke),
      y2: Math.abs(ke[0] - ke[1])
    }
  };
  return X && (Fe.max = Ba(Fe.max), Fe.maxToThird = Ba(Fe.maxToThird), Fe.box.y1 = Ne, Fe.box = Ba(Fe.box), Fe.median = Ba(Fe.median), Fe.minToFirst = Ba(Fe.minToFirst), Fe.min = Ba(Fe.min), Fe.container = Ba(Fe.container), Fe.container.y1 = Math.min.apply(Math, ke)), ye ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, ye(Fe)) : /* @__PURE__ */ Ie.createElement(qe, {
    className: Sn("visx-boxplot", o)
  }, U.map(function(Je, gt) {
    var mt = X ? O(Je) : ve, yt = X ? ve : O(Je);
    return /* @__PURE__ */ Ie.createElement("circle", Ki({
      key: "visx-boxplot-outlier-" + gt,
      className: "visx-boxplot-outlier",
      cx: mt,
      cy: yt,
      r: 4,
      stroke: C,
      strokeWidth: w,
      fill: T,
      fillOpacity: m
    }, le));
  }), /* @__PURE__ */ Ie.createElement("line", Ki({
    className: "visx-boxplot-max",
    x1: Fe.max.x1,
    y1: Fe.max.y1,
    x2: Fe.max.x2,
    y2: Fe.max.y2,
    stroke: C,
    strokeWidth: w
  }, q)), /* @__PURE__ */ Ie.createElement("line", {
    className: "visx-boxplot-max-to-third",
    x1: Fe.maxToThird.x1,
    y1: Fe.maxToThird.y1,
    x2: Fe.maxToThird.x2,
    y2: Fe.maxToThird.y2,
    stroke: C,
    strokeWidth: w
  }), /* @__PURE__ */ Ie.createElement("rect", Ki({
    className: "visx-boxplot-box",
    x: Fe.box.x1,
    y: Fe.box.y1,
    width: Fe.box.x2,
    height: Fe.box.y2,
    stroke: C,
    strokeWidth: w,
    fill: T,
    fillOpacity: m,
    rx: B,
    ry: D
  }, oe)), /* @__PURE__ */ Ie.createElement("line", Ki({
    className: "visx-boxplot-median",
    x1: Fe.median.x1,
    y1: Fe.median.y1,
    x2: Fe.median.x2,
    y2: Fe.median.y2,
    stroke: C,
    strokeWidth: w
  }, G)), /* @__PURE__ */ Ie.createElement("line", {
    className: "visx-boxplot-min-to-first",
    x1: Fe.minToFirst.x1,
    y1: Fe.minToFirst.y1,
    x2: Fe.minToFirst.x2,
    y2: Fe.minToFirst.y2,
    stroke: C,
    strokeWidth: w
  }), /* @__PURE__ */ Ie.createElement("line", Ki({
    className: "visx-boxplot-min",
    x1: Fe.min.x1,
    y1: Fe.min.y1,
    x2: Fe.min.x2,
    y2: Fe.min.y2,
    stroke: C,
    strokeWidth: w
  }, $)), de && /* @__PURE__ */ Ie.createElement("rect", Ki({
    x: Fe.container.x1,
    y: Fe.container.y1,
    width: Fe.container.x2,
    height: Fe.container.y2,
    fillOpacity: "0"
  }, Z)));
}
gg.propTypes = {
  max: Re.number,
  min: Re.number,
  firstQuartile: Re.number,
  thirdQuartile: Re.number,
  median: Re.number,
  boxWidth: Re.number,
  fill: Re.string,
  fillOpacity: Re.oneOfType([Re.number, Re.string]),
  stroke: Re.string,
  strokeWidth: Re.oneOfType([Re.number, Re.string]),
  rx: Re.number,
  ry: Re.number,
  outliers: Re.arrayOf(Re.number),
  container: Re.bool,
  children: Re.func
};
const Iw = (e, t, n, r, i, o, h, d, c) => `
    <div class="p-2  text-red" style="max-width: 300px; word-wrap: break-word; opacity:0.7; background: rgba(255, 255, 255, 0.9)">
      <div class="fw-bold" style="color: ${c};">
        ${d ? `${d} : ${t}` : t}
      </div>
      <div class="" style="background: ${c}; height: 2px;"></div>
        <strong>Key:</strong> ${n}<br/>
        <strong>${e.labels.q1}:</strong> ${r}<br/>
        <strong>${e.labels.q3}:</strong> ${i}<br/>
        <strong>${e.labels.iqr}:</strong> ${h}<br/>
        <strong>${e.labels.median}:</strong> ${o}
    </div>
  `, Fw = (e) => {
  if (!e || e.length === 0)
    return {};
  const t = Ke.sortBy(e), n = kl(t, 0.25) ?? 0, r = kl(t, 0.75) ?? 0, i = r - n, o = n - 1.5 * i, h = r + 1.5 * i, d = t.filter((c) => c >= o && c <= h);
  return {
    min: zg(d),
    // Smallest non-outlier value
    max: Em(d),
    // Largest non-outlier value
    median: Gm(t),
    // Median of all values
    firstQuartile: n,
    thirdQuartile: r,
    iqr: i
  };
}, Bw = (e, t, n) => {
  const r = t.series.map((h) => h == null ? void 0 : h.dataKey), i = {}, o = n.filter((h) => h[t.xAxis.dataKey] === e);
  return r.forEach((h) => {
    i[h] = o.map((d) => d[h]);
  }), i;
}, zw = (e, t, n) => {
  const r = n - t, i = t - 1.5 * r, o = n + 1.5 * r;
  return e.filter((h) => h < i || h > o);
}, $w = (e, t, n) => {
  const r = n - t, i = t - 1.5 * r, o = n + 1.5 * r;
  return e.filter((h) => h >= i && h <= o);
}, Hw = (e, t) => {
  const n = e.map((o) => o[t.xAxis.dataKey]), r = [], i = Ke.uniq(n);
  return i && i.length > 0 && i.forEach((o) => {
    const h = Bw(o, t, e), d = {}, c = {}, p = {}, y = {}, g = {}, b = {}, T = {}, m = {};
    Object.keys(h).forEach((C) => {
      const w = h[C], { firstQuartile: S, thirdQuartile: B, min: M, max: D, median: O, iqr: L } = Fw(w);
      d[C] = zw(w, S, B).map(Number), c[C] = $w(w, S, B).map(Number), p[C] = O, y[C] = M, g[C] = D, b[C] = S, T[C] = B, m[C] = L;
    }), r.push({
      columnCategory: o,
      keyValues: h,
      columnOutliers: d,
      columnNonOutliers: c,
      min: y,
      max: g,
      q1: b,
      q3: T,
      median: p,
      iqr: m
    });
  }), r;
}, Vw = ({ xScale: e, yScale: t, seriesScale: n }) => {
  const { config: r, colorScale: i, seriesHighlight: o, transformedData: h } = fe.useContext(ft), { boxplot: d } = r, c = `cdc-open-viz-tooltip-${r.runtime.uniqueId}`, p = e.bandwidth();
  getComputedStyle(document.body);
  const y = zr, g = Math.min(40, p);
  Ke.get(_r, [r.palette, 0], "#000");
  const b = Hw(h, r);
  return /* @__PURE__ */ a(Xr, { component: "BoxPlot", children: /* @__PURE__ */ a(qe, { left: Number(r.yAxis.size), className: "boxplot", children: b.map((T, m) => {
    const C = p - g, w = 4;
    return /* @__PURE__ */ a(
      qe,
      {
        left: e(T.columnCategory) + (e.bandwidth() - n.bandwidth()) / 2,
        children: r.series.map((S, B) => {
          const M = r.legend.behavior === "highlight" && o.length > 0 && o.indexOf(S.dataKey) === -1, D = r.legend.behavior === "highlight" || o.length === 0 || o.indexOf(S.dataKey) !== -1, O = M ? 0.3 : 0.5;
          return /* @__PURE__ */ F(qe, { children: [
            d.plotNonOutlierValues && T.columnNonOutliers[S.dataKey].map((L, U) => /* @__PURE__ */ a(
              "circle",
              {
                display: D ? "block" : "none",
                cx: n(S.dataKey) + n.bandwidth() / 2,
                cy: t(L),
                r: w,
                opacity: O,
                fill: y,
                style: { stroke: y }
              },
              `boxplot-${m}--circle-${U}`
            )),
            D && /* @__PURE__ */ a(
              gg,
              {
                display: D ? "block" : "none",
                "data-left": e(T.columnCategory) + r.yAxis.size + C / 2 + 0.5,
                min: Number(T.min[S.dataKey]),
                max: Number(T.max[S.dataKey]),
                left: n(S.dataKey),
                firstQuartile: T.q1[S.dataKey],
                thirdQuartile: T.q3[S.dataKey],
                median: T.median[S.dataKey],
                boxWidth: n.bandwidth(),
                fill: i(S.dataKey),
                fillOpacity: 1,
                stroke: y,
                valueScale: t,
                outliers: d.plotOutlierValues ? Ke.map(T.columnOutliers[S.dataKey], (L) => L) : [],
                outlierProps: {
                  style: {
                    fill: y,
                    opacity: O,
                    stroke: y
                  }
                },
                medianProps: {
                  style: {
                    opacity: O,
                    stroke: y
                  }
                },
                boxProps: {
                  style: {
                    stroke: y,
                    strokeWidth: d.borders === "true" ? 1.5 : 0,
                    opacity: O
                  }
                },
                maxProps: {
                  style: {
                    opacity: O,
                    stroke: y
                  }
                },
                container: !0,
                containerProps: {
                  "data-tooltip-html": Iw(
                    d,
                    T.columnCategory,
                    S.dataKey,
                    Ke.round(T.q1[S.dataKey], r.dataFormat.roundTo),
                    Ke.round(T.q3[S.dataKey], r.dataFormat.roundTo),
                    Ke.round(T.median[S.dataKey], r.dataFormat.roundTo),
                    Ke.round(T.iqr[S.dataKey], r.dataFormat.roundTo),
                    r.xAxis.label,
                    y
                  ),
                  "data-tooltip-id": c,
                  tabIndex: -1
                }
              },
              `box-plot-${m}-${S}`
            )
          ] }, `boxplotplot-${S.dataKey}-${B}`);
        })
      },
      `boxplotplot-${T.columnCategory}`
    );
  }) }, "boxplot-group") });
}, Ww = ({ xScale: e, yScale: t }) => {
  const {
    transformedData: n,
    config: r,
    tableData: i,
    formatNumber: o,
    seriesHighlight: h,
    colorPalettes: d
  } = fe.useContext(ft), c = 4.5, p = Object.keys(r.runtime.seriesLabels).length > 1, y = Object.entries(r.columns).filter(([b, T]) => T.tooltips).map(([b, T]) => [
    T.label || T.name,
    T.name,
    {
      addColPrefix: T.prefix,
      addColSuffix: T.suffix,
      addColRoundTo: T.roundToPlace,
      addColCommas: T.commas
    }
  ]), g = (b, T, m) => `<div>
    ${r.legend.showLegendValuesTooltip && r.runtime.seriesLabels && p ? `${r.runtime.seriesLabels[T] || ""}<br/>` : ""}
    ${r.xAxis.label}: ${o(b[r.xAxis.dataKey], "bottom")} <br/>
    ${r.yAxis.label}: ${o(b[T], "left")}<br/>
   ${y.map(
    ([C, w, S]) => `${C} : ${Jh(i[m][w], "left", !1, r, S)}<br/>`
  ).join("")}
</div>`;
  return /* @__PURE__ */ a(qe, { className: "scatter-plot", left: r.yAxis.size, children: n.map((b, T) => r.runtime.seriesKeys.map((m, C) => {
    const w = r.legend.behavior === "highlight" && h.length > 0 && h.indexOf(m) === -1, S = r.legend.behavior === "highlight" || h.length === 0 || h.indexOf(m) !== -1, B = r != null && r.customColors ? r.customColors[C] : r.palette ? d[r.palette][C] : "#000";
    let M = {
      filter: "unset",
      opacity: 1,
      stroke: S ? "black" : ""
    };
    return /* @__PURE__ */ a(
      "circle",
      {
        r: c,
        cx: e(b[r.xAxis.dataKey]),
        cy: t(b[m]),
        fill: S ? B : "transparent",
        fillOpacity: w ? 0.25 : 1,
        style: M,
        "data-tooltip-html": g(b, m, T),
        "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
        tabIndex: -1
      },
      `${T}-${C}`
    );
  })) });
};
function jw({ height: e, xScale: t }) {
  const {
    transformedData: n,
    config: r,
    formatNumber: i,
    twoColorPalette: o,
    updateConfig: h,
    parseDate: d,
    formatDate: c,
    currentViewport: p
  } = fe.useContext(ft), { barStyle: y, tipRounding: g, roundingStyle: b, twoColor: T } = r, m = fe.useRef([]), [C, w] = fe.useState(window.innerWidth), S = b === "standard" ? "8px" : b === "shallow" ? "5px" : b === "finger" ? "15px" : "0px";
  r.barStyle;
  const B = Number(r.xAxis.target), M = r.series[0].dataKey, D = Number(t.domain()[1]), L = n.some((ie) => ie[M] < 0) || B > 0 || t.domain()[0] < 0, U = r.barHasBorder === "true" ? 1 : 0, X = r.lollipopSize === "large" ? 7 : r.lollipopSize === "medium" ? 6 : 5, ne = r.lollipopSize === "large" ? 14 : r.lollipopSize === "medium" ? 12 : 10, G = Math.max(t(0), Math.min(t(B), t(D))), ce = (ie) => {
    if (ie == null || y !== "rounded")
      return;
    let le = {};
    return ie === "left" && (le = { borderRadius: `${S} 0 0 ${S}` }), ie === "right" && (le = { borderRadius: `0 ${S} ${S} 0` }), g === "full" && (le = { borderRadius: S }), le;
  }, q = {
    calculate: function() {
      const le = n[0][M] < B ? "left" : "right", J = `${r.xAxis.targetLabel} ${i(r.xAxis.target || 0, "left")}`, de = mr(J, "bold 20px sans-serif");
      let ae = r.isLollipopChart ? X / 2 : Number(r.barHeight) / 2, Z = 0, ye = 0, ue = !1;
      le === "right" && (Z = -10, ue = de - Z < G, ye = G - de), le === "left" && (Z = 10, ue = t(D) - G > de + Z, ye = G), this.text = J, this.y = ae, this.x = ye, this.padding = Z, this.showLabel = r.xAxis.showTargetLabel ? ue : !1;
    }
  };
  q.calculate();
  const re = fe.useRef(null), $ = Pf(re, {});
  fe.useEffect(() => {
    const ie = () => {
      var le;
      w(window.innerWidth), (le = m.current) == null || le.forEach((J) => {
        !J || !J.style || (J.style.transition = "none", J.style.transform = "translate(0) scale(1)");
      });
    };
    return window.addEventListener("resize", ie), () => {
      window.removeEventListener("resize", ie);
    };
  }, []);
  const [j, oe] = fe.useState(!1);
  return fe.useEffect(() => {
    $ != null && $.isIntersecting && setTimeout(() => {
      oe(!0);
    }, 100);
  }, [$ == null ? void 0 : $.isIntersecting, r.animate]), fe.useEffect(() => {
    var ie;
    (ie = m.current) == null || ie.forEach((le, J) => {
      if (!(!le || !le.style)) {
        if (r.animate) {
          const de = B / D * 100;
          le.style.opacity = "0", le.style.transform = `translate(${de / 1.07}%) scale(0, 1)`, setTimeout(() => {
            le.style.opacity = "1", le.style.transform = "translate(0) scale(1)", le.style.transition = "transform 0.5s ease";
          }, 100);
        } else
          le.style.transition = "none", le.style.opacity = "0";
        r.animate || (le.style.transition = "none", le.style.opacity = "1");
      }
    });
  }, [r.animate, r, j]), /* @__PURE__ */ F(Xr, { component: "Deviation Bar", children: [
    /* @__PURE__ */ F(qe, { left: Number(r.xAxis.size), children: [
      n.map((ie, le) => {
        const J = Number(ie[M]), de = r.isLollipopChart ? X : Number(r.barHeight), ae = Number(r.barSpace), Z = Math.abs(t(J) - G), ye = t(J), ue = J > B ? G : ye, ve = J < B ? "left" : "right";
        let ke = 0;
        ke = le !== 0 ? (ae + de + U) * le : ke;
        const me = (ae + de + U) * n.length;
        r.heights.horizontal = me;
        const Ee = mr(i(J, "left"), "normal 16px sans-serif") < Z - 6, De = ye, Xe = ke + de / 2, Fe = ye, Je = ke + de / 2, gt = ye, mt = ke - de / 2, yt = ce(ve), [Ye, ot] = o[T.palette], ut = { left: Ye, right: ot }, st = as(zr, ut[ve]);
        let tt = Uw(r.isLollipopChart, Ee, ne, st);
        const $e = i(J, "left"), it = r.runtime.yAxis.type === "date" ? c(d(n[le][r.runtime.originalXAxis.dataKey])) : n[le][r.runtime.originalXAxis.dataKey];
        let ht = r.runtime.yAxis.label ? `${r.runtime.yAxis.label}: ${it}` : it, Ce = r.runtime.xAxis.label ? `${r.runtime.xAxis.label}: ${$e}` : $e;
        const Ht = `<div>
          ${ht}<br />
          ${Ce}
            </div>`;
        return /* @__PURE__ */ F(qe, { children: [
          /* @__PURE__ */ a(
            "foreignObject",
            {
              ref: (vn) => {
                m.current[le] = vn;
              },
              x: ue,
              y: ke,
              width: Z,
              height: de,
              "data-tooltip-html": Ht,
              "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
              tabIndex: -1,
              children: /* @__PURE__ */ a(
                "div",
                {
                  style: {
                    width: Z,
                    height: de,
                    border: `${U}px solid #333`,
                    backgroundColor: ut[ve],
                    ...yt
                  }
                }
              )
            }
          ),
          r.yAxis.displayNumbersOnBar && /* @__PURE__ */ a(dt, { verticalAnchor: "middle", x: De, y: Xe, ...tt[ve], children: i(ie[M], "left") }),
          r.isLollipopChart && r.lollipopShape === "circle" && /* @__PURE__ */ a(
            "circle",
            {
              cx: Fe,
              cy: Je,
              r: ne / 2,
              fill: ut[ve],
              style: { filter: "unset", opacity: 1 }
            }
          ),
          r.isLollipopChart && r.lollipopShape === "square" && /* @__PURE__ */ a(
            "rect",
            {
              x: gt,
              y: mt,
              width: ne,
              height: ne,
              fill: ut[ve],
              style: { opacity: 1, filter: "unset" }
            }
          )
        ] }, `deviation-bar-${r.orientation}-${M}-${le}`);
      }),
      q.showLabel && /* @__PURE__ */ a(dt, { fontWeight: "bold", dx: q.padding, verticalAnchor: "middle", x: q.x, y: q.y, children: q.text }),
      L && /* @__PURE__ */ a(an, { from: { x: G, y: 0 }, to: { x: G, y: e }, stroke: "#333", strokeWidth: 2 })
    ] }),
    /* @__PURE__ */ a("foreignObject", { y: e / 2, ref: re })
  ] });
}
function Uw(e, t, n, r) {
  return e ? {
    right: {
      textAnchor: "start",
      dx: n + 6,
      fill: "#000000"
    },
    left: {
      textAnchor: "end",
      dx: -n,
      fill: "#000000"
    }
  } : {
    right: {
      textAnchor: t ? "end" : "start",
      dx: t ? -6 : 6,
      fill: t ? r : "#000000"
    },
    left: {
      textAnchor: t ? "start" : "end",
      dx: t ? 6 : -6,
      fill: t ? r : "#000000"
    }
  };
}
const Kw = ({ xScale: e, yScale: t, height: n, width: r, handleTooltipMouseOver: i, handleTooltipMouseOff: o }) => {
  var m;
  const { transformedData: h, rawData: d, config: c, seriesHighlight: p } = fe.useContext(ft), { xAxis: y, yAxis: g, legend: b, runtime: T } = c;
  return h && /* @__PURE__ */ a(Xr, { component: "ForecastingChart", children: /* @__PURE__ */ F(qe, { className: "forecasting-items", left: Number(g.size), children: [
    (m = T.forecastingSeriesKeys) == null ? void 0 : m.map((C, w) => !C || !C.stages ? !1 : C.stages.map((S, B) => {
      var U;
      const { behavior: M } = b, D = d.filter((X) => X[C.stageColumn] === S.key);
      let O = M === "highlight" && p.length > 0 && p.indexOf(S.key) === -1, L = M === "highlight" || p.length === 0 || p.indexOf(S.key) !== -1;
      return /* @__PURE__ */ a(qe, { className: `forecasting-areas-combo-${w}`, children: (U = C.confidenceIntervals) == null ? void 0 : U.map((X, ne) => {
        const G = oc[S.color] || _r[S.color] || !1, ce = () => L && G[2] ? G[2] : "transparent", q = () => L && G[1] ? G[1] : "transparent";
        if (!(X.high === "" || X.low === ""))
          return /* @__PURE__ */ F(qe, { children: [
            /* @__PURE__ */ a(
              O0,
              {
                curve: ec,
                data: D,
                fill: ce(),
                opacity: O ? 0.1 : 0.5,
                x: (re) => e(Date.parse(re[y.dataKey])),
                y0: (re) => t(re[X.low]),
                y1: (re) => t(re[X.high])
              }
            ),
            ne === 0 && /* @__PURE__ */ F(Be, { children: [
              /* @__PURE__ */ a(Gr, { data: D, x: (re) => Number(e(Date.parse(re[y.dataKey]))), y: (re) => Number(t(re[X.high])), curve: ec, stroke: q(), strokeWidth: 1, strokeOpacity: 1 }),
              /* @__PURE__ */ a(Gr, { data: D, x: (re) => Number(e(Date.parse(re[y.dataKey]))), y: (re) => Number(t(re[X.low])), curve: ec, stroke: q(), strokeWidth: 1, strokeOpacity: 1 })
            ] })
          ] }, `forecasting-areas--stage-${S.key.replaceAll(" ", "-")}--group-${B}-${ne}`);
      }) }, `forecasting-areas--stage-${S.key.replaceAll(" ", "-")}-${w}`);
    })),
    /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ a(Pr, { width: Number(r), height: Number(n), fill: "transparent", fillOpacity: 0.05, onMouseMove: (C) => i(C, h), onMouseOut: o }, "bars") }, "tooltip-hover-section")
  ] }, "forecasting-items-wrapper") });
};
function qc(e, t) {
  const n = e.series.every(({ type: T }) => T === "Bar"), r = e.series.every(({ type: T }) => ["Line", "dashed-sm", "dashed-md", "dashed-lg"].includes(T)), i = (T) => (m) => T.reduce((C, w) => isNaN(Number(m[w])) ? C : C + Number(m[w]), 0), o = (T) => {
    const m = e.runtime.series.find((C) => C.dataKey === T);
    return m != null && m.dynamicCategory ? m.originalDataKey : T;
  }, h = () => {
    let T = Math.max(
      ...t == null ? void 0 : t.map(
        (m) => Math.max(
          ...e.runtime.seriesKeys.map((C) => {
            const w = o(C);
            return Wa(m[w]) ? Number(p(m[w])) : 0;
          })
        )
      )
    );
    if ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && n) && e.visualizationSubType === "stacked") {
      const m = t.map(i(e.runtime.seriesKeys)).filter((C) => !isNaN(C));
      T = Math.max(...m);
    }
    if (e.visualizationSubType === "stacked" && e.visualizationType === "Area Chart") {
      const m = t.map(i(e.runtime.seriesKeys));
      T = Math.max(...m);
    }
    if ((e.visualizationType === "Bar" || e.visualizationType === "Deviation Bar") && e.series && e.series.dataKey && (T = Math.max(
      ...t.map((m) => Wa(m[e.series.dataKey]) ? Number(p(m[e.series.dataKey])) : 0)
    )), e.visualizationType === "Combo" && e.visualizationSubType === "stacked" && !n && e.runtime.barSeriesKeys && e.runtime.lineSeriesKeys) {
      const m = t.map(i(e.runtime.barSeriesKeys)), C = Math.max(
        ...t.map((S) => Math.max(...e.runtime.lineSeriesKeys.map((B) => Number(p(S[B])))))
      ), w = Math.max(...m);
      T = Math.max(w, C);
    }
    return T;
  }, d = () => {
    const T = Math.min(
      ...t.map(
        (m) => Math.min(
          ...e.runtime.seriesKeys.map((C) => {
            const w = o(C);
            return Wa(m[w]) ? Number(p(m[w])) : 1 / 0;
          })
        )
      )
    );
    return String(T);
  }, c = () => e.runtime.seriesKeys ? e.runtime.seriesKeys.some((T) => t.some((m) => m[o(T)] >= 0)) : !1, p = (T) => T === null || T === "" ? "" : typeof T == "string" ? T.replace(/[,$]/g, "") : T, y = Number(h()), g = Number(d()), b = c();
  return { minValue: g, maxValue: y, existPositiveValue: b, isAllLine: r };
}
const jr = {
  TIME: "time",
  LOG: "log",
  POINT: "point",
  LINEAR: "linear",
  BAND: "band"
}, vg = 10, Gw = (e) => {
  let { xAxisDataMapped: t, xMax: n, yMax: r, min: i, max: o, config: h, data: d } = e;
  const { rawData: c, dimensions: p } = fe.useContext(ft), [y] = p, g = h.runtime.barSeriesKeys || h.runtime.seriesKeys, b = h.runtime.xAxis.type, T = h.orientation === "horizontal", { visualizationType: m, xAxis: C, forestPlot: w } = h;
  let S = null, B = null, M = null, D = null, O = null, L = null, U = zn({
    domain: [0, 100],
    range: [0, n]
  });
  if (T && (S = Qw({ min: i * 1.03, ...e }), S.type = h.yAxis.type === "logarithmic" ? jr.LOG : jr.LINEAR, B = ek(b, t), B.rangeRound([0, r]), O = tk(g, [0, r])), T || (S = Zo(t, [0, n], 1 - h.barThickness), B = Jw(e), O = Zo(g, [0, S.bandwidth()], 0)), h.xAxis.type === "date" && !T) {
    const X = bm(t, h.xAxis.sortByRecentDate);
    S = Zo(X, [0, n], 1 - h.barThickness);
  }
  if (C.type === "date-time" || C.type === "continuous") {
    let X = Math.min(...t.map(Number)), ne = Math.max(...t.map(Number));
    X -= (h.xAxis.padding ? h.xAxis.padding * 0.01 : 0) * (ne - X), ne += m === "Line" ? 0 : (h.xAxis.padding ? h.xAxis.padding * 0.01 : 0) * (ne - X);
    const G = h.xAxis.sortByRecentDate ? [n, 0] : [0, n];
    S = TS({
      domain: [X, ne],
      range: G
    }), S.type = jr.TIME;
    let ce = Number.MAX_VALUE, q = bm(t, h.xAxis.sortByRecentDate);
    for (let re = 0; re < q.length - 1; re++) {
      let $ = S(q[re + 1]) - S(q[re]);
      $ < ce && (ce = $);
    }
    (t.length === 1 || ce > n / 4) && (ce = n / 4), O = Zo(g, [0, (h.barThickness || 1) * ce], 0);
  }
  if (h.visualizationType === "Deviation Bar") {
    const X = h.isLollipopChart ? 1.05 : 1.03;
    B = wc({
      domain: t,
      range: [0, r]
    }), S = zn({
      domain: [i * X, Math.max(Number(C.target), o)],
      range: [0, n],
      round: !0,
      nice: !0
    }), S.type = jr.LINEAR;
  }
  if (h.visualizationType === "Scatter Plot") {
    if (C.type === "continuous") {
      let X = C.min ? C.min : Math.min.apply(null, S.domain()), ne = C.max ? C.max : Math.max.apply(null, S.domain());
      S = zn({
        domain: [X, ne],
        range: [0, n]
      }), S.type = jr.LINEAR;
    }
    C.type === "categorical" && (S = Zo(t, [0, n], 1), S.type = jr.BAND);
  }
  if (m === "Box Plot") {
    const X = [];
    if (h.boxplot.plots.map((j) => j.columnOutliers.map((oe) => X.push(oe))) && !h.boxplot.hideOutliers) {
      let j = Math.min(...X), oe = Math.max(...X);
      j < i && (i = j), oe > o && (o = oe);
    }
    let G = Math.min(...h.boxplot.plots.map((j) => j.columnLowerBounds)), ce = Math.max(...h.boxplot.plots.map((j) => j.columnUpperBounds));
    G < i && (i = G), ce > o && (o = ce);
    const q = Ke.uniq(d.map((j) => j[h.xAxis.dataKey])), re = [0, h.barThickness * 100 || 1], $ = Ke.map(h.series, "dataKey");
    B = zn({
      range: [r, 0],
      round: !0,
      domain: [i, o]
    }), S = wc({
      range: [0, n],
      domain: q
    }), S.type = jr.BAND, O = Zo($, re);
  }
  if (m === "Paired Bar") {
    let ne = Math.max.apply(
      Math,
      d.map((ce) => {
        var q;
        return ce[(q = h.series[0]) == null ? void 0 : q.dataKey];
      })
    ), G = Math.max.apply(
      Math,
      d.map((ce) => {
        var q;
        return ce[(q = h.series[1]) == null ? void 0 : q.dataKey];
      })
    );
    D = zn({
      domain: [0, Math.max(ne, G) * 1.02],
      range: [n / 2, 0]
    }), M = zn({
      domain: D.domain(),
      range: [n / 2, n],
      nice: !0
    });
  }
  if (m === "Forest Plot") {
    const X = () => w.regression.showDiamond || w.regression.description ? [0 + w.rowHeight * 2, r - w.rowHeight] : [0 + w.rowHeight * 2, r];
    B = zn({
      domain: [0, c.length],
      range: X()
    });
    const ne = 5, G = Number(w.leftWidthOffset) / 100 * n, ce = Number(w.rightWidthOffset) / 100 * n, q = Number(w.rightWidthOffsetMobile) / 100 * n, re = Number(w.leftWidthOffsetMobile) / 100 * n;
    if (y > 480) {
      if (w.type === "Linear" && (S = zn({
        domain: [
          Math.min(...d.map(($) => parseFloat($[w.lower]))) - ne,
          Math.max(...d.map(($) => parseFloat($[w.upper]))) + ne
        ],
        range: [G, Number(y) - ce]
      }), S.type = jr.LINEAR), w.type === "Logarithmic") {
        let $ = Math.max(...d.map((oe) => parseFloat(oe[w.upper]))), j = Math.min(...d.map((oe) => parseFloat(oe[w.lower])));
        S = kc({
          domain: [j, $],
          range: [G, n - ce],
          nice: !0
        }), S.type = jr.LOG;
      }
    } else if (w.type === "Linear" && (S = zn({
      domain: [
        Math.min(...d.map(($) => parseFloat($[w.lower]))) - ne,
        Math.max(...d.map(($) => parseFloat($[w.upper]))) + ne
      ],
      range: [re, n - q],
      type: jr.LINEAR
    })), w.type === "Logarithmic") {
      let $ = Math.max(...d.map((oe) => parseFloat(oe[w.upper]))), j = Math.min(...d.map((oe) => parseFloat(oe[w.lower])));
      S = kc({
        domain: [j, $],
        range: [G, n - ce],
        nice: !0,
        base: $ > 1 ? 10 : 2,
        round: !1,
        type: jr.LOG
      });
    }
  }
  return { xScale: S, yScale: B, seriesScale: O, g1xScale: D, g2xScale: M, xScaleNoPadding: L, xScaleAnnotation: U };
}, Yw = (e) => {
  const t = new Date(e);
  return new Date(t.getFullYear(), t.getMonth(), 1).getTime();
}, Xw = (e) => (e.includes("%b") || e.includes("%B") || e.includes("%m") || e.includes("%-m") || e.includes("%_m")) && !e.includes("%d") && !e.includes("%-d") && !e.includes("%_d") && !e.includes("%e"), qw = (e, t, n, r) => {
  const i = t.domain();
  if (t.type === "time") {
    const o = e[e.length - 1], h = e[0], d = (o - h) / (n - 1);
    let c = [];
    for (let p = o; p >= h; p -= d)
      c.push(p);
    return c[c.length - 1] !== h && c.push(h), c.reverse(), Xw(r.xAxis.dateDisplayFormat) && (c = c.map((p) => Yw(p))), c;
  }
  if (i.length > 2) {
    const o = n || 1, h = [];
    for (let d = i.length; d > 0; d -= o) {
      const c = Math.max(Math.round(d) - 1, 0);
      h.push(i[c]);
    }
    return h.reverse(), h;
  }
}, Zw = (e, t, n, r) => {
  let i = t.ticks;
  const o = pg(t.scale, t.numTicks);
  if (o.length < n.length) {
    let h = 0;
    const d = n.indexOf(o[o.length - 1]);
    d < n.length - 1 && (h = e.xAxis.sortByRecentDate ? n.indexOf(o[0]) * -1 : n.length - 1 - d), i = o.map((c) => t.ticks[t.ticks.findIndex((p) => p.value === c) + h]);
  }
  return i.forEach((h, d) => {
    h.formattedValue = r(h.value, d, i);
  }), i;
}, Qw = ({ min: e, max: t, xMax: n, config: r }) => {
  const i = r.yAxis.type === "logarithmic";
  return e = i && e >= 0 && e < 1 ? e + 0.1 : e, (i ? kc : zn)({
    domain: [e, t],
    range: [0, n],
    nice: i,
    zero: i
  });
}, Jw = ({ min: e, max: t, yMax: n, config: r, leftMax: i }) => {
  const o = r.yAxis.type === "logarithmic";
  e = o && e >= 0 && e < 1 ? e + 0.1 : e;
  const h = o ? kc : zn;
  r.visualizationType === "Combo" && (t = i);
  const d = r.visualizationType === "Bump Chart" ? [1, t] : [e, t], c = r.visualizationType === "Bump Chart" ? [30, n] : [n, vg];
  return h({
    domain: d,
    range: c,
    nice: o,
    zero: o
  });
}, ek = (e, t) => e === "date" ? zn({
  domain: [Math.min(...t), Math.max(...t)]
}) : ts({ domain: t, padding: 0.5 }), tk = (e, t, n = 0) => ts({
  domain: e,
  range: t,
  padding: n
}), Zo = (e, t, n = 0) => wc({
  domain: e,
  range: t,
  padding: n
}), bm = (e, t) => !e || e.length === 0 ? [] : e.length === 1 ? e : t ? e.sort((n, r) => Number(r) - Number(n)) : e.sort((n, r) => Number(n) - Number(r));
function Mf({ config: e, yMax: t = 0, data: n = [], updateConfig: r }) {
  var b, T, m, C;
  const i = e.visualizationType === "Combo" && e.orientation === "vertical", o = e.series && e.series.filter((w) => w.axis === "Right").map((w) => w.dataKey);
  let { minValue: h } = qc(e, n);
  const d = (w) => {
    if (!w)
      return [0];
    let S = [];
    return w.map((B, M) => S = [...S, ...n.map((D) => Number(D[B]))]), S;
  };
  let c = Math.max.apply(null, d(o));
  e.yAxis.rightMax > c && (c = e.yAxis.rightMax), e.yAxis.rightMin < h && (h = e.yAxis.rightMin);
  const p = ((T = (b = e.runtime) == null ? void 0 : b.barSeriesKeys) == null ? void 0 : T.length) > 0, y = ((C = (m = e.runtime) == null ? void 0 : m.lineSeriesKeys) == null ? void 0 : C.length) > 0;
  return (p || y) && h > 0 && (h = 0), { yScaleRight: zn({
    domain: [h, c],
    range: [t, vg]
  }), hasRightAxis: i };
}
const nk = (e) => {
  const { preliminaryData: t, data: n, stroke: r, strokeWidth: i, handleLineType: o, lineType: h, seriesKey: d } = e, c = t.filter(
    (b) => b.seriesKey && b.column && b.value && b.type && b.style && b.type === "effect"
  ), p = (b) => c.find(
    (T) => T.seriesKey === d && b[T.column] === T.value && T.type === "effect" && T.style !== "Open Circles"
  );
  let y = [];
  const g = (b) => ({
    stroke: r,
    strokeWidth: i,
    strokeDasharray: b
  });
  return n.forEach((b, T) => {
    let m = p(b), C = g(o(m ? m.style : h));
    y.push(C), m && T > 0 && (y[T - 1] = g(o(m.style)));
  }), y;
}, Pc = (e) => !isNaN(parseFloat(e)) && isFinite(e), rk = (e, t, n) => {
  let r = "0";
  const i = {
    data: { 0: [] },
    style: ""
  };
  if (!e.length)
    return i;
  const o = e[0], h = (c) => {
    if (!(c.type === "effect" || c.hideLineStyle))
      return c.type == "suppression" && c.value === o[t] && (!c.column || c.column === t);
  }, d = n.find(h);
  if (d && d.style) {
    const c = { ...o, [t]: 0 };
    i.data[r].push(c), i.style = d.style;
    let p = 1;
    for (; p < e.length && !Pc(e[p][t]); )
      p++;
    p < e.length && i.data[r].push(e[p]);
  } else
    i.data[r].push(o);
  return i;
}, ik = (e, t, n) => {
  let r = "0";
  const i = {
    data: { 0: [] },
    style: ""
  };
  let o = -1;
  return n == null || n.forEach((h) => {
    if (h.type !== "effect" && e[e.length - 1][t] === h.value && h.style && (!h.column || h.column === t) && h.type == "suppression" && !h.hideLineStyle) {
      const d = e.length - 1, c = { ...e[d], [t]: 0 };
      i.data[r].push(c);
      let p = d - 1;
      for (; p >= 0 && !Pc(e[p][t]); )
        p--;
      p >= 0 && o !== p && (i.data[r].push(e[p]), o = p), i.style = h.style;
    }
  }), i;
};
function ak(e, t, n) {
  let r = {
    data: {},
    style: ""
  }, i = 1;
  return e.forEach((o, h) => {
    n.forEach((d) => {
      const c = d.value;
      if (o[t] === c) {
        let p = null, y = null;
        for (let g = h - 1; g >= 0; g--)
          if (Pc(e[g][t])) {
            p = e[g];
            break;
          }
        for (let g = h + 1; g < e.length; g++)
          if (Pc(e[g][t])) {
            y = e[g];
            break;
          }
        p && y && (r.style = d.style, r.data[i++] = [p, y]);
      }
    });
  }), r;
}
const ok = (e, t, n, r) => {
  const i = rk(e, t, n), o = ik(e, t, n), h = ak(e, t, n);
  return [i, h, o];
};
var sk = ["children", "className", "top", "left", "size"];
function Yh() {
  return Yh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Yh.apply(this, arguments);
}
function lk(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function If(e) {
  var t = e.children, n = e.className, r = e.top, i = e.left, o = e.size, h = lk(e, sk), d = $g();
  return d.type(qx), (typeof o == "number" || o) && d.size(o), t ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, t({
    path: d
  })) : /* @__PURE__ */ Ie.createElement(Qh, {
    top: r,
    left: i
  }, /* @__PURE__ */ Ie.createElement("path", Yh({
    className: Sn("visx-glyph-cross", n),
    d: d() || ""
  }, h)));
}
If.propTypes = {
  children: Re.func,
  className: Re.string,
  top: Re.number,
  left: Re.number,
  size: Re.oneOfType([Re.number, Re.func])
};
const uk = [
  _m,
  Pm,
  ac,
  Nm,
  ac,
  If,
  ({ fill: e }) => /* @__PURE__ */ a(Qh, { children: /* @__PURE__ */ a(dt, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle", children: "⬟" }) })
], Gu = (e) => {
  var re, $;
  const {
    config: t,
    d: n,
    displayArea: r,
    seriesKey: i,
    xScale: o,
    yScale: h,
    colorScale: d,
    parseDate: c,
    yScaleRight: p,
    data: y,
    tooltipPoint: g,
    dataIndex: b,
    mode: T,
    seriesIndex: m,
    handleTooltipMouseOver: C,
    handleTooltipMouseOff: w
  } = e, { isolatedDotsSameSize: S, lineDatapointStyle: B, visual: M } = t, D = (re = t == null ? void 0 : t.series.filter((j) => j.dataKey === i)) == null ? void 0 : re[0], O = uk[t.visual.lineDatapointSymbol === "standard" && m < M.maximumShapeAmount ? m : 0], L = m === 4, ne = S ? 55 : 124, G = (j) => (t.xAxis.type === "categorical" ? o(j) : o(c(j))) + (o.bandwidth ? o.bandwidth() / 2 : 0), ce = (j, oe) => {
    const ie = G(j), le = (D == null ? void 0 : D.axis) === "Right" ? p(oe) : h(oe);
    return `translate(${ie}, ${le})${L ? " rotate(180)" : ""}`;
  }, q = (j, oe, ie, le) => {
    const J = ie.runtime.seriesLabels || [], de = ie.runtime.seriesLabelsAll || [];
    let ae = j ? oe(J[le] || de[m]) : "transparent";
    return ie.lineDatapointColor === "Lighter than Line" && ae !== "transparent" && ae && (ae = Qi(ae).brighten(1)), ae;
  };
  if (["ALWAYS_SHOW_POINTS", "HOVER_POINTS"].includes(T))
    return !D || M.maximumShapeAmount === m && M.lineDatapointSymbol === "standard" ? /* @__PURE__ */ a(Be, {}) : /* @__PURE__ */ a(
      "g",
      {
        transform: ce(n[t.xAxis.dataKey], n[D == null ? void 0 : D.dataKey]),
        className: `visx-glyph-group${r ? "" : "-hidden"}`,
        "data-seriesIndex": m,
        children: /* @__PURE__ */ a(
          O,
          {
            fillOpacity: T === "ALWAYS_SHOW_POINTS" ? 1 : 0,
            fill: q(r, d, t, i)
          }
        )
      }
    );
  if (T === "ISOLATED_POINTS") {
    const j = (ie, le) => {
      const J = y[ie], de = y[ie - 1] || {}, ae = y[ie + 1] || {}, Z = ie === 0 && !ae[le], ye = ie === y.length - 1 && !de[le], ue = ie > 0 && ie < y.length - 1 && J[le] && !de[le] && !ae[le];
      return Z || ye || ue;
    }, oe = n ? y.findIndex((ie) => ie[t.xAxis.dataKey] === n[t.xAxis.dataKey]) : b;
    if (j(oe, i)) {
      const ie = d(t.runtime.seriesLabelsAll[m]);
      return /* @__PURE__ */ a(
        "g",
        {
          transform: ce(n[($ = t.xAxis) == null ? void 0 : $.dataKey], n[D == null ? void 0 : D.dataKey]),
          className: `visx-glyph-group${r ? "" : "-hidden"}`,
          "data-seriesIndex": m,
          children: /* @__PURE__ */ a(O, { size: ne, stroke: ie, fill: ie })
        }
      );
    }
  }
  return T === "TOOLTIP_POINTS" && r === !0 ? /* @__PURE__ */ a(
    "g",
    {
      transform: ce(g.xValue, g.yValue),
      className: "visx-glyph-circle",
      onMouseOver: (j) => {
        C(j), B == "hover" && (j.target.style.fillOpacity = "1");
      },
      onMouseOut: (j) => {
        w(), B == "hover" && (j.target.style.fillOpacity = "0");
      },
      children: /* @__PURE__ */ a(O, { size: 55, fill: g.color, fillOpacity: "0" })
    }
  ) : null;
}, ck = (e) => {
  var y, g;
  const { config: t, xScale: n, yScale: r, parseDate: i } = e;
  if (!((y = t == null ? void 0 : t.runtime) != null && y.series))
    return;
  const o = (b) => {
    if (t.xAxis.type === "date")
      return i(b).getTime();
    if (t.xAxis.type === "date-time")
      return new Date(b);
    if (t.xAxis.type === "categorical")
      return b;
  }, h = (b) => n.bandwidth ? n.bandwidth() / 2 + Number(b) : Number(b), d = (b) => {
    var T;
    return (T = Object.values(t.columns)) == null ? void 0 : T.filter((m) => m.tooltips).map((m) => `
        <li className='tooltip-body'>
          <strong>${m.label || m.name}</strong>: ${b[m.name]}
        </li>`).join(" ");
  }, c = (b) => `<ul> ${d(b)} </ul>`, p = (g = t.runtime) == null ? void 0 : g.series.map((b) => t.data.map((T, m) => {
    let C = T[b.dataKey], w = T[t.xAxis.dataKey];
    return /* @__PURE__ */ a(Ie.Fragment, { children: /* @__PURE__ */ a(qe, { left: Number(t.runtime.yAxis.size), children: C && /* @__PURE__ */ F(Be, { children: [
      /* @__PURE__ */ a(
        "circle",
        {
          "data-tooltip-html": c(T),
          "data-tooltip-id": "bump-chart",
          r: 10,
          cx: Number(h(n(o(w)))),
          cy: Number(r(C)),
          stroke: "#CACACA",
          strokeWidth: 1,
          fill: "#E5E4E2"
        },
        `bump-circle-${C}-${m}`
      ),
      C.toString().length === 2 ? (
        // prettier-ignore
        /* @__PURE__ */ a(
          "text",
          {
            x: Number(h(n(o(w)))) - 7,
            y: Number(r(C)) + 4,
            fill: "#000000",
            fontSize: 11.5,
            children: C
          }
        )
      ) : (
        // prettier-ignore
        /* @__PURE__ */ a(
          "text",
          {
            x: Number(h(n(o(w)))) - 4,
            y: Number(r(C)) + 4,
            fill: "#000000",
            fontSize: 11.5,
            children: C
          }
        )
      )
    ] }) }) }, `bump-circle-${C}-${m}`);
  }));
  return /* @__PURE__ */ a(Be, { children: p });
}, xm = (e) => {
  var j;
  const {
    getXAxisData: t,
    getYAxisData: n,
    handleTooltipMouseOff: r,
    handleTooltipMouseOver: i,
    tooltipData: o,
    xMax: h,
    xScale: d,
    yMax: c,
    yScale: p
  } = e, { colorScale: y, config: g, formatNumber: b, handleLineType: T, parseDate: m, seriesHighlight: C, tableData: w, transformedData: S, updateConfig: B, brushConfig: M, clean: D } = fe.useContext(ft), { yScaleRight: O } = Mf({ config: g, yMax: c, data: S, updateConfig: B }), L = g.tooltips.singleSeries, { lineDatapointStyle: U, showLineSeriesLabels: X, legend: ne } = g, G = M.data.length > 0 && ((j = g.brush) == null ? void 0 : j.active), ce = G ? D(M.data) : S, q = G ? D(M.data) : w, re = (oe) => d(t(oe)) + (d.bandwidth ? d.bandwidth() / 2 : 0), $ = [];
  return /* @__PURE__ */ F(Xr, { component: "LineChart", children: [
    /* @__PURE__ */ F(qe, { left: Number(g.runtime.yAxis.size), className: "line-chart-group", children: [
      (g.runtime.lineSeriesKeys || g.runtime.seriesKeys).map((oe, ie) => {
        var ke;
        const le = g.runtime.series.find((me) => me.dataKey === oe), J = le.type, de = le.axis || "left", ae = ne.behavior === "highlight" || C.length === 0 || C.indexOf(oe) !== -1, Z = ok(
          w,
          oe,
          g.preliminaryData,
          g.xAxis.dataKey
        ), ye = ((ke = g == null ? void 0 : g.preliminaryData) == null ? void 0 : ke.filter((me) => me.style && !me.style.includes("Circles")).length) > 0, ue = le.dynamicCategory ? ce.filter((me) => me[le.dynamicCategory] === oe) : ce, ve = le.dynamicCategory ? le.originalDataKey : oe;
        return /* @__PURE__ */ F(
          qe,
          {
            opacity: ne.behavior === "highlight" && C.length > 0 && C.indexOf(oe) === -1 ? 0.5 : 1,
            display: ne.behavior === "highlight" || C.length === 0 && !ne.dynamicLegend || C.indexOf(oe) !== -1 ? "block" : "none",
            children: [
              /* @__PURE__ */ a(
                Pr,
                {
                  width: Number(h),
                  height: Number(c),
                  fill: "transparent",
                  fillOpacity: 0.05
                },
                "bars"
              ),
              ue.map((me, Ne) => ($.push({
                color: y(g.runtime.seriesLabels[oe]),
                seriesKey: ve,
                seriesIndex: ie,
                xValue: me[g.xAxis.dataKey],
                yValue: me[ve]
              }), Wa(me[ve]) && /* @__PURE__ */ F(Ie.Fragment, { children: [
                g.labels && /* @__PURE__ */ a(
                  dt,
                  {
                    x: re(me),
                    y: de === "Right" ? O(n(me, ve)) : p(n(me, ve)),
                    fill: "#000",
                    textAnchor: "middle",
                    children: b(me[ve], "left")
                  }
                ),
                U === "always show" && /* @__PURE__ */ a(
                  Gu,
                  {
                    mode: "ALWAYS_SHOW_POINTS",
                    dataIndex: Ne,
                    tableData: w,
                    data: ue,
                    d: me,
                    config: g,
                    seriesKey: ve,
                    displayArea: ae,
                    tooltipData: o,
                    xScale: d,
                    yScale: p,
                    colorScale: y,
                    parseDate: m,
                    yScaleRight: O,
                    seriesAxis: de,
                    seriesIndex: ie
                  },
                  `line-circle--${Ne}`
                ),
                (U === "hover" || U === "hidden") && /* @__PURE__ */ a(
                  Gu,
                  {
                    mode: "HOVER_POINTS",
                    dataIndex: Ne,
                    tableData: w,
                    data: ue,
                    d: me,
                    config: g,
                    seriesKey: ve,
                    displayArea: ae,
                    xScale: d,
                    yScale: p,
                    colorScale: y,
                    parseDate: m,
                    yScaleRight: O,
                    seriesAxis: de,
                    seriesIndex: ie
                  },
                  `line-hover-circle--${Ne}`
                ),
                /* @__PURE__ */ a(
                  Gu,
                  {
                    mode: "ISOLATED_POINTS",
                    seriesIndex: ie,
                    dataIndex: Ne,
                    tableData: w,
                    data: ue,
                    d: me,
                    config: g,
                    seriesKey: ve,
                    displayArea: ae,
                    xScale: d,
                    yScale: p,
                    colorScale: y,
                    parseDate: m,
                    yScaleRight: O,
                    seriesAxis: de
                  },
                  `isolated-circle-${Ne}`
                )
              ] }, `series-${oe}-point-${Ne}`))),
              ye ? /* @__PURE__ */ F(Be, { children: [
                /* @__PURE__ */ a(
                  ng,
                  {
                    curve: $a[le.lineType],
                    segments: ue.map((me) => [me]),
                    segmentation: "x",
                    x: (me) => re(me),
                    y: (me) => de === "Right" ? O(n(me, ve)) : p(Number(n(me, ve))),
                    styles: nk({
                      preliminaryData: g.preliminaryData,
                      data: q,
                      stroke: y(g.runtime.seriesLabels[oe]),
                      strokeWidth: le.weight || 2,
                      handleLineType: T,
                      lineType: J,
                      seriesKey: oe
                    }),
                    defined: (me, Ne) => me[oe] !== "" && me[oe] !== null && me[oe] !== void 0
                  }
                ),
                Z.map((me, Ne) => Object.entries(me.data).map(([Ee, De]) => {
                  var Xe;
                  return /* @__PURE__ */ a(
                    Gr,
                    {
                      data: De,
                      x: (Fe) => re(Fe),
                      y: (Fe) => de === "Right" ? O(n(Fe, oe)) : p(Number(n(Fe, oe))),
                      stroke: y(g.runtime.seriesLabels[oe]),
                      strokeWidth: ((Xe = le[0]) == null ? void 0 : Xe.weight) || 2,
                      strokeOpacity: 1,
                      shapeRendering: "geometricPrecision",
                      strokeDasharray: T(me.style),
                      defined: (Fe, Je) => Fe[oe] !== "" && Fe[oe] !== null && Fe[oe] !== void 0
                    },
                    Ne
                  );
                }))
              ] }) : /* @__PURE__ */ F(Be, { children: [
                g.confidenceKeys && g.series.map((me, Ne) => me.dynamicCategory ? [...new Set(ce.map((De) => De[me.dynamicCategory]))].map((De, Xe) => {
                  const Fe = ce.filter((Je) => Je[me.dynamicCategory] === De);
                  return /* @__PURE__ */ a(
                    Ih,
                    {
                      className: "confidence-interval",
                      data: Fe,
                      x: (Je) => re(Je),
                      y0: (Je) => p(Je[g.confidenceKeys.lower]),
                      y1: (Je) => p(Je[g.confidenceKeys.upper]),
                      opacity: 0.5,
                      fill: y(De),
                      yScale: p,
                      curve: $a[me.lineType]
                    },
                    `area-closed-${Ne}-${Xe}`
                  );
                }) : /* @__PURE__ */ a(
                  Ih,
                  {
                    data: ce,
                    x: (Ee) => re(Ee),
                    y0: (Ee) => p(Ee[g.confidenceKeys.lower]),
                    y1: (Ee) => p(Ee[g.confidenceKeys.upper]),
                    opacity: 0.5,
                    fill: y(
                      g.runtime.seriesLabels ? g.runtime.seriesLabels[me.dataKey] : me.dataKey
                    ),
                    yScale: p,
                    curve: $a[me.lineType]
                  },
                  `area-closed-${Ne}`
                )),
                /* @__PURE__ */ a(
                  Gr,
                  {
                    curve: $a[le.lineType],
                    data: g.visualizationType == "Bump Chart" ? ue : g.xAxis.type === "date-time" || g.xAxis.type === "date" ? ue.sort((me, Ne) => {
                      let Ee = t(me), De = t(Ne);
                      return Ee < De ? -1 : De < Ee ? 1 : 0;
                    }) : ue,
                    x: (me) => re(me),
                    y: (me) => de === "Right" ? O(n(me, ve)) : p(Number(n(me, ve))),
                    stroke: y(g.runtime.seriesLabels[oe]),
                    strokeWidth: le.weight || 2,
                    strokeOpacity: 1,
                    shapeRendering: "geometricPrecision",
                    strokeDasharray: J ? T(J) : 0,
                    defined: (me, Ne) => me[ve] !== "" && me[ve] !== null && me[ve] !== void 0
                  }
                )
              ] }),
              g.animate && /* @__PURE__ */ a(
                Gr,
                {
                  className: "animation",
                  curve: $a[le.lineType],
                  data: ue,
                  x: (me) => re(me),
                  y: (me) => de === "Right" ? O(n(me, ve)) : p(Number(n(me, ve))),
                  stroke: "#fff",
                  strokeWidth: 3,
                  strokeOpacity: 1,
                  shapeRendering: "geometricPrecision",
                  strokeDasharray: J ? T(J) : 0,
                  defined: (me, Ne) => me[oe] !== "" && me[oe] !== null && me[oe] !== void 0
                }
              ),
              X && (g.runtime.lineSeriesKeys || g.runtime.seriesKeys).map((me) => {
                let Ne;
                for (let Xe = ue.length - 1; Xe >= 0; Xe--)
                  if (ue[Xe][me]) {
                    Ne = ue[Xe];
                    break;
                  }
                if (!Ne || ne.position === "right")
                  return /* @__PURE__ */ a(Be, {});
                let Ee = g.runtime.seriesLabels[me] || me;
                const De = "...";
                return Ee.length > 10 && (Ee = Ee.substring(0, 10) + De), /* @__PURE__ */ a(
                  dt,
                  {
                    display: ne.behavior === "highlight" || C.length === 0 && !ne.dynamicLegend || C.indexOf(me) !== -1 ? "block" : "none",
                    x: re(Ne) + 5,
                    y: p(n(Ne, me)),
                    alignmentBaseline: "middle",
                    fill: y(g.runtime.seriesLabels[me] || me),
                    children: Ee
                  }
                );
              })
            ]
          },
          `series-${oe}-${ie}`
        );
      }),
      g.legend.dynamicLegend && C.length === 0 && /* @__PURE__ */ a(dt, { x: h / 2, y: c / 2, fill: "black", textAnchor: "middle", color: "black", children: g.legend.dynamicLegendChartMessage })
    ] }),
    /* @__PURE__ */ a(qe, { left: Number(g.runtime.yAxis.size), className: "glyph-tooltip-group", children: /* @__PURE__ */ F(qe, { display: "block", children: [
      /* @__PURE__ */ a(
        Pr,
        {
          width: Number(h),
          height: Number(c),
          fill: "transparent",
          fillOpacity: 0.05,
          onMouseMove: (oe) => {
            L || i(oe, w);
          },
          onMouseOut: r
        },
        "tooltip bars"
      ),
      $.map((oe, ie) => {
        const { _data: le, seriesKey: J, seriesIndex: de, color: ae } = oe;
        return /* @__PURE__ */ a(Ie.Fragment, { children: /* @__PURE__ */ a(
          Gu,
          {
            mode: "TOOLTIP_POINTS",
            dataIndex: ie,
            tooltipPoint: oe,
            tableData: w,
            data: le,
            d: oe,
            config: g,
            seriesKey: J,
            displayArea: !0,
            tooltipData: o,
            xScale: d,
            yScale: p,
            colorScale: y,
            parseDate: m,
            yScaleRight: O,
            seriesAxis: "[circle]",
            seriesIndex: de,
            handleTooltipMouseOver: i,
            handleTooltipMouseOff: r
          },
          `line-circle--${ie}`
        ) }, `series-${J}-point-${ie}`);
      })
    ] }, "tooltip-group") }),
    g.visualizationType === "Bump Chart" && /* @__PURE__ */ a(ck, { config: g, xScale: d, yScale: p })
  ] });
}, dk = ({
  xScale: e,
  yScale: t,
  config: n,
  height: r,
  width: i,
  handleTooltipMouseOff: o,
  handleTooltipMouseOver: h,
  forestPlotRightLabelRef: d
}) => {
  const { rawData: c, updateConfig: p } = fe.useContext(ft), { forestPlot: y } = n, g = n.xAxis.tickWidthMax + 10, [b, T] = fe.useState(!1);
  fe.useEffect(() => {
    try {
      const D = ["estimateField", "lower", "upper", "estimateRadius"], O = n, L = 10;
      for (let U = 0; U < L; U++)
        D.forEach((X) => {
          var ne;
          n.forestPlot[X] && n.forestPlot[X] !== ((ne = O.columns[n.forestPlot[`additionalColumn${U}`]]) == null ? void 0 : ne.name) && (delete O.columns[`additionalColumn${U}`], O.columns[n.forestPlot[X]] = {}, O.columns[n.forestPlot[X]].dataKey = O.forestPlot[X], O.columns[n.forestPlot[X]].name = O.forestPlot[X], O.columns[n.forestPlot[X]].dataTable = !0, O.columns[n.forestPlot[X]].tooltips = !0, O.columns[n.forestPlot[X]].label = O.forestPlot[X]);
        });
      n.forestPlot.radius.scalingColumn && (O.columns[n.forestPlot.radius.scalingColumn] = {}, O.columns[n.forestPlot.radius.scalingColumn].dataKey = O.forestPlot.radius.scalingColumn, O.columns[n.forestPlot.radius.scalingColumn].name = O.forestPlot.radius.scalingColumn, O.columns[n.forestPlot.radius.scalingColumn].label = O.forestPlot.radius.scalingColumn, O.columns[n.forestPlot.radius.scalingColumn].dataTable = !0, O.columns[n.forestPlot.radius.scalingColumn].tooltips = !0), O.table.showVertical && (O.table.indexLabel = n.xAxis.dataKey), p(O);
    } catch (D) {
      console.log(D.message);
    }
  }, []), fe.useEffect(() => {
    !b && n.forestPlot.type === "Logarithmic" && (p({
      ...n,
      dataFormat: {
        ...n.dataFormat,
        roundTo: 2
      }
    }), T(!0));
  }, [n.forestPlot.type]);
  const m = n.data.find((D) => D[n.xAxis.dataKey] === n.forestPlot.pooledResult.column), C = m ? [
    { x: e(m[n.forestPlot.lower]), y: r - Number(n.forestPlot.rowHeight) },
    {
      x: e(m[n.forestPlot.estimateField]),
      y: r - y.pooledResult.diamondHeight - Number(n.forestPlot.rowHeight)
    },
    { x: e(m[n.forestPlot.upper]), y: r - Number(n.forestPlot.rowHeight) },
    {
      x: e(m[n.forestPlot.estimateField]),
      y: r + y.pooledResult.diamondHeight - Number(n.forestPlot.rowHeight)
    },
    { x: e(m[n.forestPlot.lower]), y: r - Number(n.forestPlot.rowHeight) }
  ] : [], w = n.forestPlot.rowHeight, S = [
    { x: 0, y: w },
    { x: i, y: w }
  ], B = [
    { x: 0, y: r },
    { x: i, y: r }
  ], M = Object.entries(n.columns).map((D) => D[1]).filter((D) => D.forestPlot === !0);
  return /* @__PURE__ */ F(Be, { children: [
    /* @__PURE__ */ F(qe, { width: i, children: [
      y.title && /* @__PURE__ */ a(
        dt,
        {
          className: "forest-plot--title",
          x: y.type === "Linear" ? e(0) : e(1),
          y: 0,
          textAnchor: "middle",
          verticalAnchor: "start",
          fill: "black",
          children: y.title
        }
      ),
      y.lineOfNoEffect.show && y.type === "Linear" && /* @__PURE__ */ a(
        an,
        {
          from: { x: e(0), y: 0 + w },
          to: { x: e(0), y: r },
          className: "forestplot__line-of-no-effect",
          stroke: y.regression.baseLineColor || "black"
        }
      ),
      y.lineOfNoEffect.show && y.type === "Logarithmic" && /* @__PURE__ */ a(
        an,
        {
          from: { x: e(1), y: 0 + w },
          to: { x: e(1), y: r },
          className: "forestplot__line-of-no-effect",
          stroke: y.regression.baseLineColor || "black"
        }
      ),
      c.map((D, O) => {
        const L = zn({
          domain: c.map((q) => q[y.radius.scalingColumn]),
          range: [y.radius.min, y.radius.max]
        }), U = y.radius.scalingColumn !== "" ? L(c[O][y.radius.scalingColumn]) : 4, X = y.colors.shape ? y.colors.shape : "black", ne = y.colors.line ? y.colors.line : "black", G = 4;
        return D[n.xAxis.dataKey] === y.pooledResult.column ? /* @__PURE__ */ a(
          Gr,
          {
            data: C,
            x: (q) => q.x,
            y: (q) => q.y - Dc / 2,
            stroke: "black",
            strokeWidth: 2,
            fill: "black",
            curve: Ph
          }
        ) : /* @__PURE__ */ F(qe, { children: [
          /* @__PURE__ */ a(
            "path",
            {
              stroke: ne,
              strokeWidth: 1,
              className: "lower-ci",
              d: `
                    M${e(D[y.lower])} ${t(O) - Number(G)}
                    L${e(D[y.lower])} ${t(O) + Number(G)}
                `
            }
          ),
          /* @__PURE__ */ a(
            "path",
            {
              stroke: ne,
              strokeWidth: 1,
              className: "upper-ci",
              d: `
                    M${e(D[y.upper])} ${t(O) - Number(G)}
                    L${e(D[y.upper])} ${t(O) + Number(G)}
                `
            }
          ),
          /* @__PURE__ */ a(
            "line",
            {
              stroke: ne,
              className: `line-${D[n.yAxis.dataKey]}`,
              x1: e(D[y.lower]),
              x2: e(D[y.upper]),
              y1: t(O),
              y2: t(O)
            },
            O
          ),
          y.shape === "circle" && /* @__PURE__ */ a(
            bv,
            {
              className: "forest-plot--circle",
              cx: e(Number(D[y.estimateField])),
              cy: t(O),
              r: y.radius.scalingColumn !== "" ? L(c[O][y.radius.scalingColumn]) : 4,
              fill: X,
              style: { opacity: 1, filter: "unset" }
            }
          ),
          y.shape === "square" && /* @__PURE__ */ a(
            "rect",
            {
              className: "forest-plot--square",
              x: e(Number(D[y.estimateField])),
              y: t(O) - U / 2,
              width: U,
              height: U,
              fill: X,
              style: { opacity: 1, filter: "unset" }
            }
          ),
          y.shape === "text" && /* @__PURE__ */ a(
            dt,
            {
              className: "forest-plot--text",
              x: e(Number(D[y.estimateField])),
              y: t(O),
              textAnchor: "middle",
              verticalAnchor: "middle",
              fill: X,
              children: D[y.estimateField]
            }
          )
        ] });
      }),
      C && y.regression.showDiamond && /* @__PURE__ */ a(
        Gr,
        {
          data: C,
          x: (D) => D.x,
          y: (D) => D.y,
          stroke: "black",
          strokeWidth: 2,
          fill: y.regression.baseLineColor,
          curve: Ph
        }
      ),
      y.regression.description && /* @__PURE__ */ a(
        dt,
        {
          x: 0 - Number(n.xAxis.size),
          width: i,
          y: r - n.forestPlot.rowHeight - Number(y.rowHeight) / 3,
          verticalAnchor: "start",
          textAnchor: "start",
          style: { fontWeight: "bold", fontSize: 12 },
          children: y.regression.description
        }
      ),
      /* @__PURE__ */ a(
        Pr,
        {
          className: "forest-plot-tooltip-area",
          width: i,
          height: r,
          fill: "transparent",
          fillOpacity: 0.5,
          onMouseMove: (D) => h(D, c),
          onMouseOut: o
        },
        "forest-plot-tooltip-area"
      )
    ] }),
    /* @__PURE__ */ a(
      an,
      {
        from: S[0],
        to: S[1],
        style: { stroke: "black", strokeWidth: 2 },
        className: "forestplot__top-line"
      }
    ),
    /* @__PURE__ */ a(
      an,
      {
        from: B[0],
        to: B[1],
        style: { stroke: "black", strokeWidth: 2 },
        className: "forestplot__bottom-line"
      }
    ),
    M.map((D) => c.map((O, L) => /* @__PURE__ */ a(
      dt,
      {
        className: `${O[D.name]}`,
        x: D.forestPlotAlignRight ? i : D.forestPlotStartingPoint,
        y: t(L),
        textAnchor: D.forestPlotAlignRight ? "end" : "start",
        verticalAnchor: "middle",
        fill: "black",
        children: O[D.name]
      }
    ))),
    !y.hideDateCategoryCol && c.map((D, O) => /* @__PURE__ */ a(
      dt,
      {
        className: `${D[n.xAxis.dataKey]}`,
        x: 0,
        y: t(O),
        textAnchor: "start",
        verticalAnchor: "middle",
        fill: "black",
        children: D[n.xAxis.dataKey]
      }
    )),
    !y.hideDateCategoryCol && n.xAxis.dataKey && /* @__PURE__ */ a(dt, { className: n.xAxis.dataKey, x: 0, y: 0, textAnchor: "start", verticalAnchor: "start", fill: "black", children: n.xAxis.dataKey }),
    M.map((D) => /* @__PURE__ */ a(
      dt,
      {
        className: `${D.label}`,
        x: D.forestPlotAlignRight ? i : D.forestPlotStartingPoint,
        y: 0,
        textAnchor: D.forestPlotAlignRight ? "end" : "start",
        verticalAnchor: "start",
        fill: "black",
        children: D.label
      }
    )),
    y.leftLabel && /* @__PURE__ */ a(
      dt,
      {
        className: "forest-plot__left-label",
        x: y.type === "Linear" ? e(0) - 25 : e(1) - 25,
        y: r + g,
        textAnchor: "end",
        verticalAnchor: "start",
        children: y.leftLabel
      }
    ),
    y.rightLabel && /* @__PURE__ */ a(
      dt,
      {
        innerRef: d,
        className: "forest-plot__right-label",
        x: y.type === "Linear" ? e(0) + 25 : e(1) + 25,
        y: r + g,
        textAnchor: "start",
        verticalAnchor: "start",
        children: y.rightLabel
      }
    )
  ] });
}, hk = ({ width: e, height: t, originalWidth: n }) => {
  var S, B, M;
  const { config: r, colorScale: i, transformedData: o, formatNumber: h, seriesHighlight: d } = fe.useContext(ft);
  if (!r || ((S = r == null ? void 0 : r.series) == null ? void 0 : S.length) < 2)
    return;
  const c = r.barHasBorder === "true" ? 1 : 0, p = e / 2, y = 1.02, g = {
    parentKey: (B = r.dataDescription) == null ? void 0 : B.seriesKey,
    dataKey: r.series[0].dataKey,
    dataKeyLabel: r.runtime.seriesLabels[r.series[0].dataKey] || r.series[0].dataKey,
    color: i(r.runtime.seriesLabels[r.series[0].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((D) => D[r.series[0].dataKey])
    ),
    labelColor: ""
  }, b = {
    parentKey: (M = r.dataDescription) == null ? void 0 : M.seriesKey,
    dataKey: r.series[1].dataKey,
    dataKeyLabel: r.runtime.seriesLabels[r.series[1].dataKey] || r.series[1].dataKey,
    color: i(r.runtime.seriesLabels[r.series[1].dataKey]),
    max: Math.max.apply(
      Math,
      o.map((D) => D[r.series[1].dataKey])
    ),
    labelColor: ""
  }, T = zn({
    domain: [0, Math.max(g.max * y, b.max * 1.1)],
    range: [0, p]
  });
  g.labelColor = g.color ? as(zr, g.color) : zr, b.labelColor = b.color ? as(zr, b.color) : zr;
  const m = r.yAxis.label ? `${r.yAxis.label}: ` : "", C = (D) => {
    var O;
    return `<p>
				${(O = r.dataDescription) == null ? void 0 : O.seriesKey}: ${g.dataKeyLabel}<br/>
				${r.xAxis.dataKey}: ${D[r.xAxis.dataKey]}<br/>
				${m}${h(D[g.dataKey], "left")}
			</p>`;
  }, w = (D) => {
    var O;
    return `<p>
				${(O = r.dataDescription) == null ? void 0 : O.seriesKey}: ${b.dataKeyLabel}<br/>
				${r.xAxis.dataKey}: ${D[r.xAxis.dataKey]}<br/>
				${m}${h(D[b.dataKey], "left")}
			</p>`;
  };
  return e > 0 && /* @__PURE__ */ F(Be, { children: [
    /* @__PURE__ */ a("style", { children: `
				#cdc-visualization__paired-bar-chart,
				 #cdc-visualization__paired-bar-chart > .visx-group {
					transform-origin: center
				}
				` }),
    /* @__PURE__ */ F(
      "svg",
      {
        id: "cdc-visualization__paired-bar-chart",
        width: n,
        height: t,
        viewBox: `0 0 ${e + Number(r.runtime.yAxis.size)} ${t}`,
        role: "img",
        tabIndex: 0,
        children: [
          /* @__PURE__ */ a("title", { children: `Paired bar chart graphic with the title ${r.title ? r.title : "No Title Found"}` }),
          /* @__PURE__ */ F(qe, { top: 0, left: Number(r.xAxis.size), children: [
            o.filter((D) => r.series[0].dataKey === g.dataKey).map((D, O) => {
              var $, j;
              let L = r.legend.behavior === "highlight" && d.length > 0 && d.indexOf(r.series[0].dataKey) === -1, U = r.legend.behavior === "highlight" || d.length === 0 || d.indexOf(r.series[0].dataKey) !== -1, X = T(D[r.series[0].dataKey]), ne = Number(r.barHeight) ? Number(r.barHeight) : 25, G = 0;
              G = O !== 0 ? (Number(r.barSpace) + ne + c) * O : G;
              const ce = (Number(r.barSpace) + ne + c) * o.length;
              r.heights.horizontal = ce;
              const re = mr(h(D[g.dataKey], "left")) < X - 5;
              return /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F(qe, { className: "horizontal", children: [
                /* @__PURE__ */ a(
                  Pr,
                  {
                    id: `bar-${g.dataKey}-${D[($ = r.dataDescription) == null ? void 0 : $.xKey]}`,
                    className: "bar group-1",
                    x: p - X,
                    y: G,
                    width: T(D[r.series[0].dataKey]),
                    height: ne,
                    fill: g.color,
                    "data-tooltip-html": C(D),
                    "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
                    stroke: "#333",
                    strokeWidth: c,
                    opacity: L ? 0.5 : 1,
                    display: U ? "block" : "none",
                    tabIndex: -1
                  },
                  `bar-${g.dataKey}-${D[(j = r.dataDescription) == null ? void 0 : j.xKey]}`
                ),
                r.yAxis.displayNumbersOnBar && U && /* @__PURE__ */ a(
                  dt,
                  {
                    textAnchor: re ? "start" : "end",
                    dx: re ? 5 : -5,
                    verticalAnchor: "middle",
                    x: p - X,
                    y: G + r.barHeight / 2,
                    fill: re ? g.labelColor : "#000",
                    children: h(D[g.dataKey], "left")
                  }
                )
              ] }, `group-${g.dataKey}-${D[r.xAxis.dataKey]}`) });
            }),
            o.filter((D) => r.series[1].dataKey === b.dataKey).map((D, O) => {
              var $, j, oe;
              let L = T(D[r.series[1].dataKey]), U = r.legend.behavior === "highlight" && d.length > 0 && d.indexOf(r.series[1].dataKey) === -1, X = r.legend.behavior === "highlight" || d.length === 0 || d.indexOf(r.series[1].dataKey) !== -1, ne = r.barHeight ? Number(r.barHeight) : 25, G = 0;
              G = O !== 0 ? (Number(r.barSpace) + ne + c) * O : G;
              const ce = (Number(r.barSpace) + ne + c) * o.length;
              r.heights.horizontal = ce;
              const re = mr(h(D[b.dataKey], "left")) < L - 5;
              return /* @__PURE__ */ F(Be, { children: [
                /* @__PURE__ */ a("style", { children: `
                      .bar-${b.dataKey}-${D[r.xAxis.dataKey]} {
                          transform-origin: ${p}px ${G}px
                      }
							      ` }),
                /* @__PURE__ */ F(qe, { className: "horizontal", children: [
                  /* @__PURE__ */ a(
                    Pr,
                    {
                      id: `bar-${b.dataKey}-${D[($ = r.dataDescription) == null ? void 0 : $.xKey]}`,
                      className: "bar group-2",
                      x: p,
                      y: G,
                      width: T(D[r.series[1].dataKey]),
                      height: ne,
                      fill: b.color,
                      "data-tooltip-html": w(D),
                      "data-tooltip-id": `cdc-open-viz-tooltip-${r.runtime.uniqueId}`,
                      strokeWidth: c,
                      stroke: "#333",
                      opacity: U ? 0.5 : 1,
                      display: X ? "block" : "none",
                      tabIndex: -1
                    },
                    `bar-${b.dataKey}-${D[(j = r.dataDescription) == null ? void 0 : j.xKey]}`
                  ),
                  r.yAxis.displayNumbersOnBar && X && /* @__PURE__ */ a(
                    dt,
                    {
                      textAnchor: re ? "end" : "start",
                      dx: re ? -5 : 5,
                      verticalAnchor: "middle",
                      x: p + L,
                      y: G + r.barHeight / 2,
                      fill: re ? b.labelColor : "#000",
                      children: h(D[b.dataKey], "left")
                    }
                  )
                ] }, `group-${b.dataKey}-${D[(oe = r.dataDescription) == null ? void 0 : oe.xKey]}`)
              ] });
            })
          ] })
        ]
      }
    )
  ] });
}, fk = ({ yMax: e, leftSize: t, max: n, xMax: r }) => {
  var w;
  const { config: i } = fe.useContext(ft), { orientation: o } = i, h = (S, B = "#f1f1f1") => {
    try {
      return Qi(S).hex();
    } catch {
      return B;
    }
  }, d = (w = i.yAxis) == null ? void 0 : w.categories, y = ((S) => {
    const B = Object.keys(S), M = B[B.length - 1];
    if (S[M] === "") {
      const D = B.slice(0, -1).reduce((L, U) => {
        const X = Number(S[U]);
        return L + (isNaN(X) ? 0 : X);
      }, 0), O = n - D;
      S[M] = O;
    }
    return [S];
  })(((S) => [...S].reduce((M, D) => (M[D.label] = D.height, M), {}))(d)), g = 0, b = wc({
    domain: [g],
    padding: 0,
    range: [0, t]
  }), T = zn({
    domain: [0, n],
    range: [e, 0],
    clamp: !0
  }), m = Df({
    domain: d.map((S) => S == null ? void 0 : S.label),
    range: d.map((S) => {
      var B;
      return h((B = S == null ? void 0 : S.color) == null ? void 0 : B.trim());
    })
  }), C = Object.keys(y[0]);
  return /* @__PURE__ */ a(qe, { left: t - b.bandwidth(), top: 0, children: /* @__PURE__ */ a(
    tg,
    {
      data: y,
      keys: C,
      x: () => b(g),
      xScale: b,
      yScale: T,
      color: m,
      children: (S) => S.map(
        (B) => B.bars.map((M) => {
          const D = i.yAxis.categories.length - 1 === B.index, O = Dc / 1.3, L = Qi(M.color).luminance() < 0.4 ? "#fff" : "#000", U = mr(M.key, `${O}px`), X = Number(U) < M.width && M.height > O, ne = `<ul>
              <li class="tooltip-heading""> Label : ${M.key}  </li>
                    </li></ul>`;
          return /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ F(
            qe,
            {
              id: `barStack${B.index}-${M.index}`,
              className: "stack vertical",
              children: [
                $l({
                  type: "axisBar",
                  config: i,
                  index: B.index,
                  background: m(M.key),
                  borderColor: "#333",
                  borderStyle: "solid",
                  borderWidth: 0,
                  width: b.bandwidth(),
                  height: M.height,
                  x: M.x,
                  y: M.y,
                  tooltipHtml: ne,
                  tooltipId: `cdc-open-viz-tooltip-${i.runtime.uniqueId}`
                }),
                /* @__PURE__ */ a(
                  dt,
                  {
                    display: X ? "block" : "none",
                    x: M.x + b.bandwidth() / 2,
                    y: M.y + M.height / 2,
                    fill: L,
                    textAnchor: "middle",
                    verticalAnchor: "middle",
                    style: { fontSize: O },
                    children: M.key
                  },
                  `text-${B.index}-${M.index}`
                ),
                i.runtime.yAxis.gridLines && /* @__PURE__ */ a(
                  an,
                  {
                    from: { x: M.x + b.bandwidth(), y: M.y },
                    to: { x: r + b.bandwidth(), y: M.y },
                    stroke: "#d6d6d6"
                  }
                ),
                !D && /* @__PURE__ */ a("rect", { x: M.x, y: M.y, width: M.width, height: 1, fill: "#fff" }),
                /* @__PURE__ */ a("rect", { x: M.x + M.width, y: 0, width: 1, height: e, fill: "#000" })
              ]
            },
            `bar-stack-${B.index}-${M.index}`
          ) }, `${B.index}--${M.index}--${o}`);
        })
      )
    }
  ) });
};
function pk({ orientation: e, heights: t, visualizationType: n }, r) {
  const o = e === "vertical" || n === "Forest Plot", d = (t == null ? void 0 : t.mobileVertical) && gh(r) ? "mobileVertical" : "vertical";
  return o ? d : "horizontal";
}
function mk({ heights: e, orientation: t, visualizationType: n }, r) {
  if (!e)
    return 0;
  const i = pk({ orientation: t, heights: e, visualizationType: n }, r), o = Number(e == null ? void 0 : e[i]);
  return isNaN(o) ? 0 : o;
}
function yk(e, t, n) {
  var w, S;
  const r = e.current.getBoundingClientRect().x, i = !!document.querySelector(".editor-panel:not(.hidden)"), o = (S = (w = t.current) == null ? void 0 : w[t.current.length - 1]) == null ? void 0 : S.getBoundingClientRect(), h = o ? o.x + o.width : 0, d = i ? Rm : 0, c = h - r - d - n, p = dv.clamp(c, 0, 20), y = Number(e.current.style.paddingRight.replace("px", "")), g = Math.abs(y - p), b = 5, T = y === c, m = g < b && c > 0 || Math.abs(c) < 1;
  return [!T && !m, p];
}
const bg = ({ config: e, minValue: t, maxValue: n, existPositiveValue: r, data: i, isAllLine: o, tableData: h }) => {
  let d = 0, c = 0, p = 0, y = 0;
  const { convertLineToBarGraph: g } = fe.useContext(ft);
  if (!i)
    return { min: d, max: c };
  const { visualizationType: b, series: T } = e, { max: m, min: C } = e.runtime.yAxis, w = e.yAxis.enablePadding ? 1 + e.yAxis.scalePadding / 100 : 1, S = e.yAxis.type === "logarithmic", B = r ? Number(m) >= n : Number(m) >= 0, M = S ? Number(C) >= 0 : Number(C) <= 0 && t >= 0 || Number(C) <= t && t < 0;
  d = C && M ? Number(C) : t, c = m && B ? Number(m) : Number.MIN_VALUE;
  const { lower: D, upper: O } = (e == null ? void 0 : e.confidenceKeys) || {};
  if (D && O && e.visualizationType === "Bar") {
    const L = d < 0 ? 1.1 : 0, U = Math.max(...i.flatMap((ne) => [ne[O], ne[D]])) * w, X = Math.min(...i.flatMap((ne) => [ne[O], ne[D]])) * w * L;
    c = c > U ? c : U, d = d < X ? d : X;
  }
  if (e.series.filter((L) => (L == null ? void 0 : L.type) === "Forecasting")) {
    const {
      runtime: { forecastingSeriesKeys: L }
    } = e;
    if ((L == null ? void 0 : L.length) > 0) {
      let U = [];
      L.forEach((ce) => {
        var q;
        (q = ce.confidenceIntervals) == null || q.map((re) => {
          U.push(re.high), U.push(re.low);
        });
      });
      const X = i.map((ce) => U.map((q) => ce[q])), ne = Math.max.apply(
        null,
        X.map((ce) => ce[0])
      ), G = Math.min.apply(
        null,
        X.map((ce) => ce[1])
      );
      ne > c && (c = ne), G < d && (d = G);
    }
  }
  if (b === "Combo")
    try {
      if (!i)
        throw new Error("COVE: missing data while getting min/max for combo chart.");
      let L = T.filter((ne) => ne.axis === "Left"), U = T.filter((ne) => ne.axis === "Right");
      const X = (ne, G, ce, q = "left") => {
        let re = 0;
        return (G.map((j) => j.dataKey) || []).forEach((j) => {
          let oe = G.find((J) => J.dataKey === j), ie = ne.map((J) => J[j]), le = Math.max.apply(null, ie);
          e.visualizationSubType === "stacked" && q === "left" && oe.type === "Bar" && (re += le), le > ce && (ce = le), ce < re && (ce = re);
        }), ce;
      };
      p = X(i, L, p, "left"), y = X(i, U, y, "right"), p < Number(m) && (p = Number(m));
    } catch (L) {
      console.error(L.message);
    }
  if ((b === "Bar" || g || b === "Combo" && !o) && d > 0 && (d = 0), (e.visualizationType === "Bar" || g || e.visualizationType === "Combo" && !o) && d < 0 && (d = d * 1.1), e.visualizationType === "Combo" && o && ((C == null || C === "") && d > 0 && (d = 0), C)) {
    const L = S ? Number(C) >= 0 && Number(C) < t : Number(C) < t;
    d = Number(C) && L ? Number(C) : t;
  }
  if (e.visualizationType === "Deviation Bar" && d > 0) {
    const L = Number(C) < Math.min(t, Number(e.xAxis.target));
    d = Number(C) && L ? Number(C) : 0;
  }
  if (e.visualizationType === "Line" && !g) {
    const L = S ? Number(C) >= 0 && Number(C) < t : Number(C) < t, U = h == null ? void 0 : h.some((ne, G) => {
      var ce;
      return (ce = e.preliminaryData) == null ? void 0 : ce.some((q) => {
        var oe;
        if (q.type !== "suppression" || !q.style)
          return !1;
        const re = Ke.pick(ne, (oe = e.runtime) == null ? void 0 : oe.seriesKeys), $ = Ke.values(re).includes(q.value);
        return (q.column ? ne[q.column] === q.value : $) && (G === 0 || G === h.length - 1);
      });
    });
    let X = e.yAxis.type === "categorical";
    d = C !== "" && L ? Number(C) : U || X ? 0 : t;
  }
  if (c === Number.MIN_VALUE && (c = r ? n : 0), e.runtime.yAxis.paddingPercent) {
    let L = (c - d) * e.runtime.yAxis.paddingPercent;
    d -= L, c += L;
  }
  if (e.isLollipopChart && e.yAxis.displayNumbersOnBar) {
    const L = i.map((X) => X[e.series[0].dataKey]), U = Math.max(...L).toString().length;
    switch (!0) {
      case (U > 8 && U <= 12):
        c = c * 1.3;
        break;
      case (U > 4 && U <= 7):
        c = c * 1.1;
        break;
    }
  }
  return e.yAxis.enablePadding && (d < 0 ? (c *= 1 + e.yAxis.scalePadding * 2 / 100, d *= 1 + e.yAxis.scalePadding * 2 / 100) : c *= 1 + e.yAxis.scalePadding / 100), e.visualizationType === "Area Chart" && e.visualizationSubType === "stacked" && (d = 0), e.visualizationType === "Scatter Plot" && (c = c * 1.1), { min: d, max: c, leftMax: p, rightMax: y };
};
function gk(e) {
  return { hasTopAxis: e.visualizationType === "Bar" || e.visualizationType === "Combo" || e.visualizationType === "Line" };
}
const Hl = () => {
  const { config: e } = fe.useContext(ft), { visualizationType: t, series: n, orientation: r, visualizationSubType: i } = e, o = [
    "Area Chart",
    "Bar",
    "Box Plot",
    "Bump Chart",
    "Combo",
    "Deviation Bar",
    "Forecasting",
    // 'Forest Plot',
    "Line",
    "Paired Bar",
    "Pie",
    "Scatter Plot",
    "Spark Line",
    "Sankey"
  ], h = [
    "theme-blue",
    "theme-purple",
    "theme-brown",
    "theme-teal",
    "theme-pink",
    "theme-orange",
    "theme-slate",
    "theme-indigo",
    "theme-cyan",
    "theme-green",
    "theme-amber"
  ], d = () => !["Forest Plot", "Sankey"].includes(t), c = () => !!["Scatter Plot"].includes(t), p = () => !!["Scatter Plot"].includes(t), y = () => !["Spark Line"].includes(t), g = () => !["Spark Line"].includes(t), b = () => ![
    "Area Chart",
    "Box Plot",
    "Pie",
    "Scatter Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), T = () => ![
    "Area Chart",
    "Scatter Plot",
    "Box Plot",
    "Forest Plot",
    "Spark Line",
    "Sankey",
    "Bump Chart"
  ].includes(t), m = () => {
    switch (t) {
      case "Box Plot":
        return !0;
      case "Forest Plot":
        return !1;
      case "Spark Line":
        return !1;
      case "Sankey":
        return !1;
      default:
        return !0;
    }
  }, C = () => t === "Forest Plot" ? !1 : e.orientation === "horizontal" && (e.yAxis.labelPlacement === "Below Bar" || e.yAxis.labelPlacement === "On Date/Category Axis" || e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar"), w = () => !!["Bar", "Combo", "Line"].includes(e.visualizationType), S = () => {
    switch (t) {
      case "Area Chart":
        return !0;
      case "Combo":
        return !0;
      case "Line":
        return !0;
      case "Bar":
        return !0;
      case "Scatter Plot":
        return !0;
      default:
        return !1;
    }
  }, B = () => {
    if ((t === "Bar" || "Combo") && i === "regular")
      return !0;
  }, M = () => e.xAxis.type === "categorical" ? !1 : ["Line", "Bar", "Area Chart", "Combo"].includes(t) && r === "vertical", D = () => ["Box Plot", "Scatter Plot", "Pie", "Line"].includes(t) ? !1 : n == null ? void 0 : n.some(
    (it) => it.type === "Bar" || it.type === "Paired Bar" || it.type === "Deviation Bar"
  ), O = () => {
    switch (t) {
      case "Sankey":
        return !1;
      case "Forest Plot":
        return !1;
      case "Box Plot":
        return !1;
      case "Pie":
        return !1;
      case "Spark Line":
        return !1;
      default:
        return !0;
    }
  }, L = !["Box Plot", "Forest Plot", "Spark Line"].includes(t);
  return {
    enabledChartTypes: o,
    headerColors: h,
    visCanAnimate: T,
    visHasAnchors: S,
    visHasBarBorders: D,
    visHasDataCutoff: O,
    visHasLabelOnData: b,
    visHasDataSuppression: B,
    visHasLegend: m,
    visHasLegendAxisAlign: () => t === "Bar" && i === "stacked" && e.legend.behavior === "isolate",
    visHasLegendColorCategory: () => {
      var $e;
      return t === "Bar" && i === "regular" && (($e = e.series) == null ? void 0 : $e.length) === 1;
    },
    visHasBrushChart: M,
    visHasNumbersOnBars: C,
    visHasaAdditionalLabelsOnBars: w,
    visSupportsBarSpace: () => ["Forest Plot"].includes(t) ? !1 : r === "horizontal" || t === "Paired Bar",
    visSupportsBarThickness: () => !["Forest Plot"].includes(t),
    visSupportsChartHeight: () => !["Spark Line"].includes(t),
    visSupportsMobileChartHeight: () => !!["Bar", "Line", "Combo", "Area Chart"].includes(t),
    visSupportsDateCategoryAxis: d,
    visSupportsDateCategoryAxisMin: c,
    visSupportsDateCategoryAxisMax: p,
    visSupportsDateCategoryAxisLabel: () => !["Forest Plot", "Spark Line", "Bump Chart"].includes(t),
    visSupportsDateCategoryAxisLine: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryAxisTicks: () => !["Forest Plot", "Spark Line"].includes(t),
    visSupportsDateCategoryHeight: () => !(["Spark Line", "Sankey", "Bump Chart"].includes(t) || e.orientation !== "horizontal"),
    visSupportsDateCategoryNumTicks: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryTickRotation: () => !["Spark Line"].includes(t),
    visSupportsDateCategoryAxisPadding: () => e.xAxis.type === "date-time",
    visSupportsFilters: () => !["Forest Plot", "Sankey"].includes(t),
    visSupportsFootnotes: g,
    visSupportsLeftValueAxis: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsNonSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsPreliminaryData: () => !!["Line", "Bar", "Combo"].includes(t),
    visSupportsRankByValue: () => !["Spark Line"].includes(t),
    visSupportsRegions: () => !["Forest Plot", "Pie", "Paired Bar", "Spark Line", "Sankey"].includes(t),
    visSupportsResponsiveTicks: () => !["Spark Line"].includes(t),
    visSupportsReverseColorPalette: () => !["Forest Plot", "Paired Bar", "Deviation Bar", "Sankey"].includes(t),
    visSupportsSequentialPallete: () => !["Paired Bar", "Deviation Bar", "Forest Plot", "Forecasting", "Sankey"].includes(t),
    visSupportsSuperTitle: y,
    visSupportsTooltipLines: () => !!["Combo", "Forecasting", "Area Chart", "Line", "Bar"].includes(t),
    visHasSelectableLegendValues: L,
    visSupportsTooltipOpacity: () => !["Spark Line", "Sankey"].includes(t),
    visSupportsValueAxisGridLines: () => {
      const $e = ["Forest Plot"];
      return !(r === "horizontal" || $e.includes(t));
    },
    visSupportsValueAxisLabels: () => !["Forest Plot", "Bump Chart"].includes(t),
    visSupportsValueAxisLine: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisTicks: () => !["Forest Plot"].includes(t),
    visSupportsReactTooltip: () => {
      if (e.yAxis.type === "categorical" || ["Deviation Bar", "Box Plot", "Scatter Plot", "Paired Bar"].includes(t))
        return !0;
    },
    visSupportsValueAxisMax: () => !["Forest Plot"].includes(t),
    visSupportsValueAxisMin: () => !["Forest Plot"].includes(t),
    visSupportsDynamicSeries: () => t === "Line" || t === "Bar" || t === "Scatter Plot" || t === "Area Chart",
    visSupportsYPadding: () => {
      var $e;
      return !e.dataFormat.onlyShowTopPrefixSuffix || !(($e = e.dataFormat.suffix) != null && $e.includes(" "));
    },
    visHasSingleSeriesTooltip: () => t === "Bar" || t === "Line" || t === "Area Chart" && i === "stacked",
    visHasCategoricalAxis: () => {
      if ((t === "Line" || t === "Bar" || t === "Combo" || t === "Area Chart") && e.yAxis.type === "categorical" && r === "vertical")
        return !0;
    }
  };
}, vk = ({ data: e, xScale: t, yScale: n, config: r, xMax: i, annotationSeriesKey: o }, h) => {
  const { xAxis: d, visualizationType: c, orientation: p } = r, y = (w, S, B, M, D) => {
    let O = [];
    r.xAxis.type === "date-time" && (S = new Date(S), B = new Date(B), M = M.map((X) => new Date(X)), O = D.ticks().map((X) => new Date(X)));
    const L = (w - S) / (B - S), U = Math.round(L * (M.length - 1));
    return r.xAxis.type === "date-time" ? O[U] : M[U];
  }, b = ((w, S = !1) => {
    if (c !== "Pie" && p !== "horizontal") {
      if (r.xAxis.type === "date-time") {
        const B = new Date(t.invert(w)), M = r.data.map((L) => new Date(L[r.xAxis.dataKey]).getTime());
        let D = 1 / 0, O = null;
        return M.forEach((L) => {
          const U = Math.abs(B.getTime() - L);
          U < D && (D = U, O = L);
        }), new Date(O).getTime();
      }
      if (r.xAxis.type === "categorical" || c === "Combo" && p !== "horizontal" && c !== "Forest Plot") {
        const M = (t.range()[1] - t.range()[0]) / (t.domain().length + 1), O = Math.floor((Number(w) - M / 2) / M);
        return t.domain()[O];
      }
      if (r.xAxis.type === "date") {
        const B = y(w, 0, i, t.domain(), t);
        let M = null, D = Number.MAX_VALUE;
        return t.domain().forEach((O) => {
          const L = Math.abs(B - O);
          L < D && (D = L, M = O);
        }), M;
      }
      return w;
    }
  })(h - Number(r.yAxis.size || 0));
  let T = [];
  if (!b)
    return { x: 0, y: 0 };
  d.type === "categorical" && (T = r.data.filter((w) => w[r.xAxis.dataKey] === b)), (d.type === "date" || d.type === "date-time") && (T = r.data.filter((w) => new Date(w[r.xAxis.dataKey]).getTime() === b));
  const m = T[0][o];
  return { x: b, y: m };
}, bk = (e, t, n) => {
  const { connectionLocation: r } = e;
  return r === "right" ? "end" : r === "left" ? "start" : r === "bottom" || r === "top" || t(e.xKey) + e.dx < n.yAxis.size ? "middle" : null;
}, xk = (e, t, n) => {
  const { connectionLocation: r } = e;
  return r === "top" ? "start" : r === "bottom" ? "end" : r === "right" || r === "left" ? "middle" : t(e.xKey) + e.dx < n.yAxis.size ? "end" : null;
};
const Sk = ({ xScale: e, yScale: t, xScaleAnnotation: n, xMax: r, svgRef: i, onDragStateChange: o }) => {
  const { config: h, dimensions: d, isEditor: c, updateConfig: p, colorScale: y } = fe.useContext(ft), { annotations: g } = h, [b] = d, T = c ? Wg : jg;
  return g && g.map((m, C) => {
    var M;
    const w = m.text || "", S = n(m.x), B = () => ({
      __html: Om.sanitize(w)
    });
    return /* @__PURE__ */ F(
      T,
      {
        width: 200,
        height: b,
        dx: m.dx,
        dy: m.dy,
        x: S,
        y: m.y,
        canEditLabel: m.edit.label || !1,
        canEditSubject: m.edit.subject && m.connectionType !== "none" || !1,
        onDragStart: () => o(!0),
        onDragEnd: (D) => {
          o(!1);
          let O = [...g];
          if (m.x === n.invert(D.x) && m.y === D.y)
            O[C] = { ...O[C], dx: D.dx, dy: D.dy };
          else if (m.snapToNearestPoint) {
            let L = vk(
              {
                data: h.data,
                xScale: e,
                yScale: t,
                config: h,
                xMax: r - h.yAxis.size / 2,
                annotationSeriesKey: m.seriesKey
              },
              D.x
            );
            O[C] = {
              ...O[C],
              x: n.invert(e(L.x)),
              y: t(L.y)
            };
          } else
            O[C] = {
              ...O[C],
              x: n.invert(D.x),
              y: D.y
            };
          p({
            ...h,
            annotations: O
          });
        },
        children: [
          /* @__PURE__ */ a(
            Hg,
            {
              className: "annotation__desktop-label",
              showAnchorLine: !1,
              horizontalAnchor: bk(m, e, h),
              verticalAnchor: xk(m, e, h),
              children: /* @__PURE__ */ F(
                "div",
                {
                  style: {
                    borderRadius: 5,
                    // Optional: set border radius
                    backgroundColor: `rgba(255, 255, 255, ${m != null && m.opacity ? Number(m == null ? void 0 : m.opacity) / 100 : 1})`,
                    padding: "10px",
                    width: "auto",
                    display: h.general.showAnnotationDropdown ? "inline-flex" : "flex",
                    justifyContent: "start",
                    flexDirection: "row"
                  },
                  tabIndex: 0,
                  "aria-label": `Annotation text that reads: ${m.text}`,
                  children: [
                    ((M = h == null ? void 0 : h.general) == null ? void 0 : M.showAnnotationDropdown) && /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ a("p", { className: "annotation__has-dropdown-number", style: { margin: "2px 6px" }, children: C + 1 }) }),
                    /* @__PURE__ */ a("div", { dangerouslySetInnerHTML: B() })
                  ]
                }
              )
            }
          ),
          m.connectionType === "line" && /* @__PURE__ */ a(Xf, { type: "line", pathProps: { markerStart: `url(#marker-start--${C})` } }),
          m.connectionType === "elbow" && /* @__PURE__ */ a(Xf, { type: "elbow", pathProps: { markerStart: `url(#marker-start--${C})` } }),
          m.connectionType === "curve" && /* @__PURE__ */ a(
            Gr,
            {
              d: `M ${S},${m.y}
                      Q ${S + m.dx / 2}, ${m.y + m.dy / 2 + Number(m == null ? void 0 : m.bezier) || 0} ${S + m.dx},${m.y + m.dy}`,
              stroke: "black",
              strokeWidth: "2",
              fill: "none",
              "marker-start": `url(#marker-start--${C})`
            }
          ),
          m.marker === "circle" && /* @__PURE__ */ a(
            Vg,
            {
              id: `marker-start--${C}`,
              className: "circle-subject",
              stroke: y(m.seriesKey),
              radius: 8
            }
          ),
          m.marker === "arrow" && /* @__PURE__ */ a(
            Dm,
            {
              fill: "black",
              id: `marker-start--${C}`,
              x: S,
              y: m.y,
              stroke: "#333",
              markerWidth: 10,
              size: 10,
              strokeWidth: 1,
              orient: "auto-start-reverse",
              markerUnits: "userSpaceOnUse"
            }
          ),
          /* @__PURE__ */ a(
            "circle",
            {
              fill: "white",
              cx: S + m.dx,
              cy: m.y + m.dy,
              r: 16,
              className: "annotation__mobile-label annotation__mobile-label-circle",
              stroke: y(m.seriesKey)
            }
          ),
          /* @__PURE__ */ a(
            "text",
            {
              height: 16,
              x: S + m.dx,
              y: m.y + m.dy,
              className: "annotation__mobile-label",
              alignmentBaseline: "middle",
              textAnchor: "middle",
              children: C + 1
            }
          )
        ]
      }
    );
  });
};
const wk = ({ useBootstrapVisibilityClasses: e = !0 }) => {
  const { config: t } = fe.useContext(ft), n = t.annotations || [], r = () => {
    const o = ["annotation-list"];
    return e && o.push("d-block", "d-md-none"), o.join(" ");
  }, i = n.map((o, h) => {
    const d = o.text || "", c = () => ({
      __html: Om.sanitize(d)
    });
    return /* @__PURE__ */ a("li", { children: /* @__PURE__ */ F("div", { className: "annotation__title-wrapper", children: [
      /* @__PURE__ */ a("div", { className: "annotation__title-circle", children: h + 1 }),
      /* @__PURE__ */ a("p", { className: "annotation__subtext", dangerouslySetInnerHTML: c() })
    ] }) }, "annotation-li-item__annotationIndex");
  });
  return /* @__PURE__ */ a("ul", { className: r(), children: i });
};
const kk = () => {
  var c;
  const { currentViewport: e, config: t } = fe.useContext(ft), [n, r] = fe.useState(!1), i = ["sm", "xs", "xxs"].includes(e) ? "13px" : `${Dc}px`;
  fe.useContext(ft);
  const o = {
    maxHeight: t.table.limitHeight && `${t.table.height}px`,
    OverflowY: "scroll"
  }, h = () => {
    const p = ["data-table-heading", "annotation__dropdown-list", "p-3"];
    return n || p.push("collapsed"), p.join(" ");
  };
  return /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F("section", { className: (() => {
    const p = ["data-table-container", e, "d-block", "d-lg-none", "w-100"];
    return t.general.showAnnotationDropdown && (p.push("d-lg-block"), p.splice(p.indexOf("d-lg-none"), 1)), p.join(" ");
  })(), children: [
    /* @__PURE__ */ F(
      "div",
      {
        style: { fontSize: i },
        role: "button",
        className: h(),
        onClick: () => {
          r(!n);
        },
        tabIndex: 0,
        onKeyDown: (p) => {
          p.keyCode === 13 && r(!n);
        },
        children: [
          /* @__PURE__ */ a(Ve, { display: n ? "minus" : "plus", base: !0 }),
          t.general.annotationDropdownText === "" ? "Annotations" : (c = t == null ? void 0 : t.general) == null ? void 0 : c.annotationDropdownText
        ]
      }
    ),
    n && /* @__PURE__ */ a("div", { className: "table-container annotation-dropdown__panel", style: o, children: /* @__PURE__ */ a(Ff.List, { useBootstrapVisibilityClasses: !1 }) })
  ] }) });
}, Ff = {
  Draggable: Sk,
  // Mobile auto display
  List: wk,
  // Desktop Accessible Option
  Dropdown: kk
}, Tk = ({ axis: e, max: t, runtime: n, currentViewport: r, isHorizontal: i, data: o, config: h, min: d }) => {
  let { numTicks: c } = n[e];
  n[e].viewportNumTicks && n[e].viewportNumTicks[r] && (c = n[e].viewportNumTicks[r]);
  let p;
  return e === "yAxis" && (p = i && !c ? o.length : i && c ? c : !i && !c ? void 0 : !i && c && c, p === void 0 && !h.dataFormat.roundTo && (Number(t) <= 3 ? p = 2 : p = 4), Number(p) > Number(t) && !i && (p = Math.max(2, Number(d) < 0 ? Math.round(t) * 2 : Math.round(t)))), e === "xAxis" && (p = i && !c ? void 0 : i && c ? c : !i && !c ? void 0 : !i && c && c, i && p === void 0 && !h.dataFormat.roundTo && (t <= 3 ? p = 2 : p = 4), h.visualizationType === "Forest Plot" && (p = h.yAxis.numTicks !== "" ? h.yAxis.numTicks : 4)), p;
}, dh = 9, Yu = 4.5, hh = 8, Ck = 1e3 * 60 * 60 * 24 * 30, Ak = 16, Lk = 13, Ek = 18, _k = 14, Pk = 4.5, fh = fe.forwardRef(({ parentHeight: e, parentWidth: t }, n) => {
  var Wn, ar, Xn, qn, v, P;
  const {
    brushConfig: r,
    colorScale: i,
    config: o,
    convertLineToBarGraph: h,
    currentViewport: d,
    dimensions: c,
    formatDate: p,
    formatNumber: y,
    handleChartAriaLabels: g,
    handleLineType: b,
    handleDragStateChange: T,
    isDraggingAnnotation: m,
    legendRef: C,
    parseDate: w,
    parentRef: S,
    tableData: B,
    transformedData: M,
    updateConfig: D,
    seriesHighlight: O
  } = fe.useContext(ft), {
    heights: L,
    visualizationType: U,
    visualizationSubType: X,
    orientation: ne,
    xAxis: G,
    yAxis: ce,
    runtime: q,
    legend: re,
    forestPlot: $,
    brush: j,
    dataFormat: oe,
    debugSvg: ie
  } = o, { suffix: le, onlyShowTopPrefixSuffix: J } = oe, { labelsAboveGridlines: de, hideAxis: ae } = o.yAxis, { minValue: Z, maxValue: ye, existPositiveValue: ue, isAllLine: ve } = qc(o, M), { visSupportsReactTooltip: ke } = Hl(), { hasTopAxis: me } = gk(o), [Ne, Ee] = fe.useState(!1), [De, Xe] = fe.useState({ x: 0, y: 0 }), [Fe, Je] = fe.useState(0), [gt, mt] = fe.useState(0), yt = fe.useRef(null), Ye = fe.useRef(null), ot = fe.useRef(null), ut = fe.useRef(null), st = fe.useRef(), tt = fe.useRef([]), $e = fe.useRef(null), it = fe.useRef(ye), ht = fe.useRef([]), Ce = Pf(st, {
    freezeOnceVisible: !1
  }), Ht = !0, vn = ne === "horizontal" || o.visualizationType === "Forest Plot", pt = o.yAxis.type === "logarithmic", hn = U === "Forest Plot", yn = o.xAxis.type === "date-time", Vt = !le.includes(" "), zt = J && !Vt, Cn = Number(ne === "horizontal" ? o.xAxis.size : o.yAxis.size), qt = isNaN(parseInt(`${q.yAxis.labelOffset}`)) ? 0 : parseInt(`${q.yAxis.labelOffset}`), Ft = gh(d) ? Lk : Ak, Gt = gh(d) ? _k : Ek, Zt = `normal ${Ft}px Nunito, sans-serif`, gn = hn ? o.data.length * o.forestPlot.rowHeight : 0, Pt = fe.useMemo(
    () => mk(o, d),
    [o, d, e, (Wn = o.heights) == null ? void 0 : Wn.vertical, (ar = o.heights) == null ? void 0 : ar.horizontal]
  ), Qt = fe.useMemo(() => Pt + gn, [Pt, gn]), Rt = fe.useMemo(() => {
    var Y;
    const _ = c[0], W = re == null ? void 0 : re.hide, he = ["bottom", "top"].includes((Y = o.legend) == null ? void 0 : Y.position), N = Yi(d);
    if (!(!hn && !W && !he && !N))
      return _;
    if (C.current) {
      const be = getComputedStyle(C.current);
      return _ - C.current.getBoundingClientRect().width - parseInt(be.marginLeft) - parseInt(be.marginRight);
    }
    return _ * 0.73;
  }, [c[0], o.legend, d, C.current]), bt = fe.useMemo(() => {
    var W;
    return tt.current = (W = tt.current) == null ? void 0 : W.filter((he) => he), tt.current.length ? Math.max(...tt.current.map((he) => he.getBBox().height)) + Yu + hh : void 0;
  }, [c[0], o.xAxis, tt.current, o.xAxis.tickRotation]), lt = Rt - q.yAxis.size - (U === "Combo" ? o.yAxis.rightAxisSize : 0), Se = Pt + gn, _e = o.filters && o.filters.values.length === 0 && M.length === 0, xe = (_) => Tn(o.runtime.xAxis) ? w(_[o.runtime.originalXAxis.dataKey]).getTime() : _[o.runtime.originalXAxis.dataKey], Ge = (_, W) => _[W], Ze = o.brush.active && ((Xn = r.data) != null && Xn.length) ? r.data.map((_) => xe(_)) : M.map((_) => xe(_)), et = o.orientation === "horizontal" || o.visualizationType === "Forest Plot" ? "yAxis" : "xAxis", Nt = {
    data: M,
    tableData: B,
    config: {
      ...o,
      yAxis: {
        ...o.yAxis,
        scalePadding: zt ? gt : o.yAxis.scalePadding,
        enablePadding: zt || o.yAxis.enablePadding
      }
    },
    minValue: Z,
    maxValue: ye,
    isAllLine: ve,
    existPositiveValue: ue,
    xAxisDataMapped: Ze,
    xMax: lt,
    yMax: Se
  }, { min: Wt, max: xt, leftMax: at, rightMax: un } = bg(Nt), { yScaleRight: jt, hasRightAxis: An } = Mf({ config: o, yMax: Se, data: M, updateConfig: D }), { xScale: wt, yScale: Lt, seriesScale: bn, g1xScale: $n, g2xScale: Ln, xScaleNoPadding: En, xScaleAnnotation: nr } = Gw({
    ...Nt,
    min: Wt,
    max: xt,
    leftMax: at,
    rightMax: un,
    dimensions: c,
    xMax: t - Number(o.orientation === "horizontal" ? o.xAxis.size : o.yAxis.size) - (An ? o.yAxis.rightAxisSize : 0)
  }), [Yn, _n] = ["yAxis", "xAxis"].map(
    (_) => Tk({ axis: _, max: xt, runtime: q, currentViewport: d, isHorizontal: vn, data: M, config: o, min: Wt })
  ), fn = hn ? o.data.length : Yn, { tooltipData: _t, showTooltip: Jt, hideTooltip: Yt, tooltipOpen: on, tooltipLeft: wn, tooltipTop: Ut } = rg(), {
    handleTooltipMouseOver: sn,
    handleTooltipClick: pn,
    handleTooltipMouseOff: Bt,
    TooltipListItem: rr
  } = lg({
    xScale: wt,
    yScale: Lt,
    seriesScale: bn,
    showTooltip: Jt,
    hideTooltip: Yt
  }), { dataKey: Mn } = q.xAxis, Pn = M.length && yn ? [0, M.length - 1].map((_) => w(M[_][Mn])).reduce((_, W) => Math.abs(_ - W)) / Ck : 0, cn = yn && Pn > _n && !o.runtime.xAxis.manual, Hn = (_, W, he) => {
    if (pt && _ === 0.1 && (_ = 0), !(o.data && !o.data[W] && U === "Forest Plot"))
      return o.visualizationType === "Forest Plot" ? o.data[W][o.xAxis.dataKey] : Tn(q.yAxis) ? p(w(_)) : ne === "vertical" && xt - Wt < 3 ? y(_, "left", Ht, !1, !1, "1", { index: W, length: he.length }) : ne === "vertical" ? y(_, "left", Ht, !1, !1, void 0, { index: W, length: he.length }) : _;
  }, Vn = (_, W, he) => (pt && _ === 0.1 && (_ = 0), Tn(q.xAxis) && o.visualizationType !== "Forest Plot" ? p(_, W, he) : ne === "horizontal" && o.visualizationType !== "Forest Plot" ? y(_, "left", Ht) : o.xAxis.type === "continuous" && o.visualizationType !== "Forest Plot" ? y(_, "bottom", Ht) : o.visualizationType === "Forest Plot" ? y(
    _,
    "left",
    o.dataFormat.abbreviated,
    o.runtime.xAxis.prefix,
    o.runtime.xAxis.suffix,
    Number(o.dataFormat.roundTo)
  ) : _), yr = () => {
    let _ = o.xAxis.manualStep;
    return o.xAxis.viewportStepCount && o.xAxis.viewportStepCount[d] && (_ = o.xAxis.viewportStepCount[d]), _;
  }, gr = (_) => {
    const W = _.currentTarget.getBoundingClientRect(), he = _.clientX - W.left, N = _.clientY - W.top;
    Xe({
      x: he,
      y: N
    });
  };
  fe.useEffect(() => {
    if (!S.current || !t || !ht.current.length)
      return;
    const [_, W] = yk(S, tt, t);
    _ && (S.current.style.paddingRight = `${W}px`, ht.current.forEach((he) => {
      he && he.setAttribute("x1", lt - W);
    }));
  }, [t, e, M]), fe.useEffect(() => {
    document.querySelector(".isEditor") && Ee((W) => !0);
  }), fe.useEffect(() => {
    (Ce == null ? void 0 : Ce.isIntersecting) === !0 && o.animate && setTimeout(() => {
      Ee((_) => !0);
    }, 500);
  }, [Ce == null ? void 0 : Ce.isIntersecting, o.animate]), fe.useEffect(() => {
    const _ = ot.current;
    if (!_ && !Fe)
      return;
    if (!_)
      return Je(0);
    const W = _.getBBox().width;
    Je(W);
  }, [o.dataFormat.suffix, o.dataFormat.onlyShowTopPrefixSuffix]), fe.useEffect(() => {
    if (!hn || G.hideLabel)
      return;
    const _ = Ye.current;
    if (!_)
      return;
    const W = Se + Number(o.xAxis.axisPadding), N = _.getBBox().y - W + _.getBBox().height + dh;
    $e.current && $e.current.setAttribute("y", N);
  }, [(qn = o == null ? void 0 : o.data) == null ? void 0 : qn.length, gn]), fe.useEffect(() => {
    if (!yt.current)
      return;
    const _ = yt.current.getBBox().height, W = U === "Forest Plot", he = ut.current && ce.labelsAboveGridlines, N = j != null && j.active ? (j == null ? void 0 : j.height) + (j == null ? void 0 : j.height) : 0, z = W ? o.data.length * $.rowHeight : 0, Y = he ? ut.current.getBBox().height : 0, be = _ + N + z + Y, Oe = Pt + be;
    if (!S.current || (S.current.style.height = `${Oe}px`, !Y))
      return;
    const We = n.current;
    if (!We)
      return;
    const rt = S.current.getBoundingClientRect().width;
    if (We.setAttribute("viewBox", `0 ${-Y} ${rt} ${Oe}`), !C.current)
      return;
    const Dt = (re == null ? void 0 : re.position) !== "top" && (re == null ? void 0 : re.position) !== "bottom" && !Yi(d);
    C.current.style.transform = Dt ? `translateY(${Y}px)` : "none";
  }, [yt.current, o, bt, j, d, ut.current, Pt]), fe.useEffect(() => {
    it.current !== ye && (it.current = ye, gt && mt(0));
  }, [ye]), fe.useEffect(() => {
    var Dt;
    if (!(Lt != null && Lt.ticks))
      return;
    const _ = Lt.ticks(fn);
    if (ne === "horizontal" || !zt || (Dt = o.yAxis) != null && Dt.max || _.length === 0) {
      mt(0);
      return;
    }
    const W = 0.025, N = Math.max(..._) - ye * W;
    if (!(ye > N))
      return;
    const Y = _.length === 1 ? _[0] : _[1] - _[0], be = Math.max(...Lt.ticks(fn)) + Y, Oe = Z < 0 ? ye / 2 : ye, We = (be - ye) / Oe, rt = We > W ? We : We + Y / Oe;
    mt(rt * 100 + 0.1);
  }, [ye, zt, Lt, fn]);
  const ir = () => {
    const _ = bt + dh, W = (he, N) => {
      if (!he.length)
        return !1;
      const z = he.filter((Xt) => Xt.index !== 0), Y = z == null ? void 0 : z.length, be = N.range()[0] || lt / 2, Oe = z.map(
        (Xt) => mr(y(Xt.value, "left"), Zt)
      ), We = 100, rt = Oe.reduce((Xt, tn) => Xt + tn, We), Dt = (be - rt) / Y;
      let Mt = [0];
      for (let Xt = 1; Xt < Oe.length; Xt++)
        Mt[Xt] = Mt[Xt - 1] + Oe[Xt - 1] + Dt;
      let dn = !1;
      return Oe.forEach((Xt, tn) => {
        if (Mt[tn] + Oe[tn] > Mt[tn + 1]) {
          dn = !0;
          return;
        }
      }), dn;
    };
    return /* @__PURE__ */ F(Be, { children: [
      /* @__PURE__ */ a(
        tc,
        {
          top: Se,
          left: Number(q.yAxis.size),
          label: q.xAxis.label,
          tickFormat: Tn(q.xAxis) ? p : y,
          scale: $n,
          stroke: "#333",
          tickStroke: "#333",
          numTicks: q.xAxis.numTicks || void 0,
          children: (he) => /* @__PURE__ */ F(qe, { className: "bottom-axis", children: [
            he.ticks.map((N, z) => {
              const Y = W(he.ticks, $n), be = Number(o.xAxis.maxTickRotation) || 90, Oe = o.isResponsiveTicks && Y, We = N.index !== 0 && (Oe ? be : Number(o.yAxis.tickRotation)), rt = We && N.index !== 0 ? "end" : "middle";
              return /* @__PURE__ */ F(qe, { className: "vx-axis-tick", children: [
                !q.yAxis.hideTicks && /* @__PURE__ */ a(an, { from: N.from, to: N.to, stroke: "#333" }),
                !q.yAxis.hideLabel && /* @__PURE__ */ a(
                  dt,
                  {
                    innerRef: (Dt) => tt.current[z] = Dt,
                    x: N.to.x,
                    y: N.to.y,
                    angle: -We,
                    verticalAnchor: We ? "middle" : "start",
                    textAnchor: rt,
                    fontSize: Ft,
                    children: y(N.value, "left")
                  }
                )
              ] }, `vx-tick-${N.value}-${z}`);
            }),
            !q.yAxis.hideAxis && /* @__PURE__ */ a(an, { from: he.axisFromPoint, to: he.axisToPoint, stroke: "#333" })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        tc,
        {
          innerRef: yt,
          top: Se,
          left: Number(q.yAxis.size),
          label: q.xAxis.label,
          tickFormat: Tn(q.xAxis) ? p : q.xAxis.dataKey !== "Year" ? y : (he) => he,
          scale: Ln,
          stroke: "#333",
          tickStroke: "#333",
          numTicks: q.xAxis.numTicks || void 0,
          children: (he) => /* @__PURE__ */ F(Be, { children: [
            /* @__PURE__ */ F(qe, { className: "bottom-axis", children: [
              he.ticks.map((N, z) => {
                const Y = W(he.ticks, Ln), be = Number(o.xAxis.maxTickRotation) || 90, Oe = o.isResponsiveTicks && Y, We = N.index !== 0 && (Oe ? be : Number(o.yAxis.tickRotation)), rt = We && N.index !== 0 ? "end" : "middle";
                return z ? /* @__PURE__ */ F(qe, { className: "vx-axis-tick", children: [
                  !q.yAxis.hideTicks && /* @__PURE__ */ a(an, { from: N.from, to: N.to, stroke: "#333" }),
                  !q.yAxis.hideLabel && /* @__PURE__ */ a(
                    dt,
                    {
                      x: N.to.x,
                      y: N.to.y + Yu,
                      angle: -We,
                      verticalAnchor: We ? "middle" : "start",
                      textAnchor: rt,
                      fontSize: Ft,
                      children: y(N.value, "left")
                    }
                  )
                ] }, `vx-tick-${N.value}-${z}`) : /* @__PURE__ */ a(Be, {});
              }),
              !q.yAxis.hideAxis && /* @__PURE__ */ a(an, { from: he.axisFromPoint, to: he.axisToPoint, stroke: "#333" })
            ] }),
            /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ a(
              dt,
              {
                className: "x-axis-title-label",
                x: lt / 2,
                y: _,
                stroke: "#333",
                textAnchor: "middle",
                verticalAnchor: "start",
                fontSize: Gt,
                children: q.xAxis.label
              }
            ) })
          ] })
        }
      )
    ] });
  };
  return isNaN(Rt) ? /* @__PURE__ */ a(Ie.Fragment, {}) : /* @__PURE__ */ a(Xr, { component: "LinearChart", children: /* @__PURE__ */ F(
    "div",
    {
      style: { width: `${t}px`, overflow: "visible", position: "relative" },
      className: "tooltip-boundary",
      children: [
        /* @__PURE__ */ F(
          "svg",
          {
            ref: n,
            onMouseMove: gr,
            width: t + o.yAxis.rightAxisSize,
            height: _e ? 1 : e,
            className: `linear ${o.animate ? "animated" : ""} ${Ne && o.animate ? "animate" : ""} ${ie && "debug"} ${m && "dragging-annotation"}`,
            role: "img",
            "aria-label": g(o),
            style: { overflow: "visible" },
            children: [
              !m && /* @__PURE__ */ a(Pr, { width: t, height: Pt, fill: "transparent" }),
              " ",
              !["Spark Line", "Forest Plot"].includes(U) && o.yAxis.type !== "categorical" && /* @__PURE__ */ a(
                hm,
                {
                  scale: Lt,
                  left: Number(q.yAxis.size) - o.yAxis.axisPadding,
                  numTicks: fn,
                  children: (_) => {
                    const W = o.orientation === "horizontal" ? (_.axisToPoint.y - _.axisFromPoint.y) / 2 : (_.axisFromPoint.y - _.axisToPoint.y) / 2;
                    return /* @__PURE__ */ F(qe, { className: "left-axis", children: [
                      _.ticks.map((he, N) => {
                        const z = String(he.value).startsWith("1") || he.value === 0.1 ? "block" : "none", Y = he.index === 0 && he.value === 0 && o.xAxis.hideAxis;
                        return /* @__PURE__ */ a(qe, { className: "vx-axis-tick", children: q.yAxis.gridLines && !Y ? /* @__PURE__ */ a(
                          an,
                          {
                            innerRef: (be) => ht.current[N] = be,
                            display: (pt && z).toString(),
                            from: { x: he.from.x + lt, y: he.from.y },
                            to: he.from,
                            stroke: "#d6d6d6"
                          },
                          `${he.value}--hide-hideGridLines`
                        ) : "" }, `vx-tick-${he.value}-${N}`);
                      }),
                      /* @__PURE__ */ a(
                        dt,
                        {
                          className: "y-label",
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          transform: `translate(${-1 * q.yAxis.size + qt}, ${W}) rotate(-90)`,
                          fontWeight: "bold",
                          fill: o.yAxis.labelColor,
                          fontSize: Gt,
                          children: _.label
                        }
                      )
                    ] });
                  }
                }
              ),
              U === "Paired Bar" && ir(),
              U === "Deviation Bar" && ((v = o.runtime.series) == null ? void 0 : v.length) === 1 && /* @__PURE__ */ a(jw, { animatedChart: Ne, xScale: wt, yScale: Lt, width: lt, height: Se }),
              U === "Paired Bar" && /* @__PURE__ */ a(hk, { originalWidth: Rt, width: lt, height: Se }),
              U === "Scatter Plot" && /* @__PURE__ */ a(
                Ww,
                {
                  xScale: wt,
                  yScale: Lt,
                  getXAxisData: xe,
                  getYAxisData: Ge,
                  xMax: lt,
                  yMax: Se,
                  handleTooltipMouseOver: sn,
                  handleTooltipMouseOff: Bt,
                  handleTooltipClick: pn,
                  tooltipData: _t,
                  showTooltip: Jt
                }
              ),
              U === "Box Plot" && /* @__PURE__ */ a(
                Vw,
                {
                  seriesScale: bn,
                  xMax: lt,
                  yMax: Se,
                  min: Wt,
                  max: xt,
                  xScale: wt,
                  yScale: Lt
                }
              ),
              (U === "Area Chart" && o.visualizationSubType === "stacked" || U === "Combo") && /* @__PURE__ */ a(
                _w,
                {
                  xScale: wt,
                  yScale: Lt,
                  yMax: Se,
                  xMax: lt,
                  chartRef: n,
                  width: lt,
                  height: Se,
                  handleTooltipMouseOver: sn,
                  handleTooltipMouseOff: Bt,
                  tooltipData: _t,
                  showTooltip: Jt
                }
              ),
              (U === "Bar" || U === "Combo" || h) && /* @__PURE__ */ a(
                Mw,
                {
                  xScale: wt,
                  yScale: Lt,
                  seriesScale: bn,
                  xMax: lt,
                  yMax: Se,
                  getXAxisData: xe,
                  getYAxisData: Ge,
                  animatedChart: Ne,
                  visible: Ne,
                  handleTooltipMouseOver: sn,
                  handleTooltipMouseOff: Bt,
                  handleTooltipClick: pn,
                  tooltipData: _t,
                  showTooltip: Jt,
                  chartRef: n
                }
              ),
              (U === "Combo" || U === "Bump Chart") && /* @__PURE__ */ a(
                xm,
                {
                  xScale: wt,
                  yScale: Lt,
                  getXAxisData: xe,
                  getYAxisData: Ge,
                  xMax: lt,
                  yMax: Se,
                  seriesStyle: o.runtime.series,
                  handleTooltipMouseOver: sn,
                  handleTooltipMouseOff: Bt,
                  handleTooltipClick: pn,
                  tooltipData: _t,
                  showTooltip: Jt
                }
              ),
              (U === "Forecasting" || U === "Combo") && /* @__PURE__ */ a(
                Kw,
                {
                  showTooltip: Jt,
                  tooltipData: _t,
                  xScale: wt,
                  yScale: Lt,
                  width: lt,
                  le: !0,
                  height: Se,
                  xScaleNoPadding: En,
                  chartRef: n,
                  handleTooltipMouseOver: sn,
                  handleTooltipMouseOff: Bt,
                  isBrush: !1
                }
              ),
              U === "Forest Plot" && /* @__PURE__ */ a(
                dk,
                {
                  xScale: wt,
                  yScale: Lt,
                  seriesScale: bn,
                  width: Rt,
                  height: Qt,
                  getXAxisData: xe,
                  getYAxisData: Ge,
                  animatedChart: Ne,
                  visible: Ne,
                  handleTooltipMouseOver: sn,
                  handleTooltipMouseOff: Bt,
                  handleTooltipClick: pn,
                  tooltipData: _t,
                  showTooltip: Jt,
                  chartRef: n,
                  config: o,
                  forestPlotRightLabelRef: Ye
                }
              ),
              o.brush.active && o.xAxis.type !== "categorical" && /* @__PURE__ */ a(Aw, { xMax: lt, yMax: Se }),
              !["Paired Bar", "Box Plot", "Area Chart", "Scatter Plot", "Deviation Bar", "Forecasting", "Bar"].includes(
                U
              ) && !h && /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ a(
                xm,
                {
                  xScale: wt,
                  yScale: Lt,
                  getXAxisData: xe,
                  getYAxisData: Ge,
                  xMax: lt,
                  yMax: Se,
                  seriesStyle: o.runtime.series,
                  tooltipData: _t,
                  handleTooltipMouseOver: sn,
                  handleTooltipMouseOff: Bt
                }
              ) }),
              o.yAxis.anchors && o.yAxis.anchors.map((_, W) => {
                let he = Lt(_.value), N = 0;
                if (_.value && (o.yAxis.labelPlacement === "Below Bar" ? N = -6.5 + Number(o.series.length * o.barHeight) / o.series.length : N = 8, !!he))
                  return (
                    // prettier-ignore
                    /* @__PURE__ */ a(
                      an,
                      {
                        strokeDasharray: b(_.lineStyle),
                        stroke: _.color ? _.color : "rgba(0,0,0,1)",
                        className: "anchor-y",
                        from: { x: 0 + Cn, y: he - N },
                        to: { x: Rt - o.yAxis.rightAxisSize, y: he - N }
                      },
                      `yAxis-${_.value}--${W}`
                    )
                  );
              }),
              o.xAxis.anchors && o.xAxis.anchors.map((_, W) => {
                let he = G;
                ne === "horizontal" && (he = ce);
                let z = (() => {
                  let Y;
                  return Y = Tn(he) ? wt(w(_.value, !1)) : wt(_.value), (o.xAxis.type === "categorical" || o.xAxis.type === "date") && (Y = Y ? Y + (he.type === "categorical" || he.type === "date" ? wt.bandwidth() : 0) / 2 : 0), Y;
                })();
                if (z)
                  return (
                    // prettier-ignore
                    /* @__PURE__ */ a(
                      an,
                      {
                        strokeDasharray: b(_.lineStyle),
                        stroke: _.color ? _.color : "rgba(0,0,0,1)",
                        fill: _.color ? _.color : "rgba(0,0,0,1)",
                        className: "anchor-x",
                        from: { x: Number(z) + Number(Cn), y: 0 },
                        to: { x: Number(z) + Number(Cn), y: Se }
                      },
                      `xAxis-${_.value}--${W}`
                    )
                  );
              }),
              o.visualizationType !== "Bar" && o.visualizationType !== "Combo" && /* @__PURE__ */ a(
                Of,
                {
                  xScale: wt,
                  handleTooltipClick: pn,
                  handleTooltipMouseOff: Bt,
                  handleTooltipMouseOver: sn,
                  showTooltip: Jt,
                  hideTooltip: Yt,
                  tooltipData: _t,
                  yMax: Se,
                  width: Rt
                }
              ),
              _e && /* @__PURE__ */ a(
                dt,
                {
                  x: Number(o.yAxis.size) + Number(lt / 2),
                  y: Pt / 2 - (o.xAxis.padding || 0) / 2,
                  textAnchor: "middle",
                  children: o.chartMessage.noData
                }
              ),
              o.visual.horizontalHoverLine && _t && /* @__PURE__ */ a(
                qe,
                {
                  className: "horizontal-tooltip-line",
                  left: o.yAxis.size ? o.yAxis.size : 0,
                  children: /* @__PURE__ */ a(
                    an,
                    {
                      from: { x: 0, y: De.y },
                      to: { x: lt, y: De.y },
                      stroke: "black",
                      strokeWidth: 1,
                      pointerEvents: "none",
                      strokeDasharray: "5,5",
                      className: "horizontal-tooltip-line"
                    }
                  )
                },
                `tooltipLine-horizontal${De.y}${De.x}`
              ),
              o.visual.verticalHoverLine && _t && /* @__PURE__ */ a(qe, { className: "vertical-tooltip-line", children: /* @__PURE__ */ a(
                an,
                {
                  from: { x: De.x, y: 0 },
                  to: { x: De.x, y: Se },
                  stroke: "black",
                  strokeWidth: 1,
                  pointerEvents: "none",
                  strokeDasharray: "5,5",
                  className: "vertical-tooltip-line"
                }
              ) }, `tooltipLine-vertical${De.y}${De.x}`),
              /* @__PURE__ */ a(qe, { left: Number(o.runtime.yAxis.size), children: /* @__PURE__ */ a(
                Ff.Draggable,
                {
                  xScale: wt,
                  yScale: Lt,
                  xScaleAnnotation: nr,
                  xMax: lt,
                  svgRef: n,
                  onDragStateChange: T
                }
              ) }),
              !["Spark Line", "Forest Plot"].includes(U) && o.yAxis.type !== "categorical" && /* @__PURE__ */ a(
                hm,
                {
                  scale: Lt,
                  tickLength: pt ? 6 : 8,
                  left: Number(q.yAxis.size) - o.yAxis.axisPadding,
                  label: q.yAxis.label || q.yAxis.label,
                  stroke: "#333",
                  tickFormat: Hn,
                  numTicks: fn,
                  children: (_) => {
                    const W = o.orientation === "horizontal" ? (_.axisToPoint.y - _.axisFromPoint.y) / 2 : (_.axisFromPoint.y - _.axisToPoint.y) / 2, he = Se / _.ticks.length / 2 - Se / _.ticks.length * (1 - o.barThickness) + 5;
                    return /* @__PURE__ */ F(qe, { className: "left-axis", children: [
                      !o.yAxis.hideAxis && /* @__PURE__ */ a(
                        an,
                        {
                          from: _.axisFromPoint,
                          to: q.horizontal ? {
                            x: 0,
                            y: o.visualizationType === "Forest Plot" ? e : Number(L.horizontal)
                          } : _.axisToPoint,
                          stroke: "#000"
                        }
                      ),
                      Lt.domain()[0] < 0 && /* @__PURE__ */ a(
                        an,
                        {
                          from: { x: _.axisFromPoint.x, y: Lt(0) },
                          to: { x: lt, y: Lt(0) },
                          stroke: "#333"
                        }
                      ),
                      U === "Bar" && ne === "horizontal" && wt.domain()[0] < 0 && /* @__PURE__ */ a(
                        an,
                        {
                          from: { x: wt(0), y: 0 },
                          to: { x: wt(0), y: Se },
                          stroke: "#333",
                          strokeWidth: 2
                        }
                      ),
                      _.ticks.map((N, z) => {
                        const Y = _.ticks[0].to.y, be = 15, Oe = String(N.value).startsWith("1") || N.value === 0.1 ? "block" : "none", We = Oe === "block" ? 7 : 0, rt = { x: N.to.x - We, y: N.to.y }, Dt = _.ticks.length - 1 === z, Mt = Dt && J && le && !Vt, Xt = de ? ae ? -8 : -12 : Pk, tn = de ? 4 : 0, Zn = N.to.x - Xt, In = N.to.y - tn, or = de ? "end" : "middle", jn = J && de && le && Dt;
                        return /* @__PURE__ */ F(qe, { className: "vx-axis-tick", children: [
                          !q.yAxis.hideTicks && !de && !Mt && /* @__PURE__ */ a(
                            an,
                            {
                              from: N.from,
                              to: pt ? rt : N.to,
                              stroke: o.yAxis.tickColor,
                              display: ne === "horizontal" ? "none" : "block",
                              fontSize: Ft
                            },
                            `${N.value}--hide-hideTicks`
                          ),
                          ne === "horizontal" && X !== "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            dt,
                            {
                              transform: `translate(${N.to.x - 5}, ${o.isLollipopChart ? N.to.y - Y : N.to.y - Y + (Number(o.barHeight * o.runtime.series.length) - be) / 2}) rotate(-${o.runtime.horizontal && o.runtime.yAxis.tickRotation || 0})`,
                              verticalAnchor: "start",
                              textAnchor: "end",
                              fontSize: Ft,
                              children: N.formattedValue
                            }
                          ),
                          ne === "horizontal" && X === "stacked" && o.yAxis.labelPlacement === "On Date/Category Axis" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            dt,
                            {
                              transform: `translate(${N.to.x - 5}, ${N.to.y - Y + (Number(o.barHeight) - be) / 2}) rotate(-${q.horizontal ? q.yAxis.tickRotation : 0})`,
                              verticalAnchor: "start",
                              textAnchor: "end",
                              fontSize: Ft,
                              children: N.formattedValue
                            }
                          ),
                          ne === "horizontal" && U === "Paired Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            dt,
                            {
                              transform: `translate(${N.to.x - 5}, ${N.to.y - Y + Number(o.barHeight) / 2}) rotate(-${q.horizontal ? q.yAxis.tickRotation : 0})`,
                              textAnchor: "end",
                              verticalAnchor: "middle",
                              fontSize: Ft,
                              children: N.formattedValue
                            }
                          ),
                          ne === "horizontal" && U === "Deviation Bar" && !o.yAxis.hideLabel && /* @__PURE__ */ a(
                            dt,
                            {
                              transform: `translate(${N.to.x - 5}, ${o.isLollipopChart ? N.to.y - Y + 2 : N.to.y - Y + Number(o.barHeight) / 2}) rotate(-${q.horizontal ? q.yAxis.tickRotation : 0})`,
                              textAnchor: "end",
                              verticalAnchor: "middle",
                              fontSize: Ft,
                              children: N.formattedValue
                            }
                          ),
                          ne === "vertical" && U === "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ F(Be, { children: [
                            /* @__PURE__ */ a(
                              dt,
                              {
                                display: o.useLogScale ? Oe : "block",
                                dx: o.useLogScale ? -6 : 0,
                                x: o.runtime.horizontal ? N.from.x + 2 : N.to.x - 8.5,
                                y: N.to.y - 13 + (o.runtime.horizontal ? he : 0),
                                angle: -Number(o.yAxis.tickRotation) || 0,
                                verticalAnchor: o.runtime.horizontal ? "start" : "middle",
                                textAnchor: o.runtime.horizontal ? "start" : "end",
                                fill: o.yAxis.tickLabelColor,
                                fontSize: Ft,
                                children: o.runtime.seriesLabelsAll[N.formattedValue - 1]
                              }
                            ),
                            (O.length === 0 || O.includes(
                              o.runtime.seriesLabelsAll[N.formattedValue - 1]
                            )) && /* @__PURE__ */ a(
                              "rect",
                              {
                                x: 0 - Number(o.yAxis.size),
                                y: N.to.y - 8 + (o.runtime.horizontal ? he : 7),
                                width: Number(o.yAxis.size) + wt(wt.domain()[0]),
                                height: "2",
                                fill: i(o.runtime.seriesLabelsAll[N.formattedValue - 1])
                              }
                            )
                          ] }),
                          ne === "vertical" && U !== "Paired Bar" && U !== "Bump Chart" && !o.yAxis.hideLabel && /* @__PURE__ */ F(Be, { children: [
                            J && Dt && !de && /* @__PURE__ */ a(
                              ip,
                              {
                                innerRef: ot,
                                display: pt ? Oe : "block",
                                dx: pt ? -6 : 0,
                                x: Zn,
                                y: In,
                                angle: -Number(o.yAxis.tickRotation) || 0,
                                verticalAnchor: or,
                                textAnchor: Vt ? "end" : "start",
                                fill: o.yAxis.tickLabelColor,
                                stroke: "#fff",
                                paintOrder: "stroke",
                                strokeLinejoin: "round",
                                style: { whiteSpace: "pre-wrap" },
                                fontSize: Ft,
                                children: le
                              }
                            ),
                            /* @__PURE__ */ a(
                              ip,
                              {
                                innerRef: (Ar) => Dt && (ut.current = Ar),
                                display: pt ? Oe : "block",
                                dx: pt ? -6 : 0,
                                x: Vt ? Zn - Fe : Zn,
                                y: In + (o.runtime.horizontal ? he : 0),
                                angle: -Number(o.yAxis.tickRotation) || 0,
                                verticalAnchor: o.runtime.horizontal ? "start" : or,
                                textAnchor: o.runtime.horizontal || de ? "start" : "end",
                                fill: o.yAxis.tickLabelColor,
                                stroke: "#fff",
                                disableStroke: !de,
                                strokeLinejoin: "round",
                                paintOrder: "stroke",
                                style: { whiteSpace: "pre-wrap" },
                                fontSize: Ft,
                                children: `${N.formattedValue}${jn ? le : ""}`
                              }
                            )
                          ] })
                        ] }, `vx-tick-${N.value}-${z}`);
                      }),
                      /* @__PURE__ */ a(
                        dt,
                        {
                          className: "y-label",
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          transform: `translate(${-1 * q.yAxis.size + qt}, ${W}) rotate(-90)`,
                          fontWeight: "bold",
                          fill: o.yAxis.labelColor,
                          fontSize: Gt,
                          children: _.label
                        }
                      )
                    ] });
                  }
                }
              ),
              o.yAxis.type === "categorical" && o.orientation === "vertical" && /* @__PURE__ */ a(
                fk,
                {
                  max: xt,
                  maxValue: ye,
                  height: Pt,
                  xMax: lt,
                  yMax: Se,
                  leftSize: Number(q.yAxis.size) - o.yAxis.axisPadding
                }
              ),
              An && /* @__PURE__ */ a(
                lw,
                {
                  scale: jt,
                  left: Number(Rt - o.yAxis.rightAxisSize),
                  label: o.yAxis.rightLabel,
                  tickFormat: (_) => y(_, "right"),
                  numTicks: q.yAxis.rightNumTicks || void 0,
                  labelOffset: 45,
                  children: (_) => {
                    const W = o.orientation === "horizontal" ? (_.axisToPoint.y - _.axisFromPoint.y) / 2 : (_.axisFromPoint.y - _.axisToPoint.y) / 2, he = Se / _.ticks.length / 2 - Se / _.ticks.length * (1 - o.barThickness) + 5;
                    return /* @__PURE__ */ F(qe, { className: "right-axis", children: [
                      _.ticks.map((N, z) => /* @__PURE__ */ F(qe, { className: "vx-axis-tick", children: [
                        !q.yAxis.rightHideTicks && /* @__PURE__ */ a(
                          an,
                          {
                            from: N.from,
                            to: N.to,
                            display: q.horizontal ? "none" : "block",
                            stroke: o.yAxis.rightAxisTickColor
                          }
                        ),
                        q.yAxis.rightGridLines ? /* @__PURE__ */ a(an, { from: { x: N.from.x + lt, y: N.from.y }, to: N.from, stroke: "#d6d6d6" }) : "",
                        !o.yAxis.rightHideLabel && /* @__PURE__ */ a(
                          dt,
                          {
                            x: N.to.x,
                            y: N.to.y + (q.horizontal ? he : 0),
                            verticalAnchor: q.horizontal ? "start" : "middle",
                            textAnchor: "start",
                            fill: o.yAxis.rightAxisTickLabelColor,
                            fontSize: Ft,
                            children: N.formattedValue
                          }
                        )
                      ] }, `vx-tick-${N.value}-${z}`)),
                      !o.yAxis.rightHideAxis && /* @__PURE__ */ a(an, { from: _.axisFromPoint, to: _.axisToPoint, stroke: "#333" }),
                      /* @__PURE__ */ a(
                        dt,
                        {
                          className: "y-label",
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          transform: `translate(${o.yAxis.rightLabelOffsetSize ? o.yAxis.rightLabelOffsetSize : 0}, ${W}) rotate(-90)`,
                          fontWeight: "bold",
                          fill: o.yAxis.rightAxisLabelColor,
                          fontSize: Gt,
                          children: _.label
                        }
                      )
                    ] });
                  }
                }
              ),
              me && o.topAxis.hasLine && /* @__PURE__ */ a(
                hw,
                {
                  stroke: "#333",
                  left: Number(q.yAxis.size),
                  scale: wt,
                  hideTicks: !0,
                  hideZero: !0,
                  tickLabelProps: () => ({
                    fill: "transparent"
                  })
                }
              ),
              U !== "Paired Bar" && U !== "Spark Line" && /* @__PURE__ */ a(
                tc,
                {
                  innerRef: yt,
                  top: q.horizontal && o.visualizationType !== "Forest Plot" ? Number(L.horizontal) + Number(o.xAxis.axisPadding) : o.visualizationType === "Forest Plot" ? Se + Number(o.xAxis.axisPadding) : Se,
                  left: o.visualizationType !== "Forest Plot" ? Number(q.yAxis.size) : 0,
                  label: o[et].label,
                  tickFormat: Vn,
                  scale: wt,
                  stroke: "#333",
                  numTicks: cn ? Pn : _n,
                  tickStroke: "#333",
                  tickValues: o.runtime.xAxis.manual ? qw(Ze, wt, yn ? _n : yr(), o) : o.runtime.xAxis.type === "date" ? Ze : void 0,
                  children: (_) => {
                    var qr;
                    const W = o.series.some((Tt) => Tt.dynamicCategory);
                    o.runtime.xAxis.type === "date" && !o.runtime.xAxis.manual && !W && (_.ticks = Zw(o, _, Ze, p));
                    const he = cn && wt.ticks(_n).map(
                      (Tt) => _.ticks.findIndex(
                        (xn) => (typeof xn.value == "number" ? xn.value : xn.value.getTime()) === Tt.getTime()
                      )
                    ).slice(0, 2).reduce((Tt, xn) => xn - Tt), N = cn ? [..._.ticks].reverse().filter((Tt, xn) => xn % he === 0).reverse().map((Tt, xn, Un) => ({
                      ...Tt,
                      // reformat in case showYearsOnce, since first month of year may have changed
                      formattedValue: Vn(Tt.value, xn, Un)
                    })) : _.ticks, z = bt + dh, Y = (Tt) => /\s/.test(Tt), be = N.some((Tt) => Y(Tt.value)), Oe = Math.max(
                      ...N.map((Tt) => mr(Tt.formattedValue, Zt))
                    ), We = be ? 180 : 100, rt = N.map((Tt) => mr(Tt.formattedValue, Zt)), Dt = rt.reduce((Tt, xn) => Tt + xn, We), Mt = (lt - Dt) / (N.length - 1), dn = 40, Xt = Rt / N.length - Yu * 2 - dn;
                    let tn = [0];
                    for (let Tt = 1; Tt < rt.length; Tt++)
                      tn[Tt] = tn[Tt - 1] + rt[Tt - 1] + Mt;
                    const Zn = (qr = yt == null ? void 0 : yt.current) == null ? void 0 : qr.getBBox().height;
                    o.xAxis.axisBBox = Zn;
                    const In = rt[rt.length - 1], jn = tn[tn.length - 1] + In + In / 2, Ar = lt - In, ui = rt.some((Tt) => Tt > Xt) || // Force wrap if any tick is too long
                    o.xAxis.showYearsOnce || // Force wrap when showing years once so it's easier to read
                    jn > Ar, na = ui && o.isResponsiveTicks ? Oe + hh + 20 : 0;
                    return o.dynamicMarginTop = na, o.xAxis.tickWidthMax = Oe, /* @__PURE__ */ F(qe, { className: "bottom-axis", width: c[0], children: [
                      N.map((Tt, xn, Un) => {
                        const Lr = String(Tt.value).startsWith("1") || Tt.value === 0.1 ? "block" : "none", Zr = Lr === "block" ? 16 : hh, $t = { x: Tt.to.x, y: Zr }, vr = 100 / Un.length;
                        o.yAxis.tickRotation = o.isResponsiveTicks && o.orientation === "horizontal" ? 0 : o.yAxis.tickRotation, o.xAxis.tickRotation = o.isResponsiveTicks && o.orientation === "vertical" ? 0 : o.xAxis.tickRotation;
                        const kn = o.isResponsiveTicks && ui ? -Number(o.xAxis.maxTickRotation) || -90 : -Number(o.runtime.xAxis.tickRotation);
                        return /* @__PURE__ */ F(qe, { className: "vx-axis-tick", children: [
                          !o.xAxis.hideTicks && /* @__PURE__ */ a(
                            an,
                            {
                              from: Tt.from,
                              to: ne === "horizontal" && pt ? $t : Tt.to,
                              stroke: o.xAxis.tickColor,
                              strokeWidth: Lr === "block" && pt ? 1.3 : 1
                            }
                          ),
                          !o.xAxis.hideLabel && /* @__PURE__ */ a(
                            dt,
                            {
                              innerRef: (Er) => tt.current[xn] = Er,
                              dy: o.orientation === "horizontal" && pt ? 8 : 0,
                              display: o.orientation === "horizontal" && pt ? Lr : "block",
                              x: Tt.to.x,
                              y: Tt.to.y + Yu,
                              angle: kn,
                              verticalAnchor: kn < -50 ? "middle" : "start",
                              textAnchor: kn ? "end" : "middle",
                              width: ui && !o.isResponsiveTicks && !Number(o[et].tickRotation) ? vr : void 0,
                              fill: o.xAxis.tickLabelColor,
                              fontSize: Ft,
                              children: Tt.formattedValue
                            }
                          )
                        ] }, `vx-tick-${Tt.value}-${xn}`);
                      }),
                      !o.xAxis.hideAxis && /* @__PURE__ */ a(an, { from: _.axisFromPoint, to: _.axisToPoint, stroke: "#333" }),
                      /* @__PURE__ */ a(
                        dt,
                        {
                          innerRef: $e,
                          className: "x-axis-title-label",
                          x: lt / 2,
                          y: hn ? 0 : z,
                          textAnchor: "middle",
                          verticalAnchor: "start",
                          fontWeight: "bold",
                          fill: o.xAxis.labelColor,
                          fontSize: Gt,
                          children: _.label
                        }
                      )
                    ] });
                  }
                }
              )
            ]
          }
        ),
        !m && _t && Object.entries(_t.data).length > 0 && on && Jt && !((P = _t == null ? void 0 : _t.data) != null && P.some((_) => _.some((W) => W === void 0))) && _t.dataYPosition && _t.dataXPosition && /* @__PURE__ */ F(Be, { children: [
          /* @__PURE__ */ a("style", { children: `.tooltip {background-color: rgba(255,255,255, ${o.tooltips.opacity / 100}) !important;` }),
          /* @__PURE__ */ a("style", { children: ".tooltip {max-width:300px} !important; word-wrap: break-word; " }),
          /* @__PURE__ */ a(
            sg,
            {
              className: "tooltip cdc-open-viz-module",
              left: wn,
              top: Ut,
              children: /* @__PURE__ */ a("ul", { children: typeof _t == "object" && Object.entries(_t.data).filter(([_, W]) => Array.isArray(W) && !W.includes(void 0)).map((_, W) => /* @__PURE__ */ a(rr, { item: _ }, W)) })
            },
            Math.random()
          )
        ] }),
        o.visualizationType === "Bump Chart" && /* @__PURE__ */ a(
          ReactTooltip,
          {
            id: "bump-chart",
            variant: "light",
            arrowColor: "rgba(0,0,0,0)",
            className: "tooltip",
            style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
          }
        ),
        ke() && !m && /* @__PURE__ */ a(
          ReactTooltip,
          {
            id: `cdc-open-viz-tooltip-${q.uniqueId}`,
            variant: "light",
            arrowColor: "rgba(0,0,0,0)",
            className: "tooltip",
            style: { background: `rgba(255,255,255, ${o.tooltips.opacity / 100})`, color: "black" }
          }
        ),
        /* @__PURE__ */ a("div", { className: "animation-trigger", ref: st })
      ]
    }
  ) });
});
const Nk = (e) => {
  var ce;
  const { width: t, height: n } = e, {
    transformedData: r,
    config: i,
    parseDate: o,
    formatDate: h,
    seriesHighlight: d,
    formatNumber: c,
    colorScale: p,
    handleChartAriaLabels: y
  } = fe.useContext(ft);
  let g = Number(t);
  const { minValue: b, maxValue: T } = qc(i, r), m = { top: 5, right: 20, bottom: 10, left: 10 }, C = Number(n), w = g - i.runtime.yAxis.size, S = C - m.top - 20, B = (q) => i.runtime.xAxis.type === "date" ? o(q[i.runtime.originalXAxis.dataKey]).getTime() : q[i.runtime.originalXAxis.dataKey], M = (q, re) => q[re];
  let D, O;
  const { max: L, min: U } = i.runtime.yAxis, X = Number(L) >= Number(T), ne = Number(U) <= Number(b);
  if (r) {
    let q = Number(U && ne ? U : b), re = Number(L && X ? L : Number.MIN_VALUE);
    if (re === Number.MIN_VALUE && (re = T), i.runtime.yAxis.paddingPercent) {
      let j = (re - q) * i.runtime.yAxis.paddingPercent;
      q -= j, re += j;
    }
    let $ = r.map((j) => B(j));
    i.runtime.horizontal ? (D = zn({
      domain: [q, re],
      range: [0, w]
    }), O = i.runtime.xAxis.type === "date" ? zn({ domain: [Math.min(...$), Math.max(...$)] }) : ts({ domain: $, padding: 0.5 }), ts({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, S]
    }), O.rangeRound([0, S])) : (q = q < 0 ? q * 1.11 : q, O = zn({
      domain: [q, re],
      range: [S - m.bottom, m.top]
    }), D = ts({
      domain: $,
      range: [m.left, g - m.right]
    }), ts({
      domain: i.runtime.barSeriesKeys || i.runtime.seriesKeys,
      range: [0, w]
    }));
  }
  const G = [D.domain()[0], D.domain()[D.domain().length - 1]];
  return /* @__PURE__ */ a(Xr, { component: "SparkLine", children: /* @__PURE__ */ F(
    "svg",
    {
      role: "img",
      "aria-label": y(i),
      width: t,
      height: 100,
      className: "sparkline",
      tabIndex: 0,
      children: [
        /* @__PURE__ */ a("title", { children: `Spark line graphic with the title ${i.title ? i.title : "No Title Found"}` }),
        ((ce = i.runtime.lineSeriesKeys) == null ? void 0 : ce.length) > 0 ? i.runtime.lineSeriesKeys : i.runtime.seriesKeys.map((q, re) => /* @__PURE__ */ F(Be, { children: [
          /* @__PURE__ */ F(
            qe,
            {
              style: { width: g },
              className: "sparkline-group",
              opacity: i.legend.behavior === "highlight" && d.length > 0 && d.indexOf(q) === -1 ? 0.5 : 1,
              display: i.legend.behavior === "highlight" || d.length === 0 || d.indexOf(q) !== -1 ? "block" : "none",
              children: [
                i.labels && r.map(($, j) => /* @__PURE__ */ a(qe, { children: /* @__PURE__ */ a(
                  dt,
                  {
                    x: D(B($)),
                    y: O(M($, q)),
                    fill: p ? p(
                      i.runtime.seriesLabels ? i.runtime.seriesLabels[q] : q
                    ) : "#000",
                    textAnchor: "middle",
                    children: c($[q])
                  }
                ) }, `series-${q}-point-${j}`)),
                /* @__PURE__ */ a(
                  Gr,
                  {
                    curve: Uc,
                    data: r,
                    x: ($) => D(B($)),
                    y: ($) => O(M($, q)),
                    stroke: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[q] : q) : "#000",
                    strokeWidth: 2,
                    strokeOpacity: 1,
                    shapeRendering: "geometricPrecision",
                    markerEnd: `url(#arrow--${re})`
                  }
                ),
                /* @__PURE__ */ a(
                  Dm,
                  {
                    id: `arrow--${re}`,
                    refX: 2,
                    size: 6,
                    markerEnd: `url(#arrow--${re})`,
                    strokeOpacity: 1,
                    fillOpacity: 1,
                    fill: p ? p(i.runtime.seriesLabels ? i.runtime.seriesLabels[q] : q) : "#000"
                  }
                )
              ]
            },
            `series-${q}`
          ),
          /* @__PURE__ */ a(
            tc,
            {
              top: S + m.top,
              hideAxisLine: !0,
              hideTicks: !0,
              scale: D,
              tickValues: G,
              tickFormat: ($) => i.xAxis.type === "date" ? h($) : null,
              stroke: "black",
              tickStroke: "black",
              tickLabelProps: () => ({
                fill: "black",
                fontSize: 11,
                textAnchor: "middle"
              })
            }
          )
        ] }))
      ]
    }
  ) });
};
var Rk = ["flexDirection", "alignItems", "margin", "display", "children"];
function Xh() {
  return Xh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Xh.apply(this, arguments);
}
function Dk(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Dl(e) {
  var t = e.flexDirection, n = t === void 0 ? "row" : t, r = e.alignItems, i = r === void 0 ? "center" : r, o = e.margin, h = o === void 0 ? "0" : o, d = e.display, c = d === void 0 ? "flex" : d, p = e.children, y = Dk(e, Rk);
  return /* @__PURE__ */ Ie.createElement("div", Xh({
    className: "visx-legend-item",
    style: {
      display: c,
      alignItems: i,
      flexDirection: n,
      margin: h
    }
  }, y), p);
}
Dl.propTypes = {
  alignItems: Re.string,
  margin: Re.oneOfType([Re.string, Re.number]),
  children: Re.node,
  display: Re.string
};
var Ok = ["flex", "label", "margin", "align", "children"];
function qh() {
  return qh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, qh.apply(this, arguments);
}
function Mk(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Ol(e) {
  var t = e.flex, n = t === void 0 ? "1" : t, r = e.label, i = e.margin, o = i === void 0 ? "5px 0" : i, h = e.align, d = h === void 0 ? "left" : h, c = e.children, p = Mk(e, Ok);
  return /* @__PURE__ */ Ie.createElement("div", qh({
    className: "visx-legend-label",
    style: {
      justifyContent: d,
      display: "flex",
      flex: n,
      margin: o
    }
  }, p), c || r);
}
Ol.propTypes = {
  align: Re.string,
  label: Re.node,
  flex: Re.oneOfType([Re.string, Re.number]),
  margin: Re.oneOfType([Re.string, Re.number]),
  children: Re.node
};
function Zh() {
  return Zh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Zh.apply(this, arguments);
}
function Bf(e) {
  var t = e.fill, n = e.width, r = e.height, i = e.style;
  return /* @__PURE__ */ Ie.createElement("div", {
    style: Zh({
      width: n,
      height: r,
      background: t
    }, i)
  });
}
Bf.propTypes = {
  fill: Re.string,
  width: Re.oneOfType([Re.string, Re.number]),
  height: Re.oneOfType([Re.string, Re.number])
};
function xg(e) {
  var t = e.fill, n = e.width, r = e.height, i = e.style, o = typeof n == "string" || typeof n > "u" ? 0 : n, h = typeof r == "string" || typeof r > "u" ? 0 : r, d = Math.max(o, h), c = d / 2;
  return /* @__PURE__ */ Ie.createElement("svg", {
    width: d,
    height: d
  }, /* @__PURE__ */ Ie.createElement(qe, {
    top: c,
    left: c
  }, /* @__PURE__ */ Ie.createElement("circle", {
    r: c,
    fill: t,
    style: i
  })));
}
xg.propTypes = {
  fill: Re.string,
  width: Re.oneOfType([Re.string, Re.number]),
  height: Re.oneOfType([Re.string, Re.number])
};
function Sg(e) {
  var t = e.fill, n = e.width, r = e.height, i = e.style, o = typeof r == "string" || typeof r > "u" ? 0 : r, h = typeof (i == null ? void 0 : i.strokeWidth) == "number" ? i == null ? void 0 : i.strokeWidth : 2;
  return /* @__PURE__ */ Ie.createElement("svg", {
    width: n,
    height: r
  }, /* @__PURE__ */ Ie.createElement(qe, {
    top: o / 2 - h / 2
  }, /* @__PURE__ */ Ie.createElement("line", {
    x1: 0,
    x2: n,
    y1: 0,
    y2: 0,
    stroke: t,
    strokeWidth: h,
    style: i
  })));
}
Sg.propTypes = {
  fill: Re.string,
  width: Re.oneOfType([Re.string, Re.number]),
  height: Re.oneOfType([Re.string, Re.number])
};
function Sl() {
  return Sl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Sl.apply(this, arguments);
}
var ph = function() {
};
function Ik(e) {
  var t = e.shape, n = t === void 0 ? "rect" : t, r = e.fill, i = r === void 0 ? ph : r, o = e.size, h = o === void 0 ? ph : o, d = e.width, c = e.height, p = e.label, y = e.item, g = e.itemIndex, b = e.shapeStyle, T = b === void 0 ? ph : b, m = {
    width: d,
    height: c,
    item: y,
    itemIndex: g,
    label: p,
    fill: i(Sl({}, p)),
    size: h(Sl({}, p)),
    style: T(Sl({}, p))
  };
  return typeof n == "string" ? n === "circle" ? /* @__PURE__ */ Ie.createElement(xg, m) : n === "line" ? /* @__PURE__ */ Ie.createElement(Sg, m) : /* @__PURE__ */ Ie.createElement(Bf, m) : /* @__PURE__ */ Ie.isValidElement(n) ? /* @__PURE__ */ Ie.cloneElement(n, m) : n ? /* @__PURE__ */ Ie.createElement(n, m) : null;
}
function Nc() {
  return Nc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Nc.apply(this, arguments);
}
function wg(e) {
  var t = e.shape, n = t === void 0 ? Bf : t, r = e.width, i = e.height, o = e.margin, h = e.label, d = e.item, c = e.itemIndex, p = e.fill, y = e.size, g = e.shapeStyle;
  return /* @__PURE__ */ Ie.createElement("div", {
    className: "visx-legend-shape",
    style: {
      display: "flex",
      width: y ? y(Nc({}, h)) : r,
      height: y ? y(Nc({}, h)) : i,
      margin: o
    }
  }, Ik({
    shape: n,
    item: d,
    itemIndex: c,
    label: h,
    width: r,
    height: i,
    fill: p,
    shapeStyle: g
  }));
}
wg.propTypes = {
  itemIndex: Re.number.isRequired,
  margin: Re.oneOfType([Re.string, Re.number]),
  width: Re.oneOfType([Re.string, Re.number]),
  height: Re.oneOfType([Re.string, Re.number])
};
function kg(e) {
  return e && typeof e == "object" && "value" in e && typeof e.value < "u" ? e.value : e;
}
function Sm(e) {
  return String(kg(e));
}
function Fk(e) {
  var t = e.scale, n = e.labelFormat;
  return function(r, i) {
    return {
      datum: r,
      index: i,
      text: "" + n(r, i),
      value: t(r)
    };
  };
}
var Bk = ["className", "style", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "shapeStyle", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "legendLabelProps", "children"];
function wl() {
  return wl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, wl.apply(this, arguments);
}
function zk(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var $k = {
  display: "flex"
};
function Tg(e) {
  var t = e.className, n = e.style, r = n === void 0 ? $k : n, i = e.scale, o = e.shape, h = e.domain, d = e.fill, c = d === void 0 ? Sm : d, p = e.size, y = p === void 0 ? Sm : p, g = e.labelFormat, b = g === void 0 ? kg : g, T = e.labelTransform, m = T === void 0 ? Fk : T, C = e.shapeWidth, w = C === void 0 ? 15 : C, S = e.shapeHeight, B = S === void 0 ? 15 : S, M = e.shapeMargin, D = M === void 0 ? "2px 4px 2px 0" : M, O = e.shapeStyle, L = e.labelAlign, U = L === void 0 ? "left" : L, X = e.labelFlex, ne = X === void 0 ? "1" : X, G = e.labelMargin, ce = G === void 0 ? "0 4px" : G, q = e.itemMargin, re = q === void 0 ? "0" : q, $ = e.direction, j = $ === void 0 ? "column" : $, oe = e.itemDirection, ie = oe === void 0 ? "row" : oe, le = e.legendLabelProps, J = e.children, de = zk(e, Bk), ae = h || ("domain" in i ? i.domain() : []), Z = m({
    scale: i,
    labelFormat: b
  }), ye = ae.map(Z);
  return J ? /* @__PURE__ */ Ie.createElement(Ie.Fragment, null, J(ye)) : /* @__PURE__ */ Ie.createElement("div", {
    className: Sn("visx-legend", t),
    style: wl({}, r, {
      flexDirection: j
    })
  }, ye.map(function(ue, ve) {
    return /* @__PURE__ */ Ie.createElement(Dl, wl({
      key: "legend-" + ue.text + "-" + ve,
      margin: re,
      flexDirection: ie
    }, de), /* @__PURE__ */ Ie.createElement(wg, {
      shape: o,
      height: B,
      width: w,
      margin: D,
      item: ae[ve],
      itemIndex: ve,
      label: ue,
      fill: c,
      size: y,
      shapeStyle: O
    }), /* @__PURE__ */ Ie.createElement(Ol, wl({
      label: ue.text,
      flex: ne,
      margin: ce,
      align: U
    }, le)));
  }));
}
Tg.propTypes = {
  children: Re.func,
  className: Re.string,
  domain: Re.array,
  shapeWidth: Re.oneOfType([Re.string, Re.number]),
  shapeHeight: Re.oneOfType([Re.string, Re.number]),
  shapeMargin: Re.oneOfType([Re.string, Re.number]),
  labelAlign: Re.string,
  labelFlex: Re.oneOfType([Re.string, Re.number]),
  labelMargin: Re.oneOfType([Re.string, Re.number]),
  itemMargin: Re.oneOfType([Re.string, Re.number]),
  fill: Re.func,
  size: Re.func,
  shapeStyle: Re.func
};
function Cg(e) {
  return /* @__PURE__ */ Ie.createElement(Tg, e);
}
const Hk = (e) => {
  const { position: t, singleRow: n, verticalSorted: r, hideBorder: i } = e.legend, o = {
    left: "left",
    right: "right",
    bottom: "bottom",
    top: "top"
  }, h = {
    bottom: n ? ["single-row", "bottom"] : ["double-column", "bottom"],
    top: n ? ["single-row", "top"] : ["double-column", "top"]
  }, d = ["legend-container", o[t]].filter(Boolean), c = ["legend-container__inner", ...h[t] || []];
  ["bottom", "top"].includes(t) && r && c.push("vertical-sorted");
  const p = (["right", "left"].includes(t) || !t) && i.side, y = ["top", "bottom"].includes(t) && i.topBottom;
  return p || y ? d.push("border-0", "p-0") : d.push("p-3"), {
    containerClasses: d,
    innerClasses: c
  };
}, Vk = (e, t, n) => {
  const i = t([{ datum: "", index: 0, text: "", value: "" }]), o = e.legend.colorCode ? i.map((d) => d == null ? void 0 : d.value) : (n == null ? void 0 : n.range()) ?? [], h = e.legend.colorCode ? i.map((d) => (d == null ? void 0 : d.text) || (d == null ? void 0 : d.datum)) : (n == null ? void 0 : n.domain()) ?? [];
  return { colors: o, labels: h };
}, Wk = (e, t) => e && t.legend.hide || !e ? "0px" : e && t.brush.active && !t.legend.hide ? `${27 + t.brush.height + 25}px` : "27px", jk = (e, t) => {
  var o, h, d;
  const n = ((o = t.legend) == null ? void 0 : o.position) === "top" && !t.legend.hide, r = !t.legend.hideSuppressionLink && t.visualizationSubType !== "stacked" && ((h = t.preliminaryData) == null ? void 0 : h.some((c) => c.label && c.type === "suppression" && c.value && ((c == null ? void 0 : c.style) || c.symbol)));
  let i = 0;
  return n && (i = 27), n && ((d = t.dataFormat) != null && d.onlyShowTopPrefixSuffix) && (i += 9), e && (i += 9), r && (i += 40), `${i}px`;
};
const Uk = ({ linkText: e, href: t = null, tooltipOpacity: n = 100, tooltipContent: r }) => /* @__PURE__ */ F(Be, { children: [
  /* @__PURE__ */ a(
    "a",
    {
      className: "tooltip-link",
      "data-tooltip-content": r,
      "data-tooltip-id": "supression-tooltip",
      href: t,
      children: e
    }
  ),
  /* @__PURE__ */ a(
    $m,
    {
      id: "supression-tooltip",
      place: "top",
      effect: "solid",
      variant: "light",
      style: {
        background: `rgba(255, 255, 255, ${n})`,
        color: "var(--cool-gray-90)",
        padding: "9px 18px",
        boxShadow: "0px 2px 2px rgba(28, 29, 31, 0.45)",
        maxWidth: "239px",
        fontSize: "var(--filter-label-font-size)",
        fontFamily: "var(--app-font-main)",
        borderRadius: "4px"
      }
    }
  )
] }), Kk = ({ config: e, isLegendBottom: t }) => {
  const { preliminaryData: n, visualizationType: r, visualizationSubType: i, legend: o } = e, h = () => (n == null ? void 0 : n.some((b) => b.label && b.type === "effect" && b.style !== "Filled Circles")) && ["Line", "Combo"].includes(r), d = () => !o.hideSuppressedLabels && (n == null ? void 0 : n.some(
    (b) => b.label && b.displayLegend && b.type === "suppression" && b.value && ((b == null ? void 0 : b.style) || b.symbol)
  )) && (r === "Bar" && i === "regular" || r === "Line" || r === "Combo"), c = () => n == null ? void 0 : n.map(
    (b, T) => b.label && b.type === "effect" && b.style && /* @__PURE__ */ F("div", { className: "legend-preliminary", children: [
      /* @__PURE__ */ a("span", { className: b.symbol, children: b.lineCode }),
      /* @__PURE__ */ a("p", { children: b.label })
    ] }, T)
  ), p = () => {
    const b = (T) => T ? {
      color: "#777772"
    } : null;
    return n == null ? void 0 : n.map((T, m) => {
      if (!T.displayLegend || T.type !== "suppression")
        return null;
      const C = "legend-preliminary", w = m + r;
      return r === "Bar" ? /* @__PURE__ */ F("div", { style: b(T.displayGray), className: `${C} ${T.symbol}`, children: [
        /* @__PURE__ */ a("span", { className: T.symbol, children: T.iconCode }),
        /* @__PURE__ */ a("p", { className: T.type, children: T.label })
      ] }, w) : r === "Line" ? /* @__PURE__ */ F("div", { style: b(T.displayGray), className: C, children: [
        /* @__PURE__ */ a("span", { children: T.lineCode }),
        /* @__PURE__ */ a("p", { className: T.type, children: T.label })
      ] }, w) : r === "Combo" ? /* @__PURE__ */ F(Ie.Fragment, { children: [
        T.symbol && T.iconCode && /* @__PURE__ */ F("div", { style: b(T.displayGray), className: `${C} ${T.symbol}`, children: [
          /* @__PURE__ */ a("span", { className: T.symbol, children: T.iconCode }),
          /* @__PURE__ */ a("p", { className: T.type, children: T.label })
        ] }, w),
        T.style && T.lineCode && /* @__PURE__ */ F("div", { style: b(T.displayGray), className: C, children: [
          /* @__PURE__ */ a("span", { children: T.lineCode }),
          /* @__PURE__ */ a("p", { children: T.label })
        ] }, w)
      ] }) : null;
    });
  }, y = () => o.singleRow && t ? "legend-container__inner bottom single-row" : "", g = () => !e.legend.hideSuppressionLink && e.visualizationSubType !== "stacked" && (n == null ? void 0 : n.some((b) => b.label && b.type === "suppression" && b.value && ((b == null ? void 0 : b.style) || b.symbol)));
  return /* @__PURE__ */ F(Ie.Fragment, { children: [
    h() && /* @__PURE__ */ F(Ie.Fragment, { children: [
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("div", { className: y(), children: c() })
    ] }),
    d() && /* @__PURE__ */ F(Ie.Fragment, { children: [
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("div", { className: y(), children: p() })
    ] }),
    g() && /* @__PURE__ */ a("div", { className: "legend-container__outer link-container", children: /* @__PURE__ */ F("p", { children: [
      "This chart contains",
      /* @__PURE__ */ a(
        Uk,
        {
          tooltipContent: `Data is
                           suppressed to maintain statistical reliability.
                            This occurs when the number of respondents or 
                            reported values does not meet the minimum
                             reporting threshold.`,
          linkText: "suppressed data",
          href: null,
          tooltipOpacity: e.tooltips.opacity
        }
      )
    ] }) })
  ] });
}, Ag = (e) => {
  switch (e) {
    case "dashed-sm":
      return "5 5";
    case "Dashed Small":
      return "5 5";
    case "dashed-md":
      return "10 5";
    case "Dashed Medium":
      return "10 5";
    case "dashed-lg":
      return "15 5";
    case "Dashed Large":
      return "15 5";
    default:
      return 0;
  }
}, Gk = [
  _m,
  Pm,
  ac,
  Nm,
  ac,
  If,
  ({ fill: e }) => /* @__PURE__ */ a(Qh, { children: /* @__PURE__ */ a(dt, { fill: e, fontSize: 14, textAnchor: "middle", verticalAnchor: "middle", children: "⬟" }) })
], Yk = (e) => {
  var d;
  const { config: t, label: n, index: r } = e, i = r === 4, o = Gk[t.visual.lineDatapointSymbol === "standard" && r < t.visual.maximumShapeAmount ? r : 0], h = `translate(15, 3) ${i ? "rotate(180)" : ""}`;
  return /* @__PURE__ */ F("svg", { width: 30, height: 10, style: { overflow: "visible" }, className: "me-2", children: [
    /* @__PURE__ */ a(
      an,
      {
        from: { x: 0, y: 3 },
        to: { x: 30, y: 3 },
        stroke: n.value,
        strokeWidth: 2,
        strokeDasharray: Ag(((d = t.series[r]) == null ? void 0 : d.type) || "")
      }
    ),
    /* @__PURE__ */ a("g", { display: t.legend.hasShape ? "block" : "none", transform: h, children: /* @__PURE__ */ a(o, { fillOpacity: 1, fill: n.value }) })
  ] });
};
const Xk = ({ formatLabels: e }) => {
  const {
    highlight: t,
    seriesHighlight: n,
    colorScale: r,
    transformedData: i,
    config: o,
    currentViewport: h
  } = fe.useContext(ft), c = ((T, m) => {
    const C = /* @__PURE__ */ new Set();
    return T.forEach((w) => {
      o.series.forEach((S) => {
        w[m] && w[S.dataKey] && C.add(w[m]);
      });
    }), Array.from(C);
  })(i, o.legend.groupBy), p = ["legend-group", "container", o.legend.position, h, "row"], y = h === "xs" ? "col-12" : h === "sm" ? "col-6" : h === "md" ? "col-4" : "col-3";
  let b = ["legend-group group-item", o.legend.position === "bottom" || o.legend.position === "top" ? y : "col-12"];
  return /* @__PURE__ */ a("div", { className: p.join(" "), children: c.map((T) => /* @__PURE__ */ F("div", { className: b.join(" "), children: [
    /* @__PURE__ */ a("div", { children: /* @__PURE__ */ a("p", { className: "legend-group group-label", children: T }) }),
    /* @__PURE__ */ a(Cg, { scale: r, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0", children: (m) => e(m).filter((C) => {
      const w = o.legend.groupBy || "";
      return i.some((S) => S[w] === T && S[C.text] !== void 0 && S[C.text] !== "NA");
    }).map((C, w) => {
      let S = ["legend-group", "group-item"];
      return n.length && (n.includes(C.datum) ? S.push("highlighted") : S.push("inactive")), /* @__PURE__ */ F(
        Dl,
        {
          alignItems: "start",
          className: S.join(" "),
          onClick: (B) => {
            B.preventDefault(), t(C);
          },
          tabIndex: 0,
          children: [
            /* @__PURE__ */ a(yh, { shape: o.legend.style === "boxes" ? "square" : "circle", fill: C.value }),
            /* @__PURE__ */ a(Ol, { align: "left", margin: "0", children: C.text })
          ]
        },
        `legend-item-${w}`
      );
    }) })
  ] }, T)) });
}, qk = (e) => {
  const { filters: t, data: n, runtime: r, legend: i } = e, { colorCode: o } = i, { series: h } = r, d = n.filter((y) => t.every((g) => y[g.columnName] === g.active)), c = o && Array.from(new Set(d.map((y) => y[o])));
  return h.flatMap((y) => !o || y.type !== "Bar" ? y : c.map((g) => ({ ...y, colorCodeSeries: g }))).map((y) => ({
    ...y,
    data: d.filter((g) => !y.dynamicCategory || g[y.dynamicCategory] === y.dataKey).filter((g) => !y.colorCodeSeries || g[o] === y.colorCodeSeries).filter((g) => {
      const b = y.dynamicCategory ? y.originalDataKey : y.dataKey;
      return g[b] || g[b] === 0;
    })
  })).filter((y) => y.data.length).map((y) => y.colorCodeSeries || y.name || y.dataKey);
}, Zk = 36, Qk = fe.forwardRef(
  ({
    config: e,
    colorScale: t,
    seriesHighlight: n,
    highlight: r,
    handleShowAll: i,
    currentViewport: o,
    formatLabels: h,
    skipId: d = "legend",
    dimensions: c,
    transformedData: p
  }, y) => {
    const { innerClasses: g, containerClasses: b } = Hk(e), { runtime: T, legend: m } = e, { series: C } = T, w = qk(e), S = !C.length || m.unified || !w.length, B = (m == null ? void 0 : m.position) === "bottom" || Yi(o) && !m.hide && (m == null ? void 0 : m.position) !== "top", M = {
      marginBottom: jk(B, e),
      marginTop: Wk(B, e)
    }, { HighLightedBarUtils: D } = Xc(e);
    let O = D.findDuplicates(e.highlightedBarValues);
    return m ? /* @__PURE__ */ F(
      "aside",
      {
        ref: y,
        style: M,
        id: d || "legend",
        className: b.join(" "),
        role: "region",
        "aria-label": "legend",
        tabIndex: 0,
        children: [
          (m.label || m.description) && /* @__PURE__ */ F("div", { className: m.description ? "mb-3" : "mb-2", children: [
            m.label && /* @__PURE__ */ a("h3", { className: "fw-bold", children: Gi(m.label) }),
            m.description && /* @__PURE__ */ a("p", { className: "mt-2", children: Gi(m.description) })
          ] }),
          /* @__PURE__ */ a(
            Ug,
            {
              config: e,
              ...Vk(e, h, t),
              dimensions: c,
              parentPaddingToSubtract: m.hideBorder ? 0 : Zk
            }
          ),
          /* @__PURE__ */ a(Xk, { formatLabels: h }),
          /* @__PURE__ */ a(Cg, { scale: t, itemDirection: "row", labelMargin: "0 20px 0 0", shapeMargin: "0 10px 0", children: (L) => /* @__PURE__ */ F(Be, { children: [
            /* @__PURE__ */ F("div", { className: g.join(" "), children: [
              h(L).filter((U) => S || w.includes(U.datum)).map((U, X) => {
                var ce, q;
                let ne = ["legend-item", `legend-text--${U.text.replace(" ", "").toLowerCase()}`], G = U.datum;
                if (e.exclusions.active && ((ce = e.exclusions.keys) != null && ce.includes(G)))
                  return null;
                if (T.seriesLabels) {
                  let re = e.runtime.seriesLabelsAll.indexOf(G);
                  G = e.runtime.seriesKeys[re], ((q = T == null ? void 0 : T.forecastingSeriesKeys) == null ? void 0 : q.length) > 0 && (G = U.text);
                }
                return n.length && (n.includes(G) ? ne.push("highlighted") : ne.push("inactive")), e.legend.style === "gradient" || e.legend.groupBy ? /* @__PURE__ */ a(Be, {}) : /* @__PURE__ */ F(
                  Dl,
                  {
                    className: ne.join(" "),
                    tabIndex: 0,
                    onKeyDown: (re) => {
                      re.key === "Enter" && (re.preventDefault(), r(U));
                    },
                    onClick: (re) => {
                      re.preventDefault(), r(U);
                    },
                    role: "button",
                    children: [
                      /* @__PURE__ */ a(Be, { children: e.visualizationType === "Line" && e.legend.style === "lines" ? /* @__PURE__ */ a(Ie.Fragment, { children: /* @__PURE__ */ a(Yk, { index: X, label: U, config: e }) }) : /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ a(
                        yh,
                        {
                          shape: e.legend.style === "boxes" ? "square" : "circle",
                          fill: U.value
                        }
                      ) }) }),
                      /* @__PURE__ */ a(Ol, { align: "left", className: "m-0", children: Gi(U.text) })
                    ]
                  },
                  `legend-quantile-${X}`
                );
              }),
              O.map((U, X) => {
                let ne = "legend-item", G = U.legendLabel;
                return G ? (n.length > 0 && n.includes(G) === !1 && (ne += " inactive"), /* @__PURE__ */ F(
                  Dl,
                  {
                    className: ne,
                    tabIndex: 0,
                    onKeyDown: (ce) => {
                      ce.key === "Enter" && (ce.preventDefault(), r(U.legendLabel));
                    },
                    onClick: (ce) => {
                      ce.preventDefault(), r(U.legendLabel);
                    },
                    children: [
                      /* @__PURE__ */ a(
                        yh,
                        {
                          shape: e.legend.style === "boxes" ? "square" : "circle",
                          style: { borderRadius: "0px" },
                          fill: "transparent",
                          borderColor: U.color ? U.color : "rgba(255, 102, 1)"
                        }
                      ),
                      " ",
                      /* @__PURE__ */ a(Ol, { align: "left", children: U.legendLabel ? U.legendLabel : U.value })
                    ]
                  },
                  `legend-quantile-${X}`
                )) : !1;
              })
            ] }),
            /* @__PURE__ */ a(Kk, { config: e, isLegendBottom: B })
          ] }) }),
          n.length > 0 && /* @__PURE__ */ a(Oc, { onClick: (L) => i(L), style: { marginTop: "1rem" }, children: "Show All" })
        ]
      }
    ) : null;
  }
);
function Jk(e) {
  return Kg({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" }, child: [] }] })(e);
}
const eT = (e, t, n, r) => (i) => {
  var m, C, w, S, B;
  const { visualizationType: o, visualizationSubType: h, series: d, runtime: c, legend: p } = e, y = (M) => p.verticalSorted ? Ke.sortBy(Ke.cloneDeep(M), (D) => {
    var L;
    const O = (L = D.datum) == null ? void 0 : L.match(/-?\d+(\.\d+)?/);
    return O ? parseFloat(O[0]) : Number.MAX_SAFE_INTEGER;
  }) : M, g = (M) => e.series.some((D) => D.dynamicCategory) ? b(M) : e.legend.reverseLabelOrder ? y(M).reverse() : y(M), b = (M) => {
    switch (e.legend.order) {
      case "dataColumn":
        return M;
      case "asc":
      case "desc":
        return M.sort((D, O) => {
          const L = D.datum || D.text, U = O.datum || O.text, X = parseFloat(L), ne = parseFloat(U);
          return !isNaN(X) && !isNaN(ne) ? e.legend.order === "asc" ? X - ne : ne - X : e.legend.order === "asc" ? L.localeCompare(U) : U.localeCompare(L);
        });
      default:
        return M;
    }
  }, T = (m = e.legend) == null ? void 0 : m.colorCode;
  if (o === "Deviation Bar") {
    const [M, D] = Mc[e.twoColor.palette], O = {
      datum: "X",
      index: 0,
      text: `Below ${e.xAxis.targetLabel}`,
      value: M
    }, L = {
      datum: "X",
      index: 1,
      text: `Above ${e.xAxis.targetLabel}`,
      value: D
    };
    return g([O, L]);
  }
  if (o === "Bar" && h === "regular" && T && (d == null ? void 0 : d.length) === 1) {
    let M = _r[e.palette];
    for (; t.length > M.length; )
      M = M.concat(M);
    M = M.slice(0, n.length);
    const D = /* @__PURE__ */ new Set();
    t.forEach((L) => D.add(L[T]));
    const O = Array.from(D).map((L, U) => ({
      datum: L,
      index: U,
      text: L,
      value: M[U]
    }));
    return g(O);
  }
  if (((C = c == null ? void 0 : c.forecastingSeriesKeys) == null ? void 0 : C.length) > 0) {
    let M = [];
    return (S = (w = e.runtime) == null ? void 0 : w.forecastingSeriesKeys) == null || S.map((D, O) => {
      var L;
      return (L = D == null ? void 0 : D.stages) == null ? void 0 : L.map((U, X) => {
        var ce, q, re, $;
        let ne = (ce = oc[U.color]) != null && ce[2] ? (q = oc[U.color]) == null ? void 0 : q[2] : (re = _r[U.color]) != null && re[2] ? ($ = _r[U.color]) == null ? void 0 : $[2] : "#ccc";
        const G = {
          datum: U.key,
          index: X,
          text: U.key,
          value: ne
        };
        M.push(G);
      });
    }), e.runtime.barSeriesKeys && e.runtime.barSeriesKeys.forEach((D, O) => {
      let L = _r[e.palette][O] ? _r[e.palette][O] : "#ccc";
      const U = {
        datum: D,
        index: O,
        text: D,
        value: L
      };
      M.push(U);
    }), g(M);
  }
  if (e.series.some((M) => M.name)) {
    const M = Array.from(new Set(e.series.map((D) => D.name || D.dataKey))).map((D, O) => ({
      datum: D,
      index: O,
      text: D,
      value: r(D)
    }));
    return g(M);
  }
  if ((e.visualizationType === "Bar" || e.visualizationType === "Combo") && e.visualizationSubType === "regular" && e.suppressedData) {
    const M = i.length - 1;
    let D = [];
    return (B = e.suppressedData) == null || B.forEach(({ label: O, icon: L }, U) => {
      if (O && L) {
        const X = {
          datum: O,
          index: M + U,
          text: O,
          icon: /* @__PURE__ */ a(Jk, { color: "#000", size: 15 })
        };
        D.push(X);
      }
    }), [...i, ...D];
  }
  return g(i);
}, tT = fe.forwardRef((e, t) => {
  const {
    // prettier-ignore
    config: n,
    colorScale: r,
    seriesHighlight: i,
    highlight: o,
    tableData: h,
    handleShowAll: d,
    transformedData: c,
    currentViewport: p,
    dimensions: y,
    getTextWidth: g,
    transformedData: b
  } = fe.useContext(ft);
  if (!n.legend)
    return null;
  const T = eT(n, h, c, r);
  return /* @__PURE__ */ a(fe.Fragment, { children: /* @__PURE__ */ a(
    Qk,
    {
      getTextWidth: g,
      dimensions: y,
      ref: t,
      transformedData: b,
      skipId: e.skipId || "legend",
      config: n,
      colorScale: r,
      seriesHighlight: i,
      highlight: o,
      handleShowAll: d,
      currentViewport: p,
      formatLabels: T
    }
  ) });
}), rc = {
  annotations: [],
  allowLineToBarGraph: void 0,
  type: "chart",
  debugSvg: !1,
  chartMessage: {
    noData: "No Data Available"
  },
  title: "",
  showTitle: !0,
  showDownloadMediaButton: !1,
  theme: "theme-blue",
  animate: !1,
  lineDatapointStyle: "hover",
  lineDatapointColor: "Same as Line",
  barHasBorder: "true",
  isLollipopChart: !1,
  lollipopShape: "circle",
  lollipopColorStyle: "two-tone",
  visualizationSubType: "regular",
  barStyle: "",
  roundingStyle: "standard",
  tipRounding: "top",
  isResponsiveTicks: !1,
  general: {
    annotationDropdownText: "Annotations",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0,
    showZeroValueData: !0,
    hideNullValue: !0
  },
  padding: {
    left: 5,
    right: 5
  },
  preliminaryData: [],
  yAxis: {
    hideAxis: !1,
    displayNumbersOnBar: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 50,
    gridLines: !1,
    enablePadding: !1,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    rightHideAxis: !1,
    rightAxisSize: 0,
    rightLabel: "",
    rightLabelOffsetSize: 0,
    rightAxisLabelColor: "#333",
    rightAxisTickLabelColor: "#333",
    rightAxisTickColor: "#333",
    numTicks: "",
    axisPadding: 0,
    scalePadding: 10,
    tickRotation: 0,
    anchors: [],
    shoMissingDataLabel: !0,
    showMissingDataLine: !0,
    categories: []
  },
  boxplot: {
    plots: [],
    borders: "true",
    plotOutlierValues: !1,
    plotNonOutlierValues: !0,
    labels: {
      q1: "Lower Quartile",
      q2: "q2",
      q3: "Upper Quartile",
      q4: "q4",
      minimum: "Minimum",
      maximum: "Maximum",
      mean: "Mean",
      median: "Median",
      sd: "Standard Deviation",
      iqr: "Interquartile Range",
      count: "Count",
      outliers: "Outliers",
      values: "Values",
      lowerBounds: "Lower Bounds",
      upperBounds: "Upper Bounds"
    }
  },
  topAxis: {
    hasLine: !1
  },
  isLegendValue: !1,
  barThickness: 0.35,
  barHeight: 25,
  barSpace: 15,
  heights: {
    vertical: 300,
    horizontal: 750
  },
  xAxis: {
    sortDates: !1,
    anchors: [],
    type: "categorical",
    showTargetLabel: !0,
    targetLabel: "Target",
    hideAxis: !1,
    hideLabel: !1,
    hideTicks: !1,
    size: 75,
    tickRotation: 0,
    min: "",
    max: "",
    labelColor: "#333",
    tickLabelColor: "#333",
    tickColor: "#333",
    numTicks: "",
    labelOffset: 0,
    axisPadding: 200,
    target: 0,
    maxTickRotation: 0,
    padding: 5,
    showYearsOnce: !1,
    sortByRecentDate: !1
  },
  table: {
    label: "Data Table",
    expanded: !0,
    limitHeight: !1,
    height: "",
    caption: "",
    showDownloadUrl: !1,
    showDataTableLink: !0,
    showDownloadLinkBelow: !0,
    indexLabel: "",
    download: !1,
    showVertical: !0,
    dateDisplayFormat: "",
    showMissingDataLabel: !0,
    showSuppressedSymbol: !0
  },
  orientation: "vertical",
  color: "pinkpurple",
  columns: {
    // start with a blank list
  },
  legend: {
    hide: !1,
    behavior: "isolate",
    axisAlign: !0,
    singleRow: !0,
    colorCode: "",
    reverseLabelOrder: !1,
    description: "",
    dynamicLegend: !1,
    dynamicLegendDefaultText: "Show All",
    dynamicLegendItemLimit: 5,
    dynamicLegendItemLimitMessage: "Dynamic Legend Item Limit Hit.",
    dynamicLegendChartMessage: "Select Options from the Legend",
    label: "",
    lineMode: !1,
    verticalSorted: !1,
    highlightOnHover: !1,
    hideSuppressedLabels: !1,
    hideSuppressionLink: !1,
    seriesHighlight: [],
    style: "circles",
    subStyle: "linear blocks",
    groupBy: "",
    shape: "circle",
    tickRotation: "",
    order: "dataColumn",
    hideBorder: {
      side: !1,
      topBottom: !0
    },
    position: "right",
    orderedValues: []
  },
  brush: {
    height: 45,
    active: !1
  },
  exclusions: {
    active: !1,
    keys: []
  },
  palette: "qualitative-bold",
  isPaletteReversed: !1,
  twoColor: {
    palette: "monochrome-1",
    isPaletteReversed: !1
  },
  labels: !1,
  dataFormat: {
    commas: !1,
    prefix: "",
    suffix: "",
    abbreviated: !1,
    bottomSuffix: "",
    bottomPrefix: "",
    bottomAbbreviated: !1
  },
  filters: [],
  confidenceKeys: {},
  visual: {
    border: !0,
    accent: !0,
    background: !0,
    verticalHoverLine: !1,
    horizontalHoverLine: !1,
    lineDatapointSymbol: "none",
    maximumShapeAmount: 7
  },
  useLogScale: !1,
  filterBehavior: "Filter Change",
  highlightedBarValues: [],
  series: [],
  tooltips: {
    opacity: 90,
    singleSeries: !1,
    dateDisplayFormat: ""
  },
  forestPlot: {
    startAt: 0,
    colors: {
      line: "",
      shape: ""
    },
    lineOfNoEffect: {
      show: !0
    },
    type: "",
    pooledResult: {
      diamondHeight: 5,
      column: ""
    },
    estimateField: "",
    estimateRadius: "",
    shape: "square",
    rowHeight: 20,
    description: {
      show: !0,
      text: "description",
      location: 0
    },
    result: {
      show: !0,
      text: "result",
      location: 100
    },
    radius: {
      min: 2,
      max: 10,
      scalingColumn: ""
    },
    regression: {
      lower: 0,
      upper: 0,
      estimateField: 0
    },
    leftWidthOffset: 0,
    rightWidthOffset: 0,
    showZeroLine: !1,
    leftLabel: "",
    rightLabel: ""
  },
  area: {
    isStacked: !1
  },
  sankey: {
    title: {
      defaultColor: "black"
    },
    iterations: 1,
    rxValue: 0.9,
    overallSize: {
      width: 900,
      height: 700
    },
    margin: {
      margin_y: 25,
      margin_x: 0
    },
    nodeSize: {
      nodeWidth: 26,
      nodeHeight: 40
    },
    nodePadding: 55,
    nodeFontColor: "black",
    nodeColor: {
      default: "#ff8500",
      inactive: "#808080"
    },
    linkColor: {
      default: "#ffc900",
      inactive: "#D3D3D3"
    },
    opacity: {
      nodeOpacityDefault: 1,
      nodeOpacityInactive: 0.1,
      LinkOpacityDefault: 1,
      LinkOpacityInactive: 0.1
    },
    storyNodeFontColor: "#006778",
    storyNodeText: [],
    nodeValueStyle: {
      textBefore: "(",
      textAfter: ")"
    },
    data: []
  }
}, nT = ({
  config: e,
  deleteColumn: t,
  updateField: n,
  colKey: r,
  controls: i
}) => {
  var g, b, T, m;
  const [o, h] = i, d = (C, w) => {
    if (C === "dataTable" && w === !0) {
      const S = Ke.cloneDeep(e.columns);
      S[r] = { ...S[r], dataTable: w }, n(null, null, "columns", S);
    } else
      n("columns", r, C, w);
  }, c = (C) => {
    const w = Ke.cloneDeep(e.columns), B = { ...e.columns[r], name: C, label: C };
    if (B.dataTable === void 0 && (B.dataTable = !0), C !== r) {
      w[C] = B, delete w[r];
      const M = { ...Ke.cloneDeep(o), [C]: !0 };
      delete M[r], h(M);
    }
    n(null, null, "columns", w);
  }, p = () => {
    var B;
    const C = e.data.flatMap((M) => Object.keys(M).map((D) => D)), w = Object.values(e.columns).map((M) => M.name), S = Ke.uniq(C).filter((M) => !(e.table.groupBy === M || w.includes(M)));
    return (B = e.columns[r]) != null && B.name && S.push(e.columns[r].name), S;
  }, y = (g = e.columns[r]) == null ? void 0 : g.name;
  return /* @__PURE__ */ F(
    Gg,
    {
      fieldName: y,
      fieldKey: r,
      fieldType: "Column",
      controls: i,
      deleteField: () => t(r),
      children: [
        /* @__PURE__ */ a(
          ct,
          {
            label: "Column",
            value: (b = e.columns[r]) == null ? void 0 : b.name,
            fieldName: "name",
            section: "columns",
            initial: "-Select-",
            options: p(),
            updateField: (C, w, S, B) => c(B)
          }
        ),
        e.type !== "table" && /* @__PURE__ */ a(
          ct,
          {
            label: "Associate to Series",
            value: (T = e.columns[r]) == null ? void 0 : T.series,
            fieldName: "series",
            section: "columns",
            initial: "Select series",
            options: ((m = e.series) == null ? void 0 : m.map((C) => C.dataKey)) || [],
            updateField: (C, w, S, B) => d("series", B)
          }
        ),
        /* @__PURE__ */ a(
          ze,
          {
            value: e.columns[r].label,
            section: "columns",
            subsection: r,
            fieldName: "label",
            label: "Label",
            updateField: n
          }
        ),
        /* @__PURE__ */ F("ul", { className: "column-edit", children: [
          /* @__PURE__ */ F("li", { className: "three-col", children: [
            /* @__PURE__ */ a(
              ze,
              {
                value: e.columns[r].prefix,
                section: "columns",
                subsection: r,
                fieldName: "prefix",
                label: "Prefix",
                updateField: n
              }
            ),
            /* @__PURE__ */ a(
              ze,
              {
                value: e.columns[r].suffix,
                section: "columns",
                subsection: r,
                fieldName: "suffix",
                label: "Suffix",
                updateField: n
              }
            ),
            /* @__PURE__ */ a(
              ze,
              {
                type: "number",
                value: e.columns[r].roundToPlace,
                section: "columns",
                subsection: r,
                fieldName: "roundToPlace",
                label: "Round",
                updateField: n
              }
            )
          ] }),
          /* @__PURE__ */ a("li", { children: /* @__PURE__ */ F("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].commas,
                onChange: (C) => {
                  d("commas", C.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Add Commas to Numbers" })
          ] }) }),
          /* @__PURE__ */ a("li", { children: e.table.showVertical && /* @__PURE__ */ F("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].dataTable ?? !0,
                onChange: (C) => {
                  d("dataTable", C.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in Data Table" })
          ] }) }),
          e.visualizationType === "Pie" && /* @__PURE__ */ a("li", { children: /* @__PURE__ */ F("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].showInViz,
                onChange: (C) => {
                  d("showInViz", C.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in Visualization" })
          ] }) }),
          e.type !== "table" && /* @__PURE__ */ a("li", { children: /* @__PURE__ */ F("label", { className: "checkbox", children: [
            /* @__PURE__ */ a(
              "input",
              {
                type: "checkbox",
                checked: e.columns[r].tooltips || !1,
                onChange: (C) => {
                  n("columns", r, "tooltips", C.target.checked);
                }
              }
            ),
            /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in tooltip" })
          ] }) }),
          e.visualizationType === "Forest Plot" && /* @__PURE__ */ F(Be, { children: [
            /* @__PURE__ */ a("li", { children: /* @__PURE__ */ F("label", { className: "checkbox", children: [
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: e.columns[r].forestPlot || !1,
                  onChange: (C) => {
                    d("forestPlot", C.target.checked);
                  }
                }
              ),
              /* @__PURE__ */ a("span", { className: "edit-label", children: "Show in Forest Plot" })
            ] }) }),
            /* @__PURE__ */ a("li", { children: /* @__PURE__ */ F("label", { className: "checkbox", children: [
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: e.columns[r].forestPlotAlignRight || !1,
                  onChange: (C) => {
                    d("forestPlotAlignRight", C.target.checked);
                  }
                }
              ),
              /* @__PURE__ */ a("span", { className: "edit-label", children: "Align Right" })
            ] }) }),
            !e.columns[r].forestPlotAlignRight && /* @__PURE__ */ a("li", { children: /* @__PURE__ */ F("label", { className: "text", children: [
              /* @__PURE__ */ a("span", { className: "edit-label", children: "Forest Plot Starting Point" }),
              /* @__PURE__ */ a(
                "input",
                {
                  type: "number",
                  value: e.columns[r].forestPlotStartingPoint || 0,
                  onChange: (C) => {
                    d("forestPlotStartingPoint", C.target.value);
                  }
                }
              )
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ F("label", { children: [
          /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Order" }),
          /* @__PURE__ */ a(
            "input",
            {
              onWheel: (C) => C.currentTarget.blur(),
              type: "number",
              min: "1",
              value: e.columns[r].order,
              onChange: (C) => n("columns", r, "order", parseInt(C.target.value))
            }
          )
        ] })
      ]
    }
  );
}, rT = ({ config: e, updateField: t, deleteColumn: n }) => {
  var h;
  const r = fe.useState({}), i = Object.keys(e.columns), o = (d) => {
    const c = `additionalColumn${d}`, p = {
      label: "New Column",
      dataTable: !0,
      tooltips: !1,
      prefix: "",
      suffix: "",
      forestPlot: !1,
      startingPoint: "0",
      forestPlotAlignRight: !1,
      roundToPlace: 0,
      commas: !1,
      showInViz: !1,
      forestPlotStartingPoint: 0
    }, [y, g] = r;
    g({ ...y, [c]: !0 }), t("columns", null, c, p);
  };
  return /* @__PURE__ */ F(Be, { children: [
    e.type !== "navigation" && /* @__PURE__ */ F("fieldset", { children: [
      /* @__PURE__ */ a("label", { children: /* @__PURE__ */ F("span", { className: "edit-label", children: [
        "Configurations",
        /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "You can specify additional columns to display in tooltips and / or the supporting data table." }) })
        ] })
      ] }) }),
      i.map((d, c) => /* @__PURE__ */ a(
        nT,
        {
          controls: r,
          config: e,
          deleteColumn: n,
          updateField: t,
          colKey: d
        },
        d + c
      )),
      /* @__PURE__ */ a(
        "button",
        {
          className: "btn btn-primary",
          onClick: (d) => {
            d.preventDefault(), o(i.length + 1);
          },
          children: "Add Configuration"
        }
      )
    ] }),
    ((h = e.legend) == null ? void 0 : h.type) === "category" && /* @__PURE__ */ F("fieldset", { children: [
      /* @__PURE__ */ a("label", { children: /* @__PURE__ */ F("span", { className: "edit-label", children: [
        "Additional Category",
        /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "You can provide additional categories to ensure they appear in the legend" }) })
        ] })
      ] }) }),
      e.legend.additionalCategories && e.legend.additionalCategories.map((d, c) => /* @__PURE__ */ F("fieldset", { className: "edit-block", children: [
        /* @__PURE__ */ a(
          "button",
          {
            className: "remove-column",
            onClick: (p) => {
              p.preventDefault();
              const y = [...e.legend.additionalCategories];
              y.splice(c, 1), t("legend", null, "additionalCategories", y);
            },
            children: "Remove"
          }
        ),
        /* @__PURE__ */ a(
          ze,
          {
            value: d,
            label: "Category",
            section: "legend",
            subsection: null,
            fieldName: "additionalCategories",
            updateField: (p, y, g, b) => {
              const T = [...e.legend.additionalCategories];
              T[c] = b, t(p, y, g, T);
            }
          }
        )
      ] }, d)),
      /* @__PURE__ */ a(
        "button",
        {
          className: "btn btn-primary full-width",
          onClick: (d) => {
            d.preventDefault();
            const c = [...e.legend.additionalCategories || []];
            c.push(""), t("legend", null, "additionalCategories", c);
          },
          children: "Add Category"
        }
      )
    ] })
  ] });
}, wm = "-Select-", iT = ({ config: e, updateField: t, isDashboard: n, columns: r }) => {
  var p, y, g, b, T, m;
  const i = ((p = e.dataKey) == null ? void 0 : p.includes("http://")) || ((y = e == null ? void 0 : e.dataKey) == null ? void 0 : y.includes("https://")), o = fe.useMemo(() => Object.keys(e.columns).map((C) => [C, e.columns[C].dataTable]).filter(([C, w]) => !w).map(([C]) => C), [e.columns]), h = fe.useMemo(() => {
    const C = e.data.flatMap(Object.keys);
    return Ke.uniq(C).filter((S) => !0);
  }, [e.data]), d = (C) => {
    C === wm && (C = void 0), t("table", null, "groupBy", C);
  }, c = (C, w, S, B) => {
    const M = Ke.cloneDeep(e.columns), D = [];
    for (let O in M) {
      const L = M[O];
      D.push(L.name), B.includes(L.name) ? M[O].dataTable = !1 : M[O].dataTable = !0;
    }
    B.forEach((O) => {
      D.includes(O) || (M[O] = { name: O, dataTable: !1 });
    }), t(null, null, "columns", M);
  };
  return /* @__PURE__ */ F(Be, { children: [
    /* @__PURE__ */ a(
      ze,
      {
        value: e.table.label,
        updateField: t,
        section: "table",
        fieldName: "label",
        id: "tableLabel",
        label: "Data Table Title",
        placeholder: "Data Table",
        tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Label is required for Data Table for 508 Compliance" }) })
        ] })
      }
    ),
    e.type !== "table" && /* @__PURE__ */ a(
      Ue,
      {
        value: e.table.show,
        fieldName: "show",
        label: "Show Data Table",
        section: "table",
        updateField: t,
        className: "column-heading",
        tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
            Ve,
            {
              display: "question",
              style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
            }
          ) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Hiding the data table may affect accessibility. An alternate form of accessing visualization data is a 508 requirement." }) })
        ] })
      }
    ),
    e.visualizationType !== "Box Plot" && e.type !== "table" && /* @__PURE__ */ a(
      Ue,
      {
        value: e.table.showVertical,
        fieldName: "showVertical",
        label: "Show Vertical Data",
        section: "table",
        updateField: t,
        className: "column-heading",
        tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
            Ve,
            {
              display: "question",
              style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
            }
          ) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "This will draw the data table with vertical data instead of horizontal." }) })
        ] })
      }
    ),
    e.type !== "table" && /* @__PURE__ */ a(
      ze,
      {
        value: e.table.indexLabel,
        section: "table",
        fieldName: "indexLabel",
        label: "Index Column Header",
        updateField: t,
        tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "To comply with 508 standards, if the first column in the data table has no header, enter a brief one here." }) })
        ] })
      }
    ),
    /* @__PURE__ */ a(
      ze,
      {
        value: e.table.caption,
        updateField: t,
        section: "table",
        type: "textarea",
        fieldName: "caption",
        label: "Screen Reader Description",
        placeholder: " Data table",
        tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter a description of the data table to be read by screen readers." }) })
        ] })
      }
    ),
    /* @__PURE__ */ a(
      Ue,
      {
        value: e.table.limitHeight,
        section: "table",
        fieldName: "limitHeight",
        label: " Limit Table Height",
        updateField: t
      }
    ),
    e.table.limitHeight && /* @__PURE__ */ a(
      ze,
      {
        value: e.table.height,
        section: "table",
        fieldName: "height",
        label: "Data Table Height",
        type: "number",
        min: 0,
        max: 500,
        placeholder: "Height(px)",
        updateField: t
      }
    ),
    (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ F("label", { children: [
      /* @__PURE__ */ a("span", { className: "edit-label column-heading mt-1", children: "Exclude Columns " }),
      /* @__PURE__ */ a(
        ap,
        {
          options: r.map((C) => ({ label: C, value: C })),
          selected: o,
          label: "Exclude Columns",
          fieldName: "dataTable",
          section: "columns",
          updateField: c
        },
        o.join("") + "excluded"
      )
    ] }),
    /* @__PURE__ */ a(
      Ue,
      {
        value: e.table.collapsible,
        fieldName: "collapsible",
        label: " Collapsible",
        section: "table",
        updateField: t
      }
    ),
    e.table.collapsible !== !1 && /* @__PURE__ */ a(
      Ue,
      {
        value: e.table.expanded,
        fieldName: "expanded",
        label: " Expanded by Default",
        section: "table",
        updateField: t
      }
    ),
    /* @__PURE__ */ a(
      Ue,
      {
        value: e.table.download,
        fieldName: "download",
        label: "Show Download CSV Link",
        section: "table",
        updateField: t
      }
    ),
    e.table.download && /* @__PURE__ */ F(Be, { children: [
      /* @__PURE__ */ a(
        Ue,
        {
          value: e.table.showDownloadLinkBelow,
          fieldName: "showDownloadLinkBelow",
          className: "ms-4",
          label: "Show Link Below Table",
          section: "table",
          updateField: t
        }
      ),
      /* @__PURE__ */ a(
        Ue,
        {
          value: e.table.downloadVisibleDataOnly,
          fieldName: "downloadVisibleDataOnly",
          className: "ms-4",
          label: "Download only visible data",
          section: "table",
          updateField: t
        }
      )
    ] }),
    n && e.type !== "table" && /* @__PURE__ */ a(
      Ue,
      {
        value: e.table.showDataTableLink,
        fieldName: "showDataTableLink",
        label: "Show Data Table Name & Link",
        section: "table",
        updateField: t
      }
    ),
    i && /* @__PURE__ */ a(
      Ue,
      {
        value: e.table.showDownloadUrl,
        fieldName: "showDownloadUrl",
        label: "Show URL to Automatically Updated Data",
        section: "table",
        updateField: t
      }
    ),
    e.type !== "table" && /* @__PURE__ */ a(
      Ue,
      {
        value: e.table.showDownloadImgButton,
        fieldName: "showDownloadImgButton",
        label: "Display Image Button",
        section: "table",
        updateField: t
      }
    ),
    /* @__PURE__ */ F("label", { children: [
      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Table Cell Min Width" }),
      /* @__PURE__ */ a(
        "input",
        {
          type: "number",
          value: e.table.cellMinWidth ? e.table.cellMinWidth : 0,
          onChange: (C) => t("table", null, "cellMinWidth", C.target.value)
        }
      )
    ] }),
    (e == null ? void 0 : e.visualizationType) !== "Sankey" && /* @__PURE__ */ a(
      ct,
      {
        value: e.table.groupBy,
        fieldName: "groupBy",
        section: "table",
        label: "Group By",
        updateField: (C, w, S, B) => d(B),
        initial: wm,
        options: h.filter(
          (C) => {
            var w, S;
            return C !== ((w = e.table.pivot) == null ? void 0 : w.columnName) && !(((S = e.table.pivot) == null ? void 0 : S.valueColumns) || []).includes(C);
          }
        ),
        tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Choose a column to use for grouping data rows. The selected column will not be shown in the data table. You will only be able to choose a column which does not have a column configuration." }) })
        ] })
      }
    ),
    /* @__PURE__ */ a(
      ct,
      {
        label: "Pivot Column",
        tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Select a Column whos data values will be pivoted to Column Values." }) })
        ] }),
        value: (g = e.table.pivot) == null ? void 0 : g.columnName,
        options: h.filter(
          (C) => {
            var w;
            return C !== e.table.groupBy && !(((w = e.table.pivot) == null ? void 0 : w.valueColumns) || []).includes(C);
          }
        ),
        initial: "-Select-",
        section: "table",
        subsection: "pivot",
        fieldName: "columnName",
        updateField: t
      }
    ),
    ((b = e.table.pivot) == null ? void 0 : b.columnName) && /* @__PURE__ */ F("label", { children: [
      /* @__PURE__ */ F("span", { className: "edit-label column-heading mt-1", children: [
        "Pivot Value Column(s)",
        /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
          /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
          /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "The column(s) whos values will be pivoted under the column selected as the Filter." }) })
        ] })
      ] }),
      /* @__PURE__ */ a(
        ap,
        {
          options: h.filter((C) => {
            var w;
            return C !== ((w = e.table.pivot) == null ? void 0 : w.columnName) && C !== e.table.groupBy;
          }).map((C) => ({ label: C, value: C })),
          selected: (T = e.table.pivot) == null ? void 0 : T.valueColumns,
          label: "Pivot Value Column(s) ",
          section: "table",
          subsection: "pivot",
          fieldName: "valueColumns",
          updateField: t
        },
        (m = e.table.pivot) == null ? void 0 : m.columnName
      )
    ] })
  ] });
}, ic = (e) => /* @__PURE__ */ fe.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", ...e }, /* @__PURE__ */ fe.createElement("path", { fill: "currentColor", d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z" })), aT = ({ name: e }) => {
  var d, c, p, y, g;
  const { config: t, rawData: n, updateConfig: r } = fe.useContext(ft);
  if (t.visualizationType !== "Forest Plot")
    return;
  const i = (b) => {
    b.orientation === "horizontal" && (b.labels = !1), b.table.show === void 0 && (b.table.show = !isDashboard), b.visualizationType === "Combo" && (b.orientation = "vertical");
  }, o = (b = !0) => {
    let T = {};
    return n.forEach((m) => {
      Object.keys(m).forEach((C) => T[C] = !0);
    }), b && Object.keys(T).forEach((m) => {
      (t.series && t.series.filter((C) => C.dataKey === m).length > 0 || t.confidenceKeys && Object.keys(t.confidenceKeys).includes(m)) && delete T[m];
    }), Object.keys(T);
  }, h = (b, T, m, C) => {
    if (b === "boxplot" && T === "legend") {
      r({
        ...t,
        [b]: {
          ...t[b],
          [T]: {
            ...t.boxplot[T],
            [m]: C
          }
        }
      });
      return;
    }
    if (b === "boxplot" && T === "labels") {
      r({
        ...t,
        [b]: {
          ...t[b],
          [T]: {
            ...t.boxplot[T],
            [m]: C
          }
        }
      });
      return;
    }
    if (b === "forestPlot" && T) {
      let M = {
        ...t,
        [b]: {
          ...t[b],
          [T]: {
            ...t.forestPlot[T],
            [m]: C
          }
        }
      };
      r(M);
      return;
    }
    if (b === "columns" && T !== "" && m !== "") {
      r({
        ...t,
        [b]: {
          ...t[b],
          [T]: {
            ...t[b][T],
            [m]: C
          }
        }
      });
      return;
    }
    if (b === null && T === null) {
      let M = { ...t, [m]: C };
      i(M), r(M);
      return;
    }
    const w = Array.isArray(t[b]);
    let S = w ? [...t[b], C] : { ...t[b], [m]: C };
    T !== null && (w ? (S = [...t[b]], S[T] = { ...S[T], [m]: C }) : typeof C == "string" ? S[T] = C : S = { ...t[b], [T]: { ...t[b][T], [m]: C } });
    let B = { ...t, [b]: S };
    i(B), r(B);
  };
  return /* @__PURE__ */ F(Nn, { children: [
    /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ F(Dn, { children: [
      e,
      (!t.forestPlot.estimateField || !t.forestPlot.upper || !t.forestPlot.lower) && /* @__PURE__ */ a(ic, { width: "25", className: "warning-icon" })
    ] }) }),
    /* @__PURE__ */ F(On, { children: [
      /* @__PURE__ */ a(
        ct,
        {
          value: t.xAxis.dataKey || "",
          section: "xAxis",
          fieldName: "dataKey",
          label: "Study Column",
          initial: "Select",
          required: !0,
          updateField: h,
          options: o(!1),
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Select the column or row containing the categories or dates for this axis. " }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        ct,
        {
          value: t.forestPlot.type,
          label: "Forest Plot Type",
          initial: "Select",
          required: !0,
          onChange: (b) => {
            b.target.value !== "" && b.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                type: b.target.value
              }
            }), b.target.value = "";
          },
          options: ["Linear", "Logarithmic"],
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ F("p", { children: [
              "Linear - Typically used for continuous outcomes. Line of no effect is positioned on 0 (zero) ",
              /* @__PURE__ */ a("br", {}),
              /* @__PURE__ */ a("br", {}),
              " Logarithmic - Typically used for binary outcomes such as risk ratios and odds ratios. Line of no effect is positioned on 1."
            ] }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(ze, { type: "text", value: ((d = t.forestPlot) == null ? void 0 : d.title) || "", updateField: h, section: "forestPlot", fieldName: "title", label: "Plot Title" }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { children: "Column Settings" }),
      /* @__PURE__ */ a(
        ct,
        {
          value: t.forestPlot.estimateField,
          label: "Point Estimate Column",
          initial: t.forestPlot.estimateField || "Select",
          required: !0,
          onChange: (b) => {
            b.target.value !== "" && b.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                estimateField: b.target.value
              }
            }), b.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ a(
        ct,
        {
          value: t.forestPlot.shape,
          label: "Point Estimate Shape",
          onChange: (b) => {
            b.target.value !== "" && b.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                shape: b.target.value
              }
            }), b.target.value = "";
          },
          options: ["text", "circle", "square"]
        }
      ),
      /* @__PURE__ */ a(
        ct,
        {
          value: t.forestPlot.lower,
          label: "Lower CI Column",
          required: !0,
          initial: t.forestPlot.lower || "Select",
          onChange: (b) => {
            b.target.value !== "" && b.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                lower: b.target.value
              }
            }), b.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ a(
        ct,
        {
          value: t.forestPlot.upper,
          label: "Upper CI Column",
          initial: t.forestPlot.upper || "Select",
          required: !0,
          onChange: (b) => {
            b.target.value !== "" && b.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                upper: b.target.value
              }
            }), b.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ a("label", { children: /* @__PURE__ */ F("span", { className: "edit-label column-heading", children: [
        "Pooled Result Column",
        /* @__PURE__ */ a(
          "input",
          {
            type: "text",
            value: t.forestPlot.pooledResult.column || "",
            label: "Pooled Result Row",
            onChange: (b) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  pooledResult: {
                    ...t.forestPlot.pooledResult,
                    column: b.target.value
                  }
                }
              }), b.target.value = "";
            }
          }
        )
      ] }) }),
      /* @__PURE__ */ a(Ue, { value: ((p = (c = t.forestPlot) == null ? void 0 : c.lineOfNoEffect) == null ? void 0 : p.show) || !1, section: "forestPlot", subsection: "lineOfNoEffect", fieldName: "show", label: "Show Line of No Effect", updateField: h }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { children: "Width Settings" }),
      /* @__PURE__ */ F("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Left (%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.leftWidthOffset || 0,
            onChange: (b) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  leftWidthOffset: b.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ F("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Left Mobile(%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.leftWidthOffsetMobile || 0,
            onChange: (b) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  leftWidthOffsetMobile: b.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ F("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Right (%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.rightWidthOffset || 0,
            onChange: (b) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  rightWidthOffset: b.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ F("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Chart Offset Right Mobile(%)" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            min: 0,
            max: 100,
            value: t.forestPlot.rightWidthOffsetMobile || 0,
            onChange: (b) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  rightWidthOffsetMobile: b.target.value
                }
              });
            }
          }
        )
      ] }),
      /* @__PURE__ */ a(ze, { type: "number", min: 20, max: 45, value: t.forestPlot.rowHeight ? t.forestPlot.rowHeight : 10, updateField: h, section: "forestPlot", fieldName: "rowHeight", label: "Row Height", placeholder: "10" }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { children: "Labels Settings" }),
      /* @__PURE__ */ a(ze, { type: "text", value: ((y = t.forestPlot) == null ? void 0 : y.leftLabel) || "", updateField: h, section: "forestPlot", fieldName: "leftLabel", label: "Left Label" }),
      /* @__PURE__ */ a(ze, { type: "text", value: ((g = t.forestPlot) == null ? void 0 : g.rightLabel) || "", updateField: h, section: "forestPlot", fieldName: "rightLabel", label: "Right Label" }),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("hr", {}),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a(
        ct,
        {
          value: t.forestPlot.radius.scalingColumn,
          label: "Weight Column",
          initial: "Select",
          onChange: (b) => {
            b.target.value !== "" && b.target.value !== "Select" && r({
              ...t,
              forestPlot: {
                ...t.forestPlot,
                radius: {
                  ...t.forestPlot.radius,
                  scalingColumn: b.target.value
                }
              }
            }), b.target.value = "";
          },
          options: o(!1)
        }
      ),
      /* @__PURE__ */ F("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Radius Minimum Size" }),
        /* @__PURE__ */ a(
          "input",
          {
            min: 3,
            max: 6,
            value: t.forestPlot.radius.min || 3,
            onChange: (b) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  radius: {
                    ...t.forestPlot.radius,
                    min: Number(b.target.value)
                  }
                }
              });
            },
            type: "number",
            label: "Radius Minimum",
            placeholder: " 1"
          }
        )
      ] }),
      /* @__PURE__ */ F("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Radius Maximum Size" }),
        /* @__PURE__ */ a(
          "input",
          {
            min: 7,
            max: 10,
            value: t.forestPlot.radius.max,
            onChange: (b) => {
              r({
                ...t,
                forestPlot: {
                  ...t.forestPlot,
                  radius: {
                    ...t.forestPlot.radius,
                    max: Number(b.target.value)
                  }
                }
              });
            },
            type: "number",
            label: "Radius Minimum",
            placeholder: " 1"
          }
        )
      ] })
    ] })
  ] });
}, Ka = Ie.createContext({}), oT = (e) => {
  const { updateConfig: t, config: n, rawData: r } = fe.useContext(ft), { getColumns: i, selectComponent: o } = e, h = ["Line", "dashed-sm", "dashed-md", "dashed-lg"], d = (c, p, y) => {
    let g = [...n.series];
    if (g[c][y] = p, y === "type" && p === "Bar" && (g[c].axis = "Left"), g[c].type === "Forecasting") {
      let b = Array.from(new Set(r.map((m) => m[g[c].dataKey]))), T = [];
      b.forEach((m) => {
        T.push({ key: m });
      }), g[c].stages = T, g[c].stageColumn = g[c].dataKey;
    }
    t({ ...n, series: g });
  };
  return /* @__PURE__ */ a(Ka.Provider, { value: { updateSeries: d, supportedRightAxisTypes: h, getColumns: i, selectComponent: o }, children: e.children });
}, sT = (e) => {
  const { config: t, updateConfig: n } = fe.useContext(ft), { series: r, index: i } = e;
  if (!(() => {
    let c = !1;
    return t.visualizationSubType === "stacked" || ["Line", "dashed-sm", "dashed-md", "dashed-lg", "Area Chart", "Bump Chart"].some((y) => y.includes(r.type)) && (c = !0), c;
  })())
    return;
  const h = (c, p) => {
    let y = [...t.series];
    y[c].lineType = p, n({ ...t, series: y });
  };
  let d = [];
  return Object.keys(os).map((c) => d.push(os[c])), /* @__PURE__ */ a(
    Ji,
    {
      initial: "Select an option",
      value: r.lineType ? r.lineType : "curveLinear",
      label: "Series Line Type",
      onChange: (c) => {
        h(i, c.target.value);
      },
      options: d
    }
  );
}, lT = (e) => {
  const { config: t } = fe.useContext(ft), { updateSeries: n } = fe.useContext(Ka), { index: r, series: i } = e, o = () => {
    if (t.visualizationType === "Combo")
      return {
        Bar: "Bar",
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed",
        "Area Chart": "Area Chart",
        Forecasting: "Forecasting"
      };
    if (t.visualizationType === "Line" || t.visualizationType === "Bump Chart")
      return {
        Line: "Line",
        "dashed-sm": "Small Dashed",
        "dashed-md": "Medium Dashed",
        "dashed-lg": "Large Dashed"
      };
  };
  if (["Line", "Combo", "Bump Chart"].includes(t.visualizationType))
    return /* @__PURE__ */ a(
      Ji,
      {
        initial: "Select an option",
        value: i.type,
        label: "Series Type",
        onChange: (h) => {
          n(r, h.target.value, "type");
        },
        options: o()
      }
    );
}, uT = (e) => {
  const { config: t, updateConfig: n, rawData: r } = fe.useContext(ft), { updateSeries: i, getColumns: o } = fe.useContext(Ka), { index: h, series: d } = e;
  return /* @__PURE__ */ a(
    Ji,
    {
      initial: "Select an option",
      value: d.stageColumn,
      label: "Add Forecasting Stages",
      onChange: (c) => {
        let p = [], y = new Set(r == null ? void 0 : r.map((b) => b[c.target.value]));
        y = Array.from(y), y = y.filter((b) => b !== void 0), y.forEach((b) => p.push({ key: b }));
        const g = [...t.series];
        g[h] = { ...g[h], stages: p, stageColumn: c.target.value }, n({
          ...t,
          series: g
        });
      },
      options: o(!1)
    }
  );
}, cT = (e) => {
  const { config: t, rawData: n } = fe.useContext(ft), { updateSeries: r } = fe.useContext(Ka), { index: i, series: o } = e;
  if (o.type !== "Forecasting" || !n || !o.stageColumn)
    return;
  let h = new Set(n.map((d) => d[o.stageColumn]));
  return h = Array.from(h), h = h.filter((d) => d !== void 0), /* @__PURE__ */ a(
    Ji,
    {
      initial: "Select an option",
      value: o.stageItem,
      label: "Forecasting Item Column",
      onChange: (d) => {
        r(i, d.target.value, "stageItem");
      },
      options: h
    }
  );
}, dT = (e) => {
  const { config: t } = fe.useContext(ft), { updateSeries: n, supportedRightAxisTypes: r } = fe.useContext(Ka), { index: i, series: o } = e;
  if (!(t.visualizationType !== "Combo" || !o) && r.includes(o.type))
    return /* @__PURE__ */ a(
      Ji,
      {
        initial: "Select an option",
        value: o.axis ? o.axis : "Left",
        label: "Series Axis",
        onChange: (h) => {
          n(i, h.target.value, "axis");
        },
        options: {
          Left: "Left",
          Right: "Right"
        }
      }
    );
}, hT = (e) => {
  var o;
  const { config: t, updateConfig: n } = fe.useContext(ft), { index: r, series: i } = e;
  if (i.type === "Forecasting" && i)
    return (o = i == null ? void 0 : i.stages) == null ? void 0 : o.map((h, d) => {
      var c, p, y, g;
      return /* @__PURE__ */ a(
        Ji,
        {
          initial: "Select an option",
          value: (p = (c = t.series) == null ? void 0 : c[r].stages) != null && p[d].color ? (g = (y = t.series) == null ? void 0 : y[r].stages) == null ? void 0 : g[d].color : "Select",
          label: `${h.key} Series Color`,
          onChange: (b) => {
            const T = [...t.series], m = T[r].stages;
            m[d].color = b.target.value, T[r] = { ...T[r], stages: m }, n({
              ...t,
              series: T
            });
          },
          options: Object.keys(oc)
        },
        `${h}--${d}`
      );
    });
}, fT = (e) => {
  var h;
  const { config: t, updateConfig: n } = fe.useContext(ft), { series: r, index: i } = e, { getColumns: o } = fe.useContext(Ka);
  if (r.type === "Forecasting")
    return /* @__PURE__ */ F("div", { className: "edit-block", children: [
      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Confidence Interval Groups" }),
      /* @__PURE__ */ F("fieldset", { children: [
        /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: (h = r == null ? void 0 : r.confidenceIntervals) == null ? void 0 : h.map((d, c) => {
          const p = d.showInTooltip ? d.showInTooltip : !1, y = (g, b, T) => {
            g.preventDefault();
            let m = [...t.series];
            m[b].confidenceIntervals[T].showInTooltip = !p, n({
              ...t,
              series: m
            });
          };
          return /* @__PURE__ */ F(Nn, { className: "series-item series-item--chart", children: [
            /* @__PURE__ */ a(Rn, { className: "series-item__title", children: /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F(Dn, { className: "accordion__button accordion__button", children: [
              "Group ",
              c + 1,
              /* @__PURE__ */ a(
                "button",
                {
                  className: "series-list__remove",
                  onClick: (g) => {
                    g.preventDefault();
                    const b = [...t.series[i].confidenceIntervals];
                    b.splice(c, 1);
                    const T = [...t.series];
                    T[i] = { ...T[i], confidenceIntervals: [...b] }, n({
                      ...t,
                      series: T
                    });
                  },
                  children: "Remove"
                }
              )
            ] }) }) }),
            /* @__PURE__ */ F(On, { children: [
              /* @__PURE__ */ F("div", { className: "input-group", children: [
                /* @__PURE__ */ a("label", { htmlFor: "showInTooltip", children: "Show In Tooltip" }),
                /* @__PURE__ */ F(
                  "div",
                  {
                    className: "cove-input__checkbox--small",
                    onClick: (g) => y(g, i, c),
                    children: [
                      /* @__PURE__ */ a(
                        "div",
                        {
                          className: "cove-input__checkbox-box custom-color",
                          style: { backgroundColor: "" },
                          children: p && /* @__PURE__ */ a(Um, { className: "", style: { fill: "#025eaa" } })
                        }
                      ),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          className: "cove-input--hidden",
                          type: "checkbox",
                          name: "showInTooltip",
                          checked: p || !1,
                          readOnly: !0
                        }
                      )
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ a(
                Ji,
                {
                  initial: "Select an option",
                  value: t.series[i].confidenceIntervals[c].low ? t.series[i].confidenceIntervals[c].low : "Select",
                  label: "Low Confidence Interval",
                  onChange: (g) => {
                    const b = [...t.series[i].confidenceIntervals];
                    b[c].low = g.target.value;
                    const T = [...t.series];
                    T[i] = { ...T[i], confidenceIntervals: b }, n({
                      ...t,
                      series: T
                    });
                  },
                  options: o()
                }
              ),
              /* @__PURE__ */ a(
                Ji,
                {
                  initial: "Select an option",
                  value: t.series[i].confidenceIntervals[c].high ? t.series[i].confidenceIntervals[c].high : "Select",
                  label: "High Confidence Interval",
                  onChange: (g) => {
                    const b = [...t.series[i].confidenceIntervals];
                    b[c].high = g.target.value;
                    const T = [...t.series];
                    T[i] = { ...T[i], confidenceIntervals: b }, n({
                      ...t,
                      series: T
                    });
                  },
                  options: o()
                }
              )
            ] })
          ] }, `${c}`);
        }) }),
        /* @__PURE__ */ a(
          "button",
          {
            className: "btn btn-primary full-width",
            onClick: (d) => {
              d.preventDefault();
              let c = null;
              t.series[i].confidenceIntervals ? c = [...t.series[i].confidenceIntervals] : c = [];
              const p = [...t.series];
              p[i] = {
                ...p[i],
                confidenceIntervals: [...c, { high: "", low: "" }]
              }, n({
                ...t,
                series: p
              });
            },
            children: "Add Confidence Interval Group"
          }
        )
      ] })
    ] });
}, pT = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: i } = fe.useContext(ft);
  if (!["Line", "Combo", "dashed-sm", "dashed-md", "dashed-lg"].includes(t.type))
    return;
  const h = (d, c, p, y) => {
    let g = [...r.series], b = { ...r.runtime.seriesLabels };
    g[d].weight = c && Math.max(Number(p), Math.min(Number(y), Number(c))), b[g[d].dataKey] = g[d].weight ? g[d].weight : g[d].dataKey;
    const T = {
      ...r,
      series: g,
      runtime: {
        ...r.runtime,
        seriesLabels: b
      }
    };
    i(T);
  };
  return /* @__PURE__ */ F(Be, { children: [
    /* @__PURE__ */ a("label", { htmlFor: "series-weight", children: "Line Weight" }),
    /* @__PURE__ */ a(
      "input",
      {
        type: "number",
        value: t.weight ? t.weight : "",
        min: "1",
        max: "9",
        onChange: (d) => {
          h(n, d.target.value, d.target.min, d.target.max);
        }
      },
      `series-weight-${n}`
    )
  ] });
}, mT = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: i } = fe.useContext(ft);
  if (![
    "Bump Chart",
    "Bar",
    "Line",
    "Area Chart",
    "Combo",
    "Deviation",
    "Paired",
    "Scatter",
    "dashed-sm",
    "dashed-md",
    "dashed-lg"
  ].includes(t.type))
    return;
  const h = (c, p) => {
    let y = [...r.series], g = { ...r.runtime.seriesLabels };
    y[c].name = p, g[y[c].dataKey] = y[c].name ? y[c].name : y[c].dataKey;
    let b = {
      ...r,
      series: y,
      runtime: {
        ...r.runtime,
        seriesLabels: g
      }
    };
    i(b);
  }, d = t.name !== void 0 && t.name !== t.dataKey ? t.name : t.dataKey;
  return /* @__PURE__ */ F(Be, { children: [
    /* @__PURE__ */ a("label", { htmlFor: "series-name", children: "Series Name" }),
    /* @__PURE__ */ a(
      "input",
      {
        type: "text",
        value: d,
        onChange: (c) => {
          h(n, c.target.value);
        }
      },
      `series-name-${n}`
    )
  ] });
}, yT = (e) => {
  const { series: t, index: n } = e, { config: r, updateConfig: i } = fe.useContext(ft);
  if (["Paired Bar", "Scatter Plot", "Deviation Bar"].includes(r.visualizationType))
    return;
  const o = (h) => {
    let d = [...r.series];
    d[h].tooltip && d[h].tooltip, d[h].tooltip = !d[h].tooltip, i({
      ...r,
      series: d
    });
  };
  return /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F("div", { className: "input-group", children: [
    /* @__PURE__ */ a("label", { htmlFor: `series-tooltip--${n}`, children: "Show In Tooltip" }),
    /* @__PURE__ */ F("div", { className: "cove-input__checkbox--small", onClick: (h) => o(n), children: [
      /* @__PURE__ */ a("div", { className: "cove-input__checkbox-box custom-color", style: { backgroundColor: "" }, children: t.tooltip && /* @__PURE__ */ a(Um, { className: "", style: { fill: "#025eaa" } }) }),
      /* @__PURE__ */ a(
        "input",
        {
          className: "cove-input--hidden",
          type: "checkbox",
          name: `series-tooltip--${n}`,
          checked: t.tooltip ? t.tooltip : !1,
          readOnly: !0
        }
      )
    ] })
  ] }) });
}, gT = (e) => {
  const { config: t, updateConfig: n } = fe.useContext(ft), { series: r, index: i } = e, o = (d) => {
    let c = [...t.series], p = -1;
    for (let y = 0; y < c.length; y++)
      if (c[y].dataKey === d) {
        p = y;
        break;
      }
    if (p !== -1) {
      c.splice(p, 1);
      let y = { ...t, series: c };
      c.length === 0 && delete y.series, n(y);
    }
    t.visualizationType === "Paired Bar" && n({
      ...t,
      series: []
    });
  }, h = (d, c, p) => {
    d.preventDefault(), o(c.dataKey);
  };
  return t.series && t.series.length > 1 && /* @__PURE__ */ a("button", { className: "series-list__remove", onClick: (d) => h(d, r), children: "Remove" });
}, Lg = (e) => {
  const { config: t, updateConfig: n } = fe.useContext(ft), { updateSeries: r, getColumns: i } = fe.useContext(Ka), { series: o, getItemStyle: h, sortableItemStyles: d, chartsWithOptions: c, index: p } = e, y = [
    { label: "Order By Data Column", value: "dataColumn" },
    {
      label: "Ascending Alphanumeric",
      value: "asc"
    },
    {
      label: "Descending Alphanumeric",
      value: "desc"
    }
  ], g = ["Bar", "Line"].includes(t.visualizationType) && t.visualizationSubType !== "Stacked" && !t.series.find((b) => b.dynamicCategory && b.dataKey !== o.dataKey);
  return /* @__PURE__ */ a(Yg, { draggableId: `draggableFilter-${o.dataKey}`, index: p, children: (b, T) => /* @__PURE__ */ a(
    "div",
    {
      className: T.isDragging ? "currently-dragging" : "",
      style: h(T.isDragging, b.draggableProps.style, d),
      ref: b.innerRef,
      ...b.draggableProps,
      ...b.dragHandleProps,
      children: /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: /* @__PURE__ */ F(Nn, { className: "series-item series-item--chart", children: [
        /* @__PURE__ */ a(Rn, { className: "series-item__title", children: /* @__PURE__ */ F(
          Dn,
          {
            className: c.includes(t.visualizationType) ? "accordion__button" : "accordion__button hide-arrow",
            children: [
              /* @__PURE__ */ a(Ve, { display: "move", size: 15, style: { cursor: "default" } }),
              o.dataKey,
              /* @__PURE__ */ a(oi.Button.Remove, { series: o, index: p })
            ]
          }
        ) }),
        c.includes(t.visualizationType) && /* @__PURE__ */ F(On, { children: [
          /* @__PURE__ */ a(oi.Input.Name, { series: o, index: p }),
          g && /* @__PURE__ */ F(Be, { children: [
            /* @__PURE__ */ a(
              ct,
              {
                label: "Dynamic Category",
                value: o.dynamicCategory,
                options: ["- Select - ", ...i().filter((m) => o.dataKey !== m)],
                updateField: (m, C, w, S) => {
                  S === "- Select -" && (S = ""), r(p, S, "dynamicCategory");
                },
                tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "This field is Optional. If you have a dynamic data series you can select the category field here. You can only add one dynamic category per visualization." }) })
                ] })
              }
            ),
            /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ a(
              ct,
              {
                value: t.legend.order,
                options: y,
                section: "legend",
                fieldName: "order",
                updateField: (m, C, w, S) => {
                  n({ ...t, legend: { ...t.legend, order: S } });
                },
                label: "Dynamic Series Order"
              }
            ) })
          ] }),
          /* @__PURE__ */ a(oi.Input.Weight, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Dropdown.SeriesType, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Dropdown.AxisPosition, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Dropdown.LineType, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Dropdown.ForecastingColor, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Dropdown.ConfidenceInterval, { series: o, index: p }),
          /* @__PURE__ */ a(oi.Checkbox.DisplayInTooltip, { series: o, index: p })
        ] })
      ] }) })
    },
    p
  ) }, o.dataKey);
}, vT = (e) => {
  const { series: t, getItemStyle: n, sortableItemStyles: r, chartsWithOptions: i } = e;
  return t.map((o, h) => /* @__PURE__ */ a(
    Lg,
    {
      getItemStyle: n,
      sortableItemStyles: r,
      chartsWithOptions: i,
      series: o,
      index: h
    },
    `series-list-${h}`
  ));
}, oi = {
  Wrapper: oT,
  Dropdown: {
    SeriesType: lT,
    AxisPosition: dT,
    ConfidenceInterval: fT,
    LineType: sT,
    ForecastingStage: uT,
    ForecastingColumn: cT,
    ForecastingColor: hT
  },
  Input: {
    Name: mT,
    Weight: pT
  },
  Checkbox: {
    DisplayInTooltip: yT
  },
  Button: {
    Remove: gT
  },
  Item: Lg,
  List: vT
}, bT = fe.memo(({ config: e, updateConfig: t }) => {
  let n = (c, p, y) => {
    let g = [];
    e.regions && (g = [...e.regions]), g[y][c] = p, t({ ...e, regions: g });
  }, r = (c, p, y, g, b) => n(y, g, b), i = (c) => {
    let p = [];
    e.regions && (p = [...e.regions]), p.splice(c, 1), t({ ...e, regions: p });
  }, o = () => {
    let c = [];
    e.regions && (c = [...e.regions]), c.push({}), t({ ...e, regions: c });
  };
  const h = ["Fixed", "Previous Days"], d = ["Last Date", "Fixed"];
  return /* @__PURE__ */ F(Be, { children: [
    e.regions && e.regions.map(({ label: c, color: p, from: y, to: g, background: b, range: T = "Custom" }, m) => {
      var C;
      return /* @__PURE__ */ F("div", { className: "edit-block", children: [
        /* @__PURE__ */ a(
          "button",
          {
            type: "button",
            className: "btn btn-danger remove-column",
            onClick: (w) => {
              w.preventDefault(), i(m);
            },
            children: "Remove"
          }
        ),
        /* @__PURE__ */ a(ze, { value: c, label: "Region Label", fieldName: "label", i: m, updateField: r }),
        /* @__PURE__ */ F("div", { className: "two-col-inputs", children: [
          /* @__PURE__ */ a(
            ze,
            {
              value: p,
              label: "Text Color",
              fieldName: "color",
              updateField: (w, S, B, M) => n(B, M, m)
            }
          ),
          /* @__PURE__ */ a(
            ze,
            {
              value: b,
              label: "Background",
              fieldName: "background",
              updateField: (w, S, B, M) => n(B, M, m)
            }
          )
        ] }),
        /* @__PURE__ */ a(
          ct,
          {
            value: e.regions[m].fromType ?? "Fixed",
            label: "Minimum Region Type",
            initial: "Select",
            required: !0,
            onChange: (w) => {
              if (w.target.value !== "" && w.target.value !== "Select") {
                const S = [...e.regions];
                S[m].fromType = w.target.value, t({
                  ...e,
                  regions: S
                });
              }
              w.target.value = "";
            },
            options: h
          }
        ),
        (e.regions[m].fromType === "Fixed" || e.regions[m].fromType === "Previous Days" || !e.regions[m].fromType) && /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ a(
          ze,
          {
            value: y,
            label: e.regions[m].fromType === "Fixed" || !((C = e.regions[m]) != null && C.fromType) ? "From Value" : "Previous Number of Days",
            fieldName: "from",
            updateField: (w, S, B, M) => n(B, M, m),
            tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "When using categorical (linear scale) match the data set value. When using date (linear / date time scale) match the x-axis value." }) })
            ] })
          }
        ) }),
        /* @__PURE__ */ a(
          ct,
          {
            value: e.regions[m].toType ?? "Fixed",
            label: "Maximum Region Type",
            initial: "Select",
            required: !0,
            onChange: (w) => {
              if (w.target.value !== "" && w.target.value !== "Select") {
                const S = [...e.regions];
                S[m].toType = w.target.value, t({
                  ...e,
                  regions: S
                });
              }
              w.target.value = "";
            },
            options: d
          }
        ),
        (e.regions[m].toType === "Fixed" || !e.regions[m].toType) && /* @__PURE__ */ a(
          ze,
          {
            value: g,
            label: "To Value",
            fieldName: "to",
            updateField: (w, S, B, M) => n(B, M, m)
          }
        )
      ] }, `region-${m}`);
    }),
    !e.regions && /* @__PURE__ */ a("p", { style: { textAlign: "center" }, children: "There are currently no regions." }),
    /* @__PURE__ */ a(
      "button",
      {
        type: "button",
        className: "btn btn-primary full-width",
        onClick: (c) => {
          c.preventDefault(), o();
        },
        children: "Add Region"
      }
    )
  ] });
}), xT = ({ name: e }) => {
  const { visSupportsRegions: t } = Hl(), { config: n, updateConfig: r } = fe.useContext(ft);
  return t() ? /* @__PURE__ */ F(Nn, { children: [
    /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ a(Dn, { children: e }) }),
    /* @__PURE__ */ a(On, { children: /* @__PURE__ */ a(bT, { config: n, updateConfig: r }) })
  ] }) : null;
}, zf = fe.createContext(null), $f = () => {
  const e = fe.useContext(zf);
  if (e === null)
    throw new Error("COVE: editor panel context is null.");
  return e;
}, ST = (e) => {
  const { config: t } = fe.useContext(ft), { updateField: n } = $f(), {
    enabledChartTypes: r,
    visHasNumbersOnBars: i,
    visHasaAdditionalLabelsOnBars: o,
    visHasLabelOnData: h,
    visSupportsChartHeight: d,
    visSupportsMobileChartHeight: c,
    visSupportsSuperTitle: p,
    visSupportsFootnotes: y
  } = Hl(), { visualizationType: g, visualizationSubType: b, barStyle: T } = t, m = () => (g === "Bar" || g === "Deviation Bar") && b !== "stacked" && (t.orientation === "horizontal" || t.orientation === "vertical") ? ["flat", "rounded", "lollipop"] : ["flat", "rounded"];
  return /* @__PURE__ */ F(Nn, { children: [
    " ",
    /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ a(Dn, { children: "General" }) }),
    /* @__PURE__ */ F(On, { children: [
      (t == null ? void 0 : t.visualizationType) !== "Sankey" && /* @__PURE__ */ a(
        ct,
        {
          value: g,
          fieldName: "visualizationType",
          label: "Chart Type",
          updateField: n,
          options: r
        }
      ),
      d() && t.orientation === "vertical" && /* @__PURE__ */ F("div", { className: c() ? "two-col-inputs" : "", children: [
        /* @__PURE__ */ a(
          ze,
          {
            type: "number",
            value: t.heights.vertical,
            section: "heights",
            fieldName: "vertical",
            label: "Chart Height",
            updateField: n,
            tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ F(ee.Target, { children: [
                "˝",
                /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } })
              ] }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "For some visualization types, such as the Sankey diagram, it may be necessary to adjust the chart height for optimal display." }) })
            ] })
          }
        ),
        c() && t.orientation === "vertical" && /* @__PURE__ */ a(
          ze,
          {
            type: "number",
            value: t.heights.mobileVertical,
            section: "heights",
            fieldName: "mobileVertical",
            label: "Mobile Height",
            updateField: n,
            tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "If the chart height is not optimized for mobile, you can adjust the height for better display. Not setting a value will default to the chart height." }) })
            ] })
          }
        )
      ] }),
      (g === "Bar" || g === "Combo") && /* @__PURE__ */ a(
        ct,
        {
          value: b || "Regular",
          fieldName: "visualizationSubType",
          label: "Chart Subtype",
          updateField: n,
          options: ["regular", "stacked"]
        }
      ),
      g === "Area Chart" && b === "stacked" && /* @__PURE__ */ a(
        ct,
        {
          value: t.stackedAreaChartLineType || "Linear",
          fieldName: "stackedAreaChartLineType",
          label: "Stacked Area Chart Line Type",
          updateField: n,
          options: Object.keys(os)
        }
      ),
      g === "Bar" && /* @__PURE__ */ a(
        ct,
        {
          value: t.orientation || "vertical",
          fieldName: "orientation",
          label: "Orientation",
          updateField: n,
          options: ["vertical", "horizontal"]
        }
      ),
      g === "Deviation Bar" && /* @__PURE__ */ a(ct, { label: "Orientation", options: ["horizontal"] }),
      (g === "Bar" || g === "Deviation Bar") && /* @__PURE__ */ a(
        ct,
        {
          value: t.isLollipopChart ? "lollipop" : T || "flat",
          fieldName: "barStyle",
          label: "bar style",
          updateField: n,
          options: m(),
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Consider using the 'Flat' bar style when presenting data that includes '0' values." }) })
          ] })
        }
      ),
      (g === "Bar" || g === "Deviation Bar") && T === "rounded" && /* @__PURE__ */ a(
        ct,
        {
          value: t.tipRounding || "top",
          fieldName: "tipRounding",
          label: "tip rounding",
          updateField: n,
          options: ["top", "full"]
        }
      ),
      (g === "Bar" || g === "Deviation Bar") && T === "rounded" && /* @__PURE__ */ a(
        ct,
        {
          value: t.roundingStyle || "standard",
          fieldName: "roundingStyle",
          label: "rounding style",
          updateField: n,
          options: ["standard", "shallow", "finger"]
        }
      ),
      g === "Bar" && t.orientation === "horizontal" && /* @__PURE__ */ a(
        ct,
        {
          value: t.yAxis.labelPlacement || "Below Bar",
          section: "yAxis",
          fieldName: "labelPlacement",
          label: "Label Placement",
          updateField: n,
          options: ["Below Bar", "On Date/Category Axis"]
        }
      ),
      i() ? /* @__PURE__ */ a(
        Ue,
        {
          value: t.yAxis.displayNumbersOnBar,
          section: "yAxis",
          fieldName: "displayNumbersOnBar",
          label: t.isLollipopChart ? "Display Numbers after Bar" : "Display Numbers on Bar",
          updateField: n
        }
      ) : h() && /* @__PURE__ */ a(
        Ue,
        {
          value: t.labels,
          fieldName: "labels",
          label: "Display label on data",
          updateField: n,
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ F(ee.Content, { children: [
              /* @__PURE__ */ a("p", { children: "Recommended set to display for Section 508 compliance." }),
              /* @__PURE__ */ a("hr", {}),
              /* @__PURE__ */ F("p", { children: [
                "Selecting this option will ",
                /* @__PURE__ */ a("i", { children: " not " }),
                ' hide the display of "zero value", "suppressed data", or "missing data" indicators on the chart (if applicable).'
              ] })
            ] })
          ] })
        }
      ),
      o() && /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ a(
          Ue,
          {
            tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Selecting this option will display a thin line slightly above the Date/Category Axis to indicate "zero value" where zero values are indicated in the Data Series.' }) })
            ] }),
            value: t.general.showZeroValueData,
            section: "general",
            fieldName: "showZeroValueData",
            label: 'Display "Zero Data" Label',
            updateField: n
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ F(ee.Content, { children: [
                t.visualizationSubType === "stacked" && /* @__PURE__ */ a("p", { children: "We do not recommend using stacked vertical/horizontal bar charts for missing data. If you choose to proceed, selecting this option will display 'N/A' in the tooltip hover and data table (e.g. nothing will display in chart)." }),
                t.visualizationSubType !== "stacked" && /* @__PURE__ */ a("p", { children: "Selecting this option will display 'N/A' on the Date/Category Axis, in the tooltip hover, and in the data table to indicate missing or undefined data values." })
              ] })
            ] }),
            value: t.general.showMissingDataLabel,
            section: "general",
            fieldName: "showMissingDataLabel",
            label: 'Display "Missing Data" Label',
            updateField: n
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            display: t.visualizationType === "Bar" || t.visualizationType === "Combo",
            tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting 'Remove Null Values' will hide the 'N/A' (no data indicator) when you hover over the chart." }) })
            ] }),
            value: t.general.hideNullValue,
            section: "general",
            fieldName: "hideNullValue",
            label: 'Remove "Null" Values From Hover',
            updateField: n
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
              /* @__PURE__ */ F(ee.Content, { children: [
                t.visualizationSubType !== "stacked" && /* @__PURE__ */ F("p", { children: [
                  "Selecting this option will show the ",
                  /* @__PURE__ */ a("i", { children: "suppression indicator " }),
                  " on the Date/Category axis, within tooltips, and in the data table where suppressed data values appear in the Data Series."
                ] }),
                t.visualizationSubType === "stacked" && /* @__PURE__ */ a("p", { children: "We do not recommend using stacked vertical/horizontal bar charts for suppressed data. If you choose to proceed, selecting this option will display the 'suppressed data symbol' in the tooltip hover and data table (e.g., nothing will display in the chart)." })
              ] })
            ] }),
            value: t.general.showSuppressedSymbol,
            section: "general",
            fieldName: "showSuppressedSymbol",
            label: 'Display "suppressed data" label',
            updateField: n
          }
        )
      ] }),
      g === "Pie" && /* @__PURE__ */ a(ct, { fieldName: "pieType", label: "Pie Chart Type", updateField: n, options: ["Regular", "Donut"] }),
      g === "Line" && /* @__PURE__ */ a(
        Ue,
        {
          value: t.allowLineToBarGraph,
          fieldName: "allowLineToBarGraph",
          label: "Convert to Bar Graph",
          updateField: n,
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Switch to bar graph when less than 3 data points available." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          value: t.title || "Chart Title",
          fieldName: "title",
          id: "title",
          label: "Title",
          placeholder: "Chart Title",
          updateField: n,
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Title is required to set the name of the download file but can be hidden using the option below." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(Ue, { value: t.showTitle, fieldName: "showTitle", label: "Show Title", updateField: n }),
      p() && /* @__PURE__ */ a(
        ze,
        {
          value: t.superTitle,
          updateField: n,
          fieldName: "superTitle",
          label: "Super Title",
          placeholder: "Super Title",
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Super Title" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          type: "textarea",
          value: t.introText,
          updateField: n,
          fieldName: "introText",
          label: "Message",
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Intro Text" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          type: "textarea",
          value: t.description,
          fieldName: "description",
          label: "Subtext/Citation",
          updateField: n,
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter supporting text to display below the data visualization, if applicable. The following HTML tags are supported: strong, em, sup, and sub." }) })
          ] })
        }
      ),
      y() && /* @__PURE__ */ a(
        ze,
        {
          type: "textarea",
          value: t.footnotes,
          updateField: n,
          fieldName: "footnotes",
          label: "Footnotes",
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Consider adding footnotes when displaying 'suppressed,' 'no data,' and 'zero values' to ensure accurate interpretation of the data." }) })
          ] })
        }
      )
    ] })
  ] });
}, wT = (e) => {
  const { config: t } = fe.useContext(ft), { boxplot: n } = t;
  if (t.visualizationType !== "Box Plot")
    return;
  const { updateField: r } = $f();
  return /* @__PURE__ */ F(Nn, { children: [
    /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ a(Dn, { children: e.name }) }),
    /* @__PURE__ */ F(On, { children: [
      /* @__PURE__ */ a("h4", { style: { fontSize: "18px" }, children: "Labels for 5-Number Summary" }),
      /* @__PURE__ */ a(
        ze,
        {
          type: "text",
          value: n.labels.maximum,
          fieldName: "maximum",
          section: "boxplot",
          subsection: "labels",
          label: "Maximum",
          updateField: r,
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Highest value, excluding outliers" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          type: "text",
          value: n.labels.q3,
          fieldName: "q3",
          section: "boxplot",
          subsection: "labels",
          label: "Upper Quartile",
          updateField: r,
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Represented by top line of box. 25% of data are higher." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          type: "text",
          value: n.labels.median,
          fieldName: "median",
          section: "boxplot",
          subsection: "labels",
          label: "Median",
          updateField: r,
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Middle data point. Half of data are higher value." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          type: "text",
          value: n.labels.q1,
          fieldName: "q1",
          section: "boxplot",
          subsection: "labels",
          label: "Lower Quartile",
          updateField: r,
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Represented by bottom line of box. 25% of data are lower." }) })
          ] })
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          type: "text",
          value: n.labels.minimum,
          fieldName: "minimum",
          section: "boxplot",
          subsection: "labels",
          label: "Minimum",
          updateField: r,
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Lowest value, excluding outliers" }) })
          ] })
        }
      ),
      /* @__PURE__ */ a("br", {}),
      /* @__PURE__ */ a("h4", { style: { fontSize: "18px" }, children: "Labels for Additional Measures" }),
      /* @__PURE__ */ a(
        ze,
        {
          type: "text",
          value: n.labels.iqr,
          fieldName: "iqr",
          section: "boxplot",
          subsection: "labels",
          label: "Interquartile Range",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          type: "text",
          value: n.labels.count,
          fieldName: "count",
          section: "boxplot",
          subsection: "labels",
          label: "Count",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          type: "text",
          value: n.labels.mean,
          fieldName: "mean",
          section: "boxplot",
          subsection: "labels",
          label: "Mean",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          type: "text",
          value: n.labels.outliers,
          fieldName: "outliers",
          section: "boxplot",
          subsection: "labels",
          label: "Outliers",
          updateField: r
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          type: "text",
          value: n.labels.values,
          fieldName: "values",
          section: "boxplot",
          subsection: "labels",
          label: "Values",
          updateField: r
        }
      )
    ] })
  ] });
}, kT = (e, t) => {
  let n = [], r = [], i = [];
  const o = [];
  if (e.visualizationType === "Paired Bar" || e.visualizationType === "Deviation Bar") {
    const h = e.twoColor.isPaletteReversed;
    n = Object.keys(Mc).filter(
      (d) => h ? d.endsWith("reverse") : !d.endsWith("reverse")
    );
  } else {
    const h = [], d = [];
    for (const c in _r) {
      const p = c.startsWith("sequential"), y = c.startsWith("qualitative"), g = c.startsWith("colorblindsafe"), b = c.endsWith("reverse");
      p && (!e.isPaletteReversed && !b || e.isPaletteReversed && b) && h.push(c), y && (!e.isPaletteReversed && !b || e.isPaletteReversed && b) && d.push(c), g && (!e.isPaletteReversed && !b || e.isPaletteReversed && b) && o.push(c);
    }
    r = h, i = d;
  }
  return fe.useEffect(() => {
    let h = "";
    e.twoColor.isPaletteReversed && !e.twoColor.palette.endsWith("reverse") && (h = e.twoColor.palette + "reverse"), !e.twoColor.isPaletteReversed && e.twoColor.palette.endsWith("reverse") && (h = e.twoColor.palette.slice(0, -7)), t({ ...e, twoColor: { ...e.twoColor, palette: h } });
  }, [e.twoColor.isPaletteReversed]), fe.useEffect(() => {
    let h = "";
    e.isPaletteReversed && !e.palette.endsWith("reverse") && (h = e.palette + "reverse"), !e.isPaletteReversed && e.palette.endsWith("reverse") && (h = e.palette.slice(0, -7)), t({ ...e, palette: h });
  }, [e.isPaletteReversed]), { twoColorPalettes: n, sequential: r, nonSequential: i, accessibleColors: o };
}, TT = (e) => {
  var ne;
  const { config: t, updateConfig: n, colorPalettes: r, twoColorPalette: i } = fe.useContext(ft), { visual: o } = t, { setLollipopShape: h, updateField: d } = $f(), {
    visHasBarBorders: c,
    visCanAnimate: p,
    visSupportsNonSequentialPallete: y,
    headerColors: g,
    visSupportsTooltipOpacity: b,
    visSupportsTooltipLines: T,
    visSupportsBarSpace: m,
    visSupportsBarThickness: C,
    visHasDataCutoff: w,
    visSupportsSequentialPallete: S,
    visSupportsReverseColorPalette: B,
    visHasSingleSeriesTooltip: M
  } = Hl(), { twoColorPalettes: D, sequential: O, nonSequential: L, accessibleColors: U } = kT(t, n), X = (G, ce) => {
    if (console.log("value", ce), G === "storyNodeFontColor") {
      n({
        ...t,
        sankey: {
          ...t.sankey,
          storyNodeFontColor: ce
        }
      });
      return;
    } else
      n({
        ...t,
        sankey: {
          ...t.sankey,
          [G]: {
            ...t.sankey[G],
            default: ce
          }
        }
      });
  };
  return /* @__PURE__ */ F(Nn, { children: [
    /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ a(Dn, { children: "Visual" }) }),
    /* @__PURE__ */ F(On, { children: [
      (t.barStyle === "lollipop" || t.isLollipopChart) && /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ F("fieldset", { className: "header", children: [
          /* @__PURE__ */ a("legend", { className: "edit-label", children: "Lollipop Shape" }),
          /* @__PURE__ */ F(
            "div",
            {
              onChange: (G) => {
                h(G.target.value);
              },
              children: [
                /* @__PURE__ */ F("label", { className: "radio-label", children: [
                  /* @__PURE__ */ a("input", { type: "radio", name: "lollipopShape", value: "circle", checked: t.lollipopShape === "circle" }),
                  "Circle"
                ] }),
                /* @__PURE__ */ F("label", { className: "radio-label", children: [
                  /* @__PURE__ */ a("input", { type: "radio", name: "lollipopShape", value: "square", checked: t.lollipopShape === "square" }),
                  "Square"
                ] })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ a(
          ct,
          {
            value: t.lollipopColorStyle ? t.lollipopColorStyle : "two-tone",
            fieldName: "lollipopColorStyle",
            label: "Lollipop Color Style",
            updateField: d,
            options: ["regular", "two-tone"]
          }
        ),
        /* @__PURE__ */ a(
          ct,
          {
            value: t.lollipopSize ? t.lollipopSize : "small",
            fieldName: "lollipopSize",
            label: "Lollipop Size",
            updateField: d,
            options: ["small", "medium", "large"]
          }
        )
      ] }),
      t.visualizationType === "Box Plot" && /* @__PURE__ */ F("fieldset", { className: "fieldset fieldset--boxplot", children: [
        /* @__PURE__ */ a("legend", { className: "", children: "Box Plot Settings" }),
        /* @__PURE__ */ a(
          ct,
          {
            value: t.boxplot.borders,
            fieldName: "borders",
            section: "boxplot",
            label: "Box Plot Borders",
            updateField: d,
            options: ["true", "false"]
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            value: t.boxplot.plotOutlierValues,
            fieldName: "plotOutlierValues",
            section: "boxplot",
            label: "Plot Outliers",
            updateField: d
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            value: t.boxplot.plotNonOutlierValues,
            fieldName: "plotNonOutlierValues",
            section: "boxplot",
            label: "Plot non-outlier values",
            updateField: d
          }
        )
      ] }),
      c() && /* @__PURE__ */ a(
        ct,
        {
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
              Ve,
              {
                display: "question",
                style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
              }
            ) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Recommended set to display for Section 508 compliance." }) })
          ] }),
          value: t.barHasBorder,
          fieldName: "barHasBorder",
          label: "Bar Borders",
          updateField: d,
          options: ["true", "false"]
        }
      ),
      p() && /* @__PURE__ */ a(
        Ue,
        {
          value: t.animate,
          fieldName: "animate",
          label: "Animate Visualization",
          updateField: d
        }
      ),
      (((ne = t.series) == null ? void 0 : ne.some(
        (G) => G.type === "Line" || G.type === "dashed-lg" || G.type === "dashed-sm" || G.type === "dashed-md"
      )) && t.visualizationType === "Combo" || t.visualizationType === "Line") && /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ a(
          ct,
          {
            tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
              /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                Ve,
                {
                  display: "question",
                  style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                }
              ) }),
              /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Shapes will appear in the following order: circle, square, triangle, diamond, and inverted triangle. Use with a maximum of 5 data points." }) })
            ] }),
            value: t.visual.lineDatapointSymbol,
            section: "visual",
            fieldName: "lineDatapointSymbol",
            label: "Line Datapoint Symbols",
            updateField: d,
            options: ["none", "standard"]
          }
        ),
        t.series.length > t.visual.maximumShapeAmount && t.visual.lineDatapointSymbol === "standard" && /* @__PURE__ */ a("small", { className: "text-danger", children: "Standard only supports up to 7 data points" }),
        /* @__PURE__ */ a(
          ct,
          {
            value: t.lineDatapointStyle,
            fieldName: "lineDatapointStyle",
            label: "Line Datapoint Style",
            updateField: d,
            options: ["hidden", "hover", "always show"]
          }
        ),
        /* @__PURE__ */ a(
          ct,
          {
            value: t.lineDatapointColor,
            fieldName: "lineDatapointColor",
            label: "Line Datapoint Color",
            updateField: d,
            options: ["Same as Line", "Lighter than Line"]
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            value: !t.isolatedDotsSameSize,
            fieldName: "isolatedDotsSameSize",
            label: "Accentuate isolated data points",
            updateField: (G, ce, q, re) => d(G, ce, q, !re)
          }
        )
      ] }),
      /* @__PURE__ */ F("label", { className: "header", children: [
        /* @__PURE__ */ a("span", { className: "edit-label", children: "Header Theme" }),
        /* @__PURE__ */ a("ul", { className: "color-palette", children: g.map((G) => /* @__PURE__ */ a(
          "button",
          {
            title: G,
            onClick: (ce) => {
              ce.preventDefault(), n({ ...t, theme: G });
            },
            className: t.theme === G ? "selected " + G : G
          },
          G
        )) })
      ] }),
      (y() || y()) && /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ a("label", { children: /* @__PURE__ */ a("span", { className: "edit-label", children: "Chart Color Palette" }) }),
        B() && /* @__PURE__ */ a(
          qf,
          {
            fieldName: "isPaletteReversed",
            size: "small",
            label: "Use selected palette in reverse order",
            updateField: d,
            value: t.isPaletteReversed
          }
        ),
        S() && /* @__PURE__ */ F(Be, { children: [
          /* @__PURE__ */ a("span", { children: "Sequential" }),
          /* @__PURE__ */ a("ul", { className: "color-palette", children: O.map((G) => {
            const ce = {
              backgroundColor: r[G][2]
            }, q = {
              backgroundColor: r[G][3]
            }, re = {
              backgroundColor: r[G][5]
            };
            return /* @__PURE__ */ F(
              "button",
              {
                title: G,
                onClick: ($) => {
                  $.preventDefault(), n({ ...t, palette: G });
                },
                className: t.palette === G ? "selected" : "",
                children: [
                  /* @__PURE__ */ a("span", { style: ce }),
                  /* @__PURE__ */ a("span", { style: q }),
                  /* @__PURE__ */ a("span", { style: re })
                ]
              },
              G
            );
          }) })
        ] }),
        y() && /* @__PURE__ */ F(Be, { children: [
          /* @__PURE__ */ a("span", { children: "Non-Sequential" }),
          /* @__PURE__ */ a("ul", { className: "color-palette", children: L.map((G) => {
            const ce = {
              backgroundColor: r[G][2]
            }, q = {
              backgroundColor: r[G][4]
            }, re = {
              backgroundColor: r[G][6]
            };
            return /* @__PURE__ */ F(
              "button",
              {
                title: G,
                onClick: ($) => {
                  $.preventDefault(), n({ ...t, palette: G });
                },
                className: t.palette === G ? "selected" : "",
                children: [
                  /* @__PURE__ */ a("span", { style: ce }),
                  /* @__PURE__ */ a("span", { style: q }),
                  /* @__PURE__ */ a("span", { style: re })
                ]
              },
              G
            );
          }) }),
          /* @__PURE__ */ a("span", { children: "Colorblind Safe" }),
          /* @__PURE__ */ a("ul", { className: "color-palette", children: U.map((G) => {
            const ce = {
              backgroundColor: r[G][2]
            }, q = {
              backgroundColor: r[G][3]
            }, re = {
              backgroundColor: r[G][5]
            };
            return /* @__PURE__ */ F(
              "button",
              {
                title: G,
                onClick: ($) => {
                  $.preventDefault(), n({ ...t, palette: G });
                },
                className: t.palette === G ? "selected" : "",
                children: [
                  /* @__PURE__ */ a("span", { style: ce }),
                  /* @__PURE__ */ a("span", { style: q }),
                  /* @__PURE__ */ a("span", { style: re })
                ]
              },
              G
            );
          }) })
        ] })
      ] }),
      t.visualizationType === "Sankey" && /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ F("span", { className: "sankey__color-input", children: [
          /* @__PURE__ */ a(
            "input",
            {
              type: "color",
              value: t.sankey.nodeColor.default,
              id: "storyNodeColor",
              name: "storyNodeColor",
              onChange: (G) => X("nodeColor", G.target.value)
            }
          ),
          /* @__PURE__ */ a("label", { htmlFor: "storyNodeColor", children: "Story Node Color" })
        ] }),
        /* @__PURE__ */ F("span", { className: "sankey__color-input", children: [
          /* @__PURE__ */ a(
            "input",
            {
              type: "color",
              value: t.sankey.storyNodeFontColor || "red",
              id: "storyNodeFontColor",
              name: "storyNodeFontColor",
              onChange: (G) => X("storyNodeFontColor", G.target.value)
            }
          ),
          /* @__PURE__ */ a("label", { htmlFor: "storyNodeFontColor", children: "Story Node Font Color" })
        ] }),
        /* @__PURE__ */ F("span", { className: "sankey__color-input", children: [
          /* @__PURE__ */ a(
            "input",
            {
              type: "color",
              value: t.sankey.linkColor.default,
              id: "linkColor",
              name: "linkColor",
              onChange: (G) => X("linkColor", G.target.value)
            }
          ),
          /* @__PURE__ */ a("label", { htmlFor: "linkColor", children: "Link Color" })
        ] })
      ] }),
      (t.visualizationType === "Paired Bar" || t.visualizationType === "Deviation Bar") && /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ a(
          qf,
          {
            section: "twoColor",
            fieldName: "isPaletteReversed",
            size: "small",
            label: "Use selected palette in reverse order",
            updateField: d,
            value: t.twoColor.isPaletteReversed
          }
        ),
        /* @__PURE__ */ a("ul", { className: "color-palette", children: D.map((G) => {
          const ce = {
            backgroundColor: i[G][0]
          }, q = {
            backgroundColor: i[G][1]
          };
          return /* @__PURE__ */ F(
            "button",
            {
              title: G,
              onClick: (re) => {
                re.preventDefault(), n({ ...t, twoColor: { ...t.twoColor, palette: G } });
              },
              className: t.twoColor.palette === G ? "selected" : "",
              children: [
                /* @__PURE__ */ a("span", { className: "two-color", style: ce }),
                /* @__PURE__ */ a("span", { className: "two-color", style: q })
              ]
            },
            G
          );
        }) })
      ] }),
      w() && /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ a(
        ze,
        {
          value: t.dataCutoff,
          type: "number",
          fieldName: "dataCutoff",
          className: "number-narrow",
          label: "Data Cutoff",
          updateField: d,
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Any value below the cut-off value is included in a special "less than" category. This option supports special conditions like suppressed data.' }) })
          ] })
        }
      ) }),
      C() && t.orientation === "horizontal" && !t.isLollipopChart && t.yAxis.labelPlacement !== "On Bar" && /* @__PURE__ */ a(
        ze,
        {
          type: "number",
          value: t.barHeight || "25",
          fieldName: "barHeight",
          label: " Bar Thickness",
          updateField: d,
          min: 15
        }
      ),
      (t.orientation !== "horizontal" || t.visualizationType === "Combo") && /* @__PURE__ */ a(
        ze,
        {
          value: t.barThickness,
          type: "number",
          fieldName: "barThickness",
          label: "Bar Thickness",
          updateField: d
        }
      ),
      m() && /* @__PURE__ */ a(
        ze,
        {
          type: "number",
          value: t.barSpace || "15",
          fieldName: "barSpace",
          label: "Bar Space",
          updateField: d,
          min: 0
        }
      ),
      (t.visualizationType === "Bar" || t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ a(
        Ue,
        {
          value: t.topAxis.hasLine,
          section: "topAxis",
          fieldName: "hasLine",
          label: "Add Top Axis Line",
          updateField: d
        }
      ),
      t.visualizationType === "Spark Line" && /* @__PURE__ */ F("div", { className: "cove-accordion__panel-section checkbox-group", children: [
        /* @__PURE__ */ a(
          Ue,
          {
            value: o == null ? void 0 : o.border,
            section: "visual",
            fieldName: "border",
            label: "Show Border",
            updateField: d
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            value: o == null ? void 0 : o.borderColorTheme,
            section: "visual",
            fieldName: "borderColorTheme",
            label: "Use Border Color Theme",
            updateField: d
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            value: o == null ? void 0 : o.accent,
            section: "visual",
            fieldName: "accent",
            label: "Use Accent Style",
            updateField: d
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            value: o == null ? void 0 : o.background,
            section: "visual",
            fieldName: "background",
            label: "Use Theme Background Color",
            updateField: d
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            value: o == null ? void 0 : o.hideBackgroundColor,
            section: "visual",
            fieldName: "hideBackgroundColor",
            label: "Hide Background Color",
            updateField: d
          }
        )
      ] }),
      (t.visualizationType === "Line" || t.visualizationType === "Combo") && /* @__PURE__ */ a(
        Ue,
        {
          value: t.showLineSeriesLabels,
          fieldName: "showLineSeriesLabels",
          label: "Append Series Name to End of Line Charts",
          updateField: d
        }
      ),
      (t.visualizationType === "Line" || t.visualizationType === "Combo") && t.showLineSeriesLabels && /* @__PURE__ */ a(
        Ue,
        {
          value: t.colorMatchLineSeriesLabels,
          fieldName: "colorMatchLineSeriesLabels",
          label: "Match Series Color to Name at End of Line Charts",
          updateField: d
        }
      ),
      T() && /* @__PURE__ */ F(Be, { children: [
        /* @__PURE__ */ a(
          Ue,
          {
            value: o.verticalHoverLine,
            fieldName: "verticalHoverLine",
            section: "visual",
            label: "Vertical Hover Line",
            updateField: d
          }
        ),
        /* @__PURE__ */ a(
          Ue,
          {
            value: o.horizontalHoverLine,
            fieldName: "horizontalHoverLine",
            section: "visual",
            label: "Horizontal Hover Line",
            updateField: d
          }
        )
      ] }),
      b() && /* @__PURE__ */ F("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Tooltip Opacity" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "number",
            value: t.tooltips.opacity ? t.tooltips.opacity : 100,
            onChange: (G) => n({
              ...t,
              tooltips: {
                ...t.tooltips,
                opacity: G.target.value
              }
            })
          }
        )
      ] }),
      M() && /* @__PURE__ */ a(
        Ue,
        {
          value: t.tooltips.singleSeries,
          fieldName: "singleSeries",
          section: "tooltips",
          label: "SHOW HOVER FOR SINGLE DATA SERIES",
          updateField: d
        }
      ),
      /* @__PURE__ */ F("label", { children: [
        /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "No Data Message" }),
        /* @__PURE__ */ a(
          "input",
          {
            type: "text",
            value: t.chartMessage.noData ? t.chartMessage.noData : "",
            onChange: (G) => n({
              ...t,
              chartMessage: {
                ...t.chartMessage,
                noData: G.target.value
              }
            })
          }
        )
      ] })
    ] })
  ] });
}, CT = (e) => {
  var c, p, y, g, b;
  const { config: t, updateConfig: n } = fe.useContext(ft), r = (c = t.data) == null ? void 0 : c[0], { updateField: i } = fe.useContext(zf);
  if (t.visualizationType !== "Sankey")
    return;
  const o = (T, m, C) => {
    let w = [];
    r != null && r.storyNodeText && (w = [...r == null ? void 0 : r.storyNodeText]), w[C][T] = m, n({
      ...t,
      sankey: {
        ...t.sankey,
        data: {
          ...t.sankey.data,
          storyNodeText: w
        }
      }
    });
  }, h = () => {
    const T = r;
    T.storyNodeText.push({
      StoryNode: "",
      segmentTextBefore: "",
      segmentTextAfter: ""
    }), n({
      ...t,
      sankey: {
        ...t.sankey,
        data: [{ ...T }]
      }
    });
  }, d = (T) => {
    const m = r;
    m.storyNodeText.splice(T, 1), n({ ...t, sankey: { ...t.sankey, data: { ...m } } });
  };
  return /* @__PURE__ */ F(Nn, { children: [
    /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ a(Dn, { children: "Sankey Settings" }) }),
    /* @__PURE__ */ F(On, { children: [
      /* @__PURE__ */ a("p", { children: "Node stories can provide additional details to support public health messaging. COVE can display a maximum of 3 node stories." }),
      (r == null ? void 0 : r.storyNodeText) && (r == null ? void 0 : r.storyNodeText.map(({ StoryNode: T, segmentTextBefore: m, segmentTextAfter: C }, w) => /* @__PURE__ */ F(
        "div",
        {
          style: { border: "1px solid black", margin: "15px auto", padding: "15px", borderRadius: "10px" },
          children: [
            /* @__PURE__ */ F("label", { children: [
              "Story Node Text",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "text",
                  value: T,
                  fieldName: "StoryNode",
                  label: "StoryNode",
                  onChange: (S) => o("StoryNode", S.target.value, w)
                }
              )
            ] }),
            /* @__PURE__ */ F("label", { children: [
              "Story Text Before",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "text",
                  value: m,
                  fieldName: "segmentTextBefore",
                  label: "Segment Text Before",
                  onChange: (S) => o("segmentTextBefore", S.target.value, w)
                }
              )
            ] }),
            /* @__PURE__ */ F("label", { children: [
              "Story Text After",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "text",
                  value: C,
                  fieldName: "segmentTextAfter",
                  label: "Segment Text After",
                  onChange: (S) => o("segmentTextAfter", S.target.value, w)
                }
              )
            ] }),
            /* @__PURE__ */ a(Oc, { onClick: (S) => d(w), className: "btn btn-danger full-width", children: "Remove Story Node" })
          ]
        },
        w
      ))),
      ((p = r == null ? void 0 : r.storyNodeText) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ a(
        "button",
        {
          type: "button",
          className: "btn btn-primary full-width",
          onClick: (T) => {
            T.preventDefault(), h();
          },
          children: "Add StoryNode"
        }
      ),
      ((b = (g = (y = t.data) == null ? void 0 : y[0]) == null ? void 0 : g.tooltips) == null ? void 0 : b.length) > 0 && /* @__PURE__ */ a(
        Ue,
        {
          value: t.enableTooltips,
          fieldName: "enableTooltips",
          label: "Enable Tooltips",
          updateField: i
        }
      )
    ] })
  ] });
};
const AT = (e) => {
  var d, c, p;
  const { updateConfig: t, config: n, svgRef: r } = fe.useContext(ft), i = (y, g, b) => {
    var w;
    const T = (w = document.querySelector(".chart-container  > svg")) == null ? void 0 : w.getBoundingClientRect(), m = [T == null ? void 0 : T.width, T == null ? void 0 : T.height], C = [...n == null ? void 0 : n.annotations];
    C[b][g] = y, C[b].savedDimensions = m, t({
      ...n,
      annotations: C
    });
  }, o = () => {
    var T, m, C, w, S, B, M, D, O, L;
    const y = [
      ((C = (m = (T = r == null ? void 0 : r.current) == null ? void 0 : T.width) == null ? void 0 : m.baseVal) == null ? void 0 : C.value) || ((w = r == null ? void 0 : r.current) == null ? void 0 : w.width),
      ((M = (B = (S = r == null ? void 0 : r.current) == null ? void 0 : S.height) == null ? void 0 : B.baseVal) == null ? void 0 : M.value) || ((D = r == null ? void 0 : r.current) == null ? void 0 : D.height)
    ], g = {
      text: "New Annotation",
      snapToNearestPoint: !1,
      fontSize: 16,
      bezier: 10,
      show: {
        desktop: !0,
        tablet: !0,
        mobile: !0
      },
      connectorType: "line",
      colors: {
        label: "black",
        connector: "black",
        marker: "black"
      },
      selected: !0,
      anchor: {
        vertical: !1,
        horizontal: !1
      },
      marker: "arrow",
      edit: {
        subject: !0,
        label: !0
      },
      seriesKey: "",
      x: 50,
      y: Number((y == null ? void 0 : y[1]) / 2),
      xKey: n.xAxis.type === "date" ? new Date((L = (O = n == null ? void 0 : n.data) == null ? void 0 : O[0]) == null ? void 0 : L[n.xAxis.dataKey]).getTime() : n.xAxis.type === "categorical" ? "1/15/2016" : "",
      yKey: "",
      dx: 20,
      dy: -20,
      opacity: "100",
      savedDimensions: y,
      connectionType: "line"
    }, b = Array.isArray(n.annotations) ? n.annotations : [];
    t({
      ...n,
      annotations: [...b, g]
    });
  }, h = (y) => {
    const g = n.annotations.filter((b, T) => T !== y);
    t({
      ...n,
      annotations: g
    });
  };
  return /* @__PURE__ */ a(Du, { children: /* @__PURE__ */ F(Du.Section, { title: e.name, children: [
    /* @__PURE__ */ F("label", { children: [
      "Show Annotation Dropdown",
      /* @__PURE__ */ a(
        "input",
        {
          type: "checkbox",
          checked: ((d = n == null ? void 0 : n.general) == null ? void 0 : d.showAnnotationDropdown) || !1,
          onChange: (y) => {
            t({
              ...n,
              general: {
                ...n.general,
                showAnnotationDropdown: y.target.checked
              }
            });
          }
        }
      )
    ] }, "key-1"),
    n.general.showAnnotationDropdown && /* @__PURE__ */ F("label", { children: [
      "Annotation Dropdown Title:",
      /* @__PURE__ */ a(
        "input",
        {
          type: "text",
          style: { marginBottom: "10px" },
          value: (c = n == null ? void 0 : n.general) == null ? void 0 : c.annotationDropdownText,
          onChange: (y) => {
            t({
              ...n,
              general: {
                ...n.general,
                annotationDropdownText: y.target.value
              }
            });
          }
        }
      )
    ] }, "key-2"),
    (n == null ? void 0 : n.annotations) && (n == null ? void 0 : n.annotations.map((y, g) => {
      var b, T, m, C, w, S, B, M;
      return /* @__PURE__ */ a(Du, { children: /* @__PURE__ */ a(
        Du.Section,
        {
          title: y.text ? y.text.substring(0, 15) + "..." : `Annotation ${g + 1}`,
          children: /* @__PURE__ */ F("div", { className: "annotation-group", children: [
            /* @__PURE__ */ F("label", { children: [
              "Annotation Text:",
              /* @__PURE__ */ a(
                "textarea",
                {
                  rows: 5,
                  value: y.text,
                  onChange: (D) => i(D.target.value, "text", g)
                }
              )
            ] }),
            /* @__PURE__ */ F("label", { children: [
              "Opacity",
              /* @__PURE__ */ a("br", {}),
              /* @__PURE__ */ a(
                "input",
                {
                  type: "range",
                  onChange: (D) => {
                    const O = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    O[g].opacity = D.target.value, t({
                      ...n,
                      annotations: O
                    });
                  },
                  value: ((T = (b = n == null ? void 0 : n.annotations) == null ? void 0 : b[g]) == null ? void 0 : T.opacity) || "100"
                }
              )
            ] }),
            /* @__PURE__ */ F("label", { children: [
              "Edit Subject",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: ((C = (m = n == null ? void 0 : n.annotations[g]) == null ? void 0 : m.edit) == null ? void 0 : C.subject) || !1,
                  onChange: (D) => {
                    const O = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    O[g].edit.subject = D.target.checked, t({
                      ...n,
                      annotations: O
                    });
                  }
                }
              )
            ] }),
            /* @__PURE__ */ F("label", { children: [
              "Edit Label",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "checkbox",
                  checked: ((S = (w = n == null ? void 0 : n.annotations[g]) == null ? void 0 : w.edit) == null ? void 0 : S.label) || !1,
                  onChange: (D) => {
                    const O = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    O[g].edit.label = D.target.checked, t({
                      ...n,
                      annotations: O
                    });
                  }
                }
              )
            ] }),
            /* @__PURE__ */ F("label", { children: [
              "Connection Type:",
              /* @__PURE__ */ F(
                "select",
                {
                  onChange: (D) => {
                    const O = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    O[g].connectionType = D.target.value, t({
                      ...n,
                      annotations: O
                    });
                  },
                  value: (B = n == null ? void 0 : n.annotations[g]) == null ? void 0 : B.connectionType,
                  children: [
                    /* @__PURE__ */ a("option", { value: "select", children: "Select" }, "select"),
                    ["curve", "line", "elbow", "none"].map((D, O) => /* @__PURE__ */ a("option", { value: D, children: D }, D))
                  ]
                },
                "annotation-connection-type"
              )
            ] }),
            y.connectionType === "curve" && /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F("label", { children: [
              "Curve Control",
              /* @__PURE__ */ a(
                "input",
                {
                  type: "range",
                  min: "-20",
                  max: "20",
                  value: ((M = n == null ? void 0 : n.annotations[g]) == null ? void 0 : M.bezier) || 0,
                  onChange: (D) => {
                    const O = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    O[g].bezier = D.target.value, t({
                      ...n,
                      annotations: O
                    });
                  }
                }
              )
            ] }) }),
            /* @__PURE__ */ F("label", { children: [
              "Marker",
              /* @__PURE__ */ a(
                "select",
                {
                  value: y.marker,
                  onChange: (D) => {
                    const O = Ke.cloneDeep(n == null ? void 0 : n.annotations);
                    O[g].marker = D.target.value, t({
                      ...n,
                      annotations: O
                    });
                  },
                  children: ["arrow", "circle"].map((D, O) => /* @__PURE__ */ a("option", { children: D }, `col-${O}`))
                },
                "annotation-marker"
              )
            ] }),
            /* @__PURE__ */ a(Oc, { className: "btn btn-danger full-width", onClick: () => h(g), children: "Delete Annotation" })
          ] })
        }
      ) }, g);
    })),
    ((p = n == null ? void 0 : n.annotations) == null ? void 0 : p.length) < 3 && /* @__PURE__ */ a("button", { onClick: o, className: "btn btn-primary mt-2 full-width", children: "Add Annotation" })
  ] }, e.name) }, e.name);
}, ki = {
  ForestPlot: aT,
  Series: oi,
  Regions: xT,
  General: ST,
  BoxPlot: wT,
  Visual: TT,
  Sankey: CT,
  Annotate: AT
};
const LT = new Km(), km = (e, t) => {
  for (let n = 0; n < e.length; n++) {
    let r = Object.keys(e[n]), i = !0;
    for (let o = 0; o < r.length; o++)
      if (e[n][r[o]] !== t[r[o]]) {
        i = !1;
        break;
      }
    if (i)
      return n;
  }
  return -1;
}, ET = (e, t, n) => {
  var i;
  const r = Ke.cloneDeep(e);
  if (r.rankByValue = t, e.rankByValue && !t) {
    const o = Object.values(Ke.get(e, "confidenceKeys", {})), d = [...Ke.get(e, "series", []).map((y) => y.dataKey) ?? [], ...o ?? []], c = (i = e == null ? void 0 : e.xAxis) != null && i.dataKey ? LT.cleanData(e.data, e.xAxis.dataKey, d) : e.data, p = n.sort((y, g) => {
      const b = km(c, y), T = km(c, g);
      return b - T;
    });
    return [r, p];
  }
  return [r];
}, _T = ({ config: e, updateConfig: t, data: n }) => {
  var w, S, B;
  const r = e.visualizationType === "Combo", i = ((w = e.runtime.lineSeriesKeys) == null ? void 0 : w.length) > 0, o = ((S = e.runtime.barSeriesKeys) == null ? void 0 : S.length) > 0, h = r && i, d = r && o, c = () => Ke.uniq(Ke.flatMap(n, Ke.keys)), p = () => e.visualizationType === "Line" || h ? ["effect", "suppression"] : ["suppression"], y = {
    "Dashed Small": "- - -",
    "Dashed Medium": "– –",
    "Dashed Large": "— –",
    "Open Circles": "◯",
    "Filled Circles": ""
  }, g = (M) => {
    const D = Object.keys(y);
    return M === "suppression" ? D.slice(0, -2) : D;
  }, b = () => {
    if (e.visualizationType === "Bar" || d)
      return Object.keys(Zf);
  };
  let T = (M) => {
    let D = [];
    e.preliminaryData && (D = [...e.preliminaryData]), D.splice(M, 1), t({ ...e, preliminaryData: D });
  }, m = () => {
    const M = e.visualizationType === "Line" ? "effect" : "suppression";
    let D = e.preliminaryData ? [...e.preliminaryData] : [];
    const O = {
      type: M,
      seriesKey: "",
      label: "Suppressed",
      column: "",
      value: "",
      style: "",
      displayTooltip: !0,
      displayLegend: !0,
      displayTable: !0,
      symbol: "",
      iconCode: "",
      lineCode: "",
      hideBarSymbol: !1,
      hideLineStyle: !1,
      circleSize: 6,
      displayGray: !0
    };
    D.push(O), t({ ...e, preliminaryData: D });
  }, C = (M, D, O) => {
    let L = [];
    e.preliminaryData && (L = [...e.preliminaryData]), L[O][M] = D, M === "symbol" && (L[O].iconCode = Zf[D]), M === "style" && (L[O].lineCode = y[D]), t({ ...e, preliminaryData: L });
  };
  return /* @__PURE__ */ F(Be, { children: [
    e.preliminaryData && ((B = e.preliminaryData) == null ? void 0 : B.map(
      ({
        displayGray: M,
        circleSize: D,
        column: O,
        displayLegend: L,
        displayTable: U,
        displayTooltip: X,
        label: ne,
        seriesKey: G,
        style: ce,
        symbol: q,
        type: re,
        value: $,
        hideBarSymbol: j,
        hideLineStyle: oe
      }, ie) => {
        var le, J;
        return /* @__PURE__ */ F("div", { className: "edit-block", children: [
          /* @__PURE__ */ F("p", { children: [
            " ",
            re === "suppression" ? "Suppressed" : "Effect",
            " Data"
          ] }),
          /* @__PURE__ */ a(
            "button",
            {
              type: "button",
              className: "btn btn-danger",
              onClick: (de) => {
                de.preventDefault(), T(ie);
              },
              children: "Remove"
            }
          ),
          /* @__PURE__ */ a(
            ct,
            {
              value: re,
              initial: e.visualizationType == "Bar" ? "" : "Select",
              fieldName: "type",
              label: "Type",
              updateField: (de, ae, Z, ye) => C(Z, ye, ie),
              options: p()
            }
          ),
          re === "suppression" ? /* @__PURE__ */ F(Be, { children: [
            /* @__PURE__ */ a(
              ct,
              {
                tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ F("p", { children: [
                    " ",
                    'Without a selected "Data Series", the suppression symbol will be applied for all series in the current dataset visualization. However, choosing a specific "data series" will isolate the suppression to that series.'
                  ] }) })
                ] }),
                value: O,
                initial: "Select",
                fieldName: "column",
                label: "Add Data Series",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie),
                options: (le = e.runtime) == null ? void 0 : le.seriesKeys
              }
            ),
            /* @__PURE__ */ a(
              ze,
              {
                value: $,
                fieldName: "value",
                label: "Suppressed Data  Value",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie)
              }
            ),
            (h || e.visualizationType === "Line") && /* @__PURE__ */ F(Be, { children: [
              /* @__PURE__ */ a(
                ct,
                {
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "The recommended approach for presenting data is to include a footnote indicating any data suppression." }) })
                  ] }),
                  value: ce,
                  initial: "Select",
                  fieldName: "style",
                  label: "suppression line style",
                  updateField: (de, ae, Z, ye) => C(Z, ye, ie),
                  options: g(re)
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  value: oe,
                  fieldName: "hideLineStyle",
                  label: "Hide Suppressed line Style",
                  updateField: (de, ae, Z, ye) => C(Z, ye, ie)
                }
              )
            ] }),
            (d || e.visualizationType === "Bar") && /* @__PURE__ */ F(Be, { children: [
              /* @__PURE__ */ a(
                ct,
                {
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ F("p", { children: [
                      "A symbol is ",
                      /* @__PURE__ */ a("i", { children: "required" }),
                      ' to indicate suppressed data. We suggest "double asterisks." If "double asterisks" are already used elsewhere (e.g., footnotes), please select an alternative symbol from the menu to denote data suppression.'
                    ] }) })
                  ] }),
                  value: q,
                  initial: "Select",
                  fieldName: "symbol",
                  label: e.visualizationType === "Combo" ? "suppression bar symbol" : "suppression symbol",
                  updateField: (de, ae, Z, ye) => C(Z, ye, ie),
                  options: b()
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  value: j,
                  fieldName: "hideBarSymbol",
                  label: "Hide Suppressed Bar Symbol  ",
                  updateField: (de, ae, Z, ye) => C(Z, ye, ie)
                }
              )
            ] }),
            /* @__PURE__ */ a(
              ze,
              {
                tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "This label will display in the tooltip and legend." }) })
                ] }),
                value: ne || "Suppressed",
                fieldName: "label",
                label: "Suppressed Data Label",
                placeholder: "",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie)
              }
            ),
            /* @__PURE__ */ a(
              Ue,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Deselecting the "Display In Tooltips" option prevents suppressed values from appearing in tooltips.' }) })
                ] }),
                value: X,
                fieldName: "displayTooltip",
                label: "Display in tooltips",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie)
              }
            ),
            /* @__PURE__ */ a(
              Ue,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Deselecting "Display in Legend" indicates that you do not want to display suppressed data in the legend.' }) })
                ] }),
                value: L,
                fieldName: "displayLegend",
                label: "Display in legend",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie)
              }
            ),
            /* @__PURE__ */ a(
              Ue,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Deselecting "Display In Data Table" indicates that you do not want to display suppressed data in the data table.' }) })
                ] }),
                value: U,
                fieldName: "displayTable",
                label: "Display in table",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie)
              }
            ),
            /* @__PURE__ */ a(
              Ue,
              {
                display: e.visualizationSubType === "regular",
                tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting this option will apply to chart, tooltip hover, legend, and data table." }) })
                ] }),
                value: M,
                fieldName: "displayGray",
                label: "Highlight Suppressed Data In Gray",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie)
              }
            )
          ] }) : /* @__PURE__ */ F(Be, { children: [
            /* @__PURE__ */ a(
              ct,
              {
                value: G,
                initial: "Select",
                fieldName: "seriesKey",
                label: "ASSOCIATE TO SERIES",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie),
                options: e.runtime.lineSeriesKeys ?? ((J = e.runtime) == null ? void 0 : J.seriesKeys)
              }
            ),
            /* @__PURE__ */ a(
              ct,
              {
                value: O,
                initial: "Select",
                fieldName: "column",
                label: "COLUMN WITH CONFIGURATION VALUE",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie),
                options: c()
              }
            ),
            /* @__PURE__ */ a(
              ze,
              {
                tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                  /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                  /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "If 'Filled Circles' is selected as the style, this field is optional, and the style 'Filled Circles' will apply to all points within the associated series data." }) })
                ] }),
                value: $,
                fieldName: "value",
                label: "VALUE TO TRIGGER",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie)
              }
            ),
            /* @__PURE__ */ a(
              ct,
              {
                value: ce,
                initial: "Select",
                fieldName: "style",
                label: "Style",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie),
                options: g(re)
              }
            ),
            ce.includes("Circles") && /* @__PURE__ */ a(
              ze,
              {
                className: "number-narrow",
                type: "number",
                value: D,
                fieldName: "circleSize",
                label: "circle size",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie)
              }
            ),
            ce !== "Filled Circles" && /* @__PURE__ */ a(
              ze,
              {
                value: ne,
                fieldName: "label",
                label: "Label",
                placeholder: "",
                updateField: (de, ae, Z, ye) => C(Z, ye, ie)
              }
            )
          ] })
        ] }, `preliminaryData-${ie}`);
      }
    )),
    /* @__PURE__ */ a("button", { type: "button", onClick: m, className: "btn btn-primary full-width", children: e.visualizationType === "Line" ? "Add Special Line" : e.visualizationType === "Bar" ? " Add Special Bar" : "Add Special Bar/Line" })
  ] });
}, PT = ({ config: e, updateConfig: t, display: n }) => {
  var p, y, g, b;
  const r = (p = e == null ? void 0 : e.yAxis) == null ? void 0 : p.maxValue, i = ((g = (y = e == null ? void 0 : e.yAxis) == null ? void 0 : y.categories) == null ? void 0 : g.reduce((T, m) => T + (parseFloat(m.height) || 0), 0)) || 0, o = (T) => {
    let m = [];
    e.yAxis.categories && (m = [...e.yAxis.categories]), m.splice(T, 1), t({ ...e, yAxis: { ...e.yAxis, categories: m } });
  }, h = () => {
    var w, S;
    const T = (S = (w = e.yAxis) == null ? void 0 : w.categories) == null ? void 0 : S.length, m = 0.4;
    return Qi("#ddd").darken(m * T).hex();
  }, d = () => {
    const T = e.yAxis.categories ? [...e.yAxis.categories] : [], m = {
      label: "Label " + Number(T.length + 1),
      height: "",
      color: h()
    };
    T.push(m), t({ ...e, yAxis: { ...e.yAxis, categories: T } });
  }, c = (T, m, C) => {
    let w = [];
    e.yAxis.categories && (w = [...e.yAxis.categories]), w[C][T] = m, t({ ...e, yAxis: { ...e.yAxis, categories: w } });
  };
  return n ? /* @__PURE__ */ F(Be, { children: [
    e.yAxis.type === "categorical" && ((b = e.yAxis.categories) == null ? void 0 : b.map(({ label: T, color: m, height: C }, w) => /* @__PURE__ */ F("div", { className: "edit-block", children: [
      /* @__PURE__ */ F("p", { children: [
        "Axis Category ",
        w + 1
      ] }),
      /* @__PURE__ */ a(
        "button",
        {
          type: "button",
          className: "btn btn-danger",
          onClick: (S) => {
            S.preventDefault(), o(w);
          },
          children: "Remove"
        }
      ),
      /* @__PURE__ */ a(
        ze,
        {
          tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ F("p", { children: [
              " ",
              "Category Height will be ignored for the last category. The last category will fill the rest of the axis height."
            ] }) })
          ] }),
          type: "number",
          value: C,
          fieldName: "height",
          label: "Category Height",
          updateField: (S, B, M, D) => c(M, D, w)
        }
      ),
      Number(i) > Number(r) && e.yAxis.categories.length - 1 === w && /* @__PURE__ */ a("span", { style: { color: "red", display: "block", fontSize: "15px" }, children: "Update Max value to show all categories" }),
      /* @__PURE__ */ F("div", { className: "two-col-inputs", children: [
        /* @__PURE__ */ a(
          ze,
          {
            value: m,
            fieldName: "color",
            label: "Color",
            updateField: (S, B, M, D) => c(M, D, w)
          }
        ),
        /* @__PURE__ */ a(
          ze,
          {
            value: T,
            fieldName: "label",
            label: "Label",
            updateField: (S, B, M, D) => c(M, D, w)
          }
        )
      ] })
    ] }, `preliminaryData-${w}`))),
    /* @__PURE__ */ a("button", { type: "button", onClick: d, className: "btn btn-primary full-width", children: "Add Axis Category" })
  ] }) : /* @__PURE__ */ a(Be, {});
}, NT = () => {
  var on, wn, Ut, sn, pn, Bt, rr, Mn, Pn, cn, Hn, Vn, yr, gr, ir, Wn, ar, Xn, qn, v, P, _, W, he;
  const {
    config: e,
    updateConfig: t,
    tableData: n,
    transformedData: r,
    isLoading: i,
    colorScale: o,
    colorPalettes: h,
    twoColorPalette: d,
    unfilteredData: c,
    excludedData: p,
    isDashboard: y,
    setParentConfig: g,
    missingRequiredSections: b,
    isDebug: T,
    setFilteredData: m,
    lineOptions: C,
    rawData: w,
    highlight: S,
    handleShowAll: B,
    dimensions: M
  } = fe.useContext(ft), { minValue: D, maxValue: O, existPositiveValue: L, isAllLine: U } = qc(e, c), X = { data: r, config: e }, { leftMax: ne, rightMax: G } = bg(X), {
    visHasAnchors: ce,
    visHasBrushChart: q,
    visHasCategoricalAxis: re,
    visHasLegend: $,
    visHasLegendAxisAlign: j,
    visHasLegendColorCategory: oe,
    visHasSelectableLegendValues: ie,
    visSupportsDateCategoryAxis: le,
    visSupportsDateCategoryAxisLabel: J,
    visSupportsDateCategoryAxisLine: de,
    visSupportsDateCategoryAxisMax: ae,
    visSupportsDateCategoryAxisMin: Z,
    visSupportsDateCategoryAxisPadding: ye,
    visSupportsDateCategoryAxisTicks: ue,
    visSupportsDateCategoryHeight: ve,
    visSupportsDateCategoryNumTicks: ke,
    visSupportsDateCategoryTickRotation: me,
    visSupportsDynamicSeries: Ne,
    visSupportsFilters: Ee,
    visSupportsLeftValueAxis: De,
    visSupportsPreliminaryData: Xe,
    visSupportsRankByValue: Fe,
    visSupportsResponsiveTicks: Je,
    visSupportsValueAxisGridLines: gt,
    visSupportsValueAxisLabels: mt,
    visSupportsValueAxisLine: yt,
    visSupportsValueAxisMax: Ye,
    visSupportsValueAxisMin: ot,
    visSupportsValueAxisTicks: ut,
    visSupportsYPadding: st
  } = Hl();
  fe.useEffect(() => {
    let N = [];
    e.series && (N = e.series.map((z) => ({
      ...z,
      type: e.visualizationType === "Combo" ? "Bar" : e.visualizationType ? e.visualizationType : "Bar",
      axis: "Left"
    }))), t({
      ...e,
      series: N
    });
  }, [e.visualizationType]), fe.useEffect(() => {
    e.visualizationType === "Scatter Plot" && t({
      ...e,
      xAxis: {
        ...e.xAxis,
        type: "continuous"
      }
    });
  }, []), fe.useEffect(() => {
    e.visualizationType !== "Bar" && t({ ...e, tooltips: { ...e.tooltips, singleSeries: !1 } });
  }, [e.visualizationType]);
  const { hasRightAxis: tt } = Mf({ config: e, yMax: e.yAxis.size, data: e.data, updateConfig: t }), $e = (N, z) => ({
    ...z
  }), it = {
    animate: !1,
    animateReplay: !0,
    display: "block",
    boxSizing: "border-box",
    border: "1px solid #D1D1D1",
    borderRadius: "2px",
    background: "#F1F1F1",
    padding: ".4em .6em",
    fontSize: ".8em",
    marginRight: ".3em",
    marginBottom: ".3em",
    cursor: "move",
    zIndex: "999"
  }, ht = (N) => {
    N.orientation === "horizontal" && (N.labels = !1), N.table.show === void 0 && (N.table.show = !y), N.visualizationType === "Combo" && (N.orientation = "vertical"), Tn(N.xAxis) && !N.xAxis.padding && (N.xAxis.padding = 0), N.visualizationType === "Line" && (N.visualizationSubType = "regular", N.barStyle = "flat", N.isLollipopChart = !1);
  }, Ce = (N, z, Y, be) => {
    if (T && console.log(
      "#COVE: CHART: EditorPanel: section, subsection, fieldName, newValue",
      N,
      z,
      Y,
      be
    ), N === "boxplot" && (z === "legend" || z === "labels")) {
      t({
        ...e,
        [N]: {
          ...e[N],
          [z]: {
            ...e.boxplot[z],
            [Y]: be
          }
        }
      });
      return;
    }
    const Oe = (Mt) => Mt === 0 ? !0 : !!Mt;
    if (N === "columns" && Oe(z) && Oe(Y)) {
      t({
        ...e,
        columns: {
          ...e.columns,
          [z]: {
            ...e.columns[z],
            [Y]: be
          }
        }
      });
      return;
    }
    if (N === null && z === null) {
      Oe(Y) || console.error("fieldName is required");
      let Mt = { ...e, [Y]: be };
      ht(Mt), t(Mt);
      return;
    }
    const We = Array.isArray(e[N]);
    let rt = We ? [...e[N], be] : { ...e[N], [Y]: be };
    Oe(z) && (We ? (rt = [...e[N]], rt[z] = { ...rt[z], [Y]: be }) : typeof be == "string" ? rt[z] = be : Oe(Y) && (rt = { ...e[N], [z]: { ...e[N][z], [Y]: be } }));
    let Dt = { ...e, [N]: rt };
    ht(Dt), t(Dt);
  }, [Ht, vn] = fe.useState(!0), [pt, hn] = fe.useState(!1);
  if (i)
    return null;
  const yn = (N) => {
    t({
      ...e,
      lollipopShape: N
    });
  }, Vt = (N) => {
    let z = e.series ? [...e.series] : [], Y = Array.from(new Set(r.map((Oe) => Oe[N]))), be = [];
    Y.forEach((Oe) => {
      be.push({ key: Oe });
    }), e.visualizationType === "Forecasting" ? z.push({
      dataKey: N,
      type: e.visualizationType,
      stages: be,
      stageColumn: N,
      axis: "Left",
      tooltip: !0
    }) : z.push({ dataKey: N, type: e.visualizationType, axis: "Left", tooltip: !0 }), t({ ...e, series: z });
  }, zt = (N) => {
    let z = [...e.exclusions.keys];
    z.push(N);
    let Y = { ...e.exclusions, keys: z };
    t({ ...e, exclusions: Y });
  }, Cn = (N) => {
    let z = -1, Y = [...e.exclusions.keys];
    for (let be = 0; be < Y.length; be++)
      if (Y[be] === N) {
        z = be;
        break;
      }
    if (z !== -1) {
      Y.splice(z, 1);
      let be = { ...e.exclusions, keys: Y }, Oe = { ...e, exclusions: be };
      Y.length === 0 && delete Oe.exclusions.keys, t(Oe);
    }
  }, qt = (N = !0) => {
    let z = {};
    if (c.forEach((Y) => {
      Object.keys(Y).forEach((be) => z[be] = !0);
    }), N) {
      const { lower: Y, upper: be } = e.confidenceKeys || {};
      Object.keys(z).forEach((Oe) => {
        (e.series && e.series.filter((We) => We.dataKey === Oe).length > 0 || e.confidenceKeys && Object.keys(e.confidenceKeys).includes(Oe) && (Y && be || Y || be) && Oe !== Y && Oe !== be) && delete z[Oe];
      });
    }
    return Object.keys(z);
  }, Ft = (N) => {
    const z = [];
    switch (N) {
      case "style":
        z.push("circles", "boxes"), e.visualizationType === "Bar" && (!["right", "left"].includes(e.legend.position) || !e.legend.position) && z.push("gradient"), e.visualizationType === "Line" && z.push("lines");
        break;
      case "subStyle":
        e.visualizationType === "Bar" ? z.push("linear blocks") : z.push("linear blocks", "smooth");
        break;
      case "groupBy":
        z.push(...qt());
        break;
    }
    return z;
  }, Gt = (N) => {
    if (!N)
      return [];
    const z = /* @__PURE__ */ new Set();
    for (let Y = 0; Y < N.length; Y++)
      for (const [be] of Object.entries(N[Y]))
        z.add(be);
    return Array.from(z);
  }, Zt = (N, z = !1) => {
    let Y = [];
    return p.forEach((be) => {
      Y.push(be[N]);
    }), z ? [...new Set(Y)] : Y;
  }, gn = () => {
    vn(!Ht), t({
      ...e,
      showEditorPanel: !Ht
    });
  }, Pt = () => {
    let N = Ke.cloneDeep(e);
    return b(e) === !1 && delete N.newViz, delete N.runtime, N;
  };
  fe.useEffect(() => {
    if (g) {
      const N = Pt();
      g(N);
    }
  }, [e]), fe.useEffect(() => {
    const N = e.xAxis.anchors.length > 0 ? e.xAxis.anchors : [], z = e.yAxis.anchors.length > 0 ? e.yAxis.anchors : [];
    t({
      ...e,
      xAxis: {
        ...e.xAxis,
        anchors: z
      },
      yAxis: {
        ...e.yAxis,
        anchors: N
      }
    });
  }, [e.orientation]), fe.useEffect(() => {
    e.visualizationType === "Paired Bar" && t({
      ...e,
      orientation: "horizontal"
    });
  }, []), fe.useEffect(() => {
    e.orientation === "horizontal" && t({
      ...e,
      lollipopShape: e.lollipopShape
    });
  }, [e.isLollipopChart, e.lollipopShape]), fe.useEffect(() => {
    e.visualizationType === "Deviation Bar" && t({ ...e, orientation: "horizontal" });
  }, [e.visualizationType]);
  const Qt = fe.useCallback(() => {
    const N = [...e.exclusions.keys];
    return /* @__PURE__ */ a("ul", { className: "series-list", children: N.map((z, Y) => /* @__PURE__ */ F("li", { children: [
      /* @__PURE__ */ a("div", { className: "series-list__name", "data-title": z, children: /* @__PURE__ */ a("div", { className: "series-list__name--text", children: z }) }),
      /* @__PURE__ */ a("button", { className: "series-list__remove", onClick: () => Cn(z), children: "×" })
    ] }, z)) });
  }, [e]), Rt = (N, z) => {
    let Y = e.series, [be] = Y.splice(N, 1);
    Y.splice(z, 0, be), t({ ...e, series: Y });
  };
  e.isLollipopChart && ((on = e == null ? void 0 : e.series) == null ? void 0 : on.length) > 1 && (e.runtime.editorErrorMessage = "Lollipop charts must use only one data series"), e.visualizationType === "Paired Bar" && ((wn = e == null ? void 0 : e.series) == null ? void 0 : wn.length) !== 2 && (e.runtime.editorErrorMessage = "Paired Bar charts must use exactly two data series"), e.visualizationType === "Deviation Bar" && ((Ut = e == null ? void 0 : e.series) == null ? void 0 : Ut.length) !== 1 && (e.runtime.editorErrorMessage = "Deviation Bar charts must use exactly one data series"), e.isLollipopChart && ((sn = e == null ? void 0 : e.series) == null ? void 0 : sn.length) === 0 && (e.runtime.editorErrorMessage = "Add a data series");
  const bt = e.orientation === "horizontal" ? "xAxis" : "yAxis", [lt, Se] = fe.useState({ maxMsg: "", minMsg: "", rightMaxMessage: "", minMsgRight: "" }), _e = () => {
    const N = e[bt].max, z = e[bt].rightMax;
    let Y = "", be = "";
    if (e.visualizationType !== "Combo")
      switch (!0) {
        case (N && parseFloat(N) < parseFloat(O) && L):
          Y = "Max value must be more than " + O;
          break;
        case (N && parseFloat(N) < 0 && !L):
          Y = "Value must be more than or equal to 0";
          break;
        default:
          Y = "";
      }
    if (e.visualizationType === "Combo")
      switch (!0) {
        case (N && parseFloat(N) < ne):
          Y = "Max value must be more than " + ne;
          break;
        case (z && parseFloat(z) < G):
          be = "Max value must be more than " + G;
          break;
        case (N && parseFloat(N) < 0 && !L):
          Y = "Value must be more than or equal to 0";
          break;
        default:
          Y = "";
      }
    Se((Oe) => ({ ...Oe, maxMsg: Y, rightMaxMessage: be }));
  }, xe = () => {
    const N = parseFloat(e[bt].min);
    let z = Number(D), Y = "";
    switch (!0) {
      case (e.useLogScale && ["Line", "Combo", "Bar"].includes(e.visualizationType) && N < 0):
        Y = "Negative numbers are not supported in logarithmic scale";
        break;
      case ((e.visualizationType === "Line" || e.visualizationType === "Spark Line") && N > z):
        Y = "Value should not exceed " + D;
        break;
      case (e.visualizationType === "Combo" && U && N > z):
        Y = "Value should not exceed " + D;
        break;
      case ((e.visualizationType === "Bar" || e.visualizationType === "Combo" && !U) && z > 0 && N > 0):
        Y = e.useLogScale ? "Value must be equal to 0" : "Value must be less than or equal to 0";
        break;
      case (e.visualizationType === "Deviation Bar" && N >= Math.min(z, e.xAxis.target)):
        Y = "Value must be less than " + Math.min(z, e.xAxis.target);
        break;
      case (e.visualizationType !== "Deviation Bar" && N && z < 0 && N > z):
        Y = "Value should not exceed " + D;
        break;
      default:
        Y = "";
    }
    Se((be) => ({ ...be, minMsg: Y }));
  };
  fe.useEffect(() => {
    xe(), _e();
  }, [D, O, e]);
  const Ge = ((pn = e == null ? void 0 : e.dataKey) == null ? void 0 : pn.includes("http://")) || ((Bt = e == null ? void 0 : e.dataKey) == null ? void 0 : Bt.includes("https://")), Ze = () => {
    var N, z;
    if (T !== void 0 && T && !((N = e == null ? void 0 : e.xAxis) != null && N.dataKey)) {
      let Y = qt(!1);
      if (Y.includes("Date"))
        return "Date";
      if (Y.includes("Race"))
        return "Race";
      if (Y.includes("Month"))
        return "Month";
    }
    return ((z = e == null ? void 0 : e.xAxis) == null ? void 0 : z.dataKey) || "";
  }, et = () => {
    if (T !== void 0 && T && qt(!1).length > 0) {
      let N = qt(!1).filter((z) => z !== Ze());
      if (N.length > 0)
        return N[0];
    }
    return "";
  };
  if (T && !e.xAxis.dataKey && (e.xAxis.dataKey = Ze()), T && ((rr = e == null ? void 0 : e.series) == null ? void 0 : rr.length) === 0) {
    let N = et();
    N !== "" && Vt(N), T && console.log("### COVE DEBUG: Chart: Setting default datacol=", N);
  }
  const Nt = [
    "Bump Chart",
    "Area Chart",
    "Combo",
    "Line",
    "Bar",
    "Forecasting",
    "Scatter Plot",
    "Paired Bar",
    "Deviation Bar"
  ], Wt = [
    /* @__PURE__ */ a("option", { value: "", children: "- Select Option -" }, "Select Option")
  ];
  if (e.data && e.series) {
    Object.keys(((Mn = e.data) == null ? void 0 : Mn[0]) || []).map((z) => {
      const Y = e == null ? void 0 : e.series.some((be) => be.dataKey === z);
      if (z !== e.xAxis.dataKey && !Y)
        return Wt.push(
          /* @__PURE__ */ a("option", { value: z, children: z }, z)
        );
    });
    let N = {};
    e.data.forEach((z) => {
      Object.keys(z).forEach((Y) => {
        N[Y] = N[Y] || [];
        const be = typeof z[Y] == "number" ? z[Y].toString() : z[Y];
        N[Y].indexOf(be) === -1 && N[Y].push(be);
      });
    });
  }
  if (!e.data && r) {
    if (!r[0])
      return;
    Object.keys(r[0]).map((z) => {
      const Y = r.some((be) => be.dataKey === z);
      if (z !== e.xAxis.dataKey && !Y)
        return Wt.push(
          /* @__PURE__ */ a("option", { value: z, children: z }, z)
        );
    });
    let N = {};
    r.forEach((z) => {
      Object.keys(z).forEach((Y) => {
        N[Y] = N[Y] || [];
        const be = typeof z[Y] == "number" ? z[Y].toString() : z[Y];
        N[Y].indexOf(be) === -1 && N[Y].push(be);
      });
    });
  }
  const xt = (N) => {
    const z = Ke.cloneDeep(e.columns);
    delete z[N], t({
      ...e,
      columns: z
    });
  }, at = async (N, z, Y) => {
    switch (z) {
      case "name":
        t({
          ...e,
          columns: {
            ...e.columns,
            [N]: {
              ...e.columns[N],
              [z]: Y
            }
          }
        });
        break;
      default:
        t({
          ...e,
          columns: {
            ...e.columns,
            [N]: {
              ...e.columns[N],
              [z]: Y
            }
          }
        });
        break;
    }
  }, {
    highlightedBarValues: un,
    highlightedSeriesValues: jt,
    handleUpdateHighlightedBar: An,
    handleAddNewHighlightedBar: wt,
    handleRemoveHighlightedBar: Lt,
    handleUpdateHighlightedBarColor: bn,
    handleHighlightedBarLegendLabel: $n,
    handleUpdateHighlightedBorderWidth: Ln
  } = Xc(e, t), En = e.visualizationType === "Bar" && e.visualizationSubType === "regular" && e.runtime.seriesKeys.length === 1, nr = () => {
    const N = r.map((z) => z[e.legend.colorCode]);
    return En ? N : qt(!1).filter((z) => z !== e.xAxis.dataKey);
  }, Yn = (N) => {
    t({ ...e, legend: { ...e.legend, seriesHighlight: N } });
  }, _n = (N, z, Y) => {
    var We;
    const be = { ...e[N], [z]: Y }, Oe = { ...e, [N]: be };
    Y === "highlight" && ((We = e.legend.seriesHighlight) != null && We.length) && (Oe.legend.seriesHighlight.length = 0), t(Oe);
  }, fn = (N, z, Y) => {
    const be = { ...e.xAxis[N] };
    be[z] = Y;
    const Oe = { ...e, xAxis: { ...e.xAxis, [N]: be } };
    t(Oe);
  }, _t = ![void 0, "- Select - "].includes((cn = (Pn = e.series) == null ? void 0 : Pn[0]) == null ? void 0 : cn.dynamicCategory), Jt = ((Hn = e.series) == null ? void 0 : Hn.length) > 1, Yt = {
    addNewExclusion: zt,
    data: r,
    editColumn: at,
    getColumns: qt,
    getDataValueOptions: Gt,
    getDataValues: Zt,
    getItemStyle: $e,
    handleSeriesChange: Rt,
    handleAddNewHighlightedBar: wt,
    setCategoryAxis: Ze,
    updateField: Ce,
    warningMsg: lt,
    highlightedBarValues: un,
    handleHighlightedBarLegendLabel: $n,
    handleUpdateHighlightedBar: An,
    handleRemoveHighlightedBar: Lt,
    isPaletteReversed: e.isPaletteReversed,
    highlightedSeriesValues: jt,
    handleUpdateHighlightedBorderWidth: Ln,
    handleUpdateHighlightedBarColor: bn,
    setLollipopShape: yn
  };
  return /* @__PURE__ */ a(zf.Provider, { value: Yt, children: /* @__PURE__ */ a(Xr, { component: "EditorPanel", children: /* @__PURE__ */ F(
    mh.Sidebar,
    {
      displayPanel: Ht,
      isDashboard: y,
      title: "Configure Chart",
      onBackClick: gn,
      children: [
        /* @__PURE__ */ F(za, { allowZeroExpanded: !0, children: [
          /* @__PURE__ */ a(ki.General, { name: "General" }),
          /* @__PURE__ */ a(ki.ForestPlot, { name: "Forest Plot Settings" }),
          /* @__PURE__ */ a(ki.Sankey, { name: "Sankey" }),
          e.visualizationType !== "Pie" && e.visualizationType !== "Forest Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ F(Nn, { children: [
            /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ F(Dn, { children: [
              "Data Series",
              " ",
              (!e.series || e.series.length === 0 || e.visualizationType === "Paired Bar" && e.series.length < 2) && !e.dynamicSeries && /* @__PURE__ */ a(ic, { width: "25", className: "warning-icon" })
            ] }) }),
            /* @__PURE__ */ F(On, { children: [
              e.dynamicSeries && e.visualizationType === "Line" && /* @__PURE__ */ a(
                ct,
                {
                  fieldName: "dynamicSeriesType",
                  value: e.dynamicSeriesType,
                  label: "Series Type",
                  initial: "Select",
                  updateField: Ce,
                  options: ["Line", "dashed-sm", "dashed-md", "dashed-lg"]
                }
              ),
              e.dynamicSeries && e.visualizationType === "Line" && e.dynamicSeriesType === "Line" && /* @__PURE__ */ a(
                ct,
                {
                  fieldName: "dynamicSeriesLineType",
                  value: e.dynamicSeriesLineType ? e.dynamicSeriesLineType : "curveLinear",
                  label: "Line Type",
                  initial: "Select",
                  updateField: Ce,
                  options: Object.keys(os).map((N) => os[N])
                }
              ),
              (!Ne() || !e.dynamicSeries) && /* @__PURE__ */ F(Be, { children: [
                (!e.series || e.series.length === 0) && !e.dynamicSeries && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a("p", { className: "warning", children: "At least one series is required" }),
                (!e.series || e.series.length === 0 || e.series.length < 2) && e.visualizationType === "Paired Bar" && /* @__PURE__ */ a("p", { className: "warning", children: "Select two data series for paired bar chart (e.g., Male and Female)." }),
                /* @__PURE__ */ F(Be, { children: [
                  /* @__PURE__ */ a(
                    ct,
                    {
                      fieldName: "visualizationType",
                      label: "Add Data Series",
                      initial: "Select",
                      onChange: (N) => {
                        N.target.value !== "" && N.target.value !== "Select" && Vt(N.target.value), N.target.value = "";
                      },
                      options: qt()
                    }
                  ),
                  e.series && e.series.length !== 0 && /* @__PURE__ */ F(ki.Series.Wrapper, { getColumns: qt, children: [
                    /* @__PURE__ */ F("fieldset", { children: [
                      /* @__PURE__ */ a("legend", { className: "edit-label float-left", children: "Displaying" }),
                      /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "A data series is a set of related data points plotted in a chart and typically represented in the chart legend." }) })
                      ] })
                    ] }),
                    /* @__PURE__ */ a(
                      Xg,
                      {
                        onDragEnd: ({ source: N, destination: z }) => Rt(N.index, z.index),
                        children: /* @__PURE__ */ a(qg, { droppableId: "filter_order", children: (N) => /* @__PURE__ */ F("ul", { ...N.droppableProps, className: "series-list", ref: N.innerRef, children: [
                          /* @__PURE__ */ a(
                            ki.Series.List,
                            {
                              series: e.series,
                              getItemStyle: $e,
                              sortableItemStyles: it,
                              chartsWithOptions: Nt
                            }
                          ),
                          N.placeholder
                        ] }) })
                      }
                    )
                  ] })
                ] }),
                (e.series && e.series.length && e.visualizationType === "Bar" || e.series && e.series.length <= 1 && e.visualizationType === "Line") && /* @__PURE__ */ F(Be, { children: [
                  /* @__PURE__ */ a("span", { className: "divider-heading", children: "Confidence Keys" }),
                  /* @__PURE__ */ a(
                    ct,
                    {
                      value: e.confidenceKeys.upper || "",
                      section: "confidenceKeys",
                      fieldName: "upper",
                      label: "Upper",
                      updateField: Ce,
                      initial: "Select",
                      options: qt()
                    }
                  ),
                  /* @__PURE__ */ a(
                    ct,
                    {
                      value: e.confidenceKeys.lower || "",
                      section: "confidenceKeys",
                      fieldName: "lower",
                      label: "Lower",
                      updateField: Ce,
                      initial: "Select",
                      options: qt()
                    }
                  )
                ] }),
                Fe() && e.series && e.series.length === 1 && /* @__PURE__ */ a(
                  ct,
                  {
                    value: e.rankByValue,
                    fieldName: "rankByValue",
                    label: "Rank by Value",
                    initial: "Select",
                    updateField: (N, z, Y, be) => {
                      const [Oe, We] = ET(e, be, r);
                      t(Oe, We);
                    },
                    options: ["asc", "desc"]
                  }
                ),
                Xe() && /* @__PURE__ */ a(_T, { config: e, updateConfig: t, data: r })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ a(ki.BoxPlot, { name: "Measures" }),
          De() && /* @__PURE__ */ F(Nn, { children: [
            /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ F(Dn, { children: [
              e.visualizationType === "Pie" ? "Data Format" : e.orientation === "vertical" ? "Left Value Axis" : "Value Axis",
              e.visualizationType === "Pie" && !e.yAxis.dataKey && /* @__PURE__ */ a(ic, { width: "25", className: "warning-icon" })
            ] }) }),
            /* @__PURE__ */ F(On, { children: [
              e.visualizationType === "Pie" && /* @__PURE__ */ a(
                ct,
                {
                  value: e.yAxis.dataKey || "",
                  section: "yAxis",
                  fieldName: "dataKey",
                  label: "Data Column",
                  initial: "Select",
                  required: !0,
                  updateField: Ce,
                  options: qt(!1),
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Select the source data to be visually represented." }) })
                  ] })
                }
              ),
              e.visualizationType !== "Pie" && /* @__PURE__ */ F(Be, { children: [
                /* @__PURE__ */ F("label", { children: [
                  /* @__PURE__ */ F("span", { className: "edit-label", children: [
                    "Axis Type",
                    /* @__PURE__ */ F(ee, { style: { textTransform: "none", display: "inline-block" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(ee.Content, { children: "Select 'Numeric (Linear Scale)' for uniform scaling, 'Numeric (Logarithmic Scale)' for exponential data, or 'Categorical' for discrete categories." })
                    ] })
                  ] }),
                  /* @__PURE__ */ F(
                    "select",
                    {
                      value: e.yAxis.type,
                      onChange: (N) => t({
                        ...e,
                        yAxis: {
                          ...e.yAxis,
                          type: N.target.value
                        }
                      }),
                      children: [
                        /* @__PURE__ */ a("option", { value: "linear", children: "Numeric (Linear Scale)" }),
                        e.visualizationSubType !== "stacked" && /* @__PURE__ */ a("option", { value: "logarithmic", children: "Numeric (Logarithmic Scale)" }),
                        e.orientation !== "horizontal" && /* @__PURE__ */ a("option", { value: "categorical", children: "Categorical" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ a(
                  PT,
                  {
                    config: e,
                    updateConfig: t,
                    data: r,
                    display: re()
                  }
                ),
                /* @__PURE__ */ a(
                  ze,
                  {
                    display: !re(),
                    value: e.yAxis.label,
                    section: "yAxis",
                    fieldName: "label",
                    label: "Label",
                    updateField: Ce,
                    maxLength: 35,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "35 character limit" }) })
                    ] })
                  }
                ),
                e.runtime.seriesKeys && e.runtime.seriesKeys.length === 1 && !["Box Plot", "Deviation Bar", "Forest Plot"].includes(e.visualizationType) && /* @__PURE__ */ a(
                  Ue,
                  {
                    value: e.isLegendValue,
                    fieldName: "isLegendValue",
                    label: "Use Legend Value in Hover",
                    updateField: Ce
                  }
                ),
                /* @__PURE__ */ a(
                  ze,
                  {
                    display: !re(),
                    value: e.yAxis.numTicks,
                    placeholder: "Auto",
                    type: "number",
                    section: "yAxis",
                    fieldName: "numTicks",
                    label: "Number of ticks",
                    className: "number-narrow",
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used." }) })
                    ] }),
                    updateField: Ce
                  }
                ),
                /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.yAxis.size,
                    type: "number",
                    section: "yAxis",
                    fieldName: "size",
                    label: e.orientation === "horizontal" ? "Size (Height)" : "Size (Width)",
                    className: "number-narrow",
                    updateField: Ce,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: `Increase the size if elements in the ${e.orientation} axis are being crowded or hidden behind other elements.  Decrease if less space is required for the value axis.` }) })
                    ] })
                  }
                ),
                /* @__PURE__ */ a(
                  ze,
                  {
                    display: !re(),
                    value: e.yAxis.labelOffset,
                    section: "yAxis",
                    fieldName: "labelOffset",
                    label: "Label offset",
                    type: "number",
                    className: "number-narrow",
                    updateField: Ce
                  }
                ),
                e.orientation === "horizontal" && /* @__PURE__ */ a(
                  Ue,
                  {
                    value: e.isResponsiveTicks,
                    fieldName: "isResponsiveTicks",
                    label: "Use Responsive Ticks",
                    updateField: Ce
                  }
                ),
                (e.orientation === "vertical" || !e.isResponsiveTicks) && /* @__PURE__ */ a(
                  ze,
                  {
                    display: !re(),
                    value: e.yAxis.tickRotation || 0,
                    type: "number",
                    min: 0,
                    section: "yAxis",
                    fieldName: "tickRotation",
                    label: "Tick rotation (Degrees)",
                    className: "number-narrow",
                    updateField: Ce
                  }
                ),
                e.isResponsiveTicks && e.orientation === "horizontal" && /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.xAxis.maxTickRotation,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "maxTickRotation",
                    label: "Max Tick Rotation",
                    className: "number-narrow",
                    updateField: Ce,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Degrees ticks will be rotated if values overlap, especially in smaller viewports." }) })
                    ] })
                  }
                ),
                gt() && /* @__PURE__ */ a(
                  Ue,
                  {
                    value: e.yAxis.gridLines,
                    section: "yAxis",
                    fieldName: "gridLines",
                    label: "Show Gridlines",
                    updateField: Ce
                  }
                ),
                gt() && /* @__PURE__ */ a(
                  Ue,
                  {
                    value: e.yAxis.labelsAboveGridlines,
                    section: "yAxis",
                    fieldName: "labelsAboveGridlines",
                    label: "Tick labels above gridlines",
                    updateField: Ce,
                    disabled: !e.yAxis.gridLines,
                    title: e.yAxis.gridLines ? "" : "Show gridlines to enable"
                  }
                ),
                st() && /* @__PURE__ */ a(
                  Ue,
                  {
                    value: e.yAxis.enablePadding,
                    section: "yAxis",
                    fieldName: "enablePadding",
                    label: "Add Padding to Value Axis Scale",
                    updateField: Ce
                  }
                ),
                e.yAxis.enablePadding && st() && /* @__PURE__ */ a(
                  ze,
                  {
                    type: "number",
                    section: "yAxis",
                    fieldName: "scalePadding",
                    label: "Padding Percentage",
                    className: "number-narrow",
                    updateField: Ce,
                    value: e.yAxis.scalePadding
                  }
                )
              ] }),
              /* @__PURE__ */ a("span", { className: "divider-heading", children: "Number Formatting" }),
              /* @__PURE__ */ a(
                Ue,
                {
                  value: e.dataFormat.commas,
                  section: "dataFormat",
                  fieldName: "commas",
                  label: "Add commas",
                  updateField: Ce,
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting this option will add commas to the left value axis, tooltip hover, and data table." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  display: !re(),
                  value: e.dataFormat.abbreviated,
                  section: "dataFormat",
                  fieldName: "abbreviated",
                  label: "Abbreviate Axis Values",
                  updateField: Ce,
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "This option abbreviates very large or very small numbers on the value axis" }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                ze,
                {
                  value: e.dataFormat.roundTo ? e.dataFormat.roundTo : 0,
                  type: "number",
                  section: "dataFormat",
                  fieldName: "roundTo",
                  label: "Round to decimal point",
                  className: "number-narrow",
                  updateField: Ce,
                  min: 0
                }
              ),
              " ",
              /* @__PURE__ */ F("div", { className: "two-col-inputs", children: [
                /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.dataFormat.prefix,
                    section: "dataFormat",
                    fieldName: "prefix",
                    label: "Prefix",
                    updateField: Ce,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ F(ee.Content, { children: [
                        e.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data prefix to display in the data table and chart tooltips, if applicable." }),
                        e.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data prefix (such as "$"), if applicable.' })
                      ] })
                    ] })
                  }
                ),
                /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.dataFormat.suffix,
                    section: "dataFormat",
                    fieldName: "suffix",
                    label: "Suffix",
                    updateField: Ce,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ F(ee.Content, { children: [
                        e.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data suffix to display in the data table and tooltips, if applicable." }),
                        e.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data suffix (such as "%"), if applicable.' })
                      ] })
                    ] })
                  }
                )
              ] }),
              e.orientation === "horizontal" ? (
                // horizontal - x is vertical y is horizontal
                /* @__PURE__ */ F(Be, { children: [
                  yt() && /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.xAxis.hideAxis,
                      section: "xAxis",
                      fieldName: "hideAxis",
                      label: "Hide Axis",
                      updateField: Ce
                    }
                  ),
                  mt() && /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.xAxis.hideLabel,
                      section: "xAxis",
                      fieldName: "hideLabel",
                      label: "Hide Tick Labels",
                      updateField: Ce
                    }
                  ),
                  ut() && /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.xAxis.hideTicks,
                      section: "xAxis",
                      fieldName: "hideTicks",
                      label: "Hide Ticks",
                      updateField: Ce
                    }
                  ),
                  Ye() && /* @__PURE__ */ a(
                    ze,
                    {
                      value: e.xAxis.max,
                      section: "xAxis",
                      fieldName: "max",
                      label: "max value",
                      type: "number",
                      placeholder: "Auto",
                      updateField: Ce
                    }
                  ),
                  /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: lt.maxMsg }),
                  ot() && /* @__PURE__ */ a(
                    ze,
                    {
                      value: e.xAxis.min,
                      section: "xAxis",
                      fieldName: "min",
                      type: "number",
                      label: "min value",
                      placeholder: "Auto",
                      updateField: Ce
                    }
                  ),
                  /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: lt.minMsg }),
                  e.visualizationType === "Deviation Bar" && /* @__PURE__ */ F(Be, { children: [
                    /* @__PURE__ */ a(
                      ze,
                      {
                        value: e.xAxis.target,
                        section: "xAxis",
                        fieldName: "target",
                        type: "number",
                        label: "Deviation point",
                        placeholder: "Auto",
                        updateField: Ce
                      }
                    ),
                    /* @__PURE__ */ a(
                      ze,
                      {
                        value: e.xAxis.targetLabel || "Target",
                        section: "xAxis",
                        fieldName: "targetLabel",
                        type: "text",
                        label: "Deviation point Label",
                        updateField: Ce
                      }
                    ),
                    /* @__PURE__ */ a(
                      Ue,
                      {
                        value: e.xAxis.showTargetLabel,
                        section: "xAxis",
                        fieldName: "showTargetLabel",
                        label: "Show Deviation point label",
                        updateField: Ce
                      }
                    )
                  ] })
                ] })
              ) : e.visualizationType !== "Pie" && /* @__PURE__ */ F(Be, { children: [
                /* @__PURE__ */ a(
                  Ue,
                  {
                    display: !re(),
                    value: e.dataFormat.onlyShowTopPrefixSuffix,
                    section: "dataFormat",
                    fieldName: "onlyShowTopPrefixSuffix",
                    label: "Only Show Top Prefix/Suffix",
                    updateField: Ce
                  }
                ),
                /* @__PURE__ */ a(
                  Ue,
                  {
                    display: !re(),
                    value: e.yAxis.hideAxis,
                    section: "yAxis",
                    fieldName: "hideAxis",
                    label: "Hide Axis",
                    updateField: Ce
                  }
                ),
                /* @__PURE__ */ a(
                  Ue,
                  {
                    display: !re(),
                    value: e.yAxis.hideLabel,
                    section: "yAxis",
                    fieldName: "hideLabel",
                    label: "Hide Tick Labels",
                    updateField: Ce
                  }
                ),
                /* @__PURE__ */ a(
                  Ue,
                  {
                    display: !re(),
                    value: e.yAxis.hideTicks,
                    section: "yAxis",
                    fieldName: "hideTicks",
                    label: "Hide Ticks",
                    updateField: Ce
                  }
                ),
                /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.yAxis.max,
                    section: "yAxis",
                    fieldName: "max",
                    type: "number",
                    label: "left axis max value",
                    placeholder: "Auto",
                    updateField: Ce
                  }
                ),
                /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: lt.maxMsg }),
                e.visualizationType !== "Area Chart" && e.visualizationSubType !== "stacked" && /* @__PURE__ */ F(Be, { children: [
                  /* @__PURE__ */ a(
                    ze,
                    {
                      value: e.yAxis.min,
                      section: "yAxis",
                      fieldName: "min",
                      type: "number",
                      label: "left axis min value",
                      placeholder: "Auto",
                      updateField: Ce
                    }
                  ),
                  /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: lt.minMsg })
                ] })
              ] }),
              ce() && e.orientation !== "horizontal" && /* @__PURE__ */ F("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: (yr = (Vn = e.yAxis) == null ? void 0 : Vn.anchors) == null ? void 0 : yr.map((N, z) => /* @__PURE__ */ F(Nn, { className: "series-item series-item--chart", children: [
                  /* @__PURE__ */ a(Rn, { className: "series-item__title", children: /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F(Dn, { className: "accordion__button accordion__button", children: [
                    "Anchor ",
                    z + 1,
                    /* @__PURE__ */ a(
                      "button",
                      {
                        className: "series-list__remove",
                        onClick: (Y) => {
                          Y.preventDefault();
                          const be = [...e.yAxis.anchors];
                          be.splice(z, 1), t({
                            ...e,
                            yAxis: {
                              ...e.yAxis,
                              anchors: be
                            }
                          });
                        },
                        children: "Remove"
                      }
                    )
                  ] }) }) }),
                  /* @__PURE__ */ F(On, { children: [
                    /* @__PURE__ */ F("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                      /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                      ] }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.yAxis.anchors[z].value ? e.yAxis.anchors[z].value : "",
                          onChange: (Y) => {
                            Y.preventDefault();
                            const be = [...e.yAxis.anchors];
                            be[z].value = Y.target.value, t({
                              ...e,
                              yAxis: {
                                ...e.yAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ F("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.yAxis.anchors[z].color ? e.yAxis.anchors[z].color : "",
                          onChange: (Y) => {
                            Y.preventDefault();
                            const be = [...e.yAxis.anchors];
                            be[z].color = Y.target.value, t({
                              ...e,
                              yAxis: {
                                ...e.yAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ F("label", { children: [
                      "Anchor Line Style",
                      /* @__PURE__ */ F(
                        "select",
                        {
                          value: e.yAxis.anchors[z].lineStyle || "",
                          onChange: (Y) => {
                            const be = [...e.yAxis.anchors];
                            be[z].lineStyle = Y.target.value, t({
                              ...e,
                              yAxis: {
                                ...e.yAxis,
                                anchors: be
                              }
                            });
                          },
                          children: [
                            /* @__PURE__ */ a("option", { children: "Select" }),
                            C.map((Y) => /* @__PURE__ */ a("option", { children: Y.value }, Y.key))
                          ]
                        }
                      )
                    ] })
                  ] })
                ] }, `yaxis-anchors-2-${z}`)) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (N) => {
                      N.preventDefault();
                      const z = [...e.yAxis.anchors];
                      z.push({}), t({
                        ...e,
                        yAxis: {
                          ...e.yAxis,
                          anchors: z
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] }),
              ce() && e.orientation === "horizontal" && /* @__PURE__ */ F("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: (ir = (gr = e.xAxis) == null ? void 0 : gr.anchors) == null ? void 0 : ir.map((N, z) => /* @__PURE__ */ F(Nn, { className: "series-item series-item--chart", children: [
                  /* @__PURE__ */ a(Rn, { className: "series-item__title", children: /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F(Dn, { className: "accordion__button accordion__button", children: [
                    "Anchor ",
                    z + 1,
                    /* @__PURE__ */ a(
                      "button",
                      {
                        className: "series-list__remove",
                        onClick: (Y) => {
                          Y.preventDefault();
                          const be = [...e.xAxis.anchors];
                          be.splice(z, 1), t({
                            ...e,
                            xAxis: {
                              ...e.xAxis,
                              anchors: be
                            }
                          });
                        },
                        children: "Remove"
                      }
                    )
                  ] }) }) }),
                  /* @__PURE__ */ F(On, { children: [
                    /* @__PURE__ */ F("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                      /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                      ] }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.xAxis.anchors[z].value ? e.xAxis.anchors[z].value : "",
                          onChange: (Y) => {
                            Y.preventDefault();
                            const be = [...e.xAxis.anchors];
                            be[z].value = Y.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ F("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.xAxis.anchors[z].color ? e.xAxis.anchors[z].color : "",
                          onChange: (Y) => {
                            Y.preventDefault();
                            const be = [...e.xAxis.anchors];
                            be[z].color = Y.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ F("label", { children: [
                      "Anchor Line Style",
                      /* @__PURE__ */ F(
                        "select",
                        {
                          value: e.xAxis.anchors[z].lineStyle || "",
                          onChange: (Y) => {
                            const be = [...e.xAxis.anchors];
                            be[z].lineStyle = Y.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          },
                          children: [
                            /* @__PURE__ */ a("option", { children: "Select" }),
                            C.map((Y) => /* @__PURE__ */ a("option", { children: Y.value }, Y.key))
                          ]
                        }
                      )
                    ] })
                  ] })
                ] }, `xaxis-anchors-${z}`)) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (N) => {
                      N.preventDefault();
                      const z = [...e.xAxis.anchors];
                      z.push({}), t({
                        ...e,
                        xAxis: {
                          ...e.xAxis,
                          anchors: z
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] })
            ] })
          ] }),
          tt && /* @__PURE__ */ F(Nn, { children: [
            /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ a(Dn, { children: "Right Value Axis" }) }),
            /* @__PURE__ */ F(On, { children: [
              /* @__PURE__ */ a(
                ze,
                {
                  value: e.yAxis.rightLabel,
                  section: "yAxis",
                  fieldName: "rightLabel",
                  label: "Label",
                  updateField: Ce,
                  maxLength: 35,
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "35 character limit" }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                ze,
                {
                  value: e.yAxis.rightNumTicks,
                  placeholder: "Auto",
                  type: "number",
                  section: "yAxis",
                  fieldName: "rightNumTicks",
                  label: "Number of ticks",
                  className: "number-narrow",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                ze,
                {
                  value: e.yAxis.rightAxisSize,
                  type: "number",
                  section: "yAxis",
                  fieldName: "rightAxisSize",
                  label: "Size (Width)",
                  className: "number-narrow",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                ze,
                {
                  value: e.yAxis.rightLabelOffsetSize,
                  type: "number",
                  section: "yAxis",
                  fieldName: "rightLabelOffsetSize",
                  label: "Label Offset",
                  className: "number-narrow",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a("span", { className: "divider-heading", children: "Number Formatting" }),
              /* @__PURE__ */ a(
                Ue,
                {
                  value: e.dataFormat.rightCommas,
                  section: "dataFormat",
                  fieldName: "rightCommas",
                  label: "Add commas",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                ze,
                {
                  value: e.dataFormat.rightRoundTo,
                  type: "number",
                  section: "dataFormat",
                  fieldName: "rightRoundTo",
                  label: "Round to decimal point",
                  className: "number-narrow",
                  updateField: Ce,
                  min: 0
                }
              ),
              /* @__PURE__ */ F("div", { className: "two-col-inputs", children: [
                /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.dataFormat.rightPrefix,
                    section: "dataFormat",
                    fieldName: "rightPrefix",
                    label: "Prefix",
                    updateField: Ce,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ F(ee.Content, { children: [
                        e.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data prefix to display in the data table and chart tooltips, if applicable." }),
                        e.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data prefix (such as "$"), if applicable.' })
                      ] })
                    ] })
                  }
                ),
                /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.dataFormat.rightSuffix,
                    section: "dataFormat",
                    fieldName: "rightSuffix",
                    label: "Suffix",
                    updateField: Ce,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ F(ee.Content, { children: [
                        e.visualizationType === "Pie" && /* @__PURE__ */ a("p", { children: "Enter a data suffix to display in the data table and tooltips, if applicable." }),
                        e.visualizationType !== "Pie" && /* @__PURE__ */ a("p", { children: 'Enter a data suffix (such as "%"), if applicable.' })
                      ] })
                    ] })
                  }
                )
              ] }),
              /* @__PURE__ */ a(
                Ue,
                {
                  value: e.yAxis.rightHideAxis,
                  section: "yAxis",
                  fieldName: "rightHideAxis",
                  label: "Hide Axis",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  value: e.yAxis.rightHideLabel,
                  section: "yAxis",
                  fieldName: "rightHideLabel",
                  label: "Hide Tick Labels",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  value: e.yAxis.rightHideTicks,
                  section: "yAxis",
                  fieldName: "rightHideTicks",
                  label: "Hide Ticks",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                ze,
                {
                  value: e.yAxis.max,
                  section: "yAxis",
                  fieldName: "rightMax",
                  type: "number",
                  label: "right axis max value",
                  placeholder: "Auto",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: lt.rightMaxMessage }),
              /* @__PURE__ */ a(
                ze,
                {
                  value: e.yAxis.min,
                  section: "yAxis",
                  fieldName: "rightMin",
                  type: "number",
                  label: "right axis min value",
                  placeholder: "Auto",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a("span", { style: { color: "red", display: "block" }, children: lt.minMsg })
            ] })
          ] }),
          le() && /* @__PURE__ */ F(Nn, { children: [
            /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ F(Dn, { children: [
              e.visualizationType === "Pie" ? "Segments" : "Date/Category Axis",
              !e.xAxis.dataKey && /* @__PURE__ */ a(ic, { width: "25", className: "warning-icon" })
            ] }) }),
            /* @__PURE__ */ F(On, { children: [
              e.visualizationType !== "Pie" && /* @__PURE__ */ F(Be, { children: [
                e.visualizationType !== "Forest Plot" && /* @__PURE__ */ F(Be, { children: [
                  /* @__PURE__ */ F("label", { children: [
                    /* @__PURE__ */ F("span", { className: "edit-label", children: [
                      "Data Scaling Type",
                      /* @__PURE__ */ F(ee, { style: { textTransform: "none", display: "inline-block" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: "Linear scales are employed for quantitative data, while time scales are used for time-series data." })
                      ] })
                    ] }),
                    /* @__PURE__ */ F(
                      "select",
                      {
                        value: e.xAxis.type,
                        onChange: (N) => t({
                          ...e,
                          xAxis: {
                            ...e.xAxis,
                            type: N.target.value
                          }
                        }),
                        children: [
                          e.visualizationType !== "Bump Chart" && /* @__PURE__ */ a("option", { value: "categorical", children: "Categorical (Linear Scale)" }),
                          e.visualizationType !== "Bump Chart" && /* @__PURE__ */ a("option", { value: "date", children: "Date (Linear Scale)" }),
                          /* @__PURE__ */ a("option", { value: "date-time", children: "Date (Date Time Scale)" }),
                          e.visualizationType === "Scatter Plot" && /* @__PURE__ */ a("option", { value: "continuous", children: "Continuous" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.xAxis.manual,
                      section: "xAxis",
                      fieldName: "manual",
                      label: "Manual Ticks",
                      updateField: Ce
                    }
                  ),
                  /* @__PURE__ */ a(
                    Ue,
                    {
                      display: e.xAxis.type !== "categorical",
                      value: e.xAxis.sortByRecentDate,
                      section: "xAxis",
                      fieldName: "sortByRecentDate",
                      label: "Show dates newest to oldest",
                      updateField: Ce
                    }
                  ),
                  ye() && /* @__PURE__ */ a(
                    ze,
                    {
                      value: e.xAxis.padding,
                      type: "number",
                      min: 0,
                      section: "xAxis",
                      fieldName: "padding",
                      label: "Padding (Percent)",
                      className: "number-narrow",
                      updateField: Ce,
                      tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "For use with date scale. Extends the earliest and latest dates represented on the scale by the percentage specified." }) })
                      ] })
                    }
                  )
                ] }),
                /* @__PURE__ */ a(
                  ct,
                  {
                    value: e.xAxis.dataKey || Ze() || "",
                    section: "xAxis",
                    fieldName: "dataKey",
                    label: "Data Key",
                    initial: "Select",
                    required: !0,
                    updateField: Ce,
                    options: qt(!1),
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Select the column or row containing the categories or dates for this axis. " }) })
                    ] })
                  }
                )
              ] }),
              e.visualizationType === "Pie" && /* @__PURE__ */ a(
                ct,
                {
                  value: e.xAxis.dataKey || "",
                  section: "xAxis",
                  fieldName: "dataKey",
                  label: "Segment Labels",
                  initial: "Select",
                  required: !0,
                  updateField: Ce,
                  options: qt(!1),
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Select the source row or column that contains the segment labels. Depending on the data structure, it may be listed as "Key."' }) })
                  ] })
                }
              ),
              e.visualizationType !== "Pie" && /* @__PURE__ */ F(Be, { children: [
                /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.xAxis.label,
                    section: "xAxis",
                    fieldName: "label",
                    label: "Label",
                    updateField: Ce,
                    maxLength: 35,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "35 character limit" }) })
                    ] })
                  }
                ),
                e.xAxis.type === "continuous" && /* @__PURE__ */ F(Be, { children: [
                  /* @__PURE__ */ a(
                    ze,
                    {
                      value: e.dataFormat.bottomPrefix,
                      section: "dataFormat",
                      fieldName: "bottomPrefix",
                      label: "Prefix",
                      updateField: Ce,
                      tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Enter a data prefix (such as "$"), if applicable.' }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ a(
                    ze,
                    {
                      value: e.dataFormat.bottomSuffix,
                      section: "dataFormat",
                      fieldName: "bottomSuffix",
                      label: "Suffix",
                      updateField: Ce,
                      tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Enter a data suffix (such as "%"), if applicable.' }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.dataFormat.bottomAbbreviated,
                      section: "dataFormat",
                      fieldName: "bottomAbbreviated",
                      label: "Abbreviate Axis Values",
                      updateField: Ce,
                      tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "This option abbreviates very large or very small numbers on the value axis" }) })
                      ] })
                    }
                  )
                ] }),
                (Tn(e.xAxis) || (e == null ? void 0 : e.visualizationType) === "Bump Chart") && /* @__PURE__ */ F(Be, { children: [
                  /* @__PURE__ */ F("p", { style: { padding: "1.5em 0 0.5em", fontSize: ".9rem", lineHeight: "1rem" }, children: [
                    "Format how charts should parse and display your dates using",
                    " ",
                    /* @__PURE__ */ a("a", { href: "https://d3js.org/d3-time-format#locale_format", target: "_blank", rel: "noreferrer", children: "these guidelines" }),
                    "."
                  ] }),
                  /* @__PURE__ */ a(
                    ze,
                    {
                      tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ F("p", { children: [
                          "This field specifies the pattern used to read and interpret dates in your dataset, ensuring the dates are correctly understood and processed.",
                          " "
                        ] }) })
                      ] }),
                      value: e.xAxis.dateParseFormat,
                      section: "xAxis",
                      fieldName: "dateParseFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "Date Parse Format",
                      updateField: Ce
                    }
                  ),
                  /* @__PURE__ */ a(
                    ze,
                    {
                      tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ F("p", { children: [
                          " ",
                          "Adjusts the date display format on the axis for clear, visual date representation."
                        ] }) })
                      ] }),
                      value: e.xAxis.dateDisplayFormat,
                      section: "xAxis",
                      fieldName: "dateDisplayFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "AXIS DATE DISPLAY FORMAT",
                      updateField: Ce
                    }
                  ),
                  /* @__PURE__ */ a(
                    ze,
                    {
                      tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ F("p", { children: [
                          "Specify a custom format for displaying dates in data table. If left empty, dates will adopt the Axis Date Display format.",
                          " "
                        ] }) })
                      ] }),
                      value: e.table.dateDisplayFormat,
                      section: "table",
                      fieldName: "dateDisplayFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "DATA TABLE DATE DISPLAY FORMAT",
                      updateField: Ce
                    }
                  ),
                  /* @__PURE__ */ a(
                    ze,
                    {
                      tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ F("p", { children: [
                          "Specify a custom format for displaying dates on hovers. If left empty, dates will adopt the Axis Date Display format.",
                          " "
                        ] }) })
                      ] }),
                      value: e.tooltips.dateDisplayFormat,
                      section: "tooltips",
                      fieldName: "dateDisplayFormat",
                      placeholder: "Ex. %Y-%m-%d",
                      label: "HOVER DATE DISPLAY FORMAT",
                      updateField: Ce
                    }
                  )
                ] }),
                /* @__PURE__ */ a(
                  Ue,
                  {
                    value: e.exclusions.active,
                    section: "exclusions",
                    fieldName: "active",
                    label: e.xAxis.type === "date" || e.xAxis.type === "date-time" ? "Limit by start and/or end dates" : "Exclude one or more values",
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ F("p", { children: [
                        "When this option is checked, you can select source-file values for exclusion from the date/category axis.",
                        " "
                      ] }) })
                    ] }),
                    updateField: Ce
                  }
                ),
                /* @__PURE__ */ a(
                  Ue,
                  {
                    value: e.xAxis.showYearsOnce,
                    section: "xAxis",
                    fieldName: "showYearsOnce",
                    label: "Show years once",
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "When this option is checked and the date format for the axis includes years, each year will only be shown once in the axis." }) })
                    ] }),
                    updateField: Ce
                  }
                ),
                q() && /* @__PURE__ */ a(
                  Ue,
                  {
                    value: (Wn = e.brush) == null ? void 0 : Wn.active,
                    section: "brush",
                    fieldName: "active",
                    label: "Brush Slider ",
                    updateField: Ce,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ F("p", { children: [
                        "Use the brush slider to narrow down your data view to specific values along the axis. This tool is useful for examining detailed data segments within the larger dataset.",
                        " "
                      ] }) })
                    ] })
                  }
                ),
                e.exclusions.active && /* @__PURE__ */ F(Be, { children: [
                  e.xAxis.type === "categorical" && /* @__PURE__ */ F(Be, { children: [
                    e.exclusions.keys.length > 0 && /* @__PURE__ */ F(Be, { children: [
                      /* @__PURE__ */ a("fieldset", { children: /* @__PURE__ */ a("legend", { className: "edit-label", children: "Excluded Keys" }) }),
                      /* @__PURE__ */ a(Qt, {})
                    ] }),
                    /* @__PURE__ */ a(
                      ct,
                      {
                        fieldName: "visualizationType",
                        label: "Add Exclusion",
                        initial: "Select",
                        onChange: (N) => {
                          N.target.value !== "" && N.target.value !== "Select" && zt(N.target.value), N.target.value = "";
                        },
                        options: Zt(e.xAxis.dataKey, !0)
                      }
                    )
                  ] }),
                  (e.xAxis.type === "date" || e.xAxis.type === "date-time") && /* @__PURE__ */ F(Be, { children: [
                    /* @__PURE__ */ a(
                      ze,
                      {
                        type: "date",
                        section: "exclusions",
                        fieldName: "dateStart",
                        label: "Start Date",
                        updateField: Ce,
                        value: e.exclusions.dateStart || ""
                      }
                    ),
                    /* @__PURE__ */ a(
                      ze,
                      {
                        type: "date",
                        section: "exclusions",
                        fieldName: "dateEnd",
                        label: "End Date",
                        updateField: Ce,
                        value: e.exclusions.dateEnd || ""
                      }
                    )
                  ] })
                ] }),
                ke() && e.xAxis.type !== "date-time" && e.xAxis.manual && /* @__PURE__ */ F(Be, { children: [
                  /* @__PURE__ */ a(
                    ze,
                    {
                      value: e.xAxis.manualStep,
                      placeholder: "Auto",
                      type: "number",
                      min: 1,
                      section: "xAxis",
                      fieldName: "manualStep",
                      label: "Step count",
                      className: "number-narrow",
                      updateField: Ce,
                      tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Number of data points which are assigned a tick, starting from the right most data point. Value of 1 will show a tick at every data point, value of 2 will show a tick for every other, etc." }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ F("div", { className: "viewport-overrides", children: [
                    /* @__PURE__ */ a("label", { children: /* @__PURE__ */ F(
                      "button",
                      {
                        onClick: () => hn(!pt),
                        className: "edit-label",
                        children: [
                          "Step Count: viewport overrides",
                          " ",
                          /* @__PURE__ */ a("span", { style: { transform: `rotate(${pt ? "90deg" : "0deg"})` }, children: ">" })
                        ]
                      }
                    ) }),
                    pt && /* @__PURE__ */ a("div", { className: "edit-block", children: Object.keys(Hf).map((N) => /* @__PURE__ */ a(
                      ze,
                      {
                        value: e.xAxis.viewportStepCount ? e.xAxis.viewportStepCount[N] : void 0,
                        placeholder: "Auto",
                        type: "number",
                        label: N,
                        className: "number-narrow",
                        updateField: (z, Y, be, Oe) => fn("viewportStepCount", N, Oe)
                      },
                      `viewport-step-count-input-${N}`
                    )) })
                  ] })
                ] }),
                ke() && (e.xAxis.type === "date-time" || !e.xAxis.manual) && /* @__PURE__ */ F(Be, { children: [
                  /* @__PURE__ */ a(
                    ze,
                    {
                      value: e.xAxis.numTicks,
                      placeholder: "Auto",
                      type: "number",
                      min: 1,
                      section: "xAxis",
                      fieldName: "numTicks",
                      label: "Number of ticks",
                      className: "number-narrow",
                      updateField: Ce,
                      tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                          Ve,
                          {
                            display: "question",
                            style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                          }
                        ) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: 'Apporoximate number of ticks. Other factors such as space available and data may change the exact number of ticks used. To enforce an exact number of ticks, check "Manual Ticks" above.' }) })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ F("div", { className: "viewport-overrides", children: [
                    /* @__PURE__ */ a("label", { children: /* @__PURE__ */ F(
                      "button",
                      {
                        onClick: () => hn(!pt),
                        className: "edit-label",
                        children: [
                          "Number of ticks: viewport overrides",
                          " ",
                          /* @__PURE__ */ a("span", { style: { transform: `rotate(${pt ? "90deg" : "0deg"})` }, children: ">" })
                        ]
                      }
                    ) }),
                    pt && /* @__PURE__ */ a("div", { className: "edit-block", children: Object.keys(Hf).map((N) => /* @__PURE__ */ a(
                      ze,
                      {
                        value: e.xAxis.viewportNumTicks ? e.xAxis.viewportNumTicks[N] : void 0,
                        placeholder: "Auto",
                        type: "number",
                        label: N,
                        className: "number-narrow",
                        updateField: (z, Y, be, Oe) => fn("viewportNumTicks", N, Oe)
                      },
                      `viewport-num-ticks-input-${N}`
                    )) })
                  ] })
                ] }),
                ve() && /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.xAxis.size,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "size",
                    label: e.orientation === "horizontal" ? "Size (Width)" : "Size (Height)",
                    className: "number-narrow",
                    updateField: Ce
                  }
                ),
                e.orientation === "horizontal" && /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.xAxis.labelOffset,
                    section: "xAxis",
                    fieldName: "labelOffset",
                    label: "Label offset",
                    type: "number",
                    className: "number-narrow",
                    updateField: Ce
                  }
                ),
                (e.xAxis.type === "continuous" || e.forestPlot.type === "Logarithmic") && /* @__PURE__ */ F(Be, { children: [
                  /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.dataFormat.bottomCommas,
                      section: "dataFormat",
                      fieldName: "bottomCommas",
                      label: "Add commas",
                      updateField: Ce
                    }
                  ),
                  /* @__PURE__ */ a(
                    ze,
                    {
                      value: e.dataFormat.bottomRoundTo,
                      type: "number",
                      section: "dataFormat",
                      fieldName: "bottomRoundTo",
                      label: "Round to decimal point",
                      className: "number-narrow",
                      updateField: Ce,
                      min: 0
                    }
                  )
                ] }),
                Je() && e.orientation === "vertical" && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a(
                  Ue,
                  {
                    value: e.isResponsiveTicks,
                    fieldName: "isResponsiveTicks",
                    label: "Use Responsive Ticks",
                    updateField: Ce
                  }
                ),
                (e.orientation === "horizontal" || !e.isResponsiveTicks) && me() && /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.xAxis.tickRotation,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "tickRotation",
                    label: "Tick rotation (Degrees)",
                    className: "number-narrow",
                    updateField: Ce
                  }
                ),
                e.orientation === "vertical" && e.isResponsiveTicks && e.visualizationType !== "Paired Bar" && /* @__PURE__ */ a(
                  ze,
                  {
                    value: e.xAxis.maxTickRotation,
                    type: "number",
                    min: 0,
                    section: "xAxis",
                    fieldName: "maxTickRotation",
                    label: "Max Tick Rotation",
                    className: "number-narrow",
                    updateField: Ce,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Degrees ticks will be rotated if values overlap, especially in smaller viewports." }) })
                    ] })
                  }
                ),
                e.orientation === "horizontal" ? /* @__PURE__ */ F(Be, { children: [
                  de() && /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.yAxis.hideAxis,
                      section: "yAxis",
                      fieldName: "hideAxis",
                      label: "Hide Axis",
                      updateField: Ce
                    }
                  ),
                  J() && /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.yAxis.hideLabel,
                      section: "yAxis",
                      fieldName: "hideLabel",
                      label: "Hide Tick Labels",
                      updateField: Ce
                    }
                  )
                ] }) : /* @__PURE__ */ F(Be, { children: [
                  de() && /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.xAxis.hideAxis,
                      section: "xAxis",
                      fieldName: "hideAxis",
                      label: "Hide Axis",
                      updateField: Ce
                    }
                  ),
                  J() && /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.xAxis.hideLabel,
                      section: "xAxis",
                      fieldName: "hideLabel",
                      label: "Hide Tick Labels",
                      updateField: Ce
                    }
                  ),
                  ue() && /* @__PURE__ */ a(
                    Ue,
                    {
                      value: e.xAxis.hideTicks,
                      section: "xAxis",
                      fieldName: "hideTicks",
                      label: "Hide Ticks",
                      updateField: Ce
                    }
                  )
                ] }),
                ((ar = e.series) == null ? void 0 : ar.length) === 1 && e.visualizationType === "Bar" && /* @__PURE__ */ F(Be, { children: [
                  /* @__PURE__ */ a("label", { htmlFor: "barHighlight", children: "Bar Highlighting" }),
                  e.series.length === 1 && un.map((N, z) => /* @__PURE__ */ a("fieldset", { children: /* @__PURE__ */ F("div", { className: "edit-block", children: [
                    /* @__PURE__ */ a("button", { className: "btn btn-danger", onClick: (Y) => Lt(Y, z), children: "Remove" }),
                    /* @__PURE__ */ F("p", { children: [
                      "Highlighted Bar ",
                      z + 1
                    ] }),
                    /* @__PURE__ */ F("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Value" }),
                      /* @__PURE__ */ F(
                        "select",
                        {
                          value: e.highlightedBarValues[z].value,
                          onChange: (Y) => An(Y, z),
                          children: [
                            /* @__PURE__ */ a("option", { value: "", children: "- Select Value -" }),
                            jt && [...new Set(jt)].sort().map((Y) => /* @__PURE__ */ a("option", { children: Y }, `special-class-value-option-${z}-${Y}`))
                          ]
                        }
                      )
                    ] }),
                    /* @__PURE__ */ F("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.highlightedBarValues[z].color ? e.highlightedBarValues[z].color : "",
                          onChange: (Y) => bn(Y, z)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ F("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Border Width" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          max: "5",
                          min: "0",
                          type: "number",
                          value: e.highlightedBarValues[z].borderWidth ? e.highlightedBarValues[z].borderWidth : "",
                          onChange: (Y) => Ln(Y, z)
                        }
                      )
                    ] }),
                    /* @__PURE__ */ F("label", { children: [
                      /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Legend Label" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.highlightedBarValues[z].legendLabel ? e.highlightedBarValues[z].legendLabel : "",
                          onChange: (Y) => $n(Y, z)
                        }
                      )
                    ] })
                  ] }, `highlighted-bar-${z}`) })),
                  /* @__PURE__ */ a("button", { className: "btn btn-primary full-width", onClick: (N) => wt(N), children: "Add Highlighted Bar" })
                ] })
              ] }),
              e.visualizationType === "Pie" && /* @__PURE__ */ F(Be, { children: [
                /* @__PURE__ */ a(
                  Ue,
                  {
                    value: e.exclusions.active,
                    section: "exclusions",
                    fieldName: "active",
                    label: "Exclude one or more values",
                    updateField: Ce,
                    tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                      /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                        Ve,
                        {
                          display: "question",
                          style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                        }
                      ) }),
                      /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "When this option is checked, you can select values for exclusion from the pie segments." }) })
                    ] })
                  }
                ),
                e.exclusions.active && /* @__PURE__ */ F(Be, { children: [
                  e.exclusions.keys.length > 0 && /* @__PURE__ */ F(Be, { children: [
                    /* @__PURE__ */ a("fieldset", { children: /* @__PURE__ */ a("legend", { className: "edit-label", children: "Excluded Keys" }) }),
                    /* @__PURE__ */ a(Qt, {})
                  ] }),
                  /* @__PURE__ */ a(
                    ct,
                    {
                      fieldName: "visualizationType",
                      label: "Add Exclusion",
                      initial: "Select",
                      onChange: (N) => {
                        N.target.value !== "" && N.target.value !== "Select" && zt(N.target.value), N.target.value = "";
                      },
                      options: Zt(e.xAxis.dataKey, !0)
                    }
                  )
                ] })
              ] }),
              Z() && /* @__PURE__ */ a(
                ze,
                {
                  value: e.xAxis.min,
                  section: "xAxis",
                  fieldName: "min",
                  type: "number",
                  label: "min value",
                  placeholder: "Auto",
                  updateField: Ce
                }
              ),
              ae() && /* @__PURE__ */ a(
                ze,
                {
                  value: e.xAxis.max,
                  section: "xAxis",
                  fieldName: "max",
                  type: "number",
                  label: "max value",
                  placeholder: "Auto",
                  updateField: Ce
                }
              ),
              ce() && e.orientation !== "horizontal" && /* @__PURE__ */ F("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: (qn = (Xn = e.xAxis) == null ? void 0 : Xn.anchors) == null ? void 0 : qn.map((N, z) => /* @__PURE__ */ F(Nn, { className: "series-item series-item--chart", children: [
                  /* @__PURE__ */ a(Rn, { className: "series-item__title", children: /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F(Dn, { className: "accordion__button accordion__button", children: [
                    "Anchor ",
                    z + 1,
                    /* @__PURE__ */ a(
                      "button",
                      {
                        className: "series-list__remove",
                        onClick: (Y) => {
                          Y.preventDefault();
                          const be = [...e.xAxis.anchors];
                          be.splice(z, 1), t({
                            ...e,
                            xAxis: {
                              ...e.xAxis,
                              anchors: be
                            }
                          });
                        },
                        children: "Remove"
                      }
                    )
                  ] }) }) }),
                  /* @__PURE__ */ F(On, { children: [
                    /* @__PURE__ */ F("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                      /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                        /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                        /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                      ] }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.xAxis.anchors[z].value ? e.xAxis.anchors[z].value : "",
                          onChange: (Y) => {
                            Y.preventDefault();
                            const be = [...e.xAxis.anchors];
                            be[z].value = Y.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ F("label", { children: [
                      /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                      /* @__PURE__ */ a(
                        "input",
                        {
                          type: "text",
                          value: e.xAxis.anchors[z].color ? e.xAxis.anchors[z].color : "",
                          onChange: (Y) => {
                            Y.preventDefault();
                            const be = [...e.xAxis.anchors];
                            be[z].color = Y.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ F("label", { children: [
                      "Anchor Line Style",
                      /* @__PURE__ */ F(
                        "select",
                        {
                          value: e.xAxis.anchors[z].lineStyle || "",
                          onChange: (Y) => {
                            const be = [...e.xAxis.anchors];
                            be[z].lineStyle = Y.target.value, t({
                              ...e,
                              xAxis: {
                                ...e.xAxis,
                                anchors: be
                              }
                            });
                          },
                          children: [
                            /* @__PURE__ */ a("option", { children: "Select" }),
                            C.map((Y) => /* @__PURE__ */ a("option", { children: Y.value }, Y.key))
                          ]
                        }
                      )
                    ] })
                  ] })
                ] }, `xaxis-anchors-2-${z}`)) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (N) => {
                      N.preventDefault();
                      const z = [...e.xAxis.anchors];
                      z.push({}), t({
                        ...e,
                        xAxis: {
                          ...e.xAxis,
                          anchors: z
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] }),
              ce() && e.orientation === "horizontal" && /* @__PURE__ */ F("div", { className: "edit-block", children: [
                /* @__PURE__ */ a("span", { className: "edit-label column-heading", children: "Anchors" }),
                /* @__PURE__ */ a(za, { allowZeroExpanded: !0, children: (P = (v = e.yAxis) == null ? void 0 : v.anchors) == null ? void 0 : P.map((N, z) => /* @__PURE__ */ F(
                  Nn,
                  {
                    className: "series-item series-item--chart",
                    children: [
                      /* @__PURE__ */ a(Rn, { className: "series-item__title", children: /* @__PURE__ */ a(Be, { children: /* @__PURE__ */ F(Dn, { className: "accordion__button accordion__button", children: [
                        "Anchor ",
                        z + 1,
                        /* @__PURE__ */ a(
                          "button",
                          {
                            className: "series-list__remove",
                            onClick: (Y) => {
                              Y.preventDefault();
                              const be = [...e.yAxis.anchors];
                              be.splice(z, 1), t({
                                ...e,
                                yAxis: {
                                  ...e.yAxis,
                                  anchors: be
                                }
                              });
                            },
                            children: "Remove"
                          }
                        )
                      ] }) }) }),
                      /* @__PURE__ */ F(On, { children: [
                        /* @__PURE__ */ F("label", { children: [
                          /* @__PURE__ */ a("span", { children: "Anchor Value" }),
                          /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                            /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                            /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Enter the value as its shown in the data column" }) })
                          ] }),
                          /* @__PURE__ */ a(
                            "input",
                            {
                              type: "text",
                              value: e.yAxis.anchors[z].value ? e.yAxis.anchors[z].value : "",
                              onChange: (Y) => {
                                Y.preventDefault();
                                const be = [...e.yAxis.anchors];
                                be[z].value = Y.target.value, t({
                                  ...e,
                                  yAxis: {
                                    ...e.yAxis,
                                    anchors: be
                                  }
                                });
                              }
                            }
                          )
                        ] }),
                        /* @__PURE__ */ F("label", { children: [
                          /* @__PURE__ */ a("span", { children: "Anchor Color" }),
                          /* @__PURE__ */ a(
                            "input",
                            {
                              type: "text",
                              value: e.yAxis.anchors[z].color ? e.yAxis.anchors[z].color : "",
                              onChange: (Y) => {
                                Y.preventDefault();
                                const be = [...e.yAxis.anchors];
                                be[z].color = Y.target.value, t({
                                  ...e,
                                  yAxis: {
                                    ...e.yAxis,
                                    anchors: be
                                  }
                                });
                              }
                            }
                          )
                        ] }),
                        /* @__PURE__ */ F("label", { children: [
                          "Anchor Line Style",
                          /* @__PURE__ */ F(
                            "select",
                            {
                              value: e.yAxis.anchors[z].lineStyle || "",
                              onChange: (Y) => {
                                const be = [...e.yAxis.anchors];
                                be[z].lineStyle = Y.target.value, t({
                                  ...e,
                                  yAxis: {
                                    ...e.yAxis,
                                    anchors: be
                                  }
                                });
                              },
                              children: [
                                /* @__PURE__ */ a("option", { children: "Select" }),
                                C.map((Y) => /* @__PURE__ */ a("option", { children: Y.value }, Y.key))
                              ]
                            }
                          )
                        ] })
                      ] })
                    ]
                  },
                  `accordion-yaxis-anchors-${z}`
                )) }),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (N) => {
                      N.preventDefault();
                      const z = [...e.yAxis.anchors];
                      z.push({}), t({
                        ...e,
                        yAxis: {
                          ...e.yAxis,
                          anchors: z
                        }
                      });
                    },
                    children: "Add Anchor"
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ a(ki.Regions, { name: "Regions" }),
          e.visualizationType !== "Box Plot" && e.visualizationType !== "Sankey" && /* @__PURE__ */ F(Nn, { children: [
            /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ a(Dn, { children: "Columns" }) }),
            /* @__PURE__ */ F(On, { children: [
              /* @__PURE__ */ a(rT, { config: e, updateField: Ce, deleteColumn: xt }),
              " "
            ] })
          ] }),
          $() && /* @__PURE__ */ F(Nn, { children: [
            /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ a(Dn, { children: "Legend" }) }),
            /* @__PURE__ */ F(On, { children: [
              /* @__PURE__ */ a(
                ct,
                {
                  value: (_ = e.legend) == null ? void 0 : _.position,
                  section: "legend",
                  fieldName: "position",
                  label: "Position",
                  updateField: Ce,
                  options: ["right", "left", "bottom", "top"]
                }
              ),
              (e.legend.position === "left" || e.legend.position === "right" || !e.legend.position) && e.legend.style === "gradient" && /* @__PURE__ */ a("span", { style: { color: "red", fontSize: "14px" }, children: "Position must be set to top or bottom to use gradient style." }),
              /* @__PURE__ */ a(
                ct,
                {
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "If using gradient style, limit the legend to five items for better mobile visibility, and position the legend at the top or bottom." }) })
                  ] }),
                  display: !e.legend.hide,
                  value: e.legend.style,
                  section: "legend",
                  fieldName: "style",
                  label: "Legend Style",
                  updateField: Ce,
                  options: Ft("style")
                }
              ),
              /* @__PURE__ */ a(
                ct,
                {
                  value: e.legend.groupBy,
                  section: "legend",
                  fieldName: "groupBy",
                  initial: "Select",
                  label: "Legend Group By:",
                  updateField: Ce,
                  options: Ft("groupBy")
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Choose option Shapes in Line Datapoint Symbols to display." }) })
                  ] }),
                  display: !e.legend.hide && e.legend.style === "lines",
                  value: e.legend.hasShape,
                  section: "legend",
                  fieldName: "hasShape",
                  label: "Shapes",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                ct,
                {
                  display: !e.legend.hide && e.legend.style === "gradient",
                  value: e.legend.subStyle,
                  section: "legend",
                  fieldName: "subStyle",
                  label: "Gradient Style",
                  updateField: Ce,
                  options: Ft("subStyle")
                }
              ),
              /* @__PURE__ */ a(
                ze,
                {
                  display: e.legend.style === "gradient" && !e.legend.hide,
                  className: "number-narrow",
                  type: "number",
                  value: e.legend.tickRotation,
                  section: "legend",
                  fieldName: "tickRotation",
                  label: "Tick Rotation (Degrees)",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  display: (W = e.preliminaryData) == null ? void 0 : W.some((N) => N.label && N.type === "suppression" && N.value),
                  value: e.legend.hideSuppressedLabels,
                  section: "legend",
                  fieldName: "hideSuppressedLabels",
                  label: "Hide Suppressed Labels",
                  updateField: Ce,
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: `Hiding suppressed labels will not override the 'Special Class' assigned to line chart indicating "suppressed" data in the Data Series Panel.` }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  display: (he = e.preliminaryData) == null ? void 0 : he.some((N) => N.label && N.type === "suppression" && N.value),
                  value: e.legend.hideSuppressionLink,
                  section: "legend",
                  fieldName: "hideSuppressionLink",
                  label: "Hide Suppression Definition Link",
                  updateField: Ce,
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Selecting this option will hide the suppression definition link from display." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                ct,
                {
                  display: _t || Jt,
                  value: e.legend.behavior,
                  section: "legend",
                  fieldName: "behavior",
                  label: "Legend Behavior (When clicked)",
                  updateField: (...[N, , z, Y]) => _n(N, z, Y),
                  options: ["highlight", "isolate"]
                }
              ),
              /* @__PURE__ */ a(
                ct,
                {
                  display: oe(),
                  value: e.legend.colorCode,
                  section: "legend",
                  fieldName: "colorCode",
                  label: "Color code by category",
                  initial: "Select",
                  updateField: Ce,
                  options: Gt(r)
                }
              ),
              j() && /* @__PURE__ */ a(
                Ue,
                {
                  value: e.legend.axisAlign,
                  fieldName: "axisAlign",
                  section: "legend",
                  label: "Align to Axis on Isolate",
                  updateField: Ce
                }
              ),
              e.legend.behavior === "highlight" && e.tooltips.singleSeries && /* @__PURE__ */ a(
                Ue,
                {
                  value: e.legend.highlightOnHover,
                  section: "legend",
                  fieldName: "highlightOnHover",
                  label: "HIGHLIGHT DATA SERIES ON HOVER",
                  updateField: Ce
                }
              ),
              ie && e.legend.behavior === "isolate" && !En && /* @__PURE__ */ F("fieldset", { className: "primary-fieldset edit-block", children: [
                /* @__PURE__ */ a("label", { children: /* @__PURE__ */ F("span", { className: "edit-label", children: [
                  "Isolate Data Series",
                  /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(Ve, { display: "question", style: { marginLeft: "0.5rem" } }) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "You can choose data series that are shown on load. Others will be added when the user clicks on them in the legend." }) })
                  ] })
                ] }) }),
                e.legend.seriesHighlight && e.legend.seriesHighlight.map((N, z) => /* @__PURE__ */ F("fieldset", { className: "edit-block", children: [
                  /* @__PURE__ */ a(
                    "button",
                    {
                      className: "btn btn-danger",
                      onClick: (Y) => {
                        Y.preventDefault();
                        const be = [...e.legend.seriesHighlight];
                        be.splice(z, 1), Ce("legend", null, "seriesHighlight", be), be.length || B();
                      },
                      children: "Remove"
                    }
                  ),
                  /* @__PURE__ */ a(
                    ct,
                    {
                      value: e.legend.seriesHighlight[z],
                      fieldName: "seriesHighlight",
                      label: "Isolate Value",
                      onChange: (Y) => {
                        const be = [...e.legend.seriesHighlight];
                        be.includes(Y.target.value) || (be[z] = Y.target.value, Yn([...be]));
                      },
                      options: nr()
                    }
                  )
                ] }, `${N}-${z}`)),
                /* @__PURE__ */ a(
                  "button",
                  {
                    className: "btn btn-primary full-width",
                    onClick: (N) => {
                      N.preventDefault();
                      const z = nr(), Y = [...e.legend.seriesHighlight];
                      if (Y.length < z.length) {
                        const [Oe] = z.filter((We) => !Y.includes(We));
                        Y.push(Oe), Yn([...Y]);
                      }
                    },
                    children: "Add Isolate Value"
                  }
                )
              ] }, "additional-highlight-values"),
              /* @__PURE__ */ a(
                Ue,
                {
                  display: !e.legend.hide && e.legend.style !== "gradient",
                  value: e.legend.reverseLabelOrder,
                  section: "legend",
                  fieldName: "reverseLabelOrder",
                  label: "Reverse Labels",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  display: !e.legend.hide,
                  value: ["left", "right"].includes(e.legend.position) ? e.legend.hideBorder.side : e.legend.hideBorder.topBottom,
                  section: "legend",
                  subsection: "hideBorder",
                  fieldName: ["left", "right"].includes(e.legend.position) ? "side" : "topBottom",
                  label: "Hide Legend Box",
                  updateField: Ce,
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "Default option for top and bottom legends is ‘No Box.’." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  display: !e.legend.hide && !["left", "right"].includes(e.legend.position) && e.legend.style !== "gradient",
                  value: e.legend.singleRow,
                  section: "legend",
                  fieldName: "singleRow",
                  label: "Single Row Legend",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  display: ["bottom", "top"].includes(e.legend.position) && !e.legend.hide && e.legend.style !== "gradient" && !e.legend.singleRow && !e.legend.singleRow,
                  value: e.legend.verticalSorted,
                  section: "legend",
                  fieldName: "verticalSorted",
                  label: "Vertical sorted Legend",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  value: !!e.legend.hide,
                  section: "legend",
                  fieldName: "hide",
                  label: "Hide Legend",
                  updateField: Ce,
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "With a single-series chart, consider hiding the legend to reduce visual clutter." }) })
                  ] })
                }
              ),
              /* @__PURE__ */ a(
                ze,
                {
                  value: e.legend.label,
                  section: "legend",
                  fieldName: "label",
                  label: "Title",
                  updateField: Ce
                }
              ),
              /* @__PURE__ */ a(
                ze,
                {
                  type: "textarea",
                  value: e.legend.description,
                  updateField: Ce,
                  section: "legend",
                  fieldName: "description",
                  label: "Legend Description"
                }
              ),
              /* @__PURE__ */ a(
                Ue,
                {
                  value: e.legend.unified,
                  section: "legend",
                  fieldName: "unified",
                  label: "Unified Legend",
                  updateField: Ce,
                  tooltip: /* @__PURE__ */ F(ee, { style: { textTransform: "none" }, children: [
                    /* @__PURE__ */ a(ee.Target, { children: /* @__PURE__ */ a(
                      Ve,
                      {
                        display: "question",
                        style: { marginLeft: "0.5rem", display: "inline-block", whiteSpace: "nowrap" }
                      }
                    ) }),
                    /* @__PURE__ */ a(ee.Content, { children: /* @__PURE__ */ a("p", { children: "For a chart with filters, check this option if you want the legend to contain an item for every series in the data set, including those that are filtered." }) })
                  ] })
                }
              )
            ] })
          ] }),
          Ee() && /* @__PURE__ */ F(Nn, { children: [
            /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ a(Dn, { children: "Filters" }) }),
            /* @__PURE__ */ a(On, { children: /* @__PURE__ */ a(Zg, { config: e, updateField: Ce, rawData: w }) })
          ] }),
          /* @__PURE__ */ a(ki.Visual, { name: "Visual" }),
          e.visualizationType !== "Spark Line" && /* @__PURE__ */ F(Nn, { children: [
            /* @__PURE__ */ a(Rn, { children: /* @__PURE__ */ a(Dn, { children: "Data Table" }) }),
            /* @__PURE__ */ F(On, { children: [
              /* @__PURE__ */ a(
                iT,
                {
                  config: e,
                  columns: Object.keys(r[0] || {}),
                  updateField: Ce,
                  isDashboard: y,
                  isLoadedFromUrl: Ge
                }
              ),
              " "
            ] })
          ] }),
          /* @__PURE__ */ a(ki.Annotate, { name: "Text Annotations" })
        ] }),
        e.type !== "Spark Line" && /* @__PURE__ */ a(Qg, { loadConfig: t, config: e, convertStateToConfig: Pt })
      ]
    }
  ) }) });
}, Tm = (e) => {
  let t = "", n = Math.abs(e);
  return n >= 1e9 ? (t = "B", e = e / 1e9) : n >= 1e6 ? (t = "M", e = e / 1e6) : n >= 1e3 && (t = "K", e = e / 1e3), e + t;
}, cl = (e, t) => {
  var n;
  return e ? (n = e.legend) != null && n.hide ? e != null && e.title ? `dataTableSection__${e.title.replace(/\s/g, "")}` : "dataTableSection" : t : "dataTableSection";
}, RT = [
  {
    value: "Dashed Small",
    key: "dashed-sm"
  },
  {
    value: "Dashed Medium",
    key: "dashed-md"
  },
  {
    value: "Dashed Large",
    key: "dashed-lg"
  },
  {
    value: "Solid Line",
    key: "solid-line"
  }
], Cm = (e) => typeof e == "string" ? parseFloat(e.replace(/,/g, "")) : Number(e), DT = (e, t) => {
  if (t.rankByValue) {
    const n = t.series[0].dataKey, r = e.sort((i, o) => Cm(i[n]) - Cm(o[n]));
    return t.rankByValue === "asc" ? r : r.reverse();
  }
  return e;
}, Am = (e = "#000000", t = !1) => {
  let n = Qi(e), r = t ? n.brighten(0.5).hex() : n.saturate(1.3).hex();
  return [e, r, n.darken(0.3).hex()];
}, OT = (e, t) => {
  const { allowLineToBarGraph: n, series: r, visualizationType: i, xAxis: o } = e;
  if (!n)
    return !1;
  const h = i === "Line" && (t == null ? void 0 : t.length) < 3, c = (r == null ? void 0 : r.some((p) => p.dynamicCategory)) && Ke.uniq(t == null ? void 0 : t.map((p) => p[o.dataKey])).length <= 2;
  return h || c;
}, MT = (e, t) => {
  const n = t, r = Ke.uniq(Ke.map(n, e.xAxis.dataKey)), i = Ke.map(e.series, "dataKey"), o = [];
  r.forEach((d) => {
    i.forEach((c) => {
      try {
        if (!d)
          throw new Error("No groups resolved in box plots");
        const { count: p, sortedData: y } = Ke.chain(n).filter((S) => S[e.xAxis.dataKey] === d).thru((S) => ({
          count: S.length,
          sortedData: Ke.map(S, (B) => Number(B[c])).sort()
        })).value();
        if (!y)
          throw new Error("boxplots dont have data yet");
        if (!o)
          throw new Error("boxplots dont have plots yet");
        const g = kl(y, 0.25), b = kl(y, 0.75), T = b - g, m = g - 1.5 * T, C = b + 1.5 * T, w = y.filter((S) => S >= m && S <= C);
        o.push({
          columnCategory: d,
          columnMax: Em(w),
          columnThirdQuartile: Ke.round(b, e.dataFormat.roundTo),
          columnMedian: Number(Gm(y)).toFixed(e.dataFormat.roundTo),
          columnFirstQuartile: Ke.round(g, e.dataFormat.roundTo),
          columnMin: Ke.min(w),
          columnCount: p,
          columnSd: Number(Av(y)).toFixed(e.dataFormat.roundTo),
          columnMean: Number(Pv(y)).toFixed(e.dataFormat.roundTo),
          columnIqr: Ke.round(T, e.dataFormat.roundTo),
          values: y,
          columnLowerBounds: m,
          columnUpperBounds: C,
          columnOutliers: Ke.filter(y, (S) => S < m || S > C),
          columnNonOutliers: Ke.filter(y, (S) => S >= m && S <= C)
        });
      } catch (p) {
        console.error("COVE: ", p.message);
      }
    });
  });
  const h = i.length > 1 ? Ke.flatMap(r, (d) => Ke.map(i, (c) => `${Ke.capitalize(c)} - ${Ke.capitalize(d)}`)) : r;
  return [o, h];
}, IT = (e) => {
  if (e.visualizationType !== "Combo" || !e.series)
    return;
  const t = {
    barSeriesKeys: [],
    lineSeriesKeys: [],
    areaSeriesKeys: [],
    forecastingSeriesKeys: []
  }, n = /* @__PURE__ */ new Map([
    ["Area Chart", "areaSeriesKeys"],
    ["Forecasting", "forecastingSeriesKeys"],
    ["Bar", "barSeriesKeys"],
    ["Combo", "barSeriesKeys"],
    ["Line", "lineSeriesKeys"],
    ["dashed-sm", "lineSeriesKeys"],
    ["dashed-md", "lineSeriesKeys"],
    ["dashed-lg", "lineSeriesKeys"]
  ]);
  return e.series.forEach((r) => {
    const i = n.get(r.type);
    if (i) {
      const o = i === "barSeriesKeys" || i === "lineSeriesKeys" ? r.dataKey : r;
      t[i].push(o);
    }
    r.type === "Combo" && (r.type = "Bar");
  }), { ...e.runtime, ...t };
}, FT = (e, t) => {
  var r;
  let n = t;
  if (e.exclusions && e.exclusions.active)
    if (e.xAxis.type === "categorical" && ((r = e.exclusions.keys) == null ? void 0 : r.length) > 0)
      n = t.filter((i) => !e.exclusions.keys.includes(i[e.xAxis.dataKey]));
    else if (Tn(e.xAxis) && (e.exclusions.dateStart || e.exclusions.dateEnd) && e.xAxis.dateParseFormat) {
      const i = (p) => new Date(p).getTime();
      let o = i(e.exclusions.dateStart), h = i(e.exclusions.dateEnd) + 86399999, d = typeof o !== void 0 && isNaN(o) === !1, c = typeof h !== void 0 && isNaN(h) === !1;
      d && c ? n = t.filter(
        (p) => i(p[e.xAxis.dataKey]) >= o && i(p[e.xAxis.dataKey]) <= h
      ) : d ? n = t.filter((p) => i(p[e.xAxis.dataKey]) >= o) : c && (n = t.filter((p) => i(p[e.xAxis.dataKey]) <= h));
    } else
      n = t;
  return n;
}, BT = (e) => {
  const t = ["Paired Bar", "Deviation Bar"].includes(e.visualizationType) ? e.twoColor.palette : e.palette, n = { ..._r, ...Mc };
  let r = e.customColors || n[t], i = e.runtime.seriesKeys.length;
  for (; i > r.length; )
    r = r.concat(r);
  return r = r.slice(0, i), Df({
    domain: e.runtime.seriesLabelsAll,
    range: r,
    unknown: null
  });
};
const zT = (e) => {
  var t, n, r;
  return {
    isLoading: !0,
    config: rc,
    stateData: Ke.cloneDeep(e == null ? void 0 : e.data) || [],
    colorScale: null,
    excludedData: void 0,
    filteredData: void 0,
    seriesHighlight: e && ((n = (t = e == null ? void 0 : e.legend) == null ? void 0 : t.seriesHighlight) != null && n.length) ? [...(r = e == null ? void 0 : e.legend) == null ? void 0 : r.seriesHighlight] : [],
    currentViewport: "lg",
    dimensions: [0, 0],
    container: null,
    coveLoadedEventRan: !1,
    isDraggingAnnotation: !1,
    imageId: `cove-${Math.random().toString(16).slice(-4)}`,
    brushConfig: {
      data: [],
      isActive: !1,
      isBrushing: !1
    }
  };
}, $T = (e, t) => {
  switch (t.type) {
    case "SET_LOADING":
      return { ...e, isLoading: t.payload };
    case "SET_CONFIG":
      return { ...e, config: t.payload };
    case "UPDATE_CONFIG":
      return { ...e, config: t.payload };
    case "SET_COLOR_SCALE":
      return { ...e, colorScale: t.payload };
    case "SET_STATE_DATA":
      return { ...e, stateData: t.payload };
    case "SET_EXCLUDED_DATA":
      return { ...e, excludedData: t.payload };
    case "SET_FILTERED_DATA":
      return { ...e, filteredData: t.payload };
    case "SET_SERIES_HIGHLIGHT":
      return { ...e, seriesHighlight: t.payload };
    case "SET_VIEWPORT":
      return { ...e, currentViewport: t.payload };
    case "SET_DIMENSIONS":
      return { ...e, dimensions: t.payload };
    case "SET_CONTAINER":
      return { ...e, container: t.payload };
    case "SET_LOADED_EVENT":
      return { ...e, coveLoadedEventRan: t.payload };
    case "SET_DRAG_ANNOTATIONS":
      return { ...e, isDraggingAnnotation: t.payload };
    case "SET_BRUSH_CONFIG":
      return { ...e, brushConfig: t.payload };
  }
}, HT = ({
  config: e,
  isEditor: t = !1,
  isDebug: n = !1,
  isDashboard: r = !1,
  setConfig: i,
  setEditing: o,
  link: h,
  setSharedFilter: d,
  setSharedFilterValue: c,
  dashboardConfig: p
}) => {
  var Gt, Zt, gn, Pt, Qt, Rt, bt, lt;
  const y = new Km(), g = zT(e), [b, T] = fe.useReducer($T, g), {
    config: m,
    stateData: C,
    excludedData: w,
    filteredData: S,
    currentViewport: B,
    isLoading: M,
    dimensions: D,
    container: O,
    coveLoadedEventRan: L,
    imageId: U,
    seriesHighlight: X,
    colorScale: ne,
    brushConfig: G
  } = b, { description: ce, visualizationType: q } = m, re = fe.useRef(null), $ = fe.useContext(kv), [j, oe] = fe.useState(), ie = (Se) => {
    T({ type: "SET_CONFIG", payload: Se }), t && !r && $.setTempConfig(Se);
  }, le = (Se) => {
    T({ type: "SET_FILTERED_DATA", payload: Se });
  }, J = fe.useRef(null), de = fe.useRef(null), ae = (Se) => {
    T({ type: "SET_DRAG_ANNOTATIONS", payload: Se });
  };
  let { legend: Z, title: ye } = m;
  t && (!ye || ye === "") && (ye = "Chart Title"), m.table && (!((Gt = m.table) != null && Gt.label) || ((Zt = m.table) == null ? void 0 : Zt.label) === "") && (m.table.label = "Data Table");
  const { lineDatapointClass: ue, contentClasses: ve, sparkLineStyles: ke } = ev(m), me = fe.useId(), Ee = (m.xAxis || m.yAxis) && ["date-time", "date"].includes((m.xAxis || m.yAxis).type) && m.xAxis.dataKey, De = OT(m, S), Xe = async (Se) => {
    let _e = Ke.defaultsDeep(Se, rc);
    return Ke.defaultsDeep(_e, {
      table: { showVertical: !1 }
    }), Ke.set(_e, "table.show", Ke.get(_e, "table.show", !r)), Ke.forEach(_e.series, (xe) => {
      Ke.defaults(xe, {
        tooltip: !0,
        axis: "Left"
      });
    }), _e.visualizationType === "Bump Chart" && _e.xAxis.type, r ? _e : wv(_e);
  }, Fe = (Se, _e) => {
    var Nt, Wt;
    const xe = Ke.cloneDeep(Se);
    let Ge = _e || C;
    Ge = DT(Ge, xe), Object.keys(rc).forEach((xt) => {
      xe[xt] && typeof xe[xt] == "object" && !Array.isArray(xe[xt]) && (xe[xt] = { ...rc[xt], ...xe[xt] });
    });
    const Ze = FT(xe, _e || C);
    T({ type: "SET_EXCLUDED_DATA", payload: Ze });
    let et = [];
    if (xe.filters) {
      const xt = Sv(xe.filters, Ze);
      et = Uo(xt, Ze), T({ type: "SET_FILTERED_DATA", payload: et });
    }
    if (xe.xAxis.type === "date-time" && m.orientation === "horizontal" && (xe.xAxis.type = "date"), xe.runtime = {}, xe.runtime.series = Ke.cloneDeep(xe.series), xe.runtime.seriesLabels = {}, xe.runtime.seriesLabelsAll = [], xe.runtime.originalXAxis = xe.xAxis, xe.visualizationType === "Pie")
      xe.runtime.seriesKeys = (_e || Ge).map((xt) => xt[xe.xAxis.dataKey]), xe.runtime.seriesLabelsAll = xe.runtime.seriesKeys;
    else {
      const xt = _e || xe.formattedData || xe.data;
      xe.runtime.seriesKeys = (xe.runtime.series || []).flatMap((at) => {
        if (at.dynamicCategory) {
          Ke.remove(xe.runtime.seriesLabelsAll, (jt) => jt === at.dataKey), Ke.remove(xe.runtime.series, (jt) => jt.dataKey === at.dataKey);
          const un = Ke.uniq(xt.map((jt) => jt[at.dynamicCategory]));
          return un.forEach((jt) => {
            xe.runtime.seriesLabels[jt] = jt, xe.runtime.seriesLabelsAll.push(jt), xe.runtime.series.push({
              dataKey: jt,
              type: at.type,
              lineType: at.lineType,
              originalDataKey: at.dataKey,
              dynamicCategory: at.dynamicCategory,
              tooltip: !0
            });
          }), un;
        } else
          return xe.runtime.seriesLabels[at.dataKey] = at.name || at.label || at.dataKey, xe.runtime.seriesLabelsAll.push(at.name || at.dataKey), [at.dataKey];
      });
    }
    if (xe.visualizationType === "Box Plot" && xe.series) {
      const [xt, at] = MT(xe, C);
      xe.boxplot.categories = at, xe.boxplot.plots = xt;
    }
    xe.visualizationType === "Combo" && xe.series && (xe.runtime = IT(xe)), xe.visualizationType === "Forecasting" && xe.series && (xe.runtime.forecastingSeriesKeys = [], xe.series.forEach((xt) => {
      xt.type === "Forecasting" && xe.runtime.forecastingSeriesKeys.push(xt);
    })), xe.visualizationType === "Area Chart" && xe.series && (xe.runtime.areaSeriesKeys = [], xe.series.forEach((xt) => {
      xe.runtime.areaSeriesKeys.push({ ...xt, type: "Area Chart" });
    }), xe.visualizationSubType = "stacked"), xe.visualizationType === "Bar" && xe.orientation === "horizontal" || ["Deviation Bar", "Paired Bar", "Forest Plot"].includes(xe.visualizationType) ? (xe.runtime.xAxis = xe.yAxis.yAxis ? xe.yAxis.yAxis : xe.yAxis, xe.runtime.yAxis = xe.xAxis.xAxis ? xe.xAxis.xAxis : xe.xAxis, xe.runtime.horizontal = !1, xe.orientation = "horizontal", xe.yAxis.type = xe.yAxis.type === "categorical" ? "linear" : xe.yAxis.type) : ["Box Plot", "Scatter Plot", "Area Chart", "Line", "Forecasting"].includes(xe.visualizationType) && !De ? (xe.runtime.xAxis = xe.xAxis, xe.runtime.yAxis = xe.yAxis, xe.runtime.horizontal = !1, xe.orientation = "vertical") : (xe.runtime.xAxis = xe.xAxis, xe.runtime.yAxis = xe.yAxis, xe.runtime.horizontal = !1), xe.runtime.uniqueId = Date.now(), xe.runtime.editorErrorMessage = xe.visualizationType === "Pie" && !xe.yAxis.dataKey ? "Data Key property in Y Axis section must be set for pie charts." : "", xe.runtime.editorErrorMessage = "", (Nt = xe.legend.seriesHighlight) != null && Nt.length && T({ type: "SET_SERIES_HIGHLIGHT", payload: (Wt = xe.legend) == null ? void 0 : Wt.seriesHighlight }), ie(xe);
  }, Je = (Se, _e) => {
    let xe = m.visualizationType === "Bar" && m.visualizationSubType === "horizontal" ? m.xAxis.dataKey : m.yAxis.sortKey, Ge = parseFloat(Se[xe]), Ze = parseFloat(_e[xe]);
    return Ge < Ze ? m.sortData === "ascending" ? 1 : -1 : Ge > Ze ? m.sortData === "ascending" ? -1 : 1 : 0;
  }, gt = new Pg((Se) => {
    for (let _e of Se) {
      let { width: xe, height: Ge } = _e.contentRect;
      xe = t ? xe - Rm : xe;
      const Ze = Ng(xe);
      T({ type: "SET_VIEWPORT", payload: Ze }), _e.target.dataset.lollipop === "true" && (xe = xe - 2.5), xe = xe, T({ type: "SET_DIMENSIONS", payload: [xe, Ge] });
    }
  }), mt = fe.useCallback((Se) => {
    Se !== null && gt.observe(Se), T({ type: "SET_CONTAINER", payload: Se });
  }, []), yt = async (Se) => {
    try {
      const _e = Se.filters ? Se.filters.filter((xe) => xe.type === "url").length > 0 : !1;
      if (Se.dataUrl && !_e) {
        Se.dataUrl && (Se.dataUrl = `${Se.dataUrl}`);
        let xe = await Jg(Se.dataUrl, "Chart");
        xe && Se.dataDescription && (xe = y.autoStandardize(xe), xe = y.developerStandardize(xe, Se.dataDescription)), xe && (Se.data = xe);
      } else
        Se.formattedData ? Se.data = Se.formattedData : Se.dataDescription && (Se.data = y.autoStandardize(Se.data), Se.data = y.developerStandardize(Se.data, Se.dataDescription));
    } catch (_e) {
      console.error("Error on prepareData function ", _e);
    }
    return Se;
  };
  fe.useEffect(() => {
    (async () => {
      try {
        if (e) {
          const _e = await Xe(e), xe = await yt(_e);
          T({ type: "SET_STATE_DATA", payload: xe.data }), T({ type: "SET_EXCLUDED_DATA", payload: xe.data }), Fe(_e, xe.data);
        }
      } catch {
        console.error("Could not Load!");
      }
    })();
  }, [(gn = e == null ? void 0 : e.data) != null && gn.length ? e.data : null]), fe.useEffect(() => {
    O && !M && !Ke.isEmpty(m) && !L && (tv("cove_loaded", { config: m }), T({ type: "SET_LOADED_EVENT", payload: !0 }));
  }, [O, m, M]), fe.useEffect(() => {
    const Se = (_e) => {
      let xe = [];
      xe.push(_e.detail), oe(xe);
    };
    return nv("cove_filterData", (_e) => Se(_e)), () => {
      rv("cove_filterData", Se);
    };
  }, [m]), fe.useEffect(() => {
    if (j && j[0] && !j[0].hasOwnProperty("active")) {
      let _e = { ...m };
      delete _e.filters, ie(_e), T({ type: "SET_FILTERED_DATA", payload: Uo(j, w) });
    }
    if (j && j.length > 0 && j.length > 0 && j[0].hasOwnProperty("active")) {
      let Se = { ...m, filters: j };
      ie(Se), T({ type: "SET_FILTERED_DATA", payload: Uo(j, w) });
    }
  }, [j]), fe.useEffect(() => {
    var Se;
    if (C && m.xAxis && ((Se = m.runtime) != null && Se.seriesKeys)) {
      const _e = BT(m);
      T({ type: "SET_COLOR_SCALE", payload: _e }), T({ type: "SET_LOADING", payload: !1 });
    }
    m && C && m.sortData && C.sort(Je);
  }, [m, C]);
  const Ye = (Se) => {
    if (X.length + 1 === m.runtime.seriesKeys.length && m.visualizationType !== "Forecasting")
      return ot();
    const _e = Ke.findKey(m.runtime.seriesLabels, (Ge) => Ge === Se.datum) || Se.datum, xe = Ke.xor(X, [_e]);
    T({ type: "SET_SERIES_HIGHLIGHT", payload: xe });
  }, ot = () => {
    try {
      const Se = J.current;
      if (!Se)
        throw new Gd("No legend available to set previous focus on.");
      Se.focus();
    } catch (Se) {
      console.error("COVE:", Se.message);
    }
    T({ type: "SET_SERIES_HIGHLIGHT", payload: [] });
  }, ut = m.orientation === "horizontal" ? "yAxis" : "xAxis", st = (Se, _e = !0) => {
    let xe = av(m.runtime[ut].dateParseFormat)(Se);
    return xe || (_e && (m.runtime.editorErrorMessage = `Error parsing date "${Se}". Try reviewing your data and date parse settings in the X Axis section.`), /* @__PURE__ */ new Date());
  }, tt = (Se, _e, xe) => {
    var Ze, et;
    let Ge = qu(m.runtime[ut].dateDisplayFormat)(Se);
    if ((Ze = m.runtime[ut].dateDisplayFormat) != null && Ze.includes("%b.") && Ge.includes("May.") && (Ge = Ge.replace(/May\./g, "May")), m.xAxis.showYearsOnce && ((et = m.runtime[ut].dateDisplayFormat) != null && et.includes("%Y")) && xe) {
      const Nt = xe[_e - 1] ? xe[_e - 1].value : null, Wt = qu(m.runtime[ut].dateDisplayFormat)(Nt), xt = Ge.match(/\d{4}/), at = Wt.match(/\d{4}/);
      xt && at && xt[0] === at[0] && (Ge = Ge.replace(xt, ""));
    }
    return Ge;
  }, $e = (Se) => qu(m.tooltips.dateDisplayFormat)(Se), it = (Se, _e, xe = !1, Ge, Ze, et, { index: Nt, length: Wt } = { index: null, length: null }) => {
    if (Se === "")
      return "N/A";
    if (isNaN(Se) || !Se)
      return Se;
    const xt = Se < 0;
    (_e === void 0 || !_e) && (_e = "left"), xt && (Se = Math.abs(Se));
    let {
      dataFormat: {
        commas: at,
        abbreviated: un,
        roundTo: jt,
        prefix: An,
        suffix: wt,
        rightRoundTo: Lt,
        bottomRoundTo: bn,
        rightPrefix: $n,
        rightSuffix: Ln,
        bottomPrefix: En,
        bottomSuffix: nr,
        bottomAbbreviated: Yn,
        onlyShowTopPrefixSuffix: _n
      }
    } = m;
    String(Se).indexOf(",") !== -1 && (Se = Se.replaceAll(",", ""));
    let fn = Se, _t = {
      useGrouping: !!at
      // for old chart data table to work right cant just leave this to undefined
    };
    if (_e === "left" || _e === void 0) {
      let on;
      et !== void 0 ? on = et ? Number(et) : 0 : on = jt ? Number(jt) : 0, _t = {
        useGrouping: et ? !0 : !!m.dataFormat.commas,
        minimumFractionDigits: on,
        maximumFractionDigits: on
      };
    }
    _e === "right" && (_t = {
      useGrouping: !!m.dataFormat.rightCommas,
      minimumFractionDigits: Lt ? Number(Lt) : 0,
      maximumFractionDigits: Lt ? Number(Lt) : 0
    });
    const Jt = () => m.forestPlot.type === "Logarithmic" && !bn ? 2 : Number(bn) ? Number(bn) : 0;
    if (_e === "bottom" && (_t = {
      useGrouping: !!m.dataFormat.bottomCommas,
      minimumFractionDigits: Jt(),
      maximumFractionDigits: Jt()
    }), Se = rp(Se), isNaN(Se))
      return m.runtime.editorErrorMessage = `Unable to parse number from data ${fn}. Try reviewing your data and selections in the Data Series section.`, fn;
    if (!m.dataFormat)
      return Se;
    if (m.dataCutoff) {
      let on = rp(m.dataCutoff);
      Se < on && (Se = on);
    }
    _e === "left" && at && un && xe || _e === "bottom" && at && un && xe ? Se = Se : Se = Se.toLocaleString("en-US", _t);
    let Yt = "";
    if (un && _e === "left" && xe && (Se = Tm(parseFloat(Se))), Yn && _e === "bottom" && xe && (Se = Tm(parseFloat(Se))), Ge && _e === "left")
      Yt = Ge + Yt;
    else {
      const on = _n && Wt - 1 !== Nt;
      An && _e === "left" && !on && (Yt += An);
    }
    return $n && _e === "right" && (Yt += $n), En && _e === "bottom" && (Yt += En), Yt += Se, Ze && _e === "left" ? Yt += Ze : wt && _e === "left" && !_n && (Yt += wt), Ln && _e === "right" && (Yt += Ln), nr && _e === "bottom" && (Yt += nr), xt && (Yt = "-" + Yt), String(Yt);
  }, ht = (Se) => {
    try {
      if (!Se)
        throw new Gd("COVE: No rowObj in applyLegendToRow");
      if (m.type === "navigation") {
        let _e = _r[m.color] || _r.bluegreenreverse;
        return Am(_e[3]);
      }
      return Am();
    } catch (_e) {
      console.error("COVE: ", _e);
    }
  }, Ce = (Se) => {
    var et;
    if (!Array.isArray(Se))
      return [];
    if (m.visualizationType === "Forecasting")
      return Se;
    const _e = Object.values(Ke.get(m, "confidenceKeys", {})), Ge = [...Ke.get(m, "series", []).map((Nt) => Nt.dataKey) ?? [], ..._e ?? []], Ze = m.xAxis.dataKey;
    return (et = m == null ? void 0 : m.xAxis) != null && et.dataKey ? y.cleanData(Se, Ze, Ge) : Se;
  }, Ht = () => {
    var Ge, Ze, et;
    if (q === "Sankey")
      return (Ze = (Ge = m == null ? void 0 : m.data) == null ? void 0 : Ge[0]) == null ? void 0 : Ze.tableData;
    const Se = S || w, _e = m.series.find((Nt) => !!Nt.dynamicCategory);
    if (!_e)
      return Se;
    const xe = Object.values(m.columns).filter((Nt) => Nt.dataTable).map((Nt) => Nt.name).concat([_e.dynamicCategory, _e.dataKey]);
    return (et = m.xAxis) != null && et.dataKey && xe.push(m.xAxis.dataKey), Se.map((Nt) => Ke.pick(Nt, xe));
  }, vn = (Se) => {
    const _e = Ke.cloneDeep(Se), xe = _e.series.find((Ge) => !!Ge.dynamicCategory);
    if (xe) {
      const Ge = { columnName: xe.dynamicCategory, valueColumns: [xe.dataKey] };
      _e.table.pivot = Ge;
    }
    return _e;
  };
  let pt = /* @__PURE__ */ a(sv, {});
  const hn = (Se) => {
    if (Ke.isString(Se))
      return Ke.kebabCase(Se);
  }, yn = () => {
    var xe;
    const Se = (Z == null ? void 0 : Z.position) === "bottom" || Yi(B), _e = ["chart-container", "p-relative"];
    return Z != null && Z.position && (Yi(B) && (Z == null ? void 0 : Z.position) !== "top" ? _e.push("legend-bottom") : _e.push(`legend-${Z.position}`)), Z != null && Z.hide && _e.push("legend-hidden"), ue && _e.push(ue), m.barHasBorder || _e.push("chart-bar--no-border"), (xe = m.brush) != null && xe.active && (p == null ? void 0 : p.type) === "dashboard" && (!Se || Z.hide) && _e.push("dashboard-brush"), _e.push(...ve), _e;
  }, Vt = () => {
    var xe, Ge;
    const Se = ["subtext mt-4"], _e = (Z == null ? void 0 : Z.position) === "bottom" || Yi(B);
    return m.isResponsiveTicks && Se.push("subtext--responsive-ticks "), (xe = m.brush) != null && xe.active && !_e && Se.push("subtext--brush-active "), (Ge = m.brush) != null && Ge.active && m.legend.hide && Se.push("subtext--brush-active "), Se;
  };
  if (!M) {
    const Se = /* @__PURE__ */ F("a", { href: `#data-table-${m.dataKey}`, className: "margin-left-href", children: [
      m.dataKey,
      " (Go to Table)"
    ] });
    pt = /* @__PURE__ */ F(Be, { children: [
      t && /* @__PURE__ */ a(NT, {}),
      /* @__PURE__ */ F(mh.Responsive, { isEditor: t, children: [
        m.newViz && /* @__PURE__ */ a(Tv, { updateConfig: Fe, config: m }),
        m.newViz === void 0 && t && m.runtime && ((Pt = m.runtime) == null ? void 0 : Pt.editorErrorMessage) && /* @__PURE__ */ a(Gd, { errorMessage: m.runtime.editorErrorMessage }),
        !vh(m) && !m.newViz && /* @__PURE__ */ F(
          "div",
          {
            className: `cdc-chart-inner-container cove-component__content type-${hn(
              m.visualizationType
            )}`,
            "aria-label": jh(m),
            tabIndex: 0,
            children: [
              /* @__PURE__ */ a(
                ov,
                {
                  showTitle: m.showTitle,
                  isDashboard: r,
                  title: ye,
                  superTitle: m.superTitle,
                  classes: ["chart-title", `${m.theme}`, "cove-component__header", "mb-3"],
                  style: void 0
                }
              ),
              /* @__PURE__ */ F("div", { className: yn().join(" "), children: [
                (m == null ? void 0 : m.introText) && m.visualizationType !== "Spark Line" && /* @__PURE__ */ a("section", { className: "introText mb-4", children: Gi(m.introText) }),
                m.filters && !j && m.visualizationType !== "Spark Line" && /* @__PURE__ */ a(
                  op,
                  {
                    config: m,
                    setConfig: ie,
                    setFilteredData: le,
                    filteredData: S,
                    excludedData: w,
                    filterData: Uo,
                    dimensions: D
                  }
                ),
                /* @__PURE__ */ a(Qf, { skipId: cl(m, me), skipMessage: "Skip Over Chart Container" }),
                ((Qt = m.annotations) == null ? void 0 : Qt.length) > 0 && /* @__PURE__ */ a(
                  Qf,
                  {
                    skipId: cl(m, me),
                    skipMessage: "Skip over annotations"
                  },
                  "skip-annotations"
                ),
                /* @__PURE__ */ F(Mv, { children: [
                  /* @__PURE__ */ F(
                    "div",
                    {
                      className: Z.hide || Yi(B) || Z.position === "bottom" || Z.position === "top" || q === "Sankey" || q === "Spark Line" ? "w-100" : "w-75",
                      children: [
                        !["Spark Line", "Line", "Sankey", "Pie", "Sankey"].includes(m.visualizationType) && /* @__PURE__ */ a("div", { ref: de, style: { width: "100%" }, children: /* @__PURE__ */ a(Ko, { children: (_e) => /* @__PURE__ */ a(fh, { ref: re, parentWidth: _e.width, parentHeight: _e.height }) }) }),
                        m.visualizationType === "Pie" && /* @__PURE__ */ a(Ko, { className: "justify-content-center d-flex", style: { width: "100%" }, children: (_e) => /* @__PURE__ */ a(_S, { ref: re, parentWidth: _e.width, parentHeight: _e.height }) }),
                        m.visualizationType === "Line" && (De ? /* @__PURE__ */ a("div", { ref: de, style: { width: "100%" }, children: /* @__PURE__ */ a(Ko, { children: (_e) => /* @__PURE__ */ a(fh, { ref: re, parentWidth: _e.width, parentHeight: _e.height }) }) }) : /* @__PURE__ */ a("div", { ref: de, style: { width: "100%" }, children: /* @__PURE__ */ a(Ko, { children: (_e) => {
                          const Ge = m.showLineSeriesLabels && (m.legend.position !== "right" || m.legend.hide) ? 120 : 0;
                          return /* @__PURE__ */ a(
                            fh,
                            {
                              ref: re,
                              parentWidth: _e.width - Ge,
                              parentHeight: _e.height
                            }
                          );
                        } }) })),
                        m.visualizationType === "Spark Line" && /* @__PURE__ */ F(Be, { children: [
                          /* @__PURE__ */ a(
                            op,
                            {
                              config: m,
                              setConfig: ie,
                              setFilteredData: le,
                              filteredData: S,
                              excludedData: w,
                              filterData: Uo,
                              dimensions: D
                            }
                          ),
                          (m == null ? void 0 : m.introText) && /* @__PURE__ */ a("section", { className: "introText mb-4", style: { padding: "0px 0 35px" }, children: Gi(m.introText) }),
                          /* @__PURE__ */ a("div", { style: { height: "100px", width: "100%", ...ke }, children: /* @__PURE__ */ a(Ko, { children: (_e) => /* @__PURE__ */ a(Nk, { width: _e.width, height: _e.height }) }) }),
                          ce && /* @__PURE__ */ a("div", { className: "subtext", style: { padding: "35px 0 15px" }, children: Gi(ce) })
                        ] }),
                        m.visualizationType === "Sankey" && /* @__PURE__ */ a(Ko, { "aria-hidden": "true", children: (_e) => /* @__PURE__ */ a(KS, { runtime: m.runtime, width: _e.width, height: _e.height }) })
                      ]
                    }
                  ),
                  !m.legend.hide && m.visualizationType !== "Spark Line" && m.visualizationType !== "Sankey" && /* @__PURE__ */ a(tT, { ref: J, skipId: cl(m, me) })
                ] }),
                r && m.table && m.table.show && m.table.showDataTableLink ? Se : h && h,
                m.description && m.visualizationType !== "Spark Line" && /* @__PURE__ */ a("div", { className: Vt().join(" "), children: Gi(m.description) }),
                /* @__PURE__ */ F(Ud.Section, { classes: ["download-buttons"], children: [
                  m.table.showDownloadImgButton && /* @__PURE__ */ a(
                    Ud.Button,
                    {
                      text: "Download Image",
                      title: "Download Chart as Image",
                      type: "image",
                      state: m,
                      elementToCapture: U
                    }
                  ),
                  m.table.showDownloadPdfButton && /* @__PURE__ */ a(
                    Ud.Button,
                    {
                      text: "Download PDF",
                      title: "Download Chart as PDF",
                      type: "pdf",
                      state: m,
                      elementToCapture: U
                    }
                  )
                ] }),
                (m.xAxis.dataKey && m.table.show && m.visualizationType !== "Spark Line" && m.visualizationType !== "Sankey" || m.visualizationType === "Sankey" && m.table.show) && /* @__PURE__ */ a(
                  iv,
                  {
                    config: vn(m),
                    rawData: m.visualizationType === "Sankey" ? (bt = (Rt = m == null ? void 0 : m.data) == null ? void 0 : Rt[0]) == null ? void 0 : bt.tableData : m.table.customTableConfig ? Uo(m.filters, m.data) : m.data,
                    runtimeData: Ht(),
                    expandDataTable: m.table.expanded,
                    columns: m.columns,
                    defaultSortBy: Ee,
                    displayGeoName: (_e) => _e,
                    applyLegendToRow: ht,
                    tableTitle: m.table.label,
                    indexTitle: m.table.indexLabel,
                    vizTitle: ye,
                    viewport: B,
                    tabbingId: cl(m, me),
                    colorScale: ne
                  },
                  Ee
                ),
                ((lt = m == null ? void 0 : m.annotations) == null ? void 0 : lt.length) > 0 && /* @__PURE__ */ a(Ff.Dropdown, {}),
                (m == null ? void 0 : m.footnotes) && /* @__PURE__ */ a("section", { className: "footnotes pt-2 mt-4", children: Gi(m.footnotes) })
              ] })
            ]
          }
        )
      ] })
    ] });
  }
  const Ft = {
    ...b,
    brushConfig: G,
    capitalize: (Se) => Se.charAt(0).toUpperCase() + Se.slice(1),
    convertLineToBarGraph: De,
    clean: Ce,
    colorPalettes: _r,
    dashboardConfig: p,
    debugSvg: n,
    formatDate: tt,
    formatNumber: it,
    formatTooltipsDate: $e,
    getXAxisData: (Se) => Tn(m.runtime.xAxis) ? st(Se[m.runtime.originalXAxis.dataKey]).getTime() : Se[m.runtime.originalXAxis.dataKey],
    getYAxisData: (Se, _e) => Se[_e],
    handleChartAriaLabels: jh,
    handleLineType: Ag,
    handleChartTabbing: cl,
    highlight: Ye,
    handleShowAll: ot,
    isDashboard: r,
    isDebug: n,
    handleDragStateChange: ae,
    isEditor: t,
    isNumber: Wa,
    legend: Z,
    legendId: me,
    legendRef: J,
    lineOptions: RT,
    missingRequiredSections: vh,
    outerContainerRef: mt,
    parentRef: de,
    parseDate: st,
    rawData: Ke.cloneDeep(C) ?? {},
    setConfig: ie,
    setEditing: o,
    setParentConfig: i,
    setSharedFilter: d,
    setSharedFilterValue: c,
    svgRef: re,
    tableData: S || w,
    transformedData: Ce(S || w),
    twoColorPalette: Mc,
    unfilteredData: Ke.cloneDeep(C),
    updateConfig: Fe
  };
  return /* @__PURE__ */ a(ft.Provider, { value: Ft, children: /* @__PURE__ */ a(ef.Provider, { value: T, children: /* @__PURE__ */ a(
    mh.VisualizationWrapper,
    {
      config: m,
      isEditor: t,
      currentViewport: B,
      ref: mt,
      imageId: U,
      showEditorPanel: m == null ? void 0 : m.showEditorPanel,
      children: pt
    }
  ) }) });
}, SC = HT;
export {
  SC as C,
  iT as D,
  rT as a
};
